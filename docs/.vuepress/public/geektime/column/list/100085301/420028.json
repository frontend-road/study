{"id":420028,"title":"13｜类型系统：如何使用trait来定义接口？","content":"<p>你好，我是陈天。</p><p>通过上一讲的学习，我们对 Rust 类型系统的本质有了认识。作为对类型进行定义、检查和处理的工具，类型系统保证了某个操作处理的数据类型是我们所希望的。</p><p>在Rust强大的泛型支持下，我们可以很方便地定义、使用泛型数据结构和泛型函数，并使用它们来处理参数多态，让输入输出参数的类型更灵活，增强代码的复用性。</p><p>今天我们继续讲多态中另外两种方式：特设多态和子类型多态，看看它们能用来解决什么问题、如何实现、如何使用。</p><p>如果你不太记得这两种多态的定义，我们简单回顾一下：特设多态包括运算符重载，是指同一种行为有很多不同的实现；而把子类型当成父类型使用，比如 Cat 当成 Animal 使用，属于子类型多态。</p><p>这两种多态的实现在Rust中都和 trait 有关，所以我们得先来了解一下 trait 是什么，再看怎么用 trait 来处理这两种多态。</p><h2>什么是 trait？</h2><p>trait 是 Rust 中的接口，它<strong>定义了类型使用这个接口的行为</strong>。你可以类比到自己熟悉的语言中理解，trait 对于 Rust 而言，相当于 interface 之于 Java、protocol 之于 Swift、type class 之于 Haskell。</p><p>在开发复杂系统的时候，我们常常会强调接口和实现要分离。因为这是一种良好的设计习惯，它把调用者和实现者隔离开，双方只要按照接口开发，彼此就可以不受对方内部改动的影响。</p><!-- [[[read_end]]] --><p>trait 就是这样。它可以把数据结构中的行为单独抽取出来，使其可以在多个类型之间共享；也可以作为约束，在泛型编程中，限制参数化类型必须符合它规定的行为。</p><h3>基本 trait</h3><p>我们来看看基本 trait 如何定义。这里，以标准库中 <a href=\"https://doc.rust-lang.org/std/io/trait.Write.html\">std::io::Write</a> 为例，可以看到这个 trait 中定义了一系列方法的接口：</p><pre><code class=\"language-rust\">pub trait Write {\n    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;\n    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;\n    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize&gt; { ... }\n    fn is_write_vectored(&amp;self) -&gt; bool { ... }\n    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt; { ... }\n    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;()&gt; { ... }\n    fn write_fmt(&amp;mut self, fmt: Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt; { ... }\n    fn by_ref(&amp;mut self) -&gt; &amp;mut Self where Self: Sized { ... }\n}\n</code></pre><p>这些方法也被称作关联函数（associate function）。<strong>在 trait 中，方法可以有缺省的实现</strong>，对于这个 Write trait，你只需要实现 write 和 flush 两个方法，其他都有<a href=\"https://doc.rust-lang.org/src/std/io/mod.rs.html#1310-1629\">缺省实现</a>。</p><p>如果你把 trait 类比为父类，实现 trait 的类型类比为子类，那么缺省实现的方法就相当于子类中可以重载但不是必须重载的方法。</p><p>在刚才定义方法的时候，我们频繁看到两个特殊的关键字：Self 和 self。</p><ul>\n<li>Self 代表当前的类型，比如 File 类型实现了 Write，那么实现过程中使用到的 Self 就指代 File。</li>\n<li>self 在用作方法的第一个参数时，实际上是 self: Self 的简写，所以 &amp;self 是 self: &amp;Self, 而 &amp;mut self 是 self: &amp;mut Self。</li>\n</ul><p>光讲定义，理解不太深刻，我们构建一个 BufBuilder 结构实现 Write trait，结合代码来说明。（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0a852b9832e4edd4f9760ca5355eb9f2\">Write trait 代码</a>）：</p><pre><code class=\"language-rust\">use std::fmt;\nuse std::io::Write;\n\nstruct BufBuilder {\n&nbsp; &nbsp; buf: Vec&lt;u8&gt;,\n}\n\nimpl BufBuilder {\n&nbsp; &nbsp; pub fn new() -&gt; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf: Vec::with_capacity(1024),\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\n// 实现 Debug trait，打印字符串\nimpl fmt::Debug for BufBuilder {\n&nbsp; &nbsp; fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n&nbsp; &nbsp; &nbsp; &nbsp; write!(f, \"{}\", String::from_utf8_lossy(&amp;self.buf))\n&nbsp; &nbsp; }\n}\n\nimpl Write for BufBuilder {\n&nbsp; &nbsp; fn write(&amp;mut self, buf: &amp;[u8]) -&gt; std::io::Result&lt;usize&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; // 把 buf 添加到 BufBuilder 的尾部\n&nbsp; &nbsp; &nbsp; &nbsp; self.buf.extend_from_slice(buf);\n&nbsp; &nbsp; &nbsp; &nbsp; Ok(buf.len())\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; fn flush(&amp;mut self) -&gt; std::io::Result&lt;()&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; // 由于是在内存中操作，所以不需要 flush\n&nbsp; &nbsp; &nbsp; &nbsp; Ok(())\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let mut buf = BufBuilder::new();\n&nbsp; &nbsp; buf.write_all(b\"Hello world!\").unwrap();\n&nbsp; &nbsp; println!(\"{:?}\", buf);\n}\n</code></pre><p>从代码中可以看到，我们实现了 write 和 flush 方法，其它的方法都用缺省实现，这样 BufBuilder 对 Write trait 的实现是完整的。如果没有实现 write 或者 flush，Rust 编译器会报错，你可以自己尝试一下。</p><p>数据结构一旦实现了某个 trait，那么这个 trait 内部的方法都可以被使用，比如这里我们调用了  <code>buf.write_all()</code> 。</p><p>那么  <code>write_all()</code> 是如何被调用的呢？我们回去看 write_all 的签名：</p><pre><code class=\"language-rust\">fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;\n</code></pre><p>它接受两个参数：&amp;mut self 和 &amp;[u8]，第一个参数传递的是 buf 这个变量的可变引用，第二个参数传递的是 b\"Hello world!\"。</p><h3>基本 trait 练习</h3><p>好，搞明白 trait 基本的定义和使用后，我们来尝试定义一个 trait 巩固下。</p><p>假设我们要做一个字符串解析器，可以把字符串的某部分解析成某个类型，那么可以这么定义这个 trait：它有一个方法是 parse，这个方法接受一个字符串引用，返回 Self。</p><pre><code class=\"language-rust\">pub trait Parse {\n  fn parse(s: &amp;str) -&gt; Self;\n}\n</code></pre><p>这个 parse 方法是 trait 的静态方法，因为它的第一个参数和 self 无关，所以在调用时需要使用  <code>T::parse(str)</code> 。</p><p>我们来尝试为 u8 这个数据结构来实现 parse，比如说：“123abc” 会被解析出整数 123，而 “abcd” 会被解析出 0。</p><p>要达到这样的目的，需要引入一个新的库 <a href=\"https://github.com/rust-lang/regex\">Regex</a> 使用正则表达式提取需要的内容，除此之外，还需要使用 <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.parse\">str::parse 函数</a> 把一个包含数字的字符串转换成数字。</p><p>整个代码如下（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=859d0c3e69b38c0728b8566d1a08ea2e\">Parse trait 练习代码</a>）：</p><pre><code class=\"language-rust\">use regex::Regex;\npub trait Parse {\n&nbsp; &nbsp; fn parse(s: &amp;str) -&gt; Self;\n}\n\nimpl Parse for u8 {\n&nbsp; &nbsp; fn parse(s: &amp;str) -&gt; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; let re: Regex = Regex::new(r\"^[0-9]+\").unwrap();\n&nbsp; &nbsp; &nbsp; &nbsp; if let Some(captures) = re.captures(s) {\n            // 取第一个 match，将其捕获的 digits 换成 u8\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; captures\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .get(0)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map_or(0, |s| s.as_str().parse().unwrap_or(0))\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\n#[test]\nfn parse_should_work() {\n&nbsp; &nbsp; assert_eq!(u8::parse(\"123abcd\"), 123);\n&nbsp; &nbsp; assert_eq!(u8::parse(\"1234abcd\"), 0);\n&nbsp; &nbsp; assert_eq!(u8::parse(\"abcd\"), 0);\n}\n\nfn main() {\n&nbsp; &nbsp; println!(\"result: {}\", u8::parse(\"255 hello world\"));\n}\n</code></pre><p>这个实现并不难，如果你感兴趣的话，可以再尝试为 f64 实现这个 Parse trait，比如 “123.45abcd” 需要被解析成 123.45。</p><p>在实现 f64 的过程中，你是不是感觉除了类型和用于捕获的 regex 略有变化外，整个代码基本和上面的代码是重复的？作为开发者，我们希望 Don’t Repeat Yourself（DRY），所以这样的代码写起来很别扭，让人不舒服。有没有更好的方法？</p><p>有！上一讲介绍了泛型编程，所以<strong>在实现 trait  的时候，也可以用泛型参数来实现 trait</strong>，需要注意的是，要对泛型参数做一定的限制。</p><ul>\n<li>第一，不是任何类型都可以通过字符串解析出来，在例子中，我们只能处理数字类型，并且这个类型还要能够被 <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.parse\">str::parse</a> 处理。</li>\n</ul><p>具体看文档，str::parse 是一个泛型函数，它返回任何实现了 FromStr trait 的类型，所以这里<strong>对泛型参数的第一个限制是，它必须实现了 FromStr trait</strong>。</p><ul>\n<li>第二，上面代码当无法正确解析字符串的时候，会直接返回 0，表示无法处理，但我们使用泛型参数后，无法返回 0，因为 0 不一定是某个符合泛型参数的类型中的一个值。怎么办？</li>\n</ul><p>其实返回 0 的目的是为处理不了的情况，返回一个缺省值，在 Rust 标准库中有 Default trait，绝大多数类型都实现了这个 trait，来为数据结构提供缺省值，所以<strong>泛型参数的另一个限制是 Default</strong>。</p><p>好，基本的思路有了，来看看代码吧（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=cefbce6d981c2ef7705ef663de7b9f74\">Parse trait DRY代码</a>）：</p><pre><code class=\"language-rust\">use std::str::FromStr;\n\nuse regex::Regex;\npub trait Parse {\n    fn parse(s: &amp;str) -&gt; Self;\n}\n\n// 我们约束 T 必须同时实现了 FromStr 和 Default\n// 这样在使用的时候我们就可以用这两个 trait 的方法了\nimpl&lt;T&gt; Parse for T\nwhere\n    T: FromStr + Default,\n{\n    fn parse(s: &amp;str) -&gt; Self {\n        let re: Regex = Regex::new(r\"^[0-9]+(\\.[0-9]+)?\").unwrap();\n        // 生成一个创建缺省值的闭包，这里主要是为了简化后续代码\n        // Default::default() 返回的类型根据上下文能推导出来，是 Self\n        // 而我们约定了 Self，也就是 T 需要实现 Default trait\n        let d = || Default::default();\n        if let Some(captures) = re.captures(s) {\n            captures\n                .get(0)\n                .map_or(d(), |s| s.as_str().parse().unwrap_or(d()))\n        } else {\n            d()\n        }\n    }\n}\n\n#[test]\nfn parse_should_work() {\n    assert_eq!(u32::parse(\"123abcd\"), 123);\n    assert_eq!(u32::parse(\"123.45abcd\"), 0);\n    assert_eq!(f64::parse(\"123.45abcd\"), 123.45);\n    assert_eq!(f64::parse(\"abcd\"), 0f64);\n}\n\nfn main() {\n    println!(\"result: {}\", u8::parse(\"255 hello world\"));\n}\n</code></pre><p>通过对带有约束的泛型参数实现 trait，一份代码就实现了 u32 / f64 等类型的 Parse trait，非常精简。不过，看这段代码你有没有感觉还是有些问题？当无法正确解析字符串时，我们返回了缺省值，难道不是应该返回一个错误么？</p><p>是的。<strong>这里返回缺省值的话，会跟解析 “0abcd” 这样的情况混淆，不知道解析出的 0，究竟是出错了，还是本该解析出 0</strong>。</p><p>所以更好的方式是 parse 函数返回一个 Result&lt;T, E&gt;：</p><pre><code class=\"language-rust\">pub trait Parse {\n    fn parse(s: &amp;str) -&gt; Result&lt;Self, E&gt;;\n}\n</code></pre><p>但这里 Result 的 E 让人犯难了：要返回的错误信息，在 trait 定义时并不确定，不同的实现者可以使用不同的错误类型，这里 trait 的定义者最好能够把这种灵活性留给 trait 的实现者。怎么办？</p><p>想想既然 trait 允许内部包含方法，也就是关联函数，可不可以进一步包含关联类型呢？答案是肯定的。</p><h3>带关联类型的 trait</h3><p>Rust 允许 trait 内部包含关联类型，实现时跟关联函数一样，它也需要实现关联类型。我们看怎么为 Parse trait 添加关联类型：</p><pre><code class=\"language-rust\">pub trait Parse {\n    type Error;\n    fn parse(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt;;\n}\n</code></pre><p>有了关联类型 Error，Parse trait 就可以在出错时返回合理的错误了，看修改后的代码（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3fe64849f7f6e05222303b237707bb58\">Parse trait DRY.2代码</a>）：</p><pre><code class=\"language-rust\">use std::str::FromStr;\n\nuse regex::Regex;\npub trait Parse {\n    type Error;\n    fn parse(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt;\n    where\n        Self: Sized;\n}\n\nimpl&lt;T&gt; Parse for T\nwhere\n    T: FromStr + Default,\n{\n    // 定义关联类型 Error 为 String\n    type Error = String;\n    fn parse(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {\n        let re: Regex = Regex::new(r\"^[0-9]+(\\.[0-9]+)?\").unwrap();\n        if let Some(captures) = re.captures(s) {\n            // 当出错时我们返回 Err(String)\n            captures\n                .get(0)\n                .map_or(Err(\"failed to capture\".to_string()), |s| {\n                    s.as_str()\n                        .parse()\n                        .map_err(|_err| \"failed to parse captured string\".to_string())\n                })\n        } else {\n            Err(\"failed to parse string\".to_string())\n        }\n    }\n}\n\n#[test]\nfn parse_should_work() {\n    assert_eq!(u32::parse(\"123abcd\"), Ok(123));\n    assert_eq!(\n        u32::parse(\"123.45abcd\"),\n        Err(\"failed to parse captured string\".into())\n    );\n    assert_eq!(f64::parse(\"123.45abcd\"), Ok(123.45));\n    assert!(f64::parse(\"abcd\").is_err());\n}\n\nfn main() {\n    println!(\"result: {:?}\", u8::parse(\"255 hello world\"));\n}\n</code></pre><p>上面的代码中，我们允许用户把错误类型延迟到 trait 实现时才决定，这种带有关联类型的 trait 比普通 trait，更加灵活，抽象度更高。</p><p>trait 方法里的参数或者返回值，都可以用关联类型来表述，而在实现有关联类型的 trait 时，只需要额外提供关联类型的具体类型即可。</p><h3>支持泛型的 trait</h3><p>到目前为止，我们一步步了解了基础 trait 的定义、使用，以及更为复杂灵活的带关联类型的 trait。所以结合上一讲介绍的泛型，你有没有想到这个问题：trait 的定义是不是也可以支持泛型呢？</p><p>比如要定义一个 Concat trait 允许数据结构拼接起来，那么自然而然地，我们希望 String 可以和 String 拼接、和 &amp;str 拼接，甚至和任何能转换成 String 的数据结构拼接。这个时候，就需要 Trait 也支持泛型了。</p><p>来看看标准库里的操作符是如何重载的，以 <a href=\"https://doc.rust-lang.org/std/ops/trait.Add.html\">std::ops::Add</a> 这个用于提供加法运算的 trait 为例：</p><pre><code class=\"language-rust\">pub trait Add&lt;Rhs = Self&gt; {\n    type Output;\n    #[must_use]\n    fn add(self, rhs: Rhs) -&gt; Self::Output;\n}\n</code></pre><p>这个 trait 有一个泛型参数 Rhs，代表加号右边的值，它被用在 add 方法的第二个参数位。这里 Rhs 默认是 Self，也就是说你用 Add trait ，如果不提供泛型参数，那么加号右值和左值都要是相同的类型。</p><p>我们来定义一个复数类型，尝试使用下这个 trait（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=685e20867a539e5b559df7976b34f574\">Add trait 练习代码1</a>）：</p><pre><code class=\"language-rust\">use std::ops::Add;\n\n#[derive(Debug)]\nstruct Complex {\n    real: f64,\n    imagine: f64,\n}\n\nimpl Complex {\n    pub fn new(real: f64, imagine: f64) -&gt; Self {\n        Self { real, imagine }\n    }\n}\n\n// 对 Complex 类型的实现\nimpl Add for Complex {\n    type Output = Self;\n\n    // 注意 add 第一个参数是 self，会移动所有权\n    fn add(self, rhs: Self) -&gt; Self::Output {\n        let real = self.real + rhs.real;\n        let imagine = self.imagine + rhs.imagine;\n        Self::new(real, imagine)\n    }\n}\n\nfn main() {\n    let c1 = Complex::new(1.0, 1f64);\n    let c2 = Complex::new(2 as f64, 3.0);\n    println!(\"{:?}\", c1 + c2);\n    // c1、c2 已经被移动，所以下面这句无法编译\n    // println!(\"{:?}\", c1 + c2);\n}\n</code></pre><p>复数类型有实部和虚部，两个复数的实部相加，虚部相加，得到一个新的复数。注意 add 的第一个参数是 self，它会移动所有权，所以调用完两个复数 c1 + c2 后，根据所有权规则，它们就无法使用了。</p><p>所以，Add trait 对于实现了 Copy trait 的类型如 u32、f64 等结构来说，用起来很方便，但对于我们定义的 Complex 类型，执行一次加法，原有的值就无法使用，很不方便，怎么办？能不能对 Complex 的引用实现 Add trait 呢？</p><p>可以的。我们为 &amp;Complex 也实现 Add（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b37f69ec583cccf49276e8db61e5fc1b\">Add trait 练习代码2</a>）：</p><pre><code class=\"language-rust\">// ...\n\n// 如果不想移动所有权，可以为 &amp;Complex 实现 add，这样可以做 &amp;c1 + &amp;c2\nimpl Add for &amp;Complex {\n    // 注意返回值不应该是 Self 了，因为此时 Self 是 &amp;Complex\n    type Output = Complex;\n\n    fn add(self, rhs: Self) -&gt; Self::Output {\n        let real = self.real + rhs.real;\n        let imagine = self.imagine + rhs.imagine;\n        Complex::new(real, imagine)\n    }\n}\n\nfn main() {\n    let c1 = Complex::new(1.0, 1f64);\n    let c2 = Complex::new(2 as f64, 3.0);\n    println!(\"{:?}\", &amp;c1 + &amp;c2);\n    println!(\"{:?}\", c1 + c2);\n}\n</code></pre><p>可以做 &amp;c1 + &amp;c2，这样所有权就不会移动了。</p><p>讲了这么多，你可能有疑问了，这里都只使用了缺省的泛型参数，那定义泛型有什么用？</p><p>我们用加法的实际例子，来回答这个问题。之前都是两个复数的相加，现在设计一个复数和一个实数直接相加，相加的结果是实部和实数相加，虚部不变。好，来看看这个需求怎么实现（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=cc02b2ed6e8ec3e593d0e9d5b7f1b6c6\">Add trait 练习代码3</a>）：</p><pre><code class=\"language-rust\">// ...\n\n// 因为 Add&lt;Rhs = Self&gt; 是个泛型 trait，我们可以为 Complex 实现 Add&lt;f64&gt;\nimpl Add&lt;f64&gt; for &amp;Complex {\n    type Output = Complex;\n\n    // rhs 现在是 f64 了\n    fn add(self, rhs: f64) -&gt; Self::Output {\n        let real = self.real + rhs;\n        Complex::new(real, self.imagine)\n    }\n}\n\nfn main() {\n    let c1 = Complex::new(1.0, 1f64);\n    let c2 = Complex::new(2 as f64, 3.0);\n    println!(\"{:?}\", &amp;c1 + &amp;c2);\n    println!(\"{:?}\", &amp;c1 + 5.0);\n    println!(\"{:?}\", c1 + c2);\n}\n</code></pre><p>通过使用 Add<f64> ，为 Complex 实现了和 f64 相加的方法。<strong>所以泛型 trait 可以让我们在需要的时候，对同一种类型的同一个 trait，有多个实现</strong>。</f64></p><p>这个小例子实用性不太够，再来看一个实际工作中可能会使用到的泛型 trait，你就知道这个支持有多强大了。</p><p><a href=\"https://docs.rs/tower/0.4.8/tower/trait.Service.html\">tower::Service</a> 是一个第三方库，它定义了一个精巧的用于处理请求，返回响应的经典 trait，在不少著名的第三方网络库中都有使用，比如处理 gRPC 的 <a href=\"https://docs.rs/tonic/0.5.2/tonic/\">tonic</a>。</p><p>看 Service 的定义：</p><pre><code class=\"language-rust\">// Service trait 允许某个 service 的实现能处理多个不同的 Request\npub trait Service&lt;Request&gt; {\n    type Response;\n    type Error;\n    // Future 类型受 Future trait 约束\n    type Future: Future;\n    fn poll_ready(\n        &amp;mut self, \n        cx: &amp;mut Context&lt;'_&gt;\n    ) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;\n    fn call(&amp;mut self, req: Request) -&gt; Self::Future;\n}\n</code></pre><p>这个 trait 允许某个 Service 能处理多个不同的 Request。我们在 Web 开发中使用该 trait 的话，每个 Method+URL 可以定义为一个 Service，其 Request 是输入类型。</p><p>注意对于某个确定的 Request 类型，只会返回一种 Response，所以这里 Response 使用关联类型，而非泛型。如果有可能返回多个 Response，那么应该使用泛型 Service&lt;Request, Response&gt;。<img src=\"https://static001.geekbang.org/resource/image/71/f8/7185e631b5700f85e8b0e4dc5d0aedf8.jpg?wh=2389x1004\" alt=\"\"></p><p>未来讲网络开发的时候再详细讲这个 trait，现在你只要能理解泛型 trait 的广泛应用场景就可以了。</p><h3>trait 的“继承”</h3><p>在 Rust 中，一个 trait 可以“继承”另一个 trait 的关联类型和关联函数。比如 trait B: A ，是说任何类型 T，如果实现了 trait B，它也必须实现 trait A，换句话说，<strong>trait B 在定义时可以使用 trait A 中的关联类型和方法</strong>。</p><p>可“继承”对扩展 trait 的能力很有帮助，很多常见的 trait 都会使用 trait 继承来提供更多的能力，比如 tokio 库中的 <a href=\"https://docs.rs/tokio/1.10.0/tokio/io/trait.AsyncWriteExt.html\">AsyncWriteExt</a>、futures 库中的 <a href=\"https://docs.rs/futures/0.3.16/futures/stream/trait.StreamExt.html\">StreamExt</a>。</p><p>以 StreamExt 为例，由于 StreamExt 中的方法都有缺省的实现，且所有实现了 Stream trait 的类型都实现了 StreamExt：</p><pre><code class=\"language-rust\">impl&lt;T: ?Sized&gt; StreamExt for T where T: Stream {}\n</code></pre><p>所以如果你实现了 Stream trait，就可以直接使用 StreamExt 里的方法了，非常方便。</p><p>好，到这里trait就基本讲完了，简单总结一下，trait 作为对不同数据结构中相同行为的一种抽象。除了基本 trait 之外，</p><ul>\n<li>当行为和具体的数据关联时，比如字符串解析时定义的 Parse trait，我们引入了带有关联类型的 trait，把和行为有关的数据类型的定义，进一步延迟到 trait 实现的时候。</li>\n<li>对于同一个类型的同一个 trait 行为，可以有不同的实现，比如我们之前大量使用的 From<t>，此时可以用泛型 trait。</t></li>\n</ul><p>可以说 Rust 的 trait 就像一把瑞士军刀，把需要定义接口的各种场景都考虑进去了。</p><p>而特设多态是同一种行为的不同实现。所以其实，<strong>通过定义 trait 以及为不同的类型实现这个 trait，我们就已经实现了特设多态</strong>。</p><p>刚刚讲过的 Add trait 就是一个典型的特设多态，同样是加法操作，根据操作数据的不同进行不同的处理。Service trait 是一个不那么明显的特设多态，同样是 Web 请求，对于不同的 URL，我们使用不同的代码去处理。</p><h2>如何做子类型多态？</h2><p>从严格意义上说，子类型多态是面向对象语言的专利。<strong>如果一个对象 A 是对象 B 的子类，那么 A 的实例可以出现在任何期望 B 的实例的上下文中</strong>，比如猫和狗都是动物，如果一个函数的接口要求传入一个动物，那么传入猫和狗都是允许的。</p><p>Rust 虽然没有父类和子类，但 trait 和实现 trait 的类型之间也是类似的关系，所以，Rust 也可以做子类型多态。看一个例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=21d316e5ce9338cfeba6b5a4f7a3b479\">代码</a>）：</p><pre><code class=\"language-rust\">struct Cat;\nstruct Dog;\n\ntrait Animal {\n    fn name(&amp;self) -&gt; &amp;'static str;\n}\n\nimpl Animal for Cat {\n    fn name(&amp;self) -&gt; &amp;'static str {\n        \"Cat\"\n    }\n}\n\nimpl Animal for Dog {\n    fn name(&amp;self) -&gt; &amp;'static str {\n        \"Dog\"\n    }\n}\n\nfn name(animal: impl Animal) -&gt; &amp;'static str {\n    animal.name()\n}\n\nfn main() {\n    let cat = Cat;\n    println!(\"cat: {}\", name(cat));\n}\n</code></pre><p>这里 impl Animal 是 T: Animal 的简写，所以 name 函数的定义和以下定义等价：</p><pre><code class=\"language-rust\">fn name&lt;T: Animal&gt;(animal: T) -&gt; &amp;'static str;\n</code></pre><p>上一讲提到过，这种泛型函数会根据具体使用的类型被单态化，编译成多个实例，是静态分派。</p><p>静态分派固然很好，效率很高，<strong>但很多时候，类型可能很难在编译时决定</strong>。比如要撰写一个格式化工具，这个在 IDE 里很常见，我们可以定义一个 <code>Formatter</code> 接口，然后创建一系列实现：</p><pre><code class=\"language-rust\">pub trait Formatter {\n    fn format(&amp;self, input: &amp;mut String) -&gt; bool;\n}\n\nstruct MarkdownFormatter;\nimpl Formatter for MarkdownFormatter {\n    fn format(&amp;self, input: &amp;mut String) -&gt; bool {\n        input.push_str(\"\\nformatted with Markdown formatter\");\n        true\n    }\n}\n\nstruct RustFormatter;\nimpl Formatter for RustFormatter {\n    fn format(&amp;self, input: &amp;mut String) -&gt; bool {\n        input.push_str(\"\\nformatted with Rust formatter\");\n        true\n    }\n}\n\nstruct HtmlFormatter;\nimpl Formatter for HtmlFormatter {\n    fn format(&amp;self, input: &amp;mut String) -&gt; bool {\n        input.push_str(\"\\nformatted with HTML formatter\");\n        true\n    }\n}\n</code></pre><p>首先，使用什么格式化方法，只有当打开文件，分析出文件内容之后才能确定，我们无法在编译期给定一个具体类型。其次，一个文件可能有一到多个格式化工具，比如一个 Markdown 文件里有 Rust 代码，同时需要 <code>MarkdownFormatter</code> 和 <code>RustFormatter</code> 来格式化。</p><p>这里如果使用一个 Vec&lt;T&gt; 来提供所有需要的格式化工具，那么，下面这个函数其 formatters 参数该如何确定类型呢？</p><pre><code class=\"language-rust\">pub fn format(input: &amp;mut String, formatters: Vec&lt;???&gt;) {\n    for formatter in formatters {\n        formatter.format(input);\n    }\n}\n</code></pre><p>正常情况下，<code>Vec&lt;&gt;</code> 容器里的类型需要是一致的，但此处无法给定一个一致的类型。</p><p>所以我们要有一种手段，告诉编译器，此处需要并且仅需要任何实现了 <code>Formatter</code> 接口的数据类型。<strong>在 Rust 里，这种类型叫Trait Object</strong>，表现为 <code>&amp;dyn Trait</code> 或者 <code>Box&lt;dyn Trait&gt;</code>。</p><p>这里，<code>dyn</code> 关键字只是用来帮助我们更好地区分普通类型和 Trait 类型，阅读代码时，看到 dyn 就知道后面跟的是一个 trait 了。</p><p>于是，上述代码可以写成：</p><pre><code class=\"language-rust\">pub fn format(input: &amp;mut String, formatters: Vec&lt;&amp;dyn Formatter&gt;) {\n    for formatter in formatters {\n        formatter.format(input);\n    }\n}\n</code></pre><p>这样可以在运行时，构造一个 <code>Formatter</code> 的列表，传递给 <code>format</code> 函数进行文件的格式化，这就是<strong>动态分派</strong>（dynamic dispatching）。</p><p>看最终调用的<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=73f88c0bc0911026335ceba5cb670603\">格式化工具代码</a>：</p><pre><code class=\"language-rust\">pub trait Formatter {\n    fn format(&amp;self, input: &amp;mut String) -&gt; bool;\n}\n\nstruct MarkdownFormatter;\nimpl Formatter for MarkdownFormatter {\n    fn format(&amp;self, input: &amp;mut String) -&gt; bool {\n        input.push_str(\"\\nformatted with Markdown formatter\");\n        true\n    }\n}\n\nstruct RustFormatter;\nimpl Formatter for RustFormatter {\n    fn format(&amp;self, input: &amp;mut String) -&gt; bool {\n        input.push_str(\"\\nformatted with Rust formatter\");\n        true\n    }\n}\n\nstruct HtmlFormatter;\nimpl Formatter for HtmlFormatter {\n    fn format(&amp;self, input: &amp;mut String) -&gt; bool {\n        input.push_str(\"\\nformatted with HTML formatter\");\n        true\n    }\n}\n\npub fn format(input: &amp;mut String, formatters: Vec&lt;&amp;dyn Formatter&gt;) {\n    for formatter in formatters {\n        formatter.format(input);\n    }\n}\n\nfn main() {\n    let mut text = \"Hello world!\".to_string();\n    let html: &amp;dyn Formatter = &amp;HtmlFormatter;\n    let rust: &amp;dyn Formatter = &amp;RustFormatter;\n    let formatters = vec![html, rust];\n    format(&amp;mut text, formatters);\n\n    println!(\"text: {}\", text);\n}\n</code></pre><p>这个实现是不是很简单？学到这里你在兴奋之余，不知道会不会感觉有点负担，又一个Rust新名词出现了。别担心，虽然 Trait Object 是 Rust 独有的概念，但是这个概念并不新鲜。为什么这么说呢，来看它的实现机理。</p><h3>Trait Object 的实现机理</h3><p>当需要使用 Formatter trait 做动态分派时，可以像如下例子一样，将一个具体类型的引用，赋给 <code>&amp;Formatter</code> ： <img src=\"https://static001.geekbang.org/resource/image/49/1d/4900097edab0yye11233e14ef857be1d.jpg?wh=2248x1370\" alt=\"\"></p><p>HtmlFormatter 的引用赋值给 Formatter 后，会生成一个 Trait Object，在上图中可以看到，<strong>Trait Object 的底层逻辑就是胖指针</strong>。其中，一个指针指向数据本身，另一个则指向虚函数表（vtable）。</p><p>vtable 是一张静态的表，Rust 在编译时会为使用了 trait object 的类型的 trait 实现生成一张表，放在可执行文件中（一般在 TEXT 或 RODATA 段）。看下图，可以帮助你理解：<img src=\"https://static001.geekbang.org/resource/image/9d/5e/9ddeafee9740e891f6bf9c1584e6905e.jpg?wh=2389x1738\" alt=\"\"></p><p>在这张表里，包含具体类型的一些信息，如 size、aligment 以及一系列函数指针：</p><ul>\n<li>这个接口支持的所有的方法，比如 <code>format()</code> ；</li>\n<li>具体类型的 drop trait，当 Trait object 被释放，它用来释放其使用的所有资源。</li>\n</ul><p>这样，当在运行时执行 <code>formatter.format()</code> 时，formatter 就可以从 vtable 里找到对应的函数指针，执行具体的操作。</p><p>所以，<strong>Rust 里的 Trait Object 没什么神秘的，它不过是我们熟知的 C++ / Java 中 vtable 的一个变体而已</strong>。</p><p>这里说句题外话，C++ / Java 指向 vtable 的指针，在编译时放在类结构里，而 Rust 放在 Trait object 中。这也是为什么 Rust 很容易对原生类型做动态分派，而 C++/Java 不行。</p><p>事实上，Rust 也并不区分原生类型和组合类型，对 Rust 来说，所有类型的地位都是一致的。</p><p>不过，你使用 trait object 的时候，要注意对象安全（object safety）。只有满足对象安全的 trait 才能使用 trait object，在<a href=\"https://doc.rust-lang.org/book/ch17-02-trait-objects.html\">官方文档</a>中有详细讨论。</p><p>那什么样的 trait 不是对象安全的呢？</p><p><strong>如果 trait 所有的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能产生 trait object</strong>。</p><p>不允许返回 Self，是因为 trait object 在产生时，原来的类型会被抹去，所以 Self 究竟是谁不知道。比如 Clone trait 只有一个方法 clone()，返回 Self，所以它就不能产生 trait object。</p><p>不允许携带泛型参数，是因为 Rust 里带泛型的类型在编译时会做单态化，而 trait object 是运行时的产物，两者不能兼容。</p><p>比如 From<t> trait，因为整个 trait 带了泛型，每个方法也自然包含泛型，就不能产生 trait object。如果一个 trait 只有部分方法返回 Self 或者使用了泛型参数，那么这部分方法在 trait object 中不能调用。</t></p><h2>小结</h2><p>今天完整地介绍了 trait 是如何定义和使用的，包括最基本的 trait、带关联类型的 trait，以及泛型 trait。我们还回顾了通过 trait 做静态分发以及使用 trait object 做动态分发。</p><p>今天的内容比较多，不太明白的地方建议你多看几遍，你也可以通过下图来回顾这一讲的主要内容：<img src=\"https://static001.geekbang.org/resource/image/59/e6/59bd1c6f90b99e9604e6602e33a622e6.jpg?wh=2375x2173\" alt=\"\"></p><p>trait 作为对不同数据结构中相同行为的一种抽象，它可以让我们<strong>在开发时，通过用户需求，先敲定系统的行为，把这些行为抽象成 trait，之后再慢慢确定要使用的数据结构，以及如何为数据结构实现这些 trait</strong>。</p><p>所以，trait 是你做 Rust 开发的核心元素。什么时候使用什么 trait，需要根据需求来确定。</p><p>但是需求往往不是那么明确的，尤其是因为我们要把用户需求翻译成系统设计上的需求。这种翻译能力，得靠足够多源码的阅读和思考，以及足够丰富的历练，一点点累积成的。<strong>因为 Rust 的 trait 再强大，也只是一把瑞士军刀，能让它充分发挥作用的是持有它的那个人</strong>。</p><p>以在 get hands dirty 系列中写的代码为例，我们使用了 trait 对系统进行解耦，并增强其扩展性，你可以简单回顾一下。比如第 5 讲的 Engine trait 和 SpecTransform trait，使用了普通 trait：</p><pre><code class=\"language-rust\">// Engine trait：未来可以添加更多的 engine，主流程只需要替换 engine\npub trait Engine {\n    // 对 engine 按照 specs 进行一系列有序的处理\n    fn apply(&amp;mut self, specs: &amp;[Spec]);\n    // 从 engine 中生成目标图片，注意这里用的是 self，而非 self 的引用\n    fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt;;\n}\n// SpecTransform：未来如果添加更多的 spec，只需要实现它即可\npub trait SpecTransform&lt;T&gt; {\n    // 对图片使用 op 做 transform\n    fn transform(&amp;mut self, op: T);\n}\n</code></pre><p>第 6 讲的 Fetch/Load trait，使用了带关联类型的 trait：</p><pre><code class=\"language-rust\">// Rust 的 async trait 还没有稳定，可以用 async_trait 宏\n#[async_trait]\npub trait Fetch {\n    type Error;\n    async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt;;\n}\n\npub trait Load {\n    type Error;\n    fn load(self) -&gt; Result&lt;DataSet, Self::Error&gt;;\n}\n</code></pre><h2>思考题</h2><p>1.对于 Add&lt;Rhs&gt; trait，如果我们不用泛型，把 Rhs 作为 Add trait 的关联类型，可以么？为什么？</p><p>2.如下代码能编译通过么，为什么？</p><pre><code class=\"language-rust\">use std::{fs::File, io::Write};\nfn main() {\n    let mut f = File::create(\"/tmp/test_write_trait\").unwrap();\n    let w: &amp;mut dyn Write = &amp;mut f;\n    w.write_all(b\"hello \").unwrap();\n    let w1 = w.by_ref();\n    w1.write_all(b\"world\").unwrap();\n}\n</code></pre><p>3.在 Complex 的例子中，c1 + c2 会导致所有权移动，所以我们使用了 &amp;c1 + &amp;c2 来避免这种行为。除此之外，你还有什么方法能够让 c1 + c2 执行完之后还能继续使用么？如何修改 Complex 的代码来实现这个功能呢？</p><pre><code class=\"language-rust\">    // c1、c2 已经被移动，所以下面这句无法编译\n    // println!(\"{:?}\", c1 + c2);\n</code></pre><p>4.学有余力的同学可以挑战一下，<a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\">Iterator</a> 是 Rust 下的迭代器的 trait，你可以阅读 Iterator 的文档获得更多的信息。它有一个关联类型 Item 和一个方法 next() 需要实现，每次调用 next，如果迭代器中还能得到一个值，则返回 Some(Item)，否则返回 None。请阅读<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6310cafc64afbd4762dd7997533f7d31\">如下代码</a>，想想看如何实现 SentenceIter 这个结构的迭代器？</p><pre><code class=\"language-rust\">struct SentenceIter&lt;'a&gt; {\n    s: &amp;'a mut &amp;'a str,\n    delimiter: char,\n}\n\nimpl&lt;'a&gt; SentenceIter&lt;'a&gt; {\n    pub fn new(s: &amp;'a mut &amp;'a str, delimiter: char) -&gt; Self {\n        Self { s, delimiter }\n    }\n}\n\nimpl&lt;'a&gt; Iterator for SentenceIter&lt;'a&gt; {\n&nbsp; &nbsp; type Item; // 想想 Item 应该是什么类型？\n\n&nbsp; &nbsp; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; // 如何实现 next 方法让下面的测试通过？\n&nbsp; &nbsp; &nbsp; &nbsp; todo!()\n&nbsp; &nbsp; }\n}\n\n\n\n#[test]\nfn it_works() {\n    let mut s = \"This is the 1st sentence. This is the 2nd sentence.\";\n    let mut iter = SentenceIter::new(&amp;mut s, '.');\n    assert_eq!(iter.next(), Some(\"This is the 1st sentence.\"));\n    assert_eq!(iter.next(), Some(\"This is the 2nd sentence.\"));\n    assert_eq!(iter.next(), None);\n}\n\nfn main() {\n    let mut s = \"a。 b。 c\";\n    let sentences: Vec&lt;_&gt; = SentenceIter::new(&amp;mut s, '。').collect();\n    println!(\"sentences: {:?}\", sentences);\n}\n</code></pre><p>今天你已经完成了Rust学习的第13次打卡。我们下节课见～</p><h2>延伸阅读</h2><p>使用 trait 有两个注意事项：</p><ul>\n<li>第一，在定义和使用 trait 时，我们需要遵循孤儿规则（Orphan Rule）。</li>\n</ul><p>trait 和实现 trait 的数据类型，至少有一个是在当前 crate 中定义的，也就是说，你不能为第三方的类型实现第三方的 trait，当你尝试这么做时，Rust 编译器会报错。我们在第6讲的 SQL查询工具query中，定义了很多简单的直接包裹已有数据结构的类型，就是为了应对孤儿规则。</p><ul>\n<li>第二，Rust 对含有 async fn 的 trait ，还没有一个很好的被标准库接受的实现，如果你感兴趣可以看<a href=\"https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/\">这篇文章</a>了解它背后的原因。</li>\n</ul><p>在第5讲Thumbor图片服务器我们使用了 async_trait 这个库，为 trait 的实现添加了一个标记宏 #[async_trait]。这是目前最推荐的无缝使用 async trait 的方法。未来 async trait 如果有了标准实现，我们不需要对现有代码做任何改动。</p><p>使用 async_trait 的代价是每次调用会发生额外的堆内存分配，但绝大多数应用场景下，这并不会有性能上的问题。</p><p>还记得当时写get hands dirty系列时，说我们在后面讲到具体知识点会再回顾么。你可以再回去看看（第5讲）在Thumbor图片服务器中定义的 Engine / SpecTransform，以及（第6讲）在SQL查询工具query中定义的 Fetch / Load，想想它们的作用以及给架构带来的好处。</p><p>另外，有同学可能好奇为什么我说“ vtable 会为每个类型的每个 trait 实现生成一张表”。这个并没有在任何公开的文档中提及，不过既然它是一个数据结构，我们就可以通过打印它的地址来追踪它的行为。我写了一段代码，你可以自行运行来进一步加深对 vtable 的理解（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1d161189515edb54c339657f41d28973\">代码</a>）：</p><pre><code class=\"language-rust\">use std::fmt::{Debug, Display};\nuse std::mem::transmute;\n\nfn main() {\n&nbsp; &nbsp; let s1 = String::from(\"hello world!\");\n&nbsp; &nbsp; let s2 = String::from(\"goodbye world!\");\n&nbsp; &nbsp; // Display / Debug trait object for s\n&nbsp; &nbsp; let w1: &amp;dyn Display = &amp;s1;\n&nbsp; &nbsp; let w2: &amp;dyn Debug = &amp;s1;\n\n&nbsp; &nbsp; // Display / Debug trait object for s1\n&nbsp; &nbsp; let w3: &amp;dyn Display = &amp;s2;\n&nbsp; &nbsp; let w4: &amp;dyn Debug = &amp;s2;\n\n&nbsp; &nbsp; // 强行把 triat object 转换成两个地址 (usize, usize)\n&nbsp; &nbsp; // 这是不安全的，所以是 unsafe\n    let (addr1, vtable1): (usize, usize) = unsafe { transmute(w1) };\n    let (addr2, vtable2): (usize, usize) = unsafe { transmute(w2) };\n    let (addr3, vtable3): (usize, usize) = unsafe { transmute(w3) };\n    let (addr4, vtable4): (usize, usize) = unsafe { transmute(w4) };\n\n&nbsp; &nbsp; // s 和 s1 在栈上的地址，以及 main 在 TEXT 段的地址\n&nbsp; &nbsp; println!(\n&nbsp; &nbsp; &nbsp; &nbsp; \"s1: {:p}, s2: {:p}, main(): {:p}\",\n&nbsp; &nbsp; &nbsp; &nbsp; &amp;s1, &amp;s2, main as *const ()\n&nbsp; &nbsp; );\n&nbsp; &nbsp; // trait object(s / Display) 的 ptr 地址和 vtable 地址\n&nbsp; &nbsp; println!(\"addr1: 0x{:x}, vtable1: 0x{:x}\", addr1, vtable1);\n&nbsp; &nbsp; // trait object(s / Debug) 的 ptr 地址和 vtable 地址\n&nbsp; &nbsp; println!(\"addr2: 0x{:x}, vtable2: 0x{:x}\", addr2, vtable2);\n\n&nbsp; &nbsp; // trait object(s1 / Display) 的 ptr 地址和 vtable 地址\n&nbsp; &nbsp; println!(\"addr3: 0x{:x}, vtable3: 0x{:x}\", addr3, vtable3);\n\n&nbsp; &nbsp; // trait object(s1 / Display) 的 ptr 地址和 vtable 地址\n&nbsp; &nbsp; println!(\"addr4: 0x{:x}, vtable4: 0x{:x}\", addr4, vtable4);\n\n&nbsp; &nbsp; // 指向同一个数据的 trait object 其 ptr 地址相同\n&nbsp; &nbsp; assert_eq!(addr1, addr2);\n&nbsp; &nbsp; assert_eq!(addr3, addr4);\n\n&nbsp; &nbsp; // 指向同一种类型的同一个 trait 的 vtable 地址相同\n&nbsp; &nbsp; // 这里都是 String + Display\n&nbsp; &nbsp; assert_eq!(vtable1, vtable3);\n&nbsp; &nbsp; // 这里都是 String + Debug\n&nbsp; &nbsp; assert_eq!(vtable2, vtable4);\n}\n</code></pre><p>（如果你觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论～）</p>","neighbors":{"left":{"article_title":"12｜类型系统：Rust的类型系统有什么特点？","id":420021},"right":{"article_title":"14｜类型系统：有哪些必须掌握的trait？","id":421324}},"comments":[{"had_liked":false,"id":313091,"user_name":"GengTeng","can_delete":false,"product_type":"c1","uid":1224623,"ip_address":"","ucode":"3F926F5EF1D075","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/af/8b03ce2c.jpg","comment_is_top":false,"comment_ctime":1632276470,"is_pvip":false,"replies":[{"id":"113460","content":"非常棒！<br><br>对于第 4 题，如果没有 delimiter 的，要返回剩余部分。可以看看我的参考答案：<br><br>```rust<br>struct SentenceIter&lt;&#39;a&gt; {<br>    s: &amp;&#39;a mut &amp;&#39;a str,<br>    delimiter: char,<br>}<br><br>impl&lt;&#39;a&gt; SentenceIter&lt;&#39;a&gt; {<br>    pub fn new(s: &amp;&#39;a mut &amp;&#39;a str, delimiter: char) -&gt; Self {<br>        Self { s, delimiter }<br>    }<br>}<br><br>impl&lt;&#39;a&gt; Iterator for SentenceIter&lt;&#39;a&gt; {<br>    type Item = &amp;&#39;a str;<br><br>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>        &#47;&#47; 如果内部的字符串引用指向空，则提前结束<br>        if self.s.is_empty() {<br>            return None;<br>        }<br>        match self.s.find(self.delimiter) {<br>            Some(pos) =&gt; {<br>                &#47;&#47; 注意对于 utf8 char，取它的长度需要用 c.len_utf8()<br>                let len = self.delimiter.len_utf8();<br>                let s = &amp;self.s[..pos + len];<br>                let suffix = &amp;self.s[pos + len..];<br>                &#47;&#47; 更改内部字符串引用，指向剩余部分<br>                *self.s = suffix;<br>                Some(s.trim())<br>            }<br>            None =&gt; {<br>                &#47;&#47; 没有找到句号时，有可能后续还有最后一句内容<br>                let s = (*self.s).trim();<br>                *self.s = &quot;&quot;;<br><br>                if s.len() == 0 {<br>                    None<br>                } else {<br>                    Some(s)<br>                }<br>            }<br>        }<br>    }<br>}<br><br>#[test]<br>fn it_works() {<br>    let mut s = &quot;This is the 1st sentence. This is the 2nd sentence.&quot;;<br>    let mut iter = SentenceIter::new(&amp;mut s, &#39;.&#39;);<br>    assert_eq!(iter.next(), Some(&quot;This is the 1st sentence.&quot;));<br>    assert_eq!(iter.next(), Some(&quot;This is the 2nd sentence.&quot;));<br>    assert_eq!(iter.next(), None);<br>}<br><br>fn main() {<br>    let mut s = &quot;a。 b。 c&quot;;<br>    let sentences: Vec&lt;_&gt; = SentenceIter::new(&amp;mut s, &#39;。&#39;).collect();<br>    println!(&quot;sentences: {:?}&quot;, sentences);<br>}<br>```<br><br>playground：https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4590211f7542553e7feef960e814ab0b","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632357248,"ip_address":"","comment_id":313091,"utype":1}],"discussion_count":3,"race_medal":0,"score":"44581949430","product_id":100085301,"comment_content":"1. 不可以。关联类型无法就只能impl一次了，我们需要为Complex实现多个Add&lt;Rhs&gt;。<br>2. 不能。返回类型中的 Self 需要是Sized，而 dyn Write 不是Sized。<br>3. #[derive(Debug, Copy, Clone)]<br>4. impl&lt;&#39;a&gt; Iterator for SentenceIter&lt;&#39;a&gt; {<br>        type Item = &amp;&#39;a str;<br><br>        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>            match self.s.find(self.delimiter) {<br>                None =&gt; None,<br>                Some(i) =&gt; {<br>                    let s = &amp;self.s[..i + self.delimiter.len_utf8()];<br>                    *self.s = &amp;self.s[i + self.delimiter.len_utf8()..];<br>                    if let Some((start, _)) =<br>                        s.as_bytes().iter().enumerate().find(|(_, b)| **b != b&#39; &#39;)<br>                    {<br>                        Some(&amp;s[start..])<br>                    } else {<br>                        None<br>                    }<br>                }<br>            }<br>        }<br>    }<br><br>这个SentenceIter的功能定义不明确，分割出来的每个sentence如果都需要包括delimiter的话，那剩余部分没有delimiter的情况该返回None吗？或者返回一个不带delimiter的剩余部分？都很别扭。","like_count":10,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527222,"discussion_content":"非常棒！\n\n对于第 4 题，如果没有 delimiter 的，要返回剩余部分。可以看看我的参考答案：\n\n```rust\nstruct SentenceIter&amp;lt;&amp;#39;a&amp;gt; {\n    s: &amp;amp;&amp;#39;a mut &amp;amp;&amp;#39;a str,\n    delimiter: char,\n}\n\nimpl&amp;lt;&amp;#39;a&amp;gt; SentenceIter&amp;lt;&amp;#39;a&amp;gt; {\n    pub fn new(s: &amp;amp;&amp;#39;a mut &amp;amp;&amp;#39;a str, delimiter: char) -&amp;gt; Self {\n        Self { s, delimiter }\n    }\n}\n\nimpl&amp;lt;&amp;#39;a&amp;gt; Iterator for SentenceIter&amp;lt;&amp;#39;a&amp;gt; {\n    type Item = &amp;amp;&amp;#39;a str;\n\n    fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt; {\n        // 如果内部的字符串引用指向空，则提前结束\n        if self.s.is_empty() {\n            return None;\n        }\n        match self.s.find(self.delimiter) {\n            Some(pos) =&amp;gt; {\n                // 注意对于 utf8 char，取它的长度需要用 c.len_utf8()\n                let len = self.delimiter.len_utf8();\n                let s = &amp;amp;self.s[..pos + len];\n                let suffix = &amp;amp;self.s[pos + len..];\n                // 更改内部字符串引用，指向剩余部分\n                *self.s = suffix;\n                Some(s.trim())\n            }\n            None =&amp;gt; {\n                // 没有找到句号时，有可能后续还有最后一句内容\n                let s = (*self.s).trim();\n                *self.s = &amp;quot;&amp;quot;;\n\n                if s.len() == 0 {\n                    None\n                } else {\n                    Some(s)\n                }\n            }\n        }\n    }\n}\n\n#[test]\nfn it_works() {\n    let mut s = &amp;quot;This is the 1st sentence. This is the 2nd sentence.&amp;quot;;\n    let mut iter = SentenceIter::new(&amp;amp;mut s, &amp;#39;.&amp;#39;);\n    assert_eq!(iter.next(), Some(&amp;quot;This is the 1st sentence.&amp;quot;));\n    assert_eq!(iter.next(), Some(&amp;quot;This is the 2nd sentence.&amp;quot;));\n    assert_eq!(iter.next(), None);\n}\n\nfn main() {\n    let mut s = &amp;quot;a。 b。 c&amp;quot;;\n    let sentences: Vec&amp;lt;_&amp;gt; = Sentence","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632357248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295043,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c2/c3/da31c9c2.jpg","nickname":"浩然","note":"","ucode":"D1FB4E3E7ADE5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569334,"discussion_content":"这样迭代完之后，s 的值不就被改变了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651408767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1355560,"avatar":"https://static001.geekbang.org/account/avatar/00/14/af/28/cc69ea4b.jpg","nickname":"周烨","note":"","ucode":"6DAE79E4966CEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400952,"discussion_content":"请问这里为什么要用 (*self.s).trim()？直接 self.s.trim() 也可以拿到正确结果啊。\n```// 没有找到句号时，有可能后续还有最后一句内容\nlet s = (*self.s).trim();```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633499566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314173,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1632885701,"is_pvip":false,"replies":[{"id":"113980","content":"不是 append 的关系。每一个 trait 和某个数据结构对该 trait 的实现都会生成一个静态的 vtable。vtable 是彼此独立的。<br><br>1. method call 不需要 table，通过类型就可以得到类型固定的 method call  的地址（编译期就可以完成了）。vtable 是一个运行期的概念。在 trait object 生成的时候，才指向具体的 vtable。<br>2. 你可以再仔细看看关于 vtable 的那几个图。并不是通过 addr + offset 来调 trait 的 method 的。是通过 vtable。比如一个 trait object 指向了 String Display 的 vtable，那么重这个 vtable 里就能找到 fmt 方法的地址。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633321724,"ip_address":"","comment_id":314173,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14517787589","product_id":100085301,"comment_content":"```<br>    &#47;&#47; 指向同一种类型的同一个 trait 的 vtable 地址相同<br>    &#47;&#47; 这里都是 String + Display<br>    assert_eq!(vtable1, vtable3);<br>    &#47;&#47; 这里都是 String + Debug<br>    assert_eq!(vtable2, vtable4);<br>```<br><br>我原本以为String有个method call table, Display也有一个单独的; 那么说, 我自己写了个trait给String type, 岂不是编译的时候, 我自己提供的method需要append到String之前已经有的vtable?<br><br>1. vtable和method call table有啥区别呢?<br><br>2. 那么call `fn fmt(&amp;self, f: &amp;mut Formatter&lt;&#39;_&gt;) -&gt; Result;`的时候, 编译器是知道这个call在各个不同的实现中vtable的offset? 而且, 这些offset都要一样? 因为我记得, 编译的时候, 因为类型被erase了, 只能通过addr + offset (ptr, *args) 来call metho<br><br>例如, vtable1 + offset 和 vtable3 + offset 的地址都是call table中 fmt method 对应地址?","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527599,"discussion_content":"不是 append 的关系。每一个 trait 和某个数据结构对该 trait 的实现都会生成一个静态的 vtable。vtable 是彼此独立的。\n\n1. method call 不需要 table，通过类型就可以得到类型固定的 method call  的地址（编译期就可以完成了）。vtable 是一个运行期的概念。在 trait object 生成的时候，才指向具体的 vtable。\n2. 你可以再仔细看看关于 vtable 的那几个图。并不是通过 addr + offset 来调 trait 的 method 的。是通过 vtable。比如一个 trait object 指向了 String Display 的 vtable，那么重这个 vtable 里就能找到 fmt 方法的地址。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633321724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","nickname":"Marvichov","note":"","ucode":"7482099415C41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401286,"discussion_content":"我猜, 是通过 <vtable_prt + 对每个trait生成的固定offset>(data_ptr, *args) 来进行动态method call的. 不知道是不是这样的.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633618439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","nickname":"Marvichov","note":"","ucode":"7482099415C41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401284,"discussion_content":"谢谢老师, 明白了.\n\n我理解 `String + Debug` 错了. 我以为是String的所有method + (append) Debug的vtable. 这里应该理解为: Debug&#39;s vtable for String type.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633617986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313108,"user_name":"lisiur","can_delete":false,"product_type":"c1","uid":1201350,"ip_address":"","ucode":"CEB2DBCE29CAA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","comment_is_top":false,"comment_ctime":1632281535,"is_pvip":false,"replies":[{"id":"113464","content":"非常棒！1，2，3 答案正确！4 需要考虑最后的部分。对 main() 里的实例代码，这个只返回[&quot;a。&quot;, &quot;b。&quot;]。你可以看我之前在其他回答下的回复。<br><br>谢谢指正，对，trait object 那个图是有问题，ptr 应该指向 HtmlFormatter。有时候图 copy &amp; paste 时，就回忘了把不用的部分删除并修改，lol。我回头让编辑更新！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632357620,"ip_address":"","comment_id":313108,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14517183423","product_id":100085301,"comment_content":"1. 不应该这么做。如果这么做的话，同一个类型对同一个 trait 只能有一个实现，<br>Rhs 也之能有一种可能，这样就不能既实现 String + String 又实现 String + &amp;str，没有扩展性。<br><br>2. 不能编译通过，因为 by_ref 返回值含有 Self，不能作为 trait object 的方法使用。<br><br>3. 对 Complex 实现 Copy 和 Clone<br><br>```<br>#[derive(Debug, Copy, Clone)]<br>struct Complex {<br>    real: f64,<br>    imagine: f64,<br>}<br>```<br><br>4. <br><br>```rust<br>impl&lt;&#39;a&gt; Iterator for SentenceIter&lt;&#39;a&gt; {<br>    type Item = &amp;&#39;a str;<br><br>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>        self.s.find(self.delimiter).map(|index| {<br>            let next = &amp;self.s[..index + self.delimiter.len_utf8()];<br>            *self.s = &amp;self.s[index + self.delimiter.len_utf8()..];<br>            next.trim_start()<br>        })<br>    }<br>}<br>```<br><br>有个小小的疑问想请教下老师，在 **Trait Object 的实现机理** 这一小节开始给的配图中，<br>formatter 这个 trait object 的 ptr 为啥会指向参数 text 呢？不是指向 HtmlFormatter 这个实例数据吗？","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527235,"discussion_content":"非常棒！1，2，3 答案正确！4 需要考虑最后的部分。对 main() 里的实例代码，这个只返回[&amp;quot;a。&amp;quot;, &amp;quot;b。&amp;quot;]。你可以看我之前在其他回答下的回复。\n\n谢谢指正，对，trait object 那个图是有问题，ptr 应该指向 HtmlFormatter。有时候图 copy &amp;amp; paste 时，就回忘了把不用的部分删除并修改，lol。我回头让编辑更新！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632357620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313789,"user_name":"QY","can_delete":false,"product_type":"c1","uid":2781088,"ip_address":"","ucode":"46BE73D1F1BBF4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/6f/a0/5ae45670.jpg","comment_is_top":false,"comment_ctime":1632665826,"is_pvip":false,"replies":[{"id":"113720","content":"因为 strtok 会修改传入的参数，使其指向 &amp;str 的 tokenize 后面的位置，所以需要 &amp;mut &amp;str。你可以仔细看我画的图去理解。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632796271,"ip_address":"","comment_id":313789,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10222600418","product_id":100085301,"comment_content":"请问第四题为什么要用&amp;mut &amp;s 呢？ 是性能更好吗？<br>感觉&amp;s使用起来自由度更高。宣言s时不需要mut s。","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527472,"discussion_content":"因为 strtok 会修改传入的参数，使其指向 &amp;amp;str 的 tokenize 后面的位置，所以需要 &amp;amp;mut &amp;amp;str。你可以仔细看我画的图去理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632796271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2781088,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/6f/a0/5ae45670.jpg","nickname":"QY","note":"","ucode":"46BE73D1F1BBF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399273,"discussion_content":"谢谢老师的回复。\n像我以下这样。因为SentenceIter可以宣言为mut，所以s在与SentenceIter一个scope中可以不需要宣言为mut，之后自由度更高。\n```rust\nstruct SentenceIter<&#39;a> {\n    s: &amp;&#39;a str, //s 不需要是mut 因为sentenceItem是mut\n    delimiter: char,\n}\n\nimpl<&#39;a> SentenceIter<&#39;a> {\n    pub fn new(s: &amp;&#39;a str, delimiter: char) -> Self {\n        Self { s, delimiter }\n    }\n}\n\nimpl<&#39;a> Iterator for SentenceIter<&#39;a> {\n    type Item = &amp;&#39;a str;\n\n    fn next(&amp;mut self) -> Option<Self::Item> {\n        match self.s.find(self.delimiter) {\n            Some(p) => {\n                let (next, suffix) = self.s.split_at(p + self.delimiter.len_utf8());\n                self.s = suffix;\n                Some(next.trim())\n            }\n            None => {\n                if self.s.is_empty() {\n                    return None;\n                }\n                let next = self.s.trim();\n                self.s = &#34;&#34;;\n                Some(next)\n            }\n        }\n    }\n}\n\n#[test]\nfn it_works() {\n    let s = &#34;This is the 1st sentence. This is the 2nd sentence.&#34;;\n    let mut iter = SentenceIter::new(&amp;s, &#39;.&#39;);\n    println!(&#34;{}&#34;, s);\n    assert_eq!(iter.next(), Some(&#34;This is the 1st sentence.&#34;));\n    assert_eq!(iter.next(), Some(&#34;This is the 2nd sentence.&#34;));\n    assert_eq!(iter.next(), None);\n}\n\nfn main() {\n    let s = &#34;a。 b。 c&#34;;\n    let sentences: Vec<_> = SentenceIter::new(s, &#39;。&#39;).collect();\n    println!(&#34;sentences: {:?}&#34;, sentences);\n}\n```","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1632928006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078927,"avatar":"","nickname":"linuxfish","note":"","ucode":"557F21A1CC7EAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400660,"discussion_content":"感觉这个写法更容易理解一些，s 不需要是 mut的，也不需要是 引用的引用。\n\nps，test里初始化 iter 时不需要传引用了：\n\nlet mut iter = SentenceIter::new(s, &#39;.&#39;);     ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633358074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314979,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1633620083,"is_pvip":false,"replies":[{"id":"114163","content":"对，我是说指向 vtable 的指针是放在类结构里的。文中最后 summary 的图里也是这个意思吧？","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633812429,"ip_address":"","comment_id":314979,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5928587379","product_id":100085301,"comment_content":"&gt; C++ &#47; Java 指向 vtable 的指针，在编译时放在类结构里，<br><br>现在C++的vtable也是分开放的 (可能看编译器, clang是分开的); <br><br>不过对 cpp, 对interface的实现大家都和original class definition放在一起. 没有试过在分开的文件中impl一个cpp的class的interface (parent inheritance). 可能也行, 但是不符合cpp的convention. <br><br>rust相对而言, 对某个类型的impl可以到处放.<br><br>```<br>vtable for Foo:<br>        .quad   0<br>        .quad   typeinfo for Foo    &#47;&#47; RTTI for foo<br>        .quad   Foo::method1()      &#47;&#47; where vtable starts<br>        .quad   Bar::method2()      &#47;&#47; for method2 in vtable<br>        .quad   Foo::~Foo() [complete object destructor]<br>        .quad   Foo::~Foo() [deleting destructor]<br>```<br><br>https:&#47;&#47;guihao-liang.github.io&#47;2020&#47;05&#47;30&#47;what-is-vtable-in-cpp","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527847,"discussion_content":"对，我是说指向 vtable 的指针是放在类结构里的。文中最后 summary 的图里也是这个意思吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633812429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313446,"user_name":"多少","can_delete":false,"product_type":"c1","uid":2547771,"ip_address":"","ucode":"0A6EF7AA6E4BB7","user_header":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","comment_is_top":false,"comment_ctime":1632446337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5927413633","product_id":100085301,"comment_content":"听音频总结部分有彩蛋哈哈","like_count":1},{"had_liked":false,"id":313095,"user_name":"夏洛克Moriaty","can_delete":false,"product_type":"c1","uid":2754785,"ip_address":"","ucode":"49BA020F04AB16","user_header":"https://static001.geekbang.org/account/avatar/00/2a/08/e1/b4748943.jpg","comment_is_top":false,"comment_ctime":1632277485,"is_pvip":false,"replies":[{"id":"113461","content":"👍<br>","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632357255,"ip_address":"","comment_id":313095,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5927244781","product_id":100085301,"comment_content":"今天内容很多，也很细，看来需要常来温故才行","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527226,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632357255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359805,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1474179,"ip_address":"北京","ucode":"76D8B165D6A424","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/83/c04e6b76.jpg","comment_is_top":false,"comment_ctime":1665914470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665914470","product_id":100085301,"comment_content":"请问 陈天老师，第4题，成员类型s: &amp;&#39;a mut &amp;&#39;a str,  我看写成 s: &amp;&#39;a str也可以， 像您那么写的好处是什么呢？","like_count":0},{"had_liked":false,"id":355146,"user_name":"Geek_e284c2","can_delete":false,"product_type":"c1","uid":3070339,"ip_address":"北京","ucode":"20718266BD50D5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/6xQSiaCXJUM56oosZbUtm7qM1M0QQd8c4Qov8BDZGGnpe6nU2v8MibP0GiaaBpibTbcXzItZrjBwibD7IadpDnlIqKA/132","comment_is_top":false,"comment_ctime":1661135965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661135965","product_id":100085301,"comment_content":"在基本 trait 这一小节中。<br>    关于把 trait 当成父类，实现 trait 的类型比做子类，那么有默认实现的方法相当于子类中可以重载但不是必须重载的方法。<br>    在Java和C++中方法的重载是具有相同的方法名，但是形参列表不同，可以对方法进行重载，而文中对应的重载应该是对应 Java&#47;C++ 中的函数重写，即子类型可以对父类型中的方法进行覆盖重写。<br>    然后导致我这里的理解有问题，所以这里应该是不是写错了，还是Rust中的重载与重写和Java中的不同。","like_count":0},{"had_liked":false,"id":350225,"user_name":"buoge","can_delete":false,"product_type":"c1","uid":1018506,"ip_address":"","ucode":"646FC6717A09BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/8a/7c1baa25.jpg","comment_is_top":false,"comment_ctime":1656670652,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656670652","product_id":100085301,"comment_content":"这一章 从早上上班，看到晚上下班 lol","like_count":0},{"had_liked":false,"id":337963,"user_name":"nuan","can_delete":false,"product_type":"c1","uid":2905523,"ip_address":"","ucode":"55FF98EB85404D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDqHQQByGiaXcAk94MdDn3ftupZLXyR6bAKibxOzMxy5h3uBwZ7QiaCiaIfbCMK0cIQfGNax8iawoiaQAg/132","comment_is_top":false,"comment_ctime":1647183586,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1647183586","product_id":100085301,"comment_content":"“self 在用作方法的第一个参数时，实际上是 self: Self 的简写”，没明白 self: Self 是什么。","like_count":0},{"had_liked":false,"id":331773,"user_name":"清风徐来","can_delete":false,"product_type":"c1","uid":1202697,"ip_address":"","ucode":"2AAA5B8DE30DF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/09/afa3e112.jpg","comment_is_top":false,"comment_ctime":1642755475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642755475","product_id":100085301,"comment_content":"老师的课程非常棒，一连看下来酣畅淋漓，从原理角度出发直接点题没有一句废话，非常对个人的胃口；回顾做开发这几年，遇到的一些技术学习泛泛而谈的倒是挺多，但是能把技术剖析到这种程度的不多，字里行间能看得出老师花了很多精力，多谢老师提供这么棒的学习资料。","like_count":0},{"had_liked":false,"id":331491,"user_name":"Digitalization","can_delete":false,"product_type":"c1","uid":1488654,"ip_address":"","ucode":"3596FAAF46D4D6","user_header":"https://static001.geekbang.org/account/avatar/00/16/b7/0e/739fd98a.jpg","comment_is_top":false,"comment_ctime":1642602321,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1642602321","product_id":100085301,"comment_content":"assert_eq!(u8::parse(&quot;1234abcd&quot;), 0);<br>是因为它是u8无法解析吗？具体是哪一步被干掉的？<br>","like_count":0,"discussions":[{"author":{"id":1079876,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9hlAIKQ1sGDu16oWLOHyCSicr18XibygQSMLMjuDvKk73deDlH9aMphFsj41WYJh121aniaqBLiaMNg/132","nickname":"腾达","note":"","ucode":"72F9CFBA44FDEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548041,"discussion_content":"1234 超过 u8最大能表达的 256","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643008209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326117,"user_name":"overheat","can_delete":false,"product_type":"c1","uid":2675695,"ip_address":"","ucode":"DD82D9194C26D0","user_header":"https://static001.geekbang.org/account/avatar/00/28/d3/ef/b3b88181.jpg","comment_is_top":false,"comment_ctime":1639385523,"is_pvip":true,"replies":[{"id":"118804","content":"谢谢！:)","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639804362,"ip_address":"","comment_id":326117,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639385523","product_id":100085301,"comment_content":"陈天老师的这部分是目前看到的最生动的教程，the book对有些内部机制bi而不谈，其他书面教程感觉我自己的语文没学好。我现在是看了第20章再回头看的，终于明白了trait object这个之前差不多直接跳过的概念。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539677,"discussion_content":"谢谢！:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639804362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321839,"user_name":"彭亚伦","can_delete":false,"product_type":"c1","uid":2425378,"ip_address":"","ucode":"77A32C73A23F72","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/22/19585900.jpg","comment_is_top":false,"comment_ctime":1637059511,"is_pvip":true,"replies":[{"id":"116882","content":"格式太乱，不好读。你可以贴 playground 链接","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1637077216,"ip_address":"","comment_id":321839,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637059511","product_id":100085301,"comment_content":"第四题, 用标准库里的`split_at`实现一个:<br><br>```rust<br>struct SentenceIter&lt;&#39;a&gt; {<br>    s: &amp;&#39;a mut &amp;&#39;a str,<br>    delimiter: char,<br>}<br><br>impl&lt;&#39;a&gt; SentenceIter&lt;&#39;a&gt; {<br>    pub fn new(s: &amp;&#39;a mut &amp;&#39;a str, delimiter: char) -&gt; Self {<br>        Self { s, delimiter }<br>    }<br>}<br><br>impl&lt;&#39;a&gt; Iterator for SentenceIter&lt;&#39;a&gt; {<br>    type Item = &amp;&#39;a str; <br><br>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>        if self.s.is_empty() {<br>            return None;<br>        }<br>        match self.s.find(self.delimiter) {<br>            Some(count) =&gt; {<br>                   &#47;&#47;标准库的split_at 方法<br>                let (first, last) = self.s.split_at(count + self.delimiter.len_utf8());<br>                *self.s = last.trim();  &#47;&#47;把self.s修改为split之后的后半部分<br>                return Some(first.trim());  &#47;&#47;返回前半部分<br>            }<br>            None =&gt; { &#47;&#47;处理没有找到的情况<br>                let s = (*self.s).trim();<br>                *self.s = &quot;&quot;;<br>                if s.is_empty() { &#47;&#47;如果此时s长度为0, 则返回None, 否则将s先trim之后返回<br>                    return None;<br>                } else {<br>                    return Some(s);<br>                }<br>            }<br>        }<br>    }<br>}<br><br>```","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530489,"discussion_content":"格式太乱，不好读。你可以贴 playground 链接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637077216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2425378,"avatar":"https://static001.geekbang.org/account/avatar/00/25/02/22/19585900.jpg","nickname":"彭亚伦","note":"","ucode":"77A32C73A23F72","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":530577,"discussion_content":"好的, 链接在这里, :)\nhttps://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=bf346d3f4571c5376e95ae572e3e2cb6 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637108447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":530489,"ip_address":""},"score":530577,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":320704,"user_name":"TheLudlows","can_delete":false,"product_type":"c1","uid":1069346,"ip_address":"","ucode":"64895727505014","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/22/d12f7a72.jpg","comment_is_top":false,"comment_ctime":1636461363,"is_pvip":false,"replies":[{"id":"116303","content":"Self: Sized 和关联类型无关，使用 Self 的时候，你需要用 Sized 约束。你可以看文中一开始的 Write trait。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636471852,"ip_address":"","comment_id":320704,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1636461363","product_id":100085301,"comment_content":"老师，为什么加了关联类型之后，需要用Sized对Self进行限定呢？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530087,"discussion_content":"Self: Sized 和关联类型无关，使用 Self 的时候，你需要用 Sized 约束。你可以看文中一开始的 Write trait。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636471852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2181012,"avatar":"https://static001.geekbang.org/account/avatar/00/21/47/94/46d6a079.jpg","nickname":"Siact","note":"","ucode":"0C294F4614D48C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556381,"discussion_content":"将Self 最为Resutl的泛型参数的时候,泛型参数需要大小确定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647335797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069346,"avatar":"https://static001.geekbang.org/account/avatar/00/10/51/22/d12f7a72.jpg","nickname":"TheLudlows","note":"","ucode":"64895727505014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413454,"discussion_content":"为什么Parse Trait中没有用Sized约束呢\npub trait Parse {\n  fn parse(s: &amp;str) -> Self;\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636472564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318620,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1635351495,"is_pvip":false,"replies":[{"id":"116409","content":"首先这里应该是 &amp;dyn Bar，其次，Bar 是一个 trait，它的类型是不确定的，而 &amp;T 是一个确定的类型，在编译时会根据使用编译成 Foo 或者其他类型。这是本质的区别。对于 trait，只能通过虚表来获得原始类型的能力和一些属性。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636558263,"ip_address":"","comment_id":318620,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635351495","product_id":100085301,"comment_content":"老师，这里关于静态分发和动态分发，有个例子没搞懂<br><br>#[drive(Debug)]<br>struct Foo;<br><br>trait Bar{<br>    fn baz(&amp;self);<br>}<br><br>impl Bar for Foo{<br>    fn baz(&amp;self) { println!(&quot;{:?}&quot;,self)};<br>}<br><br>fn static_dispatch&lt;T&gt;(t: &amp;T) where T:Bar{<br>    t.baz();<br>}<br><br>&#47;&#47;为什么这里是动态分发就无法确定类型大小<br>&#47;&#47;这里t也是限制为&amp;Bar对象呀.<br>fn dynamic_dispatch(t: &amp;Bar){<br>  t.baz();<br>}<br><br>这里不能理解的是动态分发，参数t也是要求为&amp;Bar的呀，那么这里到底和静态分发的核心区分是什么？凭什么就无法确定类型大小而需要用虚表呢？这个实在不太理解，多谢了。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529317,"discussion_content":"首先这里应该是 &amp;amp;dyn Bar，其次，Bar 是一个 trait，它的类型是不确定的，而 &amp;amp;T 是一个确定的类型，在编译时会根据使用编译成 Foo 或者其他类型。这是本质的区别。对于 trait，只能通过虚表来获得原始类型的能力和一些属性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636558263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317414,"user_name":"野山门","can_delete":false,"product_type":"c1","uid":1019276,"ip_address":"","ucode":"4430AF308209A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/8c/8e3d356c.jpg","comment_is_top":false,"comment_ctime":1634789178,"is_pvip":false,"replies":[{"id":"115239","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635121869,"ip_address":"","comment_id":317414,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634789178","product_id":100085301,"comment_content":"看大家的答案后，小小的改进了一下第四题：<br>```<br>impl&lt;&#39;a&gt; Iterator for SentenceIter&lt;&#39;a&gt; {<br>  type Item = &amp;&#39;a str; &#47;&#47; 想想 Item 应该是什么类型？<br><br>  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>    if self.s.trim().is_empty() {<br>      return None;<br>    }<br>    match self.s.find(self.delimiter) {<br>      None =&gt; {<br>        let s = self.s.trim();<br>        *self.s = &quot;&quot;;<br>        Some(s)<br>      }<br>      Some(i) =&gt; {<br>        let next_index = i + self.delimiter.len_utf8();<br>        let s = &amp;self.s[..next_index].trim();<br>        *self.s = &amp;self.s[next_index..];<br>        Some(s)<br>      }<br>    }<br>  }<br>}<br>```","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528807,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635121869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313476,"user_name":"码生笔谈","can_delete":false,"product_type":"c1","uid":1229329,"ip_address":"","ucode":"EBAD30BEE4E17D","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/11/323358ed.jpg","comment_is_top":false,"comment_ctime":1632455307,"is_pvip":false,"replies":[{"id":"113521","content":"这个写法并不好。Iterator 是懒接口，每次调用 next() 才做下一次的运算。你可以看看我之前的回复以及这个 playground 里的参考代码：playground：https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4590211f7542553e7feef960e814ab0b","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632464104,"ip_address":"","comment_id":313476,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1632455307","product_id":100085301,"comment_content":"第四题：<br><br>struct SentenceIter&lt;&#39;a&gt; {<br>    s: &amp;&#39;a mut &amp;&#39;a str,<br>    delimiter: char,<br>    splited: Vec&lt;&amp;&#39;a str&gt;,<br>    index: usize,<br>}<br><br>impl&lt;&#39;a&gt; SentenceIter&lt;&#39;a&gt; {<br>    pub fn new(s: &amp;&#39;a mut &amp;&#39;a str, delimiter: char) -&gt; Self {<br>        let splited: Vec&lt;&amp;&#39;a str&gt; = s.split_inclusive(delimiter).collect();<br>        Self {<br>            s,<br>            delimiter,<br>            splited,<br>            index: 0<br>        }<br>    }<br>}<br><br>impl&lt;&#39;a&gt; Iterator for SentenceIter&lt;&#39;a&gt; {<br>    type Item = &amp;&#39;a str; &#47;&#47; 想想 Item 应该是什么类型？<br><br>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>        if self.index &lt; self.splited.len() {<br>            let r = Some(self.splited[self.index].trim());<br>            self.index += 1;<br>            return r<br>        }<br>        None<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527364,"discussion_content":"这个写法并不好。Iterator 是懒接口，每次调用 next() 才做下一次的运算。你可以看看我之前的回复以及这个 playground 里的参考代码：playground：https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=4590211f7542553e7feef960e814ab0b","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632464104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577439,"discussion_content":"哈哈，不失为某些场景下的一个选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656117592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313280,"user_name":"记事本","can_delete":false,"product_type":"c1","uid":1401568,"ip_address":"","ucode":"FA942636EE0CC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","comment_is_top":false,"comment_ctime":1632363162,"is_pvip":false,"replies":[{"id":"113527","content":"具备强大的抽象能力是件好事","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632464583,"ip_address":"","comment_id":313280,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632363162","product_id":100085301,"comment_content":"rust泛型真的太抽象了","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527301,"discussion_content":"具备强大的抽象能力是件好事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632464583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313157,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1632299201,"is_pvip":false,"replies":[{"id":"113470","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632358132,"ip_address":"","comment_id":313157,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1632299201","product_id":100085301,"comment_content":"“如果不提供泛型参数，那么加号右值和左值都要是相同的类型。”，解决了我根据前一节内容看到“impl Add&lt;&amp;str&gt; for String”的困惑，这种感觉真的舒服，你仔细琢磨的问题，不明白的，老师下节课就告诉你了。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527251,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632358132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313123,"user_name":"hughieyu","can_delete":false,"product_type":"c1","uid":1206690,"ip_address":"","ucode":"FC1A64B2BAB784","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/a2/c30ac459.jpg","comment_is_top":false,"comment_ctime":1632287545,"is_pvip":false,"replies":[{"id":"113465","content":"1&#47;2&#47;3 正确。4 需要考虑 main() 中的场景，要处理不带 delimiter 的后续部分，可以看我之前的回答。<br><br>trait 泛型是对同一个数据结构你需要有多个不同的实现，trait 的关联类型是，在某个实现里，我需要设定和这个实现相关的类型。其实关联类型就和关联函数一样的。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632357825,"ip_address":"","comment_id":313123,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632287545","product_id":100085301,"comment_content":"1. 不可以。 Complex不能实现Add多次，只能实现对一种类型的计算。<br>2. 不能。 对于trait object来说， Self信息已经被擦除了。<br>3. #[derive(Debug, Copy, Clone)] 或者 用自定义类型包装Rc实现Add 如RcComplex(Rc&lt;Complex&gt;)<br>4. impl&lt;&#39;a&gt; Iterator for SentenceIter&lt;&#39;a&gt; {<br>    type Item = &amp;&#39;a str; &#47;&#47; 想想 Item 应该是什么类型？<br><br>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>       match self.s.find(self.delimiter) {<br>           None =&gt; None,<br>           Some(idx) =&gt; {<br>               let slice = &amp;self.s[..idx+self.delimiter.len_utf8()];<br>                *self.s = &amp;self.s[idx+self.delimiter.len_utf8()..];<br><br>                match slice.as_bytes().iter().enumerate().find(|(_,b)|**b != b&#39; &#39;){<br>                    None =&gt; None,<br>                    Some((start,_)) =&gt; Some(&amp;slice[start..]),<br>                }<br>           }<br>       }<br>    }<br>}<br><br>问题： trait泛型和关联类型的使用场景还是有些模糊","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527239,"discussion_content":"1/2/3 正确。4 需要考虑 main() 中的场景，要处理不带 delimiter 的后续部分，可以看我之前的回答。\n\ntrait 泛型是对同一个数据结构你需要有多个不同的实现，trait 的关联类型是，在某个实现里，我需要设定和这个实现相关的类型。其实关联类型就和关联函数一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632357825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}