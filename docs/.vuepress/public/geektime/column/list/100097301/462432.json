{"id":462432,"title":"09 | 异常恢复，付出的代价能不能少一点？","content":"<p>你好，我是范学雷。今天，我们接着讨论Java的错误处理。这一讲，是上一次我们讨论的关于错误处理问题的继续和升级。</p><p>就像我们上一次讨论到的，Java的异常处理是一个对代码性能有着重要影响的因素。所以说，Java错误处理的缺陷和滥用也成为了一个热度始终不减的老话题。但是，Java的异常处理，有着天生的优势，特别是它在错误排查方面的作用，我们很难找到合适的替代方案。</p><p>那有没有可能改进Java的异常处理，保持它在错误排查方面的优势的同时，提高它的性能呢？这是一个又让马儿跑，又让马儿不吃草的问题。不过，这并不妨碍我们顺着这个思路，找一找其中的可能性。</p><p>我们还是先从阅读案例开始，来试着找一找其中的蛛丝马迹吧。</p><h2>阅读案例</h2><p>要尝试解决一个问题，我们首先要做的，就是把问题梳理清楚，定义好。我们先来看看Java异常处理的三个典型使用场景。</p><p>下面的这段代码里，有三个不同的异常使用方法。在分别解析的过程中，你可能会遇到几个疑问，不过别急，带着这几个问题，我们最后来一一解读。</p><pre><code class=\"language-java\">package co.ivi.jus.stack.former;\n\nimport java.security.NoSuchAlgorithmException;\n\npublic class UseCase {\n    public static void main(String[] args) {\n        String[] algorithms = {\"SHA-128\", \"SHA-192\"};\n        \n        String availableAlgorithm = null;\n        for (String algorithm : algorithms) {\n            Digest md;\n            try {\n                md = Digest.of(algorithm);\n            } catch (NoSuchAlgorithmException ex) {\n                // ignore, continue to use the next algorithm.\n                continue;\n            }\n            \n            try {\n                md.digest(\"Hello, world!\".getBytes());\n            } catch (Exception ex) {\n                System.getLogger(\"co.ivi.jus.stack.former\")\n                        .log(System.Logger.Level.WARNING,\n                             algorithm + \" does not work\",\n                             ex);\n                continue;\n            }\n            \n            availableAlgorithm = algorithm;\n        }\n        \n        if (availableAlgorithm != null) {\n            System.out.println(availableAlgorithm + \" is available\");\n        } else {\n            throw new RuntimeException(\"No available hash algorithm\");\n        }\n    }\n}\n</code></pre><!-- [[[read_end]]] --><h3>可恢复异常</h3><p>第一种就是可恢复的异常处理。</p><p>这是什么意思呢？对于代码里的异常NoSuchAlgorithmException来说，这段代码尝试捕获、识别这个异常，然后再从异常里恢复过来，继续执行代码。我们把这种可以从异常里恢复过来，继续执行的异常处理叫做可恢复的异常处理，简称为可恢复异常。</p><p>为了深入理解可恢复异常，我们需要仔细地看看NoSuchAlgorithmException这个异常的处理过程。这个处理的过程，其实就只有一行有效的代码，也就是catch语句。</p><pre><code class=\"language-java\">} catch (NoSuchAlgorithmException nsae) {\n    // ignore, continue to use the next algorithm.\n}\n</code></pre><p>只要catch语句能够捕获、识别到这个异常，这个异常的生命周期就结束了。catch只需要知道异常的名字，而不需要知道异常的调用堆栈。不使用异常的调用堆栈，也就意味着这样的异常处理，极大地消弱了Java异常在错误排查方面的作用。</p><p><strong>既然可恢复异常不使用异常的调用堆栈，是不是可恢复异常就不需要生成调用堆栈了呢？这是我们提出的第一个问题。</strong></p><p>从Java异常的性能基准测试结果看，我们知道，生成异常的调用堆栈是异常处理影响性能的最主要因素。如果不需要生成调用堆栈，那么Java异常的处理性能就会有成百上千倍的提升。所以，如果我们找到了第一个问题的答案，我们就解决了可恢复异常的性能瓶颈。</p><h3>不可恢复异常</h3><p>好了，我们再回头看看第二个使用场景。对于代码里的异常RuntimeException来说，上面的代码并没有尝试捕获、识别它。这个异常直接导致了程序的退出，并且把异常的信息和调用堆栈打印了出来。</p><pre><code class=\"language-java\">Exception in thread \"main\" java.lang.RuntimeException: No available hash algorithm\n\tat co.ivi.jus.stack.former.UseCase.main(UseCase.java:27)\n</code></pre><p>这样的异常处理方式导致了程序的中断，程序不能从异常抛出的地方恢复过来。我们把这种方式，叫做不可恢复的异常处理，简称为不可恢复异常。</p><p>调用堆栈对于不可恢复异常来说至关重要，因为我们可以从异常调用堆栈的打印信息里，快速定位到出问题的代码。毫无疑问，这加快了问题排查，降低了运维的成本。</p><p>由于不可恢复异常中断了程序的运行，所以它的性能开销是一次性的。因此，不可恢复异常对于性能的影响，其实我们不用太在意。</p><p>使用了异常信息和调用堆栈，又不用担心性能的影响，不可恢复异常似乎很理想。可是，在多大的程度上，我们可以允许程序由于异常中断而退出呢？这是一个很难回答的问题。</p><p>试想一下，如果是作为服务器的程序，我们会希望它能一直运行，遇到异常能够恢复过来。所以一般情况下，服务器的场景下，不会使用不可恢复异常。</p><p>现在的客户端程序呢？比如手机里的app，如果遇到异常就崩溃，我们就不会有耐心继续使用了。似乎，客户端的程序，也没有多少不可恢复异常的使用场景。</p><p>也许，不可恢复异常的使用场景，仅仅存在于我们的演示程序里。高质量的产品里，似乎很难允许不可恢复异常的存在。</p><p><strong>既然我们无法忍受程序的崩溃，那么不可恢复异常还有存在的必要吗？这是我们提出的第二个问题。</strong></p><h3>记录的调试信息</h3><p>最后，我们再来看看第三个使用场景。对于代码里的异常Exception来说，这段代码尝试捕获、识别这个异常，然后从异常里恢复过来继续执行代码。它是一个可恢复的异常。和第一个场景不同的是，这段代码还在日志里记录了下了这个异常；一般来说，这个异常的调试信息，也就是异常信息和调用堆栈，也会被详细地记载在日志里。</p><p>其实，这也是可恢复异常的一个典型的使用场景；程序可以恢复，但是异常信息可以记录待查。</p><p>我们再来仔细看看异常信息是怎么记录在案的。为了方便我们观察，我把日志记录的这几行代码单独摘抄了出来。</p><pre><code class=\"language-java\">System.getLogger(\"co.ivi.jus.stack.former\")\n        .log(System.Logger.Level.WARNING,\n             algorithm + \" does not work\",\n             ex);\n</code></pre><p>我们可以看到，日志记录下来了如下的关键信息：</p><ol>\n<li>在异常捕获的场景下，这个异常的记录方式，包括是否记录（“co.ivi.jus.stack.former”）；</li>\n<li>在异常捕获的场景下，这个异常的记录地点（System.getLogger()）；</li>\n<li>在异常捕获的场景下，这个异常的严重程度（Logger.Level）；</li>\n<li>在异常捕获的场景下，这个异常表示的影响（“[algorithm] does not work”）；</li>\n<li>异常生成的时候携带的信息，包括异常信息和调用堆栈（ex）。</li>\n</ol><p>其中，前四项信息，是在方法调用的代码里生成的；第五项，是在方法实现的代码里生成的。也就是说，记录在案的调试信息，既包括调用代码的信息，也包括实现代码的信息。</p><p><strong>如果放弃了Java的异常处理机制，我们还能够获得足够的调试信息吗？换种说法，我们有没有快速定位问题的替代方案？这是我们提出的第三个问题。</strong></p><h2>改进的共用错误码</h2><p>刚才，我们通过Java异常处理的三个典型场景，提出了三个棘手的问题：</p><ul>\n<li>既然可恢复异常不使用异常的调用堆栈，是不是可恢复异常就不需要生成调用堆栈了？</li>\n<li>既然我们无法忍受程序的崩溃，那么不可恢复异常还有存在的必要吗？</li>\n<li>我们有没有快速定位问题的替代方案？</li>\n</ul><p>带着这三个问题，我们再来看看能不能改进一下我们上一讲里讨论的共用错误码的方案。</p><p>共用错误码本身，并没有携带调试信息。为了能够快速定位出问题，我们需要为共用错误码的方案补上调试信息。</p><p>下面的两段代码，就是我们要在补充调试信息方面做的尝试。第一段代码，是我们在方法实现的代码里的尝试。在这段代码里，我们使用异常的形式补充了调试信息，包括问题描述和调用堆栈。</p><pre><code class=\"language-java\">public static Returned&lt;Digest&gt; of(String algorithm) {\n    return switch (algorithm) {\n        case \"SHA-256\" -&gt; new Returned.ReturnValue(new SHA256());\n        case \"SHA-512\" -&gt; new Returned.ReturnValue(new SHA512());\n        case null -&gt; {\n            System.getLogger(\"co.ivi.jus.stack.union\")\n                    .log(System.Logger.Level.WARNING,\n                        \"No algorithm is specified\",\n                        new Throwable(\"the calling stack\"));\n            yield new Returned.ErrorCode(-1);\n        }\n        default -&gt; {\n            System.getLogger(\"co.ivi.jus.stack.union\")\n                    .log(System.Logger.Level.INFO,\n                    \"Unknown algorithm is specified \" + algorithm,\n                            new Throwable(\"the calling stack\"));\n            yield new Returned.ErrorCode(-1);\n        }\n    };\n}\n</code></pre><p>第二段代码，是我们在方法调用的代码里的尝试。在这段代码里，我们补充了调用场景的信息。</p><pre><code class=\"language-java\">Returned&lt;Digest&gt; rt = Digest.of(\"SHA-128\");\nswitch (rt) {\n    case Returned.ReturnValue rv -&gt; {\n            Digest d = (Digest) rv.returnValue();\n            d.digest(\"Hello, world!\".getBytes());\n        }\n    case Returned.ErrorCode ec -&gt;\n        System.getLogger(\"co.ivi.jus.stack.union\")\n                .log(System.Logger.Level.INFO,\n                        \"Failed to get instance of SHA-128\");\n}\n</code></pre><p>经过这样的调整，类似于使用异常处理的、快速定位出问题的调试信息就又回来了。</p><pre><code class=\"language-java\">Nov 05, 2021 10:08:23 PM co.ivi.jus.stack.union.Digest of\nINFO: Unknown algorithm is specified SHA-128\njava.lang.Throwable: the calling stack\n\tat co.ivi.jus.stack.union.Digest.of(Digest.java:37)\n\tat co.ivi.jus.stack.union.UseCase.main(UseCase.java:10)\n\nNov 05, 2021 10:08:23 PM co.ivi.jus.stack.union.UseCase main\nINFO: Failed to get instance of SHA-128\n</code></pre><p>你一定会有这样的问题。调试信息又回来了，难道不是以性能损失为代价的吗？</p><p>是的，使用调试信息带来的性能损失，并不比使用异常性能的损失小多少。不过好在，日志记录既可以开启，又可以关闭。如果我们关闭了日志，就不用再生成调试信息了，当然它的性能影响也就消失了。当需要我们定位问题的时候，再启动日志。这时候，我们就能够把性能的影响控制到一个极小的范围内了。</p><p>那么，使用错误码的错误处理方案，是怎么处理我们在阅读案例提到的问题的呢？</p><p>其实，每一个问题的处理，都很清晰。我把问题和答案都列在了下面的表格里，你可以看一看。</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/ce/acdd47e9e5d310007aa505d45f63fbce.jpg?wh=1920x769\" alt=\"图片\"></p><p>当然，日志并不是唯一可以记录调试信息的方式。比如说，我们还可以使用更便捷的JFR（Java Flight Recorder）特性。</p><p>其实，错误码的调试信息使用方式，更符合调试的目的：只有需要调试的时候，才会生成调试信息。那么，<strong>如果继续沿用Java的异常处理机制，调试信息能不能按需开启、关闭呢？这是我们今天的第四个问题，也是提给Java语言设计师的问题。</strong></p><p>有了今天这四个问题做铺垫，如果有一天， Java语言的异常能够支持可以开合的异常处理机制了，想必到时候你就不会感到惊讶了。</p><h2>总结</h2><p>好，到这里，我来做个小结。刚才，我们了解和讨论了Java异常处理的两个概念：可恢复异常和不可恢复异常。我还给出了在使用错误码的场景下，快速定位问题的替代方案。</p><p>这一讲我们并没有讨论新特性，而是我们重点讨论了现在Java异常处理机制的几个热门话题。这节课的重点，是要开拓我们的思维。了解这些热门的话题，不仅可以增加你的谈资，还可以切实地提高你的代码性能和可维护性。</p><p>另外，我还拎出了几个今天讨论过的技术要点，这些都可能在你的面试中出现哦。通过这一次学习，你应该能够：</p><ul>\n<li>了解可恢复异常和不可恢复异常这两个概念，以及它们的使用场景；\n<ul>\n<li>面试问题：你的代码是怎么处理Java异常的？</li>\n</ul>\n</li>\n<li>了解怎么在使用错误码的方案里，添加快速定位出问题的调试信息；\n<ul>\n<li>面试问题：你的代码，是怎么定位可能存在的问题的？</li>\n</ul>\n</li>\n</ul><p>对Java错误处理机制的改进，这会是一个持续热门的话题。而能够了解替代方案，并且使用替代方案的软件工程师，现在还不多。如果你能够展示错误处理的替代方案，而且还不牺牲异常处理的优势，这是一个能够在面试里获得主动权，控制话语权的必杀技。</p><h2>思考题</h2><p>怎么通过改进Java的异常处理，来获取性能的提升，我们已经花了两讲的时间了。我们提出的这些改进方案，其实依然有很大的提升空间。比如说吧，我们使用了整数表示错误码，这里其实就存在很多问题。</p><p>因为有时候，我们可能需要区别不同的错误，这样我们就不能总是使用一个错误码（-1）。如果存在多个错误码，我们怎么知道方法实现的代码返回的错误码是什么呢？编译器能不能帮助我们检查错误码的使用是不是匹配？ 比如说错误码的检查有没有遗漏，有没有多余？如果返回的错误码从两个增加到三个，使用该方法的代码能不能自动地检测到？</p><p>解决好这些问题，能够大幅度提高代码的可维护性和健壮性。该怎么解决掉这些问题呢？这是我们今天的思考题。</p><p>为了方便你阅读，我把需要两个错误码的案例代码放在了下面。一段代码是方法实现的代码，一段代码是方法使用的代码。你可以在这两段代码的基础上改动，看看最后你是怎么处理多个错误码的。</p><p>这一段是方法实现的代码。</p><pre><code class=\"language-java\">public static Returned&lt;Digest&gt; of(String algorithm) {\n    return switch (algorithm) {\n        case \"SHA-256\" -&gt; new Returned.ReturnValue(new SHA256());\n        case \"SHA-512\" -&gt; new Returned.ReturnValue(new SHA512());\n        case null -&gt; {\n            System.getLogger(\"co.ivi.jus.stack.union\")\n                    .log(System.Logger.Level.WARNING,\n                        \"No algorithm is specified\",\n                        new Throwable(\"the calling stack\"));\n            yield new Returned.ErrorCode(-1);\n        }\n        default -&gt; {\n            System.getLogger(\"co.ivi.jus.stack.union\")\n                    .log(System.Logger.Level.INFO,\n                    \"Unknown algorithm is specified \" + algorithm,\n                            new Throwable(\"the calling stack\"));\n            yield new Returned.ErrorCode(-2);\n        }\n    };\n}\n</code></pre><p>这一段是方法使用的代码。</p><pre><code class=\"language-java\">Returned&lt;Digest&gt; rt = Digest.of(\"SHA-128\");\nswitch (rt) {\n    case Returned.ReturnValue rv -&gt; {\n            Digest d = (Digest) rv.returnValue();\n            d.digest(\"Hello, world!\".getBytes());\n        }\n    case Returned.ErrorCode ec -&gt; {\n        if (ec.errorCode() == -1) {\n            System.getLogger(\"co.ivi.jus.stack.union\")\n                    .log(System.Logger.Level.INFO,\n                            \"Unlikedly to happen\");\n        } else {\n            System.getLogger(\"co.ivi.jus.stack.union\")\n                    .log(System.Logger.Level.INFO,\n                            \"SHA-218 is not supported\");\n        }\n    }\n}\n</code></pre><p>欢迎你在留言区留言、讨论，分享你的阅读体验以及验证的代码和结果。我们下节课再见！</p><p>注：本文使用的完整的代码可以从<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/stack\">GitHub</a>下载，你可以通过修改<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/stack\">GitHub</a>上<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/stack/review/xuelei\">review template</a>代码，完成这次的思考题。如果你想要分享你的修改或者想听听评审的意见，请提交一个 GitHub的拉取请求（Pull Request），并把拉取请求的地址贴到留言里。这一小节的拉取请求代码，请在<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/stack/review\">异常恢复专用的代码评审目录</a>下，建一个以你的名字命名的子目录，代码放到你专有的子目录里。比如，我的代码，就放在stack/review/xuelei的目录下面。</p>","neighbors":{"left":{"article_title":"08 | 抛出异常，是不是错误处理的第一选择？","id":461630},"right":{"article_title":"10 | Flow，是异步编程的终极选择吗？","id":464209}},"comments":[{"had_liked":false,"id":324655,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1638529228,"is_pvip":false,"replies":[{"id":"117810","content":"是一个好思路，学习了。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638549627,"ip_address":"","comment_id":324655,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23113365708","product_id":100097301,"comment_content":"调试信息能不能按需开启、关闭呢？<br><br>可以，成本比较大。举个例子。<br><br>1.实现生产环境一键镜像，难点是要包含生产所有数据（知识级与操作级都要）<br>2.基于OpenTelemetry把日志打印齐全<br>3.基于观测数据做链路可视化界面<br>4.链路可视化界面支持请求向不同环境重放(入参已有，不过是调指定环境的接口)<br><br>如此一来测试环境就拥有和生产环境一模一样的，你不仅可以在测试环境打印debug日志，还可以直接debug。<br><br>","like_count":5,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535833,"discussion_content":"是一个好思路，学习了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638549627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324585,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1638510764,"is_pvip":false,"replies":[{"id":"117779","content":"哈哈，编程语言本质上都是处理类似的问题，只是设计者的偏好可能不同。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638520662,"ip_address":"","comment_id":324585,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5933478060","product_id":100097301,"comment_content":"这么巧！昨天刚看到 Go 语言处理异常的四种方式，有一种可以参考《Tony Bai · Go 语言第一课》| 22｜函数：怎么结合多返回值进行错误处理？原文链接：https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;461821<br><br>策略四：错误行为特征检视策略<br>在 Go 标准库中，我们发现了这样一种错误处理方式：将某个包中的错误类型归类，统一提取出一些公共的错误行为特征，并将这些错误行为特征放入一个公开的接口类型中。这种方式也被叫做错误行为特征检视策略。<br><br>以标准库中的net包为例，它将包内的所有错误类型的公共行为特征抽象并放入net.Error这个接口中，如下面代码：<br><br>```go<br><br>&#47;&#47; $GOROOT&#47;src&#47;net&#47;net.go<br>type Error interface {<br>    error<br>    Timeout() bool  &#47;&#47; 断网、断电、网络拥堵、丢包等都可以造成超时<br>    Temporary() bool<br>}<br>```<br><br>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。策略四将稀奇古怪的错误信息进行了抽象分类，将无限种可能转换成了有限种可能（将不可控转换成可控），遵循了开闭原则。<br><br>再回顾本专栏《深入剖析 Java 新特性》04 | 封闭类：怎么刹住失控的扩展性？中提到的怎么判断一个图形是正方形的例子可以帮助理解：特殊的长方形、菱形、梯形、多边形等都是正方形<br>","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535699,"discussion_content":"哈哈，编程语言本质上都是处理类似的问题，只是设计者的偏好可能不同。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638520662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359291,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1665393319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665393319","product_id":100097301,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":359165,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"美国","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1665299018,"is_pvip":false,"replies":[{"id":"130695","content":"一般情况下一次就行。不过有时候，方法的使用需要更好地控制日志信息，也可能会多次输出。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1665426335,"ip_address":"美国","comment_id":359165,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1665299018","product_id":100097301,"comment_content":"老师，方法实现和方法使用为啥输出两遍日志呢，方法实现里面输出一次不就行了","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589981,"discussion_content":"一般情况下一次就行。不过有时候，方法的使用需要更好地控制日志信息，也可能会多次输出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665426335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"美国"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325973,"user_name":"fatme","can_delete":false,"product_type":"c1","uid":1034451,"ip_address":"","ucode":"75A805D2BB2AD1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","comment_is_top":false,"comment_ctime":1639285143,"is_pvip":false,"replies":[{"id":"118261","content":"主要是生成堆栈信息的开销，向上抛的开销要小很多，除非中间有截获代码。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1639334062,"ip_address":"","comment_id":325973,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639285143","product_id":100097301,"comment_content":"老师，对于使用异常的情况。造成其性能下降的原因，是否应该包括两部分活动：一是生成调用栈的调试信息；另一个是把异常沿调用栈向上抛出，直到被捕捉或终止程序？如果是的话，其中哪一个部分造成的性能损耗更厉害呢？","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538135,"discussion_content":"主要是生成堆栈信息的开销，向上抛的开销要小很多，除非中间有截获代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639334062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324964,"user_name":"零__轨迹","can_delete":false,"product_type":"c1","uid":1228920,"ip_address":"","ucode":"F6143ABE4543C5","user_header":"https://static001.geekbang.org/account/avatar/00/12/c0/78/d01640b5.jpg","comment_is_top":false,"comment_ctime":1638760042,"is_pvip":true,"replies":[{"id":"117892","content":"没有明白这个问题是什么意思？ 能描述的详细一些吗，或者举个例子？","user_name":"作者回复","user_name_real":"作者","uid":"1111315","ctime":1638762040,"ip_address":"","comment_id":324964,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1638760042","product_id":100097301,"comment_content":"请问老师，参考函数式中的Try来封装有异常的执行结果对官方来说是否可行呢？","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536337,"discussion_content":"没有明白这个问题是什么意思？ 能描述的详细一些吗，或者举个例子？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638762040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537323,"discussion_content":"“对官方来说”这样的说法有点别扭，JDK编译能通过的，都是语法合规的。提问题不用客气，直接来就行。 \n\n个人理解，上面Try的设计，有很多问题，这些问题我们第8和第9讲里也有对应的讨论。一般情况下，返回异常不是一个好办法，也不常见，即没有性能的优化，又让代码变得很繁杂。另外，Try的设计，用起来很容易出错，需要编码纪律约束。而好的设计，是不需要纪律约束，而是编译器强制性的禁止。不过，这个设计也有它的使用场景，比如说下一层的类库使用了异常，而我们能控制的这一层不想使用异常，那就找一个办法折衷，这样就可以整合了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639033891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228920,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/78/d01640b5.jpg","nickname":"零__轨迹","note":"","ucode":"F6143ABE4543C5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536352,"discussion_content":"和 Optional 类似，将执行结果封装在一个容器中，或者是 Scala 中的 Try\nclass Try[T] {\n  // 如果有执行结果则 result 非空\n  T result;\n  // 如果有异常则 e 非空\n  Throwable e;\n  // 类似 orElse 等方法支持异常处理, 而不是抛出异常\n}\n// 作为返回值\npublic Try[T] doSomething() {}\n水平有限，请老师指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638766686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324586,"user_name":"bigben","can_delete":false,"product_type":"c1","uid":1169313,"ip_address":"","ucode":"DBD15A6C8E2590","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkeOAC8k7aPMfQZ4ickiavpfR9mTQs1wGhGtIicotzAoszE5qkLfFTabkDU2E39ovSgoibJ1IiaLXtGicg/132","comment_is_top":false,"comment_ctime":1638510819,"is_pvip":false,"replies":[{"id":"117778","content":"1、是的，我在代码里忽视了这个问题。“new Throwable”应该在日志启用的情况下调用，而不是总是被调用。<br>2、是的，这里的调试信息关闭，需要特殊的代码处理，而且性能的影响依然很大（我忘记是数十倍还是数百倍了，不过不再是几千倍的水平了）。我们期望的，是不需要更改代码的，几乎没有性能影响的改进。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638520562,"ip_address":"","comment_id":324586,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1638510819","product_id":100097301,"comment_content":"1、System.getLogger(&quot;co.ivi.jus.stack.union&quot;) .log(System.Logger.Level.INFO, &quot;Unknown algorithm is specified &quot; + algorithm, new Throwable(&quot;the calling stack&quot;));<br>这个把日志关掉也不能提高多少性能，new Throwable(&quot;the calling stack&quot;)总是要收集堆栈信息的；<br>2、如果继续沿用 Java 的异常处理机制，调试信息可以按需开启、关闭吧，Throwable(String message, Throwable cause,<br>                        boolean enableSuppression,<br>                        boolean writableStackTrace)","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535697,"discussion_content":"1、是的，我在代码里忽视了这个问题。“new Throwable”应该在日志启用的情况下调用，而不是总是被调用。\n2、是的，这里的调试信息关闭，需要特殊的代码处理，而且性能的影响依然很大（我忘记是数十倍还是数百倍了，不过不再是几千倍的水平了）。我们期望的，是不需要更改代码的，几乎没有性能影响的改进。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638520562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":535794,"discussion_content":"想请问下大佬，怎样只在日志启用的情况下调用Throwable创建？代码怎样写呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638541075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":535697,"ip_address":""},"score":535794,"extra":""},{"author":{"id":1993603,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/6b/83/5fb44cd0.jpg","nickname":"Jagger Chen","note":"","ucode":"7C6ACBCF32ED12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537162,"discussion_content":"通过控制日志级别可以吗？if (enableDebug()) {}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638974913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":535794,"ip_address":""},"score":537162,"extra":""},{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1993603,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/6b/83/5fb44cd0.jpg","nickname":"Jagger Chen","note":"","ucode":"7C6ACBCF32ED12","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537326,"discussion_content":"我一般是检查日志是否启用，然后才调用日志的相关接口。也就是你说的if (debug enabled) { ... }.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639034009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537162,"ip_address":""},"score":537326,"extra":""}]}]},{"had_liked":false,"id":324582,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","comment_is_top":false,"comment_ctime":1638510293,"is_pvip":false,"replies":[{"id":"117813","content":"嗯，这是一个很好的思路。要是能解决更大范围内的适用性，就更好了。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638594156,"ip_address":"","comment_id":324582,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638510293","product_id":100097301,"comment_content":"思考题我把 ErrorCode 许可类改成了枚举，至于编译器检测使用匹配（遗漏或多余），则是使用 switch 表达式，PR 在：https:&#47;&#47;github.com&#47;XueleiFan&#47;java-up&#47;pull&#47;16","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535892,"discussion_content":"嗯，这是一个很好的思路。要是能解决更大范围内的适用性，就更好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638594156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324555,"user_name":"哦吼掉了","can_delete":false,"product_type":"c1","uid":1232599,"ip_address":"","ucode":"1F89B1BA1EEF52","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/d7/8168e1bf.jpg","comment_is_top":false,"comment_ctime":1638500193,"is_pvip":true,"replies":[{"id":"117780","content":"想提交一个GitHub的PR吗？","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638520712,"ip_address":"","comment_id":324555,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638500193","product_id":100097301,"comment_content":"感觉写的比较冗杂，希望各路大神指点下<br>Result rt = Digest.of(&quot;SHA-256&quot;);<br>switch (rt) {<br>    case Result.ErrorCode e -&gt; {<br>        switch (e.errorCode){<br>            case -1-&gt; System.out.println(&quot;algorithm is null&quot;);<br>            case -2-&gt; System.out.println(&quot;algorithm is not support&quot;);<br>            default -&gt; {<br>                &#47;&#47; other errorCode<br>            }<br>        }<br>    }<br>    case Result.ReturnValue rv -&gt; {<br>        switch (rv.returnValue){<br>            case Digest d -&gt; d.digest(&quot;Hello, world!&quot;.getBytes());<br>            default -&gt; {<br>                &#47;&#47; other type process<br>            }<br>        }<br>    }<br>    default -&gt; {<br>        &#47;&#47; other permit class<br>    }<br>};<br>","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535700,"discussion_content":"想提交一个GitHub的PR吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638520712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324516,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1638484445,"is_pvip":false,"replies":[{"id":"117770","content":"是一个思路。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638502424,"ip_address":"","comment_id":324516,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638484445","product_id":100097301,"comment_content":"感觉应该用switch表达式来穷举error code","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535647,"discussion_content":"是一个思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638502424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}