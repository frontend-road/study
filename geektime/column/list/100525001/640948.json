{"id":640948,"title":"16｜技术栈更新：消息组件Kotlin+MVVM重构","content":"<p>你好，我是黄俊彬。</p><p>随着项目不断的迭代，新的技术栈也会持续不断地演进。适时使用新的技术栈，可以帮助我们提高效率以及代码质量。这节课，我们就一起来学习如何安全高效地为遗留系统升级技术栈，具体我们会使用新的语言Kotlin以及新的架构模式MVVM，来重构消息组件。</p><p>选择Kotlin + MVVM，有两方面考量：一方面，Kotlin从框架层面提供了大量的封装，可以帮我们减少工作量，无需编写大量的模板代码；另一方面，<a href=\"https://developer.android.com/kotlin\">Kotlin也是官方推荐的开发语言</a>，MVVM框架则是官方推荐的分层架构，为此 <a href=\"https://developer.android.com/jetpack\">JetPack</a> 也专门提供了相应的框架组件支持快速开发。</p><p>不过技术栈不同了，流程方法仍然相同，这里我们会继续使用组件内分层重构的方法。</p><h2>准备：支持Kotlin</h2><p>对于遗留系统来说，通常使用的开发语言都是Java，那么在选择Kotlin语言时，我们通常会有2种选择：第一种是Kotlin与Java语言混编，另外一种是完全使用Kotlin替换Java。</p><p>至于哪种方式更好，它们之间有什么差异？我们结合例子来分析一下。</p><p>第一种方法使用Java与Kotlin混编，这个做法的好处是我们不需要改动原来的代码，只需要用Kotlin语言编写扩展的代码就可以了。但是缺点就是由于Kotlin的语言高度依赖编辑器生成转换代码，所以有些语法通过Java来调用Kotlin会比较啰嗦，例如伴生函数的调用。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">//定义\nclass KotlinClass {\n&nbsp; &nbsp; companion object {\n&nbsp; &nbsp; &nbsp; &nbsp; fun doWork() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* … */\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\n//使用Kotlin调用Kotlin\nKotlinClass.doWork();\n\n//使用Java调用Kotlin（方式一）\npublic final class JavaClass {\n&nbsp; &nbsp; public static void main(String... args) {\n&nbsp; &nbsp; &nbsp; &nbsp; KotlinClass.Companion.doWork();\n&nbsp; &nbsp; }\n}\n\n//使用Java调用Kotlin（方式二）\nclass KotlinClass {\n&nbsp; &nbsp; companion object {\n&nbsp; &nbsp; &nbsp; &nbsp; @JvmStatic fun doWork() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* … */\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\npublic final class JavaClass {\n&nbsp; &nbsp; public static void main(String... args) {\n&nbsp; &nbsp; &nbsp; &nbsp; KotlinClass.doWork();\n&nbsp; &nbsp; }\n}\n</code></pre><p>从例子可以看出，虽然我们可以通过@JvmStatic注解来简化调用，但是始终没有Kotlin调用Kotlin那么方便。</p><p>第二种方法使用Kotlin替换Java的好处就是，可以减少一些跨语言调用编写问题，但是缺点是需要将原有的代码改动成Kotlin。好在官方也提供了将Java语言转换为Kotlin语言的功能，转换起来很方便。</p><p>对于Sharing项目来说，我们已经覆盖了基本的自动化测试功能，可以在转换后进行验证，所以这里我们采用将Java代码替换成Kotlin代码的方式，具体的操作你可以参考后面的图片。</p><p><img src=\"https://static001.geekbang.org/resource/image/18/3f/18097ed6002ae420f8879d7243e1ef3f.jpg?wh=2375x1821\" alt=\"\"></p><p><strong>注意转换完成后如果有一些代码提示编译错误，需要先进行调整，保证基本的编译正常。另外由于是从Java代码转换来的，所以有很多代码虽然转换成Kotlin，但也还带着浓浓的Java味道，你可以继续结合Kotlin的语法特点重构代码。</strong></p><p>转换后的代码是后面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/bc/5e910cd4717c57fbf18819df885e57bc.jpg?wh=2748x1371\" alt=\"\"></p><p>最后当确定编译通过后，我们需要运行基本的冒烟自动化测试，保证运行通过。</p><p><img src=\"https://static001.geekbang.org/resource/image/57/7b/57ff8c8a7c33eecc0a25b5872b175e7b.jpg?wh=2748x1588\" alt=\"\"></p><p>完成Kotlin的转换工作后，接下来我们就可以开启MVVM架构的重构改造了。</p><h2>第一步：业务分析</h2><p>下面我们开始对消息组件进行MVVM重构，同样是七个步骤。第一步先来看业务分析。消息组件的展示逻辑基本与文件组件的类似，都有异常逻辑处理的区分。</p><p>消息组件与文件组件最主要的区别是增加了本地缓存，当网络异常时会判断本地是否存在缓存数据，如果有，则优先展示缓存数据，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/33/55/33d1d48e4c9c1d23670a31c2ccf90d55.jpg?wh=3910x3251\" alt=\"\"></p><p>根据流程图我们可以看出，主要的用户操作场景是这样的：</p><ul>\n<li>当用户进入消息页面时，如果成功从网络上加载消息列表，那么页面会显示消息列表（标题、时间、发布文件信息等）。</li>\n<li>若从网络上加载消息列表时出现异常，如果存在本地缓存数据时，则显示缓存消息列表信息。</li>\n<li>若从网络上加载消息列表出现异常且没有本地缓存信息时，用户界面会展示网络异常的提示信息，此时点击提示会重新触发数据的加载。</li>\n<li>当加载数据为空时，同样会展示数据为空的提示，点击后重新触发刷新。</li>\n</ul><h2>第二步：代码分析</h2><p>下面我们一起来分析消息组件主页面的关键业务逻辑代码，我们先看看原有代码设计。：</p><pre><code class=\"language-plain\">@Route(path = \"/messageFeature/message\")\nclass MessageFragment : Fragment() {\n   //... ...\n    fun getMessageList() {\n        Thread {\n            val message = android.os.Message()\n            try {\n                val messageList = messageController?.getMessageList()\n                message.what = 1\n                message.obj = messageList\n            } catch (e: NetworkErrorException) {\n                message.what = 0\n                message.obj = \"网络异常，请点击重试。\"\n                e.printStackTrace()\n            }\n            mHandler.sendMessage(message)\n        }.start()\n    }\n\n    var mHandler = Handler { msg -&gt;\n        if (msg.what == 1) {\n            showTip(false)\n            //显示网络数据\n            val messageList = msg.obj as MutableList&lt;Message&gt;\n            if (messageList.size == 0) {\n                showTip(true)\n                //显示空数据\n                tvMessage!!.text = \"没有数据，请点击重试。\"\n            } else {\n                val fileListAdapter = MessageListAdapter(messageList, activity)\n                messageListRecycleView!!.addItemDecoration(\n                    DividerItemDecoration(\n                        activity, DividerItemDecoration.VERTICAL\n                    )\n                )\n                //设置布局显示格式\n                messageListRecycleView!!.layoutManager = LinearLayoutManager(activity)\n                messageListRecycleView!!.adapter = fileListAdapter\n                //从网络中更新到数据保存到缓存之中\n                messageController!!.saveMessageToCache(messageList)\n            }\n        } else if (msg.what == 0) {\n            //尝试从缓存中读取数据\n            val messageList = messageController?.getMessageListFromCache()\n            if (messageList == null || messageList.size == 0) {\n                showTip(true)\n                //显示异常提醒数据\n                tvMessage!!.text = msg.obj.toString()\n            } else {\n                val fileListAdapter = MessageListAdapter(messageList, activity)\n                messageListRecycleView!!.addItemDecoration(\n                    DividerItemDecoration(\n                        activity, DividerItemDecoration.VERTICAL\n                    )\n                )\n                //设置布局显示格式\n                messageListRecycleView!!.layoutManager = LinearLayoutManager(activity)\n                messageListRecycleView!!.adapter = fileListAdapter\n            }\n        }\n        false\n    }\n}\n</code></pre><p>从上述代码可以看出，消息组件的核心问题有2个。第一个问题与文件组件问题类似，主要还是过大类的问题，我们这节课里将其重构为MVVM架构。</p><p>另外一个问题就是缓存数据保存到数据库操作都是采用SQL拼写的方式，这样做有什么缺点你可以做个思考，下节课我们再专门说说如何对它做优化。</p><h2>第三步：补充自动化验收测试</h2><p>接下来我们进行第三步，补充自动化验收测试。根据前面的业务分析，我们梳理出核心的4个用例。</p><ul>\n<li>测试用例1：当用户进入消息页面时，正常请求到数据，显示消息列表。</li>\n<li>测试用例2：当用户进入消息页面时，网络异常，但有本地缓存数据，显示缓存消息列表。</li>\n<li>测试用例3：当用户进入消息页面时，网络异常，但无本地缓存数据，显示异常提示。</li>\n<li>测试用例4：当用户进入消息页面时，数据为空，显示空提示。</li>\n</ul><p>我们将这些用例进行自动化，代码是后面这样。</p><pre><code class=\"language-plain\">//测试用例1\n@Test\nfun `show show message list when get success`() {\n    //given\n    ShadowMessageController.state = ShadowMessageController.State.SUCCESS\n    //when\n    val scenario: FragmentScenario&lt;MessageFragment&gt; =\n        FragmentScenario.launchInContainer(MessageFragment::class.java)\n    scenario.onFragment() {\n        //then\n        onView(withText(\"张三共享文件到消息中...\")).check(matches(isDisplayed()))\n        onView(withText(\"大型Android遗留系统重构.pdf\")).check(matches(isDisplayed()))\n        onView(withText(\"2021-03-17 14:47:55\")).check(matches(isDisplayed()))\n        onView(withText(\"李四共享视频到消息中...\")).check(matches(isDisplayed()))\n        onView(withText(\"修改代码的艺术.pdf\")).check(matches(isDisplayed()))\n        onView(withText(\"2021-03-17 14:48:08\")).check(matches(isDisplayed()))\n    }\n}\n\n//测试用例2\n@Test\nfun `show show message list when net work exception but have cache`() {\n    //given\n    ShadowMessageController.state = ShadowMessageController.State.CACHE\n    //when\n    val scenario: FragmentScenario&lt;MessageFragment&gt; =\n        FragmentScenario.launchInContainer(MessageFragment::class.java)\n    scenario.onFragment() {\n        //then\n        onView(withText(\"张三共享文件到消息中...\")).check(matches(isDisplayed()))\n        onView(withText(\"大型Android遗留系统重构.pdf\")).check(matches(isDisplayed()))\n        onView(withText(\"2021-03-17 14:47:55\")).check(matches(isDisplayed()))\n        onView(withText(\"李四共享视频到消息中...\")).check(matches(isDisplayed()))\n        onView(withText(\"修改代码的艺术.pdf\")).check(matches(isDisplayed()))\n        onView(withText(\"2021-03-17 14:48:08\")).check(matches(isDisplayed()))\n    }\n}\n\n//测试用例3\n@Test\nfun `show show error tip when net work exception and not have cache`() {\n    //given\n    ShadowMessageController.state = ShadowMessageController.State.ERROR\n    //when\n    val scenario: FragmentScenario&lt;MessageFragment&gt; =\n        FragmentScenario.launchInContainer(MessageFragment::class.java)\n    scenario.onFragment() {\n        //then\n        onView(withText(\"网络异常，请点击重试。\")).check(matches(isDisplayed()))\n    }\n}\n\n//测试用例4\n@Test\nfun `show show empty tip when not has data`() {\n    //given\n    ShadowMessageController.state = ShadowMessageController.State.EMPTY\n    //when\n    val scenario: FragmentScenario&lt;MessageFragment&gt; =\n        FragmentScenario.launchInContainer(MessageFragment::class.java)\n    scenario.onFragment() {\n        //then\n        onView(withText(\"没有数据，请点击重试。\")).check(matches(isDisplayed()))\n    }\n}\n</code></pre><p>这里补充一个编程技巧，<strong>用Kotlin语言编写测试用例的时候，建议你使用引号来标识用例名，避免用下划线串联用例名，这样代码阅读体验更好。</strong></p><p>后面是测试用例的执行结果，用例成功通过。</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/ef/abc15bc057e9d2ce275327a1byya65ef.jpg?wh=2748x1639\" alt=\"\"></p><h2>第四步：简单设计</h2><p>下面我们来进行简单设计，这次的分层架构我们选择使用MVVM。</p><p>首先我们来了解一下MVVM的架构设计模式，以及基于该模式我们需要定义哪些核心的类以及数据模型。</p><h3>1. MVVM架构</h3><p>MVVM架构的主要特点是业务逻辑和视图分离，ViewModel和视图之间通过直接绑定，不用定义大量的接口。你可以结合后面的MVVM架构设计图来加深理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/9c/9aeb5faedd040465fb81daff39cfdb9c.jpg?wh=2505x1320\" alt=\"\"></p><h3>2. 关键绑定数据定义</h3><p>ViewModel与View之间会通过DataBindng自动进行双向同步，所以我们需要先定义好关键的数据。</p><pre><code class=\"language-plain\">// 数据列表\nval messageListLiveData: LiveData&lt;List&lt;Message&gt;&gt;\n// 异常信息\nval errorMessageLiveData: LiveData&lt;String&gt;\n</code></pre><h3>3. 集成第三方框架</h3><p>由于MVVM需要用到双向绑定，所以通常情况下使用MVVM架构都会沿用官方提供的组件进行开发，这里我们需要引入对应的组件。</p><pre><code class=\"language-plain\">//使用LiveData及ViewModel来管理数据及与View交互\nimplementation 'androidx.core:core-ktx:1.3.2'\nimplementation 'androidx.lifecycle:lifecycle-livedata-ktx:2.3.0'\nimplementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.0'\n//使用协程管理线程调度\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1'\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1'\n</code></pre><h2>第五步：小步安全重构</h2><p>做完设计，我们就可以进行小步安全重构了。</p><p>我将整个重构分为了几个关键的步骤，每个步骤都附上了用编辑器自动化重构的演示动图。<strong>由于Kotlin语言IDE不支持移动方法，所以在操作过程有很多地方需要用手工进行移动，你可以参考对比一下上节课，感受一下自动和手动的差别。</strong></p><h3>1.将业务逻辑移动至ViewModel类中</h3><p>首先将MessageFragment以及MessageController中的主要业务逻辑移动至独立的ViewModel类中，包含获取列表、上传消息以及缓存消息。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/28/5fec5b2c27f6c02074b31041007d9a28.gif?wh=1132x603\" alt=\"\"></p><p>从上面的演示可以看出，手动挪动代码的问题就是<strong>效率低，而且非常容易出错</strong>。</p><h3>2. 提取公共的UI展示方法</h3><p>然后将展示列表数据、展示异常信息以及空数据等操作提取为独立的方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/40/4c/4017511f17844b4cec0a9e758eae9e4c.gif?wh=1364x726\" alt=\"图片\"></p><h3>3. 定义LiveData，使用协程管理异步数据</h3><p>接下来我们在MessageViewModel类中添加对应的LiveData数据，同时将原本使用Thread创建异步的方法调整为使用协程来进行统一管理。</p><p>由于这部分都是新增代码，所以下面我直接展示调整后的最终代码。</p><pre><code class=\"language-plain\">class MessageViewModel(mContext: Context?) : ViewModel() {\n    val messageListLiveData: MutableLiveData&lt;MutableList&lt;Message&gt;&gt; = MutableLiveData()\n    val errorMessageLiveData: MutableLiveData&lt;String&gt; = MutableLiveData();\n\n    fun getMessageList() {\n        viewModelScope.launch {\n            try {\n                val messageList = messageRepository.getMessageList()\n                messageListLiveData.value = messageList\n                saveMessageToCache(messageList)\n            } catch (e: NetworkErrorException) {\n                val messageList = getMessageListFromCache()\n                if (messageList == null || messageList.isEmpty()) {\n                    errorMessageLiveData.value = \"网络异常，请点击重试。\"\n                } else {\n                    messageListLiveData.value = messageList\n                }\n            }\n        }\n    }\n}\n</code></pre><h3>4. 使用Repository仓储模式管理数据源</h3><p>我们继续对数据源进行管理，通过提取DataSource接口来管理本地的缓存数据读取。<img src=\"https://static001.geekbang.org/resource/image/71/db/716565f1822785243f6b419361afd1db.gif?wh=1364x726\" alt=\"图片\"></p><h3>5. 使用DataBinding&nbsp;进行双向绑定</h3><p>最后，我们可以通过配置databinding来绑定数据。</p><pre><code class=\"language-plain\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n    &lt;data&gt;\n        &lt;import type=\"android.view.View\" /&gt;\n        &lt;variable\n            name=\"message\"\n            type=\"com.jkb.junbin.sharing.feature.message.Message\" /&gt;\n    &lt;/data&gt;\n    &lt;RelativeLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"horizontal\"\n        android:padding=\"10dp\"&gt;\n        &lt;TextView\n            android:id=\"@+id/tv_date\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_alignParentRight=\"true\"\n            android:layout_gravity=\"right\"\n            android:text=\"@{message.formatDate}\" /&gt;\n        &lt;TextView\n            android:id=\"@+id/tv_content\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_alignParentLeft=\"true\"\n            android:layout_gravity=\"left\"\n            android:layout_toLeftOf=\"@id/tv_date\"\n            android:text=\"@{message.content}\" /&gt;\n\n        &lt;LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_below=\"@id/tv_content\"\n            android:layout_marginTop=\"10dp\"&gt;\n            &lt;ImageView\n                android:layout_width=\"50dp\"\n                android:layout_height=\"50dp\"\n                android:src=\"@mipmap/icon_qz\" /&gt;\n            &lt;LinearLayout\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:layout_below=\"@id/tv_content\"\n                android:layout_marginTop=\"10dp\"\n                android:orientation=\"vertical\"&gt;\n                &lt;TextView\n                    android:id=\"@+id/tv_filename\"\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:layout_marginLeft=\"5dp\"\n                    android:text=\"@{message.fileName}\" /&gt;\n                &lt;TextView\n                    android:id=\"@+id/tv_count\"\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:layout_marginLeft=\"5dp\"\n                    android:text='@{\"文件浏览量：\"+message.downloadCount}'\n                    android:visibility='@{message.downloadCount==null?View.GONE:View.VISIBLE}' /&gt;\n            &lt;/LinearLayout&gt;\n        &lt;/LinearLayout&gt;\n    &lt;/RelativeLayout&gt;\n&lt;/layout&gt;\n</code></pre><p>具体调整代码比较多，但调整思路和上面的例子类似，就不在这里一一展示了，你可以通过这个<a href=\"https://github.com/junbin1011/Sharing\">链接</a>查看整体的代码。</p><h2>第六步：补充中小型测试</h2><p>至此我们已经完成了整体的重构工作，恭喜你学到这里。</p><p>下面我们以MessageViewModel为例，对它补充对应的中小型测试。MessageViewModelTest将对主要的业务逻辑进行测试，同样也不会涉及UI部分，只会校验最终LiveData的数据是否正确。</p><pre><code class=\"language-plain\">class DynamicViewModelTest {\n    private val testDispatcher = TestCoroutineDispatcher()\n    @get:Rule\n    val rule = InstantTaskExecutorRule()\n    @Before\n    fun setUp() {\n        Dispatchers.setMain(testDispatcher)\n        ARouter.openDebug()\n        ARouter.init(ApplicationProvider.getApplicationContext())\n    }\n    @After\n    fun tearDown() {\n        Dispatchers.resetMain()\n        testDispatcher.cleanupTestCoroutines()\n    }\n    @Test\n    fun `show show message list when get success`() = runBlocking {\n        //given\n        ShadowMessageRepository.state = ShadowMessageRepository.State.SUCCESS\n        val messageViewModel = MessageViewModel(ApplicationProvider.getApplicationContext())\n        //when\n        messageViewModel.getMessageList()\n        //then\n        val messageOne = LiveDataTestUtil.getValue(messageViewModel.messageListLiveData)[0]\n        assertThat(messageOne.id).isEqualTo(1)\n        assertThat(messageOne.content).isEqualTo(\"张三共享文件到消息中...\")\n        assertThat(messageOne.fileName).isEqualTo(\"大型Android遗留系统重构.pdf\")\n        assertThat(messageOne.formatDate).isEqualTo(\"2021-03-17 14:47:55\")\n        val messageTwo = LiveDataTestUtil.getValue(messageViewModel.messageListLiveData)[1]\n        assertThat(messageTwo.id).isEqualTo(2)\n        assertThat(messageTwo.content).isEqualTo(\"李四共享视频到消息中...\")\n        assertThat(messageTwo.fileName).isEqualTo(\"修改代码的艺术.pdf\")\n        assertThat(messageTwo.formatDate).isEqualTo(\"2021-03-17 14:48:08\")\n    }\n    @Test\n    fun `show show dynamic list when net work exception but have cache`() = runBlocking {\n        //given\n        ShadowMessageRepository.state = ShadowMessageRepository.State.CACHE\n        val messageViewModel = MessageViewModel(ApplicationProvider.getApplicationContext())\n        //when\n        messageViewModel.getMessageList()\n        //then\n        val messageOne = LiveDataTestUtil.getValue(messageViewModel.messageListLiveData)[0]\n        assertThat(messageOne.id).isEqualTo(1)\n        assertThat(messageOne.content).isEqualTo(\"张三共享文件到消息中...\")\n        assertThat(messageOne.fileName).isEqualTo(\"大型Android遗留系统重构.pdf\")\n        assertThat(messageOne.formatDate).isEqualTo(\"2021-03-17 14:47:55\")\n        val messageTwo = LiveDataTestUtil.getValue(messageViewModel.messageListLiveData)[1]\n        assertThat(messageTwo.id).isEqualTo(2)\n        assertThat(messageTwo.content).isEqualTo(\"李四共享视频到消息中...\")\n        assertThat(messageTwo.fileName).isEqualTo(\"修改代码的艺术.pdf\")\n        assertThat(messageTwo.formatDate).isEqualTo(\"2021-03-17 14:48:08\")\n    }\n    @Test\n    fun `show show error tip when net work exception and not have cache`() = runBlocking {\n        //given\n        ShadowMessageRepository.state = ShadowMessageRepository.State.ERROR\n        val messageViewModel = MessageViewModel(ApplicationProvider.getApplicationContext())\n        //when\n        messageViewModel.getMessageList()\n        //then\n        val errorMessage = LiveDataTestUtil.getValue(messageViewModel.errorMessageLiveData)\n        assertThat(errorMessage).isEqualTo(\"网络异常，请点击重试。\")\n        val messageList = LiveDataTestUtil.getValue(messageViewModel.messageListLiveData)\n        assertThat(messageList).isNull()\n    }\n    @Test\n    fun `show show empty tip when not has data`() = runBlocking {\n        //given\n        ShadowMessageRepository.state = ShadowMessageRepository.State.EMPTY\n        val messageViewModel = MessageViewModel(ApplicationProvider.getApplicationContext())\n        //when\n        messageViewModel.getMessageList()\n        //then\n        val messageList = LiveDataTestUtil.getValue(messageViewModel.messageListLiveData)\n        assertThat(messageList).isEmpty()\n    }\n}\n</code></pre><h2>第七步：集成验收</h2><p>最后一步就是集成进行验证，我们应该保证APP模块中的架构守护测试用例和基本冒烟测试通过，操作和上节课类似，这里我就不再进行演示了。</p><p>相比重构前MessageFragment将所有的逻辑都写在一个类中，这次重构，解决了业务与UI的逻辑分离、线程调度管理、覆盖自动化测试等问题。</p><h2>总结</h2><p>今天我们继续使用分层架构重构的流程方法重构了消息组件。不过，这次我们使用了新的语言Kotlin以及新的分层架构MVVM。</p><p>可以看到尽管使用的语法与架构不一样，但是流程方法还是一样都是相通的，你可以参考下表所示的3个维度和7个步骤。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/8a/2c407859918dfb4fd44ee6a78d337c8a.jpg?wh=1920x1151\" alt=\"图片\"></p><p>在实际的重构过程中需要注意，如果之前的代码都是采用Java语言开发，虽然Kotlin语言支持混编，但是Java代码调用Kotlin代码还是比较麻烦，需要进行一些特殊的处理。另一种选择是使用工具将原有的代码转换成Kotlin代码，但是这也会引入新的问题，就是转换后代码还需要继续进行优化调整，才能编译通过。</p><p>在实际的项目中，你可以结合团队成员技术栈以及代码规模来考虑选择哪种方式。另外还要注意，由于Kotlin语言IDE不支持移动方法，所以重构时会比较麻烦，需要部分进行手工移动代码，我们需要在移动后频繁运行守护测试，避免修改出现问题。</p><p>在代码分析步骤提到的另外一个问题就是，消息组件中的缓存数据保存到数据库操作都是采用SQL拼写的方式。下节课，我们将继续对消息组件的数据库操作部分进行重构，敬请期待。</p><h2>思考题</h2><p>感谢你学完了今天的内容，今天的思考题是这样的：在你的项目上有没有使用Java与Kotlin混编，你有遇到什么问题吗？</p><p>感谢你学完了今天的课程，欢迎你把它分享给你的同事或朋友，让我们一起来高效高质量交付软件！</p>","comments":[{"had_liked":false,"id":370654,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1679056550,"is_pvip":false,"replies":[{"id":135282,"content":"Hi，peter。\nQ1：使用IDE工具提供的转换，将java代码直接转换成Kotlin代码。\nQ2：推荐使用kotlin。我理解不是放弃，而是扩展。\nQ3：没有，协程是kotlin的特性。\nQ4：可以。\nQ5：MVVM支持双向绑定，MVP得自己定义接口。\nQ6：我觉得还是看系统的状态。新系统开发建议支持使用Kotlin。遗留系统改造有个过程，可以适当考虑混编。","user_name":"作者回复","user_name_real":"编辑","uid":1179206,"ctime":1679275150,"ip_address":"广东","comment_id":370654,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100525001,"comment_content":"请教老师几个问题：\nQ1：第二种方法是怎么转换为kotlin的？\n文中开头的例子说到“第二种方法使用 Kotlin 替换 Java 的好处就是，可以减少一些跨语言调用编写问题，但是缺点是需要将原有的代码改动成 Kotlin”。 例子代码中，一个是kotlin，一个是Java，并没有Java转换为kotlin的信息啊。\nQ2：假如现在开发APP，用kotlin还是Java？哪个好？如果现在会Java但不会kotlin，需要放弃Java而学习kotlin吗？\nQ3：kotlin有协程，安卓用Java开发的话，有协程吗？（印象中是没有的）\nQ4：kotlin可以用MVVM，用Java可以采用吗？\nQ5：Java和kotlin混合开发，除了调用不太方便，还有什么问题？比如，会有性能问题吗？\nQ5：MVVM和MVP都是“业务逻辑和视图分离”，似乎是一样的。那这两种模式有什么区别？\nQ6：老师赞成Java和kotlin混合开发吗？","like_count":0,"discussions":[{"author":{"id":1179206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/46/033fccb2.jpg","nickname":"黄俊彬","note":"","ucode":"0DBE0CE4E7CFC9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609870,"discussion_content":"Hi，peter。\nQ1：使用IDE工具提供的转换，将java代码直接转换成Kotlin代码。\nQ2：推荐使用kotlin。我理解不是放弃，而是扩展。\nQ3：没有，协程是kotlin的特性。\nQ4：可以。\nQ5：MVVM支持双向绑定，MVP得自己定义接口。\nQ6：我觉得还是看系统的状态。新系统开发建议支持使用Kotlin。遗留系统改造有个过程，可以适当考虑混编。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679275150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370627,"user_name":"永远年轻","can_delete":false,"product_type":"c1","uid":1097653,"ip_address":"浙江","ucode":"349BF9EEB4FE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/bf/b5/a8db0572.jpg","comment_is_top":false,"comment_ctime":1679036164,"is_pvip":false,"replies":[{"id":135280,"content":"Hi，感谢反馈。","user_name":"作者回复","user_name_real":"编辑","uid":1179206,"ctime":1679274517,"ip_address":"广东","comment_id":370627,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100525001,"comment_content":"第五点中，应该是使用了 DataBinding 的单项绑定，数据变动会驱动 UI 变化，而 UI 变化不会驱动数据变化。双向绑定应该是 「@={vm.xxx}」","like_count":0,"discussions":[{"author":{"id":1179206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/46/033fccb2.jpg","nickname":"黄俊彬","note":"","ucode":"0DBE0CE4E7CFC9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609868,"discussion_content":"Hi，感谢反馈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679274517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370602,"user_name":"3.141516","can_delete":false,"product_type":"c1","uid":1013309,"ip_address":"上海","ucode":"34AF71B02692F3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/3d/8120438b.jpg","comment_is_top":false,"comment_ctime":1679019392,"is_pvip":true,"replies":[{"id":135279,"content":"Hi，实际我没有做过精准的时间测试。网上有同学做过编译耗时的测试，你可以参考一下：https:&#47;&#47;developer.aliyun.com&#47;article&#47;112717。","user_name":"作者回复","user_name_real":"编辑","uid":1179206,"ctime":1679274500,"ip_address":"广东","comment_id":370602,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100525001,"comment_content":"项目中是 Kotlin、Java 混编，有个问题想请教一下老师：Kotlin、Java 混编和纯 Kotlin 的编译时间哪个更短呢？","like_count":0,"discussions":[{"author":{"id":1179206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/46/033fccb2.jpg","nickname":"黄俊彬","note":"","ucode":"0DBE0CE4E7CFC9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609867,"discussion_content":"Hi，实际我没有做过精准的时间测试。网上有同学做过编译耗时的测试，你可以参考一下：https://developer.aliyun.com/article/112717。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679274500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373841,"user_name":"louc","can_delete":false,"product_type":"c1","uid":2728241,"ip_address":"安徽","ucode":"08FB5A46314B2B","user_header":"https://static001.geekbang.org/account/avatar/00/29/a1/31/ca97e229.jpg","comment_is_top":false,"comment_ctime":1683256004,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100525001,"comment_content":"不太严谨啊，怎么重构后，getMessageList就在主线程取数据了，之前不是在异步线程么","like_count":0,"discussions":[{"author":{"id":1151235,"avatar":"https://static001.geekbang.org/account/avatar/00/11/91/03/48785ffc.jpg","nickname":"王研科","note":"","ucode":"EDAD13A009E6BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620693,"discussion_content":"只看这里确实前后不完全一致，不过用协程的话ViewlModel里通常就这么写，然后在repository里设置合适的 CoroutineDispatcher","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686452380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}