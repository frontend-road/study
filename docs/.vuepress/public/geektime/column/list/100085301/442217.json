{"id":442217,"title":"34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？","content":"<p>你好，我是陈天。</p><p>对于并发状态下这三种常见的工作模式：自由竞争模式、map/reduce 模式、DAG 模式，我们的难点是如何在这些并发的任务中进行同步。atomic / Mutex 解决了自由竞争模式下并发任务的同步问题，也能够很好地解决 map/reduce 模式下的同步问题，因为此时同步只发生在 map 和 reduce 两个阶段。<br>\n<img src=\"https://static001.geekbang.org/resource/image/00/58/003294c9ba4b291e47585fa1a599a358.jpg?wh=2364x1142\" alt=\"\"></p><p>然而，它们没有解决一个更高层次的问题，也就是 DAG 模式：如果这种访问需要按照一定顺序进行或者前后有依赖关系，该怎么做？</p><p>这个问题的典型场景是<strong>生产者-消费者模式：生产者生产出来内容后，需要有机制通知消费者可以消费</strong>。比如 socket 上有数据了，通知处理线程来处理数据，处理完成之后，再通知 socket 收发的线程发送数据。</p><h2>Condvar</h2><p>所以，操作系统还提供了 Condvar。Condvar 有两种状态：</p><ul>\n<li>等待（wait）：线程在队列中等待，直到满足某个条件。</li>\n<li>通知（notify）：当 condvar 的条件满足时，当前线程通知其他等待的线程可以被唤醒。通知可以是单个通知，也可以是多个通知，甚至广播（通知所有人）。</li>\n</ul><p>在实践中，Condvar 往往和 Mutex 一起使用：<strong>Mutex 用于保证条件在读写时互斥，Condvar 用于控制线程的等待和唤醒</strong>。我们来看一个例子：</p><!-- [[[read_end]]] --><pre><code class=\"language-rust\">use std::sync::{Arc, Condvar, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    let pair2 = Arc::clone(&amp;pair);\n\n    thread::spawn(move || {\n        let (lock, cvar) = &amp;*pair2;\n        let mut started = lock.lock().unwrap();\n        *started = true;\n        eprintln!(\"I'm a happy worker!\");\n        // 通知主线程\n        cvar.notify_one();\n        loop {\n            thread::sleep(Duration::from_secs(1));\n            println!(\"working...\");\n        }\n    });\n\n    // 等待工作线程的通知\n    let (lock, cvar) = &amp;*pair;\n    let mut started = lock.lock().unwrap();\n    while !*started {\n        started = cvar.wait(started).unwrap();\n    }\n    eprintln!(\"Worker started!\");\n}\n</code></pre><p>这段代码通过 condvar，我们实现了 worker 线程在执行到一定阶段后通知主线程，然后主线程再做一些事情。</p><p>这里，我们使用了一个 Mutex 作为互斥条件，然后在 <a href=\"https://doc.rust-lang.org/src/std/sync/condvar.rs.html#184-191\">cvar.wait()</a> 中传入这个 Mutex。这个接口需要一个 MutexGuard，以便于知道需要唤醒哪个 Mutex 下等待的线程：</p><pre><code class=\"language-rust\">pub fn wait&lt;'a, T&gt;(\n    &amp;self,\n    guard: MutexGuard&lt;'a, T&gt;\n) -&gt; LockResult&lt;MutexGuard&lt;'a, T&gt;&gt;\n</code></pre><h2>Channel</h2><p>但是用 Mutex 和 Condvar 来处理复杂的 DAG 并发模式会比较吃力。所以，Rust 还提供了各种各样的 Channel 用于处理并发任务之间的通讯。</p><p>由于 Golang 不遗余力地推广，Channel 可能是最广为人知的并发手段。相对于 Mutex，Channel 的抽象程度最高，接口最为直观，使用起来的心理负担也没那么大。使用 Mutex 时，你需要很小心地避免死锁，控制临界区的大小，防止一切可能发生的意外。</p><p>虽然在 Rust 里，我们可以“无畏并发”（Fearless concurrency）—— 当代码编译通过，绝大多数并发问题都可以规避，但性能上的问题、逻辑上的死锁还需要开发者照料。</p><p><strong>Channel 把锁封装在了队列写入和读取的小块区域内，然后把读者和写者完全分离</strong>，使得读者读取数据和写者写入数据，对开发者而言，除了潜在的上下文切换外，完全和锁无关，就像访问一个本地队列一样。所以，对于大部分并发问题，我们都可以用 Channel 或者类似的思想来处理（比如 actor model）。</p><p>Channel 在具体实现的时候，根据不同的使用场景，会选择不同的工具。Rust 提供了以下四种 Channel：</p><ul>\n<li>oneshot：这可能是最简单的 Channel，写者就只发一次数据，而读者也只读一次。这种一次性的、多个线程间的同步可以用 oneshot channel 完成。由于 oneshot 特殊的用途，实现的时候可以直接用 atomic swap 来完成。</li>\n<li>rendezvous：很多时候，我们只需要通过 Channel 来控制线程间的同步，并不需要发送数据。rendezvous channel 是 channel size 为 0 的一种特殊情况。</li>\n</ul><p>这种情况下，我们用 Mutex + Condvar 实现就足够了，在具体实现中，rendezvous channel 其实也就是 Mutex + Condvar 的一个包装。</p><ul>\n<li>bounded：<strong>bounded channel 有一个队列，但队列有上限。一旦队列被写满了，写者也需要被挂起等待</strong>。当阻塞发生后，读者一旦读取数据，channel 内部就会使用 Condvar 的 <code>notify_one</code> 通知写者，唤醒某个写者使其能够继续写入。</li>\n</ul><p>因此，实现中，一般会用到 Mutex + Condvar + VecDeque 来实现；如果不用 Condvar，可以直接使用 thread::park + thread::notify 来完成（<a href=\"https://github.com/zesterer/flume\">flume</a> 的做法）；如果不用 VecDeque，也可以使用双向链表或者其它的 ring buffer 的实现。</p><ul>\n<li>unbounded：queue 没有上限，如果写满了，就自动扩容。我们知道，Rust 的很多数据结构如 <code>Vec</code> 、<code>VecDeque</code> 都是自动扩容的。unbounded 和 bounded 相比，除了不阻塞写者，其它实现都很类似。</li>\n</ul><p>所有这些 channel 类型，同步和异步的实现思路大同小异，主要的区别在于挂起/唤醒的对象。<strong>在同步的世界里，挂起/唤醒的对象是线程；而异步的世界里，是粒度很小的 task</strong>。<br>\n<img src=\"https://static001.geekbang.org/resource/image/a4/61/a4372f4dd810ced7a99f54d50695cc61.jpg?wh=2364x1610\" alt=\"\"></p><p>根据 Channel 读者和写者的数量，Channel 又可以分为：</p><ul>\n<li>SPSC：Single-Producer Single-Consumer，单生产者，单消费者。最简单，可以不依赖于 Mutex，只用 atomics 就可以实现。</li>\n<li>SPMC：Single-Producer Multi-Consumer，单生产者，多消费者。需要在消费者这侧读取时加锁。</li>\n<li>MPSC：Multi-Producer Single-Consumer，多生产者，单消费者。需要在生产者这侧写入时加锁。</li>\n<li>MPMC：Multi-Producer Multi-Consumer。多生产者，多消费者。需要在生产者写入或者消费者读取时加锁。</li>\n</ul><p>在众多 Channel 类型中，使用最广的是 MPSC channel，多生产者，单消费者，<strong>因为往往我们希望通过单消费者来保证，用于处理消息的数据结构有独占的写访问</strong>。<br>\n<img src=\"https://static001.geekbang.org/resource/image/4f/12/4fbacc0fecf5618d30b976d110838912.jpg?wh=2364x1433\" alt=\"\"></p><p>比如，在 <a href=\"https://github.com/tyrchen/xunmi/blob/master/src/indexer.rs#L50\">xunmi</a> 的实现中，index writer 内部是一个多线程的实现，但在使用时，我们需要用到它的可写引用。</p><p>如果要能够在各种上下文中使用 index writer，我们就不得不将其用 Arc&lt;Mutex&lt;T&gt;&gt; 包裹起来，但这样在索引大量数据时效率太低，所以我们可以用 MPSC channel，让各种上下文都把数据发送给单一的线程，使用 index writer 索引，这样就避免了锁：</p><pre><code class=\"language-rust\">pub struct IndexInner {\n    index: Index,\n    reader: IndexReader,\n    config: IndexConfig,\n    updater: Sender&lt;Input&gt;,\n}\n\npub struct IndexUpdater {\n    sender: Sender&lt;Input&gt;,\n    t2s: bool,\n    schema: Schema,\n}\n\nimpl Indexer {\n    // 打开或者创建一个 index\n    pub fn open_or_create(config: IndexConfig) -&gt; Result&lt;Self&gt; {\n        let schema = config.schema.clone();\n        let index = if let Some(dir) = &amp;config.path {\n            fs::create_dir_all(dir)?;\n            let dir = MmapDirectory::open(dir)?;\n            Index::open_or_create(dir, schema.clone())?\n        } else {\n            Index::create_in_ram(schema.clone())\n        };\n\n        Self::set_tokenizer(&amp;index, &amp;config);\n\n        let mut writer = index.writer(config.writer_memory)?;\n\n        // 创建一个 unbounded MPSC channel\n        let (s, r) = unbounded::&lt;Input&gt;();\n\n        // 启动一个线程，从 channel 的 reader 中读取数据\n        thread::spawn(move || {\n            for input in r {\n                // 然后用 index writer 处理这个 input\n                if let Err(e) = input.process(&amp;mut writer, &amp;schema) {\n                    warn!(\"Failed to process input. Error: {:?}\", e);\n                }\n            }\n        });\n\n        // 把 channel 的 sender 部分存入 IndexInner 结构\n        Self::new(index, config, s)\n    }\n\n    pub fn get_updater(&amp;self) -&gt; IndexUpdater {\n        let t2s = TextLanguage::Chinese(true) == self.config.text_lang;\n        // IndexUpdater 内部包含 channel 的 sender 部分\n        // 由于是 MPSC channel，所以这里可以简单 clone 一下 sender\n        // 这也意味着，我们可以创建任意多个 IndexUpdater 在不同上下文发送数据\n        // 而数据最终都会通过 channel 给到上面创建的线程，由 index writer 处理\n        IndexUpdater::new(self.updater.clone(), self.index.schema(), t2s)\n    }\n}\n</code></pre><h2>Actor</h2><p>最后我们简单介绍一下 <a href=\"https://en.wikipedia.org/wiki/Actor_model\">actor model</a>，它在业界主要的使用者是 Erlang VM以及 <a href=\"https://akka.io/\">akka</a>。</p><p>actor 是一种有栈协程。每个 actor，有自己的一个独立的、轻量级的调用栈，以及一个用来接受消息的消息队列（mailbox 或者 message queue），外界跟 actor 打交道的唯一手段就是，给它发送消息。</p><p>Rust 标准库没有 actor 的实现，但是社区里有比较成熟的 <a href=\"https://github.com/actix/actix\">actix</a>（大名鼎鼎的 actix-web 就是基于 actix 实现的），以及 <a href=\"https://github.com/bastion-rs/bastion\">bastion</a>。</p><p>下面的代码用 actix 实现了一个简单的 DummyActor，它可以接收一个 InMsg，返回一个 OutMsg：</p><pre><code class=\"language-rust\">use actix::prelude::*;\nuse anyhow::Result;\n\n// actor 可以处理的消息\n#[derive(Message, Debug, Clone, PartialEq)]\n#[rtype(result = \"OutMsg\")]\nenum InMsg {\n    Add((usize, usize)),\n    Concat((String, String)),\n}\n\n#[derive(MessageResponse, Debug, Clone, PartialEq)]\nenum OutMsg {\n    Num(usize),\n    Str(String),\n}\n\n// Actor\nstruct DummyActor;\n\nimpl Actor for DummyActor {\n    type Context = Context&lt;Self&gt;;\n}\n\n// 实现处理 InMsg 的 Handler trait\nimpl Handler&lt;InMsg&gt; for DummyActor {\n    type Result = OutMsg; // &lt;-  返回的消息\n\n    fn handle(&amp;mut self, msg: InMsg, _ctx: &amp;mut Self::Context) -&gt; Self::Result {\n        match msg {\n            InMsg::Add((a, b)) =&gt; OutMsg::Num(a + b),\n            InMsg::Concat((mut s1, s2)) =&gt; {\n                s1.push_str(&amp;s2);\n                OutMsg::Str(s1)\n            }\n        }\n    }\n}\n\n#[actix::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    let addr = DummyActor.start();\n    let res = addr.send(InMsg::Add((21, 21))).await?;\n    let res1 = addr\n        .send(InMsg::Concat((\"hello, \".into(), \"world\".into())))\n        .await?;\n\n    println!(\"res: {:?}, res1: {:?}\", res, res1);\n\n    Ok(())\n}\n</code></pre><p>可以看到，对 DummyActor，我们只需要实现 Actor trait和Handler&lt;InMsg&gt; trait 。</p><h2>一点小结</h2><p>学完这前后两讲，我们小结一下各种并发原语的使用场景Atomic、Mutex、RwLock、Semaphore、Condvar、Channel、Actor。</p><ul>\n<li>Atomic 在处理简单的原生类型时非常有用，如果你可以通过 AtomicXXX 结构进行同步，那么它们是最好的选择。</li>\n<li>当你的数据结构无法简单通过 AtomicXXX 进行同步，但你又的确需要在多个线程中共享数据，那么 Mutex / RwLock 可以是一种选择。不过，你需要考虑锁的粒度，粒度太大的 Mutex / RwLock 效率很低。</li>\n<li>如果你有 N 份资源可以供多个并发任务竞争使用，那么，Semaphore 是一个很好的选择。比如你要做一个 DB 连接池。</li>\n<li>当你需要在并发任务中通知、协作时，Condvar 提供了最基本的通知机制，而Channel 把这个通知机制进一步广泛扩展开，于是你可以用 Condvar 进行点对点的同步，用 Channel 做一对多、多对一、多对多的同步。</li>\n</ul><p>所以，当我们做大部分复杂的系统设计时，Channel 往往是最有力的武器，除了可以让数据穿梭于各个线程、各个异步任务间，它的接口还可以很优雅地跟 stream 适配。</p><p>如果说在做整个后端的系统架构时，我们着眼的是：有哪些服务、服务和服务之间如何通讯、数据如何流动、服务和服务间如何同步；那么<strong>在做某一个服务的架构时，着眼的是有哪些功能性的线程（异步任务）、它们之间的接口是什么样子、数据如何流动、如何同步</strong>。</p><p>在这里，Channel 兼具接口、同步和数据流三种功能，所以我说是最有力的武器。</p><p>然而它不该是唯一的武器。我们面临的真实世界的并发问题是多样的，解决方案也应该是多样的，计算机科学家们在过去的几十年里不断探索，构建了一系列的并发原语，也说明了很难有一种银弹解决所有问题。</p><p>就连 Mutex 本身，在实现中，还会根据不同的场景做不同的妥协（比如做 faireness 的妥协），因为这个世界就是这样，鱼与熊掌不可兼得，没有完美的解决方案，只有妥协出来的解决方案。所以 Channel 不是银弹，actor model 不是银弹，lock 不是银弹。</p><p><strong>一门好的编程语言，可以提供大部分场景下的最佳实践（如 Erlang/Golang），但不该营造一种气氛，只有某个最佳实践才是唯一方案</strong>。我很喜欢 Erlang 的 actor model 和 Golang 的 Channel，但很可惜，它们过分依赖特定的、唯一的并发方案，使得开发者拿着榔头，看什么都是钉子。</p><p>相反，Rust 提供几乎你需要的所有解决方案，并且并不鼓吹它们的优劣，完全交由你按需选择。我在用 Rust 撰写多线程应用时，Channel 仍然是第一选择，但我还是会在合适的时候使用 Mutex、RwLock、Semaphore、Condvar、Atomic 等工具，而不是试图笨拙地用 Channel 叠加 Channel 来应对所有的场景。</p><h3>思考题</h3><ol>\n<li>请仔细阅读标准库的文档 <a href=\"https://doc.rust-lang.org/std/sync/index.html\">std::sync</a>，以及 <a href=\"https://doc.rust-lang.org/std/sync/atomic/index.html\">std::sync::atomic</a> 和 <a href=\"https://doc.rust-lang.org/std/sync/mpsc/index.html\">std::sync::mpsc</a>。 尝试着使用 mpsc::channel 在两个线程中<strong>来回</strong>发送消息。比如线程 A 给线程 B 发送：hello world!，线程 B 收到之后回复 goodbye!。</li>\n<li>想想看，如果要你实现 actor model，利用现有的并发原语，你该如何实现呢？</li>\n</ol><p>欢迎在留言区分享你的思考，感谢你的阅读。你已经完成Rust学习的第34次打卡啦，如果觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。我们下节课见。</p>","comments":[{"had_liked":false,"id":326882,"user_name":"×22","can_delete":false,"product_type":"c1","uid":2412446,"ip_address":"","ucode":"68DA918813054E","user_header":"https://static001.geekbang.org/account/avatar/00/24/cf/9e/e695885e.jpg","comment_is_top":false,"comment_ctime":1639731336,"is_pvip":false,"replies":[{"id":"118772","content":"dashmap，如果你的使用场景适合的话，也可以尝试 Jon 写的 left-right: https:&#47;&#47;github.com&#47;jonhoo&#47;left-right","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639791893,"ip_address":"","comment_id":326882,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10229665928","product_id":100085301,"comment_content":"请问一下，目前rust的标准库中并没有类似concurrent hash map等并发安全的集合，虽然第三方库有一些实现，但是不容易从中做出选择，请问老师有什么推荐吗","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539621,"discussion_content":"dashmap，如果你的使用场景适合的话，也可以尝试 Jon 写的 left-right: https://github.com/jonhoo/left-right","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639791893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324864,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1638692922,"is_pvip":false,"replies":[{"id":"118859","content":"对，高级的并发原语都是低级的原语的组合和做了精心的使用限制。我文中有讲到什么样的 channel 大概用了什么样的技术去实现。比如 mpsc，因为 consumer 只有一个，所以实现地好的话 consumer 侧不需要锁。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639848336,"ip_address":"","comment_id":324864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10228627514","product_id":100085301,"comment_content":"Channel 把锁封装在了队列写入和读取的小块区域内，然后把读者和写者完全分离，使得读者读取数据和写者写入数据，对开发者而言，除了潜在的上下文切换外，完全和锁无关，就像访问一个本地队列一样<br><br>这段文字，我还是没有很明白，所谓对于channel和mutex锁的区别，是不是可以这样理解？channel可以看成是一个队列(vec那样的)，然后channel这里就是一头写入一头消费，那么如果有并发的时候，就是对头尾进行加锁，并且会做多一些其他的辅助操作，例如队列满了或者空的时候各种安全检查判断等等，实际上channel就是对mutex+queue的抽象封装？ 多谢了","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539819,"discussion_content":"对，高级的并发原语都是低级的原语的组合和做了精心的使用限制。我文中有讲到什么样的 channel 大概用了什么样的技术去实现。比如 mpsc，因为 consumer 只有一个，所以实现地好的话 consumer 侧不需要锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639848337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350969,"user_name":"Geek_e188ed","can_delete":false,"product_type":"c1","uid":2264479,"ip_address":"","ucode":"A7CCFE385E7C3E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/UmdVZ3v0axr9ymauQGQRyexSK58icbICh9h2hIycfDB7pJFPeYvYVRFW4ql6icXbE7s1RqScra0TP5HL2XWVN5Nw/132","comment_is_top":false,"comment_ctime":1657431055,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5952398351","product_id":100085301,"comment_content":"老师，代码示例有点少啊，比如Channel这块，你的文字描述我都看懂了，但是没有使用Channel的代码示例，可能怎么调用我都不知道","like_count":1,"discussions":[{"author":{"id":2648083,"avatar":"https://static001.geekbang.org/account/avatar/00/28/68/13/452e9331.jpg","nickname":"太南喬 Serendipity!","note":"","ucode":"F1DA88F7E8B2F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580235,"discussion_content":"文檔裡面有範例的\nhttps://doc.rust-lang.org/std/sync/mpsc/index.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658033622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321848,"user_name":"newzai","can_delete":false,"product_type":"c1","uid":1102367,"ip_address":"","ucode":"D5E34D427D65FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/1f/2ef2514b.jpg","comment_is_top":false,"comment_ctime":1637065827,"is_pvip":false,"replies":[{"id":"118912","content":"你可以使用单独的 channel，也可以用 condvar，也可以用第三方封装好的 signal。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639852339,"ip_address":"","comment_id":321848,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5932033123","product_id":100085301,"comment_content":"go经常会使用 chan struct 来作为actor对象的退出信号，rust有什么建议不？不想和数据channel混合在一起。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539873,"discussion_content":"你可以使用单独的 channel，也可以用 condvar，也可以用第三方封装好的 signal。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639852340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321567,"user_name":"终生恻隐","can_delete":false,"product_type":"c1","uid":2739953,"ip_address":"","ucode":"4E21A631545D22","user_header":"https://static001.geekbang.org/account/avatar/00/29/ce/f1/d2fc86bb.jpg","comment_is_top":false,"comment_ctime":1636948722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5931916018","product_id":100085301,"comment_content":"#[test]<br>fn test_mpsc() {<br>    let (a2btx, a2brx) = mpsc::channel();<br>    let (b2atx, b2arx) = mpsc::channel();<br><br>    let threada = thread::spawn(move || {<br>        a2btx.send(&quot;hello world!&quot;.to_string()).unwrap();<br>        for re in b2arx {<br>            println!(&quot;{}\\n&quot;, re);<br>            thread::sleep(Duration::from_secs(1));<br>            a2btx.send(&quot;hello world!&quot;.to_string()).unwrap();<br>        }<br>    });<br><br>    let threadb = thread::spawn(move || {<br>        for re in a2brx {<br>            println!(&quot;{}\\n&quot;, re);<br>            thread::sleep(Duration::from_secs(1));<br>            b2atx.send(&quot;goodbye!&quot;.to_string()).unwrap();<br>        }<br>    });<br><br>    thread::sleep(Duration::from_secs(10));<br>    return<br>}","like_count":1},{"had_liked":false,"id":359885,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"天津","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1666013244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666013244","product_id":100085301,"comment_content":"golang也是有atomic，mutex，rwlock，cond的，而且各种三方库也是把这些原语用得飞起。只是官方一直在强烈建议使用channel来用在大多数场景，这可能就是文中说的“但不该营造一种气氛”?","like_count":0},{"had_liked":false,"id":358661,"user_name":"进击的Lancelot","can_delete":false,"product_type":"c1","uid":2620407,"ip_address":"广东","ucode":"3BCC355801DC61","user_header":"https://static001.geekbang.org/account/avatar/00/27/fb/f7/88ab6f83.jpg","comment_is_top":false,"comment_ctime":1664523634,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1664523634","product_id":100085301,"comment_content":"思考题：https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3604e3e575fd7dbc98c1e926c62583eb","like_count":0},{"had_liked":false,"id":349577,"user_name":"朱叶子","can_delete":false,"product_type":"c1","uid":2819942,"ip_address":"","ucode":"015C66AE526F20","user_header":"https://static001.geekbang.org/account/avatar/00/2b/07/66/b703a6e5.jpg","comment_is_top":false,"comment_ctime":1656084650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656084650","product_id":100085301,"comment_content":"工作线程中，缺了drop(started)，导致主线程无法获取mutex","like_count":0},{"had_liked":false,"id":338999,"user_name":"一雄","can_delete":false,"product_type":"c1","uid":1898574,"ip_address":"","ucode":"DB71F9125BEED5","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f8/4e/3026516d.jpg","comment_is_top":false,"comment_ctime":1647854298,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1647854298","product_id":100085301,"comment_content":"老师，前面发的代码，和小伙伴讨论了一下以后，知道问题在哪里了。在子线程上，lock需要在通知完了condvar之后，需要释放，那个lock。我想到的打补丁的方法是，加个大括号，和老师信息更新一下","like_count":0},{"had_liked":false,"id":338989,"user_name":"一雄","can_delete":false,"product_type":"c1","uid":1898574,"ip_address":"","ucode":"DB71F9125BEED5","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f8/4e/3026516d.jpg","comment_is_top":false,"comment_ctime":1647850865,"is_pvip":true,"discussion_count":2,"race_medal":4,"score":"1647850865","product_id":100085301,"comment_content":"<br>use std::sync::{Arc, Condvar, Mutex};<br>use std::thread;<br>use std::time::Duration;<br><br>fn main() {<br>    let pair = Arc::new((Mutex::new(false), Condvar::new()));<br>    let pair2 = Arc::clone(&amp;pair);<br><br>    thread::spawn(move || {<br>        let (lock, cvar) = &amp;*pair2;<br>        let mut started = lock.lock().unwrap();<br>        *started = true;<br>        eprintln!(&quot;I&#39;m a happy worker!&quot;);<br>        &#47;&#47; 通知主线程<br>        cvar.notify_one();<br>        loop {<br>            thread::sleep(Duration::from_secs(1));<br>            println!(&quot;working...&quot;);<br>        }<br>    });<br><br>    &#47;&#47; 等待工作线程的通知<br>    let (lock, cvar) = &amp;*pair;<br>    let mut started = lock.lock().unwrap();<br>    while !*started {<br>        started = cvar.wait(started).unwrap();<br>    }<br>    eprintln!(&quot;Worker started!&quot;);<br>}<br><br>老师麻烦看一下，这个demo跑不起来，我尝试把loop拿掉发现是有效的，但没理解为什么加了loop就无效了","like_count":0,"discussions":[{"author":{"id":1448126,"avatar":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","nickname":"慕高迪","note":"","ucode":"EB1CB5EA4E3A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560086,"discussion_content":"fn main() {\n    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    let pair2 = Arc::clone(&amp;pair);\n\n    thread::spawn(move || {\n        let (lock, cvar) = &amp;*pair2;\n        let mut started = lock.lock().unwrap();\n        *started = true;\n        eprintln!(&#34;I&#39;m a happy worker!&#34;);\n\n        drop(started); \n\n        // 通知主线程\n        cvar.notify_one();\n\n       \n        loop{\n            thread::sleep(Duration::from_secs(1)); \n            println!(&#34;working...&#34;);\n        }\n    });\n\n    // 等待工作线程的通知\n    let (lock, cvar) = &amp;*pair;\n    let mut started = lock.lock().unwrap();\n    while !*started {\n        started = cvar.wait(started).unwrap();\n    }\n    eprintln!(&#34;Worker started!&#34;);\n    thread::sleep(Duration::from_secs(10)); \n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649165678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1898574,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f8/4e/3026516d.jpg","nickname":"一雄","note":"","ucode":"DB71F9125BEED5","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":1448126,"avatar":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","nickname":"慕高迪","note":"","ucode":"EB1CB5EA4E3A90","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560274,"discussion_content":"嗯，后来解决了，谢谢兄弟。解决方式和你一样，更加透彻地理解了，lock的机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649246189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":560086,"ip_address":""},"score":560274,"extra":""}]}]},{"had_liked":false,"id":321753,"user_name":"千回百转无劫山","can_delete":false,"product_type":"c1","uid":1456256,"ip_address":"","ucode":"2C249889C00929","user_header":"","comment_is_top":false,"comment_ctime":1637030758,"is_pvip":true,"replies":[{"id":"118916","content":"理解正确","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639852756,"ip_address":"","comment_id":321753,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637030758","product_id":100085301,"comment_content":"读完本节有一个感悟，actor model是异步任务级别的“微服务”：发送信息给一个actor，然后从actor再接收信息，就类似于后端中发送一个请求给一个微服务，再接收响应。也就是说，一个actor对应一个“”微服务“”，不知道这种理解是否正确？还有就是，一个actor对应的是类似于tokio的一个task吗？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539877,"discussion_content":"理解正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639852756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321555,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1636946064,"is_pvip":false,"replies":[{"id":"118919","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639853083,"ip_address":"","comment_id":321555,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1636946064","product_id":100085301,"comment_content":"对，合理的使用 Channel，不应该死搬硬套。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539880,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639853083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321524,"user_name":"GengTeng","can_delete":false,"product_type":"c1","uid":1224623,"ip_address":"","ucode":"3F926F5EF1D075","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/af/8b03ce2c.jpg","comment_is_top":false,"comment_ctime":1636939089,"is_pvip":false,"replies":[{"id":"118921","content":"哈哈","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639853097,"ip_address":"","comment_id":321524,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1636939089","product_id":100085301,"comment_content":"笨拙地用 Channel 叠加 Channel 来应对所有的场景?Go: 你直接说我名儿得了。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539882,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639853097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1462209,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4f/c1/7f596aba.jpg","nickname":"给我点阳光就灿烂","note":"","ucode":"F3B0439BE0D062","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415042,"discussion_content":"Go表示不接锅，我也有atomic 和 mutex","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636970228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}