{"id":39838,"title":"26 | 向量化","content":"<p>在上一篇的实践环节中，我给你留了一个题目：如何进一步优化下面这段代码。</p>\n<pre><code>void foo(byte[] dst, byte[] src) {\n  for (int i = 0; i &lt; dst.length - 4; i += 4) {\n    dst[i] = src[i];\n    dst[i+1] = src[i+1];\n    dst[i+2] = src[i+2];\n    dst[i+3] = src[i+3];\n  }\n  ... // post-loop\n}\n</code></pre>\n<p>由于X86_64平台不支持内存间的直接移动，上面代码中的<code>dst[i] = src[i]</code>通常会被编译为两条内存访问指令：第一条指令把<code>src[i]</code>的值读取至寄存器中，而第二条指令则把寄存器中的值写入至<code>dst[i]</code>中。</p>\n<p>因此，上面这段代码中的一个循环迭代将会执行四条内存读取指令，以及四条内存写入指令。</p>\n<p>由于数组元素在内存中是连续的，当从<code>src[i]</code>的内存地址处读取32位的内容时，我们将一并读取<code>src[i]</code>至<code>src[i+3]</code>的值。同样，当向<code>dst[i]</code>的内存地址处写入32位的内容时，我们将一并写入<code>dst[i]</code>至<code>dst[i+3]</code>的值。</p>\n<p>通过综合这两个批量操作，我们可以使用一条内存读取指令以及一条内存写入指令，完成上面代码中循环体内的全部工作。如果我们用<code>x[i:i+3]</code>来指代<code>x[i]</code>至<code>x[i+3]</code>合并后的值，那么上述优化可以被表述成如下所示的代码：</p>\n<pre><code>void foo(byte[] dst, byte[] src) {\n  for (int i = 0; i &lt; dst.length - 4; i += 4) {\n    dst[i:i+3] = src[i:i+3];\n  }\n  ... // post-loop\n}\n</code></pre>\n<h2>SIMD指令</h2>\n<p>在前面的示例中，我们使用的是byte数组，四个数组元素并起来也才4个字节。如果换成int数组，或者long数组，那么四个数组元素并起来将会是16字节或32字节。</p><!-- [[[read_end]]] -->\n<p>我们知道，X86_64体系架构上通用寄存器的大小为64位（即8个字节），无法暂存这些超长的数据。因此，即时编译器将借助长度足够的XMM寄存器，来完成int数组与long数组的向量化读取和写入操作。（为了实现方便，byte数组的向量化读取、写入操作同样使用了XMM寄存器。）</p>\n<p>所谓的XMM寄存器，是由SSE（Streaming SIMD Extensions）指令集所引入的。它们一开始仅为128位。自从X86平台上的CPU开始支持AVX（Advanced Vector Extensions）指令集后（2011年），XMM寄存器便升级为256位，并更名为YMM寄存器。原本使用XMM寄存器的指令，现将使用YMM寄存器的低128位。</p>\n<p>前几年推出的AVX512指令集，更是将YMM寄存器升级至512位，并更名为ZMM寄存器。HotSpot虚拟机也紧跟时代，更新了不少基于AVX512指令集以及ZMM寄存器的优化。不过，支持AVX512指令集的CPU都比较贵，目前在生产环境中很少见到。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/56/f2/56cb8c99ce8a80d1c510ef50122616f2.png?wh=1210*396\" alt=\"\" /></p>\n<p>SSE指令集以及之后的AVX指令集都涉及了一个重要的概念，那便是单指令流多数据流（Single Instruction Multiple Data，SIMD），即通过单条指令操控多组数据的计算操作。这些指令我们称之为SIMD指令。</p>\n<p>SIMD指令将XMM寄存器（或YMM寄存器、ZMM寄存器）中的值看成多个整数或者浮点数组成的向量，并且批量进行计算。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/8a/cf/8ad6be0e44c4f14b45c7c8c4cf6eabcf.png?wh=882*576\" alt=\"\" /></p>\n<p>举例来说，128位XMM寄存器里的值可以看成16个byte值组成的向量，或者8个short值组成的向量，4个int值组成的向量，两个long值组成的向量；而SIMD指令<code>PADDB</code>、<code>PADDW</code>、<code>PADDD</code>以及<code>PADDQ</code>，将分别实现byte值、short值、int值或者long值的向量加法。</p>\n<pre><code>void foo(int[] a, int[] b, int[] c) {\n  for (int i = 0; i &lt; c.length; i++) {\n    c[i] = a[i] + b[i];\n  }\n}\n</code></pre>\n<p>上面这段代码经过向量化优化之后，将使用<code>PADDD</code>指令来实现<code>c[i:i+3] = a[i:i+3] + b[i:i+3]</code>。其执行过程中的数据流如下图所示，图片源自Vladimir Ivanov的演讲[1]。下图中内存的右边是高位，寄存器的左边是高位，因此数组元素的顺序是反过来的。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/d6/40/d61b5f38e3736acf3447412888a32b40.png?wh=1362*1062\" alt=\"\" /></p>\n<p>也就是说，原本需要<code>c.length</code>次加法操作的代码，现在最少只需要<code>c.length/4</code>次向量加法即可完成。因此，SIMD指令也被看成CPU指令级别的并行。</p>\n<blockquote>\n<p>这里<code>c.length/4</code>次是理论值。现实中，C2还将考虑缓存行对齐等因素，导致能够应用向量化加法的仅有数组中间的部分元素。</p>\n</blockquote>\n<h2>使用SIMD指令的HotSpot Intrinsic</h2>\n<p>SIMD指令虽然非常高效，但是使用起来却很麻烦。这主要是因为不同的CPU所支持的SIMD指令可能不同。一般来说，越新的SIMD指令，它所支持的寄存器长度越大，功能也越强。</p>\n<blockquote>\n<p>目前几乎所有的X86_64平台上的CPU都支持SSE指令集，绝大部分支持AVX指令集，三四年前量产的CPU支持AVX2指令集，最近少数服务器端CPU支持AVX512指令集。AVX512指令集的提升巨大，因为它不仅将寄存器长度增大至512字节，而且引入了非常多的新指令。</p>\n</blockquote>\n<p>为了能够尽量利用新的SIMD指令，我们需要提前知道程序会被运行在支持哪些指令集的CPU上，并在编译过程中选择所支持的SIMD指令中最新的那些。</p>\n<p>或者，我们可以在编译结果中纳入同一段代码的不同版本，每个版本使用不同的SIMD指令。在运行过程中，程序将根据CPU所支持的指令集，来选择执行哪一个版本。</p>\n<blockquote>\n<p>虽然程序中包含当前CPU可能不支持的指令，但是只要不执行到这些指令，程序便不会出问题。如果不小心执行到这些不支持的指令，CPU会触发一个中断，并向当前进程发出<code>sigill</code>信号。</p>\n</blockquote>\n<p>不过，这对于使用即时编译技术的Java虚拟机来说，并不是一个大问题。</p>\n<p>我们知道，Java虚拟机所执行的Java字节码是平台无关的。它首先会被解释执行，而后反复执行的部分才会被Java虚拟机即时编译为机器码。换句话说，在进行即时编译的时候，Java虚拟机已经运行在目标CPU之上，可以轻易地得知其所支持的指令集。</p>\n<p>然而，Java字节码的平台无关性却引发了另一个问题，那便是Java程序无法像C++程序那样，直接使用由Intel提供的，将被替换为具体SIMD指令的intrinsic方法[2]。</p>\n<p>HotSpot虚拟机提供的替代方案是Java层面的intrinsic方法，这些intrinsic方法的语义要比单个SIMD指令复杂得多。在运行过程中，HotSpot虚拟机将根据当前体系架构来决定是否将对该intrinsic方法的调用替换为另一高效的实现。如果不，则使用原本的Java实现。</p>\n<p>举个例子，Java 8中<code>Arrays.equals(int[], int[])</code>的实现将逐个比较int数组中的元素。</p>\n<pre><code>    public static boolean equals(int[] a, int[] a2) {\n        if (a==a2)\n            return true;\n        if (a==null || a2==null)\n            return false;\n        int length = a.length;\n        if (a2.length != length)\n            return false;\n        // 关键循环\n        for (int i=0; i&lt;length; i++)\n            if (a[i] != a2[i])\n                return false;\n\n        return true;\n    }\n</code></pre>\n<p>对应的intrinsic高效实现会将数组的多个元素加载至XMM/YMM/ZMM寄存器中，然后进行按位比较。如果两个数组相同，那么其中若干个元素合并而成的值也相同，其按位比较也应成功。反过来，如果按位比较失败，则说明两个数组不同。</p>\n<p>使用SIMD指令的HotSpot intrinsic是虚拟机开发人员根据其语义定制的，因而性能相当优越。</p>\n<p>不过，由于开发成本及维护成本较高，这种类型的intrinsic屈指可数，如用于复制数组的<code>System.arraycopy</code>和<code>Arrays.copyOf</code>，用于比较数组的<code>Arrays.equals</code>，以及Java 9新加入的<code>Arrays.compare</code>和<code>Arrays.mismatch</code>，以及字符串相关的一些方法<code>String.indexOf</code>、<code>StringLatin1.inflate</code>。</p>\n<blockquote>\n<p><code>Arrays.copyOf</code>将调用<code>System.arraycopy</code>，实际上只有后者是intrinsic。在Java 9之后，数组比较真正的intrinsic是<code>ArraySupports.vectorizedMismatch</code>方法，而<code>Arrays.equals</code>、<code>Arrays.compare</code>和<code>Arrays.mismatch</code>将调用至该方法中。</p>\n</blockquote>\n<p>另外，这些intrinsic方法只能做到点覆盖，在不少情况下，应用程序并不会用到这些intrinsic的语义，却又存在向量化优化的机会。这个时候，我们便需要借助即时编译器中的自动向量化（auto vectorization）。</p>\n<h2>自动向量化</h2>\n<p>即时编译器的自动向量化将针对能够展开的计数循环，进行向量化优化。如前面介绍过的这段代码，即时编译器便能够自动将其展开优化成使用<code>PADDD</code>指令的向量加法。</p>\n<pre><code>void foo(int[] a, int[] b, int[] c) {\n  for (int i = 0; i &lt; c.length; i++) {\n    c[i] = a[i] + b[i];\n  }\n}\n</code></pre>\n<p>关于计数循环的判定，我在上一篇介绍循环优化时已经讲解过了，这里我补充几点自动向量化的条件。</p>\n<ol>\n<li>循环变量的增量应为1，即能够遍历整个数组。</li>\n<li>循环变量不能为long类型，否则C2无法将循环识别为计数循环。</li>\n<li>循环迭代之间最好不要有数据依赖，例如出现类似于<code>a[i] = a[i-1]</code>的语句。当循环展开之后，循环体内存在数据依赖，那么C2无法进行自动向量化。</li>\n<li>循环体内不要有分支跳转。</li>\n<li>不要手工进行循环展开。如果C2无法自动展开，那么它也将无法进行自动向量化。</li>\n</ol>\n<p>我们可以看到，自动向量化的条件较为苛刻。而且，C2支持的整数向量化操作并不多，据我所致只有向量加法，向量减法，按位与、或、异或，以及批量移位和批量乘法。C2还支持向量点积的自动向量化，即两两相乘再求和，不过这需要多条SIMD指令才能完成，因此并不是十分高效。</p>\n<p>为了解决向量化intrinsic以及自动向量化覆盖面过窄的问题，我们在OpenJDK的Paname项目[3]中尝试引入开发人员可控的向量化抽象。</p>\n<p>该抽象将提供一套通用的跨平台API，让Java程序能够定义诸如<code>IntVector&lt;S256Bits&gt;</code>的向量，并使用由它提供的一系列向量化intrinsic方法。即时编译器负责将这些intrinsic的调用转换为符合当前体系架构/CPU的SIMD指令。如果你感兴趣的话，可以参考Vladimir Ivanov今年在JVMLS上的演讲[4]。</p>\n<h2>总结与实践</h2>\n<p>今天我介绍了即时编译器中的向量化优化。</p>\n<p>向量化优化借助的是CPU的SIMD指令，即通过单条指令控制多组数据的运算。它被称为CPU指令级别的并行。</p>\n<p>HotSpot虚拟机运用向量化优化的方式有两种。第一种是使用HotSpot intrinsic，在调用特定方法的时候替换为使用了SIMD指令的高效实现。Intrinsic属于点覆盖，只有当应用程序明确需要这些intrinsic的语义，才能够获得由它带来的性能提升。</p>\n<p>第二种是依赖即时编译器进行自动向量化，在循环展开优化之后将不同迭代的运算合并为向量运算。自动向量化的触发条件较为苛刻，因此也无法覆盖大多数用例。</p>\n<hr />\n<p>今天的实践环节，我们来观察一下即时编译器的自动向量化的自适配性。</p>\n<p>在支持256位YMM寄存器的机器上，C2会根据循环回边的执行次数以及方法的执行次数来推测每个循环的次数。如果超过一定值，C2会采用基于256位YMM寄存器的指令，相比起基于128位XMM寄存器的指令而言，单指令能处理的数据翻了一倍。</p>\n<p>请采用Java 9以上的版本运行下述代码。（Java 8始终采用基于128位XMM寄存器指令的Bug可能仍未修复。）</p>\n<pre><code>// Run with \n// java -XX:CompileCommand='dontinline VectorizationTest.foo' -XX:CompileCommand='print VectorizationTest.foo' -XX:-TieredCompilation VectorizationTest\npublic class VectorizationTest {\n  static void foo(int[] a, int[] b, int[] c) {\n    for (int i = 0; i &lt; a.length; i++) {\n      c[i] = a[i] + b[i];\n    }\n  }\n  public static void main(String[] args) throws InterruptedException {\n    int[] a = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8 };\n    int[] c = new int[16];\n    for (int i = 0; i &lt; 20_000; i++) {\n      foo(a, a, c);\n    }\n    Thread.sleep(2000);\n  }\n}\n</code></pre>\n<p>输出将包含如下机器码：</p>\n<pre><code>  0x000000011ce7c650: vmovdqu xmm0,XMMWORD PTR [rdx+rbx*4+0x10]\n  0x000000011ce7c656: vpaddd xmm0,xmm0,XMMWORD PTR [rsi+rbx*4+0x10]\n  0x000000011ce7c65c: vmovdqu XMMWORD PTR [rcx+rbx*4+0x10],xmm0\n</code></pre>\n<p>如果替换为：</p>\n<pre><code>    int[] a = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8 };\n    int[] c = new int[32];\n</code></pre>\n<p>输出将包含如下机器码：</p>\n<pre><code>  0x000000010ff04d9c: vmovdqu ymm0,YMMWORD PTR [rdx+rbx*4+0x10]\n  0x000000010ff04da2: vpaddd ymm0,ymm0,YMMWORD PTR [rsi+rbx*4+0x10]\n  0x000000010ff04da8: vmovdqu YMMWORD PTR [rcx+rbx*4+0x10],ymm0\n\n---\n</code></pre>\n<p>你可以将<code>foo</code>方法更改为下述代码：</p>\n<pre><code>  static void foo(int[] a) {\n    for (int i = 4; i &lt; a.length; i++) {\n      a[i] = a[i - 4];\n    }\n  }\n</code></pre>\n<p>重复上述实验，看看会发生什么。</p>\n<p>[1] <a href=\"http://cr.openjdk.java.net/~vlivanov/talks/2017_Vectorization_in_HotSpot_JVM.pdf\">http://cr.openjdk.java.net/~vlivanov/talks/2017_Vectorization_in_HotSpot_JVM.pdf</a><br />\n[2] <a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/</a><br />\n[3] <a href=\"http://openjdk.java.net/projects/panama/\">http://openjdk.java.net/projects/panama/</a><br />\n[4]: <a href=\"http://cr.openjdk.java.net/~vlivanov/talks/2018_JVMLS_VectorAPI.pdf\">http://cr.openjdk.java.net/~vlivanov/talks/2018_JVMLS_VectorAPI.pdf</a><br />\n</p>\n","comments":[{"had_liked":false,"id":25735,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1537428778,"is_pvip":false,"replies":[{"id":"9400","content":"赞","user_name":"作者回复","comment_id":25735,"uid":"1176688","ip_address":"","utype":1,"ctime":1537449845,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"126091480362","product_id":100010301,"comment_content":"小结一下<br>1：向量化优化-本质是一次性多干一些活，免得来回折腾费时费力，通过减少来回折腾的工作量来提高性能。他是怎么实现的呢？他是借助CPU的SIMD指令，通过单条指令控制多组数据的运算，实现了CPU指令级别的并行。<br>2：这么好为什么不大批量的使用哪？他有几种方式呢？<br>使用向量化优化是有一些前提条件的，目前HotSpot 虚拟机运用向量化优化的方式有两种。第一种使用HotSpot intrinsic，在调用特定的方法的时候替换为使用了SIMD指令的高效实现。第二种是依赖即时编译器进行的自动向量化，自动向量化也有苛刻的使用前提条件。","like_count":30,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424402,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537449845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25299,"user_name":"罗布圆滚滚","can_delete":false,"product_type":"c1","uid":1177911,"ip_address":"","ucode":"BEC21A36976C14","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/37/3a5d73ad.jpg","comment_is_top":false,"comment_ctime":1537295942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18717165126","product_id":100010301,"comment_content":"好棒哦！学到很多","like_count":4},{"had_liked":false,"id":25682,"user_name":"Geek_488a8e","can_delete":false,"product_type":"c1","uid":1184696,"ip_address":"","ucode":"2B767F53DB902F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erozFScHpVRM5OCwMW7giaM13NE7gN5iatw9Ozwu93ibRZZjmSmcfzBLSXs8tYtwW7Q2E8eUdy9lGl5A/132","comment_is_top":false,"comment_ctime":1537409339,"is_pvip":false,"replies":[{"id":"9350","content":"我们做自动向量化也会考虑值不值得的问题。<br><br>比如说X86不能在通用寄存器上计算，有时候需要额外的mov指令移到XMM中(如果不是直接从内存中加载的话)。<br><br>另外，某些reduce操作，比如求向量内所有元素的和，X86无法用单条指令实现，只有两两相加的指令，因此需要好几条向量指令协作完成。这种情况下，我们便会放弃自动向量化。","user_name":"作者回复","comment_id":25682,"uid":"1176688","ip_address":"","utype":1,"ctime":1537434444,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14422311227","product_id":100010301,"comment_content":"之前用过TI的DSP芯片，里边有很多支持向量处理的计算指令，比如复数乘法，共轭相乘等，但是这些计算指令器不多，而且不能在一个指令周期完成计算，所以大量使用后会影响指令流水，反而不如能在一个指令周期完成计算的单数据加法器","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424388,"discussion_content":"我们做自动向量化也会考虑值不值得的问题。\n\n比如说X86不能在通用寄存器上计算，有时候需要额外的mov指令移到XMM中(如果不是直接从内存中加载的话)。\n\n另外，某些reduce操作，比如求向量内所有元素的和，X86无法用单条指令实现，只有两两相加的指令，因此需要好几条向量指令协作完成。这种情况下，我们便会放弃自动向量化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537434444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326718,"user_name":"SochiLee","can_delete":false,"product_type":"c1","uid":1537865,"ip_address":"","ucode":"47596594EDF4D7","user_header":"https://static001.geekbang.org/account/avatar/00/17/77/49/445eea2d.jpg","comment_is_top":false,"comment_ctime":1639643073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639643073","product_id":100010301,"comment_content":"我看网上说SIMD是单指令多数据，并不是指令并行。","like_count":0},{"had_liked":false,"id":309107,"user_name":"宋世通","can_delete":false,"product_type":"c1","uid":1245468,"ip_address":"","ucode":"C7AA3F0E6930F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/1c/d638d46e.jpg","comment_is_top":false,"comment_ctime":1629945692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629945692","product_id":100010301,"comment_content":"又一次打开了新世界的大门","like_count":0},{"had_liked":false,"id":289805,"user_name":"null","can_delete":false,"product_type":"c1","uid":1087337,"ip_address":"","ucode":"3D3B4B7E00C0DA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep647VHejicQ4Rccy8krSFwHiaroYdjnkQud7YYvAKWQtlqibd9OrTm6DXGCIe5s3NWhiczumnphkUNbQ/132","comment_is_top":false,"comment_ctime":1619181341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619181341","product_id":100010301,"comment_content":"请问，Java如何面向SIMD变成，多用数组吗？有什么开发技巧？lucene专门用了，但是看不懂","like_count":0},{"had_liked":false,"id":232842,"user_name":"李孟","can_delete":false,"product_type":"c1","uid":1006768,"ip_address":"","ucode":"AD2349CB12F130","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/b0/77e5f8c8.jpg","comment_is_top":false,"comment_ctime":1594127854,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1594127854","product_id":100010301,"comment_content":"1.向量优化借助CPU的SIMD指令，即通过单条指令控制多组数据的运算。它被称为CPU指令级别的并行<br>2.HotSpot 虚拟机运用向量化优化的方式有两种：HotSpot intrinsic，循环展开优化","like_count":0},{"had_liked":false,"id":224039,"user_name":"任鑫","can_delete":false,"product_type":"c1","uid":1142025,"ip_address":"","ucode":"9803EB15B634C3","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/09/ffeabc27.jpg","comment_is_top":false,"comment_ctime":1591261435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591261435","product_id":100010301,"comment_content":"写编译器、虚拟机的确实都是大佬","like_count":0},{"had_liked":false,"id":207344,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1587050962,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1587050962","product_id":100010301,"comment_content":"也就是说java因为本身的语言特性限制，无法支持使用到某些CPU指令，从而不能使用它们来进行性能优化？","like_count":0,"discussions":[{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285585,"discussion_content":"使用都可以使用，只是没法直接使用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592884474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165545,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1577257229,"is_pvip":false,"replies":[{"id":"65537","content":"伪代码","user_name":"作者回复","comment_id":165545,"uid":"1176688","ip_address":"","utype":1,"ctime":1578265290,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1577257229","product_id":100010301,"comment_content":"dst[i:i+3] = src[i:i+3] 这是伪代码还是新版的 JDK 支持的写法？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479199,"discussion_content":"伪代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578265290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145643,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1572336052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572336052","product_id":100010301,"comment_content":"SIMD，寄存器每次存好几条数据，那么就一次性拿这么多数据放到寄存器中，统一用一个向量相关的指令来算。这样一下子就可以算了循环中的很多次，相当于我们在并行执行某个循环。<br>另外从寄存器中读写数据比内存快了很多很多倍。","like_count":0},{"had_liked":false,"id":124704,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1565947849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565947849","product_id":100010301,"comment_content":"666，学到了","like_count":0},{"had_liked":false,"id":90026,"user_name":"渡劫达摩","can_delete":false,"product_type":"c1","uid":1465391,"ip_address":"","ucode":"A7005CBB34B698","user_header":"https://static001.geekbang.org/account/avatar/00/16/5c/2f/a9c8d42f.jpg","comment_is_top":false,"comment_ctime":1556370640,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1556370640","product_id":100010301,"comment_content":"<br>    dst[i:i+3] = src[i:i+3]还有这种写法？是大哥省略了部分代码吗？","like_count":0,"discussions":[{"author":{"id":1447739,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eou1BMETumU21ZI4yiaLenOMSibzkAgkw944npIpsJRicmdicxlVQcgibyoQ00rdGk9Htp1j0dM5CP2Fibw/132","nickname":"寥若晨星","note":"","ucode":"2E87E43687DE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552346,"discussion_content":"这是伪代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645424568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}