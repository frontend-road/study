{"id":264199,"title":"13 | 如何给简单的图案添加纹理和复杂滤镜？","content":"<p>你好，我是月影。</p><p>上一课我们讲了两类处理像素的滤镜，分别是颜色滤镜和高斯滤镜。其中，<strong>颜色滤镜是基本的简单滤镜</strong>。因为简单滤镜里的每个像素都是独立的，所以它的处理结果<strong>不依赖于其他像素点的信息</strong>，因此应用起来也比较简单。<strong>而高斯滤镜也就是平滑效果滤镜</strong>，它是最基本的<strong>复杂滤镜</strong>。复杂滤镜的处理结果不仅与当前像素有关，还与其周围的像素点有关，所以应用起来很复杂。</p><p>当然了，颜色滤镜和高斯滤镜能够实现的视觉效果有限。如果想要实现更复杂的视觉效果，我们还需要使用更多其他的滤镜。所以这一节课，我们就来说说，怎么结合不同滤镜实现更复杂的视觉效果。</p><h2>其他简单滤镜在Canvas中的应用</h2><p>我们知道，简单滤镜的处理效果和像素点的颜色有关。其实，还有一些简单滤镜的处理效果和像素点的坐标、外部环境（比如鼠标位置、时间）有关。这些滤镜虽然也是简单滤镜，但能实现的效果可不简单。让我们来看几个有趣的例子。</p><p><strong>第一个例子，实现图片边缘模糊的效果。</strong></p><pre><code>import {loadImage, getImageData, traverse} from './lib/util.js';\nconst canvas = document.getElementById('paper');\nconst context = canvas.getContext('2d');\n(async function () {\n  const img = await loadImage('assets/girl1.jpg');\n  const imageData = getImageData(img);\n  traverse(imageData, ({r, g, b, a, x, y}) =&gt; {\n    const d = Math.hypot((x - 0.5), (y - 0.5));\n    a *= 1.0 - 2 * d;\n    return [r, g, b, a];\n  });\n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n  context.putImageData(imageData, 0, 0);\n}());\n</code></pre><p>如上面代码所示，我们可以在遍历像素点的时候计算当前像素点到图片中心点的距离，然后根据距离设置透明度，这样我们就可以实现下面这样的边缘模糊效果了。</p><p><img src=\"https://static001.geekbang.org/resource/image/33/c0/33450156f67efc94d33e6f93ea8b93c0.jpg?wh=1000*554\" alt=\"\" title=\"边缘模糊效果示意图\"></p><p><strong>第二个，我们可以利用像素处理实现图片融合</strong>。比如说，我们可以给一张照片加上阳光照耀的效果。具体操作就是，把下面这张透明的PNG图片叠加到一张照片上。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/fe/1e/fe66ffff1ff6bd738bbb3ca4e037671e.jpg?wh=1000*554\" alt=\"\" title=\"纹理\"></p><p>这种能叠加到其他照片上的图片，通常被称为<strong>纹理</strong>（Texture），叠加后的效果也叫做纹理效果。纹理与图片叠加的代码和效果如下：</p><pre><code>import {loadImage, getImageData, traverse, getPixel} from './lib/util.js';\nimport {transformColor, brightness, saturate} from './lib/color-matrix.js';\nconst canvas = document.getElementById('paper');\nconst context = canvas.getContext('2d');\n(async function () {\n  const img = await loadImage('assets/girl1.jpg');\n  const sunlight = await loadImage('assets/sunlight.png');\n  const imageData = getImageData(img);\n  const texture = getImageData(sunlight);\n  traverse(imageData, ({r, g, b, a, index}) =&gt; {\n    const texColor = getPixel(texture, index);\n    return transformColor([r, g, b, a], brightness(1 + 0.7 * texColor[3]), saturate(2 - texColor[3]));\n  });\n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n  context.putImageData(imageData, 0, 0);\n}());\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/5c/71/5cbf83d6217e5a1062e4c8380af85271.jpg?wh=1000*554\" alt=\"\" title=\"阳光照耀效果图\"></p><p>另外，我们还可以选择不同的图片，来实现不同的纹理叠加效果，比如爆炸效果、水波效果等等。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/7f/2c74538c71c23577a8d87b572335c57f.jpg?wh=1000*554\" alt=\"\" title=\"爆炸效果图\"></p><p>纹理叠加能实现的效果非常多，所以它也是像素处理中的基础操作。不过，不管我们是用Canvas的ImageData API处理像素、应用滤镜还是纹理合成都有一个弊端，那就是我们必须循环遍历图片上的每个像素点。如果这个图片很大，比如它是2000px宽、2000px高，我们就需要遍历400万像素！这个计算量是相当大的。</p><p>因为在前面的例子中，我们生成的都只是静态的图片效果，所以这个计算量的问题还不明显。一旦我们想要利用像素处理，制作出更酷炫的动态效果，这样的计算量注定会成为性能瓶颈。这该怎么办呢？</p><p>好在，我们还有WebGL这个神器。WebGL通过运行着色器代码来完成图形的绘制和输出。其中，片元着色器负责处理像素点的颜色。那接下来，我们来说说如何用片元着色器处理像素。</p><h2>片元着色器是怎么处理像素的？</h2><p>如果想要在片元着色器中处理像素，我们需要先将图片的数据信息读取出来，交给WebGL程序来处理，这样我们就可以在着色器中处理了。</p><p>那么如何将图片数据信息读取出来呢？在WebGL中，我们会使用特殊的一种对象，叫做<strong>纹理对象</strong>（Texture）。我们将纹理对象作为一种特殊格式的变量，通过uniform传递给着色器，这样就可以在着色器中处理了。</p><p>纹理对象包括了整张图片的所有像素点的颜色信息，在着色器中，我们可以通过纹理坐标来读取对应的具体坐标处像素的颜色信息。纹理坐标是一个变量，类型是二维向量，x、y的值从0到1。在我们前面的课程里已经见过这个变量，就是我们传给顶点着色器的uv属性，对应片元着色器中的vUv变量。</p><p>因此，着色器中是可以加载纹理对象的。具体来说就是，我们先通过图片或者Canvas对象来创建纹理对象，然后通过uniform变量把它传入着色器。这样，我们再通过纹理坐标vUv就可以从加载的纹理对象上获取颜色信息。</p><h3>1. 加载纹理</h3><p>下面，我就详细说说每一步的具体操作。</p><p><strong>首先是创建纹理对象</strong>。这个步骤比较复杂，因为设置不同的参数可以改变我们在Shader中对纹理取色的行为，所以其中最复杂的是参数部分。但在这里我们不需要知道太多，你先记住我在代码里给出的这几个就够了。其他的，如果之后需要用到，你再去参考<a href=\"https://zhuanlan.zhihu.com/p/68894334\">相关的资料</a>就可以了。代码如下所示：</p><pre><code>function createTexture(gl, img) {\n  // 创建纹理对象\n  const texture = gl.createTexture();\n  \n  // 设置预处理函数，由于图片坐标系和WebGL坐标的Y轴是反的，这个设置可以将图片Y坐标翻转一下\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n  \n  // 激活指定纹理单元，WebGL有多个纹理单元，因此在Shader中可以使用多个纹理\n  gl.activeTexture(gl.TEXTURE0);\n  \n  // 将纹理绑定到当前上下文\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  \n  // 指定纹理图像\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n  \n  // 设置纹理的一些参数\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n}\n  // 解除纹理绑定\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  \n  return texture;\n}\n</code></pre><p>纹理创建完成之后，我们还要<strong>设置纹理</strong>。具体来说就是，通过gl.activeTexture将对象绑定到纹理单元，再把纹理单元编号通过uniform写入shader变量中。</p><pre><code>function setTexture(gl, idx) {\n  // 激活纹理单元\n  gl.activeTexture(gl.TEXTURE0 + idx);\n  // 绑定纹理\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  // 获取shader中纹理变量\n  const loc = gl.getUniformLocation(program, 'tMap');\n  // 将对应的纹理单元写入shader变量\n  gl.uniform1i(loc, idx);\n  // 解除纹理绑定\n  gl.bindTexture(gl.TEXTURE_2D, null);\n}\n</code></pre><p>这样设置完成之后，我们就可以在Shader中使用纹理对象了。使用的代码如下：</p><pre><code>uniform sampler2D tMap;\n\n...\n\nvec3 color = texture2D(tMap, vUv); // 从纹理中提取颜色，vUv是纹理坐标\n</code></pre><p>总的来说，在WebGL中，从创建纹理、设置纹理到使用纹理的步骤非常多，使用上可以说是非常繁琐了。方便起见，这里我们可以直接使用上一节课用过的gl-renderer库。经过gl-renderer库的封装之后，我们通过renderer.loadTexture就可以创建并加载纹理，然后直接将纹理对象本身作为renderer的uniforms属性值即可，就不用去关注其他细节了。具体的操作代码如下：</p><pre><code>const texture = await renderer.loadTexture(imgURL);\n\nrenderer.uniforms.tMap = texture;\n</code></pre><p>知道了原理，接下来，我们就一起来动手把图片创建为纹理，然后加载到Shader中去使用吧。</p><p>首先，我们读取图片纹理并加载，代码如下所示。</p><pre><code>const texture = await renderer.loadTexture('https://p1.ssl.qhimg.com/t01cca5849c98837396.jpg');\nrenderer.uniforms.tMap = texture;\n\nrenderer.setMeshData([{\n  positions: [\n    [-1, -1],\n    [-1, 1],\n    [1, 1],\n    [1, -1],\n  ],\n  attributes: {\n    uv: [\n      [0, 0],\n      [0, 1],\n      [1, 1],\n      [1, 0],\n    ],\n  },\n  cells: [[0, 1, 2], [2, 0, 3]],\n}]);\n\nrenderer.render();\n</code></pre><p>然后，我们直接对纹理对象取色。对应的片元着色器代码如下所示：</p><pre><code>#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D tMap;\nvarying vec2 vUv;\n\nvoid main() {\n    gl_FragColor = texture2D(tMap, vUv);\n}\n\n</code></pre><p>在片元着色器中，我们使用texture2D函数来获取纹理的颜色。这个函数支持两个参数，一个是纹理单元的uniform变量，另一个是要获取像素的坐标，这个坐标就是我们之前用过的uv纹理坐标。在这个片元着色器代码里，我们只是根据vUv坐标将纹理图片上对应的颜色取出来，其他什么也没做，所以画布上最终呈现出来的还是原始图片。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/36/d22c3ff49fd473b4cb6b52f036542a36.jpg?wh=1000*554\" alt=\"\"></p><h3>2. 实现滤镜</h3><p>加载完纹理之后，我们就可以在它的基础上实现滤镜了。用Shader实现滤镜的方法也很简单，为了方便你理解，这次我们就只实现图片灰度化。我们可以在前面加载纹理的基础上，引入颜色矩阵，修改后的片元着色器代码如下：</p><pre><code>#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D tMap;\nuniform mat4 colorMatrix;\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 color = texture2D(tMap, vUv);\n    gl_FragColor = colorMatrix * vec4(color.rgb, 1.0);\n    gl_FragColor.a = color.a;\n}\n</code></pre><p>然后，你可以把这段代码和我们刚才加载纹理的代码做个比较。你会发现，刚才我们只是简单地把color从纹理坐标中取出，直接把它设置给gl_FragColor。而现在，我们在设置gl_FragColor的时候，是先把颜色和colorMatrix相乘。这样其实就相当于是对颜色向量做了一个仿射变换。</p><p>对应地，我们修改一下前面的JavaScript代码。其中最主要的修改操作，就是通过uniform引入了一个colorMatrix。修改后的代码如下：</p><pre><code>const texture = await renderer.loadTexture('https://p1.ssl.qhimg.com/t01cca5849c98837396.jpg');\nrenderer.uniforms.tMap = texture;\nconst r = 0.2126,\n  g = 0.7152,\n  b = 0.0722;\nrenderer.uniforms.colorMatrix = [\n  r, r, r, 0,\n  g, g, g, 0,\n  b, b, b, 0,\n  0, 0, 0, 1,\n];\n\nrenderer.setMeshData([{\n  positions: [\n    [-1, -1],\n    [-1, 1],\n    [1, 1],\n    [1, -1],\n  ],\n  attributes: {\n    uv: [\n      [0, 0],\n      [0, 1],\n      [1, 1],\n      [1, 0],\n    ],\n  },\n  cells: [[0, 1, 2], [2, 0, 3]],\n}]);\n\nrenderer.render();\n</code></pre><p>还记得吗？上一节课我们也实现了一个颜色矩阵，那它们有什么区别呢？区别主要有两个。</p><p>首先，上一节课的颜色矩阵是一个4<em>5的矩阵，但是因为GLSL语法在数据类型上不能直接支持mat4（4</em>4）以上的矩阵，所以我们要计算4*5矩阵很不方便。而且在通常情况下，我们不经常处理颜色的alpha值，所以这里我就把alpha通道忽略了，只对RGB做矩阵变换，这样我们用mat4的齐次矩阵就够了。</p><p>其次，根据标准的矩阵与向量乘法的法则，应该是向量与矩阵的列相乘，所以我把这次传入的矩阵转置了一下，把按行排列的rgba换成按列排列，就得到了下面这个矩阵。</p><pre><code>renderer.uniforms.colorMatrix = [\n  r, r, r, 0,\n  g, g, g, 0,\n  b, b, b, 0,\n  0, 0, 0, 1,\n];\n</code></pre><p>这样，我们就实现了与上一节课一样的图片灰度化的功能，它是使用片元着色器实现的，在性能上要远远高于Canvas2D。</p><h3>3. 实现图片的粒子化</h3><p>不过，用Shader只处理颜色滤镜就有些大材小用了，利用Shader的高性能我们可以实现一些更加复杂的效果，比如，给图片实现一个粒子化的渐显效果。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/02/ea/02df04608e76c0920ac9ef1525c42aea.gif?wh=506*284\" alt=\"\"></p><p>这个视觉效果如果在Canvas2D中实现，需要大量的运算，非常耗费性能，几乎不太可能流畅地运行起来，但是在WebGL的Shader中就可以轻松做到。究竟是怎么做到的呢？</p><p>我们重点来看一下Fragment Shader的代码。</p><pre><code>#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D tMap;\nuniform float uTime;\nvarying vec2 vUv;\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid main() {\n    vec2 st = vUv * vec2(100, 55.4);\n    vec2 uv = vUv + 1.0 - 2.0 * random(floor(st));\n    vec4 color = texture2D(tMap, mix(uv, vUv, min(uTime, 1.0)));\n    gl_FragColor.rgb = color.rgb;\n    gl_FragColor.a = color.a * uTime;\n}\n</code></pre><p>这段代码虽然不长，但如果你还不太熟悉Shader，可能一眼看去，很难直接了解具体的作用，不要紧，我们一步一步来看。</p><p>首先，我们使用第11节课学过的重复网格技巧，将图形网格化。因为原始图像的图片像素宽高是1000px和554px，所以我们用 vec2 st = vUv * vec2(100, 55.4) 就可以得到10px X 10px大小的网格。</p><p>然后，我们再用伪随机函数random 根据网格随机一个偏移量，因为这个偏移量是0~1之间的值，我们将它乘以2再用1减去它，就能得到一个范围在-1~1之间的随机偏移。这样我们从纹理取色的时候，不是直接从对应的纹理坐标vUv处取色，而是从这个随机偏移的位置取色，就能保证取出来的颜色就是一个乱序的色值。这时候，图片显示的效果是一片随机的画面：</p><p><img src=\"https://static001.geekbang.org/resource/image/20/3d/20dc4c07e075da18a44975142e79913d.jpg?wh=1000*554\" alt=\"\"></p><p>接着，我们引入uTime变量，用mix函数对偏移后的uv和原始的vUv相对于时间变化进行插值。当初始时间为0的时候，取色从uv取；当时间超过一个周期的时候，取色从vUv取；当时间在中间时，取值介于uv和vUv之间。</p><p>最后，我们再把uTime也和透明度关联起来。这样就实现了你上面看到的粒子化的渐显效果。</p><p>当然，这个效果做得其实还比较粗糙，因为我们引入的变量比较少，在后续的课程中，我们会一步一步深入，继续实现更加惊艳的效果。在课后，你也可以试着实现其他的效果，然后把你的成果分享出来。</p><h3>4. 实现图像合成</h3><p>除此之外，Fragment Shader还可以引入多纹理，让我们可以很方便地实现图像合成。比如说，对于在电影场景合成中比较常用的绿幕图片，我们就可以使用shader技术把它实时地合成到其他的图像上。</p><p>举个例子，现在我们有一张带有猫的绿幕图片。</p><p><img src=\"https://static001.geekbang.org/resource/image/20/cc/20febddf9e1edbb9e7bd349e544f24cc.jpg?wh=538*300\" alt=\"\" title=\"带有猫的绿幕图片\"></p><p>我们要通过Fragment Shader将它合成到“高尔夫”那张照片上，具体的shader代码如下：</p><pre><code>#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D tMap;\nuniform sampler2D tCat;\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 color = texture2D(tMap, vUv);\n    vec2 st = vUv * 3.0 - vec2(1.2, 0.5);\n    vec4 cat = texture2D(tCat, st);\n\n    gl_FragColor.rgb = cat.rgb;\n    if(cat.r &lt; 0.5 &amp;&amp; cat.g &gt; 0.6) {\n      gl_FragColor.rgb = color.rgb;\n    }\n    gl_FragColor.a = color.a;\n}\n</code></pre><p>如上面的代码所示，我们可以先通过tCat纹理获取绿幕图片。如果RGB通道中的G通道超过阈值，且R通道低于阈值，我们就可以接着把猫的图像从纹理中定位出来。然后经过缩放和平移变换等操作，我们就能把它放置到画面中适当的位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/dc/d2d1aacc6cc7c7c6a19c24ea821564dc.jpg?wh=1000*554\" alt=\"\"></p><h2>要点总结</h2><p>今天，我们讨论了边缘模糊和纹理叠加这两种滤镜，并且重点学习了用Shader加载纹理和实现滤镜的方法。</p><p>首先，我们知道了什么是边缘模糊，边缘模糊很容易实现，只要我们在遍历像素点的时候，同时计算当前像素点到图片中心点的距离，然后根据距离设置透明度，就可以实现边缘模糊的效果。</p><p>然后， 我们重点讲了Shader中的纹理叠加滤镜。</p><p>要实现这个滤镜，我们要先加载纹理，获取纹理的颜色。用Shader加载纹理的过程比较复杂，但我们可以使用一些封装好的库，如gl-renderer来简化纹理的加载。那在获取纹理的颜色的时候，我们可以通过texture2D函数读取纹理单元对应的uv坐标处的像素颜色。</p><p>加载了纹理之后呢，我们就可以通过纹理结合滤镜函数来处理像素，这就是纹理滤镜的应用场景了。通过纹理滤镜，我们不仅可以实现灰度化图片，还可以图片的粒子化渐显等等更加复杂的效果</p><p>除此之外，我们还可以使用shader加载多个纹理图片，把它们的颜色按照不同的方式进行叠加，从而实现图像合成。图像合成虽然在可视化中使用得比较少，但它非常适合用来实现一些特殊的视觉效果。</p><h2>小试牛刀</h2><ol>\n<li>\n<p>你可以完善一下片元着色器中的颜色滤镜函数，实现灰度效果以外的效果吗？</p>\n</li>\n<li>\n<p>上节课，我们用Canvas2D实现了平滑效果滤镜，其实我们也可以用Fragment Shader结合纹理的形式把它实现出来，你能做到吗？</p>\n</li>\n<li>\n<p>如果我们想让一个图片的某个局部呈现“马赛克”效果，该用什么滤镜？你能把它实现出来吗？</p>\n</li>\n</ol><h2>欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这节课分享给你的朋友，我们下节课见！</h2><h2><span class=\"reference\">源码</span></h2><p><span class=\"reference\"><a href=\"https://github.com/akira-cn/graphics/tree/master/pixels-shader\">课程示例代码</a></span></p><h2><span class=\"reference\">推荐阅读</span></h2><p><span class=\"reference\"><a href=\"https://zhuanlan.zhihu.com/p/68894334\">Texture的参数设置参考文档</a></span></p>","comments":[{"had_liked":false,"id":303734,"user_name":"MG.Fre","can_delete":false,"product_type":"c1","uid":2438273,"ip_address":"","ucode":"F13921B03CC4D5","user_header":"https://static001.geekbang.org/account/avatar/00/25/34/81/f44f2f11.jpg","comment_is_top":false,"comment_ctime":1626949017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5921916313","product_id":100053801,"comment_content":"马赛克效果：对纹理坐标做放大缩小处理，st = floor(vUv * 50.0) &#47; 50.0；精度丢失；局部马赛克的话，加坐标范围的判断就可以了。","like_count":1},{"had_liked":false,"id":236233,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1595374886,"is_pvip":false,"replies":[{"id":"87572","content":"如果你说的是随机数函数里的数字，那个数字就是随便写的一个大数，因为伪随机用正弦函数小数点后几位来模拟随机","user_name":"作者回复","comment_id":236233,"uid":"1159792","ip_address":"","utype":1,"ctime":1595643369,"user_name_real":"月影"}],"discussion_count":2,"race_medal":0,"score":"5890342182","product_id":100053801,"comment_content":"shader中有很多数字，为什么是这些数字？","like_count":1,"discussions":[{"author":{"id":1159792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b2/70/ba9cecc6.jpg","nickname":"月影","note":"","ucode":"298582FA7DBF27","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501996,"discussion_content":"如果你说的是随机数函数里的数字，那个数字就是随便写的一个大数，因为伪随机用正弦函数小数点后几位来模拟随机","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595643369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1511744,"avatar":"https://static001.geekbang.org/account/avatar/00/17/11/40/ee498a86.jpg","nickname":"scqilin","note":"","ucode":"F572FD9CA79F17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292936,"discussion_content":"12.9898,78.233和43758.5453是生成白噪声图的经验数，是前人总结出来的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595387715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299699,"user_name":"Geek3340","can_delete":false,"product_type":"c1","uid":2028953,"ip_address":"","ucode":"C64D302CD53513","user_header":"","comment_is_top":false,"comment_ctime":1624804252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624804252","product_id":100053801,"comment_content":"if(cat.r &lt; 0.5 &amp;&amp; cat.g &gt; 0.6) {<br>请问 这里的 阀值是如何得到的呢","like_count":0},{"had_liked":false,"id":278945,"user_name":"番薯","can_delete":false,"product_type":"c1","uid":2435667,"ip_address":"","ucode":"F0A83719D29595","user_header":"https://static001.geekbang.org/account/avatar/00/25/2a/53/5b9afe0a.jpg","comment_is_top":false,"comment_ctime":1613477311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613477311","product_id":100053801,"comment_content":"尝试了用webgl写高斯模糊和马赛克，发现个问题：片元着色器里，循环和数组都不能带uniform变量，只能直接hardcode代表半径的数字进去，写片元就是这样吗？还是有更合适的方法？<br>https:&#47;&#47;codepen.io&#47;sfyan-the-styleful&#47;pen&#47;OJbpXzx<br>https:&#47;&#47;codepen.io&#47;sfyan-the-styleful&#47;pen&#47;KKNWEgQ","like_count":0},{"had_liked":false,"id":266906,"user_name":"Zack","can_delete":false,"product_type":"c1","uid":1758012,"ip_address":"","ucode":"758511DF7D6D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eokhlnrZO1G1SnxWka7hSeqwHnIcuQKugQDBDKUDXc2ZDXKsibHTNviaG6CiaqBiaK5Bwcu37xakaFthw/132","comment_is_top":false,"comment_ctime":1607522306,"is_pvip":false,"replies":[{"id":"101096","content":"因为行主序和列主序问题，与矩阵乘法具体实现有关","user_name":"作者回复","comment_id":266906,"uid":"1159792","ip_address":"","utype":1,"ctime":1612875995,"user_name_real":"月影"}],"discussion_count":3,"race_medal":0,"score":"1607522306","product_id":100053801,"comment_content":"webgl实现灰度化，为什么要先把颜色矩阵转置？","like_count":0,"discussions":[{"author":{"id":1159792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b2/70/ba9cecc6.jpg","nickname":"月影","note":"","ucode":"298582FA7DBF27","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511438,"discussion_content":"因为行主序和列主序问题，与矩阵乘法具体实现有关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612875995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1559528,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Fnol5T7X9z9icw8yP1Zx5enHdYqbmP4EbNymaP87USujdeDp22QYMEwfYqkT7mOkXYegBZmhRx9bDbUbKGTPYlg/132","nickname":"Geek_00734e","note":"","ucode":"5F641387DA2291","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351093,"discussion_content":"一个矩阵乘以一个向量相当于矩阵和列向量的线性组合。\n一个向量乘以矩阵，相当于矩阵和行向量的线性组合。\n而向量的表示中行向量与列向量没用本质区别，只是在数学中展示方式不同而已，而在程序中都可以以数组的形式类比。\n而glsl 中构建矩阵的参数实际是这样生成的，再结合数学中的矩阵乘法就可以理解了\nmat3 myMat3 = mat3(1.0, 0.0, 0.0,  // 第一列\n                   0.0, 1.0, 0.0,  // 第二列\n                   0.0, 1.0, 1.0); // 第三列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614152244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1559528,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Fnol5T7X9z9icw8yP1Zx5enHdYqbmP4EbNymaP87USujdeDp22QYMEwfYqkT7mOkXYegBZmhRx9bDbUbKGTPYlg/132","nickname":"Geek_00734e","note":"","ucode":"5F641387DA2291","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351083,"discussion_content":"const fragment = `\n      #ifdef GL_ES\n      precision highp float;\n      #endif\n\n      uniform sampler2D tMap;\n      uniform mat4 colorMatrix;\n      varying vec2 vUv;\n      float r = 0.2126;\n      float g = 0.7152;\n      float b = 0.0722;\n      mat4 myMat4 = mat4(\n                        r, r, r, 0.0,\n                        g, g, g, 0.0,\n                        b, b, b, 0.0,\n                        0.0, 0.0, 0.0, 1.0\n                        );\n      mat4 myMat5 = mat4(\n                        r, g, b, 0.0,\n                        r, g, b, 0.0,\n                        r, g, b, 0.0,\n                        0.0, 0.0, 0.0, 1.0\n                        );\n\n      void main() {\n          vec4 color = texture2D(tMap, vUv);\n          gl_FragColor = vec4(color.rgb, 1.0) * myMat5;\n          // gl_FragColor = myMat4 * vec4(color.rgb, 1.0);\n          // gl_FragColor = colorMatrix * vec4(color.rgb, 1.0);\n          // gl_FragColor = vec4(color.rgb, 1.0) * colorMatrix;\n          gl_FragColor.a = color.a;\n      }\n    `;\n\n我来贴段代码，经测试这几种效果一样的，求老师解释，现在很是困惑，为啥向量跟矩阵相乘顺序改变就不需要转置。这一块卡住好几天了，百思不得解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614149319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}