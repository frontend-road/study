{"id":284291,"title":"15 | 消息队列的考验：Redis有哪些解决方案？","content":"<p>你好，我是蒋德钧。</p><p>现在的互联网应用基本上都是采用分布式系统架构进行设计的，而很多分布式系统必备的一个基础软件就是消息队列。</p><p>消息队列要能支持组件通信消息的快速读写，而Redis本身支持数据的高速访问，正好可以满足消息队列的读写性能需求。不过，除了性能，消息队列还有其他的要求，所以，很多人都很关心一个问题：“Redis适合做消息队列吗？”</p><p>其实，这个问题的背后，隐含着两方面的核心问题：</p><ul>\n<li>消息队列的消息存取需求是什么？</li>\n<li>Redis如何实现消息队列的需求？</li>\n</ul><p>这节课，我们就来聊一聊消息队列的特征和Redis提供的消息队列方案。只有把这两方面的知识和实践经验串连起来，才能彻底理解基于Redis实现消息队列的技术实践。以后当你需要为分布式系统组件做消息队列选型时，就可以根据组件通信量和消息通信速度的要求，选择出适合的Redis消息队列方案了。</p><p>我们先来看下第一个问题：消息队列的消息读取有什么样的需求？</p><h2>消息队列的消息存取需求</h2><p>我先介绍一下消息队列存取消息的过程。在分布式系统中，当两个组件要基于消息队列进行通信时，一个组件会把要处理的数据以消息的形式传递给消息队列，然后，这个组件就可以继续执行其他操作了；远端的另一个组件从消息队列中把消息读取出来，再在本地进行处理。</p><!-- [[[read_end]]] --><p>为了方便你理解，我还是借助一个例子来解释一下。</p><p>假设组件1需要对采集到的数据进行求和计算，并写入数据库，但是，消息到达的速度很快，组件1没有办法及时地既做采集，又做计算，并且写入数据库。所以，我们可以使用基于消息队列的通信，让组件1把数据x和y保存为JSON格式的消息，再发到消息队列，这样它就可以继续接收新的数据了。组件2则异步地从消息队列中把数据读取出来，在服务器2上进行求和计算后，再写入数据库。这个过程如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/bc/d79d46ec4aa22bf46fde3ae1a99fc2bc.jpg?wh=3000*1459\" alt=\"\"></p><p>我们一般把消息队列中发送消息的组件称为生产者（例子中的组件1），把接收消息的组件称为消费者（例子中的组件2），下图展示了一个通用的消息队列的架构模型：</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/62/f470bb957c1faff674c08b1fa65a3a62.jpg?wh=3000*857\" alt=\"\"></p><p>在使用消息队列时，消费者可以异步读取生产者消息，然后再进行处理。这样一来，即使生产者发送消息的速度远远超过了消费者处理消息的速度，生产者已经发送的消息也可以缓存在消息队列中，避免阻塞生产者，这是消息队列作为分布式组件通信的一大优势。</p><p><strong>不过，消息队列在存取消息时，必须要满足三个需求，分别是消息保序、处理重复的消息和保证消息可靠性。</strong></p><h3>需求一：消息保序</h3><p>虽然消费者是异步处理消息，但是，消费者仍然需要按照生产者发送消息的顺序来处理消息，避免后发送的消息被先处理了。对于要求消息保序的场景来说，一旦出现这种消息被乱序处理的情况，就可能会导致业务逻辑被错误执行，从而给业务方造成损失。</p><p>我们来看一个更新商品库存的场景。</p><p>假设生产者负责接收库存更新请求，消费者负责实际更新库存，现有库存量是10。生产者先后发送了消息1和消息2，消息1要把商品X的库存记录更新为5，消息2是把商品X库存更新为3。如果消息1和2在消息队列中无法保序，出现消息2早于消息1被处理的情况，那么，很显然，库存更新就出错了。这是业务应用无法接受的。</p><p>面对这种情况，你可能会想到一种解决方案：不要把更新后的库存量作为生产者发送的消息，而是<strong>把库存扣除值作为消息的内容</strong>。这样一来，消息1是扣减库存量5，消息2是扣减库存量2。如果消息1和消息2之间没有库存查询请求的话，即使消费者先处理消息2，再处理消息1，这个方案也能够保证最终的库存量是正确的，也就是库存量为3。</p><p>但是，我们还需要考虑这样一种情况：假如消费者收到了这样三条消息：消息1是扣减库存量5，消息2是读取库存量，消息3是扣减库存量2，此时，如果消费者先处理了消息3（把库存量扣减2），那么库存量就变成了8。然后，消费者处理了消息2，读取当前的库存量是8，这就会出现库存量查询不正确的情况。从业务应用层面看，消息1、2、3应该是顺序执行的，所以，消息2查询到的应该是扣减了5以后的库存量，而不是扣减了2以后的库存量。所以，用库存扣除值作为消息的方案，在消息中同时包含读写操作的场景下，会带来数据读取错误的问题。而且，这个方案还会面临一个问题，那就是重复消息处理。</p><h3>需求二：重复消息处理</h3><p>消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。此时，消费者可能会收到多条重复的消息。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题了。</p><p>还是以库存更新为例，假设消费者收到了一次消息1，要扣减库存量5，然后又收到了一次消息1，那么，如果消费者无法识别这两条消息实际是一条相同消息的话，就会执行两次扣减库存量5的操作，此时，库存量就不对了。这当然也是无法接受的。</p><h3>需求三：消息可靠性保证</h3><p>另外，消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时，消息队列需要能提供消息可靠性的保证，也就是说，当消费者重启后，可以重新读取消息再次进行处理，否则，就会出现消息漏处理的问题了。</p><p>Redis的List和Streams两种数据类型，就可以满足消息队列的这三个需求。我们先来了解下基于List的消息队列实现方法。</p><h2>基于List的消息队列解决方案</h2><p>List本身就是按先进先出的顺序对数据进行存取的，所以，如果使用List作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p><p>具体来说，生产者可以使用LPUSH命令把要发送的消息依次写入List，而消费者则可以使用RPOP命令，从List的另一端按照消息的写入顺序，依次读取消息并进行处理。</p><p>如下图所示，生产者先用LPUSH写入了两条库存消息，分别是5和3，表示要把库存更新为5和3；消费者则用RPOP把两条消息依次读出，然后进行相应的处理。</p><p><img src=\"https://static001.geekbang.org/resource/image/b0/7c/b0959216cbce7ac383ce206b8884777c.jpg?wh=3000*2250\" alt=\"\"></p><p>不过，在消费者读取数据时，有一个潜在的性能风险点。</p><p>在生产者往List中写入数据时，List并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用RPOP命令（比如使用一个while(1)循环）。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环。</p><p>所以，即使没有新消息写入List，消费者也要不停地调用RPOP命令，这就会导致消费者程序的CPU一直消耗在执行RPOP命令上，带来不必要的性能损失。</p><p>为了解决这个问题，Redis提供了BRPOP命令。<strong>BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p><p>消息保序的问题解决了，接下来，我们还需要考虑解决重复消息处理的问题，这里其实有一个要求：<strong>消费者程序本身能对重复消息进行判断。</strong></p><p>一方面，消息队列要能给每一个消息提供全局唯一的ID号；另一方面，消费者程序要把已经处理过的消息的ID号记录下来。</p><p>当收到一条消息后，消费者程序就可以对比收到的消息ID和记录的已处理过的消息ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。这种处理特性也称为幂等性，幂等性就是指，对于同一条消息，消费者收到一次的处理结果和收到多次的处理结果是一致的。</p><p>不过，List本身是不会为每个消息生成ID号的，所以，消息的全局唯一ID号就需要生产者程序在发送消息前自行生成。生成之后，我们在用LPUSH命令把消息插入List时，需要在消息中包含这个全局唯一ID。</p><p>例如，我们执行以下命令，就把一条全局ID为101030001、库存量为5的消息插入了消息队列：</p><pre><code>LPUSH mq &quot;101030001:stock:5&quot;\n(integer) 1\n</code></pre><p>最后，我们再来看下，List类型是如何保证消息可靠性的。</p><p>当消费者程序从List中读取一条消息后，List就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从List中读取消息了。</p><p>为了留存消息，List类型提供了BRPOPLPUSH命令，这个命令的作用是让消费者程序从一个List中读取消息，同时，Redis会把这个消息再插入到另一个List（可以叫作备份List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份List中重新读取消息并进行处理了。</p><p>我画了一张示意图，展示了使用BRPOPLPUSH命令留存消息，以及消费者再次读取消息的过程，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/3d/5045395da08317b546aab7eb698d013d.jpg?wh=3000*2135\" alt=\"\"></p><p>生产者先用LPUSH把消息“5”“3”插入到消息队列mq中。消费者程序使用BRPOPLPUSH命令读取消息“5”，同时，消息“5”还会被Redis插入到mqback队列中。如果消费者程序处理消息“5”时宕机了，等它重启后，可以从mqback中再次读取消息“5”，继续处理。</p><p>好了，到这里，你可以看到，基于List类型，我们可以满足分布式组件对消息队列的三大需求。但是，在用List做消息队列时，我们还可能遇到过一个问题：<strong>生产者消息发送很快，而消费者处理消息的速度比较慢，这就导致List中的消息越积越多，给Redis的内存带来很大压力</strong>。</p><p>这个时候，我们希望启动多个消费者程序组成一个消费组，一起分担处理List中的消息。但是，List类型并不支持消费组的实现。那么，还有没有更合适的解决方案呢？这就要说到Redis从5.0版本开始提供的Streams数据类型了。</p><p>和List相比，Streams同样能够满足消息队列的三大需求。而且，它还支持消费组形式的消息读取。接下来，我们就来了解下Streams的使用方法。</p><h2>基于Streams的消息队列解决方案</h2><p>Streams是Redis专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令。</p><ul>\n<li>XADD：插入消息，保证有序，可以自动生成全局唯一ID；</li>\n<li>XREAD：用于读取消息，可以按ID读取数据；</li>\n<li>XREADGROUP：按消费组形式读取消息；</li>\n<li>XPENDING和XACK：XPENDING命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而XACK命令用于向消息队列确认消息处理已完成。</li>\n</ul><p>首先，我们来学习下Streams类型存取消息的操作XADD。</p><p>XADD命令可以往消息队列中插入新消息，消息的格式是键-值对形式。对于插入的每一条消息，Streams可以自动为其生成一个全局唯一的ID。</p><p>比如说，我们执行下面的命令，就可以往名称为mqstream的消息队列中插入一条消息，消息的键是repo，值是5。其中，消息队列名称后面的<code>*</code>，表示让Redis为插入的数据自动生成一个全局唯一的ID，例如“1599203861727-0”。当然，我们也可以不用<code>*</code>，直接在消息队列名称后自行设定一个ID号，只要保证这个ID号是全局唯一的就行。不过，相比自行设定ID号，使用<code>*</code>会更加方便高效。</p><pre><code>XADD mqstream * repo 5\n&quot;1599203861727-0&quot;\n</code></pre><p>可以看到，消息的全局唯一ID由两部分组成，第一部分“1599203861727”是数据插入时，以毫秒为单位计算的当前服务器时间，第二部分表示插入消息在当前毫秒内的消息序号，这是从0开始编号的。例如，“1599203861727-0”就表示在“1599203861727”毫秒内的第1条消息。</p><p>当消费者需要读取消息时，可以直接使用XREAD命令从消息队列中读取。</p><p>XREAD在读取消息时，可以指定一个消息ID，并从这个消息ID的下一条消息开始进行读取。</p><p>例如，我们可以执行下面的命令，从ID号为1599203861727-0的消息开始，读取后续的所有消息（示例中一共3条）。</p><pre><code>XREAD BLOCK 100 STREAMS  mqstream 1599203861727-0\n1) 1) &quot;mqstream&quot;\n   2) 1) 1) &quot;1599274912765-0&quot;\n         2) 1) &quot;repo&quot;\n            2) &quot;3&quot;\n      2) 1) &quot;1599274925823-0&quot;\n         2) 1) &quot;repo&quot;\n            2) &quot;2&quot;\n      3) 1) &quot;1599274927910-0&quot;\n         2) 1) &quot;repo&quot;\n            2) &quot;1&quot;\n</code></pre><p>另外，消费者也可以在调用XRAED时设定block配置项，实现类似于BRPOP的阻塞读取操作。当消息队列中没有消息时，一旦设置了block配置项，XREAD就会阻塞，阻塞的时长可以在block配置项进行设置。</p><p>举个例子，我们来看一下下面的命令，其中，命令最后的“$”符号表示读取最新的消息，同时，我们设置了block 10000的配置项，10000的单位是毫秒，表明XREAD在读取最新消息时，如果没有消息到来，XREAD将阻塞10000毫秒（即10秒），然后再返回。下面命令中的XREAD执行后，消息队列mqstream中一直没有消息，所以，XREAD在10秒后返回空值（nil）。</p><pre><code>XREAD block 10000 streams mqstream $\n(nil)\n(10.00s)\n</code></pre><p>刚刚讲到的这些操作是List也支持的，接下来，我们再来学习下Streams特有的功能。</p><p>Streams本身可以使用XGROUP创建消费组，创建消费组之后，Streams可以使用XREADGROUP命令让消费组内的消费者读取消息，</p><p>例如，我们执行下面的命令，创建一个名为group1的消费组，这个消费组消费的消息队列是mqstream。</p><pre><code>XGROUP create mqstream group1 0\nOK\n</code></pre><p>然后，我们再执行一段命令，让group1消费组里的消费者consumer1从mqstream中读取所有消息，其中，命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。因为在consumer1读取消息前，group1中没有其他消费者读取过消息，所以，consumer1就得到mqstream消息队列中的所有消息了（一共4条）。</p><pre><code>XREADGROUP group group1 consumer1 streams mqstream &gt;\n1) 1) &quot;mqstream&quot;\n   2) 1) 1) &quot;1599203861727-0&quot;\n         2) 1) &quot;repo&quot;\n            2) &quot;5&quot;\n      2) 1) &quot;1599274912765-0&quot;\n         2) 1) &quot;repo&quot;\n            2) &quot;3&quot;\n      3) 1) &quot;1599274925823-0&quot;\n         2) 1) &quot;repo&quot;\n            2) &quot;2&quot;\n      4) 1) &quot;1599274927910-0&quot;\n         2) 1) &quot;repo&quot;\n            2) &quot;1&quot;\n</code></pre><p>需要注意的是，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。比如说，我们执行完刚才的XREADGROUP命令后，再执行下面的命令，让group1内的consumer2读取消息时，consumer2读到的就是空值，因为消息已经被consumer1读取完了，如下所示：</p><pre><code>XREADGROUP group group1 consumer2  streams mqstream 0\n1) 1) &quot;mqstream&quot;\n   2) (empty list or set)\n</code></pre><p>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。例如，我们执行下列命令，让group2中的consumer1、2、3各自读取一条消息。</p><pre><code>XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;\n1) 1) &quot;mqstream&quot;\n   2) 1) 1) &quot;1599203861727-0&quot;\n         2) 1) &quot;repo&quot;\n            2) &quot;5&quot;\n\nXREADGROUP group group2 consumer2 count 1 streams mqstream &gt;\n1) 1) &quot;mqstream&quot;\n   2) 1) 1) &quot;1599274912765-0&quot;\n         2) 1) &quot;repo&quot;\n            2) &quot;3&quot;\n\nXREADGROUP group group2 consumer3 count 1 streams mqstream &gt;\n1) 1) &quot;mqstream&quot;\n   2) 1) 1) &quot;1599274925823-0&quot;\n         2) 1) &quot;repo&quot;\n            2) &quot;2&quot;\n</code></pre><p>为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams会自动使用内部队列（也称为PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用XACK命令通知Streams“消息已经处理完成”。如果消费者没有成功处理消息，它就不会给Streams发送XACK命令，消息仍然会留存。此时，消费者可以在重启后，用XPENDING命令查看已读取、但尚未确认处理完成的消息。</p><p>例如，我们来查看一下group2中各个消费者已读取、但尚未确认的消息个数。其中，XPENDING返回结果的第二、三行分别表示group2中所有消费者读取的消息最小ID和最大ID。</p><pre><code>XPENDING mqstream group2\n1) (integer) 3\n2) &quot;1599203861727-0&quot;\n3) &quot;1599274925823-0&quot;\n4) 1) 1) &quot;consumer1&quot;\n      2) &quot;1&quot;\n   2) 1) &quot;consumer2&quot;\n      2) &quot;1&quot;\n   3) 1) &quot;consumer3&quot;\n      2) &quot;1&quot;\n</code></pre><p>如果我们还需要进一步查看某个消费者具体读取了哪些数据，可以执行下面的命令：</p><pre><code>XPENDING mqstream group2 - + 10 consumer2\n1) 1) &quot;1599274912765-0&quot;\n   2) &quot;consumer2&quot;\n   3) (integer) 513336\n   4) (integer) 1\n</code></pre><p>可以看到，consumer2已读取的消息的ID是1599274912765-0。</p><p>一旦消息1599274912765-0被consumer2处理了，consumer2就可以使用XACK命令通知Streams，然后这条消息就会被删除。当我们再使用XPENDING命令查看时，就可以看到，consumer2已经没有已读取、但尚未确认处理的消息了。</p><pre><code> XACK mqstream group2 1599274912765-0\n(integer) 1\nXPENDING mqstream group2 - + 10 consumer2\n(empty list or set)\n</code></pre><p>现在，我们就知道了用Streams实现消息队列的方法，我还想再强调下，Streams是Redis 5.0专门针对消息队列场景设计的数据类型，如果你的Redis是5.0及5.0以后的版本，就可以考虑把Streams用作消息队列了。</p><h2>小结</h2><p>这节课，我们学习了分布式系统组件使用消息队列时的三大需求：消息保序、重复消息处理和消息可靠性保证，这三大需求可以进一步转换为对消息队列的三大要求：消息数据有序存取，消息数据具有全局唯一编号，以及消息数据在消费完成后被删除。</p><p>我画了一张表格，汇总了用List和Streams实现消息队列的特点和区别。当然，在实践的过程中，你也可以根据新的积累，进一步补充和完善这张表。</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/14/b2d6581e43f573da6218e790bb8c6814.jpg?wh=2922*943\" alt=\"\"></p><p>其实，关于Redis是否适合做消息队列，业界一直是有争论的。很多人认为，要使用消息队列，就应该采用Kafka、RabbitMQ这些专门面向消息队列场景的软件，而Redis更加适合做缓存。</p><p>根据这些年做Redis研发工作的经验，我的看法是：Redis是一个非常轻量级的键值数据库，部署一个Redis实例就是启动一个进程，部署Redis集群，也就是部署多个Redis实例。而Kafka、RabbitMQ部署时，涉及额外的组件，例如Kafka的运行就需要再部署ZooKeeper。相比Redis来说，Kafka和RabbitMQ一般被认为是重量级的消息队列。</p><p>所以，关于是否用Redis做消息队列的问题，不能一概而论，我们需要考虑业务层面的数据体量，以及对性能、可靠性、可扩展性的需求。如果分布式系统中的组件消息通信量不大，那么，Redis只需要使用有限的内存空间就能满足消息存储的需求，而且，Redis的高性能特性能支持快速的消息读写，不失为消息队列的一个好的解决方案。</p><h2>每课一问</h2><p>按照惯例，我给你提个小问题。如果一个生产者发送给消息队列的消息，需要被多个消费者进行读取和处理（例如，一个消息是一条从业务系统采集的数据，既要被消费者1读取进行实时计算，也要被消费者2读取并留存到分布式文件系统HDFS中，以便后续进行历史查询），你会使用Redis的什么数据类型来解决这个问题呢？</p><p>欢迎在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎你帮我分享给更多人。我们下节课见。</p>","comments":[{"had_liked":false,"id":247610,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1599760280,"is_pvip":true,"discussion_count":60,"race_medal":0,"score":"2187738113944","product_id":100056701,"comment_content":"如果一个生产者发送给消息队列的消息，需要被多个消费者进行读取和处理，你会使用Redis的什么数据类型来解决这个问题？<br><br>这种情况下，只能使用Streams数据类型来解决。使用Streams数据类型，创建多个消费者组，就可以实现同时消费生产者的数据。每个消费者组内可以再挂多个消费者分担读取消息进行消费，消费完成后，各自向Redis发送XACK，标记自己的消费组已经消费到了哪个位置，而且消费组之间互不影响。<br><br>另外，老师在介绍使用List用作队列时，为了保证消息可靠性，使用BRPOPLPUSH命令把消息取出的同时，还把消息插入到备份队列中，从而防止消费者故障导致消息丢失。<br><br>这种情况下，还需要额外做一些工作，也就是维护这个备份队列：每次执行BRPOPLPUSH命令后，因为都会把消息插入一份到备份队列中，所以当消费者成功消费取出的消息后，最好把备份队列中的消息删除，防止备份队列存储过多无用的数据，导致内存浪费。<br><br>这篇文章主要是讲消息队列的使用，借这个机会，也顺便总结一下使用消息队列时的注意点：<br><br>在使用消息队列时，重点需要关注的是如何保证不丢消息？<br><br>那么下面就来分析一下，哪些情况下，会丢消息，以及如何解决？<br><br>1、生产者在发布消息时异常：<br><br>a) 网络故障或其他问题导致发布失败（直接返回错误，消息根本没发出去）<br>b) 网络抖动导致发布超时（可能发送数据包成功，但读取响应结果超时了，不知道结果如何）<br><br>情况a还好，消息根本没发出去，那么重新发一次就好了。但是情况b没办法知道到底有没有发布成功，所以也只能再发一次。所以这两种情况，生产者都需要重新发布消息，直到成功为止（一般设定一个最大重试次数，超过最大次数依旧失败的需要报警处理）。这就会导致消费者可能会收到重复消息的问题，所以消费者需要保证在收到重复消息时，依旧能保证业务的正确性（设计幂等逻辑），一般需要根据具体业务来做，例如使用消息的唯一ID，或者版本号配合业务逻辑来处理。<br><br>2、消费者在处理消息时异常：<br><br>也就是消费者把消息拿出来了，但是还没处理完，消费者就挂了。这种情况，需要消费者恢复时，依旧能处理之前没有消费成功的消息。使用List当作队列时，也就是利用老师文章所讲的备份队列来保证，代价是增加了维护这个备份队列的成本。而Streams则是采用ack的方式，消费成功后告知中间件，这种方式处理起来更优雅，成熟的队列中间件例如RabbitMQ、Kafka都是采用这种方式来保证消费者不丢消息的。<br><br>3、消息队列中间件丢失消息<br><br>上面2个层面都比较好处理，只要客户端和服务端配合好，就能保证生产者和消费者都不丢消息。但是，如果消息队列中间件本身就不可靠，也有可能会丢失消息，毕竟生产者和消费这都依赖它，如果它不可靠，那么生产者和消费者无论怎么做，都无法保证数据不丢失。<br><br>a) 在用Redis当作队列或存储数据时，是有可能丢失数据的：一个场景是，如果打开AOF并且是每秒写盘，因为这个写盘过程是异步的，Redis宕机时会丢失1秒的数据。而如果AOF改为同步写盘，那么写入性能会下降。另一个场景是，如果采用主从集群，如果写入量比较大，从库同步存在延迟，此时进行主从切换，也存在丢失数据的可能（从库还未同步完成主库发来的数据就被提成主库）。总的来说，Redis不保证严格的数据完整性和主从切换时的一致性。我们在使用Redis时需要注意。<br><br>b) 而采用RabbitMQ和Kafka这些专业的队列中间件时，就没有这个问题了。这些组件一般是部署一个集群，生产者在发布消息时，队列中间件一般会采用写多个节点+预写磁盘的方式保证消息的完整性，即便其中一个节点挂了，也能保证集群的数据不丢失。当然，为了做到这些，方案肯定比Redis设计的要复杂（毕竟是专们针对队列场景设计的）。<br><br>综上，Redis可以用作队列，而且性能很高，部署维护也很轻量，但缺点是无法严格保数据的完整性（个人认为这就是业界有争议要不要使用Redis当作队列的地方）。而使用专业的队列中间件，可以严格保证数据的完整性，但缺点是，部署维护成本高，用起来比较重。<br><br>所以我们需要根据具体情况进行选择，如果对于丢数据不敏感的业务，例如发短信、发通知的场景，可以采用Redis作队列。如果是金融相关的业务场景，例如交易、支付这类，建议还是使用专业的队列中间件。","like_count":510,"discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378009,"discussion_content":"如果大家对于Redis队列还有疑问，可以看看我新写的这篇文章，非常全面：《把Redis当做队列来用，真的合适吗？》：https://mp.weixin.qq.com/s/RthQvzLHZRGNo-z6X_7jQQ","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1622995733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":380811,"discussion_content":"感谢，我看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624710137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378009,"ip_address":""},"score":380811,"extra":""},{"author":{"id":2357566,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f9/3e/0d5f27c4.jpg","nickname":"肥猫不开心","note":"","ucode":"FA9204B84913C0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":381743,"discussion_content":"大佬的公众号文章多点就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625197612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378009,"ip_address":""},"score":381743,"extra":""}]},{"author":{"id":1239350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e9/36/f62471c5.jpg","nickname":"不诉离殇","note":"","ucode":"4F7BB1220ECED7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312660,"discussion_content":"“而采用RabbitMQ和Kafka这些专业的队列中间件时，就没有这个问题了” 。补充一点 一般对于消息中间件来说 都有很复杂的策略来保证生产消息时的可靠性，以kafka为例，生产者生产消息时 可以指定acks参数 ，acks的值有0 1 all三种。 只有设置为all(并且ISR>1)的时候才能保证不丢消息，但是这个性能就会有一些影响，还是靠业务根据数据重要程度抉择平衡。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1602761439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1239350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e9/36/f62471c5.jpg","nickname":"不诉离殇","note":"","ucode":"4F7BB1220ECED7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312672,"discussion_content":"感谢补充。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602766322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312660,"ip_address":""},"score":312672,"extra":""},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1239350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e9/36/f62471c5.jpg","nickname":"不诉离殇","note":"","ucode":"4F7BB1220ECED7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333559,"discussion_content":"对  一般而言  kafka rocketmq  对于消息的可靠性保证 要么是靠 更多的跟随队列写入确认，要么就是主从全部写入才算，还可以算 是否异步落盘，但整体可靠性很高。。我觉得redis 作为队列最大的问题在于消息积压了怎么办。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607563787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312660,"ip_address":""},"score":333559,"extra":""}]},{"author":{"id":1971906,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2KOBFlndeR70m1S8iblK1MhHbOpbiak1miclloKfzmOFFHfmKibW4ZibQKsOx88FHFb75PdREfEiapHp3iasEQvAWvshw/132","nickname":"Geek_ba73a7","note":"","ucode":"5899751F76ED1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337691,"discussion_content":"Kaito，你回答问题为何如此的帅气","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1609045759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1971906,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2KOBFlndeR70m1S8iblK1MhHbOpbiak1miclloKfzmOFFHfmKibW4ZibQKsOx88FHFb75PdREfEiapHp3iasEQvAWvshw/132","nickname":"Geek_ba73a7","note":"","ucode":"5899751F76ED1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337845,"discussion_content":"多工作几年，你也可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609086972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337691,"ip_address":""},"score":337845,"extra":""}]},{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347943,"discussion_content":"消息丢失问题，消息是否发送成功问题和重复消费问题，是每个消息中间件都面临的问题。需要根据业务的不同，在可靠性和高性能之间做平衡选择。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1612393500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2216639,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/lqSHCH9XBTWfxeobcpI4amW4ycQkuE8rIwkXgFhMbZlg0htmicx0BZTvwvuILySwkYrctfmj5PU9Rscqic8O2eNg/132","nickname":"irats","note":"","ucode":"44B4A6DCA64BDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310883,"discussion_content":"对于你上面说的“网络抖动导致发布超时（可能发送数据包成功，但读取响应结果超时了，不知道结果如何）”这一段话，我有一个疑问。\n如果数据包的发送使用的是tcp协议，那么tcp的重传机制不是会保证数据包一定会到达redis吗？\n这个超时是怎么定义的？指的是不是应用程序层面上认为的超时？如果是的话，那么导致这个超时的可能是不是如下两种:1.网络拥塞，tcp还在尝试重传。2.tcp连接断开。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602091412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":9,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2216639,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/lqSHCH9XBTWfxeobcpI4amW4ycQkuE8rIwkXgFhMbZlg0htmicx0BZTvwvuILySwkYrctfmj5PU9Rscqic8O2eNg/132","nickname":"irats","note":"","ucode":"44B4A6DCA64BDE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310926,"discussion_content":"TCP重传只是尽可能地让数据传输成功，如果网络本身出现问题，还是会失败的。\n\n超时是应用层设置的，超时发生时是不知道结果如何的，可能数据已经发过去了，只是没读到对方返回的结果，也可能根本没发出去，这两个阶段都有可能存在网络问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602138645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310883,"ip_address":""},"score":310926,"extra":""},{"author":{"id":2216639,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/lqSHCH9XBTWfxeobcpI4amW4ycQkuE8rIwkXgFhMbZlg0htmicx0BZTvwvuILySwkYrctfmj5PU9Rscqic8O2eNg/132","nickname":"irats","note":"","ucode":"44B4A6DCA64BDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":311419,"discussion_content":"可是只要tcp连接还没断开，应用交给tcp传输的数据就一定会到达吧？\n那在tcp没有断开的情况下，tcp尝试重传的时间超过了用户层定义的超时时间(tcp层还可继续尝试重传，可能下一次就发送成功)，那么生产者用户层在这种情况下再向tcp交付一次数据，那这不就是应用层自己导致的数据多次发送了吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602333858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310926,"ip_address":""},"score":311419,"extra":""},{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2216639,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/lqSHCH9XBTWfxeobcpI4amW4ycQkuE8rIwkXgFhMbZlg0htmicx0BZTvwvuILySwkYrctfmj5PU9Rscqic8O2eNg/132","nickname":"irats","note":"","ucode":"44B4A6DCA64BDE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311426,"discussion_content":"是的，会出现这种情况的。应用层超时了，无法知道结果，可能成功也可能失败。\n\n应用层此时有2个选择，一是应用层主动向目标查询校验，二是重新发送一次消息。在消息队列的场景中，一般选择后者，并让消费者在消费时实现幂等逻辑，保证重复消费业务依旧正常。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1602336271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311419,"ip_address":""},"score":311426,"extra":""}]},{"author":{"id":1436839,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ec/a7/7d44c655.jpg","nickname":"snailshen","note":"","ucode":"C4875C476649B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308004,"discussion_content":"rocketmq如果采用异步刷盘时，也不能保证数据一致性，除非采用同步刷盘，并且生产者等待broker通知写入成功，但这种方案对性能磁盘集群吞吐量都有影响","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600824462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2107375,"avatar":"https://static001.geekbang.org/account/avatar/00/20/27/ef/a7f94eda.jpg","nickname":"Jerry You","note":"","ucode":"679A44B505482F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306073,"discussion_content":"一直有个疑惑：使用stream类型时，涉及到xack，假设读取后需要写入数据库，然后ack出错，这个怎么处理重复消息的读取问题，是需要在数据库层在做一下去重的判断么？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600160650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2107375,"avatar":"https://static001.geekbang.org/account/avatar/00/20/27/ef/a7f94eda.jpg","nickname":"Jerry You","note":"","ucode":"679A44B505482F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306080,"discussion_content":"业务层在写数据库时做成幂等的。幂等的方式很多方案实现，例如根据唯一ID查询、配合版本号做更新等等。你可以查一下资料。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1600163888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306073,"ip_address":""},"score":306080,"extra":""}]},{"author":{"id":1262808,"avatar":"https://static001.geekbang.org/account/avatar/00/13/44/d8/1a1761f9.jpg","nickname":"James_Shangguan","note":"","ucode":"F5855BC008DDEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411175,"discussion_content":"大厂都有基础架构团队，基础设施相对完善，如果有消息队列的使用需求，会使用自研的消息队列组件。关于技术选型，首先需要看软件特性是否满足需求，主要包括兼容性和扩展性；其次需要看目前的技术能力，根据目前自己或者团队的技术栈和技术能力，能否可以平滑的使用；第三，要看开源组件的社区，主要关注更新是否频繁、项目是否有人维护、遇到坑的时候可以取得联系寻求帮助、是否在业内被广泛使用等。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635861251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022411,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/cb/8964faab.jpg","nickname":"-只是小小配角_","note":"","ucode":"EFC1CD54A23F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348573,"discussion_content":"生产者生产消息时遇到异常重试后，消息队列里不一定会有多条重复的消息，因为stream可以生产者指定消息ID，重复的消息ID不会成功进入消息队列","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612627308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2105773,"avatar":"https://static001.geekbang.org/account/avatar/00/20/21/ad/734464b7.jpg","nickname":"jacky","note":"","ucode":"CF3638E2177182","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305102,"discussion_content":"这是不是和消息中间件的广播模式类似？如有一个组，未发xack，消息就会一直在streams里，多了是否会堆积，这怎么处理？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599786338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2105773,"avatar":"https://static001.geekbang.org/account/avatar/00/20/21/ad/734464b7.jpg","nickname":"jacky","note":"","ucode":"CF3638E2177182","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305274,"discussion_content":"Stream的xadd命令可以指定maxlen，旧的消息可以被自动删掉。当然，这样使用也意味着数据会丢失。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599837033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305102,"ip_address":""},"score":305274,"extra":""},{"author":{"id":2105773,"avatar":"https://static001.geekbang.org/account/avatar/00/20/21/ad/734464b7.jpg","nickname":"jacky","note":"","ucode":"CF3638E2177182","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":305280,"discussion_content":"谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599837635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305274,"ip_address":""},"score":305280,"extra":""}]},{"author":{"id":2649276,"avatar":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","nickname":"Leo","note":"","ucode":"CEBAD9CDCFC2A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557367,"discussion_content":"赞同，简单的消息队列确实可以用redis来做，但是系统对可靠性及数据准确安全性有要求还是用专业的消息中间件吧！毕竟专业的事交给专业的人去做！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647776960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553452,"discussion_content":"日常mark!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645888667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1796332,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/68/ec/eb0ebbb6.jpg","nickname":"日月星辰","note":"","ucode":"4E9F48153B2D8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551147,"discussion_content":"Redis 也可以部署集群啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644909758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116693,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0a/15/e83c898f.jpg","nickname":"John","note":"","ucode":"147A9228FD818E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547602,"discussion_content":"如果采取List的方法，把消息插入到备份队列，那么想到一个情况，如果重启之后，去读取备份list ( mqback ) 中的消息，但是就在读取之后，刚好又一次down机了，请问这时候如何处理才比较稳妥了？谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642761223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344535,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOn7k48KXia5rf0eXpzv2EGtqGibz3eNb8QnL8X72uia0g1rBwzXef4dV2JEdz3r4bu9GC1FLIeic4UA/132","nickname":"Lee","note":"","ucode":"6B8D59A0B1A1A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545972,"discussion_content":"精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642116909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2367796,"avatar":"","nickname":"北鼻账号","note":"","ucode":"6802D915311E05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539251,"discussion_content":"看老师的问题，一条消息被多个消费者进行消费，那我觉得pub/sub 和stream都能支持到。但是，若考虑到消息持久化问题，那就只能是stream了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639648254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2571577,"avatar":"https://static001.geekbang.org/account/avatar/00/27/3d/39/e93e342e.jpg","nickname":"Awarker","note":"","ucode":"AEE3DB8EF133D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414418,"discussion_content":"我想问下多个消费者消费同一个消息队列的话，怎么知道消息是自己的呢，文中说如果消息读取之后，其它消费者就不能读取了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636732284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1880227,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/J5z01TT1BhMANkhlDBSetV4S4qTGvup3vwEdY2DdSXs1SkyPvWATqQGbibjCykcz9VpRKKQTOaUx9jECs0khxDA/132","nickname":"叶泽豪","note":"","ucode":"A439A52B46EEB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2571577,"avatar":"https://static001.geekbang.org/account/avatar/00/27/3d/39/e93e342e.jpg","nickname":"Awarker","note":"","ucode":"AEE3DB8EF133D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545284,"discussion_content":"这时应该是业务就允许并发的场景。否则还是要求有序消费，那么多个消费者在消费的时候就要同步，性能比较低。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641893910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":414418,"ip_address":""},"score":545284,"extra":""}]},{"author":{"id":2793822,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/a1/5e/4c53cb49.jpg","nickname":"helloWorld","note":"","ucode":"E7D28A9F456959","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404727,"discussion_content":"就很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634392809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377990,"discussion_content":"看来redis果然会存在数据丢失的可能，在一次面试过程中面试官看我之前项目中使用redis做消息队列，就问到了会不会有数据丢失，数据丢失怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622988707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/61/8ad99e09.jpg","nickname":"刘百万","note":"","ucode":"692E23D070641A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369044,"discussion_content":"多个消费组，每个组对应一个消费者是吗 那为什么不用 list创建多个消费者各自的队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618911294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363469,"discussion_content":"感谢分享，收获满满","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617201266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003327,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","nickname":"王坤祥","note":"","ucode":"FB988B9F381A33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349750,"discussion_content":"精彩~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613496257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2176180,"avatar":"","nickname":"Geek_5aae47","note":"","ucode":"2E6D974EE836E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345937,"discussion_content":"课代表，我想问一下，当我们使用list的RPOPLPUSH,我理解的是再获取消息的时候同时把这条消息插入到一个指定的新队列中,那么宕机后重启，redis是不会自动去读取设定的备用的消息队列，而是需要自己手动去实现。\n另外就是，你提到的如果消费成功需要去删除备用队列的消息，这种情况只适用于单机的redis吧，如果是集群redis使用lrem去删除消息的话，由于list队列元素索引位置不确定性会导致误删。不知道我的理解对不对？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611818268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1022411,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/cb/8964faab.jpg","nickname":"-只是小小配角_","note":"","ucode":"EFC1CD54A23F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2176180,"avatar":"","nickname":"Geek_5aae47","note":"","ucode":"2E6D974EE836E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348571,"discussion_content":"是指删除了队列里的其他相同内容的消息吗？lrem 支持按顺序删除一个或多个指定内容的消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612626395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345937,"ip_address":""},"score":348571,"extra":""}]},{"author":{"id":2392536,"avatar":"","nickname":"Geek_9b08a5","note":"","ucode":"CF08E141456F24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338476,"discussion_content":"大佬，问下redis streams能够数据持久化的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609297687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2392536,"avatar":"","nickname":"Geek_9b08a5","note":"","ucode":"CF08E141456F24","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338672,"discussion_content":"可以，也是用RDB和AOF。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1609335984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338476,"ip_address":""},"score":338672,"extra":""}]},{"author":{"id":1602239,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyobcyicicCQoldZofsS36xrjA2R2hk2F89pu1hCqwjlRaRG4xKkgCicZibEVdOwpfN5rWjEchrsxicSQ/132","nickname":"Geek_e8d55e","note":"","ucode":"5F13626B0E1E45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335381,"discussion_content":"大佬，请教一下，如果消费者从stream中读出一条消息后，但未回复ack，然后消费者挂了，那么当消费者重启后，消费者是从已读取未确认队列中取消息吗？另外如果改消费者一直没起来，那它读取的那条消息要怎么被消费？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608177040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1602239,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyobcyicicCQoldZofsS36xrjA2R2hk2F89pu1hCqwjlRaRG4xKkgCicZibEVdOwpfN5rWjEchrsxicSQ/132","nickname":"Geek_e8d55e","note":"","ucode":"5F13626B0E1E45","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335424,"discussion_content":"对。没消费者消费，消息一直保留，如果设置了消息有效期，那过期自动删除。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608191904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335381,"ip_address":""},"score":335424,"extra":""},{"author":{"id":2176180,"avatar":"","nickname":"Geek_5aae47","note":"","ucode":"2E6D974EE836E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":345978,"discussion_content":"问一下，如何设置单条消息的ttl?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611827309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335424,"ip_address":""},"score":345978,"extra":""}]},{"author":{"id":2212143,"avatar":"https://static001.geekbang.org/account/avatar/00/21/c1/2f/5c8167aa.jpg","nickname":"油纸伞","note":"","ucode":"C2655B9F8874E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329654,"discussion_content":"文中说的 ：需要注意的是，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。 ---- 使用Stream一个消费组内，一条消息只能有一个消费者读取，有多个消费组，是可以重复读取消费这条消息?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606444014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2212143,"avatar":"https://static001.geekbang.org/account/avatar/00/21/c1/2f/5c8167aa.jpg","nickname":"油纸伞","note":"","ucode":"C2655B9F8874E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329659,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606444574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329654,"ip_address":""},"score":329659,"extra":""},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2212143,"avatar":"https://static001.geekbang.org/account/avatar/00/21/c1/2f/5c8167aa.jpg","nickname":"油纸伞","note":"","ucode":"C2655B9F8874E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333556,"discussion_content":"建议也看下 kafka  rocketmq 等如何处理不同消费组消费消息的。一般分为客户端记录offset跟 服务器端记录。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607563650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":329654,"ip_address":""},"score":333556,"extra":""}]},{"author":{"id":1156926,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a7/3e/a00cfbde.jpg","nickname":"会飞的鱼","note":"","ucode":"CDCFBFE03C48BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324189,"discussion_content":"如果是Stream数据类型来消费数据，在只有一个消费组的情况下，多个消费者之间在业务层面是如果保证消息是被顺序消费的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605066480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1156926,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a7/3e/a00cfbde.jpg","nickname":"会飞的鱼","note":"","ucode":"CDCFBFE03C48BD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324193,"discussion_content":"无法保证，业务使用消息队列不能强依赖顺序性。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605067358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324189,"ip_address":""},"score":324193,"extra":""},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1156926,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a7/3e/a00cfbde.jpg","nickname":"会飞的鱼","note":"","ucode":"CDCFBFE03C48BD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333557,"discussion_content":"所以建议使用专业的mq，针对顺序消费 你只需要保证 客户端实现分区即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607563685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324189,"ip_address":""},"score":333557,"extra":""}]},{"author":{"id":1022267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/3b/791d0f5e.jpg","nickname":"王先森","note":"","ucode":"1AF1A395107479","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312007,"discussion_content":"有个概念的东西,针对同一个stream,不同组收到的消息是一样的,组内多个消费者收到的消息是不一样的？例如 stream消息流是 1 2 3 4，group1和group2收到是都是 1 2 3 4，但是组内消息不是重复的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602560248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1023093,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/75/525e53b1.jpg","nickname":"Hobby","note":"","ucode":"8954830380D44F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1022267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/3b/791d0f5e.jpg","nickname":"王先森","note":"","ucode":"1AF1A395107479","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334724,"discussion_content":"不一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607952505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312007,"ip_address":""},"score":334724,"extra":""},{"author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1022267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/3b/791d0f5e.jpg","nickname":"王先森","note":"","ucode":"1AF1A395107479","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347859,"discussion_content":"不同组数据重复，组内成员数据不重复","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612343735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312007,"ip_address":""},"score":347859,"extra":""}]},{"author":{"id":1120057,"avatar":"https://static001.geekbang.org/account/avatar/00/11/17/39/3274257b.jpg","nickname":"ple","note":"","ucode":"E1C4519C325994","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305160,"discussion_content":"专业的消息队列产品也不敢保证数据一定不丢，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599801928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1120057,"avatar":"https://static001.geekbang.org/account/avatar/00/11/17/39/3274257b.jpg","nickname":"ple","note":"","ucode":"E1C4519C325994","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305275,"discussion_content":"如果使用方法正确，并且部署维护没问题，是不会丢数据的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599837075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305160,"ip_address":""},"score":305275,"extra":""},{"author":{"id":1133036,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ec/6bae1fd7.jpg","nickname":"哇咔咔","note":"","ucode":"54BF877836C591","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":305585,"discussion_content":"感觉只有以同步的方式从内存写磁盘才不会丢是吗？如果生产者一发送消息，kafka收到了消息后，给了生产者一个成功的响应，但是kafka就挂了。这种情况下，会丢失数据吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600009692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305275,"ip_address":""},"score":305585,"extra":""},{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1133036,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ec/6bae1fd7.jpg","nickname":"哇咔咔","note":"","ucode":"54BF877836C591","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":305592,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600010430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305585,"ip_address":""},"score":305592,"extra":""}]}]},{"had_liked":false,"id":247647,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1599786113,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"568535469185","product_id":100056701,"comment_content":"每次想回答问题，看到 Kaito 的留言，顿时就有一种“眼前有景道不得，崔颢题诗在上头”的感觉。","like_count":133,"discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305123,"discussion_content":"别这样，可以先思考一下，有可能我的回答也不一定全面，欢迎一起讨论！","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1599790451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2909824,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/66/80/3729a457.jpg","nickname":"桐郁梧忧","note":"","ucode":"11690F7CEADAC0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552095,"discussion_content":"解释下这行诗：\n起源是由于崔大哥的《黄鹤楼》\n　　昔人已乘黄鹤去, 此地空余黄鹤楼。 黄鹤一去不复返, 白云千载空悠悠。 晴川历历汉阳树, 芳草萋萋鹦鹉洲。 日暮乡关何处是, 烟波江上使人愁。\n　　后来李白来到黄鹤楼，想趁着酒意题诗一首，但是他读了崔大哥的诗以后，出了一身冷汗，心想幸好没有写，否则可能会献丑，因此上说了这句话。“眼前有景道不得，崔颢题诗在上头”","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1645282609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2866243,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/bc/43/22ab8fcc.jpg","nickname":"天儿","note":"","ucode":"24A900F6304B1C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2909824,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/66/80/3729a457.jpg","nickname":"桐郁梧忧","note":"","ucode":"11690F7CEADAC0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":565743,"discussion_content":"为啥你没有赞呢，我给你补一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650533374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":552095,"ip_address":""},"score":565743,"extra":""},{"author":{"id":2909824,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/66/80/3729a457.jpg","nickname":"桐郁梧忧","note":"","ucode":"11690F7CEADAC0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2866243,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/bc/43/22ab8fcc.jpg","nickname":"天儿","note":"","ucode":"24A900F6304B1C","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":570376,"discussion_content":"哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651748476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":565743,"ip_address":""},"score":570376,"extra":""}]},{"author":{"id":2078431,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/b6/df/04d607c9.jpg","nickname":"krisChan","note":"","ucode":"78AC0E1F65D5CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306920,"discussion_content":"我文化低，我还去百度了一下这首诗","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1600418535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1465407,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5c/3f/a263f551.jpg","nickname":"倚天照海","note":"","ucode":"84EC611D00C9EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309032,"discussion_content":"每次看到Kaito的评论，我就想起大宅门里陈宝国和姜文的对话：“我这个知府应该你来做”","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1601176755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1465407,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5c/3f/a263f551.jpg","nickname":"倚天照海","note":"","ucode":"84EC611D00C9EC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340517,"discussion_content":"哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610021347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309032,"ip_address":""},"score":340517,"extra":""}]},{"author":{"id":1590395,"avatar":"https://static001.geekbang.org/account/avatar/00/18/44/7b/e45491f9.jpg","nickname":"Saber","note":"","ucode":"4DFB5A0E674480","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374847,"discussion_content":"老哥也是厉害，有种李白的感觉 ","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1621387750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107772,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e7/3c/366c15ca.jpg","nickname":"浪里个狼","note":"","ucode":"2085BB3632DCAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310651,"discussion_content":"Kaito老哥是真的牛皮","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601971367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/46/f4/5e878cd4.jpg","nickname":"李佳","note":"","ucode":"082E7FCA4AE76D","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305750,"discussion_content":"那更应该自己来回答，不是为了找一个标准答案或者正确答案，更重要的是自己的思考过程，加油啊！期待看到你的答案～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600075188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254321,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1603100383,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"220646432479","product_id":100056701,"comment_content":"1，作者讲了什么？<br>    如何使用redis实现消息队列的需求<br><br>2，作者是怎么把这事给说明白的？<br>    1，将一个问题拆解为两个具体的小问题：消息队列应具备哪些特性，Redis能否实现这些特性<br><br>3，为了讲明白，作者讲了哪些要点？，有哪些亮点？<br>    1，亮点1：作者首先将一个相对模糊的问题，拆解成为两个问题更精确的问题<br>    2，要点1：消息队列读取需求有三点：消息保存，消息唯一，消息可靠性<br>    3，要点2：消息还要确保有序，削峰平谷，消费性能有弹性<br>    4，要点3：Redis的list和5.0后的Stream数据结构可以满足<br>    5，要点4：消息队列的三大要求：消息数据有序存取，消息数据具有全局唯一编号，消息数据在消费完成后被删除<br>    <br>4，对于作者所讲，我有哪些发散性思考？<br>  \t解决问题的前提是搞清楚问题是什么<br>\t开篇：“Redis适合做消息队列吗”？对于这样的问题，我本能的就会直接想：“用Redis做消息队列？应该可以吧，很多资料上都这么说的”。<br>\t这样的回答，证明我并没有思考，只是陈述了我所知道的一点东西。我总是渴求快速有个答案，没有在意答案是否正确，更没有思考该如何回答问题。<br>\t虽然我总会说要想解决问题，首先要搞清楚问题是什么。这个句话似乎有点白痴，自己遇到的问题，这个问题不就它本身吗？怎么还会需要搞清楚呢？<br>\t其实不然，我们遇到的往往未必是问题的真身，而只是问题的表面现象或衍生出的问题。其实一个好问题的本身，就是一个好答案，而一个好问题胜过无数好答案。<br>\t那什么才是真正的解答问题？这需要先回答如何回答这个问题，也就是要先搞清楚要从哪些方面解释问题，而不是铺陈信息。<br>\t老师开篇对问题的回答方法，就是个非常好的范例<br>\t他是怎么解答的呢？<br>\t他并没有立即回答行或不行（这是我们最常有的反应），而是向后退了一步，问这个问题真正的问题是啥呢？消息队列存取消息需要哪些特性？Redis如何实现这些特性？<br>\t这就将一个相对模糊的问题拆解为两个较清晰的小问题，分别作答，最终得到一篇很好的文章<br><br>5，将来在哪些场景里，我能够使用它？<br><br>6，留言区收获<br>1，Redis是否可以作为消息队列？如果可以，哪些场景适合使用Redis，而不是消息中间件？<br>\t答：这个问题应当进一步拆分为：消息队列读写消息有哪些需求和Redis如何实现这些需求。<br>        首先消息队列的消息读写有三大需求：消息读写的有序性，消息数据的唯一性，消息消费后数据删除。<br>        针对这三大需求，Redis的List和5.0后的Stream数据结构，可以支持。<br>        对于List，POP和PUSH命令，还有阻塞式的，备份式的。<br>        对于Stream，是Redis5.0后提供新的数据结构，专门用户消息队列，他可以生成全局唯一id，还有能够创建消费者组，多个消费者同时消费<br>        Stream类型，使用了应答机制，消费者消费完毕后会给Streams发送XACK命令，否则消息将会保存Streams的内部队列中，使用XPENDING命令可以查看<br>       就Redis的相关数据结构而言，是可以作为消息队列的。但也要注意使用它的场景，虽然它性能很高，部署维护也轻量，但缺点是无法严格保证数据的完整性。<br>    他适用于消息量并不是非常巨大，数据不是非常重要，从而不必引入其他消息组件的场景，如发短信，站内信<br><br>2，如果一个生产者发送给消息队列的消息，需要被多个消费者进行读取和处理，Redis的什么数据类型可以解决这个问题？<br>    答：如果要使用Redis实现这个需求，Redis的Streams数据类型可以实现。<br>\t\tStreams可以使用XADD向队列中写入消息，XGOURP创建消费者组，XREADGROUP已消费者组形式消费消息，XACK向消息队列确认处理完成，XPENDING查询已消费待确认的消息<br><br>3，如果使用Redis作为消息队列，有哪些事项需要注意？<br>    答：消息的可靠性，重点需要关注的是如何保证不丢消息<br><br><br>4，在使用消息队列时，如何保证不丢消息？<br>    答：消息丢失可能会发生在三个环节：生产者发布消息，消息者消费消息，消息中间件丢失消息<br>    生产者丢失消息一般通过重试机制和全局唯一id来解决，<br>\t消费者消费消息一般通过ack方式问询上报消费进度，<br>\t消息中间件宕机，一般通过主从备份，分布式集群来解决","like_count":52,"discussions":[{"author":{"id":1793589,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epxppZUun6eqVDbbuyIzSZibcydqnDkdZ96NBDmNYHun484FUcdj3vdaJmuxia9wqEChMRkhj8IpfaA/132","nickname":"Summer","note":"","ucode":"DA2683248EA698","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552455,"discussion_content":"学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645477197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2036674,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/13/c2/f8f82f33.jpg","nickname":"么么么么木木木","note":"","ucode":"0FDC8660CBBD14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390634,"discussion_content":"思路学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629947273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297887,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cd/df/c520d418.jpg","nickname":"董俊俊","note":"","ucode":"732300A779660B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382462,"discussion_content":"课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625582140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1665922,"avatar":"https://static001.geekbang.org/account/avatar/00/19/6b/82/7143f7d9.jpg","nickname":"学啊学","note":"","ucode":"D7E3DFB1757004","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341003,"discussion_content":"跟着各位大佬一起学","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610259887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339134,"discussion_content":"分析作者行文思路，这个赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609514380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301913,"avatar":"https://static001.geekbang.org/account/avatar/00/13/dd/99/40de9e3f.jpg","nickname":"Vernon","note":"","ucode":"4BBAFAA6DA5E6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314411,"discussion_content":"点赞去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603155663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266986,"user_name":"walle斌","can_delete":false,"product_type":"c1","uid":1062848,"ip_address":"","ucode":"0DB3243004951F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","comment_is_top":false,"comment_ctime":1607563832,"is_pvip":false,"replies":[{"id":"97924","content":"是的。所以，如果应用场景中压力不大，Redis应用起来也相对简单，可以作为一个方案备选。但是如果消息压力大，还是会考虑专用的一些MQ，例如Kafka。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608994897,"ip_address":"","comment_id":266986,"utype":1}],"discussion_count":5,"race_medal":0,"score":"57442138680","product_id":100056701,"comment_content":"redis作为队列，我觉得最大的问题应该是消息积压的问题。。任何一个mq 都要应对 高流量的消息积压问题。 ","like_count":13,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511469,"discussion_content":"是的。所以，如果应用场景中压力不大，Redis应用起来也相对简单，可以作为一个方案备选。但是如果消息压力大，还是会考虑专用的一些MQ，例如Kafka。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608994897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1996866,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/78/42/03295e28.jpg","nickname":"刘羽禅","note":"","ucode":"E1241C44D00477","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540882,"discussion_content":"你消费的够快就不会挤压呀。\n1.做任务数量的监控预警，动态的调整消费者的数量，就可以。\n2.把队列的redis实例和业务的redis实例隔离开。\n避免消费挂掉，任务挤压，内存占用，影响了业务的redis\n其他的问题，评论区了也已给出来答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640187313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033578,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","nickname":"白不吃","note":"","ucode":"F019914D8819C2","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393778,"discussion_content":"说到点子上了，不像前面的评论，干舔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631595878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376227,"discussion_content":"redis内部是用环形数组实现backlog 那么在qps 10W/s 的场景下（因为redis官方阈值写入时10w 所以就不拿kafka benchmark来讨论）会造成消息丢失。上一个backlog还没同步完 这时候redis里数据已经丢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622028840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192724,"avatar":"https://static001.geekbang.org/account/avatar/00/12/33/14/78104f1f.jpg","nickname":"Just Do IT","note":"","ucode":"1EAD92510FA7BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357717,"discussion_content":"最大的问题还是数据完整性问题，积压在消费者组多加几个消费者就好了，专业的mq也都是这么解决，都存在积压问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615858650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247695,"user_name":"DKSky","can_delete":false,"product_type":"c1","uid":1336009,"ip_address":"","ucode":"69371A81033949","user_header":"https://static001.geekbang.org/account/avatar/00/14/62/c9/7da27891.jpg","comment_is_top":false,"comment_ctime":1599796351,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"53139403903","product_id":100056701,"comment_content":"老师的文中说“我们希望启动多个消费者程序组成一个消费组，一起分担处理 List 中的消息。但是，List 类型并不支持消费组的实现。那么，还有没有更合适的解决方案呢？“<br>这句话不太明白，如果多个消费者客户端使用brpop命令阻塞式的“抢”列表尾部的元素，这些消费者不属于同一个consumer group吗？","like_count":12,"discussions":[{"author":{"id":2358947,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fe/a3/414c47cc.jpg","nickname":"旺仔小馒头","note":"","ucode":"45BE8E943C794C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371262,"discussion_content":"这一块作者说的应该是不对的，弊端应该是同一个消息没办法被多个消费者同时消费","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1619700964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207622,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","nickname":"丁小明","note":"","ucode":"CC23857B8D75D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323933,"discussion_content":"确实是可以的，我就基于redis实现过一个分布式的延迟队列。list这个结构不支持一条消息被多个消费者消费，但是不同消息多个消费者是完全没问题的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1605016214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1207622,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","nickname":"丁小明","note":"","ucode":"CC23857B8D75D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581783,"discussion_content":"性能会有问题么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658992160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":323933,"ip_address":"陕西"},"score":581783,"extra":""}]},{"author":{"id":1014023,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/07/2f418316.jpg","nickname":"恰饭哒","note":"","ucode":"0395069A050057","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362858,"discussion_content":"多个消费者消费用发布订阅模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617063562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1148845,"avatar":"https://static001.geekbang.org/account/avatar/00/11/87/ad/50a85a04.jpg","nickname":"hao","note":"","ucode":"997F2B57E2F556","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321627,"discussion_content":"我也有这个疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604601211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261578,"user_name":"hoppo","can_delete":false,"product_type":"c1","uid":1588794,"ip_address":"","ucode":"B0C7C124A99B2D","user_header":"https://static001.geekbang.org/account/avatar/00/18/3e/3a/2267d2a3.jpg","comment_is_top":false,"comment_ctime":1605427952,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40260133616","product_id":100056701,"comment_content":"关于顺序消费的问题，其实要严格保证顺序的话，只有生产者-队列-消费者完全的一对一才行。就好比List这种。<br><br>如果使用Stream消费组的话，多个消费者一起操作的时候，是没法保证顺序性的。<br><br>专业的消息队列中间件一般都采用局部有序的方法：需要有序操作的部分通过路由发到一个队列中，队列-消费者采用一对一的方式。<br>","like_count":9,"discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581784,"discussion_content":"如果不维持多个消费队列，设置再多消费者也没有意义吧，并发去竞争一个队列，会有顺序问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658992227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311856,"user_name":"licong","can_delete":false,"product_type":"c1","uid":1502601,"ip_address":"","ucode":"02478E64E9D223","user_header":"https://static001.geekbang.org/account/avatar/00/16/ed/89/86340059.jpg","comment_is_top":false,"comment_ctime":1631507749,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"27401311525","product_id":100056701,"comment_content":"redis的publish&#47;subscribe也可以作为简单的MQ使用，老师的专栏好像没提到这个","like_count":6,"discussions":[{"author":{"id":1926222,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/64/4e/83c61c7f.jpg","nickname":"靓仔","note":"","ucode":"077A290A2DCF42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579342,"discussion_content":"认真看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657362880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577102,"discussion_content":"哨兵里那个pub消息?  把自己的ip port公布出去?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655915646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261291,"user_name":"Aecho1610213142","can_delete":false,"product_type":"c1","uid":2303205,"ip_address":"","ucode":"84AA9E4C110ABF","user_header":"https://static001.geekbang.org/account/avatar/00/23/24/e5/a83c0ff5.jpg","comment_is_top":false,"comment_ctime":1605259514,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23080095994","product_id":100056701,"comment_content":"老师好！多个消费者 如何保证消息的顺序执行？","like_count":5,"discussions":[{"author":{"id":1609289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8e/49/10ef002d.jpg","nickname":"周翔在山麓（Xiang Zhou）","note":"","ucode":"E126273356E5B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340341,"discussion_content":"他的现在模型根本不需要考虑有序性问题。。。真正的有序性问题反而被回避了。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609983112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103875,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d8/03/04af3e17.jpg","nickname":"张沛","note":"","ucode":"0EB2143BC61F1B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560505,"discussion_content":"这个部分老师好像没有展开细说","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649348308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8e/49/10ef002d.jpg","nickname":"周翔在山麓（Xiang Zhou）","note":"","ucode":"E126273356E5B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340343,"discussion_content":"有点失望","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609983133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247612,"user_name":"杨逸林","can_delete":false,"product_type":"c1","uid":1167233,"ip_address":"","ucode":"4BF3CF3E2F1AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","comment_is_top":false,"comment_ctime":1599761606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23074598086","product_id":100056701,"comment_content":"1. 问题回答<br>每个 Stream 都可以挂多个消费组，每个消费组会有个游标 last_delivered_id 在 Stream 数组之上往前移动，表示当前消费组已经消费到哪条消息了。如果这是对的，那只需要开两个消费者组，消费者 1 在组1，消费者2在组2不就行了么。<br>这个 last_delivered_id 有点像 Kafka 的 offset。<br><br>2. 有点不同的观点<br>Kafka 其实已经考虑去掉 ZK 了，而且适合高吞吐量的业务，不过不适合流式处理。专业的事，还是教给专业的来做好点。<br><br>我之前用过 Redis 的 publish 和 subscribe 命令来做不同系统的数据同步。不过那个在用 Jedis 来订阅有坑，必须循环调用，不然会在一定时间后被 down 掉。","like_count":5},{"had_liked":false,"id":260885,"user_name":"Lywane","can_delete":false,"product_type":"c1","uid":1446512,"ip_address":"","ucode":"2B0027AA069CE9","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","comment_is_top":false,"comment_ctime":1605147706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18785016890","product_id":100056701,"comment_content":"我们希望启动多个消费者程序组成一个消费组，一起分担处理 List 中的消息。但是，List 类型并不支持消费组的实现 （多个消费者执行BRPOP不行吗）","like_count":4},{"had_liked":false,"id":262944,"user_name":"Luke 💨","can_delete":false,"product_type":"c1","uid":1504276,"ip_address":"","ucode":"343C168A06B30A","user_header":"https://static001.geekbang.org/account/avatar/00/16/f4/14/c1c81d88.jpg","comment_is_top":false,"comment_ctime":1605908106,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"14490809994","product_id":100056701,"comment_content":"不懂为啥要用这种模式实现消息队列，感觉有点牵强，而且大部分功能需要自己实现，redis内部不是有发布订阅模式吗，就是一种消息队列啊，两者有啥不一样吗？","like_count":4,"discussions":[{"author":{"id":1884510,"avatar":"","nickname":"代安娜","note":"","ucode":"C219A1A3BC7AD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341066,"discussion_content":"发布订阅的消息不能持久化","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1610283223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347861,"discussion_content":"接1楼补充，发布订阅模式，客户端离线这一段时间的数据会丢失","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1612344093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2729003,"avatar":"https://static001.geekbang.org/account/avatar/00/29/a4/2b/0e1bab59.jpg","nickname":"senda","note":"","ucode":"74541011088AFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545222,"discussion_content":"发布订阅和消息队列根本就是两码事，而且应用场景也不一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641879503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022411,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/cb/8964faab.jpg","nickname":"-只是小小配角_","note":"","ucode":"EFC1CD54A23F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348566,"discussion_content":"pub/sub 应该基本被淘汰了，可以做临时测试用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612625587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2161554,"avatar":"https://static001.geekbang.org/account/avatar/00/20/fb/92/17923e19.jpg","nickname":"团圆丁","note":"","ucode":"23DD0146F43C7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1022411,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/cb/8964faab.jpg","nickname":"-只是小小配角_","note":"","ucode":"EFC1CD54A23F39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580832,"discussion_content":"其它内置功能有用到，比如哨兵。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658388217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":348566,"ip_address":""},"score":580832,"extra":""}]}]},{"had_liked":false,"id":247729,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1599809202,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14484711090","product_id":100056701,"comment_content":"请教下老师两个问题：<br>1.如果消息延迟了，如何做好监控？<br>2.如何尽可能的减少消息的延迟，我好像知道一个很牛逼的技术叫“零拷贝”，但是不太理解其原理，望老师解惑。谢谢。","like_count":3,"discussions":[{"author":{"id":1167233,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","nickname":"杨逸林","note":"","ucode":"4BF3CF3E2F1AC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305263,"discussion_content":"谷歌搜索 Kafka Zero Copy，或者直接搜 Zero Copy 就知道了，省去了两步","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599834543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324600,"user_name":"Yipsen","can_delete":false,"product_type":"c1","uid":2856313,"ip_address":"","ucode":"F0ECE8C12AF105","user_header":"","comment_is_top":false,"comment_ctime":1638515302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10228449894","product_id":100056701,"comment_content":"消费组消费时虽然分摊了压力，但是怎么保证顺序消费呢？如果要保证岂不是要上一条消息的消费者必须发出ack后，消费组的另一个成员消费者才能开始消费消息，那不就等于加锁来保证顺序了，这样是不是消费组分摊就形同虚设或者没有起到应有的作用了？所以负载处理+顺序消费redis stream是怎么保证的？","like_count":2},{"had_liked":false,"id":280978,"user_name":"Wang Junling","can_delete":false,"product_type":"c1","uid":2441811,"ip_address":"","ucode":"A5A67DB1904ED3","user_header":"https://static001.geekbang.org/account/avatar/00/25/42/53/577009a5.jpg","comment_is_top":false,"comment_ctime":1614509382,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10204443974","product_id":100056701,"comment_content":"我对Redis的源码不是很熟，如果位大佬看到我的提问请帮忙解释一下。<br>1、LPUSH和RPUSH的运行原理是什么样的呢？时间算法复杂度是？<br>2、RPOP和LPOP的运行原理和时间复杂度是什么样的呢？","like_count":2,"discussions":[{"author":{"id":1357315,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoVRER40LhyAhBK6YgPYibRzWARkc3efUquib4j9BPru4y8FfvXK2sBPbXej9314pZdfdcxb07RcjZw/132","nickname":"酷酷的嵩","note":"","ucode":"EF249E96F42491","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388292,"discussion_content":"list可以理解为双向链表，你提到的时间复杂度都是O(1)。tips：命令的时间复杂度可以在官网查看","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628684164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250109,"user_name":"dfuru","can_delete":false,"product_type":"c1","uid":2110772,"ip_address":"","ucode":"0222FADA093D95","user_header":"","comment_is_top":false,"comment_ctime":1600938300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10190872892","product_id":100056701,"comment_content":"使用list，list留存消息队列消费者可指定，且消费者2读取后再删除。<br>stream 留存消息队列是内部匿名的，且消费者1消费完发送ACK后，消息就被删除，导致消费者2读取不到。","like_count":2},{"had_liked":false,"id":247767,"user_name":"土豆白菜","can_delete":false,"product_type":"c1","uid":1029749,"ip_address":"","ucode":"D1551C729D33E0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b6/75/32c19395.jpg","comment_is_top":false,"comment_ctime":1599825533,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10189760125","product_id":100056701,"comment_content":"茅草房-土房-平房","like_count":2},{"had_liked":false,"id":247636,"user_name":"刀斧手何在","can_delete":false,"product_type":"c1","uid":1202572,"ip_address":"","ucode":"B99D7ECC3EE954","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/8c/ba81a832.jpg","comment_is_top":false,"comment_ctime":1599784480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10189719072","product_id":100056701,"comment_content":"Redis做消息队列的优势是高并发写入性能和水平扩展能力。最大的坑 我觉得就是Kaito同学说的第3点 数据可靠性","like_count":2},{"had_liked":false,"id":326572,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1639567779,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5934535075","product_id":100056701,"comment_content":"评论区小收获：命令的时间复杂度可以在官网查看","like_count":1},{"had_liked":false,"id":314412,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1633006225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5927973521","product_id":100056701,"comment_content":"消息队列的目的是在分布式的系统间进行通信，通信方式是通过网络传输的方式，通过网络传输就有消息丢失、重复发送消息、不同消息到达顺序混乱的可能。所以消息队列应用的三大需求是：<br>  1、消息保序<br>  2、重复消息处理<br>  3、消息可靠性保证<br><br>对应处理方案是：<br>  1、消息数据有序存取<br>  2、消息数据具有全局唯一编号<br>  3、消息数据在未消费完宕机恢复时继续消费，消费完成后被删除","like_count":1},{"had_liked":false,"id":313337,"user_name":"HJ_Liu","can_delete":false,"product_type":"c1","uid":2573030,"ip_address":"","ucode":"A8187B180BB37D","user_header":"","comment_is_top":false,"comment_ctime":1632382355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5927349651","product_id":100056701,"comment_content":"老师你好，有个问题想更深入了解下。用Stream类型用作消息队列，用多个消费组，是不是也不能保证处理的顺序性？","like_count":1},{"had_liked":false,"id":313216,"user_name":"猪小擎","can_delete":false,"product_type":"c1","uid":1370959,"ip_address":"","ucode":"D9552746AE3327","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","comment_is_top":false,"comment_ctime":1632312775,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5927280071","product_id":100056701,"comment_content":"消息队列必须要满足的3个需求？保序，处理重复，确认？以我我对消息队列的使用经验，这三条，80%的消息队列，一个都不需要满足。rabbitmq有参数设置，读取队列数据不需要发送ack，就是队列不是必须确认的例证。这三条都是可选项，不是必选项。要满足这些，必须以性能为代价。php的yii框架yii-queue库，就使用sorted set+hash的方式实现多消费者队列。老版本还有bug，当推送延迟队列时，会出现重复消费的情况，推了5000个任务，消费了5001个任务。","like_count":1},{"had_liked":false,"id":312854,"user_name":"while (1)等;","can_delete":false,"product_type":"c1","uid":1061991,"ip_address":"","ucode":"BAEC7258D65B69","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/67/06a7f9be.jpg","comment_is_top":false,"comment_ctime":1632060420,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"5927027716","product_id":100056701,"comment_content":"老师好， BRPOP 的原理是什么？客户端和服务端保持长连接吗？","like_count":1,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404318,"discussion_content":"检查list中是否有相应的value，如果没有不会立即响应（阻塞）；\n在超时时间内如果有这个key的写入会从阻塞的客户端列表中选择最早阻塞的那个客户端写入返回","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634286440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"discussion":{"id":581786,"discussion_content":"由谁来唤醒呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658992352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":404318,"ip_address":"陕西"},"score":581786,"extra":""}]}]},{"had_liked":false,"id":310258,"user_name":"日落黄昏下","can_delete":false,"product_type":"c1","uid":1464032,"ip_address":"","ucode":"A97725B81D86BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/e0/d34f57b3.jpg","comment_is_top":false,"comment_ctime":1630571058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5925538354","product_id":100056701,"comment_content":"好像brpop堵塞的同一个key是会维护一个堵塞client列表，当有数据的时候会signal这个客户端列表，然后pop数据给client。是不是可以说list也是支持多个消费者一起消费的呢？","like_count":1},{"had_liked":false,"id":310197,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1630545765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5925513061","product_id":100056701,"comment_content":"消息的有序性是可选的，不是必须的吧，有些业务场景就不需要有序性，比如只增不删的场景。另外有序性也可以作为一个乐观锁的东东，对于量大，但不太可能乱序的情况，这种模式可提供效率","like_count":1},{"had_liked":false,"id":310195,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1630545566,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5925512862","product_id":100056701,"comment_content":"redis的消费者订阅后，如果下线了一天，第二天这个消费者还能消费昨天的消息吗？","like_count":1,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404319,"discussion_content":"如果是pubsub，不可以。如果是stream，可以 ，前提redis内存足够积压这一天的消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634286565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309890,"user_name":"Geek_227f15","can_delete":false,"product_type":"c1","uid":1281470,"ip_address":"","ucode":"7A38380E0F5D85","user_header":"","comment_is_top":false,"comment_ctime":1630383412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5925350708","product_id":100056701,"comment_content":"1. 读写大的场景肯定不适合redis，因为redis只有一个队列，而rocketMq这类专用的消息中间件一个队列实际是由很多逻辑队列组成不会有瓶颈。另外，一般不会部署redis实例只运行消息队列，这样的话消息队列会影响其他在线业务。<br>2. redis无法支撑大量消息堆积","like_count":1},{"had_liked":false,"id":306290,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1628486997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923454293","product_id":100056701,"comment_content":"我想如果有使用过MQ的话,这个问题应该遇到过,那就是分消费者组,然后就可以进行重复消费了","like_count":1},{"had_liked":false,"id":299205,"user_name":"DDD","can_delete":false,"product_type":"c1","uid":1500472,"ip_address":"","ucode":"26411E3487BBB5","user_header":"https://static001.geekbang.org/account/avatar/00/16/e5/38/d271950c.jpg","comment_is_top":false,"comment_ctime":1624511351,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5919478647","product_id":100056701,"comment_content":"消息队列我觉得我会优先考虑kakfa","like_count":1,"discussions":[{"author":{"id":1996866,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/78/42/03295e28.jpg","nickname":"刘羽禅","note":"","ucode":"E1241C44D00477","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540883,"discussion_content":"阿里的rocketmq更棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640187378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296773,"user_name":"Rover","can_delete":false,"product_type":"c1","uid":1386315,"ip_address":"","ucode":"7575EC91F45B99","user_header":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","comment_is_top":false,"comment_ctime":1623154898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5918122194","product_id":100056701,"comment_content":"rpop不是会把list集合的key删除么","like_count":1},{"had_liked":false,"id":291945,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1620621221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5915588517","product_id":100056701,"comment_content":"处理备份队列的时候，也有服务处理失败的问题呀？将备份队列的消息取出来，然后处理，如果处理过程中，服务重启了呢，这个怎么解决？继续使用 BRPOPLPUSH ？但还是有备备份队列的问题？","like_count":1},{"had_liked":false,"id":287088,"user_name":"李很奈斯","can_delete":false,"product_type":"c1","uid":2033714,"ip_address":"","ucode":"21FA87D66758AC","user_header":"https://static001.geekbang.org/account/avatar/00/1f/08/32/8137ce04.jpg","comment_is_top":false,"comment_ctime":1617770955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912738251","product_id":100056701,"comment_content":"喜欢老师的讲课方式🙆","like_count":1},{"had_liked":false,"id":286227,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1617201374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912168670","product_id":100056701,"comment_content":"强大的 Streams 消息队列，基本荡平工作中的大部分场景","like_count":1},{"had_liked":false,"id":285066,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1616597372,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5911564668","product_id":100056701,"comment_content":"在学习专栏内容之前，我觉得消息队列需要保证消息的可靠性，但是 Redis 明显是无法保证这个的。当然，对于那些不需要严格可靠的消息队列，Redis 的高性能显然是有优势的。<br><br>消息队列需要满足三个需求，分别是消息保序、处理重复消息和保证消息可靠性。<br><br>对于消息保序里面，商品扣减库存的例子，有一点凑巧了。<br><br>假设有 10 件库存，如果按时间顺序，分别减少 2、8、1，结果因为顺序的关系，先减了 2 和 1，但是 8 就没法扣减了，估计业主会不开心，坚持要上 Kafka。<br><br>利用 List 类型的先进先出特性，可以在一定程度上保证顺序，但是考虑到重复消息和可靠性，还是要增加不少额外的操作。<br><br>回到最开始的问题，为什么不用一个轻量型的消息队列？然后就有了 Streams 类型。<br><br>我可以吐槽一下 xread 返回值的显示格式么？难道是某位 Lisper 大神写的<br><br>感觉上 Streams 类型其实就是在 Redis 的基础上实现了轻量型的消息队列。<br><br>这里发现了我的一个误解，因为 mqstream 里面的消息虽然已经被 xread 读过了，但是并没有发 xack，所以消息还在 mqstream 中。<br><br>对于课后题，如果多个消费者需要读取消息队列中的消息，我觉的仍然可以使用 Streams 类型，但是发送 XACK 的机制需要处理一下，所有消费者都消费完了再统一结账（XACK）。<br><br>或者如果数据量不是特别大，也可以考虑用多个 Streams 并行处理，比如实时计算有一个 Streams，分布式文件系统留存也有一个 Streams，写的时候同时写入。<br><br>课代表 @Kaito 的回答更清晰一些，多个消费者组就可以解决问题，另外对于 Redis 做消息队列的分析也是专栏内容很好的补充。","like_count":1},{"had_liked":false,"id":276529,"user_name":"单朋荣","can_delete":false,"product_type":"c1","uid":1272662,"ip_address":"","ucode":"8AD121BEDD9675","user_header":"https://static001.geekbang.org/account/avatar/00/13/6b/56/37a4cea7.jpg","comment_is_top":false,"comment_ctime":1611990569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5906957865","product_id":100056701,"comment_content":"pending队列，是如何处理多个消费组消息留存的问题的啊？","like_count":1},{"had_liked":false,"id":267755,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1211713,"ip_address":"","ucode":"E3AD8BF42E19DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/41/3c5b770b.jpg","comment_is_top":false,"comment_ctime":1607913130,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5902880426","product_id":100056701,"comment_content":"打卡～","like_count":1},{"had_liked":false,"id":260593,"user_name":"会飞的鱼","can_delete":false,"product_type":"c1","uid":1156926,"ip_address":"","ucode":"CDCFBFE03C48BD","user_header":"https://static001.geekbang.org/account/avatar/00/11/a7/3e/a00cfbde.jpg","comment_is_top":false,"comment_ctime":1605066502,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5900033798","product_id":100056701,"comment_content":"如果是Stream数据类型来消费数据，在只有一个消费组的情况下，多个消费者之间在业务层面是如果保证消息是被顺序消费的呢？","like_count":1,"discussions":[{"author":{"id":1022411,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/cb/8964faab.jpg","nickname":"-只是小小配角_","note":"","ucode":"EFC1CD54A23F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348568,"discussion_content":"我的认识：同一个消息只能被同一个消费组里的一个消费者消费，消息队列保证了消息有序，所以消息被消费也是有序的，只是由于消费者处理速度的不同，消息最终处理完成的顺序和消费时的顺序不一致。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612625775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337923,"discussion_content":"保证不了,一般专业的消息队列都会有queue分区的概念,同一个分区里的消息可以保证有序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609125659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249835,"user_name":"哈德韦","can_delete":false,"product_type":"c1","uid":1637085,"ip_address":"","ucode":"E7C9B3D087D2D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/fa/dd/f640711f.jpg","comment_is_top":false,"comment_ctime":1600827162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895794458","product_id":100056701,"comment_content":"请问老师，我看到我们生产环境使用了Redis的BZPOPMAX和ZADD等（应该是有序集合）做了一个消息队列，并且有多个消费组，这样有什么缺陷吗？为什么课程中只提到使用LIST和STREAM？","like_count":1},{"had_liked":false,"id":249826,"user_name":"snailshen","can_delete":false,"product_type":"c1","uid":1436839,"ip_address":"","ucode":"C4875C476649B1","user_header":"https://static001.geekbang.org/account/avatar/00/15/ec/a7/7d44c655.jpg","comment_is_top":false,"comment_ctime":1600824554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895791850","product_id":100056701,"comment_content":"老师留的问题属于消息广播模式，可采用pub.sub","like_count":1},{"had_liked":false,"id":249825,"user_name":"snailshen","can_delete":false,"product_type":"c1","uid":1436839,"ip_address":"","ucode":"C4875C476649B1","user_header":"https://static001.geekbang.org/account/avatar/00/15/ec/a7/7d44c655.jpg","comment_is_top":false,"comment_ctime":1600824126,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5895791422","product_id":100056701,"comment_content":"老师留的问题属于消息广播场景，可以借助redis得pub|sub模型","like_count":1,"discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347942,"discussion_content":"发布/订阅模式消息不能持久化，当某个消费者挂了，重启这段时间的消息是消费不到的，只能消费最新的消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612393299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249733,"user_name":"Sunny","can_delete":false,"product_type":"c1","uid":1067570,"ip_address":"","ucode":"FE57B69A9CF91D","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/32/23db38ab.jpg","comment_is_top":false,"comment_ctime":1600774236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895741532","product_id":100056701,"comment_content":"使用Streams数据类型，创建多个消费者组.","like_count":1},{"had_liked":false,"id":249280,"user_name":"Mr.蜜","can_delete":false,"product_type":"c1","uid":1035257,"ip_address":"","ucode":"C911B81198B3F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","comment_is_top":false,"comment_ctime":1600567181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895534477","product_id":100056701,"comment_content":"这个问题，其实很简单，让xread和xact分在不同的消费者上，当消费者处理完消息以后，消息就进入另一个队列，让nfs去读区这个消息，然后xact关闭他。","like_count":1},{"had_liked":false,"id":249142,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1629141,"ip_address":"","ucode":"8AC3F3AB9BB6BF","user_header":"","comment_is_top":false,"comment_ctime":1600475068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895442364","product_id":100056701,"comment_content":"有没go的redis消息队列demo分享？","like_count":1},{"had_liked":false,"id":248216,"user_name":"豪森布鲁斯王","can_delete":false,"product_type":"c1","uid":1551099,"ip_address":"","ucode":"6037F674B60E26","user_header":"https://static001.geekbang.org/account/avatar/00/17/aa/fb/62b1e89b.jpg","comment_is_top":false,"comment_ctime":1600067392,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5895034688","product_id":100056701,"comment_content":"老师您好，我们现在遇到一个异步抢占式的需求，多个生产者产生大量的数据，放入缓存中，然后多个消费者从缓存中获取，要保证每个数据只能被一个消费者消费，生产者可能产生大量的任务，至少千万量级吧，这种场景适合使用redis吗，应该使用哪种模式呢？","like_count":1,"discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347940,"discussion_content":"千万级的就是用专业的消息中间件吧，kafka，rocketMQ，Rabbit MQ，根据具体业务选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612393087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347867,"discussion_content":"建议直接上kafka吧，高性能稳定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612344828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248140,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1065310,"ip_address":"","ucode":"E5D21F2A3359CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/5e/9d2953a3.jpg","comment_is_top":false,"comment_ctime":1600043273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895010569","product_id":100056701,"comment_content":"BRPOP 命令阻塞功能依赖客户端实现吧，如果客户端没有实现阻塞，这个命令是不是就没阻塞效果","like_count":1},{"had_liked":false,"id":355064,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"浙江","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1661049493,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661049493","product_id":100056701,"comment_content":"redis消息队列对于消息量比较大无法启削峰作用，原因：消耗内存，内存有限，一般20G redis相对比较大内存了。<br>消息队列生产及消费的负载需要程序自已实现。","like_count":0},{"had_liked":false,"id":353551,"user_name":"A 拽丫头","can_delete":false,"product_type":"c1","uid":1470434,"ip_address":"上海","ucode":"F875D99D18DF6E","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/e2/f3b05833.jpg","comment_is_top":false,"comment_ctime":1659539692,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659539692","product_id":100056701,"comment_content":"向老师请教：<br>消费组  group1 和  group2  都能消费同一个队列，那是不是说明  streams 的一个消息可以被多个消费组来消费，那么队列是怎么(什么机制)保证这个消息已经被这2个消费组都消费过后在删除了，两个group 消费的进度可能不同，会不会导致队列元素累计过多了？","like_count":0},{"had_liked":false,"id":349957,"user_name":"深黑色","can_delete":false,"product_type":"c1","uid":1047139,"ip_address":"","ucode":"3B070961739D42","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/63/bfbee4ac.jpg","comment_is_top":false,"comment_ctime":1656471377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656471377","product_id":100056701,"comment_content":"请问streams的数据存储是在内存中吗？是否也是通过aof来保证数据安全呢？","like_count":0},{"had_liked":false,"id":344095,"user_name":"和光同尘","can_delete":false,"product_type":"c1","uid":1994380,"ip_address":"","ucode":"E35F36CA298A98","user_header":"https://static001.geekbang.org/account/avatar/00/1e/6e/8c/49d94d09.jpg","comment_is_top":false,"comment_ctime":1651237448,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651237448","product_id":100056701,"comment_content":"不支持广播吧","like_count":0},{"had_liked":false,"id":338275,"user_name":"poppy","can_delete":false,"product_type":"c1","uid":1826213,"ip_address":"","ucode":"A275687C2CDE9B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/dd/a5/bdae6d4a.jpg","comment_is_top":false,"comment_ctime":1647402392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647402392","product_id":100056701,"comment_content":"关于stream的使用，消费者组同时消费如何保证消息有序呢","like_count":0},{"had_liked":false,"id":329650,"user_name":"高杰","can_delete":false,"product_type":"c1","uid":2308772,"ip_address":"","ucode":"5C36D7B97B8459","user_header":"","comment_is_top":false,"comment_ctime":1641456689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641456689","product_id":100056701,"comment_content":"1. 保证消息有序<br>使用stream时，多个消费者怎么保证消息是按照顺序执行？例如第一个消费者取回数据在执行中，第二个消费者接着取回数据，执行完成的时间比第一个消费者执行完成的时间要早，怎么办？<br>2.消息重复<br>生产者怎么保证插入的数据不重复？可能网络问题导致重复插入数据。<br>消费者在处理完数据后，还没有发送XACK就发生故障了，怎么办？1）按全局ID做幂等，先保存ID后，数据如果还没有处理就故障，下次再处理数据会丢失；2）先处理数据完成后，还没提交保存ID就发生故障，下次再处理数据会重复；3）数据处理完成，保存ID完成，这时候发生故障，下次再处理数据时，不会发生任何问题；","like_count":0},{"had_liked":false,"id":247927,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1599919705,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"1599919705","product_id":100056701,"comment_content":"xread 读取消息的时候，设置 block 1000 ，当 stream 没有消息的时候会阻塞 1000 ms, 那么当 stream 有新的消息过来后，会重新计算阻塞的时间吗？","like_count":0,"discussions":[{"author":{"id":2108046,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLoAicus6PVAO7SJzBmPMsQ4AISV0IZTvFkQ5fzicA3VJ8GZbAFhtqZZkOCrnSiaPkYgTianK5gvmLsuQ/132","nickname":"Geek_dac7ff","note":"","ucode":"CA90CDD5AA0077","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306343,"discussion_content":"命令都返回了。下次自然重新算时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600249689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247620,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1599780157,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1599780157","product_id":100056701,"comment_content":"发布&#47;订阅&quot;(publish&#47;subscribe)模式，支持重复消费","like_count":0,"discussions":[{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323853,"discussion_content":"如果想要完全避免 重复消费 Exactly Once，是否要在业务端记录最近一段时间(消息的过期时间)内成功的消息ID，凡是重复的ID一律不执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605009754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347941,"discussion_content":"消费端考虑幂等性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612393165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":323853,"ip_address":""},"score":347941,"extra":""}]}]}]}