{"id":740805,"title":"第 6 章 表达式","content":"\n<blockquote>\n<p>LISP 程序员知道一切的价值（value），但不了解其代价。</p>\n<p style=\"text-align: right\">——Alan Perlis，警句 #55</p>\n</blockquote>\n<p>&nbsp;</p>\n<p>本章将介绍 Rust <strong>表达式</strong>，它是函数体的组成部分，因而也是大部分 Rust 代码的组成部分。Rust 中的大多数内容是表达式。本章将探索表达式的强大功能以及如何克服它的局限性。我们将介绍在 Rust 中完全面向表达式的控制流，以及 Rust 的基础运算符如何独立工作和组合工作。</p>\n<p>某些概念（比如闭包和迭代器）严格来说也属于这一类，但略显深奥，我们稍后将用单独的一章来介绍它们。目前，我们的目标是在这“区区几页”中涵盖尽可能多的语法。</p>\n<h2 id=\"nav_point_94\">6.1　表达式语言</h2>\n<p>Rust 乍看起来和 C 家族的语言相似，但这只是假象。在 C 语言中，<strong>表达式</strong>和语句之间有明显的区别，表达式看起来是这样的：</p>\n<pre class=\"code-rows\"><code>5 * (fahr-32) / 9</code></pre>\n<p>而<strong>语句</strong>看起来更像这样：</p>\n<pre class=\"code-rows\"><code>for (; begin != end; ++begin) {\n    if (*begin == target)\n        break;\n}</code></pre>\n<p>表达式有值，而语句没有。</p>\n<p>Rust 是所谓的<strong>表达式语言</strong>。这意味着它遵循更古老的传统，可以追溯到 Lisp，在 Lisp 中，表达式能完成所有工作。</p>\n<p>在 C 中，<code>if</code> 和 <code>switch</code> 是语句，它们不生成值，也不能在表达式中间使用。而在 Rust 中，<code>if</code> 和 <code>match</code> <strong>可以</strong>生成值。第 2 章介绍过一个生成数值的 <code>match</code> 表达式：</p>\n<pre class=\"code-rows\"><code>pixels[r * bounds.0 + c] =\n    match escapes(Complex { re: point.0, im: point.1 }, 255) {\n        None =&gt; 0,\n        Some(count) =&gt; 255 - count as u8\n    };</code></pre>\n<p><code>if</code> 表达式可用于初始化变量：</p>\n<pre class=\"code-rows\"><code>let status =\n    if cpu.temperature &lt;= MAX_TEMP {\n        HttpStatus::Ok\n    } else {\n        HttpStatus::ServerError  // 服务程序出错了\n    };</code></pre>\n<p><code>match</code> 表达式可以作为参数传给函数或宏：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code>println!(\"Inside the vat, you see {}.\",\n    match vat.contents {\n        Some(brain) =&gt; brain.desc(),\n        None =&gt; \"nothing of interest\"\n    });</code></pre>\n<p>这解释了为什么 Rust 没有 C 那样的三元运算符（<code><i>expr1</i> ? <i>expr2</i> : <i>expr3</i></code>）。在 C 语言中，三元运算符是一个表达式级别的类似 <code>if</code> 语句的东西。这在 Rust 中是多余的：<code>if</code> 表达式足以处理这两种情况。</p>\n<p>C 中的大多数控制流工具是语句。而在 Rust 中，它们都是表达式。</p>\n<h2 id=\"nav_point_95\">6.2　优先级与结合性</h2>\n<p>表 6-1 总结了 Rust 的表达式语法。本章将讨论所有这些类型的表达式。这里的运算符已按优先级顺序列出，从最高到最低。（与大多数编程语言一样，当一个表达式包含多个相邻的运算符时，Rust 会根据<strong>运算符优先级</strong>来确定运算顺序。例如，在 <code>limit &lt; 2 * broom.size + 1</code> 中，<code>.</code> 运算符具有最高优先级，因此会最先访问字段。）</p>\n<p><strong>表 6-1：表达式</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>表达式类型</p></th>\n<th><p>示例</p></th>\n<th><p>相关特型</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>数组字面量</p></td>\n<td><p><code>[1, 2, 3]</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>数组重复表达式</p></td>\n<td><p><code>[0; 50]</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>元组</p></td>\n<td><p><code>(6, \"crullers\")</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>分组</p></td>\n<td><p><code>(2 + 2)</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>块</p></td>\n<td><p><code>{ f(); g() }</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>控制流表达式</p></td>\n<td><p><code>if ok { f() }</code><br /><code>if ok { 1 } else { 0 }</code><br /><code>if let Some(x) = f() { x } else { 0 }</code><br /><code>match x { None =&gt; 0, _ =&gt; 1 }</code><br /><code>for v in e { f(v); }</code><br /><code>while ok { ok = f(); }</code><br /><code>while let Some(x) = it.next() { f(x); }</code><br /><code>loop { next_event(); }</code><br /><code>break</code><br /><code>continue</code><br /><code>return 0</code></p></td>\n<td><p><code>std::iter::IntoIterator</code></p></td>\n</tr>\n<tr>\n<td><p>宏调用</p></td>\n<td><p><code>println!(\"ok\")</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>路径</p></td>\n<td><p><code>std::f64::consts::PI</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>结构体字面量</p></td>\n<td><p><code>Point </code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>元组字段访问</p></td>\n<td><p><code>pair.0</code></p></td>\n<td><p><code>Deref</code>、<code>DerefMut</code></p></td>\n</tr>\n<tr>\n<td><p>结构体字段访问</p></td>\n<td><p><code>point.x</code></p></td>\n<td><p><code>Deref</code>、<code>DerefMut</code></p></td>\n</tr>\n<tr>\n<td><p>方法调用</p></td>\n<td><p><code>point.translate(50, 50)</code></p></td>\n<td><p><code>Deref</code>、<code>DerefMut</code></p></td>\n</tr>\n<tr>\n<td><p>函数调用</p></td>\n<td><p><code>stdin()</code></p></td>\n<td><p><code>Fn(Arg0, ...) -&gt; T</code>、<code>FnMut(Arg0, ...) -&gt; T</code>、<code>FnOnce(Arg0, ...) -&gt; T</code></p></td>\n</tr>\n<tr>\n<td><p>索引</p></td>\n<td><p><code>arr[0]</code></p></td>\n<td><p><code>Index</code>、<code>IndexMutDeref</code>、<code>DerefMut</code></p></td>\n</tr>\n<tr>\n<td><p>错误检查</p></td>\n<td><p><code>create_dir(\"tmp\")?</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>逻辑非 / 按位非</p></td>\n<td><p><code>!ok</code></p></td>\n<td><p><code>Not</code></p></td>\n</tr>\n<tr>\n<td><p>取负</p></td>\n<td><p><code>-num</code></p></td>\n<td><p><code>Neg</code></p></td>\n</tr>\n<tr>\n<td><p>解引用</p></td>\n<td><p><code>*ptr</code></p></td>\n<td><p><code>Deref</code>、<code>DerefMut</code></p></td>\n</tr>\n<tr>\n<td><p>借用</p></td>\n<td><p><code>&amp;val</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>类型转换</p></td>\n<td><p><code>x as u32</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>乘</p></td>\n<td><p><code>n * 2</code></p></td>\n<td><p><code>Mul</code></p></td>\n</tr>\n<tr>\n<td><p>除</p></td>\n<td><p><code>n / 2</code></p></td>\n<td><p><code>Div</code></p></td>\n</tr>\n<tr>\n<td><p>取余（取模）</p></td>\n<td><p><code>n % 2</code></p></td>\n<td><p><code>Rem</code></p></td>\n</tr>\n<tr>\n<td><p>加</p></td>\n<td><p><code>n + 1</code></p></td>\n<td><p><code>Add</code></p></td>\n</tr>\n<tr>\n<td><p>减</p></td>\n<td><p><code>n - 1</code></p></td>\n<td><p><code>Sub</code></p></td>\n</tr>\n<tr>\n<td><p>左移</p></td>\n<td><p><code>n &lt;&lt; 1</code></p></td>\n<td><p><code>Shl</code></p></td>\n</tr>\n<tr>\n<td><p>右移</p></td>\n<td><p><code>n &gt;&gt; 1</code></p></td>\n<td><p><code>Shr</code></p></td>\n</tr>\n<tr>\n<td><p>按位与</p></td>\n<td><p><code>n &amp; 1</code></p></td>\n<td><p><code>BitAnd</code></p></td>\n</tr>\n<tr>\n<td><p>按位异或</p></td>\n<td><p><code>n ^ 1</code></p></td>\n<td><p><code>BitXor</code></p></td>\n</tr>\n<tr>\n<td><p>按位或</p></td>\n<td><p><code>n | 1</code></p></td>\n<td><p><code>BitOr</code></p></td>\n</tr>\n<tr>\n<td><p>小于</p></td>\n<td><p><code>n &lt; 1</code></p></td>\n<td><p><code>std::cmp::PartialOrd</code></p></td>\n</tr>\n<tr>\n<td><p>小于等于</p></td>\n<td><p><code>n &lt;= 1</code></p></td>\n<td><p><code>std::cmp::PartialOrd</code></p></td>\n</tr>\n<tr>\n<td><p>大于</p></td>\n<td><p><code>n &gt; 1</code></p></td>\n<td><p><code>std::cmp::PartialOrd</code></p></td>\n</tr>\n<tr>\n<td><p>大于等于</p></td>\n<td><p><code>n &gt;= 1</code></p></td>\n<td><p><code>std::cmp::PartialOrd</code></p></td>\n</tr>\n<tr>\n<td><p>等于</p></td>\n<td><p><code>n == 1</code></p></td>\n<td><p><code>std::cmp::PartialEq</code></p></td>\n</tr>\n<tr>\n<td><p>不等于</p></td>\n<td><p><code>n != 1</code></p></td>\n<td><p><code>std::cmp::PartialEq</code></p></td>\n</tr>\n<tr>\n<td><p>逻辑与</p></td>\n<td><p><code>x.ok &amp;&amp; y.ok</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>逻辑或</p></td>\n<td><p><code>x.ok || backup.ok</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>右开区间范围</p></td>\n<td><p><code>start .. stop</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>右闭区间范围</p></td>\n<td><p><code>start ..= stop</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>赋值</p></td>\n<td><p><code>x = val</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p>复合赋值</p></td>\n<td><p><code>x *= 1</code><br /><code>x /= 1</code><br /><code>x %= 1</code><br /><code>x += 1</code><br /><code>x -= 1</code><br /><code>x &lt;&lt;= 1</code><br /><code>x &gt;&gt;= 1</code><br /><code>x &amp;= 1</code><br /><code>x ^= 1</code><br /><code>x |= 1</code></p></td>\n<td><p><code>DivAssign</code><br /><code>RemAssign</code><br /><code>AddAssign</code><br /><code>SubAssign</code><br /><code>ShlAssign</code><br /><code>ShrAssign</code><br /><code>BitAndAssign</code><br /><code>BitXorAssign</code><br /><code>BitOrAssign</code><br /><code>MulAssign</code></p></td>\n</tr>\n<tr>\n<td><p>闭包</p></td>\n<td><p><code>|x, y| x + y</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n</tbody>\n</table>\n<p>所有可以链式书写的运算符都是左结合的。也就是说，诸如 <code>a - b - c</code> 之类的操作链会分组为 <code>(a - b) - c</code>，而不是 <code>a - (b - c)</code>。所有可以这样链式书写的运算符都遵循左结合规则：</p>\n<pre class=\"code-rows\"><code>*   /   %   +   -   &lt;&lt;   &gt;&gt;   &amp;   ^   |   &amp;&amp;   ||   as</code></pre>\n<p>比较运算符、赋值运算符和范围运算符（<code>..</code> 和 <code>..=</code>）则根本无法链式书写。</p>\n<h2 id=\"nav_point_96\">6.3　块与分号</h2>\n<p>块是一种最通用的表达式。一个块生成一个值，并且可以在任何需要值的地方使用：</p>\n<pre class=\"code-rows\"><code>let display_name = match post.author() {\n    Some(author) =&gt; author.name(),\n    None =&gt; {\n        let network_info = post.get_network_metadata()?;\n        let ip = network_info.client_address();\n        ip.to_string()\n    }\n};</code></pre>\n<p><code>Some(author) =&gt;</code> 之后的代码是简单表达式 <code>author.name()</code>，<code>None =&gt;</code> 之后的代码是一个块表达式，它们对 Rust 来说没什么不同。块表达式的值是最后一个表达式 <code>ip.to_string()</code> 的值。</p>\n<p>请注意，<code>ip.to_string()</code> 方法调用后面没有分号。大多数 Rust 代码行以分号或花括号结尾，就像 C 或 Java 一样。如果一个块看起来很像 C 代码，在你熟悉的每个地方都有分号，那么它就会像 C 的块一样运行，并且其值为 <code>()</code>。正如第 2 章提到的，当块的最后一行不带分号时，就以最后这个表达式的值而不是通常的 <code>()</code> 作为块的值。</p>\n<p>在某些语言，尤其是 JavaScript 中，可以省略分号，并且该语言会简单地替你填充分号——这是一个小小的便捷特性。但 Rust 不一样。在 Rust 中，分号是有实际意义的：</p>\n<pre class=\"code-rows\"><code>let msg = {\n    // let声明：分号总是必需的\n    let dandelion_control = puffball.open();\n\n    // 带分号的表达式：调用方法，丢弃返回值\n    dandelion_control.release_all_seeds(launch_codes);\n\n    // 无分号的表达式：调用方法，返回值将存入`msg`\n    dandelion_control.get_status()\n};</code></pre>\n<p>块可以包含多个声明并在末尾生成值，这是一个很好的特性，你很快就会适应它。但它的一个缺点是，如果你不小心遗漏了分号，则会导致奇怪的错误消息：</p>\n<pre class=\"code-rows\"><code>...\nif preferences.changed() {\n    page.compute_size()  // 糟糕，丢了分号\n}\n...</code></pre>\n<p>如果在 C 或 Java 程序中犯了同样的错误，那么编译器会直接指出你漏了一个分号。但 Rust 会这么说：</p>\n<pre class=\"code-rows\"><code>error: mismatched types\n22 |         page.compute_size()  // 糟糕，丢了分号\n   |         ^^^^^^^^^^^^^^^^^^^- help: try adding a semicolon: `;`\n   |         |\n   |         expected (), found tuple\n   |\n   = note: expected unit type `()`\n              found tuple `(u32, u32)`</code></pre>\n<p>由于缺少分号，块的值将是 <code>page.compute_size()</code> 返回的任何值，但是没有 <code>else</code> 的 <code>if</code> 必定返回 <code>()</code>。幸好，Rust 已经针对这类错误做出改进，并会建议添加分号。</p>\n<h2 id=\"nav_point_97\">6.4　声明</h2>\n<p>除了表达式和分号，块还可以包含任意数量的声明。最常见的是 <code>let</code> 声明，它会声明局部变量：</p>\n<pre>\n<b>let</b> <i>name</i>: <i>type</i> = <i>expr</i>;\n</pre>\n\n<p>类型和初始化代码是可选的，分号则是必需的。与 Rust 中的所有标识符一样，变量名必须以字母或下划线开头，并且只能在第一个字符之后包含数字。Rust 中的“字母”是广义的，包括希腊字母、带重音的拉丁字符和更多符号——符合 Unicode 标准中附件 #31 要求的一切字符（也包括中文）。不允许使用表情符号。</p>\n<p><code>let</code> 声明可以在不初始化变量的情况下声明变量，然后再用赋值语句来初始化变量。这在某些情况下很有用，因为有时确实应该在某种控制流结构的中间初始化变量：</p>\n<pre class=\"code-rows\"><code>let name;\nif user.has_nickname() {\n    name = user.nickname();\n} else {\n    name = generate_unique_name();\n    user.register(&amp;name);\n}</code></pre>\n<p>这里有两种初始化局部变量 <code>name</code> 的方式，但无论采用哪种方式，都只会初始化一次，所以 <code>name</code> 不需要声明为 <code>mut</code>。</p>\n<p>在初始化之前就使用变量是错误的。（这与“移动后又使用值”的错误紧密相关。Rust 确实非常希望你只使用存在的值。）</p>\n<p>你可能偶尔会看到似乎在重新声明现有变量的代码，如下所示：</p>\n<pre class=\"code-rows\"><code>for line in file.lines() {\n    let line = line?;\n    ...\n}</code></pre>\n<p>这个 <code>let</code> 声明会创建一个不同类型的、新的（第二个）变量。第一个 <code>line</code> 变量的类型是 <code>Result&lt;String, io::Error&gt;</code>。第二个 <code>line</code> 变量则是 <code>String</code>。第二个定义会在所处代码块的其余部分代替第一个定义。这叫作<strong>遮蔽</strong>（shadowing），在 Rust 程序中很常见。该代码等效于如下内容：</p>\n<pre class=\"code-rows\"><code>for line_result in file.lines() {\n    let line = line_result?;\n    ...\n}</code></pre>\n<p>本书会坚持在这种情况下使用 <code>_result</code> 后缀，以便让不同变量具有不同的名称。</p>\n<p>块还可以包含<strong>语法项声明</strong>（item declaration）。语法项是指可以在程序或模块中的任意地方出现的声明，比如 <code>fn</code>、<code>struct</code> 或 <code>use</code>。</p>\n<p>后面的章节会详细介绍这些语法项。现阶段，用 <code>fn</code> 这个例子就足够了。任何块都可能包含一个 <code>fn</code>：</p>\n<pre class=\"code-rows\"><code>use std::io;\nuse std::cmp::Ordering;\n\nfn show_files() -&gt; io::Result&lt;()&gt; {\n    let mut v = vec![];\n    ...\n    fn cmp_by_timestamp_then_name(a: &amp;FileInfo, b: &amp;FileInfo) -&gt; Ordering {\n        a.timestamp.cmp(&amp;b.timestamp)   // 首先，比较时间戳\n            .reverse()                  // 最新的文件优先\n            .then(a.path.cmp(&amp;b.path))  // 通过路径做二级比较\n    }\n\n    v.sort_by(cmp_by_timestamp_then_name);\n    ...\n}</code></pre>\n<p>当在块内声明一个 <code>fn</code> 时，它的作用域是整个块，也就是说，它可以在整个封闭块内部<strong>使用</strong>。但是嵌套的 <code>fn</code> 无法访问恰好在同一作用域内的局部变量或参数。例如，函数 <code>cmp_by_timestamp_then_name</code> 不能直接使用 <code>v</code>。（封闭块与闭包不同。Rust 也有闭包，闭包可以看到封闭块作用域内的变量。请参阅第 14 章。）</p>\n<p>块甚至可以包含完整的模块。这可能看起来有点儿过分（真的需要把语言的<strong>每一</strong>部分都嵌进任何其他部分吗？），但是程序员（特别是使用宏的程序员）总是有办法为语言提供的每一种独立语法找到用武之地。</p>\n<h2 id=\"nav_point_98\">6.5　<code>if</code> 与 <code>match</code></h2>\n<p><code>if</code> 表达式的形式我们很眼熟：</p>\n<pre>\n<b>if</b> <i>condition1</i> <b>{</b>\n    <i>block1</i>\n<b>} else if</b> <i>condition2</i> <b>{</b>\n    <i>block2</i>\n<b>} else {</b>\n    <i>block_n</i>\n<b>}</b>\n</pre>\n\n<p>每个 <em><code>condition</code></em> 都必须是 <code>bool</code> 类型的表达式，依照 Rust 的风格，不会隐式地将数值或指针转换为布尔值。</p>\n<p>与 C 不同，条件周围不需要圆括号。事实上，如果出现了不必要的圆括号，那么 <code>rustc</code> 会给出警告。但花括号是必需的。</p>\n<p><code>else if</code> 块以及最后的 <code>else</code> 是可选的。没有 <code>else</code> 块的 <code>if</code> 表达式的行为与具有空的 <code>else</code> 块完全相同。</p>\n<p><code>match</code> 表达式类似于 C 语言中的 <code>switch</code> 语句，但更灵活。下面是一个简单的例子：</p>\n<pre class=\"code-rows\"><code>match code {\n    0 =&gt; println!(\"OK\"),\n    1 =&gt; println!(\"Wires Tangled\"),\n    2 =&gt; println!(\"User Asleep\"),\n    _ =&gt; println!(\"Unrecognized Error {}\", code)\n}</code></pre>\n<p>这类似于 <code>switch</code> 语句的用途。它将执行此 <code>match</code> 表达式的四个分支之一，具体执行哪个分支取决于 <code>code</code> 的值。通配符模式 <code>_</code> 会匹配所有内容。这类似于 <code>switch</code> 语句中的 <code>default:</code> 语句，不过它必须排在最后。将 <code>_</code> 模式放在其他模式之前意味着它会优先于其他模式。这样一来，其他模式将永远没机会匹配到（编译器会发出警告）。</p>\n<p>编译器可以使用跳转表来优化这种 <code>match</code>，就像 C++ 中的 <code>switch</code> 语句一样。当 <code>match</code> 的每个分支都生成一个常量值时，也会应用与 C++ 类似的优化。在这种情况下，编译器会构建出这些值的数组，并将各个 <code>match</code> 项编译为数组访问。除了边界检查，编译后的代码中根本不存在任何分支。</p>\n<p><code>match</code> 的多功能性源于每个分支 <code>=&gt;</code> 左侧支持的多种<strong>模式</strong>（pattern）。在上面的例子中，每个模式只是一个常量整数。我们还展示了用以区分两种 <code>Option</code> 值的 <code>match</code> 表达式：</p>\n<pre class=\"code-rows\"><code>match params.get(\"name\") {\n    Some(name) =&gt; println!(\"Hello, {}!\", name),\n    None =&gt; println!(\"Greetings, stranger.\")\n}</code></pre>\n<p>对模式的强大能力来说，这还只是“冰山一角”。模式可以匹配一系列值，它可以解构元组、可以匹配结构体的各个字段、可以追踪引用、可以借用部分值，等等。甚至可以说，Rust 的模式定义了自己的迷你语言。第 10 章会用一些篇幅来介绍模式。</p>\n<p><code>match</code> 表达式的一般形式如下所示：</p>\n<pre>\n<b>match</b> <i>value</i> <b>{</b>\n    <i>pattern</i> <b>=&gt;</b> <i>expr</i>,\n...\n}\n</pre>\n\n<p>如果 <em><code>expr</code></em> 是一个块，则可以省略此分支之后的逗号。</p>\n<p>Rust 会从第一项开始依次根据每个模式检查给定的 <em><code>value</code></em>。当模式能够匹配时，对应的 <em><code>expr</code></em> 会被求值，而当这个 <code>match</code> 表达式结束时，不会再检查别的模式。至少要有一个模式能够匹配。Rust 禁止执行未覆盖所有可能值的 <code>match</code> 表达式：</p>\n<pre class=\"code-rows\"><code>let score = match card.rank {\n    Jack =&gt; 10,\n    Queen =&gt; 10,\n    Ace =&gt; 11\n};  // 错误：未穷举所有模式</code></pre>\n<p><code>if</code> 表达式的所有块都必须生成相同类型的值：</p>\n<pre class=\"code-rows\"><code>let suggested_pet =\n    if with_wings { Pet::Buzzard } else { Pet::Hyena };  // 正确\n\nlet favorite_number =\n    if user.is_hobbit() { \"eleventy-one\" } else { 9 };  // 错误\n\nlet best_sports_team =\n    if is_hockey_season() { \"Predators\" };  // 错误</code></pre>\n<p>（最后一个示例之所以是错的，是因为在 7 月份结果将是 <code>()</code>。）<span class=\"comment-number\">1</span></p>\n\n<p>类似地，<code>match</code> 表达式的所有分支都必须具有相同的类型。</p>\n<pre class=\"code-rows\"><code>let suggested_pet =\n    match favorites.element {\n        Fire =&gt; Pet::RedPanda,\n        Air =&gt; Pet::Buffalo,\n        Water =&gt; Pet::Orca,\n        _ =&gt; None  // 错误：不兼容的类型\n    };</code></pre>\n<h3 id=\"nav_point_99\">6.5.1　<code>if let</code></h3>\n<p>还有一种 <code>if</code> 形式，即 <code>if let</code> 表达式：</p>\n<pre>\n<b>if let</b> <i>pattern</i> <b>=</b> <i>expr</i> <b>{</b>\n    <i>block1</i>\n<b>} else {</b>\n    <i>block2</i>\n<b>}</b>\n</pre>\n\n<p>给定的 <em><code>expr</code></em> 要么匹配 <em><code>pattern</code></em>，这时会运行 <em><code>block1</code></em>；要么无法匹配，这时会运行 <em><code>block2</code></em>。有时这是从 <code>Option</code> 或 <code>Result</code> 中获取数据的好办法：</p>\n<pre class=\"code-rows\"><code>if let Some(cookie) = request.session_cookie {\n    return restore_session(cookie);\n}\n\nif let Err(err) = show_cheesy_anti_robot_task() {\n    log_robot_attempt(err);\n    politely_accuse_user_of_being_a_robot();\n} else {\n    session.mark_as_human();\n}</code></pre>\n<p><code>if let</code> 不是<strong>必需</strong>的，因为凡是 <code>if let</code> 可以做到的，<code>match</code> 同样可以做到。<code>if let</code> 表达式其实是只有一个模式的 <code>match</code> 表达式的简写形式。</p>\n<pre>\n<b>match</b> <i>expr</i> <b>{</b>\n    <i>pattern</i> <b>=&gt; {</b> <i>block1</i> <b>}</b>\n    <b>_ =&gt; {</b> <i>block2</i> <b>}</b>\n<b>}</b>\n</pre>\n\n<h3 id=\"nav_point_100\">6.5.2　循环</h3>\n<p>有 4 种循环表达式：</p>\n<pre>\n<b>while</b> <i>condition</i> <b>{</b>\n    <i>block</i>\n<b>}</b>\n\n<b>while let</b> <i>pattern</i> <b>=</b> <i>expr</i> <b>{</b>\n    <i>block</i>\n<b>}</b>\n\n<b>loop {</b>\n    <i>block</i>\n<b>}</b>\n\n<b>for</b> <i>pattern</i> <b>in</b> <i>iterable</i> <b>{</b>\n    <i>block</i>\n<b>}</b>\n</pre>\n\n<p>各种循环都是 Rust 中的表达式，但 <code>while</code> 循环或 <code>for</code> 循环的值总是 <code>()</code>，因此它们的值通常没什么用。如果指定了一个值，那么 <code>loop</code> 表达式就能生成一个值。</p>\n<p><code>while</code> 循环的行为与 C 中的等效循环完全一样，只不过其 <em><code>condition</code></em> 必须是 <code>bool</code> 类型。</p>\n<p><code>while let</code> 循环类似于 <code>if let</code>。在每次循环迭代开始时，<em><code>expr</code></em> 的值要么匹配给定的 <em><code>pattern</code></em>，这时会运行循环体（<code>block</code>）；要么不匹配，这时会退出循环。</p>\n<p>可以用 <code>loop</code> 来编写无限循环。它会永远重复执行循环体（直到遇上 <code>break</code> 或 <code>return</code>，或者直到线程崩溃）。</p>\n<p><code>for</code> 循环会对可迭代（<code>iterable</code>）表达式求值，然后为结果迭代器中的每个值运行一次循环体。许多类型可以迭代，包括所有标准库集合，比如 <code>Vec</code> 和 <code>HashMap</code>。标准的 C 语言的 <code>for</code> 循环如下所示：</p>\n<pre class=\"code-rows\"><code>for (int i = 0; i &lt; 20; i++) {\n    printf(\"%d\\n\", i);\n}</code></pre>\n<p>在 Rust 中则是这样的：</p>\n<pre class=\"code-rows\"><code>for i in 0..20 {\n    println!(\"{}\", i);\n}</code></pre>\n<p>与 C 一样，最后打印出的数值是 <code>19</code>。</p>\n<p><code>..</code> 运算符会生成一个<strong>范围</strong>（range），即具有两个字段（<code>start</code> 和 <code>end</code>）的简单结构体。<code>0..20</code> 与 <code>std::ops::Range { start: 0, end: 20 }</code> 相同。各种范围都可以与 <code>for</code> 循环一起使用，因为 <code>Range</code> 是一种可迭代类型，它实现了 <code>std::iter::IntoIterator</code> 特型（参见第 15 章）。标准集合都是可迭代的，数组和切片也是如此。</p>\n<p>为了与 Rust 的移动语义保持一致，把值用于 <code>for</code> 循环会消耗该值：</p>\n<pre class=\"code-rows\"><code>let strings: Vec&lt;String&gt; = error_messages();\nfor s in strings {                  // 在这里，每个String都会转移给s……\n    println!(\"{}\", s);\n}                                   // ……并在此丢弃\nprintln!(\"{} error(s)\", strings.len()); // 错误：使用了已移动出去的值</code></pre>\n<p>这可能很不方便。简单的补救措施是在循环中访问此集合的引用。然后，循环变量也会变成对集合中每个条目的引用：</p>\n<pre class=\"code-rows\"><code>for rs in &amp;strings {\n    println!(\"String {:?} is at address {:p}.\", *rs, rs);\n}</code></pre>\n<p>这里 <code>&amp;strings</code> 的类型是 <code>&amp;Vec&lt;String&gt;</code>，<code>rs</code> 的类型是 <code>&amp;String</code>。</p>\n<p>遍历（可迭代对象的）可变引用会为每个元素提供一个可变引用：</p>\n<pre class=\"code-rows\"><code>for rs in &amp;mut strings {  // rs的类型是&amp;mut String\n    rs.push('\\n');  // 为每个字符串添加一个换行\n}</code></pre>\n<p>第 15 章会更详细地介绍 <code>for</code> 循环，并展示使用迭代器的许多其他方式。</p>\n<h2 id=\"nav_point_101\">6.6　循环中的控制流</h2>\n<p><code>break</code> 表达式会退出所在循环。（在 Rust 中，<code>break</code> 只能用在循环中，不能用在 <code>match</code> 表达式中，这与 <code>switch</code> 语句不同。）</p>\n<p>在 <code>loop</code> 的循环体中，可以在 <code>break</code> 后面跟一个表达式，该表达式的值会成为此 <code>loop</code> 的值：</p>\n<pre class=\"code-rows\"><code>// 对`next_line`的每一次调用，或者返回一个`Some(line)`（这里的`line`是\n// 输入中的一行），或者当输入已结束时返回`None`。最终会返回以\"answer: \"\n// 开头的第1行，如果没找到，就返回\"answer: nothing\"\nlet answer = loop {\n    if let Some(line) = next_line() {\n        if line.starts_with(\"answer: \") {\n            break line;\n        }\n    } else {\n        break \"answer: nothing\";\n    }\n};</code></pre>\n<p>自然，<code>loop</code> 中的所有 <code>break</code> 表达式也必须生成具有相同类型的值，这样该类型就会成为这个 <code>loop</code> 本身的类型。</p>\n<p><code>continue</code> 表达式会跳转到循环的下一次迭代：</p>\n<pre class=\"code-rows\"><code>// 读取某些数据，每次一行\nfor line in input_lines {\n    let trimmed = trim_comments_and_whitespace(line);\n    if trimmed.is_empty() {\n        // 跳转回循环的顶部，并移到输入中的下一行\n        continue;\n    }\n    ...\n}</code></pre>\n<p>在 <code>for</code> 循环中，<code>continue</code> 会前进到集合中的下一个值，如果没有更多值，则退出循环。同样，在 <code>while</code> 循环中，<code>continue</code> 会重新检查循环条件，如果当前条件为假，就退出循环。</p>\n<p>循环可以带有生命周期<strong>标签</strong>。在以下示例中，<code>'search:</code> 是外部 <code>for</code> 循环的标签。因此，<code>break 'search</code> 会退出这层循环，而不是退出内部循环：</p>\n<pre class=\"code-rows\"><code>'search:\nfor room in apartment {\n    for spot in room.hiding_spots() {\n        if spot.contains(keys) {\n            println!(\"Your keys are {} in the {}.\", spot, room);\n            break 'search;\n        }\n    }\n}</code></pre>\n<p><code>break</code> 可以同时具有标签和值表达式：</p>\n<pre class=\"code-rows\"><code>// 找到此系列中第一个完全平方数的平方根\nlet sqrt = 'outer: loop {\n    let n = next_number();\n    for i in 1.. {\n        let square = i * i;\n        if square == n {\n            // 找到了一个平方根\n            break 'outer i;\n        }\n        if square &gt; n {\n            // `n`不是完全平方数，尝试下一个\n            break;\n        }\n    }\n};</code></pre>\n<p>标签也可以与 <code>continue</code> 一起使用。</p>\n<h2 id=\"nav_point_102\">6.7　<code>return</code> 表达式</h2>\n<p><code>return</code> 表达式会退出当前函数，并向调用者返回一个值。</p>\n<p>不带值的 <code>return</code> 是 <code>return ()</code> 的简写：</p>\n<pre class=\"code-rows\"><code>fn f() {     // 省略了返回类型：默认为()\n    return;  // 省略了返回值：默认为()\n}</code></pre>\n<p>函数不必有明确的 <code>return</code> 表达式。函数体的工作方式类似于块表达式：如果最后一个表达式后没有分号，则它的值就是函数的返回值。事实上，这是在 Rust 中提供函数返回值的首选方式。</p>\n<p>但这并不意味着 <code>return</code> 是无用的，或者仅仅是对不熟悉表达式语言的用户做出的让步。与 <code>break</code> 表达式一样，<code>return</code> 可以放弃进行中的工作。例如，第 2 章就使用过 <code>?</code> 运算符在调用可能失败的函数后检查错误：</p>\n<pre class=\"code-rows\"><code>let output = File::create(filename)?;</code></pre>\n<p>我们曾解释说这是 <code>match</code> 表达式的简写形式：</p>\n<pre class=\"code-rows\"><code>let output = match File::create(filename) {\n    Ok(f) =&gt; f,\n    Err(err) =&gt; return Err(err)\n};</code></pre>\n<p>上述代码会首先调用 <code>File::create(filename)</code>。如果返回 <code>Ok(f)</code>，则整个 <code>match</code> 表达式的计算结果为 <code>f</code>，因此可以把 <code>f</code> 存储在 <code>output</code> 中，继续执行 <code>match</code> 后的下一行代码。</p>\n<p>否则，我们将匹配 <code>Err(err)</code> 并抵达 <code>return</code> 表达式。这时候，对 <code>match</code> 表达式求值的具体结果会决定 <code>output</code> 变量的值。我们会放弃所有这些并退出所在函数，返回从 <code>File::create()</code> 中得到的任何错误。</p>\n<p>7.2.4 节会完整讲解 <code>?</code> 运算符。</p>\n<h2 id=\"nav_point_103\">6.8　为什么 Rust 中会有 <code>loop</code></h2>\n<p>Rust 编译器中有几个部分会分析程序中的控制流。</p>\n<ul>\n<li>Rust 会检查通过函数的每条路径是否返回了预期返回类型的值。为了正确地做到这一点，它需要知道是否有可能抵达函数的末尾。</li>\n<li>Rust 会检查局部变量有没有在未初始化的情况下使用过。这就要检查通过函数的每一条路径，以确保只要不经过初始化此变量的代码，就无法抵达使用它的地方。</li>\n<li>Rust 会对不可达代码发出警告。如果<strong>无法</strong>通过函数抵达某段代码，则这段代码不可达。</li>\n</ul>\n<p>以上这些称为<strong>流敏感</strong>（flow-sensitive）分析。这不是什么新事物，多年来，Java 一直在采用与 Rust 相似的“显式赋值”分析。</p>\n<p>要执行这种规则，语言就必须在简单性和智能性之间取得平衡。简单性使得程序员更容易弄清楚编译器到底在说什么，而智能性有助于消除假警报和编译器拒绝一份完美而安全的程序的情况。Rust 更倾向于简单性，它的流敏感分析根本不会检查循环条件，而会简单地假设程序中的任何条件都可以为真或为假。</p>\n<p>这会导致 Rust 可能拒绝某些安全程序：</p>\n<pre class=\"code-rows\"><code>fn wait_for_process(process: &amp;mut Process) -&gt; i32 {\n    while true {\n        if process.wait() {\n            return process.exit_code();\n        }\n    }\n}  // 错误：类型不匹配：期待i32，实际找到了()</code></pre>\n<p>这里的错误是假警报。此函数只会通过 <code>return</code> 语句退出，因此 <code>while</code> 循环无法生成 <code>i32</code> 这个事实无关紧要。</p>\n<p><code>loop</code> 表达式就是这个问题的“有话直说”式解决方案。</p>\n<p>Rust 的类型系统也会受到控制流的影响。前面说过，<code>if</code> 表达式的所有分支都必须具有相同的类型。但是，在可能以 <code>break</code> 或 <code>return</code> 表达式、无限 <code>loop</code>，或者调用 <code>panic!()</code> 或 <code>std::process::exit()</code> 等多种方式结束的块上强制执行此规则是不现实的。这些表达式的共同点是它们永远都不会以通常的方式结束并生成一个值。<code>break</code> 或 <code>return</code> 会突然退出当前块、无限 <code>loop</code> 则根本不会结束，等等。</p>\n<p>所以，在 Rust 中，这些表达式没有正常类型。不能正常结束的表达式属于一个特殊类型 <code>!</code>，并且它们不受“类型必须匹配”这条规则的约束。可以在 <code>std::process::exit()</code> 的函数签名中看到 <code>!</code>：</p>\n<pre class=\"code-rows\"><code>fn exit(code: i32) -&gt; !</code></pre>\n<p>此处的 <code>!</code> 表示 <code>exit()</code> 永远不会返回，它是一个<strong>发散函数</strong>（divergent function）。</p>\n<p>你可以用相同的语法编写自己的发散函数，这在某些情况下是很自然的：</p>\n<pre class=\"code-rows\"><code>fn serve_forever(socket: ServerSocket, handler: ServerHandler) -&gt; ! {\n    socket.listen();\n    loop {\n        let s = socket.accept();\n        handler.handle(s);\n    }\n}</code></pre>\n<p>当然，如果此函数正常返回了，那么 Rust 就会认为它能正常返回反而是一个错误。</p>\n<p>有了这些大规模控制流的构建块，就可以继续处理该流中常用的、更细粒度的表达式（比如函数调用和算术运算符）了。</p>\n<h2 id=\"nav_point_104\">6.9　函数与方法调用</h2>\n<p>Rust 中调用函数和方法的语法与许多其他语言中的语法相同：</p>\n<pre class=\"code-rows\"><code>let x = gcd(1302, 462);  // 函数调用\n\nlet room = player.location();  // 方法调用</code></pre>\n<p>在此处的第二个示例中，<code>player</code> 是虚构类型 <code>Player</code> 的变量，它具有虚构的 <code>.location()</code> 方法。（第 9 章在讨论用户定义类型时会展示如何定义我们自己的方法。）</p>\n<p>Rust 通常会在引用和它们所引用的值之间做出明确的区分。如果将 <code>&amp;i32</code> 传给需要 <code>i32</code> 的函数，则会出现类型错误。你会注意到 <code>.</code> 运算符稍微放宽了这些规则。在调用 <code>player. location()</code> 的方法中，<code>player</code> 可能是一个 <code>Player</code>、一个 <code>&amp;Player</code> 类型的引用，也可能是一个 <code>Box&lt;Player&gt;</code> 或 <code>Rc&lt;Player&gt;</code> 类型的智能指针。<code>.location()</code> 方法可以通过值或引用获取 <code>player</code>。同一个 <code>.location()</code> 语法适用于所有情况，因为 Rust 的 <code>.</code> 运算符会根据需要自动对 <code>player</code> 解引用或借入一个对它的引用。</p>\n<p>第三种语法用于调用类型关联函数，比如 <code>Vec::new()</code>：</p>\n<pre class=\"code-rows\"><code>let mut numbers = Vec::new();  // 类型关联函数调用</code></pre>\n<p>这些语法类似于面向对象语言中的静态方法：普通方法会在值上调用（如 <code>my_vec.len()</code>），类型关联函数会在类型上调用（如 <code>Vec::new()</code>）。</p>\n<p>自然，也支持链式方法调用：</p>\n<pre class=\"code-rows\"><code>// 来自第2章的基于Actix的Web服务器\nserver\n    .bind(\"127.0.0.1:3000\").expect(\"error binding server to address\")\n    .run().expect(\"error running server\");</code></pre>\n<p>Rust 语法的怪癖之一就是，在函数调用或方法调用中，泛型类型的常用语法 <code>Vec&lt;T&gt;</code> 是不起作用的：</p>\n<pre class=\"code-rows\"><code>return Vec&lt;i32&gt;::with_capacity(1000);  // 错误：是某种关于“链式比较”的错误消息\n\nlet ramp = (0 .. n).collect&lt;Vec&lt;i32&gt;&gt;();  // 同样的错误</code></pre>\n<p>这里的问题在于，在表达式中 <code>&lt;</code> 是小于运算符。Rust 编译器建议用 <code>::&lt;T&gt;</code> 代替 <code>&lt;T&gt;</code>。这样就解决了问题：</p>\n<pre class=\"code-rows\"><code>return Vec::&lt;i32&gt;::with_capacity(1000);  // 正确，改用::&lt;\n\nlet ramp = (0 .. n).collect::&lt;Vec&lt;i32&gt;&gt;();  // 正确，改用::&lt;</code></pre>\n<p>符号 <code>::&lt;...&gt;</code> 在 Rust 社区中被亲切地称为<strong>比目鱼</strong>（turbofish）。</p>\n<p>或者，通常可以删掉类型参数，让 Rust 来推断它们：</p>\n<pre class=\"code-rows\"><code>return Vec::with_capacity(10);  // 正确，只要fn的返回类型是Vec&lt;i32&gt;\n\nlet ramp: Vec&lt;i32&gt; = (0 .. n).collect();  // 正确，前面已给定变量的类型</code></pre>\n<p>只要类型可以被推断，就省略类型，这是一种很好的代码风格。</p>\n<h2 id=\"nav_point_105\">6.10　字段与元素</h2>\n<p>你可以使用早已熟悉的语法访问结构体的字段。元组也一样，不过它们的字段是数值而不是名称：</p>\n<pre class=\"code-rows\"><code>game.black_pawns   // 结构体字段\ncoords.1           // 元组元素</code></pre>\n<p>如果 <code>.</code> 左边的值是引用或智能指针类型，那么它就会像方法调用一样自动解引用。</p>\n<p>方括号会访问数组、切片或向量的元素：</p>\n<pre class=\"code-rows\"><code>pieces[i]          // 数组元素</code></pre>\n<p>方括号左侧的值也会自动解引用。</p>\n<p>像下面这样的 3 个表达式叫作<strong>左值</strong>，因为赋值时它们可以出现在左侧：</p>\n<pre class=\"code-rows\"><code>game.black_pawns = 0x00ff0000_00000000_u64;\ncoords.1 = 0;\npieces[2] = Some(Piece::new(Black, Knight, coords));</code></pre>\n<p>当然，只有当 <code>game</code>、<code>coords</code> 和 <code>pieces</code> 声明为 <code>mut</code> 变量时才允许这样做。</p>\n<p>从数组或向量中提取切片的写法很直观：</p>\n<pre class=\"code-rows\"><code>let second_half = &amp;game_moves[midpoint .. end];</code></pre>\n<p>这里的 <code>game_moves</code> 可以是数组、切片或向量，无论哪种方式，结果都是已被借出的长度为 <code>end - midpoint</code> 的切片。在 <code>second_half</code> 的生命周期内，<code>game_moves</code> 要被视为已借出的引用。</p>\n<p><code>..</code> 运算符允许省略任何一个操作数，它会根据存在的操作数最多生成 4 种类型的对象：</p>\n<pre class=\"code-rows\"><code>..      // RangeFull\na ..    // RangeFrom { start: a }\n.. b    // RangeTo { end: b }\na .. b  // Range { start: a, end: b }</code></pre>\n<p>后两种形式是<strong>排除结束值</strong>（或<strong>半开放</strong>）的：结束值不包含在所表示的范围内。例如，范围 <code>0 .. 3</code> 包括数值 <code>0</code>、<code>1</code> 和 <code>2</code>，但不包括 <code>3</code>。</p>\n<p><code>..=</code> 运算符会生成<strong>包含结束值</strong>（或<strong>封闭</strong>）的范围，其中包括结束值：</p>\n<pre class=\"code-rows\"><code>..= b    // RangeToInclusive { end: b }\na ..= b  // RangeInclusive::new(a, b)</code></pre>\n<p>例如，范围 <code>0 ..= 3</code> 包括数值 <code>0</code>、<code>1</code>、<code>2</code> 和 <code>3</code>。</p>\n<p>只有包含起始值的范围才是可迭代的，因为循环必须从某处开始。但是在数组切片中，这 6 种形式都可以使用。如果省略了范围的起点或末尾，则默认为被切片数据的起点或末尾。</p>\n<p>因此，经典的分治算法快速排序 <code>quicksort</code> 的实现部分看起来可能像下面这样。</p>\n<pre class=\"code-rows\"><code>fn quicksort&lt;T: Ord&gt;(slice: &amp;mut [T]) {\n    if slice.len() &lt;= 1 {\n        return;  // 无可排序\n    }\n\n    // 把slice分成两部分：前半片和后半片\n    let pivot_index = partition(slice);\n\n    // 对slice的前半片递归排序\n    quicksort(&amp;mut slice[.. pivot_index]);\n\n    // 对slice的后半片递归排序\n    quicksort(&amp;mut slice[pivot_index + 1 ..]);\n}</code></pre>\n<h2 id=\"nav_point_106\">6.11　引用运算符</h2>\n<p>地址运算符 <code>&amp;</code> 和 <code>&amp;mut</code> 已在第 5 章中介绍过。</p>\n<p>一元 <code>*</code> 运算符用于访问引用所指向的值。如你所见，当使用 <code>.</code> 运算符访问字段或方法时，Rust 会自动追踪引用，因此只有想要读取或写入引用所指的整个值时才需要用 <code>*</code> 运算符。</p>\n<p>例如，有时迭代器会生成引用，但程序需要访问底层值：</p>\n<pre class=\"code-rows\"><code>let padovan: Vec&lt;u64&gt; = compute_padovan_sequence(n);\nfor elem in &amp;padovan {\n    draw_triangle(turtle, *elem);\n}</code></pre>\n<p>在此示例中，<code>elem</code> 的类型为 <code>&amp;u64</code>，因此 <code>*elem</code> 为 <code>u64</code>。</p>\n<h2 id=\"nav_point_107\">6.12　算术运算符、按位运算符、比较运算符和逻辑运算符</h2>\n<p>Rust 的二元运算符与许多其他语言中的二元运算符类似。为了节省时间，这里假设你熟悉其中某一种语言，并专注于 Rust 与传统语言不同的几个点。</p>\n<p>Rust 有一些常用的算术运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 和 <code>%</code>。如第 3 章所述，在调试构建中会检测到整数溢出并引发 panic。标准库为此提供了一些非检查（<code>unchecked</code>）的算术方法，比如 <code>a.wrapping_add(b)</code>。</p>\n<p>整数除法会向 0 取整，而整数除以 0 会触发 panic，即使在发布构建中也是如此。标准库为整数提供了一个 <code>a.checked_div(b)</code> 方法，它将返回一个 <code>Option</code>（如果 <code>b</code> 为 0 则返回 <code>None</code>），并且不会引发 panic。</p>\n<p>一元 <code>-</code> 运算符会对一个数取负。它支持除无符号整数之外的所有数值类型。没有一元 <code>+</code> 运算符。</p>\n<pre class=\"code-rows\"><code>println!(\"{}\", -100);     // -100\nprintln!(\"{}\", -100u32);  // 错误：不能在类型`u32`上使用一元`-`运算符\nprintln!(\"{}\", +100);     // 错误：期待表达式，但发现了`+`</code></pre>\n<p>与在 C 中一样，<code>a % b</code> 会计算向 0 四舍五入的有符号余数或模数。其结果与左操作数的符号相同。注意，<code>%</code> 既能用于整数，也能用于浮点数：</p>\n<pre class=\"code-rows\"><code>let x = 1234.567 % 10.0;  // 约等于4.567</code></pre>\n<p>Rust 还继承了 C 的按位整数运算符 <code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>。但是，Rust 会使用 <code>!</code> 而不是 <code>~</code> 表示按位非：</p>\n<pre class=\"code-rows\"><code>let hi: u8 = 0xe0;\nlet lo = !hi;  // 0x1f</code></pre>\n<p>这意味着对于整数 <code>n</code>，不能用 <code>!n</code> 来表示“<code>n</code> 为 0”，而是应该写成 <code>n == 0</code>。</p>\n<p>移位总是对有符号整数类型进行符号扩展，对无符号整数类型进行零扩展。由于 Rust 具有无符号整数，因此它不需要诸如 Java 的 <code>&gt;&gt;&gt;</code> 运算符之类的无符号移位运算符。</p>\n<p>与 C 不同，Rust 中按位运算的优先级高于比较运算，因此如果编写 <code>x &amp; BIT != 0</code>，那么就意味着 <code>(x &amp; BIT) != 0</code>，正如预期的那样。这比在 C 中解释成的 <code>x &amp; (BIT != 0)</code> 有用得多，后者会测试错误的位。</p>\n<p>Rust 的比较运算符是 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code>，参与比较的两个值必须具有相同的类型。</p>\n<p>Rust 还有两个短路逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code>，它们的操作数都必须具有确切的 <code>bool</code> 类型。</p>\n<h2 id=\"nav_point_108\">6.13　赋值</h2>\n<p><code>=</code> 运算符用于给 <code>mut</code> 变量及其字段或元素赋值。但是赋值在 Rust 中不像在其他语言中那么常见，因为默认情况下变量是不可变的。</p>\n<p>如第 4 章所述，如果值是非 <code>Copy</code> 类型的，则赋值会将其<strong>移动</strong>到目标位置。值的所有权会从源转移给目标。目标的先前值（如果有的话）将被丢弃。</p>\n<p>Rust 支持复合赋值：</p>\n<pre class=\"code-rows\"><code>total += item.price;</code></pre>\n<p>这等效于 <code>total = total + item.price;</code>。Rust 也支持其他运算符：<code>-=</code>、<code>*=</code> 等。完整列表参见表 6-1。</p>\n<p>与 C 不同，Rust 不支持链式赋值：不能编写 <code>a = b = 3</code> 来将值 <code>3</code> 同时赋给 <code>a</code> 和 <code>b</code>。赋值在 Rust 中非常罕见，你是不会想念这种简写形式的。</p>\n<p>Rust 没有 C 的自增运算符 <code>++</code> 和自减运算符 <code>--</code>。</p>\n<h2 id=\"nav_point_109\">6.14　类型转换</h2>\n<p>在 Rust 中，将值从一种类型转换为另一种类型通常需要进行显式转换。这种转换要使用 <code>as</code> 关键字：</p>\n<pre class=\"code-rows\"><code>let x = 17;              // x是i32类型的\nlet index = x as usize;  // 转换成usize</code></pre>\n<p>Rust 允许进行好几种类型的转换。</p>\n<ul>\n<li><p>数值可以从任意内置数值类型转换为其他内置数值类型。</p>\n<p>将一种整数类型转换为另一种整数类型始终是明确定义的。转换为更窄的类型会导致截断。转换为更宽类型的有符号整数会进行符号扩展，转换为无符号整数会进行零扩展，等等。简而言之，没有意外。</p>\n<p>从浮点类型转换为整数类型会向 0 舍入，比如 <code>-1.99 as i32</code> 就是 <code>-1</code>。如果值太大而无法容纳整数类型，则转换会生成整数类型可以表示的最接近的值，比如 <code>1e6 as u8</code> 就是 <code>255</code>。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><code>bool</code> 类型或 <code>char</code> 类型的值或者类似 C 的 <code>enum</code> 类型的值可以转换为任何整数类型。（第 10 章会介绍枚举。）</p>\n<p>不允许向相反方向转换，因为 <code>bool</code> 类型、<code>char</code> 类型和 <code>enum</code> 类型都对其值有限制，必须通过运行期检查强制执行。例如，禁止将 <code>u16</code> 转换为 <code>char</code> 类型，因为某些 <code>u16</code> 值（如 <code>0xd800</code>）对应于 Unicode 的半代用区码点，因此无法生成有效的 <code>char</code> 值。有一个标准方法 <code>std::char::from_u32()</code>，它会执行运行期检查并返回一个 <code>Option&lt;char&gt;</code>，但更重要的是，这种转变的需求已经越来越少了。我们通常会一次转换整个字符串或流，Unicode 文本的算法通常比较复杂，最好留给库去实现。</p>\n<p>作为例外，<code>u8</code> 可以转换为 <code>char</code> 类型，因为从 0 到 255 的所有整数都是 <code>char</code> 能持有的有效 Unicode 码点。</p>\n<p>&nbsp;</p>\n</li>\n<li><p>一些涉及不安全指针类型的转换也是允许的。参见 22.8 节。</p>\n</li>\n</ul>\n<p>我们说过<strong>通常</strong>需要进行强制转换。但一些涉及引用类型的转换非常直观，Rust 甚至无须强制转换就能执行它们。一个简单的例子是将可变引用转换为不可变引用。</p>\n<p>不过，还可能会发生几个更重要的自动转换。</p>\n<ul>\n<li><code>&amp;String</code> 类型的值会自动转换为 <code>&amp;str</code> 类型，无须强制转换。</li>\n<li><code>&amp;Vec&lt;i32&gt;</code> 类型的值会自动转换为 <code>&amp;[i32]</code>。</li>\n<li><code>&amp;Box&lt;Chessboard&gt;</code> 类型的值会自动转换为 <code>&amp;Chessboard</code>。</li>\n</ul>\n<p>这些称为<strong>隐式解引用</strong>，因为它们适用于所有实现了内置特型 <code>Deref</code> 的类型。<code>Deref</code> 隐式转换的目的是使智能指针类型（如 <code>Box</code>）的行为尽可能像其底层值。多亏了 <code>Deref</code>，<code>Box&lt;Chessboard&gt;</code> 的用法基本上和普通 <code>Chessboard</code> 的用法一样。</p>\n<p>用户定义类型也可以实现 <code>Deref</code> 特型。当你需要编写自己的智能指针类型时，请参阅 13.5 节。</p>\n<h2 id=\"nav_point_110\">6.15　闭包</h2>\n<p>Rust 也有<strong>闭包</strong>，即轻量级的类似函数的值。闭包通常由一个参数列表组成，在两条竖线之间列出，后跟一个表达式：</p>\n<pre class=\"code-rows\"><code>let is_even = |x| x % 2 == 0;</code></pre>\n<p>Rust 会推断其参数类型和返回类型。你也可以像写函数一样显式地写出它们。如果确实指定了返回类型，那么为了语法的完整性，闭包的主体必须是一个块：</p>\n<pre class=\"code-rows\"><code>let is_even = |x: u64| -&gt; bool x % 2 == 0;  // 错误\n\nlet is_even = |x: u64| -&gt; bool { x % 2 == 0 };  // 正确</code></pre>\n<p>调用闭包和调用函数的语法是一样的：</p>\n<pre class=\"code-rows\"><code>assert_eq!(is_even(14), true);</code></pre>\n<p>闭包是 Rust 最令人愉悦的特性之一，关于它们还有很多内容可以讲，第 14 章会详细介绍。</p>\n<h2 id=\"nav_point_111\">6.16　前路展望</h2>\n<p>表达式就是我们心目中的“可执行代码”，它们是 Rust 程序中编译成机器指令的那部分。然而，表达式也只是整个语言的一小部分。</p>\n<p>大多数编程语言也是如此。程序的首要任务是执行，但这不是它唯一的任务。程序必须进行通信，必须是可测试的，必须保持组织性和灵活性，这样它们才能持续演进。程序还需要与其他团队构建的代码和服务进行互操作。就算只是为了执行，像 Rust 这样的静态类型语言的程序也需要更多的工具来组织数据，而不能仅仅使用元组和数组。</p>\n<p>接下来，本书会用几章内容来讨论这些特性：首先是模块与 crate，它们会帮你对程序进行组织；然后是结构体与枚举，它们会帮你对数据进行组织。</p>\n<p>不过，在此之前我们先来简单讨论一下“错误处理”这个重要主题。</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}