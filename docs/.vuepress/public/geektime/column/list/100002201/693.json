{"id":693,"title":"12 | 程序中的错误处理：异步编程以及我的最佳实践","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p><p>上节课中，我们讨论了错误返回码和异常捕捉，以及在不同情况下该如何选择和使用。这节课会接着讲两个有趣的话题：异步编程世界里的错误处理方法，以及我在实战中总结出来的错误处理最佳实践。</p><h1>异步编程世界里的错误处理</h1><p>在异步编程的世界里，因为被调用的函数是被放到了另外一个线程里运行，这将导致：</p><ul>\n<li>\n<p><strong>无法使用返回码</strong>。因为函数在“被”异步运行中，所谓的返回只是把处理权交给下一条指令，而不是把函数运行完的结果返回。<strong>所以，函数返回的语义完全变了，返回码也没有用了</strong>。</p>\n</li>\n<li>\n<p><strong>无法使用抛异常的方式</strong>。因为除了上述的函数立马返回的原因之外，抛出的异常也在另外一个线程中，不同线程中的栈是完全不一样的，所以主线程的 <code>catch</code> 完全看不到另外一个线程中的异常。</p>\n</li>\n</ul><p>对此，在异步编程的世界里，我们也会有好几种处理错误的方法，最常用的就是 <code>callback</code> 方式。在做异步请求的时候，注册几个 <code>OnSuccess()</code>、 <code>OnFailure()</code> 这样的函数，让在另一个线程中运行的异步代码回调过来。</p><h2>JavaScript异步编程的错误处理</h2><p>比如，下面这个JavaScript示例：</p><pre><code class=\"language-JavaScript\">function successCallback(result) {\n  console.log(\"It succeeded with \" + result);\n}\n\nfunction failureCallback(error) {\n  console.log(\"It failed with \" + error);\n}\n\ndoSomething(successCallback, failureCallback);\n</code></pre><!-- [[[read_end]]] --><p>通过注册错误处理的回调函数，让异步执行的函数在出错的时候，调用被注册进来的错误处理函数，这样的方式比较好地解决了程序的错误处理。<strong>而出错的语义从返回码、异常捕捉到了直接耦合错误出处函数的样子</strong>，挺好的。</p><p>但是， 如果我们需要把几个异步函数顺序执行的话（异步程序中，程序执行的顺序是不可预测的、也是不确定的，而有时候，函数被调用的上下文是有相互依赖的，所以，我们希望它们能按一定的顺序处理），就会出现了所谓的Callback Hell的问题。如下所示：</p><pre><code class=\"language-javascript\">doSomething(function(result) {\n  doSomethingElse(result, function(newResult) {\n    doThirdThing(newResult, function(finalResult) {\n      console.log('Got the final result: ' + finalResult);\n    }, failureCallback);\n  }, failureCallback);\n}, failureCallback);\n</code></pre><p>而这样层层嵌套中需要注册的错误处理函数也有可能是完全不一样的，而且会导致代码非常混乱，难以阅读和维护。</p><p>所以，一般来说，在异步编程的实践里，我们会用Promise模式来处理。如下所示（箭头表达式）：</p><pre><code class=\"language-JavaScript\">doSomething()\n.then(result =&gt; doSomethingElse(result))\n.then(newResult =&gt; doThirdThing(newResult))\n.then(finalResult =&gt; {\n  console.log(`Got the final result: ${finalResult}`);\n}).catch(failureCallback);\n</code></pre><p>上面代码中的 <code>then()</code> 和 <code>catch()</code> 方法就是Promise对象的方法，<code>then()</code>方法可以把各个异步的函数给串联起来，而<code>catch()</code> 方法则是出错的处理。</p><p>看到上面的那个级联式的调用方式，这就要我们的 <code>doSomething()</code> 函数返回Promise对象，下面是这个函数的相关代码示例：</p><p>比如：</p><pre><code class=\"language-JavaScript\">function doSomething() {\n\tlet promise = new Promise();\n\tlet xhr = new XMLHttpRequest();\n\txhr.open('GET', 'http://coolshell.cn/....', true);\n\n\txhr.onload = function (e) {\n        if (this.status === 200) {\n            results = JSON.parse(this.responseText);\n            promise.resolve(results); //成功时，调用resolve()方法\n        }\n    };\n\n    xhr.onerror = function (e) {\n        promise.reject(e); //失败时，调用reject()方法\n    };\n\n    xhr.send();\n    return promise;\n}\n</code></pre><p>从上面的代码示例中，我们可以看到，如果成功了，要调用<br>\n<code>Promise.resolve()</code> 方法，这样Promise对象会继续调用下一个 <code>then()</code>。如果出错了就调用 <code>Promise.reject()</code> 方法，这样就会忽略后面的 <code>then()</code> 直到 <code>catch()</code> 方法。</p><p>我们可以看到 <code>Promise.reject()</code> 就像是抛异常一样。这个编程模式让我们的代码组织方便了很多。</p><p>另外，多说一句，Promise还可以同时等待两个不同的异步方法。比如下面的代码所展示的方式：</p><pre><code class=\"language-JavaScript\">promise1 = doSomething();\npromise2 = doSomethingElse();\nPromise.when(promise1, promise2).then( function (result1, result2) {\n\t... //处理 result1 和 result2 的代码\n}, handleError);\n</code></pre><p>在ECMAScript 2017的标准中，我们可以使用<code>async</code>/<code>await</code>这两个关键字来取代Promise对象，这样可以让我们的代码更易读。</p><p>比如下面的代码示例：</p><pre><code class=\"language-JavaScript\">async function foo() {\n  try {\n    let result = await doSomething();\n    let newResult = await doSomethingElse(result);\n    let finalResult = await doThirdThing(newResult);\n    console.log(`Got the final result: ${finalResult}`);\n  } catch(error) {\n    failureCallback(error);\n  }\n}\n</code></pre><p>如果在函数定义之前使用了 <code>async</code> 关键字，就可以在函数内使用 <code>await</code>。 当在 <code>await</code> 某个 <code>Promise</code> 时，函数暂停执行，直至该  <code>Promise</code> 产生结果，并且暂停不会阻塞主线程。 如果 <code>Promise</code> resolve，则会返回值。 如果 <code>Promise</code> reject，则会抛出拒绝的值。</p><p>而我们的异步代码完全可以放在一个 <code>try - catch</code> 语句块内，在有语言支持了以后，我们又可以使用 <code>try - catch</code> 语句块了。</p><p>下面我们来看一下pipeline的代码。所谓pipeline就是把一串函数给编排起来，从而形成更为强大的功能。这个玩法是函数式编程中经常用到的方法。</p><p>比如，下面这个pipeline的代码（注意，其上使用了 <code>reduce()</code> 函数）：</p><pre><code class=\"language-JavaScript\">[func1, func2].reduce((p, f) =&gt; p.then(f), Promise.resolve());\n</code></pre><p>其等同于：</p><pre><code class=\"language-JavaScript\">Promise.resolve().then(func1).then(func2);\n</code></pre><p>我们可以抽象成：</p><pre><code class=\"language-JavaScript\">let applyAsync = (acc,val) =&gt; acc.then(val);\nlet composeAsync = (...funcs) =&gt; x =&gt; funcs.reduce(applyAsync, Promise.resolve(x));\n</code></pre><p>于是，可以这样使用：</p><pre><code class=\"language-JavaScript\">let transformData = composeAsync(func1, asyncFunc1, asyncFunc2, func2);\ntransformData(data);\n</code></pre><p>但是，在ECMAScript 2017的 <code>async</code>/<code>await</code> 语法糖下，这事儿就变得更简单了。</p><pre><code class=\"language-JavaScript\">for (let f of [func1, func2]) {\n  await f();\n}\n</code></pre><h2>Java异步编程的Promise模式</h2><p>在Java中，在JDK 1.8里也引入了类似JavaScript的玩法 —— <code>CompletableFuture</code>。这个类提供了大量的异步编程中Promise的各种方式。下面我列举几个。</p><p>链式处理：</p><pre><code class=\"language-Java\">CompletableFuture.supplyAsync(this::findReceiver)\n                 .thenApply(this::sendMsg)\n                 .thenAccept(this::notify);\n</code></pre><p>上面的这个链式处理和JavaScript中的<code>then()</code>方法很像，其中的<br>\n<code>supplyAsync()</code> 表示执行一个异步方法，而 <code>thenApply()</code> 表示执行成功后再串联另外一个异步方法，最后是 <code>thenAccept()</code> 来处理最终结果。</p><p>下面这个例子是要合并两个异步函数的结果：</p><pre><code class=\"language-Java\">String result = CompletableFuture.supplyAsync(() -&gt; {\n         return \"hello\";\n     }).thenCombine(CompletableFuture.supplyAsync(() -&gt; {\n         return \"world\";\n     }), (s1, s2) -&gt; s1 + \" \" + s2).join());\nSystem.out.println(result);\n\n</code></pre><p>接下来，我们再来看一下，Java这个类相关的异常处理：</p><pre><code class=\"language-Java\">CompletableFuture.supplyAsync(Integer::parseInt) //输入: \"ILLEGAL\"\n\t\t\t     .thenApply(r -&gt; r * 2 * Math.PI)\n\t\t\t     .thenApply(s -&gt; \"apply&gt;&gt; \" + s)\n\t\t\t     .exceptionally(ex -&gt; \"Error: \" + ex.getMessage());\n</code></pre><p>我们要注意到上面代码里的 <code>exceptionally()</code> 方法，这个和JavaScript Promise中的 <code>catch()</code> 方法相似。</p><p>运行上面的代码，会出现如下输出：</p><pre><code class=\"language-Java\">Error: java.lang.NumberFormatException: For input string: \"ILLEGAL\"\n</code></pre><p>也可以这样：</p><pre><code class=\"language-Java\">CompletableFuture.supplyAsync(Integer::parseInt) // 输入: \"ILLEGAL\"\n\t\t\t\t .thenApply(r -&gt; r * 2 * Math.PI)\n\t\t\t\t .thenApply(s -&gt; \"apply&gt;&gt; \" + s)\n\t\t\t\t .handle((result, ex) -&gt; {\n\t\t\t\t \tif (result != null) {\n\t\t\t\t \t\treturn result;\n\t\t\t\t \t} else {\n\t\t\t\t \t\treturn \"Error handling: \" + ex.getMessage();\n\t\t\t\t \t}\n\t\t\t\t });\n</code></pre><p>上面代码中，你可以看到，其使用了 <code>handle()</code> 方法来处理最终的结果，其中包含了异步函数中的错误处理。</p><h2>Go语言的Promise</h2><p>在Go语言中，如果你想实现一个简单的Promise模式，也是可以的。下面的代码纯属示例，只为说明问题。如果你想要更好的代码，可以上GitHub上搜一下Go语言Promise的相关代码库。</p><p>首先，先声明一个结构体。其中有三个成员：第一个 <code>wg</code> 用于多线程同步；第二个 <code>res</code> 用于存放执行结果；第三个 <code>err</code> 用于存放相关的错误。</p><pre><code class=\"language-Go\">type Promise struct {\n\twg  sync.WaitGroup\n\tres string\n\terr error\n}\n</code></pre><p>然后，定义一个初始函数，来初始化Promise对象。其中可以看到，需要把一个函数 <code>f()</code> 传进来，然后调用 <code>wg.Add(1)</code> 对waitGroup做加一操作，新开一个Goroutine通过异步去执行用户传入的函数 <code>f()</code> ，然后记录这个函数的成功或错误，并把waitGroup做减一操作。</p><pre><code class=\"language-Go\">func NewPromise(f func() (string, error)) *Promise {\n\tp := &amp;Promise{}\n\tp.wg.Add(1)\n\tgo func() {\n\t\tp.res, p.err = f()\n\t\tp.wg.Done()\n\t}()\n\treturn p\n}\n</code></pre><p>然后，我们需要定义Promise的Then方法。其中需要传入一个函数，以及一个错误处理的函数。并且调用 <code>wg.Wait()</code> 方法来阻塞（因为之前被<code>wg.Add(1)</code>)，一旦上一个方法被调用了 <code>wg.Done()</code>，这个Then方法就会被唤醒。</p><p>唤醒的第一件事是，检查一下之前的方法有没有错误。如果有，那么就调用错误处理函数。如果之前成功了，就把之前的结果以参数的方式传入到下一个函数中。</p><pre><code class=\"language-Go\">func (p *Promise) Then(r func(string), e func(error)) (*Promise){\n\tgo func() {\n\t\tp.wg.Wait()\n\t\tif p.err != nil {\n\t\t\te(p.err)\n\t\t\treturn \n\t\t}\n\t\tr(p.res)\n\t}()\n\treturn p\n}\n</code></pre><p>下面，我们定义一个用于测试的异步方法。这个方法很简单，就是在数数，然后，有一半的几率会出错。</p><pre><code class=\"language-Go\">func exampleTicker() (string, error) {\n\tfor i := 0; i &lt; 3; i++ {\n\t\tfmt.Println(i)\n\t\t&lt;-time.Tick(time.Second * 1)\n\t}\n\t\n\trand.Seed(time.Now().UTC().UnixNano())\n\tr:=rand.Intn(100)%2\n\tfmt.Println(r)\n\tif  r != 0 {\n\t\treturn \"hello, world\", nil\n\t} else {\n\t\treturn \"\", fmt.Errorf(\"error\")\n\t}\n}\n\n</code></pre><p>下面，我们来看看我们实现的Go语言Promise是怎么使用的。代码还是比较直观的，我就不做更多的解释了。</p><pre><code class=\"language-Go\">func main() {\n\tdoneChan := make(chan int)\n\t\n\tvar p = NewPromise(exampleTicker)\n\tp.Then(func(result string) { fmt.Println(result); doneChan &lt;- 1 }, \n\t\t\tfunc(err error) { fmt.Println(err); doneChan &lt;-1 })\n\t\t\t\n\t&lt;-doneChan\n}\n</code></pre><p>当然，如果你需要更好的Go语言Promise，可以到GitHub上找，上面好些代码都是实现得很不错的。上面的这个示例，实现得比较简陋，仅仅是为了说明问题。</p><h1>错误处理的最佳实践</h1><p>下面是我个人总结的几个错误处理的最佳实践。如果你知道更好的，请一定告诉我。</p><ul>\n<li>\n<p><strong>统一分类的错误字典</strong>。无论你是使用错误码还是异常捕捉，都需要认真并统一地做好错误的分类。最好是在一个地方定义相关的错误。比如，HTTP的4XX表示客户端有问题，5XX则表示服务端有问题。也就是说，你要建立一个错误字典。</p>\n</li>\n<li>\n<p><strong>同类错误的定义最好是可以扩展的</strong>。这一点非常重要，而对于这一点，通过面向对象的继承或是像Go语言那样的接口多态可以很好地做到。这样可以方便地重用已有的代码。</p>\n</li>\n<li>\n<p><strong>定义错误的严重程度</strong>。比如，Fatal表示重大错误，Error表示资源或需求得不到满足，Warning表示并不一定是个错误但还是需要引起注意，Info表示不是错误只是一个信息，Debug表示这是给内部开发人员用于调试程序的。</p>\n</li>\n<li>\n<p><strong>错误日志的输出最好使用错误码，而不是错误信息</strong>。打印错误日志的时候，应该使用统一的格式。但最好不要用错误信息，而应使用相应的错误码，错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件进行自动化监控，而不是要从错误信息中做语义分析。比如：HTTP的日志中就会有HTTP的返回码，如：<code>404</code>。但我更推荐使用像<code>PageNotFound</code>这样的标识，这样人和机器都很容易处理。</p>\n</li>\n<li>\n<p><strong>忽略错误最好有日志</strong>。不然会给维护带来很大的麻烦。</p>\n</li>\n<li>\n<p><strong>对于同一个地方不停的报错，最好不要都打到日志里</strong>。不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。</p>\n</li>\n<li>\n<p><strong>不要用错误处理逻辑来处理业务逻辑</strong>。也就是说，不要使用异常捕捉这样的方式来处理业务逻辑，而是应该用条件判断。如果一个逻辑控制可以用if - else清楚地表达，那就不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事情，而错误码则用来处理可能会发生的事。</p>\n</li>\n<li>\n<p><strong>对于同类的错误处理，用一样的模式</strong>。比如，对于<code>null</code>对象的错误，要么都用返回null，加上条件检查的模式，要么都用抛NullPointerException的方式处理。不要混用，这样有助于代码规范。</p>\n</li>\n<li>\n<p><strong>尽可能在错误发生的地方处理错误</strong>。因为这样会让调用者变得更简单。</p>\n</li>\n<li>\n<p><strong>向上尽可能地返回原始的错误</strong>。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。</p>\n</li>\n<li>\n<p><strong>处理错误时，总是要清理已分配的资源</strong>。这点非常关键，使用RAII技术，或是<code>try-catch-finally</code>，或是Go的defer都可以容易地做到。</p>\n</li>\n<li>\n<p><strong>不推荐在循环体里处理错误</strong>。这里说的是<code>try-catch</code>，绝大多数的情况你不需要这样做。最好把整个循环体外放在try语句块内，而在外面做catch。</p>\n</li>\n<li>\n<p><strong>不要把大量的代码都放在一个try语句块内</strong>。一个try语句块内的语句应该是完成一个简单单一的事情。</p>\n</li>\n<li>\n<p><strong>为你的错误定义提供清楚的文档以及每种错误的代码示例</strong>。如果你是做RESTful API方面的，使用Swagger会帮你很容易搞定这个事。</p>\n</li>\n<li>\n<p><strong>对于异步的方式，推荐使用Promise模式处理错误</strong>。对于这一点，JavaScript中有很好的实践。</p>\n</li>\n<li>\n<p><strong>对于分布式的系统，推荐使用APM相关的软件</strong>。尤其是使用Zipkin这样的服务调用跟踪的分析来关联错误。</p>\n</li>\n</ul><p>好了。关于程序中的错误处理，我主要总结了这些。如果你有更好的想法和经验，欢迎来评论区跟我交流。</p>","neighbors":{"left":{"article_title":"11 | 程序中的错误处理：错误返回码和异常捕捉","id":675},"right":{"article_title":"13 | 魔数 0x5f3759df","id":730}},"comments":[{"had_liked":false,"id":1505,"user_name":"杜小琨","can_delete":false,"product_type":"c1","uid":1023348,"ip_address":"","ucode":"FD577B19C381B7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/74/353e05c9.jpg","comment_is_top":false,"comment_ctime":1513302683,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"400945261211","product_id":100002201,"comment_content":"向上尽可能地返回原始的错误。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。<br><br>这一条如果要作为通用规则我觉得略有争议。我的观点是错误(异常)同样要考虑封装性。<br><br>需要考虑到这个错误原因是否应该上层感知。比如在在存储一张图片时，上层进行抽象业务逻辑的单元并不期望知道底层具体存储方式的存在，你用本地磁盘也好，hdfs也罢，这些原始错误暴露到业务流程中反而会让业务茫然不知所措。其实上层业务只需要知道错误发生(图片保存失败)即可，并不关心具体错误的原因。","like_count":94,"discussions":[{"author":{"id":1025067,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a4/2b/3ba9f64b.jpg","nickname":"Devin","note":"","ucode":"7BDCD517BD8DD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40961,"discussion_content":"赞成你的观点  文章中主要也是表达一个思维或者处理事情的方式  不是什么标准  结合实际工作环境和自己的思维  辩证性的阅读文章就好","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1572312666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/1b/e22c7e4f.jpg","nickname":"小叨","note":"","ucode":"714B405C2C33B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348918,"discussion_content":"结合实际业务场景来执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612775086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033425,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c4/d1/209abdd6.jpg","nickname":"小狼","note":"","ucode":"FEAC7864FC1D20","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319864,"discussion_content":"赞成这条，原始报错信息本层打印日志，提供跟踪，到业务层，还是封装一下比较友好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604148431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302570,"discussion_content":"赞成你的观点，不过文中的是指导意义的，没有特殊情况，还是按照文中的原则来比较好，减少二义性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598962878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293869,"discussion_content":"那这样，就得做好日志系统了，要方便排查","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595691369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":492,"user_name":"何小事儿","can_delete":false,"product_type":"c1","uid":1015752,"ip_address":"","ucode":"1EA5F37230B032","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/c8/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1510572553,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"117474689545","product_id":100002201,"comment_content":"老师，如何解决技术团队因需求不断，业务开发繁忙而导致的技术水平没有显著提高机会的问题？","like_count":27,"discussions":[{"author":{"id":1655449,"avatar":"","nickname":"Geek_116c6e","note":"","ucode":"FDF664459F65BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10119,"discussion_content":"换个公司","likes_number":26,"is_delete":false,"is_hidden":false,"ctime":1568265658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652895,"avatar":"https://static001.geekbang.org/account/avatar/00/19/38/9f/895353ab.jpg","nickname":"黄卫江","note":"","ucode":"0366942B81E7FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581505,"discussion_content":"不要和别人卷没有意义的事情","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658820171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2686529,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJh8zP773uF1WexZiboCxb9DOvwtEOa0icf1z5DhSFG3MyDwibE74T2iakFHIVNU4MJxx46oj4NtGoUGw/132","nickname":"宋伟超","note":"","ucode":"515CE461D8B876","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550996,"discussion_content":"业务繁忙，考虑能否能用技术手段解决，哪怕一部分也会有收货","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644841269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074196,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/14/c980c239.jpg","nickname":"chenssy","note":"","ucode":"CB5AF27229E2D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380064,"discussion_content":"自己空余时间学","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624324949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":465,"user_name":"起司猫","can_delete":false,"product_type":"c1","uid":1018670,"ip_address":"","ucode":"D86EF6FBA10EAC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/2e/df74d56a.jpg","comment_is_top":false,"comment_ctime":1510422287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104589637391","product_id":100002201,"comment_content":"很喜欢这种方式去分析问题，我都是单从java的角度去看待对于一个问题的处理。耗子叔的文章都是从不同语言的处理方式，然后得出一个稍微通用的解决，或者给出不同处理方式的优劣。看来有时间的确应该多学几门不同的语言，看问题的视野完全不一样啊☺️☺️为了看懂go的代码，我还特地去简单看了下go的语法。貌似耗子叔很喜欢go(⊙o⊙)哇哈哈哈","like_count":25},{"had_liked":false,"id":211622,"user_name":"像喜欢春天的熊一样喜欢你","can_delete":false,"product_type":"c1","uid":1811141,"ip_address":"","ucode":"EAE0B8A1B78D78","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a2/c5/22c9ea52.jpg","comment_is_top":false,"comment_ctime":1587989755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53127597307","product_id":100002201,"comment_content":"错误处理方式<br>1、统一分类的错误字典<br>2、同类错误的定义最好是可以扩展的<br>3、定义错误的严重程度。<br>4、错误日志的输出最好使用错误码，而不是错误信息<br>5、处理错误时，总是要清理已分配的资源<br>6、向上尽可能地返回原始的错误<br>7、忽略错误最好有日志<br>8、对于同一个地方不停的报错，最好不要都打到日志里<br>9、不要用错误处理逻辑来处理业务逻辑<br>10、对于同类的错误处理，用一样的模式<br>11、尽可能在错误发生的地方处理错误<br>12、向上尽可能地返回原始的错误<br>13、处理错误时，总是要清理已分配的资源<br>14、不推荐在循环体里处理错误<br>15、不要把大量的代码都放在一个 try 语句块内<br>16、为你的错误定义提供清楚的文档以及每种错误的代码示例<br>17、对于异步的方式，推荐使用 Promise 模式处理错误<br>18、对于分布式的系统，推荐使用 APM 相关的软件","like_count":13},{"had_liked":false,"id":448,"user_name":"莫名的冲动","can_delete":false,"product_type":"c1","uid":1007088,"ip_address":"","ucode":"633DFEC5200081","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/f0/0bdf6853.jpg","comment_is_top":false,"comment_ctime":1510295335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48754935591","product_id":100002201,"comment_content":"耗子叔，挺喜欢你的文章，篇篇都是经验之谈，而且面向的受众技术人员也是最广的，既不是那种网上一搜就能找到的技术罗列，也不是普通技术人员平常都难遇到的高深技术问题解析，角度和深度都刚刚好！赞！","like_count":11},{"had_liked":false,"id":656,"user_name":"左耳朵","can_delete":false,"product_type":"c1","uid":1001269,"ip_address":"","ucode":"8A4741D677702E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","comment_is_top":false,"comment_ctime":1511235144,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35870973512","product_id":100002201,"comment_content":"@ 何小事儿 后面的《时间管理》会有一些，敬请关注","like_count":8},{"had_liked":false,"id":65166,"user_name":"陈威严","can_delete":false,"product_type":"c1","uid":1026142,"ip_address":"","ucode":"BE5F6BC588CE17","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/5e/e5307db8.jpg","comment_is_top":false,"comment_ctime":1549083148,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"27318886924","product_id":100002201,"comment_content":"BUG：左右滑动代码块时，文章有时会退出详情页，进到文章列表页","like_count":6},{"had_liked":false,"id":174160,"user_name":"爱学习的大叔","can_delete":false,"product_type":"c1","uid":1085152,"ip_address":"","ucode":"91F9ABF1EC98D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/e0/847348b1.jpg","comment_is_top":false,"comment_ctime":1580038000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18759907184","product_id":100002201,"comment_content":"我们用的splunk和newrelic来监控，然后记录完整错误日志，再借助于splunk很方便","like_count":4},{"had_liked":false,"id":164030,"user_name":"aiueo","can_delete":false,"product_type":"c1","uid":1230099,"ip_address":"","ucode":"96100CD14AB501","user_header":"https://static001.geekbang.org/account/avatar/00/12/c5/13/99baef26.jpg","comment_is_top":false,"comment_ctime":1576848200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18756717384","product_id":100002201,"comment_content":"一个强大的系统，一定要有一套日志规范和处理错误机制。","like_count":4},{"had_liked":false,"id":5522,"user_name":"站住！我的马甲","can_delete":false,"product_type":"c1","uid":1083806,"ip_address":"","ucode":"A48DC1A08EAB2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/9e/6ba55c25.jpg","comment_is_top":false,"comment_ctime":1523454540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18703323724","product_id":100002201,"comment_content":"耗子叔，对于dubbo调用怎么能够更好的返回它的异常信息","like_count":4},{"had_liked":false,"id":2096,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1515831131,"is_pvip":false,"replies":[{"id":"422","content":"吐槽，可以啊。过两天写一篇","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1516066164,"ip_address":"","comment_id":2096,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18695700315","product_id":100002201,"comment_content":"语言大神，能否总结下您接触的各种语言的特色和缺陷，比如该语言的最佳适用场景，吐槽下该语言不好的地方，比如c++的RAII，javascript的promise就是他们的特色","like_count":4,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415640,"discussion_content":"吐槽，可以啊。过两天写一篇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1516066164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93443,"user_name":"黑猫大侠","can_delete":false,"product_type":"c1","uid":1145549,"ip_address":"","ucode":"B974494C725B83","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/cd/d26fb49e.jpg","comment_is_top":false,"comment_ctime":1557471732,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14442373620","product_id":100002201,"comment_content":"讲的很全面，都分析到了，说的基本都明白，就是从来没有人来总结过。这次，算是帮大家一起学习总结了，都在不断不断提炼中。代码规范真的很重要，code view也很重要，tra catch 这种模式 + 自定义返回状态码 + 还可以自己抛出异常。语言层面从js 中的promise切入，建议可以再去看看liao雪峰老师的promise的讲解，resolve 就是结果正常需要异步跑出来丢给then去执行的事情结果，reject就类似catch捕获到的东西。","like_count":3,"discussions":[{"author":{"id":1691964,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d1/3c/fe2e9ed1.jpg","nickname":"西街二叔","note":"","ucode":"C948A4AACE4882","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":125795,"discussion_content":"廖雪峰老师的js教程适合初步接触的人，如果稍微写过前端的，可以直接看阮一峰的es6手册","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578493723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13348,"user_name":"宝爷","can_delete":false,"product_type":"c1","uid":1153664,"ip_address":"","ucode":"DD517FA7EB59AB","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/80/2bf8d7fc.jpg","comment_is_top":false,"comment_ctime":1529548069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14414449957","product_id":100002201,"comment_content":"很好奇多个async&#47;await异步调用的try catch怎么实现的，我能想到的就是编译器自动在多个异步的代码处补充try catch，使用同一个异常处理","like_count":3},{"had_liked":false,"id":12675,"user_name":"刘強","can_delete":false,"product_type":"c1","uid":1035612,"ip_address":"","ucode":"B2E41BB894A727","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","comment_is_top":false,"comment_ctime":1528952528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14413854416","product_id":100002201,"comment_content":"骨灰级程序员，名副其实啊","like_count":3},{"had_liked":false,"id":655,"user_name":"左耳朵","can_delete":false,"product_type":"c1","uid":1001269,"ip_address":"","ucode":"8A4741D677702E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","comment_is_top":false,"comment_ctime":1511235069,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14396136957","product_id":100002201,"comment_content":"@ Chris 哪些地方看不懂？","like_count":3},{"had_liked":false,"id":224873,"user_name":"罗杰.菲の樂","can_delete":false,"product_type":"c1","uid":2016408,"ip_address":"","ucode":"63590706846EEA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","comment_is_top":false,"comment_ctime":1591580756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10181515348","product_id":100002201,"comment_content":"熟悉C#的朋友们，还可以看看这篇文章<br>https:&#47;&#47;devblogs.microsoft.com&#47;pfxteam&#47;the-nature-of-taskcompletionsourcetresult&#47;","like_count":2},{"had_liked":false,"id":224864,"user_name":"罗杰.菲の樂","can_delete":false,"product_type":"c1","uid":2016408,"ip_address":"","ucode":"63590706846EEA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","comment_is_top":false,"comment_ctime":1591579012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10181513604","product_id":100002201,"comment_content":"推荐一篇介绍 future and promise 的文章：<br><br>http:&#47;&#47;dist-prog-book.com&#47;chapter&#47;2&#47;futures.html","like_count":2},{"had_liked":false,"id":184211,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1583247278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173181870","product_id":100002201,"comment_content":"老师总结的实践经验，很有价值，很多可以直接拿来就用，更重要的是思维方式。<br>需要理解异步编程的特点，与同步编程有哪些差异，还是得多实践，多看别人的实现。<br>”对于同一个地方不停的报错，最好不要打到日志里。“就这一点，现在有多少程序还在哗哗哗打重复的日志😓 其实，遇到问题，如果无法忍受了，谁都能想到解决办法，懒惰+对自己没要求，导致代码质量差。<br>老师的做事方法非常值得借鉴，实践起来！","like_count":2},{"had_liked":false,"id":136067,"user_name":"记忆犹存","can_delete":false,"product_type":"c1","uid":1084441,"ip_address":"","ucode":"8ACCA77CF83F91","user_header":"https://static001.geekbang.org/account/avatar/00/10/8c/19/4e1989bf.jpg","comment_is_top":false,"comment_ctime":1569338604,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10159273196","product_id":100002201,"comment_content":"async&#47;await异步调用的try catch设计思路是参考了C#？还是C#参考了JavaScript？<br>总之这个语法糖蛮好用的","like_count":2,"discussions":[{"author":{"id":1389015,"avatar":"https://static001.geekbang.org/account/avatar/00/15/31/d7/22066e9e.jpg","nickname":"rh","note":"","ucode":"A815A0F9DA22CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246328,"discussion_content":"先有的C# ，后有的es7","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587737069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11321,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1528071575,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10118006167","product_id":100002201,"comment_content":"想不到一个错误处理能有这么多学问！  长见识了！ 果然程序是严谨的学问，需要用一生去学习！","like_count":2,"discussions":[{"author":{"id":1062425,"avatar":"https://static001.geekbang.org/account/avatar/00/10/36/19/036501c2.jpg","nickname":"悦来越好","note":"","ucode":"54B2225B4C9180","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530959,"discussion_content":"细节决定成败，处理细节问题，我们是认真的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637196770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":5438,"user_name":"浪子","can_delete":false,"product_type":"c1","uid":1019005,"ip_address":"","ucode":"B97378E2BBBDFE","user_header":"","comment_is_top":false,"comment_ctime":1523339389,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"10113273981","product_id":100002201,"comment_content":"开个脑洞，对于“不要用错误处理逻辑来处理业务逻辑”这条规范，在幂等处理中的用数据库唯一性约束解决是不是恰好是反例？","like_count":2,"discussions":[{"author":{"id":2033476,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/07/44/1df0e4cd.jpg","nickname":"平平淡淡财是真","note":"","ucode":"BC23C8A194DDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548595,"discussion_content":"只能说世事无绝对吧，得结合相应的业务场景","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643272032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019005,"avatar":"","nickname":"浪子","note":"","ucode":"B97378E2BBBDFE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2033476,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/07/44/1df0e4cd.jpg","nickname":"平平淡淡财是真","note":"","ucode":"BC23C8A194DDA3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552353,"discussion_content":"具体场景具体分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645428371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":548595,"ip_address":""},"score":552353,"extra":""}]}]},{"had_liked":false,"id":211982,"user_name":"蓝猫","can_delete":false,"product_type":"c1","uid":1128676,"ip_address":"","ucode":"A2E11FF854013C","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/e4/17ffa30b.jpg","comment_is_top":false,"comment_ctime":1588042652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883009948","product_id":100002201,"comment_content":"一直在用CompletableFuture类进行并发编程，但是不知道是Promise模式。了解这个模式，就能从更高层次掌握异步编程的知识，就能写出更好的异步代码。","like_count":1},{"had_liked":false,"id":32139,"user_name":"meijing0114","can_delete":false,"product_type":"c1","uid":1012416,"ip_address":"","ucode":"B349D33E2F3ECC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/c0/b09911a0.jpg","comment_is_top":false,"comment_ctime":1539430583,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5834397879","product_id":100002201,"comment_content":"耗子哥，java的completablefuture的例子中，抛出异常的那句，语法应该是CompletableFuture.supplyAsync(() -&gt; Integer.parseInt(&quot;ILLEGAL&quot;)) &#47;&#47; 输入: &quot;ILLEGAL&quot;<br>                .thenApply(r -&gt; r * 2 * Math.PI)<br>                .thenApply(s -&gt; &quot;apply&gt;&gt; &quot; + s)<br>                .handle((result, ex) -&gt; {<br>                    if (result != null) {<br>                        return result;<br>                    } else {<br>                        return &quot;Error handling: &quot; + ex.getMessage();<br>                    }<br>                });","like_count":1,"discussions":[{"author":{"id":1241368,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/18/136150bc.jpg","nickname":"Y","note":"","ucode":"D81BAC10ED305E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55941,"discussion_content":"哈哈  我也想说的 确实错了 上面还多了一个括号","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574415209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":4958,"user_name":"扫地僧的功夫梦","can_delete":false,"product_type":"c1","uid":1081053,"ip_address":"","ucode":"3B775474594BC3","user_header":"https://static001.geekbang.org/account/avatar/00/10/7e/dd/e4e6718a.jpg","comment_is_top":false,"comment_ctime":1522661658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5817628954","product_id":100002201,"comment_content":"实现Callable接口是不是算有返回呢？","like_count":1},{"had_liked":false,"id":2685,"user_name":"laofengfenglao","can_delete":false,"product_type":"c1","uid":1041736,"ip_address":"","ucode":"883D1B1BD985F5","user_header":"","comment_is_top":false,"comment_ctime":1518341588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5813308884","product_id":100002201,"comment_content":"耗子叔，请教您一个和异步沾点边的具体问题，最近我在用javaweb做一个图片上传接口，应用服务器是tomcat，用的是NIO，客户端用字符串的形式把base64串给服务端（大约100KB），服务端再传到swift容器，压测时发现瓶颈在读取字符串上。一般是怎么做可以实现这种客户端高效图片上传(我们现在并发500测试时时候吞吐率连每秒50都不到，平均响应时间10秒左右)","like_count":1},{"had_liked":false,"id":2009,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1014886,"ip_address":"","ucode":"E826A17A40B971","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/66/719292c3.jpg","comment_is_top":false,"comment_ctime":1515471714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5810439010","product_id":100002201,"comment_content":"有时候会写出在try块里面出现try块的情况，请问这种写法应该避免还是得看具体的业务？","like_count":1},{"had_liked":false,"id":1056,"user_name":"milley","can_delete":false,"product_type":"c1","uid":1001175,"ip_address":"","ucode":"8C95F693644CDE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/d7/00e99ebb.jpg","comment_is_top":false,"comment_ctime":1512054528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5807021824","product_id":100002201,"comment_content":"耗子叔举例讲解了不同语言不同用法，最终得出实践。虽然每种都是略懂，但是看完觉得很有启发。","like_count":1},{"had_liked":false,"id":437,"user_name":"Chris","can_delete":false,"product_type":"c1","uid":1011343,"ip_address":"","ucode":"6DE8E7DCCCEF0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/8f/9536ccff.jpg","comment_is_top":false,"comment_ctime":1510271492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5805238788","product_id":100002201,"comment_content":"老师好，你的文章很有质量，很好，不过我是属于初级，能否谈谈对于文章内可能看不懂的地方，自己应该如何解决这个问题？希望你能指导一下，谢谢！","like_count":1},{"had_liked":false,"id":354800,"user_name":"刘強","can_delete":false,"product_type":"c1","uid":1035612,"ip_address":"上海","ucode":"B2E41BB894A727","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","comment_is_top":false,"comment_ctime":1660794171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660794171","product_id":100002201,"comment_content":"有个代码多了个右括号，看来没人实际运行过","like_count":0},{"had_liked":false,"id":292663,"user_name":"Roc","can_delete":false,"product_type":"c1","uid":1630357,"ip_address":"","ucode":"A1C8A2CE78318B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUDO6GZGnOqYhaEUt06qiazKprjBgicxNvvxq8UBOM9ZjicRKhHLzmDhfLnmXh25ASKsEfShEcAKm9Q/132","comment_is_top":false,"comment_ctime":1620913910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620913910","product_id":100002201,"comment_content":"没有 C++ promise 吗？","like_count":0},{"had_liked":false,"id":278174,"user_name":"liujunjia","can_delete":false,"product_type":"c1","uid":1796228,"ip_address":"","ucode":"5389410CEE46ED","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ZU1jFjh9cibrN4wcJmft6hBu0fbJEDulibEDjuxDG9YzccKONTywHjCgtt7UiaJiaWHvsQWjT9ZCSrEkfYrfG9jKiag/132","comment_is_top":false,"comment_ctime":1612787629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612787629","product_id":100002201,"comment_content":"String result = CompletableFuture.supplyAsync(() -&gt; {<br>         return &quot;hello&quot;;<br>     }).thenCombine(CompletableFuture.supplyAsync(() -&gt; {<br>         return &quot;world&quot;;<br>     }), (s1, s2) -&gt; s1 + &quot; &quot; + s2).join());<br>System.out.println(result);<br><br>这段代码倒数第二行多写了一个括号。<br>这么久的文章了，就没有一个人指出这个小问题吗？","like_count":0},{"had_liked":false,"id":261764,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1203115,"ip_address":"","ucode":"16DC5BD899CCE5","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/ab/aac30656.jpg","comment_is_top":false,"comment_ctime":1605516171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605516171","product_id":100002201,"comment_content":"对于同一个地方不停的报错，最好不要都打到日志里<br>关于这一条，我们在实践过程中也遇到了，采用的是把这一类错误单独到一个集合里，不至于淹没其他的错误消息。","like_count":0},{"had_liked":false,"id":247041,"user_name":"bigzuo","can_delete":false,"product_type":"c1","uid":1224554,"ip_address":"","ucode":"448C258D31A8A6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/RQdib68D7dsoFlYXOweiaPqLrcyn2jD6DCGnz8nc2VFmhmX0bpGTeSrVM5M9Qs7ibIInAmt5MeLcpcNja5YjyZCIg/132","comment_is_top":false,"comment_ctime":1599567222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599567222","product_id":100002201,"comment_content":"我对异步编程只有理论，缺少实践，类似于纸上谈兵，这个是自己的硬伤。","like_count":0},{"had_liked":false,"id":244427,"user_name":"静心","can_delete":false,"product_type":"c1","uid":1335457,"ip_address":"","ucode":"EB264FA6519FDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","comment_is_top":false,"comment_ctime":1598513061,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1598513061","product_id":100002201,"comment_content":" promise.resolve(results); <br><br>可以这么使用吗？以前从来没这么使用过","like_count":0},{"had_liked":false,"id":211143,"user_name":"浮生醉","can_delete":false,"product_type":"c1","uid":1783354,"ip_address":"","ucode":"7549E41BD65511","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/3a/335db90a.jpg","comment_is_top":false,"comment_ctime":1587903198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587903198","product_id":100002201,"comment_content":"总结的很好，而且从各种不同的语言都分析了下错误的处理方式，就是对Go和C语言没有涉及，看起来有点不太明白","like_count":0},{"had_liked":false,"id":210676,"user_name":"BeginYan","can_delete":false,"product_type":"c1","uid":1082843,"ip_address":"","ucode":"BB06C4712E6383","user_header":"https://static001.geekbang.org/account/avatar/00/10/85/db/f978ddcd.jpg","comment_is_top":false,"comment_ctime":1587805922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587805922","product_id":100002201,"comment_content":"之前曾经搞过一段时间的APM，但是因为主要是想追踪C++函数级别的调用链，试了很多方法都没能在不侵入代码的前提下实时获取调用链路，最终放弃了","like_count":0},{"had_liked":false,"id":210630,"user_name":"蓝猫","can_delete":false,"product_type":"c1","uid":1128676,"ip_address":"","ucode":"A2E11FF854013C","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/e4/17ffa30b.jpg","comment_is_top":false,"comment_ctime":1587799697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587799697","product_id":100002201,"comment_content":"向上尽可能地返回原始的错误，这条最近实践的初衷是什么？我能想到的原因是方便排查问题，可以从原始错误信息中了解最真实的错误原因","like_count":0},{"had_liked":false,"id":210629,"user_name":"蓝猫","can_delete":false,"product_type":"c1","uid":1128676,"ip_address":"","ucode":"A2E11FF854013C","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/e4/17ffa30b.jpg","comment_is_top":false,"comment_ctime":1587799482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587799482","product_id":100002201,"comment_content":"定义错误的严重程度，这个要如何定义，通过定义不同的异常类吗？","like_count":0},{"had_liked":false,"id":210396,"user_name":"Geek_7b1383","can_delete":false,"product_type":"c1","uid":1310716,"ip_address":"","ucode":"A2F03709F77122","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLndPicaib35sSOgGib8iafFBq8B0hoBO3Bfp3QViblYQ669lRFjPD1RSX2rDibmElID00l5oWokhuZBJnw/132","comment_is_top":false,"comment_ctime":1587736885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587736885","product_id":100002201,"comment_content":"1）忽略错误最好有日志。不然会给维护带来很大的麻烦。<br>2）对于同一个地方不停的报错，最好不要都打到日志里。不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。<br>这两种实践过程中体会很深，有个老系统批量中的任务报错，日志有记录初始化失败，打了好几G，没一个有效信息，对于排障不明显，其他人配合排障很困难，通读代码等一点点排障才解决，不太可取","like_count":0},{"had_liked":false,"id":209957,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1587640192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587640192","product_id":100002201,"comment_content":"我也很喜欢 JavaScript 的 Promise &#47; async &amp; await，同时也赞叹 Java 中 CompletableFuture 类库<br><br>都是优雅的实现，再加上 JavaScript 的箭头函数和 Java 中的 lambda，让代码更加简洁","like_count":0},{"had_liked":false,"id":209698,"user_name":"Geek_6b80e0","can_delete":false,"product_type":"c1","uid":1489045,"ip_address":"","ucode":"37A2B4DBAFE2B4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLkpGLibHdMIcdiazlpF6JOL5ZUz13yuxWBFeZrlsbaiaDxJictNslF9ic87lLtZic3DsHEXxfmTIHNwYA/132","comment_is_top":false,"comment_ctime":1587602053,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587602053","product_id":100002201,"comment_content":"规划好错误信息捕获和处理，对后续排查问题能起到很大作用","like_count":0},{"had_liked":false,"id":207996,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1587232730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587232730","product_id":100002201,"comment_content":"再回去细读前一篇","like_count":0},{"had_liked":false,"id":198790,"user_name":"四道杠的红领巾","can_delete":false,"product_type":"c1","uid":1213394,"ip_address":"","ucode":"F17257066F85EC","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/d2/1758ce61.jpg","comment_is_top":false,"comment_ctime":1585468364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585468364","product_id":100002201,"comment_content":"这篇文章是干货，先mark慢慢品","like_count":0},{"had_liked":false,"id":193920,"user_name":"刘溟","can_delete":false,"product_type":"c1","uid":1395962,"ip_address":"","ucode":"600C77C4D24B06","user_header":"","comment_is_top":false,"comment_ctime":1584982811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584982811","product_id":100002201,"comment_content":"感觉cps和monad这些很高端的词汇，在这里用上了。回调就是传递continuation，then则有点类似monad的bind操作","like_count":0},{"had_liked":false,"id":193141,"user_name":"Archy","can_delete":false,"product_type":"c1","uid":1357305,"ip_address":"","ucode":"1BD1E2B2B7DE3A","user_header":"https://static001.geekbang.org/account/avatar/00/14/b5/f9/da7d80c7.jpg","comment_is_top":false,"comment_ctime":1584884694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584884694","product_id":100002201,"comment_content":"输出错误日志，错误用错误码指；不在循环体里处理错误","like_count":0},{"had_liked":false,"id":172088,"user_name":"文刂 氵共 超","can_delete":false,"product_type":"c1","uid":1282813,"ip_address":"","ucode":"C2CE1512D23012","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/fd/6b0e58fe.jpg","comment_is_top":false,"comment_ctime":1579086373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579086373","product_id":100002201,"comment_content":"坚持学习，学习笔记 https:&#47;&#47;mubu.com&#47;colla&#47;30PTQLPBS20","like_count":0},{"had_liked":false,"id":164305,"user_name":"kuzan","can_delete":false,"product_type":"c1","uid":1006773,"ip_address":"","ucode":"4A6CCE0629D4AE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/b5/0737c1f2.jpg","comment_is_top":false,"comment_ctime":1576932528,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1576932528","product_id":100002201,"comment_content":"golang 需要promise么？","like_count":0,"discussions":[{"author":{"id":1393863,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqMiaIuXLFmXvVlnP9Do2icudO3JV6l5ueicWYYFhZb2ftT9XSKHFHJWa33XLnUKlCSs0JhvI7omF8Mg/132","nickname":"wzhan366","note":"","ucode":"AF59C23A5C8E9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227338,"discussion_content":" 为啥不用？如果不用，又有什么好的处理方式么？ 直接用channel？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586484709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1006773,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/b5/0737c1f2.jpg","nickname":"kuzan","note":"","ucode":"4A6CCE0629D4AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1393863,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqMiaIuXLFmXvVlnP9Do2icudO3JV6l5ueicWYYFhZb2ftT9XSKHFHJWa33XLnUKlCSs0JhvI7omF8Mg/132","nickname":"wzhan366","note":"","ucode":"AF59C23A5C8E9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235180,"discussion_content":"\n个人理解直接基于协程做异步结果编排即可\n这块没想透彻，欢迎赐教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587026491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227338,"ip_address":""},"score":235180,"extra":""}]}]},{"had_liked":false,"id":99173,"user_name":"edisonhuang","can_delete":false,"product_type":"c1","uid":1530167,"ip_address":"","ucode":"BB2F639A779F96","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg","comment_is_top":false,"comment_ctime":1559174765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559174765","product_id":100002201,"comment_content":"错误处理需要我们为错误定义统一的错误状态字典，错误的基类最好是易于扩展的，为错误定义不同的等级，记录好错误日志，不要轻易忽略错误，尽可能在错误发生的地方处理错误，原样返回错误信息。对于异步编程，推荐使用Promise模式处理错误。","like_count":0},{"had_liked":false,"id":80578,"user_name":"西关八号","can_delete":false,"product_type":"c1","uid":1206406,"ip_address":"","ucode":"28016BF8391F97","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/86/3ef20498.jpg","comment_is_top":false,"comment_ctime":1553684349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553684349","product_id":100002201,"comment_content":"错误里面里面的大学问，学习了","like_count":0},{"had_liked":false,"id":38434,"user_name":"Geek_fb3db2","can_delete":false,"product_type":"c1","uid":1218254,"ip_address":"","ucode":"8089B8311B6C80","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/ce/8c3bdbe5.jpg","comment_is_top":false,"comment_ctime":1542034808,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1542034808","product_id":100002201,"comment_content":"从不同语言中总结异常的处理方式 结合现在项目来看 确实对于异常的处理需要改进很多 ","like_count":0},{"had_liked":false,"id":14853,"user_name":"渔夫","can_delete":false,"product_type":"c1","uid":1019289,"ip_address":"","ucode":"6BF08FD8923E45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/99/f886543d.jpg","comment_is_top":false,"comment_ctime":1530705265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530705265","product_id":100002201,"comment_content":"异常应分层分类，需要识别分层边界和领域边界","like_count":0}]}