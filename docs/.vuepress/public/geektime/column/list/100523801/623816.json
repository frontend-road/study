{"id":623816,"title":"02｜Modules（中）：解决编译性能和符号隔离的银弹","content":"<p>你好，我是卢誉声。</p><p>上一讲我们聊到开发者为了业务逻辑划分和代码复用，需要模块化代码。但随着现代C++编程语言的演进，现代C++项目的规模越来越大，即便是最佳实践方法，在不牺牲编译性能的情况下，也没有完全解决<strong>符号可见性</strong>和<strong>符号名称隔离</strong>的问题。</p><p>如果从技术的本质来探究“模块”这个概念，其实<strong>模块主要解决的就是符号的可见性问题</strong>。而控制符号可见性的灵活程度和粒度，决定了一门编程语言能否很好地支持现代化、标准化和模块化的程序开发。一般，模块技术需要实现以下几个必要特性。</p><ul>\n<li>每个模块使用模块名称进行标识。</li>\n<li>模块可以不断划分为更多的子模块，便于大规模代码组织。</li>\n<li>模块内部符号仅对模块内部可见，对模块外部不可见。</li>\n<li>模块可以定义外部接口，外部接口中的符号对模块外部可见。</li>\n<li>模块可以相互引用，并调用被引用模块的外部接口（也就是符号）。</li>\n</ul><p>我们在<a href=\"https://time.geekbang.org/column/article/623274\">上一讲</a>中仔细讲解了include头文件机制，虽然它在一定程度上解决了同一组件内相同符号定义冲突的符号可见性问题，但头文件代码这种技术方式实现非常“低级”，仍无法避免两个编译单元的重复符号的符号名称隔离问题。我们迫切需要一种更加现代的、为未来编程场景提供完备支持的解决方案。</p><p>而今天的主角——C++ Modules，在满足上述特性的基础上，针对C++的特性将提供一种解决符号隔离问题的全新思路。我们一起进入今天的学习，看看如何使用C++ Modules解决旧世界的问题？</p><!-- [[[read_end]]] --><p>课程配套代码点击<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>获取。</p><h2>基本用法</h2><p>首先我们了解一下什么是C++ Modules。</p><p>作为一种共享符号声明与定义的技术，C++ Modules目的是替代头文件的一些使用场景，也就是现代编程的模块化场景。前面说过，模块解决的是模块之间符号的可见性控制问题，不解决模块之间的符号名称隔离问题，因此C++ Modules与C++标准中的命名空间（namespace）在设计上是正交的，不会产生冲突。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/a6/269f36c189fb55db8b3a67e03bb24ca6.jpg?wh=1900x1410\" alt=\"\"></p><p>与其他现代化编程语言不同，C++包含一个预处理阶段来处理预处理指令，然后生成每个编译单元的最终代码。因此C++ Modules的设计必须考虑如何处理预处理指令，并在预处理阶段支持C++ Modules。目前，C++ Modules支持通过import导入C++的头文件并使用头文件中定义的预处理指令。</p><p>总之，在现代化的编程模式与编程习惯下，如果我们采用了C++ Modules，基本可以完全抛弃#include，而且大部分场景下，在不对遗留代码进行更改的情况下仍可以使用过去的头文件。</p><p>了解了基本概念，我们接着来看C++ Modules的具体细节，包括模块声明、导入导出的方法、全局和私有模块的划分、模块分区以及所有权问题。这些细节是掌握C++ Modules的关键，当然了也不是什么难题，毕竟对于核心语言特性的变更和设计哲学来说，“易用”是首要目标，也是重中之重。<br>\n<img src=\"https://static001.geekbang.org/resource/image/2f/07/2fe553ba7ac28dc8221a1d58cf4c5707.jpg?wh=1990x1286\" alt=\"\"></p><p>从每一个设定的引入中，你将看到如何通过C++ Modules提供的新特性方便地声明模块、引用模块、使用模块提供的接口，并更好地组织模块代码，学会使用新的特性替代传统的模块管理方式，编写更易于维护的代码。</p><h4>模块声明</h4><p>在引入C++ Modules后，编译单元会被分为“模块单元”和“普通单元”两种类型。普通单元除了可以有限引用“模块”以外，和传统的C++编译单元没有任何区别，这也实现了对历史代码的向下兼容。只有“模块单元”才能用于定义模块并实现模块中的符号。</p><p><strong>如果想要将编译单元设置成“模块单元”，需要在编译单元的源代码头部</strong>（除了包含全局模块片段的情况下）<strong>采用module关键字</strong>，比如我们现在如果要声明一个“模块单元”属于模块helloworld，需要采用如下方式声明。</p><pre><code class=\"language-c++\">module helloworld;\n</code></pre><p>“模块单元”会被分为“模块接口单元（Module Interface Unit）”和“模块实现单元（Module Implementation Unit）”。</p><ul>\n<li>模块接口单元用于定义模块的对外接口，也就是控制哪些符号对外可见，作用类似于传统方案中的头文件。</li>\n<li>模块实现单元用于实现模块接口模块中的符号，作用类似于传统方案中与头文件配套的编译单元。</li>\n</ul><p>模块单元默认是模块实现单元，如果想要将模块单元定义成模块接口单元，需要在module前添加export关键字。</p><pre><code class=\"language-c++\">export module helloworld;\n</code></pre><p>在构建过程中多个编译单元声明为同名的模块单元，只要同名，这些编译单元的符号也就内部相互可见，也就是<strong>模块声明相同的编译单元都属于同一个模块</strong>。</p><p>这里有个例外需要注意，整个项目中，每个模块只能有一个模块接口单元，换言之，模块接口单元的模块名称是不能重复的，否则就会出错。</p><p><img src=\"https://static001.geekbang.org/resource/image/0f/f1/0ffcf9e386a2af1e61byy57d414f9ef1.jpg?wh=2900x1590\" alt=\"\"></p><h4>导出声明</h4><p>与传统的编译单元不同，一个模块单元中定义的符号对模块外部默认是不可见的。比如下面这段代码中，我们定义的private_hello函数就是对模块外部不可见的。</p><pre><code class=\"language-c++\">export module helloworld;\nvoid private_hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n}\n</code></pre><p>如果想要定义对模块外部可见的函数，我们需要使用export关键字，比如下面这段代码中我们定义了一个对模块外部可见的hello函数。</p><pre><code class=\"language-c++\">export module helloworld;\nvoid private_hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n}\n\nexport void hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n}\n</code></pre><p>前面说过，C++ Modules与传统的命名空间（namespace）是保持正交设计的。因此我们可以在模块单元中导出命名空间。</p><pre><code class=\"language-c++\">export module helloworld;\n\nexport namespace hname {\n&nbsp;&nbsp;&nbsp; int32_t getNumber() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 10;\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>这里定义了一个对外可见的命名空间hname，包含一个getNumber函数。我们就可以在其他模块通过hname::getNumber调用这个函数，也就是hname::getNumber这个符号对外部可见。</p><p>不过你需要知道的是，这样其实让该namespace中包含的所有符号对外可见了，因此也可以这样编码。</p><pre><code class=\"language-c++\">export module helloworld;\n&nbsp;\nnamespace hname {\n&nbsp;&nbsp;&nbsp; export int32_t getNumber() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 10;\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>这和前面的代码是等价的，只是如果namespace不标注export，我们可以在namespace内部通过export关键字更细粒度地标记符号的对外可见性，因此<strong>在编码实践上一般不建议直接在namespace上使用export</strong>，当然特定场景除外（比如定义一个namespace作为对外接口）。</p><h4>导入模块</h4><p>我们可以在其他编译单元中通过import关键字导入模块，而且，无论是模块单元还是普通单元都可以导入模块，比如编写main.cpp，使用了前面helloworld模块中定义的外部符号。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n&nbsp;\nimport helloworld;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; hello();\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello \" &lt;&lt; hname::getNumber() &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>关键字import导入模块，实际其实是让被引用的模块中的符号对本编译单元可见，也就是将被导入模块中的符号直接暴露在本编译单元中，这就类似于传统C++技术中的using namespace。</p><p>我们说过C++ Modules并不解决符号名称隔离问题，也就是如果通过import导入了一个模块，并且被导入模块中有符号与本编译单元可见符号的名称冲突了，还是会产生命名空间污染。如果想避免污染，就需要结合使用namespace进行编码。</p><p><strong>需要注意的是，通过import导入的模块符号只在本编译单元可见</strong>，其他的编译单元是无法使用被导入的模块符号的。同时，如果模块A通过import导入了模块B的符号，然后模块B通过import导入了模块C的符号，模块A中是无法直接使用模块C的符号的。毕竟模块系统就是为了严格规范符号可见性。</p><p>如果想要把通过import导入的符号对外导出，就需要在import前加上export来将导入的模块中的符号全部对外导出。比如：</p><pre><code class=\"language-c++\">export import bye;\n</code></pre><p>就可以将bye模块的所有符号再对外导出。</p><p>接下来我们看看怎样直接在main.cpp中使用函数goodbye()。我们首先定义一个模块bye，编写bye.cpp。</p><pre><code class=\"language-c++\">export module bye;\n&nbsp;\nimport &lt;iostream&gt;;\n&nbsp;\nexport void goodbye() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Goodbye\" &lt;&lt; std::endl;\n}\n</code></pre><p>然后修改helloworld.cpp的定义。</p><pre><code class=\"language-c++\">export module helloworld;\nexport import bye;\n\nvoid private_hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n}\n\nexport void hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n}\n</code></pre><p>最后，编写main.cpp。</p><pre><code class=\"language-c++\">import helloworld;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; hello();\n&nbsp;&nbsp;&nbsp; goodbye();\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>由于模块helloworld导出了bye模块的符号，我们可以在main.cpp中直接使用bye模块中的函数goodbye()。</p><h4>导入头文件</h4><p>既然普通单元和模块单元都可以通过import导入模块，那么普通单元和模块单元的import的区别是什么呢？</p><p>事实上，最大的区别就是模块单元无法使用#include引入头文件，必须要使用import导入头文件。比如说，我们定义一个头文件h1.h。</p><pre><code class=\"language-c++\">#pragma once\n&nbsp;\n#define H1 (1)\n</code></pre><p>然后在helloworld.cpp中通过import引入这个头文件。</p><pre><code class=\"language-c++\">export module helloworld;\n&nbsp;\nimport &lt;iostream&gt;;\nimport \"h1.h\";\n&nbsp;\nexport void hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello2 \" &lt;&lt; H1 &lt;&lt; std::endl;\n}\n</code></pre><p>我们就可以在helloworld.cpp中使用h1.h中定义的H1这个符号。<br>\n&nbsp;<br>\n发现了吗？通过import导入头文件的兼容性是经过精心设计的，从设计上来说，你依然可以认为import头文件是简单的文本操作，也就是将头文件的文本复制到编译单元中。</p><p>所以我们可以利用头文件的这种特性。比如编写一个h2.h。</p><pre><code class=\"language-c++\">#pragma once\n&nbsp;\n#define H2 (H1 + 1)\n</code></pre><p>然后修改一下helloworld.cpp，通过import导入这个新的头文件。</p><pre><code class=\"language-c++\">export module helloworld;\n&nbsp;\nimport &lt;iostream&gt;;\nimport \"h1.h\";\nimport \"h2.h\";\n&nbsp;\nexport void hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello2 \" &lt;&lt; H1 &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello2 \" &lt;&lt; H2 &lt;&lt; std::endl;\n}\n</code></pre><p>可以看到，这里引用h2.h中的H2，而h2.h中也使用了h1.h中的H1。以此得知，通过import导入头文件依然可以实现原本预处理指令的效果，这是因为C++ Modules也规定了在预处理阶段对import的处理要求，所以import在预处理和编译阶段都会有对应的效果。</p><p>虽然我们可以通过import来导入头文件，但是import和以前的#include还是存在区别的。</p><p>区别就是，<strong>通过import导入头文件的编译单元定义的预处理宏，是无法被import导入的文件访问的</strong>，比如这样的代码就会出现编译错误。</p><pre><code class=\"language-c++\">export module helloworld;\n&nbsp;\nimport &lt;iostream&gt;;\n#define H1 (1)\nimport \"h2.h\";\n&nbsp;\nexport void hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello2 \" &lt;&lt; H1 &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello2 \" &lt;&lt; H2 &lt;&lt; std::endl;\n}\n</code></pre><p>这是因为H1是在编译单元中定义的，而编译单元本身是一个模块单元，因此h2.h中无法访问到这个编译单元中定义的H1。</p><p>但是在传统的C/C++代码中，很多头文件经常会要求用户通过定义预定义宏进行配置，比如这段代码就会影响头文件的行为。</p><pre><code class=\"language-c++\">#define _POSIX_C_SOURCE 200809L\n#include &lt;stdlib.h&gt;\n</code></pre><p>那么，在新的模块单元中我们要如何实现这种特性呢？这就需要“模块片段”来帮忙。<br>\n<img src=\"https://static001.geekbang.org/resource/image/c7/c6/c70392987bc65c5d1ff964c3ce3f59c6.jpg?wh=2560x1348\" alt=\"\"></p><h2>模块片段</h2><p>模块片段又可以分为全局模块片段和私有模块片段。对于前面的问题，我们需要的是全局模块片段。</p><h4>全局模块片段</h4><p>全局模块片段（global module fragment）是实现向下兼容性的关键特性，当无法通过import导入传统的头文件实现#include指令的效果时，就要使用全局模块片段来导入头文件。</p><p>全局模块片段是一个模块单元的一部分，需要定义在模块单元的模块声明之前，声明语法如下。</p><pre><code class=\"language-c++\">module;\n预处理指令\n模块声明\n</code></pre><p>如果需要在模块单元中定义全局模块片段，文件必须以modules;声明开头，表示这是一个模块单元的全局模块片段；接着就是全局模块片段的定义，内容只能包含预处理指令；编写完模块片段定义之后需要加上模块单元的模块声明，也就是export module或module声明。</p><p>比如我们可以修改一下前文中有问题的helloworld.cpp，解决无法通过import导入头文件的问题。</p><pre><code class=\"language-c++\">module;\n&nbsp;\n#define H1 (1)\n#include \"h2.h\"\n&nbsp;\nexport module helloworld;\n&nbsp;\nimport &lt;iostream&gt;;\n&nbsp;\nexport void hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello2 \" &lt;&lt; H1 &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello2 \" &lt;&lt; H2 &lt;&lt; std::endl;\n}\n</code></pre><p>在全局模块片段中先定义了宏H1，然后再通过#include而非import包含头文件h2.h，这样h2.h就会以传统的预处理模式被包含在本模块单元内，这样我们就可以在模块单元中使用h2.h中的宏H2了。</p><h4>私有模块片段</h4><p>除了可以在模块单元的模块定义前添加全局模块片段，在接口模块单元的模块单元接口定义后，我们还可以定义私有模块片段作为模块的内部实现。</p><p>如果我们想要编写一个单文件模块，就可以采用这个特性。在模块接口单元中定义“接口”部分和“实现”部分，也就是在模块单元定义中编写接口，在私有模块片段内编写实现。我们修改一下之前的helloworld.cpp，在代码尾部添加私有模块片段，如下所示。</p><pre><code class=\"language-c++\">export module helloworld;\n&nbsp;\nimport &lt;iostream&gt;;\n&nbsp;\nexport void hello()；\n&nbsp;\nmodule : private;\n&nbsp;\nvoid hiddenHello();\n&nbsp;\nvoid hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello2 \" &lt;&lt; H1 &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello2 \" &lt;&lt; H2 &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; hiddenHello();\n}\n&nbsp;\nvoid hiddenHello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hidden Hello!\" &lt;&lt; std::endl;\n}\n</code></pre><p>私有代码片段需要使用module : private标识，然后定义我们需要实现的代码。在私有代码片段中定义了函数hello()和hiddenHello()，并在模块单元代码中通过export导出这个符号。这里由于函数hiddenHello()定义在了函数hello()之后，因此需要在hello之前前置声明。</p><p>所以module : private就是提供了一种在单文件模块中标记接口部分和实现部分的手段，由于我们可能更倾向于使用模块接口单元和模块实现单元来组织模块，因此这种方式可能是使用较少的。<br>\n<img src=\"https://static001.geekbang.org/resource/image/c3/4a/c3a3cb1f517828b1887a2ba101d31e4a.jpg?wh=3500x2002\" alt=\"\"></p><h2>模块分区</h2><p>模块的一个关键特性是可以划分为更多的子模块。在C++ Modules中，子模块主要有两种实现方式：通过模块名称进行区分、利用模块分区特性。</p><p>先看第一个方式，通过模块名称进行区分。</p><p>C++ Modules的模块名称除了可以使用C++标识符字符以外，还可以使用“.”这个符号，比如有一个名为utils的模块，如果需要定义一个utils中的图像处理子模块image，可以声明一个名为utils.image的模块，将其作为utils的子模块。这种子模块的模块名组织方式和其他现代编程语言更类似，所以使用起来也很简单易懂。</p><p>但这种方式存在一个问题：C++中并没有提供标注两个模块隶属关系的方法，所以子模块和父模块之间其实没有什么隶属关系，本质上通过这种方法进行模块分层，只是一种基于名称的约定，父模块使用子模块和其他模块使用子模块没区别。</p><p>因此有了第二种方式，C++ Modules提供“模块分区”作为一种划分子模块的方法。</p><p>模块分区的声明方法是将一个模块单元的名称命名为“模块名:分区名”，如果我们需要定义一个helloworld的分区B，可以创建一个名为helloworld_b.cpp的文件，并在文件开头使用如下方式声明模块。</p><pre><code class=\"language-c++\">module helloworld:B;\n</code></pre><p>然后就可以像其他的模块单元一样定义模块的内容，比如定义一个函数helloworldB，完整代码如下所示。</p><pre><code class=\"language-c++\">export module helloworld:B;\n\nimport &lt;iostream&gt;;\n\nvoid helloworldB() {\n    std::cout &lt;&lt; \"HelloworldB\" &lt;&lt; std::endl;\n}\n</code></pre><p>模块分区单元也可以分为“模块分区接口单元”和“模块分区实现单元”，模块分区接口单元也就是在模块声明前追加export关键词。比如我们定义helloworld的分区A，文件名是helloworld_a.cpp。</p><pre><code class=\"language-c++\">export module helloworld:A;\n\nexport void helloworldA();\n \nimport &lt;iostream&gt;;\n\nvoid helloworldA() {\n    std::cout &lt;&lt; \"HelloworldA\" &lt;&lt; std::endl;\n}\n</code></pre><p>接下来就可以在helloworld模块中通过import导入这两个分区，并调用这两个函数。</p><pre><code class=\"language-c++\">export module helloworld;\n&nbsp;\nimport &lt;iostream&gt;;\n&nbsp;\nexport import :A;\nimport :B;\n&nbsp;\nvoid hello() {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; helloworldA();\n&nbsp;&nbsp;&nbsp; helloworldB();\n}\n</code></pre><p>在模块中通过import导入分区的时候，需要直接指定分区名称，不需要指定模块名称，这样就可以导入本模块的不同分区。分区导入到本模块后，分区内部的符号也就对整个模块可见了，因此，分区内部是否将符号标识为export，并不影响分区内部符号对模块内部的可见性。</p><p>那么模块分区内部的export有什么作用呢？</p><p>作用是允许“模块接口单元”通过export，来控制是否将一个分区内导入的符号导出给其他模块，有两种方法。</p><p>1.在主模块的模块接口单元通过export import导入分区，分区内标识为export的符号就对其他模块可见。<br>\n2.在主模块中通过import导入分区，并在主模块的模块接口单元中通过export声明需要导出的符号。</p><p>第一种方式比较简单方便，第二种方式的控制粒度比较细，各有优劣，需要我们在实际应用中根据实际情况选择处理方案。</p><p>使用模块分区后有一个很重要的特点，<strong>模块分区单元中的符号，必须通过主模块的接口单元控制对外可见性</strong>，因为一个模块无法通过import导入一个模块的分区。这就为模块的开发者提供了控制子模块符号可见性的有效工具。</p><h2>模块所有权</h2><p>我们在使用模块的时候需要注意符号声明的所有权问题，这个会影响两个方面，一个是符号的实现位置，另一个是符号的“链接性（linkage）”。</p><p>在模块单元的模块声明中出现的符号声明，属于（attached）这个模块。所有属于一个模块的符号声明，必须在这个模块的编译单元内实现，我们不能在模块之外的编译单元中实现这些符号。</p><p>模块所有权也会引发符号的链接性发生变化。在传统的C++中链接性分为无链接性（no linkage）、内部链接性（internal linkage）、外部链接性（external linkage）。</p><ul>\n<li>无链接性的符号只能在其声明作用域中使用。</li>\n<li>内部链接性的符号可以在声明的编译单元内使用。</li>\n<li>外部链接性的符号可以在其他的编译单元使用。<br>\n<img src=\"https://static001.geekbang.org/resource/image/f4/36/f4cbbff67538e16c913d3b01057a4836.jpg?wh=1990x686\" alt=\"\"></li>\n</ul><p>在C++支持Modules之后，新增了一种链接性叫做模块链接性（module linkage）。所有从属于模块而且没有通过export标记导出的符号就具备这种链接性。具备模块链接性的符号可以在属于这个模块的编译单元中使用。</p><p>模块中的符号如果满足下面两种情况，就不属于声明所在模块。</p><p>1.具备外部链接性的namespace。<br>\n2.使用“链接性指示符”修改符号的链接性。</p><p>我们用一段非常简单的代码来展示一下。</p><pre><code class=\"language-c++\">export module lib;\n&nbsp;\nnamespace hello {\n&nbsp;&nbsp;&nbsp; extern \"C++\" int32_t f();\n    extern \"C\" int32_t g();\n&nbsp;&nbsp;&nbsp; int32_t x();\n&nbsp;&nbsp;&nbsp; export int32_t z();\n}\n</code></pre><p>定义模块lib，包含了5个符号，分别是命名空间hello、函数hello::f、hello::g、hello::x和hello::z，我们逐一分析一下这些符号的链接性与所有权。</p><ul>\n<li>hello是命名空间，所以不从属于模块lib。</li>\n<li>函数hello::f使用了extern “C++”指示符，说明这个符号是外部链接性，并采用C++的方式生成符号，所以不从属于模块lib。</li>\n<li>函数hello::g使用了extern “C”指示符，说明这个符号是外部链接性，但采用了C的方式生成符号，所以不从属于模块lib。</li>\n<li>函数hello::x是属于模块lib的符号，只不过符号本身是模块链接性，只能被相同模块的编译单元引用。</li>\n<li>函数hello::z是属于模块lib的符号，并且添加了export，因此符号是外部链接性，可以被其他模块的编译单元引用。</li>\n</ul><p>其中hello、f、g都不从属于模块lib，因此这些符号都可以在其他模块中实现，而x和z只能在模块lib中实现。</p><h2>总结</h2><p>使用C++ Modules，我们可以切实有效地提升构建性能，从语言层面，这不仅是为我们开发者提供了规范的模块化工具，更是解决了一个鱼与熊掌不可兼得的关键问题，即传统头文件编译范式，在编译性能和符号隔离之间二选一的难题。<br>\n<img src=\"https://static001.geekbang.org/resource/image/73/86/73b3dc24ce594345574f946557c90586.jpg?wh=2300x1454\" alt=\"\"></p><p>这里我们对Modules的基础概念简单总结一下。</p><ul>\n<li>使用module声明，可以将编译单元设置为模块单元，如果声明前包含export则为模块接口单元，否则就是模块实现单元。一个模块只能包含一个模块接口单元。</li>\n<li>在module中声明的符号默认具有模块链接性，只能在模块内部使用，可以通过export将符号设置为对其他模块可见。</li>\n<li>使用import，可以将其他模块的符号引入到一个模块中，被引用模块的符号对本编译单元可见。也可以使用import导入传统头文件，相对于#include会有一些限制。</li>\n<li>模块支持定义分区。模块分区只能被本模块导入，不能被其他模块导入。模块分区内符号对其他模块的可见性需要通过主模块的接口模块控制。</li>\n<li>在模块单元中通过modules;定义全局模块片段，通过module : private;定义私有模块片段，可以在特定场景中使用这些特性解决问题。</li>\n<li>模块中声明的符号，归属权一般是模块本身，只能在相同模块实现。但是具备外部链接性的namespace和采用“链接性指示符”修改了链接性的符号是例外。</li>\n</ul><p>下一讲，我们将学习如何使用C++ Modules来组织实际的项目代码，敬请期待！</p><h2>课后思考</h2><p>在这一讲中，我们讲解了C++ Modules带来的极大便利性以及当前仍旧存在的功能限制。你能否举出在日常使用C++过程中碰到的有关于符号的编译、链接问题？可以分享一下你的解决方法。</p><p>欢迎留言和我分享你的想法，我们一同交流！</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/b6/4c3123c4298d88018298b860befe76b6.jpg?wh=2600x1530\" alt=\"\"></p>","neighbors":{"left":{"article_title":"01｜Modules（上）：C++模块化问题的前世今生","id":623274},"right":{"article_title":"03｜Modules（下）：实战写个多模块图像处理服务","id":624101}},"comments":[{"had_liked":false,"id":366681,"user_name":"Ak","can_delete":false,"product_type":"c1","uid":2702256,"ip_address":"广西","ucode":"057E3D3F837D81","user_header":"https://static001.geekbang.org/account/avatar/00/29/3b/b0/eb382271.jpg","comment_is_top":false,"comment_ctime":1674036060,"is_pvip":false,"replies":[{"id":133681,"content":"C++的演进过程必定要不断借鉴其他的语言模型中的优点，这样才能不断现代化，在保持更高的性能的同时提升生产力。但是，C++跟Java和Python还是存在一个根本性区别，就是C++在演进过程中始终秉持着这样一个思想，即能在编译时解决的计算问题，就一定不要推迟到运行时。所以可以看到，自C++11之后推出的几乎所有新特性，都是为编译时服务的。这也是C++与其他编程语言之间最大的区别之一。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674469658,"ip_address":"江苏","comment_id":366681,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"怎么感觉C++越来越像Java和python😅","like_count":6,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600520,"discussion_content":"C++的演进过程必定要不断借鉴其他的语言模型中的优点，这样才能不断现代化，在保持更高的性能的同时提升生产力。但是，C++跟Java和Python还是存在一个根本性区别，就是C++在演进过程中始终秉持着这样一个思想，即能在编译时解决的计算问题，就一定不要推迟到运行时。所以可以看到，自C++11之后推出的几乎所有新特性，都是为编译时服务的。这也是C++与其他编程语言之间最大的区别之一。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1674469658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366736,"user_name":"Geek1185","can_delete":false,"product_type":"c1","uid":2028954,"ip_address":"山东","ucode":"47BEE492EF4C1A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/9a/63dc81a2.jpg","comment_is_top":false,"comment_ctime":1674124050,"is_pvip":false,"replies":[{"id":133683,"content":"C++本身因为需要向下兼容C语言就导致了很高的复杂性，但这也是C++的设计哲学，保证C++具备极佳的性能。但是一旦用了新的特性就可以部分抛弃对应的旧特性，这样就可以在工程上简化C++的复杂性，这也是C++演进的目标。我们作为开发者，要适当尝试去逐渐迭代使用新的特性，丢弃一些过去的惯用法，保证自己的编程习惯控制在一个大致固定的范围内，这也是为什么说C++20会是一个比较关键的时间节点，让大家逐步从C++11甚至更早的编程习惯下，过渡到新的编程世界中。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674469840,"ip_address":"江苏","comment_id":366736,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"C++发展的过程中一直要兼容前面的用法，感觉越来越复杂了","like_count":2,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600522,"discussion_content":"C++本身因为需要向下兼容C语言就导致了很高的复杂性，但这也是C++的设计哲学，保证C++具备极佳的性能。但是一旦用了新的特性就可以部分抛弃对应的旧特性，这样就可以在工程上简化C++的复杂性，这也是C++演进的目标。我们作为开发者，要适当尝试去逐渐迭代使用新的特性，丢弃一些过去的惯用法，保证自己的编程习惯控制在一个大致固定的范围内，这也是为什么说C++20会是一个比较关键的时间节点，让大家逐步从C++11甚至更早的编程习惯下，过渡到新的编程世界中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674469840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368256,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"江苏","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1676071052,"is_pvip":false,"replies":[{"id":134151,"content":"在ES Module之前，JS的模块化方案主要是各类“事实标准”，整体混乱且问题多多，ES Module的定案也花费了相当之多的时间，浏览器能够支持ES Module也是近些年的事情了，出于兼容性考量大部分前端项目还会沿用类似于webpack的方案。\n\n而C++由于更多的历史遗留问题、技术限制甚至是标准委员会内不同大公司之间的一些博弈，导致Modules标准到C++20才得以定案。\n\n模块化的目的就是名称（符号）隔离，并且支持控制模块内名称（符号）的可见性，从这个目的上无论是解释性语言和编译性语言其实是一致的，不同点在于实现原理、实现限制与因语言本身设计思路以及历史遗留问题导致的设计与实现的差异，这些都体现在具体的设计细节与实现技术细节上，就算不同编译性语言之间（比如Java与Rust）与不同解释性语言之间（比如Python与ES）也会有很大差异，但是本质的设计目的一致，所以基本设计构思是不会有差别的。","user_name":"作者回复","user_name_real":"作者","uid":1006976,"ctime":1676258540,"ip_address":"上海","comment_id":368256,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"前端开发中，JavaScript的模块化方案发展多年了，历史中也出现了各种模块化方案，浏览器现在支持es module方案。感觉js的模块化探索走在前列。现在不太理解编译型语言的模块化和js这种解释型语言的模块化，有什么异同？","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603598,"discussion_content":"在ES Module之前，JS的模块化方案主要是各类“事实标准”，整体混乱且问题多多，ES Module的定案也花费了相当之多的时间，浏览器能够支持ES Module也是近些年的事情了，出于兼容性考量大部分前端项目还会沿用类似于webpack的方案。\n\n而C++由于更多的历史遗留问题、技术限制甚至是标准委员会内不同大公司之间的一些博弈，导致Modules标准到C++20才得以定案。\n\n模块化的目的就是名称（符号）隔离，并且支持控制模块内名称（符号）的可见性，从这个目的上无论是解释性语言和编译性语言其实是一致的，不同点在于实现原理、实现限制与因语言本身设计思路以及历史遗留问题导致的设计与实现的差异，这些都体现在具体的设计细节与实现技术细节上，就算不同编译性语言之间（比如Java与Rust）与不同解释性语言之间（比如Python与ES）也会有很大差异，但是本质的设计目的一致，所以基本设计构思是不会有差别的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676258540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380268,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"广东","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1693292132,"is_pvip":false,"replies":[{"id":138610,"content":"1.其实并不是花里胡哨，而是C++在语法兼容性上存在很重的历史负担，而且不能增添不必要的运行时成本，导致很多现代语言特性在C++中的实现就会变得非常“复杂”、“脆弱“，需要更多的技巧来集成到项目中。至于C++的库，其实在互联网时代之前C&#47;C++的库绝对是最丰富的——想想看GNU的那么多库，而且Linux的传统是，但凡有一个应用，大概率会提供对应的.h声明和二进制动态库，基本都是给C&#47;C++用的，所以其实C&#47;C++并不缺少成熟的第三方库，只不过不如Python&#47;Java那么方便。但到了互联网时代之后，Java&#47;Python由于其使用率以及库&#47;模块的集成便利程度，自然在成熟库的数量和丰富性上与C++不在一个等级。另外由于C++缺少标准的第三方模块仓库，所以一般找第三方库都要去GitHub自己挖掘，并且集成难度必然相对于Java&#47;Python更高，这也是C++早期羸弱的Module机制导致的（再加上各个平台不一致的ABI标准），最终形成了一个比较恶劣的第三方库生态环境。\n\n2.用Modules本质就是只需要.cpp或者说模块文件，而不再区分.h&#47;.cpp。但其实Modules一般也是需要划分声明文件和实现文件，和.h&#47;.cpp的分工有异曲同工之妙。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1693901109,"ip_address":"上海","comment_id":380268,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"我觉得不好用，花里胡哨的。C++最大的问题是库太少了，不像python和java那样想写个啥到处都是现成的库。用Modules的话，就只需要.cpp不需要.h了？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627225,"discussion_content":"1.其实并不是花里胡哨，而是C++在语法兼容性上存在很重的历史负担，而且不能增添不必要的运行时成本，导致很多现代语言特性在C++中的实现就会变得非常“复杂”、“脆弱“，需要更多的技巧来集成到项目中。至于C++的库，其实在互联网时代之前C/C++的库绝对是最丰富的——想想看GNU的那么多库，而且Linux的传统是，但凡有一个应用，大概率会提供对应的.h声明和二进制动态库，基本都是给C/C++用的，所以其实C/C++并不缺少成熟的第三方库，只不过不如Python/Java那么方便。但到了互联网时代之后，Java/Python由于其使用率以及库/模块的集成便利程度，自然在成熟库的数量和丰富性上与C++不在一个等级。另外由于C++缺少标准的第三方模块仓库，所以一般找第三方库都要去GitHub自己挖掘，并且集成难度必然相对于Java/Python更高，这也是C++早期羸弱的Module机制导致的（再加上各个平台不一致的ABI标准），最终形成了一个比较恶劣的第三方库生态环境。\n\n2.用Modules本质就是只需要.cpp或者说模块文件，而不再区分.h/.cpp。但其实Modules一般也是需要划分声明文件和实现文件，和.h/.cpp的分工有异曲同工之妙。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693901109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371117,"user_name":"亘古谣","can_delete":false,"product_type":"c1","uid":1783797,"ip_address":"四川","ucode":"DF76829D41BC26","user_header":"https://static001.geekbang.org/account/avatar/00/1b/37/f5/12d6641f.jpg","comment_is_top":false,"comment_ctime":1679557970,"is_pvip":false,"replies":[{"id":135399,"content":"目前cmake生成的Visual Studio工程在使用C++ Modules时无法正常将源代码标记为模块接口或者模块实现，但如果源代码后缀名是ixx时就会将对应的文件作为模块接口&#47;模块实现编译，因此我们将cpp文件复制了一个相同的ixx文件，以自动适配Visual Studio项目。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1679581926,"ip_address":"上海","comment_id":371117,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"我下载了源代码看了， 发现.ixx 和 .cpp里面的内容一样的。 我的理解.ixx不是向外提供的接口文件么， 怎么和实现文件一样？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610501,"discussion_content":"目前cmake生成的Visual Studio工程在使用C++ Modules时无法正常将源代码标记为模块接口或者模块实现，但如果源代码后缀名是ixx时就会将对应的文件作为模块接口/模块实现编译，因此我们将cpp文件复制了一个相同的ixx文件，以自动适配Visual Studio项目。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679581926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367286,"user_name":"Geek_7c0961","can_delete":false,"product_type":"c1","uid":2277181,"ip_address":"美国","ucode":"B1482E64FF9E4E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8aLz0tWdsZuMiaNUAd0dicSD9M6A77seMGFdHgvsQwOzN8ztYPiaJSo53DcbjQWUQpw4pf4rI2f7vg/132","comment_is_top":false,"comment_ctime":1675103550,"is_pvip":true,"replies":[{"id":133868,"content":"不知道你的clang版本号是多少，如果版本比较旧可以自己下载新版本源代码编译。但是clang对C++20的支持在3个主流编译器中的确是比较糟糕的，如果条件允许可以安装一个Windows虚拟机，然后使用VS，综合来说，就目前，Visual Studio对C++20的支持是最完善的。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1675349812,"ip_address":"江苏","comment_id":367286,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"mac os 上的 clang 对c++20支持十分有限,不知道在环境配置上面有啥好的建议么?","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601694,"discussion_content":"不知道你的clang版本号是多少，如果版本比较旧可以自己下载新版本源代码编译。但是clang对C++20的支持在3个主流编译器中的确是比较糟糕的，如果条件允许可以安装一个Windows虚拟机，然后使用VS，综合来说，就目前，Visual Studio对C++20的支持是最完善的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675349812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366856,"user_name":"小龚小龚 马到成功 🔥","can_delete":false,"product_type":"c1","uid":2572557,"ip_address":"江苏","ucode":"F137BE58BC1F48","user_header":"https://static001.geekbang.org/account/avatar/00/27/41/0d/99312186.jpg","comment_is_top":false,"comment_ctime":1674464417,"is_pvip":false,"replies":[{"id":133691,"content":"悉心采纳。可以考虑每个标题作为一个章节来学习。后续会针对内容编排进行调整。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674485412,"ip_address":"江苏","comment_id":366856,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"不会考虑用户的心智负担吗？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600544,"discussion_content":"悉心采纳。可以考虑每个标题作为一个章节来学习。后续会针对内容编排进行调整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674485412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366814,"user_name":"xuyong","can_delete":false,"product_type":"c1","uid":2134230,"ip_address":"北京","ucode":"7047B361A1A7F9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoZ5NZbtUUJV426Bs5xflO20BjapfRZSwtHkLqPlVuDqcAyrotkWVky74EMEbAbsMc85ZxxCs1nPw/132","comment_is_top":false,"comment_ctime":1674284612,"is_pvip":false,"replies":[{"id":133686,"content":"看起来概念复杂，但是在工程应用中其实非常简单（比如可以看后面的示例项目章节），而且不需要有很深入的理解就可以受益于现在的modules体系。可以期待一下 Modules（下），参考具体的代码实战有助于快速理解和掌握本课的内容。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674470212,"ip_address":"江苏","comment_id":366814,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"有点复杂了啊","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600525,"discussion_content":"看起来概念复杂，但是在工程应用中其实非常简单（比如可以看后面的示例项目章节），而且不需要有很深入的理解就可以受益于现在的modules体系。可以期待一下 Modules（下），参考具体的代码实战有助于快速理解和掌握本课的内容。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1674470212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366737,"user_name":"西钾钾","can_delete":false,"product_type":"c1","uid":1097722,"ip_address":"浙江","ucode":"0EE77083636ED9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV27QOK57cdpdh3E4hbArCOlccdtjCyWooF9fhjeSKAMo9SN1v9RODkrZUZD4RejjbdsqU2FIeMA/132","comment_is_top":false,"comment_ctime":1674126590,"is_pvip":false,"replies":[{"id":133685,"content":"从gcc和clang的新规定是可以将模块文件后缀名命名成.cppm，但其实这个是无所谓的，后缀名依然可以继续使用传统的.cpp。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674470158,"ip_address":"江苏","comment_id":366737,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"helloworld.cpp 是需要需改为 helloworld.cppm 吗？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600524,"discussion_content":"从gcc和clang的新规定是可以将模块文件后缀名命名成.cppm，但其实这个是无所谓的，后缀名依然可以继续使用传统的.cpp。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674470158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366679,"user_name":"西钾钾","can_delete":false,"product_type":"c1","uid":1097722,"ip_address":"浙江","ucode":"0EE77083636ED9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV27QOK57cdpdh3E4hbArCOlccdtjCyWooF9fhjeSKAMo9SN1v9RODkrZUZD4RejjbdsqU2FIeMA/132","comment_is_top":false,"comment_ctime":1674034675,"is_pvip":false,"replies":[{"id":133682,"content":"即将跟随课程提供给大家。","user_name":"作者回复","user_name_real":"作者","uid":1006976,"ctime":1674469674,"ip_address":"江苏","comment_id":366679,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"建议搞一个代码仓库","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600521,"discussion_content":"即将跟随课程提供给大家。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674469675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600194,"discussion_content":"老师正在整理中，后续会陆续更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674100831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"吉林","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366662,"user_name":"tanatang","can_delete":false,"product_type":"c1","uid":2349826,"ip_address":"四川","ucode":"7526705D25959A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/FhibmYQUzY7ibPac8Id5PwbibqCbvj5rWibeQhEyvYguc9pvPNUciaQydicrUjJKkhhp1s2AgfP7LRTZA8zqaa82yC8g/132","comment_is_top":false,"comment_ctime":1674026510,"is_pvip":false,"replies":[{"id":133680,"content":"基本不会出现这个问题。因为在新的模块系统里，只能在global里include头文件，这时候被包含头文件import的符号不会有影响。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674469549,"ip_address":"江苏","comment_id":366662,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100523801,"comment_content":"“同时，如果模块 A 通过 import 导入了模块 B 的符号，然后模块 B 通过 import 导入了模块 C 的符号，模块 A 中是无法直接使用模块 C 的符号的。毕竟模块系统就是为了严格规范符号可见性。”\n这个得要求 是在 *.cpp中import其它模块，如果在 *.h中导入了其它模块， 当.h被其它文件include的时候，就不是这样了。对吧？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600519,"discussion_content":"基本不会出现这个问题。因为在新的模块系统里，只能在global里include头文件，这时候被包含头文件import的符号不会有影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674469549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366623,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1674004580,"is_pvip":false,"replies":[{"id":133591,"content":"A1：安卓支持C++是通过NDK实现的，如果想要了解编译期对C++11的支持情况，应该看一下安装以及激活的NDK版本，然后可以知道实际使用的编译器是gcc还是clang以及其版本。一般现在NDK用的都是clang，如果查不到相关信息可以到NDK的toolchains目录中找到llvm的bin目录，然后执行clang --version查看编译器版本。\n\n查到clang的版本之后就可以上网查一下clang各个版本对C++20的特性支持情况，比如可以到clang官网（https:&#47;&#47;clang.llvm.org&#47;cxx_status.html#cxx20）查询。\n\nA2：是的，除非你在C++中创建了一个不由Java控制托管的native线程并在其中执行相应代码（这部分代码自然是在其他线程执行），否则肯定是在P1中执行。不过如果你采用JNI结合C++协程，可以实现在C++中暂停执行，并让其他Java线程来调度执行后续代码，这个可以到详细讨论协程的时候再思考怎么实现。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1674026971,"ip_address":"江苏","comment_id":366623,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100523801,"comment_content":"请教老师两个问题：\nQ1：怎么知道C++版本？\n我现在正在调试一个安卓上的C++程序，在看专栏的时候，想在这份安卓代码上测试文章中的内容。文章中的内容是C++20版本，我怎么知道这个安卓代码是否支持C++20？（安卓代码的IDE是AS3.5）\nQ2：所有被调用的代码都属于同一个线程吗？\n安卓代码，上层是Java，通过JNI调用native层的c++代码。 Java层的Class A中创建一个线程P1，该线程的while循环中，会调用其他的Java类代码，也会调用JNI代码，JNI代码再调用native层的c++代码。那么所有被调用的代码，包括Java代码（其他类）、JNI代码、C++代码，都属于线程P1，对吗？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600125,"discussion_content":"A1：安卓支持C++是通过NDK实现的，如果想要了解编译期对C++11的支持情况，应该看一下安装以及激活的NDK版本，然后可以知道实际使用的编译器是gcc还是clang以及其版本。一般现在NDK用的都是clang，如果查不到相关信息可以到NDK的toolchains目录中找到llvm的bin目录，然后执行clang --version查看编译器版本。\n\n查到clang的版本之后就可以上网查一下clang各个版本对C++20的特性支持情况，比如可以到clang官网（https://clang.llvm.org/cxx_status.html#cxx20）查询。\n\nA2：是的，除非你在C++中创建了一个不由Java控制托管的native线程并在其中执行相应代码（这部分代码自然是在其他线程执行），否则肯定是在P1中执行。不过如果你采用JNI结合C++协程，可以实现在C++中暂停执行，并让其他Java线程来调度执行后续代码，这个可以到详细讨论协程的时候再思考怎么实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674026971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366813,"user_name":"xuyong","can_delete":false,"product_type":"c1","uid":2134230,"ip_address":"北京","ucode":"7047B361A1A7F9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoZ5NZbtUUJV426Bs5xflO20BjapfRZSwtHkLqPlVuDqcAyrotkWVky74EMEbAbsMc85ZxxCs1nPw/132","comment_is_top":false,"comment_ctime":1674284608,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100523801,"comment_content":"太复杂","like_count":0}]}