{"id":332603,"title":"109 | Go 编程模式：Functional Options","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p><p>这节课，我们来讨论一下Functional Options这个编程模式。这是一个函数式编程的应用案例，编程技巧也很好，是目前Go语言中最流行的一种编程模式。</p><p>但是，在正式讨论这个模式之前，我们先来看看要解决什么样的问题。</p><h2>配置选项问题</h2><p>在编程中，我们经常需要对一个对象（或是业务实体）进行相关的配置。比如下面这个业务实体（注意，这只是一个示例）：</p><pre><code>type Server struct {\n    Addr     string\n    Port     int\n    Protocol string\n    Timeout  time.Duration\n    MaxConns int\n    TLS      *tls.Config\n}\n</code></pre><p>在这个 <code>Server</code> 对象中，我们可以看到：</p><ul>\n<li>要有侦听的IP地址 <code>Addr</code> 和端口号 <code>Port</code> ，这两个配置选项是必填的（当然，IP地址和端口号都可以有默认值，不过这里我们用于举例，所以是没有默认值，而且不能为空，需要是必填的）。</li>\n<li>然后，还有协议 <code>Protocol</code> 、 <code>Timeout</code> 和<code>MaxConns</code> 字段，这几个字段是不能为空的，但是有默认值的，比如，协议是TCP，超时<code>30</code>秒 和 最大链接数<code>1024</code>个。</li>\n<li>还有一个 <code>TLS</code>  ，这个是安全链接，需要配置相关的证书和私钥。这个是可以为空的。</li>\n</ul><p>所以，针对这样的配置，我们需要有多种不同的创建不同配置 <code>Server</code> 的函数签名，如下所示：</p><pre><code>func NewDefaultServer(addr string, port int) (*Server, error) {\n  return &amp;Server{addr, port, &quot;tcp&quot;, 30 * time.Second, 100, nil}, nil\n}\n\nfunc NewTLSServer(addr string, port int, tls *tls.Config) (*Server, error) {\n  return &amp;Server{addr, port, &quot;tcp&quot;, 30 * time.Second, 100, tls}, nil\n}\n\nfunc NewServerWithTimeout(addr string, port int, timeout time.Duration) (*Server, error) {\n  return &amp;Server{addr, port, &quot;tcp&quot;, timeout, 100, nil}, nil\n}\n\nfunc NewTLSServerWithMaxConnAndTimeout(addr string, port int, maxconns int, timeout time.Duration, tls *tls.Config) (*Server, error) {\n  return &amp;Server{addr, port, &quot;tcp&quot;, 30 * time.Second, maxconns, tls}, nil\n}\n</code></pre><p>因为Go语言不支持重载函数，所以，你得用不同的函数名来应对不同的配置选项。</p><!-- [[[read_end]]] --><h2>配置对象方案</h2><p>要解决这个问题，最常见的方式是使用一个配置对象，如下所示：</p><pre><code>type Config struct {\n    Protocol string\n    Timeout  time.Duration\n    Maxconns int\n    TLS      *tls.Config\n}\n</code></pre><p>我们把那些非必输的选项都移到一个结构体里，这样一来，  <code>Server</code> 对象就会变成：</p><pre><code>type Server struct {\n    Addr string\n    Port int\n    Conf *Config\n}\n</code></pre><p>于是，我们就只需要一个 <code>NewServer()</code> 的函数了，在使用前需要构造 <code>Config</code> 对象。</p><pre><code>func NewServer(addr string, port int, conf *Config) (*Server, error) {\n    //...\n}\n\n//Using the default configuratrion\nsrv1, _ := NewServer(&quot;localhost&quot;, 9000, nil) \n\nconf := ServerConfig{Protocol:&quot;tcp&quot;, Timeout: 60*time.Duration}\nsrv2, _ := NewServer(&quot;locahost&quot;, 9000, &amp;conf)\n</code></pre><p>这段代码算是不错了，大多数情况下，我们可能就止步于此了。但是，对于有洁癖的、有追求的程序员来说，他们会看到其中不太好的一点，那就是<code>Config</code> 并不是必需的，所以，你需要判断是否是 <code>nil</code> 或是 Empty——  <code>Config{}</code>会让我们的代码感觉不太干净。</p><h2>Builder模式</h2><p>如果你是一个Java程序员，熟悉设计模式的一定会很自然地使用Builder模式。比如下面的代码：</p><pre><code>User user = new User.Builder()\n  .name(&quot;Hao Chen&quot;)\n  .email(&quot;haoel@hotmail.com&quot;)\n  .nickname(&quot;左耳朵&quot;)\n  .build();\n</code></pre><p>仿照这个模式，我们可以把刚刚的代码改写成下面的样子（注：下面的代码没有考虑出错处理，其中关于出错处理的更多内容，你可以再回顾下<a href=\"https://time.geekbang.org/column/article/332602\">上节课</a>）：</p><pre><code>//使用一个builder类来做包装\ntype ServerBuilder struct {\n  Server\n}\n\nfunc (sb *ServerBuilder) Create(addr string, port int) *ServerBuilder {\n  sb.Server.Addr = addr\n  sb.Server.Port = port\n  //其它代码设置其它成员的默认值\n  return sb\n}\n\nfunc (sb *ServerBuilder) WithProtocol(protocol string) *ServerBuilder {\n  sb.Server.Protocol = protocol \n  return sb\n}\n\nfunc (sb *ServerBuilder) WithMaxConn( maxconn int) *ServerBuilder {\n  sb.Server.MaxConns = maxconn\n  return sb\n}\n\nfunc (sb *ServerBuilder) WithTimeOut( timeout time.Duration) *ServerBuilder {\n  sb.Server.Timeout = timeout\n  return sb\n}\n\nfunc (sb *ServerBuilder) WithTLS( tls *tls.Config) *ServerBuilder {\n  sb.Server.TLS = tls\n  return sb\n}\n\nfunc (sb *ServerBuilder) Build() (Server) {\n  return  sb.Server\n}\n</code></pre><p>这样一来，就可以使用这样的方式了：</p><pre><code>sb := ServerBuilder{}\nserver, err := sb.Create(&quot;127.0.0.1&quot;, 8080).\n  WithProtocol(&quot;udp&quot;).\n  WithMaxConn(1024).\n  WithTimeOut(30*time.Second).\n  Build()\n</code></pre><p>这种方式也很清楚，不需要额外的Config类，使用链式的函数调用的方式来构造一个对象，只需要多加一个Builder类。你可能会觉得，这个Builder类似乎有点多余，我们似乎可以直接在<code>Server</code> 上进行这样的 Builder 构造，的确是这样的。但是，在处理错误的时候可能就有点麻烦，不如一个包装类更好一些。</p><p>如果我们想省掉这个包装的结构体，就要请出Functional Options上场了：函数式编程。</p><h2>Functional Options</h2><p>首先，我们定义一个函数类型：</p><pre><code>type Option func(*Server)\n</code></pre><p>然后，我们可以使用函数式的方式定义一组如下的函数：</p><pre><code>func Protocol(p string) Option {\n    return func(s *Server) {\n        s.Protocol = p\n    }\n}\nfunc Timeout(timeout time.Duration) Option {\n    return func(s *Server) {\n        s.Timeout = timeout\n    }\n}\nfunc MaxConns(maxconns int) Option {\n    return func(s *Server) {\n        s.MaxConns = maxconns\n    }\n}\nfunc TLS(tls *tls.Config) Option {\n    return func(s *Server) {\n        s.TLS = tls\n    }\n}\n</code></pre><p>这组代码传入一个参数，然后返回一个函数，返回的这个函数会设置自己的 <code>Server</code> 参数。例如，当我们调用其中的一个函数 <code>MaxConns(30)</code> 时，其返回值是一个 <code>func(s* Server) { s.MaxConns = 30 }</code> 的函数。</p><p>这个叫高阶函数。在数学上，这有点像是计算长方形面积的公式为： <code>rect(width, height) = width * height;</code> 这个函数需要两个参数，我们包装一下，就可以变成计算正方形面积的公式：<code>square(width) = rect(width, width)</code>  。也就是说，<code>squre(width)</code>返回了另外一个函数，这个函数就是<code>rect(w,h)</code> ，只不过它的两个参数是一样的，即：<code>f(x) = g(x, x)</code>。</p><p>好了，现在我们再定一个 <code>NewServer()</code>的函数，其中，有一个可变参数 <code>options</code>  ，它可以传出多个上面的函数，然后使用一个for-loop来设置我们的 <code>Server</code> 对象。</p><pre><code>func NewServer(addr string, port int, options ...func(*Server)) (*Server, error) {\n\n  srv := Server{\n    Addr:     addr,\n    Port:     port,\n    Protocol: &quot;tcp&quot;,\n    Timeout:  30 * time.Second,\n    MaxConns: 1000,\n    TLS:      nil,\n  }\n  for _, option := range options {\n    option(&amp;srv)\n  }\n  //...\n  return &amp;srv, nil\n}\n</code></pre><p>于是，我们在创建 <code>Server</code> 对象的时候，就可以像下面这样：</p><pre><code>s1, _ := NewServer(&quot;localhost&quot;, 1024)\ns2, _ := NewServer(&quot;localhost&quot;, 2048, Protocol(&quot;udp&quot;))\ns3, _ := NewServer(&quot;0.0.0.0&quot;, 8080, Timeout(300*time.Second), MaxConns(1000))\n</code></pre><p>怎么样，是不是高度整洁和优雅？这不但解决了“使用 <code>Config</code> 对象方式的需要有一个config参数，但在不需要的时候，是放 <code>nil</code> 还是放 <code>Config{}</code>”的选择困难问题，也不需要引用一个Builder的控制对象，直接使用函数式编程，在代码阅读上也很优雅。</p><p>所以，以后，你要玩类似的代码时，我强烈推荐你使用Functional Options这种方式，这种方式至少带来了6个好处：</p><ul>\n<li>直觉式的编程；</li>\n<li>高度的可配置化；</li>\n<li>很容易维护和扩展；</li>\n<li>自文档；</li>\n<li>新来的人很容易上手；</li>\n<li>没有什么令人困惑的事（是nil 还是空）。</li>\n</ul><h2>参考文档</h2><ul>\n<li><a href=\"http://commandcenter.blogspot.com.au/2014/01/self-referential-functions-and-design.html\">Self referential functions and design</a>， by Rob Pike</li>\n</ul><p>好了，这节课就到这里。如果你觉得今天的内容对你有所帮助，欢迎你帮我分享给更多人。</p>","neighbors":{"left":{"article_title":"108 | Go 编程模式：错误处理","id":332602},"right":{"article_title":"110 | Go编程模式：委托和反转控制","id":332605}},"comments":[{"had_liked":false,"id":274441,"user_name":"汪辉","can_delete":false,"product_type":"c1","uid":1625869,"ip_address":"","ucode":"2416B890609849","user_header":"https://static001.geekbang.org/account/avatar/00/18/cf/0d/a173e2b8.jpg","comment_is_top":false,"comment_ctime":1611022394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27380826170","product_id":100002201,"comment_content":"之前看到mq的初始化可选配置的时候有用到Functional Options这个模式，没想到在这里找到源头了。","like_count":7},{"had_liked":false,"id":278297,"user_name":"Geek_a754be","can_delete":false,"product_type":"c1","uid":2437733,"ip_address":"","ucode":"A18C3752E2C1C8","user_header":"","comment_is_top":false,"comment_ctime":1612860954,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23087697434","product_id":100002201,"comment_content":"之前在公司自研的微服务框架里面看到大规模使用，原来有个学名叫Functional Options","like_count":6,"discussions":[{"author":{"id":2526790,"avatar":"https://static001.geekbang.org/account/avatar/00/26/8e/46/3b8b0651.jpg","nickname":"hi_tp🤣","note":"","ucode":"6652FE6299B77F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360412,"discussion_content":"Go grpc 实例化的时候就是这样干的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616427866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279145,"user_name":"萧","can_delete":false,"product_type":"c1","uid":1229143,"ip_address":"","ucode":"0C2239867AFF5F","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/57/27de274f.jpg","comment_is_top":false,"comment_ctime":1613636334,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"10203570926","product_id":100002201,"comment_content":"太强了，受益匪浅","like_count":3},{"had_liked":false,"id":341941,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1649926249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649926249","product_id":100002201,"comment_content":"option 意味选项，本身就有函数的意思","like_count":0},{"had_liked":false,"id":337982,"user_name":"Geek_Huahui","can_delete":false,"product_type":"c1","uid":1497346,"ip_address":"","ucode":"A688B183E5CE5E","user_header":"https://static001.geekbang.org/account/avatar/00/16/d9/02/c4e2d7e8.jpg","comment_is_top":false,"comment_ctime":1647220869,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647220869","product_id":100002201,"comment_content":"真的牛逼","like_count":0},{"had_liked":false,"id":333018,"user_name":"今年也没有猫","can_delete":false,"product_type":"c1","uid":1546547,"ip_address":"","ucode":"99379F3E276746","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/33/1981b0cc.jpg","comment_is_top":false,"comment_ctime":1643960301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643960301","product_id":100002201,"comment_content":"简单理解  就是一种闭包的组织形式。","like_count":0},{"had_liked":false,"id":326797,"user_name":"方勇(gopher)","can_delete":false,"product_type":"c1","uid":1290625,"ip_address":"","ucode":"D199911C4CFEF5","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/81/13f23d1e.jpg","comment_is_top":false,"comment_ctime":1639703808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639703808","product_id":100002201,"comment_content":"确实很多中间件的传参都这么设计，有时候可能要考虑，函数放在client端，还是server端","like_count":0},{"had_liked":false,"id":321089,"user_name":"青阳","can_delete":false,"product_type":"c1","uid":2139807,"ip_address":"","ucode":"3591D366BAB0B9","user_header":"https://static001.geekbang.org/account/avatar/00/20/a6/9f/3c60fffd.jpg","comment_is_top":false,"comment_ctime":1636676105,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636676105","product_id":100002201,"comment_content":"和函数科里化是一回事吗","like_count":0},{"had_liked":false,"id":299380,"user_name":"图个啥呢","can_delete":false,"product_type":"c1","uid":1134984,"ip_address":"","ucode":"BEE1F1477056A2","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/88/232fe847.jpg","comment_is_top":false,"comment_ctime":1624603802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624603802","product_id":100002201,"comment_content":"厉害了！","like_count":0},{"had_liked":false,"id":297162,"user_name":"👻 小二","can_delete":false,"product_type":"c1","uid":1625463,"ip_address":"","ucode":"9EEA8553163270","user_header":"https://static001.geekbang.org/account/avatar/00/18/cd/77/b2ab5d44.jpg","comment_is_top":false,"comment_ctime":1623333615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623333615","product_id":100002201,"comment_content":"这种接口也很友好， 就是苦了作者<br><br>```go<br>package main<br><br>import (<br>\t&quot;crypto&#47;tls&quot;<br>\t&quot;time&quot;<br>)<br><br>type Option struct {<br>\tTimeout *time.Duration<br>\tTLS     *tls.Config<br>}<br><br>func (option *Option) SetTimeOut(timeout time.Duration) *Option {<br>\toption.Timeout = &amp;timeout<br>\treturn option<br>}<br><br>func (option *Option) SetTLS(tls *tls.Config) *Option {<br>\toption.TLS = tls<br>\treturn option<br>}<br><br>func MergeOptions(options ...*Option) *Option {<br><br>\t&#47;&#47;把option合并起来<br>\treturn nil<br>}<br><br>type Server struct {<br>\tAddr    string<br>\tPort    int<br>\tTimeout time.Duration<br>\tTLS     *tls.Config<br>}<br><br>func NewOptions() *Option {<br>\treturn new(Option)<br>}<br>func NewServer(addr string, port int, options ...*Option) (*Server, error) {<br><br>\tsrv := Server{<br>\t\tAddr:    addr,<br>\t\tPort:    port,<br>\t\tTimeout: 30 * time.Second,<br>\t\tTLS:     nil,<br>\t}<br><br>\top := MergeOptions(options...)<br><br>\tif op.Timeout != nil {<br>\t\tsrv.Timeout = *op.Timeout<br>\t}<br><br>\tif op.TLS != nil {<br>\t\tsrv.TLS = op.TLS<br>\t}<br><br>\t&#47;&#47;...<br>\treturn &amp;srv, nil<br>}<br>func main() {<br>\t_, _ = NewServer(&quot;127.0.0.1&quot;, 80)<br>\t_, _ = NewServer(&quot;127.0.0.1&quot;, 80, NewOptions().SetTimeOut(100))<br>\t_, _ = NewServer(&quot;127.0.0.1&quot;, 80, NewOptions().SetTimeOut(100).SetTLS(nil))<br>}<br><br>```","like_count":0},{"had_liked":false,"id":293737,"user_name":"轻飘飘过","can_delete":false,"product_type":"c1","uid":1347071,"ip_address":"","ucode":"68F26121369330","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/ff/986ffb41.jpg","comment_is_top":false,"comment_ctime":1621514968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621514968","product_id":100002201,"comment_content":"对比js的...解构和函数式编程的compose?","like_count":0},{"had_liked":false,"id":289873,"user_name":"astrosta","can_delete":false,"product_type":"c1","uid":2583001,"ip_address":"","ucode":"64E88ADBBF0622","user_header":"https://static001.geekbang.org/account/avatar/00/27/69/d9/343b7a5f.jpg","comment_is_top":false,"comment_ctime":1619244292,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619244292","product_id":100002201,"comment_content":"用了很久，才知道叫Functional Options","like_count":0},{"had_liked":false,"id":289694,"user_name":"Geek_450b7e","can_delete":false,"product_type":"c1","uid":2264427,"ip_address":"","ucode":"653B2066F8BBD6","user_header":"","comment_is_top":false,"comment_ctime":1619146012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619146012","product_id":100002201,"comment_content":"优秀，学到了","like_count":0},{"had_liked":false,"id":288912,"user_name":"Eirture","can_delete":false,"product_type":"c1","uid":1308178,"ip_address":"","ucode":"49EC3830989464","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/12/19914d72.jpg","comment_is_top":false,"comment_ctime":1618759874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618759874","product_id":100002201,"comment_content":"在 Kubernetes 源代码中学过这一招，原来是叫 Functional Options，有了名字更容易记住和传播 👍","like_count":0},{"had_liked":false,"id":284218,"user_name":"小丢👣","can_delete":false,"product_type":"c1","uid":1031711,"ip_address":"","ucode":"A7699F00418FC4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/1f/57c88dd1.jpg","comment_is_top":false,"comment_ctime":1616124422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616124422","product_id":100002201,"comment_content":"豁然开朗，respect","like_count":0},{"had_liked":false,"id":278068,"user_name":"侯鹏₁₈₆₁₄₀₉₂₄₁₉","can_delete":false,"product_type":"c1","uid":1212378,"ip_address":"","ucode":"BB85A8993B4DBB","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/da/73778db7.jpg","comment_is_top":false,"comment_ctime":1612749924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612749924","product_id":100002201,"comment_content":"非常棒👍🏻","like_count":0}]}