{"id":627920,"title":"12｜Ranges（二）：用“视图”破除函数式编程之困","content":"<p>你好，我是卢誉声。</p><p>上一讲，我们重点讨论了C++传统函数式编程的困境，介绍了Ranges的概念，了解到range可以视为对传统容器的一种泛化，都具备迭代器等接口。但与传统容器不同的是，range对象不一定直接拥有数据。</p><p>在这种情况下，range对象就是一个视图（view）。这一讲，我们来讨论一下视图，它是Ranges中提出的又一个核心概念，是Ranges真正解放函数式编程的重要驱动力（项目的完整代码，你可以<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>获取）。</p><h2>视图</h2><p>视图也叫范围视图（range views），它本质是一种轻量级对象，用于间接表示一个可迭代的序列。Ranges也为视图实现了视图的迭代器，我们可以通过迭代器来访问视图。</p><p>对于传统STL中大部分可接受迭代器参数的算法函数，在C++20中都针对视图和视图迭代器提供了重载版本，<strong>比如ranges::for_each等函数，这些算法函数在C++20中叫做Constraint Algorithm</strong>。</p><p>那么Ranges库提供的视图有哪些呢？</p><p>我把视图类型和举例梳理了一张表格，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/15/ab5c7d5043e35756c8dfe7784cafb615.jpg?wh=3500x1365\" alt=\"\"></p><p>所有的视图类型与函数，都定义在std::ranges::views命名空间中，标准库也为我们提供了std::views作为这个命名空间的一个别名，所以实际开发时我们可以直接使用std::views。</p><!-- [[[read_end]]] --><p>后面是直接使用std::views的代码。后面我再解释iota、take的涵义，你可以先忽略这个细节。</p><pre><code class=\"language-c++\">#include &lt;ranges&gt;\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    for (int32_t i : std::views::iota(1) | std::views::take(4)) {\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    \n    return 0;\n}\n</code></pre><h2>基础视图接口</h2><p>了解了视图概念还不够，我们再聊聊C++标准中基础接口的详细设计，以及自定义实现方法。</p><p>C++ Ranges定义了一个标准接口ranges::view_interface（本质是一个抽象类）。我们首先来看一下如何使用该类，自定义自己的视图类。</p><pre><code class=\"language-c++\">template &lt;class Element, size_t Size&gt;\nclass ArrayView : public std::ranges::view_interface&lt;ArrayView&lt;Element, Size&gt;&gt; {\npublic:\n&nbsp;&nbsp;&nbsp; using Container = std::array&lt;Element, Size&gt;;\n&nbsp;\n&nbsp;&nbsp;&nbsp; ArrayView() = default;\n&nbsp;&nbsp;&nbsp; ArrayView(const Container&amp; container) :\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _begin(container.cbegin()), _end(container.cend())\n&nbsp;&nbsp;&nbsp; {}\n&nbsp;\n&nbsp;&nbsp;&nbsp; auto begin() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _begin;\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; auto end() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _end;\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\nprivate:\n&nbsp;&nbsp;&nbsp; typename Container::const_iterator _begin;\n&nbsp;&nbsp;&nbsp; typename Container::const_iterator _end;\n};\n</code></pre><p>可以看到，代码中定义了ArrayView类，该类型表示array容器的视图。我们定义了三个成员函数。</p><ul>\n<li>构造函数：包含默认构造函数和通过array对象创建视图的构造函数。构造函数将_begin和_end初始化为array的cbegin和cend。</li>\n<li>begin：返回_begin，Ranges可以通过该函数获取begin迭代器。</li>\n<li>end：返回_end，Ranges可以通过该函数获取end迭代器。</li>\n</ul><p>这样我们就可以将其作为视图来使用，你可以对照示例代码来理解。</p><pre><code class=\"language-c++\">int main() {\n&nbsp;&nbsp;&nbsp; std::array&lt;int, 4&gt; array = { 1, 2, 3, 4 };\n&nbsp;&nbsp;&nbsp; ArrayView arrayView { array };\n&nbsp;\n&nbsp;&nbsp;&nbsp; for (auto v : arrayView) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; v &lt;&lt; \" \";\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>在这段代码中，创建array对象后创建视图，由于视图类中定义了begin和end成员函数，因此可以用C++的for循环直接遍历这个视图。</p><p>除此以外，ranges::view_interface中还定义了几个成员函数，当视图类满足特定约束时基类会提供默认实现，开发者必要时可以覆盖其实现，具体可以参考后面这张表。</p><p><img src=\"https://static001.geekbang.org/resource/image/0e/bc/0e7f4a7a3edf9c55e27187bc73de06bc.jpg?wh=3270x1803\" alt=\"\"></p><p>从这里我们就可以看出视图的本质就是对一个可迭代序列的间接引用，视图自身不存储数据，只是引用了可迭代序列的一部分数据。</p><p>虽然Ranges提供了视图的基础接口。但总体来说，我们自己实现所有的视图接口可就太麻烦了。</p><p>因此，Ranges提供了视图工厂和适配器，为我们提供了便利的构造视图的方法——这是我们使用视图的主要方法。接下来，我们就来仔细看一下视图工厂与适配器的细节。</p><h3>工厂</h3><p>视图工厂提供了一些常用的视图类，以及基于这些视图类构建视图对象的工具函数。</p><p>我们先来看一段代码，感性地认识一下如何使用视图工厂。</p><pre><code class=\"language-c++\">#include &lt;array&gt;\n#include &lt;ranges&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; namespace ranges = std::ranges;\n&nbsp;&nbsp;&nbsp; namespace views = std::views;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // iota_view与iota\n&nbsp;&nbsp;&nbsp; for (int32_t i : ranges::iota_view{ 0, 10 }) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; i &lt;&lt; \" \";\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; for (int32_t i : views::iota(1) | views::take(4)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; i &lt;&lt; \" \";\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // istream_view与istream\n&nbsp;&nbsp;&nbsp; std::istringstream textStream{ \"hello, world\" };\n&nbsp;&nbsp;&nbsp; for (const std::string&amp; s : ranges::istream_view&lt;std::string&gt;{ textStream }) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Text: \" &lt;&lt; s &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::istringstream numberStream{ \"3 1 4 1 5\" };\n&nbsp;&nbsp;&nbsp; for (int n : views::istream&lt;int32_t&gt;(numberStream)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Number: \" &lt;&lt; n &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>在这段代码中，我们使用了两个视图工厂——ranges::iota_view和ranges::istream_view。</p><p>views::iota是ranges::iota_view的工具函数，有了它，就能更方便地创建一个iota_view对象。调用views::iota时，我们也使用了视图适配器views::take(4)创建一个新视图，包含前一个视图的前4个元素。类似于L | R这种语法就是所谓的视图管道，允许我们将多个视图连接在一起，让分步的数据处理变得简洁优雅。</p><p>另一个视图工厂是ranges::istream_view，作用是创建一个从输入流中不断读取数据的视图类。在遍历这个视图的时候，视图会尝试从输入流中读取数据，直到输入流结束为止。views::istream（也就是ranges::istream_view的工具函数），可以返回一个istream_view对象。</p><p>由此可见，使用视图工厂是非常简单的。后面表格里整理了C++20中提供的所有工厂，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/24/bb/24cffca4f0693a29f950ae0afb6e59bb.jpg?wh=2970x1444\" alt=\"\"></p><p>除此之外，还有一些在C++23中提供的新视图工厂，待后续讨论C++23时我再介绍。</p><h3>适配器</h3><p>除了直接创建视图，Ranges还提供了一系列工具，可以将一个或者多个视图转换成一个新的视图，用来支持数据处理和运算工作。</p><p>这些用视图作为参数的“工厂”就是视图适配器。比如说，上一节中用到的views::take返回的就是类型为take_view的视图适配器对象。</p><p>Ranges也支持通过嵌套和组合的方式来使用视图适配器。后面的例子是一个典型的函数式编程案例。</p><pre><code class=\"language-c++\">#include &lt;vector&gt;\n#include &lt;ranges&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;algorithm&gt;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; namespace ranges = std::ranges;\n&nbsp;&nbsp;&nbsp; namespace views = std::views;\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::random_device rd;\n&nbsp;&nbsp;&nbsp; std::mt19937 gen(rd());\n&nbsp;&nbsp;&nbsp; std::uniform_int_distribution&lt;&gt; distrib(1, 10);\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 步骤6：输出\n&nbsp;&nbsp;&nbsp; ranges::for_each(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 步骤5：将键值对序列[(0,a1),(1,a2),...,(n, an)]转换为[0+a1,1+a2,...,n+an]的求和序列\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::transform(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 步骤4：选取结果键值对的至多前3个键值对（不足3个则全部返回）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::take(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 步骤3：从随机数键值对中筛选数值大于5的键值对\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::filter(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 步骤2：生成随机数键值对序列[(0,a1),(1,a2),...,(n, an)]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::transform(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 步骤1：生成序列[0,10)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;views::iota(0, 10),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&amp;distrib, &amp;gen](auto index) { return std::make_pair(index, distrib(gen)); }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](auto element) { return element.second &gt; 5;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](auto element) { return element.first + element.second; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ), \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](auto number) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; number &lt;&lt; \" \";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>这段代码是一个典型的函数式编程案例。你可以结合代码来理解这几个步骤。</p><p>第一步，使用views::iota生成一个[0,10)的等差序列，相当于一个range。</p><p>第二步，使用views::transform为等差序列中的每一个数生成一个随机数，返回一个由随机数键值对组成的序列，序列形式为[(0,a1),(1,a2),…,(n, an)]。</p><p>第三步，使用views::filter从随机数键值对序列中筛选所有随机数大于5的键值对，生成一个新的序列。</p><p>第四步，使用views::take从filter输出的键值对序列中选取前3个键值对，如果filter输出的数量不足3个则返回所有元素，也就是这里肯定不会产生越界。</p><p>第五步，使用views::transform将take返回的键值对序列[(0,a1),(1,a2),…,(n, an)]转换为[0+a1,1+a2,…,n+an]的求和序列。</p><p>第六步，使用views::for_each输出结果。</p><p>我们可以看出，整段代码是用嵌套函数的形式编写的，而且在transform、filter和for_each中，都使用了Lambda表达式作为高阶函数。这段编码已经非常简洁了，除了部分C++无法避免的语法特性，可读性堪比其他函数式编程语言。</p><p>不过，如果你还不熟悉函数式编程，那么看到这种深度的括号嵌套应该会感到非常头痛。对此，我跟你说一个有关Lisp的地狱笑话。</p><blockquote>\n<p>某个程序员偷到了一个系统代码的最后一页，结果发现那一页上全部都是右括号。</p>\n</blockquote><p>或许，你现在应该理解了这个笑话的梗在哪里。</p><p>如果我们要用传统STL算法来实现这个函数式编程的过程，大概情况会是这样的。</p><pre><code class=\"language-c++\">#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; std::random_device rd;\n&nbsp;&nbsp;&nbsp; std::mt19937 gen(rd());\n&nbsp;&nbsp;&nbsp; std::uniform_int_distribution&lt;&gt; distrib(1, 10);\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; rangeNumbers(10, 0);\n&nbsp;&nbsp;&nbsp; std::iota(rangeNumbers.begin(), rangeNumbers.end(), 0);\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::vector&lt;std::pair&lt;int, int&gt;&gt; rangePairs;\n&nbsp;&nbsp;&nbsp; std::transform(rangeNumbers.begin(), rangeNumbers.end(), std::back_inserter(rangePairs), [&amp;distrib, &amp;gen](int index) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::make_pair(index, distrib(gen));\n&nbsp;&nbsp;&nbsp; });\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::vector&lt;std::pair&lt;int, int&gt;&gt; filteredPairs;\n&nbsp;&nbsp;&nbsp; std::copy_if(rangePairs.begin(), rangePairs.end(), std::back_inserter(filteredPairs), [](const auto&amp; element) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return element.second &gt; 5;\n&nbsp;&nbsp;&nbsp; });\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::vector&lt;std::pair&lt;int, int&gt;&gt; leadingPairs;\n&nbsp;&nbsp;&nbsp; std::copy_n(filteredPairs.begin(), 3, std::back_inserter(leadingPairs));\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; resultNumbers;\n&nbsp;&nbsp;&nbsp; std::transform(leadingPairs.begin(), leadingPairs.end(), std::back_inserter(resultNumbers), [](const auto&amp; element) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return element.first + element.second;\n&nbsp;&nbsp;&nbsp; });\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::for_each(resultNumbers.begin(), resultNumbers.end(), [](int number) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; number &lt;&lt; \" \";\n&nbsp;&nbsp;&nbsp; });\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>由于传统算法为了通用性，所以算法函数的输入都是迭代器，我们也就不得不创建大量的临时变量存储中间结果。有了对比，我们可以直观感受到，相比采用视图的方法，传统STL算法写的代码可读性就差了很多，而且也没有提供越界检查功能。</p><p>除了上述案例中用到的适配器，Ranges还提供了大量的适配器。如果你感兴趣的话，可以查一下&lt;ranges&gt;头文件的文档，进一步了解所有的适配器。</p><h3>视图管道</h3><p>在实际编码时，虽然有适配器的帮助，但是大量的函数嵌套还是非常影响代码可读性。为此，C++还提供了视图管道（pipeline）来帮助我们更好地组织代码。比如前面的代码就还有改进空间，我们可以修改成后面这样。</p><pre><code class=\"language-c++\">#include &lt;vector&gt;\n#include &lt;ranges&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;algorithm&gt;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; namespace ranges = std::ranges;\n&nbsp;&nbsp;&nbsp; namespace views = std::views;\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::random_device rd;\n&nbsp;&nbsp;&nbsp; std::mt19937 gen(rd());\n&nbsp;&nbsp;&nbsp; std::uniform_int_distribution&lt;&gt; distrib(1, 10);\n&nbsp;&nbsp;&nbsp; \n&nbsp;&nbsp;&nbsp; ranges::for_each(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::iota(0, 10) |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::transform([&amp;distrib, &amp;gen](int index) { return std::make_pair(index, distrib(gen)); }) |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::filter([](const auto&amp; element) { return element.second &gt; 5;&nbsp; }) |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::take(3) |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::transform([](const auto&amp; element) { return element.first + element.second; }), \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int number) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; number &lt;&lt; \" \";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>这个代码中，除了ranges::for_each属于算法函数，其他的嵌套视图都修改成了通过|这个视图管道操作符连接的形式。比如原本代码中的transform(iota(), fn)，我们可以修改成iota() | transform(fn)这种形式。</p><p>所谓的视图管道依赖于 <strong>Range适配器对象（range adaptor object）</strong>这个概念。简单来说，Range适配器对象需要重载operator()操作符，并且满足后面这三个条件。</p><p>1.参数列表为(R, …args)。<br>\n2.第一个参数是另一个Range适配器对象R。<br>\n3.可以存在后续参数…args，也可以不存在后续参数。</p><p>也就是说，Range适配器对象必定是一个仿函数（functor）。由于第一个参数可以接收另一个适配器对象，因此我们可以像上一节中那样实现视图适配器的嵌套。<strong>那么视图管道又是怎么实现的呢？</strong></p><p>首先，Range适配器对象中有一个特例，就是如果后续参数…args不存在时，我们就把这种适配器对象叫做 <strong>range适配器闭包对象（range adaptor closure object）</strong>。假设有一个适配器闭包对象C，其参数列表只有一个参数R，并且R也是一个适配器对象，那么我们可以这样将两者嵌套调用。</p><pre><code class=\"language-c++\">C(R)\n</code></pre><p>这时，C++ Ranges就提供了视图管道，让我们可以将这种函数调用写成：</p><pre><code class=\"language-c++\">R | C\n</code></pre><p>所以视图管道，本质上就是一个对 “range适配器闭包对象函数调用”的语法糖。</p><p>那么，<strong>普通的Range适配器对象如何转换成闭包对象呢</strong>？很简单，只需要将除了第一个参数的后续参数…args通过binding绑定上固定的参数，生成只有一个参数的偏函数就可以了。</p><p>此外，视图管道还可以复合使用，假设R、C和D都是range适配器闭包对象，我们就可以写成这样。</p><pre><code class=\"language-c++\">R | C | D\n(R | C) | D\nD(C(R))\n</code></pre><p>这三者是完全等价的。所以可以看出 | 管道操作符的结合方向是自左向右结合。如果想要改变结合性，我们可以使用括号，后面这种形式代码就是等价的。</p><pre><code class=\"language-c++\">R | (C | D)\nD(C)(R)\n</code></pre><p>这样一来，通过视图管道和视图适配器，我们就能组织出C++中非常优雅的函数式代码了。</p><p>需要额外说明的是，C++20中暂时只能使用标准库中定义的视图类型，我们自己哪怕实现了满足range适配器闭包对象的接口也无法在视图管道中使用，用户自定义的适配器闭包对象类型在C++23中才会得到支持。不过现阶段我们也有变通的方法可以将自定义的类型组合到视图管道中，我们将会在下一讲中具体讨论。</p><h2>总结</h2><p>通过两讲的内容，我们一起了解了Ranges的来龙去脉。</p><p>这一讲我们学习了Ranges的另一个重要概念——视图，我们通过它来间接引用特定范围的数据，而非拥有数据。在视图的基础上，通过视图工厂、视图适配器和视图管道，我们可以让复杂的数据处理变得简洁优雅。</p><p>我们还讨论了range适配器闭包对象，这种对象只需要满足后面三个条件中的一个。</p><p>1.只有一个参数，参数类型为Range适配器对象。<br>\n2.将另一个range适配器对象的后续参数…args绑定固定参数后生成的仿函数（functor）。<br>\n3.使用视图管道操作符 | 连接两个range适配器闭包对象后返回的对象。</p><h2>课后思考</h2><p>我们在讨论Ranges视图适配器的时候，曾提到除了课程里用到的适配器，Ranges还提供了大量的适配器。你能否查阅相关文档进一步了解这些适配器，并结合一段简短的代码来展示其使用？</p><p>欢迎把你的代码贴出来，与大家一起分享。我们一同交流。下一讲见！</p>","comments":[{"had_liked":false,"id":370376,"user_name":"tang_ming_wu","can_delete":false,"product_type":"c1","uid":2566054,"ip_address":"广东","ucode":"98E5847CEF8B84","user_header":"https://static001.geekbang.org/account/avatar/00/27/27/a6/32e9479b.jpg","comment_is_top":false,"comment_ctime":1678764035,"is_pvip":false,"replies":[{"id":135262,"content":"首先，函数式编程本身并不是伪需求，如果你了解并习惯了函数式编程的一些基本原则和解决问题的思路，你会发现在处理特定问题时采用函数式编程的思路是很顺畅的。\n\n其次，现在讨论函数式编程时很多人可能的确在“自嗨”，因为在我看来函数式编程并不比传统的过程化或者面向对象等范式更”高级”，我认为这些范式没有绝对优劣。以我个人为例，在处理复杂数据尤其是并行编程时，会优先选用函数式编程的思路组织计算过程，在实现函数细节时，我会更习惯使用过程化&#47;结构化的思路，在组织整个系统的架构或对系统进行建模时，我可能更倾向于基于面向对象的设计方法并进行模块划分——在合理的场景使用每个人所认定的更合理的解决方案就行。计算机世界没有“银弹”，不同的技术或者方法论对我们来说都只是解决实际问题的一个“工具”，我们不需要教条化，该用什么就用什么，仅此而已。\n\n但是，我们依然需要去学习，去尝试使用一些不同的思路。由于我们大部分人入门时都以结构化&#47;过程与面向对象为主要范式的语言开始学习，自然会习惯采用这些熟悉的思路去解决问题，一旦换了一种思维方式（比如函数式编程），一开始就会无所适从并且抵触。反之，如果我们一开始学习的不是C&#47;C++&#47;Java这类语言，而是LISP或者Erlang这类函数式语言，那么你可能会觉得用函数式的思路去解决问题是一个非常自然的事情，就和你现在习惯使用C++编写代码一样。\n\n同时，我也不觉得函数式编程有什么地方会让我们不方便调试，反而由于习惯了变量的不可变性（无副作用），很多时候反倒容易在调试更快确定发生问题的位置。\n\n至于设计解耦也和函数式编程完全没有关系。也许因为我的例子中只演示了如何使用函数式编程处理数据，所以你觉得函数式编程的耦合性很高。但耦合性更多体现在系统的模块划分和组织，而不是我们针对某一个数据的处理过程中。我们使用函数式编程来组织系统时，可以根据函数和业务的关系分析函数之间的内聚性，然后进行模块划分，并不会将函数都放在一个模块中，依然可以实现高内聚、低耦合的系统设计。我的示例中只是在实现一个算法，这些代码必然是要以一种高内聚的方式来组织的，而且你会发现数据处理代码的各个部分由于只关注如何解决一个问题，因此数据流的每一个处理函数反倒有更强的内聚性。\n\n代码的可维护性就更取决于我们自己的系统设计和编码习惯，和函数式编程没有任何必然关系。这里也需要再提一下，函数式编程中的变量不可变性有时候对于代码维护反倒是有益处的。\n\n说实话，我一开始也不习惯（自然也不认同）函数式编程的思路和理念， 但在实际工作中慢慢去尝试换一种思路解决问题后，突然发现自己已经非常习惯在数据处理过程中使用map&#47;filter&#47;reduce之类的高阶函数来组织代码，现在非常享受这种分离关注点、无副作用和函数幂等性带给我的“快乐”，也许这也不是纯粹的函数式编程，但在汲取其中一些核心理念后，我在处理复杂数据时的编码风格的确产生了很大改变，并且让我感到受益良多。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1679157402,"ip_address":"上海","comment_id":370376,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"对比函数式编程实现和传统编程实现，我个人觉得函数式编程只是伪需求和一小部分人的自嗨：（1）不方便调试（2）不方便设计解耦（3）不方便维护（4）不方便阅读理解。","like_count":5,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609755,"discussion_content":"首先，函数式编程本身并不是伪需求，如果你了解并习惯了函数式编程的一些基本原则和解决问题的思路，你会发现在处理特定问题时采用函数式编程的思路是很顺畅的。\n\n其次，现在讨论函数式编程时很多人可能的确在“自嗨”，因为在我看来函数式编程并不比传统的过程化或者面向对象等范式更”高级”，我认为这些范式没有绝对优劣。以我个人为例，在处理复杂数据尤其是并行编程时，会优先选用函数式编程的思路组织计算过程，在实现函数细节时，我会更习惯使用过程化/结构化的思路，在组织整个系统的架构或对系统进行建模时，我可能更倾向于基于面向对象的设计方法并进行模块划分——在合理的场景使用每个人所认定的更合理的解决方案就行。计算机世界没有“银弹”，不同的技术或者方法论对我们来说都只是解决实际问题的一个“工具”，我们不需要教条化，该用什么就用什么，仅此而已。\n\n但是，我们依然需要去学习，去尝试使用一些不同的思路。由于我们大部分人入门时都以结构化/过程与面向对象为主要范式的语言开始学习，自然会习惯采用这些熟悉的思路去解决问题，一旦换了一种思维方式（比如函数式编程），一开始就会无所适从并且抵触。反之，如果我们一开始学习的不是C/C++/Java这类语言，而是LISP或者Erlang这类函数式语言，那么你可能会觉得用函数式的思路去解决问题是一个非常自然的事情，就和你现在习惯使用C++编写代码一样。\n\n同时，我也不觉得函数式编程有什么地方会让我们不方便调试，反而由于习惯了变量的不可变性（无副作用），很多时候反倒容易在调试更快确定发生问题的位置。\n\n至于设计解耦也和函数式编程完全没有关系。也许因为我的例子中只演示了如何使用函数式编程处理数据，所以你觉得函数式编程的耦合性很高。但耦合性更多体现在系统的模块划分和组织，而不是我们针对某一个数据的处理过程中。我们使用函数式编程来组织系统时，可以根据函数和业务的关系分析函数之间的内聚性，然后进行模块划分，并不会将函数都放在一个模块中，依然可以实现高内聚、低耦合的系统设计。我的示例中只是在实现一个算法，这些代码必然是要以一种高内聚的方式来组织的，而且你会发现数据处理代码的各个部分由于只关注如何解决一个问题，因此数据流的每一个处理函数反倒有更强的内聚性。\n\n代码的可维护性就更取决于我们自己的系统设计和编码习惯，和函数式编程没有任何必然关系。这里也需要再提一下，函数式编程中的变量不可变性有时候对于代码维护反倒是有益处的。\n\n说实话，我一开始也不习惯（自然也不认同）函数式编程的思路和理念， 但在实际工作中慢慢去尝试换一种思路解决问题后，突然发现自己已经非常习惯在数据处理过程中使用map/filter/reduce之类的高阶函数来组织代码，现在非常享受这种分离关注点、无副作用和函数幂等性带给我的“快乐”，也许这也不是纯粹的函数式编程，但在汲取其中一些核心理念后，我在处理复杂数据时的编码风格的确产生了很大改变，并且让我感到受益良多。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1679157402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385339,"user_name":"Family mission","can_delete":false,"product_type":"c1","uid":2710729,"ip_address":"上海","ucode":"10D4D65520FE0D","user_header":"https://static001.geekbang.org/account/avatar/00/29/5c/c9/f1b053f2.jpg","comment_is_top":false,"comment_ctime":1702459593,"is_pvip":false,"replies":[{"id":140537,"content":"对views::reverse和ranges::reverse_view的使用没问题，赞","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1703004863,"ip_address":"上海","comment_id":385339,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"views::reverse和ranges::reverse_view的使用\n#include &lt;iostream&gt;\n#include &lt;ranges&gt;\n \nint main()\n{\n    namespace ranges=std::ranges;\n    namespace views = std::views;\n    static constexpr auto il = {3, 1, 4, 1, 5, 9};\n \n    ranges::reverse_view rv{il};\n    for (int i : rv)\n        std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n \n    for (int i : il | views::reverse)\n        std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n \n    &#47;&#47; operator[] is inherited from std::view_interface\n    for (auto i{0U}; i != rv.size(); ++i)\n        std::cout &lt;&lt; rv[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n}","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634125,"discussion_content":"对views::reverse和ranges::reverse_view的使用没问题，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703004863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385332,"user_name":"Family mission","can_delete":false,"product_type":"c1","uid":2710729,"ip_address":"上海","ucode":"10D4D65520FE0D","user_header":"https://static001.geekbang.org/account/avatar/00/29/5c/c9/f1b053f2.jpg","comment_is_top":false,"comment_ctime":1702455050,"is_pvip":false,"replies":[{"id":140535,"content":"这个是嵌套模板\n首先是std::ranges::view_interface&lt;T&gt;\n然后T是ArrayView&lt;Element, Size&gt;\n所以最后就是std::ranges::view_interface&lt;ArrayView&lt;Element, Size&gt;&gt;","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1703004825,"ip_address":"上海","comment_id":385332,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"作者你好，感觉ranges作用以及功能性都不错，请教个问题\ntemplate &lt;class Element, size_t Size&gt;\nclass ArrayView : public std::ranges::view_interface&lt;ArrayView&lt;Element, Size&gt;&gt; {\n中class ArrayView 继承std::ranges::view_interface&lt;ArrayView&lt;Element, Size&gt;&gt;不太理解的点是继承模板类不都是类名&lt;模板类型&gt;这种么，这个写法是两个尖括号是啥意思","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634123,"discussion_content":"这个是嵌套模板\n首先是std::ranges::view_interface&lt;T&gt;\n然后T是ArrayView&lt;Element, Size&gt;\n所以最后就是std::ranges::view_interface&lt;ArrayView&lt;Element, Size&gt;&gt;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703004825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382580,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"广东","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1697610446,"is_pvip":false,"replies":[{"id":139352,"content":"函数式编程在数据处理领域极为有用，这也是为什么像Scala这样的编程语言能占有一席之地的原因之一。在数据不可变性基础上，对数据做变换、转化和处理，使用函数式编程在多线程场景下必不可少。相较于加锁，函数式编程能以更低成本实现数据的并发处理，从这个角度看，支持函数式编程是有意义的。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1697724818,"ip_address":"上海","comment_id":382580,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"函数式编程的可读性真是差，非常差，C++发展越来越倒退了","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629855,"discussion_content":"函数式编程在数据处理领域极为有用，这也是为什么像Scala这样的编程语言能占有一席之地的原因之一。在数据不可变性基础上，对数据做变换、转化和处理，使用函数式编程在多线程场景下必不可少。相较于加锁，函数式编程能以更低成本实现数据的并发处理，从这个角度看，支持函数式编程是有意义的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697724818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371948,"user_name":"大熊猫有宝贝","can_delete":false,"product_type":"c1","uid":1389695,"ip_address":"上海","ucode":"765AC2CF55B9B3","user_header":"https://static001.geekbang.org/account/avatar/00/15/34/7f/6c99fc74.jpg","comment_is_top":false,"comment_ctime":1680536597,"is_pvip":false,"replies":[{"id":135796,"content":"视图工厂包含：\n（1）视图类：视图对象的类型\n（2）工具函数：用于从特定的视图类型，创建视图对象","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1680704068,"ip_address":"上海","comment_id":371948,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"工厂和工具函数之间的关系该怎么理解呢？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612461,"discussion_content":"视图工厂包含：\n（1）视图类：视图对象的类型\n（2）工具函数：用于从特定的视图类型，创建视图对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680704068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368219,"user_name":"📷全程不笑🏀","can_delete":false,"product_type":"c1","uid":2767893,"ip_address":"广东","ucode":"10195E2385F4DE","user_header":"https://static001.geekbang.org/account/avatar/00/2a/3c/15/0c2db845.jpg","comment_is_top":false,"comment_ctime":1676016202,"is_pvip":false,"replies":[{"id":134083,"content":"目前这个时间点，gcc 对新标准支持并不好。从支持程度上来说，Visual C++\n&gt; clang &gt; gcc。\n\n你可以尝试 Visual Studio 2022 来进行编译。另外建议gcc升级到12.2。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1676030866,"ip_address":"上海","comment_id":368219,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"老师好，请教个问题，我的环境是ubuntu20.04， gcc版本11.1.0。\n工厂小节中的示例代码编译报错了， istream_view与istream相关。\n第25行的视图初始化应该为小括号吧，大括号{}我这边编译报错。另外28行的views::istream也编译报错，替换成ranges::istream_view运行正常，不知道是不是我环境的问题？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603254,"discussion_content":"目前这个时间点，gcc 对新标准支持并不好。从支持程度上来说，Visual C++\n&gt; clang &gt; gcc。\n\n你可以尝试 Visual Studio 2022 来进行编译。另外建议gcc升级到12.2。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676030866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}