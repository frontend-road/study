{"id":299312,"title":"07 | Cond：条件变量的实现机制及避坑指南","content":"<p>你好，我是鸟窝。</p><p>在写Go程序之前，我曾经写了10多年的Java程序，也面试过不少Java程序员。在Java面试中，经常被问到的一个知识点就是等待/通知（wait/notify）机制。面试官经常会这样考察候选人：请实现一个限定容量的队列（queue），当队列满或者空的时候，利用等待/通知机制实现阻塞或者唤醒。</p><p>在Go中，也可以实现一个类似的限定容量的队列，而且实现起来也比较简单，只要用条件变量（Cond）并发原语就可以。Cond并发原语相对来说不是那么常用，但是在特定的场景使用会事半功倍，比如你需要在唤醒一个或者所有的等待者做一些检查操作的时候。</p><p>那么今天这一讲，我们就学习下Cond这个并发原语。</p><h2>Go标准库的Cond</h2><p>Go标准库提供Cond原语的目的是，为等待/通知场景下的并发问题提供支持。Cond通常应用于等待某个条件的一组goroutine，等条件变为true的时候，其中一个goroutine或者所有的goroutine都会被唤醒执行。</p><p>顾名思义，Cond是和某个条件相关，这个条件需要一组goroutine协作共同完成，在条件还没有满足的时候，所有等待这个条件的goroutine都会被阻塞住，只有这一组goroutine通过协作达到了这个条件，等待的goroutine才可能继续进行下去。</p><!-- [[[read_end]]] --><p>那这里等待的条件是什么呢？等待的条件，可以是某个变量达到了某个阈值或者某个时间点，也可以是一组变量分别都达到了某个阈值，还可以是某个对象的状态满足了特定的条件。总结来讲，等待的条件是一种可以用来计算结果是true还是false的条件。</p><p>从开发实践上，我们真正使用Cond的场景比较少，因为一旦遇到需要使用Cond的场景，我们更多地会使用Channel的方式（我会在第12和第13讲展开Channel的用法）去实现，因为那才是更地道的Go语言的写法，甚至Go的开发者有个“把Cond从标准库移除”的提议（<a href=\"https://github.com/golang/go/issues/21165\">issue 21165</a>）。而有的开发者认为，Cond是唯一难以掌握的Go并发原语。至于其中原因，我先卖个关子，到这一讲的后半部分我再和你解释。</p><p>今天，这一讲我们就带你仔细地学一学Cond这个并发原语吧。</p><h2>Cond的基本用法</h2><p>标准库中的Cond并发原语初始化的时候，需要关联一个Locker接口的实例，一般我们使用Mutex或者RWMutex。</p><p>我们看一下Cond的实现：</p><pre><code>type Cond\n  func NeWCond(l Locker) *Cond\n  func (c *Cond) Broadcast()\n  func (c *Cond) Signal()\n  func (c *Cond) Wait()\n</code></pre><p>首先，Cond关联的Locker实例可以通过c.L访问，它内部维护着一个先入先出的等待队列。</p><p>然后，我们分别看下它的三个方法Broadcast、Signal和Wait方法。</p><p><strong>Signal方法</strong>，允许调用者Caller唤醒一个等待此Cond的goroutine。如果此时没有等待的goroutine，显然无需通知waiter；如果Cond等待队列中有一个或者多个等待的goroutine，则需要从等待队列中移除第一个goroutine并把它唤醒。在其他编程语言中，比如Java语言中，Signal方法也被叫做notify方法。</p><p>调用Signal方法时，不强求你一定要持有c.L的锁。</p><p><strong>Broadcast方法</strong>，允许调用者Caller唤醒所有等待此Cond的goroutine。如果此时没有等待的goroutine，显然无需通知waiter；如果Cond等待队列中有一个或者多个等待的goroutine，则清空所有等待的goroutine，并全部唤醒。在其他编程语言中，比如Java语言中，Broadcast方法也被叫做notifyAll方法。</p><p>同样地，调用Broadcast方法时，也不强求你一定持有c.L的锁。</p><p><strong>Wait方法</strong>，会把调用者Caller放入Cond的等待队列中并阻塞，直到被Signal或者Broadcast的方法从等待队列中移除并唤醒。</p><p>调用Wait方法时必须要持有c.L的锁。</p><p>Go实现的sync.Cond的方法名是Wait、Signal和Broadcast，这是计算机科学中条件变量的<a href=\"https://en.wikipedia.org/wiki/Monitor_(synchronization)#Condition_variables_2\">通用方法名</a>。比如，C语言中对应的方法名是pthread_cond_wait、pthread_cond_signal和 pthread_cond_broadcast。</p><p>知道了Cond提供的三个方法后，我们再通过一个百米赛跑开始时的例子，来学习下<strong>Cond的使用方法</strong>。10个运动员进入赛场之后需要先做拉伸活动活动筋骨，向观众和粉丝招手致敬，在自己的赛道上做好准备；等所有的运动员都准备好之后，裁判员才会打响发令枪。</p><p>每个运动员做好准备之后，将ready加一，表明自己做好准备了，同时调用Broadcast方法通知裁判员。因为裁判员只有一个，所以这里可以直接替换成Signal方法调用。调用Broadcast方法的时候，我们并没有请求c.L锁，只是在更改等待变量的时候才使用到了锁。</p><p>裁判员会等待运动员都准备好（第22行）。虽然每个运动员准备好之后都唤醒了裁判员，但是裁判员被唤醒之后需要检查等待条件是否满足（<strong>运动员都准备好了</strong>）。可以看到，裁判员被唤醒之后一定要检查等待条件，如果条件不满足还是要继续等待。</p><pre><code>func main() {\n    c := sync.NewCond(&amp;sync.Mutex{})\n    var ready int\n\n    for i := 0; i &lt; 10; i++ {\n        go func(i int) {\n            time.Sleep(time.Duration(rand.Int63n(10)) * time.Second)\n\n            // 加锁更改等待条件\n            c.L.Lock()\n            ready++\n            c.L.Unlock()\n\n            log.Printf(&quot;运动员#%d 已准备就绪\\n&quot;, i)\n            // 广播唤醒所有的等待者\n            c.Broadcast()\n        }(i)\n    }\n\n    c.L.Lock()\n    for ready != 10 {\n        c.Wait()\n        log.Println(&quot;裁判员被唤醒一次&quot;)\n    }\n    c.L.Unlock()\n\n    //所有的运动员是否就绪\n    log.Println(&quot;所有运动员都准备就绪。比赛开始，3，2，1, ......&quot;)\n}\n</code></pre><p>你看，Cond的使用其实没那么简单。它的复杂在于：一，这段代码有时候需要加锁，有时候可以不加；二，Wait唤醒后需要检查条件；三，条件变量的更改，其实是需要原子操作或者互斥锁保护的。所以，有的开发者会认为，Cond是唯一难以掌握的Go并发原语。</p><p>我们继续看看Cond的实现原理。</p><h2>Cond的实现原理</h2><p>其实，Cond的实现非常简单，或者说复杂的逻辑已经被Locker或者runtime的等待队列实现了。我们直接看看Cond的源码吧。</p><pre><code>type Cond struct {\n    noCopy noCopy\n\n    // 当观察或者修改等待条件的时候需要加锁\n    L Locker\n\n    // 等待队列\n    notify  notifyList\n    checker copyChecker\n}\n\nfunc NewCond(l Locker) *Cond {\n    return &amp;Cond{L: l}\n}\n\nfunc (c *Cond) Wait() {\n    c.checker.check()\n    // 增加到等待队列中\n    t := runtime_notifyListAdd(&amp;c.notify)\n    c.L.Unlock()\n    // 阻塞休眠直到被唤醒\n    runtime_notifyListWait(&amp;c.notify, t)\n    c.L.Lock()\n}\n\nfunc (c *Cond) Signal() {\n    c.checker.check()\n    runtime_notifyListNotifyOne(&amp;c.notify)\n}\n\nfunc (c *Cond) Broadcast() {\n    c.checker.check()\n    runtime_notifyListNotifyAll(&amp;c.notify）\n}\n</code></pre><p>这部分源码确实很简单，我来带你学习下其中比较关键的逻辑。</p><p>runtime_notifyListXXX是运行时实现的方法，实现了一个等待/通知的队列。如果你想深入学习这部分，可以再去看看runtime/sema.go代码中。</p><p>copyChecker是一个辅助结构，可以在运行时检查Cond是否被复制使用。</p><p>Signal和Broadcast只涉及到notifyList数据结构，不涉及到锁。</p><p>Wait把调用者加入到等待队列时会释放锁，在被唤醒之后还会请求锁。在阻塞休眠期间，调用者是不持有锁的，这样能让其他goroutine有机会检查或者更新等待变量。</p><p>我们继续看看使用Cond常见的两个错误，一个是调用Wait的时候没有加锁，另一个是没有检查条件是否满足程序就继续执行了。</p><h2>使用Cond的2个常见错误</h2><p>我们先看<strong>Cond最常见的使用错误，也就是调用Wait的时候没有加锁</strong>。</p><p>以前面百米赛跑的程序为例，在调用cond.Wait时，把前后的Lock/Unlock注释掉，如下面的代码中的第20行和第25行：</p><pre><code>func main() {\n    c := sync.NewCond(&amp;sync.Mutex{})\n    var ready int\n\n    for i := 0; i &lt; 10; i++ {\n        go func(i int) {\n            time.Sleep(time.Duration(rand.Int63n(10)) * time.Second)\n\n            // 加锁更改等待条件\n            c.L.Lock()\n            ready++\n            c.L.Unlock()\n\n            log.Printf(&quot;运动员#%d 已准备就绪\\n&quot;, i)\n            // 广播唤醒所有的等待者\n            c.Broadcast()\n        }(i)\n    }\n\n    // c.L.Lock()\n    for ready != 10 {\n        c.Wait()\n        log.Println(&quot;裁判员被唤醒一次&quot;)\n    }\n    // c.L.Unlock()\n\n    //所有的运动员是否就绪\n    log.Println(&quot;所有运动员都准备就绪。比赛开始，3，2，1, ......&quot;)\n}\n</code></pre><p>再运行程序，就会报释放未加锁的panic：</p><p><img src=\"https://static001.geekbang.org/resource/image/47/76/4780dca40087277be0d183674bc42c76.jpeg?wh=877*367\" alt=\"\"></p><p>出现这个问题的原因在于，cond.Wait方法的实现是，把当前调用者加入到notify队列之中后会释放锁（如果不释放锁，其他Wait的调用者就没有机会加入到notify队列中了），然后一直等待；等调用者被唤醒之后，又会去争抢这把锁。如果调用Wait之前不加锁的话，就有可能Unlock一个未加锁的Locker。所以切记，<strong>调用cond.Wait方法之前一定要加锁</strong>。</p><p>使用Cond的另一个常见错误是，只调用了一次Wait，没有检查等待条件是否满足，结果条件没满足，程序就继续执行了。出现这个问题的原因在于，误以为Cond的使用，就像WaitGroup那样调用一下Wait方法等待那么简单。比如下面的代码中，把第21行和第24行注释掉：</p><pre><code>func main() {\n    c := sync.NewCond(&amp;sync.Mutex{})\n    var ready int\n\n    for i := 0; i &lt; 10; i++ {\n        go func(i int) {\n            time.Sleep(time.Duration(rand.Int63n(10)) * time.Second)\n\n            // 加锁更改等待条件\n            c.L.Lock()\n            ready++\n            c.L.Unlock()\n\n            log.Printf(&quot;运动员#%d 已准备就绪\\n&quot;, i)\n            // 广播唤醒所有的等待者\n            c.Broadcast()\n        }(i)\n    }\n\n    c.L.Lock()\n    // for ready != 10 {\n    c.Wait()\n    log.Println(&quot;裁判员被唤醒一次&quot;)\n    // }\n    c.L.Unlock()\n\n    //所有的运动员是否就绪\n    log.Println(&quot;所有运动员都准备就绪。比赛开始，3，2，1, ......&quot;)\n}\n</code></pre><p>运行这个程序，你会发现，可能只有几个运动员准备好之后程序就运行完了，而不是我们期望的所有运动员都准备好才进行下一步。原因在于，每一个运动员准备好之后都会唤醒所有的等待者，也就是这里的裁判员，比如第一个运动员准备好后就唤醒了裁判员，结果这个裁判员傻傻地没做任何检查，以为所有的运动员都准备好了，就继续执行了。</p><p>所以，我们一定要<strong>记住</strong>，waiter goroutine被唤醒<strong>不等于</strong>等待条件被满足，只是有goroutine把它唤醒了而已，等待条件有可能已经满足了，也有可能不满足，我们需要进一步检查。你也可以理解为，等待者被唤醒，只是得到了一次检查的机会而已。</p><p>到这里，我们小结下。如果你想在使用Cond的时候避免犯错，只要时刻记住调用cond.Wait方法之前一定要加锁，以及waiter goroutine被唤醒不等于等待条件被满足这两个知识点。</p><h2>知名项目中Cond的使用</h2><p>Cond在实际项目中被使用的机会比较少，原因总结起来有两个。</p><p>第一，同样的场景我们会使用其他的并发原语来替代。Go特有的Channel类型，有一个应用很广泛的模式就是通知机制，这个模式使用起来也特别简单。所以很多情况下，我们会使用Channel而不是Cond实现wait/notify机制。</p><p>第二，对于简单的wait/notify场景，比如等待一组goroutine完成之后继续执行余下的代码，我们会使用WaitGroup来实现。因为WaitGroup的使用方法更简单，而且不容易出错。比如，上面百米赛跑的问题，就可以很方便地使用WaitGroup来实现。</p><p>所以，我在这一讲开头提到，Cond的使用场景很少。先前的标准库内部有几个地方使用了Cond，比如io/pipe.go等，后来都被其他的并发原语（比如Channel）替换了，sync.Cond的路越走越窄。但是，还是有一批忠实的“粉丝”坚持在使用Cond，原因在于Cond有三点特性是Channel无法替代的：</p><ul>\n<li>Cond和一个Locker关联，可以利用这个Locker对相关的依赖条件更改提供保护。</li>\n<li>Cond可以同时支持Signal和Broadcast方法，而Channel只能同时支持其中一种。</li>\n<li>Cond的Broadcast方法可以被重复调用。等待条件再次变成不满足的状态后，我们又可以调用Broadcast再次唤醒等待的goroutine。这也是Channel不能支持的，Channel被close掉了之后不支持再open。</li>\n</ul><p>开源项目中使用sync.Cond的代码少之又少，包括标准库原先一些使用Cond的代码也改成使用Channel实现了，所以别说找Cond相关的使用Bug了，想找到的一个使用的例子都不容易，我找了Kubernetes中的一个例子，我们一起看看它是如何使用Cond的。</p><p>Kubernetes项目中定义了优先级队列 <a href=\"https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/internal/queue/scheduling_queue.go\">PriorityQueue</a> 这样一个数据结构，用来实现Pod的调用。它内部有三个Pod的队列，即activeQ、podBackoffQ和unschedulableQ，其中activeQ就是用来调度的活跃队列（heap）。</p><p>Pop方法调用的时候，如果这个队列为空，并且这个队列没有Close的话，会调用Cond的Wait方法等待。</p><p>你可以看到，调用Wait方法的时候，调用者是持有锁的，并且被唤醒的时候检查等待条件（队列是否为空）。</p><pre><code>// 从队列中取出一个元素\nfunc (p *PriorityQueue) Pop() (*framework.QueuedPodInfo, error) {\n\t\tp.lock.Lock()\n\t\tdefer p.lock.Unlock()\n\t\tfor p.activeQ.Len() == 0 { // 如果队列为空\n\t\t\tif p.closed {\n\t\t\t\treturn nil, fmt.Errorf(queueClosed)\n\t\t\t}\n\t\t\tp.cond.Wait() // 等待，直到被唤醒\n\t\t}\n\t\t......\n\t\treturn pInfo, err\n\t}\n\n</code></pre><p>当activeQ增加新的元素时，会调用条件变量的Boradcast方法，通知被Pop阻塞的调用者。</p><pre><code>// 增加元素到队列中\nfunc (p *PriorityQueue) Add(pod *v1.Pod) error {\n\t\tp.lock.Lock()\n\t\tdefer p.lock.Unlock()\n\t\tpInfo := p.newQueuedPodInfo(pod)\n\t\tif err := p.activeQ.Add(pInfo); err != nil {//增加元素到队列中\n\t\t\tklog.Errorf(&quot;Error adding pod %v to the scheduling queue: %v&quot;, nsNameForPod(pod), err)\n\t\t\treturn err\n\t\t}\n\t\t......\n\t\tp.cond.Broadcast() //通知其它等待的goroutine，队列中有元素了\n\n\t\treturn nil\n\t}\n</code></pre><p>这个优先级队列被关闭的时候，也会调用Broadcast方法，避免被Pop阻塞的调用者永远hang住。</p><pre><code>func (p *PriorityQueue) Close() {\n\t\tp.lock.Lock()\n\t\tdefer p.lock.Unlock()\n\t\tclose(p.stop)\n\t\tp.closed = true\n\t\tp.cond.Broadcast() //关闭时通知等待的goroutine，避免它们永远等待\n}\n</code></pre><p>你可以思考一下，这里为什么使用Cond这个并发原语，能不能换成Channel实现呢？</p><h2>总结</h2><p>好了，我们来做个总结。</p><p>Cond是为等待/通知场景下的并发问题提供支持的。它提供了条件变量的三个基本方法Signal、Broadcast和Wait，为并发的goroutine提供等待/通知机制。</p><p>在实践中，处理等待/通知的场景时，我们常常会使用Channel替换Cond，因为Channel类型使用起来更简洁，而且不容易出错。但是对于需要重复调用Broadcast的场景，比如上面Kubernetes的例子，每次往队列中成功增加了元素后就需要调用Broadcast通知所有的等待者，使用Cond就再合适不过了。</p><p>使用Cond之所以容易出错，就是Wait调用需要加锁，以及被唤醒后一定要检查条件是否真的已经满足。你需要牢记这两点。</p><p>虽然我们讲到的百米赛跑的例子，也可以通过WaitGroup来实现，但是本质上WaitGroup和Cond是有区别的：WaitGroup是主goroutine等待确定数量的子goroutine完成任务；而Cond是等待某个条件满足，这个条件的修改可以被任意多的goroutine更新，而且Cond的Wait不关心也不知道其他goroutine的数量，只关心等待条件。而且Cond还有单个通知的机制，也就是Signal方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/47/5d/477157d2dbe1b7e4511f56c2c9c2105d.jpg?wh=2251*1332\" alt=\"\"></p><h2>思考题</h2><ol>\n<li>一个Cond的waiter被唤醒的时候，为什么需要再检查等待条件，而不是唤醒后进行下一步？</li>\n<li>你能否利用Cond实现一个容量有限的queue？</li>\n</ol><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","comments":[{"had_liked":false,"id":256933,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1603787358,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"121862871646","product_id":100061801,"comment_content":"思考题：<br>1. 唤醒的方式有broadcast，第N个waiter被唤醒后需要检查等待条件，因为不知道前N-1个被唤醒的waiter所作的修改是否使等待条件再次成立。<br>2. 以下是我实现的一个，有限容量Queue，欢迎讨论！<br>https:&#47;&#47;play.studygolang.com&#47;p&#47;11K2iPVYErn<br><br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;math&#47;rand&quot;<br>\t&quot;strings&quot;<br>\t&quot;sync&quot;<br>)<br><br>type Queue struct {<br>\tcond *sync.Cond<br>\tdata []interface{}<br>\tcapc int<br>\tlogs []string<br>}<br><br>func NewQueue(capacity int) *Queue {<br>\treturn &amp;Queue{cond: &amp;sync.Cond{L: &amp;sync.Mutex{}}, data: make([]interface{}, 0), capc: capacity, logs: make([]string, 0)}<br>}<br><br>func (q *Queue) Enqueue(d interface{}) {<br>\tq.cond.L.Lock()<br>\tdefer q.cond.L.Unlock()<br><br>\tfor len(q.data) == q.capc {<br>\t\tq.cond.Wait()<br>\t}<br>\t&#47;&#47; FIFO入队<br>\tq.data = append(q.data, d)<br>\t&#47;&#47; 记录操作日志<br>\tq.logs = append(q.logs, fmt.Sprintf(&quot;En %v\\n&quot;, d))<br>\t&#47;&#47; 通知其他waiter进行Dequeue或Enqueue操作<br>\tq.cond.Broadcast()<br><br>}<br><br>func (q *Queue) Dequeue() (d interface{}) {<br>\tq.cond.L.Lock()<br>\tdefer q.cond.L.Unlock()<br><br>\tfor len(q.data) == 0 {<br>\t\tq.cond.Wait()<br>\t}<br>\t&#47;&#47; FIFO出队<br>\td = q.data[0]<br>\tq.data = q.data[1:]<br>\t&#47;&#47; 记录操作日志<br>\tq.logs = append(q.logs, fmt.Sprintf(&quot;De %v\\n&quot;, d))<br>\t&#47;&#47; 通知其他waiter进行Dequeue或Enqueue操作<br>\tq.cond.Broadcast()<br>\treturn<br>}<br><br>func (q *Queue) Len() int {<br>\tq.cond.L.Lock()<br>\tdefer q.cond.L.Unlock()<br>\treturn len(q.data)<br>}<br><br>func (q *Queue) String() string {<br>\tvar b strings.Builder<br>\tfor _, log := range q.logs {<br>\t\t&#47;&#47;fmt.Fprint(&amp;b, log)<br>\t\tb.WriteString(log)<br>\t}<br>\treturn b.String()<br>}","like_count":29,"discussions":[{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382775,"discussion_content":"噢，那是 for len(q.data) == q.capc ，我看成 if len(q.data) == q.capc 了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625718011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382760,"discussion_content":"老哥，wait 之后不用检查了吗？比如现在有两个入队列操作在等待，一个出队列会 Broadcast()，那这两个入队列的操作是不是同时被唤醒了，然后都执行添加操作就超长度啦？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625714355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1628736,"avatar":"https://static001.geekbang.org/account/avatar/00/18/da/40/bda5ad2b.jpg","nickname":"ChuanBing จุ๊บ","note":"","ucode":"4482E852FC147A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385985,"discussion_content":"wait 唤醒后, 会lock, 就算多个goroutine 被同时唤醒, 但是只有一个能够获取到锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627372304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":382760,"ip_address":""},"score":385985,"extra":""}]}]},{"had_liked":false,"id":256566,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1603679567,"is_pvip":false,"replies":[{"id":"93485","content":"是的","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603758891,"ip_address":"","comment_id":256566,"utype":1}],"discussion_count":1,"race_medal":1,"score":"44553352527","product_id":100061801,"comment_content":"老师，上节课你提到noCopy，是一个辅助的、用来帮助 vet 检查用的类型，而Cond还有个copyChecker 是一个辅助结构，可以在运行时检查 Cond 是否被复制使用。<br><br>nocpoy是静态检查，copyChecker是运行时检查，不是理解是否正确？<br><br>另外不是是否有其他区别呢？","like_count":10,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508055,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603758891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258297,"user_name":"SuperDai","can_delete":false,"product_type":"c1","uid":1289318,"ip_address":"","ucode":"0CA86D253754CA","user_header":"https://static001.geekbang.org/account/avatar/00/13/ac/66/a256008b.jpg","comment_is_top":false,"comment_ctime":1604374390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18784243574","product_id":100061801,"comment_content":"上一个自己的实现<br><br>package caplimitqueue<br><br>import (<br>\t&quot;sync&quot;<br><br>\t&quot;github.com&#47;gammazero&#47;deque&quot;<br>)<br><br>&#47;&#47; CapLimitQueue 限容队列<br>type CapLimitQueue struct {<br>\tcond *sync.Cond<br>\tq    deque.Deque<br>\tcap  int<br>}<br><br>&#47;&#47; NewCapLimitQueue 返回CapLimitQueue实例.<br>func NewCapLimitQueue(cap int) *CapLimitQueue {<br>\tif cap == 0 {<br>\t\tcap = 64<br>\t}<br>\tq := &amp;CapLimitQueue{<br>\t\tcap: cap,<br>\t}<br>\tq.cond = sync.NewCond(&amp;sync.Mutex{})<br>\treturn q<br>}<br><br>&#47;&#47; Push 往限容队列添加数据对象.<br>func (q *CapLimitQueue) Push(elem interface{}) {<br>\tq.cond.L.Lock()<br>\tfor q.q.Len() &gt;= q.cap {<br>\t\t&#47;&#47; (1) 队列已满, 等待消费goroutine取出数据对象.<br>\t\tq.cond.Wait()<br>\t}<br>\tdefer q.cond.L.Unlock()<br><br>\tq.q.PushBack(elem)<br>\t&#47;&#47; (2) 通知消费goroutine已有数据对象进队列 -&gt; (3)<br>\tq.cond.Broadcast()<br>}<br><br>&#47;&#47; Pop 从限容队列取出数据对象.<br>func (q *CapLimitQueue) Pop(want int) []interface{} {<br>\tq.cond.L.Lock()<br>\tfor q.q.Len() == 0 {<br>\t\t&#47;&#47; (3) 队列为空, 等待生产goroutine添加数据对象.<br>\t\tq.cond.Wait()<br>\t}<br>\tdefer q.cond.L.Unlock()<br><br>\tif want &gt; q.q.Len() {<br>\t\twant = q.q.Len()<br>\t}<br>\toutput := make([]interface{}, want)<br>\tfor i := 0; i &lt; want; i++ {<br>\t\toutput[i] = q.q.PopFront()<br>\t}<br>\t&#47;&#47; (4) 通知生产goroutine已有数据对象出队列 -&gt; (1)<br>\tq.cond.Broadcast()<br><br>\treturn output<br>}<br><br>&#47;&#47; Len 返回限容队列当前长度.<br>func (q *CapLimitQueue) Len() int {<br>\tq.cond.L.Lock()<br>\tdefer q.cond.L.Unlock()<br>\treturn q.q.Len()<br>}<br>","like_count":4},{"had_liked":false,"id":256642,"user_name":"Junes","can_delete":false,"product_type":"c1","uid":1354665,"ip_address":"","ucode":"CD2E829C868970","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/a9/590d6f02.jpg","comment_is_top":false,"comment_ctime":1603695110,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14488596998","product_id":100061801,"comment_content":"1. 是否需要等待，是看业务实现的需求吧：<br>每个caller会唤醒一个或者所有的waiter<br>caller和waiter的数量对应是不确定的，如N:M<br>waiter唤醒后的处理逻辑是自己决定的，比如示例中的ready和队列长度<br><br>2. 有长度限制的队列，代码可以参考示例中的PriorityQueue<br>Push入队Broadcast，Pop出队Wait<br>队列长度有限制的话，在Dueue中维护一个变量size，当前队列长度大于等于size时，Push操作直接返回错误<br>改造：如果希望Dueue满时Push操作阻塞，可以在Push用个Wait来阻塞，收到Broadcast后，检测到当前队列小于size就Push<br>附上一块伪代码<br><br>&#47;&#47; 从队列中取出一个元素<br>func (p *Dueue) Pop() (interface{}, error) {<br>\tp.lock.Lock()<br>\tdefer p.lock.Unlock()<br><br>\t&#47;&#47; 如果队列为空,等待，直到被唤醒<br>\tfor p.queue.Len() == 0 {<br>\t\tp.cond.Wait()<br>\t}<br>\treturn p.queue.Pop()<br>}<br><br>&#47;&#47; 增加元素到队列中(非阻塞方式)<br>func (p *Dueue) Push(e interface{}) error {<br>\tp.lock.Lock()<br>\tdefer p.lock.Unlock()<br><br>\t&#47;&#47; 如果队列满了，直接返回error(阻塞改造：在Pop中添加个Broadcast方法，这里改造成for循环进行wait)<br>\tif p.queue.Len() &gt;= p.maxSize {<br>\t\treturn fmt.Errorf(&quot;over size&quot;)<br>\t}<br><br>\t&#47;&#47; 把元素加入到队列后，通知所有的waiter<br>\tp.queue.Push(e)<br>\tp.cond.Broadcast()<br>\treturn nil<br>}<br>","like_count":3,"discussions":[{"author":{"id":1187021,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","nickname":"Gojustforfun","note":"","ucode":"7513A40F27344F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318368,"discussion_content":"Push在发生错误时，无法调用p.cond.Broadcast()，错误只是当前时刻不能Push数据，但是通知其他waiter调用Pop后，再次重试Push就会成功。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603718634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257082,"user_name":"myrfy","can_delete":false,"product_type":"c1","uid":1169401,"ip_address":"","ucode":"2814BAE5D70098","user_header":"","comment_is_top":false,"comment_ctime":1603849256,"is_pvip":false,"replies":[{"id":"93637","content":"因为需要重用，使用chan close后没法重用了","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603895168,"ip_address":"","comment_id":257082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10193783848","product_id":100061801,"comment_content":"还是没有想明白k8s为什么不能用channel通知<br>close可以实现broadcast的功效，在pop的时候，也是只有一个goroutine可以拿到数据，感觉除了关闭队列之外，不存在需要broadcast的情况。也就是感觉不需要多次broadcast，这样channel应该是满足要求的……请老师明示","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508212,"discussion_content":"因为需要重用，使用chan close后没法重用了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603895168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329604,"user_name":"chongsheng","can_delete":false,"product_type":"c1","uid":1368768,"ip_address":"","ucode":"859DF328FCA608","user_header":"https://static001.geekbang.org/account/avatar/00/14/e2/c0/e7a59706.jpg","comment_is_top":false,"comment_ctime":1641443111,"is_pvip":false,"replies":[{"id":"120084","content":"👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1641479136,"ip_address":"","comment_id":329604,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5936410407","product_id":100061801,"comment_content":"关于Cond还有一种会不小心误用的场景，因为一些原因导致Wait执行的时候，Signal&#47;Broadcast就已经执行完了，导致Wait一直等待无法唤醒。比如这里的例子<br>https:&#47;&#47;stackoverflow.com&#47;questions&#47;36857167&#47;how-to-correctly-use-sync-cond","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544347,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641479137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262868,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1605863784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5900831080","product_id":100061801,"comment_content":"打卡","like_count":1},{"had_liked":false,"id":259809,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1604845126,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5899812422","product_id":100061801,"comment_content":"第一个思考题其实不难，其他goroutine只是ready++后唤醒，如果等待的主goroutine不检查条件变量，主goroutine在第一次唤醒时就继续执行了！也就体现不出条件变量的“条件”了","like_count":1,"discussions":[{"author":{"id":1529249,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/a1/e77b9612.jpg","nickname":"峪五","note":"","ucode":"DCF2DC959D0CD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327036,"discussion_content":"鸟窝说的是 c.checker.check()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605715688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1056807,"avatar":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","nickname":"虢國技醬","note":"","ucode":"5A192262AA037E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322937,"discussion_content":"补充：ready=1时主goroutine就继续执行了，但我们其实是想让它=10；这其实也是把条件变量的条件交给使用的人来控制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604845360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257207,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1603882043,"is_pvip":false,"discussion_count":1,"race_medal":2,"score":"5898849339","product_id":100061801,"comment_content":"文章虽然看明白了，但是要完成思考题还是有一定的难度的。<br>","like_count":1,"discussions":[{"author":{"id":1137757,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5c/5d/bf418037.jpg","nickname":"David","note":"","ucode":"3DC0B0F86F7D39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358821,"discussion_content":"西安罗杰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616055966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256894,"user_name":"moooofly","can_delete":false,"product_type":"c1","uid":1008348,"ip_address":"","ucode":"4A20795C281B6F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","comment_is_top":false,"comment_ctime":1603778951,"is_pvip":false,"replies":[{"id":"93504","content":"你第一句给出了答案。分别应用不同阶段","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603793503,"ip_address":"","comment_id":256894,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5898746247","product_id":100061801,"comment_content":"请教一个问题，nocpoy 是用于 vet 静态检查，copyChecker 是为了运行时检查，都是为了检查 copy 问题，为啥 Cond 要在两处检查，而 Mutex 只需要一处？","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508157,"discussion_content":"你第一句给出了答案。分别应用不同阶段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603793503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318766,"discussion_content":"可能我问的不够清楚，我换个说法，Mutex为何不需要运行时检查，而 Cond 却需要？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603846917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256811,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1603758401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898725697","product_id":100061801,"comment_content":"第一题的答案应该应该还包括spurious wakeup的因素","like_count":1},{"had_liked":false,"id":358265,"user_name":"Geek_b45293","can_delete":false,"product_type":"c1","uid":3185034,"ip_address":"北京","ucode":"17E6EAD66A8F4E","user_header":"","comment_is_top":false,"comment_ctime":1664156192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664156192","product_id":100061801,"comment_content":"有个问题，为什么 Mutex 不使用 copyChecker 来检测是否被复制呢？","like_count":0},{"had_liked":false,"id":329603,"user_name":"chongsheng","can_delete":false,"product_type":"c1","uid":1368768,"ip_address":"","ucode":"859DF328FCA608","user_header":"https://static001.geekbang.org/account/avatar/00/14/e2/c0/e7a59706.jpg","comment_is_top":false,"comment_ctime":1641443029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641443029","product_id":100061801,"comment_content":"关于Cond还有一种不小心误用的场景，就是在Wait()调用之前，Signal&#47;Broadcast就执行完了，导致一直Wait()。比如这里的例子","like_count":0},{"had_liked":false,"id":319755,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1635929517,"is_pvip":true,"replies":[{"id":"117245","content":"对","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1637681981,"ip_address":"","comment_id":319755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635929517","product_id":100061801,"comment_content":"文章中在描述 Cond 的复杂性时，说明了 3 点，第三点：「条件变量的更改」 是否可需改为：「等待条件的更改」？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532778,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637681981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317099,"user_name":"徐改","can_delete":false,"product_type":"c1","uid":1298380,"ip_address":"","ucode":"82276A584AC602","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","comment_is_top":false,"comment_ctime":1634688512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634688512","product_id":100061801,"comment_content":"关于思考题2：<br>我使用了环形队列，用来避免线性队列队满情况下因数据搬移而带来的时间开销:<br>&#47; 环形队列，实现阻塞、通知机制<br>func (queue *PriorityQueue) Add(v interface{}) {<br>\tqueue.cond.L.Lock()<br>\tdefer queue.cond.L.Unlock()<br>\t&#47;&#47; 判断队满<br>\tif (queue.tail + 1) % cap(queue.item) == queue.head {<br>\t\tfmt.Println(&quot;生产者被阻塞&quot;)<br>\t\tqueue.cond.Wait()<br>\t\tfmt.Println(&quot;生产者被唤醒&quot;)<br>\t}<br>\tfmt.Println(&quot;生产者生产数据&quot;)<br>\tqueue.item[queue.tail] = v<br>\tqueue.tail = (queue.tail + 1) % cap(queue.item)<br>\tqueue.cond.Broadcast()<br>}<br><br>func (queue *PriorityQueue) Pop() interface{} {<br>\tqueue.cond.L.Lock()<br>\tdefer queue.cond.L.Unlock()<br>\t&#47;&#47; 判断队空<br>\tif queue.tail == queue.head {<br>\t\tfmt.Println(&quot;消费者被阻塞&quot;)<br>\t\tqueue.cond.Wait()<br>\t\tfmt.Println(&quot;消费者被唤醒&quot;)<br>\t}<br>\tfmt.Println(&quot;消费者消费数据&quot;)<br>\tv := queue.item[queue.head]<br>\tqueue.head = (queue.head + 1) % cap(queue.item)<br>\tqueue.cond.Broadcast()<br>\treturn v<br>}","like_count":0},{"had_liked":false,"id":313460,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1241621,"ip_address":"","ucode":"57C92E14FF8F24","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/15/c5be3083.jpg","comment_is_top":false,"comment_ctime":1632451382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632451382","product_id":100061801,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;sync&quot;<br>\t&quot;time&quot;<br><br>\t&quot;go.uber.org&#47;atomic&quot;<br>)<br><br>type CondQue struct {<br>\tc    *sync.Cond<br>\tsize int<br>\tlist []int<br>}<br><br>func NewCondQue(size int) *CondQue {<br>\treturn &amp;CondQue{size: size, c: sync.NewCond(&amp;sync.Mutex{})}<br>}<br><br>func (q *CondQue) Add(item int) {<br>\tq.c.L.Lock()<br>\tdefer q.c.L.Unlock()<br>\tfor len(q.list) &gt;= q.size { &#47;&#47; 当前队列长度已满<br>\t\tq.c.Wait() &#47;&#47; 等待<br>\t\tfmt.Printf(&quot;wait for add:%v\\n&quot;, item)<br>\t}<br>\tq.list = append(q.list, item)<br>\tq.c.Broadcast()<br>\tfmt.Printf(&quot;add:%v cur len:%v\\n&quot;, item, len(q.list))<br>}<br><br>func (q *CondQue) Pop() int {<br>\tq.c.L.Lock()<br>\tdefer q.c.L.Unlock()<br>\tfor len(q.list) &lt;= 0 { &#47;&#47; 当前队列长度已空<br>\t\tq.c.Wait() &#47;&#47; 等待<br>\t\tfmt.Printf(&quot;wait for pop\\n&quot;)<br>\t}<br><br>\titem := q.list[0]<br>\tq.list = q.list[1:]<br>\tfmt.Printf(&quot;pop:%v cur len:%v\\n&quot;, item, len(q.list))<br>\treturn item<br>}<br><br>func main() {<br>\tcond := NewCondQue(2)<br>\tvar g atomic.Int32<br>\tfor i := 0; i &lt; 3; i++ {<br>\t\tgo func() {<br>\t\t\tfor {<br>\t\t\t\tg.Add(1)<br>\t\t\t\tcond.Add(int(g.Load()))<br>\t\t\t\ttime.Sleep(time.Second * 1)<br>\t\t\t}<br>\t\t}()<br>\t}<br>\tfor i := 0; i &lt; 2; i++ {<br>\t\tgo func() {<br>\t\t\tfor {<br>\t\t\t\t_ = cond.Pop()<br>\t\t\t\ttime.Sleep(time.Millisecond * 500)<br>\t\t\t}<br>\t\t}()<br>\t}<br>\ttime.Sleep(time.Second * 10)<br>}<br>","like_count":0},{"had_liked":false,"id":303933,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1627107136,"is_pvip":true,"replies":[{"id":"110318","content":"那你locker就永远没释放呗","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1627730803,"ip_address":"","comment_id":303933,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1627107136","product_id":100061801,"comment_content":"老师请教一个问题，如果Wait前加锁，然后执行完Wait又Unlock有什么作用，我把Wait后面的Unlock去掉，好似程序也能正常运行。是我漏了什么？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523879,"discussion_content":"那你locker就永远没释放呗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627730803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301489,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1625713687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625713687","product_id":100061801,"comment_content":"想问老师，为什么 ready 在 Wait 之后处理，会有死锁的时候发生？<br>c.L.Lock()<br>for ready != 10 {<br>\tc.Wait()<br>\tready ++<br>\tfmt.Println(&quot;裁判员被唤醒&quot;,ready)<br>}<br>c.L.Unlock()<br>","like_count":0},{"had_liked":false,"id":293623,"user_name":"小虾米","can_delete":false,"product_type":"c1","uid":1005528,"ip_address":"","ucode":"F543987A7FAB20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/d8/425e1b0a.jpg","comment_is_top":false,"comment_ctime":1621470113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621470113","product_id":100061801,"comment_content":"如果在执行    runtime_notifyListWait(&amp;c.notify, t)之前有其他协程broadcast了，会不会永远不会醒来了？","like_count":0},{"had_liked":false,"id":267225,"user_name":"臭猫","can_delete":false,"product_type":"c1","uid":1313181,"ip_address":"","ucode":"5C3D1ED80055B7","user_header":"https://static001.geekbang.org/account/avatar/00/14/09/9d/8af6cb1e.jpg","comment_is_top":false,"comment_ctime":1607654109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607654109","product_id":100061801,"comment_content":"k8s里，p.lock.Lock() 这个在wait之前的锁，并不是p.cock.L.Lock()，这样不会有问题？","like_count":0},{"had_liked":false,"id":264988,"user_name":"Eirture","can_delete":false,"product_type":"c1","uid":1308178,"ip_address":"","ucode":"49EC3830989464","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/12/19914d72.jpg","comment_is_top":false,"comment_ctime":1606729220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606729220","product_id":100061801,"comment_content":"简单的实现：<br><br>https:&#47;&#47;play.golang.org&#47;p&#47;GqwFSz_F7nL<br>","like_count":0},{"had_liked":false,"id":263250,"user_name":"hetiu","can_delete":false,"product_type":"c1","uid":1056127,"ip_address":"","ucode":"35D9338C3ABD20","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/7f/aabc1b66.jpg","comment_is_top":false,"comment_ctime":1606058836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606058836","product_id":100061801,"comment_content":"如果wait要支持timeout，只能用channel和context了吧？","like_count":0},{"had_liked":false,"id":257963,"user_name":"网管","can_delete":false,"product_type":"c1","uid":1176852,"ip_address":"","ucode":"608175DF616365","user_header":"https://static001.geekbang.org/account/avatar/00/11/f5/14/92b373dd.jpg","comment_is_top":false,"comment_ctime":1604226224,"is_pvip":false,"replies":[{"id":"94058","content":"有锁，看方法第一二行","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604369601,"ip_address":"","comment_id":257963,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604226224","product_id":100061801,"comment_content":"老师，Kubernetes  PriorityQueue的那个Pop方法里没有使用p.cond.L.Lock()方法，他们是怎么防止不出现释放未加锁的panic啊。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508510,"discussion_content":"有锁，看方法第一二行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604369601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257069,"user_name":"S.S Mr Lin","can_delete":false,"product_type":"c1","uid":1258558,"ip_address":"","ucode":"1DDD5132B0DA64","user_header":"https://static001.geekbang.org/account/avatar/00/13/34/3e/0b1c2b7f.jpg","comment_is_top":false,"comment_ctime":1603847371,"is_pvip":false,"replies":[{"id":"93593","content":"放在外面的原因是可以利用锁保护共享数据的读写。wait总是需要锁","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603862045,"ip_address":"","comment_id":257069,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603847371","product_id":100061801,"comment_content":"每次调用wait前都要加锁，为啥加锁语句放在了fo的外面？第二次wait是不是就没有加锁了？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508207,"discussion_content":"放在外面的原因是可以利用锁保护共享数据的读写。wait总是需要锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603862045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256874,"user_name":"会飞的大象","can_delete":false,"product_type":"c1","uid":1520299,"ip_address":"","ucode":"080A36D971E6CF","user_header":"https://static001.geekbang.org/account/avatar/00/17/32/ab/272af78e.jpg","comment_is_top":false,"comment_ctime":1603770303,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1603770303","product_id":100061801,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":256699,"user_name":"syuan","can_delete":false,"product_type":"c1","uid":1215879,"ip_address":"","ucode":"D9BBC2ADAB5F2E","user_header":"https://static001.geekbang.org/account/avatar/00/12/8d/87/47d95f4a.jpg","comment_is_top":false,"comment_ctime":1603710665,"is_pvip":false,"replies":[{"id":"93487","content":"因为会被唤醒，唤醒之后如果条件还不满足，又会被加入到等待队列中","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603759006,"ip_address":"","comment_id":256699,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603710665","product_id":100061801,"comment_content":"Wait 方法，会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。<br>百米跑代码第22行:    c.Wait(),把调用者加入队列阻塞，不理解? for循环一直检查，是把c一直加入阻塞队列吗？还是waiter方法自已生成t对象加入阻塞队列？如果是，同一个c对应t( t := runtime_notifyListAdd(&amp;c.notify)对象唯一吗？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508087,"discussion_content":"因为会被唤醒，唤醒之后如果条件还不满足，又会被加入到等待队列中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603759006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256666,"user_name":"儿戏","can_delete":false,"product_type":"c1","uid":1133809,"ip_address":"","ucode":"02956B19F65C7A","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/f1/8dc266ee.jpg","comment_is_top":false,"comment_ctime":1603700477,"is_pvip":false,"replies":[{"id":"93480","content":"看cpu,带宽，看cancen是不是超时导致的，设大超时时间，看pprof","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603754526,"ip_address":"","comment_id":256666,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603700477","product_id":100061801,"comment_content":"老师，请教个课程外的问题，使用httputil.ReverseProxy 做方向代理，压测的时候大量报出 http: proxy error: context canceled 这个错误。linux 打开文件数调整了，time_waite也都优化过了，一直没有找到问题，您的博客也看了还是不能定位，求赐教","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508077,"discussion_content":"看cpu,带宽，看cancen是不是超时导致的，设大超时时间，看pprof","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603754526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256594,"user_name":"RRR","can_delete":false,"product_type":"c1","uid":1014991,"ip_address":"","ucode":"F32A579D201EC5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/cf/d5382404.jpg","comment_is_top":false,"comment_ctime":1603686720,"is_pvip":false,"replies":[{"id":"93409","content":"两者的同步原语都是独立实现的，没有可比性。从功能上来说，cond和java notify&#47;wait机制是类似的，其它语言也有对应的同步原语","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603699478,"ip_address":"","comment_id":256594,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603686720","product_id":100061801,"comment_content":"感觉 Cond 是不是和 Java 中的 notify &#47; wait 机制对应而存在的呢？Golang 和 Java 的异步模式最大的区别是不是就在这里呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508065,"discussion_content":"两者的同步原语都是独立实现的，没有可比性。从功能上来说，cond和java notify/wait机制是类似的，其它语言也有对应的同步原语","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603699478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256591,"user_name":"牛晓东","can_delete":false,"product_type":"c1","uid":1607074,"ip_address":"","ucode":"75E08C8AE039BC","user_header":"https://static001.geekbang.org/account/avatar/00/18/85/a2/4d16e2cf.jpg","comment_is_top":false,"comment_ctime":1603685917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603685917","product_id":100061801,"comment_content":"咱们本节课有很多图片，链接……这句话好想写成一个公开的函数，需要的时候调一下😃😃<br>老师真的很细心，每次都提醒以达到最佳效果👍👍👍","like_count":0},{"had_liked":false,"id":256563,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1603679176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603679176","product_id":100061801,"comment_content":"打卡。","like_count":0}]}