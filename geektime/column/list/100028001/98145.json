{"id":98145,"title":"05 | ArrayList还是LinkedList？使用不当性能差千倍","content":"<p>你好，我是刘超。</p><p>集合作为一种存储数据的容器，是我们日常开发中使用最频繁的对象类型之一。JDK为开发者提供了一系列的集合类型，这些集合类型使用不同的数据结构来实现。因此，不同的集合类型，使用场景也不同。</p><p>很多同学在面试的时候，经常会被问到集合的相关问题，比较常见的有ArrayList和LinkedList的区别。</p><p>相信大部分同学都能回答上：“ArrayList是基于数组实现，LinkedList是基于链表实现。”</p><p>而在回答使用场景的时候，我发现大部分同学的答案是：<span class=\"orange\">“ArrayList和LinkedList在新增、删除元素时，LinkedList的效率要高于 ArrayList，而在遍历的时候，ArrayList的效率要高于LinkedList。”</span>这个回答是否准确呢？今天这一讲就带你验证。</p><h2>初识List接口</h2><p>在学习List集合类之前，我们先来通过这张图，看下List集合类的接口和类的实现关系：</p><p><img src=\"https://static001.geekbang.org/resource/image/54/09/54f564eb63a2c74723a82540668fc009.jpg?wh=1000x1001\" alt=\"\"></p><p>我们可以看到ArrayList、Vector、LinkedList集合类继承了AbstractList抽象类，而AbstractList实现了List接口，同时也继承了AbstractCollection抽象类。ArrayList、Vector、LinkedList又根据自我定位，分别实现了各自的功能。</p><!-- [[[read_end]]] --><p>ArrayList和Vector使用了数组实现，这两者的实现原理差不多，LinkedList使用了双向链表实现。基础铺垫就到这里，接下来，我们就详细地分析下ArrayList和LinkedList的源码实现。</p><h2>ArrayList是如何实现的？</h2><p>ArrayList很常用，先来几道测试题，自检下你对ArrayList的了解程度。</p><p><strong>问题1：</strong>我们在查看ArrayList的实现类源码时，你会发现对象数组elementData使用了transient修饰，我们知道transient关键字修饰该属性，则表示该属性不会被序列化，然而我们并没有看到文档中说明ArrayList不能被序列化，这是为什么？</p><p><strong>问题2：</strong>我们在使用ArrayList进行新增、删除时，经常被提醒“使用ArrayList做新增删除操作会影响效率”。那是不是ArrayList在大量新增元素的场景下效率就一定会变慢呢？</p><p><strong>问题3：</strong>如果让你使用for循环以及迭代循环遍历一个ArrayList，你会使用哪种方式呢？原因是什么？</p><p>如果你对这几道测试都没有一个全面的了解，那就跟我一起从数据结构、实现原理以及源码角度重新认识下ArrayList吧。</p><h3>1.ArrayList实现类</h3><p>ArrayList实现了List接口，继承了AbstractList抽象类，底层是数组实现的，并且实现了自增扩容数组大小。</p><p>ArrayList还实现了Cloneable接口和Serializable接口，所以他可以实现克隆和序列化。</p><p>ArrayList还实现了RandomAccess接口。你可能对这个接口比较陌生，不知道具体的用处。通过代码我们可以发现，这个接口其实是一个空接口，什么也没有实现，那ArrayList为什么要去实现它呢？</p><p>其实RandomAccess接口是一个标志接口，他标志着“只要实现该接口的List类，都能实现快速随机访问”。</p><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable\n</code></pre><h3>2.ArrayList属性</h3><p>ArrayList属性主要由数组长度size、对象数组elementData、初始化容量default_capacity等组成， 其中初始化容量默认大小为10。</p><pre><code>  //默认初始化容量\n    private static final int DEFAULT_CAPACITY = 10;\n    //对象数组\n    transient Object[] elementData; \n    //数组长度\n    private int size;\n</code></pre><p>从ArrayList属性来看，它没有被任何的多线程关键字修饰，但elementData被关键字transient修饰了。这就是我在上面提到的第一道测试题：transient关键字修饰该字段则表示该属性不会被序列化，但ArrayList其实是实现了序列化接口，这到底是怎么回事呢？</p><p>这还得从“ArrayList是基于数组实现“开始说起，由于ArrayList的数组是基于动态扩增的，所以并不是所有被分配的内存空间都存储了数据。</p><p>如果采用外部序列化法实现数组的序列化，会序列化整个数组。ArrayList为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法writeObject以及readObject来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。</p><p>因此使用transient修饰数组，是防止对象数组被其他外部方法序列化。</p><h3>3.ArrayList构造函数</h3><p>ArrayList类实现了三个构造函数，第一个是创建ArrayList对象时，传入一个初始化值；第二个是默认创建一个空数组对象；第三个是传入一个集合类型进行初始化。</p><p>当ArrayList新增元素时，如果所存储的元素已经超过其已有大小，它会计算元素大小后再进行动态扩容，数组的扩容会导致整个数组进行一次内存复制。因此，我们在初始化ArrayList时，可以通过第一个构造函数合理指定数组初始大小，这样有助于减少数组的扩容次数，从而提高系统性能。</p><pre><code> public ArrayList(int initialCapacity) {\n        //初始化容量不为零时，将根据初始化值创建数组大小\n        if (initialCapacity &gt; 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始化容量为零时，使用默认的空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+\n                                               initialCapacity);\n        }\n    }\n\n    public ArrayList() {\n        //初始化默认为空数组\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n</code></pre><h3>4.ArrayList新增元素</h3><p>ArrayList新增元素的方法有两种，一种是直接将元素加到数组的末尾，另外一种是添加元素到任意位置。</p><pre><code> public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n</code></pre><p>两个方法的相同之处是在添加元素之前，都会先确认容量大小，如果容量够大，就不用进行扩容；如果容量不够大，就会按照原来数组的1.5倍大小进行扩容，在扩容之后需要将数组复制到新分配的内存地址。</p><pre><code>  private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length &gt; 0)\n            grow(minCapacity);\n    }\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\n        if (newCapacity - minCapacity &lt; 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n</code></pre><p>当然，两个方法也有不同之处，添加元素到任意位置，会导致在该位置后的所有元素都需要重新排列，而将元素添加到数组的末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。</p><p>这里你就可以找到第二道测试题的答案了。如果我们在初始化时就比较清楚存储数据的大小，就可以在ArrayList初始化时指定数组容量大小，并且在添加元素时，只在数组末尾添加元素，那么ArrayList在大量新增元素的场景下，性能并不会变差，反而比其他List集合的性能要好。</p><h3>5.ArrayList删除元素</h3><p>ArrayList的删除方法和添加任意位置元素的方法是有些相同的。ArrayList在每一次有效的删除元素操作之后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。</p><pre><code> public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved &gt; 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n</code></pre><h3>6.ArrayList遍历元素</h3><p>由于ArrayList是基于数组实现的，所以在获取元素的时候是非常快捷的。</p><pre><code>  public E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n</code></pre><h2>LinkedList是如何实现的？</h2><p>虽然LinkedList与ArrayList都是List类型的集合，但LinkedList的实现原理却和ArrayList大相径庭，使用场景也不太一样。</p><p>LinkedList是基于双向链表数据结构实现的，LinkedList定义了一个Node结构，Node结构中包含了3个部分：元素内容item、前指针prev以及后指针next，代码如下。</p><pre><code> private static class Node&lt;E&gt; {\n        E item;\n        Node&lt;E&gt; next;\n        Node&lt;E&gt; prev;\n\n        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n</code></pre><p>总结一下，LinkedList就是由Node结构对象连接而成的一个双向链表。在JDK1.7之前，LinkedList中只包含了一个Entry结构的header属性，并在初始化的时候默认创建一个空的Entry，用来做header，前后指针指向自己，形成一个循环双向链表。</p><p>在JDK1.7之后，LinkedList做了很大的改动，对链表进行了优化。链表的Entry结构换成了Node，内部组成基本没有改变，但LinkedList里面的header属性去掉了，新增了一个Node结构的first属性和一个Node结构的last属性。这样做有以下几点好处：</p><ul>\n<li>first/last属性能更清晰地表达链表的链头和链尾概念；</li>\n<li>first/last方式可以在初始化LinkedList的时候节省new一个Entry；</li>\n<li>first/last方式最重要的性能优化是链头和链尾的插入删除操作更加快捷了。</li>\n</ul><p>这里同ArrayList的讲解一样，我将从数据结构、实现原理以及源码分析等几个角度带你深入了解LinkedList。</p><h3>1.LinkedList实现类</h3><p>LinkedList类实现了List接口、Deque接口，同时继承了AbstractSequentialList抽象类，LinkedList既实现了List类型又有Queue类型的特点；LinkedList也实现了Cloneable和Serializable接口，同ArrayList一样，可以实现克隆和序列化。</p><p>由于LinkedList存储数据的内存地址是不连续的，而是通过指针来定位不连续地址，因此，LinkedList不支持随机快速访问，LinkedList也就不能实现RandomAccess接口。</p><pre><code>public class LinkedList&lt;E&gt;\n    extends AbstractSequentialList&lt;E&gt;\n    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable\n</code></pre><h3>2.LinkedList属性</h3><p>我们前面讲到了LinkedList的两个重要属性first/last属性，其实还有一个size属性。我们可以看到这三个属性都被transient修饰了，原因很简单，我们在序列化的时候不会只对头尾进行序列化，所以LinkedList也是自行实现readObject和writeObject进行序列化与反序列化。</p><pre><code>  transient int size = 0;\n    transient Node&lt;E&gt; first;\n    transient Node&lt;E&gt; last;\n</code></pre><h3>3.LinkedList新增元素</h3><p>LinkedList添加元素的实现很简洁，但添加的方式却有很多种。默认的add (Ee)方法是将添加的元素加到队尾，首先是将last元素置换到临时变量中，生成一个新的Node节点对象，然后将last引用指向新节点对象，之前的last对象的前指针指向新节点对象。</p><pre><code> public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n\n    void linkLast(E e) {\n        final Node&lt;E&gt; l = last;\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n</code></pre><p>LinkedList也有添加元素到任意位置的方法，如果我们是将元素添加到任意两个元素的中间位置，添加元素操作只会改变前后元素的前后指针，指针将会指向添加的新元素，所以相比ArrayList的添加操作来说，LinkedList的性能优势明显。</p><pre><code> public void add(int index, E element) {\n        checkPositionIndex(index);\n\n        if (index == size)\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n\n    void linkBefore(E e, Node&lt;E&gt; succ) {\n        // assert succ != null;\n        final Node&lt;E&gt; pred = succ.prev;\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n</code></pre><h3>4.LinkedList删除元素</h3><p>在LinkedList删除元素的操作中，我们首先要通过循环找到要删除的元素，如果要删除的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找。</p><p>这样做的话，无论要删除较为靠前或较为靠后的元素都是非常高效的，但如果List拥有大量元素，移除的元素又在List的中间段，那效率相对来说会很低。</p><h3>5.LinkedList遍历元素</h3><p>LinkedList的获取元素操作实现跟LinkedList的删除元素操作基本类似，通过分前后半段来循环查找到对应的元素。但是通过这种方式来查询元素是非常低效的，特别是在for循环遍历的情况下，每一次循环都会去遍历半个List。</p><p>所以在LinkedList循环遍历时，我们可以使用iterator方式迭代循环，直接拿到我们的元素，而不需要通过循环查找List。</p><h2>总结</h2><p>前面我们已经从源码的实现角度深入了解了ArrayList和LinkedList的实现原理以及各自的特点。如果你能充分理解这些内容，很多实际应用中的相关性能问题也就迎刃而解了。</p><p>就像如果现在还有人跟你说，“ArrayList和LinkedList在新增、删除元素时，LinkedList的效率要高于ArrayList，而在遍历的时候，ArrayList的效率要高于LinkedList”，你还会表示赞同吗？</p><p>现在我们不妨通过几组测试来验证一下。这里因为篇幅限制，所以我就直接给出测试结果了，对应的测试代码你可以访问<a href=\"https://github.com/nickliuchao/collection\">Github</a>查看和下载。</p><p><strong>1.ArrayList和LinkedList新增元素操作测试</strong></p><ul>\n<li>从集合头部位置新增元素</li>\n<li>从集合中间位置新增元素</li>\n<li>从集合尾部位置新增元素</li>\n</ul><p>测试结果(花费时间)：</p><ul>\n<li>ArrayList&gt;LinkedList</li>\n<li>ArrayList&lt;LinkedList</li>\n<li>ArrayList&lt;LinkedList</li>\n</ul><p>通过这组测试，我们可以知道LinkedList添加元素的效率未必要高于ArrayList。</p><p>由于ArrayList是数组实现的，而数组是一块连续的内存空间，在添加元素到数组头部的时候，需要对头部以后的数据进行复制重排，所以效率很低；而LinkedList是基于链表实现，在添加元素的时候，首先会通过循环查找到添加元素的位置，如果要添加的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找。因此LinkedList添加元素到头部是非常高效的。</p><p>同上可知，ArrayList在添加元素到数组中间时，同样有部分数据需要复制重排，效率也不是很高；LinkedList将元素添加到中间位置，是添加元素最低效率的，因为靠近中间位置，在添加元素之前的循环查找是遍历元素最多的操作。</p><p>而在添加元素到尾部的操作中，我们发现，在没有扩容的情况下，ArrayList的效率要高于LinkedList。这是因为ArrayList在添加元素到尾部的时候，不需要复制重排数据，效率非常高。而LinkedList虽然也不用循环查找元素，但LinkedList中多了new对象以及变换指针指向对象的过程，所以效率要低于ArrayList。</p><p>说明一下，这里我是基于ArrayList初始化容量足够，排除动态扩容数组容量的情况下进行的测试，如果有动态扩容的情况，ArrayList的效率也会降低。</p><p><strong>2.ArrayList和LinkedList删除元素操作测试</strong></p><ul>\n<li>从集合头部位置删除元素</li>\n<li>从集合中间位置删除元素</li>\n<li>从集合尾部位置删除元素</li>\n</ul><p>测试结果(花费时间)：</p><ul>\n<li>ArrayList&gt;LinkedList</li>\n<li>ArrayList&lt;LinkedList</li>\n<li>ArrayList&lt;LinkedList</li>\n</ul><p>ArrayList和LinkedList删除元素操作测试的结果和添加元素操作测试的结果很接近，这是一样的原理，我在这里就不重复讲解了。</p><p><strong>3.ArrayList和LinkedList遍历元素操作测试</strong></p><ul>\n<li>for(;;)循环</li>\n<li>迭代器迭代循环</li>\n</ul><p>测试结果(花费时间)：</p><ul>\n<li>ArrayList&lt;LinkedList</li>\n<li>ArrayList≈LinkedList</li>\n</ul><p>我们可以看到，LinkedList的for循环性能是最差的，而ArrayList的for循环性能是最好的。</p><p>这是因为LinkedList基于链表实现的，在使用for循环的时候，每一次for循环都会去遍历半个List，所以严重影响了遍历的效率；ArrayList则是基于数组实现的，并且实现了RandomAccess接口标志，意味着ArrayList可以实现快速随机访问，所以for循环效率非常高。</p><p>LinkedList的迭代循环遍历和ArrayList的迭代循环遍历性能相当，也不会太差，所以在遍历LinkedList时，我们要切忌使用for循环遍历。</p><h2>思考题</h2><p>我们通过一个使用for循环遍历删除操作ArrayList数组的例子，思考下ArrayList数组的删除操作应该注意的一些问题。</p><pre><code>public static void main(String[] args)\n    {\n        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();\n        list.add(&quot;a&quot;);\n        list.add(&quot;a&quot;);\n        list.add(&quot;b&quot;);\n        list.add(&quot;b&quot;);\n        list.add(&quot;c&quot;);\n        list.add(&quot;c&quot;);\n        remove(list);//删除指定的“b”元素\n\n        for(int i=0; i&lt;list.size(); i++)(&quot;c&quot;)()()(s : list) \n        {\n            System.out.println(&quot;element : &quot; + s)list.get(i)\n        }\n    }\n</code></pre><p>从上面的代码来看，我定义了一个ArrayList数组，里面添加了一些元素，然后我通过remove删除指定的元素。请问以下两种写法，哪种是正确的？</p><p>写法1：</p><pre><code>public static void remove(ArrayList&lt;String&gt; list) \n    {\n        Iterator&lt;String&gt; it = list.iterator();\n        \n        while (it.hasNext()) {\n            String str = it.next();\n            \n            if (str.equals(&quot;b&quot;)) {\n                it.remove();\n            }\n        }\n\n    }\n</code></pre><p>写法2：</p><pre><code>public static void remove(ArrayList&lt;String&gt; list) \n    {\n        for (String s : list)\n        {\n            if (s.equals(&quot;b&quot;)) \n            {\n                list.remove(s);\n            }\n        }\n    }\n</code></pre><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起学习。</p><p><img src=\"https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg\" alt=\"unpreview\"></p>","comments":[{"had_liked":false,"id":99139,"user_name":"陆离","can_delete":false,"product_type":"c1","uid":1483932,"ip_address":"","ucode":"2C8C206CE36A81","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg","comment_is_top":true,"comment_ctime":1559164558,"is_pvip":false,"replies":[{"id":"35734","content":"陆离同学一直保持非常稳定的发挥，答案非常准确！","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559226292,"ip_address":"","comment_id":99139,"utype":1}],"discussion_count":2,"race_medal":0,"score":"9.2233724507307991e+18","product_id":100028001,"comment_content":"对于arraylist和linkedlist的性能以前一直都是人云亦云，大家都说是这样那就这样吧，我也从来没有自己去验证过，没想过因操作位置的不同差异还挺大。<br>当然这里面有一个前提，那就是arraylist的初始大小要足够大。<br>思考题是第一个是正确的，第二个虽然用的是foreach语法糖，遍历的时候用的也是迭代器遍历，但是在remove操作时使用的是原始数组list的remove，而不是迭代器的remove。<br>这样就会造成modCound != exceptedModeCount，进而抛出异常。","like_count":97,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451985,"discussion_content":"陆离同学一直保持非常稳定的发挥，答案非常准确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559226292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kjMRia1qRWgOktyWPSJIIqfkkpiakco1nCQnrI2n43Sicn94tJVzgQtzFXCTOTuwYww64Umkn6WSwgBdbJICfPs3Q/132","nickname":"feng*","note":"","ucode":"3080426972F9C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304803,"discussion_content":"调用迭代器的remove会同步调用list的吗?","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599664491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99431,"user_name":"刘天若Warner","can_delete":false,"product_type":"c1","uid":1216848,"ip_address":"","ucode":"032639CD670DA3","user_header":"https://static001.geekbang.org/account/avatar/00/12/91/50/e576a068.jpg","comment_is_top":true,"comment_ctime":1559212602,"is_pvip":false,"replies":[{"id":"35727","content":"for(:)循环[这里指的不是for(;;)]是一个语法糖，这里会被解释为迭代器，在使用迭代器遍历时，ArrayList内部创建了一个内部迭代器iterator，在使用next()方法来取下一个元素时，会使用ArrayList里保存的一个用来记录List修改次数的变量modCount，与iterator保存了一个expectedModCount来表示期望的修改次数进行比较，如果不相等则会抛出异常；<br><br>而在在foreach循环中调用list中的remove()方法，会走到fastRemove()方法，该方法不是iterator中的方法，而是ArrayList中的方法，在该方法只做了modCount++，而没有同步到expectedModCount。<br><br>当再次遍历时，会先调用内部类iteator中的hasNext(),再调用next(),在调用next()方法时，会对modCount和expectedModCount进行比较，此时两者不一致，就抛出了ConcurrentModificationException异常。<br><br>所以关键是用ArrayList的remove还是iterator中的remove。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559225842,"ip_address":"","comment_id":99431,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233723304718008e+18","product_id":100028001,"comment_content":"老师，为什么第二种就会抛出`ConcurrentModificationException`异常呢，我觉得第一种迭代器会抛这个异常啊","like_count":69,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452107,"discussion_content":"for(:)循环[这里指的不是for(;;)]是一个语法糖，这里会被解释为迭代器，在使用迭代器遍历时，ArrayList内部创建了一个内部迭代器iterator，在使用next()方法来取下一个元素时，会使用ArrayList里保存的一个用来记录List修改次数的变量modCount，与iterator保存了一个expectedModCount来表示期望的修改次数进行比较，如果不相等则会抛出异常；\n\n而在在foreach循环中调用list中的remove()方法，会走到fastRemove()方法，该方法不是iterator中的方法，而是ArrayList中的方法，在该方法只做了modCount++，而没有同步到expectedModCount。\n\n当再次遍历时，会先调用内部类iteator中的hasNext(),再调用next(),在调用next()方法时，会对modCount和expectedModCount进行比较，此时两者不一致，就抛出了ConcurrentModificationException异常。\n\n所以关键是用ArrayList的remove还是iterator中的remove。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559225842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99914,"user_name":"Loubobooo","can_delete":false,"product_type":"c1","uid":1108306,"ip_address":"","ucode":"7B2543A80EBDEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/52/aa3be800.jpg","comment_is_top":false,"comment_ctime":1559357363,"is_pvip":false,"replies":[{"id":"35909","content":"👍","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559394363,"ip_address":"","comment_id":99914,"utype":1}],"discussion_count":2,"race_medal":0,"score":"134703343539","product_id":100028001,"comment_content":"这一道我会。如果有看过阿里java规约就知道，在集合中进行remove操作时，不要在 foreach 循环里进行元素的 remove&#47;add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。<br>&lt;!-- 规约第七条 --&gt;","like_count":32,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452322,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559394363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784474,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3a/9a/8b6aaa39.jpg","nickname":"黑","note":"","ucode":"96D0F91F8A6FCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377100,"discussion_content":"原因不就是因为arraylist.remove（Object）操作本身就是循环遍历一遍数组元素嘛。第二种写法直接list.remove就能解决问题了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622507853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187950,"user_name":"脱缰的野马__","can_delete":false,"product_type":"c1","uid":1447569,"ip_address":"","ucode":"D5F993E7232C61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","comment_is_top":false,"comment_ctime":1584282293,"is_pvip":false,"replies":[{"id":"73029","content":"赞，这是计算机底层访问数组和链表的实现原理，数组因为存储地址是连续的，所以在每次访问某个元素的时候，会将某一块连续地址的数据读取到CPU缓存中，这也是数组查询快于链表的关键。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584533400,"ip_address":"","comment_id":187950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"113253431989","product_id":100028001,"comment_content":"老师您好，在我的认知里面，之所以数组遍历比链表要快，应该还有一个底层的原因，就是源于数组的实现是在内存当中是一块连续的内存空间，而链表所有元素可能分布在内存的不同位置，对于数组这种数据结构来说对CPU读是非常友好的，不管是CPU从内存读数据读到高速缓存还是线程从磁盘读数据到内存时，都不只是读取需要的那部分数据，而是读取相关联的某一块地址数据，这样的话对于在遍历数组的时候，在一定程度上提高了CPU高速缓存的命中率，减少了CPU访问内存的次数从而提高了效率，这是我结合计算机相关原理的角度考虑的一点。","like_count":27,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487300,"discussion_content":"赞，这是计算机底层访问数组和链表的实现原理，数组因为存储地址是连续的，所以在每次访问某个元素的时候，会将某一块连续地址的数据读取到CPU缓存中，这也是数组查询快于链表的关键。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584533400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99320,"user_name":"皮皮","can_delete":false,"product_type":"c1","uid":1156624,"ip_address":"","ucode":"D692CFAA982137","user_header":"https://static001.geekbang.org/account/avatar/00/11/a6/10/3ff2e1a5.jpg","comment_is_top":false,"comment_ctime":1559192614,"is_pvip":true,"replies":[{"id":"35733","content":"关键在用谁的remove方法。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559226194,"ip_address":"","comment_id":99320,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74573636646","product_id":100028001,"comment_content":"第一种写法正确，第二种会报错，原因是上述两种写法都有用到list内部迭代器Iterator，而在迭代器内部有一个属性是exceptedmodcount，每次调用next和remove方法时会检查该值和list内部的modcount是否一致，不一致会报异常。问题中的第二种写法remove（e），会在每次调用时modcount++，虽然迭代器的remove方法也会调用list的这个remove（e）方法，但每次调用后还有一个exceptedmodcount=modcount操作，所以后续调用next时判断就不会报异常了。","like_count":17,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452060,"discussion_content":"关键在用谁的remove方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559226194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99774,"user_name":"TerryGoForIt","can_delete":false,"product_type":"c1","uid":1020644,"ip_address":"","ucode":"701B0E72F15AB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/e4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1559296764,"is_pvip":false,"replies":[{"id":"35842","content":"HashMap有负载因子是既要考虑数组太短，因哈希冲突导致链表过长而导致查询性能下降，也考虑了数组过长，新增数据时性能下降。这个负载因子是综合了数组和链表两者的长度，不能太大也不能太小。而ArrayList不需要这种考虑。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559308126,"ip_address":"","comment_id":99774,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61688838908","product_id":100028001,"comment_content":"老师您好，我比较好奇的是为什么 ArrayList 不像 HashMap 一样在扩容时需要一个负载因子呢？","like_count":14,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452267,"discussion_content":"HashMap有负载因子是既要考虑数组太短，因哈希冲突导致链表过长而导致查询性能下降，也考虑了数组过长，新增数据时性能下降。这个负载因子是综合了数组和链表两者的长度，不能太大也不能太小。而ArrayList不需要这种考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559308126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101916,"user_name":"JasonZ","can_delete":false,"product_type":"c1","uid":1104818,"ip_address":"","ucode":"992193AE44C39C","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/b2/29b4f22b.jpg","comment_is_top":false,"comment_ctime":1560051333,"is_pvip":false,"replies":[{"id":"36869","content":"因为for循环需要遍历链表，每循环一次就需要遍历一次指定节点前的数据，源码如下:<br><br>&#47;&#47; 获取双向链表中指定位置的节点    <br>    private Entry&lt;E&gt; entry(int index) {    <br>        if (index &lt; 0 || index &gt;= size)    <br>            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+    <br>                                                &quot;, Size: &quot;+size);    <br>        Entry&lt;E&gt; e = header;    <br>        &#47;&#47; 获取index处的节点。    <br>        &#47;&#47; 若index &lt; 双向链表长度的1&#47;2,则从前先后查找;    <br>        &#47;&#47; 否则，从后向前查找。    <br>        if (index &lt; (size &gt;&gt; 1)) {    <br>            for (int i = 0; i &lt;= index; i++)    <br>                e = e.next;    <br>        } else {    <br>            for (int i = size; i &gt; index; i--)    <br>                e = e.previous;    <br>        }    <br>        return e;    <br>    }<br><br>而iterator在第一次拿到一个数据后，之后的循环中会使用Iterator中的next()方法采用的是顺序访问。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560173305,"ip_address":"","comment_id":101916,"utype":1}],"discussion_count":8,"race_medal":0,"score":"48804691589","product_id":100028001,"comment_content":"linkedlist使用iterator比普通for循环效率高，是由于遍历次数少，这是为什么？有什么文档可以参考么？","like_count":11,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453171,"discussion_content":"因为for循环需要遍历链表，每循环一次就需要遍历一次指定节点前的数据，源码如下:\n\n// 获取双向链表中指定位置的节点    \n    private Entry&amp;lt;E&amp;gt; entry(int index) {    \n        if (index &amp;lt; 0 || index &amp;gt;= size)    \n            throw new IndexOutOfBoundsException(&amp;quot;Index: &amp;quot;+index+    \n                                                &amp;quot;, Size: &amp;quot;+size);    \n        Entry&amp;lt;E&amp;gt; e = header;    \n        // 获取index处的节点。    \n        // 若index &amp;lt; 双向链表长度的1/2,则从前先后查找;    \n        // 否则，从后向前查找。    \n        if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {    \n            for (int i = 0; i &amp;lt;= index; i++)    \n                e = e.next;    \n        } else {    \n            for (int i = size; i &amp;gt; index; i--)    \n                e = e.previous;    \n        }    \n        return e;    \n    }\n\n而iterator在第一次拿到一个数据后，之后的循环中会使用Iterator中的next()方法采用的是顺序访问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560173305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337115,"discussion_content":"我看老师的解释也没明白，后来搜了搜，最后搞明白了：for循环中会使用 Linkedlist.get(i)方法来获取链表中的元素，而每次执行 get 方法都会从链表的头结点开始遍历，直到遍历到 i 的位置；而 Iterator 的 next 方法是顺着链表一个个节点遍历过去，少了从头结点遍历到 i 位置这一步骤，所以比较快。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1608800481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1222873,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a8/d9/c2f5fe31.jpg","nickname":"凡尘里的一根葱","note":"","ucode":"4D88CEC9775D8F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31857,"discussion_content":"老师没介绍好for循环是那种方式，导致很多阅读者花了很多时间理解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1570964408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030289,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/91/26099766.jpg","nickname":"车尼","note":"","ucode":"70F31699B27ABE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1587,"discussion_content":"老师，还是不太明白for循环比iterator遍历速度快在哪？理论上都得从头一个一个遍历，iterator并没有讨巧的地方啊，什么场景下快呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562720687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1357623,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJmBKrLvqOIXDDbj3ocEIJzqsQx2e5VLDBSX6LmofYtprWwKaVAmHUqU2z3mjREHX8n9eLLiavlPg/132","nickname":"wg1993","note":"","ucode":"D5112FEFDB1DF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1030289,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/91/26099766.jpg","nickname":"车尼","note":"","ucode":"70F31699B27ABE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32413,"discussion_content":"其实你们自己写一个LinkedList的for(;;)循环，进入get方法马上就能看出来慢在哪了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571033384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1587,"ip_address":""},"score":32413,"extra":""}]},{"author":{"id":1542509,"avatar":"https://static001.geekbang.org/account/avatar/00/17/89/6d/4e90e612.jpg","nickname":"Jett.wang","note":"","ucode":"50EEC41D92040F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5389,"discussion_content":"老师 我也不太明天 为啥Iterator 效率高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566222048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1022767,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/2f/b7a3625e.jpg","nickname":"Len","note":"","ucode":"53C623CE17973F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1542509,"avatar":"https://static001.geekbang.org/account/avatar/00/17/89/6d/4e90e612.jpg","nickname":"Jett.wang","note":"","ucode":"50EEC41D92040F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25651,"discussion_content":"注意⚠️，@老师 这里说的是 for get(i) 遍历要远慢于 Iterator ，很明显每一次 get(i) 都要叠加 get(i -1) 时间复杂度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570544725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5389,"ip_address":""},"score":25651,"extra":""},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1022767,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9b/2f/b7a3625e.jpg","nickname":"Len","note":"","ucode":"53C623CE17973F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":336276,"discussion_content":"应该是的，对于LinkedList这种没有下标索引的结构来说，判断hasNext()的效率比直接get(i)是要高一个O(n)的复杂度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608543592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25651,"ip_address":""},"score":336276,"extra":""}]}]},{"had_liked":false,"id":99342,"user_name":"csyangchsh","can_delete":false,"product_type":"c1","uid":1002939,"ip_address":"","ucode":"8604F5C839710B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/bb/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1559196995,"is_pvip":false,"replies":[{"id":"35731","content":"厉害了，感谢建议。这里很多同学没有了解过JMH测试框架，所以没有使用。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559226083,"ip_address":"","comment_id":99342,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44508869955","product_id":100028001,"comment_content":"测试代码不严谨，建议使用JMH。","like_count":10,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452068,"discussion_content":"厉害了，感谢建议。这里很多同学没有了解过JMH测试框架，所以没有使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559226083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102282,"user_name":"建国","can_delete":false,"product_type":"c1","uid":1242847,"ip_address":"","ucode":"A077B3AFB307A0","user_header":"https://static001.geekbang.org/account/avatar/00/12/f6/df/a576bfce.jpg","comment_is_top":false,"comment_ctime":1560175806,"is_pvip":false,"replies":[{"id":"37321","content":"这个是随机的，因为分配的内存地址不是连续的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560390273,"ip_address":"","comment_id":102282,"utype":1}],"discussion_count":4,"race_medal":0,"score":"27329979582","product_id":100028001,"comment_content":"老师，您好，linkList查找元素通过分前后半段，每次查找都要遍历半个list，怎么就知道元素是出于前半段还是后半段的呢？","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453337,"discussion_content":"这个是随机的，因为分配的内存地址不是连续的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560390273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1072350,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5c/de/16695891.jpg","nickname":"小太阳","note":"","ucode":"84FF032FE78B11","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75036,"discussion_content":"老师也没说清楚，大家还是看源码吧~\n贴个源码：\nLinkedList.Node<E> node(int index) {\n        LinkedList.Node x;\n        int i;\n        if (index < this.size >> 1) {\n            x = this.first;\n\n            for(i = 0; i < index; ++i) {\n                x = x.next;\n            }\n\n            return x;\n        } else {\n            x = this.last;\n\n            for(i = this.size - 1; i > index; --i) {\n                x = x.prev;\n            }\n\n            return x;\n        }\n    }","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1575719490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214582,"avatar":"https://static001.geekbang.org/account/avatar/00/12/88/76/c69b7fe5.jpg","nickname":"youngitachi","note":"","ucode":"88717CA8B8ED64","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2905,"discussion_content":"我觉得老师是想说平均下来要遍历一半的list吧，感觉表述确实有点奇怪","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564030266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242455,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","nickname":"天天向上","note":"","ucode":"0CCCA6F4DCC480","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":95444,"discussion_content":"看了下jdk8的源码，没有找到老是说的这个查找的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577022647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99679,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1559277952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27329081728","product_id":100028001,"comment_content":"谢谢老师明白了，如果第二种写法换成for(;;)就会直接调用ArrayList的remove()方法就不会报错了。<br><br>在第二种写法里面用foreach相当于是使用ArrayList内部的Itr类进行遍历，但删除数据又是用的ArrayList里面的remove()方法。从而导致状态不一致，引发报错。","like_count":6},{"had_liked":false,"id":165114,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1577164420,"is_pvip":false,"replies":[{"id":"62967","content":"赞","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1577185617,"ip_address":"","comment_id":165114,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18757033604","product_id":100028001,"comment_content":"modCount属于ArrayList<br>expectedModCount属于Iterator<br><br>增强for循环  本质是iterator遍历<br>iterator循环  iterator遍历<br><br>增强for循环  调用list.remove() 不会修改到iterator的expectedModCount, 从而导致 迭代器的expectedModCount != ArrayList的modCound; 迭代器会抛出 concurrentModifiedException<br><br>而iterator遍历 的时候 用iterator. remove(); modCount 会被同步到expectedModCount中去，ArrayList的modCount == Iterator的exceptedModCount，所以不会抛出异常。<br><br><br>老师对其他同学的评论以及我的理解就是这样。","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479032,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577185617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121216,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1181647,"ip_address":"","ucode":"46A2F679C094E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","comment_is_top":false,"comment_ctime":1565079824,"is_pvip":false,"replies":[{"id":"44635","content":"这里指的是不需要通过遍历寻址，可以通过index直接访问到内存地址。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565140537,"ip_address":"","comment_id":121216,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18744949008","product_id":100028001,"comment_content":"老师，随机访问到底是什么意思？怎么个随机法？谢谢～","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461685,"discussion_content":"这里指的是不需要通过遍历寻址，可以通过index直接访问到内存地址。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565140537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kjMRia1qRWgOktyWPSJIIqfkkpiakco1nCQnrI2n43Sicn94tJVzgQtzFXCTOTuwYww64Umkn6WSwgBdbJICfPs3Q/132","nickname":"feng*","note":"","ucode":"3080426972F9C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304801,"discussion_content":"随便给一个index都可以直接定位到具体的值，这就是所谓的随机访问:直接通过给的一个索引键取到具体意义的值。区别于顺序访问吧，顺序访问就只能通过开始一个个的往下取值直到取到需要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599664306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99661,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1559274660,"is_pvip":false,"replies":[{"id":"35841","content":"没啥区别的，可以实际操作试试","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559307430,"ip_address":"","comment_id":99661,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14444176548","product_id":100028001,"comment_content":"请问：List&lt;A&gt; list = new ArrayList&lt;&gt;();<br>for(int i=0;i++;i&lt;1000){<br> A a = new A();<br> list.add(a);<br>}<br>和<br>和  这个  List&lt;A&gt; list = new ArrayList&lt;&gt;();<br>A a;<br>for(int i=0;i++;i&lt;1000){<br> a = new A();<br> list.add(a);<br>}<br>效率上有差别吗？不说new ArrayList&lt;&gt;(); 初始化问题。单纯说创建对象这一块。谢谢！","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452209,"discussion_content":"没啥区别的，可以实际操作试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559307430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99160,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1559173217,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14444075105","product_id":100028001,"comment_content":"写法一正确，写法二会快速失败","like_count":3},{"had_liked":false,"id":200857,"user_name":"麦兜布熊","can_delete":false,"product_type":"c1","uid":1118352,"ip_address":"","ucode":"F46E3571FAE9FE","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/90/5cb92311.jpg","comment_is_top":false,"comment_ctime":1585662793,"is_pvip":false,"replies":[{"id":"75241","content":"在做一些业务功能开发时，我们平常用的最多的是ArrayList，因为ArrayList就能满足我们的业务需求，单次填充列表以及单次全部读取列表。<br>到经常有删除&#47;插入操作的情况下适合使用LinkedList，例如我们要写一个类似LRU算法的缓存功能，就可以用到LinkedList。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585741060,"ip_address":"","comment_id":200857,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175597385","product_id":100028001,"comment_content":"老师，什么场景会用到linkedlist呢？我好像只见过Arraylist的代码呢","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490155,"discussion_content":"在做一些业务功能开发时，我们平常用的最多的是ArrayList，因为ArrayList就能满足我们的业务需求，单次填充列表以及单次全部读取列表。\n到经常有删除/插入操作的情况下适合使用LinkedList，例如我们要写一个类似LRU算法的缓存功能，就可以用到LinkedList。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585741060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148311,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1572972463,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10162907055","product_id":100028001,"comment_content":"first&#47;last 方式可以在初始化 LinkedList 的时候节省 new 一个 Entry；<br><br>来回看老师的专栏，这是第三遍了，每次都会有新的理解，同时也有新的疑问产生，比如上边的那句话今天一直没有想明白。。。。麻烦老师详细解答一下。","like_count":2,"discussions":[{"author":{"id":1152145,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/91/6d6ca42f.jpg","nickname":"怀草诗","note":"","ucode":"78F8B9B4628F15","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254994,"discussion_content":"我认为这边作者是比较JDK 1.7之前和之后的实现方式\n1.7之前是需要new Entry的 \nprivate transient Entry<E> header = new Entry<E>(null, null, null);\n在Entry内部又有前后指针定义\n1.7之后在初始化的时候不用再去new Entry了，直接使用Node结构。\n不知道说的对不对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588348585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114585,"user_name":"Aaron_涛","can_delete":false,"product_type":"c1","uid":1180617,"ip_address":"","ucode":"067F3CBB1F036C","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/c9/9a9d82ab.jpg","comment_is_top":false,"comment_ctime":1563345679,"is_pvip":false,"replies":[{"id":"41935","content":"是的，是因为连续内存。在代码中，程序是不知道底层开辟的内存情况，所以需要一个类似序列化的接口标志，这个接口仅仅是一个标志，并不是实现。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563421734,"ip_address":"","comment_id":114585,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10153280271","product_id":100028001,"comment_content":"arrayList，for循环访问快是因为内存连续，可以整个缓存行读取进cpu缓存中，遍历下个的时候无需去内存中获取。并不是实现什么随机获取接口","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458733,"discussion_content":"是的，是因为连续内存。在代码中，程序是不知道底层开辟的内存情况，所以需要一个类似序列化的接口标志，这个接口仅仅是一个标志，并不是实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563421734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193692,"avatar":"https://static001.geekbang.org/account/avatar/00/12/36/dc/36b306a2.jpg","nickname":"WWR","note":"","ucode":"1FCFD17A6E0390","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6182,"discussion_content":"所以建议作者描述清楚，而不是比较模糊的概念，还有一个，LinkedList 基于链表实现，为什么for遍历的时候会遍历半个List？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566747281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102367,"user_name":"gavin","can_delete":false,"product_type":"c1","uid":1567261,"ip_address":"","ucode":"07D4FE0887FE0E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/U5tJTyH25kJA3eAtK0jKTmiaDGkFx4O1yOVjKnbnEQukTjDJCqhlKvLFaIZ6UVp3HcJK3GllMCRfDPU7wodslLQ/132","comment_is_top":false,"comment_ctime":1560213932,"is_pvip":false,"replies":[{"id":"37318","content":"arraylist的add方法默认是从尾部操作，delete方法就是根据自己指定的位置来删除；linkedlist的add方法也是默认从尾部插入元素，delete方法也是根据指定的元素来删除。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560389602,"ip_address":"","comment_id":102367,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10150148524","product_id":100028001,"comment_content":"老师好，怎么确定操作集合是从头部、中间、还是尾部操作的呢？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453381,"discussion_content":"arraylist的add方法默认是从尾部操作，delete方法就是根据自己指定的位置来删除；linkedlist的add方法也是默认从尾部插入元素，delete方法也是根据指定的元素来删除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560389602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99326,"user_name":"DebugDog","can_delete":false,"product_type":"c1","uid":1027798,"ip_address":"","ucode":"1664D37CE03B9D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","comment_is_top":false,"comment_ctime":1559194072,"is_pvip":true,"replies":[{"id":"35732","content":"对的，使用普通循环也需要注意。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559226123,"ip_address":"","comment_id":99326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10149128664","product_id":100028001,"comment_content":"写法一正确。<br>虽然都是调用了remove方法，但是两个remove方法是不同的。<br>写法二是有可能会报ConcurrentModificationException异常。<br>所以在ArrayList遍历删除元素时使用iterator方式或者普通的for循环。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452062,"discussion_content":"对的，使用普通循环也需要注意。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559226123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99266,"user_name":"mickle","can_delete":false,"product_type":"c1","uid":1201493,"ip_address":"","ucode":"1F89608B5E06C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/55/55/19ec7b0e.jpg","comment_is_top":false,"comment_ctime":1559183470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10149118062","product_id":100028001,"comment_content":"第二种不行吧，会报并发修改异常的","like_count":2},{"had_liked":false,"id":345086,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1652011349,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5946978645","product_id":100028001,"comment_content":"分析第二个方法会抛ConcurrentModificationException异常，我们这么入手应该好理解一点，将生成的class文件反编译等到如下代码：<br><br> public static void remove(List&lt;String&gt; list) {<br>        Iterator var1 = list.iterator(); &#47;&#47; ①<br><br>        while(var1.hasNext()) {<br>            String s = (String)var1.next(); &#47;&#47; ②<br>            if (s.equals(&quot;b&quot;)) {<br>                list.remove(s); &#47;&#47; ③<br>            }<br>        }<br><br>    }<br><br>首先明确<br>1）modCound是ArrayList的成员变量继承自AbstractList；<br>2）expectedModCount是ArrayList内部迭代器Itr的成员变量；<br><br>执行到①处时会new一个迭代器对象，迭代器对象创建时会将list对象的成员变量modCound赋值给expectedModCount；<br>执行到②处时会检查list对象中的成员变量modCound与迭代器var1对象中的成员变量expectedModCount是否相等，不相等则抛ConcurrentModificationException异常；<br>执行到③处时对象list的成员变量modCound会被修改，但是迭代器var1对象中的成员变量expectedModCount不会被同步修复；<br><br>循环执行回到②处时就抛ConcurrentModificationException异常；","like_count":1},{"had_liked":false,"id":284752,"user_name":"郝希军","can_delete":false,"product_type":"c1","uid":2390479,"ip_address":"","ucode":"38CCE6B9BAF529","user_header":"https://static001.geekbang.org/account/avatar/00/24/79/cf/211f0208.jpg","comment_is_top":false,"comment_ctime":1616460537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5911427833","product_id":100028001,"comment_content":"第一个是正确的写法，第二种写法会有异常，因为直接把list的某个位置删除，但是for循环编辑器又不知道已经被删除，然后遍历到最后一个的时候肯定异常了，这题还是挺简单的","like_count":1},{"had_liked":false,"id":125511,"user_name":"李德强","can_delete":false,"product_type":"c1","uid":1503239,"ip_address":"","ucode":"59ABCA0892E3CD","user_header":"https://static001.geekbang.org/account/avatar/00/16/f0/07/92445721.jpg","comment_is_top":false,"comment_ctime":1566197362,"is_pvip":false,"replies":[{"id":"46225","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566265070,"ip_address":"","comment_id":125511,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5861164658","product_id":100028001,"comment_content":"自己掉坑里了!<br>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();<br><br>        list.add(&quot;a&quot;);<br>        list.add(&quot;b&quot;);<br>        list.add(&quot;c&quot;);<br>        list.add(&quot;d&quot;);<br>        list.add(&quot;e&quot;);<br><br>        for (String item :  list) {<br>            if (item.equals(&quot;d&quot;)) {<br>                list.remove(item);<br>            }<br>        }<br><br>这种移除唯一且倒数第二个的不会报错。<br>原因时判断hasNext时就返回了false，没有机会去校验modCount了。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463588,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566265070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kjMRia1qRWgOktyWPSJIIqfkkpiakco1nCQnrI2n43Sicn94tJVzgQtzFXCTOTuwYww64Umkn6WSwgBdbJICfPs3Q/132","nickname":"feng*","note":"","ucode":"3080426972F9C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304809,"discussion_content":"不是应该最后一个remove的时候才会导致hasnext为false吗?是因为remove了d导致e往前跳了然后这个时候hasnext就为空吗?（可是如果这样的话不是没有遍历e的机会就吗）?😂😂不懂啊大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599664721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kjMRia1qRWgOktyWPSJIIqfkkpiakco1nCQnrI2n43Sicn94tJVzgQtzFXCTOTuwYww64Umkn6WSwgBdbJICfPs3Q/132","nickname":"feng*","note":"","ucode":"3080426972F9C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304807,"discussion_content":"不是还有个e的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599664605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","nickname":"多襄丸","note":"","ucode":"1AA1497C5A293C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98445,"discussion_content":"但是只有三个元素被遍历到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577163791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99379,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1559202484,"is_pvip":false,"replies":[{"id":"35729","content":"对的！","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559225954,"ip_address":"","comment_id":99379,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5854169780","product_id":100028001,"comment_content":"写法2不正确，使用for循环遍历元素的过程中，如果删除元素，由于modCount != expectedModCount，会抛出ConcurrentModificationException异常","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452087,"discussion_content":"对的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559225954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99140,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1559168262,"is_pvip":false,"replies":[{"id":"35737","content":"是的，不要使用迭代器循环时用ArrayList的remove方法，具体分析可以看留言区。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559226540,"ip_address":"","comment_id":99140,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5854135558","product_id":100028001,"comment_content":"需要用迭代器方式删除<br>for循环遍历删除会抛并发修改异常","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451986,"discussion_content":"是的，不要使用迭代器循环时用ArrayList的remove方法，具体分析可以看留言区。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559226540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358844,"user_name":"颜如玉","can_delete":false,"product_type":"c1","uid":2856239,"ip_address":"重庆","ucode":"C55FDAE3559054","user_header":"https://static001.geekbang.org/account/avatar/00/2b/95/2f/d88950a1.jpg","comment_is_top":false,"comment_ctime":1664883729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664883729","product_id":100028001,"comment_content":"为什么会设计出modCount和expectedModCount这样的字段呢？","like_count":0},{"had_liked":false,"id":349888,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1656412478,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656412478","product_id":100028001,"comment_content":"一般remove都是对某个元素进行操作，我们遍历删除的时候做个判断，命中了之后就停止循环，modCount++是先加后用，因此不会影响remove操作，这样就不存在抛异常的问题了。","like_count":0},{"had_liked":false,"id":345595,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1652419706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652419706","product_id":100028001,"comment_content":"一、新增<br>1.ArrayList：<br>是末尾添加elementData[size++] = input操作，所以在不需要扩容的情况下，add的时间复杂度是O(1)，而随机添加就需要对添加位置之后的所有元素进行reHash，重新分配空间，会造成性能损失，插入元素越靠前越严重。而且如果数组长度达到阈值还要扩容。<br>2.LinkedList <br>add默认末尾添加，而且随机添加只是改变前后node的后指针和前继指针的指向即可，由于它的特殊的结构我们还可以选择头部添加addFirst()和尾部添加linkLast()<br>由于链表在空间上不是连续的，而是靠指针连接，所以没必要重新分配空间，所以不管是末尾添加还是随机添加时间复杂度都是O（1）<br><br>二、删除<br>1.ArrayList：<br>(1.)随机访因为下标的缘故时间复杂度是O（1）但删除就需要找到目标元素，就需要遍历数组，时间复杂度是O(n)<br>(2)每次对元素修改操作都会modCount++，是为了判断是否存在并发操作，但在调用Itr的next()方法的时候会调用checkForComodification()对这个参数进行检测是否做了修改，是则抛异常。<br>(3)正确的remove姿势是遍历到目标删除元素删除后终止循环<br><br>2.LinkedList <br>可以头部&#47;尾部添加，也可以头部尾部（removeFirst()&#47;removeFirst()）删除，删除原理就是把头部和尾部节点都设为null方便GC回收，通俗点讲就是把要删除的元素择出来。<br>remove()有两种一种是删除目标元素，一种是根据下标删除（下标删除当链表为空是会抛异常）<br><br>三、遍历<br>1.ArrayList：<br>实现了RandomAccess接口标识遍历是根据index随机访问，性能相对要好<br>2.LinkedList <br>在使用 for 循环的时候，每一次 for 循环都会去遍历半个 List，所以严重影响了遍历的效率","like_count":0},{"had_liked":false,"id":343805,"user_name":"Ywis","can_delete":false,"product_type":"c1","uid":2444935,"ip_address":"","ucode":"EEAB6B4BBBFCDA","user_header":"https://static001.geekbang.org/account/avatar/00/25/4e/87/e78b0f25.jpg","comment_is_top":false,"comment_ctime":1651063781,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651063781","product_id":100028001,"comment_content":"remove方法既然不能用，那他存在的意义是什么呢？","like_count":0},{"had_liked":false,"id":336955,"user_name":"BeerBear","can_delete":false,"product_type":"c1","uid":2679713,"ip_address":"","ucode":"5BB9A8DDC23818","user_header":"https://static001.geekbang.org/account/avatar/00/28/e3/a1/d50f2188.jpg","comment_is_top":false,"comment_ctime":1646489022,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646489022","product_id":100028001,"comment_content":"最后一道思考题，如果做法一种没有指定传入的List是什么类型，应该优先传入LinkedList，因为LinkedList在remove时性能更高。","like_count":0},{"had_liked":false,"id":300644,"user_name":"平民人之助","can_delete":false,"product_type":"c1","uid":2658705,"ip_address":"","ucode":"5CCEC0BAC08AEC","user_header":"https://static001.geekbang.org/account/avatar/00/28/91/91/428a27a3.jpg","comment_is_top":false,"comment_ctime":1625283718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625283718","product_id":100028001,"comment_content":"迭代器会有一个数组下标，直接删除会导致空指针。如果走其他方法，可以搞成奶牛数组list，也能直接删除。","like_count":0},{"had_liked":false,"id":295841,"user_name":"夏日炎炎","can_delete":false,"product_type":"c1","uid":2599977,"ip_address":"","ucode":"3CC2F287F6AE66","user_header":"https://static001.geekbang.org/account/avatar/00/27/ac/29/8e75c8af.jpg","comment_is_top":false,"comment_ctime":1622617349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622617349","product_id":100028001,"comment_content":"Fast fail机制","like_count":0},{"had_liked":false,"id":290808,"user_name":"Zuul","can_delete":false,"product_type":"c1","uid":1269585,"ip_address":"","ucode":"C73BD1767222C6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJeVG7hJqOKibpfMzpnoVIfwDzoqAlbGM7RdQZ1nMTxN2BLRHdZejA19nLEBrLJyUR4eiavjm7wYt8g/132","comment_is_top":false,"comment_ctime":1619764327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619764327","product_id":100028001,"comment_content":"老师你好，有一个疑问，ArrayList是支持排序的，那如果 list里的元素是 【2,5,8,12,14】 如果用默认的add添加一个10，不是也会重排的吗？","like_count":0},{"had_liked":false,"id":288224,"user_name":"Jecy-8","can_delete":false,"product_type":"c1","uid":1016276,"ip_address":"","ucode":"2AE1575B9E63A6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/d4/e92abeb4.jpg","comment_is_top":false,"comment_ctime":1618370392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618370392","product_id":100028001,"comment_content":"如果使用for(;;)，不会报错，但是如果有多个需要删除的元素时会漏掉或错删，因此需要在删除之后i需要重置一下位置<br>for (int i =0; i &lt; list.size(); i ++) {<br>            if (list.get(i).equals(&quot;b&quot;)) {<br>                list.remove(list.get(i));<br>                i --;<br>            }<br>        }","like_count":0},{"had_liked":false,"id":287882,"user_name":"🎄J","can_delete":false,"product_type":"c1","uid":1589452,"ip_address":"","ucode":"0DD6E529B4221A","user_header":"https://static001.geekbang.org/account/avatar/00/18/40/cc/9ff93968.jpg","comment_is_top":false,"comment_ctime":1618206628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618206628","product_id":100028001,"comment_content":"3.LinkedList 新增元素：“之前的 last 对象的前指针指向新节点对象”描述不对吧，我看源码是：<br>if (l == null)<br>            first = newNode;<br>        else<br>            l.next = newNode;<br>所以应该是：如果添加的是第一个元素(l=null)，则将last引用指向新节点对象之前的 last 对象的下一个（next）指针指向新节点对象”","like_count":0},{"had_liked":false,"id":282852,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1096397,"ip_address":"","ucode":"14C0858C413E00","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/cd/1f91aa44.jpg","comment_is_top":false,"comment_ctime":1615439316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615439316","product_id":100028001,"comment_content":"老师您好：怎么知道linkedlist采用for（：）循环调用哪个方法呢？","like_count":0},{"had_liked":false,"id":281188,"user_name":"def","can_delete":false,"product_type":"c1","uid":1263977,"ip_address":"","ucode":"39BDBEA0560C13","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/69/c0fcf4e8.jpg","comment_is_top":false,"comment_ctime":1614613421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614613421","product_id":100028001,"comment_content":"原来forEach 语法糖写法也是用到了内部的Iterator去遍历的，这个地方之前还真的没有留意到...","like_count":0},{"had_liked":false,"id":248357,"user_name":"Geek_d2186f","can_delete":false,"product_type":"c1","uid":2100878,"ip_address":"","ucode":"90A85FFF7A4D51","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erHVh5AkbfJMK2xQlM0vow6UlsOAUQI47tia6SnQsQAujd0yGwRnOtibrEevkzEcdatzBdnCPnd8GyA/132","comment_is_top":false,"comment_ctime":1600132843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600132843","product_id":100028001,"comment_content":"第一种可以，for-each不适用于add和remove等操作，导致list 元素变化。","like_count":0},{"had_liked":false,"id":248353,"user_name":"Geek_d2186f","can_delete":false,"product_type":"c1","uid":2100878,"ip_address":"","ucode":"90A85FFF7A4D51","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erHVh5AkbfJMK2xQlM0vow6UlsOAUQI47tia6SnQsQAujd0yGwRnOtibrEevkzEcdatzBdnCPnd8GyA/132","comment_is_top":false,"comment_ctime":1600132616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600132616","product_id":100028001,"comment_content":"第一种方法和第三种方法都会导致list中元素变化，不适用于add和remove操作，只有第二种请求可以用于add和remove操作。","like_count":0},{"had_liked":false,"id":241642,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1597377017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597377017","product_id":100028001,"comment_content":"总结：<br>1. 头插居多且元素不固定，使用LinkedList，其他情况使用ArrayList；<br>2. 不要用for来遍历LinkedList.<br>思考题:<br>foreach使用迭代器,第一个使用了迭代器的remove，可行。第二个使用了list的remove，modCount会变，再次调用next时会报错。迭代器使用modCount实现fail-fast，以保证迭代过程中如果多线程改变了数据则直接跑错。","like_count":0},{"had_liked":false,"id":239504,"user_name":"别过来你丑到我了(¬_¬)ﾉ","can_delete":false,"product_type":"c1","uid":1733095,"ip_address":"","ucode":"36B032ED2B2B7C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/71/e7/39cf45cc.jpg","comment_is_top":false,"comment_ctime":1596551306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596551306","product_id":100028001,"comment_content":"public static void main(String[] args) {<br>        List&lt;String&gt; var0 = new ArrayList&lt;String&gt;() {<br>            {<br>                this.add(&quot;1&quot;);<br>                this.add(&quot;2&quot;);<br>                this.add(&quot;3&quot;);<br>                this.add(&quot;4&quot;);<br>            }<br>        };<br>        Iterator var1 = var0.iterator();<br><br>        while(var1.hasNext()) {<br>            String var2 = (String)var1.next();<br>            if (var2.equals(&quot;3&quot;)) {<br>                &#47;&#47; 此时这里并不会抛异常，但当 var2 = 1 or 2 or 4 时，则都会抛异常<br>                var0.remove(var2);<br>                &#47;&#47; break;<br>            }<br>        }<br><br>        System.out.println(var0);<br>    }<br><br>背景：JDK1.8，以上代码为增强 for 循环 remove 元素反编译后得到的代码。<br>如代码所示，当元素值等于 3 时，remove掉改元素，按道理应该抛异常，但是没有，换成等于 1 或者 2 或者 4 的时候，都会抛异常，debug 的时候发现，等于 3 remove 掉元素之后，直接退出 while 循环了，但是按道理 hasNext 应该是 true 才对呀，有点困惑，求老师解答~","like_count":0},{"had_liked":false,"id":222857,"user_name":"虞淇淇妈妈","can_delete":false,"product_type":"c1","uid":1587402,"ip_address":"","ucode":"369EDCFFEA11B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/38/ca/7a151456.jpg","comment_is_top":false,"comment_ctime":1590931732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590931732","product_id":100028001,"comment_content":"中间位置添加元素，ArryList的代码有问题啊","like_count":0},{"had_liked":false,"id":210160,"user_name":"guohuibo","can_delete":false,"product_type":"c1","uid":1813366,"ip_address":"","ucode":"B89CA3D227790A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ab/76/38975d8c.jpg","comment_is_top":false,"comment_ctime":1587692736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587692736","product_id":100028001,"comment_content":"public class LinkedList&lt;E&gt;<br>    extends AbstractSequentialList&lt;E&gt;<br>    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable<br>老师想问个问题，LinkedList继承了AbstractSequentialList,但是AbstractSequentialList已经实现了List接口，那么为啥LinkedList还要再次实现List接口了?有什么好处吗?","like_count":0},{"had_liked":false,"id":204182,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1586347294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586347294","product_id":100028001,"comment_content":"只在数组末尾添加元素，那么 ArrayList 在大量新增元素的场景下，性能并不会变差，反而比其他 List 集合的性能要好。<br><br>这种情况比linklist性能好的依据是什么，毕竟linkedlist是双向链表，时间复杂度也是O(1)啊。","like_count":0},{"had_liked":false,"id":164548,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1577025631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577025631","product_id":100028001,"comment_content":"对于linkedList的遍历、remove、get方法，都会用到java.util.LinkedList#node方法，而老师讲到的删除位置的查找，遍历的问题，都是因为这个方法中的内容。","like_count":0},{"had_liked":false,"id":152780,"user_name":"思忆","can_delete":false,"product_type":"c1","uid":1199451,"ip_address":"","ucode":"26B307A6C4F35C","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/5b/3ed7df22.jpg","comment_is_top":false,"comment_ctime":1574079384,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574079384","product_id":100028001,"comment_content":"这两种都不正确，因为增强for循环的底层使用的是迭代器，再删除过程中，指针发生变化，所以会异常","like_count":0},{"had_liked":false,"id":148924,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1573110121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573110121","product_id":100028001,"comment_content":"思考题是初级开发者在使用remove的时候普遍遇到的问题，第一个使用迭代器成功，第二个会报错！","like_count":0},{"had_liked":false,"id":143211,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571649383,"is_pvip":false,"replies":[{"id":"56524","content":"因为数组是连续性的存储结构，在新增数据时，如果不是想数组尾部顺序插入元素，则会涉及到其他数据的重新排列，性能就会差了。虽然查询性能很优秀，但在新增和删除数据时，性能就会变差了。<br><br>第二个问题已经回答了。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1572521369,"ip_address":"","comment_id":143211,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571649383","product_id":100028001,"comment_content":"看了老师如下的回答不是很明白，为什么数组过长新增数据的性能就下降了呢？因为数组越长hash碰撞的几率越小，那么性能越高才对。<br><br>老师您好，我比较好奇的是为什么 ArrayList 不像 HashMap 一样在扩容时需要一个负载因子呢？<br><br>作者回复: HashMap有负载因子是既要考虑数组太短，因哈希冲突导致链表过长而导致查询性能下降，也考虑了数组过长，新增数据时性能下降。这个负载因子是综合了数组和链表两者的长度，不能太大也不能太小。而ArrayList不需要这种考虑。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471422,"discussion_content":"因为数组是连续性的存储结构，在新增数据时，如果不是想数组尾部顺序插入元素，则会涉及到其他数据的重新排列，性能就会差了。虽然查询性能很优秀，但在新增和删除数据时，性能就会变差了。\n\n第二个问题已经回答了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572521369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139363,"user_name":"Sdylan","can_delete":false,"product_type":"c1","uid":1008503,"ip_address":"","ucode":"4589D0D0FA9275","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/77/423345ab.jpg","comment_is_top":false,"comment_ctime":1570619200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570619200","product_id":100028001,"comment_content":"2019.10.09 打卡 开眼界了 从源头分析 得到自己的结论 值得学习一把","like_count":0},{"had_liked":false,"id":131671,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1567842819,"is_pvip":false,"replies":[{"id":"51131","content":"性能应该对应具体场景来分析，同理，优化空间也是根据具体场景来进行优化。目前，大部分通用的源码都是兼容了大部分场景来实现的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568538796,"ip_address":"","comment_id":131671,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567842819","product_id":100028001,"comment_content":"课后思考及问题<br>请问老师你仔细研究过ArrayList和LinkedList之后，你觉得他们在性能上是否做到了极致？是否还存在优化的空间？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466566,"discussion_content":"性能应该对应具体场景来分析，同理，优化空间也是根据具体场景来进行优化。目前，大部分通用的源码都是兼容了大部分场景来实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568538796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131429,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1567750508,"is_pvip":false,"replies":[{"id":"49878","content":"具体的测试代码可以在github中查看，如果对测试结果有疑问，可以深入源码查看相应的实现，分析性能。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567771641,"ip_address":"","comment_id":131429,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567750508","product_id":100028001,"comment_content":"先说思考题   写法1正确，在ForEach遍历，或者fori遍历时，是禁止在内部删除数据的，会报错。<br><br>还有就是添加元素和删除元素的问题。这个测试不严谨。没有写明测试环境和测试代码。也没有测试数据。<br>个人测试的结果是，全都是ArrayList更快。个人表示，也出乎我的意料。最起码在我个人的理解里，链表插入数据明显会更快。 因为不需要考虑数据扩容的问题。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466446,"discussion_content":"具体的测试代码可以在github中查看，如果对测试结果有疑问，可以深入源码查看相应的实现，分析性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567771641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114401,"user_name":"Gankki","can_delete":false,"product_type":"c1","uid":1190150,"ip_address":"","ucode":"399C6F74286590","user_header":"https://static001.geekbang.org/account/avatar/00/12/29/06/0b327738.jpg","comment_is_top":false,"comment_ctime":1563289969,"is_pvip":false,"replies":[{"id":"42350","content":"把老师考到了，现在数据结构这块很多都是以这种内部类来设计的，没有发现有特别的考虑。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563760013,"ip_address":"","comment_id":114401,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563289969","product_id":100028001,"comment_content":"老师，您好。LinkedList 中 Node 是私有的静态内部类，除了防止内存泄露吗？还有其他的设计考虑吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458645,"discussion_content":"把老师考到了，现在数据结构这块很多都是以这种内部类来设计的，没有发现有特别的考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563760013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109639,"user_name":"我戒酒了","can_delete":false,"product_type":"c1","uid":1073281,"ip_address":"","ucode":"7B4764646AB2A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/81/cfc17578.jpg","comment_is_top":false,"comment_ctime":1562070293,"is_pvip":false,"replies":[{"id":"40397","content":"对的，感谢细心的你提醒","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562466084,"ip_address":"","comment_id":109639,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562070293","product_id":100028001,"comment_content":"ArrayListTest 的这个测试方法笔误写错了吧\t<br>public static void addFromMidTest(int DataNum) {<br>\t\tArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(DataNum);<br>\t\tint i = 0;<br>\t\t<br>\t\tlong timeStart = System.currentTimeMillis();<br>\t\twhile (i &lt; DataNum) {<br>\t\t\tint temp = list.size();<br>\t\t\tlist.add(temp&#47;2+&quot;aaavvv&quot;); &#47;&#47;正确写法list.add(temp&#47;2, +&quot;aaavvv&quot;);<br>\t\t\ti++;<br>\t\t}<br>\t\tlong timeEnd = System.currentTimeMillis();<br><br>\t\tSystem.out.println(&quot;ArrayList从集合中间位置新增元素花费的时间&quot; + (timeEnd - timeStart));<br>\t}","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456492,"discussion_content":"对的，感谢细心的你提醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562466084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109474,"user_name":"吃胖了再减肥再吃再健身之谜之不瘦","can_delete":false,"product_type":"c1","uid":1588087,"ip_address":"","ucode":"BDDB3BA9D23F3A","user_header":"","comment_is_top":false,"comment_ctime":1562039481,"is_pvip":false,"replies":[{"id":"40398","content":"老师没有在查询时同时新增测试，考虑的只是单个场景下的测试。ArrayList新增需要固定一个初始化大小，如果默认初始化大小，则会在新增时出现扩容的情况，这样性能反而会降低。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562466287,"ip_address":"","comment_id":109474,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562039481","product_id":100028001,"comment_content":"老师，我用的测试代码试了好多次，在“从集合尾部位置新增元素”这个场景下，我测试的结果是“ArrayList&gt;LinkedList”，你代码里面的1000000，一百万次遍历时，会有少量的情况出现“ArrayList&lt;LinkedList”，所以我讲遍历次数增加到10000000，一千万次遍历，测试结果如下<br>第一次：<br>ArrayList从集合尾部位置新增元素花费的时间4690<br>LinkedList从集合尾部位置新增元素花费的时间2942<br>第二次：<br>ArrayList从集合尾部位置新增元素花费的时间4655<br>LinkedList从集合尾部位置新增元素花费的时间2798<br>第三次：<br>ArrayList从集合尾部位置新增元素花费的时间5126<br>LinkedList从集合尾部位置新增元素花费的时间2960<br><br>从这个场景看来，大数据量遍历的情况下，LinkedList新增数据比较快，不知道我这个验证的结果是否正确，期待老师指教，谢谢！","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456429,"discussion_content":"老师没有在查询时同时新增测试，考虑的只是单个场景下的测试。ArrayList新增需要固定一个初始化大小，如果默认初始化大小，则会在新增时出现扩容的情况，这样性能反而会降低。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562466287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105586,"user_name":"无忧","can_delete":false,"product_type":"c1","uid":1474325,"ip_address":"","ucode":"CC46D589F59D9C","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/15/7d670139.jpg","comment_is_top":false,"comment_ctime":1561036096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561036096","product_id":100028001,"comment_content":"老师，你好。ArrayList删除元素时将对应位置元素设置为null。代码注释说GC会回收，请问回收是什么时候触发呢。<br>如果元素为空就会被回收的话，AreayList在扩容时未使用的数组部分会不会也是空的被回收呢？<br> public E remove(int index) {<br>        rangeCheck(index);<br><br>        modCount++;<br>        E oldValue = elementData(index);<br><br>        int numMoved = size - index - 1;<br>        if (numMoved &gt; 0)<br>            System.arraycopy(elementData, index+1, elementData, index,<br>                             numMoved);<br>        elementData[--size] = null; &#47;&#47; clear to let GC do its work<br><br>        return oldValue;<br>    }<br>","like_count":0},{"had_liked":false,"id":105582,"user_name":"无忧","can_delete":false,"product_type":"c1","uid":1474325,"ip_address":"","ucode":"CC46D589F59D9C","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/15/7d670139.jpg","comment_is_top":false,"comment_ctime":1561035723,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1561035723","product_id":100028001,"comment_content":"老师你好。ArrayLists删除元素时<br> public E remove(int index) {<br>        rangeCheck(index);<br><br>        modCount++;<br>        E oldValue = elementData(index);<br><br>        int numMoved = size - index - 1;<br>        if (numMoved &gt; 0)<br>            System.arraycopy(elementData, index+1, elementData, index,<br>                             numMoved);<br>        elementData[--size] = null; &#47;&#47; clear to let GC do its work<br><br>        return oldValue;<br>    }<br>","like_count":0,"discussions":[{"author":{"id":1667383,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epVWzibg2dH85DwtWJibyUGUoDg3CJQI5n2KvQKVsOsh57YvK2aXNBeDec8KHZQFeibsmPnxibPG600mA/132","nickname":"Geek_19cff2","note":"","ucode":"B069B4A32D8DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198828,"discussion_content":"如果有答案，麻烦告知一下，谢谢🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583516047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667383,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epVWzibg2dH85DwtWJibyUGUoDg3CJQI5n2KvQKVsOsh57YvK2aXNBeDec8KHZQFeibsmPnxibPG600mA/132","nickname":"Geek_19cff2","note":"","ucode":"B069B4A32D8DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198827,"discussion_content":"兄弟，你这个问题问的太好了，我也想不明白，万一再遍历删除时，碰到垃圾回收，这个时候会不会报错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583516006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105183,"user_name":"码德纽@宝","can_delete":false,"product_type":"c1","uid":1345546,"ip_address":"","ucode":"FA4088B0DD4EBB","user_header":"https://static001.geekbang.org/account/avatar/00/14/88/0a/31e6d5bb.jpg","comment_is_top":false,"comment_ctime":1560934490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560934490","product_id":100028001,"comment_content":"我个人感觉arraylist和linkedlist性能最大的区别在于arraylist需要重新组排和扩容的开销。","like_count":0},{"had_liked":false,"id":102123,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1560142144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560142144","product_id":100028001,"comment_content":"源码粘贴不完。大概描述一下<br><br>方法1 最后是通过调用迭代器remove(int index)，是直接删除对应下标的元素。<br>方法2 最终是  如果b存在，那么调用list的remove（Object o），list的remove是删除指定对象equlse为true的第一个元素。<br><br>方法2 其实是转换为迭代器遍历，迭代器遍历的过程中使用了list的删除，导致迭代器下标越界。<br><br>顺便说下，自认为还有方法3<br>public static void remove3(ArrayList&lt;String&gt; list){<br>    while (list.remove(&quot;b&quot;)){<br>    }<br>  }<br>这种方式删除元素 好像也是可以的。","like_count":0},{"had_liked":false,"id":102107,"user_name":"Bruce","can_delete":false,"product_type":"c1","uid":1563508,"ip_address":"","ucode":"86EA64F24CD4BA","user_header":"https://static001.geekbang.org/account/avatar/00/17/db/74/d513e7d7.jpg","comment_is_top":false,"comment_ctime":1560138122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560138122","product_id":100028001,"comment_content":"”之前的 last 对象的前指针指向新节点对象。”<br><br>这句话  为什么是前指针呢 代码里写的是  l.next = newNode;<br>","like_count":0},{"had_liked":false,"id":101390,"user_name":"iusugar","can_delete":false,"product_type":"c1","uid":1485845,"ip_address":"","ucode":"1372E5AD2068D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/ac/15/935acedb.jpg","comment_is_top":false,"comment_ctime":1559797056,"is_pvip":false,"replies":[{"id":"36585","content":"收到，和老师说过了，这讲的会尽快加上，感谢你的建议！","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1559834747,"ip_address":"","comment_id":101390,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1559797056","product_id":100028001,"comment_content":"老师，可以在代码块多加一些注释吗？有些变量和方法不是很明白。原谅我比较菜...","like_count":0,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452941,"discussion_content":"收到，和老师说过了，这讲的会尽快加上，感谢你的建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559834747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101239,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1559747380,"is_pvip":false,"replies":[{"id":"36495","content":"是不会报错了，但剩余的业务就无法进行下去了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559780524,"ip_address":"","comment_id":101239,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559747380","product_id":100028001,"comment_content":"第二种remove后加个return就不报错了吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452862,"discussion_content":"是不会报错了，但剩余的业务就无法进行下去了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559780524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100034,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1559398065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559398065","product_id":100028001,"comment_content":"所以好像遇到这种问题，不能一上来就定性，ArrayList就是擅长随即访问，LinkedList就是擅长增加、删除。要基于不同的情况去分析问题，会让你有新的发现。","like_count":0},{"had_liked":false,"id":99974,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1559374908,"is_pvip":false,"replies":[{"id":"36215","content":"很赞成，需要根据不同的业务场景考虑，实际场景中的问题更复杂。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559570296,"ip_address":"","comment_id":99974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559374908","product_id":100028001,"comment_content":"实际场景使用中linked list的效率应该还要更低吧？因为要考虑到内存结构紧凑的问题。array list在删除时候移动元素，很大可能是在一个cache line上操作，会很快，但linked list就未必了：写测试代码，linked list的元素总是连贯的。但实际使用场景一定是不连贯的。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452346,"discussion_content":"很赞成，需要根据不同的业务场景考虑，实际场景中的问题更复杂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559570296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99911,"user_name":"清风拂面","can_delete":false,"product_type":"c1","uid":1321278,"ip_address":"","ucode":"8D858D70F0851E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbBZ9iaHfebHH4kOzFvxvs8Hx5iaUruAZvE8Dj4nia0mk4uxLc2rRUZD0ic9uKdxLibib0dGSaibL6NGRUg/132","comment_is_top":false,"comment_ctime":1559357175,"is_pvip":false,"replies":[{"id":"35868","content":"同学你好～你是想说ArrayList从头插入元素和从尾部插入元素的速度问题吗？从头部插入，存在数组复制，从尾部不存在。所以从尾部插入的速度要比头部快。","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1559359681,"ip_address":"","comment_id":99911,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1559357175","product_id":100028001,"comment_content":"文稿关于从头部和尾部插入新元素所用时间那一块反了","like_count":0,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452321,"discussion_content":"同学你好～你是想说ArrayList从头插入元素和从尾部插入元素的速度问题吗？从头部插入，存在数组复制，从尾部不存在。所以从尾部插入的速度要比头部快。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559359681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99498,"user_name":"小辉辉","can_delete":false,"product_type":"c1","uid":1189661,"ip_address":"","ucode":"9FF25E25C85350","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","comment_is_top":false,"comment_ctime":1559230424,"is_pvip":false,"replies":[{"id":"35840","content":"希望在这个专栏后面更多的帮助到你，避免踩坑！","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559307325,"ip_address":"","comment_id":99498,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559230424","product_id":100028001,"comment_content":"第一种是对的，第二种情况说的就是我之前干过的事情，而且当时出现有时报错，有时不报错。自己踩过的坑，记忆深刻😂😂😂","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452139,"discussion_content":"希望在这个专栏后面更多的帮助到你，避免踩坑！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559307325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99428,"user_name":"阳阳","can_delete":false,"product_type":"c1","uid":1159221,"ip_address":"","ucode":"BD7404A3AE79E4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/35/44e5516e.jpg","comment_is_top":false,"comment_ctime":1559212121,"is_pvip":true,"replies":[{"id":"35728","content":"答对了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559225865,"ip_address":"","comment_id":99428,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1559212121","product_id":100028001,"comment_content":"写法一是正确的，写法二会报错。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452104,"discussion_content":"答对了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559225865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99401,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1559207415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559207415","product_id":100028001,"comment_content":"老师，用foreach循环删除集合里倒数第二个元素，为什么不会报错？","like_count":0},{"had_liked":false,"id":99393,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1559205449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559205449","product_id":100028001,"comment_content":"第一种是对的。第二种会报java.util.ConcurrentModificationException","like_count":0},{"had_liked":false,"id":99287,"user_name":"半清醒","can_delete":false,"product_type":"c1","uid":1467843,"ip_address":"","ucode":"119F57A160DD8C","user_header":"https://static001.geekbang.org/account/avatar/00/16/65/c3/5324b326.jpg","comment_is_top":false,"comment_ctime":1559186449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559186449","product_id":100028001,"comment_content":"收获颇多！！","like_count":0},{"had_liked":false,"id":99251,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1559182335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559182335","product_id":100028001,"comment_content":"请问下文中提到有关LinkedList在1.7之后的改动：first&#47;last 方式可以在初始化 LinkedList 的时候节省 new 一个 Entry。原因是？作者可否指名下，感谢！","like_count":0},{"had_liked":false,"id":99224,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1559179223,"is_pvip":false,"replies":[{"id":"35747","content":"如果存在大量扩容，我相信你的测试不准确。for(:)这种写法就是增强型，是一个语法糖。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559227489,"ip_address":"","comment_id":99224,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559179223","product_id":100028001,"comment_content":"老师好!这个我测试过。增加元素的话，就算不设置初始值，array也比linked快。随机，增删的话，增删元素靠近前部的话linked比array快。list总元素越大，linked比array快的比例越少。根据元素的位子不array的性能会比较稳定，linked差别挺大的。循环的话都用增强型for循环，基本看不出多大差别。测试结果和老师讲的符合。老师我有个问题:网上都说增强型for循环只是个语法糖底层还是迭代器遍历。课后习题第二种会报错的吧?","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452026,"discussion_content":"如果存在大量扩容，我相信你的测试不准确。for(:)这种写法就是增强型，是一个语法糖。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559227489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99221,"user_name":"大卫","can_delete":false,"product_type":"c1","uid":1019127,"ip_address":"","ucode":"D861709E483793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/f7/a4de6f64.jpg","comment_is_top":false,"comment_ctime":1559179026,"is_pvip":false,"replies":[{"id":"35746","content":"因为可以减少遍历的发生。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559227389,"ip_address":"","comment_id":99221,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559179026","product_id":100028001,"comment_content":"为什么迭代器方式比for效率要高呢?<br><br>最后的问题是使用迭代方式去remove，直接for循环遍历remove可能会导致ConcurrentModifedException异常","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452024,"discussion_content":"因为可以减少遍历的发生。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559227389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99183,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1559175539,"is_pvip":false,"replies":[{"id":"35745","content":"你是说LinkedList使用迭代器比for循环高吗，使用for需要遍历list，而使用iterator可以减少遍历。第二问题，你说的对的，这个接口只是一个标准罢了。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559227349,"ip_address":"","comment_id":99183,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559175539","product_id":100028001,"comment_content":"为什么直接使用迭代器会比使用for循环遍历方式高呢，另外，如果是遍历的话，randomaccess并不重要吧，链表也能通过指针一次拿到下个元素的地址","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452007,"discussion_content":"你是说LinkedList使用迭代器比for循环高吗，使用for需要遍历list，而使用iterator可以减少遍历。第二问题，你说的对的，这个接口只是一个标准罢了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559227349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99169,"user_name":"a、","can_delete":false,"product_type":"c1","uid":1532404,"ip_address":"","ucode":"590FE8DB111492","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","comment_is_top":false,"comment_ctime":1559174050,"is_pvip":false,"replies":[{"id":"35744","content":"这个理解有点偏差，建议看留言区的正确解释。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559227024,"ip_address":"","comment_id":99169,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559174050","product_id":100028001,"comment_content":"删除arrayList应该倒序删除，这样就不会出现少删除的情况，因为arraylist每删除一个元素，arraylist都会把内部数组元素从新排列一次，第一个删除是对的，第二个会出现ConcurrentModificationException","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452001,"discussion_content":"这个理解有点偏差，建议看留言区的正确解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559227024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99163,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1559173632,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559173632","product_id":100028001,"comment_content":"第一个正确，最大感受时间复杂度这个东东要充分考虑场景，系数，io复杂度等等才能在实际工程有其意义。","like_count":0},{"had_liked":false,"id":99130,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1559150487,"is_pvip":false,"replies":[{"id":"35735","content":"答案已经给出，希望能帮助你减少平时使用arraylist的潜在问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559226455,"ip_address":"","comment_id":99130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559150487","product_id":100028001,"comment_content":"思考:<br><br>我觉得第二种写法是对的，之前也一直是用的这种写法。而且，删除之后，数据的改变会反应在list上。<br><br>第一种写法没怎么用过，看写法，在删除元素之后。数据的变更并不会体现在list上。<br><br>如有不正确，请指正。谢谢。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451981,"discussion_content":"答案已经给出，希望能帮助你减少平时使用arraylist的潜在问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559226455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}