{"id":156849,"title":"07 | DDD分层架构：有效降低层与层之间的依赖","content":"<p>你好，我是欧创新。前面我们讲了DDD的一些重要概念以及领域模型的设计理念。今天我们来聊聊“DDD分层架构”。</p><p>微服务架构模型有好多种，例如整洁架构、CQRS和六边形架构等等。每种架构模式虽然提出的时代和背景不同，但其核心理念都是为了设计出“高内聚低耦合”的架构，轻松实现架构演进。而DDD分层架构的出现，使架构边界变得越来越清晰，它在微服务架构模型中，占有非常重要的位置。</p><p>那DDD分层架构到底长什么样？DDD分层架构如何推动架构演进？我们该怎么转向DDD分层架构？这就是我们这一讲重点要解决的问题。</p><h2>什么是DDD分层架构？</h2><p>DDD的分层架构在不断发展。最早是传统的四层架构；后来四层架构有了进一步的优化，实现了各层对基础层的解耦；再后来领域层和应用层之间增加了上下文环境（Context）层，五层架构（DCI）就此形成了。</p><p><img src=\"https://static001.geekbang.org/resource/image/d6/e1/d6abc3e4f5837cd51b689d01433cace1.jpg?wh=1300*636\" alt=\"\"></p><p>我们看一下上面这张图，在最早的传统四层架构中，基础层是被其它层依赖的，它位于最核心的位置，那按照分层架构的思想，它应该就是核心，但实际上领域层才是软件的核心，所以这种依赖是有问题的。后来我们采用了依赖倒置（Dependency inversion principle,DIP）的设计，优化了传统的四层架构，实现了各层对基础层的解耦。</p><!-- [[[read_end]]] --><p>我们今天讲的DDD分层架构就是优化后的四层架构。在下面这张图中，从上到下依次是：用户接口层、应用层、领域层和基础层。那DDD各层的主要职责是什么呢？下面我来逐一介绍一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/9d/d02e92626dd8d6b077002ab6b977159d.png?wh=964*872\" alt=\"\"></p><p>1.<strong>用户接口层</strong></p><p>用户接口层负责向用户显示信息和解释用户指令。这里的用户可能是：用户、程序、自动化测试和批处理脚本等等。</p><p>2.<strong>应用层</strong></p><p>应用层是很薄的一层，理论上不应该有业务规则或逻辑，主要面向用例和流程相关的操作。但应用层又位于领域层之上，因为领域层包含多个聚合，所以它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作。</p><p>此外，应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排。</p><p>这里我要提醒你一下：在设计和开发时，不要将本该放在领域层的业务逻辑放到应用层中实现。因为庞大的应用层会使领域模型失焦，时间一长你的微服务就会演化为传统的三层架构，业务逻辑会变得混乱。</p><p>另外，应用服务是在应用层的，它负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装，以粗粒度的服务通过API网关向前端发布。还有，应用服务还可以进行安全认证、权限校验、事务控制、发送或订阅领域事件等。</p><p>3.<strong>领域层</strong></p><p>领域层的作用是实现企业核心业务逻辑，通过各种校验手段保证业务的正确性。领域层主要体现领域模型的业务能力，它用来表达业务概念、业务状态和业务规则。</p><p>领域层包含聚合根、实体、值对象、领域服务等领域模型中的领域对象。</p><p>这里我要特别解释一下其中几个领域对象的关系，以便你在设计领域层的时候能更加清楚。首先，领域模型的业务逻辑主要是由实体和领域服务来实现的，其中实体会采用充血模型来实现所有与之相关的业务功能。其次，你要知道，实体和领域服务在实现业务逻辑上不是同级的，当领域中的某些功能，单一实体（或者值对象）不能实现时，领域服务就会出马，它可以组合聚合内的多个实体（或者值对象），实现复杂的业务逻辑。</p><p>4.<strong>基础层</strong></p><p>基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。</p><p>基础层包含基础服务，它采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。</p><p>比如说，在传统架构设计中，由于上层应用对数据库的强耦合，很多公司在架构演进中最担忧的可能就是换数据库了，因为一旦更换数据库，就可能需要重写大部分的代码，这对应用来说是致命的。那采用依赖倒置的设计以后，应用层就可以通过解耦来保持独立的核心业务逻辑。当数据库变更时，我们只需要更换数据库基础服务就可以了，这样就将资源变更对应用的影响降到了最低。</p><h3>DDD分层架构最重要的原则是什么？</h3><p>在《实现领域驱动设计》一书中，DDD分层架构有一个重要的原则：<span class=\"orange\">每层只能与位于其下方的层发生耦合。</span></p><p>而架构根据耦合的紧密程度又可以分为两种：严格分层架构和松散分层架构。优化后的DDD分层架构模型就属于严格分层架构，任何层只能对位于其直接下方的层产生依赖。而传统的DDD分层架构则属于松散分层架构，它允许某层与其任意下方的层发生依赖。</p><p>那我们怎么选呢？综合我的经验，为了服务的可管理，我建议你采用严格分层架构。</p><p>在严格分层架构中，领域服务只能被应用服务调用，而应用服务只能被用户接口层调用，服务是逐层对外封装或组合的，依赖关系清晰。而在松散分层架构中，领域服务可以同时被应用层或用户接口层调用，服务的依赖关系比较复杂且难管理，甚至容易使核心业务逻辑外泄。</p><p>试想下，如果领域层中的某个服务发生了重大变更，那该如何通知所有调用方同步调整和升级呢？但在严格分层架构中，你只需要逐层通知上层服务就可以了。</p><h2>DDD分层架构如何推动架构演进？</h2><p>领域模型不是一成不变的，因为业务的变化会影响领域模型，而领域模型的变化则会影响微服务的功能和边界。那我们该如何实现领域模型和微服务的同步演进呢？</p><p>1.<strong>微服务架构的演进</strong></p><p>通过基础篇的讲解，我们知道：领域模型中对象的层次从内到外依次是：值对象、实体、聚合和限界上下文。</p><p>实体或值对象的简单变更，一般不会让领域模型和微服务发生大的变化。但聚合的重组或拆分却可以。这是因为聚合内业务功能内聚，能独立完成特定的业务逻辑。那聚合的重组或拆分，势必就会引起业务模块和系统功能的变化了。</p><p>这里我们可以以聚合为基础单元，完成领域模型和微服务架构的演进。聚合可以作为一个整体，在不同的领域模型之间重组或者拆分，或者直接将一个聚合独立为微服务。</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/7c/7f1e3891c9c11abce96020e0bf20d67c.jpg?wh=1212*754\" alt=\"\"></p><p>我们结合上图，以微服务1为例，讲解下微服务架构的演进过程：</p><ul>\n<li>当你发现微服务1中聚合a的功能经常被高频访问，以致拖累整个微服务1的性能时，我们可以把聚合a的代码，从微服务1中剥离出来，独立为微服务2。这样微服务2就可轻松应对高性能场景。</li>\n<li>在业务发展到一定程度以后，你会发现微服务3的领域模型有了变化，聚合d会更适合放到微服务1的领域模型中。这时你就可以将聚合d的代码整体搬迁到微服务1中。如果你在设计时已经定义好了聚合之间的代码边界，这个过程不会太复杂，也不会花太多时间。</li>\n<li>最后我们发现，在经历模型和架构演进后，微服务1已经从最初包含聚合a、b、c，演进为包含聚合b、c、d的新领域模型和微服务了。</li>\n</ul><p>你看，好的聚合和代码模型的边界设计，可以让你快速应对业务变化，轻松实现领域模型和微服务架构的演进。你可能还会想，那怎么实现聚合代码快速重组呢？别急，后面实战篇会详细讲解，这里我们先感知下大的实现流程。</p><p>2.<strong>微服务内服务的演进</strong></p><p>在微服务内部，实体的方法被领域服务组合和封装，领域服务又被应用服务组合和封装。在服务逐层组合和封装的过程中，你会发现这样一个有趣的现象。</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/76/9a602b741c222b19c7cc4780da79cf76.jpg?wh=1814*902\" alt=\"\"></p><p>我们看下上面这张图。在服务设计时，你并不一定能完整预测有哪些下层服务会被多少个上层服务组装，因此领域层通常只提供一些原子服务，比如领域服务a、b、c。但随着系统功能增强和外部接入越来越多，应用服务会不断丰富。有一天你会发现领域服务b和c同时多次被多个应用服务调用了，执行顺序也基本一致。这时你可以考虑将b和c合并，再将应用服务中b、c的功能下沉到领域层，演进为新的领域服务（b+c）。这样既减少了服务的数量，也减轻了上层服务组合和编排的复杂度。</p><p>你看，这就是服务演进的过程，它是随着你的系统发展的，最后你会发现你的领域模型会越来越精炼，越来越能适应需求的快速变化。</p><h2>三层架构如何演进到DDD分层架构？</h2><p>综合前面的讲解，相信DDD分层架构的优势，你心里也有个谱了。我们不妨总结一下最最重要两点。</p><p>首先，由于层间松耦合，我们可以专注于本层的设计，而不必关心其它层，也不必担心自己的设计会影响其它层。可以说，DDD成功地降低了层与层之间的依赖。</p><p>其次，分层架构使得程序结构变得清晰，升级和维护更加容易。我们修改某层代码时，只要本层的接口参数不变，其它层可以不必修改。即使本层的接口发生变化，也只影响相邻的上层，修改工作量小且错误可以控制，不会带来意外的风险。</p><p><strong>那我们该怎样转向DDD分层架构呢？不妨看看下面这个过程。</strong></p><p>传统企业应用大多是单体架构，而单体架构则大多是三层架构。三层架构解决了程序内代码间调用复杂、代码职责不清的问题，但这种分层是逻辑概念，在物理上它是中心化的集中式架构，并不适合分布式微服务架构。</p><p>DDD分层架构中的要素其实和三层架构类似，只是在DDD分层架构中，这些要素被重新归类，重新划分了层，确定了层与层之间的交互规则和职责边界。</p><p><img src=\"https://static001.geekbang.org/resource/image/16/a1/1680723ca91aa57d719d5cdbc1d910a1.jpg?wh=1700*1268\" alt=\"\"></p><p>我们看一下上面这张图，分析一下从三层架构向DDD分层架构演进的过程。</p><p>首先，你要清楚，三层架构向DDD分层架构演进，主要发生在业务逻辑层和数据访问层。</p><p>DDD分层架构在用户接口层引入了DTO，给前端提供了更多的可使用数据和更高的展示灵活性。</p><p>DDD分层架构对三层架构的业务逻辑层进行了更清晰的划分，改善了三层架构核心业务逻辑混乱，代码改动相互影响大的情况。DDD分层架构将业务逻辑层的服务拆分到了应用层和领域层。应用层快速响应前端的变化，领域层实现领域模型的能力。</p><p>另外一个重要的变化发生在数据访问层和基础层之间。三层架构数据访问采用DAO方式；DDD分层架构的数据库等基础资源访问，采用了仓储（Repository）设计模式，通过依赖倒置实现各层对基础资源的解耦。</p><p>仓储又分为两部分：仓储接口和仓储实现。仓储接口放在领域层中，仓储实现放在基础层。原来三层架构通用的第三方工具包、驱动、Common、Utility、Config等通用的公共的资源类统一放到了基础层。</p><p>最后，我想说，传统三层架构向DDD分层架构的演进，体现的正是领域驱动设计思想的演进。希望你也感受到了，并尝试将其应用在自己的架构设计中。</p><h2>总结</h2><p>今天我们主要讲了DDD的分层架构，它作为微服务的核心框架，我想怎么强调其重要性都是不过分的。</p><p>DDD分层架构包含用户接口层、应用层、领域层和基础层。通过这些层次划分，我们可以明确微服务各层的职能，划定各领域对象的边界，确定各领域对象的协作方式。这种架构既体现了微服务设计和架构演进的需求，又很好地融入了领域模型的概念，二者无缝结合，相信会给你的微服务设计带来不一样的感觉。</p><h2>思考题</h2><p>请结合你的业务场景中，思考一下领域层会有哪些领域对象，应用层会有哪些领域对象？</p><p>欢迎留言和我分享你的思考，你也可以把今天所学分享给身边的朋友，邀请他加入探讨，共同进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/33/7b1a917aff0ec923b78a54e81ed90733.jpg?wh=1110*659\" alt=\"unpreview\"></p>","comments":[{"had_liked":false,"id":257445,"user_name":"平平淡淡财是真","can_delete":false,"product_type":"c1","uid":2033476,"ip_address":"","ucode":"BC23C8A194DDA3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/07/44/1df0e4cd.jpg","comment_is_top":false,"comment_ctime":1603973819,"is_pvip":false,"replies":[{"id":"94081","content":"在传统的三层架构里面可能没有这么多的对象。而在DDD中增加这些对象主要是为了实现各层以及领域模型中DO对象与前端VO或传输对象DTO和后端数据库PO的解耦。<br>DDD中主要有一下几类对象。<br>数据持久化对象 (Persistent Object， PO)，与数据库结构一一映射，它是数据持久化过程中的数据载体。<br>领域对象（ Domain Object， DO），微服务运行时核心业务对象的载体， DO 一般包括实体或值对象。<br>数据传输对象（ Data Transfer Object， DTO），用于前端应用与微服务应用层或者微服务之间的数据组装和传输，是应用之间数据传输的载体。<br>视图对象（View Object， VO），用于封装展示层指定页面或组件的数据。<br>微服务基础层的主要数据对象是PO。在设计时，我们需要先建立DO和PO的映射关系。大多数情况下DO和PO是一一对应的。但也有DO和PO多对多的情况。在DO和PO数据转换时，需要进行数据重组。对于DO对象较多复杂的数据转换操作，你可以在聚合用工厂模式来实现。<br>当DO数据需要持久化时，先将DO转换为PO对象，由仓储实现服务完成数据库持久化操作。<br>当DO需要构建和数据初始化时，仓储实现服务先从数据库获取PO对象，将PO转换为DO后，完成DO数据构建和初始化。<br>领域层主要是DO对象。DO是实体和值对象的数据和业务行为载体，承载着基础的核心业务逻辑，多个依赖紧密的DO对象构成聚合。领域层DO对象在持久化时需要转换为PO对象。<br>应用层主要对象有DO对象，但也可能会有DTO对象。应用层在进行不同聚合的领域服务编排时，一般建议采用聚合根ID的引用方式，应尽量避免不同聚合之间的DO对象直接引用，避免聚合之间产生依赖。<br>在涉及跨微服务的应用服务调用时，在调用其他微服务的应用服务前，DO会被转换为DTO，完成跨微服务的DTO数据组装，因此会有DTO对象。<br>在前端调用后端应用服务时，用户接口层先完成DTO到DO的转换，然后DO作为应用服务的参数，传导到领域层完成业务逻辑处理。<br>用户接口层主要完成DO和DTO的互转，完成微服务与前端应用数据交互和转换。<br>facade接口服务在完成后端应用服务封装后，会对多个DO对象进行组装，转换为DTO对象，向前端应用完成数据转换和传输。<br>facade接口服务在接收到前端应用传入的DTO后，完成DTO向多个DO对象的转换，调用后端应用服务完成业务逻辑处理。<br>前端应用主要是VO对象。展现层使用VO进行界面展示，通过用户接口层与应用层采用DTO对象进行数据交互。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1604392104,"ip_address":"","comment_id":257445,"utype":1}],"discussion_count":4,"race_medal":0,"score":"529884951227","product_id":100037301,"comment_content":"老师你好，问一个对象命名的问题，例如：VO、DO、DTO、PO、POJO、Entity、model这些使用场景和代表的含义是什么？帖子上看的解释各不相同，很不确定。我的理解是这样的：VO=值对象、DO=PO=POJO=Entity=就是基础的实体对象，DTO=数据传输对象，model=前后端传输的数据模型。<br>请老师指点一下","like_count":124,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508336,"discussion_content":"在传统的三层架构里面可能没有这么多的对象。而在DDD中增加这些对象主要是为了实现各层以及领域模型中DO对象与前端VO或传输对象DTO和后端数据库PO的解耦。\nDDD中主要有一下几类对象。\n数据持久化对象 (Persistent Object， PO)，与数据库结构一一映射，它是数据持久化过程中的数据载体。\n领域对象（ Domain Object， DO），微服务运行时核心业务对象的载体， DO 一般包括实体或值对象。\n数据传输对象（ Data Transfer Object， DTO），用于前端应用与微服务应用层或者微服务之间的数据组装和传输，是应用之间数据传输的载体。\n视图对象（View Object， VO），用于封装展示层指定页面或组件的数据。\n微服务基础层的主要数据对象是PO。在设计时，我们需要先建立DO和PO的映射关系。大多数情况下DO和PO是一一对应的。但也有DO和PO多对多的情况。在DO和PO数据转换时，需要进行数据重组。对于DO对象较多复杂的数据转换操作，你可以在聚合用工厂模式来实现。\n当DO数据需要持久化时，先将DO转换为PO对象，由仓储实现服务完成数据库持久化操作。\n当DO需要构建和数据初始化时，仓储实现服务先从数据库获取PO对象，将PO转换为DO后，完成DO数据构建和初始化。\n领域层主要是DO对象。DO是实体和值对象的数据和业务行为载体，承载着基础的核心业务逻辑，多个依赖紧密的DO对象构成聚合。领域层DO对象在持久化时需要转换为PO对象。\n应用层主要对象有DO对象，但也可能会有DTO对象。应用层在进行不同聚合的领域服务编排时，一般建议采用聚合根ID的引用方式，应尽量避免不同聚合之间的DO对象直接引用，避免聚合之间产生依赖。\n在涉及跨微服务的应用服务调用时，在调用其他微服务的应用服务前，DO会被转换为DTO，完成跨微服务的DTO数据组装，因此会有DTO对象。\n在前端调用后端应用服务时，用户接口层先完成DTO到DO的转换，然后DO作为应用服务的参数，传导到领域层完成业务逻辑处理。\n用户接口层主要完成DO和DTO的互转，完成微服务与前端应用数据交互和转换。\nfacade接口服务在完成后端应用服务封装后，会对多个DO对象进行组装，转换为DTO对象，向前端应用完成数据转换和传输。\nfacade接口服务在接收到前端应用传入的DTO后，完成DTO向多个DO对象的转换，调用后端应用服务完成业务逻辑处理。\n前端应用主要是VO对象。展现层使用VO进行界面展示，通过用户接口层与应用层采用DTO对象进行数据交互。\n","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1604392104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391505,"discussion_content":"关键理解：应用层在进行不同聚合的领域服务编排时，一般建议采用聚合根ID的引用方式，应尽量避免不同聚合之间的DO对象直接引用，避免聚合之间产生依赖。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1630487045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2898321,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKyHPnchF6iaibvGxrDicZPYongfqiaoia7oP0OrtuwjwVSBTun09Zhw7XQZlo3wCOFEypcOcRdezic6uEA/132","nickname":"陈小伟","note":"","ucode":"E0B21267BCFA9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548392,"discussion_content":"PO：\npersistant object持久对象\n最形象的理解就是一个PO就是数据库中的一条记录。\n好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。\n\n \n\n\nBO：\nbusiness object业务对象\n主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。\n比如一个简历，有教育经历、工作经历、  关系等等。\n我们可以把教育经历对应一个PO，工作经历对应一个PO，  关系对应一个PO。\n建立一个对应简历的BO对象处理简历，每个BO包含这些PO。\n这样处理业务逻辑时，我们就可以针对BO去处理。\n\n \n\n\nVO ：\nvalue object值对象\nViewObject表现层对象\n主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。\n\n \n\nDTO ：\nData Transfer Object数据传输对象\n主要用于远程调用等需要大量传输对象的地方。\n比如我们一张表有100个字段，那么对应的PO就有100个属性。\n但是我们界面上只要显示10个字段，\n客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，\n这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO\n\n \n\n\nPOJO ：\nplain ordinary java object 简单java对象\n个人感觉POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。\n一个POJO持久化以后就是PO\n直接用它传递、传递过程中就是DTO\n直接用来对应表示层就是VO","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1643178468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578847,"discussion_content":"🚩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657066916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145154,"user_name":"Jerry.hu","can_delete":false,"product_type":"c1","uid":1004984,"ip_address":"","ucode":"A2A918DEE6FA2F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/b8/a3dbb4f2.jpg","comment_is_top":false,"comment_ctime":1572224688,"is_pvip":false,"replies":[{"id":"55965","content":"等我有时间的时候准备一下哈。现在的代码都是到类和方法级。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572227771,"ip_address":"","comment_id":145154,"utype":1}],"discussion_count":7,"race_medal":0,"score":"177665883824","product_id":100037301,"comment_content":"老师能否结合一个实战的小项目进行讲解和梳理、同时可以将其项目贡享在git上 让大家结合实战 感觉效果会更好","like_count":42,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472272,"discussion_content":"等我有时间的时候准备一下哈。现在的代码都是到类和方法级。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572227771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1045791,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/1f/577265ea.jpg","nickname":"少帅","note":"","ucode":"EF88F62C236594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":538993,"discussion_content":"什么时候放代码？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639574158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":472272,"ip_address":""},"score":538993,"extra":""}]},{"author":{"id":1045856,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/60/92f78be2.jpg","nickname":"Joe","note":"","ucode":"D8757F7C7C35D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61755,"discussion_content":"http://github.com/joecao/qbike 一个从需求分析开始直到最后映射成微服务架构的完整实战例子，使用event storming ，领域驱动，充血模型，cqrs和spring cloud","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1574783147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1045856,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/60/92f78be2.jpg","nickname":"Joe","note":"","ucode":"D8757F7C7C35D3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":88903,"discussion_content":"太棒了,非常感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576738340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":61755,"ip_address":""},"score":88903,"extra":""}]},{"author":{"id":1450112,"avatar":"https://static001.geekbang.org/account/avatar/00/16/20/80/55e93141.jpg","nickname":"拾光漫步","note":"","ucode":"48DB0837C8F95C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40512,"discussion_content":"应该这样 ,  没有实践的理论就是耍流氓","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1572227934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1046661,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/85/3c072e6f.jpg","nickname":"这菜真香呀","note":"","ucode":"13692E295A6A47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1450112,"avatar":"https://static001.geekbang.org/account/avatar/00/16/20/80/55e93141.jpg","nickname":"拾光漫步","note":"","ucode":"48DB0837C8F95C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195523,"discussion_content":"是的。。。看到第7课 太干涩了 没有实战例子讲解概念，就感觉云里雾里。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583285695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40512,"ip_address":""},"score":195523,"extra":""}]},{"author":{"id":1116807,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0a/87/56b07589.jpg","nickname":"nearzk","note":"","ucode":"CDEA6841E5F54C","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350963,"discussion_content":"https://github.com/dayatang/dddlib 这个例子很完整，质量也很高","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1614083731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159443,"user_name":"FlyFish","can_delete":false,"product_type":"c1","uid":1641373,"ip_address":"","ucode":"69EFA98180EB80","user_header":"https://static001.geekbang.org/account/avatar/00/19/0b/9d/a7ff709c.jpg","comment_is_top":false,"comment_ctime":1575625028,"is_pvip":false,"replies":[{"id":"60954","content":"我们先从底下往上逐层讲，单个实体自身的方法就是实体本身的业务行为。多个实体可组成更复杂的业务动作，这个是领域服务，实体的方法和领域服务共同构成领域模型的基础业务能力，这个能力是原子的基础的，不太考虑外界的用户行为和流程。而应用服务是对这些基础的能力进行组合和编排，它组合和编排的服务可以是跨聚合的领域服务，主要体现组合后的业务能力，更面向前端的用户操作，属于比较粗粒度的服务，通过编排可以更灵活应对外部需求变化。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575635325,"ip_address":"","comment_id":159443,"utype":1}],"discussion_count":2,"race_medal":0,"score":"117539742020","product_id":100037301,"comment_content":"老师好，可以具体讲讲domain层的service和application层service的区别吗，什么东西该房domian，什么该放application的service，然后application层app和aplication层的service具体又该如何界定，现在有点云里雾里，有点傻傻分不清楚","like_count":28,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477060,"discussion_content":"我们先从底下往上逐层讲，单个实体自身的方法就是实体本身的业务行为。多个实体可组成更复杂的业务动作，这个是领域服务，实体的方法和领域服务共同构成领域模型的基础业务能力，这个能力是原子的基础的，不太考虑外界的用户行为和流程。而应用服务是对这些基础的能力进行组合和编排，它组合和编排的服务可以是跨聚合的领域服务，主要体现组合后的业务能力，更面向前端的用户操作，属于比较粗粒度的服务，通过编排可以更灵活应对外部需求变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575635325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1574763,"avatar":"https://static001.geekbang.org/account/avatar/00/18/07/6b/fad9ebc4.jpg","nickname":"何处天涯","note":"","ucode":"6EAFA4E573ED67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576522,"discussion_content":"我决定FlyFish的问题是个命名问题, 传统架构中, 类命名往往是xxxController, xxxService. 现在使用DDD分层, 应用层有应用服务, 领域层有领域服务,那么类命名是是不是都是xxxService了? 我觉得domain层和应用层的服务, 就是一个方法, domain层的领域无法可以写在聚合根中, 也可以以其它方式命名. 当然, 由于没有现成的代码参考, 对命名往往不是很自信. 如果有现成的代码参考, 往往可以一目了然.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655626624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145586,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1572320889,"is_pvip":false,"replies":[{"id":"56213","content":"是Mybatis的映射文件。<br>关于仓储，我是这么考虑的。仓储本身是属于基础层，但是考虑到一个聚合对应一个仓储，为了以后聚合代码整体迁移的方便，我在微服务代码目录设计时，在聚合目录下增加了一个Repository的仓储目录，跟仓储相关的代码都在这个目录下。<br>这个目录下的代码与聚合的其它业务代码是分开的。如果未来换数据库的话，只需要将Repository目录下的代码替换就可以了。而如果聚合需要整体迁移到其它微服务中去，仓储的代码也会一并迁移。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572328574,"ip_address":"","comment_id":145586,"utype":1}],"discussion_count":6,"race_medal":0,"score":"78881732217","product_id":100037301,"comment_content":"请问，最后图中MapperXML是什么？是mybatis那种做对象和数据库字段映射的xml文件么？如果是，那其中包含了与业务逻辑无关的数据库具体实现，放在领域层是否不太合适？","like_count":18,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472481,"discussion_content":"是Mybatis的映射文件。\n关于仓储，我是这么考虑的。仓储本身是属于基础层，但是考虑到一个聚合对应一个仓储，为了以后聚合代码整体迁移的方便，我在微服务代码目录设计时，在聚合目录下增加了一个Repository的仓储目录，跟仓储相关的代码都在这个目录下。\n这个目录下的代码与聚合的其它业务代码是分开的。如果未来换数据库的话，只需要将Repository目录下的代码替换就可以了。而如果聚合需要整体迁移到其它微服务中去，仓储的代码也会一并迁移。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572328574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2172520,"avatar":"https://static001.geekbang.org/account/avatar/00/21/26/68/b86dc4df.jpg","nickname":"R","note":"","ucode":"3721FC8C8DE174","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582473,"discussion_content":"在领域层只提供数据存储的接口，实现类写到基础层Persistent包里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659440510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448748,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","nickname":"Hour","note":"","ucode":"AA1045ACABC0BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347386,"discussion_content":"我理解老师的意思，各聚合内自成一套体系，后续调整也相互独立，互不影响。但是如果要换存储，那影响的应该不是单单一个聚合吧，其他聚合肯定也会有调整，那这样的话，都放在基础层，通过不同的package来区分不也挺好的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612226869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1693569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbgWCULFhKXW9qsicOkYeicvoutg5TtRaiaIlhK3JgPaI0Hiaxo6KaCU1P90GDS3Ria0JCMHEkN6frYsg/132","nickname":"530Li","note":"","ucode":"3F0E5E4BED07DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229428,"discussion_content":"即使将所有mapper和xml搬到领域层，即把数据库的访问实现搬到领域层。但是，其他资源的访问实现，例如redis、rocketmq的读写也要照搬到领域层吗？领域层会不会膨胀过大，并不是纯粹的核心业务了，而兼任了基础资源管理的职责","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586650020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204936,"discussion_content":"现在我的理解，虽然理论都要求仓储实现应该在基础层，但实践起来确实放在领域层也挺好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584240876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005589,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/15/56f4e62a.jpg","nickname":"antz","note":"","ucode":"BDFDED6D7F0BD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42027,"discussion_content":"作者这样做法呢，可能是因为将模型直接存储到了数据库里，基础设施层不会再有另外的PO模型了，所以将MapperXML直接放在领域层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572573578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230667,"user_name":"How2Go","can_delete":false,"product_type":"c1","uid":1151796,"ip_address":"","ucode":"A2242F1C832D36","user_header":"https://static001.geekbang.org/account/avatar/00/11/93/34/5e5b958e.jpg","comment_is_top":false,"comment_ctime":1593444523,"is_pvip":false,"replies":[{"id":"85210","content":"应用层连接用户接口层和领域层，它是很薄的一层，主要职能是协调领域层多个聚合完成服务的组合和编排。<br>应用层之下是领域层，领域层是由多个业务职责单一的聚合构成，实现核心的领域逻辑。应用层负责协调领域层多个聚合的领域服务或领域对象，面向用例和业务流程完成服务的组合和编排。所以理论上应用层不应该实现领域模型的领域逻辑。这也是应用层为什么会很薄的原因。<br>应用层之上是用户接口层，在应用层完成领域层服务组合和编排后，应用服务被用户接口层Facade服务封装，完成接口和数据适配后，以粗粒度的服务通过API网关面向前端应用发布。<br>此外，应用层也是微服务之间服务调用的通道，微服务在应用层可以调用其他微服务的应用服务，完成微服务之间的服务组合和编排。<br>在应用层主要有应用服务、事件订阅和发布等相关代码逻辑。<br>其中，应用服务主要负责服务的组合、编排和转发，处理业务用例的执行顺序以及结果的拼装。在应用服务中还可以进行安全认证、权限校验、事务控制、领域事件发布或订阅等。<br>BFF是位于微服务之上，它的主要职责是负责微服务之间的服务协调和编排。而应用服务主要处理微服务内的服务组合和编排，它可以组合和编排领域服务。<br>在小型项目里，应用服务也可以编排其他微服务的应用服务，我们就没必要增加一层BFF的逻辑了。<br>在设计时我们应尽可能地将可复用的服务能力往下层沉淀，在实现能力复用的同时，还可以避免跨中心的服务调用。<br>BFF像齿轮一样，来适配前端应用与微服务之间的步调。通过BFF微服务中的façade接口服务向上适配不同的前端应用，通过协调不同微服务向下实现企业级业务能力的组合、编排和协同。<br>BFF微服务可根据需求和流程变化，与前端应用版本协同发布，避免微服务为适配不同前端需求的变化，而频繁地修改和发布版本，从而保证微服务版本和核心领域逻辑的稳定。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593495819,"ip_address":"","comment_id":230667,"utype":1}],"discussion_count":4,"race_medal":0,"score":"74607888555","product_id":100037301,"comment_content":"已经结束的课程，老师还会回复吗？<br>----------<br>老师，这一节读了几遍，还没有太理解应用服务层。根据课程所说，我的理解是应用服务层会编排领域服务的执行，组织领域服务返回的结果。 但又不是API Gateway -- API Gateway 在基础层。 那么， 这个应用服务层， 是否就是BFF？","like_count":17,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499985,"discussion_content":"应用层连接用户接口层和领域层，它是很薄的一层，主要职能是协调领域层多个聚合完成服务的组合和编排。\n应用层之下是领域层，领域层是由多个业务职责单一的聚合构成，实现核心的领域逻辑。应用层负责协调领域层多个聚合的领域服务或领域对象，面向用例和业务流程完成服务的组合和编排。所以理论上应用层不应该实现领域模型的领域逻辑。这也是应用层为什么会很薄的原因。\n应用层之上是用户接口层，在应用层完成领域层服务组合和编排后，应用服务被用户接口层Facade服务封装，完成接口和数据适配后，以粗粒度的服务通过API网关面向前端应用发布。\n此外，应用层也是微服务之间服务调用的通道，微服务在应用层可以调用其他微服务的应用服务，完成微服务之间的服务组合和编排。\n在应用层主要有应用服务、事件订阅和发布等相关代码逻辑。\n其中，应用服务主要负责服务的组合、编排和转发，处理业务用例的执行顺序以及结果的拼装。在应用服务中还可以进行安全认证、权限校验、事务控制、领域事件发布或订阅等。\nBFF是位于微服务之上，它的主要职责是负责微服务之间的服务协调和编排。而应用服务主要处理微服务内的服务组合和编排，它可以组合和编排领域服务。\n在小型项目里，应用服务也可以编排其他微服务的应用服务，我们就没必要增加一层BFF的逻辑了。\n在设计时我们应尽可能地将可复用的服务能力往下层沉淀，在实现能力复用的同时，还可以避免跨中心的服务调用。\nBFF像齿轮一样，来适配前端应用与微服务之间的步调。通过BFF微服务中的façade接口服务向上适配不同的前端应用，通过协调不同微服务向下实现企业级业务能力的组合、编排和协同。\nBFF微服务可根据需求和流程变化，与前端应用版本协同发布，避免微服务为适配不同前端需求的变化，而频繁地修改和发布版本，从而保证微服务版本和核心领域逻辑的稳定。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593495819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":530770,"discussion_content":"老师，没看懂这段，微服务和微服务之间的服务调用不是BFF完成的么？您上面说的在应用层可以调用其他微服务的应用服务这个怎么理解呢？蒙圈了我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637144917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":499985,"ip_address":""},"score":530770,"extra":"{\"user_type\":1}"},{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543381,"discussion_content":"他api网关是对数据输出的吧 所以放在基础服务层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641115360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":530770,"ip_address":""},"score":543381,"extra":""}]},{"author":{"id":1151796,"avatar":"https://static001.geekbang.org/account/avatar/00/11/93/34/5e5b958e.jpg","nickname":"How2Go","note":"","ucode":"A2242F1C832D36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287883,"discussion_content":"谢谢欧老师！让我对各个层级的职责理解的更清晰了！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593577373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148340,"user_name":"祥敏","can_delete":false,"product_type":"c1","uid":1205328,"ip_address":"","ucode":"466BFA980D9A37","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/50/a54f0907.jpg","comment_is_top":false,"comment_ctime":1572991795,"is_pvip":false,"replies":[{"id":"57254","content":"<br>第一，可以这么理解。<br>第二，从本质来讲，DTO与VO都是对象。但是在DDD中将值传递的界限划分更细，比如DTO、DO、VO、PO，分别对应不同阶段的事务处理。DTO通常面向接口层，与VO相比可能会有前端应用&#47;接口请求方要求的一些个性化的属性或值的映射等。<br>第三，简单部分可能会有重叠，但是基于不对外暴露领域层逻辑的目的，会将实体方法封装成领域服务，领域服务再封装为应用服务，然后对外暴露。<br>第四，这层本身是公共类，表示部分持久化的功能被提取为公共的面向切面聚合方法来实现<br>第五，是这样的。实体值对象的数据逻辑通过聚合根来管理，多实体的业务行为通过领域服务来组合。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573049236,"ip_address":"","comment_id":148340,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57407566643","product_id":100037301,"comment_content":"您好，根据三层架构和DDD四层架构映射这张图，以SSM框架组合谈谈我的理解和问题：<br>1.三层架构的业务接口层、业务逻辑层、数据访问层，对应实际开发的controller、service和dao三层；<br>2.图中三层架构中业务逻辑层的VO对应为四层架构中用户接口层的DTO，我的理解是VO原本就在三层架构的用户接口层，在三层架构中也会用DTO竖向穿透三层简化开发。图中的DTO划分为用户接口层，实际只是VO。<br>3.业务逻辑层中的service拆分为四层架构中的application service和domain service两层，如果以常见的CRUD开发来讲，domain service和applicatioin service是否在简单场景中就重叠了？<br>4.三层开发中的仓储的依赖倒置已经实现了，mybatis层仓储接口被service层调用，mapper xml作为仓储的接口实现。如果采用DDD四层划分，mapper xml会被划分到基础层。repository aop这里的界面截指的是什么，是指ORM框架内部的bean与关系数据库实体之间的关系映射吗？<br>5.聚合跟关注实体的持久化：聚合根、实体采用充血模型开发，CRUD中的CUD都会在聚合根、实体中实现，domain service 实现查询功能以及调用充血模型中的CUD方法，这样理解对吗？","like_count":14,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473463,"discussion_content":"\n第一，可以这么理解。\n第二，从本质来讲，DTO与VO都是对象。但是在DDD中将值传递的界限划分更细，比如DTO、DO、VO、PO，分别对应不同阶段的事务处理。DTO通常面向接口层，与VO相比可能会有前端应用/接口请求方要求的一些个性化的属性或值的映射等。\n第三，简单部分可能会有重叠，但是基于不对外暴露领域层逻辑的目的，会将实体方法封装成领域服务，领域服务再封装为应用服务，然后对外暴露。\n第四，这层本身是公共类，表示部分持久化的功能被提取为公共的面向切面聚合方法来实现\n第五，是这样的。实体值对象的数据逻辑通过聚合根来管理，多实体的业务行为通过领域服务来组合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573049236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1228290,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/02/43202976.jpg","nickname":"w 🍍","note":"","ucode":"F2386C971EC58B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":564539,"discussion_content":"DTO和VO的区别没明白。 我的理解是，前端应用传入的是DTO，返回给前端的是VO？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650273901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":473463,"ip_address":""},"score":564539,"extra":""}]}]},{"had_liked":false,"id":154855,"user_name":"Geek_d94e60","can_delete":false,"product_type":"c1","uid":1336228,"ip_address":"","ucode":"31A7F2D17C9E74","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dxDiajEGQoG0FRDX0CyQ43bLzO8w5tUyS3mDiaY7Q97xicLIGSmTFJZjAibYRWwvEYur9vjt9Tzic5icUETIbRGkhHGA/132","comment_is_top":false,"comment_ctime":1574581768,"is_pvip":false,"replies":[{"id":"59518","content":"你说的这个情况，我在第20讲的时候会讲到。<br>提前剧透一下哈。<br>跨库关联查询是分布式数据库的一个短板，会影响查询性能。在领域建模时，很多实体会分散到不同微服务中，但很多时候会因为业务需求，它们之间需要关联查询。<br>关联查询的业务场景包括两类：第一类是基于某一维度或某一主题域的数据查询，如基于客户全业务视图的数据查询，这种查询会跨多个业务线的微服务。第二类是表与表之间的关联查询，比如机构表与业务表的联表查询，但机构表和业务表分散在不同的微服务。那如何解决这两类关联查询呢？<br>对于第一类场景，由于数据分散在不同微服务里，我们无法跨多个微服务来统计这些数据。你可以建立面向主题的分布式数据库，它的数据来源于不同业务的微服务。采用数据库日志捕获技术，从各业务端微服务将数据准实时汇集到主题数据库。在数据汇集时，提前做好数据关联（如将多表数据合并为一个宽表）或者建立数据模型。面向主题数据库建设查询微服务。这样一次查询你就可以获取客户所有维度的业务数据了。你还可以根据主题或场景设计合适的分库主键，提高查询效率。<br>对于第二类场景，对于不在同一个数据库的表与表的关联查询场景。你可以采用小表广播。在业务库中增加一张冗余的代码副表。当主表数据发生变化时，可以通过消息发布和订阅的领域事件驱动模式，异步刷新所有副表数据。这样既可解决表与表的关联查询，还可以提高数据的查询效率。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574651628,"ip_address":"","comment_id":154855,"utype":1}],"discussion_count":10,"race_medal":0,"score":"48819222024","product_id":100037301,"comment_content":"老师您好，请教个问题，微服务拆分后，原来参数类或公共类业务数据  ，每个微服务都会用到，目前有两种方式处理<br>一，单独抽取一个公共服务，其它微服务都通过接口访问公共类或参数类数据<br><br>二，每个微服务都存放该类数据，但只能通过其中一个服务来维护，其它微服务走同步的方式保证数据的一致性<br><br>您比较推荐哪种呢？或者是否有其它的思路？","like_count":11,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475600,"discussion_content":"你说的这个情况，我在第20讲的时候会讲到。\n提前剧透一下哈。\n跨库关联查询是分布式数据库的一个短板，会影响查询性能。在领域建模时，很多实体会分散到不同微服务中，但很多时候会因为业务需求，它们之间需要关联查询。\n关联查询的业务场景包括两类：第一类是基于某一维度或某一主题域的数据查询，如基于客户全业务视图的数据查询，这种查询会跨多个业务线的微服务。第二类是表与表之间的关联查询，比如机构表与业务表的联表查询，但机构表和业务表分散在不同的微服务。那如何解决这两类关联查询呢？\n对于第一类场景，由于数据分散在不同微服务里，我们无法跨多个微服务来统计这些数据。你可以建立面向主题的分布式数据库，它的数据来源于不同业务的微服务。采用数据库日志捕获技术，从各业务端微服务将数据准实时汇集到主题数据库。在数据汇集时，提前做好数据关联（如将多表数据合并为一个宽表）或者建立数据模型。面向主题数据库建设查询微服务。这样一次查询你就可以获取客户所有维度的业务数据了。你还可以根据主题或场景设计合适的分库主键，提高查询效率。\n对于第二类场景，对于不在同一个数据库的表与表的关联查询场景。你可以采用小表广播。在业务库中增加一张冗余的代码副表。当主表数据发生变化时，可以通过消息发布和订阅的领域事件驱动模式，异步刷新所有副表数据。这样既可解决表与表的关联查询，还可以提高数据的查询效率。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574651628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369756,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIopdUJmtgpsr9GibAibcZgS7h23P4FrgBfed3WveI4b4f8Vl2JjibhCzib9Y8Vs2M1PGQr7cwoKADxZQ/132","nickname":"秦道","note":"","ucode":"BE195C09BD14A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316464,"discussion_content":"业务到一定规模，业务数据关联查询，遇到join遇到性能瓶颈问题，可以上大数据平台，但考虑资源复用，避免烟囱式开发，其实就可以上数据中台了(当然看业务和数据规模)。根据不同主题建模，用宽表(比如es，clickhouse)和计算能力(比如flink,spark)存储处理数据，同时通过数据地图暴露数据和接口查询服务。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1603415727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1369756,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIopdUJmtgpsr9GibAibcZgS7h23P4FrgBfed3WveI4b4f8Vl2JjibhCzib9Y8Vs2M1PGQr7cwoKADxZQ/132","nickname":"秦道","note":"","ucode":"BE195C09BD14A5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351849,"discussion_content":"mark clickhouse","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614495999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":316464,"ip_address":""},"score":351849,"extra":""},{"author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1369756,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIopdUJmtgpsr9GibAibcZgS7h23P4FrgBfed3WveI4b4f8Vl2JjibhCzib9Y8Vs2M1PGQr7cwoKADxZQ/132","nickname":"秦道","note":"","ucode":"BE195C09BD14A5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531010,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637203949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":316464,"ip_address":""},"score":531010,"extra":"{\"user_type\":1}"}]},{"author":{"id":1795080,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/64/08/17189711.jpg","nickname":"一瞬流光","note":"","ucode":"2A235651637A15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586494,"discussion_content":"小表广播万一在遇到系统崩溃重启的情况，会造成数据不一致性，就很难排查了～还需要定时全量同步一边才可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662257096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2089155,"avatar":"","nickname":"昌南一枝花","note":"","ucode":"66118BEFFDC9BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297319,"discussion_content":"参数类或公共类业务数据为什么不能放在同一个数据库里呢？不同的微服务一定要使用不同的数据库吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596873377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88956,"discussion_content":"好问题,刚好遇到,老师的解答很受用.目前也正在考虑用 canal 来实现第二种场景.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576742520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2089155,"avatar":"","nickname":"昌南一枝花","note":"","ucode":"66118BEFFDC9BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297320,"discussion_content":"小表广播更新过程中会涉及分布式事务问题吧，跨库跨表join是不是用es或大数据产品来实现更好呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596873468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":88956,"ip_address":""},"score":297320,"extra":""},{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351851,"discussion_content":"mark canal","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614496204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":88956,"ip_address":""},"score":351851,"extra":""},{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2089155,"avatar":"","nickname":"昌南一枝花","note":"","ucode":"66118BEFFDC9BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543388,"discussion_content":"你的意思是说也存在广播失败的情况吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641116077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297320,"ip_address":""},"score":543388,"extra":""}]}]},{"had_liked":false,"id":162660,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1576574534,"is_pvip":false,"replies":[{"id":"61891","content":"给你看一个非常简单的例子，有Person聚合根，Person聚合包括仓储接口和仓储实现。<br>通过增加仓储服务，使得应用逻辑和数据库逻辑的依赖关系剥离，当换数据库的时候，只需要将仓储实现替换就可以了，这样不会对核心的业务逻辑产生影响。<br><br>&#47;**<br> * Person聚合根<br> *&#47;<br>public class Person{<br>  private String id;<br>  private String name;<br>  private int age;   <br>  private boolean gender；<br><br>&#47;**<br> * 其它方法<br> *&#47;<br>}<br><br>&#47;**<br> * Person仓储接口<br> *&#47;<br>public interface  PersonRepositoryInterface {<br>  void save(Person person);  <br>  void delete(String id);  <br> }<br><br>&#47;**<br> *Person仓储实现<br> *&#47;<br>@Repository<br>public class PersonRepositoryImp implements PersonRepositoryInterface {<br>  private PersonMapper mapper;    <br>  public void save( Person person) {<br>      mapper.create(person);<br>  }<br>  public void delete((String  id) {<br>    mapper.delete(id);<br>  }<br> }<br><br>在应用逻辑中直接用仓储的接口就可以了，数据库相关的逻辑在PersonMapper里面实现。<br>PersonRepositoryInterface personRepos;<br>personRepos.save(person)<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576631851,"ip_address":"","comment_id":162660,"utype":1}],"discussion_count":4,"race_medal":0,"score":"44526247494","product_id":100037301,"comment_content":"请教老师：解耦各层对基础层依赖，采用依赖倒置的方式？这有点抽象，不知道是通过什么的一种方法？","like_count":10,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478120,"discussion_content":"给你看一个非常简单的例子，有Person聚合根，Person聚合包括仓储接口和仓储实现。\n通过增加仓储服务，使得应用逻辑和数据库逻辑的依赖关系剥离，当换数据库的时候，只需要将仓储实现替换就可以了，这样不会对核心的业务逻辑产生影响。\n\n/**\n * Person聚合根\n */\npublic class Person{\n  private String id;\n  private String name;\n  private int age;   \n  private boolean gender；\n\n/**\n * 其它方法\n */\n}\n\n/**\n * Person仓储接口\n */\npublic interface  PersonRepositoryInterface {\n  void save(Person person);  \n  void delete(String id);  \n }\n\n/**\n *Person仓储实现\n */\n@Repository\npublic class PersonRepositoryImp implements PersonRepositoryInterface {\n  private PersonMapper mapper;    \n  public void save( Person person) {\n      mapper.create(person);\n  }\n  public void delete((String  id) {\n    mapper.delete(id);\n  }\n }\n\n在应用逻辑中直接用仓储的接口就可以了，数据库相关的逻辑在PersonMapper里面实现。\nPersonRepositoryInterface personRepos;\npersonRepos.save(person)\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576631851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88926,"discussion_content":"借助设计模式专栏的一段后来解答一下,   High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Sevlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1576740751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86909,"discussion_content":"非常感谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576632129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86625,"discussion_content":"看到其他的同学也问到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576597766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145372,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1572260390,"is_pvip":false,"replies":[{"id":"56072","content":"用户接口层也很重要啊，主要前后端调用的适配。如果你的微服务要面向很多的应用或渠道提供服务，而每个渠道的入参和出参都不一样，你不太可能开发出太多的应用服务，这样Facade接口就起很好的作用了，包括DO和DTO对象的组装和转换等。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572262290,"ip_address":"","comment_id":145372,"utype":1}],"discussion_count":4,"race_medal":0,"score":"31637031462","product_id":100037301,"comment_content":"感觉用户接口层，存在感好低。仅仅存在调用应用层。 为什么还要存在这个层级？是因为，需要限制用户接口的访问？","like_count":7,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472361,"discussion_content":"用户接口层也很重要啊，主要前后端调用的适配。如果你的微服务要面向很多的应用或渠道提供服务，而每个渠道的入参和出参都不一样，你不太可能开发出太多的应用服务，这样Facade接口就起很好的作用了，包括DO和DTO对象的组装和转换等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572262290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003571,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/33/43833f7c.jpg","nickname":"Nick","note":"","ucode":"58D6AFA7C905AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47581,"discussion_content":"这里说的接口层，应该可以用API网关代替吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573371103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41020,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572329964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40996,"discussion_content":"一直不太明白，用户接口层的含义，这次相对有了清晰的认识；可不可以这样理解，用户接口层对应于我们常见的web层，属于对外开放的；应用层不再是我们传统意义上控制层（controller层，即对外提供数据，又对内控制访问流程），而是仅仅是协调领域层，完成某个流程或者是操作？？当然名字不必再拘泥于xxxController，只要能反映他的位置和功能就可以。望老师给予解答，感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572320281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145153,"user_name":"LY","can_delete":false,"product_type":"c1","uid":1273512,"ip_address":"","ucode":"6AEF6BD822A3AB","user_header":"https://static001.geekbang.org/account/avatar/00/13/6e/a8/ee6bc8a5.jpg","comment_is_top":false,"comment_ctime":1572224557,"is_pvip":false,"replies":[{"id":"55964","content":"领域对象的概念比较广泛，除了实体、值对象和聚合根外，服务也算是领域对象。领域层和应用分别有领域服务和应用服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572227669,"ip_address":"","comment_id":145153,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27342028333","product_id":100037301,"comment_content":"对今天的思考题不太理解，领域对象不应该是放在领悟层么，应用层只是会重建这些领域对象而已，所以应用层应该不会写领域对象的类才对。那又何来应用层有哪些对象的问题呢？","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472271,"discussion_content":"领域对象的概念比较广泛，除了实体、值对象和聚合根外，服务也算是领域对象。领域层和应用分别有领域服务和应用服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572227669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005589,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/15/56f4e62a.jpg","nickname":"antz","note":"","ucode":"BDFDED6D7F0BD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42031,"discussion_content":"我在这里也有些疑问：按照文中作者的意思，应用层只能调用领域服务去调用领域中的行为，那么应用层只会有领域服务这个对象；\n但是这样做的在实践中也带来了不少弊端，比如每个实体内的行为方法，都需要在领域服务中重新定义一遍，然后提供给应用服务使用；\n在实操中，我们应用层还是可以调用领域服务和领域中的行为方法，而此时领域服务更多的是在操作多个实体时会使用。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572574206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203734,"discussion_content":"我觉得应用层不会引用领域对象，而是调用领域服务。如果引用，也应该是用依赖导致原则，进行解耦，但这样又会引入接口和实现，所以最好是调用而不是引用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584074249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162184,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1576473085,"is_pvip":false,"replies":[{"id":"61736","content":"领域层交互会增加聚合之间的耦合，不利于以后微服务的再次拆分和演进，聚合之间的交互建议通过应用服务来总体协调。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576485646,"ip_address":"","comment_id":162184,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23051309565","product_id":100037301,"comment_content":"领域层之间能直接通信吗？  还是说要交给应用层？","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477977,"discussion_content":"领域层交互会增加聚合之间的耦合，不利于以后微服务的再次拆分和演进，聚合之间的交互建议通过应用服务来总体协调。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576485646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1707838,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AcJM5WNhE062TQAsIE8KTxTsZMTHJHCm4LCfsjBPibZ6iaGRamfZqIRFcLXLVfAQobeCIgA9o5wiaRCKa0dNbic1iag/132","nickname":"paulmin","note":"","ucode":"6AAB20AB369E90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394909,"discussion_content":"跨聚合的业务流程，涉及事务数据持久化的，看来要使用分布式事务的最终一致性来确保了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632124859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270149,"user_name":"Geek_c1891e","can_delete":false,"product_type":"c1","uid":2355573,"ip_address":"","ucode":"19150ADBD9F071","user_header":"","comment_is_top":false,"comment_ctime":1608955247,"is_pvip":false,"replies":[{"id":"98210","content":"您说的领域C和领域B是不是两个不同的聚合。一般来说聚合之间尽量不要产生直接的服务调用，也不要产生实体之间的引用这种类型的耦合，当然聚合根ID引用这种除外。<br>看看这两种解决办法是否可以？第一种是领域B封装出一个领域服务，通过应用层的应用服务中，组合和编排领域C和领域B的领域服务，完成跨聚合的组合业务逻辑。第二种是通过领域事件机制，领域C完成业务逻辑后，通过事件总线将事件数据发送到领域b，在领域B中完成对应的业务逻辑，实现数据最终一致性。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1609231500,"ip_address":"","comment_id":270149,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18788824431","product_id":100037301,"comment_content":"老师请教个问题:领域c需要用到领域b中访问数据库的一个方法3，但是领域b的聚合根没有对外封装暴露这个方法(可能是在领域b中在调用这个方法3之前有很多业务逻辑只适合领域b的业务)。像这种情况怎么做比较好？领域c直接倒置注入领域b访问数据库的方法3；还是让领域b封装暴露一个直接调整方法3的给领域c使用？还是有其他更好的方法？","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512536,"discussion_content":"您说的领域C和领域B是不是两个不同的聚合。一般来说聚合之间尽量不要产生直接的服务调用，也不要产生实体之间的引用这种类型的耦合，当然聚合根ID引用这种除外。\n看看这两种解决办法是否可以？第一种是领域B封装出一个领域服务，通过应用层的应用服务中，组合和编排领域C和领域B的领域服务，完成跨聚合的组合业务逻辑。第二种是通过领域事件机制，领域C完成业务逻辑后，通过事件总线将事件数据发送到领域b，在领域B中完成对应的业务逻辑，实现数据最终一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609231500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146707,"user_name":"Mr.Strive.Z.H.L","can_delete":false,"product_type":"c1","uid":1030198,"ip_address":"","ucode":"6D97E159E2EECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/36/542c96bf.jpg","comment_is_top":false,"comment_ctime":1572612824,"is_pvip":false,"replies":[{"id":"56720","content":"聚合根主要负责数据和仓储相关的内容，也就是聚合数据持久化部分。业务逻辑主要还是实体方法以及领域服务。由于聚合根也可以组织多个实体，理论上聚合根的方法也可以实现领域服务的功能。多个实体的业务逻辑用领域服务或聚合根的方法都可以做到，具体选择哪种方式？结合场景或者开发习惯，选择自己最习惯的姿势。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572657887,"ip_address":"","comment_id":146707,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18752482008","product_id":100037301,"comment_content":"老师你好，之前提过 实体是充血的，聚合根也是实体，对外提供该聚合的方法，聚合内实体的访问都必须通过聚合根，同时一个仓储对应一个聚合。我想问的是： 一个聚合内部有多个实体，那聚合根对外暴露的接口的方法岂不是非常多？？聚合内任意实体的增删改查，都通过聚合根这个充血模型对外提供？？<br>感觉聚合的设计是非常有讲究的………","like_count":5,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472986,"discussion_content":"聚合根主要负责数据和仓储相关的内容，也就是聚合数据持久化部分。业务逻辑主要还是实体方法以及领域服务。由于聚合根也可以组织多个实体，理论上聚合根的方法也可以实现领域服务的功能。多个实体的业务逻辑用领域服务或聚合根的方法都可以做到，具体选择哪种方式？结合场景或者开发习惯，选择自己最习惯的姿势。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572657887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145395,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1572265516,"is_pvip":false,"replies":[{"id":"56089","content":"依赖倒置举个例子，领域层是通过仓储接口获取基础资源的数据对象，仓储接口会调用仓储实现，具体的基础资源的数据处理过程是在仓储实现中完成的。这样做的好处是，避免将仓储实现的代码混入上层业务逻辑中。如果以后替换数据库，由于做了基础资源的个性的代码隔离，所以实现了应用逻辑与基础资源的解耦。在更换数据库时只需要更换仓储相关的代码就可以了，应用的逻辑不会受太大的影响。<br>防腐层我感觉主要是实现新旧系统切换时，出现业务逻辑混杂在一起的情况，避免污染领域模型的实现逻辑。因此增加防腐层隔离旧系统对领域模型的影响。在完成新旧切换后，防腐层的代码就可以抛弃不用了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572269813,"ip_address":"","comment_id":145395,"utype":1}],"discussion_count":7,"race_medal":0,"score":"18752134700","product_id":100037301,"comment_content":"对层级的依赖倒置不太理解。好像还有个防腐层的概念。不知道能解释下吗","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472372,"discussion_content":"依赖倒置举个例子，领域层是通过仓储接口获取基础资源的数据对象，仓储接口会调用仓储实现，具体的基础资源的数据处理过程是在仓储实现中完成的。这样做的好处是，避免将仓储实现的代码混入上层业务逻辑中。如果以后替换数据库，由于做了基础资源的个性的代码隔离，所以实现了应用逻辑与基础资源的解耦。在更换数据库时只需要更换仓储相关的代码就可以了，应用的逻辑不会受太大的影响。\n防腐层我感觉主要是实现新旧系统切换时，出现业务逻辑混杂在一起的情况，避免污染领域模型的实现逻辑。因此增加防腐层隔离旧系统对领域模型的影响。在完成新旧切换后，防腐层的代码就可以抛弃不用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572269813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","nickname":"小毅","note":"","ucode":"5651C740D68038","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42195,"discussion_content":"老师的依赖倒置例子感觉举的不太好，领域层是通过仓储接口获取基础资源的数据对象，其实这和传统的三层模型没啥区别~  对层级的依赖倒置，还希望老师能对比下DDD之前的做法和之后的做法","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1572609120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","nickname":"小毅","note":"","ucode":"5651C740D68038","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159652,"discussion_content":"我的理解是：如果原本三层里面就是用Repository模式的，这里DDD把接口留domain，实现放infrastructure，就完成了这部分的单体迁移（依赖关系infra依赖domain）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580720764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":42195,"ip_address":""},"score":159652,"extra":""}]},{"author":{"id":1204980,"avatar":"https://static001.geekbang.org/account/avatar/00/12/62/f4/e5f883cd.jpg","nickname":"james4e","note":"","ucode":"ABF50A1C53231B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40975,"discussion_content":"防腐层还有个作用是不要把在把第三方库的数据结构直接暴露给内部，这样第三方依赖接口变了，需要的改动很小，同时可以随时替换第三方依赖。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572316415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1204980,"avatar":"https://static001.geekbang.org/account/avatar/00/12/62/f4/e5f883cd.jpg","nickname":"james4e","note":"","ucode":"ABF50A1C53231B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351856,"discussion_content":"防腐层\\防损层（Anti-corruption layer）介于新应用和遗留应用之间，用于确保新应用的设计不受遗留应用的限制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614497615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40975,"ip_address":""},"score":351856,"extra":""}]},{"author":{"id":1644407,"avatar":"https://static001.geekbang.org/account/avatar/00/19/17/77/a8054ff4.jpg","nickname":"lufei","note":"","ucode":"17359C4DB96B22","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306757,"discussion_content":"应该是系统集成时要使用的哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600375768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228500,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/d4/ff1c1319.jpg","nickname":"金龟","note":"","ucode":"1C7D35C8AE8D9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":107595,"discussion_content":"不太明白，基础层实现领域层的接口，但是调用的时候，又是领域层调用基础层，在maven中会否形成环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577591152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230034,"user_name":"Geek_73f7d7","can_delete":false,"product_type":"c1","uid":2043876,"ip_address":"","ucode":"E72F9B428F10CF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/gmu7HicQS0bhTl4mdmF8OF6r9SGtiaBmdjV2mDPhlsfCjp3kVicucRuNnhJy3E2DTaNeHzYpVc583UibHrX3ukiaJfw/132","comment_is_top":false,"comment_ctime":1593245606,"is_pvip":false,"replies":[{"id":"85219","content":"你这一块可以开发一个微服务，然后用用户接口层来适配不同的前端数据和接口需求。<br>在微服务面向不同前端应用时，同样的一段业务逻辑，可能由于渠道不同，而在前端展示的页面要素不同，因此要求后端微服务返回的数据结果会不同，需要的接口协议可能也不一样。<br>这时用户接口层的Facade服务和数据组装器Assembler就可以发挥作用了。Facade服务可以封装应用服务，数据组装器Assembler可以根据不同前端应用的数据需求，完成前端DTO和后端DO对象的组装和转换等操作。面向不同前端应用提供不同的Facade接口和DTO数据服务。这样，我们不需要调整任何后端服务，就可以面向不同的前端应用，提供灵活的接口定制和数据适配服务了。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593497885,"ip_address":"","comment_id":230034,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14478147494","product_id":100037301,"comment_content":"老师你好，最近公司再做智能手环相关产品，由于手环品类多，各大厂商的协议也不能，每次都需要针对新的手环开发新的web产品，但是他们的功能都大致一样，目前是把权限管理作为边界，抽出了一个微服务，前端也用了组件化达到复用，那么针对设备管理，或者对接这块，老师有没有好的建议，期待老师回复","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499743,"discussion_content":"你这一块可以开发一个微服务，然后用用户接口层来适配不同的前端数据和接口需求。\n在微服务面向不同前端应用时，同样的一段业务逻辑，可能由于渠道不同，而在前端展示的页面要素不同，因此要求后端微服务返回的数据结果会不同，需要的接口协议可能也不一样。\n这时用户接口层的Facade服务和数据组装器Assembler就可以发挥作用了。Facade服务可以封装应用服务，数据组装器Assembler可以根据不同前端应用的数据需求，完成前端DTO和后端DO对象的组装和转换等操作。面向不同前端应用提供不同的Facade接口和DTO数据服务。这样，我们不需要调整任何后端服务，就可以面向不同的前端应用，提供灵活的接口定制和数据适配服务了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593497885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2043876,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/gmu7HicQS0bhTl4mdmF8OF6r9SGtiaBmdjV2mDPhlsfCjp3kVicucRuNnhJy3E2DTaNeHzYpVc583UibHrX3ukiaJfw/132","nickname":"Geek_73f7d7","note":"","ucode":"E72F9B428F10CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287629,"discussion_content":"感谢老师回复，听您这么一说，有点思路了，着手实践下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593498267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159884,"user_name":"鲲哥","can_delete":false,"product_type":"c1","uid":1230812,"ip_address":"","ucode":"D9582DF7806900","user_header":"https://static001.geekbang.org/account/avatar/00/12/c7/dc/1268c9f9.jpg","comment_is_top":false,"comment_ctime":1575817174,"is_pvip":false,"replies":[{"id":"61077","content":"一般都是通过应用服务或者领域服务来完成仓储调用，实体或聚合根作为参数传入仓储接口，通过仓储实现来完成持久化。一个简单的例子如下：<br><br>public class OrderService {<br>private OrderRepository orderRepository;<br>public Order updateOrder(order) {<br>***；<br>orderRepository.save(order);<br>***；<br>}<br>}","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575861726,"ip_address":"","comment_id":159884,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14460719062","product_id":100037301,"comment_content":"欧老师，你好。问一个具体实现上的问题。充血模型的实体如果需要持久化，是直接调用repository还是由领域服务调用？如果直接调用，那在spring是如何实现的呢？sprign中repository一般单例bean,充血应该不是单例吧？那他是如何依赖repository的呢？","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477197,"discussion_content":"一般都是通过应用服务或者领域服务来完成仓储调用，实体或聚合根作为参数传入仓储接口，通过仓储实现来完成持久化。一个简单的例子如下：\n\npublic class OrderService {\nprivate OrderRepository orderRepository;\npublic Order updateOrder(order) {\n***；\norderRepository.save(order);\n***；\n}\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575861726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387282,"discussion_content":"这里的OrderRepository应该是OrderRepositoryInterface吧？如果这样就意味着应用服务或领域服务直接依赖了仓储实现，因为仓储接口在领域层，而仓储实现则是在基础层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628085147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151141,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1573657649,"is_pvip":false,"replies":[{"id":"58209","content":"基础层的逻辑主要是SQL代码，DO和PO的转换和映射以及数据的持久化等。在没有仓储之前，这些代码会跟业务逻辑混杂在一起的。<br>领域层和应用层通过仓储接口会将DO的对象传给仓储实现，在仓储实现里面实现DO和PO的转换以及数据的持久化。<br>初始化的时候，仓储实现会实现PO到DO的转换，然后返回DO对象。<br>这样的话，业务逻辑都是基于DO的操作，不管基础层如何变化，只要DO不发生变化，业务逻辑都不会影响。这样就实现了业务逻辑与基础逻辑的解耦了。<br><br>仓储给你看一段在答疑那一节里面代码。<br>有Person聚合根，Person仓储接口和仓储实现。<br>&#47;**<br> * Person聚合根<br> *&#47;<br>public class Person{<br>  private String id;<br>  private String name;<br>  private int age; <br>  private boolean gender；<br>}<br><br>&#47;**<br> * Person仓储接口<br> *&#47;<br>public interface PersonRepositoryInterface {<br>  void save(Person person); <br>  void delete(String id); <br> }<br><br>&#47;**<br> *Person仓储实现<br> *&#47;<br>@Repository<br>public class PersonRepositoryImp implements PersonRepositoryInterface {<br>  private PersonMapper mapper; <br>  public void save( Person person) {<br>      mapper.create(person);<br>  }<br>  public void delete((String id) {<br>    mapper.delete(id);<br>  }<br> }<br>在应用逻辑中直接用仓储的接口就可以了，数据库相关的逻辑在PersonMapper里面实现。<br>PersonRepositoryInterface personRepos;<br>personRepos.save(person)","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573697933,"ip_address":"","comment_id":151141,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14458559537","product_id":100037301,"comment_content":"作者回复: 依赖倒置后基础层就通过仓储接口获取外部参数了，然后根据这些业务参数完成基础逻辑的实现，这个实现是在基础层。不采用依赖倒置的传统四层架构，基础层和业务逻辑实现可能会在应用层或领域层，两者逻辑混杂，不利于解耦。<br>老师您好<br>基础层通过仓储接口过去外部参数，这句话不是很懂，基础层的逻辑，哪些属于基础层逻辑呢？比如根据do的不同状态决定是否存库或者是否发送到消息总线中，是否是指这一类逻辑？还有，是不是领域层（或者是应用层）的对象do和仓储层对象po的转换发生在仓储层，还是仓储层传给基础层的实体就是do而不是po？do还po的转换应该放在哪里？<br>根据依赖倒置的原理，感觉基础层暴露给应用层和领域层的仓储层中的接口参数是do（领域实体），而不是po，不知道理解的对不对，望老师解答，感谢感谢感谢<br>还有您说的如果采用传统的四层架构，基础层以及基础层业务逻辑实现就会耦合在应用层或领域层，是不是就是上面说的根据不同的状态做不同处理的逻辑，还有没有其他常见的逻辑？感谢老师","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474378,"discussion_content":"基础层的逻辑主要是SQL代码，DO和PO的转换和映射以及数据的持久化等。在没有仓储之前，这些代码会跟业务逻辑混杂在一起的。\n领域层和应用层通过仓储接口会将DO的对象传给仓储实现，在仓储实现里面实现DO和PO的转换以及数据的持久化。\n初始化的时候，仓储实现会实现PO到DO的转换，然后返回DO对象。\n这样的话，业务逻辑都是基于DO的操作，不管基础层如何变化，只要DO不发生变化，业务逻辑都不会影响。这样就实现了业务逻辑与基础逻辑的解耦了。\n\n仓储给你看一段在答疑那一节里面代码。\n有Person聚合根，Person仓储接口和仓储实现。\n/**\n * Person聚合根\n */\npublic class Person{\n  private String id;\n  private String name;\n  private int age; \n  private boolean gender；\n}\n\n/**\n * Person仓储接口\n */\npublic interface PersonRepositoryInterface {\n  void save(Person person); \n  void delete(String id); \n }\n\n/**\n *Person仓储实现\n */\n@Repository\npublic class PersonRepositoryImp implements PersonRepositoryInterface {\n  private PersonMapper mapper; \n  public void save( Person person) {\n      mapper.create(person);\n  }\n  public void delete((String id) {\n    mapper.delete(id);\n  }\n }\n在应用逻辑中直接用仓储的接口就可以了，数据库相关的逻辑在PersonMapper里面实现。\nPersonRepositoryInterface personRepos;\npersonRepos.save(person)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573697933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/40/bd/acb9d02a.jpg","nickname":"monkeyking","note":"","ucode":"4AF7ECF79C4379","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66389,"discussion_content":"为啥不直接把PersonRepositoryInterface配置成mapper呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575043517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50291,"discussion_content":"感谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573699836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267537,"user_name":"香","can_delete":false,"product_type":"c1","uid":1220273,"ip_address":"","ucode":"121D6CECECEEC3","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","comment_is_top":false,"comment_ctime":1607798337,"is_pvip":false,"replies":[{"id":"97302","content":"你这个微服务的功能就是BFF微服务的功能呀。下面一章会讲到。<br>BFF微服务只有应用层和用户接口层的职能，完成各个微服务的服务组合和编排，适配不同前端和渠道应用的个性需求，为前端应用提供粗粒度的组合服务。所以它没有领域模型，也不会有领域层，它不需要实现领域逻辑。BFF微服务与应用服务的差异主要体现在：BFF主要是微服务之间的服务组合和编排，而应用服务主要是微服务内的服务组合和编排。<br>您说的对象转换需要按需设计，如果不需要做各层的解耦的话，就不需要定义那么多的DO对象了，也就不需要转换了，毕竟转换也有性能损耗。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608019605,"ip_address":"","comment_id":267537,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10197732929","product_id":100037301,"comment_content":"有这样一个问题需要请教一下老师。<br>在我的实际场景中有这样一个微服务，它就是用来转调各个微服务来组装数据返回给前端页面的。<br>如果采用DDD的设计理念，我的想法是这样：<br>1.首先它就是个转调的服务，没有核心逻辑业务而言，所以分层应该只有用户接口层、应用层和基础层；<br>2.在应用层调用其它微服务接口，完成数据的组装后交由给用户接口层；<br>我的问题是：<br>1.我的这样设计有没有问题？<br>2.在应用层调用其它微服务时，它需要用到一些Rest调用的组件或客户端，那么这些Rest调用的客户端是放在应用层本身还是基础层？还是？<br>3.看到老师回答的一些问题提到DTO到DO对象的转换的说明，但都是建立在有领域层的场景，在我的场景中，没有领域层，那么我理解就不存在所谓的DO对象，这种转换要如何处理，就是当我通过用户接口层去调用应用层的应用服务方法时，在我的应用服务里，我的方法参数该如何设计？<br>说实话感觉这一讲如果能结合着一个小demo，就是有一份简单的小代码架构会比较好理解的。<br>另外我还有一个疑问就是：<br>4.在每一层都需要做一个对象的转换，这样我理解是不是会产生太多的这种冗余代码了？因为我看到这一讲的时候还有大家的提问，我脑海里满是各种对象的translate。<br>","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511673,"discussion_content":"你这个微服务的功能就是BFF微服务的功能呀。下面一章会讲到。\nBFF微服务只有应用层和用户接口层的职能，完成各个微服务的服务组合和编排，适配不同前端和渠道应用的个性需求，为前端应用提供粗粒度的组合服务。所以它没有领域模型，也不会有领域层，它不需要实现领域逻辑。BFF微服务与应用服务的差异主要体现在：BFF主要是微服务之间的服务组合和编排，而应用服务主要是微服务内的服务组合和编排。\n您说的对象转换需要按需设计，如果不需要做各层的解耦的话，就不需要定义那么多的DO对象了，也就不需要转换了，毕竟转换也有性能损耗。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608019605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","nickname":"香","note":"","ucode":"121D6CECECEEC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334378,"discussion_content":"嗯，一个想法是，其实可以处理得灵活一些，在我的场景，因为完全是转调其它服务，也就是query其它服务拿到数据，我完全可以把其它服务提供数据的接口当作是一个repo，这样会清晰非常多，同时也不至于我的app层过于庞大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607832166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247127,"user_name":"沈","can_delete":false,"product_type":"c1","uid":2168079,"ip_address":"","ucode":"53B56F4384D90E","user_header":"https://static001.geekbang.org/account/avatar/00/21/15/0f/4e1a9d92.jpg","comment_is_top":false,"comment_ctime":1599615397,"is_pvip":false,"replies":[{"id":"90765","content":"基础层可以面向所有层提供服务。其它层通过repo接口来访问基础层数据处理实现逻辑。这里采用了仓储模式。仓储模式包含仓储接口和仓储实现，仓储接口面向领域层提供基础层数据处理相关的访问接口，仓储实现完成仓储接口对应的数据持久化相关的逻辑处理。<br>领域层业务逻辑面向仓储接口编程，当聚合内的实体数据需要持久化时，只需将领域对象DO对象转换成PO持久化对象，然后传递给仓储接口，通过仓储实现完成DO数据的持久化工作。这样领域层就可以更好的聚焦于聚合的领域逻辑，而不必关心实体数据在基础层到底是如何实现持久化的了。<br>当更换数据库等基础资源时，我们只需要调整仓储实现代码，做好仓储实现的数据持久化处理逻辑与新数据库的适配就可以了。由于领域逻辑只通过仓储接口访问基础层实现逻辑，所以在更换基础资源时，只要仓储接口不变就不会影响到领域层的任何领域逻辑。<br>这是一种依赖倒置的设计方式，业务逻辑面向接口编程，而不是面向实现编程。这样可以避免业务逻辑与实现逻辑的耦合，在实现逻辑出现变化时，降低对业务逻辑的影响。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1599629638,"ip_address":"","comment_id":247127,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10189549989","product_id":100037301,"comment_content":"老师，.领域层可以依赖基础层，而基础层不能依赖领域层，那领域层的repo如何调用基础层的dao进行落库呢？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505319,"discussion_content":"基础层可以面向所有层提供服务。其它层通过repo接口来访问基础层数据处理实现逻辑。这里采用了仓储模式。仓储模式包含仓储接口和仓储实现，仓储接口面向领域层提供基础层数据处理相关的访问接口，仓储实现完成仓储接口对应的数据持久化相关的逻辑处理。\n领域层业务逻辑面向仓储接口编程，当聚合内的实体数据需要持久化时，只需将领域对象DO对象转换成PO持久化对象，然后传递给仓储接口，通过仓储实现完成DO数据的持久化工作。这样领域层就可以更好的聚焦于聚合的领域逻辑，而不必关心实体数据在基础层到底是如何实现持久化的了。\n当更换数据库等基础资源时，我们只需要调整仓储实现代码，做好仓储实现的数据持久化处理逻辑与新数据库的适配就可以了。由于领域逻辑只通过仓储接口访问基础层实现逻辑，所以在更换基础资源时，只要仓储接口不变就不会影响到领域层的任何领域逻辑。\n这是一种依赖倒置的设计方式，业务逻辑面向接口编程，而不是面向实现编程。这样可以避免业务逻辑与实现逻辑的耦合，在实现逻辑出现变化时，降低对业务逻辑的影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599629638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","nickname":"香","note":"","ucode":"121D6CECECEEC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334305,"discussion_content":"如果理解了DIP（依赖倒置），就容易理解这个了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607792466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435845,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/c5/8bdb0bba.jpg","nickname":"DarKnight","note":"","ucode":"B04AFD03768827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329259,"discussion_content":"我觉得依赖可以这么理解，指的是领域层不依赖于基础层的实现细节，领域层（上层）只是依赖了一个抽象的接口（可以理解为这个抽象接口定义在了一个完全隔离的地方），而基础层（下层）只要实现了这个抽象接口的方法，都可以随意切换使用，这里的区别在于，上层使用方不再直接显式调用下层的某个具体方法，从上层的代码角度来看，甚至没有引入任何下层的包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606354522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176237,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1580996895,"is_pvip":false,"replies":[{"id":"68786","content":"能做到依赖分离，就不必要了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581314920,"ip_address":"","comment_id":176237,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10170931487","product_id":100037301,"comment_content":"老师好，现在大多数orm框架都支持多RDBMS，只需要简单配置就能实现mysql到mssql的替换。那还需要依赖倒置吗？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483059,"discussion_content":"能做到依赖分离，就不必要了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581314920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387279,"discussion_content":"我的理解是：第一不只数据库，ORM也可能发生变化；第二是基础设施层并不仅仅只是包含数据库，所以依赖倒置依然有必要","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628084830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2089155,"avatar":"","nickname":"昌南一枝花","note":"","ucode":"66118BEFFDC9BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297325,"discussion_content":"那意味着Repository模式已经没有使用到的场景了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596874488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310109,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1630487950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5925455246","product_id":100037301,"comment_content":"总结：<br><br>- 用户接口层：在应用层完成领域层服务组合和编排后，应用服务被用户接口层Facade服务封装，完成接口和数据适配后，以粗粒度的服务通过API网关面向前端应用发布。可以用来适配前后端的调用，可以用Facade模式实现包括DO和DTO对象的组装和转换等。<br>- 应用层：很薄的一层。主要职能是协调领域层多个聚合完成服务的组合和编排。入参校验一般在应用层来做。<br>- 领域层：领域层是由多个业务职责单一的聚合构成，实现核心的领域逻辑。<br>- 基础层：存储仓库接口的实现层。<br><br><br>* 传统分层：三层架构的业务接口层、业务逻辑层、数据访问层，对应实际开发的controller、service和dao三层；<br>* 领域服务：多个实体可组成的更复杂的业务动作；<br>* 聚合根：聚合根也可以用来做多个实体的复杂业务逻辑，但主要负责的就是数据和仓储相关的内容。<br>* 基础能力：实体的方法和领域服务共同构成领域模型的基础业务能力；应用服务是对这些基础的能力进行组合和编排。","like_count":1},{"had_liked":false,"id":272814,"user_name":"Geek_zyq","can_delete":false,"product_type":"c1","uid":2399835,"ip_address":"","ucode":"2421956B3EA7A9","user_header":"https://static001.geekbang.org/account/avatar/00/24/9e/5b/8c51e671.jpg","comment_is_top":false,"comment_ctime":1610294021,"is_pvip":false,"replies":[{"id":"99166","content":"这两种方式都可以实现聚合的解耦，但是各有利弊。<br>这是因为聚合是微服务内最小的业务功能单元。为了保证聚合内数据更新时，符合聚合内固定的业务规则，在一次事务提交时通常会将聚合内所有变更的对象数据作为整体，通过聚合领域服务一次通过仓储完成数据持久化操作。如果在一次交易中需要同时更新多个聚合数据，那么每一个聚合就是一个独立的数据提交单元，我们需要确保多个聚合数据都能在这个交易中提交更新成功，以保证不同聚合数据的一致性。而基于事件总线的异步化机制，就可以保证微服务内聚合之间数据提交时的最终一致性。<br>如果不采用事件总线的机制，其实你也可以采用事务机制保证数据强一致性。比如在应用服务中增加事务控制，在对多个聚合的领域服务进行组合和编排时，通过事务机制来确保多个聚合在提交数据时实现数据强一致性。这种方式一般应用于实时性和数据一致性要求高的业务场景，因为采用事务机制可能会出现系统性能损耗。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1610693645,"ip_address":"","comment_id":272814,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5905261317","product_id":100037301,"comment_content":"老师我想请问一下：上一讲说到如果要一次变更多个聚合的数据，需要使用领域事件，这一讲又说应用层负责编排协调多个聚合，这两者的功能好像重复了？我可不可以不用领域事件，就在应用层去协调多个聚合？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513399,"discussion_content":"这两种方式都可以实现聚合的解耦，但是各有利弊。\n这是因为聚合是微服务内最小的业务功能单元。为了保证聚合内数据更新时，符合聚合内固定的业务规则，在一次事务提交时通常会将聚合内所有变更的对象数据作为整体，通过聚合领域服务一次通过仓储完成数据持久化操作。如果在一次交易中需要同时更新多个聚合数据，那么每一个聚合就是一个独立的数据提交单元，我们需要确保多个聚合数据都能在这个交易中提交更新成功，以保证不同聚合数据的一致性。而基于事件总线的异步化机制，就可以保证微服务内聚合之间数据提交时的最终一致性。\n如果不采用事件总线的机制，其实你也可以采用事务机制保证数据强一致性。比如在应用服务中增加事务控制，在对多个聚合的领域服务进行组合和编排时，通过事务机制来确保多个聚合在提交数据时实现数据强一致性。这种方式一般应用于实时性和数据一致性要求高的业务场景，因为采用事务机制可能会出现系统性能损耗。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610693645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266103,"user_name":"平平淡淡财是真","can_delete":false,"product_type":"c1","uid":2033476,"ip_address":"","ucode":"BC23C8A194DDA3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/07/44/1df0e4cd.jpg","comment_is_top":false,"comment_ctime":1607170834,"is_pvip":false,"replies":[{"id":"97305","content":"依赖倒置（DIP）设计是面向接口编程的思想，而不是面向实现编程。这样可以避免业务逻辑与实现逻辑的耦合，在实现逻辑出现变化时，降低对业务逻辑的影响。<br>你可以这么理解。<br>领域层业务逻辑面向仓储接口编程，当聚合内的实体数据需要持久化时，只需将领域对象DO对象转换成PO持久化对象，然后传递给仓储接口，通过仓储实现完成DO数据的持久化工作。这样领域层就可以更好的聚焦于聚合的领域逻辑，而不必关心实体数据在基础层到底是如何实现持久化的了。<br>在更换数据库基础资源时，我们只需要调整仓储实现代码，做好仓储实现的数据持久化处理逻辑与新数据库的适配就可以了。由于领域逻辑只通过仓储接口访问基础层逻辑实现，所以在更换基础资源时，只要仓储接口不变就不会影响到领域层的任何领域逻辑。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608020431,"ip_address":"","comment_id":266103,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5902138130","product_id":100037301,"comment_content":"感觉依赖倒置只是一种思想，从老师上面的传统四层架构演进到依赖倒置的四层架构的图中看出，改变了两点，这里我只理解了其中的一个点，就是倒置后，接口层--&gt;应用层--&gt;领域层，只保留层级之间的依赖关系，而基础层去依赖其他的层级，但实际使用过程中，感觉依然是其他层去使用基础层，依然对基础层存在依赖。这一点不是很理解","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511151,"discussion_content":"依赖倒置（DIP）设计是面向接口编程的思想，而不是面向实现编程。这样可以避免业务逻辑与实现逻辑的耦合，在实现逻辑出现变化时，降低对业务逻辑的影响。\n你可以这么理解。\n领域层业务逻辑面向仓储接口编程，当聚合内的实体数据需要持久化时，只需将领域对象DO对象转换成PO持久化对象，然后传递给仓储接口，通过仓储实现完成DO数据的持久化工作。这样领域层就可以更好的聚焦于聚合的领域逻辑，而不必关心实体数据在基础层到底是如何实现持久化的了。\n在更换数据库基础资源时，我们只需要调整仓储实现代码，做好仓储实现的数据持久化处理逻辑与新数据库的适配就可以了。由于领域逻辑只通过仓储接口访问基础层逻辑实现，所以在更换基础资源时，只要仓储接口不变就不会影响到领域层的任何领域逻辑。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608020431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2033476,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/07/44/1df0e4cd.jpg","nickname":"平平淡淡财是真","note":"","ucode":"BC23C8A194DDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336599,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608631307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265150,"user_name":"玛尼玛尼哄","can_delete":false,"product_type":"c1","uid":1958527,"ip_address":"","ucode":"FB59CE2531102B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjPolxbUHLkgXFibMEuL0knexNb0ibBmiagVPnK9CiazS8NcXHBwqPIzo4cqG5iaicXibic3pHuKNWDiaYbaw/132","comment_is_top":false,"comment_ctime":1606794352,"is_pvip":false,"replies":[{"id":"96476","content":"1、聚合根是一种特殊的实体，又称根实体。聚合内包含聚合根、实体、值对象以及领域服务（组合多实体完成业务逻辑）,所以entity只是聚合中的实体。<br>2、聚合是一个逻辑概念，聚合内的聚合根管理了聚合内所有实体和值对象的生命周期，我们通过聚合根就可以获取到聚合内所有实体和值对象等领域对象。一般来说，如果聚合根被删除了，那么被它引用的实体和值对象也就不会存在了。<br>在聚合根类的方法中，可以组织聚合内部的领域对象，完成跨多个实体的复杂业务逻辑。但是，在聚合的领域服务中，也可以完成跨多个实体的复杂领域逻辑。<br>你可能会问，那跨多个实体的业务逻辑到底应该在聚合根还是在领域服务中实现呢？ <br>理论上，聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，只作为实体实现与聚合根自身行为相关的业务逻辑，而将跨多个实体的复杂领域逻辑统一放在领域服务中实现。当然，简单聚合的跨多个实体的领域逻辑，可以考虑在聚合根的方法中实现。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1606896706,"ip_address":"","comment_id":265150,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5901761648","product_id":100037301,"comment_content":"欧老师您好，我在理解基础概念和分层架构的时候有几个问题请教一下，希望能得到你的回复<br>1、分层结构中，领域层的entity应该是基础概念中的聚合，而不是一个实体（或者聚合根）是吧？我理解的聚合根也只是聚合中的一个特殊的实体。<br>2、在基础概念中有介绍聚合，【领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性】。我原本的理解中，聚合通过组合使用内部多个实体的的业务方法，来实现垮内部多个实体的复合业务，以此来体现聚合在实体间的【协同】作用，保证数据的一致性；我的理解中聚合也可以认为是一个【大】的实体，内部用充血模型来实现夸多个内部实体的业务逻辑。但是后面又出现了领域服务，用来处理聚合内夸多个实体的复合业务问题。哪我想请问下，这个聚合对内部实体的【协同】表现在什么地方？同时聚合如何来保证数据的一致性呢？这不应该是领域服务来保证的吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510820,"discussion_content":"1、聚合根是一种特殊的实体，又称根实体。聚合内包含聚合根、实体、值对象以及领域服务（组合多实体完成业务逻辑）,所以entity只是聚合中的实体。\n2、聚合是一个逻辑概念，聚合内的聚合根管理了聚合内所有实体和值对象的生命周期，我们通过聚合根就可以获取到聚合内所有实体和值对象等领域对象。一般来说，如果聚合根被删除了，那么被它引用的实体和值对象也就不会存在了。\n在聚合根类的方法中，可以组织聚合内部的领域对象，完成跨多个实体的复杂业务逻辑。但是，在聚合的领域服务中，也可以完成跨多个实体的复杂领域逻辑。\n你可能会问，那跨多个实体的业务逻辑到底应该在聚合根还是在领域服务中实现呢？ \n理论上，聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，只作为实体实现与聚合根自身行为相关的业务逻辑，而将跨多个实体的复杂领域逻辑统一放在领域服务中实现。当然，简单聚合的跨多个实体的领域逻辑，可以考虑在聚合根的方法中实现。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606896706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240352,"user_name":"昌南一枝花","can_delete":false,"product_type":"c1","uid":2089155,"ip_address":"","ucode":"66118BEFFDC9BF","user_header":"","comment_is_top":false,"comment_ctime":1596874907,"is_pvip":false,"replies":[{"id":"88807","content":"两种分层架构的优劣我在第16章有分析，建议看一看。总体来说，我觉得严格分层架构比较好管理服务，虽然麻烦一些。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597015996,"ip_address":"","comment_id":240352,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5891842203","product_id":100037301,"comment_content":"假如用户接口层只是需要简单的调用单个的领域服务方法，而在应用层创建一个对应的方法来透传参数调用领域服务，是不是太死板了？是不是实际开发过程中松散分层更实用？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503411,"discussion_content":"两种分层架构的优劣我在第16章有分析，建议看一看。总体来说，我觉得严格分层架构比较好管理服务，虽然麻烦一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597015996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227899,"user_name":"李剑洪","can_delete":false,"product_type":"c1","uid":1348199,"ip_address":"","ucode":"F185531DBF9C4E","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/67/a8c5cacf.jpg","comment_is_top":false,"comment_ctime":1592525039,"is_pvip":true,"replies":[{"id":"84124","content":"工具包放基础层就可以了，工具包的能力，如果可能还是尽量封装成facade接口。业务逻辑实现时调facade接口就可以了。如果成本太高了，也可以不考虑依赖倒置。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1592572081,"ip_address":"","comment_id":227899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5887492335","product_id":100037301,"comment_content":"对于基础层公共工具包，配置等这些同样会在领域层使用到，通过依赖倒置，那这些公共工具包怎么处理？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498824,"discussion_content":"工具包放基础层就可以了，工具包的能力，如果可能还是尽量封装成facade接口。业务逻辑实现时调facade接口就可以了。如果成本太高了，也可以不考虑依赖倒置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592572081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211295,"user_name":"Winon","can_delete":false,"product_type":"c1","uid":1080055,"ip_address":"","ucode":"17F4108B2F5D00","user_header":"https://static001.geekbang.org/account/avatar/00/10/7a/f7/24df0ff9.jpg","comment_is_top":false,"comment_ctime":1587946641,"is_pvip":false,"replies":[{"id":"78771","content":"聚合是包含聚合根、实体、值对象和领域服务的。第二张图的领域服务应该在聚合内，已调整，谢谢指出。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588044464,"ip_address":"","comment_id":211295,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882913937","product_id":100037301,"comment_content":"老师，你第二张图的聚合只包含实体和值对象，但是最后一张分层架构图的聚合又包含了领域服务，能说下为什么吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493244,"discussion_content":"聚合是包含聚合根、实体、值对象和领域服务的。第二张图的领域服务应该在聚合内，已调整，谢谢指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588044464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206069,"user_name":"阿信","can_delete":false,"product_type":"c1","uid":1399663,"ip_address":"","ucode":"CC7B15CE63264B","user_header":"https://static001.geekbang.org/account/avatar/00/15/5b/6f/113e24e6.jpg","comment_is_top":false,"comment_ctime":1586783811,"is_pvip":false,"replies":[{"id":"77321","content":"DO主要体现领域模型的关键对象，所以它的作用域主要在领域层，DO在应用层也是可以用的。基础层主要是PO，用户接口层是DTO。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587003245,"ip_address":"","comment_id":206069,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5881751107","product_id":100037301,"comment_content":"老师，您好，请问下<br>DO可以采用充血模型，封装自身相关的行为。如注入Repository完成自身的持久化等。<br>那DO的作用域会在哪些层？ 或者说哪几层可访问DO？<br><br>我的理解：领域服务可访问DO，基础层和用户层不可访问。 <br>这个理解是否正确？另应用层是否可访问，我现在不太确定？会基于什么因素来考虑？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491660,"discussion_content":"DO主要体现领域模型的关键对象，所以它的作用域主要在领域层，DO在应用层也是可以用的。基础层主要是PO，用户接口层是DTO。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587003245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2033476,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/07/44/1df0e4cd.jpg","nickname":"平平淡淡财是真","note":"","ucode":"BC23C8A194DDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336594,"discussion_content":"老师讲的充血模型，指的是在领域对象DO里面实现，而不是在实体对象PO里面实现是这样吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608630972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187480,"user_name":"sundy","can_delete":false,"product_type":"c1","uid":1724856,"ip_address":"","ucode":"581D4B976524B6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/51/b8/f76b15a1.jpg","comment_is_top":false,"comment_ctime":1584140504,"is_pvip":false,"replies":[{"id":"72540","content":"DDD是一种设计思想，只要你的业务领域能构建出领域模型，不管什么技术都是可以用的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584283815,"ip_address":"","comment_id":187480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879107800","product_id":100037301,"comment_content":"老师我想请教一下，DDD除了在微服务和中台有所应用，其他方面是否也可以应用，比如分布式，单体应用，甚至移动端的组件化，因为像我们这种小企业和初创公司，微服务很难落地，业务较为复杂时可能也就能采用传统的分布式、soa。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487118,"discussion_content":"DDD是一种设计思想，只要你的业务领域能构建出领域模型，不管什么技术都是可以用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584283815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178453,"user_name":"发飙的蜗牛","can_delete":false,"product_type":"c1","uid":1800868,"ip_address":"","ucode":"B2D96A2D0B6BA4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/a4/79ffe77c.jpg","comment_is_top":false,"comment_ctime":1581692091,"is_pvip":false,"replies":[{"id":"69235","content":"你可以看一下第十八节和加餐，里面用一个实际的案例把所有知识点基本都涵盖进去了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581730555,"ip_address":"","comment_id":178453,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5876659387","product_id":100037301,"comment_content":"DDD分层架构主要分为用户接口层，应用层，领域层自己基础层。用户接口层对外提供api接口，接收用户(可以是用户操作，其他微服务调用，消息监听等)指令调用，用户接口层调用应用层接口。应用层负责服务的组合和编排，体现在业务用例场景或者业务流程等，调用领域层领域服务来组装应用服务，然后暴露给接口层。领域层服务系统核心业务逻辑，包含重要的领域对象，如聚合，实体，值对象，领域服务等，实体都是充血模型，体现业务能力，领域服务跨多个实体协作完成业务功能。基础层提供基础服务，例如数据库，第三方服务，消息中间件等。依赖倒置能够使基础层跟其他层解耦，例如当需要替换数据库的时候，只需要替换实现就可以！DDD分层架构设计，严格把握处理好层级关系，设计好代码边界，有利于以后威服务架构的演进，从而响应业务变化。<br>老师，对于这个架构讲解，建议给一个代码例子，放个github地址更好呢！感谢，学到很多","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483827,"discussion_content":"你可以看一下第十八节和加餐，里面用一个实际的案例把所有知识点基本都涵盖进去了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581730555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164793,"user_name":"北极光","can_delete":false,"product_type":"c1","uid":1588880,"ip_address":"","ucode":"CFB4A262ED9202","user_header":"https://static001.geekbang.org/account/avatar/00/18/3e/90/39f9c90b.jpg","comment_is_top":false,"comment_ctime":1577092427,"is_pvip":false,"replies":[{"id":"64868","content":"不好意思哈，没看太懂，能否举个例子说明一下。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577674511,"ip_address":"","comment_id":164793,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5872059723","product_id":100037301,"comment_content":"老师，我有两个问题：<br>1.基础服务 如果碰到工具类，还可以勉强放里面，但是静态扩展类就不行了，因为最新框架领域才是最低层。那么这种静态扩展类怎么放好呢？或则说怎么处理？<br><br>2.领域的实体，虽然说是充血模型，但是实体里面的某个方法，很可能会细分很多业务类，甚至用到设计模式，比如用工厂。那么这些由实体的某一个方法细分开来的实现类，应该放在哪里？还是放在领域层吗？如果放在领域层，有什么好的方式区分他跟实体的区别呢？比如实体我放在entity文件夹下面，这些放在哪个文件夹下面呢？实体调用这些类，是直接new呢？还是这些类也用接口？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478895,"discussion_content":"不好意思哈，没看太懂，能否举个例子说明一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577674511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543414,"discussion_content":"老师 你好 我觉得北极光同学说的有道理 我看到这里也有相同的疑问？ 他的第2个问题意思是如果我们在领域层实现我们的业务时 中间可能会产生比较多的其它的类 那么这些类该怎么定义？放到哪个文件夹？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641130402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":478895,"ip_address":""},"score":543414,"extra":""}]}]},{"had_liked":false,"id":156739,"user_name":"Geek_4660f3","can_delete":false,"product_type":"c1","uid":1757482,"ip_address":"","ucode":"8B59B0C29EF88A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIMFaaIb1ZyU6zuYrT2WlD4RrsV2orxLonpIFwsx3ic01OLJ0N4dnSXQ3mFQxnbemiabKDw9810rX4Q/132","comment_is_top":false,"comment_ctime":1574944880,"is_pvip":false,"replies":[{"id":"60359","content":"1、差异很大的，三层架构没有领域模型的概念，业务逻辑混杂在一起。DAO也是没有严格区分应用逻辑和基础资源逻辑的。<br>2、是的。<br>3、在目录结构里，仓储接口和实现都在聚合目录里面。<br>4、这四层都是在一个微服务工程里面。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575167114,"ip_address":"","comment_id":156739,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869912176","product_id":100037301,"comment_content":"老师您好！<br>我还有几个疑问：<br>1、领域层和基础层的关系和传统三层架构中service和dao的区别在哪里，感觉没什么区别<br>2、领域层和基础层的依赖倒置是不是就是通过增加仓库接口来实现的，让领域层依赖仓库接口和基础层对仓库接口依赖并且实现接口。具体跟仓库接口放在什么位置无关<br>3、仓库接口放在领域层方便一起打包带走，但是仓库具体的实现在基础层，领域层打包带走那仓库具体实现咋办<br>4、微服务拆分的时候领域层跟基础层一般是放在一个工程下面的么","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476218,"discussion_content":"1、差异很大的，三层架构没有领域模型的概念，业务逻辑混杂在一起。DAO也是没有严格区分应用逻辑和基础资源逻辑的。\n2、是的。\n3、在目录结构里，仓储接口和实现都在聚合目录里面。\n4、这四层都是在一个微服务工程里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575167114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149319,"user_name":"骆驼1089","can_delete":false,"product_type":"c1","uid":1046421,"ip_address":"","ucode":"6E2EA2955BF204","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/95/42e16e49.jpg","comment_is_top":false,"comment_ctime":1573191876,"is_pvip":false,"replies":[{"id":"57414","content":"应用层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573198269,"ip_address":"","comment_id":149319,"utype":1}],"discussion_count":5,"race_medal":0,"score":"5868159172","product_id":100037301,"comment_content":"老师，有一个问题问一下，DDD分层架构，对传入参数校验，应该放在哪层呢？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473815,"discussion_content":"应用层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573198269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045770,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/0a/077b9922.jpg","nickname":"krugle","note":"","ucode":"60A7D9189C01BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57205,"discussion_content":"如果在应用层校验，比如一些复杂的参数校验，需要计算的 也是放到这层吗，给用户一个合理的提示，这一层好像做不了啊，那么领域层还需要校验吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574581342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88929,"discussion_content":"入参校验放在应用层,业务逻辑校验放在领域层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576740879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74234,"discussion_content":"领域层也是可以的啊，主要是业务规则之类的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575639987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1438475,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/0b/4560079e.jpg","nickname":"王宇","note":"","ucode":"0E9BC3AD99C8E5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":189667,"discussion_content":"这个我也赞同，规则本身就是领域的一部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582896900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74234,"ip_address":""},"score":189667,"extra":""}]}]},{"had_liked":false,"id":148819,"user_name":"Geek_f0e3c6","can_delete":false,"product_type":"c1","uid":1730498,"ip_address":"","ucode":"4CC3525E92BFE1","user_header":"","comment_is_top":false,"comment_ctime":1573090649,"is_pvip":false,"replies":[{"id":"57287","content":"我主要分析的是四层😄。五层只是告诉大家有这个东西。后面也是基于四层来开展的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573097114,"ip_address":"","comment_id":148819,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868057945","product_id":100037301,"comment_content":"前面讲DDD分5层，后面怎么就没了上下文环境层？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473624,"discussion_content":"我主要分析的是四层😄。五层只是告诉大家有这个东西。后面也是基于四层来开展的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573097114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148677,"user_name":"若水","can_delete":false,"product_type":"c1","uid":1303418,"ip_address":"","ucode":"575F2A2F579B0B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKeqZb7U4s6SZHXz1Vv2u8iaHibZeZ9Ndgibr2nT9BS6Z4wiao3j8Ya5O8FK1SnxxyagDjvsMYaauWficA/132","comment_is_top":false,"comment_ctime":1573047991,"is_pvip":false,"replies":[{"id":"57266","content":"应用层做。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573051800,"ip_address":"","comment_id":148677,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5868015287","product_id":100037301,"comment_content":"老师您好，我想咨询一下，领域驱动校验一般放在那一层？<br>如下情况：<br>1.判断属性是否为空？<br>2.判断日期开始小于结束？<br>3.校验需要调用另外一个领域服务？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473573,"discussion_content":"应用层做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573051800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438475,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/0b/4560079e.jpg","nickname":"王宇","note":"","ucode":"0E9BC3AD99C8E5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189678,"discussion_content":"领域层可以吗？有些和业务关联性比较强的放到领域层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582897117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148658,"user_name":"vivi","can_delete":false,"product_type":"c1","uid":1357983,"ip_address":"","ucode":"360A81D2003C99","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/9f/c64f0896.jpg","comment_is_top":false,"comment_ctime":1573045347,"is_pvip":false,"replies":[{"id":"57267","content":"尽量解耦吧。如果不存在业务逻辑与基础服务耦合的问题，感觉不用也可以。考虑一下综合成本和性价比。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573051926,"ip_address":"","comment_id":148658,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5868012643","product_id":100037301,"comment_content":"老师，是对我们所有依赖的基础服务（DB，ES，MQ，REDIS，ZOOKEEPER等）都做成仓储对模式吗？都用一个Repository 接口和对应的实现。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473568,"discussion_content":"尽量解耦吧。如果不存在业务逻辑与基础服务耦合的问题，感觉不用也可以。考虑一下综合成本和性价比。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573051926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387283,"discussion_content":"数据库使用Repository模式解耦，其他服务未必一定用这个模式，只要通过接口达到解耦目的即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628085427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543417,"discussion_content":"那这样的话可能就比较乱了 后面发展就不知道什么情况了 不过也确实没有好的办法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641130905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":387283,"ip_address":""},"score":543417,"extra":""}]}]},{"had_liked":false,"id":148007,"user_name":"八百","can_delete":false,"product_type":"c1","uid":1253530,"ip_address":"","ucode":"79F1F79ADF5A00","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/9a/3b1c65fd.jpg","comment_is_top":false,"comment_ctime":1572927564,"is_pvip":false,"replies":[{"id":"57011","content":"DO转PO。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572929878,"ip_address":"","comment_id":148007,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5867894860","product_id":100037301,"comment_content":"仓储用来存储实体，但是实体定义在领域层，仓储在基础层，项目结构里，基础层是访问不到领域层的实体类的吧，是在领域层做一层数据转换吗","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473369,"discussion_content":"DO转PO。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572929878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387285,"discussion_content":"通过仓储模式，将仓储接口定义在领域层，仓储实现在基础层，基础层依赖领域层，基础层可以访问到领域层中实体类。个人认为领域对象DO和持久化对象PO，很多时候都模糊称为实体，并不严格区分，完全可以复用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628085852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146023,"user_name":"。","can_delete":false,"product_type":"c1","uid":1222200,"ip_address":"","ucode":"75B163F01F20F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/38/55483b8c.jpg","comment_is_top":false,"comment_ctime":1572421107,"is_pvip":false,"replies":[{"id":"56354","content":"实体除了自身相关的增删改查外，自身相关的其它业务行为也是在实体类内部来实现的，比如实体内不同属性之间的业务逻辑处理，多个同类实体的逻辑处理。<br>聚合根内对多个实体操作的方法，主要还是在数据方面的处理，本质上是实体的方法，只不过它是聚合根。<br>我理解的领域服务是对多个实体属性以及方法进行组合的业务处理，主要表现为多个实体组合出来的一段复杂业务逻辑。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572426868,"ip_address":"","comment_id":146023,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867388403","product_id":100037301,"comment_content":"1.DDD中对于“实体”大部分情况和“数据库表”是一对一的。“实体”采用充血模型，也就是将单表的增删改查功能放在对应的“实体”里。<br>2.“聚合根”是将一组有关联的“实体”进行聚集，一次业务操作通过“聚合根”处理多个“实体”，那“聚合根”里的方法（针对这组“实体”的增删改查）就是领域服务。<br><br>欧老师，以上理解是否正确？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472674,"discussion_content":"实体除了自身相关的增删改查外，自身相关的其它业务行为也是在实体类内部来实现的，比如实体内不同属性之间的业务逻辑处理，多个同类实体的逻辑处理。\n聚合根内对多个实体操作的方法，主要还是在数据方面的处理，本质上是实体的方法，只不过它是聚合根。\n我理解的领域服务是对多个实体属性以及方法进行组合的业务处理，主要表现为多个实体组合出来的一段复杂业务逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572426868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357171,"user_name":"李卫卫","can_delete":false,"product_type":"c1","uid":1367591,"ip_address":"上海","ucode":"F89946C5BF9EA1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo6qUrJUgVNIMeWy4ffwR7AiahZSuiaOSGeicwSydRm0s5WUwzqxTib8hCuf6ticP8sKmabTf9WSgYHRxw/132","comment_is_top":false,"comment_ctime":1663030890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663030890","product_id":100037301,"comment_content":"老师，你好，不太理解基础层需要依赖领域层这个设计","like_count":0},{"had_liked":false,"id":352790,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1658926784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658926784","product_id":100037301,"comment_content":"实际应用中有谁会不停的重新划分领域，写的道理都对，没有实战的可能","like_count":0},{"had_liked":false,"id":351555,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1657888264,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657888264","product_id":100037301,"comment_content":"ddd分层核心：<br>1.业务内聚在领域层，拆分出应用层与领域层<br>背后的思考是能付用的业务逻辑聚合在一个单元，<br>单元可被多个应用层编排复用<br>如交易流程需要完成交易逻辑，还需要发积分或其它事情，这个按这个分层架构就很清晰<br>2.依赖倒置<br>领域层才是核心，仓储层服务领域层","like_count":0},{"had_liked":false,"id":344473,"user_name":"黄岩","can_delete":false,"product_type":"c1","uid":1238561,"ip_address":"","ucode":"8002AB7E17AC93","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/21/4b309276.jpg","comment_is_top":false,"comment_ctime":1651574954,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651574954","product_id":100037301,"comment_content":"看上去是将数据访问层的mapper xml 和 mapper interface 放到领域层，而DDD四层架构中的基础层只负责了 mapper 的事务与数据源管理<br>另外像 redis、mq 和 其他中间件是否同理呢（将接口和实现都放到领域层，基础层只维护配置）？<br>像文件处理、事件总线的配置也是同理吗？","like_count":0},{"had_liked":false,"id":343390,"user_name":"陶乐乐","can_delete":false,"product_type":"c1","uid":1943501,"ip_address":"","ucode":"2D4355A7498948","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epb9WYgYQJCMF3XrBbYxnzoXchW2DHfrXHeI2iasiasFdHzJ1XEMjKIN1WdqCgqIQqWU2ibQmYbCic6Gg/132","comment_is_top":false,"comment_ctime":1650812914,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650812914","product_id":100037301,"comment_content":"分层的目的主要是确定各层的职责编辑，而DDD各强调的依赖是限制依赖，而不是松散的依赖，即隔层不能相互调用。DDD分层为：接口层、应用层、领域层以及基础层。接口主要是展示交换，应用层强调服务的编排组装，领域层强调的服务的原子化，而基础层则是基础能力的支持。每层都有自己的定位，才能为后续的变化或扩展打下良好基础。","like_count":0},{"had_liked":false,"id":339919,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1648461812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648461812","product_id":100037301,"comment_content":"持久化操作不应该在领域层吧， cola框架也是把持久化操作在基础层的","like_count":0},{"had_liked":false,"id":339406,"user_name":"WESTWALL","can_delete":false,"product_type":"c1","uid":1434423,"ip_address":"","ucode":"295A030F9D3BF4","user_header":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","comment_is_top":false,"comment_ctime":1648085193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648085193","product_id":100037301,"comment_content":"三层架构和DDD在分层上的差异，只是战术层面的区别。我认为更重要的差别是：前者是“面向接口编程”，关注点在提供哪些接口；后者是关注领域对象与其所具备的业务能力。","like_count":0},{"had_liked":false,"id":333301,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1644280475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644280475","product_id":100037301,"comment_content":"“本层接口不变时，其他层基本不需要修改”，这不是DDD特有的吧。<br>DDD到底有什么独特优势，还是不太清楚，愁人","like_count":0},{"had_liked":false,"id":332118,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1643027857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643027857","product_id":100037301,"comment_content":"“为了换数据库方便”的观点有些不切实际<br>这就跟“为了预防天上掉石头”而天天出门带头盔一样","like_count":0},{"had_liked":false,"id":330260,"user_name":"小鱼","can_delete":false,"product_type":"c1","uid":1248115,"ip_address":"","ucode":"022B6D5D69DB68","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/73/44fe2df9.jpg","comment_is_top":false,"comment_ctime":1641886389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641886389","product_id":100037301,"comment_content":"大佬们，DDD依赖倒置的分层结构<br>有个疑问，仓储（对数据库等的访问）的定义在领域层，实现在基础层，每一层只能依赖调用它的下一层，那基础层作为最上层，没有人依赖它，怎么感觉实现了没啥用呢，以为没人调用它呀，是我理解错了，我能想到的是这个地方使用类似service 和serviceImpl的方式，项目根pom下引入基础层的模块，实现以bean的方式注入倒是可以，如果不使用bean注入，甚至不使用spring那么该咋搞？","like_count":0},{"had_liked":false,"id":326137,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1639390765,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639390765","product_id":100037301,"comment_content":"整体读下来，感觉和MVC的分层架构的核心变化不大，都是一个分层，隔离，每一层只依赖他的下一层。但非要说区别，从MVC 三层直接切换到DDD四层架构，倒还是有点不习惯。从三层：用户层，业务层，数据层转到 四层：用户层，应用层，领域层和基础层。恰恰多出来的这一层：领域层，算是DDD的核心中的核心，包含它自由的概念：实体，值对象，聚合，聚合根，限界上下文，都是在这里定义，封装成领域对象。<br><br>那应用层又有哪些领域对象，应用层的领域对象主要是指各个领域聚合再组合的一个抽象，各个领域对象组合成业务层要用到的领域对象。","like_count":0},{"had_liked":false,"id":322878,"user_name":"少帅","can_delete":false,"product_type":"c1","uid":1045791,"ip_address":"","ucode":"EF88F62C236594","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/1f/577265ea.jpg","comment_is_top":false,"comment_ctime":1637640449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637640449","product_id":100037301,"comment_content":"老师你好，<br>“此外，应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排。”<br>那么就是应用层调用其他微服务暴露的应用服务了，可以这样理解吗？<br>另外还有一个问题请教一下，我看你把应用事件的处理放到了应用层，这样不是引入了具体技术吗？如果放基础设施层，又导致基础设施层依赖了应用层，有点迷惑","like_count":0},{"had_liked":false,"id":322829,"user_name":"信仰","can_delete":false,"product_type":"c1","uid":2833225,"ip_address":"","ucode":"00FD50962AC5D2","user_header":"https://static001.geekbang.org/account/avatar/00/2b/3b/49/83712608.jpg","comment_is_top":false,"comment_ctime":1637627867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637627867","product_id":100037301,"comment_content":"我理解的基础层依赖倒置应该是接口定义在领域层，实现定义在基础层，这样就变成基础层依赖领域层。老师您说的接口和实现都在聚合包下面，怎么实现的基础层依赖领域层呢？","like_count":0},{"had_liked":false,"id":318349,"user_name":"lcf枫","can_delete":false,"product_type":"c1","uid":1144171,"ip_address":"","ucode":"D51E8F68BD41CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/75/6b/fd685164.jpg","comment_is_top":false,"comment_ctime":1635252171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635252171","product_id":100037301,"comment_content":"老师，我有一个困惑。在存储层。我有两个仓库 mysql localcache，使用策略的方式我可以选择其中一种去获取数据。但是使用依赖倒置的方式，感觉只能使用一种。这个怎么去解决呢？","like_count":0},{"had_liked":false,"id":311482,"user_name":"零零冒","can_delete":false,"product_type":"c1","uid":1056139,"ip_address":"","ucode":"AECC9D1A0F1583","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/8b/fd5d5a3d.jpg","comment_is_top":false,"comment_ctime":1631251514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631251514","product_id":100037301,"comment_content":"请问老师，领域服务和聚合根的区别是什么？","like_count":0},{"had_liked":false,"id":306250,"user_name":"warrior","can_delete":false,"product_type":"c1","uid":1341216,"ip_address":"","ucode":"A0C7BEF5B3DC89","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK7CENSOKQLib0HGXV6KoY8NVD8vk9YdicdTwpJjJTucBkVCHKibhMepOFLxOnuNPhSkxrzd264gw9Jw/132","comment_is_top":false,"comment_ctime":1628472443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628472443","product_id":100037301,"comment_content":"按照严格分层的规则，下层infra只能被domain层调用。如果我用netty封装了一个tomcat，那么user interface层将无法被infra的netty调用了，这不合理吧？","like_count":0},{"had_liked":false,"id":301768,"user_name":"重放","can_delete":false,"product_type":"c1","uid":1766740,"ip_address":"","ucode":"4D0FCF38F9AED3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELpFhr06SHLSicj6ZjR68aRuy6q939nGqHUAROuxNc5Cks2d8gylonwyozYT3v3ibrqKmPmWibAjuIHg/132","comment_is_top":false,"comment_ctime":1625871391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625871391","product_id":100037301,"comment_content":"不是说事件总线放在应用服务层吗？为什么最后的架构图是在基础设施层？","like_count":0},{"had_liked":false,"id":299891,"user_name":"幽林萌逐","can_delete":false,"product_type":"c1","uid":1520451,"ip_address":"","ucode":"E6D95EC891800F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLqrAA1j4Oyy6ibicNOicn8K0olrEjtLLanic8V0y9icia6cvCVRCiabOm5llC0WhzcSWvaI2fia75hYbvjrQ/132","comment_is_top":false,"comment_ctime":1624894885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624894885","product_id":100037301,"comment_content":"老师你好，我这里有一个普遍的场景想要咨询一下转换的问题，<br>rpcRequest(rpc请求的入参实体) -&gt; 我需要将这个实体落库，那么必然要将request 转换为do ，再将do 转换为po<br>1. 如果每种操作都这么转换感觉会很麻烦，特别是po和do 比较复杂的情况。<br>2. 转换逻辑应该写在哪一层，我这边分别指的是rpcRequest 转do 和do 转po，以及在查询的场景下，我的po 转 do ,do在转rpcResponse 的时候。有必要封装一个类似xxxxConvert 的类去单独完成这些事情吗？","like_count":0},{"had_liked":false,"id":292406,"user_name":"川川","can_delete":false,"product_type":"c1","uid":1382517,"ip_address":"","ucode":"DA092CAC7F294D","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/75/68487e89.jpg","comment_is_top":false,"comment_ctime":1620808536,"is_pvip":false,"replies":[{"id":"105889","content":"可以根据场景和复杂度选择两种方式灵活并存的。复杂度高的尽量用BFF，前后端之间的一些工作需要放在BFF里面完成，比如鉴权。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1620827392,"ip_address":"","comment_id":292406,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1620808536","product_id":100037301,"comment_content":"老师你好，最近才看了你的书籍《中台架构设计与实现》，最近在项目设计中，有一个疑惑和同事争论了很久，麻烦老师你解答下？老师在书里面提到了项目级微服务和企业级微服务这两个概念，实际上我们一个项目里面这两种模式应该是共存的吧， 我的个人理解是这样的：比如说我有个中台， 然后划分为了提供各种能力的小中台，  如果要协调各个中台间的微服务直接的能力就需要使用BFF层； 但是针对具体某个小中台，特别是复杂度不是很高的中台，那么微服务之间的协调则可以直接通过某个核心微服务的应用层来编排其他微服务。  可能不光是例子中的一个大中台，包括在一个大型项目内， 有的子域比较复杂，有的比较简单， 复杂子域映射成微服务落地后，微服务之间的协作建议使用BFF层，但是简单子域映射成得微服务（比如说只有两个微服务），则可以直接实现服务之间的调用。我们在工作中经常听到服务要高内聚和低耦合，看了老师的课程和书籍后我理解的高内聚、低耦合指的是聚合要足够内聚，聚合之间不要直接依赖。<br>老师麻烦你解答下，这个也是我最近和同时在争论的一个点：企业级微服务（复杂度高的项目）服务间协助是否必须使用BFF层，还是刚才我说的两种模式的灵活使用共存。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519814,"discussion_content":"可以根据场景和复杂度选择两种方式灵活并存的。复杂度高的尽量用BFF，前后端之间的一些工作需要放在BFF里面完成，比如鉴权。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620827392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290549,"user_name":"long","can_delete":false,"product_type":"c1","uid":1348028,"ip_address":"","ucode":"7C64E9EECFFBA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/91/bc/2f338491.jpg","comment_is_top":false,"comment_ctime":1619613493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619613493","product_id":100037301,"comment_content":"我有一个困惑已久的问题，防腐层既然是防止外部对内部影响，将外部的转义成内部的。但是在命名如何避免重复。比如外部接口已经有个对象叫Day，内部再创建一个实体对象也叫Day，在命名上就重复了，选用其他的名字又可能不那么贴切，像这种问题如何解决？","like_count":0},{"had_liked":false,"id":287502,"user_name":"Keith","can_delete":false,"product_type":"c1","uid":1193337,"ip_address":"","ucode":"B40774090714D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","comment_is_top":false,"comment_ctime":1617980129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617980129","product_id":100037301,"comment_content":"依赖倒置后的四层架构中的请求传递方向是什么样的? 难道是从基础层开始?","like_count":0},{"had_liked":false,"id":280060,"user_name":"zzz","can_delete":false,"product_type":"c1","uid":2434267,"ip_address":"","ucode":"50803974B71C9B","user_header":"https://static001.geekbang.org/account/avatar/00/25/24/db/3f62deb6.jpg","comment_is_top":false,"comment_ctime":1614068165,"is_pvip":false,"replies":[{"id":"101752","content":"数据字典这种场景没有领域模型可言，所以直接通过应用层或领域层用传统的方法操作就可以了。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1614131799,"ip_address":"","comment_id":280060,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1614068165","product_id":100037301,"comment_content":"老师你好，请问像数据字典等，这种简单的增删改查，需要走Domain层吗？如果不需要，这类简单的增删改查代码应该写在哪一部分？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515971,"discussion_content":"数据字典这种场景没有领域模型可言，所以直接通过应用层或领域层用传统的方法操作就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614131799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2259036,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ibrdBibCAkPuSxQImpekPJtsiaow6Efn3dtib8BDmvfYAcqydiaNfBKI4gy8QLh12BsaPqibeOgXiaCtfyrPPOWTK6qibw/132","nickname":"Geek_005cde","note":"","ucode":"CF700A82D41F2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375616,"discussion_content":"可不可以把一些字典操作统一在应用层放置一个服务(CommonService)，所有字典操作都通过这个应用服务来调用呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621771668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277779,"user_name":"冬风向左吹","can_delete":false,"product_type":"c1","uid":1066928,"ip_address":"","ucode":"376C45C5134F93","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","comment_is_top":false,"comment_ctime":1612581299,"is_pvip":false,"replies":[{"id":"101032","content":"在DDD分层架构中有应用层，如果你的微服务内部不需要进行微服务内的服务组合和编排，直接将领域服务通过用户接口层暴露也可以。<br>领域层如果需要调用其他微服务或者其他聚合的服务，可以将这个调用上移到应用层的应用服务，通过应用服务来进行组合和编排。这样可以避免不同聚合之间产生依赖。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612851684,"ip_address":"","comment_id":277779,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1612581299","product_id":100037301,"comment_content":"每个微服务都有一个自己的应用层是吗, 微服务领域层的依赖其它服务的数据来源是通过应用层调用其它微服务的用户接口API来获取的是吗, 求解惑, 谢谢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515168,"discussion_content":"在DDD分层架构中有应用层，如果你的微服务内部不需要进行微服务内的服务组合和编排，直接将领域服务通过用户接口层暴露也可以。\n领域层如果需要调用其他微服务或者其他聚合的服务，可以将这个调用上移到应用层的应用服务，通过应用服务来进行组合和编排。这样可以避免不同聚合之间产生依赖。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612851684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543406,"discussion_content":"那不对呀 那不是用户接口层调用了领域服务吗？老师的意思是说如果不需要服务的组合和编排，就是去掉了应用层，直接应用层到领域服务层对吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641128863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":515168,"ip_address":""},"score":543406,"extra":""}]}]},{"had_liked":false,"id":277777,"user_name":"冬风向左吹","can_delete":false,"product_type":"c1","uid":1066928,"ip_address":"","ucode":"376C45C5134F93","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","comment_is_top":false,"comment_ctime":1612581070,"is_pvip":false,"replies":[{"id":"101033","content":"这个图的应用服务都是在同一个微服务内的。<br>如果分别在两个微服务中的话，一般通过API网关，然后经过用户接口层来调用领域服务。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612851868,"ip_address":"","comment_id":277777,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1612581070","product_id":100037301,"comment_content":"在&quot;微服务内服务的演进&quot;这段中, 上面的配图应用服务A, 应用服务B是两个微服务还是同一个微服务里有两个应用? 如果是两个微服务的话, 应用服务A可以不走用户接口层的API直接调用领域服务b吗, 没太理解这个图的架构是怎样的","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515167,"discussion_content":"这个图的应用服务都是在同一个微服务内的。\n如果分别在两个微服务中的话，一般通过API网关，然后经过用户接口层来调用领域服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612851868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543409,"discussion_content":"老师 为什么要走网关呢？老师你说的网关是指什么？不可以直接调用户接口层吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641129154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":515167,"ip_address":""},"score":543409,"extra":""}]}]},{"had_liked":false,"id":268635,"user_name":"有爱有波哥","can_delete":false,"product_type":"c1","uid":1464493,"ip_address":"","ucode":"DD9A023563151F","user_header":"https://static001.geekbang.org/account/avatar/00/16/58/ad/6abb57c4.jpg","comment_is_top":false,"comment_ctime":1608279820,"is_pvip":false,"replies":[{"id":"97484","content":"是的，这样也是为了通过冗余来解耦聚合。以后如果聚合需要拆分，值对象就不需要重新设计了。如果不同领域的值对象以后需要变化，也会相对容易。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608281024,"ip_address":"","comment_id":268635,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608279820","product_id":100037301,"comment_content":"老师请问你一下 ，假如值对象 ，在不同的领域都用到了，那没个领域都要需要写一遍值对象吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511994,"discussion_content":"是的，这样也是为了通过冗余来解耦聚合。以后如果聚合需要拆分，值对象就不需要重新设计了。如果不同领域的值对象以后需要变化，也会相对容易。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608281024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260148,"user_name":"好孩子","can_delete":false,"product_type":"c1","uid":1422749,"ip_address":"","ucode":"2C647B97141057","user_header":"https://static001.geekbang.org/account/avatar/00/15/b5/9d/88ff91ec.jpg","comment_is_top":false,"comment_ctime":1604931162,"is_pvip":false,"replies":[{"id":"94606","content":"我建议你分开放。主要考虑它们属于不同的领域，未来如果领域之间还需要拆分的话，这个枚举类型可能就会成为两个领域模型的耦合点。虽然复用不强，但是有利于领域模型之间解耦，以及这个枚举类型的独立。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605063083,"ip_address":"","comment_id":260148,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604931162","product_id":100037301,"comment_content":"老师好，请教下，如果两个领域都需要理解一个枚举类型，那这个枚举应该定义在哪里","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509120,"discussion_content":"我建议你分开放。主要考虑它们属于不同的领域，未来如果领域之间还需要拆分的话，这个枚举类型可能就会成为两个领域模型的耦合点。虽然复用不强，但是有利于领域模型之间解耦，以及这个枚举类型的独立。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605063083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258647,"user_name":"风","can_delete":false,"product_type":"c1","uid":1077538,"ip_address":"","ucode":"104638BF19B048","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/22/b8c596b6.jpg","comment_is_top":false,"comment_ctime":1604533343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604533343","product_id":100037301,"comment_content":"传统企业应用大多是单体架构，而单体架构则大多是三层架构。三层架构解决了程序内代码间调用复杂、代码职责不清的问题，但这种分层是逻辑概念，在物理上它是中心化的集中式架构，并不适合分布式微服务架构。","like_count":0},{"had_liked":false,"id":258643,"user_name":"风","can_delete":false,"product_type":"c1","uid":1077538,"ip_address":"","ucode":"104638BF19B048","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/22/b8c596b6.jpg","comment_is_top":false,"comment_ctime":1604533050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604533050","product_id":100037301,"comment_content":"架构根据耦合的紧密程度又可以分为两种：严格分层架构和松散分层架构。优化后的 DDD 分层架构模型就属于严格分层架构，任何层只能对位于其直接下方的层产生依赖。而传统的 DDD 分层架构则属于松散分层架构，它允许某层与其任意下方的层发生依赖。","like_count":0},{"had_liked":false,"id":258642,"user_name":"风","can_delete":false,"product_type":"c1","uid":1077538,"ip_address":"","ucode":"104638BF19B048","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/22/b8c596b6.jpg","comment_is_top":false,"comment_ctime":1604532957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604532957","product_id":100037301,"comment_content":"领域模型的业务逻辑主要是由实体和领域服务来实现的，其中实体会采用充血模型来实现所有与之相关的业务功能。实体和领域服务在实现业务逻辑上不是同级的，当领域中的某些功能，单一实体（或者值对象）不能实现时，领域服务就会出马，它可以组合聚合内的多个实体（或者值对象），实现复杂的业务逻辑。","like_count":0},{"had_liked":false,"id":243210,"user_name":"JKing","can_delete":false,"product_type":"c1","uid":1436774,"ip_address":"","ucode":"E0394EC5AC9446","user_header":"https://static001.geekbang.org/account/avatar/00/15/ec/66/57d5a1de.jpg","comment_is_top":false,"comment_ctime":1597993930,"is_pvip":false,"replies":[{"id":"89661","content":"对于小型项目可能就不需要BFF微服务，如果没有BFF微服务，跨微服务的服务的组合和编排可以放在应用层。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1598000462,"ip_address":"","comment_id":243210,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597993930","product_id":100037301,"comment_content":"“此外，应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排。”微服务之间的服务组合和编排不应该在BFF层吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504224,"discussion_content":"对于小型项目可能就不需要BFF微服务，如果没有BFF微服务，跨微服务的服务的组合和编排可以放在应用层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598000462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242484,"user_name":"好孩子","can_delete":false,"product_type":"c1","uid":1422749,"ip_address":"","ucode":"2C647B97141057","user_header":"https://static001.geekbang.org/account/avatar/00/15/b5/9d/88ff91ec.jpg","comment_is_top":false,"comment_ctime":1597739484,"is_pvip":false,"replies":[{"id":"89487","content":"应用层和领域层都可以。如果是不同聚合，放在应用层，如果是同一个聚合可以放在领域层。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597757414,"ip_address":"","comment_id":242484,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597739484","product_id":100037301,"comment_content":"老师，您好，想问下对于一些需要查询数据库的参数检验，比如，创建xx，但是如果已经存在n个xx了就不能创建，这种检验应该放在哪一层呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504017,"discussion_content":"应用层和领域层都可以。如果是不同聚合，放在应用层，如果是同一个聚合可以放在领域层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597757414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242247,"user_name":"Geek_7c4953","can_delete":false,"product_type":"c1","uid":1809168,"ip_address":"","ucode":"359745D4725D4F","user_header":"","comment_is_top":false,"comment_ctime":1597646899,"is_pvip":false,"replies":[{"id":"89425","content":"你可以在用户接口层将DTO转换为应用服务和领域服务所需的DO对象，在应用层以下以DO对象的形式传参，这样就会减少很多参数传递了。当然，要注意在应用服务中，如果涉及到跨聚合的数据操作，仍然需要以参数的方式来完成服务调用。在加餐里面的代码部分有示例，你可以参考一下。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597658459,"ip_address":"","comment_id":242247,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597646899","product_id":100037301,"comment_content":"对于服务的调用时数据的流转，接口DTO-&gt;应用服务方法参数-&gt;领域服务或实体方法参数。在实际实施中，在参数较多时，感觉重复得传递参数显得代码非常臃肿冗余。<br>举个例子像这样<br>&#47;&#47; 某个接口的DTO声明<br>XxxxApiDTO{<br>　field1，<br>　field2，<br>　field3，<br>　...<br>}<br>&#47;&#47; 该接口的调用处理方法<br>XxxApi(XxxxApiDTO dto){<br>　_xxxAppService.doSomeXxx(dto.field1,dto.field2,dto.field3,...);<br>}<br>&#47;&#47; 被调用的应用服务<br>xxxAppService{<br>　doSomeXxx(field1,field2,field3...){<br>　　_xxxDomainService.doSomeXxx(field1,field2,field3...);<br>　}<br>}<br>这里的...省略的可能是7 8甚至十来个参数。代码会变得非常难看，同时改动领域服务参数，上层的所有调用都要跟着修改，也非常麻烦。<br>所以，我考虑划分以领域服务以及实体方法为单位的DTO供上层使用。API接收DTO传递给应用服务，应用服务直接将整个DTO对象传递给领域服务，领域服务再拆解参数执行具体逻辑。<br>如果是多个领域服务组合调用的，就组合这些DTO。当改动领域服务参数时，只要改动DTO的字段，那么上层的参数也就跟着改变了。<br>我想知道这样做是否有什么坏处。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503958,"discussion_content":"你可以在用户接口层将DTO转换为应用服务和领域服务所需的DO对象，在应用层以下以DO对象的形式传参，这样就会减少很多参数传递了。当然，要注意在应用服务中，如果涉及到跨聚合的数据操作，仍然需要以参数的方式来完成服务调用。在加餐里面的代码部分有示例，你可以参考一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597658459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237904,"user_name":"极客","can_delete":false,"product_type":"c1","uid":1401837,"ip_address":"","ucode":"478628BE35AEE3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIG3L8ToibAiaHqWmMP9uuHpAhMJcScSwibpUW0IichAr2vsgymwsMWvVnwo8IH2OYdq62eMVpSM374iaQ/132","comment_is_top":false,"comment_ctime":1596001934,"is_pvip":false,"replies":[{"id":"88569","content":"我一般习惯将数据库处理逻辑类的仓储接口和实现都放在 领域层的聚合目录里面，这样考虑主要是为了方便以后微服务架构演进时聚合代码的拆分，因为一个聚合会有一个仓储，它们就是一个组合。<br>对于其他工具类的仓储接口和实现，建议你统一放在基础层，因为基础层是面向微服务的所有层提供服务，不会出现服务调用时层之间的依赖混乱。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1596674763,"ip_address":"","comment_id":237904,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1596001934","product_id":100037301,"comment_content":"有个问题请教下，“解耦各层对基础层依赖，采用依赖倒置的方式”，这句话，是具体的实现中，如果用到基础设施层的东西，是在interface、APP、domain层写接口？比如说一个uti方法也在上层写接口，基础实施层写实现？这样每增加一个工具类或者通用方法都得考虑增加一个实现，而且这个实现具体放在哪一个还得评估，毕竟放在APP层，domain层就无法使用了，那如果都放在domain层是不是domain会有很多冗余的代码。请老师答疑","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502588,"discussion_content":"我一般习惯将数据库处理逻辑类的仓储接口和实现都放在 领域层的聚合目录里面，这样考虑主要是为了方便以后微服务架构演进时聚合代码的拆分，因为一个聚合会有一个仓储，它们就是一个组合。\n对于其他工具类的仓储接口和实现，建议你统一放在基础层，因为基础层是面向微服务的所有层提供服务，不会出现服务调用时层之间的依赖混乱。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596674763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110437,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f1/a5/6cc9f728.jpg","nickname":"秋天的透明雨🌧️","note":"","ucode":"9363B49BFA6C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380914,"discussion_content":"&#34;对于其他工具类的仓储接口和实现，建议你统一放在基础层，因为基础层是面向微服务的所有层提供服务，不会出现服务调用时层之间的依赖混乱。&#34;,有个问题不知道理解的对不对？如果接口也放在基础层，那不有又变成其它层以来基础成了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624791571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437715,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f0/13/e5d0355a.jpg","nickname":"杨志远","note":"","ucode":"24F0BF091EDCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295208,"discussion_content":"感觉没必要吧，依赖倒置主要是指仓储的接口和实现分离，实现放在基础层，接口层放领域层，领域服务通过调仓储接口完成数据存取，接口为上层，这样在换数据库时，只需修改仓储实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596119294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233089,"user_name":"李圣悦","can_delete":false,"product_type":"c1","uid":1638427,"ip_address":"","ucode":"C1786C98824E50","user_header":"https://static001.geekbang.org/account/avatar/00/19/00/1b/eee13196.jpg","comment_is_top":false,"comment_ctime":1594214546,"is_pvip":false,"replies":[{"id":"86033","content":"是微服务内的分层，不好理解的话，你可以看看加餐里面的内容和代码。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1594261815,"ip_address":"","comment_id":233089,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594214546","product_id":100037301,"comment_content":"老师你好，这个分层是一个微服务内的分层还是包括多个微服务？没理解各个层跟微服务的关系","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500890,"discussion_content":"是微服务内的分层，不好理解的话，你可以看看加餐里面的内容和代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594261815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231518,"user_name":"yefei73","can_delete":false,"product_type":"c1","uid":1061416,"ip_address":"","ucode":"E5445452000B72","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/28/c663b7fc.jpg","comment_is_top":false,"comment_ctime":1593696495,"is_pvip":false,"replies":[{"id":"85484","content":"这四个层是在一个微服务内的。<br>用户接口层和应用层各自职责不一样，个人建议还是分开比较好，你可以根据项目情况来权衡。<br>用户接口层主要用于前台不同应用的适配，如果这个微服务只是面向一个前端应用，用户接口层可以根据情况来设计。而如果面向的前端很多，需要做不同的接口和数据适配，建议严格按照四层分层架构来设计。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593737099,"ip_address":"","comment_id":231518,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1593696495","product_id":100037301,"comment_content":"用户接口层、应用层、领域层、基础层，是部署在一个微服务里面吗？<br>用户接口层和应用层都很薄，是否可以合并在一起，不进行区分？<br>如果采用 TypeScript + NodeJS(Server) 技术体系进行大前端开发，那用户接口层和应用层是否基于 NodeJS 实现还是用户接口层基于 NodeJS 实现，应用层、领域层、基础层在一个微服务里面？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500331,"discussion_content":"这四个层是在一个微服务内的。\n用户接口层和应用层各自职责不一样，个人建议还是分开比较好，你可以根据项目情况来权衡。\n用户接口层主要用于前台不同应用的适配，如果这个微服务只是面向一个前端应用，用户接口层可以根据情况来设计。而如果面向的前端很多，需要做不同的接口和数据适配，建议严格按照四层分层架构来设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593737099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061416,"avatar":"https://static001.geekbang.org/account/avatar/00/10/32/28/c663b7fc.jpg","nickname":"yefei73","note":"","ucode":"E5445452000B72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288533,"discussion_content":"谢谢。如果面向前端很多，用户接口层的作用有一部分有点像 GraphQL 提供的功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593778440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230157,"user_name":"涛涛","can_delete":false,"product_type":"c1","uid":1180810,"ip_address":"","ucode":"747C4B1F20A2D3","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/8a/ff94bd60.jpg","comment_is_top":false,"comment_ctime":1593291086,"is_pvip":false,"replies":[{"id":"85217","content":"是的，数据库的处理逻辑都在仓储实现里面实现。领域层只面向数据的仓储接口，不关心仓储里面的具体实现。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593497663,"ip_address":"","comment_id":230157,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593291086","product_id":100037301,"comment_content":"老师您好，分库分表是不是放在仓储实现层了？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499788,"discussion_content":"是的，数据库的处理逻辑都在仓储实现里面实现。领域层只面向数据的仓储接口，不关心仓储里面的具体实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593497663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225481,"user_name":"枫zzzzz","can_delete":false,"product_type":"c1","uid":1370304,"ip_address":"","ucode":"0CD6F332407936","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLNgTWpN9vEUMZ77xTkiaPibX8E22c2L5GTmkgyP4cajbNiap5zEp28HicvA8eOCQqYo7YDsAhuafict2Q/132","comment_is_top":false,"comment_ctime":1591764204,"is_pvip":false,"replies":[{"id":"84664","content":"你说的service（interface接口）是面向前端应用提供的接口服务吧，如果是这个那应该对应用户接口层的Facade接口，Facade接口的主要业务逻辑的实现主要在应用服务中，其中应用服务会组合和编排领域服务来实现复杂的逻辑。这样比较的话，那impl就会对应应用服务。但是应用服务不同于impl，impl中一个服务会实现所有的业务逻辑，而应用服务有分层的概念，它只完成服务的编排和组合，主要核心逻辑是在领域层的领域服务中实现。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1592986602,"ip_address":"","comment_id":225481,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591764204","product_id":100037301,"comment_content":"传统的三层架构分为controller、service和dao三层，service层又分为service（interface接口）和impl(interface接口实现)，那在向DDD转型的时候，service和impl分别对应到哪一层呢？从那张图看不是很能理解清楚，望老师指点","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497861,"discussion_content":"你说的service（interface接口）是面向前端应用提供的接口服务吧，如果是这个那应该对应用户接口层的Facade接口，Facade接口的主要业务逻辑的实现主要在应用服务中，其中应用服务会组合和编排领域服务来实现复杂的逻辑。这样比较的话，那impl就会对应应用服务。但是应用服务不同于impl，impl中一个服务会实现所有的业务逻辑，而应用服务有分层的概念，它只完成服务的编排和组合，主要核心逻辑是在领域层的领域服务中实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592986602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223181,"user_name":"周卡卡","can_delete":false,"product_type":"c1","uid":1704302,"ip_address":"","ucode":"E34B7AEB6BDA84","user_header":"https://static001.geekbang.org/account/avatar/00/1a/01/6e/4775d90b.jpg","comment_is_top":false,"comment_ctime":1591016715,"is_pvip":false,"replies":[{"id":"82485","content":"领域服务也是属于聚合的，它与聚合根都可以完成多个实体的组合和编排，对于聚合内的业务规则，不管是在领域服务还是在聚合根中实现，都是需要按照业务规则进行控制的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591255872,"ip_address":"","comment_id":223181,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591016715","product_id":100037301,"comment_content":"领域层，多个实体共同完成的业务逻辑，在domainservice里实现，也就是领域服务里直接调用实体，绕过了聚合?这种情况如何保持数据一致，或者说实体的行为是必须通过聚合来调用还是可以直接暴露给domainservice","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497044,"discussion_content":"领域服务也是属于聚合的，它与聚合根都可以完成多个实体的组合和编排，对于聚合内的业务规则，不管是在领域服务还是在聚合根中实现，都是需要按照业务规则进行控制的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591255872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221122,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1590410527,"is_pvip":false,"replies":[{"id":"81572","content":"应用层的应用服务和领域层的领域服务要分开，领域服务会对充血模型的实体对象进行组合和编排，完成核心领域逻辑。应用服务主要面向用例和流程对领域服务进行组合和编排。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590453621,"ip_address":"","comment_id":221122,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590410527","product_id":100037301,"comment_content":"领域层就是充血模型的类，应用层就是使用充血模型的service层","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496342,"discussion_content":"应用层的应用服务和领域层的领域服务要分开，领域服务会对充血模型的实体对象进行组合和编排，完成核心领域逻辑。应用服务主要面向用例和流程对领域服务进行组合和编排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590453621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221056,"user_name":"jun","can_delete":false,"product_type":"c1","uid":1899314,"ip_address":"","ucode":"3A9633CA1FE72E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LalJD9ruYQI5zVM1GOCe4PjunIbbeeMiacFHC4TAj0DBVeialKt3vRCLs9dxn1vYXvfp8pgcyaeEQkh1nde1JoBQ/132","comment_is_top":false,"comment_ctime":1590393675,"is_pvip":false,"replies":[{"id":"81513","content":"应用层是服务组合和编排的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590398079,"ip_address":"","comment_id":221056,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590393675","product_id":100037301,"comment_content":"四层架构的应用层，是不是业务编排聚合层？如果不是，那么应用层只是一个透传好像没什么意义。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496314,"discussion_content":"应用层是服务组合和编排的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590398079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221013,"user_name":"jun","can_delete":false,"product_type":"c1","uid":1899314,"ip_address":"","ucode":"3A9633CA1FE72E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LalJD9ruYQI5zVM1GOCe4PjunIbbeeMiacFHC4TAj0DBVeialKt3vRCLs9dxn1vYXvfp8pgcyaeEQkh1nde1JoBQ/132","comment_is_top":false,"comment_ctime":1590379103,"is_pvip":false,"replies":[{"id":"81582","content":"在DDD中每一层都有具体的职责的。<br>用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口和数据适配相关的功能。<br>应用层：实现服务组合和编排，主要适应业务流程快速变化的需求。这一层聚集了应用服务和事件订阅相关的功能。<br>领域层：实现领域模型的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，它们协同和组合形成领域模型的核心业务能力。<br>基础层：它贯穿所有层，为各层提供基础资源服务。这一层聚集了各种底层资源相关的服务和能力。<br>业务逻辑从领域层、应用层到用户接口层逐层组合和封装，对外提供灵活的服务。既实现了各层的分工和解耦，又实现了各层的协作。<br>在微服务设计和开发时，应用层主要职能是服务的组合和编排，切记不要将本该在领域层的核心领域逻辑在应用层实现。这会使得领域模型失焦，时间一长应用层和领域层的边界就会变得混乱，边界清晰的四层架构慢慢可能就演变成了业务逻辑混杂的三层架构了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590454402,"ip_address":"","comment_id":221013,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590379103","product_id":100037301,"comment_content":"这句话有些疑问：在设计和开发时，不要将本该放在领域层的业务逻辑放到应用层中实现。除了基础服务是永久可复用的，各领域的通用业务也是可永久复用的，如果应用层有特殊需求则可以在应用层面具体实施，如果特殊需求放在领域层实施，领域层就会越来越乱的吧；<br><br>或者可以理解成针对不同应用的特殊业务，在同级的领域层在多出来一个聚合服务将特殊业务封装在聚合服务中由应用层调用？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496298,"discussion_content":"在DDD中每一层都有具体的职责的。\n用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口和数据适配相关的功能。\n应用层：实现服务组合和编排，主要适应业务流程快速变化的需求。这一层聚集了应用服务和事件订阅相关的功能。\n领域层：实现领域模型的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，它们协同和组合形成领域模型的核心业务能力。\n基础层：它贯穿所有层，为各层提供基础资源服务。这一层聚集了各种底层资源相关的服务和能力。\n业务逻辑从领域层、应用层到用户接口层逐层组合和封装，对外提供灵活的服务。既实现了各层的分工和解耦，又实现了各层的协作。\n在微服务设计和开发时，应用层主要职能是服务的组合和编排，切记不要将本该在领域层的核心领域逻辑在应用层实现。这会使得领域模型失焦，时间一长应用层和领域层的边界就会变得混乱，边界清晰的四层架构慢慢可能就演变成了业务逻辑混杂的三层架构了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590454402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220432,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590241083,"is_pvip":true,"replies":[{"id":"81574","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590453889,"ip_address":"","comment_id":220432,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590241083","product_id":100037301,"comment_content":"本质上依赖倒置对于有多种实现定制的场景是比较好的一个设计<br>如对于基础层这块我们可以定义资源访问标准SPI，这样在领域层通过SPI进行访问，然后实现可以有一个或多个，具体如何路由则由相应的业务场景决定","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496138,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590453889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543425,"discussion_content":"如果针对的是工具类，或者其它的外围比如 redis mq MongoDB 就不好使用依赖倒置来定义  老师有没有好点办法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641131997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":496138,"ip_address":""},"score":543425,"extra":""}]}]},{"had_liked":false,"id":220428,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590240958,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590240958","product_id":100037301,"comment_content":"电商场景<br>交易领域层会有订单领域对象，应用层会有订单状态变更领域事件<br>DDD架构本质上是结合了DDD的思路方法，将传统的三层架构增加了：应用层+领域层","like_count":0},{"had_liked":false,"id":218918,"user_name":"润！","can_delete":false,"product_type":"c1","uid":1237696,"ip_address":"","ucode":"13B7C23B5F6B24","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/c0/09cef977.jpg","comment_is_top":false,"comment_ctime":1589898500,"is_pvip":false,"replies":[{"id":"81088","content":"是的，微服务的代码构建和打包后是部署在一个服务器上运行的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590050621,"ip_address":"","comment_id":218918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589898500","product_id":100037301,"comment_content":"老师，我并不是很理解，微服务的代码是单独放置在一个服务器上的？菜鸡莫见怪","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495625,"discussion_content":"是的，微服务的代码构建和打包后是部署在一个服务器上运行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590050621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213420,"user_name":"Andy Wooh","can_delete":false,"product_type":"c1","uid":1363028,"ip_address":"","ucode":"767243883F23B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/cc/54/f8cdc6b9.jpg","comment_is_top":false,"comment_ctime":1588409968,"is_pvip":false,"replies":[{"id":"79536","content":"在微服务面向不同前端应用时，同样的一段业务逻辑，可能由于渠道不同，而在前端展示的页面要素不同，因此要求后端微服务返回的数据结果不同。比如在面向内部员工的PC端应用时，可能要求返回全部数据。而面向外部客户的移动端应用，可能只需要返回几个关键数据就可以了。<br>为了避免暴露微服务的核心业务逻辑，防止数据外泄，你不能将后端所有的数据，不加区分的传递给前端应用。你更不能仅仅因为前端应用不同的数据展示需求，而开发出多个不同的后端服务，面向前端应用提供不同的服务。<br>这时用户接口层的Facade服务和数据组装器Assembler就可以发挥作用了。Facade服务可以封装应用服务，数据组装器Assembler可以根据不同前端应用的数据需求，完成前端DTO和后端DO对象的组装和转换等操作。面向不同前端应用提供不同的Facade接口和DTO数据服务。这样，我们不需要调整任何后端服务，就可以面向不同的前端应用，提供灵活的接口定制和数据适配服务了。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588835949,"ip_address":"","comment_id":213420,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1588409968","product_id":100037301,"comment_content":"老师好！<br>文中提及：DDD 分层架构在用户接口层引入了 DTO，给前端提供了更多的可使用数据和更高的展示灵活性。请问这句话怎么理解呢？<br>目前我们公司的代码中，DTO用于biz层和service层之间的参数传递。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493775,"discussion_content":"在微服务面向不同前端应用时，同样的一段业务逻辑，可能由于渠道不同，而在前端展示的页面要素不同，因此要求后端微服务返回的数据结果不同。比如在面向内部员工的PC端应用时，可能要求返回全部数据。而面向外部客户的移动端应用，可能只需要返回几个关键数据就可以了。\n为了避免暴露微服务的核心业务逻辑，防止数据外泄，你不能将后端所有的数据，不加区分的传递给前端应用。你更不能仅仅因为前端应用不同的数据展示需求，而开发出多个不同的后端服务，面向前端应用提供不同的服务。\n这时用户接口层的Facade服务和数据组装器Assembler就可以发挥作用了。Facade服务可以封装应用服务，数据组装器Assembler可以根据不同前端应用的数据需求，完成前端DTO和后端DO对象的组装和转换等操作。面向不同前端应用提供不同的Facade接口和DTO数据服务。这样，我们不需要调整任何后端服务，就可以面向不同的前端应用，提供灵活的接口定制和数据适配服务了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588835949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543424,"discussion_content":"老师 我这里有个疑问？ 如果用户接口层接受的参数是一个DTO，返回的又是另外一个DTO，那么会不会出现非常多的DTO？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641131682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":493775,"ip_address":""},"score":543424,"extra":""}]},{"author":{"id":1363028,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cc/54/f8cdc6b9.jpg","nickname":"Andy Wooh","note":"","ucode":"767243883F23B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277699,"discussion_content":"谢谢老师的详尽回复。老师的意思DTO主要用于不同端的展示需求，但这样感觉和DTO（data transfer object）的命名有点不符合呢？难道对DTO的理解应该是在不同服务之间的数据传输对象吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591095195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211064,"user_name":"星星","can_delete":false,"product_type":"c1","uid":1699521,"ip_address":"","ucode":"827E194E50188C","user_header":"https://static001.geekbang.org/account/avatar/00/19/ee/c1/0053ee3e.jpg","comment_is_top":false,"comment_ctime":1587890276,"is_pvip":false,"replies":[{"id":"79543","content":"1、DCI现在用的似乎不太多，也比较复杂，就没有细讲了。<br>2、聚合根是聚合对外的联络人和接口人，聚合之间以聚合根ID关联的方式接受聚合的外部任务和请求，在限界上下文内实现聚合之间的业务协同，聚合外部对象不能直接访问聚合内的对象。<br>聚合根可以完成聚合内实体和值对象的构建，不过这部分功能也可以放到工厂里面实现。<br>你观察的很仔细。<br>聚合根类的方法可以组织这些领域对象，完成跨多个实体的复杂业务逻辑。但是，在聚合的领域服务中，也可以完成跨多个实体的复杂领域逻辑。<br>那跨多个实体的业务逻辑到底应该在聚合根还是在领域服务中实现呢？ <br>理论上，聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，只作为实体实现与聚合根自身行为相关的业务逻辑。而将跨多个实体的复杂领域逻辑放在领域服务中实现。简单聚合的跨实体领域逻辑，可以考虑在聚合根方法中实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588837545,"ip_address":"","comment_id":211064,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587890276","product_id":100037301,"comment_content":"老师你好！<br>看完分层架构有两个问题：<br>1 文章开头提到DCI五层架构，在后续文章中并未提及上下文环境层(Context)。<br>2 应用服务是跨领域对象(聚合根、领域服务)调用，领域服务是跨实体调用,领域服务与聚合根的区别是什么？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493185,"discussion_content":"1、DCI现在用的似乎不太多，也比较复杂，就没有细讲了。\n2、聚合根是聚合对外的联络人和接口人，聚合之间以聚合根ID关联的方式接受聚合的外部任务和请求，在限界上下文内实现聚合之间的业务协同，聚合外部对象不能直接访问聚合内的对象。\n聚合根可以完成聚合内实体和值对象的构建，不过这部分功能也可以放到工厂里面实现。\n你观察的很仔细。\n聚合根类的方法可以组织这些领域对象，完成跨多个实体的复杂业务逻辑。但是，在聚合的领域服务中，也可以完成跨多个实体的复杂领域逻辑。\n那跨多个实体的业务逻辑到底应该在聚合根还是在领域服务中实现呢？ \n理论上，聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，只作为实体实现与聚合根自身行为相关的业务逻辑。而将跨多个实体的复杂领域逻辑放在领域服务中实现。简单聚合的跨实体领域逻辑，可以考虑在聚合根方法中实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588837545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203074,"user_name":"fish","can_delete":false,"product_type":"c1","uid":1194551,"ip_address":"","ucode":"ABA0945C8B9615","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/37/06440c7f.jpg","comment_is_top":false,"comment_ctime":1586136571,"is_pvip":false,"replies":[{"id":"76065","content":"其实DDD跟语言无关，不过不同的开发语言可能配套的组件和工具不一样，在实践DDD的时候难易程度会有点差异。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586224012,"ip_address":"","comment_id":203074,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586136571","product_id":100037301,"comment_content":"看了好多评论都是java的么，有没有.net的来举手","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490753,"discussion_content":"其实DDD跟语言无关，不过不同的开发语言可能配套的组件和工具不一样，在实践DDD的时候难易程度会有点差异。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586224012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200045,"user_name":"james.d","can_delete":false,"product_type":"c1","uid":1087225,"ip_address":"","ucode":"CEE241856AF3B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/f9/3f976c91.jpg","comment_is_top":false,"comment_ctime":1585536743,"is_pvip":false,"replies":[{"id":"74916","content":"应用服务、领域服务和聚合根应该都是可以的。应用服务可以直接调repository，比如查询操作。具有领域逻辑的业务操作建议通过领域服务来操作。聚合的仓储逻辑一般是针对整个聚合的完整业务逻辑，尽量不要对单个实体的的表进行仓储操作。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585548767,"ip_address":"","comment_id":200045,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585536743","product_id":100037301,"comment_content":"欧老师，数据库的读写操作一般封装在repository中，谁负责（或可以）调用repository呢？应用服务，领域服务，实体等。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489928,"discussion_content":"应用服务、领域服务和聚合根应该都是可以的。应用服务可以直接调repository，比如查询操作。具有领域逻辑的业务操作建议通过领域服务来操作。聚合的仓储逻辑一般是针对整个聚合的完整业务逻辑，尽量不要对单个实体的的表进行仓储操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585548767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193715,"user_name":"水浴清风","can_delete":false,"product_type":"c1","uid":1133926,"ip_address":"","ucode":"36EF5179E6F952","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/66/28742ad4.jpg","comment_is_top":false,"comment_ctime":1584953233,"is_pvip":false,"replies":[{"id":"74340","content":"领域服务主要实现领域层聚合中涉及多实体的业务逻辑，应用服务主要协调聚合，并对领域服务或其他微服务的应用服务进行编排和组合。用户接口层主要面向前端，进行DO和DTO数据组装和适配，并对外发布服务，它后端的服务来源于应用层的应用服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585223912,"ip_address":"","comment_id":193715,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1584953233","product_id":100037301,"comment_content":"应用层 与 用户接口层区别是什么？应用服务 与 领域服务又有什么区别呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488633,"discussion_content":"领域服务主要实现领域层聚合中涉及多实体的业务逻辑，应用服务主要协调聚合，并对领域服务或其他微服务的应用服务进行编排和组合。用户接口层主要面向前端，进行DO和DTO数据组装和适配，并对外发布服务，它后端的服务来源于应用层的应用服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585223912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1081668,"avatar":"https://static001.geekbang.org/account/avatar/00/10/81/44/a6cd7f8c.jpg","nickname":"东坡先生","note":"","ucode":"CE3377B61C7A54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238161,"discussion_content":"领域服务组装了多个聚合操作，这些聚合属于同一个领域；应用服务则组装了本地的领域服务和其他领域的服务，故应用服务可能会调用其他微服务，而领域服务不会。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587213375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133926,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/66/28742ad4.jpg","nickname":"水浴清风","note":"","ucode":"36EF5179E6F952","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215985,"discussion_content":"感觉我对领域服务和应用服务分的还不是很清晰；领域服务里 也会调用其他微服务；聚合是一个虚的边界，聚合大部分会映射到聚合根，聚合根对应的业务领域模型，领域服务就已经对需要多个业务领域模型进行编排、组合了；为什么还需要应用服务呢，如果应用服务是对领域服务的组合编排的话，感觉这样可能好理解一些；领域服务的边界又是什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585401546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191867,"user_name":"何磊","can_delete":false,"product_type":"c1","uid":1047604,"ip_address":"","ucode":"78934C3ED4A342","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/34/c733b116.jpg","comment_is_top":false,"comment_ctime":1584801508,"is_pvip":false,"replies":[{"id":"73731","content":"第一个问题：是这样的。<br>第二个问题：应用层主要组合和编排微服务内的领域服务，如果是项目级应用，可以编排微服务之间的服务。如果是企业级项目，建议微服务之间的服务编排放到BFF。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584931284,"ip_address":"","comment_id":191867,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584801508","product_id":100037301,"comment_content":"老师请教几个问题<br>1. 文章中指出如果是微服务与微服务的调用，应该放在应用层；那这样一个场景：购物车微服务依赖商品微服务。在领域服务处理购物车数据时，需要商品的数据，这个商品数据应该从应用层传入，而不是领域服务直接调用商品微服务获取吗？<br>2. 应用层这一层很像是BFF层，这一层是否可以不用具体实现，而是有一个通用的编排层？比如网关层去做这个事情。<br>可能理解的不是很对，还希望老师指正！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488274,"discussion_content":"第一个问题：是这样的。\n第二个问题：应用层主要组合和编排微服务内的领域服务，如果是项目级应用，可以编排微服务之间的服务。如果是企业级项目，建议微服务之间的服务编排放到BFF。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584931284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190197,"user_name":"Geek_d38f30","can_delete":false,"product_type":"c1","uid":1512147,"ip_address":"","ucode":"955D6480731336","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ib1aca6ibMC3bcTZeVdTFalyyhdvy4DLQ7s4WBTWaw95k8IJNTUkZ5VwfB9rYwxVz3PAz4chBJhWcyMHib9KdEEnQ/132","comment_is_top":false,"comment_ctime":1584612887,"is_pvip":false,"replies":[{"id":"73175","content":"所以DDD里面有各种边界，在设计时要注意，尽量将变化往外层转移，避免对领域层的影响。<br>当然有一些复杂的关联查询，可以不通过领域层。直接用传统的方法查询或者用CQRS模式。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584615655,"ip_address":"","comment_id":190197,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584612887","product_id":100037301,"comment_content":"DDD每层只能与位于其下方的层发生耦合。只影响下层调用层，业务改动时，简单，影响范围小。<br>领域层界定业务边界，简化业务。后面遇到业务变了，就改当前聚合或者事件就好，不影响其他聚合。<br>业务分拆与合并也是同理。<br>之前我觉得仓储（Repository）设计模式麻烦，DBcontext不香吗，简单方便。但如果是复杂业务重构，就变的不可控，表之间大家互相调用，没边界。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487912,"discussion_content":"所以DDD里面有各种边界，在设计时要注意，尽量将变化往外层转移，避免对领域层的影响。\n当然有一些复杂的关联查询，可以不通过领域层。直接用传统的方法查询或者用CQRS模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584615655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182959,"user_name":"王宇","can_delete":false,"product_type":"c1","uid":1438475,"ip_address":"","ucode":"0E9BC3AD99C8E5","user_header":"https://static001.geekbang.org/account/avatar/00/15/f3/0b/4560079e.jpg","comment_is_top":false,"comment_ctime":1582897843,"is_pvip":true,"replies":[{"id":"70801","content":"你可以考虑在需要用户数据的微服务内建立一个冗余用户表，然后采用领域事件驱动的机制，当用户数据出现修改和新增时，将用户数据发送到所有冗余表。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582939855,"ip_address":"","comment_id":182959,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1582897843","product_id":100037301,"comment_content":"老师，我有个基础的疑问，不同微服务，用到同一个数据库的用户表，感觉用户被一堆服务依赖，不能实现一个领域一个微服务对应一个数据库？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485513,"discussion_content":"你可以考虑在需要用户数据的微服务内建立一个冗余用户表，然后采用领域事件驱动的机制，当用户数据出现修改和新增时，将用户数据发送到所有冗余表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582939855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438475,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/0b/4560079e.jpg","nickname":"王宇","note":"","ucode":"0E9BC3AD99C8E5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191378,"discussion_content":"也是个办法，还有其他的处理方式吗？这样有10个微服务就有10个冗余表，这样好处就是微服务话独立起来，坏处就是太多冗余表了，还涉及到同步，数据一致性要求太高就不好办了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582991230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180188,"user_name":"刘强","can_delete":false,"product_type":"c1","uid":1816623,"ip_address":"","ucode":"3640B6AAD21D23","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b8/2f/5b039bef.jpg","comment_is_top":false,"comment_ctime":1582207334,"is_pvip":false,"replies":[{"id":"70006","content":"在DDD的分层架构里，调用顺序是这样的：最早接收到请求的是用户接口层，然后调用应用层的应用服务，应用服务在组合和编排时再调领域层的领域服务。<br>你说的controller感觉应该在用户接口层。<br>建议你在设计时还是参考我上面说的调用顺序，这种设计在解耦和保持领域业务逻辑的稳定性上还是有很好的作用的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582247753,"ip_address":"","comment_id":180188,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1582207334","product_id":100037301,"comment_content":"老师，您好，我在设计微服务中最前端是网关，负责分发请求，限流。请求分发到不同的微服务中，也就是领域层。<br>1.我在领域层中有controller和service，这个controller在这里是否有问题<br>2.我如果没有服务编排，重组，网关直接分发到领域层，是否有问题。<br>谢谢老师！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484558,"discussion_content":"在DDD的分层架构里，调用顺序是这样的：最早接收到请求的是用户接口层，然后调用应用层的应用服务，应用服务在组合和编排时再调领域层的领域服务。\n你说的controller感觉应该在用户接口层。\n建议你在设计时还是参考我上面说的调用顺序，这种设计在解耦和保持领域业务逻辑的稳定性上还是有很好的作用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582247753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1816623,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/b8/2f/5b039bef.jpg","nickname":"刘强","note":"","ucode":"3640B6AAD21D23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179787,"discussion_content":"谢谢老师，每个微服务都要抽一个用户接口层，还是整个平台弄一个用户接口层？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582253030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175380,"user_name":"Shen","can_delete":false,"product_type":"c1","uid":1182167,"ip_address":"","ucode":"CFF7609A754392","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","comment_is_top":false,"comment_ctime":1580699957,"is_pvip":false,"replies":[{"id":"69003","content":"建议你看一下加餐：基于DDD的微服务设计实例代码详解第2节。里面有详细介绍和代码。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581495846,"ip_address":"","comment_id":175380,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580699957","product_id":100037301,"comment_content":"看了几遍，还是不太理解依赖倒置","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482709,"discussion_content":"建议你看一下加餐：基于DDD的微服务设计实例代码详解第2节。里面有详细介绍和代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581495846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159661,"discussion_content":"原本层A依赖层B，现在层A提供接口，让层B实现，根据具体（实现）依赖抽象（接口）的原则，依赖就倒置了，层B就依赖层A了。\n放在文中的话，原来领域层中的仓储依赖基础设施层，现在将仓储接口留领域层，仓储实现放基础设施层，于是就变成基础设施层依赖领域层了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580721821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175101,"user_name":"莫离","can_delete":false,"product_type":"c1","uid":1099426,"ip_address":"","ucode":"DB820A7284CC36","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/a2/11c99f7f.jpg","comment_is_top":false,"comment_ctime":1580558337,"is_pvip":false,"replies":[{"id":"68010","content":"是的，应用层的应用服务会调用其它微服务发布到API网关的服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1580566540,"ip_address":"","comment_id":175101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580558337","product_id":100037301,"comment_content":"以前的rpc调用是不是就放到应用服务里面来了，那在这里还叫rpc吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482623,"discussion_content":"是的，应用层的应用服务会调用其它微服务发布到API网关的服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580566540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174571,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1580281743,"is_pvip":false,"replies":[{"id":"68002","content":"外部facade接口调用在应用层，获取到数据后再调自己的领域服务。包括这些条件判断和规则获取都在应用层去做。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1580547771,"ip_address":"","comment_id":174571,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580281743","product_id":100037301,"comment_content":"你好。老师。有个问题想请教下。一些领域实体行为的执行每次是需要实时请求才可以得到结果。如果是这样那么在领域层难道要调用另外的应用facade接口？感觉这样好奇怪？还是说领域层自己包一个接口。实现放在别的层。采用依赖倒置？<br>比如你之前说的例子 投保。一个人是否可以投保肯定有一些规则。需要所有规则都过 ，才可以投保。比如规则有 用户征信良好，可用金额大于投保金额。这个时候规则属于领域中的值对象。规则过不过是这个值对象的一个行为。这个时候每次调用规则时。征信好不好 这个结果 和可用额度这个结果 是上层应用层传下来还是 值对象中去调用外围的facade？这里规则这块投保业务的不同可能过的规则也不同。是属于一个策略。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482447,"discussion_content":"外部facade接口调用在应用层，获取到数据后再调自己的领域服务。包括这些条件判断和规则获取都在应用层去做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580547771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792214,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","nickname":"Geek_35cfdd","note":"","ucode":"AD9615ABB4CA25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158079,"discussion_content":"如果把规则的获取和规则判断放在应用层就感觉有点奇怪。应用层按理说不应该涉及业务相关的东西而只是控制流程的。而规则和规则能不能过都是投保业务本身的业务逻辑。这些不应该受收在投保规则这个值对象里面做吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580548970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173952,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1579825234,"is_pvip":false,"replies":[{"id":"67672","content":"是的，领域层以外主要是编排、组合和适配。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579862840,"ip_address":"","comment_id":173952,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579825234","product_id":100037301,"comment_content":"感觉领域层就接近业务中台了","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482254,"discussion_content":"是的，领域层以外主要是编排、组合和适配。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579862840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172811,"user_name":"Tommy","can_delete":false,"product_type":"c1","uid":1092893,"ip_address":"","ucode":"4A3C9C4720799A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIGoUQicibTtscELH4GLlA9NMWCHWceib3sg8lZqEhh2vHnhcicm7qiaklJGCP98zHQ9ibnaaicTVYbRsHWQ/132","comment_is_top":false,"comment_ctime":1579319964,"is_pvip":false,"replies":[{"id":"67070","content":"这种仓储主要是用在数据处理，这种循环依赖应该很少见。在设计时，如果有循环依赖应该尽量避免出现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579397176,"ip_address":"","comment_id":172811,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579319964","product_id":100037301,"comment_content":"老师，你说将仓储的接口定义在领域层，实现放在基础层，这样会不会产生循环依赖呢？基础层需要依赖领域层的接口去实现，领域层又需要依赖基础层的一些工具类，还请问老师有啥好的方法解决吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481862,"discussion_content":"这种仓储主要是用在数据处理，这种循环依赖应该很少见。在设计时，如果有循环依赖应该尽量避免出现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579397176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169929,"user_name":"胡鹏","can_delete":false,"product_type":"c1","uid":1326455,"ip_address":"","ucode":"52644EC57FA4DB","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/77/45e5e06d.jpg","comment_is_top":false,"comment_ctime":1578475019,"is_pvip":false,"replies":[{"id":"65916","content":"编排就不要算了吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578477957,"ip_address":"","comment_id":169929,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578475019","product_id":100037301,"comment_content":"原文:  但应用层又位于领域层之上，因为领域层包含多个聚合，所以它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作       假如应用层一个方法, 编排了聚合a的A操作和b的B操作,且A操作和B操作有先后顺序,    这样算不算应用层里面编写了业务规则呢?  ","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480776,"discussion_content":"编排就不要算了吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578477957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167069,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1577684138,"is_pvip":false,"replies":[{"id":"64895","content":"应用层主要是应用服务。应用服务会封装哪些领域服务？还有领域事件等等。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577688819,"ip_address":"","comment_id":167069,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577684138","product_id":100037301,"comment_content":"有一点不太理解，课后思考中提到“应用层有哪些领域对象”，应用层不是应该调用领域层的领域服务吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479732,"discussion_content":"应用层主要是应用服务。应用服务会封装哪些领域服务？还有领域事件等等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577688819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166839,"user_name":"吴建中","can_delete":false,"product_type":"c1","uid":1090512,"ip_address":"","ucode":"4C6D46E5EC17CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/d0/882b5388.jpg","comment_is_top":false,"comment_ctime":1577610873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577610873","product_id":100037301,"comment_content":"从传统架构到DDD的四层架构演变的过程，可以看到一切都在围绕如何让领域层更稳定，比如剥离应用服务，比如使用仓储模式，让依赖反转，比如对聚合的访问通过聚合根。按照面向对象思想对象是对现实的映射，领域模型更是如此，更强调业务与代码的一致性，领域边界（限界上下文）就是微服务的边界，这一切都在告诉我们，领域是企业的核心，是相对稳定的，我们要建立与之对应的稳定模型，同时又要具有快速响应领域变化而调整代码层面领域层的能力。分层，职责划分，依赖倒置，都是为了让变化发生时改到成本小，响应更迅速。","like_count":0},{"had_liked":false,"id":164928,"user_name":"allen","can_delete":false,"product_type":"c1","uid":1429382,"ip_address":"","ucode":"04F8FE4245E505","user_header":"https://static001.geekbang.org/account/avatar/00/15/cf/86/886d7ad3.jpg","comment_is_top":false,"comment_ctime":1577113069,"is_pvip":false,"replies":[{"id":"62855","content":"实体的行为在实体类的方法里定义。我在准备一个完整的代码示例，过一段时间就会发出来。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577141907,"ip_address":"","comment_id":164928,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577113069","product_id":100037301,"comment_content":"老师，现在都在讲充血模型，即实体要有行为，那这个行为在哪里定义呢？原来的PO是失血的，只是数据库字段与java pojo之间的映射关系，看了很多书，说是要让PO有可以执行的方法，或者增加一个DO，DO与PO之间互相转换，但没有真实见到过这类代码。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478953,"discussion_content":"实体的行为在实体类的方法里定义。我在准备一个完整的代码示例，过一段时间就会发出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577141907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163862,"user_name":"james.d","can_delete":false,"product_type":"c1","uid":1087225,"ip_address":"","ucode":"CEE241856AF3B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/f9/3f976c91.jpg","comment_is_top":false,"comment_ctime":1576812600,"is_pvip":false,"replies":[{"id":"62317","content":"领域服务是聚合内部的。它主要实现多个实体组合出来的能力。单个实体的功能在实体方法里实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576821044,"ip_address":"","comment_id":163862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576812600","product_id":100037301,"comment_content":"领域服务应该是在聚合之上的，可以跨多个聚合。如果领域服务在聚合内部，跟实体，值对象等的职责有什么区别呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478562,"discussion_content":"领域服务是聚合内部的。它主要实现多个实体组合出来的能力。单个实体的功能在实体方法里实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576821044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161977,"user_name":"silentyears","can_delete":false,"product_type":"c1","uid":1061748,"ip_address":"","ucode":"6E137BFEB874CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/74/d9d143fa.jpg","comment_is_top":false,"comment_ctime":1576420614,"is_pvip":true,"replies":[{"id":"61750","content":"表示部分持久化的功能被提取为公共的面向切面聚合方法来实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576495466,"ip_address":"","comment_id":161977,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576420614","product_id":100037301,"comment_content":"请问老师，Repository AOP指的是什么？<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477935,"discussion_content":"表示部分持久化的功能被提取为公共的面向切面聚合方法来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576495466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160624,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1575988516,"is_pvip":false,"replies":[{"id":"61309","content":"不一定呢。应用服务可以对多个领域服务组合和编排。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576024140,"ip_address":"","comment_id":160624,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575988516","product_id":100037301,"comment_content":"一般来说，一个领域服务就会对应有一个应用服务吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477435,"discussion_content":"不一定呢。应用服务可以对多个领域服务组合和编排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576024140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157940,"user_name":"OTM","can_delete":false,"product_type":"c1","uid":1074017,"ip_address":"","ucode":"D96E9A661F122B","user_header":"https://static001.geekbang.org/account/avatar/00/10/63/61/d259f7a9.jpg","comment_is_top":false,"comment_ctime":1575287235,"is_pvip":false,"replies":[{"id":"60559","content":"你可以看下第16节。里面有详细讲解。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575326425,"ip_address":"","comment_id":157940,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575287235","product_id":100037301,"comment_content":"理解如下，不知是否正确：<br>1、用户接口层： Dto 入参、 VO 出参，主要是数据的转发<br>2、应用层： 接受Dto 入参，进行Dto 转为DO ； 同时接受领域层返回的DO 进行组装返回VO<br>3、领域层： DO 对象，把DO 对象转发为对应PO ，再返回对应DO 对象<br>4、基础层： PO 对象进行持久化操作","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476586,"discussion_content":"你可以看下第16节。里面有详细讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575326425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88949,"discussion_content":"do是领域层的对象,po是基础层的对象, 如果按照上层不依赖下层的原则,感觉 do转 po应该放在基础层做呢.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576742023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156615,"user_name":"Geek_4660f3","can_delete":false,"product_type":"c1","uid":1757482,"ip_address":"","ucode":"8B59B0C29EF88A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIMFaaIb1ZyU6zuYrT2WlD4RrsV2orxLonpIFwsx3ic01OLJ0N4dnSXQ3mFQxnbemiabKDw9810rX4Q/132","comment_is_top":false,"comment_ctime":1574923665,"is_pvip":false,"replies":[{"id":"60124","content":"区别不大。我主要考虑的是，如果以后微服务之间的聚合需要重新组装的话，直接将代码目录一并复制，就可以将一个聚合打包带走了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574925996,"ip_address":"","comment_id":156615,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574923665","product_id":100037301,"comment_content":"为啥把仓库的接口放在领域层，直接把接口放在基础层，领域层引用感觉没什么区别吧","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476170,"discussion_content":"区别不大。我主要考虑的是，如果以后微服务之间的聚合需要重新组装的话，直接将代码目录一并复制，就可以将一个聚合打包带走了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574925996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757482,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIMFaaIb1ZyU6zuYrT2WlD4RrsV2orxLonpIFwsx3ic01OLJ0N4dnSXQ3mFQxnbemiabKDw9810rX4Q/132","nickname":"Geek_4660f3","note":"","ucode":"8B59B0C29EF88A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64013,"discussion_content":"老师您好！\n我还有几个疑问：\n1、领域层和基础层的关系和传统三层架构中service和dao的区别在哪里，感觉没什么区别\n2、领域层和基础层的依赖倒置是不是就是通过增加仓库接口来实现的，让领域层依赖仓库接口和基础层对仓库接口依赖并且实现接口。具体跟仓库接口放在什么位置无关\n3、仓库接口放在领域层方便一起打包带走，但是仓库具体的实现在基础层，领域层打包带走那仓库具体实现咋办\n4、微服务拆分的时候领域层跟基础层一般是放在一个工程下面的么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574930400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156309,"user_name":"王小帅","can_delete":false,"product_type":"c1","uid":1717896,"ip_address":"","ucode":"8B6C6792F01A12","user_header":"https://static001.geekbang.org/account/avatar/00/1a/36/88/c738733e.jpg","comment_is_top":false,"comment_ctime":1574854083,"is_pvip":false,"replies":[{"id":"60117","content":"可能需要区分一下哈。基础层有数据库、API网关等。这类资源是独立于微服务部署的。但是它有驱动或者仓储服务，这部分内容是以jar包的形式跟微服务一起部署的。<br>可能还会有以纯jar包形式存在的第三方工具包之类，比如ShardingSphere等。<br>基础层的资源类型太多，可能需要分类别具体情况具体分析。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574924287,"ip_address":"","comment_id":156309,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574854083","product_id":100037301,"comment_content":"貌似对基础层理解有误区，烦请老师帮忙解答下：<br>基础层是在每个微服务工程中，而不是以jar包的形式供所有微服务使用？<br>如果基础层是在每个微服务工程中，那基础层中的公共的资源不是重复使用了吗？<br>如果是以jar包的形式供所有微服务使用，仓储的接口又在各个微服务的领域层，就会出现循环依赖问题吧？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476064,"discussion_content":"可能需要区分一下哈。基础层有数据库、API网关等。这类资源是独立于微服务部署的。但是它有驱动或者仓储服务，这部分内容是以jar包的形式跟微服务一起部署的。\n可能还会有以纯jar包形式存在的第三方工具包之类，比如ShardingSphere等。\n基础层的资源类型太多，可能需要分类别具体情况具体分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574924287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156064,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1574816667,"is_pvip":false,"replies":[{"id":"59953","content":"是的。当然，如果要其它聚合实体，可以通过应用服务来做。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574823110,"ip_address":"","comment_id":156064,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574816667","product_id":100037301,"comment_content":"领域服务封装多个实体的方法，这多个实体的都是同一个聚合的","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475972,"discussion_content":"是的。当然，如果要其它聚合实体，可以通过应用服务来做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574823110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62252,"discussion_content":"如果应用层的话，那就会出现调用其他聚合的实体方法，就不是严格分层架构了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574827672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155987,"user_name":"王小帅","can_delete":false,"product_type":"c1","uid":1717896,"ip_address":"","ucode":"8B6C6792F01A12","user_header":"https://static001.geekbang.org/account/avatar/00/1a/36/88/c738733e.jpg","comment_is_top":false,"comment_ctime":1574790048,"is_pvip":false,"replies":[{"id":"60007","content":"你说的这种情况，两种基础层的资源是不一样的。第一种主要是数据库类的基础资源。第二种你说的应该是属于工具类资源，两者之间不会出现循环依赖的。而且工具类资源如果也是通过仓储服务来访问的话，领域层和基础层是可以解耦的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574845295,"ip_address":"","comment_id":155987,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574790048","product_id":100037301,"comment_content":"老师，领域层和基础层依赖关系是怎样的？有点不太理解。<br>基础层需要依赖DO、仓储接口，而这些在领域层，所以基础层依赖领域层？<br>领域层又需要依赖基础层的工具类等公用组件，这不出现循环依赖了吗？<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475946,"discussion_content":"你说的这种情况，两种基础层的资源是不一样的。第一种主要是数据库类的基础资源。第二种你说的应该是属于工具类资源，两者之间不会出现循环依赖的。而且工具类资源如果也是通过仓储服务来访问的话，领域层和基础层是可以解耦的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574845295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154955,"user_name":"krugle","can_delete":false,"product_type":"c1","uid":1045770,"ip_address":"","ucode":"60A7D9189C01BE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/0a/077b9922.jpg","comment_is_top":false,"comment_ctime":1574604806,"is_pvip":false,"replies":[{"id":"59516","content":"API网关属于基础层的组件。它支持应用层应用服务的调用和服务发布。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574651338,"ip_address":"","comment_id":154955,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574604806","product_id":100037301,"comment_content":"应用层和api网关怎么理解 为什么这里没提到api网关","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475622,"discussion_content":"API网关属于基础层的组件。它支持应用层应用服务的调用和服务发布。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574651338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543426,"discussion_content":"原来是说的是服务的注册和发现呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641132489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":475622,"ip_address":""},"score":543426,"extra":""}]}]},{"had_liked":false,"id":154486,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1574444684,"is_pvip":false,"replies":[{"id":"59320","content":"依赖倒置主要是数据库。其它内容可以灵活对待，主要看成本和代价是否合适。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574496891,"ip_address":"","comment_id":154486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574444684","product_id":100037301,"comment_content":"老师，如果领域层或应用层要用到第三方框架，而第三方框架是属于基础层吧，那这样引用第三方的类为了符合依赖倒置都要像仓库那样在领域层或应用层定义接口吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475485,"discussion_content":"依赖倒置主要是数据库。其它内容可以灵活对待，主要看成本和代价是否合适。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574496891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152451,"user_name":"daemon","can_delete":false,"product_type":"c1","uid":1048693,"ip_address":"","ucode":"295A5BEAAB6E0F","user_header":"https://static001.geekbang.org/account/avatar/00/10/00/75/f2377792.jpg","comment_is_top":false,"comment_ctime":1574004588,"is_pvip":false,"replies":[{"id":"58600","content":"在答疑那一节会有说明和介绍。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574039884,"ip_address":"","comment_id":152451,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574004588","product_id":100037301,"comment_content":"希望老师能分享下六边形架构下的依赖倒置相关的思考","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474821,"discussion_content":"在答疑那一节会有说明和介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574039884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151824,"user_name":"若水","can_delete":false,"product_type":"c1","uid":1303418,"ip_address":"","ucode":"575F2A2F579B0B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKeqZb7U4s6SZHXz1Vv2u8iaHibZeZ9Ndgibr2nT9BS6Z4wiao3j8Ya5O8FK1SnxxyagDjvsMYaauWficA/132","comment_is_top":false,"comment_ctime":1573797097,"is_pvip":false,"replies":[{"id":"58507","content":"包括的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573907223,"ip_address":"","comment_id":151824,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1573797097","product_id":100037301,"comment_content":"老师您好，网关在基础层，这里的网关包括spring cloud 里面的API gateway吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474626,"discussion_content":"包括的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573907223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543436,"discussion_content":"网关不是在用户接口层上面吗？这里说的网关是其它服务暴露出来的网关吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641134495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":474626,"ip_address":""},"score":543436,"extra":""}]},{"author":{"id":1303418,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKeqZb7U4s6SZHXz1Vv2u8iaHibZeZ9Ndgibr2nT9BS6Z4wiao3j8Ya5O8FK1SnxxyagDjvsMYaauWficA/132","nickname":"若水","note":"","ucode":"575F2A2F579B0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52710,"discussion_content":"老师，实际使用的过程中APIgateway  是controller 层只上。APIgate 一般情况下又会调用  service 这样是不是就不符合，上层调用下层的原则呢，这种情况怎么理解呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574080225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148091,"user_name":"星一","can_delete":false,"product_type":"c1","uid":1103829,"ip_address":"","ucode":"EF550131FAE1BF","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/d5/6fbf1070.jpg","comment_is_top":false,"comment_ctime":1572940001,"is_pvip":false,"replies":[{"id":"57076","content":"一个聚合一个仓储，仓储跟着聚合一起迁移。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572953496,"ip_address":"","comment_id":148091,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572940001","product_id":100037301,"comment_content":"老师您好，有个疑问，当聚合需要迁移到另一个微服务时，在这个新的微服务里没有对应的下层仓储接口怎么办？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473393,"discussion_content":"一个聚合一个仓储，仓储跟着聚合一起迁移。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572953496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147988,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1572925153,"is_pvip":false,"replies":[{"id":"57012","content":"应用层可以用do也可以用Dto，这一层面向不同的层交互，比较复杂，按场景来选择吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572930482,"ip_address":"","comment_id":147988,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572925153","product_id":100037301,"comment_content":"应用层我觉得也可以用DTO","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473362,"discussion_content":"应用层可以用do也可以用Dto，这一层面向不同的层交互，比较复杂，按场景来选择吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572930482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147610,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572872959,"is_pvip":false,"replies":[{"id":"56925","content":"依赖倒置后基础层就通过仓储接口获取外部参数了，然后根据这些业务参数完成基础逻辑的实现，这个实现是在基础层。不采用依赖倒置的传统四层架构，基础层和业务逻辑实现可能会在应用层或领域层，两者逻辑混杂，不利于解耦。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572876401,"ip_address":"","comment_id":147610,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572872959","product_id":100037301,"comment_content":"“基础层是被其它层依赖的，它位于最核心的位置，那按照分层架构的思想，它应该就是核心，但实际上领域层才是软件的核心，所以这种依赖是有问题的。后来我们采用了依赖倒置”<br><br>基础层的箭头指向不是很理解。和传统四层区别在哪里？有没有一个例子说明下传统四层如何使用基础层，改进后的四层如何使用基础层","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473275,"discussion_content":"依赖倒置后基础层就通过仓储接口获取外部参数了，然后根据这些业务参数完成基础逻辑的实现，这个实现是在基础层。不采用依赖倒置的传统四层架构，基础层和业务逻辑实现可能会在应用层或领域层，两者逻辑混杂，不利于解耦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572876401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147599,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572872289,"is_pvip":false,"replies":[{"id":"56919","content":"基本差不多了。<br>DTO在用户接口层也有。<br>应用层主要处理微服务之间的转换，用户接口层主要处理前后端之间的数据转换。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572872688,"ip_address":"","comment_id":147599,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572872289","product_id":100037301,"comment_content":"领域层：值对象、实体、聚合根、领域服务、仓储接口<br>应用层：应用服务、领域事件、Dto<br>老师对吗？或者还差哪些？<br>Dto可不可以放在应用层，如果不放在应用层 ，应用层 返回用户接口层的是什么？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473271,"discussion_content":"基本差不多了。\nDTO在用户接口层也有。\n应用层主要处理微服务之间的转换，用户接口层主要处理前后端之间的数据转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572872688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147179,"user_name":"Geek_a91670","can_delete":false,"product_type":"c1","uid":1705156,"ip_address":"","ucode":"6CAA9FF890F8EA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/04/c4/ef4bd241.jpg","comment_is_top":false,"comment_ctime":1572833025,"is_pvip":false,"replies":[{"id":"56863","content":"聚合之间的协调需要应用服务出马。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572836963,"ip_address":"","comment_id":147179,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572833025","product_id":100037301,"comment_content":"老师:&quot;单一实体（或者值对象）不能实现时，领域服务就会出马...&quot;<br>这种情况下,在聚合内协调各个实体是不是也可以呢?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473181,"discussion_content":"聚合之间的协调需要应用服务出马。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572836963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146981,"user_name":"lightSky","can_delete":false,"product_type":"c1","uid":1018749,"ip_address":"","ucode":"5801C2DF8ABEC5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/7d/6432b435.jpg","comment_is_top":false,"comment_ctime":1572750786,"is_pvip":false,"replies":[{"id":"56786","content":"个人认为啊，把基础层放最上面说明不了问题，也许只是为了展示方便哈。<br>各层的依赖关系是通过依赖的箭头来体现的。基础层是为各层提供服务的，比如数据方面的是数据库、文件系统或者缓存组件等，API网关则是为用户接口层提供服务，还有比如总线之类的。<br>其它层是通过基础组件的接口来访问基础层的。基础组件实现自己的逻辑，对外提供接口，它的内部逻辑是在自己的实现方法里实现的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572786728,"ip_address":"","comment_id":146981,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572750786","product_id":100037301,"comment_content":"同问，关于依赖倒置这一块不是很好理解，前段时间学习了《实现领域驱动设计》，也看到了传统分层到依赖倒置的新分层的演进，但具体是怎么演进的没看明白。<br><br>首先说下分层中的基础层，在《实现领域驱动设计》对应的应该是基础设施层，而且基础设施层不仅仅是基础的工具，通用的库，还应该对领域层的接口进行实现。<br><br>首先说明下文章中的推导：<br>传统分层中，基础层属于最底层，所以它是核心层，而DDD中，领域层才是核心，所以为了打破核心，所以引入了依赖倒置，从而有了新的分层架构。<br><br>我的理解：<br>1、关于核心<br>分层的原则是通过依赖关系，放在最底层只能说明这一层是基础层，是实现上层能力的基础，并不能说明它就是核心。<br><br>2、关于依赖倒置<br>依赖倒置是传统分层到新的分层的核心因素，这点我是认同的。<br>我也赞同小毅的观点“领域层是通过仓储接口获取基础资源的数据对象，其实这和传统的三层模型没啥区别~”，因为分层的原则本身就要求依赖倒置的<br><br>3、我的推导<br>在DDD中，基础设施是可以用于实现领域层的接口的，那么一定就会依赖领域层的实体或者值对象，那么这种就产生了倒置依赖，而领域层又是核心层，所以为了适配它，所以基础层可以去依赖领域层，但是引入了依赖倒置，去实现领域层的接口，所以在新的分层中，基础层不在最底层了，在《实现领域驱动设计》中更是把基础层放到了最上层，它也可以用于实现其它层，比如应用层和用户接口层的接口（个人对这块不是很赞同，基础层不太应该去实现应用层和用户接口层的接口吧，但是从依赖倒置来看，基础层采用依赖倒置，相当于是独立的，所以把它放在最上层是能说的通的）。<br><br>推论的关键点：基础层会引用领域层的对象，而在DDD中，因为领域层是核心，所以不合适，其他层需要去适配它<br><br>不知道理解的对不对，希望老师解惑<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473086,"discussion_content":"个人认为啊，把基础层放最上面说明不了问题，也许只是为了展示方便哈。\n各层的依赖关系是通过依赖的箭头来体现的。基础层是为各层提供服务的，比如数据方面的是数据库、文件系统或者缓存组件等，API网关则是为用户接口层提供服务，还有比如总线之类的。\n其它层是通过基础组件的接口来访问基础层的。基础组件实现自己的逻辑，对外提供接口，它的内部逻辑是在自己的实现方法里实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572786728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146944,"user_name":"miniluo","can_delete":false,"product_type":"c1","uid":1397339,"ip_address":"","ucode":"5735B6DEE7902B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FheCgo4Ovibo0L1vAGgMdZkzQMm1GUMHMMqQ8aglufXaD2hW9z96DjQicAam723jOCZwXVmiaNiaaq4PLsf4COibZ5A/132","comment_is_top":false,"comment_ctime":1572711120,"is_pvip":false,"replies":[{"id":"56787","content":"可以分享一下哈。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572786757,"ip_address":"","comment_id":146944,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572711120","product_id":100037301,"comment_content":"看完发现我前两天应用层写的2个API服务编排有问题。下周回去改。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473066,"discussion_content":"可以分享一下哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572786757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397339,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/FheCgo4Ovibo0L1vAGgMdZkzQMm1GUMHMMqQ8aglufXaD2hW9z96DjQicAam723jOCZwXVmiaNiaaq4PLsf4COibZ5A/132","nickname":"miniluo","note":"","ucode":"5735B6DEE7902B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42863,"discussion_content":"访问第三方的接口和访问dao层放在领域层的同一个service的方法，应该在controller做编排而不是在service，或另起一个。\n另外，我刚刚看了第八讲，才能看到一半。我觉得篇幅过长，建议分开来讲，中台和微服务后部分另起章节。因为看的时候需要思考，篇幅过长则需要一个很完整的时间看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572792770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146465,"user_name":"你的美","can_delete":false,"product_type":"c1","uid":1529298,"ip_address":"","ucode":"71B97BDBA3CDC3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","comment_is_top":false,"comment_ctime":1572529761,"is_pvip":false,"replies":[{"id":"56559","content":"仓储理论上是在基础层的。但为了代码的整体迁移方便，我把它放到了领域层的聚合目录下。但仓储代码与业务逻辑代码是严格隔离的，业务逻辑代码中不会混入仓储实现逻辑。应用层也是可以跨过领域层使用基础资源的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572533071,"ip_address":"","comment_id":146465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572529761","product_id":100037301,"comment_content":"微服务内每个聚合对应一个仓储，为了方便迁移把每个聚合的仓储放在微服务的领域层；那每个微服务所对应的仓储，应该放在基础层吧，应用层直接调用，这样行吗老师？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472872,"discussion_content":"仓储理论上是在基础层的。但为了代码的整体迁移方便，我把它放到了领域层的聚合目录下。但仓储代码与业务逻辑代码是严格隔离的，业务逻辑代码中不会混入仓储实现逻辑。应用层也是可以跨过领域层使用基础资源的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572533071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146461,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1572528579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572528579","product_id":100037301,"comment_content":"区分好领域事件的聚合 与 领域服务的组合的区别<br>领域事件的聚合是，在领域服务内以聚合的形式出现，作为一个领域服务内，高内聚低耦合的整体，实现某原子的功能。<br>领域服务的组合是，满足业务的需求而将多个领域服务的功能组合在一起，实现某种业务。","like_count":0},{"had_liked":false,"id":146459,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1572528096,"is_pvip":false,"replies":[{"id":"56554","content":"是这样理解的。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572532795,"ip_address":"","comment_id":146459,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572528096","product_id":100037301,"comment_content":"实体方法的组合和封装，就相当于一个聚合，是在同一层中，也就是放在领域层；而领域服务的组合和封装是放在应用层；<br>例如上一节中，“5. 事件接收和处理”中画的图，收款微服务中，收款聚合为收款领域事件的组合，而这些是作为实体放在领域层中的，不可以作为微服务内事件的组合放在收款微服务的应用层中，不知理解是否正确，望老师解答，也就是区分好领域事件（实体）的组合和领域服务组合，领域事件的组合是放在领域层，领域服务的组合是放在应用层。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472870,"discussion_content":"是这样理解的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572532795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146449,"user_name":"启程","can_delete":false,"product_type":"c1","uid":1388780,"ip_address":"","ucode":"A0D505AA06B581","user_header":"https://static001.geekbang.org/account/avatar/00/15/30/ec/849b6b91.jpg","comment_is_top":false,"comment_ctime":1572526617,"is_pvip":false,"replies":[{"id":"56553","content":"就是应用逻辑用仓储接口的方式去使用基础资源，与基础资源相关的逻辑都在仓储实现中实现。这样基础层的逻辑，就不会放到领域层和应用层了。以后资源换了它的逻辑不会影响业务逻辑了，只需要替换基础资源的仓储就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572532714,"ip_address":"","comment_id":146449,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572526617","product_id":100037301,"comment_content":"那采用依赖倒置的设计以后，应用层就可以通过解耦来保持独立的核心业务逻辑。当数据库变更时，我们只需要更换数据库基础服务就可以了，这样就将资源变更对应用的影响降到了最低。- - -这段不理解，希望老师详细说明一下","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472866,"discussion_content":"就是应用逻辑用仓储接口的方式去使用基础资源，与基础资源相关的逻辑都在仓储实现中实现。这样基础层的逻辑，就不会放到领域层和应用层了。以后资源换了它的逻辑不会影响业务逻辑了，只需要替换基础资源的仓储就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572532714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1388780,"avatar":"https://static001.geekbang.org/account/avatar/00/15/30/ec/849b6b91.jpg","nickname":"启程","note":"","ucode":"A0D505AA06B581","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42389,"discussion_content":"谢谢老师讲解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572663709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146128,"user_name":"Geek_9695b4","can_delete":false,"product_type":"c1","uid":1134153,"ip_address":"","ucode":"E196700C069A9C","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/49/20a4b82d.jpg","comment_is_top":false,"comment_ctime":1572437714,"is_pvip":false,"replies":[{"id":"56398","content":"需要看你的业务逻辑差异在什么地方？如果在前端与微服务的接入参数方面，你在Facade服务dto组装的时候，适配一下就可以了。如果在服务的编排与组合，你在应用层做两个应用服务就可以了。如果是领域模型的差异，那就稍微麻烦一些了，领域模型的差异如果只是业务逻辑差异，还好处理，做不同的领域服务就可以了。如果是实体之间的差异，就比较麻烦了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572443774,"ip_address":"","comment_id":146128,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1572437714","product_id":100037301,"comment_content":"老师我有个问题请教下。对于一个领域譬如订单域，怎么去适配不同用户的不同需求，譬如对于同一个订单保存操作，A用户和B用户的业务逻辑会不一样，假如用户数量很多怎么办？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472720,"discussion_content":"需要看你的业务逻辑差异在什么地方？如果在前端与微服务的接入参数方面，你在Facade服务dto组装的时候，适配一下就可以了。如果在服务的编排与组合，你在应用层做两个应用服务就可以了。如果是领域模型的差异，那就稍微麻烦一些了，领域模型的差异如果只是业务逻辑差异，还好处理，做不同的领域服务就可以了。如果是实体之间的差异，就比较麻烦了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572443774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435845,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/c5/8bdb0bba.jpg","nickname":"DarKnight","note":"","ucode":"B04AFD03768827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329267,"discussion_content":"如果是实体差异是否可以考虑策略模式，如果差异很大的话那应该也不会因个人而异吧？而是因角色或者用户分类而异吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606356191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134153,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/49/20a4b82d.jpg","nickname":"Geek_9695b4","note":"","ucode":"E196700C069A9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42211,"discussion_content":"就是实体差异","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572612220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146058,"user_name":"熊瑞","can_delete":false,"product_type":"c1","uid":1031533,"ip_address":"","ucode":"5977D34E95EB19","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bd/6d/7266c83e.jpg","comment_is_top":false,"comment_ctime":1572426714,"is_pvip":false,"replies":[{"id":"56406","content":"要尽量少出现单实体聚合哈，这样后续管理也是比较麻烦的。实在不行你把这个实体放在跟它接近业务含义的聚合里面，只不过不受聚合根管理而已。聚合之间的协作要尽量放在应用层处理。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572444482,"ip_address":"","comment_id":146058,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572426714","product_id":100037301,"comment_content":"系统中会有很多 单实体的聚合，但是他们又需要相互协作处理业务，老师不是说，聚合间通信，要不用领域事件，要么在应用层编排。 在一个微服务内部（或者界限上下文中），如果使用过多的领域事件，会增加系统复杂度，同时有些操作&#47;业务概念，不需要引入领域事件，但又是多个聚合。这个时候，协作的部分，要写的应用层吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472692,"discussion_content":"要尽量少出现单实体聚合哈，这样后续管理也是比较麻烦的。实在不行你把这个实体放在跟它接近业务含义的聚合里面，只不过不受聚合根管理而已。聚合之间的协作要尽量放在应用层处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572444482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031533,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bd/6d/7266c83e.jpg","nickname":"熊瑞","note":"","ucode":"5977D34E95EB19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41597,"discussion_content":"嗯嗯，谢谢老师。有一个细节地方，我还是不太明白，想确定下，如果把某个实体，放到跟它相近的聚合里，但是不受聚合根管理，那这个实体，是不是也有单独自己的仓储呢。（因为我以前一直理解，仓储是针对聚合根的，有多少个聚合就会大体有多少个仓储，而不是实体）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572478144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145996,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1004755,"ip_address":"","ucode":"9BB9A170023CD8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/d3/46fd4aa3.jpg","comment_is_top":false,"comment_ctime":1572414733,"is_pvip":false,"replies":[{"id":"56346","content":"等我备完稿，腾出时间了准备哈。DDD.net支持的也不错，不过JAVA现在是主流的开发语言。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572418351,"ip_address":"","comment_id":145996,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572414733","product_id":100037301,"comment_content":"建议老师给一个基于代码的实战小例子，更符合咱们“实战课”的名字，1~7篇关于DDD的基本概念阐述的差不多了，讲到分层用一个小项目展示一下更容易让大家理解。另外，感觉还是Java领域谈DDD比较多啊。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472662,"discussion_content":"等我备完稿，腾出时间了准备哈。DDD.net支持的也不错，不过JAVA现在是主流的开发语言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572418351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145782,"user_name":"天涯海峰","can_delete":false,"product_type":"c1","uid":1205151,"ip_address":"","ucode":"56BF04C20AF39D","user_header":"https://static001.geekbang.org/account/avatar/00/12/63/9f/a6edd37e.jpg","comment_is_top":false,"comment_ctime":1572364914,"is_pvip":false,"replies":[{"id":"56302","content":"首先DDD是从领域建模开始的，这时业务边界和微服务边界已经很清楚了，每个领域模型中有哪些实体、值对象等基本是清晰的，这些实体不会出现在两个不同的领域模型中。因此根据这些实体设计出来数据模型也是跟领域模型基本一致的。这样设计出来的微服务就不会出现数据库共享实体的情况了。最终就是一个微服务对应一个数据库了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572398267,"ip_address":"","comment_id":145782,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572364914","product_id":100037301,"comment_content":"老师请教一个问题，微服务划分中数据库是对应多个吗?我们目前用orm,一个库，不同微服务用了同一个数据实体，总感觉有问题，但没有找到合适的方法","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472578,"discussion_content":"首先DDD是从领域建模开始的，这时业务边界和微服务边界已经很清楚了，每个领域模型中有哪些实体、值对象等基本是清晰的，这些实体不会出现在两个不同的领域模型中。因此根据这些实体设计出来数据模型也是跟领域模型基本一致的。这样设计出来的微服务就不会出现数据库共享实体的情况了。最终就是一个微服务对应一个数据库了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572398267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438475,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/0b/4560079e.jpg","nickname":"王宇","note":"","ucode":"0E9BC3AD99C8E5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189692,"discussion_content":"例如 用户这个概念，被很多模块 微服务 引用，不同库有点不知所措","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582897557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145754,"user_name":"夙梦流尘","can_delete":false,"product_type":"c1","uid":1477260,"ip_address":"","ucode":"D7E84D3B588BD6","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/8c/07dd8832.jpg","comment_is_top":false,"comment_ctime":1572360553,"is_pvip":false,"replies":[{"id":"56298","content":"应用层只要不是关键的业务实现逻辑就可以了，它主要职能是组合、编排和转换。<br>调用外部服务是在应用层做的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572397923,"ip_address":"","comment_id":145754,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572360553","product_id":100037301,"comment_content":"如果要根据实体的某个字段判断调用外部不同的服务。这段逻辑是在应用层写吗？还是拿到领域服务。如果在应用层感觉应用层慢慢会逻辑越来越多","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472564,"discussion_content":"应用层只要不是关键的业务实现逻辑就可以了，它主要职能是组合、编排和转换。\n调用外部服务是在应用层做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572397923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145738,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1572357486,"is_pvip":false,"replies":[{"id":"56274","content":"是这样的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572391640,"ip_address":"","comment_id":145738,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572357486","product_id":100037301,"comment_content":"一直不太明白，用户接口层的含义，这次相对有了清晰的认识；可不可以这样理解，用户接口层对应于我们常见的web层，属于对外开放的；应用层不再是我们传统意义上控制层（controller层，即对外提供数据，又对内控制访问流程），而是仅仅是协调领域层，完成某个流程或者是操作？？当然名字不必再拘泥于xxxController，只要能反映他的位置和功能就可以。望老师给予解答，感谢。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472553,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572391640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145737,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1572357432,"is_pvip":false,"replies":[{"id":"56296","content":"当微服务之间服务调用的时候，这种转换就会出现在应用层。A微服务调用B微服务的应用服务，A的DO数据需要先转换成DTO。这种数据组装和调用不通过A微服务的用户接口层，所以应用层不会依赖用户接口层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572397627,"ip_address":"","comment_id":145737,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572357432","product_id":100037301,"comment_content":"<br>谢谢老师，等待后面的数据对象这一节，提前讨论下，您回复中有数据转换发生在用户接口层或者是应用层，按照严格分层架构，这个数据转换是不是放在用户接口层更合适，因为按照文中“任何层只能对位于其直接下方的层产生依赖。”，上层可以依赖下层，下层不能依赖上层，这样这个转换如果放在应用层，应用层就依赖了用户接口层，也就是下层依赖了上层。当然任何东西都不是死的，要看具体情况而定，望解答","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472552,"discussion_content":"当微服务之间服务调用的时候，这种转换就会出现在应用层。A微服务调用B微服务的应用服务，A的DO数据需要先转换成DTO。这种数据组装和调用不通过A微服务的用户接口层，所以应用层不会依赖用户接口层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572397627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41304,"discussion_content":"感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572397970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145661,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1572338767,"is_pvip":false,"replies":[{"id":"56253","content":"DDD的数据对象设计分了好多种，我后面会有一节介绍。在领域层和应用层是DO对象，用户接口层是DTO对象。一般来说这两种数据对象是需要转换的，DO对象主要承载业务逻辑，DTO主要将DO的数据组装，转换为传输数据，这个转换发生在用户接口层或者应用层，DTO数据会通过Facade服务传输到前端应用用于展示。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572354680,"ip_address":"","comment_id":145661,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1572338767","product_id":100037301,"comment_content":"比如说用户接口层有个实体（比如房源上架实体vo），用于对外，领域层有个实体用于对领域层使用，这两层的两个实体基本一致，而且现在这两层在同一个进程中，是该定义两个实体好呢，还是定义一个实体，<br>比如：<br>@Data<br>public class HouseAdvertiseVo {<br>    @Min(1)<br>    private long brokerId;<br>    @NotNull<br>    @Pattern(regexp = &quot;[\\\\d|,]+&quot;, message = &quot;houseIds格式不正确，请填写正确的房源id&quot;)<br>    private String houseIds;<br>    private String userIp;<br>}<br><br>=======<br>@Data<br>public class HouseAdvertise {<br>    private long brokerId;<br>    private List&lt;Long&gt; houseIds;<br>    private String userIp;<br>}<br><br>两者的区别就是字符串的houseIds到领域层要转换成list，如果是定义两个实体，后期如果需要添加字段，可能需要修改多处，不利于扩展；如果定义为一个，放在领域层，由用户接口层调用，又跨过了应用层，这样也不合理，应该怎样处理这种情况，望老师帮忙答复，感谢！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472515,"discussion_content":"DDD的数据对象设计分了好多种，我后面会有一节介绍。在领域层和应用层是DO对象，用户接口层是DTO对象。一般来说这两种数据对象是需要转换的，DO对象主要承载业务逻辑，DTO主要将DO的数据组装，转换为传输数据，这个转换发生在用户接口层或者应用层，DTO数据会通过Facade服务传输到前端应用用于展示。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572354680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41123,"discussion_content":"理解的很透彻哈。\n当微服务之间服务调用的时候，这种转换就会出现在应用层。A微服务调用B微服务，A的DO数据需要先转换成DTO。这种数据组装和调用不通过A微服务的用户接口层，所有应用层不会依赖用户接口层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572357813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41118,"discussion_content":"谢谢老师，等待后面的数据对象这一节，提前讨论下，您回复中有数据转换发生在用户接口层或者是应用层，按照严格分层架构，这个数据转换是不是放在用户接口层更合适，因为按照文中“任何层只能对位于其直接下方的层产生依赖。”，上层可以依赖下层，下层不能依赖上层，这样这个转换如果放在应用层，应用层就依赖了用户接口层，也就是下层依赖了上层。当然任何东西都不是死的，要看具体情况而定，望解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572357124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145633,"user_name":"Никола","can_delete":false,"product_type":"c1","uid":1699599,"ip_address":"","ucode":"FA69B23EA67738","user_header":"https://static001.geekbang.org/account/avatar/00/19/ef/0f/b968a310.jpg","comment_is_top":false,"comment_ctime":1572334988,"is_pvip":false,"replies":[{"id":"56232","content":"仓储本身是属于基础层的。将它放在领域的主要目的是，考虑微服务架构的演进，方便聚合整体代码迁移，因此将它放在领域层的代码结构里。<br>由于他们都在一个微服务内，其实放在基础层和领域层的影响不大。但仓储实现代码放领域层时要在代码目录上做好与领域逻辑代码的隔离。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572339822,"ip_address":"","comment_id":145633,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572334988","product_id":100037301,"comment_content":"老师，仓储的接口应该是放在领域层，实现应该是放在其它地方，业务层只关注业务和仓储接口，不耦合具体的仓储实现，好多地方说仓储实现放在基础设施层，但是领域层又是依赖那一层的，基础设施层实现领域层的仓储接口不可实现，我看有些项目基础设施分了几个项目，一个是通用的工具，框架的封闭，另一个项目是仓储的实现。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472499,"discussion_content":"仓储本身是属于基础层的。将它放在领域的主要目的是，考虑微服务架构的演进，方便聚合整体代码迁移，因此将它放在领域层的代码结构里。\n由于他们都在一个微服务内，其实放在基础层和领域层的影响不大。但仓储实现代码放领域层时要在代码目录上做好与领域逻辑代码的隔离。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572339822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145565,"user_name":"puff","can_delete":false,"product_type":"c1","uid":1707936,"ip_address":"","ucode":"FCB1E987B44B48","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0f/a0/1a4965b8.jpg","comment_is_top":false,"comment_ctime":1572316804,"is_pvip":false,"replies":[{"id":"56178","content":"说明一下哈。四层架构，包括三层架构，在部署上都是在一个软件包里面。所以他们是一个应用内的分层，而不是应用之间的层。<br>所以四层的代码组合起来就是一个微服务。应用内分层的目的了是为让微服务内的代码逻辑更清晰，降低不同层之间业务逻辑的依赖性，领域层实现核心的业务逻辑，应用层主要是服务的组合和编排。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572317506,"ip_address":"","comment_id":145565,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572316804","product_id":100037301,"comment_content":"老师，你好。四层架构是不是可以理解为大家常说的微应用，领域层+基础设施层对应微服务？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472467,"discussion_content":"说明一下哈。四层架构，包括三层架构，在部署上都是在一个软件包里面。所以他们是一个应用内的分层，而不是应用之间的层。\n所以四层的代码组合起来就是一个微服务。应用内分层的目的了是为让微服务内的代码逻辑更清晰，降低不同层之间业务逻辑的依赖性，领域层实现核心的业务逻辑，应用层主要是服务的组合和编排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572317506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145471,"user_name":"m5jun","can_delete":false,"product_type":"c1","uid":1237302,"ip_address":"","ucode":"CA51419232644B","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/36/452106af.jpg","comment_is_top":false,"comment_ctime":1572279319,"is_pvip":false,"replies":[{"id":"56155","content":"放仓储也是没有问题的。理论上仓储是属于基础层，由于一个聚合对应一个仓储，考虑到以后以聚合为单位的微服务重构。为了代码迁移的便利，我将仓储相关的代码统一放到了领域层仓储对应聚合的目录下。在重构时，我们可以直接将这个聚合目录下的代码迁走就可以了，聚合业务逻辑代码迁走的同时，仓储的代码也一并迁走了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572311972,"ip_address":"","comment_id":145471,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572279319","product_id":100037301,"comment_content":"为什么要把仓储接口放领域层？<br>直接放仓储我觉得更好，领域层只感知仓储的接口。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472415,"discussion_content":"放仓储也是没有问题的。理论上仓储是属于基础层，由于一个聚合对应一个仓储，考虑到以后以聚合为单位的微服务重构。为了代码迁移的便利，我将仓储相关的代码统一放到了领域层仓储对应聚合的目录下。在重构时，我们可以直接将这个聚合目录下的代码迁走就可以了，聚合业务逻辑代码迁走的同时，仓储的代码也一并迁走了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572311972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145415,"user_name":"Panmax","can_delete":false,"product_type":"c1","uid":1004871,"ip_address":"","ucode":"9D65E3B84C5519","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/47/d217c45f.jpg","comment_is_top":false,"comment_ctime":1572269334,"is_pvip":false,"replies":[{"id":"56151","content":"非常感谢，还是你细心。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572311220,"ip_address":"","comment_id":145415,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572269334","product_id":100037301,"comment_content":"在业务发展到一定程度以后，你会发现微服务2的领域模型有了变化，聚合d会更适合放到微服务1的领域模型中。<br>应该是：<br>你会发现微**服务3**的领域模型有了变化","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472385,"discussion_content":"非常感谢，还是你细心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572311220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145259,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1572238591,"is_pvip":false,"replies":[{"id":"56044","content":"第一个问题，应用层与领域层是在同一个微服务内的核心逻辑，只不过代码做了分层，它们用DO来交互。DO是领域对象。后面有专门的一节来讲服务和这些对象在不同层的交互方式。<br>第二个问题，纠正一下：应用层操作的是多个聚合的领域服务。应用服务调用领域服务，领域服务会组合自己聚合内的实体和值对象完成业务逻辑，它封装了这些实体和值对象的属性和方法。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572249505,"ip_address":"","comment_id":145259,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572238591","product_id":100037301,"comment_content":"1.提问，用户层到应用层交互的出入参后缀为dto这个没毛病，应用层与领域层交互的出入参我后缀用dmo，老师这里用啥？bo？<br>2.回答问题，领域对象的对象比较宽泛，实体和服务实例一系列东西都算。这里我假定老师提的问题是这两层操作的数据的领域对象有什么。领域层操作的是本领域的实体和值对象，应用层操作的是多个领域间，中间状态的实体和值对象（抽取当前领域层的实体和值对象的部分值，提供其他应用的领域层的实体和值对象的封装）。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472311,"discussion_content":"第一个问题，应用层与领域层是在同一个微服务内的核心逻辑，只不过代码做了分层，它们用DO来交互。DO是领域对象。后面有专门的一节来讲服务和这些对象在不同层的交互方式。\n第二个问题，纠正一下：应用层操作的是多个聚合的领域服务。应用服务调用领域服务，领域服务会组合自己聚合内的实体和值对象完成业务逻辑，它封装了这些实体和值对象的属性和方法。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572249505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145227,"user_name":"何沛","can_delete":false,"product_type":"c1","uid":1477145,"ip_address":"","ucode":"5673C580982710","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/19/a54761af.jpg","comment_is_top":false,"comment_ctime":1572233069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572233069","product_id":100037301,"comment_content":"1.领域层包含（领域事件、领域服务、值对象、实体、仓储接口、工厂、翻译器）领域对象<br>2.应用层包含（应用服务层、组装器）","like_count":0},{"had_liked":false,"id":145115,"user_name":"小孩","can_delete":false,"product_type":"c1","uid":1112367,"ip_address":"","ucode":"A7F587FC641E63","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/2f/01b32495.jpg","comment_is_top":false,"comment_ctime":1572219088,"is_pvip":false,"replies":[{"id":"55961","content":"你是说基础层不同的组件之间的依赖吗？这种场景不太多，如果一定需要，那就调用仓储接口就可以了。领域层必然要依赖基础层，它是通过仓储接口来访问的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572226493,"ip_address":"","comment_id":145115,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1572219088","product_id":100037301,"comment_content":"老师基础层依赖领域层的仓储接口，如果领域层也依赖基础层的基础设施怎么办，","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472250,"discussion_content":"你是说基础层不同的组件之间的依赖吗？这种场景不太多，如果一定需要，那就调用仓储接口就可以了。领域层必然要依赖基础层，它是通过仓储接口来访问的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572226493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327600,"discussion_content":"A在公共平台，B在大数据平台，A要联系B必须通过B的领导，不能直接去接触，我这个例子不晓得恰当不","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605870881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112367,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/2f/01b32495.jpg","nickname":"小孩","note":"","ucode":"A7F587FC641E63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41479,"discussion_content":"差不多是你的意思,如果不通过包引用,因为仓储接口放到领域层,基础设施层就需要依赖领域层,同样领域层肯定会依赖基础设施层的通用组件,那不是循环依赖了吗,所以我在实践的时候拆了两层,一个只放db相关的仓储,一个工具类的utils层,不知道老师怎么解决这个问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572438219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326826,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3e/ea/43502ec7.jpg","nickname":"赵立","note":"","ucode":"3EFBB14465C20F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40796,"discussion_content":"基础层应该包括两类，一种是业务无关的工具类，一种是业务相关的如业务数据库类。数据库访问实现依赖领域层仓储接口，工具类组成的基础服务可能是所有层次都会依赖的，一般会以外部打好的包引入项目中。不知道理解的正确否，供参考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572269079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}