{"id":814486,"title":"16｜概念详解：使用向量数据库管理向量值","content":"<p>你好，我是叶伟民。</p><p>上一节课我们讲解了如何通过嵌入模型来获取知识的向量编码表示。</p><p>但是你可能有这样的疑惑——我们每次查询知识的时候，都必须调用嵌入模型来获取所有知识的向量编码表示吗？</p><p>显然是不合理的。一般来说，我们会在获取了向量编码表示之后，将它保存起来。这节课，我们就来解决这个问题。</p><h2>保存向量编码的工具选择</h2><p>能够保存向量编码的工具有很多。这里我仅列出我研究过的：</p><ol>\n<li>Faiss</li>\n<li>Pinecone</li>\n<li>Chroma</li>\n<li>Milvus</li>\n<li>LanceDB</li>\n<li>PostgreSQL</li>\n</ol><p>研究过以上这么多工具之后，我依次在项目中应用过这三个向量编码保存工具。</p><ol>\n<li>FAISS</li>\n<li>Milvus</li>\n<li>PostgreSQL</li>\n</ol><p>在掉过N次坑之后，最终我选择安装了pgvector插件之后的PostgreSQL，到今天（2024/10/09）为止，已经在实际项目中稳定运行12个月了，所以现在我才敢推荐给大家使用。为了和默认的Postgres区分开来，在这门课的后续内容中，<strong>我将把安装了pgvector插件之后的PostgreSQL 简称为pgvector</strong>。</p><h2>PostgreSQL和pgvector</h2><p>PostgreSQL 是与MySQL齐名的开源关系数据库。PostgreSQL 默认是不支持存储向量的。只有安装了pgvector插件之后，PostgreSQL 才能支持存储向量，才能变成向量数据库。</p><!-- [[[read_end]]] --><h2>安装与运行</h2><p>我们先从最简单的安装和运行开始今天的探索之旅。</p><h3>安装pgvector</h3><p>安装pgvector的方式有好几种，最快的方式是使用docker安装。</p><p>首先我们需要安装docker。安装完docker之后，我们打开命令行工具，运行以下命令：</p><pre><code class=\"language-powershell\">docker pull pgvector/pgvector:pg16\n</code></pre><p>这条命令会从Docker Hub下载pgvector的最新版本（对应PostgreSQL 16版本）的镜像。如果你需要其他版本的PostgreSQL，可以通过更改镜像标签来拉取相应的版本。</p><h3>运行pgvector</h3><p>拉取完镜像后，我们就可以运行pgvector的容器了。在命令行工具中运行以下命令：</p><pre><code class=\"language-powershell\">docker run --name pgvector --restart=always -e POSTGRES_USER=pgvector -e POSTGRES_PASSWORD=pass@word1234567 -v D:\\dockermount\\pgvector\\pgdata⁠:/var/lib/postgresql/data -p 5432:5432 -d pgvector/pgvector:pg16\n</code></pre><p>你可能要根据你的实际情况修改以上命令中的具体参数值：</p><ul>\n<li>\n<p>–name：容器的名称。</p>\n</li>\n<li>\n<p>-e POSTGRES_USER：PostgreSQL的用户名，以后登录数据库时要使用它。</p>\n</li>\n<li>\n<p>-e POSTGRES_PASSWORD：PostgreSQL的密码，以后登录数据库时要使用它。</p>\n</li>\n<li>\n<p>-v：冒号前面的值是Windows宿主机里你想要保存数据库数据的目录，冒号后面的值是容器的数据目录。以上示例中的值是将容器的数据目录映射到了你的Windows宿主机的 <code>D:\\dockermount\\pgvector\\pgdata</code> 目录。一般来说，你需要将冒号前面的值修改为Windows宿主机你想要保存数据库数据的目录。</p>\n</li>\n<li>\n<p>-p：PostgreSQL的端口。如果你的Windows宿主机没有安装PostgreSQL，则不需要修改这个值。否则你需要将以上示例中冒号前面的值修改一下，例如改成 <code>-p 54321:5432</code>。</p>\n</li>\n</ul><h3>安装pgadmin</h3><p>把pgvector运行起来之后，我们还需要一个数据库管理工具来使用它，这里我们使用pgadmin。pgadmin是一个管理PostgreSQL的图形化管理工具。因为是图形化管理工具，使用起来自然比PostgreSQL自带的pgsql命令行工具方便多了。</p><p>前面提到我有从FAISS换成Milvus和PostgreSQL，其中一个很重要的原因就是FAISS没有提供图形化管理工具。我不得不在Jupyter里面使用LangChain来操作FAISS、Chroma的数据，操作起来比较繁琐。</p><p>现在我们来安装pgadmin。我们打开浏览器访问https://www.pgadmin.org/download/。下载Windows版本，然后按默认设置安装。</p><h3>运行pgadmin</h3><p>我们打开开始菜单，输入 <code>pgadmin</code>，将会看到如下界面。</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/8c/eae2810b5208fc4e5f14fe82585ce98c.jpg?wh=2538x1750\" alt=\"\"></p><p>接着点击蓝色的大象图标，将会打开pgadmin。之后我们按下图所示，选中左侧的Server，鼠标右键点Register，再点Server。</p><p><img src=\"https://static001.geekbang.org/resource/image/1f/e7/1ff094e9c26df20f4344a3d5a4ab0be7.jpg?wh=2920x1628\" alt=\"\"></p><p>这时将会弹出如下界面。如果前面你没有修改PostgreSQL的端口，可以直接按照以下界面填写。如果前面你修改了PostgreSQL的端口，则需要修改Port里面的值。</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/72/ae87f2e7db1c8b37b21f06115c9b7372.jpg?wh=2300x1795\" alt=\"\"></p><p>填写好以后，我们点Save按钮。如果一切正常，此时pgadmin的左侧应该会出现以下界面。</p><p><img src=\"https://static001.geekbang.org/resource/image/74/06/743c1ddc98c76ac13f9d9yyd8ebfd506.jpg?wh=3020x3335\" alt=\"\"></p><p>现在我们完成了pgadmin的安装，接下来还需要安装pgvector扩展。</p><h2>给数据库安装pgvector扩展</h2><p>然后我们选中刚才添加的服务器，点database，再点postgres，再点Extensions，鼠标右键create，然后点Extension菜单。</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/67/cfb2af58246eae7ff561183e16254667.jpg?wh=1966x2608\" alt=\"\"></p><p>然后在弹出的窗口里面的Name下拉列表中选择vector，然后再点击Save按钮。</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/f6/e707f35543c3fb78c5b08269f419bcf6.jpg?wh=2020x2200\" alt=\"\"></p><p>如果一切正常，此时pgadmin的左侧应该会出现以下界面。Extensions节点下面应该显示有vector节点。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/35/5f2ce02969fb227aaa56f2ea85be4335.jpg?wh=2920x3227\" alt=\"\"></p><h2>创建表</h2><p>现在我们可以创建表来存储向量编码数据了。</p><p>我们还是选择刚才的database，依次点击postgres-Schemas-public-Tables，鼠标右键Create，然后点Table菜单，就可以开始创建表了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/6f/71/6fe4e326a8b23d1yy33352506b82e171.jpg?wh=2920x2271\" alt=\"\"></p><p>接下来，我们在General这个Tab里面的Name填入表名，这里就叫<code>测试向量编码</code>。这里的表名你可以改为任何符合你业务场景的表名。</p><p><img src=\"https://static001.geekbang.org/resource/image/03/fe/0393242335c4bbd41057f7901c3cc4fe.jpg?wh=2820x2132\" alt=\"\"></p><h3>创建输入文本列</h3><p>然后切换到Columns这个Tab，点击最右边的+图标。</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/74/5d0462e56c629e5ac674ab3218927974.jpg?wh=2920x2222\" alt=\"\"></p><p>之后我们在 <code>Name</code> 里面输入列名<code>文本</code>，在 <code>Data type</code> 输入 <code>text</code>，并将 “<code>Not NULL？</code>” 这一项设置为开启。这里的列名你可以改为任何符合你业务场景的列名，后面添加其他列的时候也一样如此，我就不重复提示了。</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/f1/f404317a2fe2d18aeba66368a4faf1f1.jpg?wh=2920x1797\" alt=\"\"></p><h3>创建向量编码列</h3><p>然后我们继续点击刚才的最右边的+图标。</p><p>在新一列（第二列）的<code>Name</code>输入<code>向量编码</code>，在<code>Data type</code>输入<code>vector</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/0d/b3e5632d7e33036aa62b527d085b330d.jpg?wh=2870x1767\" alt=\"\"></p><h3>创建嵌入模型列</h3><p>不知道你是否记得<a href=\"https://time.geekbang.org/column/article/810048\">第10节课</a>里我们提到过，不同嵌入模型、甚至同一嵌入模型的不同版本计算出的向量编码都是不通用的。所以这里我们需要添加一列嵌入模型列。这样我们在增删改查数据的时候，就可以通过这一列获知向量值来自于哪一个嵌入模型的哪一个版本。</p><p>我们还是继续点击刚才的最右边的+图标。在新一列（第三列）的Name输入<code>嵌入模型</code>，然后在Data type输入text，并点击Save按钮保存。</p><p><img src=\"https://static001.geekbang.org/resource/image/28/c6/28b4f91a505f569f3a822eddf66277c6.jpg?wh=2879x1754\" alt=\"\"></p><p>如果一切正常，以上窗口关闭之后，我们应该在pgadmin左侧的Tables看到刚才新建的表。展开这个表的Columns节点之后，应该可以看到刚才新建的三列内容。</p><p><img src=\"https://static001.geekbang.org/resource/image/71/62/71d42b3c54f216e8c9df3d1bca400762.jpg?wh=3040x3252\" alt=\"\"></p><h2>增删改查数据</h2><p>接下来，我们来搞定各类数据操作。</p><p>虽然在pgadmin里，我们确实可以通过图形化的方法来增删改查数据。但是这里我们将使用SQL语句的方法，因为这样一旦测试成功，我们可以将这段SQL复制到Python代码中使用。<br>\n那么如何编写这些SQL语句呢？我们固然可以按照PostgreSQL的文档，一个一个字符敲出来，但是这样的方法太慢了，而且也容易出错，所以我们会使用图形化界面的方式来生成这些SQL语句。</p><p>现在我们选中刚才新建的表，鼠标右键点击Scripts菜单，然后点击INSERT Script。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/64/141ec5c2ba1495e77545722feb1e0864.jpg?wh=2940x3082\" alt=\"t15\"></p><p>然后右边的主要脚本窗格将会出现后面这样的的插入数据脚本。</p><p><img src=\"https://static001.geekbang.org/resource/image/87/2c/87aab21bda724a593a0494764526582c.jpg?wh=2900x1053\" alt=\"\"></p><p>我们把里面的 “?” 部分替换成我们想要插入的实际数据即可。没错，这里跟关系数据库里，插入输入的SQL脚本完全一模一样。</p><p>修改好SQL脚本之后，我们可以按F5键或者主窗格最上面的箭头来执行SQL。</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/08/c51f3cdeac0f40f0b6f8f87c44e72408.jpg?wh=2920x1069\" alt=\"\"></p><p>至于修改、删除、查询向量编码数据的方法与增加数据的方法类似，只不过换了一个子菜单而已：</p><ol>\n<li>修改数据的子菜单是UPDATE Script</li>\n<li>删除数据的子菜单是DELETE Script</li>\n<li>查询数据的子菜单是SELECT Script</li>\n</ol><p>我要提醒你注意的是，<strong>如果要获取某一文本的向量编码数据，我们需要在SELECT Script生成的SQL语句里面添加where查询子句。</strong></p><p>例如查询”老婆饼“的向量编码数据的最终SQL语句是这样的：</p><pre><code class=\"language-sql\">SELECT \"文本\", \"向量编码\", \"嵌入模型\"\n\tFROM public.\"测试向量编码\"\n\twhere \"文本\"='老婆饼'\n\t;\n</code></pre><p>讲到这里，同学们会发现，除了需要安装扩展、指定不同的数据类型，以及使用不同的关键字，使用pgvector来管理向量编码数据与使用关系数据库管理其他数据没有什么不同。</p><p>是的，你的发现是对的！向量数据库并没有什么神秘的。</p><p>不过进行到这里，我们仍然有个问题没能解决——虽然现在通过SELECT Script，我们可以根据指定文本查询到对应的向量编码，但是还不能根据指定文本找到最相似的文本，例如根据”老婆饼“查询出最相似的文本”菠萝包“，这就是我们下一节课要讲的内容，敬请期待。</p><h2>小结</h2><p>好了，今天这一讲到这里就结束了，最后我们来回顾一下。这一讲我们学会了四件事情。</p><p>第一件，如何安装pgvector。</p><p>第二件，如何安装图形化界面工具pgadmin。</p><p>第三件，如何使用pgadmin通过图形化的方式创建表和列来保存向量编码数据。</p><p>第四件，如何使用pgadmin通过SQL查询语句的方式增删改查向量编码数据。</p><p>看到这里，同学们会发现我强调多次图形化。是的！我的口号是——能用图形化界面解决的，就不要用代码。你可能也在其他文章里看到命令行的方式，但为了降低学习门槛，让你更快上手，所以我们选择了图形化界面的方式来操作。</p><h2>思考题</h2><p>问题1：增删改查数据的时候，为什么不直接选择LangChain里提供的pgvector API，而是使用SQL语句完成呢？</p><p>问题2：既然换一个嵌入模型就需要全部重新计算一遍向量编码，为什么要添加嵌入模型列，直接更新所有向量编码列的值不就好了吗？</p><p>欢迎你在留言区和我交流互动，如果这节课对你有启发，也推荐分享给身边更多朋友。</p>","neighbors":{"left":{"article_title":"15｜向量与嵌入模型：揭秘人类与机器语言转化的奥秘","id":813934},"right":{"article_title":"17｜概念详解：通过相似度模糊检索","id":815540}},"comments":[{"had_liked":false,"id":395296,"user_name":"无处不在","can_delete":false,"product_type":"c1","uid":1157533,"ip_address":"北京","ucode":"BB535BC6F448F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/9d/bdfd9e58.jpg","comment_is_top":false,"comment_ctime":1730128090,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100817901,"comment_content":"问题一：虽然没用过python版的langchain，但是用过java版本的langchain4j，在langchain4j中默认定义了一个固定表结构的向量表，如果是单纯搜索词的场景够用了，但是个性化的业务场景还需要定制开发\n问题二：应该是为将来的不同模型的不同维度的向量的搜索精度做准备吧","like_count":0},{"had_liked":false,"id":394932,"user_name":"言十年","can_delete":false,"product_type":"c1","uid":1110039,"ip_address":"北京","ucode":"67B8B49C3A3B17","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/17/796a3d20.jpg","comment_is_top":false,"comment_ctime":1728867840,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100817901,"comment_content":"问题一：直接用sql比较零活吧。并且不依赖组件。\n问题二：加上嵌入列，多一个选择。可以a模型也可以用b模型。而且，不影响之前的向量结果。类似于接口分v1版本v2版本，平滑升级。","like_count":0}]}