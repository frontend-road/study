{"id":99478,"title":"08 | 网络通信优化之I/O模型：如何解决高并发下I/O瓶颈？","content":"<p>你好，我是刘超。</p><p>提到Java I/O，相信你一定不陌生。你可能使用I/O操作读写文件，也可能使用它实现Socket的信息传输…这些都是我们在系统中最常遇到的和I/O有关的操作。</p><p>我们都知道，I/O的速度要比内存速度慢，尤其是在现在这个大数据时代背景下，I/O的性能问题更是尤为突出，I/O读写已经成为很多应用场景下的系统性能瓶颈，不容我们忽视。</p><p>今天，我们就来深入了解下Java I/O在高并发、大数据业务场景下暴露出的性能问题，从源头入手，学习优化方法。</p><h2>什么是I/O</h2><p>I/O是机器获取和交换信息的主要渠道，而流是完成I/O操作的主要方式。</p><p>在计算机中，流是一种信息的转换。流是有序的，因此相对于某一机器或者应用程序而言，我们通常把机器或者应用程序接收外界的信息称为输入流（InputStream），从机器或者应用程序向外输出的信息称为输出流（OutputStream），合称为输入/输出流（I/O Streams）。</p><p>机器间或程序间在进行信息交换或者数据交换时，总是先将对象或数据转换为某种形式的流，再通过流的传输，到达指定机器或程序后，再将流转换为对象数据。因此，流就可以被看作是一种数据的载体，通过它可以实现数据交换和传输。</p><!-- [[[read_end]]] --><p>Java的I/O操作类在包java.io下，其中InputStream、OutputStream以及Reader、Writer类是I/O包中的4个基本类，它们分别处理字节流和字符流。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/64/7d/64f1e83054e2997f1fd96b221fb0da7d.jpg?wh=1006*420\" alt=\"\"></p><p>回顾我的经历，我记得在初次阅读Java I/O流文档的时候，我有过这样一个疑问，在这里也分享给你，那就是：“<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么I/O流操作要分为字节流操作和字符流操作呢？</strong>”</p><p>我们知道字符到字节必须经过转码，这个过程非常耗时，如果我们不知道编码类型就很容易出现乱码问题。所以I/O流提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。下面我们就分别了解下“字节流”和“字符流”。</p><h3>1.字节流</h3><p>InputStream/OutputStream是字节流的抽象类，这两个抽象类又派生出了若干子类，不同的子类分别处理不同的操作类型。如果是文件的读写操作，就使用FileInputStream/FileOutputStream；如果是数组的读写操作，就使用ByteArrayInputStream/ByteArrayOutputStream；如果是普通字符串的读写操作，就使用BufferedInputStream/BufferedOutputStream。具体内容如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/12/8f/12bbf6e62c7c29ae82bf90fead72b98f.jpg?wh=1474*1086\" alt=\"\"></p><h3>2.字符流</h3><p>Reader/Writer是字符流的抽象类，这两个抽象类也派生出了若干子类，不同的子类分别处理不同的操作类型，具体内容如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/24/9f/24592c6f90300f7bab86ec4141dd7e9f.jpg?wh=1126*742\" alt=\"\"></p><h2>传统I/O的性能问题</h2><p>我们知道，I/O操作分为磁盘I/O操作和网络I/O操作。前者是从磁盘中读取数据源输入到内存中，之后将读取的信息持久化输出在物理磁盘上；后者是从网络中读取信息输入到内存，最终将信息输出到网络中。但不管是磁盘I/O还是网络I/O，在传统I/O中都存在严重的性能问题。</p><h3>1.多次内存复制</h3><p>在传统I/O中，我们可以通过InputStream从源数据中读取数据流输入到缓冲区里，通过OutputStream将数据输出到外部设备（包括磁盘、网络）。你可以先看下输入操作在操作系统中的具体流程，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/c2/4c4af15b08d3b11de3fe603a70dc6ac2.jpg?wh=1458*686\" alt=\"\"></p><ul>\n<li>JVM会发出read()系统调用，并通过read系统调用向内核发起读请求；</li>\n<li>内核向硬件发送读指令，并等待读就绪；</li>\n<li>内核把将要读取的数据复制到指向的内核缓存中；</li>\n<li>操作系统内核将数据复制到用户空间缓冲区，然后read系统调用返回。</li>\n</ul><p>在这个过程中，数据先从外部设备复制到内核空间，再从内核空间复制到用户空间，这就发生了两次内存复制操作。这种操作会导致不必要的数据拷贝和上下文切换，从而降低I/O的性能。</p><h3>2.阻塞</h3><p>在传统I/O中，InputStream的read()是一个while循环操作，它会一直等待数据读取，直到数据就绪才会返回。<strong>这就意味着如果没有数据就绪，这个读取操作将会一直被挂起，用户线程将会处于阻塞状态。</strong></p><p>在少量连接请求的情况下，使用这种方式没有问题，响应速度也很高。但在发生大量连接请求时，就需要创建大量监听线程，这时如果线程没有数据就绪就会被挂起，然后进入阻塞状态。一旦发生线程阻塞，这些线程将会不断地抢夺CPU资源，从而导致大量的CPU上下文切换，增加系统的性能开销。</p><h2>如何优化I/O操作</h2><p>面对以上两个性能问题，不仅编程语言对此做了优化，各个操作系统也进一步优化了I/O。JDK1.4发布了java.nio包（new I/O的缩写），NIO的发布优化了内存复制以及阻塞导致的严重性能问题。JDK1.7又发布了NIO2，提出了从操作系统层面实现的异步I/O。下面我们就来了解下具体的优化实现。</p><h3>1.使用缓冲区优化读写流操作</h3><p>在传统I/O中，提供了基于流的I/O实现，即InputStream和OutputStream，这种基于流的实现以字节为单位处理数据。</p><p>NIO与传统 I/O 不同，它是基于块（Block）的，它以块为基本单位处理数据。在NIO中，最为重要的两个组件是缓冲区（Buffer）和通道（Channel）。Buffer是一块连续的内存块，是 NIO 读写数据的中转地。Channel表示缓冲数据的源头或者目的地，它用于读取缓冲或者写入数据，是访问缓冲的接口。</p><p>传统I/O和NIO的最大区别就是传统I/O是面向流，NIO是面向Buffer。Buffer可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。虽然传统I/O后面也使用了缓冲块，例如BufferedInputStream，但仍然不能和NIO相媲美。使用NIO替代传统I/O操作，可以提升系统的整体性能，效果立竿见影。</p><h3>2. 使用DirectBuffer减少内存复制</h3><p>NIO的Buffer除了做了缓冲块优化之外，还提供了一个可以直接访问物理内存的类DirectBuffer。普通的Buffer分配的是JVM堆内存，而DirectBuffer是直接分配物理内存(非堆内存)。</p><p>我们知道数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而在Java中，在用户空间中又存在一个拷贝，那就是从Java堆内存中拷贝到临时的直接内存中，通过临时的直接内存拷贝到内存空间中去。此时的直接内存和堆内存都是属于用户空间。</p><p><img src=\"https://static001.geekbang.org/resource/image/39/c2/399d715ed2f687e22ec9ca2a65bd88c2.jpg?wh=1652*824\" alt=\"\"></p><p>你肯定会在想，为什么Java需要通过一个临时的非堆内存来复制数据呢？如果单纯使用Java堆内存进行数据拷贝，当拷贝的数据量比较大的情况下，Java堆的GC压力会比较大，而使用非堆内存可以减低GC的压力。</p><p>DirectBuffer则是直接将步骤简化为数据直接保存到非堆内存，从而减少了一次数据拷贝。以下是JDK源码中IOUtil.java类中的write方法：</p><pre><code>        if (src instanceof DirectBuffer)\n            return writeFromNativeBuffer(fd, src, position, nd);\n\n        // Substitute a native buffer\n        int pos = src.position();\n        int lim = src.limit();\n        assert (pos &lt;= lim);\n        int rem = (pos &lt;= lim ? lim - pos : 0); \n        ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);\n        try {\n            bb.put(src);\n            bb.flip();\n        // ...............\n</code></pre><p>这里拓展一点，由于DirectBuffer申请的是非JVM的物理内存，所以创建和销毁的代价很高。DirectBuffer申请的内存并不是直接由JVM负责垃圾回收，但在DirectBuffer包装类被回收时，会通过Java Reference机制来释放该内存块。</p><p>DirectBuffer只优化了用户空间内部的拷贝，而之前我们是说优化用户空间和内核空间的拷贝，那Java的NIO中是否能做到减少用户空间和内核空间的拷贝优化呢？</p><p>答案是可以的，DirectBuffer是通过unsafe.allocateMemory(size)方法分配内存，也就是基于本地类Unsafe类调用native方法进行内存分配的。而在NIO中，还存在另外一个Buffer类：MappedByteBuffer，跟DirectBuffer不同的是，MappedByteBuffer是通过本地类调用mmap进行文件内存映射的，map()系统调用方法会直接将文件从硬盘拷贝到用户空间，只进行一次数据拷贝，从而减少了传统的read()方法从硬盘拷贝到内核空间这一步。</p><h3>3.避免阻塞，优化I/O操作</h3><p>NIO很多人也称之为Non-block I/O，即非阻塞I/O，因为这样叫，更能体现它的特点。为什么这么说呢？</p><p>传统的I/O即使使用了缓冲块，依然存在阻塞问题。由于线程池线程数量有限，一旦发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中有空闲的线程可以被复用。而对Socket的输入流进行读取时，读取流会一直阻塞，直到发生以下三种情况的任意一种才会解除阻塞：</p><ul>\n<li>有数据可读；</li>\n<li>连接释放；</li>\n<li>空指针或I/O异常。</li>\n</ul><p>阻塞问题，就是传统I/O最大的弊端。NIO发布后，通道和多路复用器这两个基本组件实现了NIO的非阻塞，下面我们就一起来了解下这两个组件的优化原理。</p><p><strong>通道（Channel）</strong></p><p>前面我们讨论过，传统I/O的数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的I/O接口从磁盘读取或写入。</p><p>最开始，在应用程序调用操作系统I/O接口时，是由CPU完成分配，这种方式最大的问题是“发生大量I/O请求时，非常消耗CPU“；之后，操作系统引入了DMA（直接存储器存储），内核空间与磁盘之间的存取完全由DMA负责，但这种方式依然需要向CPU申请权限，且需要借助DMA总线来完成数据的复制操作，如果DMA总线过多，就会造成总线冲突。</p><p>通道的出现解决了以上问题，Channel有自己的处理器，可以完成内核空间和磁盘之间的I/O操作。在NIO中，我们读取和写入数据都要通过Channel，由于Channel是双向的，所以读、写可以同时进行。</p><p><strong>多路复用器（Selector）</strong></p><p>Selector是Java NIO编程的基础。用于检查一个或多个NIO Channel的状态是否处于可读、可写。</p><p>Selector是基于事件驱动实现的，我们可以在Selector中注册accpet、read监听事件，Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生监听事件，这个Channel就处于就绪状态，然后进行I/O操作。</p><p>一个线程使用一个Selector，通过轮询的方式，可以监听多个Channel上的事件。我们可以在注册Channel时设置该通道为非阻塞，当Channel上没有I/O操作时，该线程就不会一直等待了，而是会不断轮询所有Channel，从而避免发生阻塞。</p><p>目前操作系统的I/O多路复用机制都使用了epoll，相比传统的select机制，epoll没有最大连接句柄1024的限制。所以Selector在理论上可以轮询成千上万的客户端。</p><p><strong>下面我用一个生活化的场景来举例，</strong>看完你就更清楚Channel和Selector在非阻塞I/O中承担什么角色，发挥什么作用了。</p><p>我们可以把监听多个I/O连接请求比作一个火车站的进站口。以前检票只能让搭乘就近一趟发车的旅客提前进站，而且只有一个检票员，这时如果有其他车次的旅客要进站，就只能在站口排队。这就相当于最早没有实现线程池的I/O操作。</p><p>后来火车站升级了，多了几个检票入口，允许不同车次的旅客从各自对应的检票入口进站。这就相当于用多线程创建了多个监听线程，同时监听各个客户端的I/O请求。</p><p>最后火车站进行了升级改造，可以容纳更多旅客了，每个车次载客更多了，而且车次也安排合理，乘客不再扎堆排队，可以从一个大的统一的检票口进站了，这一个检票口可以同时检票多个车次。这个大的检票口就相当于Selector，车次就相当于Channel，旅客就相当于I/O流。</p><h2>总结</h2><p>Java的传统I/O开始是基于InputStream和OutputStream两个操作流实现的，这种流操作是以字节为单位，如果在高并发、大数据场景中，很容易导致阻塞，因此这种操作的性能是非常差的。还有，输出数据从用户空间复制到内核空间，再复制到输出设备，这样的操作会增加系统的性能开销。</p><p>传统I/O后来使用了Buffer优化了“阻塞”这个性能问题，以缓冲块作为最小单位，但相比整体性能来说依然不尽人意。</p><p>于是NIO发布，它是基于缓冲块为单位的流操作，在Buffer的基础上，新增了两个组件“管道和多路复用器”，实现了非阻塞I/O，NIO适用于发生大量I/O连接请求的场景，这三个组件共同提升了I/O的整体性能。</p><p>你可以在<a href=\"https://github.com/nickliuchao/io\">Github</a>上通过几个简单的例子来实践下传统IO、NIO。</p><h2>思考题</h2><p>在JDK1.7版本中，Java发布了NIO的升级包NIO2，也就是AIO。AIO实现了真正意义上的异步I/O，它是直接将I/O操作交给操作系统进行异步处理。这也是对I/O操作的一种优化，那<span class=\"orange\">为什么现在很多容器的通信框架都还是使用NIO呢？</span></p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起学习。</p><p></p>","comments":[{"had_liked":false,"id":105217,"user_name":"ZOU志伟","can_delete":false,"product_type":"c1","uid":1029179,"ip_address":"","ucode":"439779871CC992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","comment_is_top":false,"comment_ctime":1560939981,"is_pvip":false,"replies":[{"id":"51873","content":"我们通常在通信时，使用的是字节流FileInputStream来实现数据的传输，你会发现，我们在读取read()和写入write()的时候都是先将字符转成字节码再进行写入操作，同样读取也是类似。如果是中文，在gbk中一般一个中文占用两个字节，如果通过字节流的方式只读取一个字节，是无法转编码为一个中文汉字。<br><br>而字符流就是为了解决这种问题，如果用字符流去读取，字符流会根据默认编码一次性的读取一个字符，即若若是gbk编码就会一次读取2个字节。因此字符流是根据字符所占字节大小而决定读取多少字节的。这就是字符流和字节流的本质不同。","user_name":"作者回复","comment_id":105217,"uid":"1228576","ip_address":"","utype":1,"ctime":1569056304,"user_name_real":"刘超"}],"discussion_count":4,"race_medal":0,"score":"293618716109","product_id":100028001,"comment_content":"老师，为什么要字符流还是没懂","like_count":68,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454597,"discussion_content":"我们通常在通信时，使用的是字节流FileInputStream来实现数据的传输，你会发现，我们在读取read()和写入write()的时候都是先将字符转成字节码再进行写入操作，同样读取也是类似。如果是中文，在gbk中一般一个中文占用两个字节，如果通过字节流的方式只读取一个字节，是无法转编码为一个中文汉字。\n\n而字符流就是为了解决这种问题，如果用字符流去读取，字符流会根据默认编码一次性的读取一个字符，即若若是gbk编码就会一次读取2个字节。因此字符流是根据字符所占字节大小而决定读取多少字节的。这就是字符流和字节流的本质不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569056304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2515671,"avatar":"https://static001.geekbang.org/account/avatar/00/26/62/d7/5af04692.jpg","nickname":"年轻的老罗","note":"","ucode":"37484C25034D45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387794,"discussion_content":"字节流也可以啊，字符流主是为了让字符操作更加方便而已。底层还是字节流，只是包装了一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628417125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2053679,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/56/2f/4518f8e1.jpg","nickname":"放不下荣华富贵","note":"","ucode":"9FE29C22B9ABE3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297431,"discussion_content":"读取字节流，最终生成字符串时指定编码也可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596937706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396945,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epaH1gHotWQukHnF2QtT2oK9hGvyLfSaKSzuC9XKH5aSWZj2KNrxYGJeNeVzIeAibzypibsmeicppGvA/132","nickname":"魂斗罗丶","note":"","ucode":"6BEA5CD3CCC2B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2053679,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/56/2f/4518f8e1.jpg","nickname":"放不下荣华富贵","note":"","ucode":"9FE29C22B9ABE3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":379951,"discussion_content":"但是字符串有两个字节的，也有三个字节的，判断起来很麻烦，字符流不需要自己去判断，只需要指定编码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624259871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297431,"ip_address":""},"score":379951,"extra":""}]}]},{"had_liked":false,"id":101311,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1559781124,"is_pvip":false,"replies":[{"id":"36877","content":"对的，异步I&#47;O模型在Linux内核中没有实现","user_name":"作者回复","comment_id":101311,"uid":"1228576","ip_address":"","utype":1,"ctime":1560175208,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"207718211332","product_id":100028001,"comment_content":"在Linux中，AIO并未真正使用操作系统所提供的异步I&#47;O，它仍然使用poll或epoll，并将API封装为异步I&#47;O的样子，但是其本质仍然是同步非阻塞I&#47;O，加上第三方产品的出现，Java网络编程明显落后，所以没有成为主流","like_count":48,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452905,"discussion_content":"对的，异步I/O模型在Linux内核中没有实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1560175208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101426,"user_name":"Only now","can_delete":false,"product_type":"c1","uid":1038574,"ip_address":"","ucode":"C617473A03AE27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg","comment_is_top":false,"comment_ctime":1559805571,"is_pvip":false,"replies":[{"id":"36607","content":"一个设备接口试图通过总线直接向外部设备(磁盘)传送数据时，它会先向CPU发送DMA请求信号。外部设备(磁盘)通过DMA的一种专门接口电路――DMA控制器（DMAC），向CPU提出接管总线控制权的总线请求，CPU收到该信号后，在当前的总线周期结束后，会按DMA信号的优先级和提出DMA请求的先后顺序响应DMA信号。CPU对某个设备接口响应DMA请求时，会让出总线控制权。于是在DMA控制器的管理下，磁盘和存储器直接进行数据交换，而不需CPU干预。数据传送完毕后，设备接口会向CPU发送DMA结束信号，交还总线控制权。<br><br>而通道则是在DMA的基础上增加了能执行有限通道指令的I&#47;O控制器，代替CPU管理控制外设。通道有自己的指令系统，是一个协处理器，他实质是一台能够执行有限的输入输出指令，并且有专门通讯传输的通道总线完成控制。","user_name":"作者回复","comment_id":101426,"uid":"1228576","ip_address":"","utype":1,"ctime":1559872111,"user_name_real":"刘超"}],"discussion_count":3,"race_medal":0,"score":"199128301187","product_id":100028001,"comment_content":"老师能不能讲讲DMA和Channel的区别, DMA需要占用总线, 那么Channel是如何跳过总线向内存传输数据的?","like_count":47,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452959,"discussion_content":"一个设备接口试图通过总线直接向外部设备(磁盘)传送数据时，它会先向CPU发送DMA请求信号。外部设备(磁盘)通过DMA的一种专门接口电路――DMA控制器（DMAC），向CPU提出接管总线控制权的总线请求，CPU收到该信号后，在当前的总线周期结束后，会按DMA信号的优先级和提出DMA请求的先后顺序响应DMA信号。CPU对某个设备接口响应DMA请求时，会让出总线控制权。于是在DMA控制器的管理下，磁盘和存储器直接进行数据交换，而不需CPU干预。数据传送完毕后，设备接口会向CPU发送DMA结束信号，交还总线控制权。\n\n而通道则是在DMA的基础上增加了能执行有限通道指令的I/O控制器，代替CPU管理控制外设。通道有自己的指令系统，是一个协处理器，他实质是一台能够执行有限的输入输出指令，并且有专门通讯传输的通道总线完成控制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559872111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282039,"avatar":"https://static001.geekbang.org/account/avatar/00/13/8f/f7/9b59c019.jpg","nickname":"内卷改变命运","note":"","ucode":"928F29B8C1F60D","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45659,"discussion_content":"那通道需要硬件的支持吗？I/O控制器是硬件吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573053917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1879918,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/af/6e/30fb83f1.jpg","nickname":"xaviers","note":"","ucode":"58D51C4DDC5BA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":247780,"discussion_content":"那通道需要硬件的支持吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587824644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101391,"user_name":"皮皮","can_delete":false,"product_type":"c1","uid":1156624,"ip_address":"","ucode":"D692CFAA982137","user_header":"https://static001.geekbang.org/account/avatar/00/11/a6/10/3ff2e1a5.jpg","comment_is_top":false,"comment_ctime":1559797562,"is_pvip":true,"replies":[{"id":"36575","content":"你好，这篇I&#47;O性能优化主要是普及NIO对I&#47;O的性能优化。I&#47;O这块的知识点很多，包括IO模型、事件处理模型以及操作系统层的事件驱动，如果都压缩到一讲，由于字数有限，很难讲完整。对于一些童鞋来说，也不好理解。<br><br><br>我将会在后面的一讲中，补充大家提到的一些内容。谢谢你的建议。","user_name":"作者回复","comment_id":101391,"uid":"1228576","ip_address":"","utype":1,"ctime":1559823684,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"117523914554","product_id":100028001,"comment_content":"老师，个人觉得本期的内容讲的稍微浅了一点，关于IO的几种常见模型可以配图讲一下的，另外就是linux下的select，poll，epoll的对比应用场景。最重要的目前用的最多的IO多路复用可以深入讲一下的。","like_count":27,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452942,"discussion_content":"你好，这篇I/O性能优化主要是普及NIO对I/O的性能优化。I/O这块的知识点很多，包括IO模型、事件处理模型以及操作系统层的事件驱动，如果都压缩到一讲，由于字数有限，很难讲完整。对于一些童鞋来说，也不好理解。\n\n\n我将会在后面的一讲中，补充大家提到的一些内容。谢谢你的建议。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559823684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101568,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1121187,"ip_address":"","ucode":"B7E49B7C772036","user_header":"https://static001.geekbang.org/account/avatar/00/11/1b/a3/64a37f40.jpg","comment_is_top":false,"comment_ctime":1559873696,"is_pvip":false,"replies":[{"id":"36875","content":"这一讲中提到了DirectBuffer，也就是零拷贝的实现。谢谢你的建议，后面我会补充下几种网络I&#47;O模型的底层原理。","user_name":"作者回复","comment_id":101568,"uid":"1228576","ip_address":"","utype":1,"ctime":1560174667,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"57394448544","product_id":100028001,"comment_content":"很多知识linux 网络 I&#47;O模型底层原理，零拷贝技术等深入讲一下，毕竟学Java性能调优的学员都是有几年工作经验的， 希望老师后面能专门针对这次io 出个补充，这一讲比较不够深入。","like_count":13,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453017,"discussion_content":"这一讲中提到了DirectBuffer，也就是零拷贝的实现。谢谢你的建议，后面我会补充下几种网络I/O模型的底层原理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560174667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105389,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1560991761,"is_pvip":false,"replies":[{"id":"71195","content":"李老师说的对的","user_name":"作者回复","comment_id":105389,"uid":"1228576","ip_address":"","utype":1,"ctime":1583159646,"user_name_real":"刘超"}],"discussion_count":6,"race_medal":0,"score":"48805632017","product_id":100028001,"comment_content":"老师好!隔壁的李好双老师说一次普通IO需要要进过六次拷贝。<br>网卡-&gt;内核-&gt;临时本地内存-&gt;堆内存-&gt;临时本地内存-&gt;内核-&gt;网卡。<br>directbfuffer下<br>网卡-&gt;内核-&gt;本地内存-&gt;内核-&gt;网卡<br>ARP下C直接调用<br>文件-&gt;内核-&gt;网卡。<br>李老师说的对么?<br>本地内存和堆内存都是在用户空间的是么?","like_count":11,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454660,"discussion_content":"李老师说的对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583159646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1106929,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e3/f1/346bd356.jpg","nickname":"Bruce","note":"","ucode":"B2F562F717BD3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261733,"discussion_content":"MappedByteBuffer这个是网卡->本地内存，一步到位更狠","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588999721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1106929,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e3/f1/346bd356.jpg","nickname":"Bruce","note":"","ucode":"B2F562F717BD3C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344814,"discussion_content":"MappedByteBuffer这个是网卡->本地内存, 从内核态到用户态\nARP是不经过用户空间,在内核中 磁盘->内核->网卡 . \n作用不同吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611578399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261733,"ip_address":""},"score":344814,"extra":""}]},{"author":{"id":1348830,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/SM4fwn9uFicXU8cQ1rNF2LQdKNbZI1FX1jmdwaE2MTrBawbugj4TQKjMKWG0sGbmqQickyARXZFS8NZtobvoWTHA/132","nickname":"td901105","note":"","ucode":"32D42A4F36FA02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72672,"discussion_content":"directorbuffer下只是减少了用户空间一次复制吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575514111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300701,"discussion_content":"李好双 在哪个隔壁？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598238481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1184542,"avatar":"https://static001.geekbang.org/account/avatar/00/12/13/1e/00f574c1.jpg","nickname":"随遇而安","note":"","ucode":"6D2D0FF9B434AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4527,"discussion_content":"感觉是吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565520674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158845,"user_name":"td901105","can_delete":false,"product_type":"c1","uid":1348830,"ip_address":"","ucode":"32D42A4F36FA02","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SM4fwn9uFicXU8cQ1rNF2LQdKNbZI1FX1jmdwaE2MTrBawbugj4TQKjMKWG0sGbmqQickyARXZFS8NZtobvoWTHA/132","comment_is_top":false,"comment_ctime":1575464249,"is_pvip":false,"replies":[{"id":"60848","content":"阻塞线程在阻塞状态是不会占用CPU资源的，但是会被唤醒争夺CPU资源。操作系统将CPU轮流分配给线程任务，当线程数量越多的时候，当某个线程在规定的时间片运行完之后，会被其他线程抢夺CPU资源，此时会导致上下文切换。抢夺越激烈，上下文切换就越频繁。","user_name":"作者回复","comment_id":158845,"uid":"1228576","ip_address":"","utype":1,"ctime":1575537180,"user_name_real":"刘超"}],"discussion_count":3,"race_medal":0,"score":"44525137209","product_id":100028001,"comment_content":"在少量连接请求的情况下，使用这种方式没有问题，响应速度也很高。但在发生大量连接请求时，就需要创建大量监听线程，这时如果线程没有数据就绪就会被挂起，然后进入阻塞状态。一旦发生线程阻塞，这些线程将会不断地抢夺 CPU 资源，从而导致大量的 CPU 上下文切换，增加系统的性能开销。<br><br>后面一句一旦发生线程阻塞，这些线程会不断的抢夺CPU资源，从而导致大量的CPU进行上下文切换，增加系统开销，这一句不是太明白，能解释一下吗？阻塞线程不是不会占用CPU资源吗？","like_count":10,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476871,"discussion_content":"阻塞线程在阻塞状态是不会占用CPU资源的，但是会被唤醒争夺CPU资源。操作系统将CPU轮流分配给线程任务，当线程数量越多的时候，当某个线程在规定的时间片运行完之后，会被其他线程抢夺CPU资源，此时会导致上下文切换。抢夺越激烈，上下文切换就越频繁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575537180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147711,"avatar":"https://static001.geekbang.org/account/avatar/00/11/83/3f/bc2ea80d.jpg","nickname":"陌.寒哲","note":"","ucode":"B7079FF211D712","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106196,"discussion_content":"不理解作者说这些线程被唤醒争夺cpu是什么情况，期待详细说明一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577521083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147711,"avatar":"https://static001.geekbang.org/account/avatar/00/11/83/3f/bc2ea80d.jpg","nickname":"陌.寒哲","note":"","ucode":"B7079FF211D712","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106193,"discussion_content":"被阻塞的等待io的线程不会被唤醒的啊，只有io数据就绪了，发出中断，才会被设置标记位加入到就绪队列吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577520996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131702,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1567857936,"is_pvip":false,"replies":[{"id":"51132","content":"总结的很好，这章后面需要再优化","user_name":"作者回复","comment_id":131702,"uid":"1228576","ip_address":"","utype":1,"ctime":1568538926,"user_name_real":"刘超"}],"discussion_count":2,"race_medal":0,"score":"35927596304","product_id":100028001,"comment_content":"课后思考及问题<br>1本文核心观点<br>1-1：JAVA IO操作为啥分为字节流和字符流？我们知道字符到字节必须经过转码，这个过程非常耗时，如果我们不知道编码类型就很容易出现乱码问题。所以 I&#47;O 流提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。<br>有个疑问，字符流虽然在不知道其编码类型的情况下可以操作，不过一旦需要进行网络传输了，还是必须要知道的？<br>1-2：一次读取数据的操作流程，如下<br>用户空间—请求数据—内核空间—请求数据—数据存储设备—响应数据—内核空间—响应数据—用户空间，应用程序从用户空间的数据缓存区中读取数据，数据以字节流的形式流转。这种方式数据经过了两次复制过程，比较耗性能。<br>1-3：传统IO耗性能的地方主要有两点，一是数据从从存储设备到应用程序中经历了两次复制，二是数据的处理方式是阻塞式的<br>1-4：NIO快就快在解决了传统IO的两个耗性能的问题，一是减少复制次数，二是数据处理线程不再阻塞，为此增加了缓存区+通道+多路复用选择器+操作系统数据缓存区<br>对比来看，感觉老师讲的有点凌乱，IO网络通信模型，我在很多的课程上都学过，这个几乎讲到高性能这一块是必讲的，极客时间里有好几个专栏里也都有讲，大概原理还行，不过体系和细致成度一般，可能是篇幅有限吧!<br>我见过最通俗易懂的讲解就是netty权威指南的李林峰，用了好几章来讲解这一块的内容。<br>他从IO的历史演进来讲，一个个IO通信模型是怎么来的？前一个有什么问题？后一个基本是为了解决前一个的问题而来的，以及具体是怎么解决的？<br>磁盘或网络IO由于其内部结构决定和内存、各级缓存、CUP的速度有巨大的鸿沟，写操作系统的大神们和JDK的大神都清楚，所以，他们也都在绞尽脑汁来通过其他方式来尽量的解决这些问题。<br>希望他们的脑汁没没白绞，真心能明白他们绞尽脑汁后都产生了什么牛逼的方案。<br>非阻塞、零拷贝、多路复用选择器、Reactor、Preactor、DMA、epoll、通道这些概念有些理解啦有些还没，不过性能优化的原则没变还是那一套。<br>","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466579,"discussion_content":"总结的很好，这章后面需要再优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568538926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2053679,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/56/2f/4518f8e1.jpg","nickname":"放不下荣华富贵","note":"","ucode":"9FE29C22B9ABE3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297440,"discussion_content":"1-3 不止2次复制吧，用户空间内 堆内存到 临时本地内存 好像也要copy一次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596938632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124640,"user_name":"仙道","can_delete":false,"product_type":"c1","uid":1161146,"ip_address":"","ucode":"CF35D34B484B71","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/ba/ae4cabd8.jpg","comment_is_top":false,"comment_ctime":1565935211,"is_pvip":false,"replies":[{"id":"51146","content":"1、阻塞会引起上下文切换，文中强调的是上下文切换；<br>2、如果能读到则是一样的。在没有bytebuff缓存的情况下，一旦读取数据的SO_RCVBUF满了，将会通知对端TCP协议中的窗口关闭（滑动窗口），将影响TCP发送端，这也就影响到了整个TCP通信的速度。而有了bytebuff，我们可以先将读取的数据缓存在bytebuff中，提高TCP的通信能力。","user_name":"作者回复","comment_id":124640,"uid":"1228576","ip_address":"","utype":1,"ctime":1568541307,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"35925673579","product_id":100028001,"comment_content":"有两个地方理解不了，请老师指点一下。<br>1.传统io请求数据没有的话就会挂起进入阻塞状态，既然进入了阻塞状态文中为什么还会说会继续强悍cpu。<br>2，传统io对文件边读边处理，NIO一次性将文件读到缓冲区，就这样的话问什么说NIO要快？我觉得单是读取的时间花费的是一样的","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463257,"discussion_content":"1、阻塞会引起上下文切换，文中强调的是上下文切换；\n2、如果能读到则是一样的。在没有bytebuff缓存的情况下，一旦读取数据的SO_RCVBUF满了，将会通知对端TCP协议中的窗口关闭（滑动窗口），将影响TCP发送端，这也就影响到了整个TCP通信的速度。而有了bytebuff，我们可以先将读取的数据缓存在bytebuff中，提高TCP的通信能力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568541307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154945,"user_name":"Haies","can_delete":false,"product_type":"c1","uid":1587912,"ip_address":"","ucode":"1972ECAA5B4C59","user_header":"https://static001.geekbang.org/account/avatar/00/18/3a/c8/7e75d165.jpg","comment_is_top":false,"comment_ctime":1574602675,"is_pvip":false,"replies":[{"id":"60141","content":"1、是通一个directbuffer，是一个临时堆外内存；<br>2、就是DMA处理器；<br>3、内存处理比磁盘处理的IO好很多。","user_name":"作者回复","comment_id":154945,"uid":"1228576","ip_address":"","utype":1,"ctime":1574941891,"user_name_real":"刘超"}],"discussion_count":2,"race_medal":0,"score":"23049439155","product_id":100028001,"comment_content":"讲的很精炼，不过有三个问题没明白<br>1.图2的directbuffer是不是临时直接内存，和文中提到的DirectBuffer应该不是一回事吧。<br>2.Chanel有自己的处理器，这个何解？<br>3.传统I&#47;O使用buffer后，是不是处理单位也变成块了，怎么可以优化阻塞的问题呢，不太明白？","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475619,"discussion_content":"1、是通一个directbuffer，是一个临时堆外内存；\n2、就是DMA处理器；\n3、内存处理比磁盘处理的IO好很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574941891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1587912,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3a/c8/7e75d165.jpg","nickname":"Haies","note":"","ucode":"1972ECAA5B4C59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77078,"discussion_content":"谢谢，收获很大，虽然在有的人眼里很简单","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575887109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185760,"user_name":"昨夜的柠檬","can_delete":false,"product_type":"c1","uid":1125511,"ip_address":"","ucode":"C5829C29FB3E34","user_header":"https://static001.geekbang.org/account/avatar/00/11/2c/87/9a3d80dc.jpg","comment_is_top":false,"comment_ctime":1583676054,"is_pvip":false,"replies":[{"id":"72169","content":"没有找到相关描述，文中是这样描述的：一旦发生线程阻塞，这些线程将会不断地抢夺 CPU 资源，从而导致大量的 CPU 上下文切换，增加系统的性能开销。<br><br>阻塞线程在阻塞状态是不会占用CPU资源的，但是会被唤醒争夺CPU资源。操作系统将CPU轮流分配给线程任务，当线程数量越多的时候，当某个线程在规定的时间片运行完之后，会被其他线程抢夺CPU资源，此时会导致上下文切换。抢夺越激烈，上下文切换就越频繁。<br>","user_name":"作者回复","comment_id":185760,"uid":"1228576","ip_address":"","utype":1,"ctime":1584012476,"user_name_real":"刘超"}],"discussion_count":2,"race_medal":0,"score":"18763545238","product_id":100028001,"comment_content":"文中说，多线程阻塞时，会占用大量CPU资源。线程阻塞应该会让出CPU吧？","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486488,"discussion_content":"没有找到相关描述，文中是这样描述的：一旦发生线程阻塞，这些线程将会不断地抢夺 CPU 资源，从而导致大量的 CPU 上下文切换，增加系统的性能开销。\n\n阻塞线程在阻塞状态是不会占用CPU资源的，但是会被唤醒争夺CPU资源。操作系统将CPU轮流分配给线程任务，当线程数量越多的时候，当某个线程在规定的时间片运行完之后，会被其他线程抢夺CPU资源，此时会导致上下文切换。抢夺越激烈，上下文切换就越频繁。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584012476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2410305,"avatar":"","nickname":"_sulei","note":"","ucode":"05E4999D1183C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348893,"discussion_content":"作者这里没说清楚，个人猜测，作者想表达的意思是一旦某个线程发生阻塞，该线程就会让出CPU，让出的CPU资源会被其他线程抢夺，造成上下文切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612770129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203741,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1586261406,"is_pvip":false,"replies":[{"id":"77111","content":"这里说的GC，指的是Minor GC，这里不会导致内存泄漏，会被回收的","user_name":"作者回复","comment_id":203741,"uid":"1228576","ip_address":"","utype":1,"ctime":1586863592,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"10176195998","product_id":100028001,"comment_content":"如果单纯使用 Java 堆内存进行数据拷贝，当拷贝的数据量比较大的情况下，Java 堆的 GC 压力会比较大，而使用非堆内存可以减低 GC 的压力。<br><br><br><br><br>为何GC压力会比较大呢？只能说是没法回收导致内存泄漏吧。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490946,"discussion_content":"这里说的GC，指的是Minor GC，这里不会导致内存泄漏，会被回收的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586863592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148770,"user_name":"天星之主","can_delete":false,"product_type":"c1","uid":1350730,"ip_address":"","ucode":"7BC9E42B2280F4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJYEdMwBDUC6lDsNOFlRxdOXkUheMKUTWpYtK1KRuGGicS2dwyrKiasicvk1A1A8dExlRXkx5iaX4Xdjw/132","comment_is_top":false,"comment_ctime":1573084292,"is_pvip":false,"replies":[{"id":"57827","content":"direct buffer是用户态内存，已更新这一小节","user_name":"作者回复","comment_id":148770,"uid":"1228576","ip_address":"","utype":1,"ctime":1573530869,"user_name_real":"刘超"}],"discussion_count":3,"race_medal":0,"score":"10163018884","product_id":100028001,"comment_content":"“DirectBuffe直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝”，direct buffer申请的非堆内存，只是不受JVM管控，不应该还是用户态的内存吗","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473603,"discussion_content":"direct buffer是用户态内存，已更新这一小节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573530869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3f/be/c7141382.jpg","nickname":"是KK呀","note":"","ucode":"5DCEB53A13D049","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129800,"discussion_content":"应该是直接将用户态复制到外部设备吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578739663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1064894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3f/be/c7141382.jpg","nickname":"是KK呀","note":"","ucode":"5DCEB53A13D049","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344816,"discussion_content":"是优化了用户态中的额外一次拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611578463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":129800,"ip_address":""},"score":344816,"extra":""}]}]},{"had_liked":false,"id":104399,"user_name":"al-byte","can_delete":false,"product_type":"c1","uid":1466744,"ip_address":"","ucode":"D0298A02E9259D","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/78/e7aa4e04.jpg","comment_is_top":false,"comment_ctime":1560744384,"is_pvip":false,"replies":[{"id":"37867","content":"是的。如果I&#47;O操作时间比较长，我们可以创建新的一个线程来执行I&#47;O操作，避免阻塞Reactor从线程。","user_name":"作者回复","comment_id":104399,"uid":"1228576","ip_address":"","utype":1,"ctime":1560821739,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"10150678976","product_id":100028001,"comment_content":"我们可以在注册 Channel 时设置该通道为非阻塞，当 Channel 上没有 I&#47;O 操作时，该线程就不会一直等待了，而是会不断轮询所有 Channel，从而避免发生阻塞。<br>如果一个Channel上I&#47;O耗时很长是不是后续的Channel就被阻塞了？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454257,"discussion_content":"是的。如果I/O操作时间比较长，我们可以创建新的一个线程来执行I/O操作，避免阻塞Reactor从线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560821739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104143,"user_name":"小荷才露尖尖角","can_delete":false,"product_type":"c1","uid":1068480,"ip_address":"","ucode":"C74284B1FEA6BB","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/c0/7313033b.jpg","comment_is_top":false,"comment_ctime":1560664871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150599463","product_id":100028001,"comment_content":"谢谢老师！ 我觉得从基础讲起再深入挺好的 有逻辑与层次感， 一上来就是好高深的内容 就会让一半道行没够的同学放弃治疗了。","like_count":2},{"had_liked":false,"id":220885,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1590333785,"is_pvip":true,"replies":[{"id":"82345","content":"抢夺资源的整段时间维度去衡量，非自愿的上下文切换会降低线程的CPU使用效率，使得大量时间消耗在寄存器和计数器的存取之间。最直观的是查看非自愿上下文切换次数以及系统的负载。","user_name":"作者回复","comment_id":220885,"uid":"1228576","ip_address":"","utype":1,"ctime":1591102315,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"5885301081","product_id":100028001,"comment_content":"老师在评论中的下面这段话<br>阻塞线程在阻塞状态是不会占用CPU资源的，但是会被唤醒争夺CPU资源。操作系统将CPU轮流分配给线程任务，当线程数量越多的时候，当某个线程在规定的时间片运行完之后，会被其他线程抢夺CPU资源，此时会导致上下文切换。抢夺越激烈，上下文切换就越频繁。<br><br>这里抢夺越激烈，上下文切换越频繁有点不太理解，如果只是单次抢夺操作，最后不都只有一个线程抢夺到CPU从而进行一次上下文切换吗？还是这里是以抢夺资源的这整段时间维度去衡量理解的","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496261,"discussion_content":"抢夺资源的整段时间维度去衡量，非自愿的上下文切换会降低线程的CPU使用效率，使得大量时间消耗在寄存器和计数器的存取之间。最直观的是查看非自愿上下文切换次数以及系统的负载。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591102315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210800,"user_name":"xaviers","can_delete":false,"product_type":"c1","uid":1879918,"ip_address":"","ucode":"58D51C4DDC5BA8","user_header":"https://static001.geekbang.org/account/avatar/00/1c/af/6e/30fb83f1.jpg","comment_is_top":false,"comment_ctime":1587826583,"is_pvip":false,"replies":[{"id":"78608","content":"来回读写，由用户态到内核态的切换耗时，减少用户态和内核态的切换，性能更佳","user_name":"作者回复","comment_id":210800,"uid":"1228576","ip_address":"","utype":1,"ctime":1587987214,"user_name_real":"刘超"}],"discussion_count":2,"race_medal":0,"score":"5882793879","product_id":100028001,"comment_content":"老师，有个疑问。<br>Buffer 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。<br>按说边读文件边处理应该更快呀","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493111,"discussion_content":"来回读写，由用户态到内核态的切换耗时，减少用户态和内核态的切换，性能更佳","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587987214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1879918,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/af/6e/30fb83f1.jpg","nickname":"xaviers","note":"","ucode":"58D51C4DDC5BA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250050,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587987517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121388,"user_name":"袁林","can_delete":false,"product_type":"c1","uid":1106081,"ip_address":"","ucode":"2FD37F7F2E25FF","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/a1/d1c6f0a7.jpg","comment_is_top":false,"comment_ctime":1565132262,"is_pvip":false,"replies":[{"id":"73039","content":"DirectBuffer 是直接内存，这里的减少复制是减少JVM内存到直接内存的复制","user_name":"作者回复","comment_id":121388,"uid":"1228576","ip_address":"","utype":1,"ctime":1584536547,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"5860099558","product_id":100028001,"comment_content":"根据 ‘使用 DirectBuffer 减少内存复制’ 这段描述 DirectBuffer 申请的应该是内核的内存，这是如何实现的？unix使用的是哪些系统调用？<br>还请解答","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461772,"discussion_content":"DirectBuffer 是直接内存，这里的减少复制是减少JVM内存到直接内存的复制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584536547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120619,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1564962450,"is_pvip":false,"replies":[{"id":"72199","content":"减少了一次中间拷贝。 Java 堆内存中拷贝到临时的直接内存中，通过临时的直接内存拷贝到内核空间中去，而NIO中的DirectBuffer是直接内存，我们无需再在JVM内存中创建对象，再拷贝到直接内存中去了，而是在直接内存中创建对象，减少了一次拷贝。","user_name":"作者回复","comment_id":120619,"uid":"1228576","ip_address":"","utype":1,"ctime":1584017774,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"5859929746","product_id":100028001,"comment_content":"<br>请问老师，我理解传统bio之所以慢是因为它要等待数据从磁盘到内核空间再到用户空间，由于经过两次复制数据所以慢。<br>我没太理解nio是快在哪？只有用户空间直接到磁盘一次的复制？具体是怎么实现的呢？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461406,"discussion_content":"减少了一次中间拷贝。 Java 堆内存中拷贝到临时的直接内存中，通过临时的直接内存拷贝到内核空间中去，而NIO中的DirectBuffer是直接内存，我们无需再在JVM内存中创建对象，再拷贝到直接内存中去了，而是在直接内存中创建对象，减少了一次拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584017774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102251,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1090784,"ip_address":"","ucode":"563C4A71D80DA1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJwQvLGE4dMsF4JU0svW3DtGbodpjskbY65FdwF13JdtBYZfgL2IXHlHrdejWzHdjT0RibEIfib4QYA/132","comment_is_top":false,"comment_ctime":1560170510,"is_pvip":false,"replies":[{"id":"36878","content":"答案已经有同学给出了，异步I&#47;O没有在Linux内核中实现","user_name":"作者回复","comment_id":102251,"uid":"1228576","ip_address":"","utype":1,"ctime":1560175306,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"5855137806","product_id":100028001,"comment_content":"思考题：是因为会很耗费cpu吗？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453315,"discussion_content":"答案已经有同学给出了，异步I/O没有在Linux内核中实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560175306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101408,"user_name":"vvsuperman","can_delete":false,"product_type":"c1","uid":1021518,"ip_address":"","ucode":"F393A3FB894124","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/4e/2acbc3a8.jpg","comment_is_top":false,"comment_ctime":1559802715,"is_pvip":false,"replies":[{"id":"36583","content":"感谢这位同学的建议，老师会在11讲中集中补充有关IO的一些实战内容。","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1559834231,"ip_address":"","comment_id":101408,"utype":2}],"discussion_count":1,"race_medal":0,"score":"5854770011","product_id":100028001,"comment_content":"建议加写例子，比如tomcat用的io造成阻塞之类，实例分析等","like_count":1,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452952,"discussion_content":"感谢这位同学的建议，老师会在11讲中集中补充有关IO的一些实战内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559834231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101395,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1559799558,"is_pvip":false,"replies":[{"id":"57828","content":"是的，directBuffer也是属于用户空间，directbuffer的零拷贝指的是通过allocate分配直接内存空间，减少堆内存与直接内存的复制，NIO中还存在一个MappedByteBuffer类，该类通过调用mmap系统方法通过内存映射的方式拷贝数据，减少用户空间到内核空间的拷贝，而kafka的拷贝也是基于内存映射的方式实现的零拷贝。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573531484,"ip_address":"","comment_id":101395,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5854766854","product_id":100028001,"comment_content":"老师好!能说下哪些操作需要在用户态下完成么?正常的代码运行用户态就可以了是吗?<br>1.创建selector<br>2.创建serverSockekChannel<br>3.OP_ACCEPT事件注册到selector中<br>4.监听到OP_ACCEPT事件<br>5.创建channel<br>6.OP_READ事件注册到selector中<br>7.监听到READ事件<br>8.从channel中读数据<br>读的时候需要先切换到内核模式，复制在内核空间，然后从内核空间复制到用户空间。<br>9.处理数据 <br>10.write:用户模式切换到内核模式，从用户空间复制到内核空间，再从内核空间发送到IO网络上。<br>1-7步里面有哪些操作需要在内核模式下执行的么?<br><br>第8和10我是不是理解错了?<br>DMA啥时候起作用啊?<br><br>JVM的内存属于用户空间是吧，directBuffer直接申请的物理内存，是属于特殊的用户空间么。内核模式直接往那里写。kafka的0拷贝和directbuffer一个意思么?╯﹏╰都不知道<br>","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452944,"discussion_content":"是的，directBuffer也是属于用户空间，directbuffer的零拷贝指的是通过allocate分配直接内存空间，减少堆内存与直接内存的复制，NIO中还存在一个MappedByteBuffer类，该类通过调用mmap系统方法通过内存映射的方式拷贝数据，减少用户空间到内核空间的拷贝，而kafka的拷贝也是基于内存映射的方式实现的零拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573531484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355309,"user_name":"薇薇","can_delete":false,"product_type":"c1","uid":2850180,"ip_address":"湖北","ucode":"6A0C2380FC3EB6","user_header":"https://static001.geekbang.org/account/avatar/00/2b/7d/84/3453fa29.jpg","comment_is_top":false,"comment_ctime":1661257046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661257046","product_id":100028001,"comment_content":"老师能不能多给点代码","like_count":0},{"had_liked":false,"id":352036,"user_name":"Carla","can_delete":false,"product_type":"c1","uid":1181454,"ip_address":"","ucode":"29608BF359A567","user_header":"","comment_is_top":false,"comment_ctime":1658361600,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658361600","product_id":100028001,"comment_content":"directbytebuffer继承了mappedbytebuffer，意思是directbytebuffer同时优化了jvm堆的内存拷贝和系统空间的拷贝","like_count":0},{"had_liked":false,"id":345940,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1652706236,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652706236","product_id":100028001,"comment_content":"一、字节流与的区别？<br>①  字节流本身也是基于字节流的一层包装；<br><br>②  字符流的目的是给流制定编码（因为不同字符集编码单个字符所占的字节是不一样的）；<br><br>二、InputStream&#47;OutputStream是字节输入输出流的顶层父类；<br>三、Reader&#47;Writer是字符流的顶层父类；<br><br>四、nio高性能的三大利器<br>    ①  Buffer（使用缓存优化读写流操作，Buffer 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据）；<br><br>    ②  Channel（Channel是双向的可以同时进行数据的读写）；<br><br>    ③  Selector（Selector 是基于事件驱动实现的，我们可以在 Selector 中注册 accpet、read 监听事件，Selector 会不断轮询注册在其上的 Channel，如果某个 Channel 上面发生监听事件，这个 Channel 就处于就绪状态，然后进行 I&#47;O 操作，一个线程使用一个 Selector，通过轮询的方式，可以监听多个 Channel 上的事件。我们可以在注册 Channel 时设置该通道为非阻塞，当 Channel 上没有 I&#47;O 操作时，该线程就不会一直等待了，而是会不断轮询所有 Channel，从而避免发生阻塞）；<br><br><br><br>","like_count":0},{"had_liked":false,"id":341594,"user_name":"qwer","can_delete":false,"product_type":"c1","uid":1330568,"ip_address":"","ucode":"0F6C7CFF6A7BF2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/rYeAeaGf6AicjvG14BwibZsNe8pdRFiaETSJIE7icDdBCicptRwQnzU1cFh9cfjN5OB6Drp9BxlIfEULc43HAr3R12A/132","comment_is_top":false,"comment_ctime":1649728671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649728671","product_id":100028001,"comment_content":"老师 java NIO 中的channel 和 硬件层面的IO 通道有没有关系呢？如果有关系 操作系统是如何切换DMA控制方式和IO 通道的","like_count":0},{"had_liked":false,"id":301898,"user_name":"余生","can_delete":false,"product_type":"c1","uid":2421369,"ip_address":"","ucode":"AEF6C96738F03B","user_header":"https://static001.geekbang.org/account/avatar/00/24/f2/79/b2012f53.jpg","comment_is_top":false,"comment_ctime":1625967252,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625967252","product_id":100028001,"comment_content":"普通的 Buffer 分配的是 JVM 堆内存，而 DirectBuffer 是直接分配物理内存 (非堆内存)。------分配物理内存是指什么? 物理内存是缺页中断产生时才分配的?","like_count":0},{"had_liked":false,"id":301897,"user_name":"余生","can_delete":false,"product_type":"c1","uid":2421369,"ip_address":"","ucode":"AEF6C96738F03B","user_header":"https://static001.geekbang.org/account/avatar/00/24/f2/79/b2012f53.jpg","comment_is_top":false,"comment_ctime":1625966556,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625966556","product_id":100028001,"comment_content":"虽然传统 I&#47;O 后面也使用了缓冲块，例如 BufferedInputStream，但仍然不能和 NIO 相媲美。使用 NIO 替代传统 I&#47;O 操作，可以提升系统的整体性能，效果立竿见影。------然后呢?","like_count":0},{"had_liked":false,"id":276387,"user_name":"猪大强","can_delete":false,"product_type":"c1","uid":1542577,"ip_address":"","ucode":"2DD393D247798C","user_header":"https://static001.geekbang.org/account/avatar/00/17/89/b1/9f9cfc19.jpg","comment_is_top":false,"comment_ctime":1611908163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611908163","product_id":100028001,"comment_content":"老师你好，<br>DirectBuffer 则是直接将步骤简化为数据直接保存到非堆内存，从而减少了一次数据拷贝。以下是 JDK 源码中 IOUtil.java 类中的 write 方法：<br>这句话不对呢，拷贝次数没有减少呢，只是一个是堆外内存，一个是堆内存，怎么就减少了一次拷贝呢<br><br>","like_count":0},{"had_liked":false,"id":270496,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609145916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609145916","product_id":100028001,"comment_content":"我们可以在注册 Channel 时设置该通道为非阻塞，当 Channel 上没有 I&#47;O 操作时，该线程就不会一直等待了，而是会不断轮询所有 Channel，从而避免发生阻塞。<br>老师的这一句话中避免线程阻塞使用轮循一直保持线程的可运行状态,这样会提升效率吗?线程又不工作,而且还导致其他线程无法获得资源工作.那不就是浪费资源吗?怎么还会提升效率呢?","like_count":0},{"had_liked":false,"id":264015,"user_name":"Geek_9d0e04","can_delete":false,"product_type":"c1","uid":1902220,"ip_address":"","ucode":"F5560CE5BDB125","user_header":"","comment_is_top":false,"comment_ctime":1606312190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606312190","product_id":100028001,"comment_content":"mmap直接从磁盘拷贝到用户空间，不使用pagecache吗？？如果是这样的话，那pagecache的预读功能，写合并功能都用不到了，性能是不是会很差？","like_count":0},{"had_liked":false,"id":249656,"user_name":"与路同飞","can_delete":false,"product_type":"c1","uid":1138821,"ip_address":"","ucode":"2985F1440A1962","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","comment_is_top":false,"comment_ctime":1600744572,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600744572","product_id":100028001,"comment_content":"使用AIO是基于异步非阻塞IO，但是异步非阻塞IO在linux上比没有完全实现。又因为大多数服务器都是linux，故很多框架仍然使用NIO","like_count":0},{"had_liked":false,"id":237299,"user_name":"苏籍","can_delete":false,"product_type":"c1","uid":1396252,"ip_address":"","ucode":"4FA289E084B789","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erYNBIwAj3KdIXaXbeMBUjTMz31zAToHIJSdo7oQk8bfsibwViaLobVQ8miatwBlC5spLS9kVCzHMjUA/132","comment_is_top":false,"comment_ctime":1595772116,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595772116","product_id":100028001,"comment_content":"为什么 Java 需要通过一个临时的非堆内存来复制数据呢？如果单纯使用 Java 堆内存进行数据拷贝，当拷贝的数据量比较大的情况下，Java 堆的 GC 压力会比较大，而使用非堆内存可以减低 GC 的压力。<br><br>________<br>为啥单纯使用 Java 堆内存进行数据拷贝 会对GC造成压力，拷贝的数据量不是一样的吗","like_count":0,"discussions":[{"author":{"id":1902220,"avatar":"","nickname":"Geek_9d0e04","note":"","ucode":"F5560CE5BDB125","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305145,"discussion_content":"同问，为啥单纯使用 Java 堆内存进行数据拷贝 会对GC造成压力，拷贝的数据量不是一样的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599794086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223944,"user_name":"Geek_f37119","can_delete":false,"product_type":"c1","uid":2014367,"ip_address":"","ucode":"8812B9C04CA735","user_header":"","comment_is_top":false,"comment_ctime":1591237286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591237286","product_id":100028001,"comment_content":"这句话啥意思，挂起了还怎么争抢cpu，只有活动队列才会争抢吧，挂起的不会占用cpu.<br><br>这时如果线程没有数据就绪就会被挂起，然后进入阻塞状态。一旦发生线程阻塞，这些线程将会不断地抢夺 CPU 资源，从而导致大量的 CPU 上下文切换，增加系统的性能开销。","like_count":0},{"had_liked":false,"id":210780,"user_name":"xaviers","can_delete":false,"product_type":"c1","uid":1879918,"ip_address":"","ucode":"58D51C4DDC5BA8","user_header":"https://static001.geekbang.org/account/avatar/00/1c/af/6e/30fb83f1.jpg","comment_is_top":false,"comment_ctime":1587824677,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1587824677","product_id":100028001,"comment_content":"老师，通道channel需要硬件的支持吗？channel和DAM之间的区别是啥？","like_count":0,"discussions":[{"author":{"id":2854129,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/8c/f1/1a55535d.jpg","nickname":"踏雪无痕","note":"","ucode":"BB426066431D4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573460,"discussion_content":"需要的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653446498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203846,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1586273540,"is_pvip":false,"replies":[{"id":"77115","content":"传统IO中，也有一个线程模型，可以进入这一节中的加餐篇详细阅读下","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1586863884,"ip_address":"","comment_id":203846,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586273540","product_id":100028001,"comment_content":"传统的 I&#47;O 即使使用了缓冲块，依然存在阻塞问题。由于线程池线程数量有限，一旦发生大量并发请求，超过最大数量的线程就只能等待<br><br><br>奇怪了 传统的IO和线程池有什么关系？？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490979,"discussion_content":"传统IO中，也有一个线程模型，可以进入这一节中的加餐篇详细阅读下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586863884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199284,"user_name":"10年以后","can_delete":false,"product_type":"c1","uid":1297421,"ip_address":"","ucode":"FE58CA7E5C2AF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/0d/89435926.jpg","comment_is_top":false,"comment_ctime":1585485780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585485780","product_id":100028001,"comment_content":"io","like_count":0},{"had_liked":false,"id":165722,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1577289101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577289101","product_id":100028001,"comment_content":"Buffer 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。<br>按说边读文件边处理应该更快呀。","like_count":0},{"had_liked":false,"id":144391,"user_name":"亚洲舞王.尼古拉斯赵四","can_delete":false,"product_type":"c1","uid":1443078,"ip_address":"","ucode":"7159F5D7232696","user_header":"https://static001.geekbang.org/account/avatar/00/16/05/06/f5979d65.jpg","comment_is_top":false,"comment_ctime":1571909771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571909771","product_id":100028001,"comment_content":"看具体情况的吧，通信框架并不是类似于向用户提供的接口，同时会有大量的访问，使用一个selector完全可以够用的情况下，创建多个线程去执行反而消耗资源","like_count":0},{"had_liked":false,"id":142861,"user_name":"greekw","can_delete":false,"product_type":"c1","uid":1216895,"ip_address":"","ucode":"B15DEA35C67B0D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKibjS2ia1BldGnI6gGcy89W5y3009dMXpsibpkWMIWK9Tks1omwT1HQjibuKWibcmegrpXztvB1BbrOaA/132","comment_is_top":false,"comment_ctime":1571566635,"is_pvip":false,"replies":[{"id":"72196","content":"加餐篇中讲到了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584017389,"ip_address":"","comment_id":142861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571566635","product_id":100028001,"comment_content":"老师，NIO模型里面的多路复用的线程机制能否讲下？还有零拷贝是怎么实现的？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471299,"discussion_content":"加餐篇中讲到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584017389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140761,"user_name":"Sdylan","can_delete":false,"product_type":"c1","uid":1008503,"ip_address":"","ucode":"4589D0D0FA9275","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/77/423345ab.jpg","comment_is_top":false,"comment_ctime":1571044342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571044342","product_id":100028001,"comment_content":"2019.10.14 打卡： 本文讲解太抽象了，最好集合例子来讲。","like_count":0},{"had_liked":false,"id":125689,"user_name":"没有小名的曲儿","can_delete":false,"product_type":"c1","uid":1434711,"ip_address":"","ucode":"0148681C0BAA7A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOn7k48KXia5nvt5VO0x0Fh7SN5MHrbglBAEUVicdRBFpFU3icvNmpjVXDaUVjY0vvic9OrTV5mBRqVQ/132","comment_is_top":false,"comment_ctime":1566227008,"is_pvip":false,"replies":[{"id":"51149","content":"尝试看看是否可分片并行处理。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568541730,"ip_address":"","comment_id":125689,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1566227008","product_id":100028001,"comment_content":"老师，我想请教一个问题，对于向服务器上传多张图片，服务器接收到后进行压缩或者合成pdf等类似的io操作，会占用很大的资源，我试着用线程池来规避数量可服务器还是承受不住这种压力，对于这种耗时比较长的操作您有什么建议吗","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463660,"discussion_content":"尝试看看是否可分片并行处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568541730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135585,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/e1/dd7b3206.jpg","nickname":"何義","note":"","ucode":"5DC5FB72D5AE00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96358,"discussion_content":"请问老师：你所说的分片指的是创建多个线程来同时复制或转换文件吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577061177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135585,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/e1/dd7b3206.jpg","nickname":"何義","note":"","ucode":"5DC5FB72D5AE00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96351,"discussion_content":"你是不是先使用nio，同时再使用多线程？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577061064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135585,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/e1/dd7b3206.jpg","nickname":"何義","note":"","ucode":"5DC5FB72D5AE00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96349,"discussion_content":"你好！这个问题解决了没有？我现在也是遇到类似的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577061028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123400,"user_name":"Geek_94aebf","can_delete":false,"product_type":"c1","uid":1466575,"ip_address":"","ucode":"AD67A6B8275126","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLXibzeMXGoTbe4me8gUjMYYMMdrz8XLJvqadmic3AQqbNvKn8Q1udpPuV83zt20ibSlSiciaqKnH02aDg/132","comment_is_top":false,"comment_ctime":1565667964,"is_pvip":false,"replies":[{"id":"51150","content":"是否可以改用分页查询呢？或者将重要信息先传输到页面，次要的通过单次点击查看。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568541819,"ip_address":"","comment_id":123400,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1565667964","product_id":100028001,"comment_content":"Java后台需求要返回几百上千条数据，数据是实时变化的，每次返回数据有几百k到几m不等，非常耗费网络带宽，现在单机带宽30m，该从哪些方面优化?","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462655,"discussion_content":"是否可以改用分页查询呢？或者将重要信息先传输到页面，次要的通过单次点击查看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568541819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053955,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","nickname":"考休","note":"","ucode":"968DFC00D6D0CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46082,"discussion_content":"我们业务有时候也会遇到这种问题，从经验上来看，大部分都是产品没有描述好设计导致的，其实绝大多数的业务都不需要一次性返回太多的数据，页面查看都是问题，基本都是都可以像老师说的采用分页、减少返回字段的方式来解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573117958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122755,"user_name":"Knight²º¹⁸","can_delete":false,"product_type":"c1","uid":1089754,"ip_address":"","ucode":"BDCB830B6A730F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg","comment_is_top":false,"comment_ctime":1565512559,"is_pvip":false,"replies":[{"id":"45088","content":"可以转到11讲，有详细答案","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565573389,"ip_address":"","comment_id":122755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565512559","product_id":100028001,"comment_content":"Java的IO模型和操作系统的关系是啥？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462390,"discussion_content":"可以转到11讲，有详细答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565573389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122334,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1181647,"ip_address":"","ucode":"46A2F679C094E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","comment_is_top":false,"comment_ctime":1565340939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565340939","product_id":100028001,"comment_content":"老师，您github上 NIO 的例子是不是没写完整呢，客户端好像收不到服务端的的回复消息（现在时间为：）,谢谢～","like_count":0},{"had_liked":false,"id":121750,"user_name":"袁林","can_delete":false,"product_type":"c1","uid":1106081,"ip_address":"","ucode":"2FD37F7F2E25FF","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/a1/d1c6f0a7.jpg","comment_is_top":false,"comment_ctime":1565218160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565218160","product_id":100028001,"comment_content":"根据 通道（Channel）一节的描述， channel貌似越过了硬件（DMA），请问顶层是如何实现的？","like_count":0},{"had_liked":false,"id":120982,"user_name":"晓晨同学","can_delete":false,"product_type":"c1","uid":1413041,"ip_address":"","ucode":"236AEEB786E2CE","user_header":"https://static001.geekbang.org/account/avatar/00/15/8f/b1/7b697ed4.jpg","comment_is_top":false,"comment_ctime":1565021649,"is_pvip":false,"replies":[{"id":"53048","content":"两者的buffer并没有什么区别","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569977980,"ip_address":"","comment_id":120982,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565021649","product_id":100028001,"comment_content":"请问老师，传统io中的buffer和nio中的buffer同样都在用户内存缓冲区，那么有什么区别呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461560,"discussion_content":"两者的buffer并没有什么区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569977980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120069,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1564769768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564769768","product_id":100028001,"comment_content":"老师，可以讲一下，直接缓冲区、内存映射地址、NIO零拷贝之间的关系么，我总觉得他们间好像很像，但是理不清","like_count":0},{"had_liked":false,"id":109724,"user_name":"飞鱼","can_delete":false,"product_type":"c1","uid":1168496,"ip_address":"","ucode":"F279F8F7FF6921","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/70/f093eaf0.jpg","comment_is_top":false,"comment_ctime":1562082546,"is_pvip":false,"replies":[{"id":"53415","content":"使用异步代替同步，提高系统的并发性能","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570435231,"ip_address":"","comment_id":109724,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562082546","product_id":100028001,"comment_content":"老师，请教个问题，如果是长连接下，高并发应该怎么样设计方案更合理呢，谢谢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456538,"discussion_content":"使用异步代替同步，提高系统的并发性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570435231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102814,"user_name":"Geek_37bdff","can_delete":false,"product_type":"c1","uid":1543318,"ip_address":"","ucode":"8FA018F44DE347","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqWJ2sP28ZpDp6uTCXOzpd1RYK4Lkf8ZspaNNwnqzVAN7we2rk7YPia3VDjCR0b3CAc3vVhGL8kEZg/132","comment_is_top":false,"comment_ctime":1560308154,"is_pvip":false,"replies":[{"id":"37218","content":"同学你好！周四即将更新的11讲答疑课堂就能解决你的问题。到时如有疑问，可以继续给老师留言。","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1560332194,"ip_address":"","comment_id":102814,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1560308154","product_id":100028001,"comment_content":"老师，您好，能通俗解释一下什么是同步阻塞，异步阻塞，同步非阻塞，异步非阻塞这些概念不，还有就是nio是属于同步非阻塞还是异步非阻塞，为什么","like_count":0,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453596,"discussion_content":"同学你好！周四即将更新的11讲答疑课堂就能解决你的问题。到时如有疑问，可以继续给老师留言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560332194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102004,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1560093188,"is_pvip":false,"replies":[{"id":"73038","content":"文章已修正。不是的，DirectBuffer是直接内存，也属于用户空间。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584536443,"ip_address":"","comment_id":102004,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560093188","product_id":100028001,"comment_content":"从文章的描述我猜测DirectBuffer属于内核空间的内存，但java作为用户进城是如何操作内核空间内存的呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453216,"discussion_content":"文章已修正。不是的，DirectBuffer是直接内存，也属于用户空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584536443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101885,"user_name":"Geek_801517","can_delete":false,"product_type":"c1","uid":1562114,"ip_address":"","ucode":"5163462AEE8226","user_header":"","comment_is_top":false,"comment_ctime":1560015033,"is_pvip":false,"replies":[{"id":"36704","content":"收到～老师会集中大家的留言，在11讲答疑课堂中做出补充讲解。感谢你的建议！","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1560018753,"ip_address":"","comment_id":101885,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1560015033","product_id":100028001,"comment_content":"老师，我也觉得今天的内容浅了一点，nio的多路复用也可以深入讲下或者netty的实现，epoll这些也是，还有其他io模型也可以对比下","like_count":0,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453158,"discussion_content":"收到～老师会集中大家的留言，在11讲答疑课堂中做出补充讲解。感谢你的建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560018753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101584,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1559875979,"is_pvip":false,"replies":[{"id":"36874","content":"这讲中提到了零拷贝，用DirectBuffer减少内存复制，也就是避免了用户空间与内核空间来回复制。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560174536,"ip_address":"","comment_id":101584,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559875979","product_id":100028001,"comment_content":"老师，channel只是解决了内核空间和磁盘之前的io操作问题，那用户空间和内核空间之间的来回复制是不是依然是一个耗时的操作","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453023,"discussion_content":"这讲中提到了零拷贝，用DirectBuffer减少内存复制，也就是避免了用户空间与内核空间来回复制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560174536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101328,"user_name":"圣西罗","can_delete":false,"product_type":"c1","uid":1521859,"ip_address":"","ucode":"DE096B25B4DABB","user_header":"https://static001.geekbang.org/account/avatar/00/17/38/c3/f18411f9.jpg","comment_is_top":false,"comment_ctime":1559782881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559782881","product_id":100028001,"comment_content":"使用webflux的过程中最大的不方便是不支持threadlocal,导致像创建人修改人id的赋值需要明传参数","like_count":0},{"had_liked":false,"id":101285,"user_name":"胖妞","can_delete":false,"product_type":"c1","uid":1543769,"ip_address":"","ucode":"AC82AF2B912575","user_header":"","comment_is_top":false,"comment_ctime":1559778426,"is_pvip":false,"replies":[{"id":"36497","content":"git上有源码，分别是io和nio的简单实现的demo。如果需要通过简单的代码测试比对两者的性能，可以自己尝试一下，有疑问可以再问老师。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1559780761,"ip_address":"","comment_id":101285,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559778426","product_id":100028001,"comment_content":"git上的测试案例有吗？想很多通过时间具体对比一下！总感觉讲的有点抽象和概念了，脑子里没有形成一个具体的形象！希望能给几个小demo看一下！麻烦了！","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452889,"discussion_content":"git上有源码，分别是io和nio的简单实现的demo。如果需要通过简单的代码测试比对两者的性能，可以自己尝试一下，有疑问可以再问老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559780761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}