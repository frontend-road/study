{"id":636039,"title":"09｜队列：如何实现数据的先进先出？","content":"<p>你好，我是王健伟。</p><p>上节课我们提到的“栈”，用的是“桶”和“抽屉”做类比，实现的是先进后出。这节课我们来聊“队列”，根据名字想象一下，它实现的是不是<strong>先进先出</strong>了呢？</p><p>是的。队列也是一种受限的线性表，它的特点是在一端进行插入操作，在另一端进行删除操作<span class=\"reference\">（与栈刚好相反）</span>。把允许进行插入操作的一端称为<strong>队尾</strong>，允许删除操作的一端称为<strong>队头</strong>。</p><p>把队列想象成人们排队购物，排在队伍第一位的人最先购买然后最先离开，而排在队伍最后一位的人最后购买最后离开。我们向队列中插入元素，就叫做入队，从队列中删除元素，叫做出队。不包含任何数据的队列，就是空队列。</p><p>队列也被称为先进先出<span class=\"reference\">（First In First Out：FIFO）</span>的线性表。换句话说，插入数据只能在队尾<span class=\"reference\">（队列尾部）</span>进行，删除数据只能在队头<span class=\"reference\">（队列头部）</span>进行。</p><p>用队列存取数据的示意图，如图1所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/fb/a1ed04cayy5e1e124d5134cc2ebb32fb.jpg?wh=2284x364\" alt=\"\" title=\"图1&nbsp; 队列存取数据示意图\"></p><p>如果我们分别将数据a1、a2、a3、a4、a5入队，那么在将数据出队的时候，顺序同样是a1、a2、a3、a4、a5，和入队顺序是一样的。</p><p>队列支持的操作和栈非常类似，一般包括队列的创建、入队<span class=\"reference\">（插入/增加数据）</span>、出队<span class=\"reference\">（删除数据）</span>、获取队头元素<span class=\"reference\">（查找数据）</span>、判断队列是否为空或者是否已满等等操作。</p><!-- [[[read_end]]] --><p>接下来，我们就看下这些操作的实现。</p><h1>队列的顺序存储（顺序队列）</h1><p>所谓顺序队列，就是顺序存储，也就是用一段连续的内存空间，去依次存储队列中的数据。和顺序栈一样，为了数据存满时可以对队列进行扩容，顺序队列也会采用为一维数组动态分配内存的方案来编写实现代码。</p><h2>基础实现代码</h2><p>先来看一些基础的实现代码：类定义、初始化以及释放操作。</p><pre><code class=\"language-plain\">#define MaxSize 10       //数组的尺寸\t\ntemplate &lt;typename T&gt; //T代表数组中元素的类型\nclass SeqQueue\n{\npublic:\n\tSeqQueue();                          //构造函数\n\t~SeqQueue();                         //析构函数\n\npublic:\n\tbool EnQueue(const T&amp; e);            //入队列（增加数据）\n\tbool DeQueue(T&amp; e);                  //出队列（删除数据）\n\tbool GetHead(T&amp; e); //读取队头元素，但该元素并没有出队列而是依旧在队列中\n\tvoid ClearQueue();                   //将队列清空\n\t\t\n\tvoid DispList();                     //输出顺序队列中的所有元素\n\tint  ListLength();                  //获取顺序队列的长度（实际拥有的元素数量）\t\t\t\n\tbool IsEmpty();                      //判断顺序队列是否为空\n\tbool IsFull();                       //判断顺序队列是否已满\n\t\t\nprivate:\n\tT* m_data;                           //存放顺序队列中的元素\t\t\t\t\n\tint m_front;                         //队头指针(数组下标)，允许删除的一端，如果队列不为空，则指向队列头元素\n\tint m_rear;                          //队尾指针(数组下标)，允许插入的一端 ，如果队列不为空，则指向队尾元素的下一个位置\n};\n\t\n//通过构造函数对顺序队列进行初始化\ntemplate &lt;typename T&gt;\nSeqQueue&lt;T&gt;::SeqQueue()\n{\n\tm_data = new T[MaxSize];  //为一维数组动态分配内存\n\t\n\t//空队列约定m_front和m_rear都为0\n\tm_front = 0;             \n\tm_rear = 0;\n}\n\n//通过析构函数对顺序队列进行资源释放\ntemplate &lt;typename T&gt;\nSeqQueue&lt;T&gt;::~SeqQueue()\n{\n\tdelete[] m_data;\n}\n</code></pre><p>之后，就是入队列、出队列、读取队头元素操作代码。</p><pre><code class=\"language-plain\">//入队列（增加数据），也就是从队尾增加数据\ntemplate &lt;typename T&gt;\nbool SeqQueue&lt;T&gt;::EnQueue(const T&amp; e)\n{\n\tif (IsFull() == true)\n\t{\n\t\tcout &lt;&lt; \"顺序队列已满，不能再进行入队操作了!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\t\t\t\n\tm_data[m_rear] = e; //将数据放入队尾 \n\tm_rear++;//队尾指针向后走，本行和上一行可以合并写成一行代码：m_data[m_rear++] = e;\n\treturn true;\n}\n\t\n//出队列（删除数据），也就是删除队头数据\ntemplate &lt;typename T&gt;\nbool SeqQueue&lt;T&gt;::DeQueue(T&amp; e)\n{\n\tif (IsEmpty() == true)\n\t{\n\t\tcout &lt;&lt; \"当前顺序队列为空，不能进行出队操作!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\t\n\te = m_data[m_front];  //队头元素值返回到e中。\n\tm_front++;//本行和上一行可以合并写成一行代码：e = m_data[m_front++];\n\treturn true;\n}\n\t\n//读取队头元素，但该元素并没有出队列而是依旧在队列中\ntemplate &lt;typename T&gt;\nbool SeqQueue&lt;T&gt;::GetHead(T&amp; e)\n{\n\tif (IsEmpty() == true)\n\t{\n\t\tcout &lt;&lt; \"当前顺序队列为空，不能读取队头元素!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\t\n\te = m_data[m_front];  //队头元素返回到e中。\n\treturn true;\n}\n</code></pre><p>最后，是一些顺序队列的常用操作，比如输出所有元素、获取长度、判断是否为空、是否已满、将队列清空。</p><pre><code class=\"language-plain\">//输出顺序队列中的所有元素，时间复杂度为O(n)\ntemplate&lt;class T&gt;\nvoid SeqQueue&lt;T&gt;::DispList()\n{\n\t//按照从队头到队尾的顺序来显示数据\n\tfor (int i = m_front; i &lt; m_rear ; ++i)\n\t{\n\t\tcout &lt;&lt; m_data[i] &lt;&lt; \" \";&nbsp; //每个数据之间以空格分隔\n\t}\n\tcout &lt;&lt; endl; //换行\n}\n\t\n//获取顺序队列的长度（实际拥有的元素数量），时间复杂度为O(1)\ntemplate&lt;class T&gt;\nint SeqQueue&lt;T&gt;::ListLength()\n{\n\treturn m_rear - m_front;\n}\n\t\n//判断顺序队列是否为空，时间复杂度为O(1)\ntemplate&lt;class T&gt;\nbool SeqQueue&lt;T&gt;::IsEmpty()\n{\n\tif (m_front == m_rear)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//判断顺序队列是否已满，时间复杂度为O(1)\ntemplate&lt;class T&gt;\nbool SeqQueue&lt;T&gt;::IsFull()\n{\t\t\n\tif(m_rear &gt;= MaxSize) //队尾指针和数组容量做比较\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\t\n//将队列清空\ntemplate&lt;class T&gt;\nvoid SeqQueue&lt;T&gt;::ClearQueue()\n{\n\tm_front = m_rear = 0;\n\t}\n</code></pre><p>在main主函数中，我们可以加入下面的测试代码，实现4个数据的入队列。</p><pre><code class=\"language-plain\">SeqQueue&lt;int&gt; seqobj;\nseqobj.EnQueue(150);\nseqobj.EnQueue(200);\nseqobj.EnQueue(300);\nseqobj.EnQueue(400);\nseqobj.DispList();\n</code></pre><p>执行结果为：<br>\n<img src=\"https://static001.geekbang.org/resource/image/19/89/19452d7d2f1d430f11ff0c83a38cfe89.jpg?wh=1296x61\" alt=\"图片\"></p><p>此时，队列的情形如2所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/89/ffdd1823162a134499b0e6f4798cf089.jpg?wh=2284x790\" alt=\"\" title=\"图2 4个元素进入到顺序队列后的示意图\"></p><p>之后，我们可以继续在main中加入下面的代码来将2个元素出队。</p><pre><code class=\"language-plain\">cout &lt;&lt; \"---------\" &lt;&lt; endl;\nint eval = 0;\nseqobj.DeQueue(eval);\nseqobj.DeQueue(eval);\t\nseqobj.DispList();\n</code></pre><p>新增代码的执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/e5/ca/e5dc3fc40097098ca8008287b527d6ca.jpg?wh=1329x127\" alt=\"图片\"></p><p>从结果中可以看到，队头的两个元素出队<span class=\"reference\">（被删除）</span>了，此时，队列的情形如图3所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/a6/c7f37e490e01f7647996670329c735a6.jpg?wh=2284x790\" alt=\"\" title=\"图3 将2个元素从顺序队列中出队后的示意图\"></p><p>从图3可以看到，将两个元素出队后，队头指针m_front从0变成了2。而此时m_data[0]和m_data[1]这两个能够容纳元素的位置实际上是空出来了。但如果此时继续将新的元素入队，那么m_rear值会不断增加，元素会被继续放入m_data[4]、m_data[5]、m_data[6]… m_data[9]等位置。</p><p>试想，当m_data[9]被放入了元素后，继续向队列中放入元素，就会导致IsFull成员函数返回true，意味着队列已满，无法入队更多元素，而实际上此时m_data[0]和m_data[1]这两个位置还是可以容纳两个元素的。所以，<strong>此时队列的满</strong><strong>，</strong><strong>是一种虚假的满。</strong></p><p>那要如何解决这个问题呢？也许你会想在入队并发现数组头还有空闲位置的时候，通过数据搬运的方式来填补空闲位置，不过这并不是一个好办法，会大大增加入队的时间复杂度，所以解决的办法是对上述代码做适当改进，引入循环队列的概念。</p><h2>循环队列</h2><p>什么是循环队列？在图3中，即便IsFull成员函数返回true，但实际上队列也并没有满。因为m_data[0]和m_data[1]这两个位置还是可以容纳新元素的。所以必须让m_rear指针指回到m_data[0]去，这样才可以继续从m_data[0]开始保存新元素。</p><p>为了做到这一点，我们可以修改EnQueue这个入队成员函数，下面是修改后的代码。</p><pre><code class=\"language-plain\">//入队列（增加数据），也就是从队尾增加数据\ntemplate &lt;typename T&gt;\nbool SeqQueue&lt;T&gt;::EnQueue(const T&amp; e)\n{\n\tif (IsFull() == true)\n\t{\n\t\tcout &lt;&lt; \"顺序队列已满，不能再进行入队操作了!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\t\t\n\tm_data[m_rear] = e; //将数据放入队尾&nbsp;\n\t//m_rear++; //队尾指针向后走，本行和上一行可以合并写成一行代码：m_data[m_rear++] = e;\n\tm_rear = (m_rear + 1) % MaxSize; //队尾指针加1并取余，这样m_data的下标就控制在了0到(MaxSize-1)之间了\n\treturn true;\n\t}\n</code></pre><p>可以看到，这里是对m_rear这个队尾指针加1后取余，这样，当m_rear到达9（MaxSize-1）后再次入队元素时，m_rear就会变为0，就正好可以在m_data[0]这个位置继续保存新入队的元素。</p><p>换句话说，此时随着新元素的入队，在队列不满的情况下，m_rear值的变化就是从0到9，然后再变回0，不断增加到9……如此反复。显然，我们可以<strong>把顺序队列看成是一个环状的队列，队列首尾相连，保存数据元素的空间就好像是一个环状空间，这种头尾相接的队列，就叫做循环队列。</strong></p><p>之后，继续在main中加入代码行来向队列中继续增加5个元素。</p><pre><code class=\"language-plain\">cout &lt;&lt; \"---------\" &lt;&lt; endl;\nseqobj.EnQueue(500);\nseqobj.EnQueue(600);\nseqobj.EnQueue(700);\nseqobj.EnQueue(800);\nseqobj.EnQueue(900);\n\tseqobj.DispList();\n</code></pre><p>新增代码的执行结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/2e/f73bf5a373c8779666ec6dc3450dc22e.jpg?wh=1334x63\" alt=\"图片\"></p><p>此时的循环队列示意图，如图4所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/7c/ab/7c2cee26c8431971fe2fd3d4765624ab.jpg?wh=2284x1173\" alt=\"\" title=\"图4&nbsp; 4个元素入队、2个元素出队、再5个元素入队后的循环队列示意图\"></p><p>如果此时再入队1个元素，那么这个元素将保存在m_data[9]的位置且m_rear将等于0。这样再次入队新元素时，m_data[0]、m_data[1]这样的空闲位置就可以被使用了。</p><p>不过，问题又来了。要怎么判断循环队列什么时候满了呢？目前判断队列是否已满的成员函数IsFull的判满条件是只要m_rear &gt;= MaxSize，也就是只要队尾指针达到了数组容量，就认为队列满了，这显然不行。我们之前已经看到，m_rear的值因为取余的原因，永远都小于MaxSize，也就是队列永远不会满，这显然是不对的。</p><p>想象一下，如果把图4中的m_data[0]到m_data[9]全部存满数据，那队列显然就是满的了，此时m_rear == m_front就会成立。我们知道，判断队列是否为空的成员函数IsEmpty的判断条件同样是m_front == m_rear，这意味着判断队列空和队列满的代码是相同的，这是不可以的。</p><p>为此，一个比较常用的判断循环队列是否满的方法，就是通过牺牲一个保存元素的空间来判断，如图5所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/07/75/079f9b6c2e89966bb0b3375ded06f275.jpg?wh=2284x1173\" alt=\"\" title=\"图5&nbsp; 循环队列满的情形示意图\"></p><p>你看，在图5中，队列中一共有10个位置，但只保存了9个元素，留出了1个空闲位置不允许插入元素，这个时候，就满足条件m_rear+1 == m_front，或者更严谨地说，应该是(m_rear + 1) % MaxSize == m_front，也就是说，当该条件成立时，就认为队列满了<span class=\"reference\">（即使该队列还有一个空闲位置）</span>。</p><p>下面是修改后的IsFull成员函数代码。</p><pre><code class=\"language-plain\">//判断顺序队列是否已满，时间复杂度为O(1)\ntemplate&lt;class T&gt;\nbool SeqQueue&lt;T&gt;::IsFull()\n{\t\t\n\t//if(m_rear &gt;= MaxSize) //队尾指针和数组容量做比较\n\tif((m_rear + 1) % MaxSize == m_front)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\t\n</code></pre><p>当然，出队列成员函数DeQueue也必须做出修改以控制m_front的取值范围，下面是修改后的代码。</p><pre><code class=\"language-plain\">//出队列（删除数据），也就是删除队头数据\ntemplate &lt;typename T&gt;\nbool SeqQueue&lt;T&gt;::DeQueue(T&amp; e)\n{\n\tif (IsEmpty() == true)\n\t{\n\t\tcout &lt;&lt; \"当前顺序队列为空，不能进行出队操作!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\n\te = m_data[m_front];&nbsp; //队头元素值返回到e中。\n\t//m_front++;//本行和上一行可以合并写成一行代码：e = m_data[m_front++];\n\tm_front = (m_front +1) % MaxSize; //队头指针加1并取余\n\treturn true;\n\t}\n</code></pre><p>其他一些需要修改的成员函数代码这里也给出了参考。</p><pre><code class=\"language-plain\">//获取顺序队列的长度（实际拥有的元素数量），时间复杂度为O(1)\ntemplate&lt;class T&gt;\nint SeqQueue&lt;T&gt;::ListLength()\n{\n\t//return m_rear - m_front;\n\treturn (m_rear + MaxSize - m_front) % MaxSize;\n}\n\n//输出顺序队列中的所有元素，时间复杂度为O(n)\ntemplate&lt;class T&gt;\nvoid SeqQueue&lt;T&gt;::DispList()\n{\n\t//按照从队头到队尾的顺序来显示数据\n\t//for (int i = m_front; i &lt; m_rear ; ++i)\n\tfor (int i = m_front; i != m_rear;)\n\t{\n\t\tcout &lt;&lt; m_data[i] &lt;&lt; \" \";&nbsp; //每个数据之间以空格分隔\n\t\ti = (i + 1) % MaxSize;\n\t}\n\tcout &lt;&lt; endl; //换行\n\t}\n</code></pre><p>如果你认为，就为了判断队列是不是满了，就浪费了一个空闲队列的位置，实在是不值得，那么你还可以引入其他的方法，这里列举两种。</p><ul>\n<li>\n<p>引入一个int类型的成员变量m_size，初始值为0，当成功入队列一个元素时，m_size自加1，当成功出队列一个元素时，m_size自减1，那么，就可以通过m_size的值来判断队列是满还是空了<span class=\"reference\">（m_size==0为空，m_size== MaxSize为满）</span>。</p>\n</li>\n<li>\n<p>引入一个char<span class=\"reference\">（一个字节够了）</span>类型的成员变量m_tag，初始值为0。当执行出队列<span class=\"reference\">（删除）</span>操作时，把该变量的值设置为0，当执行入队列<span class=\"reference\">（插入）</span>操作时，把该变量的值设置为1，这样就标记了最近是执行了删除操作还是插入操作。注意，只有出队列操作才会导致队列为空，只有入队列操作才会导致队列变满，所以，代码大概就会是下面的样子。</p>\n</li>\n</ul><pre><code class=\"language-plain\">template &lt;typename T&gt;\nbool SeqQueue&lt;T&gt;::EnQueue(const T&amp; e) //入队列操作\n{\n\tif (IsFull() == true)\n\t{\n\t\tcout &lt;&lt; \"顺序队列已满，不能再进行入队操作了!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\tm_tag = 1; //入队\n\t......\n}\ntemplate&lt;class T&gt;\nbool SeqQueue&lt;T&gt;::IsFull()//判断顺序队列是否已满\n{\n\tif (m_front == m_rear &amp;&amp; tag == 1)\n\t\treturn true;\n\treturn false;\n}\ntemplate &lt;typename T&gt;\nbool SeqQueue&lt;T&gt;::DeQueue(T&amp; e) //出队列操作\n{\n\tif (IsEmpty() == true)\n\t{\n\t\tcout &lt;&lt; \"顺序队列为空，不能进行出队操作!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\tm_tag = 0; //出队\n\t......\n}\ntemplate&lt;class T&gt;\nbool SeqQueue&lt;T&gt;::IsEmpty()//判断顺序队列是否为空\n{\n\tif (m_front == m_rear &amp;&amp; tag == 0)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n\t}\n</code></pre><h1>队列的链式存储（链式队列）</h1><p>一般来讲，如果队列长度的最大值比较确定的情况下，可以考虑使用顺序队列<span class=\"reference\">（循环队列）</span>，否则，就可以考虑使用链式队列了。</p><p>所谓链式队列，就是用链式存储的方式来实现的队列。你可以把它理解成一个操作受限的单链表，只允许在尾部插入元素，只允许在头部删除元素。之前学习过单链表的你，这里再学习链式队列，就会非常容易。</p><p>和单链表一样，链式队列可以带头结点，也可以不带头结点，同样为编程方便，这里我会采用带头节点的实现方式去讲解。</p><p>先来看一些基础的实现代码。先说类定义、初始化以及释放操作。</p><pre><code class=\"language-plain\">//链式队列中每个节点的定义\ntemplate &lt;typename T&gt; //T代表数据元素的类型\nstruct QueueNode\n{\n\tT data;       //数据域，存放数据元素\n\tQueueNode&lt;T&gt;* next;  //指针域，指向下一个同类型（和本节点类型相同）节点\n};\n\t\n//链式队列的定义\ntemplate &lt;typename T&gt; //T代表数组中元素的类型\nclass LinkQueue\n{\npublic:\n\tLinkQueue();                          //构造函数\n\t~LinkQueue();                         //析构函数\n\t\npublic:\t\t\n\tbool EnQueue(const T&amp; e);            //入队列（增加数据）\t\t\n\tbool DeQueue(T&amp; e);                  //出队列（删除数据）\n\tbool GetHead(T&amp; e);   //读取队头元素，但该元素并没有出队列而是依旧在队列中\t\t\n\n\tvoid DispList();                     //输出链式队列中的所有元素\n\tint  ListLength();                  //获取链式队列的长度（实际拥有的元素数量）\t\t\t\n\tbool IsEmpty();                      //判断链式队列是否为空\n\t\t\nprivate:\n\tQueueNode&lt;T&gt;* m_front;              //头指针（指向头结点），这一端允许出队（删除）\n\tQueueNode&lt;T&gt;* m_rear;                //专门引入尾指针以方便入队（插入）操作\n\tint m_length;                        //记录长度，方便获取长度\n};\n\t\n//通过构造函数对链式队列进行初始化\ntemplate &lt;typename T&gt;\nLinkQueue&lt;T&gt;::LinkQueue()\n{\t\t\n\tm_front = new QueueNode&lt;T&gt;; //先创建一个头结点\n\tm_front-&gt;next = nullptr;\n\tm_rear = m_front;\n\tm_length = 0;\n\t\n\t//若不带头节点的链式队列初始化代码应该如下，供参考\n\t/*m_front = nullptr;\n\tm_rear = nullptr;*/\n}\n\t\n//通过析构函数对链式队列进行资源释放\ntemplate &lt;typename T&gt;\nLinkQueue&lt;T&gt;::~LinkQueue()\n{\n\tQueueNode&lt;T&gt;* pnode = m_front-&gt;next;\n\tQueueNode&lt;T&gt;* ptmp;\n\twhile (pnode != nullptr) //该循环负责释放数据节点\n\t{\n\t\tptmp = pnode;\n\t\tpnode = pnode-&gt;next;\n\t\tdelete ptmp;\n\t}\t\t\n\tdelete m_front;             //释放头结点\t\t\n\tm_front = m_rear = nullptr; //非必须\n\tm_length = 0;               //非必须\n}\n</code></pre><p>之后，就是入队列、出队列、读取队头元素操作代码。</p><pre><code class=\"language-plain\">//入队列（增加数据），也就是从队尾增加数据\ntemplate &lt;typename T&gt;\nbool LinkQueue&lt;T&gt;::EnQueue(const T&amp; e)\n{\n\tQueueNode&lt;T&gt;* node = new QueueNode&lt;T&gt;;\n\tnode-&gt;data = e;\n\tnode-&gt;next = nullptr;\n\t\n\tm_rear-&gt;next = node; //新节点插入到m_rear后面\n\tm_rear = node;       //更新队列尾指针\n\t\t\n\tm_length++;\n\treturn true;\n}\n\t\n//出队列（删除数据），也就是删除队头数据\ntemplate &lt;typename T&gt;\nbool LinkQueue&lt;T&gt;::DeQueue(T&amp; e)\n{\n\tif (IsEmpty() == true)\n\t{\n\t\tcout &lt;&lt; \"当前链式队列为空，不能进行出队操作!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\n\tQueueNode&lt;T&gt;* p_willdel = m_front-&gt;next;\n\te = p_willdel-&gt;data;\n\t\n\tm_front-&gt;next = p_willdel-&gt;next;\n\tif (m_rear == p_willdel) //队列中只有一个元素节点（被删除后，整个队列就为空了）\n\t\tm_rear = m_front;  //设置队列为空(尾指针指向头指针)\n\t\t\n\tdelete p_willdel;\n\tm_length--;\n\treturn true;\n}\n\t\n//读取队头元素，但该元素并没有出队列而是依旧在队列中\ntemplate &lt;typename T&gt;\nbool LinkQueue&lt;T&gt;::GetHead(T&amp; e)\n{\n\tif (IsEmpty() == true)\n\t{\n\t\tcout &lt;&lt; \"当前链式队列为空，不能读取队头元素!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\t\n\te = m_front-&gt;next-&gt;data;\n\treturn true;\n}\n</code></pre><p>最后，是一些链式队列的常用操作，比如输出所有元素、获取长度、判断是否为空。</p><pre><code class=\"language-plain\">//输出链式队列中的所有元素，时间复杂度为O(n)\ntemplate&lt;class T&gt;\nvoid LinkQueue&lt;T&gt;::DispList()\n{\n\tQueueNode&lt;T&gt;* p = m_front-&gt;next;\n\twhile (p != nullptr)&nbsp;\n\t{\n\t\tcout &lt;&lt; p-&gt;data &lt;&lt; \" \";&nbsp; //每个数据之间以空格分隔\n\t\tp = p-&gt;next;\n\t}\n\tcout &lt;&lt; endl; //换行\n}\n\t\n//获取链式队列的长度（实际拥有的元素数量），时间复杂度为O(1)\ntemplate&lt;class T&gt;\nint LinkQueue&lt;T&gt;::ListLength()\n{\n\treturn m_length;\n}\n\t\n//判断链式队列是否为空，时间复杂度为O(1)\ntemplate&lt;class T&gt;\nbool LinkQueue&lt;T&gt;::IsEmpty()\n{\n\t//当然，换一种判断方式也行：if(m_front-&gt;next == nullptr) return true;\n\tif (m_front == m_rear)&nbsp;\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n\t}\n</code></pre><p>之后，在main中加入代码行。</p><pre><code class=\"language-plain\">LinkQueue&lt;int&gt; lnobj;\nlnobj.EnQueue(150);\n\t\nint eval2 = 0;\nlnobj.DeQueue(eval2);\t\nlnobj.EnQueue(200);\t\nlnobj.EnQueue(700);\n\tlnobj.DispList();\n</code></pre><p>执行结果为：<br>\n<img src=\"https://static001.geekbang.org/resource/image/a4/dd/a498974732b15d16da7489a196497ddd.jpg?wh=1332x62\" alt=\"图片\"></p><p>从代码中可以看到，引入的两个指针，分别是头指针和尾指针。在构造函数中，需要将这两个指针进行初始化，初始化后的头尾指针分别指向头结点，这也意味着此时该链式队列为空，如图6所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/54/bf/548b6bdb669f3be2bea0ae5276cb88bf.jpg?wh=2284x430\" alt=\"\" title=\"图6&nbsp; 刚被初始化的链式队列（带头节点）示意图\"></p><p>入队新元素需要在链的末尾<span class=\"reference\">（队尾）</span>进行。图7是入队两个元素的情形，注意，尾指针始终要保持指向最后一个元素节点。</p><p><img src=\"https://static001.geekbang.org/resource/image/21/ab/21bef7e88df586113a9e9c42ff7df5ab.jpg?wh=2284x465\" alt=\"\" title=\"图7&nbsp; 分别入队100和200两个元素后的链式队列元素示意图\"></p><p>代码中引入了成员变量m_length以快速获取队列的长度<span class=\"reference\">（通过成员函数ListLength）</span>，时间复杂度仅为O(1)，如果用传统的从头指针遍历到尾指针的方法来计算队列长度，那么时间复杂度就会变成O(n)。所以，如果需要频繁获取队列长度，引入m_length就会明显提升效率。</p><p>另一个值得说的是，顺序队列存在队列满的问题，而链式队列因为是通过new来创建元素节点，所以不存在队列满的问题，除非物理内存不足。而如果不是软件导致内存泄漏，通常物理内存不会不足，一旦物理内存不足，就会导致整个程序运行崩溃，此时必须全面对程序进行排错。</p><h1>双端队列</h1><p>前面所讨论的顺序或者链式队列可以看成是普通队列，其实，还有一些变种的队列——双端队列。双端队列允许在两端插入数据，也允许在两端删除数据。它的存取数据示意图，如图8所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/94/37/94d29911b639e65b8b3d5757def15237.jpg?wh=2284x305\" alt=\"\" title=\"图8&nbsp; 双端队列存取数据示意图\"></p><p>当然，我们也可以对双端队列存取数据进行一定的限制，这样就可以得到“输入受限的双端队列”和“输出受限的双端队列”两种情况。</p><p>所谓输入受限的双端队列，指的是数据只能从一端插入但可以从两端删除的双端队列，如图9所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/07/ca/070c676690942cd053413e0de758e8ca.jpg?wh=2284x356\" alt=\"\" title=\"图9&nbsp; 输入受限的双端队列存取数据示意图\"></p><p>而输出受限的双端队列，指的是数据可以从两端插入但只能从一端删除的双端队列，如图10所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/73/ed/73fe18bce28196665eb3f5e7c7e568ed.jpg?wh=2284x336\" alt=\"\" title=\"图10&nbsp; 输出受限的双端队列存取数据示意图\"></p><p>从功能上来讲，双端队列的功能既包括了栈功能，又包括了队列功能，灵活性大大增强，但从实用性来讲，人们更经常使用的是栈和普通队列而不是双端队列。有兴趣的话，你也可以利用前面学习过的知识，尝试实现自己的双端队列。</p><h1>小结</h1><p>这节课，我们学习了队列这种常用的数据结构，分别用代码实现了队列的顺序存储<span class=\"reference\">（顺序队列）</span>和链式存储<span class=\"reference\">（链式队列）</span>。此外，还引出了双端队列的概念。在后面的课程中，会多次用到队列这种数据结构来保存数据，相信那时你会对队列的用途有更深刻的理解。</p><p>队列是一种与栈相对的数据结构，之所以这样讲，是因为<strong>栈</strong>是一种<strong>后进先出</strong>的数据结构，而<strong>队列</strong>是一种<strong>先进先出</strong>的数据结构。</p><p>队列的应用十分广泛，这里我们举两个典型应用的例子。</p><ol>\n<li>\n<p>去营业大厅办理业务时使用的叫号系统就是一个队列，办理业务的人要先取号后等待叫号，号码按照取号的顺序保存在队列中，叫号时最先取号的人会被最先叫到。</p>\n</li>\n<li>\n<p>多人同时使用网络打印机打印文件，因为打印机的速度很慢，所以每个人提交的打印任务需要在一个队列中进行排队<span class=\"reference\">（打印队列）</span>，打印机根据先进先出<span class=\"reference\">（先来先服务）</span>的原则，依次从打印队列中取出打印任务并进行打印工作。</p>\n</li>\n</ol><p>其实，<strong>对于许多服务资源有限的场合，都可以通过队列来实现对服务请求的排队。</strong></p><p>在STL<span class=\"reference\">（标准模板库）</span>中，提供了一个名字叫做queue的容器，该容器实现了队列的功能，有兴趣可以对其源码做适当研究。队列同栈一样，也分为顺序存储和链式存储。同样，STL中也提供了名字叫做deque的容器——一个典型的双端队列，有兴趣的话，你也可以读一读它的实现代码。</p><h1>归纳思考</h1><p>你可以使用一下STL中提供的deque容器，了解一下它提供的各种调用接口，参考这些调用接口，自己尝试实现一个双端队列。</p><p>欢迎你在留言区和我分享实践的成果，如果觉得有所收获，也可以把课程分享给更多的朋友一起学习进步，我们下节课见！</p>","comments":[{"had_liked":false,"id":374649,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"江苏","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1684281313,"is_pvip":false,"replies":[{"id":136757,"content":"标准库中的deque就是双端队列，应用场景。我还真没用过😂。在CHATGPT里询问一下吧","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1684415545,"ip_address":"广东","comment_id":374649,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"请问老师双端队列的应用场景一般是什么？能否举个例子","like_count":1,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618667,"discussion_content":"标准库中的deque就是双端队列，应用场景。我还真没用过😂。在CHATGPT里询问一下吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1684415546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372132,"user_name":"Se7en","can_delete":false,"product_type":"c1","uid":1225368,"ip_address":"北京","ucode":"93EFAE37AFB12D","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/98/82b76c88.jpg","comment_is_top":false,"comment_ctime":1680768920,"is_pvip":false,"replies":[{"id":135836,"content":"👏👏","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1680846166,"ip_address":"广东","comment_id":372132,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"此处留言由我来占领","like_count":0,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612679,"discussion_content":"👏👏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680846166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375162,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"江苏","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1684995506,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"基础的线性结构过了一遍，手敲代码，很大的收获。线性结构是基础，后面的树和图，难度更大。","like_count":0}]}