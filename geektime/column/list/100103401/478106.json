{"id":478106,"title":"加餐一 | 初识Kotlin函数式编程","content":"<p>你好，我是朱涛。在上一节实战课当中，我们算是用Kotlin实践了一把函数式编程的思想。不过，上节课我们其实只是浅尝辄止，也不完全算是函数式编程，咱们只是借鉴了它的思想。</p><p>函数式编程（Functional Programming），是一个跟“<a href=\"https://time.geekbang.org/column/article/473349\">面向对象</a>”类似的概念，它也是软件工程中的一种编程范式，它是声明式编程（Declarative Programming）的一种，而与它相反的，我们叫做命令式编程（Imperative Programming）。</p><p>虽然说，Kotlin的函数式编程还不属于主流，但近几年它的关注度也越来越高了，所以今天我们就借着这节加餐，一起来简单聊聊Kotlin的函数式编程，也为上一节实战课做一个延伸。这样，等将来你想深入研究Kotlin函数式编程的时候，有了这节课的认知基础，也会更加轻松。</p><h2>函数式与命令式的区别</h2><p>那么，在介绍函数式编程之前，我们首先要来看几个编程范式的概念：声明式、命令式，还有四个常见的编程范式：函数式、逻辑式、面向过程、面向对象。它们之间的关系大致如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/12/6a/12fe0504cd5329b2634a6b3746c0yy6a.jpg?wh=1920x1013\" alt=\"图片\"></p><p>我们的校园里学习编程的时候，一般都是学的C、Java，它们分别是面向过程语言、面向对象语言的代表，它们都属于“命令式”的范畴。</p><!-- [[[read_end]]] --><p>那么，想要理解“函数式”，我们首先就要理解什么是“命令式编程”，这是两种截然相反的编程范式。</p><p>所谓命令式编程，其实就是最常见的编程方式：<strong>在编程的时候，我们需要告诉计算机每一步具体都要干什么。</strong>比如说，我们要过滤集合当中所有的偶数，那么使用命令式编程的话，会需要以下几个步骤：</p><ul>\n<li>使用for循环遍历集合；</li>\n<li>在for循环当中，取出集合元素，并且判断它是否能够被2整除；</li>\n<li>对于能被2整除的元素，我们将它们添加到新的集合当中；</li>\n<li>最后，返回新的集合。</li>\n</ul><p>具体来说，命令式的代码是这样的：</p><pre><code class=\"language-plain\">fun foo(): List&lt;Int&gt; {\n    val list = listOf(1, 2, 3, 4)\n    val result = mutableListOf&lt;Int&gt;()\n    for (i in list) {\n        if (i % 2 == 0) {\n            result.add(i)\n        }\n    }\n\n    return result\n}\n</code></pre><p>那么，如果是函数式，或者说“声明式”的代码呢？</p><pre><code class=\"language-plain\">fun fp() = listOf(1, 2, 3, 4).filter { it % 2 == 0 }\n</code></pre><p>这段代码，我们是使用了Kotlin标准库当中的filter方法，它是一个高阶函数，作用就是过滤符合要求的集合元素并且返回。而具体的过滤要求呢，我们会在Lambda表达式里传进来。<br>\n由此我们也可以感受到，函数式风格的代码，它对比命令式的代码主要是有两个区别：</p><ul>\n<li>第一个区别是：它只需要声明我们想要什么，而不必关心底层如何实现。</li>\n<li>第二个区别是：代码更加简洁，可读性更高。</li>\n</ul><p>在上节课的实战案例当中，我们3.0版本的词频统计程序，其实并没有完全发挥出Kotlin函数式编程的优势，因为其中的“getWordCount()”“mapToList()”都是我们自己实现的。事实上，我们完全可以借助Kotlin标准库函数来实现。</p><pre><code class=\"language-plain\">fun processText(text: String): List&lt;WordFreq&gt; {\n    return text\n        .clean()\n        .split(\" \")\n        .filter { it != \"\" }\n        .groupBy { it }\n        .map { WordFreq(it.key, it.value.size) }\n        .sortedByDescending { it.frequency }\n}\n</code></pre><p>根据这段代码我们可以看到，借助Kotlin库函数，我们用简单的几行代码，就成功实现了单词频率统计功能。这就是函数式编程的魅力。</p><p>要知道，我们1.0版本命令式的代码，足足有五十多行代码！这中间的差距是非常大的。</p><h2>到底什么是函数式编程？</h2><p>那么，到底什么是函数式编程呢？函数式编程在数学理论上的定义很复杂，而对于我们初次接触Kotlin函数式编程来说，其实我们需要记住两个重点：</p><ul>\n<li>函数是一等公民；</li>\n<li>纯函数。</li>\n</ul><p>而以这两个点作为延伸，我们就可以扩展出很多函数式编程的其他概念。比如说，<strong>函数是一等公民</strong>，这就意味着：</p><ul>\n<li>函数可以独立于类之外，这就是Kotlin的<a href=\"https://time.geekbang.org/column/article/475684\">顶层函数</a>；</li>\n<li>函数可以作为参数和返回值，这就是<a href=\"https://time.geekbang.org/column/article/476637\">高阶函数和Lambda</a>；</li>\n<li>函数可以像变量一样，这就是函数的引用；</li>\n<li>当函数的功能更加强大以后，我们就可以几乎可以做到：只使用函数来解决所有编程的问题。</li>\n</ul><p>再比如，对于<strong>纯函数</strong>的理解，这就意味着：</p><ul>\n<li>函数不应该有副作用。所谓副作用，就是“对函数作用域以外的数据进行修改”，而这就引出了函数式的<strong>不变性</strong>。在函数式编程当中，我们不应该修改任何变量，当我们需要修改变量的时候，我们要创建一份新的拷贝再做修改，然后再使用它（这里，你是不是马上就想到了数据类的copy方法呢？）。</li>\n<li>无副作用的函数，它具有<strong>幂等性</strong>，换句话说就是：函数调用一次和调用N次，它们的效果是等价的。</li>\n<li>无副作用的函数，它具有<strong>引用透明</strong>的特性。</li>\n<li>无副作用的函数，它具有<strong>无状态</strong>的特性。</li>\n</ul><p>当然，函数式编程还有很多其他的特点，但是，在Kotlin当中，我们把握好“函数是一等公民”和“纯函数”这两个核心概念，就算初步理解了。</p><p>好，前面我们提到过，我们可以使用函数来解决所有编程问题，那么接下来，我们就来试试如何用函数来实现循环的功能吧。</p><h2>实战：函数式的循环</h2><p>for循环，是命令式编程当中最典型的语句。举个例子，我们想要计算从1到10的总和，使用for循环，我们很容易就可以写出这样的代码：</p><pre><code class=\"language-plain\">fun loop(): Int {\n    var result = 0\n    for (i in 1..10) {\n        result += i\n    }\n\n    return result\n}\n</code></pre><p>上面的代码很简单，我们定义了一个result变量，然后在for循环当中，将每一个数字与其相加，最后返回result这个变量作为结果。这很明显就是在告诉计算机每一步应该做什么，这其实也是它叫做命令式风格的原因。</p><p>那么，如果不使用for循环，仅仅只使用函数，我们该如何实现这样的功能呢？答案其实很简单，那就是<strong>递归</strong>。</p><pre><code class=\"language-plain\">fun recursionLoop(): Int {\n    fun go(i: Int, sum: Int): Int =\n        if (i &gt; 10) sum else go(i + 1, sum + i)\n\n    return go(1, 0)\n}\n</code></pre><p>从这段代码当中，我们可以看到，在recursionLoop()这个函数当中，我们定义了一个内部的函数go()，它才是我们实现递归的核心函数。</p><p>在函数式编程当中，请不要觉得这种代码很奇怪，<strong>毕竟咱们函数都是一等公民了，类的内部可以继续嵌套内部类，那函数里面为什么就不可以嵌套一个内部的函数呢？</strong></p><p>实际上，在函数式编程当中，我们有时候也会<strong>使用递归来替代循环</strong>。我们知道，递归都是有调用栈开销的，所以我们应该尽量使用<a href=\"https://zh.wikipedia.org/wiki/%25E5%25B0%25BE%25E8%25B0%2583%25E7%2594%25A8#%25E5%25B0%25BE%25E9%2580%2592%25E5%25BD%2592\">尾递归</a>。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是O(1)。</p><pre><code class=\"language-plain\">fun recursionLoop(): Int {\n// 变化在这里\n//     ↓\n    tailrec fun go(i: Int, sum: Int): Int =\n        if (i &gt; 10) sum else go(i + 1, sum + i)\n\n    return go(1, 0)\n}\n</code></pre><p>当然，上面的递归思路只是为了说明我们可以用它替代循环。在实际的开发工作中，这种方式是不推荐的，毕竟它太绕了，对吧？如果要在工作中实现类似的需求，我们使用Kotlin集合操作符一行代码就能搞定：</p><pre><code class=\"language-plain\">fun reduce() = (1..10).reduce { acc, i -&gt; acc + i } // 结果 55\n</code></pre><p>这里的reduce操作符也许你会觉得难以理解，没关系，Kotlin还为我们提供了另一个更简单的操作符，也就是sum：</p><pre><code class=\"language-plain\">fun sum() = (1..10).sum() // 结果 55\n</code></pre><p>在这里，我们也能发现一些问题：<strong>使用Kotlin，我们运用不同的思维，可以写出截然不同的4种代码</strong>。而即使同样都是函数式的思想的3种代码，它们之间的可读性也有很大的差异。</p><p>Kotlin官方一直宣扬自己是支持多种编程范式的语言，它不像某些语言，会强制你使用某种编程范式（比如C、Haskell等）。这样一来，面对不同的问题，我们开发者就可以灵活选择不同的范式进行编程。</p><p>而且，Kotlin也没有完全拥抱函数式编程，它只是在一些语法设计上，借鉴了函数式编程的思想，而且这种借鉴的行为也十分克制，比如<a href=\"https://zh.wikipedia.org/zh-hans/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D\">模式匹配</a>、<a href=\"https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B1%BB\">类型类</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)\">单子</a>。另外，函数式编程领域的很多高级概念，Kotlin也都没有天然支持，需要我们开发者自己去实现。对比起其他JVM的现代语言（如<a href=\"https://zh.wikipedia.org/wiki/Scala\">Scala</a>），<strong>Kotlin也显得更加务实，有点“博采众长”的意味</strong>。</p><h2>小结</h2><p>Kotlin作为一门刚出生不久的语言，它融合了很多现代化语言的特性，它在支持命令式编程的同时呢，也对“函数式编程”有着天然的亲和力。</p><p>命令式编程与函数式编程，它们之间本来就各有优劣。</p><p>函数式编程的优点在于，在部分场景下，它的开发效率高、可读性强，以及由于不变性、无状态等特点，更适合并发编程。而函数式编程的劣势也很明显，它的学习曲线十分陡峭、反直觉，由于自身特性的限制，往往会导致性能更差。所以，Kotlin函数式编程目前仍未成为主流，这是有一定道理的。</p><p>不过，随着2021年Android推出Jetpack Compose声明式UI框架，以及Kotlin官方推出的Compose Multiplatform以后，Kotlin函数式编程的关注度也被推向了一个前所未有的高度。总的来说，Kotlin函数式编程是一个非常大的话题，它自身就足够写一个完整的专栏了。如果有机会的话，我们在课程后面，还会再来详细聊聊Kotlin函数式编程在Compose当中的体现。</p><p>我相信，在不久的将来，Kotlin函数式编程的方式，一定会被更多的人认可和接受。</p><h2>思考题</h2><p>今天，咱们从“编程范式”聊到了Kotlin函数式编程，也请你说说你对“编程范式”以及“函数式编程”的理解吧。这个问题没有标准答案，请畅所欲言吧！</p>","comments":[{"had_liked":false,"id":331255,"user_name":"夜月","can_delete":false,"product_type":"c1","uid":1121740,"ip_address":"","ucode":"0C05F42E94F76C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Iofqk26ibmjFxAZKRibgUmwc9p5RDDArr9Jt0NTrwTKOhtPTuuia77OxOwyEUpeqp2fvU5HPpY8sK0vBejJNA3ib3w/132","comment_is_top":false,"comment_ctime":1642506418,"is_pvip":false,"replies":[{"id":"121046","content":"嗯，总结的挺好。所以，要注意控制全局作用域的扩展数量。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642556793,"ip_address":"","comment_id":331255,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18822375602","product_id":100103401,"comment_content":"函数式编程更多的是带来方便：<br>1. 更少地声明临时变量<br>2.使用库或者标准api更方便<br>但是我个人觉得，引入大量库后，全局作用域的扩展函数过多时，也会导致ide的函数选择提示过长，容易出错。","like_count":5,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547140,"discussion_content":"嗯，总结的挺好。所以，要注意控制全局作用域的扩展数量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642556793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335015,"user_name":"阿辛","can_delete":false,"product_type":"c1","uid":2917937,"ip_address":"","ucode":"7A127DA27B34AE","user_header":"https://static001.geekbang.org/account/avatar/00/2c/86/31/b55a328a.jpg","comment_is_top":false,"comment_ctime":1645256473,"is_pvip":false,"replies":[{"id":"122413","content":"感谢你的认可，我们一起加油~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645370394,"ip_address":"","comment_id":335015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10235191065","product_id":100103401,"comment_content":"感觉比慕课的讲得好. 慕课的kotlin讲的比较难","like_count":3,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552272,"discussion_content":"感谢你的认可，我们一起加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645370394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330897,"user_name":"better","can_delete":false,"product_type":"c1","uid":1169063,"ip_address":"","ucode":"AF1DB566EBB8A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","comment_is_top":false,"comment_ctime":1642258911,"is_pvip":false,"replies":[{"id":"120714","content":"嗯，没错。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642299354,"ip_address":"","comment_id":330897,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10232193503","product_id":100103401,"comment_content":"个人感觉，在使用 kt 函数式方法的时候，最好看一下此方法的实现，否则就容易造成时间复杂度更高，比如：在不知不觉中 for 嵌套了（我还在展示，你看代码多简洁哈），这也是一个性能方面的问题吧","like_count":3,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546337,"discussion_content":"嗯，没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642299354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352479,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1658720840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658720840","product_id":100103401,"comment_content":"只买对的，不买贵的！","like_count":1},{"had_liked":false,"id":347040,"user_name":"Durian_","can_delete":false,"product_type":"c1","uid":1024735,"ip_address":"","ucode":"D07FD85A81C6D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/df/924756fe.jpg","comment_is_top":false,"comment_ctime":1653637499,"is_pvip":false,"replies":[{"id":"126593","content":"这个概念三言两语还真解释不清楚，你可以留意我的博客吧，我会在我的博客里延伸讲讲Kotlin函数式编程。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1653818206,"ip_address":"","comment_id":347040,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653637499","product_id":100103401,"comment_content":"我有点不太理解这句话：<br>无副作用的函数，它具有引用透明的特性。<br>这个透明是什么意思呢？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574058,"discussion_content":"这个概念三言两语还真解释不清楚，你可以留意我的博客吧，我会在我的博客里延伸讲讲Kotlin函数式编程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653818206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343398,"user_name":"vox","can_delete":false,"product_type":"c1","uid":2466331,"ip_address":"","ucode":"0A433DF2BC1D5F","user_header":"https://static001.geekbang.org/account/avatar/00/25/a2/1b/0a4f9177.jpg","comment_is_top":false,"comment_ctime":1650816615,"is_pvip":false,"replies":[{"id":"125650","content":"比如：频繁的集合操作时。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651247096,"ip_address":"","comment_id":343398,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1650816615","product_id":100103401,"comment_content":"请问既然函数式和命令式各有优劣，那么在Android日常开发中哪些场景中建议使用函数式的写法呢？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568906,"discussion_content":"比如：频繁的集合操作时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651247096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591842,"discussion_content":"Java 8 中大量的函数式接口也主要用于集合操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666858059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332548,"user_name":"better","can_delete":false,"product_type":"c1","uid":1169063,"ip_address":"","ucode":"AF1DB566EBB8A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","comment_is_top":false,"comment_ctime":1643335982,"is_pvip":false,"replies":[{"id":"121488","content":"是的，对于数据量较大的情况，直接使用集合操作符是可能引起性能问题的。不过Kotlin在这方面也做了一些补充，比如使用Sequence或者是Flow。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643341022,"ip_address":"","comment_id":332548,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1643335982","product_id":100103401,"comment_content":"有些地方，比如 list 类型的类成员，如使用函数式，比如：filter 某些，形成新的 list，确实可以避免并发编程的状态问题，但是，每次都fitler成本也是很大的，此时需要取舍了：是弄一个新的成员变量记录 filter 后的 list，还是直接函数式过滤（如果 list 很大，filter 函数式函数经常调用，性能问题，就需要考虑了）","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548722,"discussion_content":"是的，对于数据量较大的情况，直接使用集合操作符是可能引起性能问题的。不过Kotlin在这方面也做了一些补充，比如使用Sequence或者是Flow。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643341022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330585,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4d/99/c4b8c4a7.jpg","nickname":"梦佳","note":"","ucode":"AF8E384403A86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582213,"discussion_content":"怎样算数据量大，有点模糊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659318694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331605,"user_name":"PoPlus","can_delete":false,"product_type":"c1","uid":1574765,"ip_address":"","ucode":"5F0927921317F2","user_header":"https://static001.geekbang.org/account/avatar/00/18/07/6d/4c1909be.jpg","comment_is_top":false,"comment_ctime":1642669108,"is_pvip":false,"replies":[{"id":"121181","content":"简单解释：<br><br>多线程同步问题，往往都是由于“共享可变状态”导致的。如果拥有“不变性”的话，是不是就少了些麻烦呢？并发里面，最麻烦的就是同步问题，解决了同步问题后，并发就没那么可怕了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642757120,"ip_address":"","comment_id":331605,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642669108","product_id":100103401,"comment_content":"想了解不变性无状态等特点更适合并发编程的原因～","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547585,"discussion_content":"简单解释：\n\n多线程同步问题，往往都是由于“共享可变状态”导致的。如果拥有“不变性”的话，是不是就少了些麻烦呢？并发里面，最麻烦的就是同步问题，解决了同步问题后，并发就没那么可怕了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642757121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331216,"user_name":"小猪佩琪007","can_delete":false,"product_type":"c1","uid":1339771,"ip_address":"","ucode":"823E239A9B5496","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/7b/4b6079e6.jpg","comment_is_top":false,"comment_ctime":1642488725,"is_pvip":true,"replies":[{"id":"121048","content":"加油~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642557387,"ip_address":"","comment_id":331216,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642488725","product_id":100103401,"comment_content":"醍醐灌顶，拨云见日","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547143,"discussion_content":"加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642557387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330984,"user_name":"杨浩","can_delete":false,"product_type":"c1","uid":1333606,"ip_address":"","ucode":"4D51BD8452BF04","user_header":"https://static001.geekbang.org/account/avatar/00/14/59/66/e2839938.jpg","comment_is_top":false,"comment_ctime":1642339807,"is_pvip":false,"replies":[{"id":"120995","content":"不错的见解。Android领域如果追求极致的性能的话，会用C++的，所以Java的地位反而比较尴尬。服务端的话，差不多也是这样，只是说Java在服务端的护城河更深一些。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642479443,"ip_address":"","comment_id":330984,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642339807","product_id":100103401,"comment_content":"才接触kotlin，个人理解如果是Android，kotlin就是生产力值得深耕，绝大多数情况kotlin即可，少数需要高性能的用java。<br><br>我的理解如果是用在服务端，kotlin适合高并发、IO类的应用，不适合计算型。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546963,"discussion_content":"不错的见解。Android领域如果追求极致的性能的话，会用C++的，所以Java的地位反而比较尴尬。服务端的话，差不多也是这样，只是说Java在服务端的护城河更深一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642479444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330747,"user_name":"Will","can_delete":false,"product_type":"c1","uid":2722876,"ip_address":"","ucode":"8D07F51F9050E1","user_header":"https://static001.geekbang.org/account/avatar/00/29/8c/3c/bb79b9d7.jpg","comment_is_top":false,"comment_ctime":1642143299,"is_pvip":false,"replies":[{"id":"120663","content":"感谢你的认可~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642225888,"ip_address":"","comment_id":330747,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642143299","product_id":100103401,"comment_content":"博采众长，很重要啊，这篇文章，我感觉就挺好。<br>如果硬是按个别读者的要求，多塞技术难点进去，不见的能起到普传的效果。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546205,"discussion_content":"感谢你的认可~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642225888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330708,"user_name":"new start","can_delete":false,"product_type":"c1","uid":1220171,"ip_address":"","ucode":"3F531CA4308974","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/4b/bb734fa7.jpg","comment_is_top":false,"comment_ctime":1642127454,"is_pvip":false,"replies":[{"id":"120599","content":"以后加餐少不了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642133313,"ip_address":"","comment_id":330708,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642127454","product_id":100103401,"comment_content":"这个餐有点少，不够吃","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546025,"discussion_content":"以后加餐少不了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642133313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330705,"user_name":"20220106","can_delete":false,"product_type":"c1","uid":2884743,"ip_address":"","ucode":"DC9E91125B21C6","user_header":"","comment_is_top":false,"comment_ctime":1642126314,"is_pvip":false,"replies":[{"id":"120603","content":"是的，讲的很透彻。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642133424,"ip_address":"","comment_id":330705,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642126314","product_id":100103401,"comment_content":"第一感觉，这种”类函数式编程“仍然是在表面上改变，看到的简洁其背后仍旧是机械化的工作重复，我的意思是这种变化是有限的，即使这种变化很被人接受。就比如如今的AI和人本身还相距甚远。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546029,"discussion_content":"是的，讲的很透彻。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642133424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330702,"user_name":"7Promise","can_delete":false,"product_type":"c1","uid":2879220,"ip_address":"","ucode":"BF7C7F042E51F3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/f4/27a5080a.jpg","comment_is_top":false,"comment_ctime":1642125287,"is_pvip":false,"replies":[{"id":"120602","content":"赞~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642133372,"ip_address":"","comment_id":330702,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642125287","product_id":100103401,"comment_content":"函数式编程在我理解中和函数单一功能原则有关系，将各个功能分解成尽量少代码的函数，运用在各个可能存在的地方。再加上巧妙运用kotlin自带或者自己编写的高级函数以及拓展函数。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546028,"discussion_content":"赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642133372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330700,"user_name":"colin","can_delete":false,"product_type":"c1","uid":1120970,"ip_address":"","ucode":"60C4004CB755FF","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/ca/50c1fd43.jpg","comment_is_top":false,"comment_ctime":1642124958,"is_pvip":false,"replies":[{"id":"120601","content":"我加油写，你加油学~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642133353,"ip_address":"","comment_id":330700,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642124958","product_id":100103401,"comment_content":"催更啦","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546027,"discussion_content":"我加油写，你加油学~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642133353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330699,"user_name":"Renext","can_delete":false,"product_type":"c1","uid":1020838,"ip_address":"","ucode":"3C4418F7E86CD6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","comment_is_top":false,"comment_ctime":1642124338,"is_pvip":false,"replies":[{"id":"120600","content":"好的，记下了","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642133334,"ip_address":"","comment_id":330699,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642124338","product_id":100103401,"comment_content":"详细聊聊 Kotlin 函数式编程在 Compose 当中的体现吧","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546026,"discussion_content":"好的，记下了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642133334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}