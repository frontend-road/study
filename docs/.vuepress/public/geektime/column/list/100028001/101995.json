{"id":101995,"title":"14 | 多线程之锁优化（下）：使用乐观锁优化并行操作","content":"<p>你好，我是刘超。</p><p>前两讲我们讨论了Synchronized和Lock实现的同步锁机制，这两种同步锁都属于悲观锁，是保护线程安全最直观的方式。</p><p>我们知道悲观锁在高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。那有没有可能实现一种非阻塞型的锁机制来保证线程的安全呢？答案是肯定的。今天我就带你学习下乐观锁的优化方法，看看怎么使用才能发挥它最大的价值。</p><h2>什么是乐观锁</h2><p>开始优化前，我们先来简单回顾下乐观锁的定义。</p><p>乐观锁，顾名思义，就是说在操作共享资源时，它总是抱着乐观的态度进行，它认为自己可以成功地完成操作。但实际上，当多个线程同时操作一个共享资源时，只有一个线程会成功，那么失败的线程呢？它们不会像悲观锁一样在操作系统中挂起，而仅仅是返回，并且系统允许失败的线程重试，也允许自动放弃退出操作。</p><p>所以，乐观锁相比悲观锁来说，不会带来死锁、饥饿等活性故障问题，线程间的相互影响也远远比悲观锁要小。更为重要的是，<span class=\"orange\">乐观锁没有因竞争造成的系统开销，所以在性能上也是更胜一筹。</span></p><h2>乐观锁的实现原理</h2><p>相信你对上面的内容是有一定的了解的，下面我们来看看乐观锁的实现原理，有助于我们从根本上总结优化方法。</p><!-- [[[read_end]]] --><p>CAS是实现乐观锁的核心算法，它包含了3个参数：V（需要更新的变量）、E（预期值）和N（最新值）。</p><p>只有当需要更新的变量等于预期值时，需要更新的变量才会被设置为最新值，如果更新值和预期值不同，则说明已经有其它线程更新了需要更新的变量，此时当前线程不做操作，返回V的真实值。</p><h3>1.CAS如何实现原子操作</h3><p>在JDK中的concurrent包中，atomic路径下的类都是基于CAS实现的。AtomicInteger就是基于CAS实现的一个线程安全的整型类。下面我们通过源码来了解下如何使用CAS实现原子操作。</p><p>我们可以看到AtomicInteger的自增方法getAndIncrement是用了Unsafe的getAndAddInt方法，显然AtomicInteger依赖于本地方法Unsafe类，Unsafe类中的操作方法会调用CPU底层指令实现原子操作。</p><pre><code>  //基于CAS操作更新值\n    public final boolean compareAndSet(int expect, int update) {\n        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n    }\n    //基于CAS操作增1\n    public final int getAndIncrement() {\n        return unsafe.getAndAddInt(this, valueOffset, 1);\n    }\n    \n    //基于CAS操作减1\n    public final int getAndDecrement() {\n        return unsafe.getAndAddInt(this, valueOffset, -1);\n \n</code></pre><h3>2.处理器如何实现原子操作</h3><p>CAS是调用处理器底层指令来实现原子操作，那么处理器底层又是如何实现原子操作的呢？</p><p>处理器和物理内存之间的通信速度要远慢于处理器间的处理速度，所以处理器有自己的内部缓存。如下图所示，在执行操作时，频繁使用的内存数据会缓存在处理器的L1、L2和L3高速缓存中，以加快频繁读取的速度。</p><p><img src=\"https://static001.geekbang.org/resource/image/15/f0/15ffcf63bf097a6db4826000f1923af0.png?wh=843*534\" alt=\"\"></p><p>一般情况下，一个单核处理器能自我保证基本的内存操作是原子性的，当一个线程读取一个字节时，所有进程和线程看到的字节都是同一个缓存里的字节，其它线程不能访问这个字节的内存地址。</p><p>但现在的服务器通常是多处理器，并且每个处理器都是多核的。每个处理器维护了一块字节的内存，每个内核维护了一块字节的缓存，这时候多线程并发就会存在缓存不一致的问题，从而导致数据不一致。</p><p>这个时候，处理器提供了<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性。</p><p>当处理器要操作一个共享变量的时候，其在总线上会发出一个Lock信号，这时其它处理器就不能操作共享变量了，该处理器会独享此共享内存中的变量。但总线锁定在阻塞其它处理器获取该共享变量的操作请求时，也可能会导致大量阻塞，从而增加系统的性能开销。</p><p>于是，后来的处理器都提供了缓存锁定机制，也就说当某个处理器对缓存中的共享变量进行了操作，就会通知其它处理器放弃存储该共享资源或者重新读取该共享资源。<span class=\"orange\">目前最新的处理器都支持缓存锁定机制。</span></p><h2>优化CAS乐观锁</h2><p>虽然乐观锁在并发性能上要比悲观锁优越，但是在写大于读的操作场景下，CAS失败的可能性会增大，如果不放弃此次CAS操作，就需要循环做CAS重试，这无疑会长时间地占用CPU。</p><p>在Java7中，通过以下代码我们可以看到：AtomicInteger的getAndSet方法中使用了for循环不断重试CAS操作，如果长时间不成功，就会给CPU带来非常大的执行开销。到了Java8，for循环虽然被去掉了，但我们反编译Unsafe类时就可以发现该循环其实是被封装在了Unsafe类中，CPU的执行开销依然存在。</p><pre><code>   public final int getAndSet(int newValue) {\n        for (;;) {\n            int current = get();\n            if (compareAndSet(current, newValue))\n                return current;\n        }\n    }\n</code></pre><p>在JDK1.8中，Java提供了一个新的原子类LongAdder。<span class=\"orange\">LongAdder在高并发场景下会比AtomicInteger和AtomicLong的性能更好，</span>代价就是会消耗更多的内存空间。</p><p>LongAdder的原理就是降低操作共享变量的并发数，也就是将对单一共享变量的操作压力分散到多个变量值上，将竞争的每个写线程的value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的value值进行CAS操作，最后在读取值的时候会将原子操作的共享变量与各个分散在数组的value值相加，返回一个近似准确的数值。</p><p>LongAdder内部由一个base变量和一个cell[]数组组成。当只有一个写线程，没有竞争的情况下，LongAdder会直接使用base变量作为原子操作变量，通过CAS操作修改变量；当有多个写线程竞争的情况下，除了占用base变量的一个写线程之外，其它各个线程会将修改的变量写入到自己的槽cell[]数组中，最终结果可通过以下公式计算得出：</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/bd/d1fad4bd9f40383a69b9eefda14c37bd.jpg?wh=688*194\" alt=\"\"></p><p>我们可以发现，LongAdder在操作后的返回值只是一个近似准确的数值，但是LongAdder最终返回的是一个准确的数值， 所以<span class=\"orange\">在一些对实时性要求比较高的场景下，LongAdder并不能取代AtomicInteger或AtomicLong。</span></p><h2>总结</h2><p>在日常开发中，使用乐观锁最常见的场景就是数据库的更新操作了。为了保证操作数据库的原子性，我们常常会为每一条数据定义一个版本号，并在更新前获取到它，到了更新数据库的时候，还要判断下已经获取的版本号是否被更新过，如果没有，则执行该操作。</p><p>CAS乐观锁在平常使用时比较受限，它只能保证单个变量操作的原子性，当涉及到多个变量时，CAS就无能为力了，但前两讲讲到的悲观锁可以通过对整个代码块加锁来做到这点。</p><p>CAS乐观锁在高并发写大于读的场景下，大部分线程的原子操作会失败，失败后的线程将会不断重试CAS原子操作，这样就会导致大量线程长时间地占用CPU资源，给系统带来很大的性能开销。在JDK1.8中，Java新增了一个原子类LongAdder，它使用了空间换时间的方法，解决了上述问题。</p><p>11～13讲的内容，我详细地讲解了基于JVM实现的同步锁Synchronized，AQS实现的同步锁Lock以及CAS实现的乐观锁。相信你也很好奇，这三种锁，到底哪一种的性能最好，现在我们来对比下三种不同实现方式下的锁的性能。</p><p>鉴于脱离实际业务场景的性能对比测试没有意义，我们可以分别在“读多写少”“读少写多”“读写差不多”这三种场景下进行测试。又因为锁的性能还与竞争的激烈程度有关，所以除此之外，我们还将做三种锁在不同竞争级别下的性能测试。</p><p>综合上述条件，我将对四种模式下的五个锁Synchronized、ReentrantLock、ReentrantReadWriteLock、StampedLock以及乐观锁LongAdder进行压测。</p><p>这里简要说明一下：我是在不同竞争级别的情况下，用不同的读写线程数组合出了四组测试，测试代码使用了计算并发计数器，读线程会去读取计数器的值，而写线程会操作变更计数器值，运行环境是4核的i7处理器。结果已给出，具体的测试代码可以点击<a href=\"https://github.com/nickliuchao/lockTest\">Github</a>查看下载。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/1e/d5906bf5be6a91cb4ab3e4511da2421e.jpg?wh=2022*1154\" alt=\"\"></p><p>通过以上结果，我们可以发现：在读大于写的场景下，读写锁ReentrantReadWriteLock、StampedLock以及乐观锁的读写性能是最好的；在写大于读的场景下，乐观锁的性能是最好的，其它4种锁的性能则相差不多；在读和写差不多的场景下，两种读写锁以及乐观锁的性能要优于Synchronized和ReentrantLock。</p><h2>思考题</h2><p><span class=\"orange\">我们在使用CAS操作的时候要注意的ABA问题指的是什么呢？</span></p><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起学习。</p><p></p>","neighbors":{"left":{"article_title":"13 | 多线程之锁优化（中）：深入了解Lock同步锁的优化方法","id":101651},"right":{"article_title":"15 | 多线程调优（上）：哪些操作导致了上下文切换？","id":102619}},"comments":[{"had_liked":false,"id":105335,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1560988217,"is_pvip":false,"replies":[{"id":"38137","content":"不仅回答了问题，还给出了解决方案，赞一个","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560994823,"ip_address":"","comment_id":105335,"utype":1}],"discussion_count":1,"race_medal":0,"score":"220604320313","product_id":100028001,"comment_content":"变量的原值为A，当线程T读取后到更新前这段时间，可能被其他线程更新为B值后又更新回A值，到当线程T进行CAS操作时感知不到这个变化，依然可以更新成功；StampdLock通过过去锁时返回一个时间戳可以解决该问题。","like_count":51,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454637,"discussion_content":"不仅回答了问题，还给出了解决方案，赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560994823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105341,"user_name":"colin","can_delete":false,"product_type":"c1","uid":1292206,"ip_address":"","ucode":"7A8849B8AE33E0","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","comment_is_top":false,"comment_ctime":1560988890,"is_pvip":false,"replies":[{"id":"38136","content":"假设操作后立即要获取到值，这个值可能是一个不准确的值。如果我们等待所有线程执行完成之后去获取，这个值肯定是准确的值。一般在做统计时，会经常用到这种操作，实时展现的只要求一个近似值，但最终的统计要求是准确的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560994775,"ip_address":"","comment_id":105341,"utype":1}],"discussion_count":1,"race_medal":0,"score":"96050269402","product_id":100028001,"comment_content":"老师您好，cell数组里存数得是+1 -1这种操作值么？<br><br>还有，“LongAdder 在操作后的返回值只是一个近似准确的数值，但是 LongAdder 最终返回的是一个准确的数值”这句话中“操作后返回值”和“最终返回值”怎么理解？","like_count":23,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454640,"discussion_content":"假设操作后立即要获取到值，这个值可能是一个不准确的值。如果我们等待所有线程执行完成之后去获取，这个值肯定是准确的值。一般在做统计时，会经常用到这种操作，实时展现的只要求一个近似值，但最终的统计要求是准确的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560994775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216308,"user_name":"gerry pang","can_delete":false,"product_type":"c1","uid":1068169,"ip_address":"","ucode":"54BD1D8DE1DBBF","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/89/e698c0a9.jpg","comment_is_top":false,"comment_ctime":1589240557,"is_pvip":false,"replies":[{"id":"80538","content":"虽然都是无限循环，但for(;;)是无条件循环，而while(true)是有条件循环，for(;;)编译后的指令非常简单，而while(true)编译后的指令包含了跳转、判断等。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1589618304,"ip_address":"","comment_id":216308,"utype":1}],"discussion_count":2,"race_medal":0,"score":"83193619181","product_id":100028001,"comment_content":"老师，我看源码中大量用for(;;)，请问那它和while(true)之间有什么明显的性能区别吗？","like_count":19,"discussions":[{"author":{"id":1174371,"avatar":"https://static001.geekbang.org/account/avatar/00/11/eb/63/09e7f442.jpg","nickname":"溯雪","note":"","ucode":"E819E5454BF216","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312011,"discussion_content":"两种写法编译了再反编译回来发现都是一样的(我的环境是open jdk11)，现在的编译器还是很强大的，赶脚我们撸代码的时候应该更关注可读性，这些细节大可交给编译器去优化。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602560818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494764,"discussion_content":"虽然都是无限循环，但for(;;)是无条件循环，而while(true)是有条件循环，for(;;)编译后的指令非常简单，而while(true)编译后的指令包含了跳转、判断等。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589618304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127417,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1566703870,"is_pvip":false,"replies":[{"id":"47295","content":"我们假设一个队列来分析ABA问题，会更好理解。<br><br>如果一个队列有A\\B\\A三个数据，在线程1获取队列头节点数据A后，如果CAS发现数据没有变，则修改头节点A为A1，此时正好有一个线程删除了头节点A，又有另外一个线程也删除了后来成为头节点的B，此时头节点是依然是A，而此时第一个线程去修改A，这将导致实际修改的不是队列刚开始的那个节点A。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566785028,"ip_address":"","comment_id":127417,"utype":1}],"discussion_count":1,"race_medal":1,"score":"83171082494","product_id":100028001,"comment_content":"老师，ABA的问题，CAS最终关心的是：值是否是A。那ABA的影响是什么呢?","like_count":19,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464481,"discussion_content":"我们假设一个队列来分析ABA问题，会更好理解。\n\n如果一个队列有A\\B\\A三个数据，在线程1获取队列头节点数据A后，如果CAS发现数据没有变，则修改头节点A为A1，此时正好有一个线程删除了头节点A，又有另外一个线程也删除了后来成为头节点的B，此时头节点是依然是A，而此时第一个线程去修改A，这将导致实际修改的不是队列刚开始的那个节点A。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566785028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105392,"user_name":"crazypokerk","can_delete":false,"product_type":"c1","uid":1158383,"ip_address":"","ucode":"9AAD5D9726E503","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/ef/494f56c3.jpg","comment_is_top":false,"comment_ctime":1560992173,"is_pvip":false,"replies":[{"id":"38129","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560993046,"ip_address":"","comment_id":105392,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74575436205","product_id":100028001,"comment_content":"LongAdder原理如下：将热点数据value被分离成多个单元的cell，每个cell独自维护内部的值，当前对象的实际值由cell[]数组中所有的cell累计合成。这样，热点就进行了有效的分离，提高了并行度，所以LongAdder虽然降低了并发竞争，但是却对实时更新的数据不友好。","like_count":17,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454662,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560993046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105968,"user_name":"陆离","can_delete":false,"product_type":"c1","uid":1483932,"ip_address":"","ucode":"2C8C206CE36A81","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg","comment_is_top":false,"comment_ctime":1561116886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40215822550","product_id":100028001,"comment_content":"解决ABA可以利用一个版本号进行验证，每次更新，版本号都+1，同时满足版本号与旧值相同才更新","like_count":9},{"had_liked":false,"id":105456,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1561004662,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27330808438","product_id":100028001,"comment_content":"Longaddr还是不能理解,能否在举个简单点的例子理解吗？","like_count":6,"discussions":[{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573129,"discussion_content":"举个例子，\n\n① 有十个人想去捐款，正常情况下只有一个捐款箱子每次只能有一个人进行投币（有竞争）；\n\n② 如果我们准备10个箱子分别给十个人进行投币（此时不存在竞争关系），最后将结果汇总，得到最终金额数目；\n\n③ LongAddr之所以得到的可能是个近视值，就是在写完后需要立即读的情况下cell数组可能还没汇总，就会得到一个不准确的值；\n\nPS：这里的十个人好比10个线程，捐款箱好比内存（对呀cell数组）\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1653213656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107238,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1561507492,"is_pvip":false,"replies":[{"id":"38805","content":"通常情况下，乐观锁的性能是要优于悲观锁，跟线程数量没有太大关系","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561512229,"ip_address":"","comment_id":107238,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18741376676","product_id":100028001,"comment_content":"根据你的测试结果，都是乐观锁最优，是不是线程变为100个或者以上，其他测试结果才会优于乐观锁？","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455434,"discussion_content":"通常情况下，乐观锁的性能是要优于悲观锁，跟线程数量没有太大关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561512229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105568,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1561032729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14445934617","product_id":100028001,"comment_content":"请教老师两个问题:<br>1. 文章中的这句话我不太理解, &quot;我们可以发现，LongAdder 在操作后的返回值只是一个近似准确的数值，但是 LongAdder 最终返回的是一个准确的数值&quot;. 这么判断的依据是value的计算公式吗, 为什么value的计算公式可以保证最终返回的准确性, 公式中base和数组中各个槽的权重不一样, 为什么base有这么大的权重呢?<br>2. 单核CPU是靠什么机制保证其他线程和进程都看到的缓存中的内容而不是内存中的内容呢?","like_count":3},{"had_liked":false,"id":121015,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1565050462,"is_pvip":false,"replies":[{"id":"51153","content":"1、乐观锁是一种概念，通过版本号来实现锁是一种乐观锁，而CAS是一种乐观锁的具体实现；<br>2、CAS是通过底层CPU缓存锁定实现的，这里的总线锁没有涉及到synchronized，只是之前老的CPU是根据总线锁来实现的，由于更新换代，目前使用的是性能更好的缓存锁。<br><br>建议多阅读几次文章。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568542487,"ip_address":"","comment_id":121015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10154985054","product_id":100028001,"comment_content":"这里想反馈一下，每个小节都讲得太绕了，老师可否直接点题，我越看越困惑：<br>1，关于“什么是乐观锁”。乐观锁=CAS？CAS不是属于无锁嘛，所以乐观锁=无锁？<br>2，关于“CAS的实现原理”。CAS是通过锁缓存来实现的，是吗？而synchronized是锁总线，是吗？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461576,"discussion_content":"1、乐观锁是一种概念，通过版本号来实现锁是一种乐观锁，而CAS是一种乐观锁的具体实现；\n2、CAS是通过底层CPU缓存锁定实现的，这里的总线锁没有涉及到synchronized，只是之前老的CPU是根据总线锁来实现的，由于更新换代，目前使用的是性能更好的缓存锁。\n\n建议多阅读几次文章。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568542487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110042,"user_name":"文灏","can_delete":false,"product_type":"c1","uid":1122739,"ip_address":"","ucode":"177D548FC87BED","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/b3/db933462.jpg","comment_is_top":false,"comment_ctime":1562157361,"is_pvip":false,"replies":[{"id":"39949","content":"例如，我们在做销量统计的时候，用到LongAdder 统计销量，我们只需要保证最终写入的销量，在以后查询是是准确的。具体的时间也许是毫秒之后能查到，也许是分钟之后，但我们只需要保证在写入之后，能最终统计之前写入的销量。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562208412,"ip_address":"","comment_id":110042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10152091953","product_id":100028001,"comment_content":"LongAdder 在操作后的返回值只是一个近似准确的数值, 但是 LongAdder 最终返回的是一个准确的数值. 那什么时候才能知道LongAdder现在返回的值是正确的了呢？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456696,"discussion_content":"例如，我们在做销量统计的时候，用到LongAdder 统计销量，我们只需要保证最终写入的销量，在以后查询是是准确的。具体的时间也许是毫秒之后能查到，也许是分钟之后，但我们只需要保证在写入之后，能最终统计之前写入的销量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562208412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105932,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1561106123,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10151040715","product_id":100028001,"comment_content":"ABA问题指的是假设现在有一个变量count的值为A，线程T1在未读取count值之前，线程T2把count值改为B，线程T3又把count值改为A，当线程T1读取count发现值为A，虽然值还是A，但是已经被其他线程改变过。<br>数值的原子递增可以不关注ABA问题，但是如果是原子化的更新对象，就需要关注ABA问题，因为有可能属性值发生了改变","like_count":2,"discussions":[{"author":{"id":2559704,"avatar":"https://static001.geekbang.org/account/avatar/00/27/0e/d8/2c4b709f.jpg","nickname":"perfect","note":"","ucode":"CA4290C59203F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389406,"discussion_content":"我也觉得是这样，老师你觉得呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629266866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346525,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1653213201,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5948180497","product_id":100028001,"comment_content":"今日收获<br><br>LongAdder 的原理就是降低操作共享变量的并发数，也就是将对单一共享变量的操作压力分散到多个变量值上，将竞争的每个写线程的 value 值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的 value 值进行 CAS 操作，最后在读取值的时候会将原子操作的共享变量与各个分散在数组的 value 值相加，返回一个近似准确的数值。","like_count":1},{"had_liked":false,"id":149269,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1573180782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868148078","product_id":100028001,"comment_content":"ABA的问题使用自增版本号或者时间戳就可以解决","like_count":1},{"had_liked":false,"id":107731,"user_name":"寻","can_delete":false,"product_type":"c1","uid":1147468,"ip_address":"","ucode":"4A79D34088BD10","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/4c/0134a7bd.jpg","comment_is_top":false,"comment_ctime":1561600464,"is_pvip":false,"replies":[{"id":"39153","content":"赞","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561684556,"ip_address":"","comment_id":107731,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856567760","product_id":100028001,"comment_content":"很有帮助，系统性的重新审视学习各个锁，顺带将老师的测试代码用JMH测试框架、面向对象化重构了下。<br>https:&#47;&#47;github.com&#47;seasonsolt&#47;lockTest，有助于自己进一步深度学习研究。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455642,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561684556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106436,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1561300561,"is_pvip":false,"replies":[{"id":"38496","content":"原理就是，当某个处理器对缓存中的共享变量进行了操作，就会通知其它处理器放弃对存储该共享资源或者重新读取该共享资源。<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561338832,"ip_address":"","comment_id":106436,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5856267857","product_id":100028001,"comment_content":"cas方法的三个参数是如何和cpu的缓存锁定机制联系到一起的呢？感觉没有理解，还请老师解答。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455089,"discussion_content":"原理就是，当某个处理器对缓存中的共享变量进行了操作，就会通知其它处理器放弃对存储该共享资源或者重新读取该共享资源。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561338832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1807844,"avatar":"","nickname":"koutann","note":"","ucode":"CA3E9BB3C7C611","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270564,"discussion_content":"其他处理器重新读取改共享资源是可以不加锁了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590025446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105881,"user_name":"slowChef","can_delete":false,"product_type":"c1","uid":1261189,"ip_address":"","ucode":"3EEA86E90218B1","user_header":"https://static001.geekbang.org/account/avatar/00/13/3e/85/19a35e33.jpg","comment_is_top":false,"comment_ctime":1561098602,"is_pvip":false,"replies":[{"id":"38423","content":"乐观锁的性能要优于悲观锁，这个没问题。但乐观锁并不是适合所有场景，所以很多时候还是需要使用到悲观锁。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561255725,"ip_address":"","comment_id":105881,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856065898","product_id":100028001,"comment_content":"如果从这个图看，LongAdder在几乎所有场景都远优于其他锁呀，是不是有问题呢？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454848,"discussion_content":"乐观锁的性能要优于悲观锁，这个没问题。但乐观锁并不是适合所有场景，所以很多时候还是需要使用到悲观锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561255725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105412,"user_name":"Loubobooo","can_delete":false,"product_type":"c1","uid":1108306,"ip_address":"","ucode":"7B2543A80EBDEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/52/aa3be800.jpg","comment_is_top":false,"comment_ctime":1560994957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855962253","product_id":100028001,"comment_content":"一个变量V，如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。","like_count":1},{"had_liked":false,"id":350707,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1657106229,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657106229","product_id":100028001,"comment_content":"ABA就是某个变量被修改后又被改回来，此时正在CAS的线程是分辨不出这个变量是否被修改过。这个时候应该给数据加个版本号。","like_count":0},{"had_liked":false,"id":307961,"user_name":"perfect","can_delete":false,"product_type":"c1","uid":2559704,"ip_address":"","ucode":"CA4290C59203F8","user_header":"https://static001.geekbang.org/account/avatar/00/27/0e/d8/2c4b709f.jpg","comment_is_top":false,"comment_ctime":1629339765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629339765","product_id":100028001,"comment_content":"老师你的请求量1000在代码中指的是int maxValue = 1000吗？？我测出来的结果跟你完全不一样，都是StampedLock锁最好","like_count":0},{"had_liked":false,"id":307625,"user_name":"perfect","can_delete":false,"product_type":"c1","uid":2559704,"ip_address":"","ucode":"CA4290C59203F8","user_header":"https://static001.geekbang.org/account/avatar/00/27/0e/d8/2c4b709f.jpg","comment_is_top":false,"comment_ctime":1629183184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629183184","product_id":100028001,"comment_content":"老师，Github进不去，能不能上传到gitee","like_count":0},{"had_liked":false,"id":300785,"user_name":"平民人之助","can_delete":false,"product_type":"c1","uid":2658705,"ip_address":"","ucode":"5CCEC0BAC08AEC","user_header":"https://static001.geekbang.org/account/avatar/00/28/91/91/428a27a3.jpg","comment_is_top":false,"comment_ctime":1625386393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625386393","product_id":100028001,"comment_content":"ABA是数据没有version，用atomicreferencestamped","like_count":0},{"had_liked":false,"id":281200,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1614643116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614643116","product_id":100028001,"comment_content":"第一个线程获取A .在最后更新的时候虽然 值还是A.但是版本号已经变化了，为啥还会更新<br>","like_count":0},{"had_liked":false,"id":132175,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568036900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568036900","product_id":100028001,"comment_content":"课后思考及问题<br>1：本文核心观点<br>1-1：乐观锁的实现核心——CAS，它包含了 3 个参数：V（需要更新的变量）、E（预期值）和 N（最新值）。<br>只有当需要更新的变量等于预期值时，需要更新的变量才会被设置为最新值，如果更新值和预期值不同，则说明已经有其它线程更新了需要更新的变量，此时当前线程不做操作，返回 V 的真实值。<br>1-2：通常情况下乐观锁的性能由于悲观锁，不过乐观锁有一定的使用场景，比如：它只能保证单个变量操作的原子性，当涉及到多个变量时，CAS 就无能为力，适用竞争不激烈的场景<br>1-3：对于ABA问题，乐观锁解决不了<br>1-4：ABA问题是指一个线程修改数据时，获取的最新值是A，在修改之前又有其他的线程将此值做了修改，比如：先改成了B后来又有线程将B改成了A，但是最早的那个线程是不知道的，还会修改成功的。老师在评论区给出了一个更通俗易懂的例子——如果一个队列有A\\B\\A三个数据，在线程1获取队列头节点数据A后，如果CAS发现数据没有变，则修改头节点A为A1，此时正好有一个线程删除了头节点A，又有另外一个线程也删除了后来成为头节点的B，此时头节点是依然是A，而此时第一个线程去修改A，这将导致实际修改的不是队列刚开始的那个节点A。<br>1-5：ABA问题的解决思路<br>1-5-1：StampdLock通过获取锁时返回一个时间戳可以解决<br>1-5-2：通过添加版本号，版本号每次修改都增加一个版本，这样也能解决","like_count":0},{"had_liked":false,"id":107295,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1561512441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561512441","product_id":100028001,"comment_content":"说乐观锁会占用大量的cpu导致性能下降，如果不是线程数影响，那哪些场景下乐观锁效率会低于悲观锁？","like_count":0},{"had_liked":false,"id":105832,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1561090454,"is_pvip":false,"replies":[{"id":"38424","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561255741,"ip_address":"","comment_id":105832,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561090454","product_id":100028001,"comment_content":"关于最后的问题老师是不是可以通过版本号之类来控制，版本号只增加不减少是不是可以解决这个问题那","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454832,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561255741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105828,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1561090234,"is_pvip":false,"replies":[{"id":"38425","content":"这三个等级的缓存都会涉及到，理解没问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561255842,"ip_address":"","comment_id":105828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561090234","product_id":100028001,"comment_content":"老师总线锁和缓存锁，这个缓存是l1还是L2还是L3那，总线锁可以理解成锁内存吗","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454828,"discussion_content":"这三个等级的缓存都会涉及到，理解没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561255842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105421,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1560996596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560996596","product_id":100028001,"comment_content":"老师好，我有两个问题想请教老师：<br>1.CAS实现原子性的方式我有点不太明白，缓存锁定解决的不应该是可见性的问题吗，保证当前线程对内存中数值的修改一定对其他线程可见，它是如何保证当前线程在获取值--&gt;修改值--&gt;写入值这个过程中不被其他的线程打断的呢？<br>2.通过性能对比其实可以发现，读写锁和StampedLock的性能相较于synchronized和可重入锁，要么差不多，要么更好，甚至在读少写多的情况下也体现出了一点点的优势，那么在使用锁的时候，我们为什么还要用后两种锁呢？他们的优点在哪里？<br>谢谢老师！","like_count":0},{"had_liked":false,"id":105410,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1560994594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560994594","product_id":100028001,"comment_content":"参考参数从a到b再到a，当前更新看不到变更过程，会误以为未变，从而更新成功。解决办法是引入累增版本，时间节也是累增版本。最后是一个性能对比图，和我以前看的问章性能对比差距有点大，隐试锁性能不该这么差的。","like_count":0},{"had_liked":false,"id":105408,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1560994098,"is_pvip":false,"replies":[{"id":"38176","content":"同学你好～测试图单位是时间，时间花费越多，性能越差。","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1561011374,"ip_address":"","comment_id":105408,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1560994098","product_id":100028001,"comment_content":"老师那个测试的图是不是有问题啊，怎么一直是sysn和relock。两个悲观锁性能最好啊。","like_count":0,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454670,"discussion_content":"同学你好～测试图单位是时间，时间花费越多，性能越差。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561011374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105346,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1560989229,"is_pvip":false,"replies":[{"id":"38135","content":"对的，Liam基础功扎实","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560994536,"ip_address":"","comment_id":105346,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560989229","product_id":100028001,"comment_content":"CAS compare的依据是变量的值，ABA是指该变量从A到B再到A的变化过程，虽然变量已经被修改，从结果来看，CAS还是会认为变量没有被修改","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454642,"discussion_content":"对的，Liam基础功扎实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560994536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}