{"id":473529,"title":"03 | Kotlin原理：编译器在幕后干了哪些“好事”？","content":"<p>你好，我是朱涛。</p><p>在前面两节课里，我们学了不少Kotlin的语法，其中有些语法是和Java类似的，比如数字类型、字符串；也有些语法是Kotlin所独有的，比如数据类、密封类。另外，我们还知道Kotlin和Java完全兼容，它们可以同时出现在一个代码工程当中，并且可以互相调用。</p><p>但是，这样就会引出一个问题：<strong>Java是如何识别Kotlin的独有语法的呢？</strong>比如，Java如何能够认识Kotlin里的“数据类”？</p><p>这就要从整个Kotlin的实现机制说起了。</p><p>所以，今天这节课，我会从Kotlin的编译流程出发，来带你探索这门语言的底层原理。在这个过程中，你会真正地理解，Kotlin是如何在实现灵活、简洁的语法的同时，还做到了兼容Java语言的。并且你在日后的学习和工作中，也可以根据今天所学的内容，来快速理解Kotlin的其他新特性。</p><h2>Kotlin的编译流程</h2><p>在介绍Kotlin的原理细节之前，我们先从宏观上看看它是如何运行在电脑上的，这其实就涉及到它的编译流程。</p><p>那么首先，你需要知道一件事情：你写出的Kotlin代码，电脑是无法直接理解的。即使是最简单的<code>println(\"Hello world.\")</code>，你将这行代码告诉电脑，它也是无法直接运行的。这是因为，Kotlin的语法是基于人类语言设计的，电脑没有人的思维，它只能理解二进制的0和1，不能理解println到底是什么东西。</p><!-- [[[read_end]]] --><p>因此，Kotlin的代码在运行之前，要先经过编译（Compile）。举个例子，假如我们现在有一个简单的Hello World程序：</p><pre><code class=\"language-plain\">println(\"Hello world.\")\n</code></pre><p>经过编译以后，它会变成类似这样的东西：</p><pre><code class=\"language-plain\">LDC \"Hello world.\"\nINVOKESTATIC kotlin/io/ConsoleKt.println (Ljava/lang/Object;)V\n</code></pre><p>上面两行代码，其实是Java的字节码。对，你没看错，<strong>Kotlin代码经过编译后，最终会变成Java字节码</strong>。这给人的感觉就像是：我说了一句中文，编译器将其翻译成了英文。而Kotlin和Java能够兼容的原因也在于此，<strong>Java和Kotlin本质上是在用同一种语言进行沟通。</strong></p><p>英语被看作人类世界的通用语言，那么Kotlin和Java用的是什么语言呢？没错，它们用的就是Java字节码。Java字节码并不是为人类设计的语言，它是专门给JVM执行的。</p><p>JVM，也被称作Java虚拟机，它拿到字节码后就可以解析出字节码的含义，并且在电脑里输出打印“<code>Hello World.</code>”。所以，你可以先把Java虚拟机理解为一种执行环境。回想我们在<a href=\"https://time.geekbang.org/column/article/472154\">第一节课</a>开头所安装的JDK，就是为了安装Java的编译器和Java的运行环境。</p><p>不过现在，你可能会有点晕头转向，还是没有搞清楚Kotlin的这个编译流程具体是怎么回事儿，也不清楚Kotlin和Java之间到底是什么关系。别着急，我们一起来看看下面这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/d6/0f/d67630808ee59a642b93d955ae8fa60f.jpg?wh=1920x1480\" alt=\"图片\"></p><p>这张图的内容其实非常直观，让我们从上到下，将整个过程再梳理一遍。</p><p>首先，我们写的Kotlin代码，编译器会以一定的规则将其翻译成Java字节码。这种字节码是专门为JVM而设计的，它的语法思想和汇编代码有点接近。</p><p>接着，JVM拿到字节码以后，会根据特定的语法来解析其中的内容，理解其中的含义，并且让字节码运行起来。</p><p><strong>那么，JVM到底是如何让字节码运行起来的呢？</strong>其实，JVM是建立在操作系统之上的一层抽象运行环境。举个简单的例子，Windows系统当中的程序是无法直接在Mac上面运行的。但是，我们写的Java程序却能同时在Windows、Mac、Linux系统上运行，这就是因为JVM在其中起了作用。</p><p>JVM定义了一套字节码规范，只要是符合这种规范的，都可以在JVM当中运行。至于JVM是如何跟不同的操作系统打交道的，我们不管。</p><p>还有一个更形象的例子，<strong>JVM就像是一个精通多国语言的翻译</strong>，我们只需要让JVM理解要做的事情，不管去哪个国家都不用关心，翻译会帮我们搞定剩下的事情。</p><p>最后，是计算机硬件。常见的计算机硬件包括台式机和笔记本电脑，这就是我们所熟知的东西了。</p><h2>如何研究Kotlin？</h2><p>在了解了Kotlin的编译流程之后，其实我们很容易就能想到办法了。</p><p>第一种思路，<strong>直接研究Kotlin编译后的字节码</strong>。如果我们能学会Java字节码的语法规则，那么就可以从字节码的层面去分析Kotlin的实现细节了。不过，这种方法明显吃力不讨好，即使我们学会了Java字节码的语法规则，对于一些稍微复杂一点的代码，我们分析起来也会十分吃力。</p><p>因此，我们可以尝试另一种思路：<strong>将Kotlin转换成字节码后，再将字节码反编译成等价的Java代码</strong>。最终，我们去分析等价的Java代码，通过这样的方式来理解Kotlin的实现细节。虽然这种方式不及字节码那样深入底层，但它的好处是足够直观，也方便我们去分析更复杂的代码逻辑。</p><p>这个过程看起来会有点绕，让我们用一个流程图来表示：</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/24/fdfbcf0b8a293acc91b5e435c99cb324.jpg?wh=2000x1074\" alt=\"\"></p><p>我们将其分为两个部分来看。先看红色虚线框外面的图，这是一个典型的Kotlin编译流程，Kotlin代码变成了字节码。另一个部分，是红色虚线框内部的图，我们用反编译器将Java字节码翻译成Java代码。经过这样一个流程后，我们就能得到和Kotlin等价的Java代码。</p><p>而这样，我们也可以得出这样一个结论，Kotlin的“<code>println</code>”和Java的“<code>System.out.println</code>”是等价的。</p><pre><code class=\"language-plain\">println(\"Hello world.\") /*\n          编译\n           ↓            */    \nLDC \"Hello world.\"\nINVOKESTATIC kotlin/io/ConsoleKt.println (Ljava/lang/Object;)V  /*\n         反编译\n           ↓            */\nString var0 = \"Hello world.\";\nSystem.out.println(var0);\n</code></pre><p>好了，思想和流程我们都清楚了，具体我们应该要怎么做呢？有以下几个步骤。</p><p>第一步，打开我们要研究的Kotlin代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/54/5f/54b189024034ae24bba4a40d1082995f.png?wh=717x260\" alt=\"图片\"></p><p>第二步，依次点击菜单栏：Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode。</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/e0/3b3439996bc37e26c0f12fa943c726e0.png?wh=933x499\" alt=\"图片\"></p><p>这时候，我们在右边的窗口中就可以看见Kotlin对应的字节码了。但这并不是我们想要的，所以要继续操作，将字节码转换成Java代码。</p><p>第三步，点击画面右边的“Decompile”按钮。</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/be/5e7d2835867b19de523c266d39980fbe.png?wh=1194x552\" alt=\"图片\"></p><p>最后，我们就能看见反编译出来的Java文件“Test_decompiled.java”。显而易见，main函数中的代码和我们前面所展示的是一致的：</p><p><img src=\"https://static001.geekbang.org/resource/image/40/52/40f13a1277f35113cb968fa7cc464f52.png?wh=1177x940\" alt=\"图片\"></p><p>OK，在知道如何研究Kotlin原理后，让我们来看一些实际的例子吧！</p><h2>Kotlin里到底有没有“原始类型”？</h2><p>不知道你还记不记得，之前我在<a href=\"https://time.geekbang.org/column/article/472154\">第1讲</a>中给你留过一个思考题：</p><blockquote>\n<p>虽然Kotlin在语法层面摒弃了“原始类型”，但有的时候为了性能考虑，我们确实需要用“原始类型”。这时候我们应该怎么办？</p>\n</blockquote><p>那么现在，我们已经知道了Kotlin与Java直接存在某种对应关系，所以要弄清楚这个问题，我们只需要知道“Kotlin的Long”与“Java long/Long”是否存在某种联系就可以了。</p><blockquote>\n<p><strong>注意：Java当中的long是原始类型，而Long是对象类型（包装类型）。</strong></p>\n</blockquote><p>说做就做，我们以Kotlin的Long类型为例。</p><pre><code class=\"language-plain\">// kotlin 代码\n\n// 用 val 定义可为空、不可为空的Long，并且赋值\nval a: Long = 1L\nval b: Long? = 2L\n\n// 用 var 定义可为空、不可为空的Long，并且赋值\nvar c: Long = 3L\nvar d: Long? = 4L\n\n// 用 var 定义可为空的Long，先赋值，然后改为null\nvar e: Long? = 5L\ne = null\n\n// 用 val 定义可为空的Long，直接赋值null\nval f: Long? = null\n\n// 用 var 定义可为空的Long，先赋值null，然后赋值数字\nvar g: Long? = null\ng = 6L\n</code></pre><p>这段代码的思路，其实就是将Kotlin的Long类型可能的使用情况都列举出来，然后去研究代码对应的Java反编译代码，如下所示：</p><pre><code class=\"language-java\">// 反编译后的 Java 代码\n\nlong a = 1L;\nlong b = 2L;\n\nlong c = 3L;\nlong d = 4L;\n\nLong e = 5L;\ne = (Long)null;\n\nLong f = (Long)null;\n\nLong g = (Long)null;\ng = 6L;\n</code></pre><p>可以看到，最终a、b、c、d被Kotlin转换成了Java的原始类型long；而e、f、g被转换成了Java里的包装类型Long。这里我们就来逐步分析一下：</p><ul>\n<li>对于变量a、c来说，它们两个的类型是不可为空的，所以无论如何都不能为null，对于这种情况，Kotlin编译器会直接将它们优化成原始类型。</li>\n<li>对于变量b、d来说，它们两个的类型虽然是可能为空的，但是它的值不为null，并且，编译器对上下文分析后发现，这两个变量也没有在别的地方被修改。这种情况，Kotlin编译器也会将它们优化成原始类型。</li>\n<li>对于变量e、f、g来说，不论它们是val还是var，只要它们被赋值过null，那么，Kotlin就无法对它们进行优化了。这背后的原因也很简单，Java的原始类型不是对象，只有对象才能被赋值为null。</li>\n</ul><p>我们可以用以下两个规律，来总结下Kotlin对基础类型的转换规则：</p><ul>\n<li>只要基础类型的变量可能为空，那么这个变量就会被转换成Java的包装类型。</li>\n<li>反之，只要基础类型的变量不可能为空，那么这个变量就会被转换成Java的原始类型。</li>\n</ul><p>好，接着我们再来看看另外一个例子。</p><h2>接口语法的局限性</h2><p>我在上节课，带你了解了Kotlin面向对象编程中的“接口”这个概念，其中我给你留了一个问题，就是：</p><blockquote>\n<p>接口的“成员属性”，是Kotlin独有的。请问它的局限性在哪？</p>\n</blockquote><p>那么在这里，我们就通过这个问题，来分析下Kotlin接口语法的实现原理，从而找出它的局限性。下面给出的，是一段接口代码示例：</p><pre><code class=\"language-plain\">// Kotlin 代码\n\ninterface Behavior {\n    // 接口内可以有成员属性\n    val canWalk: Boolean\n\n    // 接口方法的默认实现\n    fun walk() {\n        if (canWalk) {\n            println(canWalk)\n        }\n    }\n}\n\nprivate fun testInterface() {\n    val man = Man()\n    man.walk()\n}\n</code></pre><p>那么，要解答这个问题，我们也要弄清楚Kotlin的这两个特性，转换成对应的Java代码是什么样的。</p><pre><code class=\"language-plain\">// 等价的 Java 代码\n\npublic interface Behavior {\n   // 接口属性变成了方法\n   boolean getCanWalk();\n\n   // 方法默认实现消失了\n   void walk();\n\n   // 多了一个静态内部类\n   public static final class DefaultImpls {\n      public static void walk(Behavior $this) {\n         if ($this.getCanWalk()) {\n            boolean var1 = $this.getCanWalk();\n            System.out.println(var1);\n         }\n      }\n   }\n}\n</code></pre><p>从上面的Java代码中我们能看出来，Kotlin接口的“默认属性”canWalk，本质上并不是一个真正的属性，当它转换成Java以后，就变成了一个普通的接口方法getCanWalk()。</p><p>另外，Kotlin接口的“方法默认实现”，它本质上也没有直接提供实现的代码。对应的，它只是在接口当中定义了一个静态内部类“DefaultImpls”，然后将默认实现的代码放到了静态内部类当中去了。</p><p><strong>我们能看到，Kotlin的新特性，最终被转换成了一种Java能认识的语法。</strong></p><p>我们再具体来看看接口使用的细节：</p><pre><code class=\"language-plain\">// Kotlin 代码\n\nclass Man: Behavior {\n    override val canWalk: Boolean = true\n}\n</code></pre><p>以上代码中，我们定义了一个Man类，它实现了Behavior接口，与此同时它也重写了canWalk属性。另外，由于Behavior接口的walk()方法已经有了默认实现，所以Man可以不必实现walk()方法。</p><p>那么，<strong>Man类反编译成Java后，会变成什么样子呢？</strong></p><pre><code class=\"language-java\">// 等价的 Java 代码\n\npublic final class Man implements Behavior {\n   private final boolean canWalk = true;\n\n   public boolean getCanWalk() {\n      // 关键点 ①\n      return this.canWalk;\n   }\n\n   public void walk() {\n      // 关键点 ②\n      Behavior.DefaultImpls.walk(this);\n   }\n}\n</code></pre><p>可以看到，Man类里的getCanWalk()实现了接口当中的方法，从注释①那里我们注意到，getCanWalk()返回的还是它内部私有的canWalk属性，这就跟Kotlin当中的逻辑“override val canWalk: Boolean = true”对应上了。</p><p>另外，对于Man类当中的walk()方法，它将执行流程交给了“Behavior.DefaultImpls.walk()”，并将this作为参数传了进去。这里的逻辑，就可以跟Kotlin接口当中的默认方法逻辑对应上来了。</p><p>看完这一堆的代码之后，你的脑子可能会有点乱，我们用一张图来总结一下前面的内容吧：</p><p><img src=\"https://static001.geekbang.org/resource/image/88/b9/886dc2d7a5d5ee47934c1003447412b9.png?wh=1770x1230\" alt=\"图片\"></p><p>以上图中一共有5个箭头，它们揭示了Kotlin接口新特性的实现原理，让我们一个个来分析：</p><ul>\n<li>箭头①，代表Kotlin接口属性，实际上会被当中接口方法来看待。</li>\n<li>箭头②，代表Kotlin接口默认实现，实际上还是一个普通的方法。</li>\n<li>箭头③，代表Kotlin接口默认实现的逻辑是被放在DefaultImpls当中的，它成了静态内部类当中的一个静态方法DefaultImpls.walk()。</li>\n<li>箭头④，代表Kotlin接口的实现类必须要重写接口当中的属性，同时，它仍然还是一个方法。</li>\n<li>箭头⑤，即使Kotlin里的Man类没有实现walk()方法，但是从Java的角度看，它仍然存在walk()方法，并且，walk()方法将它的执行流程转交给了DefaultImpls.walk()，并将this传入了进去。这样，接口默认方法的逻辑就可以成功执行了。</li>\n</ul><p>到这里，我们的答案就呼之欲出了。Kotlin接口当中的属性，在它被真正实现之前，本质上并不是一个真正的属性。因此，Kotlin接口当中的属性，它既不能真正存储任何状态，也不能被赋予初始值，因为<strong>它本质上还是一个接口方法</strong>。</p><h2>小结</h2><p>到这里，你应该就明白了：你写的Kotlin代码，最终都会被Kotlin编译器进行一次统一的翻译，把它们变成Java能理解的格式。Kotlin的编译器，在这个过程当中就像是一个藏在幕后的翻译官。</p><p>可以说，Kotlin的每一个语法，最终都会被翻译成对应的Java字节码。但如果你不去反编译，你甚至感觉不到它在幕后做的那些事情。而正是因为Kotlin编译器在背后做的这些翻译工作，才可以让我们写出的Kotlin代码更加简洁、更加安全。</p><p>我们举一些更具体的例子：</p><ul>\n<li>类型推导，我们写Kotlin代码的时候省略的变量类型，最终被编译器补充回来了。</li>\n<li>原始类型，虽然Kotlin没有原始类型，但编译器会根据每一个变量的可空性将它们转换成“原始类型”或者“包装类型”。</li>\n<li>字符串模板，编译器最终会将它们转换成Java拼接的形式。</li>\n<li>when表达式，编译器最终会将它们转换成类似switch case的语句。</li>\n<li>类默认public，Kotlin当中被我们省略掉public，最终会被编译器补充。</li>\n<li>嵌套类默认static，我们在Kotlin当中的嵌套类，默认会被添加static关键字，将其变成静态内部类，防止不必要的内存泄漏。</li>\n<li>数据类，Kotlin当中简单的一行代码“data class Person(val name: String, val age: Int)”，编译器帮我们自动生成很多方法：getter()、setter()、equals()、hashCode()、toString()、componentN()、copy()。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/02/34/02702d48a28378817ed1598849bfbb34.jpg?wh=1920x912\" alt=\"图片\"></p><p>最后，我们还需要思考一个问题：<strong>Kotlin编译器一直在幕后帮忙做着翻译的好事，那它有没有可能“好心办坏事”？</strong>这个悬念留着，我们在第8讲再探讨。</p><h2>思考题</h2><p>在上节课当中，我们曾提到过，为Person类增加isAdult属性，我们要通过自定义getter来实现，比如说：</p><pre><code class=\"language-plain\">class Person(val name: String, var age: Int) {\n    val isAdult\n        get() = age &gt;= 18\n}\n</code></pre><p>而下面这种写法则是错误的：</p><pre><code class=\"language-plain\">class Person(val name: String, var age: Int) {\n    val isAdult = age &gt;= 18\n}\n</code></pre><p>请运用今天学到的知识来分析这个问题背后的原因。欢迎你在留言区分享你的答案和思路，我们下节课再见。</p>","comments":[{"had_liked":false,"id":328933,"user_name":"Renext","can_delete":false,"product_type":"c1","uid":1020838,"ip_address":"","ucode":"3C4418F7E86CD6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","comment_is_top":false,"comment_ctime":1640942145,"is_pvip":false,"replies":[{"id":"119852","content":"赞！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641002911,"ip_address":"","comment_id":328933,"utype":1}],"discussion_count":2,"race_medal":0,"score":"186324535873","product_id":100103401,"comment_content":"思考题：<br>转换成 java代码就一清二楚，两种方式的isAdult本质不是同一个东西：<br>1-通过自定义 getter 来实现的方式，isAdult其实是一个方法。外部每一次调用，都是拿最新的age进行计算，所以age的值有变动，isAdult()的结果是最新的。<br>2- val isAdult = age &gt;= 18 这种方式，isAdault是一个final变量，只会在对象新建时，在构造方法中，根据age的值赋值一次。所以，之后age的值如果有变动，isAdault值是永远不变的。<br><br>","like_count":44,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543190,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641002911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1191117,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2c/cd/314156af.jpg","nickname":"天网_beta","note":"","ucode":"57F334F9AA8EAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576647,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655724704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328956,"user_name":"阶前听雨","can_delete":false,"product_type":"c1","uid":1023236,"ip_address":"","ucode":"CFA211A7A15DB6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/04/a557d4f0.jpg","comment_is_top":false,"comment_ctime":1640952792,"is_pvip":false,"replies":[{"id":"119855","content":"你的鼓励就是我的动力。我们一起加油！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641004725,"ip_address":"","comment_id":328956,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31705723864","product_id":100103401,"comment_content":"太赞了，看了很多书和博客，基本都在讲kotlin多好用。从根本上讲kotlin的还是这门课，很多以前懵懵懂懂的概念都豁然开朗，太赞了。","like_count":8,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543195,"discussion_content":"你的鼓励就是我的动力。我们一起加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641004725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328887,"user_name":"PoPlus","can_delete":false,"product_type":"c1","uid":1574765,"ip_address":"","ucode":"5F0927921317F2","user_header":"https://static001.geekbang.org/account/avatar/00/18/07/6d/4c1909be.jpg","comment_is_top":false,"comment_ctime":1640926365,"is_pvip":false,"replies":[{"id":"119873","content":"赞！分析的很到位。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641006641,"ip_address":"","comment_id":328887,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31705697437","product_id":100103401,"comment_content":"思考题：<br>如果采用 val isAdult = age &gt;= 18 这种写法，那么错误会表现在给某个 Person 对象的 age 属性二次赋值时，isAdult 属性仍会是一个旧的 Boolean 值。原因：从反编译出的 Java 代码可以看出，isAdult 属性会被转换成一个 final 修饰的 Java 属性且在构造方法里赋好值了，那么意味着即使 age 属性后期修改一万遍，isAdult 属性也只会是它原来的那个初始值。<br>而如果用 getter 的方式则不会有这个问题，因为 getter 方式会把 isAdult 属性转换成 getter 方法而不是 final 修饰的属性，每一次调用，isAdult 属性就会动态的根据 age 属性来判断返回值。","like_count":8,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543218,"discussion_content":"赞！分析的很到位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641006641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328881,"user_name":"逢庆","can_delete":false,"product_type":"c1","uid":1189062,"ip_address":"","ucode":"519C5165B2F495","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/c6/c86e70d9.jpg","comment_is_top":false,"comment_ctime":1640923691,"is_pvip":false,"replies":[{"id":"119872","content":"没错。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641006617,"ip_address":"","comment_id":328881,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18820792875","product_id":100103401,"comment_content":"1.<br>val isAdult<br>     get() = age &gt;= 18<br>反编译后可以看到，会生成方法:<br>   public final boolean isAdult() {<br>      return this.age &gt;= 18;<br>   }<br><br>2.<br>val isAdult = age &gt;= 18<br>反编译后，可以看到：<br>会定义一个isAdult属性：<br>private final boolean isAdult;<br>并在构造函数里根据age来赋值：<br>this.isAdult = this.age &gt;= 18;<br><br><br>","like_count":5,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543215,"discussion_content":"没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641006617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330901,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1642261308,"is_pvip":false,"replies":[{"id":"120715","content":"嗯，是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642299410,"ip_address":"","comment_id":330901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10232195900","product_id":100103401,"comment_content":"You can define custom accessors for a property. <br>If you define a custom getter, it will be called every time you access the property (this way you can implement a computed property). <br>If you define a custom setter, it will be called every time you assign a value to the property, except its initialization.","like_count":3,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546338,"discussion_content":"嗯，是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642299410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333585,"user_name":"3.141516","can_delete":false,"product_type":"c1","uid":1013309,"ip_address":"","ucode":"34AF71B02692F3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/3d/8120438b.jpg","comment_is_top":false,"comment_ctime":1644412199,"is_pvip":true,"replies":[{"id":"121884","content":"其实，我们一般说Kotlin增大包体积，主要只两个方面：<br><br>1. Kotlin标准库+反射库+协程库<br>2. 字节码增加class数量","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644460411,"ip_address":"","comment_id":333585,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5939379495","product_id":100103401,"comment_content":"kotlin 的一些语法特性在编译为字节码后会增多 class 数量，所以会增加字节码的大小。<br><br>想请教下老师，在 Android 中，Kotlin 还有哪些方面会增加包大小呢？谢谢","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550254,"discussion_content":"其实，我们一般说Kotlin增大包体积，主要只两个方面：\n\n1. Kotlin标准库+反射库+协程库\n2. 字节码增加class数量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644460411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330909,"user_name":"文茂权","can_delete":false,"product_type":"c1","uid":1175422,"ip_address":"","ucode":"2F71862083D6CF","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/7e/231c9fa2.jpg","comment_is_top":false,"comment_ctime":1642267146,"is_pvip":true,"replies":[{"id":"120716","content":"赞！感谢补充。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642299443,"ip_address":"","comment_id":330909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937234442","product_id":100103401,"comment_content":"JVM 由于存在多种实现，依赖的是一套标准规范。尽管学习 Kotlin 不需要直接接触 JVM ，但参考 JVM 的设计规范对于我们学习 JVM 编程语言的设计是很有作用的。<br>这里附上 JVM 不同版本的设计规范文档：https:&#47;&#47;docs.oracle.com&#47;javase&#47;specs&#47;index.html","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546339,"discussion_content":"赞！感谢补充。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642299443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347218,"user_name":"Geek_0737de","can_delete":false,"product_type":"c1","uid":2288483,"ip_address":"","ucode":"9FFB233926A035","user_header":"","comment_is_top":false,"comment_ctime":1653823213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653823213","product_id":100103401,"comment_content":"讲的太好了，感觉一下子明了了","like_count":0},{"had_liked":false,"id":346713,"user_name":"聪明的傻孩子","can_delete":false,"product_type":"c1","uid":1329680,"ip_address":"","ucode":"14AB5B07E18DBC","user_header":"https://static001.geekbang.org/account/avatar/00/14/4a/10/365ea684.jpg","comment_is_top":false,"comment_ctime":1653375493,"is_pvip":false,"replies":[{"id":"126595","content":"加油~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1653818276,"ip_address":"","comment_id":346713,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653375493","product_id":100103401,"comment_content":"豁然开朗，大佬分析得太牛了","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574060,"discussion_content":"加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653818276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339022,"user_name":"张春亮","can_delete":false,"product_type":"c1","uid":1045303,"ip_address":"","ucode":"3921D2A256B2C9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","comment_is_top":false,"comment_ctime":1647863055,"is_pvip":false,"replies":[{"id":"124000","content":"很好～","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648029617,"ip_address":"","comment_id":339022,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647863055","product_id":100103401,"comment_content":"转换成java的话val isAdult = age &gt;= 18相当于在初始化函数中对isAdult进行赋值，并且本身为final属性，不再具有可变性。<br>val isAdult get() = age &gt;= 18 才是一个正常对应一个方法，后面的语句就是方法体","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557946,"discussion_content":"很好～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648029617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338859,"user_name":"droidYu","can_delete":false,"product_type":"c1","uid":2849755,"ip_address":"","ucode":"154FEF1B561517","user_header":"https://static001.geekbang.org/account/avatar/00/2b/7b/db/7cfa21ad.jpg","comment_is_top":false,"comment_ctime":1647764657,"is_pvip":false,"replies":[{"id":"124026","content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648031746,"ip_address":"","comment_id":338859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647764657","product_id":100103401,"comment_content":"Kotlin语言的简洁得益于Kotlin编译器的强大，之所以Java和Kotlin能完全兼容，是因为Java和Kotlin编译后的成果都是Java字节码。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557972,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648031746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332998,"user_name":"Geek_Adr","can_delete":false,"product_type":"c1","uid":2876897,"ip_address":"","ucode":"129E17B7D3EB88","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e5/e1/a5064f88.jpg","comment_is_top":false,"comment_ctime":1643947384,"is_pvip":false,"replies":[{"id":"121687","content":"val 不一定是基本类型，估计你是笔误了吧？<br><br>后半句：可空类型遇到和对象相关操作的都会被转成包装类型。也不全对，从你给的例子我们可以看到，虽然调用了a.equals(b)，a仍然是基础类型。只是在调用方法的时候才会发生“类型封装”的操作。这里面还是有细微差别的。<br><br>所以，会不会转换成基础类型，本质还是看：它有没有可能为空。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643983999,"ip_address":"","comment_id":332998,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643947384","product_id":100103401,"comment_content":"&#47;&#47; kotlin 代码<br><br>&#47;&#47; 用 val 定义可为空、不可为空的Long，并且赋值<br>val a: Long = 1L<br>val b: Long? = 2L<br>&#47;&#47; 加上方法调用<br>a.equals(b)<br><br>&#47;&#47; 反编译后的 Java 代码<br>long a = 1L;<br>Long b = 2L;<br>Long.valueOf(a).equals(b);<br><br>&#47;&#47; 是不是可以认为val一定被转成成基本类型 可空类型遇到和对象相关操作的都会被转成包装类型","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549434,"discussion_content":"val 不一定是基本类型，估计你是笔误了吧？\n\n后半句：可空类型遇到和对象相关操作的都会被转成包装类型。也不全对，从你给的例子我们可以看到，虽然调用了a.equals(b)，a仍然是基础类型。只是在调用方法的时候才会发生“类型封装”的操作。这里面还是有细微差别的。\n\n所以，会不会转换成基础类型，本质还是看：它有没有可能为空。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643983999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330908,"user_name":"文茂权","can_delete":false,"product_type":"c1","uid":1175422,"ip_address":"","ucode":"2F71862083D6CF","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/7e/231c9fa2.jpg","comment_is_top":false,"comment_ctime":1642266959,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642266959","product_id":100103401,"comment_content":"https:&#47;&#47;docs.oracle.com&#47;javase&#47;specs&#47;index.html","like_count":0},{"had_liked":false,"id":329820,"user_name":"凌宇之蓝","can_delete":false,"product_type":"c1","uid":1098376,"ip_address":"","ucode":"5CF7FC412163C7","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/88/78df5b1c.jpg","comment_is_top":false,"comment_ctime":1641551139,"is_pvip":true,"replies":[{"id":"120156","content":"赞~讲解的很清晰。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641607283,"ip_address":"","comment_id":329820,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641551139","product_id":100103401,"comment_content":"val isAdult = age &gt;= 18 反编译后成为一个final值且在构造函数中默认添加；val isAdult<br>        get() = age &gt;= 18是一个正常的方法，可以根据传入值动态改变返回值","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544614,"discussion_content":"赞~讲解的很清晰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641607283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329295,"user_name":"syz","can_delete":false,"product_type":"c1","uid":1174704,"ip_address":"","ucode":"54AF17ACD72645","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","comment_is_top":false,"comment_ctime":1641274475,"is_pvip":true,"replies":[{"id":"119948","content":"两种方式在语法上是没问题的，但背后的逻辑可不一样哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641304091,"ip_address":"","comment_id":329295,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641274475","product_id":100103401,"comment_content":"val isAdult = age &gt;= 18 这样写没毛病,等价于<br>class Person(val name: String, var age: Int, val isAdult: Boolean = age &gt;= 18)<br>------------<br> val isAdult<br>        get() = age &gt;= 18<br>这样写class Person有两个参数，附带一个方法    <br>public final boolean isAdult() {<br>      return this.age &gt;= 18;<br>}<br>","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543797,"discussion_content":"两种方式在语法上是没问题的，但背后的逻辑可不一样哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641304091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328978,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1640969721,"is_pvip":true,"replies":[{"id":"119882","content":"确实，字节码才是最接近本质的。反编译成Java之后确实会损失少量信息，但一般都不会有很大的偏差。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641172117,"ip_address":"","comment_id":328978,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1640969721","product_id":100103401,"comment_content":"直觉上反编译都是有损的，不知道有没有遇到过反编译结果不对的例子？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543465,"discussion_content":"确实，字节码才是最接近本质的。反编译成Java之后确实会损失少量信息，但一般都不会有很大的偏差。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641172118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045303,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","nickname":"张春亮","note":"","ucode":"3921D2A256B2C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557563,"discussion_content":"有一些会提示无法被反编译","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647863106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328909,"user_name":"imxilife","can_delete":false,"product_type":"c1","uid":1031301,"ip_address":"","ucode":"818D11A5D0DDD8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/85/7e174dd0.jpg","comment_is_top":false,"comment_ctime":1640931887,"is_pvip":false,"replies":[{"id":"119863","content":"是这么个意思，不过下次可以讲的再清楚一些哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641005206,"ip_address":"","comment_id":328909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640931887","product_id":100103401,"comment_content":"外部获取isAdult的值的时候会自动调它的get()方法，所以不重写get()方法是无效的","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543203,"discussion_content":"是这么个意思，不过下次可以讲的再清楚一些哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641005206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328890,"user_name":"PoPlus","can_delete":false,"product_type":"c1","uid":1574765,"ip_address":"","ucode":"5F0927921317F2","user_header":"https://static001.geekbang.org/account/avatar/00/18/07/6d/4c1909be.jpg","comment_is_top":false,"comment_ctime":1640927697,"is_pvip":false,"replies":[{"id":"119874","content":"嗯，这是有可能的，我用的最新版IntelliJ，Kotlin1.6版本。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641006851,"ip_address":"","comment_id":328890,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640927697","product_id":100103401,"comment_content":"关于 Kotlin 包装类型优化原始类型，我的实验结果和老师的结论有一点出入，不知道是不是编译器版本的原因。🌚<br>var a: Long = 1 &#47;&#47; private static long a = 1L;<br>val b: Long = 2 &#47;&#47; private static final long b = 2L;<br>var c: Long? = 3 &#47;&#47; private static Long c = 3L; 未优化成原始类型<br>val d: Long? = 4 &#47;&#47; private static final Long d = 4L; 未优化成原始类型","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543219,"discussion_content":"嗯，这是有可能的，我用的最新版IntelliJ，Kotlin1.6版本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641006851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328872,"user_name":"阿康","can_delete":false,"product_type":"c1","uid":2697815,"ip_address":"","ucode":"DF20E1E33A8A34","user_header":"https://static001.geekbang.org/account/avatar/00/29/2a/57/6629c858.jpg","comment_is_top":false,"comment_ctime":1640922287,"is_pvip":false,"replies":[{"id":"119871","content":"没错！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641006587,"ip_address":"","comment_id":328872,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640922287","product_id":100103401,"comment_content":"如果不用getter 实现，Person实例化后isAdult值就固定了，即使在重新给age赋值，isAdult也不会变。<br>1、通过自定义 getter 来实现：<br>  var man = Person(&quot;男孩&quot;,16)<br>  println(man.isAdult)<br>  man.age = 20<br>  println(man.isAdult)<br>&#47;&#47;========输出结果=======<br>false<br>true<br>&#47;&#47;=====================<br>2、val isAdult = age &gt;= 18 实现：<br>  var man = Person(&quot;男孩&quot;,16)<br>  println(man.isAdult)<br>  man.age = 20<br>  println(man.isAdult)<br>&#47;&#47;========输出结果=======<br>false<br>false<br>&#47;&#47;=====================","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543214,"discussion_content":"没错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641006587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328867,"user_name":"仇无恨","can_delete":false,"product_type":"c1","uid":1174446,"ip_address":"","ucode":"7F91C4BC5AE1B2","user_header":"https://static001.geekbang.org/account/avatar/00/11/eb/ae/09841320.jpg","comment_is_top":false,"comment_ctime":1640921227,"is_pvip":false,"replies":[{"id":"119870","content":"很好！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641006568,"ip_address":"","comment_id":328867,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640921227","product_id":100103401,"comment_content":"第二种写法相当于在类初始化时候给isAdult进行了初始化赋值，isAdult的结果只与类初始化时传入的age参数有关。<br>第一种写法相当于重写了isAdult的get函数，每次获取时都会通过当前的age的值来判断结果","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543213,"discussion_content":"很好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641006568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328861,"user_name":"$Kotlin","can_delete":false,"product_type":"c1","uid":2148188,"ip_address":"","ucode":"098E9C8F60D865","user_header":"https://static001.geekbang.org/account/avatar/00/20/c7/5c/94cb3a1a.jpg","comment_is_top":false,"comment_ctime":1640920242,"is_pvip":false,"replies":[{"id":"119869","content":"赞！很好。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641006510,"ip_address":"","comment_id":328861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640920242","product_id":100103401,"comment_content":"val isAdult get() = age &gt;= 18<br>生成的是对应的get方法<br>public final boolean isAdult() {<br>\treturn this.age &gt;= 18;<br>}<br><br>val isAdult = age &gt;= 18<br>生成的是不可变属性加方法<br>private final boolean isAdult;<br>public final boolean isAdult() {<br>\treturn this.isAdult;<br>}<br>初始化中赋值后不可更改<br>this.isAdult = this.age &gt;= 18;","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543212,"discussion_content":"赞！很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641006511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328857,"user_name":"$Kotlin","can_delete":false,"product_type":"c1","uid":2148188,"ip_address":"","ucode":"098E9C8F60D865","user_header":"https://static001.geekbang.org/account/avatar/00/20/c7/5c/94cb3a1a.jpg","comment_is_top":false,"comment_ctime":1640920047,"is_pvip":false,"replies":[{"id":"119868","content":"看到你另一个答案了，不错！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641006503,"ip_address":"","comment_id":328857,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640920047","product_id":100103401,"comment_content":"val isAdult get() = age &gt;= 18 生成的是对应的方法public final boolean isAdult() {<br>         return this.age &gt;= 18;<br>      }","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543211,"discussion_content":"看到你另一个答案了，不错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641006503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328851,"user_name":"陈彬","can_delete":false,"product_type":"c1","uid":1512006,"ip_address":"","ucode":"F7716B295D9613","user_header":"https://static001.geekbang.org/account/avatar/00/17/12/46/f361c795.jpg","comment_is_top":false,"comment_ctime":1640918815,"is_pvip":false,"replies":[{"id":"119867","content":"赞！分析的很好。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641006463,"ip_address":"","comment_id":328851,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640918815","product_id":100103401,"comment_content":"class Person(val name: String, var age: Int) {<br>    val isAdult = age &gt;= 18<br>}<br>经过老师教的方法把Kotlin 对应的字节码反编译之后代码如下:<br>public final class Person {<br>   private final boolean isAdult;<br>   @NotNull<br>   private final String name;<br>   private int age;<br><br>   public final boolean isAdult() {<br>      return this.isAdult;<br>   }<br><br>   @NotNull<br>   public final String getName() {<br>      return this.name;<br>   }<br><br>   public final int getAge() {<br>      return this.age;<br>   }<br><br>   public final void setAge(int var1) {<br>      this.age = var1;<br>   }<br><br>   public Person(@NotNull String name, int age) {<br>      Intrinsics.checkParameterIsNotNull(name, &quot;name&quot;);<br>      super();<br>      this.name = name;<br>      this.age = age;<br>      this.isAdult = this.age &gt;= 18;<br>   }<br>}<br>可以看到这种写法在初始化构造函数的时候就对isAdult属性进行赋值，导致以后不管如何修改age的值，isAdult()返回值永远不会改变。<br>我理解之所以这样的原因是在kotlin中，val定义的属性默认会生成getter方法，而第一种方式没问题是因为其重写了属性的getter方法。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543209,"discussion_content":"赞！分析的很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641006463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328850,"user_name":"Marten","can_delete":false,"product_type":"c1","uid":2879124,"ip_address":"","ucode":"726A68B7D6470E","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/94/5f3460cd.jpg","comment_is_top":false,"comment_ctime":1640918642,"is_pvip":false,"replies":[{"id":"119866","content":"是这样的。不过可以讲的再详细一些哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641006426,"ip_address":"","comment_id":328850,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640918642","product_id":100103401,"comment_content":" val isAdult = age &gt;= 18 这样写，java会认为isAdult是成员属性，如果不初始化person，isAdult的get方法返回是有问题的。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543207,"discussion_content":"是这样的。不过可以讲的再详细一些哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641006426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328847,"user_name":"JakePrim","can_delete":false,"product_type":"c1","uid":1151981,"ip_address":"","ucode":"ACA227B7610D84","user_header":"https://static001.geekbang.org/account/avatar/00/11/93/ed/9cc44242.jpg","comment_is_top":false,"comment_ctime":1640917652,"is_pvip":false,"replies":[{"id":"119865","content":"加油哈","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641005656,"ip_address":"","comment_id":328847,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640917652","product_id":100103401,"comment_content":"赞，有种豁然开朗的感觉","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543205,"discussion_content":"加油哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641005656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328846,"user_name":"墨方","can_delete":false,"product_type":"c1","uid":1295549,"ip_address":"","ucode":"638AE114D4CAC5","user_header":"https://static001.geekbang.org/account/avatar/00/13/c4/bd/44757daf.jpg","comment_is_top":false,"comment_ctime":1640917595,"is_pvip":false,"replies":[{"id":"119861","content":"赞！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641005138,"ip_address":"","comment_id":328846,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640917595","product_id":100103401,"comment_content":"又仔细看了一下, 我理解错老师说的错误的意思了, 因为如果重写了isAdult的get方法之后,isAdult会被编译为一个方法,而不是一个属性. 这样即使age发生变化,也会获知到isAdult的正确值, 不重写isAdult的get方法,改变了age之后,获取的isAdult有可能会出现错误","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543201,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641005138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328845,"user_name":"阿康","can_delete":false,"product_type":"c1","uid":2697815,"ip_address":"","ucode":"DF20E1E33A8A34","user_header":"https://static001.geekbang.org/account/avatar/00/29/2a/57/6629c858.jpg","comment_is_top":false,"comment_ctime":1640917559,"is_pvip":false,"replies":[{"id":"119864","content":"其实就是：字段(Field) 、属性(Property)。类似的还有：方法(Method)、函数(Function)。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641005647,"ip_address":"","comment_id":328845,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640917559","product_id":100103401,"comment_content":"对象属性：具有get的是可读属性，具有set的是可写属性，同时具有get、set的是可读写属性。没有get、set的那是字段，不是属性。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543204,"discussion_content":"其实就是：字段(Field) 、属性(Property)。类似的还有：方法(Method)、函数(Function)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641005647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328843,"user_name":"xiaomengjie","can_delete":false,"product_type":"c1","uid":1136848,"ip_address":"","ucode":"4FC7A90B9DFA09","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/d0/749a57e2.jpg","comment_is_top":false,"comment_ctime":1640917513,"is_pvip":false,"replies":[{"id":"119862","content":"赞！很详细！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641005168,"ip_address":"","comment_id":328843,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640917513","product_id":100103401,"comment_content":"<br>class Person(val name: String, var age: Int) {<br>    val isAdult<br>        get() = age &gt;= 18<br>}<br>编译后idAdult会转换为方法<br>public final boolean isAdult() {<br>      return this.age &gt;= 18;<br>   }<br>person对象改变age值，isAudlt会变换<br><br><br>class Person(val name: String, var age: Int) {<br>    val isAdult = age &gt;= 18<br>}<br>编译后：<br>private final boolean isAdult;<br>public final boolean isAdult() {<br>      return this.isAdult;<br>   }<br>   public Person(@NotNull String name, int age) {<br>      Intrinsics.checkNotNullParameter(name, &quot;name&quot;);<br>      super();<br>      this.name = name;<br>      this.age = age;<br>      this.isAdult = this.age &gt;= 18;<br>   }<br>额外生成final字段isAdult，构造函数中初始化<br>person对象改变age值，isAdult()不会变","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543202,"discussion_content":"赞！很详细！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641005168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328838,"user_name":"墨方","can_delete":false,"product_type":"c1","uid":1295549,"ip_address":"","ucode":"638AE114D4CAC5","user_header":"https://static001.geekbang.org/account/avatar/00/13/c4/bd/44757daf.jpg","comment_is_top":false,"comment_ctime":1640917052,"is_pvip":false,"replies":[{"id":"119860","content":"嗯……看到你另一个答案了，不错哈！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641005127,"ip_address":"","comment_id":328838,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640917052","product_id":100103401,"comment_content":"class Person(val name: String, val age: Int) {<br>    val isAdult = age &gt;= 18<br>}<br>这种写法不会出错了,估计是因为版本的问题,<br>通过反编译后的代码可以看到,isAdult被声明成final, 然后会在Person的构造方法中根据age的值去判断赋值<br>public final class Person {<br>   private final boolean isAdult;<br>   &#47;&#47;省略.........<br>   public Person(@NotNull String name, int age) {<br>   &#47;&#47;省略 .......<br>      this.isAdult = this.age &gt;= 18;<br>   }<br>}","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543200,"discussion_content":"嗯……看到你另一个答案了，不错哈！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641005127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328833,"user_name":"Xeon","can_delete":false,"product_type":"c1","uid":1592670,"ip_address":"","ucode":"F2017D934B6AF8","user_header":"https://static001.geekbang.org/account/avatar/00/18/4d/5e/5e66ca3f.jpg","comment_is_top":false,"comment_ctime":1640916179,"is_pvip":true,"replies":[{"id":"119859","content":"赞！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641004947,"ip_address":"","comment_id":328833,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640916179","product_id":100103401,"comment_content":"个人理解：上面那个自定义getter的方式最终会被编译成一个isAdult()方法，return this.age &gt;= 18; 并没有实际的isAdult属性产生（之前的文章中有提到过），此时isAdult的值是会根据age值的变化而变化的。<br>而下面那种方式是真的会存在一个被final修饰的isAdult属性，而final修饰的属性值一旦确定后是不能修改的，也就是说首次给age赋值的时候，isAdult的值就已经确定了，哪怕后面再更改age的值，isAdult的值也不会随着age的值变化而变化。所以，日常开发中这样用一不小心就会出错。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543199,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641004947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}