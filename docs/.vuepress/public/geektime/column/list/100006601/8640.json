{"id":8640,"title":"17 | 高性能缓存架构","content":"<p>虽然我们可以通过各种手段来提升存储系统的性能，但在某些复杂的业务场景下，单纯依靠存储系统的性能提升不够的，典型的场景有：</p>\n<ul>\n<li>需要经过复杂运算后得出的数据，存储系统无能为力</li>\n</ul>\n<p>例如，一个论坛需要在首页展示当前有多少用户同时在线，如果使用MySQL来存储当前用户状态，则每次获取这个总数都要“count(*)”大量数据，这样的操作无论怎么优化MySQL，性能都不会太高。如果要实时展示用户同时在线数，则MySQL性能无法支撑。</p>\n<ul>\n<li>读多写少的数据，存储系统有心无力</li>\n</ul>\n<p>绝大部分在线业务都是读多写少。例如，微博、淘宝、微信这类互联网业务，读业务占了整体业务量的90%以上。以微博为例：一个明星发一条微博，可能几千万人来浏览。如果使用MySQL来存储微博，用户写微博只有一条insert语句，但每个用户浏览时都要select一次，即使有索引，几千万条select语句对MySQL数据库的压力也会非常大。</p>\n<p>缓存就是为了弥补存储系统在这些复杂业务场景下的不足，其基本原理是将可能重复使用的数据放到内存中，一次生成、多次使用，避免每次使用都去访问存储系统。</p>\n<p>缓存能够带来性能的大幅提升，以Memcache为例，单台Memcache服务器简单的key-value查询能够达到TPS 50000以上，其基本的架构是：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/c7/15/c70fdcaab49fe730380d2207017c4215.jpg?wh=3065*2187\" alt=\"\" /></p>\n<p>缓存虽然能够大大减轻存储系统的压力，但同时也给架构引入了更多复杂性。架构设计时如果没有针对缓存的复杂性进行处理，某些场景下甚至会导致整个系统崩溃。今天，<span class=\"orange\">我来逐一分析缓存的架构设计要点。</span></p>\n<!-- [[[read_end]]] -->\n<h2>缓存穿透</h2>\n<p><strong>缓存穿透</strong>是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。通常情况下有两种情况：</p>\n<p>1.存储数据不存在</p>\n<p>第一种情况是被访问的数据确实不存在。一般情况下，如果存储系统中没有某个数据，则不会在缓存中存储相应的数据，这样就导致用户查询的时候，在缓存中找不到对应的数据，每次都要去存储系统中再查询一遍，然后返回数据不存在。缓存在这个场景中并没有起到分担存储系统访问压力的作用。</p>\n<p>通常情况下，业务上读取不存在的数据的请求量并不会太大，但如果出现一些异常情况，例如被黑客攻击，故意大量访问某些读取不存在数据的业务，有可能会将存储系统拖垮。</p>\n<p>这种情况的解决办法比较简单，如果查询存储系统的数据没有找到，则直接设置一个默认值（可以是空值，也可以是具体的值）存到缓存中，这样第二次读取缓存时就会获取到默认值，而不会继续访问存储系统。</p>\n<p>2.缓存数据生成耗费大量时间或者资源</p>\n<p>第二种情况是存储系统中存在数据，但生成缓存数据需要耗费较长时间或者耗费大量资源。如果刚好在业务访问的时候缓存失效了，那么也会出现缓存没有发挥作用，访问压力全部集中在存储系统上的情况。</p>\n<p>典型的就是电商的商品分页，假设我们在某个电商平台上选择“手机”这个类别查看，由于数据巨大，不能把所有数据都缓存起来，只能按照分页来进行缓存，由于难以预测用户到底会访问哪些分页，因此业务上最简单的就是每次点击分页的时候按分页计算和生成缓存。通常情况下这样实现是基本满足要求的，但是如果被竞争对手用爬虫来遍历的时候，系统性能就可能出现问题。</p>\n<p>具体的场景有：</p>\n<ul>\n<li>\n<p>分页缓存的有效期设置为1天，因为设置太长时间的话，缓存不能反应真实的数据。</p>\n</li>\n<li>\n<p>通常情况下，用户不会从第1页到最后1页全部看完，一般用户访问集中在前10页，因此第10页以后的缓存过期失效的可能性很大。</p>\n</li>\n<li>\n<p>竞争对手每周来爬取数据，爬虫会将所有分类的所有数据全部遍历，从第1页到最后1页全部都会读取，此时很多分页缓存可能都失效了。</p>\n</li>\n<li>\n<p>由于很多分页都没有缓存数据，从数据库中生成缓存数据又非常耗费性能（order by limit操作），因此爬虫会将整个数据库全部拖慢。</p>\n</li>\n</ul>\n<p>这种情况并没有太好的解决方案，因为爬虫会遍历所有的数据，而且什么时候来爬取也是不确定的，可能是每天都来，也可能是每周，也可能是一个月来一次，我们也不可能为了应对爬虫而将所有数据永久缓存。通常的应对方案要么就是识别爬虫然后禁止访问，但这可能会影响SEO和推广；要么就是做好监控，发现问题后及时处理，因为爬虫不是攻击，不会进行暴力破坏，对系统的影响是逐步的，监控发现问题后有时间进行处理。</p>\n<h2>缓存雪崩</h2>\n<p><strong>缓存雪崩</strong>是指当缓存失效（过期）后引起系统性能急剧下降的情况。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再次进行运算，这个处理步骤耗时几十毫秒甚至上百毫秒。而对于一个高并发的业务系统来说，几百毫秒内可能会接到几百上千个请求。由于旧的缓存已经被清除，新的缓存还未生成，并且处理这些请求的线程都不知道另外有一个线程正在生成缓存，因此所有的请求都会去重新生成缓存，都会去访问存储系统，从而对存储系统造成巨大的性能压力。这些压力又会拖慢整个系统，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。</p>\n<p>缓存雪崩的常见解决方法有两种：<strong>更新锁机制</strong>和<strong>后台更新机制</strong>。</p>\n<p>1.更新锁</p>\n<p>对缓存更新操作进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p>\n<p>对于采用分布式集群的业务系统，由于存在几十上百台服务器，即使单台服务器只有一个线程更新缓存，但几十上百台服务器一起算下来也会有几十上百个线程同时来更新缓存，同样存在雪崩的问题。因此分布式集群的业务系统要实现更新锁机制，需要用到分布式锁，如ZooKeeper。</p>\n<p>2.后台更新</p>\n<p>由后台线程来更新缓存，而不是由业务线程来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存。</p>\n<p>后台定时机制需要考虑一种特殊的场景，当缓存系统内存不够时，会“踢掉”一些缓存数据，从缓存被“踢掉”到下一次定时更新缓存的这段时间内，业务线程读取缓存返回空值，而业务线程本身又不会去更新缓存，因此业务上看到的现象就是数据丢了。解决的方式有两种：</p>\n<ul>\n<li>\n<p>后台线程除了定时更新缓存，还要频繁地去读取缓存（例如，1秒或者100毫秒读取一次），如果发现缓存被“踢了”就立刻更新缓存，这种方式实现简单，但读取时间间隔不能设置太长，因为如果缓存被踢了，缓存读取间隔时间又太长，这段时间内业务访问都拿不到真正的数据而是一个空的缓存值，用户体验一般。</p>\n</li>\n<li>\n<p>业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存。可能会出现多个业务线程都发送了缓存更新消息，但其实对后台线程没有影响，后台线程收到消息后更新缓存前可以判断缓存是否存在，存在就不执行更新操作。这种方式实现依赖消息队列，复杂度会高一些，但缓存更新更及时，用户体验更好。</p>\n</li>\n</ul>\n<p>后台更新既适应单机多线程的场景，也适合分布式集群的场景，相比更新锁机制要简单一些。</p>\n<p>后台更新机制还适合业务刚上线的时候进行缓存预热。缓存预热指系统上线后，将相关的缓存数据直接加载到缓存系统，而不是等待用户访问才来触发缓存加载。</p>\n<h2>缓存热点</h2>\n<p>虽然缓存系统本身的性能比较高，但对于一些特别热点的数据，如果大部分甚至所有的业务请求都命中同一份缓存数据，则这份数据所在的缓存服务器的压力也很大。例如，某明星微博发布“我们”来宣告恋爱了，短时间内上千万的用户都会来围观。</p>\n<p><strong>缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力</strong>。以微博为例，对于粉丝数超过100万的明星，每条微博都可以生成100份缓存，缓存的数据是一样的，通过在缓存的key里面加上编号进行区分，每次读缓存时都随机读取其中某份缓存。</p>\n<p>缓存副本设计有一个细节需要注意，就是不同的缓存副本不要设置统一的过期时间，否则就会出现所有缓存副本同时生成同时失效的情况，从而引发缓存雪崩效应。正确的做法是设定一个过期时间范围，不同的缓存副本的过期时间是指定范围内的随机值。</p>\n<h2>实现方式</h2>\n<p>由于缓存的各种访问策略和存储的访问策略是相关的，因此上面的各种缓存设计方案通常情况下都是集成在存储访问方案中，可以采用“程序代码实现”的中间层方式，也可以采用独立的中间件来实现。</p>\n<h2>小结</h2>\n<p>今天我为你讲了高性能架构设计中缓存设计需要注意的几个关键点，这些关键点本身在技术上都不复杂，但可能对业务产生很大的影响，轻则系统响应变慢，重则全站宕机，架构师在设计架构的时候要特别注意这些细节，希望这些设计关键点和技术方案对你有所帮助。</p>\n<p>这就是今天的全部内容，留一道思考题给你吧，分享一下你所在的业务发生过哪些因为缓存导致的线上问题？采取了什么样的解决方案？效果如何？</p>\n<p>欢迎你把答案写到留言区，和我一起讨论。相信经过深度思考的回答，也会让你对知识的理解更加深刻。（编辑乱入：精彩的留言有机会获得丰厚福利哦！）</p>\n","neighbors":{"left":{"article_title":"16 | 高性能NoSQL","id":8377},"right":{"article_title":"18 | 单服务器高性能模式：PPC与TPC","id":8697}},"comments":[{"had_liked":false,"id":11456,"user_name":"bluefantasy","can_delete":false,"product_type":"c1","uid":1101382,"ip_address":"","ucode":"2F24E373FDDE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/46/67c145ee.jpg","comment_is_top":false,"comment_ctime":1528158638,"is_pvip":false,"replies":[{"id":3703,"content":"很有创意👍👍","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528189048,"ip_address":"","comment_id":11456,"utype":1}],"discussion_count":36,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"我们的系统就出现过类似的问题，开始的时候没有缓存，每次做活动访问量大的时候就会导致反应特别慢。后来通过加redis缓存解决了问题。\n\n 对于缓存雪崩问题，我们采取了双key策略：要缓存的key过期时间是t，key1没有过期时间。每次缓存读取不到key时就返回key1的内容，然后触发一个事件。这个事件会同时更新key和key1。","like_count":368},{"had_liked":false,"id":11564,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1528204212,"is_pvip":false,"replies":[{"id":3752,"content":"我对mysql比较熟，以下仅限mysql：\n1. mysql第一种缓存叫sql语句结果缓存，但条件比较苛刻，程序员不可控，我们的dba线上都关闭这个功能，具体实现可以查一下\n2. mysql第二种缓存是innodb buffer pool，缓存的是磁盘上的分页数据，不是sql的查询结果，sql的执行过程省不了。而mc，redis这些实际上都是缓存sql的结果，两种缓存方式，性能差很远。\n\n因此，可控性，性能是数据库缓存和独立缓存的主要区别","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528253563,"ip_address":"","comment_id":11564,"utype":1}],"discussion_count":11,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"经常我说到缓存的时候，面试官问我，数据库自身不是有缓存吗，标准答案是怎么回击他?","like_count":221,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418850,"discussion_content":"很有创意👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528189048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200867,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/e3/594f7e34.jpg","nickname":"土豆","note":"","ucode":"D115EDC04B6E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549268,"discussion_content":"你直接存一个key，包含过期时间，读到key的时候检查下这个过期时间是否超过某个阈值，超过了就触发更新就好了呀，何必存两个？","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1643795883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275011,"discussion_content":"相当于缓存数据有降级的功能?","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1590646124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1235649,"avatar":"https://static001.geekbang.org/account/avatar/00/12/da/c1/b438893e.jpg","nickname":"湖","note":"","ucode":"292B05A8EEEEB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580730,"discussion_content":"可以参考下开源项目layering-cache的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658365285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275011,"ip_address":"","group_id":0},"score":580730,"extra":""}]},{"author":{"id":1233193,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","nickname":"DFighting","note":"","ucode":"F3BA2426FF8582","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353775,"discussion_content":"双key本质上就是老师提到的第二种，缓存不命中，触发消息后台更新缓存，先返回当前结果，等缓存更新完毕后，用户刷新页面就可以看到新的结果了。可以解决缓存穿透和雪崩(消息队列削峰填谷)","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1615203862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188906,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","nickname":"汝林外史","note":"","ucode":"3C66C0F0537A99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330892,"discussion_content":"双key是用来解决热点key过期导致的缓存击穿问题，缓存雪崩直接设置不同的过期时间就可以了。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1606727006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179965,"avatar":"https://static001.geekbang.org/account/avatar/00/12/01/3d/705d7bd3.jpg","nickname":"抉择","note":"","ucode":"D8499CD8137D03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15200,"discussion_content":"key和key1的值是相同的吗，如果是相同的存两个key为何不直接存一个key没有过期时间就好了。如果是不同的，那么在不同业务场景下，这个错误的值会带来的结果大有不同","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1568810774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":9,"child_discussions":[{"author":{"id":1073596,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/bc/88a905a5.jpg","nickname":"亮点","note":"","ucode":"1B8AE07484C69A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179965,"avatar":"https://static001.geekbang.org/account/avatar/00/12/01/3d/705d7bd3.jpg","nickname":"抉择","note":"","ucode":"D8499CD8137D03","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39017,"discussion_content":"同样疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571878877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":15200,"ip_address":"","group_id":0},"score":39017,"extra":""},{"author":{"id":1019739,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/5b/2f16ca95.jpg","nickname":"WuKongCoder","note":"","ucode":"69C990105DEF47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179965,"avatar":"https://static001.geekbang.org/account/avatar/00/12/01/3d/705d7bd3.jpg","nickname":"抉择","note":"","ucode":"D8499CD8137D03","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50252,"discussion_content":"要是没过期时间 就涉及到什么时间去更新缓存问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573696745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":15200,"ip_address":"","group_id":0},"score":50252,"extra":""},{"author":{"id":1073596,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/bc/88a905a5.jpg","nickname":"亮点","note":"","ucode":"1B8AE07484C69A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019739,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/5b/2f16ca95.jpg","nickname":"WuKongCoder","note":"","ucode":"69C990105DEF47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53044,"discussion_content":"单个缓存设置逻辑过期时间，业务逻辑判断，两份缓存耗费内存资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574127287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50252,"ip_address":"","group_id":0},"score":53044,"extra":""}]},{"author":{"id":1005042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","nickname":"有米","note":"","ucode":"C9A10B7A67BC12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":184848,"discussion_content":"双key带来的问题是，更耗内存，double了。另外带来了维护三份数据一致性的复杂度","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582562639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363620,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ce/a4/3fe4524b.jpg","nickname":"honey peach","note":"","ucode":"1CE86AF63E5452","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401818,"discussion_content":"使用多级缓存不就解决了么，靠近数据库的缓存时间稍微时间长一点，边缘缓存失效向上级缓存读取更新，靠近DB的缓存失效主动更新；另外可以开发一套回源代码程序的插件，检测缓存失效的时间点去有选择的触发更新，还可以定时全部从数据节点更新数据进行缓存，需要说明的一点是靠近数据中心节点的缓存节点可以有程序进行这种方式更新，边缘节点的缓存更新可以有用户触发更新，如果再做的比较精致一点也可以更新边缘缓存节点，这样就看业务的敏感度了，这样每个节点的压力也小，响应也更及时，更新也非常方便。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633743184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301226,"discussion_content":"双key为啥会防雪崩？每次触发事件的线程不还是要去db查数据吗？总请求量也没有便少啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598446185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":8,"child_discussions":[{"author":{"id":1149065,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/89/929aed48.jpg","nickname":"大侠","note":"","ucode":"53851A49226B25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304752,"discussion_content":"我也有这个疑问，最后不还是要请求数据库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599657137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301226,"ip_address":"","group_id":0},"score":304752,"extra":""},{"author":{"id":2510638,"avatar":"https://static001.geekbang.org/account/avatar/00/26/4f/2e/575ee18b.jpg","nickname":"ZC荣","note":"","ucode":"2DACF6E7987B9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360765,"discussion_content":"在查数据库期间可以命中key2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616512585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301226,"ip_address":"","group_id":0},"score":360765,"extra":""},{"author":{"id":1606295,"avatar":"https://static001.geekbang.org/account/avatar/00/18/82/97/04d1d538.jpg","nickname":"RickyTheGeek","note":"","ucode":"806E4334A8E093","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367832,"discussion_content":"还是不一样的吧。我理解双Key的这种方法完全将业务访问挡在缓存层了，触发事件后可以通过一个共享变量状态标识来表示是否正在更新，然后每次触发事件的时候都去检查这个值，这样就可以保证DB的单次查询来更新缓存了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618478658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301226,"ip_address":"","group_id":0},"score":367832,"extra":""}]},{"author":{"id":3174600,"avatar":"https://static001.geekbang.org/account/avatar/00/30/70/c8/736dc26c.jpg","nickname":"仅此而已","note":"","ucode":"9EA07DBBE8473A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640990,"discussion_content":"这个双key策略怎么保证key1对应的value值跟DB里的一致性的呢？除非对数据准确度有一定的容忍度，要不然有可能出现key过期，直接读取key1的数据是不准确的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712052806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","nickname":"拿笔小星","note":"","ucode":"D3D8F6A959710D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604632,"discussion_content":"其实就是有过期时间的key起了一个定时任务的作用，定时发出更新缓存的事件。其实就是老师说的后台更新策略没啥区别。你这样反而复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676388774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053294,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ1VPGSQg7SqrN1Gutx31Kicks2icZjTCg1gZoDLfEcSSricYD6l5qQgE3MkMpqlhkM4gMicymOYzaudg/132","nickname":"可可","note":"","ucode":"297A5D32949128","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":593170,"discussion_content":"这个办法不错，就是有点浪费内存，算是空间换时间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667983954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235649,"avatar":"https://static001.geekbang.org/account/avatar/00/12/da/c1/b438893e.jpg","nickname":"湖","note":"","ucode":"292B05A8EEEEB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580726,"discussion_content":"可以参考下开源项目layering-cache的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658365240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2220816,"avatar":"https://static001.geekbang.org/account/avatar/00/21/e3/10/c7d0c076.jpg","nickname":"AndyDuf","note":"","ucode":"6A12AAB6FC4D74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558564,"discussion_content":"key失效了，去读取key1，这个key1数据是正确的吗？如果是过期的不会影响业务？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648380612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109389,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ed/8d/377c106a.jpg","nickname":"KW💤","note":"","ucode":"290DD7016F4EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404006,"discussion_content":"如果缓存的是复杂数据结构，在写时会阻塞读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634208110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1744257,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","nickname":"千锤百炼领悟之极限","note":"","ucode":"224B5CF2101716","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398991,"discussion_content":"这样业务没影响吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632883623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1473709,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7c/ad/57b768f7.jpg","nickname":"曾彪彪","note":"","ucode":"A815B6C3FA574D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375233,"discussion_content":"我觉得双key，就是老师说的后台更新的变体。key的超时时间t，就是后台线程更新缓存的周期。相反，在key失效的那一会，如果大量用户访问，会生成许多时间，这里如果不加锁，会造成大量数据库的访问。所以也需要在生成缓存时再读一遍缓存，如果存在就不更新了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621523250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2510638,"avatar":"https://static001.geekbang.org/account/avatar/00/26/4f/2e/575ee18b.jpg","nickname":"ZC荣","note":"","ucode":"2DACF6E7987B9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360768,"discussion_content":"当key失效时，会触发事件更新key和key1，解决在更新过程中的缓存穿透问题，nice!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616512733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11490,"user_name":"loveluckystar","can_delete":false,"product_type":"c1","uid":1097877,"ip_address":"","ucode":"370C38AF0E9A43","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/95/6f0aad03.jpg","comment_is_top":false,"comment_ctime":1528162395,"is_pvip":false,"replies":[{"id":3688,"content":"现学现用的案例，很赞👍👍","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185953,"ip_address":"","comment_id":11490,"utype":1}],"discussion_count":7,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"讲一个头两天发生的事情，我们的一个业务背后是es做db，之前是通过redis做缓存，缓存一段时间后失效再从es读取，是业务访问加载缓存的方式。有一天线上es集群机器单台出现问题，返回慢，由于分布式的缘故，渐渐拖满了所有请求，缓存失效来查询es发生了超时，加载失败，于是下次访问还是直接访问es。最终缓存全部失效，qps翻了好多倍，直接雪崩，es集群彻底没有响应了。。。之后我们只好先下线这个缓存加载功能，让集群活过来，最终改造缓存加载方式，用后台进程去更新缓存，而不用业务访问加载。","like_count":93,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418867,"discussion_content":"现学现用的案例，很赞👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1187478,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/96/c735ad6b.jpg","nickname":"滩涂曳尾","note":"","ucode":"40F650F2A419D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23848,"discussion_content":"但是这里关键问题还是得profile定位查询请求性能瓶颈，后台更新cache并没有本质解决问题，只是避免了缓存雪崩","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1569921447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018986,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/6a/ec181c50.jpg","nickname":"小唐","note":"","ucode":"B2A471AAF109E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13640,"discussion_content":"请问“由于分布式的缘故，渐渐拖满了所有请求”。为什么一台机器慢会拖累所有请求？只会拖累所有经过这个机器的请求吧？可以解释下吗？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1568692015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1187478,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/96/c735ad6b.jpg","nickname":"滩涂曳尾","note":"","ucode":"40F650F2A419D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018986,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/6a/ec181c50.jpg","nickname":"小唐","note":"","ucode":"B2A471AAF109E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23847,"discussion_content":"因为es在查询时候，如果不指定路由，需要分布式查询所有shard，然后在proxy节点上(也即es的cordinate)汇总。只要有一个节点满，就会形成“长尾”，拖慢整个请求","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1569921368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":13640,"ip_address":"","group_id":0},"score":23847,"extra":""},{"author":{"id":1442605,"avatar":"https://static001.geekbang.org/account/avatar/00/16/03/2d/404627dc.jpg","nickname":"Anryg Zhun","note":"","ucode":"76DF8560BA9D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018986,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/6a/ec181c50.jpg","nickname":"小唐","note":"","ucode":"B2A471AAF109E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297576,"discussion_content":"查询效率由最慢的那个机器的数据分片决定的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1596974538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":13640,"ip_address":"","group_id":0},"score":297576,"extra":""}]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381055,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624882392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1185557,"avatar":"https://static001.geekbang.org/account/avatar/00/12/17/15/01f9be23.jpg","nickname":"boyka","note":"","ucode":"9C66270BA534DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371089,"discussion_content":"这个都没有触发报警吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619629518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11512,"user_name":"三月沙@wecatch","can_delete":false,"product_type":"c1","uid":1034980,"ip_address":"","ucode":"16FEF6C74D24E3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ca/e4/f15a1cf0.jpg","comment_is_top":false,"comment_ctime":1528166753,"is_pvip":false,"replies":[{"id":3686,"content":"确实，细节不少，可以写本书了😃","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185736,"ip_address":"","comment_id":11512,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"好的缓存方案应该从这几个方面入手设计：\n1.什么数据应该缓存\n2.什么时机触发缓存和以及触发方式是什么\n3.缓存的层次和粒度（ 网关缓存如 nginx，本地缓存如单机文件，分布式缓存如redis cluster，进程内缓存如全局变量）\n4.缓存的命名规则和失效规则\n5.缓存的监控指标和故障应对方案\n6.可视化缓存数据如 redis 具体 key 内容和大小","like_count":83,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418867,"discussion_content":"现学现用的案例，很赞👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1187478,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/96/c735ad6b.jpg","nickname":"滩涂曳尾","note":"","ucode":"40F650F2A419D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23848,"discussion_content":"但是这里关键问题还是得profile定位查询请求性能瓶颈，后台更新cache并没有本质解决问题，只是避免了缓存雪崩","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1569921447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018986,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/6a/ec181c50.jpg","nickname":"小唐","note":"","ucode":"B2A471AAF109E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13640,"discussion_content":"请问“由于分布式的缘故，渐渐拖满了所有请求”。为什么一台机器慢会拖累所有请求？只会拖累所有经过这个机器的请求吧？可以解释下吗？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1568692015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1187478,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/96/c735ad6b.jpg","nickname":"滩涂曳尾","note":"","ucode":"40F650F2A419D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018986,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/6a/ec181c50.jpg","nickname":"小唐","note":"","ucode":"B2A471AAF109E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23847,"discussion_content":"因为es在查询时候，如果不指定路由，需要分布式查询所有shard，然后在proxy节点上(也即es的cordinate)汇总。只要有一个节点满，就会形成“长尾”，拖慢整个请求","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1569921368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":13640,"ip_address":"","group_id":0},"score":23847,"extra":""},{"author":{"id":1442605,"avatar":"https://static001.geekbang.org/account/avatar/00/16/03/2d/404627dc.jpg","nickname":"Anryg Zhun","note":"","ucode":"76DF8560BA9D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018986,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/6a/ec181c50.jpg","nickname":"小唐","note":"","ucode":"B2A471AAF109E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297576,"discussion_content":"查询效率由最慢的那个机器的数据分片决定的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1596974538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":13640,"ip_address":"","group_id":0},"score":297576,"extra":""}]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381055,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624882392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1185557,"avatar":"https://static001.geekbang.org/account/avatar/00/12/17/15/01f9be23.jpg","nickname":"boyka","note":"","ucode":"9C66270BA534DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371089,"discussion_content":"这个都没有触发报警吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619629518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":26645,"user_name":"一叶","can_delete":false,"product_type":"c1","uid":1115608,"ip_address":"","ucode":"EB018BDA606A33","user_header":"https://static001.geekbang.org/account/avatar/00/11/05/d8/cd269378.jpg","comment_is_top":false,"comment_ctime":1537709422,"is_pvip":false,"replies":[{"id":10021,"content":"很用心，赞👍","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1537951448,"ip_address":"","comment_id":26645,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"笔记：\n书籍：\n《高性能Mysql》\n《unix编程艺术》：宁花机器一分，不花程序员一秒\n\n提升性能：\n先单机，有压力后优先考虑sql优化、db参数调优，还有硬件性能(32核&#47;16G&#47;SSD)优化，不行还可以再考虑业务逻辑优化、缓存。不要一上来就读写分离、集群等，能单库搞定的就毫不犹豫的单库。\n\n---\n\n主从读写分离\n适用于单机无法应付所有请求，且读比写多时，读写分离还可以分别针对读写节点建索引来优化。\n对实时性要求不高：刚写入就读会有延迟，同步数据特别大时，延迟可能达到分钟级（可用缓存解决：2-8原则，挑选占访问量80%的前20%来缓存）。\nTODO主从还能设置自增长key不一样？\n\n分库分表（甚用，增加很多复杂度）\n几千万或上亿\n分库时机：单机性能瓶颈，1业务不复杂，但整体数据量影响到数据库性能；2业务复杂，需要分系统由不同团队开发，使用分库减少团队耦合。（分库导致不能join和事务（有方案但性能太低用了跟没分库差别不大，用最终一致性&#47;事件驱动））\n分表时机：单表数据量大拖慢了sql性能，做垂直（将常用和不常用字段分开）或水平拆分（id分段、hash路由、添加路由表等）提高速度。（那么join、count、分页排序等就变得复杂）\nTODO环状hash 一致性hash？\n\nnosql\n（nosql——not noly sql 本质上是牺牲ACID中的某个或某几个属性，以解决关系数据库某些复杂的问题）\n关系数据库：强大的sql功能和ACID属性，发展了几十年技术相当成熟 Mysql &#47; Postgresql \nk-v存储：解决关系数据库无法存储数据结构的问题 Redis &#47; Memcache （redis不太适合key的value特别大，这种情况会导致整个redis变慢，这种场景mc更好-&gt;参考IO模型 redis单Reactor单进程读写大value会阻塞所有业务 持久化也会）\n文档数据库：解决关系数据库强schema约束，查询不存在的列会报错，扩充很麻烦还会长时间锁表  MongoDB \n列式数据库：解决关系数据库处理大数据分析或统计时IO高的问题，关系数据库即使只处理某列也会把整行查询到内存中 HBase &#47; Greenplum\n全文搜索引擎：解决关系数据库全文搜索like扫描全表性能问题 ElasticSearch &#47; solr\nLevelDB 内存型？\n时序数据库？：实时计算统计实时监控 influxDB\nOLAP OLTP HTAP？\n\n缓存（千万千万不要设计复杂的缓存，到时候各种不一致问题烦死你）\ncdn、nginx缓存、网关缓存、数据层缓存redis、db本身也有缓存(sql结果缓存、读取的磁盘分页缓存)\n缓存穿透：1本身无数据(添加默认值缓存&#47;布隆过滤器[整型自增key？]) 2未生成缓存(识别爬虫并禁止 但可能影响seo)\n缓存雪崩：缓存实效后大家都在更新缓存导致系统性能急剧下降（1消息队列通知后台更新、2使用分布式更新锁）\n缓存热点：大部分业务都会命中的同一份缓存，比如1000w+粉丝的微博消息，复制多分缓存副本，key里面加副本编号将请求分散，且设置过期范围，而不是所有副本固定同一过期时间。\n缓存框架看一下设计思路：echcache、网友分享https:&#47;&#47;github.com&#47;qiujiayu&#47;AutoLoadCache\n\n\n","like_count":71,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418872,"discussion_content":"确实，细节不少，可以写本书了😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2314165,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4f/b5/bd6140a5.jpg","nickname":"ARM","note":"","ucode":"788FD0DBD39B94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598337,"discussion_content":"说了又像是没说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672756901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597384,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671765102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11478,"user_name":"mapping","can_delete":false,"product_type":"c1","uid":1023957,"ip_address":"","ucode":"75B1F0B248ADFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/d5/bc83e702.jpg","comment_is_top":false,"comment_ctime":1528161640,"is_pvip":false,"replies":[{"id":3694,"content":"你们的缓存设计有点复杂，还不如调整业务，越复杂的方案越容易出错，参考架构设计原则","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186490,"ip_address":"","comment_id":11478,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"计算机界两大难题：命名和缓存过期。没用缓存的时候，想着怎么用缓存提升性能，用了缓存又担心数据更新不及时。技术上希望所有的请求都能命中缓存，业务上又恨不得数据实时最新。所以就会引入各种缓存过期策略，如设置过期时间，按规则删除，打版本。这些应该在前期设计缓存系统时规划好，我们最早是将 sql md5 作 key 查询结果存入缓存，结果业务系统数据不一致，要清除缓存简直是噩梦，只能祭出绝招重启 memcache，后面改成按规则删除，在 key 中加上业务和用户的前缀，可以很方便删除某个业务或某个用户的缓存。以上过期策略在前端浏览器也是这样，最简单就是 web 服务器设置静态资源缓存过期时间，如果业务频繁发新版本，过期时间不宜设置太长，但其实每次变动的文件很少，这种策略会导致大部分缓存命中率不高。按规则删除，早期很多网站上会有诊断助手类的东西，页面加载错误点下诊断助手就帮你清除缓存，原理就是对静态文件逐一带上 no-cache 请求头发送 ajax 请求强制覆盖缓存（跟 DevTools 中 disable cache 原理一样）。打版本其实就相当于让浏览器请求一个新版本文件，对于老版本文件就让它在缓存中自生自灭。","like_count":26,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424698,"discussion_content":"很用心，赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537951448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3972076,"avatar":"https://static001.geekbang.org/account/avatar/00/3c/9b/ec/7669e505.jpg","nickname":"张少维","note":"","ucode":"6DB56051E21DAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652408,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728885248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543822,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641308943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11480,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1528161735,"is_pvip":true,"replies":[{"id":3692,"content":"1. 限流\n2. 容器化+动态化\n3. 业务降级，例如限制评论","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186335,"ip_address":"","comment_id":11480,"utype":1}],"discussion_count":1,"race_medal":1,"score":2,"product_id":100006601,"comment_content":"上缓存架构的时候，结合以前的实际经历，会有几个值得注意的地方:\n\n1 哪些数据才真正的需要缓存？缓存也并非银弹。既然允许数据缓存，那么在你是可以接受在一定时间区间内的数据不一致性的。(当然可以做到最终一致性)\n\n2 确定好1后，就需要会数据类型进行分类，比如业务数据缓存，http缓存等\n\n3 根据数据类型及访问特点的不同选择不同缓存类型的技术方案。\n\n请问华仔，热点数据存在相当的突发性，临时的扩容似乎也来不及，能否从缓存架构角度如何避免类似微博宕机的事件？\n\n","like_count":23,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418859,"discussion_content":"你们的缓存设计有点复杂，还不如调整业务，越复杂的方案越容易出错，参考架构设计原则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12948,"user_name":"醇梨子","can_delete":false,"product_type":"c1","uid":1089040,"ip_address":"","ucode":"25D498248A855C","user_header":"https://static001.geekbang.org/account/avatar/00/10/9e/10/3cb10bf7.jpg","comment_is_top":false,"comment_ctime":1529199686,"is_pvip":false,"replies":[{"id":4350,"content":"没法保证，这类数据允许一定的不一致，一定范围内的对用户也没有影响，不要只从技术的角度考虑问题，结合业务考虑技术","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1529377635,"ip_address":"","comment_id":12948,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"华仔，请教一下，针对这种高并发缓存架构设计中，缓存和存储系统一致性问题怎么保证？比如说商品浏览人数，需要存库，然后又需要放缓存，需要频繁更新数据库。","like_count":21,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418861,"discussion_content":"1. 限流\n2. 容器化+动态化\n3. 业务降级，例如限制评论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11514,"user_name":"鹅米豆发","can_delete":false,"product_type":"c1","uid":1017687,"ip_address":"","ucode":"98E8D911EE32DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/57/645159ee.jpg","comment_is_top":false,"comment_ctime":1528167725,"is_pvip":false,"replies":[{"id":3684,"content":"缓存持久化是一个不错的方法","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185528,"ip_address":"","comment_id":11514,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"       1、最早也是采用后台用数据库，前台用关系型数据库+被动缓存的模式。结果是经常的性能抖动，且缓存一致性问题很难解决。后来我们的多数系统，都采用了前后台分离的模式——后台原始数据仍然是关系型数据库，前台使用缓存作为数据源，两者之间数据实时同步+定时同步+人工触发结合。\n       这个模式，基本根除了穿透，雪崩，不一致，性能抖动这些。但带来了新的问题，比如数据丢失且不可恢复。我们的做法是，让缓存具备相对可靠的持久化机制+运维体系。\n       2、遇到过几次热点问题，感觉这个更加棘手些。第一种情况，单Key数据结构本身过大，单个分片出现热点，单次访问的复杂度变大。这个相对容易，可以对key进行拆分，使用hashtag机制分片。第二种情况，数据分片普遍不均衡，较少遇到，遇到就比较棘手。第三种情况，数据分片均衡，但访问不均衡，可以增加副本数量。","like_count":14,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419472,"discussion_content":"没法保证，这类数据允许一定的不一致，一定范围内的对用户也没有影响，不要只从技术的角度考虑问题，结合业务考虑技术","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529377635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2663324,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a3/9c/836d7bb3.jpg","nickname":"11月的萧邦","note":"","ucode":"E7A2236BFD9ABE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385823,"discussion_content":"不好保证，我们的方案是先放缓存并在缓存做增减计算，然后每隔1分钟后同步至数据库，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627288495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1193755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","nickname":"拿笔小星","note":"","ucode":"D3D8F6A959710D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2663324,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a3/9c/836d7bb3.jpg","nickname":"11月的萧邦","note":"","ucode":"E7A2236BFD9ABE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604635,"discussion_content":"我们也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676389482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":385823,"ip_address":"上海","group_id":0},"score":604635,"extra":""}]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381058,"discussion_content":"监听binlog，然后删缓存\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624882719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018605,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/ed/0fed07ae.jpg","nickname":"冰梨icePear🍐","note":"","ucode":"7DEB5DCE53107E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373871,"discussion_content":"这个一般是前端记数定期同步，一致性肯定不能严格保证的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620899957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16809,"user_name":"blacknccccc","can_delete":false,"product_type":"c1","uid":1170877,"ip_address":"","ucode":"CC2310B04A624A","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/bd/9b93ea26.jpg","comment_is_top":false,"comment_ctime":1532228198,"is_pvip":false,"replies":[{"id":5837,"content":"淘宝的具体实现没有研究，我们有类似的案例，针对常用的分类会统一缓存，缓存会主动更新；不常用的根据查询条件计算md5作为key 进行缓存，缓存时间不长，例如60分钟，防止短时间内大量访问压垮存储，例如爬虫","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532255212,"ip_address":"","comment_id":16809,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"对于像淘宝商品列表筛选项特别多，组合起来会更多，这样在后台做更新缓存怎么处理，难道是把每一种组合的分页数据都缓存下来吗","like_count":13,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418874,"discussion_content":"缓存持久化是一个不错的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11456,"user_name":"bluefantasy","can_delete":false,"product_type":"c1","uid":1101382,"ip_address":"","ucode":"2F24E373FDDE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/46/67c145ee.jpg","comment_is_top":false,"comment_ctime":1528158638,"is_pvip":false,"replies":[{"id":3703,"content":"很有创意👍👍","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528189048,"ip_address":"","comment_id":11456,"utype":1}],"discussion_count":36,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"我们的系统就出现过类似的问题，开始的时候没有缓存，每次做活动访问量大的时候就会导致反应特别慢。后来通过加redis缓存解决了问题。\n\n 对于缓存雪崩问题，我们采取了双key策略：要缓存的key过期时间是t，key1没有过期时间。每次缓存读取不到key时就返回key1的内容，然后触发一个事件。这个事件会同时更新key和key1。","like_count":368,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418850,"discussion_content":"很有创意👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528189048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200867,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/e3/594f7e34.jpg","nickname":"土豆","note":"","ucode":"D115EDC04B6E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549268,"discussion_content":"你直接存一个key，包含过期时间，读到key的时候检查下这个过期时间是否超过某个阈值，超过了就触发更新就好了呀，何必存两个？","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1643795883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275011,"discussion_content":"相当于缓存数据有降级的功能?","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1590646124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1235649,"avatar":"https://static001.geekbang.org/account/avatar/00/12/da/c1/b438893e.jpg","nickname":"湖","note":"","ucode":"292B05A8EEEEB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580730,"discussion_content":"可以参考下开源项目layering-cache的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658365285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275011,"ip_address":"","group_id":0},"score":580730,"extra":""}]},{"author":{"id":1233193,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","nickname":"DFighting","note":"","ucode":"F3BA2426FF8582","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353775,"discussion_content":"双key本质上就是老师提到的第二种，缓存不命中，触发消息后台更新缓存，先返回当前结果，等缓存更新完毕后，用户刷新页面就可以看到新的结果了。可以解决缓存穿透和雪崩(消息队列削峰填谷)","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1615203862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188906,"avatar":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","nickname":"汝林外史","note":"","ucode":"3C66C0F0537A99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330892,"discussion_content":"双key是用来解决热点key过期导致的缓存击穿问题，缓存雪崩直接设置不同的过期时间就可以了。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1606727006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179965,"avatar":"https://static001.geekbang.org/account/avatar/00/12/01/3d/705d7bd3.jpg","nickname":"抉择","note":"","ucode":"D8499CD8137D03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15200,"discussion_content":"key和key1的值是相同的吗，如果是相同的存两个key为何不直接存一个key没有过期时间就好了。如果是不同的，那么在不同业务场景下，这个错误的值会带来的结果大有不同","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1568810774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":9,"child_discussions":[{"author":{"id":1073596,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/bc/88a905a5.jpg","nickname":"亮点","note":"","ucode":"1B8AE07484C69A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179965,"avatar":"https://static001.geekbang.org/account/avatar/00/12/01/3d/705d7bd3.jpg","nickname":"抉择","note":"","ucode":"D8499CD8137D03","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39017,"discussion_content":"同样疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571878877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":15200,"ip_address":"","group_id":0},"score":39017,"extra":""},{"author":{"id":1019739,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/5b/2f16ca95.jpg","nickname":"WuKongCoder","note":"","ucode":"69C990105DEF47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179965,"avatar":"https://static001.geekbang.org/account/avatar/00/12/01/3d/705d7bd3.jpg","nickname":"抉择","note":"","ucode":"D8499CD8137D03","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50252,"discussion_content":"要是没过期时间 就涉及到什么时间去更新缓存问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573696745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":15200,"ip_address":"","group_id":0},"score":50252,"extra":""},{"author":{"id":1073596,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/bc/88a905a5.jpg","nickname":"亮点","note":"","ucode":"1B8AE07484C69A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019739,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/5b/2f16ca95.jpg","nickname":"WuKongCoder","note":"","ucode":"69C990105DEF47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53044,"discussion_content":"单个缓存设置逻辑过期时间，业务逻辑判断，两份缓存耗费内存资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574127287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50252,"ip_address":"","group_id":0},"score":53044,"extra":""}]},{"author":{"id":1005042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","nickname":"有米","note":"","ucode":"C9A10B7A67BC12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":184848,"discussion_content":"双key带来的问题是，更耗内存，double了。另外带来了维护三份数据一致性的复杂度","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582562639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363620,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ce/a4/3fe4524b.jpg","nickname":"honey peach","note":"","ucode":"1CE86AF63E5452","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401818,"discussion_content":"使用多级缓存不就解决了么，靠近数据库的缓存时间稍微时间长一点，边缘缓存失效向上级缓存读取更新，靠近DB的缓存失效主动更新；另外可以开发一套回源代码程序的插件，检测缓存失效的时间点去有选择的触发更新，还可以定时全部从数据节点更新数据进行缓存，需要说明的一点是靠近数据中心节点的缓存节点可以有程序进行这种方式更新，边缘节点的缓存更新可以有用户触发更新，如果再做的比较精致一点也可以更新边缘缓存节点，这样就看业务的敏感度了，这样每个节点的压力也小，响应也更及时，更新也非常方便。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633743184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301226,"discussion_content":"双key为啥会防雪崩？每次触发事件的线程不还是要去db查数据吗？总请求量也没有便少啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598446185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":8,"child_discussions":[{"author":{"id":1149065,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/89/929aed48.jpg","nickname":"大侠","note":"","ucode":"53851A49226B25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304752,"discussion_content":"我也有这个疑问，最后不还是要请求数据库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599657137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301226,"ip_address":"","group_id":0},"score":304752,"extra":""},{"author":{"id":2510638,"avatar":"https://static001.geekbang.org/account/avatar/00/26/4f/2e/575ee18b.jpg","nickname":"ZC荣","note":"","ucode":"2DACF6E7987B9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360765,"discussion_content":"在查数据库期间可以命中key2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616512585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301226,"ip_address":"","group_id":0},"score":360765,"extra":""},{"author":{"id":1606295,"avatar":"https://static001.geekbang.org/account/avatar/00/18/82/97/04d1d538.jpg","nickname":"RickyTheGeek","note":"","ucode":"806E4334A8E093","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028953,"avatar":"","nickname":"Geek3340","note":"","ucode":"C64D302CD53513","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367832,"discussion_content":"还是不一样的吧。我理解双Key的这种方法完全将业务访问挡在缓存层了，触发事件后可以通过一个共享变量状态标识来表示是否正在更新，然后每次触发事件的时候都去检查这个值，这样就可以保证DB的单次查询来更新缓存了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618478658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301226,"ip_address":"","group_id":0},"score":367832,"extra":""}]},{"author":{"id":3174600,"avatar":"https://static001.geekbang.org/account/avatar/00/30/70/c8/736dc26c.jpg","nickname":"仅此而已","note":"","ucode":"9EA07DBBE8473A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640990,"discussion_content":"这个双key策略怎么保证key1对应的value值跟DB里的一致性的呢？除非对数据准确度有一定的容忍度，要不然有可能出现key过期，直接读取key1的数据是不准确的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712052806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","nickname":"拿笔小星","note":"","ucode":"D3D8F6A959710D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604632,"discussion_content":"其实就是有过期时间的key起了一个定时任务的作用，定时发出更新缓存的事件。其实就是老师说的后台更新策略没啥区别。你这样反而复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676388774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053294,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ1VPGSQg7SqrN1Gutx31Kicks2icZjTCg1gZoDLfEcSSricYD6l5qQgE3MkMpqlhkM4gMicymOYzaudg/132","nickname":"可可","note":"","ucode":"297A5D32949128","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":593170,"discussion_content":"这个办法不错，就是有点浪费内存，算是空间换时间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667983954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235649,"avatar":"https://static001.geekbang.org/account/avatar/00/12/da/c1/b438893e.jpg","nickname":"湖","note":"","ucode":"292B05A8EEEEB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580726,"discussion_content":"可以参考下开源项目layering-cache的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658365240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2220816,"avatar":"https://static001.geekbang.org/account/avatar/00/21/e3/10/c7d0c076.jpg","nickname":"AndyDuf","note":"","ucode":"6A12AAB6FC4D74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558564,"discussion_content":"key失效了，去读取key1，这个key1数据是正确的吗？如果是过期的不会影响业务？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648380612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109389,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ed/8d/377c106a.jpg","nickname":"KW💤","note":"","ucode":"290DD7016F4EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404006,"discussion_content":"如果缓存的是复杂数据结构，在写时会阻塞读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634208110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1744257,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","nickname":"千锤百炼领悟之极限","note":"","ucode":"224B5CF2101716","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398991,"discussion_content":"这样业务没影响吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632883623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1473709,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7c/ad/57b768f7.jpg","nickname":"曾彪彪","note":"","ucode":"A815B6C3FA574D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375233,"discussion_content":"我觉得双key，就是老师说的后台更新的变体。key的超时时间t，就是后台线程更新缓存的周期。相反，在key失效的那一会，如果大量用户访问，会生成许多时间，这里如果不加锁，会造成大量数据库的访问。所以也需要在生成缓存时再读一遍缓存，如果存在就不更新了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621523250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2510638,"avatar":"https://static001.geekbang.org/account/avatar/00/26/4f/2e/575ee18b.jpg","nickname":"ZC荣","note":"","ucode":"2DACF6E7987B9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360768,"discussion_content":"当key失效时，会触发事件更新key和key1，解决在更新过程中的缓存穿透问题，nice!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616512733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11564,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1528204212,"is_pvip":false,"replies":[{"id":3752,"content":"我对mysql比较熟，以下仅限mysql：\n1. mysql第一种缓存叫sql语句结果缓存，但条件比较苛刻，程序员不可控，我们的dba线上都关闭这个功能，具体实现可以查一下\n2. mysql第二种缓存是innodb buffer pool，缓存的是磁盘上的分页数据，不是sql的查询结果，sql的执行过程省不了。而mc，redis这些实际上都是缓存sql的结果，两种缓存方式，性能差很远。\n\n因此，可控性，性能是数据库缓存和独立缓存的主要区别","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528253563,"ip_address":"","comment_id":11564,"utype":1}],"discussion_count":11,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"经常我说到缓存的时候，面试官问我，数据库自身不是有缓存吗，标准答案是怎么回击他?","like_count":221,"discussions":[{"author":{"id":1338831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/cf/ec335526.jpg","nickname":"jc9090kkk","note":"","ucode":"6C992D07A2E78F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22905,"discussion_content":"还有一个点就是，mysql本身就有查询缓存，但是对于写请求频繁的场景，查询缓存就是一个鸡肋，为什么？因为很可能一个更新请求把数据更新掉，刚把查询结果写入查询缓存中，另一个请求就把这条数据又更新了，那么查询缓存就必须被迫的更新，缓存没办法命中，任何缓存都有命中率的概念，如果缓存命中率太低，是属于资源浪费，还不如把占用的空间节省出来给其他能命中的缓存使用呢？所以很多时候，mysql上的查询缓存是关闭的，另一缓存就是华仔说的buffer pool，但是buffer pool的概念是缓冲，而不是缓存，因为buffer pool虽然是在内存中读取操作数据，但是里面很多复杂的模块，比如join buffer，包括分页数据，每隔一段时间都会去刷“脏页”到磁盘做持久化，这个缓存的机制并不是全部给做查询用的，只能说是很小的一部分，所以每次使用mysql的这个缓冲来做查询使用的话，mysql就腾不出资源去服务其他的模块，很容易影响性能。","likes_number":37,"is_delete":false,"is_hidden":false,"ctime":1569726402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418901,"discussion_content":"我对mysql比较熟，以下仅限mysql：\n1. mysql第一种缓存叫sql语句结果缓存，但条件比较苛刻，程序员不可控，我们的dba线上都关闭这个功能，具体实现可以查一下\n2. mysql第二种缓存是innodb buffer pool，缓存的是磁盘上的分页数据，不是sql的查询结果，sql的执行过程省不了。而mc，redis这些实际上都是缓存sql的结果，两种缓存方式，性能差很远。\n\n因此，可控性，性能是数据库缓存和独立缓存的主要区别","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1528253563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1590610,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","nickname":"帝江","note":"","ucode":"93CBA4E4D05DA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381129,"discussion_content":"更新此表的其他数据也会导致这个表的语句缓存失效，并不仅限于同一条数据，基于此，新版已经废弃这个功能了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1624924787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1302429,"avatar":"https://static001.geekbang.org/account/avatar/00/13/df/9d/0d334026.jpg","nickname":"胡须老爹","note":"","ucode":"5D1580A5D0C841","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287498,"discussion_content":"1）querycache的问题都提到了。\n2）在查询用到索引，而且是索引覆盖（无需回表）的情况下，仍需要O(logN)的复杂度定位到一条记录，缓存是O(1)。那么在非索引覆盖，复杂sql如group by，数据量大，innodb buffer page调入调出（一般内存远小于DB size）等的情况下，额外的消耗就更大了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593449373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272662,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/56/37a4cea7.jpg","nickname":"单朋荣","note":"","ucode":"8AD121BEDD9675","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625302,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691562878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009622,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/d6/2f5cb85c.jpg","nickname":"xmr","note":"","ucode":"1BBF165F91F10B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621680,"discussion_content":"很受用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687493538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2151836,"avatar":"https://static001.geekbang.org/account/avatar/00/20/d5/9c/842eda55.jpg","nickname":"一步两步","note":"","ucode":"B59D1F5293B5C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588641,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663921440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2935759,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/cb/cf/fc97de76.jpg","nickname":"Geektimer","note":"","ucode":"13746813BA173A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582177,"discussion_content":"数据库的缓存不是保存在内存里面吧，是磁盘上，所以不是一个量级的。CPU读取的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659276894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161522,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b9/32/84346d4a.jpg","nickname":"雪碧心拔凉","note":"","ucode":"D13EEBAA0F443B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409944,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635556769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1189765,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/85/06fbdeac.jpg","nickname":"Vincent","note":"","ucode":"F0A32C9210FF42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389465,"discussion_content":"MARK一下 很有用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629283506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390813,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ2QFSebcWYzvSibOicRbaeqGmq1kFuHVvwjadDsicQnIbovlGqSfmfibtib9TSwcIqWfcxkKw8DSxTTVg/132","nickname":"summer_7196","note":"","ucode":"B61E9F29D0D8CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":968,"discussion_content":"1、数据结构少。不像redis这么方便；2、缓存粒度不同，mysql表（语句）级缓存，redis行级缓存。不知这样说对不对？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562211149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11490,"user_name":"loveluckystar","can_delete":false,"product_type":"c1","uid":1097877,"ip_address":"","ucode":"370C38AF0E9A43","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/95/6f0aad03.jpg","comment_is_top":false,"comment_ctime":1528162395,"is_pvip":false,"replies":[{"id":3688,"content":"现学现用的案例，很赞👍👍","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185953,"ip_address":"","comment_id":11490,"utype":1}],"discussion_count":7,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"讲一个头两天发生的事情，我们的一个业务背后是es做db，之前是通过redis做缓存，缓存一段时间后失效再从es读取，是业务访问加载缓存的方式。有一天线上es集群机器单台出现问题，返回慢，由于分布式的缘故，渐渐拖满了所有请求，缓存失效来查询es发生了超时，加载失败，于是下次访问还是直接访问es。最终缓存全部失效，qps翻了好多倍，直接雪崩，es集群彻底没有响应了。。。之后我们只好先下线这个缓存加载功能，让集群活过来，最终改造缓存加载方式，用后台进程去更新缓存，而不用业务访问加载。","like_count":93,"discussions":[{"author":{"id":1338831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/cf/ec335526.jpg","nickname":"jc9090kkk","note":"","ucode":"6C992D07A2E78F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22905,"discussion_content":"还有一个点就是，mysql本身就有查询缓存，但是对于写请求频繁的场景，查询缓存就是一个鸡肋，为什么？因为很可能一个更新请求把数据更新掉，刚把查询结果写入查询缓存中，另一个请求就把这条数据又更新了，那么查询缓存就必须被迫的更新，缓存没办法命中，任何缓存都有命中率的概念，如果缓存命中率太低，是属于资源浪费，还不如把占用的空间节省出来给其他能命中的缓存使用呢？所以很多时候，mysql上的查询缓存是关闭的，另一缓存就是华仔说的buffer pool，但是buffer pool的概念是缓冲，而不是缓存，因为buffer pool虽然是在内存中读取操作数据，但是里面很多复杂的模块，比如join buffer，包括分页数据，每隔一段时间都会去刷“脏页”到磁盘做持久化，这个缓存的机制并不是全部给做查询用的，只能说是很小的一部分，所以每次使用mysql的这个缓冲来做查询使用的话，mysql就腾不出资源去服务其他的模块，很容易影响性能。","likes_number":37,"is_delete":false,"is_hidden":false,"ctime":1569726402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418901,"discussion_content":"我对mysql比较熟，以下仅限mysql：\n1. mysql第一种缓存叫sql语句结果缓存，但条件比较苛刻，程序员不可控，我们的dba线上都关闭这个功能，具体实现可以查一下\n2. mysql第二种缓存是innodb buffer pool，缓存的是磁盘上的分页数据，不是sql的查询结果，sql的执行过程省不了。而mc，redis这些实际上都是缓存sql的结果，两种缓存方式，性能差很远。\n\n因此，可控性，性能是数据库缓存和独立缓存的主要区别","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1528253563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1590610,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","nickname":"帝江","note":"","ucode":"93CBA4E4D05DA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381129,"discussion_content":"更新此表的其他数据也会导致这个表的语句缓存失效，并不仅限于同一条数据，基于此，新版已经废弃这个功能了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1624924787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1302429,"avatar":"https://static001.geekbang.org/account/avatar/00/13/df/9d/0d334026.jpg","nickname":"胡须老爹","note":"","ucode":"5D1580A5D0C841","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287498,"discussion_content":"1）querycache的问题都提到了。\n2）在查询用到索引，而且是索引覆盖（无需回表）的情况下，仍需要O(logN)的复杂度定位到一条记录，缓存是O(1)。那么在非索引覆盖，复杂sql如group by，数据量大，innodb buffer page调入调出（一般内存远小于DB size）等的情况下，额外的消耗就更大了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593449373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272662,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/56/37a4cea7.jpg","nickname":"单朋荣","note":"","ucode":"8AD121BEDD9675","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625302,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691562878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009622,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/d6/2f5cb85c.jpg","nickname":"xmr","note":"","ucode":"1BBF165F91F10B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621680,"discussion_content":"很受用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687493538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2151836,"avatar":"https://static001.geekbang.org/account/avatar/00/20/d5/9c/842eda55.jpg","nickname":"一步两步","note":"","ucode":"B59D1F5293B5C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588641,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663921440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2935759,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/cb/cf/fc97de76.jpg","nickname":"Geektimer","note":"","ucode":"13746813BA173A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582177,"discussion_content":"数据库的缓存不是保存在内存里面吧，是磁盘上，所以不是一个量级的。CPU读取的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659276894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161522,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b9/32/84346d4a.jpg","nickname":"雪碧心拔凉","note":"","ucode":"D13EEBAA0F443B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409944,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635556769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1189765,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/85/06fbdeac.jpg","nickname":"Vincent","note":"","ucode":"F0A32C9210FF42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389465,"discussion_content":"MARK一下 很有用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629283506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390813,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ2QFSebcWYzvSibOicRbaeqGmq1kFuHVvwjadDsicQnIbovlGqSfmfibtib9TSwcIqWfcxkKw8DSxTTVg/132","nickname":"summer_7196","note":"","ucode":"B61E9F29D0D8CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":968,"discussion_content":"1、数据结构少。不像redis这么方便；2、缓存粒度不同，mysql表（语句）级缓存，redis行级缓存。不知这样说对不对？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562211149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11512,"user_name":"三月沙@wecatch","can_delete":false,"product_type":"c1","uid":1034980,"ip_address":"","ucode":"16FEF6C74D24E3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ca/e4/f15a1cf0.jpg","comment_is_top":false,"comment_ctime":1528166753,"is_pvip":false,"replies":[{"id":3686,"content":"确实，细节不少，可以写本书了😃","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185736,"ip_address":"","comment_id":11512,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"好的缓存方案应该从这几个方面入手设计：\n1.什么数据应该缓存\n2.什么时机触发缓存和以及触发方式是什么\n3.缓存的层次和粒度（ 网关缓存如 nginx，本地缓存如单机文件，分布式缓存如redis cluster，进程内缓存如全局变量）\n4.缓存的命名规则和失效规则\n5.缓存的监控指标和故障应对方案\n6.可视化缓存数据如 redis 具体 key 内容和大小","like_count":83,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418872,"discussion_content":"确实，细节不少，可以写本书了😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2314165,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4f/b5/bd6140a5.jpg","nickname":"ARM","note":"","ucode":"788FD0DBD39B94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598337,"discussion_content":"说了又像是没说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672756901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597384,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671765102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":26645,"user_name":"一叶","can_delete":false,"product_type":"c1","uid":1115608,"ip_address":"","ucode":"EB018BDA606A33","user_header":"https://static001.geekbang.org/account/avatar/00/11/05/d8/cd269378.jpg","comment_is_top":false,"comment_ctime":1537709422,"is_pvip":false,"replies":[{"id":10021,"content":"很用心，赞👍","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1537951448,"ip_address":"","comment_id":26645,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"笔记：\n书籍：\n《高性能Mysql》\n《unix编程艺术》：宁花机器一分，不花程序员一秒\n\n提升性能：\n先单机，有压力后优先考虑sql优化、db参数调优，还有硬件性能(32核&#47;16G&#47;SSD)优化，不行还可以再考虑业务逻辑优化、缓存。不要一上来就读写分离、集群等，能单库搞定的就毫不犹豫的单库。\n\n---\n\n主从读写分离\n适用于单机无法应付所有请求，且读比写多时，读写分离还可以分别针对读写节点建索引来优化。\n对实时性要求不高：刚写入就读会有延迟，同步数据特别大时，延迟可能达到分钟级（可用缓存解决：2-8原则，挑选占访问量80%的前20%来缓存）。\nTODO主从还能设置自增长key不一样？\n\n分库分表（甚用，增加很多复杂度）\n几千万或上亿\n分库时机：单机性能瓶颈，1业务不复杂，但整体数据量影响到数据库性能；2业务复杂，需要分系统由不同团队开发，使用分库减少团队耦合。（分库导致不能join和事务（有方案但性能太低用了跟没分库差别不大，用最终一致性&#47;事件驱动））\n分表时机：单表数据量大拖慢了sql性能，做垂直（将常用和不常用字段分开）或水平拆分（id分段、hash路由、添加路由表等）提高速度。（那么join、count、分页排序等就变得复杂）\nTODO环状hash 一致性hash？\n\nnosql\n（nosql——not noly sql 本质上是牺牲ACID中的某个或某几个属性，以解决关系数据库某些复杂的问题）\n关系数据库：强大的sql功能和ACID属性，发展了几十年技术相当成熟 Mysql &#47; Postgresql \nk-v存储：解决关系数据库无法存储数据结构的问题 Redis &#47; Memcache （redis不太适合key的value特别大，这种情况会导致整个redis变慢，这种场景mc更好-&gt;参考IO模型 redis单Reactor单进程读写大value会阻塞所有业务 持久化也会）\n文档数据库：解决关系数据库强schema约束，查询不存在的列会报错，扩充很麻烦还会长时间锁表  MongoDB \n列式数据库：解决关系数据库处理大数据分析或统计时IO高的问题，关系数据库即使只处理某列也会把整行查询到内存中 HBase &#47; Greenplum\n全文搜索引擎：解决关系数据库全文搜索like扫描全表性能问题 ElasticSearch &#47; solr\nLevelDB 内存型？\n时序数据库？：实时计算统计实时监控 influxDB\nOLAP OLTP HTAP？\n\n缓存（千万千万不要设计复杂的缓存，到时候各种不一致问题烦死你）\ncdn、nginx缓存、网关缓存、数据层缓存redis、db本身也有缓存(sql结果缓存、读取的磁盘分页缓存)\n缓存穿透：1本身无数据(添加默认值缓存&#47;布隆过滤器[整型自增key？]) 2未生成缓存(识别爬虫并禁止 但可能影响seo)\n缓存雪崩：缓存实效后大家都在更新缓存导致系统性能急剧下降（1消息队列通知后台更新、2使用分布式更新锁）\n缓存热点：大部分业务都会命中的同一份缓存，比如1000w+粉丝的微博消息，复制多分缓存副本，key里面加副本编号将请求分散，且设置过期范围，而不是所有副本固定同一过期时间。\n缓存框架看一下设计思路：echcache、网友分享https:&#47;&#47;github.com&#47;qiujiayu&#47;AutoLoadCache\n\n\n","like_count":71,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424698,"discussion_content":"很用心，赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537951448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3972076,"avatar":"https://static001.geekbang.org/account/avatar/00/3c/9b/ec/7669e505.jpg","nickname":"张少维","note":"","ucode":"6DB56051E21DAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652408,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728885248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543822,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641308943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11478,"user_name":"mapping","can_delete":false,"product_type":"c1","uid":1023957,"ip_address":"","ucode":"75B1F0B248ADFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/d5/bc83e702.jpg","comment_is_top":false,"comment_ctime":1528161640,"is_pvip":false,"replies":[{"id":3694,"content":"你们的缓存设计有点复杂，还不如调整业务，越复杂的方案越容易出错，参考架构设计原则","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186490,"ip_address":"","comment_id":11478,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"计算机界两大难题：命名和缓存过期。没用缓存的时候，想着怎么用缓存提升性能，用了缓存又担心数据更新不及时。技术上希望所有的请求都能命中缓存，业务上又恨不得数据实时最新。所以就会引入各种缓存过期策略，如设置过期时间，按规则删除，打版本。这些应该在前期设计缓存系统时规划好，我们最早是将 sql md5 作 key 查询结果存入缓存，结果业务系统数据不一致，要清除缓存简直是噩梦，只能祭出绝招重启 memcache，后面改成按规则删除，在 key 中加上业务和用户的前缀，可以很方便删除某个业务或某个用户的缓存。以上过期策略在前端浏览器也是这样，最简单就是 web 服务器设置静态资源缓存过期时间，如果业务频繁发新版本，过期时间不宜设置太长，但其实每次变动的文件很少，这种策略会导致大部分缓存命中率不高。按规则删除，早期很多网站上会有诊断助手类的东西，页面加载错误点下诊断助手就帮你清除缓存，原理就是对静态文件逐一带上 no-cache 请求头发送 ajax 请求强制覆盖缓存（跟 DevTools 中 disable cache 原理一样）。打版本其实就相当于让浏览器请求一个新版本文件，对于老版本文件就让它在缓存中自生自灭。","like_count":26,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418859,"discussion_content":"你们的缓存设计有点复杂，还不如调整业务，越复杂的方案越容易出错，参考架构设计原则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11480,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1528161735,"is_pvip":true,"replies":[{"id":3692,"content":"1. 限流\n2. 容器化+动态化\n3. 业务降级，例如限制评论","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186335,"ip_address":"","comment_id":11480,"utype":1}],"discussion_count":1,"race_medal":1,"score":2,"product_id":100006601,"comment_content":"上缓存架构的时候，结合以前的实际经历，会有几个值得注意的地方:\n\n1 哪些数据才真正的需要缓存？缓存也并非银弹。既然允许数据缓存，那么在你是可以接受在一定时间区间内的数据不一致性的。(当然可以做到最终一致性)\n\n2 确定好1后，就需要会数据类型进行分类，比如业务数据缓存，http缓存等\n\n3 根据数据类型及访问特点的不同选择不同缓存类型的技术方案。\n\n请问华仔，热点数据存在相当的突发性，临时的扩容似乎也来不及，能否从缓存架构角度如何避免类似微博宕机的事件？\n\n","like_count":23,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418861,"discussion_content":"1. 限流\n2. 容器化+动态化\n3. 业务降级，例如限制评论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12948,"user_name":"醇梨子","can_delete":false,"product_type":"c1","uid":1089040,"ip_address":"","ucode":"25D498248A855C","user_header":"https://static001.geekbang.org/account/avatar/00/10/9e/10/3cb10bf7.jpg","comment_is_top":false,"comment_ctime":1529199686,"is_pvip":false,"replies":[{"id":4350,"content":"没法保证，这类数据允许一定的不一致，一定范围内的对用户也没有影响，不要只从技术的角度考虑问题，结合业务考虑技术","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1529377635,"ip_address":"","comment_id":12948,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"华仔，请教一下，针对这种高并发缓存架构设计中，缓存和存储系统一致性问题怎么保证？比如说商品浏览人数，需要存库，然后又需要放缓存，需要频繁更新数据库。","like_count":21,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419472,"discussion_content":"没法保证，这类数据允许一定的不一致，一定范围内的对用户也没有影响，不要只从技术的角度考虑问题，结合业务考虑技术","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529377635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2663324,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a3/9c/836d7bb3.jpg","nickname":"11月的萧邦","note":"","ucode":"E7A2236BFD9ABE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385823,"discussion_content":"不好保证，我们的方案是先放缓存并在缓存做增减计算，然后每隔1分钟后同步至数据库，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627288495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1193755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","nickname":"拿笔小星","note":"","ucode":"D3D8F6A959710D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2663324,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a3/9c/836d7bb3.jpg","nickname":"11月的萧邦","note":"","ucode":"E7A2236BFD9ABE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604635,"discussion_content":"我们也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676389482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":385823,"ip_address":"上海","group_id":0},"score":604635,"extra":""}]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381058,"discussion_content":"监听binlog，然后删缓存\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624882719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018605,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/ed/0fed07ae.jpg","nickname":"冰梨icePear🍐","note":"","ucode":"7DEB5DCE53107E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373871,"discussion_content":"这个一般是前端记数定期同步，一致性肯定不能严格保证的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620899957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11514,"user_name":"鹅米豆发","can_delete":false,"product_type":"c1","uid":1017687,"ip_address":"","ucode":"98E8D911EE32DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/57/645159ee.jpg","comment_is_top":false,"comment_ctime":1528167725,"is_pvip":false,"replies":[{"id":3684,"content":"缓存持久化是一个不错的方法","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185528,"ip_address":"","comment_id":11514,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"       1、最早也是采用后台用数据库，前台用关系型数据库+被动缓存的模式。结果是经常的性能抖动，且缓存一致性问题很难解决。后来我们的多数系统，都采用了前后台分离的模式——后台原始数据仍然是关系型数据库，前台使用缓存作为数据源，两者之间数据实时同步+定时同步+人工触发结合。\n       这个模式，基本根除了穿透，雪崩，不一致，性能抖动这些。但带来了新的问题，比如数据丢失且不可恢复。我们的做法是，让缓存具备相对可靠的持久化机制+运维体系。\n       2、遇到过几次热点问题，感觉这个更加棘手些。第一种情况，单Key数据结构本身过大，单个分片出现热点，单次访问的复杂度变大。这个相对容易，可以对key进行拆分，使用hashtag机制分片。第二种情况，数据分片普遍不均衡，较少遇到，遇到就比较棘手。第三种情况，数据分片均衡，但访问不均衡，可以增加副本数量。","like_count":14,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418874,"discussion_content":"缓存持久化是一个不错的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16809,"user_name":"blacknccccc","can_delete":false,"product_type":"c1","uid":1170877,"ip_address":"","ucode":"CC2310B04A624A","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/bd/9b93ea26.jpg","comment_is_top":false,"comment_ctime":1532228198,"is_pvip":false,"replies":[{"id":5837,"content":"淘宝的具体实现没有研究，我们有类似的案例，针对常用的分类会统一缓存，缓存会主动更新；不常用的根据查询条件计算md5作为key 进行缓存，缓存时间不长，例如60分钟，防止短时间内大量访问压垮存储，例如爬虫","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532255212,"ip_address":"","comment_id":16809,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100006601,"comment_content":"对于像淘宝商品列表筛选项特别多，组合起来会更多，这样在后台做更新缓存怎么处理，难道是把每一种组合的分页数据都缓存下来吗","like_count":13,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420935,"discussion_content":"淘宝的具体实现没有研究，我们有类似的案例，针对常用的分类会统一缓存，缓存会主动更新；不常用的根据查询条件计算md5作为key 进行缓存，缓存时间不长，例如60分钟，防止短时间内大量访问压垮存储，例如爬虫","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532255212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11571,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1528207047,"is_pvip":false,"replies":[{"id":3746,"content":"通常有几种做法：\n1. 同步刷新缓存：当更新了某些信息后，立刻让缓存失效。\n这种做法的优点是用户体验好，缺点是修改一个数据可能需要让很多缓存失效\n2. 适当容忍不一致：例如某东的商品就是这样，我查询的时候显示有货，下单的时候提示我没货了\n3. 关键信息不缓存：库存，价格等不缓存，因为这类信息查询简单，效率高，关系数据库查询性能也很高","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528252902,"ip_address":"","comment_id":11571,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"商品列表中，像商品描述等信息，缓存更新不及时影响不大，但某些重要数据，如价格，需要及时更新的数据，有没什么好的办法做到刷新。对于价格这种关键数据，不缓存，直接从数据库查询，是否可行。或者在用户查看商品详情时再去数据库查询价格，但可能出现列表中的价格和详情页中的价格不一致。","like_count":12},{"had_liked":false,"id":42447,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1542956268,"is_pvip":true,"replies":[{"id":15294,"content":"穿透和击穿是一个概念，雪崩不是你理解的那样，雪崩的意思就是开始一个小问题越来越大越来越严重，缓存宕机导致的问题算缓存穿透，就是指缓存没作用了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1543040199,"ip_address":"","comment_id":42447,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"感觉概念理解上有点差异，缓存穿透出现在缓存失效要去查数据库。缓存击穿则是一个key失效导致高并发访问数据库压力增大。缓存雪崩则是大量缓存key失效或者缓存宕机了，导致数据库并发压力增大。感觉老师您把缓存穿透说成了击穿，击穿说成了雪崩。不知道我是否理解有问题？","like_count":9,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430096,"discussion_content":"穿透和击穿是一个概念，雪崩不是你理解的那样，雪崩的意思就是开始一个小问题越来越大越来越严重，缓存宕机导致的问题算缓存穿透，就是指缓存没作用了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1543040199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11608,"user_name":"何磊","can_delete":false,"product_type":"c1","uid":1047604,"ip_address":"","ucode":"78934C3ED4A342","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/34/c733b116.jpg","comment_is_top":false,"comment_ctime":1528247514,"is_pvip":false,"replies":[{"id":3738,"content":"除非特殊场景，一般我还是建议尽量用简单直观甚至粗暴的方案😂","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528251340,"ip_address":"","comment_id":11608,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"遇到过一次缓存失效导致缓存穿透，很多请求的压力直接到了db。为了处理这种情况，我采用的方案就是：key永不过期，后台有个进程定时更新所有缓存。\n文中提到的结合消息队列来更新更具有时效性，非常棒，看到评论中的有一个双key机制，设计很巧妙，不过成本太高了。相当于成本翻倍。","like_count":9,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418923,"discussion_content":"除非特殊场景，一般我还是建议尽量用简单直观甚至粗暴的方案😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528251340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11494,"user_name":"cqc","can_delete":false,"product_type":"c1","uid":1099493,"ip_address":"","ucode":"18053C9C62805F","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/e5/7e86498f.jpg","comment_is_top":false,"comment_ctime":1528162765,"is_pvip":false,"replies":[{"id":3687,"content":"1.是的，所以加内存才是根本解决方式\n2. 这是分级缓存策略","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185847,"ip_address":"","comment_id":11494,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"1个问题：关于后台更新，既然缓存服务器内存不足，需要剔除数据，那么后台更新再次触发查询，是否又会导致其他一些缓存数据被剔除，这感觉像是陷入一个循环了\n1个思路：我们之前的web项目，对于缓存热点数据，为了减少服务器的压力，在客户端引入了缓存：CDN加local storage，感觉对服务器端压力分散还是很有效果的。","like_count":9,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418870,"discussion_content":"1.是的，所以加内存才是根本解决方式\n2. 这是分级缓存策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11485,"user_name":"byte","can_delete":false,"product_type":"c1","uid":1034849,"ip_address":"","ucode":"2E2F1426AF7583","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ca/61/b3f00e6f.jpg","comment_is_top":false,"comment_ctime":1528162001,"is_pvip":false,"replies":[{"id":3691,"content":"缓存集群间一般不要跨数据中心同步，存储可以用跨数据中心同步","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186220,"ip_address":"","comment_id":11485,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"业务上通过Redis集群缓存网络数据，分布在北上广三地，3个数据中心，集群规模是80台物理机共1000个左右实例1主3从。线上出现过跨地域集群数据频繁全量同步打爆交换机的问题，导致整个服务不可用。通过排查发现是网络延时导致频繁全量同步以及服务器电源过热导致从服务器频繁重启。解决方案是跨地数据同步通过kafka试下，再接入各地Redis集群，电源问题通过更换硬件解决。","like_count":8,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418863,"discussion_content":"缓存集群间一般不要跨数据中心同步，存储可以用跨数据中心同步","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1528186220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11462,"user_name":"倔强小小🐤","can_delete":false,"product_type":"c1","uid":1141821,"ip_address":"","ucode":"6C13859871A111","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/3d/f9ec02ea.jpg","comment_is_top":false,"comment_ctime":1528159405,"is_pvip":false,"replies":[{"id":3701,"content":"前后端分离，在node上缓存和渲染试试","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528188950,"ip_address":"","comment_id":11462,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"我们系统是做美术馆的3d展示的，后台配置的数据有点多，画框数据有几m，单个模型数据有几百k，最早直接mysql直接读取，后来用redis但是感觉效果不理想，又引入ehcache，发现不经过网络传输性能很好，经过网络传输后网络一般还是卡的很，后来又在前端用local storage进行缓存，后端通过rabbitmq进行消息通知前端清除本地缓存，缓存设置有效期都是一天，请问下我们这种情况有更好的方案吗","like_count":8,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418853,"discussion_content":"前后端分离，在node上缓存和渲染试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528188950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11602,"user_name":"june peng","can_delete":false,"product_type":"c1","uid":1005648,"ip_address":"","ucode":"D6B3E655395E36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/50/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1528245828,"is_pvip":false,"replies":[{"id":3740,"content":"你的分析很对👍\n具体在实现的时候，后台更新线程既不能只有一个，也不能和业务线程一样多，一般8~32个就差不多了，因为缓存更新并不会非常频繁。\n假如8个线程后台更新也可能导致缓存雪崩，那就要做更多事情了，例如：后台线程更新前先读取一下缓存，存在就不更新。","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528251849,"ip_address":"","comment_id":11602,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"你好，在缓存雪崩后台更新策略里，比如1000个同时访问一个失效的缓存key，如果给这个key加读写锁，这样保证只有一个访问存储系统，其它999个人虽然慢点，但是至少能保证业务不会挂。如果用消息队列，就是前台只拿缓存key里的数据（不能访问存储系统），如果key不存在就发给消息队列更新，如果启多个进程去接受这些消息，依然不能避免后台击穿存储系统，难道只有启用一个进程？这样又太慢，可否进一步说明这种方案的复杂点在哪？谢谢","like_count":7,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418853,"discussion_content":"前后端分离，在node上缓存和渲染试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528188950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21316,"user_name":"Sic Pavis","can_delete":false,"product_type":"c1","uid":1106088,"ip_address":"","ucode":"48B5F0118347C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","comment_is_top":false,"comment_ctime":1535024153,"is_pvip":false,"replies":[{"id":7733,"content":"这种做法会经常出现一些线上小问题","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1535290222,"ip_address":"","comment_id":21316,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"刚好前段时间就有一个问题。\n产品反馈：后台更新的配置不生效，需要过几小时到半天不等的时间才能生效。\n从数据库确认持久化数据没问题，因此怀疑是缓存问题。\n\n我们的缓存设计是：业务key加一个缓存版本号做key，每次更新数据对应缓存的版本号就+1。\n前台定期扫描缓存版本号来实现缓存的更新。\n\n于是我查到了线上最新的版本号去缓存服务器查询，见鬼，数据也是正常的。排查了几天没有结果，无奈上线一个版本打了debug日志，终于找到原因了。\n\n我们的服务是双中心的，两边各存有一份缓存版本号，不知道什么原因，导致一边的缓存版本号比另外一个集群的多了3。由于我们的更新策略不是删掉无效的缓存，而是更新缓存的key，因此旧版本的缓存数据实际上还在缓存服务器上。更要命的是缓存服务器做了双中心同步（为啥同步暂且不提），这样就导致实际上一边集群读取的实际上是另外一个集群几个版本前留下的缓存数据。需要等待这个数据过期后，才能正常从数据库加载数据。","like_count":6,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422632,"discussion_content":"这种做法会经常出现一些线上小问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535290222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","nickname":"skying","note":"","ucode":"E7CFF50AB64BB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343474,"discussion_content":"对于这种缓存更新的，直接清除缓存是不是 更稳妥一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611056935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1106088,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","nickname":"Sic Pavis","note":"","ucode":"48B5F0118347C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1041865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","nickname":"skying","note":"","ucode":"E7CFF50AB64BB1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345410,"discussion_content":"单纯删除的话，考虑如下时间顺序的逻辑\n1. 旧缓存过期\n2. a线程从持久化数据库读取到旧数据。\n3. b线程更新数据，执行缓存删除\n4. a线程将旧数据写入缓存\n\n那么在下一次更新数据过缓存失效前。缓存里的都是脏数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611718487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343474,"ip_address":"","group_id":0},"score":345410,"extra":""},{"author":{"id":1009622,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/d6/2f5cb85c.jpg","nickname":"xmr","note":"","ucode":"1BBF165F91F10B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1106088,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","nickname":"Sic Pavis","note":"","ucode":"48B5F0118347C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621683,"discussion_content":"延迟双删","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687496426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345410,"ip_address":"广东","group_id":0},"score":621683,"extra":""}]}]},{"had_liked":false,"id":213274,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1588348151,"is_pvip":true,"replies":[{"id":79160,"content":"大量缓存同时到期基本不会出现，因为缓存的key很多，每个key访问是随机的，每个key的有效期也是不同的，除非缓存服务器故障，或者程序出bug，例如某个死循环写入大量缓存，导致大量缓存被踢","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1588464169,"ip_address":"","comment_id":213274,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"本来是看在《数据结构和算法之美》看一致性哈希，然后看到了雪崩效应，然后找到缓存雪崩，然后找到了这里。\n\n我对于缓存雪崩 Cache avalanche的定义有一点疑问，感觉似乎更像是缓存击穿 Cache breakdown，当然这两个的定义本来就有相似的地方。缓存击穿更多的强调大量缓存同时过期，而缓存雪崩在缓存过期的基础上，又加上了缓存服务器宕机。\n\n就好比，一台缓存服务器宕机，然后导致其他的缓存服务器压力变大，进而影响整个缓存系统。就好像是雪崩时的第一片掉落的雪花。\n\n不过，定义本身并不重要，主要还是对于场景的描述和解决方案。\n\n有意思的是，似乎在维基百科上并没有 Cache avalanche, Cache breakdown, Cache penetration 的定义。","like_count":5,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422632,"discussion_content":"这种做法会经常出现一些线上小问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535290222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","nickname":"skying","note":"","ucode":"E7CFF50AB64BB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343474,"discussion_content":"对于这种缓存更新的，直接清除缓存是不是 更稳妥一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611056935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1106088,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","nickname":"Sic Pavis","note":"","ucode":"48B5F0118347C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1041865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","nickname":"skying","note":"","ucode":"E7CFF50AB64BB1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345410,"discussion_content":"单纯删除的话，考虑如下时间顺序的逻辑\n1. 旧缓存过期\n2. a线程从持久化数据库读取到旧数据。\n3. b线程更新数据，执行缓存删除\n4. a线程将旧数据写入缓存\n\n那么在下一次更新数据过缓存失效前。缓存里的都是脏数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611718487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343474,"ip_address":"","group_id":0},"score":345410,"extra":""},{"author":{"id":1009622,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/d6/2f5cb85c.jpg","nickname":"xmr","note":"","ucode":"1BBF165F91F10B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1106088,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","nickname":"Sic Pavis","note":"","ucode":"48B5F0118347C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621683,"discussion_content":"延迟双删","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687496426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345410,"ip_address":"广东","group_id":0},"score":621683,"extra":""}]}]},{"had_liked":false,"id":11596,"user_name":"100kg","can_delete":false,"product_type":"c1","uid":1101294,"ip_address":"","ucode":"98589A8F7ED8BB","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/ee/f204ba32.jpg","comment_is_top":false,"comment_ctime":1528244315,"is_pvip":false,"replies":[{"id":3742,"content":"不会，索性是对已经存在的值建立索性数据结构，值的连续性和大小对数据结构本身没有影响，值的数量才会影响索性的大小和性能","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528251985,"ip_address":"","comment_id":11596,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"你好，我想请教下，如果两台mysql互为主从，其中一台主键自增步长设置为2，另一个为1，这样做会影响性能吗？比如索引的连贯性之类的","like_count":5,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418916,"discussion_content":"不会，索性是对已经存在的值建立索性数据结构，值的连续性和大小对数据结构本身没有影响，值的数量才会影响索性的大小和性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528251985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098690,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/c2/5ff554d9.jpg","nickname":"@","note":"","ucode":"AC8227752777D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1016,"discussion_content":"主从同步不是数据直接复制过去吗？还能自定义自己的自增的吗，或者说同步的时候制定了只同步某些字段？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562236362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11571,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1528207047,"is_pvip":false,"replies":[{"id":3746,"content":"通常有几种做法：\n1. 同步刷新缓存：当更新了某些信息后，立刻让缓存失效。\n这种做法的优点是用户体验好，缺点是修改一个数据可能需要让很多缓存失效\n2. 适当容忍不一致：例如某东的商品就是这样，我查询的时候显示有货，下单的时候提示我没货了\n3. 关键信息不缓存：库存，价格等不缓存，因为这类信息查询简单，效率高，关系数据库查询性能也很高","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528252902,"ip_address":"","comment_id":11571,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"商品列表中，像商品描述等信息，缓存更新不及时影响不大，但某些重要数据，如价格，需要及时更新的数据，有没什么好的办法做到刷新。对于价格这种关键数据，不缓存，直接从数据库查询，是否可行。或者在用户查看商品详情时再去数据库查询价格，但可能出现列表中的价格和详情页中的价格不一致。","like_count":12,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418905,"discussion_content":"通常有几种做法：\n1. 同步刷新缓存：当更新了某些信息后，立刻让缓存失效。\n这种做法的优点是用户体验好，缺点是修改一个数据可能需要让很多缓存失效\n2. 适当容忍不一致：例如某东的商品就是这样，我查询的时候显示有货，下单的时候提示我没货了\n3. 关键信息不缓存：库存，价格等不缓存，因为这类信息查询简单，效率高，关系数据库查询性能也很高","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1528252902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381059,"discussion_content":"关系数据库：热点商品也有可能抗不住。而库存因为从商品浏览到商品下单，中间的转化比本身会挡一部分流量。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624882983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42447,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1542956268,"is_pvip":true,"replies":[{"id":15294,"content":"穿透和击穿是一个概念，雪崩不是你理解的那样，雪崩的意思就是开始一个小问题越来越大越来越严重，缓存宕机导致的问题算缓存穿透，就是指缓存没作用了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1543040199,"ip_address":"","comment_id":42447,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"感觉概念理解上有点差异，缓存穿透出现在缓存失效要去查数据库。缓存击穿则是一个key失效导致高并发访问数据库压力增大。缓存雪崩则是大量缓存key失效或者缓存宕机了，导致数据库并发压力增大。感觉老师您把缓存穿透说成了击穿，击穿说成了雪崩。不知道我是否理解有问题？","like_count":9,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418905,"discussion_content":"通常有几种做法：\n1. 同步刷新缓存：当更新了某些信息后，立刻让缓存失效。\n这种做法的优点是用户体验好，缺点是修改一个数据可能需要让很多缓存失效\n2. 适当容忍不一致：例如某东的商品就是这样，我查询的时候显示有货，下单的时候提示我没货了\n3. 关键信息不缓存：库存，价格等不缓存，因为这类信息查询简单，效率高，关系数据库查询性能也很高","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1528252902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381059,"discussion_content":"关系数据库：热点商品也有可能抗不住。而库存因为从商品浏览到商品下单，中间的转化比本身会挡一部分流量。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624882983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11608,"user_name":"何磊","can_delete":false,"product_type":"c1","uid":1047604,"ip_address":"","ucode":"78934C3ED4A342","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/34/c733b116.jpg","comment_is_top":false,"comment_ctime":1528247514,"is_pvip":false,"replies":[{"id":3738,"content":"除非特殊场景，一般我还是建议尽量用简单直观甚至粗暴的方案😂","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528251340,"ip_address":"","comment_id":11608,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"遇到过一次缓存失效导致缓存穿透，很多请求的压力直接到了db。为了处理这种情况，我采用的方案就是：key永不过期，后台有个进程定时更新所有缓存。\n文中提到的结合消息队列来更新更具有时效性，非常棒，看到评论中的有一个双key机制，设计很巧妙，不过成本太高了。相当于成本翻倍。","like_count":9,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430096,"discussion_content":"穿透和击穿是一个概念，雪崩不是你理解的那样，雪崩的意思就是开始一个小问题越来越大越来越严重，缓存宕机导致的问题算缓存穿透，就是指缓存没作用了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1543040199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11494,"user_name":"cqc","can_delete":false,"product_type":"c1","uid":1099493,"ip_address":"","ucode":"18053C9C62805F","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/e5/7e86498f.jpg","comment_is_top":false,"comment_ctime":1528162765,"is_pvip":false,"replies":[{"id":3687,"content":"1.是的，所以加内存才是根本解决方式\n2. 这是分级缓存策略","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185847,"ip_address":"","comment_id":11494,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"1个问题：关于后台更新，既然缓存服务器内存不足，需要剔除数据，那么后台更新再次触发查询，是否又会导致其他一些缓存数据被剔除，这感觉像是陷入一个循环了\n1个思路：我们之前的web项目，对于缓存热点数据，为了减少服务器的压力，在客户端引入了缓存：CDN加local storage，感觉对服务器端压力分散还是很有效果的。","like_count":9,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418923,"discussion_content":"除非特殊场景，一般我还是建议尽量用简单直观甚至粗暴的方案😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528251340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11485,"user_name":"byte","can_delete":false,"product_type":"c1","uid":1034849,"ip_address":"","ucode":"2E2F1426AF7583","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ca/61/b3f00e6f.jpg","comment_is_top":false,"comment_ctime":1528162001,"is_pvip":false,"replies":[{"id":3691,"content":"缓存集群间一般不要跨数据中心同步，存储可以用跨数据中心同步","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186220,"ip_address":"","comment_id":11485,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"业务上通过Redis集群缓存网络数据，分布在北上广三地，3个数据中心，集群规模是80台物理机共1000个左右实例1主3从。线上出现过跨地域集群数据频繁全量同步打爆交换机的问题，导致整个服务不可用。通过排查发现是网络延时导致频繁全量同步以及服务器电源过热导致从服务器频繁重启。解决方案是跨地数据同步通过kafka试下，再接入各地Redis集群，电源问题通过更换硬件解决。","like_count":8,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418870,"discussion_content":"1.是的，所以加内存才是根本解决方式\n2. 这是分级缓存策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11462,"user_name":"倔强小小🐤","can_delete":false,"product_type":"c1","uid":1141821,"ip_address":"","ucode":"6C13859871A111","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/3d/f9ec02ea.jpg","comment_is_top":false,"comment_ctime":1528159405,"is_pvip":false,"replies":[{"id":3701,"content":"前后端分离，在node上缓存和渲染试试","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528188950,"ip_address":"","comment_id":11462,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"我们系统是做美术馆的3d展示的，后台配置的数据有点多，画框数据有几m，单个模型数据有几百k，最早直接mysql直接读取，后来用redis但是感觉效果不理想，又引入ehcache，发现不经过网络传输性能很好，经过网络传输后网络一般还是卡的很，后来又在前端用local storage进行缓存，后端通过rabbitmq进行消息通知前端清除本地缓存，缓存设置有效期都是一天，请问下我们这种情况有更好的方案吗","like_count":8,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418863,"discussion_content":"缓存集群间一般不要跨数据中心同步，存储可以用跨数据中心同步","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1528186220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11602,"user_name":"june peng","can_delete":false,"product_type":"c1","uid":1005648,"ip_address":"","ucode":"D6B3E655395E36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/50/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1528245828,"is_pvip":false,"replies":[{"id":3740,"content":"你的分析很对👍\n具体在实现的时候，后台更新线程既不能只有一个，也不能和业务线程一样多，一般8~32个就差不多了，因为缓存更新并不会非常频繁。\n假如8个线程后台更新也可能导致缓存雪崩，那就要做更多事情了，例如：后台线程更新前先读取一下缓存，存在就不更新。","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528251849,"ip_address":"","comment_id":11602,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"你好，在缓存雪崩后台更新策略里，比如1000个同时访问一个失效的缓存key，如果给这个key加读写锁，这样保证只有一个访问存储系统，其它999个人虽然慢点，但是至少能保证业务不会挂。如果用消息队列，就是前台只拿缓存key里的数据（不能访问存储系统），如果key不存在就发给消息队列更新，如果启多个进程去接受这些消息，依然不能避免后台击穿存储系统，难道只有启用一个进程？这样又太慢，可否进一步说明这种方案的复杂点在哪？谢谢","like_count":7,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418919,"discussion_content":"你的分析很对👍\n具体在实现的时候，后台更新线程既不能只有一个，也不能和业务线程一样多，一般8~32个就差不多了，因为缓存更新并不会非常频繁。\n假如8个线程后台更新也可能导致缓存雪崩，那就要做更多事情了，例如：后台线程更新前先读取一下缓存，存在就不更新。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1528251849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21316,"user_name":"Sic Pavis","can_delete":false,"product_type":"c1","uid":1106088,"ip_address":"","ucode":"48B5F0118347C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","comment_is_top":false,"comment_ctime":1535024153,"is_pvip":false,"replies":[{"id":7733,"content":"这种做法会经常出现一些线上小问题","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1535290222,"ip_address":"","comment_id":21316,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"刚好前段时间就有一个问题。\n产品反馈：后台更新的配置不生效，需要过几小时到半天不等的时间才能生效。\n从数据库确认持久化数据没问题，因此怀疑是缓存问题。\n\n我们的缓存设计是：业务key加一个缓存版本号做key，每次更新数据对应缓存的版本号就+1。\n前台定期扫描缓存版本号来实现缓存的更新。\n\n于是我查到了线上最新的版本号去缓存服务器查询，见鬼，数据也是正常的。排查了几天没有结果，无奈上线一个版本打了debug日志，终于找到原因了。\n\n我们的服务是双中心的，两边各存有一份缓存版本号，不知道什么原因，导致一边的缓存版本号比另外一个集群的多了3。由于我们的更新策略不是删掉无效的缓存，而是更新缓存的key，因此旧版本的缓存数据实际上还在缓存服务器上。更要命的是缓存服务器做了双中心同步（为啥同步暂且不提），这样就导致实际上一边集群读取的实际上是另外一个集群几个版本前留下的缓存数据。需要等待这个数据过期后，才能正常从数据库加载数据。","like_count":6,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418919,"discussion_content":"你的分析很对👍\n具体在实现的时候，后台更新线程既不能只有一个，也不能和业务线程一样多，一般8~32个就差不多了，因为缓存更新并不会非常频繁。\n假如8个线程后台更新也可能导致缓存雪崩，那就要做更多事情了，例如：后台线程更新前先读取一下缓存，存在就不更新。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1528251849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213274,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1588348151,"is_pvip":true,"replies":[{"id":79160,"content":"大量缓存同时到期基本不会出现，因为缓存的key很多，每个key访问是随机的，每个key的有效期也是不同的，除非缓存服务器故障，或者程序出bug，例如某个死循环写入大量缓存，导致大量缓存被踢","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1588464169,"ip_address":"","comment_id":213274,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"本来是看在《数据结构和算法之美》看一致性哈希，然后看到了雪崩效应，然后找到缓存雪崩，然后找到了这里。\n\n我对于缓存雪崩 Cache avalanche的定义有一点疑问，感觉似乎更像是缓存击穿 Cache breakdown，当然这两个的定义本来就有相似的地方。缓存击穿更多的强调大量缓存同时过期，而缓存雪崩在缓存过期的基础上，又加上了缓存服务器宕机。\n\n就好比，一台缓存服务器宕机，然后导致其他的缓存服务器压力变大，进而影响整个缓存系统。就好像是雪崩时的第一片掉落的雪花。\n\n不过，定义本身并不重要，主要还是对于场景的描述和解决方案。\n\n有意思的是，似乎在维基百科上并没有 Cache avalanche, Cache breakdown, Cache penetration 的定义。","like_count":5,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493727,"discussion_content":"大量缓存同时到期基本不会出现，因为缓存的key很多，每个key访问是随机的，每个key的有效期也是不同的，除非缓存服务器故障，或者程序出bug，例如某个死循环写入大量缓存，导致大量缓存被踢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588464169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11596,"user_name":"100kg","can_delete":false,"product_type":"c1","uid":1101294,"ip_address":"","ucode":"98589A8F7ED8BB","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/ee/f204ba32.jpg","comment_is_top":false,"comment_ctime":1528244315,"is_pvip":false,"replies":[{"id":3742,"content":"不会，索性是对已经存在的值建立索性数据结构，值的连续性和大小对数据结构本身没有影响，值的数量才会影响索性的大小和性能","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528251985,"ip_address":"","comment_id":11596,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100006601,"comment_content":"你好，我想请教下，如果两台mysql互为主从，其中一台主键自增步长设置为2，另一个为1，这样做会影响性能吗？比如索引的连贯性之类的","like_count":5,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493727,"discussion_content":"大量缓存同时到期基本不会出现，因为缓存的key很多，每个key访问是随机的，每个key的有效期也是不同的，除非缓存服务器故障，或者程序出bug，例如某个死循环写入大量缓存，导致大量缓存被踢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588464169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11566,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1528204994,"is_pvip":false,"replies":[{"id":3750,"content":"一般不会出现这种情况，但缓存服务器宕机的场景和你说的类似，我们一般会要求线上进行模拟测试，假如一台缓存服务器宕机，系统是否能够顶住，如果顶不住，就要增加缓存服务器，或者优化某些key的设计","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528253272,"ip_address":"","comment_id":11566,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"关于缓存雪崩的定义，文中的例子是说单条缓存在生成的时间间隔内有大量相同请求查询存储系统，除此之外，记得还有一个更典型的场景，是大量缓存同时过期，导致大量不同请求去查询存储系统(数据库)。请点评。","like_count":5},{"had_liked":false,"id":57208,"user_name":"kissrain","can_delete":false,"product_type":"c1","uid":1120583,"ip_address":"","ucode":"2177C53E3B2DCC","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/47/b27f1314.jpg","comment_is_top":false,"comment_ctime":1546682736,"is_pvip":false,"replies":[{"id":20639,"content":"先失效缓存再写数据库吧，因为失效缓存失败的话，也就不会写入数据库了，写入数据库失败的话，缓存还会加载原来的值","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1546694177,"ip_address":"","comment_id":57208,"utype":1}],"discussion_count":11,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"请教一下华仔，像用户下单场景，是先写入数据库再失效缓存还是先失效缓存再写入数据库呢？","like_count":4,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418903,"discussion_content":"一般不会出现这种情况，但缓存服务器宕机的场景和你说的类似，我们一般会要求线上进行模拟测试，假如一台缓存服务器宕机，系统是否能够顶住，如果顶不住，就要增加缓存服务器，或者优化某些key的设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528253272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11569,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1528205591,"is_pvip":false,"replies":[{"id":3748,"content":"通常情况下，业务线程数量要远远大于后台更新线程数量。假设20台64核机器，每台机器256线程，业务线程就是5120个，后台缓存更新线程数量一般8~32就足够了。\n\n如果缓存设计是只能一个线程更新，那确实也只能用锁了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528253137,"ip_address":"","comment_id":11569,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"&#39;后台更新既适应单机多线程的场景，也适合分布式集群的场景，相比更新锁机制要简单一些.&#39; - 没觉得简单啊，因为如文中所说，后台更新也可能会出现多个业务线程都发送了缓存更新消息，这种情况我理解也需要有分布式锁来避免多个相同请求查询存储系统，否则在判断的时候，因为缓存在构建还没有准备好。","like_count":4,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435462,"discussion_content":"先失效缓存再写数据库吧，因为失效缓存失败的话，也就不会写入数据库了，写入数据库失败的话，缓存还会加载原来的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546694177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3236509,"avatar":"https://static001.geekbang.org/account/avatar/00/31/62/9d/82e73c79.jpg","nickname":"shawshank","note":"","ucode":"5E5AC72226D862","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":645147,"discussion_content":"这里是不是应该再补充一个写入数据库后再删除一次缓存，但是这里也可能删失败，是不是最好是订阅binlog再同步到缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715822792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":435462,"ip_address":"广东","group_id":0},"score":645147,"extra":""}]},{"author":{"id":2155138,"avatar":"","nickname":"Geek_279aff","note":"","ucode":"CF76C4EAB9A1A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325150,"discussion_content":"会不会入库再失效好点？先失效再入库，如果在两步中间有发生一次查询，这样缓存的还是旧数据，但是入库的却是新的数据，不一致了吧。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605246009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1522800,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLdiaoSDXm3KibVMaYM2MiaAaleb3BW4Tgdw10qRtIhbOvMPib5Y0SJA3sBVOdYIjWq8bzf0hSA8XCf2w/132","nickname":"小熊","note":"","ucode":"D83E64BDD34F86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2155138,"avatar":"","nickname":"Geek_279aff","note":"","ucode":"CF76C4EAB9A1A2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365711,"discussion_content":"对，感觉还是先入库后失效缓存好点。正好有一次查询过来，可能缓存又加载了老数据了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617870060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325150,"ip_address":"","group_id":0},"score":365711,"extra":""},{"author":{"id":2103346,"avatar":"https://static001.geekbang.org/account/avatar/00/20/18/32/31fc3811.jpg","nickname":"哈哈","note":"","ucode":"36FA6523C6295C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1522800,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLdiaoSDXm3KibVMaYM2MiaAaleb3BW4Tgdw10qRtIhbOvMPib5Y0SJA3sBVOdYIjWq8bzf0hSA8XCf2w/132","nickname":"小熊","note":"","ucode":"D83E64BDD34F86","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379300,"discussion_content":"更新缓存要加锁，所以后面的请求不能再更新缓存了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623819896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365711,"ip_address":"","group_id":0},"score":379300,"extra":""}]},{"author":{"id":1100655,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/6f/c78ef1cf.jpg","nickname":"王二北","note":"","ucode":"D9090E28B3E1F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557635,"discussion_content":"哪个方案都会有问题，先写后删，如果删失败，就一直是旧数据，先删后写，如果删后未写入之前，有读的，也会读入旧数据，后续缓存也一直是旧数据。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647913737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3021180,"avatar":"","nickname":"Geek_78e94a","note":"","ucode":"6A66AD851614F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621187,"discussion_content":"使用双淘汰缓存机制，可以减少脏数据的概率。先淘汰缓存，然后写库，写库成功后再淘汰一次缓存。当然，小概率事件会导致第二次淘汰缓存失败的情况，但这种情况应该微乎其微了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686902866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1498274,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dc/a2/74119fb0.jpg","nickname":"马马","note":"","ucode":"4ED39D89D4031F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614682,"discussion_content":"常规方案：应该先更新数据库，再删除缓存，出现不一致的概率低。\n先删除缓存，再更新数据库，出现数据不一致的概率大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681868975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381060,"discussion_content":"我们以前是先增后删，反正也有问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624883611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2103346,"avatar":"https://static001.geekbang.org/account/avatar/00/20/18/32/31fc3811.jpg","nickname":"哈哈","note":"","ucode":"36FA6523C6295C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379301,"discussion_content":"先入库的话，失效缓存失败怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623819937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1498274,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dc/a2/74119fb0.jpg","nickname":"马马","note":"","ucode":"4ED39D89D4031F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2103346,"avatar":"https://static001.geekbang.org/account/avatar/00/20/18/32/31fc3811.jpg","nickname":"哈哈","note":"","ucode":"36FA6523C6295C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614688,"discussion_content":"重试（如mq）、通过过期时间失效、告警","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681869317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379301,"ip_address":"广东","group_id":0},"score":614688,"extra":""}]}]},{"had_liked":false,"id":11450,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1528158212,"is_pvip":false,"replies":[{"id":3706,"content":"确实没办法😃😃","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528189210,"ip_address":"","comment_id":11450,"utype":1}],"discussion_count":4,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"文中提到了缓存穿透存储数据不存在的情况，存储空对象，但是如果黑客恶意发起连续的攻击，而且key不相同，那么也会让缓存服务器的内存被迅速占满，这个方案感觉还是有些问题的","like_count":4,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418904,"discussion_content":"通常情况下，业务线程数量要远远大于后台更新线程数量。假设20台64核机器，每台机器256线程，业务线程就是5120个，后台缓存更新线程数量一般8~32就足够了。\n\n如果缓存设计是只能一个线程更新，那确实也只能用锁了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1528253137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299841,"user_name":"ZHANGPING","can_delete":false,"product_type":"c1","uid":1918112,"ip_address":"","ucode":"7108812981C996","user_header":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","comment_is_top":false,"comment_ctime":1624881577,"is_pvip":false,"replies":[{"id":108763,"content":"这个方案有以下几个落地的问题：\n1）要求每次写的时候都更新布隆过滤器，读的时候判断布隆过滤，对于缓存这种高性能计算场景，这个影响还是比较大的\n2）布隆过滤器也只能放在缓存中，不能放在各个应用程序内，布隆过滤器本身的读写需要做到高可用高性能，全局互斥\n3）布隆过滤器不能删除数据，缓存过期后布隆过滤器会失效\n\n所以布隆过滤器一般用在爬虫URL、事件数据（带时间戳，只增不删）这种场景","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1624930861,"ip_address":"","comment_id":299841,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"在网上看到过一个有意思的方案：把所有确定的Key都放在布隆过滤器，先判断Key是否存在，来避免缓存穿透。","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418847,"discussion_content":"确实没办法😃😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528189210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1137880,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5c/d8/dfe1d4dc.jpg","nickname":"学斌","note":"","ucode":"ED3432D8EDC327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374548,"discussion_content":"使用布隆过滤器（可证明不存在性，证明存在性则有一定误差）。具体还要看布隆过滤器用来存放不存在的key还是存在的key,另外为了保证误差尽量小，但是以不占用太多空间，可以以小时或者分钟数为key，达到布隆过滤器过期自动替换。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621241405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1248611,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0d/63/85f471e2.jpg","nickname":"柚子","note":"","ucode":"2F8CC2952E3122","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30755,"discussion_content":"所以只能设置过期时间短一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570857294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1360264,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c1/88/e68c58b7.jpg","nickname":"谁与话轻柔","note":"","ucode":"0C39AA91A7C9D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1248611,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0d/63/85f471e2.jpg","nickname":"柚子","note":"","ucode":"2F8CC2952E3122","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40095,"discussion_content":"可以控制请求频次，防止恶意攻击","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572078440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":30755,"ip_address":"","group_id":0},"score":40095,"extra":""}]}]},{"had_liked":false,"id":12199,"user_name":"北北也是程序员","can_delete":false,"product_type":"c1","uid":1139167,"ip_address":"","ucode":"94FD3F8E87D72D","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/df/11db20f2.jpg","comment_is_top":false,"comment_ctime":1528680276,"is_pvip":false,"replies":[{"id":4043,"content":"我们用过另外一种方式：将查询条件组合成字符串再计算md5，作为缓存的key，优点是简单灵活，缺点是浪费一部分缓存","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528762949,"ip_address":"","comment_id":12199,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"我来说说我做过的一个项目设计的缓存策略吧，因为需要实时查询所有open状态的基础订单列表信息，所以有个后台进程每分钟刷新一次缓存。但因为open态order太多，导致redis序列化与反序列化过程太久而连接中断，后来我采用的一个方案就是根据每次查询必选的组合查询条件分别分组然后以单个查询值作为key放到缓存中，这样既达到了按照查询条件过滤的情况，又缩减了每次存取数据的字节数。可能比较简单吧，感觉也没有什么特别的。哈哈😄","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522558,"discussion_content":"这个方案有以下几个落地的问题：\n1）要求每次写的时候都更新布隆过滤器，读的时候判断布隆过滤，对于缓存这种高性能计算场景，这个影响还是比较大的\n2）布隆过滤器也只能放在缓存中，不能放在各个应用程序内，布隆过滤器本身的读写需要做到高可用高性能，全局互斥\n3）布隆过滤器不能删除数据，缓存过期后布隆过滤器会失效\n\n所以布隆过滤器一般用在爬虫URL、事件数据（带时间戳，只增不删）这种场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624930861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11574,"user_name":"星火燎原","can_delete":false,"product_type":"c1","uid":1101373,"ip_address":"","ucode":"15AD8E3006E107","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/3d/385b8263.jpg","comment_is_top":false,"comment_ctime":1528210648,"is_pvip":false,"replies":[{"id":3744,"content":"那为何不直接设置为3秒超时？","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528252166,"ip_address":"","comment_id":11574,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"如果用redis做分布式锁 从业务上设置超时时间为1s 但是有一些逻辑单元确实需要执行比如3s才能释放掉锁。那么这种“正常的异常情况”应该怎么解决呢？","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418906,"discussion_content":"那为何不直接设置为3秒超时？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528252166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1137880,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5c/d8/dfe1d4dc.jpg","nickname":"学斌","note":"","ucode":"ED3432D8EDC327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374547,"discussion_content":"是可以考虑增加续期功能。不过续期次数要有限制。超过告警","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621241198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099125,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/75/128d8d69.jpg","nickname":"M","note":"","ucode":"4E8B462F248CB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4482,"discussion_content":"设置3秒还有可能5s才释放。除非这个设置的这个时间大于事务的超时时间，否则这个问题一致存在。再或者加锁的时候同时开一个守护进程，在过了超时时间的三分之二的时候，检测一下是否结束，如未结束，则延时。当然在setnx时候要给一个value标记锁的拥有者，比如threadid等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565455570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11488,"user_name":"啊哈","can_delete":false,"product_type":"c1","uid":1030776,"ip_address":"","ucode":"4E845FC7B66DB8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/78/3821b5b1.jpg","comment_is_top":false,"comment_ctime":1528162179,"is_pvip":false,"replies":[{"id":3689,"content":"缓存常见的列表操作，没法缓存所有的列表，因为搜索的条件太复杂了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186037,"ip_address":"","comment_id":11488,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"如果采用商品分页缓存，怎么实现更新呢，商品对实时性还是有要求的吧？比如更改价格，或者新上架的商品，怎么能比较实时的展现？还有商品页还是很复杂的，除了筛选还有很多的排序等等，这些场景怎么应用缓存吗？","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418906,"discussion_content":"那为何不直接设置为3秒超时？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528252166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1137880,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5c/d8/dfe1d4dc.jpg","nickname":"学斌","note":"","ucode":"ED3432D8EDC327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374547,"discussion_content":"是可以考虑增加续期功能。不过续期次数要有限制。超过告警","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621241198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099125,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/75/128d8d69.jpg","nickname":"M","note":"","ucode":"4E8B462F248CB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4482,"discussion_content":"设置3秒还有可能5s才释放。除非这个设置的这个时间大于事务的超时时间，否则这个问题一致存在。再或者加锁的时候同时开一个守护进程，在过了超时时间的三分之二的时候，检测一下是否结束，如未结束，则延时。当然在setnx时候要给一个value标记锁的拥有者，比如threadid等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565455570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11472,"user_name":"Snway","can_delete":false,"product_type":"c1","uid":1102888,"ip_address":"","ucode":"0AD31AECA8A8F7","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/28/3b6546e8.jpg","comment_is_top":false,"comment_ctime":1528160888,"is_pvip":false,"replies":[{"id":3695,"content":"重启缓存服务器😂","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186523,"ip_address":"","comment_id":11472,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"订单设置的缓存有效期是永久的，但再一次上线后，更新缓存的后台线程出问题，导致用户查看不了最新订单数据，引起大量客诉！","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418856,"discussion_content":"重启缓存服务器😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11443,"user_name":"姜泮昌","can_delete":false,"product_type":"c1","uid":1107213,"ip_address":"","ucode":"89B63270BAE099","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/0d/b4258141.jpg","comment_is_top":false,"comment_ctime":1528157212,"is_pvip":false,"replies":[{"id":3707,"content":"数据库压力大就可以考虑缓存了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528189297,"ip_address":"","comment_id":11443,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"目前我们还没用上缓存技术，所有请求都直接访问了数据库，导致数据库集群压力大，cpu、内存、IO常常过高，请问项目初用缓存，比如redis ，有什么指导原则或技巧吗？是缓存热点sql还是热点功能还是根据其他原则缓存呢？","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418856,"discussion_content":"重启缓存服务器😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11566,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1528204994,"is_pvip":false,"replies":[{"id":3750,"content":"一般不会出现这种情况，但缓存服务器宕机的场景和你说的类似，我们一般会要求线上进行模拟测试，假如一台缓存服务器宕机，系统是否能够顶住，如果顶不住，就要增加缓存服务器，或者优化某些key的设计","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528253272,"ip_address":"","comment_id":11566,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"关于缓存雪崩的定义，文中的例子是说单条缓存在生成的时间间隔内有大量相同请求查询存储系统，除此之外，记得还有一个更典型的场景，是大量缓存同时过期，导致大量不同请求去查询存储系统(数据库)。请点评。","like_count":5,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418903,"discussion_content":"一般不会出现这种情况，但缓存服务器宕机的场景和你说的类似，我们一般会要求线上进行模拟测试，假如一台缓存服务器宕机，系统是否能够顶住，如果顶不住，就要增加缓存服务器，或者优化某些key的设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528253272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57208,"user_name":"kissrain","can_delete":false,"product_type":"c1","uid":1120583,"ip_address":"","ucode":"2177C53E3B2DCC","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/47/b27f1314.jpg","comment_is_top":false,"comment_ctime":1546682736,"is_pvip":false,"replies":[{"id":20639,"content":"先失效缓存再写数据库吧，因为失效缓存失败的话，也就不会写入数据库了，写入数据库失败的话，缓存还会加载原来的值","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1546694177,"ip_address":"","comment_id":57208,"utype":1}],"discussion_count":11,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"请教一下华仔，像用户下单场景，是先写入数据库再失效缓存还是先失效缓存再写入数据库呢？","like_count":4,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435462,"discussion_content":"先失效缓存再写数据库吧，因为失效缓存失败的话，也就不会写入数据库了，写入数据库失败的话，缓存还会加载原来的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546694177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3236509,"avatar":"https://static001.geekbang.org/account/avatar/00/31/62/9d/82e73c79.jpg","nickname":"shawshank","note":"","ucode":"5E5AC72226D862","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":645147,"discussion_content":"这里是不是应该再补充一个写入数据库后再删除一次缓存，但是这里也可能删失败，是不是最好是订阅binlog再同步到缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715822792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":435462,"ip_address":"广东","group_id":0},"score":645147,"extra":""}]},{"author":{"id":2155138,"avatar":"","nickname":"Geek_279aff","note":"","ucode":"CF76C4EAB9A1A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325150,"discussion_content":"会不会入库再失效好点？先失效再入库，如果在两步中间有发生一次查询，这样缓存的还是旧数据，但是入库的却是新的数据，不一致了吧。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605246009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1522800,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLdiaoSDXm3KibVMaYM2MiaAaleb3BW4Tgdw10qRtIhbOvMPib5Y0SJA3sBVOdYIjWq8bzf0hSA8XCf2w/132","nickname":"小熊","note":"","ucode":"D83E64BDD34F86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2155138,"avatar":"","nickname":"Geek_279aff","note":"","ucode":"CF76C4EAB9A1A2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365711,"discussion_content":"对，感觉还是先入库后失效缓存好点。正好有一次查询过来，可能缓存又加载了老数据了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617870060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325150,"ip_address":"","group_id":0},"score":365711,"extra":""},{"author":{"id":2103346,"avatar":"https://static001.geekbang.org/account/avatar/00/20/18/32/31fc3811.jpg","nickname":"哈哈","note":"","ucode":"36FA6523C6295C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1522800,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLdiaoSDXm3KibVMaYM2MiaAaleb3BW4Tgdw10qRtIhbOvMPib5Y0SJA3sBVOdYIjWq8bzf0hSA8XCf2w/132","nickname":"小熊","note":"","ucode":"D83E64BDD34F86","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379300,"discussion_content":"更新缓存要加锁，所以后面的请求不能再更新缓存了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623819896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365711,"ip_address":"","group_id":0},"score":379300,"extra":""}]},{"author":{"id":1100655,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/6f/c78ef1cf.jpg","nickname":"王二北","note":"","ucode":"D9090E28B3E1F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557635,"discussion_content":"哪个方案都会有问题，先写后删，如果删失败，就一直是旧数据，先删后写，如果删后未写入之前，有读的，也会读入旧数据，后续缓存也一直是旧数据。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647913737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3021180,"avatar":"","nickname":"Geek_78e94a","note":"","ucode":"6A66AD851614F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621187,"discussion_content":"使用双淘汰缓存机制，可以减少脏数据的概率。先淘汰缓存，然后写库，写库成功后再淘汰一次缓存。当然，小概率事件会导致第二次淘汰缓存失败的情况，但这种情况应该微乎其微了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686902866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1498274,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dc/a2/74119fb0.jpg","nickname":"马马","note":"","ucode":"4ED39D89D4031F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614682,"discussion_content":"常规方案：应该先更新数据库，再删除缓存，出现不一致的概率低。\n先删除缓存，再更新数据库，出现数据不一致的概率大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681868975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381060,"discussion_content":"我们以前是先增后删，反正也有问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624883611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2103346,"avatar":"https://static001.geekbang.org/account/avatar/00/20/18/32/31fc3811.jpg","nickname":"哈哈","note":"","ucode":"36FA6523C6295C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379301,"discussion_content":"先入库的话，失效缓存失败怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623819937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1498274,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dc/a2/74119fb0.jpg","nickname":"马马","note":"","ucode":"4ED39D89D4031F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2103346,"avatar":"https://static001.geekbang.org/account/avatar/00/20/18/32/31fc3811.jpg","nickname":"哈哈","note":"","ucode":"36FA6523C6295C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614688,"discussion_content":"重试（如mq）、通过过期时间失效、告警","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681869317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379301,"ip_address":"广东","group_id":0},"score":614688,"extra":""}]}]},{"had_liked":false,"id":11569,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1528205591,"is_pvip":false,"replies":[{"id":3748,"content":"通常情况下，业务线程数量要远远大于后台更新线程数量。假设20台64核机器，每台机器256线程，业务线程就是5120个，后台缓存更新线程数量一般8~32就足够了。\n\n如果缓存设计是只能一个线程更新，那确实也只能用锁了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528253137,"ip_address":"","comment_id":11569,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"&#39;后台更新既适应单机多线程的场景，也适合分布式集群的场景，相比更新锁机制要简单一些.&#39; - 没觉得简单啊，因为如文中所说，后台更新也可能会出现多个业务线程都发送了缓存更新消息，这种情况我理解也需要有分布式锁来避免多个相同请求查询存储系统，否则在判断的时候，因为缓存在构建还没有准备好。","like_count":4,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418904,"discussion_content":"通常情况下，业务线程数量要远远大于后台更新线程数量。假设20台64核机器，每台机器256线程，业务线程就是5120个，后台缓存更新线程数量一般8~32就足够了。\n\n如果缓存设计是只能一个线程更新，那确实也只能用锁了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1528253137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11450,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1528158212,"is_pvip":false,"replies":[{"id":3706,"content":"确实没办法😃😃","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528189210,"ip_address":"","comment_id":11450,"utype":1}],"discussion_count":4,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"文中提到了缓存穿透存储数据不存在的情况，存储空对象，但是如果黑客恶意发起连续的攻击，而且key不相同，那么也会让缓存服务器的内存被迅速占满，这个方案感觉还是有些问题的","like_count":4,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418847,"discussion_content":"确实没办法😃😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528189210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1137880,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5c/d8/dfe1d4dc.jpg","nickname":"学斌","note":"","ucode":"ED3432D8EDC327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374548,"discussion_content":"使用布隆过滤器（可证明不存在性，证明存在性则有一定误差）。具体还要看布隆过滤器用来存放不存在的key还是存在的key,另外为了保证误差尽量小，但是以不占用太多空间，可以以小时或者分钟数为key，达到布隆过滤器过期自动替换。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621241405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1248611,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0d/63/85f471e2.jpg","nickname":"柚子","note":"","ucode":"2F8CC2952E3122","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30755,"discussion_content":"所以只能设置过期时间短一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570857294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1360264,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c1/88/e68c58b7.jpg","nickname":"谁与话轻柔","note":"","ucode":"0C39AA91A7C9D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1248611,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0d/63/85f471e2.jpg","nickname":"柚子","note":"","ucode":"2F8CC2952E3122","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40095,"discussion_content":"可以控制请求频次，防止恶意攻击","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572078440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":30755,"ip_address":"","group_id":0},"score":40095,"extra":""}]}]},{"had_liked":false,"id":299841,"user_name":"ZHANGPING","can_delete":false,"product_type":"c1","uid":1918112,"ip_address":"","ucode":"7108812981C996","user_header":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","comment_is_top":false,"comment_ctime":1624881577,"is_pvip":false,"replies":[{"id":108763,"content":"这个方案有以下几个落地的问题：\n1）要求每次写的时候都更新布隆过滤器，读的时候判断布隆过滤，对于缓存这种高性能计算场景，这个影响还是比较大的\n2）布隆过滤器也只能放在缓存中，不能放在各个应用程序内，布隆过滤器本身的读写需要做到高可用高性能，全局互斥\n3）布隆过滤器不能删除数据，缓存过期后布隆过滤器会失效\n\n所以布隆过滤器一般用在爬虫URL、事件数据（带时间戳，只增不删）这种场景","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1624930861,"ip_address":"","comment_id":299841,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"在网上看到过一个有意思的方案：把所有确定的Key都放在布隆过滤器，先判断Key是否存在，来避免缓存穿透。","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522558,"discussion_content":"这个方案有以下几个落地的问题：\n1）要求每次写的时候都更新布隆过滤器，读的时候判断布隆过滤，对于缓存这种高性能计算场景，这个影响还是比较大的\n2）布隆过滤器也只能放在缓存中，不能放在各个应用程序内，布隆过滤器本身的读写需要做到高可用高性能，全局互斥\n3）布隆过滤器不能删除数据，缓存过期后布隆过滤器会失效\n\n所以布隆过滤器一般用在爬虫URL、事件数据（带时间戳，只增不删）这种场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624930861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12199,"user_name":"北北也是程序员","can_delete":false,"product_type":"c1","uid":1139167,"ip_address":"","ucode":"94FD3F8E87D72D","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/df/11db20f2.jpg","comment_is_top":false,"comment_ctime":1528680276,"is_pvip":false,"replies":[{"id":4043,"content":"我们用过另外一种方式：将查询条件组合成字符串再计算md5，作为缓存的key，优点是简单灵活，缺点是浪费一部分缓存","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528762949,"ip_address":"","comment_id":12199,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"我来说说我做过的一个项目设计的缓存策略吧，因为需要实时查询所有open状态的基础订单列表信息，所以有个后台进程每分钟刷新一次缓存。但因为open态order太多，导致redis序列化与反序列化过程太久而连接中断，后来我采用的一个方案就是根据每次查询必选的组合查询条件分别分组然后以单个查询值作为key放到缓存中，这样既达到了按照查询条件过滤的情况，又缩减了每次存取数据的字节数。可能比较简单吧，感觉也没有什么特别的。哈哈😄","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419153,"discussion_content":"我们用过另外一种方式：将查询条件组合成字符串再计算md5，作为缓存的key，优点是简单灵活，缺点是浪费一部分缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528762949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2806057,"avatar":"","nickname":"95年的肉包子","note":"","ucode":"6E7C8B4FBF1100","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":533131,"discussion_content":"如果条件组合的结果集更新了，缓存中指定key失效之前，获取的结果集都不是最新的，是不是有问题，导致客户看不到自己最新的订单？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637801920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":419153,"ip_address":"","group_id":0},"score":533131,"extra":"{\"user_type\":1}"}]},{"author":{"id":1503260,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f0/1c/53f18c18.jpg","nickname":"古月三石","note":"","ucode":"D03D7484B0A3F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53116,"discussion_content":"华仔，为什么是md5还不是直接的字符串？难度只是为了节省空间？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574134454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11574,"user_name":"星火燎原","can_delete":false,"product_type":"c1","uid":1101373,"ip_address":"","ucode":"15AD8E3006E107","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/3d/385b8263.jpg","comment_is_top":false,"comment_ctime":1528210648,"is_pvip":false,"replies":[{"id":3744,"content":"那为何不直接设置为3秒超时？","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528252166,"ip_address":"","comment_id":11574,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"如果用redis做分布式锁 从业务上设置超时时间为1s 但是有一些逻辑单元确实需要执行比如3s才能释放掉锁。那么这种“正常的异常情况”应该怎么解决呢？","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419153,"discussion_content":"我们用过另外一种方式：将查询条件组合成字符串再计算md5，作为缓存的key，优点是简单灵活，缺点是浪费一部分缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528762949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2806057,"avatar":"","nickname":"95年的肉包子","note":"","ucode":"6E7C8B4FBF1100","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":533131,"discussion_content":"如果条件组合的结果集更新了，缓存中指定key失效之前，获取的结果集都不是最新的，是不是有问题，导致客户看不到自己最新的订单？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637801920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":419153,"ip_address":"","group_id":0},"score":533131,"extra":"{\"user_type\":1}"}]},{"author":{"id":1503260,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f0/1c/53f18c18.jpg","nickname":"古月三石","note":"","ucode":"D03D7484B0A3F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53116,"discussion_content":"华仔，为什么是md5还不是直接的字符串？难度只是为了节省空间？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574134454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11488,"user_name":"啊哈","can_delete":false,"product_type":"c1","uid":1030776,"ip_address":"","ucode":"4E845FC7B66DB8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/78/3821b5b1.jpg","comment_is_top":false,"comment_ctime":1528162179,"is_pvip":false,"replies":[{"id":3689,"content":"缓存常见的列表操作，没法缓存所有的列表，因为搜索的条件太复杂了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186037,"ip_address":"","comment_id":11488,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"如果采用商品分页缓存，怎么实现更新呢，商品对实时性还是有要求的吧？比如更改价格，或者新上架的商品，怎么能比较实时的展现？还有商品页还是很复杂的，除了筛选还有很多的排序等等，这些场景怎么应用缓存吗？","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418866,"discussion_content":"缓存常见的列表操作，没法缓存所有的列表，因为搜索的条件太复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11472,"user_name":"Snway","can_delete":false,"product_type":"c1","uid":1102888,"ip_address":"","ucode":"0AD31AECA8A8F7","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/28/3b6546e8.jpg","comment_is_top":false,"comment_ctime":1528160888,"is_pvip":false,"replies":[{"id":3695,"content":"重启缓存服务器😂","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186523,"ip_address":"","comment_id":11472,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"订单设置的缓存有效期是永久的，但再一次上线后，更新缓存的后台线程出问题，导致用户查看不了最新订单数据，引起大量客诉！","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418866,"discussion_content":"缓存常见的列表操作，没法缓存所有的列表，因为搜索的条件太复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11443,"user_name":"姜泮昌","can_delete":false,"product_type":"c1","uid":1107213,"ip_address":"","ucode":"89B63270BAE099","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/0d/b4258141.jpg","comment_is_top":false,"comment_ctime":1528157212,"is_pvip":false,"replies":[{"id":3707,"content":"数据库压力大就可以考虑缓存了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528189297,"ip_address":"","comment_id":11443,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100006601,"comment_content":"目前我们还没用上缓存技术，所有请求都直接访问了数据库，导致数据库集群压力大，cpu、内存、IO常常过高，请问项目初用缓存，比如redis ，有什么指导原则或技巧吗？是缓存热点sql还是热点功能还是根据其他原则缓存呢？","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418844,"discussion_content":"数据库压力大就可以考虑缓存了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528189297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36290,"user_name":"木头旮瘩","can_delete":false,"product_type":"c1","uid":1243119,"ip_address":"","ucode":"33FD0A8598B91E","user_header":"","comment_is_top":false,"comment_ctime":1541032397,"is_pvip":false,"replies":[{"id":12906,"content":"很多时候es出问题的时候你不一定知道，而是事后定位才发现根因是ES","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1541054587,"ip_address":"","comment_id":36290,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"二楼@loveluckystar童鞋说的问题，感觉问题并不是出在缓存机制上啊，有一台es出问题了，拖慢了整个系统，那把这台es拿掉呗，从其他es中查到数据后再更新缓存，缓存就可以继续命中了，等es问题修复后再重新加入集群。","like_count":2},{"had_liked":false,"id":32392,"user_name":"aaaaaaaaaaaas","can_delete":false,"product_type":"c1","uid":1230417,"ip_address":"","ucode":"44F3D4DB3F5678","user_header":"https://static001.geekbang.org/account/avatar/00/12/c6/51/30c17473.jpg","comment_is_top":false,"comment_ctime":1539564318,"is_pvip":false,"replies":[{"id":11838,"content":"就算是修改频率是一分钟，缓存在这一分钟也是有很大作用的，因为一分钟可能就是几千上万次读操作了，所以不要以为要一天都不修改的数据才能用缓存","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1539584392,"ip_address":"","comment_id":32392,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"缓存的用法还是不清楚，目前只是把基础数据放在redis中，但是基础数据并没有很大的性能问题，所以我感觉用处不大，而有性能问题查询列表因为有经常性的修改，所以没有存在redis。我现在的理解是讲读多修改少即时性要求不高的热点数据存储到redis，那对于上述查询列表怎么使用redis呢","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426754,"discussion_content":"就算是修改频率是一分钟，缓存在这一分钟也是有很大作用的，因为一分钟可能就是几千上万次读操作了，所以不要以为要一天都不修改的数据才能用缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539584392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31075,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1103163,"ip_address":"","ucode":"6E24DDD2981001","user_header":"","comment_is_top":false,"comment_ctime":1539082880,"is_pvip":false,"replies":[{"id":11217,"content":"所有缓存过期都要重新生成呀，如果正好读到一个过期的副本，可以继续用，缓存本来就不要求强一致性的","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1539132412,"ip_address":"","comment_id":31075,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"华仔，请教一下文中提到缓存热点问题，通过多副本方式解决，给每个副本的key设置一个编号，再随机读取，那么随机到的副本过期了要重新生成缓存吗？不生成怎么返回数据呢？","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426754,"discussion_content":"就算是修改频率是一分钟，缓存在这一分钟也是有很大作用的，因为一分钟可能就是几千上万次读操作了，所以不要以为要一天都不修改的数据才能用缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539584392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":27103,"user_name":"黄哲","can_delete":false,"product_type":"c1","uid":1100156,"ip_address":"","ucode":"F8D10FF2D17835","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/7c/b9cabf2f.jpg","comment_is_top":false,"comment_ctime":1537835120,"is_pvip":false,"replies":[{"id":10015,"content":"相当于双保险","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1537950913,"ip_address":"","comment_id":27103,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"有个榜单的计算过程比较复杂，大概要算3秒多，用户反馈榜单数据不对，由于对业务不熟悉，不知道计算过程这么复杂，就直接删了缓存，重新计算榜单，结果很悲剧，整个业务线挂了，一个典型的缓存雪崩案例。\n不过用了另一种解决的方式，将榜单计算的结果存在一张榜单表，缓存失效时直接读取这张榜单表，也算是一种思路吧。","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426217,"discussion_content":"所有缓存过期都要重新生成呀，如果正好读到一个过期的副本，可以继续用，缓存本来就不要求强一致性的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539132412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20077,"user_name":"秋天来了","can_delete":false,"product_type":"c1","uid":1205977,"ip_address":"","ucode":"98781C246B60A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/d9/8953d6c6.jpg","comment_is_top":false,"comment_ctime":1534252353,"is_pvip":false,"replies":[{"id":7023,"content":"这样做的性能代价有点大，每个key读取的时候都要进行这个解析，而缓存的访问量又很大","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1534299430,"ip_address":"","comment_id":20077,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"对于前面提到的双key机制，可以改成这样的，还是一个key，但是他的value附加一个有效时间，如果你读这个key中的数据，根据有效时间判断，他是已经失效了，这次，先把这个结果返回，然后通知去更新缓存，这样可以节省一个key1。","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424808,"discussion_content":"相当于双保险","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537950913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381063,"discussion_content":"不错的解决方案\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624884210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18545,"user_name":"yisshengyouni","can_delete":false,"product_type":"c1","uid":1020865,"ip_address":"","ucode":"8727DB47CD1CF2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/c1/32c33413.jpg","comment_is_top":false,"comment_ctime":1533440961,"is_pvip":false,"replies":[{"id":6514,"content":"没有太好的办法，一种是缓存服务器重启，一种是将key前缀配置在文件中，全部失效的时候换一下配置就可以","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1533532812,"ip_address":"","comment_id":18545,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"如果发现某个业务的缓存可能存在不一致问题，如何批量失效这些缓存呢，因为不能拿到所有的key。\n我们现在的做法是对每个业务加上一个前缀，如果不能确定哪些key出现不一致，就升级这个前缀，不知道还有没有好的方式？","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422097,"discussion_content":"这样做的性能代价有点大，每个key读取的时候都要进行这个解析，而缓存的访问量又很大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534299430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18166,"user_name":"走神儿","can_delete":false,"product_type":"c1","uid":1182797,"ip_address":"","ucode":"3C9B29B646FEC8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/4d/d185f942.jpg","comment_is_top":false,"comment_ctime":1533172926,"is_pvip":false,"replies":[{"id":6368,"content":"看起来性能高，实际上付出的复杂度代价更高，缓存管理会比较麻烦，一般不建议这么复杂的设计，很容易出各种数据不一致的问题","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1533202850,"ip_address":"","comment_id":18166,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"我们的缓存系统设计为三种，一种行级，就是数据库一条记录，表级，数据库表的查询结果，库级，连表查询结果，三种策略都是根据业务查询来缓存的。失效策略为更新A表，则A表的行级，表级，所有库级都失效；这样下来其实库级命中最低，但我们的代码规范是不到万不得已不能使用 join","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421417,"discussion_content":"看起来性能高，实际上付出的复杂度代价更高，缓存管理会比较麻烦，一般不建议这么复杂的设计，很容易出各种数据不一致的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533202850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13980,"user_name":"郭柱","can_delete":false,"product_type":"c1","uid":1142442,"ip_address":"","ucode":"27FBD00B472434","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/aa/839db666.jpg","comment_is_top":false,"comment_ctime":1530100400,"is_pvip":false,"replies":[{"id":4689,"content":"互联网用得更多啊，现在内存不值钱了，缓存大胆用😂","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1530178542,"ip_address":"","comment_id":13980,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"华哥，我现在来阿里云工作了，有机会希望能拜访华哥，和你分享一下之前我在上家公司做的一个系统。\n之前做过一个销售规则系统，这个系统服务于产品查询和销售。查询TPS峰值过万，查定比在100到200之间。规则系统的规则放到缓存中，同时支持规则实时发布到生产系统，性能测试指标是50ms就可以加载到生产系统。上线当晚，我就不停的在做规则修改，几分钟后查询系统变慢，开始大面积报警，当晚查询系统也在上线，后来过了一段时间发现是我们拖慢了整个业务链条，因为我们是新系统被迫下线改造，后来把缓存系统设计为AB缓存，每次加载新规则就加载到备用缓存中假设当前为B缓存，然后从日志中取1000生产查询请求，去查询最新更新的缓存，当100%成功后，将生产请求切换到B缓存，实际时间也就是秒级切换完成，这样保障了销售规则系统正常运转下去的，目前也还是这个架构。这种不考虑成本的方案是不是只有在国企才会用到？","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421417,"discussion_content":"看起来性能高，实际上付出的复杂度代价更高，缓存管理会比较麻烦，一般不建议这么复杂的设计，很容易出各种数据不一致的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533202850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11617,"user_name":"大光头","can_delete":false,"product_type":"c1","uid":1041792,"ip_address":"","ucode":"8EF797AFD1E27C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo3DrWeV7ZwRLXrRZg4V3ic1LQYdZ3u1oicDhqPic47vMguvf5QS69roTiaJrwDr5Re3Sy2UyHDWwmsTA/132","comment_is_top":false,"comment_ctime":1528249552,"is_pvip":false,"replies":[{"id":3737,"content":"做好监控就可以及时发现","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528251255,"ip_address":"","comment_id":11617,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"我们遇到的问题是代码bug导致缓存没有过期时间，缓存很快满了，缓存命中率降低，造成对业务很大的压力","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419832,"discussion_content":"互联网用得更多啊，现在内存不值钱了，缓存大胆用😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530178542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11561,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1528202295,"is_pvip":false,"replies":[{"id":3753,"content":"一般分页缓存，缓存id列表，不要缓存所有数据","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528253634,"ip_address":"","comment_id":11561,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"老师请教一下，比如数据库连表查询的分页结果，这样的数据怎么设计存入缓存了？  比如就用一个key，然后存储数据库查询结果的json吗？这个一直比较困惑。不知道key的设计怎么比较好。  感谢","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418900,"discussion_content":"一般分页缓存，缓存id列表，不要缓存所有数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528253634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36290,"user_name":"木头旮瘩","can_delete":false,"product_type":"c1","uid":1243119,"ip_address":"","ucode":"33FD0A8598B91E","user_header":"","comment_is_top":false,"comment_ctime":1541032397,"is_pvip":false,"replies":[{"id":12906,"content":"很多时候es出问题的时候你不一定知道，而是事后定位才发现根因是ES","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1541054587,"ip_address":"","comment_id":36290,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"二楼@loveluckystar童鞋说的问题，感觉问题并不是出在缓存机制上啊，有一台es出问题了，拖慢了整个系统，那把这台es拿掉呗，从其他es中查到数据后再更新缓存，缓存就可以继续命中了，等es问题修复后再重新加入集群。","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427818,"discussion_content":"很多时候es出问题的时候你不一定知道，而是事后定位才发现根因是ES","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541054587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32392,"user_name":"aaaaaaaaaaaas","can_delete":false,"product_type":"c1","uid":1230417,"ip_address":"","ucode":"44F3D4DB3F5678","user_header":"https://static001.geekbang.org/account/avatar/00/12/c6/51/30c17473.jpg","comment_is_top":false,"comment_ctime":1539564318,"is_pvip":false,"replies":[{"id":11838,"content":"就算是修改频率是一分钟，缓存在这一分钟也是有很大作用的，因为一分钟可能就是几千上万次读操作了，所以不要以为要一天都不修改的数据才能用缓存","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1539584392,"ip_address":"","comment_id":32392,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"缓存的用法还是不清楚，目前只是把基础数据放在redis中，但是基础数据并没有很大的性能问题，所以我感觉用处不大，而有性能问题查询列表因为有经常性的修改，所以没有存在redis。我现在的理解是讲读多修改少即时性要求不高的热点数据存储到redis，那对于上述查询列表怎么使用redis呢","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427818,"discussion_content":"很多时候es出问题的时候你不一定知道，而是事后定位才发现根因是ES","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541054587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31075,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1103163,"ip_address":"","ucode":"6E24DDD2981001","user_header":"","comment_is_top":false,"comment_ctime":1539082880,"is_pvip":false,"replies":[{"id":11217,"content":"所有缓存过期都要重新生成呀，如果正好读到一个过期的副本，可以继续用，缓存本来就不要求强一致性的","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1539132412,"ip_address":"","comment_id":31075,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"华仔，请教一下文中提到缓存热点问题，通过多副本方式解决，给每个副本的key设置一个编号，再随机读取，那么随机到的副本过期了要重新生成缓存吗？不生成怎么返回数据呢？","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426217,"discussion_content":"所有缓存过期都要重新生成呀，如果正好读到一个过期的副本，可以继续用，缓存本来就不要求强一致性的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539132412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":27103,"user_name":"黄哲","can_delete":false,"product_type":"c1","uid":1100156,"ip_address":"","ucode":"F8D10FF2D17835","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/7c/b9cabf2f.jpg","comment_is_top":false,"comment_ctime":1537835120,"is_pvip":false,"replies":[{"id":10015,"content":"相当于双保险","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1537950913,"ip_address":"","comment_id":27103,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"有个榜单的计算过程比较复杂，大概要算3秒多，用户反馈榜单数据不对，由于对业务不熟悉，不知道计算过程这么复杂，就直接删了缓存，重新计算榜单，结果很悲剧，整个业务线挂了，一个典型的缓存雪崩案例。\n不过用了另一种解决的方式，将榜单计算的结果存在一张榜单表，缓存失效时直接读取这张榜单表，也算是一种思路吧。","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424808,"discussion_content":"相当于双保险","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537950913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381063,"discussion_content":"不错的解决方案\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624884210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20077,"user_name":"秋天来了","can_delete":false,"product_type":"c1","uid":1205977,"ip_address":"","ucode":"98781C246B60A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/d9/8953d6c6.jpg","comment_is_top":false,"comment_ctime":1534252353,"is_pvip":false,"replies":[{"id":7023,"content":"这样做的性能代价有点大，每个key读取的时候都要进行这个解析，而缓存的访问量又很大","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1534299430,"ip_address":"","comment_id":20077,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"对于前面提到的双key机制，可以改成这样的，还是一个key，但是他的value附加一个有效时间，如果你读这个key中的数据，根据有效时间判断，他是已经失效了，这次，先把这个结果返回，然后通知去更新缓存，这样可以节省一个key1。","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422097,"discussion_content":"这样做的性能代价有点大，每个key读取的时候都要进行这个解析，而缓存的访问量又很大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534299430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18545,"user_name":"yisshengyouni","can_delete":false,"product_type":"c1","uid":1020865,"ip_address":"","ucode":"8727DB47CD1CF2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/c1/32c33413.jpg","comment_is_top":false,"comment_ctime":1533440961,"is_pvip":false,"replies":[{"id":6514,"content":"没有太好的办法，一种是缓存服务器重启，一种是将key前缀配置在文件中，全部失效的时候换一下配置就可以","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1533532812,"ip_address":"","comment_id":18545,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"如果发现某个业务的缓存可能存在不一致问题，如何批量失效这些缓存呢，因为不能拿到所有的key。\n我们现在的做法是对每个业务加上一个前缀，如果不能确定哪些key出现不一致，就升级这个前缀，不知道还有没有好的方式？","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421572,"discussion_content":"没有太好的办法，一种是缓存服务器重启，一种是将key前缀配置在文件中，全部失效的时候换一下配置就可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533532812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18166,"user_name":"走神儿","can_delete":false,"product_type":"c1","uid":1182797,"ip_address":"","ucode":"3C9B29B646FEC8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/4d/d185f942.jpg","comment_is_top":false,"comment_ctime":1533172926,"is_pvip":false,"replies":[{"id":6368,"content":"看起来性能高，实际上付出的复杂度代价更高，缓存管理会比较麻烦，一般不建议这么复杂的设计，很容易出各种数据不一致的问题","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1533202850,"ip_address":"","comment_id":18166,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"我们的缓存系统设计为三种，一种行级，就是数据库一条记录，表级，数据库表的查询结果，库级，连表查询结果，三种策略都是根据业务查询来缓存的。失效策略为更新A表，则A表的行级，表级，所有库级都失效；这样下来其实库级命中最低，但我们的代码规范是不到万不得已不能使用 join","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421572,"discussion_content":"没有太好的办法，一种是缓存服务器重启，一种是将key前缀配置在文件中，全部失效的时候换一下配置就可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533532812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13980,"user_name":"郭柱","can_delete":false,"product_type":"c1","uid":1142442,"ip_address":"","ucode":"27FBD00B472434","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/aa/839db666.jpg","comment_is_top":false,"comment_ctime":1530100400,"is_pvip":false,"replies":[{"id":4689,"content":"互联网用得更多啊，现在内存不值钱了，缓存大胆用😂","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1530178542,"ip_address":"","comment_id":13980,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"华哥，我现在来阿里云工作了，有机会希望能拜访华哥，和你分享一下之前我在上家公司做的一个系统。\n之前做过一个销售规则系统，这个系统服务于产品查询和销售。查询TPS峰值过万，查定比在100到200之间。规则系统的规则放到缓存中，同时支持规则实时发布到生产系统，性能测试指标是50ms就可以加载到生产系统。上线当晚，我就不停的在做规则修改，几分钟后查询系统变慢，开始大面积报警，当晚查询系统也在上线，后来过了一段时间发现是我们拖慢了整个业务链条，因为我们是新系统被迫下线改造，后来把缓存系统设计为AB缓存，每次加载新规则就加载到备用缓存中假设当前为B缓存，然后从日志中取1000生产查询请求，去查询最新更新的缓存，当100%成功后，将生产请求切换到B缓存，实际时间也就是秒级切换完成，这样保障了销售规则系统正常运转下去的，目前也还是这个架构。这种不考虑成本的方案是不是只有在国企才会用到？","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419832,"discussion_content":"互联网用得更多啊，现在内存不值钱了，缓存大胆用😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530178542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11617,"user_name":"大光头","can_delete":false,"product_type":"c1","uid":1041792,"ip_address":"","ucode":"8EF797AFD1E27C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo3DrWeV7ZwRLXrRZg4V3ic1LQYdZ3u1oicDhqPic47vMguvf5QS69roTiaJrwDr5Re3Sy2UyHDWwmsTA/132","comment_is_top":false,"comment_ctime":1528249552,"is_pvip":false,"replies":[{"id":3737,"content":"做好监控就可以及时发现","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528251255,"ip_address":"","comment_id":11617,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"我们遇到的问题是代码bug导致缓存没有过期时间，缓存很快满了，缓存命中率降低，造成对业务很大的压力","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418929,"discussion_content":"做好监控就可以及时发现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528251255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381062,"discussion_content":"上集群","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624883792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11561,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1528202295,"is_pvip":false,"replies":[{"id":3753,"content":"一般分页缓存，缓存id列表，不要缓存所有数据","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528253634,"ip_address":"","comment_id":11561,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100006601,"comment_content":"老师请教一下，比如数据库连表查询的分页结果，这样的数据怎么设计存入缓存了？  比如就用一个key，然后存储数据库查询结果的json吗？这个一直比较困惑。不知道key的设计怎么比较好。  感谢","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418929,"discussion_content":"做好监控就可以及时发现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528251255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1918112,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","nickname":"ZHANGPING","note":"","ucode":"7108812981C996","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381062,"discussion_content":"上集群","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624883792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11515,"user_name":"Regular","can_delete":false,"product_type":"c1","uid":1025998,"ip_address":"","ucode":"80B3EA083534CA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/ce/7ee0d672.jpg","comment_is_top":false,"comment_ctime":1528169240,"is_pvip":false,"replies":[{"id":3683,"content":"一定程度上缓解，不能完全解决","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185447,"ip_address":"","comment_id":11515,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"在 缓存雪崩的2.后台更新中“缓存系统内存不够时，会‘踢掉’一些缓存数据”，既然是内存不够那么总会有不在缓存里面的数据。后面的两种解决方式怎么能解决这个问题呢？","like_count":2},{"had_liked":false,"id":11486,"user_name":"byte","can_delete":false,"product_type":"c1","uid":1034849,"ip_address":"","ucode":"2E2F1426AF7583","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ca/61/b3f00e6f.jpg","comment_is_top":false,"comment_ctime":1528162123,"is_pvip":false,"replies":[{"id":3690,"content":"如果是媒体内容的缓存，那是CDN流式缓存的范畴，普通的后台缓存没什么特别的","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186114,"ip_address":"","comment_id":11486,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"想请教下对于流式音视频数据，类似优酷和爱奇艺这种网站后台的缓存系统如何设计比较合理？有没有推荐的方案或者书籍？谢谢！","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418875,"discussion_content":"一定程度上缓解，不能完全解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11463,"user_name":"钱浩亮","can_delete":false,"product_type":"c1","uid":1109248,"ip_address":"","ucode":"E0CF3D00159DB6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/00/d89a657c.jpg","comment_is_top":false,"comment_ctime":1528159586,"is_pvip":false,"replies":[{"id":3700,"content":"redis的SETNX可以当锁来用，至于高并发是否可用，要看你期望达到多高的并发了，毕竟这是跨网络的访问，而且是单机支持，具体性能你要实测","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528188867,"ip_address":"","comment_id":11463,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"老师我想问一下，redis有更新锁吗。再高并发的情况下，可以用吗","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418854,"discussion_content":"redis的SETNX可以当锁来用，至于高并发是否可用，要看你期望达到多高的并发了，毕竟这是跨网络的访问，而且是单机支持，具体性能你要实测","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528188867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368681,"user_name":"拿笔小星","can_delete":false,"product_type":"c1","uid":1193755,"ip_address":"上海","ucode":"D3D8F6A959710D","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","comment_is_top":false,"comment_ctime":1676560141,"is_pvip":false,"replies":[{"id":134287,"content":"先理解什么叫缓存雪崩，是缓存失效导致其它系统崩溃，缓存击穿和缓存穿透是一个意思","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1676621399,"ip_address":"广东","comment_id":368681,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"缓存雪崩的常见解决方法有两种：更新锁机制和后台更新机制。\n感觉这两个作为缓存击穿的解决方法更合适","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605233,"discussion_content":"先理解什么叫缓存雪崩，是缓存失效导致其它系统崩溃，缓存击穿和缓存穿透是一个意思","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1676621399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1193755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","nickname":"拿笔小星","note":"","ucode":"D3D8F6A959710D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":606075,"discussion_content":"老师，缓存击穿和缓存穿透不是一个意思吧。缓存击穿，是指单个热点key在缓存时效瞬间，大量请求打到db，造成数据库不可用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676903801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":605233,"ip_address":"上海","group_id":0},"score":606075,"extra":""}]}]},{"had_liked":false,"id":339696,"user_name":"小学生","can_delete":false,"product_type":"c1","uid":1311450,"ip_address":"","ucode":"6A030E4B90AF0C","user_header":"https://static001.geekbang.org/account/avatar/00/14/02/da/2265720f.jpg","comment_is_top":false,"comment_ctime":1648297629,"is_pvip":false,"replies":[{"id":124198,"content":"这个优化技巧不错，以时间换空间，时间上的损失对业务没有影响","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1648430484,"ip_address":"","comment_id":339696,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"这里之前做存储的时候遇到很多case，有存储空间设计不合理导致大量无效缓存，有热点的等等。一个印象比较生成的例子是，es query缓存，举个例子，a用户搜索“周杰伦歌曲”，会返回《东风破》《告白气球》等10首歌曲的各种详细信息，b用户搜索“jayzhou歌曲”，也会返回10首周杰伦的歌曲，甚至是和a用户完全一样的，那么问题来了，如果粗暴的以每个query为key、返回结果为value来缓存的话，每首歌曲的详细信息都缓存两遍，造成资源的极大浪费。如果将可以以id或者歌曲名为key，歌曲信息为value缓存在redis里，已query为key，歌曲id列表为value缓存的话，读取两遍redis就可以获取信息，虽然多了一次redis访问，但是资源空间上却是优化不少，记得差不多存储减少到之前的5%左右了。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605233,"discussion_content":"先理解什么叫缓存雪崩，是缓存失效导致其它系统崩溃，缓存击穿和缓存穿透是一个意思","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1676621399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1193755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","nickname":"拿笔小星","note":"","ucode":"D3D8F6A959710D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":606075,"discussion_content":"老师，缓存击穿和缓存穿透不是一个意思吧。缓存击穿，是指单个热点key在缓存时效瞬间，大量请求打到db，造成数据库不可用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676903801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":605233,"ip_address":"上海","group_id":0},"score":606075,"extra":""}]}]},{"had_liked":false,"id":314273,"user_name":"jian","can_delete":false,"product_type":"c1","uid":1185102,"ip_address":"","ucode":"21CDBBB8000F0C","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/4e/4636a81d.jpg","comment_is_top":false,"comment_ctime":1632927895,"is_pvip":false,"replies":[{"id":113851,"content":"用容器来建更多的缓存副本","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1632983202,"ip_address":"","comment_id":314273,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"请问华仔，热点数据存在相当的突发性，临时的扩容似乎也来不及，能否从缓存架构角度如何避免类似微博宕机的事件？\n\n作者回复: 1. 限流\n2. 容器化+动态化\n3. 业务降级，例如限制评论\n----------------------------------------------------------------------------------------------------\n请问老师， 容器化+动态化是如何解决热点数据？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558646,"discussion_content":"这个优化技巧不错，以时间换空间，时间上的损失对业务没有影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648430484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264979,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1606727260,"is_pvip":false,"replies":[{"id":96202,"content":"你说的缓存击穿就是文中的缓存穿透，穿透的意思就是缓存没起作用，也就是说缓存中没有对应的数据；大量key同时过期在实际情况中反而比较少见，因为不同的key生成时间、过期时间本来就是不同的，除非缓存不够被踢出，自然过期的场景下不会出现大量key同时过期，真正雪崩比较常见的是一两个热点key过期后引起系统性能急剧下降。","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1606736492,"ip_address":"","comment_id":264979,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"感觉缓存雪崩的那两条解决方案都是应对热点大key过期导致的缓存击穿的吧？？缓存雪崩是因为大量key同时过期引起的，只需要为不同的key设置不同的过期时间就好了。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510758,"discussion_content":"你说的缓存击穿就是文中的缓存穿透，穿透的意思就是缓存没起作用，也就是说缓存中没有对应的数据；大量key同时过期在实际情况中反而比较少见，因为不同的key生成时间、过期时间本来就是不同的，除非缓存不够被踢出，自然过期的场景下不会出现大量key同时过期，真正雪崩比较常见的是一两个热点key过期后引起系统性能急剧下降。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606736492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236893,"user_name":"govern","can_delete":false,"product_type":"c1","uid":1029416,"ip_address":"","ucode":"0C8802994C66AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/28/65f8ef3c.jpg","comment_is_top":false,"comment_ctime":1595579275,"is_pvip":false,"replies":[{"id":87778,"content":"后台更新线程来判断，可以生成一个空缓存来应对攻击","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1595898162,"ip_address":"","comment_id":236893,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"“业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存。” 这里怎么确定失效的数据是被“踢掉”的，还是被攻击的不存在数据，如果是后者，感觉又陷入了一个循环。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502243,"discussion_content":"后台更新线程来判断，可以生成一个空缓存来应对攻击","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595898162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225815,"user_name":"大MU","can_delete":false,"product_type":"c1","uid":1484686,"ip_address":"","ucode":"1071C1C4B91443","user_header":"https://static001.geekbang.org/account/avatar/00/16/a7/8e/588d737e.jpg","comment_is_top":false,"comment_ctime":1591866197,"is_pvip":false,"replies":[{"id":83686,"content":"确实可以这样做，但是一般会建议代码兼容，因为有时候找出所有需要预热的键并不那么简单","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1592303364,"ip_address":"","comment_id":225815,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"我觉得还有一点 就是缓存key的问题 比如 缓存的数据结构发生了变更，这时候需要将对应的缓存key进行升级 进行区分  上线时，将新的缓存key进行缓存预热  可以直接过渡到新的缓存，避免出现脏缓存的问题","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498001,"discussion_content":"确实可以这样做，但是一般会建议代码兼容，因为有时候找出所有需要预热的键并不那么简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592303364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205225,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1586573551,"is_pvip":false,"replies":[{"id":77051,"content":"加锁当然是最可靠的方式","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1586843250,"ip_address":"","comment_id":205225,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"缓存雪崩的后台更新方式，解决“踢掉”的第二种方式提到“存在就不执行更新操作”。\n那量大的时候，还是可能多个后台线程读取到更新消息，然后操作数据库吧？\n要不就是设计同一个缓存打到消息队列的同一个分区，然后只能被同一个后台线程读取？\n这里配合更新锁会好点么？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491427,"discussion_content":"加锁当然是最可靠的方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586843250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11515,"user_name":"Regular","can_delete":false,"product_type":"c1","uid":1025998,"ip_address":"","ucode":"80B3EA083534CA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/ce/7ee0d672.jpg","comment_is_top":false,"comment_ctime":1528169240,"is_pvip":false,"replies":[{"id":3683,"content":"一定程度上缓解，不能完全解决","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185447,"ip_address":"","comment_id":11515,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"在 缓存雪崩的2.后台更新中“缓存系统内存不够时，会‘踢掉’一些缓存数据”，既然是内存不够那么总会有不在缓存里面的数据。后面的两种解决方式怎么能解决这个问题呢？","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418875,"discussion_content":"一定程度上缓解，不能完全解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11486,"user_name":"byte","can_delete":false,"product_type":"c1","uid":1034849,"ip_address":"","ucode":"2E2F1426AF7583","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ca/61/b3f00e6f.jpg","comment_is_top":false,"comment_ctime":1528162123,"is_pvip":false,"replies":[{"id":3690,"content":"如果是媒体内容的缓存，那是CDN流式缓存的范畴，普通的后台缓存没什么特别的","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186114,"ip_address":"","comment_id":11486,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"想请教下对于流式音视频数据，类似优酷和爱奇艺这种网站后台的缓存系统如何设计比较合理？有没有推荐的方案或者书籍？谢谢！","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418864,"discussion_content":"如果是媒体内容的缓存，那是CDN流式缓存的范畴，普通的后台缓存没什么特别的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11463,"user_name":"钱浩亮","can_delete":false,"product_type":"c1","uid":1109248,"ip_address":"","ucode":"E0CF3D00159DB6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/00/d89a657c.jpg","comment_is_top":false,"comment_ctime":1528159586,"is_pvip":false,"replies":[{"id":3700,"content":"redis的SETNX可以当锁来用，至于高并发是否可用，要看你期望达到多高的并发了，毕竟这是跨网络的访问，而且是单机支持，具体性能你要实测","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528188867,"ip_address":"","comment_id":11463,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"老师我想问一下，redis有更新锁吗。再高并发的情况下，可以用吗","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418864,"discussion_content":"如果是媒体内容的缓存，那是CDN流式缓存的范畴，普通的后台缓存没什么特别的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368681,"user_name":"拿笔小星","can_delete":false,"product_type":"c1","uid":1193755,"ip_address":"上海","ucode":"D3D8F6A959710D","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","comment_is_top":false,"comment_ctime":1676560141,"is_pvip":false,"replies":[{"id":134287,"content":"先理解什么叫缓存雪崩，是缓存失效导致其它系统崩溃，缓存击穿和缓存穿透是一个意思","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1676621399,"ip_address":"广东","comment_id":368681,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"缓存雪崩的常见解决方法有两种：更新锁机制和后台更新机制。\n感觉这两个作为缓存击穿的解决方法更合适","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418854,"discussion_content":"redis的SETNX可以当锁来用，至于高并发是否可用，要看你期望达到多高的并发了，毕竟这是跨网络的访问，而且是单机支持，具体性能你要实测","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528188867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339696,"user_name":"小学生","can_delete":false,"product_type":"c1","uid":1311450,"ip_address":"","ucode":"6A030E4B90AF0C","user_header":"https://static001.geekbang.org/account/avatar/00/14/02/da/2265720f.jpg","comment_is_top":false,"comment_ctime":1648297629,"is_pvip":false,"replies":[{"id":124198,"content":"这个优化技巧不错，以时间换空间，时间上的损失对业务没有影响","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1648430484,"ip_address":"","comment_id":339696,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"这里之前做存储的时候遇到很多case，有存储空间设计不合理导致大量无效缓存，有热点的等等。一个印象比较生成的例子是，es query缓存，举个例子，a用户搜索“周杰伦歌曲”，会返回《东风破》《告白气球》等10首歌曲的各种详细信息，b用户搜索“jayzhou歌曲”，也会返回10首周杰伦的歌曲，甚至是和a用户完全一样的，那么问题来了，如果粗暴的以每个query为key、返回结果为value来缓存的话，每首歌曲的详细信息都缓存两遍，造成资源的极大浪费。如果将可以以id或者歌曲名为key，歌曲信息为value缓存在redis里，已query为key，歌曲id列表为value缓存的话，读取两遍redis就可以获取信息，虽然多了一次redis访问，但是资源空间上却是优化不少，记得差不多存储减少到之前的5%左右了。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558646,"discussion_content":"这个优化技巧不错，以时间换空间，时间上的损失对业务没有影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648430484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314273,"user_name":"jian","can_delete":false,"product_type":"c1","uid":1185102,"ip_address":"","ucode":"21CDBBB8000F0C","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/4e/4636a81d.jpg","comment_is_top":false,"comment_ctime":1632927895,"is_pvip":false,"replies":[{"id":113851,"content":"用容器来建更多的缓存副本","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1632983202,"ip_address":"","comment_id":314273,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"请问华仔，热点数据存在相当的突发性，临时的扩容似乎也来不及，能否从缓存架构角度如何避免类似微博宕机的事件？\n\n作者回复: 1. 限流\n2. 容器化+动态化\n3. 业务降级，例如限制评论\n----------------------------------------------------------------------------------------------------\n请问老师， 容器化+动态化是如何解决热点数据？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527625,"discussion_content":"用容器来建更多的缓存副本","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632983202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264979,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1606727260,"is_pvip":false,"replies":[{"id":96202,"content":"你说的缓存击穿就是文中的缓存穿透，穿透的意思就是缓存没起作用，也就是说缓存中没有对应的数据；大量key同时过期在实际情况中反而比较少见，因为不同的key生成时间、过期时间本来就是不同的，除非缓存不够被踢出，自然过期的场景下不会出现大量key同时过期，真正雪崩比较常见的是一两个热点key过期后引起系统性能急剧下降。","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1606736492,"ip_address":"","comment_id":264979,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"感觉缓存雪崩的那两条解决方案都是应对热点大key过期导致的缓存击穿的吧？？缓存雪崩是因为大量key同时过期引起的，只需要为不同的key设置不同的过期时间就好了。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527625,"discussion_content":"用容器来建更多的缓存副本","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632983202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236893,"user_name":"govern","can_delete":false,"product_type":"c1","uid":1029416,"ip_address":"","ucode":"0C8802994C66AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/28/65f8ef3c.jpg","comment_is_top":false,"comment_ctime":1595579275,"is_pvip":false,"replies":[{"id":87778,"content":"后台更新线程来判断，可以生成一个空缓存来应对攻击","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1595898162,"ip_address":"","comment_id":236893,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"“业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存。” 这里怎么确定失效的数据是被“踢掉”的，还是被攻击的不存在数据，如果是后者，感觉又陷入了一个循环。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510758,"discussion_content":"你说的缓存击穿就是文中的缓存穿透，穿透的意思就是缓存没起作用，也就是说缓存中没有对应的数据；大量key同时过期在实际情况中反而比较少见，因为不同的key生成时间、过期时间本来就是不同的，除非缓存不够被踢出，自然过期的场景下不会出现大量key同时过期，真正雪崩比较常见的是一两个热点key过期后引起系统性能急剧下降。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606736492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225815,"user_name":"大MU","can_delete":false,"product_type":"c1","uid":1484686,"ip_address":"","ucode":"1071C1C4B91443","user_header":"https://static001.geekbang.org/account/avatar/00/16/a7/8e/588d737e.jpg","comment_is_top":false,"comment_ctime":1591866197,"is_pvip":false,"replies":[{"id":83686,"content":"确实可以这样做，但是一般会建议代码兼容，因为有时候找出所有需要预热的键并不那么简单","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1592303364,"ip_address":"","comment_id":225815,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"我觉得还有一点 就是缓存key的问题 比如 缓存的数据结构发生了变更，这时候需要将对应的缓存key进行升级 进行区分  上线时，将新的缓存key进行缓存预热  可以直接过渡到新的缓存，避免出现脏缓存的问题","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502243,"discussion_content":"后台更新线程来判断，可以生成一个空缓存来应对攻击","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595898162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205225,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1586573551,"is_pvip":false,"replies":[{"id":77051,"content":"加锁当然是最可靠的方式","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1586843250,"ip_address":"","comment_id":205225,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100006601,"comment_content":"缓存雪崩的后台更新方式，解决“踢掉”的第二种方式提到“存在就不执行更新操作”。\n那量大的时候，还是可能多个后台线程读取到更新消息，然后操作数据库吧？\n要不就是设计同一个缓存打到消息队列的同一个分区，然后只能被同一个后台线程读取？\n这里配合更新锁会好点么？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498001,"discussion_content":"确实可以这样做，但是一般会建议代码兼容，因为有时候找出所有需要预热的键并不那么简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592303364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198765,"user_name":"benamazing","can_delete":false,"product_type":"c1","uid":1549752,"ip_address":"","ucode":"D8BE0A2D29DAB4","user_header":"https://static001.geekbang.org/account/avatar/00/17/a5/b8/17129075.jpg","comment_is_top":false,"comment_ctime":1585467142,"is_pvip":false,"replies":[{"id":74867,"content":"你这个随机范围有点大啊😂","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1585539368,"ip_address":"","comment_id":198765,"utype":1}],"discussion_count":2,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"为了避免大量缓存在同时间雪崩，我们的做法是，每个key设的缓存过期时间是在一个时间范围内的随机数。比如说随机缓存1-7天","like_count":1},{"had_liked":false,"id":173003,"user_name":"胖胖的程序猿","can_delete":false,"product_type":"c1","uid":1110423,"ip_address":"","ucode":"2C0B0F3A83F5D6","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/97/e3bbbb14.jpg","comment_is_top":false,"comment_ctime":1579405143,"is_pvip":false,"replies":[{"id":69957,"content":"是的，redis可以的","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1582193854,"ip_address":"","comment_id":173003,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"《缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力》\n\n如果只是单纯解决缓存服务器压力，那么只有一个副本，也可以用redis集群可以解决吧。\n多个副本不同失效时间，解决的是保证缓存一直都有效","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481926,"discussion_content":"是的，redis可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582193854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85347,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1555041200,"is_pvip":false,"replies":[{"id":31430,"content":"后一种情况","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1555598428,"ip_address":"","comment_id":85347,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"“分页缓存的有效期设置为1天”\n请问大神，这个1天时间指的是这个缓存在1天时间内一次访问都没有就过期吧，还是不管有没有访问，到了1天时间，就过期？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446639,"discussion_content":"后一种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555598428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80658,"user_name":"xiao皮孩。。","can_delete":false,"product_type":"c1","uid":1367499,"ip_address":"","ucode":"27AE899819D10F","user_header":"https://static001.geekbang.org/account/avatar/00/14/dd/cb/23b114a7.jpg","comment_is_top":false,"comment_ctime":1553695186,"is_pvip":false,"replies":[{"id":29348,"content":"布隆过滤器怎么做分布式呢？好像也挺麻烦的呀","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1553699249,"ip_address":"","comment_id":80658,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"这种情况的解决办法比较简单，如果查询存储系统的数据没有找到，则直接设置一个默认值（可以是空值，也可以是具体的值）存到缓存中，这样第二次读取缓存时就会获取到默认值，而不会继续访问存储系统。\n\n用布隆过滤器解决这个合适，不存在是一定不存在的。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444934,"discussion_content":"布隆过滤器怎么做分布式呢？好像也挺麻烦的呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553699249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78820,"user_name":"挨踢民工","can_delete":false,"product_type":"c1","uid":1185664,"ip_address":"","ucode":"13225918D22DDD","user_header":"https://static001.geekbang.org/account/avatar/00/12/17/80/7175176f.jpg","comment_is_top":false,"comment_ctime":1553248208,"is_pvip":false,"replies":[{"id":28699,"content":"想省钱，拿MySQL做OLAP呀，你们现在这样太复杂了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1553298398,"ip_address":"","comment_id":78820,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"我所遇到的业务场景是这样，在现有的资源情况下，我司只有一台oracle服务器，一方面做OLTP业务，又做OLAP业务，订单表接近900w。基于订单数据开发boss系统，以日单位。复杂sql查询通过后台java应用写入到缓存中，前端用PHP调用缓存。后来发现这条路有问题，针对此项目大部分SQL命中率低，所以改变策略，在PHP前端项目中分出了一道缓存层，用完整的sql语句hash后做为key，数据作为内容。由于boss系统单一个页面都会调用20个左右的sql语句。问题又出现了，用户首次访问效率极低（由于SQL复杂，最快的SQL响应都要1s，最慢4s）。前端所有请求改为webstocket方式进行通信，PHP项目层改为协程并发访问缓存层。项目越来越复杂","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444242,"discussion_content":"想省钱，拿MySQL做OLAP呀，你们现在这样太复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553298398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57510,"user_name":"kissrain","can_delete":false,"product_type":"c1","uid":1120583,"ip_address":"","ucode":"2177C53E3B2DCC","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/47/b27f1314.jpg","comment_is_top":false,"comment_ctime":1546825164,"is_pvip":false,"replies":[{"id":20791,"content":"1. 缓存策略要根据业务需求来看，不是固定的，请参考架构设计原则的合适原则\n2. 强缓存一致性需要用锁保证","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1546902743,"ip_address":"","comment_id":57510,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"华仔，请教以下几个关于缓存引起的问题\n1. 缓存是不淘汰还是淘汰还是更新缓存？\r\n2. 如果是不淘汰缓存那么如何解决数据的一致性问题？\r\n3. 定时缓存过期后，缓存生成时间比较久(如需要2s生成)，这种是否可以用双缓存key的形式（两个相同key，一个过期一个不过期）？\r\n   是否还有更好的办法解决呢？\r\n4. 使用缓存淘汰方式，缓存和数据库的一致性问题根本原因是非原子操作，如果A删除了缓存后B去读，发现没有缓存，\r\n   然后B再去读数据库的旧数据，这时候A才去更新数据，如何避免一致性问题？关键:B比A先访问数据库。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435616,"discussion_content":"1. 缓存策略要根据业务需求来看，不是固定的，请参考架构设计原则的合适原则\n2. 强缓存一致性需要用锁保证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546902743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54408,"user_name":"Geek_58ezrw","can_delete":false,"product_type":"c1","uid":1119789,"ip_address":"","ucode":"3D1F0996CE65C8","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/2d/2753369a.jpg","comment_is_top":false,"comment_ctime":1545846385,"is_pvip":false,"replies":[{"id":20001,"content":"这样处理耗时有点长吧，不过也没办法了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1546059217,"ip_address":"","comment_id":54408,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"我遇到过缓存穿透的问题，当时整个系统都进不去～_～！当时的设计也是通过先读缓存，如果没有在从数据库中读取。\n结果刚好外访问的时候，redis缓存失效，大量请求数据库，导致数据库崩掉。\n解决，先把系统关闭，服务器重启，再对缓存进行预热，最后启动系统","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435616,"discussion_content":"1. 缓存策略要根据业务需求来看，不是固定的，请参考架构设计原则的合适原则\n2. 强缓存一致性需要用锁保证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546902743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49564,"user_name":"咩咩咩","can_delete":false,"product_type":"c1","uid":1237849,"ip_address":"","ucode":"9DEC7D5D52D972","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6a8fRQFxX5VXOpRKyYibsemKwDMexMxkzZOBquPo6T4HOcYicBiaTcqibDoTIhZSjVjF3nKXTEGDYOGPt2xqqwiawjg/132","comment_is_top":false,"comment_ctime":1544716178,"is_pvip":false,"replies":[{"id":17857,"content":"这样浪费CPU运算能力呀😀","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1544747251,"ip_address":"","comment_id":49564,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"小白不是很理解热评第一的双key策略。双key浪费了一半的储存空间，不如给key的值添加一个时间戳，然后读取数据的时候判断值的时间戳和当前时间戳大小看是否需要异步更新数据，这样是不是更好？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432660,"discussion_content":"这样浪费CPU运算能力呀😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544747251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47059,"user_name":"Geek_fb3db2","can_delete":false,"product_type":"c1","uid":1218254,"ip_address":"","ucode":"8089B8311B6C80","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/ce/8c3bdbe5.jpg","comment_is_top":false,"comment_ctime":1544027214,"is_pvip":false,"replies":[{"id":16903,"content":"缓存有过期时间，缓存系统也有LRU之类的淘汰策略，不会导致缓存系统挂掉。\n","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1544133216,"ip_address":"","comment_id":47059,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"我们缓存采用文中说的代码实现方式，在系统启动把所有需要缓存数据加载到内存，其实是使用AOP方式缓存对应的方法，指定缓存何时重加载等操作，然后集群之间通过中间件通知其他机器更新缓存，有一次由于其他机器未收到缓存更新通知，导致该机器缓存是旧的，最终导致系统切日不对。\n另外问下：文中提到的缓存穿透解决方案为 对未命中缓存的key设置一个默认值，那如果源源不断发送未命中缓存的请求，那么缓存里面不就存了很多数据吗，会把系统搞挂掉，我们策略是未命中是否需要从数据库获取，感觉也不太好。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431649,"discussion_content":"缓存有过期时间，缓存系统也有LRU之类的淘汰策略，不会导致缓存系统挂掉。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544133216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37526,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/9337ca8e.jpg","comment_is_top":false,"comment_ctime":1541636887,"is_pvip":false,"replies":[{"id":13616,"content":"你一定踩过坑😂","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1541752142,"ip_address":"","comment_id":37526,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"因为缓存的不及时更新导致得到的数据不是最新的，最后直接不使用缓存。事实告诉我，系统不是达到一定的系统查询性能瓶颈，别一开始就用缓存。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428383,"discussion_content":"你一定踩过坑😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541752142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198765,"user_name":"benamazing","can_delete":false,"product_type":"c1","uid":1549752,"ip_address":"","ucode":"D8BE0A2D29DAB4","user_header":"https://static001.geekbang.org/account/avatar/00/17/a5/b8/17129075.jpg","comment_is_top":false,"comment_ctime":1585467142,"is_pvip":false,"replies":[{"id":74867,"content":"你这个随机范围有点大啊😂","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1585539368,"ip_address":"","comment_id":198765,"utype":1}],"discussion_count":2,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"为了避免大量缓存在同时间雪崩，我们的做法是，每个key设的缓存过期时间是在一个时间范围内的随机数。比如说随机缓存1-7天","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489748,"discussion_content":"你这个随机范围有点大啊😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585539368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549752,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a5/b8/17129075.jpg","nickname":"benamazing","note":"","ucode":"D8BE0A2D29DAB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217296,"discussion_content":"这个是举例哈哈，实际没那么夸张","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585539685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173003,"user_name":"胖胖的程序猿","can_delete":false,"product_type":"c1","uid":1110423,"ip_address":"","ucode":"2C0B0F3A83F5D6","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/97/e3bbbb14.jpg","comment_is_top":false,"comment_ctime":1579405143,"is_pvip":false,"replies":[{"id":69957,"content":"是的，redis可以的","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1582193854,"ip_address":"","comment_id":173003,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"《缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力》\n\n如果只是单纯解决缓存服务器压力，那么只有一个副本，也可以用redis集群可以解决吧。\n多个副本不同失效时间，解决的是保证缓存一直都有效","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489748,"discussion_content":"你这个随机范围有点大啊😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585539368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549752,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a5/b8/17129075.jpg","nickname":"benamazing","note":"","ucode":"D8BE0A2D29DAB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217296,"discussion_content":"这个是举例哈哈，实际没那么夸张","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585539685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85347,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1555041200,"is_pvip":false,"replies":[{"id":31430,"content":"后一种情况","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1555598428,"ip_address":"","comment_id":85347,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"“分页缓存的有效期设置为1天”\n请问大神，这个1天时间指的是这个缓存在1天时间内一次访问都没有就过期吧，还是不管有没有访问，到了1天时间，就过期？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481926,"discussion_content":"是的，redis可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582193854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80658,"user_name":"xiao皮孩。。","can_delete":false,"product_type":"c1","uid":1367499,"ip_address":"","ucode":"27AE899819D10F","user_header":"https://static001.geekbang.org/account/avatar/00/14/dd/cb/23b114a7.jpg","comment_is_top":false,"comment_ctime":1553695186,"is_pvip":false,"replies":[{"id":29348,"content":"布隆过滤器怎么做分布式呢？好像也挺麻烦的呀","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1553699249,"ip_address":"","comment_id":80658,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"这种情况的解决办法比较简单，如果查询存储系统的数据没有找到，则直接设置一个默认值（可以是空值，也可以是具体的值）存到缓存中，这样第二次读取缓存时就会获取到默认值，而不会继续访问存储系统。\n\n用布隆过滤器解决这个合适，不存在是一定不存在的。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446639,"discussion_content":"后一种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555598428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78820,"user_name":"挨踢民工","can_delete":false,"product_type":"c1","uid":1185664,"ip_address":"","ucode":"13225918D22DDD","user_header":"https://static001.geekbang.org/account/avatar/00/12/17/80/7175176f.jpg","comment_is_top":false,"comment_ctime":1553248208,"is_pvip":false,"replies":[{"id":28699,"content":"想省钱，拿MySQL做OLAP呀，你们现在这样太复杂了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1553298398,"ip_address":"","comment_id":78820,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"我所遇到的业务场景是这样，在现有的资源情况下，我司只有一台oracle服务器，一方面做OLTP业务，又做OLAP业务，订单表接近900w。基于订单数据开发boss系统，以日单位。复杂sql查询通过后台java应用写入到缓存中，前端用PHP调用缓存。后来发现这条路有问题，针对此项目大部分SQL命中率低，所以改变策略，在PHP前端项目中分出了一道缓存层，用完整的sql语句hash后做为key，数据作为内容。由于boss系统单一个页面都会调用20个左右的sql语句。问题又出现了，用户首次访问效率极低（由于SQL复杂，最快的SQL响应都要1s，最慢4s）。前端所有请求改为webstocket方式进行通信，PHP项目层改为协程并发访问缓存层。项目越来越复杂","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444934,"discussion_content":"布隆过滤器怎么做分布式呢？好像也挺麻烦的呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553699249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57510,"user_name":"kissrain","can_delete":false,"product_type":"c1","uid":1120583,"ip_address":"","ucode":"2177C53E3B2DCC","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/47/b27f1314.jpg","comment_is_top":false,"comment_ctime":1546825164,"is_pvip":false,"replies":[{"id":20791,"content":"1. 缓存策略要根据业务需求来看，不是固定的，请参考架构设计原则的合适原则\n2. 强缓存一致性需要用锁保证","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1546902743,"ip_address":"","comment_id":57510,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"华仔，请教以下几个关于缓存引起的问题\n1. 缓存是不淘汰还是淘汰还是更新缓存？\r\n2. 如果是不淘汰缓存那么如何解决数据的一致性问题？\r\n3. 定时缓存过期后，缓存生成时间比较久(如需要2s生成)，这种是否可以用双缓存key的形式（两个相同key，一个过期一个不过期）？\r\n   是否还有更好的办法解决呢？\r\n4. 使用缓存淘汰方式，缓存和数据库的一致性问题根本原因是非原子操作，如果A删除了缓存后B去读，发现没有缓存，\r\n   然后B再去读数据库的旧数据，这时候A才去更新数据，如何避免一致性问题？关键:B比A先访问数据库。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444242,"discussion_content":"想省钱，拿MySQL做OLAP呀，你们现在这样太复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553298398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54408,"user_name":"Geek_58ezrw","can_delete":false,"product_type":"c1","uid":1119789,"ip_address":"","ucode":"3D1F0996CE65C8","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/2d/2753369a.jpg","comment_is_top":false,"comment_ctime":1545846385,"is_pvip":false,"replies":[{"id":20001,"content":"这样处理耗时有点长吧，不过也没办法了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1546059217,"ip_address":"","comment_id":54408,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"我遇到过缓存穿透的问题，当时整个系统都进不去～_～！当时的设计也是通过先读缓存，如果没有在从数据库中读取。\n结果刚好外访问的时候，redis缓存失效，大量请求数据库，导致数据库崩掉。\n解决，先把系统关闭，服务器重启，再对缓存进行预热，最后启动系统","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434446,"discussion_content":"这样处理耗时有点长吧，不过也没办法了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546059217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49564,"user_name":"咩咩咩","can_delete":false,"product_type":"c1","uid":1237849,"ip_address":"","ucode":"9DEC7D5D52D972","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6a8fRQFxX5VXOpRKyYibsemKwDMexMxkzZOBquPo6T4HOcYicBiaTcqibDoTIhZSjVjF3nKXTEGDYOGPt2xqqwiawjg/132","comment_is_top":false,"comment_ctime":1544716178,"is_pvip":false,"replies":[{"id":17857,"content":"这样浪费CPU运算能力呀😀","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1544747251,"ip_address":"","comment_id":49564,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"小白不是很理解热评第一的双key策略。双key浪费了一半的储存空间，不如给key的值添加一个时间戳，然后读取数据的时候判断值的时间戳和当前时间戳大小看是否需要异步更新数据，这样是不是更好？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434446,"discussion_content":"这样处理耗时有点长吧，不过也没办法了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546059217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47059,"user_name":"Geek_fb3db2","can_delete":false,"product_type":"c1","uid":1218254,"ip_address":"","ucode":"8089B8311B6C80","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/ce/8c3bdbe5.jpg","comment_is_top":false,"comment_ctime":1544027214,"is_pvip":false,"replies":[{"id":16903,"content":"缓存有过期时间，缓存系统也有LRU之类的淘汰策略，不会导致缓存系统挂掉。\n","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1544133216,"ip_address":"","comment_id":47059,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"我们缓存采用文中说的代码实现方式，在系统启动把所有需要缓存数据加载到内存，其实是使用AOP方式缓存对应的方法，指定缓存何时重加载等操作，然后集群之间通过中间件通知其他机器更新缓存，有一次由于其他机器未收到缓存更新通知，导致该机器缓存是旧的，最终导致系统切日不对。\n另外问下：文中提到的缓存穿透解决方案为 对未命中缓存的key设置一个默认值，那如果源源不断发送未命中缓存的请求，那么缓存里面不就存了很多数据吗，会把系统搞挂掉，我们策略是未命中是否需要从数据库获取，感觉也不太好。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432660,"discussion_content":"这样浪费CPU运算能力呀😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544747251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37526,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/9337ca8e.jpg","comment_is_top":false,"comment_ctime":1541636887,"is_pvip":false,"replies":[{"id":13616,"content":"你一定踩过坑😂","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1541752142,"ip_address":"","comment_id":37526,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100006601,"comment_content":"因为缓存的不及时更新导致得到的数据不是最新的，最后直接不使用缓存。事实告诉我，系统不是达到一定的系统查询性能瓶颈，别一开始就用缓存。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431649,"discussion_content":"缓存有过期时间，缓存系统也有LRU之类的淘汰策略，不会导致缓存系统挂掉。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544133216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28910,"user_name":"greatcl","can_delete":false,"product_type":"c1","uid":1009449,"ip_address":"","ucode":"44D3C55394EC08","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/29/b0ec5430.jpg","comment_is_top":false,"comment_ctime":1538192511,"is_pvip":false,"replies":[{"id":10423,"content":"1. 缓存被踢是正常的\n2. 不是每个缓存被踢都会引起问题，缓存有算法的，例如LRU\n","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1538214061,"ip_address":"","comment_id":28910,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"对于文中后台更新的例子有个疑问，如果当缓存系统内存不够时，一部分缓存被踢掉，后台去频繁读取缓存，发现被踢掉之后就立刻更新缓存。那这个时候因为内存不够，不是会有其它缓存被踢掉然后产生问题吗？","like_count":1},{"had_liked":false,"id":21954,"user_name":"laurencezl","can_delete":false,"product_type":"c1","uid":1049020,"ip_address":"","ucode":"F531F68705B94D","user_header":"","comment_is_top":false,"comment_ctime":1535419219,"is_pvip":false,"replies":[{"id":7856,"content":"是你选择的，程序员设计的时候需要确定哪类缓存要后台更新","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1535437745,"ip_address":"","comment_id":21954,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"后台更新策略怎么选择哪些数据是需要缓存的？缓存的数据不是依赖查询么？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425417,"discussion_content":"1. 缓存被踢是正常的\n2. 不是每个缓存被踢都会引起问题，缓存有算法的，例如LRU\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538214061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21797,"user_name":"正是那朵玫瑰","can_delete":false,"product_type":"c1","uid":1048261,"ip_address":"","ucode":"73D630B654573F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/c5/3467cf94.jpg","comment_is_top":false,"comment_ctime":1535340114,"is_pvip":false,"replies":[{"id":7777,"content":"用户输入的查询条件千变万化，排列组合太多了，很多的查询只会出现一下，缓存其实没有必要","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1535342159,"ip_address":"","comment_id":21797,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"引用“我们用过另外一种方式：将查询条件组合成字符串再计算md5，作为缓存的key，优点是简单灵活，缺点是浪费一部分缓存”\n— — — — — — — — — — — — — — — — —\n没有太明白，为什么会浪费一部分缓存呢？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422938,"discussion_content":"是你选择的，程序员设计的时候需要确定哪类缓存要后台更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535437745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19329,"user_name":"周威","can_delete":false,"product_type":"c1","uid":1185515,"ip_address":"","ucode":"348063836A7859","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/eb/5ce7e617.jpg","comment_is_top":false,"comment_ctime":1533775975,"is_pvip":false,"replies":[{"id":6682,"content":"你们的缓存方案很完善，但太复杂，容易出小问题，通常建议宁愿多花点机器成本，而不是设计这么复杂的缓存方案，《unix编程艺术》中有个原则：宁花机器一分，不花程序员一秒","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1533779755,"ip_address":"","comment_id":19329,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"我们是cdn缓存通用url数据，rocksdb 缓存持久化实体数据，redis 缓存易变业务数据，空数据缓存防止穿透，每次数据库返回同时异步写rocks 作为降级雪崩网络延迟等意外情况的数据，设置开关可以开启本地缓存，同时启动定时任务去尝试读取最新db。由于分布式，真正开启降级方案由于每个机器本地不一样，会出现状态不一致，没有方案似乎","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422869,"discussion_content":"用户输入的查询条件千变万化，排列组合太多了，很多的查询只会出现一下，缓存其实没有必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535342159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16859,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1532258445,"is_pvip":false,"replies":[{"id":5941,"content":"读者卧虎藏龙👍👍","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532425193,"ip_address":"","comment_id":16859,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"大神们的智慧也提供一个互相交流学习的机会赞一个👍","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421786,"discussion_content":"你们的缓存方案很完善，但太复杂，容易出小问题，通常建议宁愿多花点机器成本，而不是设计这么复杂的缓存方案，《unix编程艺术》中有个原则：宁花机器一分，不花程序员一秒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533779755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16016,"user_name":"krugle","can_delete":false,"product_type":"c1","uid":1045770,"ip_address":"","ucode":"60A7D9189C01BE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/0a/077b9922.jpg","comment_is_top":false,"comment_ctime":1531740657,"is_pvip":false,"replies":[{"id":5570,"content":"缓存框架，由框架统一管理缓存,看看Ehcache","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1531792626,"ip_address":"","comment_id":16016,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"我们的缓存都是下载业务代码里面，有数据不一致的地方要到处翻代码，有什么好的方法解决这个吗，百度了好多没结果","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420951,"discussion_content":"读者卧虎藏龙👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532425193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14785,"user_name":"Simple_Zhang","can_delete":false,"product_type":"c1","uid":1169865,"ip_address":"","ucode":"58A449294D4FE0","user_header":"https://static001.geekbang.org/account/avatar/00/11/d9/c9/66feceac.jpg","comment_is_top":false,"comment_ctime":1530664488,"is_pvip":false,"replies":[{"id":4985,"content":"先更新库好些，因为更新库成功后即使更新缓存失败，缓存也有过期时间。\n\n如果要保证一致，更新库前先删除缓存，然后更新库，再更新缓存，但即使这样，也可能出现缓存和库不一致，因此要做到绝对一致是很复杂的，需要用到zk这类协调软件，一般不建议这么做，没必要","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1530667049,"ip_address":"","comment_id":14785,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"华哥，请问如何保证缓存和数据库的一致性，例如用户修改了一项配置，是先更新缓存还是先更新库？如何保证缓存和库都更新一致呢😊 ","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420637,"discussion_content":"缓存框架，由框架统一管理缓存,看看Ehcache","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531792626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14774,"user_name":"孟老师","can_delete":false,"product_type":"c1","uid":1103169,"ip_address":"","ucode":"0ADB53FECE9CF1","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/41/99b90510.jpg","comment_is_top":false,"comment_ctime":1530662529,"is_pvip":false,"replies":[{"id":4986,"content":"读的时候可以一次读取多个，进行批量操作，性能会好很多","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1530667141,"ip_address":"","comment_id":14774,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"做游戏开发，数据先写入redis，用一个线程去读，然后写入mysql。遇到redis满了的情况，就是读的速度赶不上写的。很崩溃","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420133,"discussion_content":"先更新库好些，因为更新库成功后即使更新缓存失败，缓存也有过期时间。\n\n如果要保证一致，更新库前先删除缓存，然后更新库，再更新缓存，但即使这样，也可能出现缓存和库不一致，因此要做到绝对一致是很复杂的，需要用到zk这类协调软件，一般不建议这么做，没必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530667049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13441,"user_name":"想飞的鱼","can_delete":false,"product_type":"c1","uid":1005259,"ip_address":"","ucode":"569ABE734BC65F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/cb/0b731cd6.jpg","comment_is_top":false,"comment_ctime":1529629301,"is_pvip":true,"replies":[{"id":4546,"content":"希望对你有帮助😊","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1529726948,"ip_address":"","comment_id":13441,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"我 off业务中涉及到很多金融各个分类的数据(股票，基金，债券，期货，宏观...),每个分类又有不同的业务类别数据，例如，股票有基础行情数据，还有各个上市公司的基础信息数据，财务数据......，由于业务场景，我们做缓存用了主动后台程序缓存，可以缓解数据库压力。但是这样造成了部分及时的行情数据无法及时更新到缓存中，后面我们部分业务改成了近期查库，及时查缓存，从一定程度解决问题。\n但是感觉现在开发业务复杂度变大了，需要主动缓存，业务程序查历史缓存，最新数据，进行合并。\n我们深知还需要继续学习，寻找更好的解决方案。感谢老师的分享。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420130,"discussion_content":"读的时候可以一次读取多个，进行批量操作，性能会好很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530667141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11686,"user_name":"万岁爷","can_delete":false,"product_type":"c1","uid":1093621,"ip_address":"","ucode":"0898989E8B4F2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/af/f5/5580f53a.jpg","comment_is_top":false,"comment_ctime":1528293731,"is_pvip":false,"replies":[{"id":3806,"content":"你可以自己写，不难","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528341371,"ip_address":"","comment_id":11686,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"要是能写些demo就完美了。demo可以课件形式，放到网盘","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418955,"discussion_content":"你可以自己写，不难","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528341371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28910,"user_name":"greatcl","can_delete":false,"product_type":"c1","uid":1009449,"ip_address":"","ucode":"44D3C55394EC08","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/29/b0ec5430.jpg","comment_is_top":false,"comment_ctime":1538192511,"is_pvip":false,"replies":[{"id":10423,"content":"1. 缓存被踢是正常的\n2. 不是每个缓存被踢都会引起问题，缓存有算法的，例如LRU\n","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1538214061,"ip_address":"","comment_id":28910,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"对于文中后台更新的例子有个疑问，如果当缓存系统内存不够时，一部分缓存被踢掉，后台去频繁读取缓存，发现被踢掉之后就立刻更新缓存。那这个时候因为内存不够，不是会有其它缓存被踢掉然后产生问题吗？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425417,"discussion_content":"1. 缓存被踢是正常的\n2. 不是每个缓存被踢都会引起问题，缓存有算法的，例如LRU\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538214061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21954,"user_name":"laurencezl","can_delete":false,"product_type":"c1","uid":1049020,"ip_address":"","ucode":"F531F68705B94D","user_header":"","comment_is_top":false,"comment_ctime":1535419219,"is_pvip":false,"replies":[{"id":7856,"content":"是你选择的，程序员设计的时候需要确定哪类缓存要后台更新","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1535437745,"ip_address":"","comment_id":21954,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"后台更新策略怎么选择哪些数据是需要缓存的？缓存的数据不是依赖查询么？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422938,"discussion_content":"是你选择的，程序员设计的时候需要确定哪类缓存要后台更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535437745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21797,"user_name":"正是那朵玫瑰","can_delete":false,"product_type":"c1","uid":1048261,"ip_address":"","ucode":"73D630B654573F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/c5/3467cf94.jpg","comment_is_top":false,"comment_ctime":1535340114,"is_pvip":false,"replies":[{"id":7777,"content":"用户输入的查询条件千变万化，排列组合太多了，很多的查询只会出现一下，缓存其实没有必要","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1535342159,"ip_address":"","comment_id":21797,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"引用“我们用过另外一种方式：将查询条件组合成字符串再计算md5，作为缓存的key，优点是简单灵活，缺点是浪费一部分缓存”\n— — — — — — — — — — — — — — — — —\n没有太明白，为什么会浪费一部分缓存呢？","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422869,"discussion_content":"用户输入的查询条件千变万化，排列组合太多了，很多的查询只会出现一下，缓存其实没有必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535342159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19329,"user_name":"周威","can_delete":false,"product_type":"c1","uid":1185515,"ip_address":"","ucode":"348063836A7859","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/eb/5ce7e617.jpg","comment_is_top":false,"comment_ctime":1533775975,"is_pvip":false,"replies":[{"id":6682,"content":"你们的缓存方案很完善，但太复杂，容易出小问题，通常建议宁愿多花点机器成本，而不是设计这么复杂的缓存方案，《unix编程艺术》中有个原则：宁花机器一分，不花程序员一秒","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1533779755,"ip_address":"","comment_id":19329,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"我们是cdn缓存通用url数据，rocksdb 缓存持久化实体数据，redis 缓存易变业务数据，空数据缓存防止穿透，每次数据库返回同时异步写rocks 作为降级雪崩网络延迟等意外情况的数据，设置开关可以开启本地缓存，同时启动定时任务去尝试读取最新db。由于分布式，真正开启降级方案由于每个机器本地不一样，会出现状态不一致，没有方案似乎","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421786,"discussion_content":"你们的缓存方案很完善，但太复杂，容易出小问题，通常建议宁愿多花点机器成本，而不是设计这么复杂的缓存方案，《unix编程艺术》中有个原则：宁花机器一分，不花程序员一秒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533779755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16859,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1532258445,"is_pvip":false,"replies":[{"id":5941,"content":"读者卧虎藏龙👍👍","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532425193,"ip_address":"","comment_id":16859,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"大神们的智慧也提供一个互相交流学习的机会赞一个👍","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420951,"discussion_content":"读者卧虎藏龙👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532425193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16016,"user_name":"krugle","can_delete":false,"product_type":"c1","uid":1045770,"ip_address":"","ucode":"60A7D9189C01BE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/0a/077b9922.jpg","comment_is_top":false,"comment_ctime":1531740657,"is_pvip":false,"replies":[{"id":5570,"content":"缓存框架，由框架统一管理缓存,看看Ehcache","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1531792626,"ip_address":"","comment_id":16016,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"我们的缓存都是下载业务代码里面，有数据不一致的地方要到处翻代码，有什么好的方法解决这个吗，百度了好多没结果","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420637,"discussion_content":"缓存框架，由框架统一管理缓存,看看Ehcache","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531792626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14785,"user_name":"Simple_Zhang","can_delete":false,"product_type":"c1","uid":1169865,"ip_address":"","ucode":"58A449294D4FE0","user_header":"https://static001.geekbang.org/account/avatar/00/11/d9/c9/66feceac.jpg","comment_is_top":false,"comment_ctime":1530664488,"is_pvip":false,"replies":[{"id":4985,"content":"先更新库好些，因为更新库成功后即使更新缓存失败，缓存也有过期时间。\n\n如果要保证一致，更新库前先删除缓存，然后更新库，再更新缓存，但即使这样，也可能出现缓存和库不一致，因此要做到绝对一致是很复杂的，需要用到zk这类协调软件，一般不建议这么做，没必要","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1530667049,"ip_address":"","comment_id":14785,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"华哥，请问如何保证缓存和数据库的一致性，例如用户修改了一项配置，是先更新缓存还是先更新库？如何保证缓存和库都更新一致呢😊 ","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420133,"discussion_content":"先更新库好些，因为更新库成功后即使更新缓存失败，缓存也有过期时间。\n\n如果要保证一致，更新库前先删除缓存，然后更新库，再更新缓存，但即使这样，也可能出现缓存和库不一致，因此要做到绝对一致是很复杂的，需要用到zk这类协调软件，一般不建议这么做，没必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530667049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14774,"user_name":"孟老师","can_delete":false,"product_type":"c1","uid":1103169,"ip_address":"","ucode":"0ADB53FECE9CF1","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/41/99b90510.jpg","comment_is_top":false,"comment_ctime":1530662529,"is_pvip":false,"replies":[{"id":4986,"content":"读的时候可以一次读取多个，进行批量操作，性能会好很多","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1530667141,"ip_address":"","comment_id":14774,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"做游戏开发，数据先写入redis，用一个线程去读，然后写入mysql。遇到redis满了的情况，就是读的速度赶不上写的。很崩溃","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420130,"discussion_content":"读的时候可以一次读取多个，进行批量操作，性能会好很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530667141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13441,"user_name":"想飞的鱼","can_delete":false,"product_type":"c1","uid":1005259,"ip_address":"","ucode":"569ABE734BC65F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/cb/0b731cd6.jpg","comment_is_top":false,"comment_ctime":1529629301,"is_pvip":true,"replies":[{"id":4546,"content":"希望对你有帮助😊","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1529726948,"ip_address":"","comment_id":13441,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"我 off业务中涉及到很多金融各个分类的数据(股票，基金，债券，期货，宏观...),每个分类又有不同的业务类别数据，例如，股票有基础行情数据，还有各个上市公司的基础信息数据，财务数据......，由于业务场景，我们做缓存用了主动后台程序缓存，可以缓解数据库压力。但是这样造成了部分及时的行情数据无法及时更新到缓存中，后面我们部分业务改成了近期查库，及时查缓存，从一定程度解决问题。\n但是感觉现在开发业务复杂度变大了，需要主动缓存，业务程序查历史缓存，最新数据，进行合并。\n我们深知还需要继续学习，寻找更好的解决方案。感谢老师的分享。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419651,"discussion_content":"希望对你有帮助😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529726948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11686,"user_name":"万岁爷","can_delete":false,"product_type":"c1","uid":1093621,"ip_address":"","ucode":"0898989E8B4F2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/af/f5/5580f53a.jpg","comment_is_top":false,"comment_ctime":1528293731,"is_pvip":false,"replies":[{"id":3806,"content":"你可以自己写，不难","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528341371,"ip_address":"","comment_id":11686,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100006601,"comment_content":"要是能写些demo就完美了。demo可以课件形式，放到网盘","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419651,"discussion_content":"希望对你有帮助😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529726948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11626,"user_name":"顾海","can_delete":false,"product_type":"c1","uid":1103602,"ip_address":"","ucode":"13F4E0A21975CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/f2/0601a60e.jpg","comment_is_top":false,"comment_ctime":1528251345,"is_pvip":false,"replies":[{"id":3747,"content":"实际应用比较难把所有key列出来","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528252980,"ip_address":"","comment_id":11626,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"恶意攻击导致的缓存穿透，如果你的key不是非常多，可以使用布隆过滤器","like_count":1},{"had_liked":false,"id":383811,"user_name":"柯里","can_delete":false,"product_type":"c1","uid":2556517,"ip_address":"上海","ucode":"B66035EE1E389B","user_header":"https://static001.geekbang.org/account/avatar/00/27/02/65/ddb6460e.jpg","comment_is_top":false,"comment_ctime":1699694453,"is_pvip":false,"replies":[{"id":139978,"content":"很常见的现象，但不一定是问题","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1699761207,"ip_address":"广东","comment_id":383811,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"遇到过缓存和数据库数据不一致的情况","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418931,"discussion_content":"实际应用比较难把所有key列出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528252980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375280,"user_name":"Geek_67bb9d","can_delete":false,"product_type":"c1","uid":3618397,"ip_address":"四川","ucode":"73AD49E160CA5B","user_header":"","comment_is_top":false,"comment_ctime":1685228164,"is_pvip":false,"replies":[{"id":136961,"content":"难得的亲身体验的机会 ：）","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1685266713,"ip_address":"广东","comment_id":375280,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"以前做秒杀的时候 key就是商品sku 结果就那一个单key访问量过大把整个服务器所在服务给拖垮造成服务不可用","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631568,"discussion_content":"很常见的现象，但不一定是问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699761207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368493,"user_name":"拿笔小星","can_delete":false,"product_type":"c1","uid":1193755,"ip_address":"上海","ucode":"D3D8F6A959710D","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","comment_is_top":false,"comment_ctime":1676389996,"is_pvip":false,"replies":[{"id":134233,"content":"结构都变了还重用key名，这就是在给自己挖坑啊 ：）","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1676464699,"ip_address":"广东","comment_id":368493,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"项目中遇到过因为新功能有对一个缓存对象结构做过变更，但是缓存key依然是老的。发版过程中，因为缓存里的老数据（老版本写入），新版本在读缓存时候，序列化的时候报错。后面团体养成习惯，缓存对象变更时，升级一下他的key。这样新版本只会读新key的缓存，老版本依然读老key的缓存，互不干扰。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619553,"discussion_content":"难得的亲身体验的机会 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685266713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368492,"user_name":"拿笔小星","can_delete":false,"product_type":"c1","uid":1193755,"ip_address":"上海","ucode":"D3D8F6A959710D","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","comment_is_top":false,"comment_ctime":1676389259,"is_pvip":false,"replies":[{"id":134234,"content":"第3条无解，对业务基本也没什么影响。\n第4条是一个不错的策略。","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1676464778,"ip_address":"广东","comment_id":368492,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"①我们项目中对于缓存雪崩的场景使用的是后台更新策略。缓存不过期或者过期时间设置长点，定时任务10min的执行一次从DB更新缓存的操作。\n②对于缓存热点，我们使用了进程内缓存来缓解redis节点压力\n③分页缓存我们也用，但是分页缓存会有数据重复的概率，比如：一条数据一开始在第一页最后一条，后来被挤到了第二页中。如果第一页缓存还没过期，那么就可能出现重复数据。这个目前是依赖前端去重，但这也会造成另一个问题，就是一页数据不满的情况。用户体验不好，这块大家有啥好的方法吗？\n④双key策略，其中一个key1设置过期时间，key2不设置。key1过期后，会同时更新key1和key2的缓存数据。key2数据备份作为降级使用。一些核心功能可能依赖下游服务，当下游服务不可用时，用备份数据。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604879,"discussion_content":"结构都变了还重用key名，这就是在给自己挖坑啊 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676464699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","nickname":"拿笔小星","note":"","ucode":"D3D8F6A959710D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605039,"discussion_content":"可能就是多加一个字段，但是忘记改key了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676560036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354297,"user_name":"Geek_06d12d","can_delete":false,"product_type":"c1","uid":1590623,"ip_address":"广东","ucode":"1C5172C3BBAEC3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqGaJsoQicG7Bp8cUjUkevAp5Sm8ZXy5vl5TVk4CDrq5UAoI9VicK5wwjCdk66FVRbGziaWXHgO52l1Q/132","comment_is_top":false,"comment_ctime":1660268968,"is_pvip":false,"replies":[{"id":129486,"content":"用锁的话，就需要业务代码里面嵌入缓存更新逻辑了；后台更新可以和业务代码解耦。\n\n定时更新适合生成缓存需要时间较长的缓存，如果发消息的话，会有很多业务线程发重复消息。","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1661763221,"ip_address":"广东","comment_id":354297,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"后台更新是利用不过期加后台更新，一旦淘汰就使用消息去主动更新，并发上来了会发很多消息感觉有点白费，用锁移步去更新不是更好吗。还有既然用到消息为啥不每次更新数据的时候发消息去更新缓存，还要去定时","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604880,"discussion_content":"第3条无解，对业务基本也没什么影响。\n第4条是一个不错的策略。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676464778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346932,"user_name":"davidshaw","can_delete":false,"product_type":"c1","uid":2867945,"ip_address":"","ucode":"65F9706BA27524","user_header":"https://static001.geekbang.org/account/avatar/00/2b/c2/e9/892185ca.jpg","comment_is_top":false,"comment_ctime":1653544330,"is_pvip":false,"replies":[{"id":126491,"content":"没有获取更新锁的线程此时读取缓存就是得到空值，没有说它要更新缓存呀\n","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1653616388,"ip_address":"","comment_id":346932,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。这句感觉不对，未能获取更新锁的线程应该可以读缓存，但没法更新缓存。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573701,"discussion_content":"没有获取更新锁的线程此时读取缓存就是得到空值，没有说它要更新缓存呀\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653616388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341399,"user_name":"空城。","can_delete":false,"product_type":"c1","uid":2080208,"ip_address":"","ucode":"0F6F110D811C2E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/bd/d0/070824d1.jpg","comment_is_top":false,"comment_ctime":1649579792,"is_pvip":false,"replies":[{"id":124828,"content":"双key方案只是用在一些特殊的key上，不会所有的key都用双key方案，所以内存消耗总体上其实不一定有很大影响；\n你的这个方案确实是不会浪费内存，但是每个线程每次读取key都要两次读取，实际上是耗费了CPU和网络。","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1649762889,"ip_address":"","comment_id":341399,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"应对缓存雪崩时，第一条留言的双key方案会造成内存消耗翻倍。\n我的理解是redis的key本身可以获取到过期时间，我们能不能设置一个阈值，每次查询redis的时候，去看这个key的过期时间，如果低于阈值，比如10分钟，则重新更新缓存，延长时间。这个方案和双key的方案对比有什么缺点吗","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585681,"discussion_content":"用锁的话，就需要业务代码里面嵌入缓存更新逻辑了；后台更新可以和业务代码解耦。\n\n定时更新适合生成缓存需要时间较长的缓存，如果发消息的话，会有很多业务线程发重复消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661763221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327478,"user_name":"八喜","can_delete":false,"product_type":"c1","uid":2324412,"ip_address":"","ucode":"A43D6F4E76AA41","user_header":"https://static001.geekbang.org/account/avatar/00/23/77/bc/5b9ef95a.jpg","comment_is_top":false,"comment_ctime":1640143480,"is_pvip":false,"replies":[{"id":119248,"content":"加油 ：）","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1640219554,"ip_address":"","comment_id":327478,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"缓存热点这个之前的确是没有想到，学习了","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562005,"discussion_content":"双key方案只是用在一些特殊的key上，不会所有的key都用双key方案，所以内存消耗总体上其实不一定有很大影响；\n你的这个方案确实是不会浪费内存，但是每个线程每次读取key都要两次读取，实际上是耗费了CPU和网络。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649762889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325774,"user_name":"grey927","can_delete":false,"product_type":"c1","uid":1202782,"ip_address":"","ucode":"833E02ED835B4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","comment_is_top":false,"comment_ctime":1639125922,"is_pvip":false,"replies":[{"id":118212,"content":"理论上可以，但是实际上不太可行，你想过没有，大部分的情况下访问是OK的，只是在缓存失效或者被攻击的时候才会出现缓存穿透，但是为了维护布隆过滤器，每次读写都要去访问布隆过滤器，因为程序并不知道什么时候被攻击了，这就导致了正常的时候，布隆过滤器实际上没有什么作用还影响性能；\n\n另外，缓存的key并不一定是简单的和数据库或者存储系统的主键一一对应的，这就导致你不同的缓存访问失效后要进行的布隆过滤器的判断逻辑不同，这就很麻烦了","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1639274100,"ip_address":"","comment_id":325774,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"缓存穿透的状况可以通过布隆过滤器来解决","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537937,"discussion_content":"理论上可以，但是实际上不太可行，你想过没有，大部分的情况下访问是OK的，只是在缓存失效或者被攻击的时候才会出现缓存穿透，但是为了维护布隆过滤器，每次读写都要去访问布隆过滤器，因为程序并不知道什么时候被攻击了，这就导致了正常的时候，布隆过滤器实际上没有什么作用还影响性能；\n\n另外，缓存的key并不一定是简单的和数据库或者存储系统的主键一一对应的，这就导致你不同的缓存访问失效后要进行的布隆过滤器的判断逻辑不同，这就很麻烦了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639274100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11626,"user_name":"顾海","can_delete":false,"product_type":"c1","uid":1103602,"ip_address":"","ucode":"13F4E0A21975CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/f2/0601a60e.jpg","comment_is_top":false,"comment_ctime":1528251345,"is_pvip":false,"replies":[{"id":3747,"content":"实际应用比较难把所有key列出来","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528252980,"ip_address":"","comment_id":11626,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"恶意攻击导致的缓存穿透，如果你的key不是非常多，可以使用布隆过滤器","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418931,"discussion_content":"实际应用比较难把所有key列出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528252980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383811,"user_name":"柯里","can_delete":false,"product_type":"c1","uid":2556517,"ip_address":"上海","ucode":"B66035EE1E389B","user_header":"https://static001.geekbang.org/account/avatar/00/27/02/65/ddb6460e.jpg","comment_is_top":false,"comment_ctime":1699694453,"is_pvip":false,"replies":[{"id":139978,"content":"很常见的现象，但不一定是问题","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1699761207,"ip_address":"广东","comment_id":383811,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"遇到过缓存和数据库数据不一致的情况","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631568,"discussion_content":"很常见的现象，但不一定是问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699761207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375280,"user_name":"Geek_67bb9d","can_delete":false,"product_type":"c1","uid":3618397,"ip_address":"四川","ucode":"73AD49E160CA5B","user_header":"","comment_is_top":false,"comment_ctime":1685228164,"is_pvip":false,"replies":[{"id":136961,"content":"难得的亲身体验的机会 ：）","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1685266713,"ip_address":"广东","comment_id":375280,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"以前做秒杀的时候 key就是商品sku 结果就那一个单key访问量过大把整个服务器所在服务给拖垮造成服务不可用","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619553,"discussion_content":"难得的亲身体验的机会 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685266713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368493,"user_name":"拿笔小星","can_delete":false,"product_type":"c1","uid":1193755,"ip_address":"上海","ucode":"D3D8F6A959710D","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","comment_is_top":false,"comment_ctime":1676389996,"is_pvip":false,"replies":[{"id":134233,"content":"结构都变了还重用key名，这就是在给自己挖坑啊 ：）","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1676464699,"ip_address":"广东","comment_id":368493,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"项目中遇到过因为新功能有对一个缓存对象结构做过变更，但是缓存key依然是老的。发版过程中，因为缓存里的老数据（老版本写入），新版本在读缓存时候，序列化的时候报错。后面团体养成习惯，缓存对象变更时，升级一下他的key。这样新版本只会读新key的缓存，老版本依然读老key的缓存，互不干扰。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604879,"discussion_content":"结构都变了还重用key名，这就是在给自己挖坑啊 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676464699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","nickname":"拿笔小星","note":"","ucode":"D3D8F6A959710D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605039,"discussion_content":"可能就是多加一个字段，但是忘记改key了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676560036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368492,"user_name":"拿笔小星","can_delete":false,"product_type":"c1","uid":1193755,"ip_address":"上海","ucode":"D3D8F6A959710D","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","comment_is_top":false,"comment_ctime":1676389259,"is_pvip":false,"replies":[{"id":134234,"content":"第3条无解，对业务基本也没什么影响。\n第4条是一个不错的策略。","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1676464778,"ip_address":"广东","comment_id":368492,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"①我们项目中对于缓存雪崩的场景使用的是后台更新策略。缓存不过期或者过期时间设置长点，定时任务10min的执行一次从DB更新缓存的操作。\n②对于缓存热点，我们使用了进程内缓存来缓解redis节点压力\n③分页缓存我们也用，但是分页缓存会有数据重复的概率，比如：一条数据一开始在第一页最后一条，后来被挤到了第二页中。如果第一页缓存还没过期，那么就可能出现重复数据。这个目前是依赖前端去重，但这也会造成另一个问题，就是一页数据不满的情况。用户体验不好，这块大家有啥好的方法吗？\n④双key策略，其中一个key1设置过期时间，key2不设置。key1过期后，会同时更新key1和key2的缓存数据。key2数据备份作为降级使用。一些核心功能可能依赖下游服务，当下游服务不可用时，用备份数据。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604880,"discussion_content":"第3条无解，对业务基本也没什么影响。\n第4条是一个不错的策略。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676464778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354297,"user_name":"Geek_06d12d","can_delete":false,"product_type":"c1","uid":1590623,"ip_address":"广东","ucode":"1C5172C3BBAEC3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqGaJsoQicG7Bp8cUjUkevAp5Sm8ZXy5vl5TVk4CDrq5UAoI9VicK5wwjCdk66FVRbGziaWXHgO52l1Q/132","comment_is_top":false,"comment_ctime":1660268968,"is_pvip":false,"replies":[{"id":129486,"content":"用锁的话，就需要业务代码里面嵌入缓存更新逻辑了；后台更新可以和业务代码解耦。\n\n定时更新适合生成缓存需要时间较长的缓存，如果发消息的话，会有很多业务线程发重复消息。","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1661763221,"ip_address":"广东","comment_id":354297,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"后台更新是利用不过期加后台更新，一旦淘汰就使用消息去主动更新，并发上来了会发很多消息感觉有点白费，用锁移步去更新不是更好吗。还有既然用到消息为啥不每次更新数据的时候发消息去更新缓存，还要去定时","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585681,"discussion_content":"用锁的话，就需要业务代码里面嵌入缓存更新逻辑了；后台更新可以和业务代码解耦。\n\n定时更新适合生成缓存需要时间较长的缓存，如果发消息的话，会有很多业务线程发重复消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661763221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346932,"user_name":"davidshaw","can_delete":false,"product_type":"c1","uid":2867945,"ip_address":"","ucode":"65F9706BA27524","user_header":"https://static001.geekbang.org/account/avatar/00/2b/c2/e9/892185ca.jpg","comment_is_top":false,"comment_ctime":1653544330,"is_pvip":false,"replies":[{"id":126491,"content":"没有获取更新锁的线程此时读取缓存就是得到空值，没有说它要更新缓存呀\n","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1653616388,"ip_address":"","comment_id":346932,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。这句感觉不对，未能获取更新锁的线程应该可以读缓存，但没法更新缓存。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573701,"discussion_content":"没有获取更新锁的线程此时读取缓存就是得到空值，没有说它要更新缓存呀\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653616388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341399,"user_name":"空城。","can_delete":false,"product_type":"c1","uid":2080208,"ip_address":"","ucode":"0F6F110D811C2E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/bd/d0/070824d1.jpg","comment_is_top":false,"comment_ctime":1649579792,"is_pvip":false,"replies":[{"id":124828,"content":"双key方案只是用在一些特殊的key上，不会所有的key都用双key方案，所以内存消耗总体上其实不一定有很大影响；\n你的这个方案确实是不会浪费内存，但是每个线程每次读取key都要两次读取，实际上是耗费了CPU和网络。","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1649762889,"ip_address":"","comment_id":341399,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"应对缓存雪崩时，第一条留言的双key方案会造成内存消耗翻倍。\n我的理解是redis的key本身可以获取到过期时间，我们能不能设置一个阈值，每次查询redis的时候，去看这个key的过期时间，如果低于阈值，比如10分钟，则重新更新缓存，延长时间。这个方案和双key的方案对比有什么缺点吗","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562005,"discussion_content":"双key方案只是用在一些特殊的key上，不会所有的key都用双key方案，所以内存消耗总体上其实不一定有很大影响；\n你的这个方案确实是不会浪费内存，但是每个线程每次读取key都要两次读取，实际上是耗费了CPU和网络。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649762889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327478,"user_name":"八喜","can_delete":false,"product_type":"c1","uid":2324412,"ip_address":"","ucode":"A43D6F4E76AA41","user_header":"https://static001.geekbang.org/account/avatar/00/23/77/bc/5b9ef95a.jpg","comment_is_top":false,"comment_ctime":1640143480,"is_pvip":false,"replies":[{"id":119248,"content":"加油 ：）","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1640219554,"ip_address":"","comment_id":327478,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"缓存热点这个之前的确是没有想到，学习了","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540937,"discussion_content":"加油 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640219554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325774,"user_name":"grey927","can_delete":false,"product_type":"c1","uid":1202782,"ip_address":"","ucode":"833E02ED835B4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","comment_is_top":false,"comment_ctime":1639125922,"is_pvip":false,"replies":[{"id":118212,"content":"理论上可以，但是实际上不太可行，你想过没有，大部分的情况下访问是OK的，只是在缓存失效或者被攻击的时候才会出现缓存穿透，但是为了维护布隆过滤器，每次读写都要去访问布隆过滤器，因为程序并不知道什么时候被攻击了，这就导致了正常的时候，布隆过滤器实际上没有什么作用还影响性能；\n\n另外，缓存的key并不一定是简单的和数据库或者存储系统的主键一一对应的，这就导致你不同的缓存访问失效后要进行的布隆过滤器的判断逻辑不同，这就很麻烦了","user_name":"作者回复","user_name_real":"编辑","uid":1098920,"ctime":1639274100,"ip_address":"","comment_id":325774,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100006601,"comment_content":"缓存穿透的状况可以通过布隆过滤器来解决","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540937,"discussion_content":"加油 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640219554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314914,"user_name":"cppby","can_delete":false,"product_type":"c1","uid":1061808,"ip_address":"","ucode":"BC1BA42F1440D6","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/b0/6b37f63d.jpg","comment_is_top":false,"comment_ctime":1633576846,"is_pvip":false,"replies":[{"id":114110,"content":"说出你的故事 ：）","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1633684302,"ip_address":"","comment_id":314914,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"我要早看到这个文章。 当初设计业务热点缓存的方案就不会被人喷了。。。","like_count":0},{"had_liked":false,"id":313387,"user_name":"青年祭司","can_delete":false,"product_type":"c1","uid":1259156,"ip_address":"","ucode":"C88EDAE3FF09AE","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/94/0b969588.jpg","comment_is_top":false,"comment_ctime":1632403396,"is_pvip":false,"replies":[{"id":113585,"content":"列表页缓存不需要卖家更新商品就更新缓存，列表页的信息只是商品详情页的一些关键信息，就算短时间不一致，用户进入商品详情页后看到的是最新的信息就可以了；\n另外，列表缓存是按页缓存的，一页里面10个商品，这10个商品的更新频率不会太高，你不要一个商品更新就更新所有列表页的缓存","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1632532739,"ip_address":"","comment_id":313387,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"老师，曾经接触过一个c2c的电商项目，买家在浏览商品列表时会生成缓存，但是如果卖家修改商品信息或者增加商品就需要及时更新缓存，以展示最新信息。如果持续有大量卖家更改商品信息那缓存会更新的很频繁，也就失去了意义，请问这种情况怎么设计缓存。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527833,"discussion_content":"说出你的故事 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633684302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304184,"user_name":"11月的萧邦","can_delete":false,"product_type":"c1","uid":2663324,"ip_address":"","ucode":"E7A2236BFD9ABE","user_header":"https://static001.geekbang.org/account/avatar/00/28/a3/9c/836d7bb3.jpg","comment_is_top":false,"comment_ctime":1627288833,"is_pvip":false,"replies":[{"id":110084,"content":"是的，一般会通过消息队列发个更新消息给后台进程触发立即更新\n","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1627310138,"ip_address":"","comment_id":304184,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"后台更新方案除了缓存被踢掉这个问题之外，还会有个问题：就是如果数据库的业务数据有更新了，那么缓存在定时任务更新之前读到的都是旧数据。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527335,"discussion_content":"列表页缓存不需要卖家更新商品就更新缓存，列表页的信息只是商品详情页的一些关键信息，就算短时间不一致，用户进入商品详情页后看到的是最新的信息就可以了；\n另外，列表缓存是按页缓存的，一页里面10个商品，这10个商品的更新频率不会太高，你不要一个商品更新就更新所有列表页的缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632532739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304180,"user_name":"11月的萧邦","can_delete":false,"product_type":"c1","uid":2663324,"ip_address":"","ucode":"E7A2236BFD9ABE","user_header":"https://static001.geekbang.org/account/avatar/00/28/a3/9c/836d7bb3.jpg","comment_is_top":false,"comment_ctime":1627288354,"is_pvip":false,"replies":[{"id":110083,"content":"方案可以灵活组合的，课程中介绍的方案你可以理解为基础方案，你可以排列组合调整","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1627310106,"ip_address":"","comment_id":304180,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"我之前一个项目的缓存方案有点像后台更新，由后台刷新缓存并设置永久有效期。但有一点区别：就是如果数据库数据有更新了，在下一次定时任务更新缓存之前用户读取到的都是旧数据，而我们业务要求数据更新后要立即生效，所以我们在数据库更新业务数据之后会立即更新下对应的数据。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523965,"discussion_content":"是的，一般会通过消息队列发个更新消息给后台进程触发立即更新\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627310138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290406,"user_name":"IsaacGao","can_delete":false,"product_type":"c1","uid":1057611,"ip_address":"","ucode":"95C640D185A060","user_header":"https://static001.geekbang.org/account/avatar/00/10/23/4b/5578cbd1.jpg","comment_is_top":false,"comment_ctime":1619529526,"is_pvip":false,"replies":[{"id":105255,"content":"可以加","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1619567227,"ip_address":"","comment_id":290406,"utype":1}],"discussion_count":2,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"「业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存」这里是不是也要加锁？如果不加锁应该会出现缓存击穿","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523964,"discussion_content":"方案可以灵活组合的，课程中介绍的方案你可以理解为基础方案，你可以排列组合调整","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627310106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282229,"user_name":"程辉","can_delete":false,"product_type":"c1","uid":1395334,"ip_address":"","ucode":"A8AE3BFE6EE59C","user_header":"https://static001.geekbang.org/account/avatar/00/15/4a/86/c7bd910e.jpg","comment_is_top":false,"comment_ctime":1615167334,"is_pvip":false,"replies":[{"id":102503,"content":"什么叫“多维护一套缓存列表”？如果是说后台要记录哪些缓存要更新的话，那是肯定需要的。","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1615196733,"ip_address":"","comment_id":282229,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"后台更新缓存的方式，需要多维护一套缓存列表吧？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519197,"discussion_content":"可以加","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619567227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1057611,"avatar":"https://static001.geekbang.org/account/avatar/00/10/23/4b/5578cbd1.jpg","nickname":"IsaacGao","note":"","ucode":"95C640D185A060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":530441,"discussion_content":"感谢老师答疑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637074145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":519197,"ip_address":"","group_id":0},"score":530441,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":247078,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1599578843,"is_pvip":true,"replies":[{"id":91152,"content":"Redis会更复杂一些","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1599983056,"ip_address":"","comment_id":247078,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"好像有一点专栏里面没有提及，就是缓存其实是比较贵的，不能把过多的数据放到缓存里。\n\n看到留言里面 @bluefantasy 提到的 Redis 双缓存策略，这个还真是挺巧妙的，不过成本也高一些。\n\nMemcached 和 Redis 的选择，估计也会成为面试题目。在之前的专栏里面提到过，Memcache 是纯内存缓存，支持基于一致性 hash 的集群；而 Redis 支持持久化、数据字典、主备、集群……\n\n后来简单的检索了一下，发现这个问题几乎不需要考虑，无论是从 Google Trends 上看，还是 Stack Overflow 上的回答，Redis 都是更好的选择，除非你本人是 Memcached 专家或者团队在 Memcached 上投入很大。\n\nRedis is more powerful, more popular, and better supported than memcached. Memcached can only do a small fraction of the things Redis can do. Redis is better even where their features overlap. \n— https:&#47;&#47;stackoverflow.com&#47;questions&#47;10558465&#47;memcached-vs-redis\n\n在留言里面还看到有人两个都用的，Memcached 用于缓存对象，减轻数据库负载；Redis 用于有序集合，适用于时间序列数据。\n\n在简书上的《memcached redis 对比分析》https:&#47;&#47;www.jianshu.com&#47;p&#47;e94fa7340923，可能是中文网络里阅读量比较大的一篇。\n\nMemcached 的优势似乎只有小型静态数据（HTML代码片段），我怀疑其实优势也没那么大；另外有人说 Memcached 的扩展性更好，我有点怀疑；最后就是有人提到，Memcached 可能相对来说占用内存稍微小一点，这个我觉的有可能。\n\n如果只讨论 Redis，可能对于架构设计来说过于局限了，高性能缓存架构不止于此。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516672,"discussion_content":"什么叫“多维护一套缓存列表”？如果是说后台要记录哪些缓存要更新的话，那是肯定需要的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615196733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239818,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1596671747,"is_pvip":false,"replies":[{"id":88714,"content":"存储系统不适合做复杂逻辑处理","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1596842961,"ip_address":"","comment_id":239818,"utype":1}],"discussion_count":2,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"“读多写少的数据，存储系统有心无力”\n为什么存储系统有心无力？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505304,"discussion_content":"Redis会更复杂一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599983056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233825,"user_name":"余松","can_delete":false,"product_type":"c1","uid":1487584,"ip_address":"","ucode":"89EC9CE3AD0281","user_header":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","comment_is_top":false,"comment_ctime":1594464994,"is_pvip":false,"replies":[{"id":86354,"content":"你理解错了，这个问题的根本原因是生成缓存数据太耗费资源，不管你放在old区还是new区，生成缓存这个动作消耗资源都一样的","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1594595738,"ip_address":"","comment_id":233825,"utype":1}],"discussion_count":2,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"关于缓存穿透第二类问题“缓存数据生成耗费大量时间或者资源”，爬虫这类恶意攻击导致的缓存无法发挥作用，老师提到“这种情况并没有太好的解决方案”。我倒是觉得MySQL给了我们很好的一个解决方案：实际像爬虫这种场景，MySQL每时每刻都在经历--All 全表扫描，但是MySQL又要维护Buffer Pool缓存提高查询效率。是不是和老师提到的爬虫问题非常相似，大量数据只读一次导致常用的数据被淘汰。\nMySQL给出的解决方案是：优化LRU淘汰机制，将其分为Young区（链前部）+Old区（链后部）。新刷新的数据智能放在Old的头部，只有再次读取到该数据，设置一个条件比如缓存被读了多少次、存活多长时间才能进入Young区。达到了这样的效果：\n1.访问最多的数据能够保持在链表头部，快速访问。\n2.那些偶尔刷一次的数据（爬虫访问量远比正常访问量少）很快被淘汰。\n篇幅有限，没办法详细描述buffer pool。抛砖引玉吧，感兴趣的同学自行查看《高性能MySQL》","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503232,"discussion_content":"存储系统不适合做复杂逻辑处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596842961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296977,"discussion_content":"自问自答：数据库的读比写要复杂，读库即查询，涉及条件查询，联合查询，因此写库反而更简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596720517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229778,"user_name":"李卫卫","can_delete":false,"product_type":"c1","uid":1367591,"ip_address":"","ucode":"F89946C5BF9EA1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo6qUrJUgVNIMeWy4ffwR7AiahZSuiaOSGeicwSydRm0s5WUwzqxTib8hCuf6ticP8sKmabTf9WSgYHRxw/132","comment_is_top":false,"comment_ctime":1593143221,"is_pvip":false,"replies":[{"id":85271,"content":"后台统一异步更新","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1593516104,"ip_address":"","comment_id":229778,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"缓存分片保证消除热点key，是这个不错思路，不过缓存中不同key的数据一致性如何保证？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499637,"discussion_content":"后台统一异步更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593516104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314914,"user_name":"cppby","can_delete":false,"product_type":"c1","uid":1061808,"ip_address":"","ucode":"BC1BA42F1440D6","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/b0/6b37f63d.jpg","comment_is_top":false,"comment_ctime":1633576846,"is_pvip":false,"replies":[{"id":114110,"content":"说出你的故事 ：）","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1633684302,"ip_address":"","comment_id":314914,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"我要早看到这个文章。 当初设计业务热点缓存的方案就不会被人喷了。。。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527833,"discussion_content":"说出你的故事 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633684302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313387,"user_name":"青年祭司","can_delete":false,"product_type":"c1","uid":1259156,"ip_address":"","ucode":"C88EDAE3FF09AE","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/94/0b969588.jpg","comment_is_top":false,"comment_ctime":1632403396,"is_pvip":false,"replies":[{"id":113585,"content":"列表页缓存不需要卖家更新商品就更新缓存，列表页的信息只是商品详情页的一些关键信息，就算短时间不一致，用户进入商品详情页后看到的是最新的信息就可以了；\n另外，列表缓存是按页缓存的，一页里面10个商品，这10个商品的更新频率不会太高，你不要一个商品更新就更新所有列表页的缓存","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1632532739,"ip_address":"","comment_id":313387,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"老师，曾经接触过一个c2c的电商项目，买家在浏览商品列表时会生成缓存，但是如果卖家修改商品信息或者增加商品就需要及时更新缓存，以展示最新信息。如果持续有大量卖家更改商品信息那缓存会更新的很频繁，也就失去了意义，请问这种情况怎么设计缓存。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527335,"discussion_content":"列表页缓存不需要卖家更新商品就更新缓存，列表页的信息只是商品详情页的一些关键信息，就算短时间不一致，用户进入商品详情页后看到的是最新的信息就可以了；\n另外，列表缓存是按页缓存的，一页里面10个商品，这10个商品的更新频率不会太高，你不要一个商品更新就更新所有列表页的缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632532739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304184,"user_name":"11月的萧邦","can_delete":false,"product_type":"c1","uid":2663324,"ip_address":"","ucode":"E7A2236BFD9ABE","user_header":"https://static001.geekbang.org/account/avatar/00/28/a3/9c/836d7bb3.jpg","comment_is_top":false,"comment_ctime":1627288833,"is_pvip":false,"replies":[{"id":110084,"content":"是的，一般会通过消息队列发个更新消息给后台进程触发立即更新\n","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1627310138,"ip_address":"","comment_id":304184,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"后台更新方案除了缓存被踢掉这个问题之外，还会有个问题：就是如果数据库的业务数据有更新了，那么缓存在定时任务更新之前读到的都是旧数据。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523965,"discussion_content":"是的，一般会通过消息队列发个更新消息给后台进程触发立即更新\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627310138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304180,"user_name":"11月的萧邦","can_delete":false,"product_type":"c1","uid":2663324,"ip_address":"","ucode":"E7A2236BFD9ABE","user_header":"https://static001.geekbang.org/account/avatar/00/28/a3/9c/836d7bb3.jpg","comment_is_top":false,"comment_ctime":1627288354,"is_pvip":false,"replies":[{"id":110083,"content":"方案可以灵活组合的，课程中介绍的方案你可以理解为基础方案，你可以排列组合调整","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1627310106,"ip_address":"","comment_id":304180,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"我之前一个项目的缓存方案有点像后台更新，由后台刷新缓存并设置永久有效期。但有一点区别：就是如果数据库数据有更新了，在下一次定时任务更新缓存之前用户读取到的都是旧数据，而我们业务要求数据更新后要立即生效，所以我们在数据库更新业务数据之后会立即更新下对应的数据。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523964,"discussion_content":"方案可以灵活组合的，课程中介绍的方案你可以理解为基础方案，你可以排列组合调整","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627310106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290406,"user_name":"IsaacGao","can_delete":false,"product_type":"c1","uid":1057611,"ip_address":"","ucode":"95C640D185A060","user_header":"https://static001.geekbang.org/account/avatar/00/10/23/4b/5578cbd1.jpg","comment_is_top":false,"comment_ctime":1619529526,"is_pvip":false,"replies":[{"id":105255,"content":"可以加","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1619567227,"ip_address":"","comment_id":290406,"utype":1}],"discussion_count":2,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"「业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存」这里是不是也要加锁？如果不加锁应该会出现缓存击穿","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519197,"discussion_content":"可以加","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619567227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1057611,"avatar":"https://static001.geekbang.org/account/avatar/00/10/23/4b/5578cbd1.jpg","nickname":"IsaacGao","note":"","ucode":"95C640D185A060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":530441,"discussion_content":"感谢老师答疑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637074145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":519197,"ip_address":"","group_id":0},"score":530441,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":282229,"user_name":"程辉","can_delete":false,"product_type":"c1","uid":1395334,"ip_address":"","ucode":"A8AE3BFE6EE59C","user_header":"https://static001.geekbang.org/account/avatar/00/15/4a/86/c7bd910e.jpg","comment_is_top":false,"comment_ctime":1615167334,"is_pvip":false,"replies":[{"id":102503,"content":"什么叫“多维护一套缓存列表”？如果是说后台要记录哪些缓存要更新的话，那是肯定需要的。","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1615196733,"ip_address":"","comment_id":282229,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"后台更新缓存的方式，需要多维护一套缓存列表吧？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516672,"discussion_content":"什么叫“多维护一套缓存列表”？如果是说后台要记录哪些缓存要更新的话，那是肯定需要的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615196733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247078,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1599578843,"is_pvip":true,"replies":[{"id":91152,"content":"Redis会更复杂一些","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1599983056,"ip_address":"","comment_id":247078,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"好像有一点专栏里面没有提及，就是缓存其实是比较贵的，不能把过多的数据放到缓存里。\n\n看到留言里面 @bluefantasy 提到的 Redis 双缓存策略，这个还真是挺巧妙的，不过成本也高一些。\n\nMemcached 和 Redis 的选择，估计也会成为面试题目。在之前的专栏里面提到过，Memcache 是纯内存缓存，支持基于一致性 hash 的集群；而 Redis 支持持久化、数据字典、主备、集群……\n\n后来简单的检索了一下，发现这个问题几乎不需要考虑，无论是从 Google Trends 上看，还是 Stack Overflow 上的回答，Redis 都是更好的选择，除非你本人是 Memcached 专家或者团队在 Memcached 上投入很大。\n\nRedis is more powerful, more popular, and better supported than memcached. Memcached can only do a small fraction of the things Redis can do. Redis is better even where their features overlap. \n— https:&#47;&#47;stackoverflow.com&#47;questions&#47;10558465&#47;memcached-vs-redis\n\n在留言里面还看到有人两个都用的，Memcached 用于缓存对象，减轻数据库负载；Redis 用于有序集合，适用于时间序列数据。\n\n在简书上的《memcached redis 对比分析》https:&#47;&#47;www.jianshu.com&#47;p&#47;e94fa7340923，可能是中文网络里阅读量比较大的一篇。\n\nMemcached 的优势似乎只有小型静态数据（HTML代码片段），我怀疑其实优势也没那么大；另外有人说 Memcached 的扩展性更好，我有点怀疑；最后就是有人提到，Memcached 可能相对来说占用内存稍微小一点，这个我觉的有可能。\n\n如果只讨论 Redis，可能对于架构设计来说过于局限了，高性能缓存架构不止于此。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505304,"discussion_content":"Redis会更复杂一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599983056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239818,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1596671747,"is_pvip":false,"replies":[{"id":88714,"content":"存储系统不适合做复杂逻辑处理","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1596842961,"ip_address":"","comment_id":239818,"utype":1}],"discussion_count":2,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"“读多写少的数据，存储系统有心无力”\n为什么存储系统有心无力？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503232,"discussion_content":"存储系统不适合做复杂逻辑处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596842961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296977,"discussion_content":"自问自答：数据库的读比写要复杂，读库即查询，涉及条件查询，联合查询，因此写库反而更简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596720517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233825,"user_name":"余松","can_delete":false,"product_type":"c1","uid":1487584,"ip_address":"","ucode":"89EC9CE3AD0281","user_header":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","comment_is_top":false,"comment_ctime":1594464994,"is_pvip":false,"replies":[{"id":86354,"content":"你理解错了，这个问题的根本原因是生成缓存数据太耗费资源，不管你放在old区还是new区，生成缓存这个动作消耗资源都一样的","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1594595738,"ip_address":"","comment_id":233825,"utype":1}],"discussion_count":2,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"关于缓存穿透第二类问题“缓存数据生成耗费大量时间或者资源”，爬虫这类恶意攻击导致的缓存无法发挥作用，老师提到“这种情况并没有太好的解决方案”。我倒是觉得MySQL给了我们很好的一个解决方案：实际像爬虫这种场景，MySQL每时每刻都在经历--All 全表扫描，但是MySQL又要维护Buffer Pool缓存提高查询效率。是不是和老师提到的爬虫问题非常相似，大量数据只读一次导致常用的数据被淘汰。\nMySQL给出的解决方案是：优化LRU淘汰机制，将其分为Young区（链前部）+Old区（链后部）。新刷新的数据智能放在Old的头部，只有再次读取到该数据，设置一个条件比如缓存被读了多少次、存活多长时间才能进入Young区。达到了这样的效果：\n1.访问最多的数据能够保持在链表头部，快速访问。\n2.那些偶尔刷一次的数据（爬虫访问量远比正常访问量少）很快被淘汰。\n篇幅有限，没办法详细描述buffer pool。抛砖引玉吧，感兴趣的同学自行查看《高性能MySQL》","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501180,"discussion_content":"你理解错了，这个问题的根本原因是生成缓存数据太耗费资源，不管你放在old区还是new区，生成缓存这个动作消耗资源都一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594595738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1487584,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","nickname":"余松","note":"","ucode":"89EC9CE3AD0281","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353999,"discussion_content":"嗯 后来想到了，这种情况应该绕开pagecache，使用直接io。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615217118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229778,"user_name":"李卫卫","can_delete":false,"product_type":"c1","uid":1367591,"ip_address":"","ucode":"F89946C5BF9EA1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo6qUrJUgVNIMeWy4ffwR7AiahZSuiaOSGeicwSydRm0s5WUwzqxTib8hCuf6ticP8sKmabTf9WSgYHRxw/132","comment_is_top":false,"comment_ctime":1593143221,"is_pvip":false,"replies":[{"id":85271,"content":"后台统一异步更新","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1593516104,"ip_address":"","comment_id":229778,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100006601,"comment_content":"缓存分片保证消除热点key，是这个不错思路，不过缓存中不同key的数据一致性如何保证？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501180,"discussion_content":"你理解错了，这个问题的根本原因是生成缓存数据太耗费资源，不管你放在old区还是new区，生成缓存这个动作消耗资源都一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594595738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1487584,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","nickname":"余松","note":"","ucode":"89EC9CE3AD0281","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353999,"discussion_content":"嗯 后来想到了，这种情况应该绕开pagecache，使用直接io。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615217118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143214,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571650150,"is_pvip":false,"replies":[{"id":55446,"content":"是的，有一个更新后，其它的副本也更新了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1571747093,"ip_address":"","comment_id":143214,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"关于缓存热点的解决方案有一个疑问：如果读取的谋一份缓存过期了，那就会穿透到数据库查询，然后写进入缓存，并设置一个随机的过期时间吗？","like_count":0},{"had_liked":false,"id":78727,"user_name":"@@fighting","can_delete":false,"product_type":"c1","uid":1236394,"ip_address":"","ucode":"7235C1E74549AE","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/aa/859544fd.jpg","comment_is_top":false,"comment_ctime":1553224911,"is_pvip":false,"replies":[{"id":28701,"content":"这个就是简单的商品数据缓存，和分页关系不大","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1553298702,"ip_address":"","comment_id":78727,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"关于分页的存储我看到过的一个缓存方案是：不缓存整个页面，而是将页面的每一条商品单独缓存，第二次请求数据库的话只请求id，然后根据id去缓存拿具体数据；这样虽然多了好多的内存访问io，但是减少了内存的消耗","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471425,"discussion_content":"是的，有一个更新后，其它的副本也更新了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571747093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42342,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1112307,"ip_address":"","ucode":"19ACFC78CFD80F","user_header":"","comment_is_top":false,"comment_ctime":1542941519,"is_pvip":false,"replies":[{"id":15165,"content":"缓存雪崩部分就讲了怎么更新啊，其它的更新没什么复杂的吧😄","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1542956431,"ip_address":"","comment_id":42342,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"怎么没有讲讲缓存更新的问题，我觉得这也挺麻烦的","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444211,"discussion_content":"这个就是简单的商品数据缓存，和分页关系不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553298702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39033,"user_name":"allan","can_delete":false,"product_type":"c1","uid":1142819,"ip_address":"","ucode":"CA0BE868AA9FF5","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/23/972dcd30.jpg","comment_is_top":false,"comment_ctime":1542175948,"is_pvip":false,"replies":[{"id":13953,"content":"后面有很多章节讲这部分","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1542195018,"ip_address":"","comment_id":39033,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"想问下老师，您对分布式和集群的理解？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430059,"discussion_content":"缓存雪崩部分就讲了怎么更新啊，其它的更新没什么复杂的吧😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542956431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24643,"user_name":"杨陆伟","can_delete":false,"product_type":"c1","uid":1108457,"ip_address":"","ucode":"3BC968447406EB","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/e9/1f95e422.jpg","comment_is_top":false,"comment_ctime":1537178590,"is_pvip":false,"replies":[{"id":9262,"content":"查询结果不会影响key呢，至于说缓存不实时，这个没法避免，电商的商品缓存问题不大","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1537342362,"ip_address":"","comment_id":24643,"utype":1}],"discussion_count":1,"race_medal":4,"score":11,"product_id":100006601,"comment_content":"将查询条件组合成字符串再计算md5，作为缓存的key。======&#47;&#47;请问这种方式有什么作用？例如查询出的商品变多或变少了，这个key马上就失效了","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428885,"discussion_content":"后面有很多章节讲这部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542195018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16793,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1532190923,"is_pvip":false,"replies":[{"id":5944,"content":"可以测试验证一下，我没有详细研究过","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532425319,"ip_address":"","comment_id":16793,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"华哥，请问下redis由于是单线程模型他的setnx分布式锁在高并发场景下会不会有性能问题？另外他的队列结构在redis多节点集群环境下是不是会有数据不一致问题？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424072,"discussion_content":"查询结果不会影响key呢，至于说缓存不实时，这个没法避免，电商的商品缓存问题不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537342362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16792,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1532190092,"is_pvip":false,"replies":[{"id":5838,"content":"必须的，我也能学到很多😀","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532255241,"ip_address":"","comment_id":16792,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"看评论也能科普不少好东西啊","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420930,"discussion_content":"可以测试验证一下，我没有详细研究过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532425319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16788,"user_name":"bubble","can_delete":false,"product_type":"c1","uid":1103280,"ip_address":"","ucode":"557121A7F16CE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/b0/b560e561.jpg","comment_is_top":false,"comment_ctime":1532186645,"is_pvip":false,"replies":[{"id":5839,"content":"黑猫白猫理论😄","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532255296,"ip_address":"","comment_id":16788,"utype":1}],"discussion_count":2,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"我们用过另外一种方式：将查询条件组合成字符串再计算md5，作为缓存的key，优点是简单灵活，缺点是浪费一部分缓存\n\n这个有创意","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420929,"discussion_content":"必须的，我也能学到很多😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532255241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16787,"user_name":"bubble","can_delete":false,"product_type":"c1","uid":1103280,"ip_address":"","ucode":"557121A7F16CE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/b0/b560e561.jpg","comment_is_top":false,"comment_ctime":1532186068,"is_pvip":false,"replies":[{"id":5840,"content":"雪崩是缓存读不到，大家都去读存储，你的场景是读取不到key就返回key1，因此不会雪崩","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532255378,"ip_address":"","comment_id":16787,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"我们的系统就出现过类似的问题，开始的时候没有缓存，每次做活动访问量大的时候就会导致反应特别慢。后来通过加redis缓存解决了问题。\n\n对于缓存雪崩问题，我们采取了双key策略：要缓存的key过期时间是t，key1没有过期时间。每次缓存读取不到key时就返回key1的内容，然后触发一个事件。这个事件会同时更新key和key1。\n\n对以上疑问，既然是雪崩了，多少个key也没用吧！雪崩在此作何理解？？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420926,"discussion_content":"雪崩是缓存读不到，大家都去读存储，你的场景是读取不到key就返回key1，因此不会雪崩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532255378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11950,"user_name":"echo＿陈","can_delete":false,"product_type":"c1","uid":1080794,"ip_address":"","ucode":"EFAEADA8A05906","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/da/780f149e.jpg","comment_is_top":false,"comment_ctime":1528455017,"is_pvip":false,"replies":[{"id":3934,"content":"这种是正常的，只有短时间内大量数据都没法命中缓存才算缓存穿透","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528503515,"ip_address":"","comment_id":11950,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"关于缓存穿透，比如，对用户缓存，因为每个用户的访问时间是均匀分布的……也不会同时缓存失效……这时候缓存穿透问题不大吧","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419058,"discussion_content":"这种是正常的，只有短时间内大量数据都没法命中缓存才算缓存穿透","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528503515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143214,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571650150,"is_pvip":false,"replies":[{"id":55446,"content":"是的，有一个更新后，其它的副本也更新了","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1571747093,"ip_address":"","comment_id":143214,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"关于缓存热点的解决方案有一个疑问：如果读取的谋一份缓存过期了，那就会穿透到数据库查询，然后写进入缓存，并设置一个随机的过期时间吗？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471425,"discussion_content":"是的，有一个更新后，其它的副本也更新了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571747093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78727,"user_name":"@@fighting","can_delete":false,"product_type":"c1","uid":1236394,"ip_address":"","ucode":"7235C1E74549AE","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/aa/859544fd.jpg","comment_is_top":false,"comment_ctime":1553224911,"is_pvip":false,"replies":[{"id":28701,"content":"这个就是简单的商品数据缓存，和分页关系不大","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1553298702,"ip_address":"","comment_id":78727,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"关于分页的存储我看到过的一个缓存方案是：不缓存整个页面，而是将页面的每一条商品单独缓存，第二次请求数据库的话只请求id，然后根据id去缓存拿具体数据；这样虽然多了好多的内存访问io，但是减少了内存的消耗","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444211,"discussion_content":"这个就是简单的商品数据缓存，和分页关系不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553298702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42342,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1112307,"ip_address":"","ucode":"19ACFC78CFD80F","user_header":"","comment_is_top":false,"comment_ctime":1542941519,"is_pvip":false,"replies":[{"id":15165,"content":"缓存雪崩部分就讲了怎么更新啊，其它的更新没什么复杂的吧😄","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1542956431,"ip_address":"","comment_id":42342,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"怎么没有讲讲缓存更新的问题，我觉得这也挺麻烦的","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430059,"discussion_content":"缓存雪崩部分就讲了怎么更新啊，其它的更新没什么复杂的吧😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542956431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39033,"user_name":"allan","can_delete":false,"product_type":"c1","uid":1142819,"ip_address":"","ucode":"CA0BE868AA9FF5","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/23/972dcd30.jpg","comment_is_top":false,"comment_ctime":1542175948,"is_pvip":false,"replies":[{"id":13953,"content":"后面有很多章节讲这部分","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1542195018,"ip_address":"","comment_id":39033,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"想问下老师，您对分布式和集群的理解？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428885,"discussion_content":"后面有很多章节讲这部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542195018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24643,"user_name":"杨陆伟","can_delete":false,"product_type":"c1","uid":1108457,"ip_address":"","ucode":"3BC968447406EB","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/e9/1f95e422.jpg","comment_is_top":false,"comment_ctime":1537178590,"is_pvip":false,"replies":[{"id":9262,"content":"查询结果不会影响key呢，至于说缓存不实时，这个没法避免，电商的商品缓存问题不大","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1537342362,"ip_address":"","comment_id":24643,"utype":1}],"discussion_count":1,"race_medal":4,"score":11,"product_id":100006601,"comment_content":"将查询条件组合成字符串再计算md5，作为缓存的key。======&#47;&#47;请问这种方式有什么作用？例如查询出的商品变多或变少了，这个key马上就失效了","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424072,"discussion_content":"查询结果不会影响key呢，至于说缓存不实时，这个没法避免，电商的商品缓存问题不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537342362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16793,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1532190923,"is_pvip":false,"replies":[{"id":5944,"content":"可以测试验证一下，我没有详细研究过","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532425319,"ip_address":"","comment_id":16793,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"华哥，请问下redis由于是单线程模型他的setnx分布式锁在高并发场景下会不会有性能问题？另外他的队列结构在redis多节点集群环境下是不是会有数据不一致问题？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420930,"discussion_content":"可以测试验证一下，我没有详细研究过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532425319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16792,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1532190092,"is_pvip":false,"replies":[{"id":5838,"content":"必须的，我也能学到很多😀","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532255241,"ip_address":"","comment_id":16792,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"看评论也能科普不少好东西啊","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420929,"discussion_content":"必须的，我也能学到很多😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532255241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16788,"user_name":"bubble","can_delete":false,"product_type":"c1","uid":1103280,"ip_address":"","ucode":"557121A7F16CE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/b0/b560e561.jpg","comment_is_top":false,"comment_ctime":1532186645,"is_pvip":false,"replies":[{"id":5839,"content":"黑猫白猫理论😄","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532255296,"ip_address":"","comment_id":16788,"utype":1}],"discussion_count":2,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"我们用过另外一种方式：将查询条件组合成字符串再计算md5，作为缓存的key，优点是简单灵活，缺点是浪费一部分缓存\n\n这个有创意","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420927,"discussion_content":"黑猫白猫理论😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532255296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054154,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/ca/bf3fb655.jpg","nickname":"Lee","note":"","ucode":"E9385622CA7ACB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651997,"discussion_content":"为什么说会浪费一部分缓存？没理解什么意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728014957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16787,"user_name":"bubble","can_delete":false,"product_type":"c1","uid":1103280,"ip_address":"","ucode":"557121A7F16CE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/b0/b560e561.jpg","comment_is_top":false,"comment_ctime":1532186068,"is_pvip":false,"replies":[{"id":5840,"content":"雪崩是缓存读不到，大家都去读存储，你的场景是读取不到key就返回key1，因此不会雪崩","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1532255378,"ip_address":"","comment_id":16787,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"我们的系统就出现过类似的问题，开始的时候没有缓存，每次做活动访问量大的时候就会导致反应特别慢。后来通过加redis缓存解决了问题。\n\n对于缓存雪崩问题，我们采取了双key策略：要缓存的key过期时间是t，key1没有过期时间。每次缓存读取不到key时就返回key1的内容，然后触发一个事件。这个事件会同时更新key和key1。\n\n对以上疑问，既然是雪崩了，多少个key也没用吧！雪崩在此作何理解？？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420927,"discussion_content":"黑猫白猫理论😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532255296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054154,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/ca/bf3fb655.jpg","nickname":"Lee","note":"","ucode":"E9385622CA7ACB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651997,"discussion_content":"为什么说会浪费一部分缓存？没理解什么意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728014957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11950,"user_name":"echo＿陈","can_delete":false,"product_type":"c1","uid":1080794,"ip_address":"","ucode":"EFAEADA8A05906","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/da/780f149e.jpg","comment_is_top":false,"comment_ctime":1528455017,"is_pvip":false,"replies":[{"id":3934,"content":"这种是正常的，只有短时间内大量数据都没法命中缓存才算缓存穿透","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528503515,"ip_address":"","comment_id":11950,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100006601,"comment_content":"关于缓存穿透，比如，对用户缓存，因为每个用户的访问时间是均匀分布的……也不会同时缓存失效……这时候缓存穿透问题不大吧","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420926,"discussion_content":"雪崩是缓存读不到，大家都去读存储，你的场景是读取不到key就返回key1，因此不会雪崩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532255378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11765,"user_name":"Sonny721","can_delete":false,"product_type":"c1","uid":1104291,"ip_address":"","ucode":"C95DD306BFBE54","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a3/2856b5b5.jpg","comment_is_top":false,"comment_ctime":1528340899,"is_pvip":false,"replies":[{"id":3825,"content":"没明白，直接查key1为何不行？","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528373440,"ip_address":"","comment_id":11765,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"在以往的开发中遇到过这样的问题，某个数据做了缓存，key为k1，在后面的业务中发现也需要这个缓存数据，但是查询的key不是key1，而是key2，这种情况有什么好的解决方案么，曾经用过的方案是把key1与key2的对应关系也做了缓存，根据对应关系去缓存中查询想要的数据。类似的业务需求，有好的解决方案么？","like_count":0},{"had_liked":false,"id":11635,"user_name":"正直D令狐勇","can_delete":false,"product_type":"c1","uid":1079581,"ip_address":"","ucode":"8FFE3489C1C04C","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/1d/375d28c0.jpg","comment_is_top":false,"comment_ctime":1528254082,"is_pvip":false,"replies":[{"id":3766,"content":"你是说爬虫的案例是缓存雪崩？我理解不是的，雪崩是由于缓存不存在且高并发访问，穿透是由于缓存不存在或生成缓存需要耗费大量资源","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528269325,"ip_address":"","comment_id":11635,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"老师这里把缓存击穿和缓存雪崩合并在一起讲了。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418933,"discussion_content":"你是说爬虫的案例是缓存雪崩？我理解不是的，雪崩是由于缓存不存在且高并发访问，穿透是由于缓存不存在或生成缓存需要耗费大量资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528269325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11534,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1528183431,"is_pvip":false,"replies":[{"id":3678,"content":"这里主要的问题是缓存使用不当，正常缓存返回null后应该去存储查","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528184688,"ip_address":"","comment_id":11534,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"公司业务部署在某公司云上，有一次memcache故障，导致返回的数据总是为null。刚好系统设计是数据都先加载到缓存的，于是处理逻辑就认为系统里都没有数据，导致出现很大的数据问题。后来我们重新编写逻辑，不完全信任缓存进程，把一部分使用量较高的，数据不大的数据用JVM本地进行缓存。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418933,"discussion_content":"你是说爬虫的案例是缓存雪崩？我理解不是的，雪崩是由于缓存不存在且高并发访问，穿透是由于缓存不存在或生成缓存需要耗费大量资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528269325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11526,"user_name":"十七","can_delete":false,"product_type":"c1","uid":1103979,"ip_address":"","ucode":"2AB53F785C3EA5","user_header":"","comment_is_top":false,"comment_ctime":1528175913,"is_pvip":false,"replies":[{"id":3680,"content":"之前看到有证券公司将依赖redis+lua的计算改为go去计算，redis只做存储","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528184821,"ip_address":"","comment_id":11526,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"现在项目重度依赖redis做统计计算，在请求量非常大的情况下，达不到低延时要求，不知道行业内有没有性能更好的实现方案","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418882,"discussion_content":"之前看到有证券公司将依赖redis+lua的计算改为go去计算，redis只做存储","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528184821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11520,"user_name":"李唐","can_delete":false,"product_type":"c1","uid":1107863,"ip_address":"","ucode":"5491425C5C959D","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/97/c9cc72f0.jpg","comment_is_top":false,"comment_ctime":1528173123,"is_pvip":false,"replies":[{"id":3681,"content":"否决的理由是什么？如果评估缓存穿透的可能性很低，不做确实也可以","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528184886,"ip_address":"","comment_id":11520,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"曾经设计过某安卓游戏平台，前台采用redis+solr+mysql多级缓存方案，考虑过缓存穿透，后来被新来的架构师否决了。个人感觉，业务架构重于技术架构","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418879,"discussion_content":"否决的理由是什么？如果评估缓存穿透的可能性很低，不做确实也可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528184886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11516,"user_name":"yushing","can_delete":false,"product_type":"c1","uid":1108112,"ip_address":"","ucode":"244C58F218D586","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/90/d63f8347.jpg","comment_is_top":false,"comment_ctime":1528170369,"is_pvip":false,"replies":[{"id":3682,"content":"1. 监控数据库的各项指标，发现逐步变慢后看看是不是爬虫，只要系统还撑得住就让它爬，撑不住就不让它爬\n2. 缓存是为了解决性能问题，实时性要求很高就不能用缓存了，或者要做缓存及时更新机制","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185034,"ip_address":"","comment_id":11516,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"1、文本提到可以监控爬虫，发现问题后及时处理，请问具体是怎么处理呢？\n2、分页数据有很多排序规则，而且可能在某个时间点要上架新商品，就会有实时性的要求，请问这样使用分页缓存真的合适么？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418879,"discussion_content":"否决的理由是什么？如果评估缓存穿透的可能性很低，不做确实也可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528184886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11513,"user_name":"yushing","can_delete":false,"product_type":"c1","uid":1108112,"ip_address":"","ucode":"244C58F218D586","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/90/d63f8347.jpg","comment_is_top":false,"comment_ctime":1528167612,"is_pvip":false,"replies":[{"id":3685,"content":"我觉得这样设计没什么问题呀，除非你们的list很大，如果list很大，分段缓存就可以","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185700,"ip_address":"","comment_id":11513,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"业务系统中有使用reids存储商品list列表，每次添加、更新商品时，跟该商品有关的列表缓存都要跟着刷新；后来改成列表缓存中只保存商品id，查询时再关联商品信息，但这样只是在更新商品时不用更新商品列表缓存，在商品有添加、删除操作时，列表缓存更新的问题依然存在，请问对列表缓存的更新有什么好的方式呢？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418876,"discussion_content":"1. 监控数据库的各项指标，发现逐步变慢后看看是不是爬虫，只要系统还撑得住就让它爬，撑不住就不让它爬\n2. 缓存是为了解决性能问题，实时性要求很高就不能用缓存了，或者要做缓存及时更新机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11475,"user_name":"李志博","can_delete":false,"product_type":"c1","uid":1009109,"ip_address":"","ucode":"F3C72573B3C112","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/d5/88beb15a.jpg","comment_is_top":false,"comment_ctime":1528161331,"is_pvip":false,"replies":[{"id":3696,"content":"最好优化缓存设计，这么大的缓存，带宽都很浪费","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186573,"ip_address":"","comment_id":11475,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"最近有一个redis 存储数据过大的问题，字符串key ，大小2.5mb导致压测的时候发现带宽不够了，我优化的方式类似于后台更新的方式，启动的时候查一次，放到一个concurrent hash map 上，然后写个定时器每隔半小时更新一次，业务线程直接读map 里的数据，如果读不到，说明是新增的数据，我搞了个jdk 自带sync开头的queue ，先通过offer 往queue 里添加一个new object 触发一个异步线程更新缓存，同时业务线程在根据id 查单条，我还利用开关的观察者机制，留了个后门，可以通过人工方式触发缓存更新","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418857,"discussion_content":"最好优化缓存设计，这么大的缓存，带宽都很浪费","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14998,"user_name":"家榆","can_delete":false,"product_type":"c1","uid":1030050,"ip_address":"","ucode":"6D62685C80DD7C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b7/a2/0ce9b8df.jpg","comment_is_top":false,"comment_ctime":1530794891,"is_pvip":false,"replies":null,"discussion_count":5,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"我是实现了个框架:https:&#47;&#47;github.com&#47;qiujiayu&#47;AutoLoadCache，用于解决一下问题:\n1. 缓存操作与业务代码耦合问题；\n2. 缓存穿透问题；\n3. 异步在缓存快要过期时，异步刷新缓存；\n4. 使用“拿来主义机制”，降低回源并发量；","like_count":43,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418857,"discussion_content":"最好优化缓存设计，这么大的缓存，带宽都很浪费","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528186573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128714,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566953929,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"我们的服务严重依赖缓存，正好顺便回顾一下：\n1：使用缓存的目的？\n1-1：加快速度，提升性能\n\n\n2：刷新缓存的方式？\n2-1：定时任务，每天一刷\n2-2：手动触发，随时随地\n2-3：为防止数据量大有间隙，先增后删\n2-4：为防止数据量大任务多，采用分布式刷新\n2-5：刷入缓存的信息基本会经过加工处理\n2-6：使用缓存时，会填充本地缓存\n2-7：可控制本地缓存是否失效\n\n3：使用缓存的方式？\n3-1：字符串类型使用最多,有时也用字典和列表\n3-2：计数\n3-3：共享回话信息\n3-4：队列\n3-5：分布式锁\n3-6：如果缓存没有，我们不会读库，怕库扛不住\n\n4：使用缓存遇到的问题？\n4-1：重启服务导致缓存读不到，可用率下降\n4-2：缓存集群扩缩容缓存读不到，可用率下降\n4-3：大value，导致性能下降\n4-4：大value，导致带宽打满\n4-5：公用机器别的服务打满连接跟踪表，导致不能新建链接\n4-6：之前还有先删后插，数据量大时有间隙，读不到缓存，可用率下降\n4-7：代码逻辑存在问题，导致缓存错乱引起的问题\n4-8：昨晚遇到一个，写本地缓存的bug，控制不住缓本地存啦，导致业务异常\n\n5：缓存集群的维护？\n维护的事比较弱，公司有专门的基础架构部，专门提供各种缓存、MQ、RPC、数据库中间件、容器扩缩容、监控等的团队，业务开发主要以使用为主，出问题可以一起排查。\n这种分工，好处是专业的人负责专业的事，不过也会让业务开发技术实力更弱，一些基础服务大概知道原理，实现细节不太深入。\n当然，学习是自己的事情，自己最好要积极主动。","like_count":14},{"had_liked":false,"id":11765,"user_name":"Sonny721","can_delete":false,"product_type":"c1","uid":1104291,"ip_address":"","ucode":"C95DD306BFBE54","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a3/2856b5b5.jpg","comment_is_top":false,"comment_ctime":1528340899,"is_pvip":false,"replies":[{"id":3825,"content":"没明白，直接查key1为何不行？","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528373440,"ip_address":"","comment_id":11765,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"在以往的开发中遇到过这样的问题，某个数据做了缓存，key为k1，在后面的业务中发现也需要这个缓存数据，但是查询的key不是key1，而是key2，这种情况有什么好的解决方案么，曾经用过的方案是把key1与key2的对应关系也做了缓存，根据对应关系去缓存中查询想要的数据。类似的业务需求，有好的解决方案么？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418989,"discussion_content":"没明白，直接查key1为何不行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528373440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11635,"user_name":"正直D令狐勇","can_delete":false,"product_type":"c1","uid":1079581,"ip_address":"","ucode":"8FFE3489C1C04C","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/1d/375d28c0.jpg","comment_is_top":false,"comment_ctime":1528254082,"is_pvip":false,"replies":[{"id":3766,"content":"你是说爬虫的案例是缓存雪崩？我理解不是的，雪崩是由于缓存不存在且高并发访问，穿透是由于缓存不存在或生成缓存需要耗费大量资源","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528269325,"ip_address":"","comment_id":11635,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"老师这里把缓存击穿和缓存雪崩合并在一起讲了。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418989,"discussion_content":"没明白，直接查key1为何不行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528373440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11534,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1528183431,"is_pvip":false,"replies":[{"id":3678,"content":"这里主要的问题是缓存使用不当，正常缓存返回null后应该去存储查","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528184688,"ip_address":"","comment_id":11534,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"公司业务部署在某公司云上，有一次memcache故障，导致返回的数据总是为null。刚好系统设计是数据都先加载到缓存的，于是处理逻辑就认为系统里都没有数据，导致出现很大的数据问题。后来我们重新编写逻辑，不完全信任缓存进程，把一部分使用量较高的，数据不大的数据用JVM本地进行缓存。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418886,"discussion_content":"这里主要的问题是缓存使用不当，正常缓存返回null后应该去存储查","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528184688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11526,"user_name":"十七","can_delete":false,"product_type":"c1","uid":1103979,"ip_address":"","ucode":"2AB53F785C3EA5","user_header":"","comment_is_top":false,"comment_ctime":1528175913,"is_pvip":false,"replies":[{"id":3680,"content":"之前看到有证券公司将依赖redis+lua的计算改为go去计算，redis只做存储","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528184821,"ip_address":"","comment_id":11526,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"现在项目重度依赖redis做统计计算，在请求量非常大的情况下，达不到低延时要求，不知道行业内有没有性能更好的实现方案","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418886,"discussion_content":"这里主要的问题是缓存使用不当，正常缓存返回null后应该去存储查","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528184688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11520,"user_name":"李唐","can_delete":false,"product_type":"c1","uid":1107863,"ip_address":"","ucode":"5491425C5C959D","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/97/c9cc72f0.jpg","comment_is_top":false,"comment_ctime":1528173123,"is_pvip":false,"replies":[{"id":3681,"content":"否决的理由是什么？如果评估缓存穿透的可能性很低，不做确实也可以","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528184886,"ip_address":"","comment_id":11520,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"曾经设计过某安卓游戏平台，前台采用redis+solr+mysql多级缓存方案，考虑过缓存穿透，后来被新来的架构师否决了。个人感觉，业务架构重于技术架构","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418882,"discussion_content":"之前看到有证券公司将依赖redis+lua的计算改为go去计算，redis只做存储","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528184821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11516,"user_name":"yushing","can_delete":false,"product_type":"c1","uid":1108112,"ip_address":"","ucode":"244C58F218D586","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/90/d63f8347.jpg","comment_is_top":false,"comment_ctime":1528170369,"is_pvip":false,"replies":[{"id":3682,"content":"1. 监控数据库的各项指标，发现逐步变慢后看看是不是爬虫，只要系统还撑得住就让它爬，撑不住就不让它爬\n2. 缓存是为了解决性能问题，实时性要求很高就不能用缓存了，或者要做缓存及时更新机制","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185034,"ip_address":"","comment_id":11516,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"1、文本提到可以监控爬虫，发现问题后及时处理，请问具体是怎么处理呢？\n2、分页数据有很多排序规则，而且可能在某个时间点要上架新商品，就会有实时性的要求，请问这样使用分页缓存真的合适么？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418876,"discussion_content":"1. 监控数据库的各项指标，发现逐步变慢后看看是不是爬虫，只要系统还撑得住就让它爬，撑不住就不让它爬\n2. 缓存是为了解决性能问题，实时性要求很高就不能用缓存了，或者要做缓存及时更新机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11513,"user_name":"yushing","can_delete":false,"product_type":"c1","uid":1108112,"ip_address":"","ucode":"244C58F218D586","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/90/d63f8347.jpg","comment_is_top":false,"comment_ctime":1528167612,"is_pvip":false,"replies":[{"id":3685,"content":"我觉得这样设计没什么问题呀，除非你们的list很大，如果list很大，分段缓存就可以","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528185700,"ip_address":"","comment_id":11513,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"业务系统中有使用reids存储商品list列表，每次添加、更新商品时，跟该商品有关的列表缓存都要跟着刷新；后来改成列表缓存中只保存商品id，查询时再关联商品信息，但这样只是在更新商品时不用更新商品列表缓存，在商品有添加、删除操作时，列表缓存更新的问题依然存在，请问对列表缓存的更新有什么好的方式呢？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418873,"discussion_content":"我觉得这样设计没什么问题呀，除非你们的list很大，如果list很大，分段缓存就可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11475,"user_name":"李志博","can_delete":false,"product_type":"c1","uid":1009109,"ip_address":"","ucode":"F3C72573B3C112","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/d5/88beb15a.jpg","comment_is_top":false,"comment_ctime":1528161331,"is_pvip":false,"replies":[{"id":3696,"content":"最好优化缓存设计，这么大的缓存，带宽都很浪费","user_name":"作者回复","user_name_real":"华仔","uid":1098920,"ctime":1528186573,"ip_address":"","comment_id":11475,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"最近有一个redis 存储数据过大的问题，字符串key ，大小2.5mb导致压测的时候发现带宽不够了，我优化的方式类似于后台更新的方式，启动的时候查一次，放到一个concurrent hash map 上，然后写个定时器每隔半小时更新一次，业务线程直接读map 里的数据，如果读不到，说明是新增的数据，我搞了个jdk 自带sync开头的queue ，先通过offer 往queue 里添加一个new object 触发一个异步线程更新缓存，同时业务线程在根据id 查单条，我还利用开关的观察者机制，留了个后门，可以通过人工方式触发缓存更新","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418873,"discussion_content":"我觉得这样设计没什么问题呀，除非你们的list很大，如果list很大，分段缓存就可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528185700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14998,"user_name":"家榆","can_delete":false,"product_type":"c1","uid":1030050,"ip_address":"","ucode":"6D62685C80DD7C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b7/a2/0ce9b8df.jpg","comment_is_top":false,"comment_ctime":1530794891,"is_pvip":false,"replies":null,"discussion_count":5,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"我是实现了个框架:https:&#47;&#47;github.com&#47;qiujiayu&#47;AutoLoadCache，用于解决一下问题:\n1. 缓存操作与业务代码耦合问题；\n2. 缓存穿透问题；\n3. 异步在缓存快要过期时，异步刷新缓存；\n4. 使用“拿来主义机制”，降低回源并发量；","like_count":43,"discussions":[{"author":{"id":1022487,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9a/17/45d50064.jpg","nickname":"初见","note":"","ucode":"808185EBE38A6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541062,"discussion_content":"哈哈哈，遇到真人了，我提了issue，你让我去实现提PR，然而我996，有时候周天还得加班，实在没时间","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640245082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297142,"discussion_content":"对于初次使用缓存的系统，穿透是必然发生的吧？\n有什么好的策略来解决这种场景下的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596785696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1160192,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b4/00/661fb98d.jpg","nickname":"追忆似水年华","note":"","ucode":"C1D7C0DD7E7411","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310159,"discussion_content":"文章里说的缓存预热？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601649303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297142,"ip_address":"","group_id":0},"score":310159,"extra":""}]},{"author":{"id":1798979,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/73/43/ae139b1f.jpg","nickname":"博","note":"","ucode":"F7CA69FF5D09BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229439,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586652583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193711,"avatar":"https://static001.geekbang.org/account/avatar/00/12/36/ef/83c2a743.jpg","nickname":"悠南","note":"","ucode":"333665DB7CFDD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1975,"discussion_content":"我用过你这个。。。遇到真人了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563158305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128714,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566953929,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100006601,"comment_content":"我们的服务严重依赖缓存，正好顺便回顾一下：\n1：使用缓存的目的？\n1-1：加快速度，提升性能\n\n\n2：刷新缓存的方式？\n2-1：定时任务，每天一刷\n2-2：手动触发，随时随地\n2-3：为防止数据量大有间隙，先增后删\n2-4：为防止数据量大任务多，采用分布式刷新\n2-5：刷入缓存的信息基本会经过加工处理\n2-6：使用缓存时，会填充本地缓存\n2-7：可控制本地缓存是否失效\n\n3：使用缓存的方式？\n3-1：字符串类型使用最多,有时也用字典和列表\n3-2：计数\n3-3：共享回话信息\n3-4：队列\n3-5：分布式锁\n3-6：如果缓存没有，我们不会读库，怕库扛不住\n\n4：使用缓存遇到的问题？\n4-1：重启服务导致缓存读不到，可用率下降\n4-2：缓存集群扩缩容缓存读不到，可用率下降\n4-3：大value，导致性能下降\n4-4：大value，导致带宽打满\n4-5：公用机器别的服务打满连接跟踪表，导致不能新建链接\n4-6：之前还有先删后插，数据量大时有间隙，读不到缓存，可用率下降\n4-7：代码逻辑存在问题，导致缓存错乱引起的问题\n4-8：昨晚遇到一个，写本地缓存的bug，控制不住缓本地存啦，导致业务异常\n\n5：缓存集群的维护？\n维护的事比较弱，公司有专门的基础架构部，专门提供各种缓存、MQ、RPC、数据库中间件、容器扩缩容、监控等的团队，业务开发主要以使用为主，出问题可以一起排查。\n这种分工，好处是专业的人负责专业的事，不过也会让业务开发技术实力更弱，一些基础服务大概知道原理，实现细节不太深入。\n当然，学习是自己的事情，自己最好要积极主动。","like_count":14,"discussions":[{"author":{"id":1022487,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9a/17/45d50064.jpg","nickname":"初见","note":"","ucode":"808185EBE38A6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541062,"discussion_content":"哈哈哈，遇到真人了，我提了issue，你让我去实现提PR，然而我996，有时候周天还得加班，实在没时间","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640245082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297142,"discussion_content":"对于初次使用缓存的系统，穿透是必然发生的吧？\n有什么好的策略来解决这种场景下的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596785696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1160192,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b4/00/661fb98d.jpg","nickname":"追忆似水年华","note":"","ucode":"C1D7C0DD7E7411","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310159,"discussion_content":"文章里说的缓存预热？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601649303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297142,"ip_address":"","group_id":0},"score":310159,"extra":""}]},{"author":{"id":1798979,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/73/43/ae139b1f.jpg","nickname":"博","note":"","ucode":"F7CA69FF5D09BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229439,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586652583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193711,"avatar":"https://static001.geekbang.org/account/avatar/00/12/36/ef/83c2a743.jpg","nickname":"悠南","note":"","ucode":"333665DB7CFDD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1975,"discussion_content":"我用过你这个。。。遇到真人了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563158305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11437,"user_name":"Geek_zij8s5","can_delete":false,"product_type":"c1","uid":1056161,"ip_address":"","ucode":"7A68590474AEAE","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/a1/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1528153971,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"对缓存的key也需要进行valid，避免无效的key查询缓存","like_count":8},{"had_liked":false,"id":11627,"user_name":"🔰夏天的味道","can_delete":false,"product_type":"c1","uid":1069105,"ip_address":"","ucode":"3CA1DE1ADC95F0","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/31/98e2c8e9.jpg","comment_is_top":false,"comment_ctime":1528251364,"is_pvip":false,"replies":null,"discussion_count":3,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"线上遇到的一个错误：业务查询的结果序列化后放到redis，下次从redis取出来时报错。原来是结果类虽然实现了Serializable接口，但是没有重写serialVersionUID，导致不能成功反序列化。","like_count":7},{"had_liked":false,"id":11497,"user_name":"sunny","can_delete":false,"product_type":"c1","uid":1107941,"ip_address":"","ucode":"51E95362C053F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/e5/fbf3fcd8.jpg","comment_is_top":false,"comment_ctime":1528162896,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"之前系统用阿里云memcached.有一段时间缓存总是失效。后来发现随着业务的增长，缓存的值越来越多。同一个value下的值过多会导致缓存系统存储失效。进而导致了文中提到的缓存血崩的情况。后来限制了缓存内容大小。解决了问题。","like_count":4},{"had_liked":false,"id":267040,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/d1ab239e.jpg","comment_is_top":false,"comment_ctime":1607579783,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"要点总结：\n● 缓存穿透\n\t○ 访问的数据在DB和cache都不存在。\n\t\t■ 这种情况下cache访问不到，查DB，DB也没有所有不缓存。形成了一个恶心循环，每次都要穿透到DB，导致DB访问压力。办法就是：给访问的Key设置缓存一个默认值。这样就不会再查DB了。\n\t○ DB中虽然存在数据，但放入Cache‘需要很久时间。\n\t\t■ 因为查DB得到的数据放入Cache需要很长时间，在这段时间内都会有大量请求穿透到DB。解决办法就是优化程序加快缓存速度。\n\n● 缓存雪崩\n        指的是缓存失效后引起的系统性能急剧下降的情况。从小范围引起大范围的性能问题。\n比如分布式集群环境中，当缓存失效之后，集群中每台机器都会受到大量请求读取缓存失败，那么这些请求就会去读取DB来生成缓存，导致数据库压力。\n解决办法：\n\t○ 更新锁\n\t\t■ 分布式集群系统中要保证每台业务机器只有一个业务线程能去生成缓存。同时利用分布式锁🔐机制来保证集群所有业务机器中也只有一台机器能够生成缓存，避免因为集群规模太大的时候每台机器都更新缓存导致的雪崩。\n\t○ 后台线程定时更新缓存\n\t\t■ 缓存本身设置为永久，由后台线程定时更新缓存。这种方案可能出现缓存系统由于内存不够踢到一部分缓存数据。那么就会有一些请求读取不到缓存导致看起来数据丢失了。所以后台线程可以多一个职责，即定时读取缓存，发现缓存被踢立即更新缓存。定时间隔不能太长，不然缓存踢掉之后太久不能被读取到，导致用户体验变差。\n","like_count":3},{"had_liked":false,"id":168688,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1578140782,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":13,"product_id":100006601,"comment_content":"在设计缓存架构的同时，要考虑下面几件事情：\n1. 缓存穿透\n2. 缓存血崩\n3. 缓存热点\n\n缓存穿透是指业务没有在缓存中找到想要的数据，从而去存储系统中重新查询。\n缓存血崩是指在缓存过期但还没有刷新之前，业务请求数据时，因为缓存中没有，所以每个线程都查询db，从而拖垮整个系统。\n缓存热点是针对热点进行单独的缓存管理。注意不要把所有缓存的过期时间设置成相同的，否则容易引发系统血崩。","like_count":1},{"had_liked":false,"id":124688,"user_name":"junshuaizhang","can_delete":false,"product_type":"c1","uid":1101502,"ip_address":"","ucode":"5734A9BEA03149","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/be/5cf3f1a0.jpg","comment_is_top":false,"comment_ctime":1565944679,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"评论区更精彩呀","like_count":1},{"had_liked":false,"id":21147,"user_name":"lawlielt","can_delete":false,"product_type":"c1","uid":1058095,"ip_address":"","ucode":"709728A82C0667","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/2f/3266c0da.jpg","comment_is_top":false,"comment_ctime":1534939503,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"我们也是双key，一个存数据不过期，另一个存过期时间。过期时间的key用作多线程锁。","like_count":1},{"had_liked":false,"id":11914,"user_name":"bigticket","can_delete":false,"product_type":"c1","uid":1109619,"ip_address":"","ucode":"6377FEC1F7E323","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/73/122500d0.jpg","comment_is_top":false,"comment_ctime":1528431602,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"为应对读写不平衡，高并发读取的业务场景，加入缓存机制；缓存又涉及到缓存穿透、缓存雪崩等问题，需要设计合理的过期时间，分页读取等","like_count":1},{"had_liked":false,"id":352698,"user_name":"杨恒","can_delete":false,"product_type":"c1","uid":3066545,"ip_address":"","ucode":"057CCB97B56740","user_header":"https://static001.geekbang.org/account/avatar/00/2e/ca/b1/044d3e98.jpg","comment_is_top":false,"comment_ctime":1658888556,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"建议参考HTTP 协议中描述的cache。","like_count":0},{"had_liked":false,"id":352048,"user_name":"湖","can_delete":false,"product_type":"c1","uid":1235649,"ip_address":"","ucode":"292B05A8EEEEB7","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/c1/b438893e.jpg","comment_is_top":false,"comment_ctime":1658365304,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"可以参考下开源项目layering-cache的实现","like_count":0},{"had_liked":false,"id":11437,"user_name":"Geek_zij8s5","can_delete":false,"product_type":"c1","uid":1056161,"ip_address":"","ucode":"7A68590474AEAE","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/a1/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1528153971,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"对缓存的key也需要进行valid，避免无效的key查询缓存","like_count":8},{"had_liked":false,"id":11627,"user_name":"🔰夏天的味道","can_delete":false,"product_type":"c1","uid":1069105,"ip_address":"","ucode":"3CA1DE1ADC95F0","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/31/98e2c8e9.jpg","comment_is_top":false,"comment_ctime":1528251364,"is_pvip":false,"replies":null,"discussion_count":3,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"线上遇到的一个错误：业务查询的结果序列化后放到redis，下次从redis取出来时报错。原来是结果类虽然实现了Serializable接口，但是没有重写serialVersionUID，导致不能成功反序列化。","like_count":7,"discussions":[{"author":{"id":1193755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","nickname":"拿笔小星","note":"","ucode":"D3D8F6A959710D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604636,"discussion_content":"我们也遇到过，团队要求，缓存对象有变更时候，要升级缓存key。我们所有缓存都会带个版本号。当缓存对象结构有变更时候，要求升级版本号。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676389694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1412994,"avatar":"https://static001.geekbang.org/account/avatar/00/15/8f/82/374f43a1.jpg","nickname":"假装自己不胖","note":"","ucode":"308F1BAA96CDA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288946,"discussion_content":"序列化的结果存redis,其实我觉得用json化之后存会不会更直观些,那就无需序列化了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593939753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1367591,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo6qUrJUgVNIMeWy4ffwR7AiahZSuiaOSGeicwSydRm0s5WUwzqxTib8hCuf6ticP8sKmabTf9WSgYHRxw/132","nickname":"李卫卫","note":"","ucode":"F89946C5BF9EA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286349,"discussion_content":"和你序列化方式有关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593143084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11497,"user_name":"sunny","can_delete":false,"product_type":"c1","uid":1107941,"ip_address":"","ucode":"51E95362C053F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/e5/fbf3fcd8.jpg","comment_is_top":false,"comment_ctime":1528162896,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"之前系统用阿里云memcached.有一段时间缓存总是失效。后来发现随着业务的增长，缓存的值越来越多。同一个value下的值过多会导致缓存系统存储失效。进而导致了文中提到的缓存血崩的情况。后来限制了缓存内容大小。解决了问题。","like_count":4},{"had_liked":false,"id":267040,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/d1ab239e.jpg","comment_is_top":false,"comment_ctime":1607579783,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"要点总结：\n● 缓存穿透\n\t○ 访问的数据在DB和cache都不存在。\n\t\t■ 这种情况下cache访问不到，查DB，DB也没有所有不缓存。形成了一个恶心循环，每次都要穿透到DB，导致DB访问压力。办法就是：给访问的Key设置缓存一个默认值。这样就不会再查DB了。\n\t○ DB中虽然存在数据，但放入Cache‘需要很久时间。\n\t\t■ 因为查DB得到的数据放入Cache需要很长时间，在这段时间内都会有大量请求穿透到DB。解决办法就是优化程序加快缓存速度。\n\n● 缓存雪崩\n        指的是缓存失效后引起的系统性能急剧下降的情况。从小范围引起大范围的性能问题。\n比如分布式集群环境中，当缓存失效之后，集群中每台机器都会受到大量请求读取缓存失败，那么这些请求就会去读取DB来生成缓存，导致数据库压力。\n解决办法：\n\t○ 更新锁\n\t\t■ 分布式集群系统中要保证每台业务机器只有一个业务线程能去生成缓存。同时利用分布式锁🔐机制来保证集群所有业务机器中也只有一台机器能够生成缓存，避免因为集群规模太大的时候每台机器都更新缓存导致的雪崩。\n\t○ 后台线程定时更新缓存\n\t\t■ 缓存本身设置为永久，由后台线程定时更新缓存。这种方案可能出现缓存系统由于内存不够踢到一部分缓存数据。那么就会有一些请求读取不到缓存导致看起来数据丢失了。所以后台线程可以多一个职责，即定时读取缓存，发现缓存被踢立即更新缓存。定时间隔不能太长，不然缓存踢掉之后太久不能被读取到，导致用户体验变差。\n","like_count":3},{"had_liked":false,"id":168688,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1578140782,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":13,"product_id":100006601,"comment_content":"在设计缓存架构的同时，要考虑下面几件事情：\n1. 缓存穿透\n2. 缓存血崩\n3. 缓存热点\n\n缓存穿透是指业务没有在缓存中找到想要的数据，从而去存储系统中重新查询。\n缓存血崩是指在缓存过期但还没有刷新之前，业务请求数据时，因为缓存中没有，所以每个线程都查询db，从而拖垮整个系统。\n缓存热点是针对热点进行单独的缓存管理。注意不要把所有缓存的过期时间设置成相同的，否则容易引发系统血崩。","like_count":1},{"had_liked":false,"id":124688,"user_name":"junshuaizhang","can_delete":false,"product_type":"c1","uid":1101502,"ip_address":"","ucode":"5734A9BEA03149","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/be/5cf3f1a0.jpg","comment_is_top":false,"comment_ctime":1565944679,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"评论区更精彩呀","like_count":1},{"had_liked":false,"id":21147,"user_name":"lawlielt","can_delete":false,"product_type":"c1","uid":1058095,"ip_address":"","ucode":"709728A82C0667","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/2f/3266c0da.jpg","comment_is_top":false,"comment_ctime":1534939503,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"我们也是双key，一个存数据不过期，另一个存过期时间。过期时间的key用作多线程锁。","like_count":1},{"had_liked":false,"id":11914,"user_name":"bigticket","can_delete":false,"product_type":"c1","uid":1109619,"ip_address":"","ucode":"6377FEC1F7E323","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/73/122500d0.jpg","comment_is_top":false,"comment_ctime":1528431602,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"为应对读写不平衡，高并发读取的业务场景，加入缓存机制；缓存又涉及到缓存穿透、缓存雪崩等问题，需要设计合理的过期时间，分页读取等","like_count":1},{"had_liked":false,"id":352698,"user_name":"杨恒","can_delete":false,"product_type":"c1","uid":3066545,"ip_address":"","ucode":"057CCB97B56740","user_header":"https://static001.geekbang.org/account/avatar/00/2e/ca/b1/044d3e98.jpg","comment_is_top":false,"comment_ctime":1658888556,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"建议参考HTTP 协议中描述的cache。","like_count":0},{"had_liked":false,"id":352048,"user_name":"湖","can_delete":false,"product_type":"c1","uid":1235649,"ip_address":"","ucode":"292B05A8EEEEB7","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/c1/b438893e.jpg","comment_is_top":false,"comment_ctime":1658365304,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":13,"product_id":100006601,"comment_content":"可以参考下开源项目layering-cache的实现","like_count":0,"discussions":[{"author":{"id":1193755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/1b/82310e20.jpg","nickname":"拿笔小星","note":"","ucode":"D3D8F6A959710D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604636,"discussion_content":"我们也遇到过，团队要求，缓存对象有变更时候，要升级缓存key。我们所有缓存都会带个版本号。当缓存对象结构有变更时候，要求升级版本号。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676389694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1412994,"avatar":"https://static001.geekbang.org/account/avatar/00/15/8f/82/374f43a1.jpg","nickname":"假装自己不胖","note":"","ucode":"308F1BAA96CDA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288946,"discussion_content":"序列化的结果存redis,其实我觉得用json化之后存会不会更直观些,那就无需序列化了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593939753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1367591,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo6qUrJUgVNIMeWy4ffwR7AiahZSuiaOSGeicwSydRm0s5WUwzqxTib8hCuf6ticP8sKmabTf9WSgYHRxw/132","nickname":"李卫卫","note":"","ucode":"F89946C5BF9EA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286349,"discussion_content":"和你序列化方式有关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593143084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299853,"user_name":"ZHANGPING","can_delete":false,"product_type":"c1","uid":1918112,"ip_address":"","ucode":"7108812981C996","user_header":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","comment_is_top":false,"comment_ctime":1624884499,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"内容和评论都很精彩，学习了~~~","like_count":0},{"had_liked":false,"id":282353,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1615204660,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"简单总结下今天的学习内容：\n前提：缓存是为了减轻存储系统的压力，不能要求缓存和存储系统一样(数据完全正确、准确的同时还得快)\n1、缓存穿透：缓存不生效，导致压力如洪峰般涌入存储系统。记得之前看过一个博客说可以加个熔断保护机制\n2、缓存雪崩：缓存挂了，拖垮整个业务系统。关键问题是何时同步缓存数据，可以分布式锁：减小并发或者消息队列削峰填谷程序更新缓存\n3、缓存热点。每次有大瓜，微博总会挂。解决方案多份数据，注意设置不同的过期时间，不然也会在未来某一刻给存储系统带来很大的压力。\n总结一下，我理解的缓存，定位和业务系统是不一样的，设计架构的适合不能单独只考虑性能如何，多个结构之间的协调联动以及问题发生的时候如何防范也得考虑清楚","like_count":0},{"had_liked":false,"id":244165,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1598415287,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"缓存的一致性问题这里讨论的比较少，自己的写读一致。","like_count":0},{"had_liked":false,"id":244150,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1598412072,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"缓存更新还有一种方式，读写都使用一致性hash，正常情况下都写都会落到相同的机器，因为写还没设置的缓存，可以在当前进程内缓存解决，对于失效的更新，本地的锁机制也可以防止雪崩。hash方式就是会牺牲一定的可用性，再比较短的时间内出现服务不可用。hash不一致可能导致多个线程去拉数据库，但是这种情况下并发还是更少很多。","like_count":0},{"had_liked":false,"id":200307,"user_name":"Ahaochan","can_delete":false,"product_type":"c1","uid":1726482,"ip_address":"","ucode":"2421EC162370FF","user_header":"https://wx.qlogo.cn/mmopen/vi_32/kibibtNMahiafQ3qM51Hu4yiaF3rybBiaJobRlBhUDTF67DtBKibKib66LcSSVOiaTmloA2noSic9hfntYlAsu9icIPKicE6Q/132","comment_is_top":false,"comment_ctime":1585571067,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"1. 缓存穿透\nQ1: 缓存不存在，流量直接打在db上\nA1: 给不存在的数据加上null的缓存，或者用布隆过滤器，过滤不存在数据的请求\nQ2: 缓存更新太久，流量直接打在db上\nA2: 后台线程检测过期时间，及时续命\n\n2. 缓存雪崩\nQ1: 缓存同时失效，流量全打在db上\nA1: 1失效重新生成缓存的动作加锁，2还是后台线程及时续命\n\n3. 缓存热点\nQ1: 热点数据导致缓存服务器压力过大\nA1: 缓存副本分流","like_count":0},{"had_liked":false,"id":62919,"user_name":"gkb111","can_delete":false,"product_type":"c1","uid":1224217,"ip_address":"","ucode":"9B3154BCC9046B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLLUic3XzxET3L3QXxcTbeg96GMx1HkiaiaZdudchmOmtPnuEPHK5vYEeMkvJR098XljMbXDialYib3z6w/132","comment_is_top":false,"comment_ctime":1548207501,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"缓存就是为了减少存储系统压力。如何解决缓存和存储系统不一致的问题，及时更新缓存，防止多机多线程同时更新缓存，这也会导致系统崩溃，两种方式，分布式锁，或者后台更新机制。","like_count":0},{"had_liked":false,"id":54402,"user_name":"Geek_58ezrw","can_delete":false,"product_type":"c1","uid":1119789,"ip_address":"","ucode":"3D1F0996CE65C8","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/2d/2753369a.jpg","comment_is_top":false,"comment_ctime":1545843869,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"像有些配置类的，商品类的数据，我之前的做法是直接通过后台预热到缓存中，并且没有失效时间。采用AOP思想，后台有改动了信息，缓存也跟着变动。","like_count":0},{"had_liked":false,"id":47062,"user_name":"Geek_fb3db2","can_delete":false,"product_type":"c1","uid":1218254,"ip_address":"","ucode":"8089B8311B6C80","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/ce/8c3bdbe5.jpg","comment_is_top":false,"comment_ctime":1544027334,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"缓存穿透：\n不通过缓存 ，直接获取数据库数据，可能会把应用拖的非常满\n缓存雪崩，大量缓存失效，需要重新加载缓存，导致线程间加载缓存缓存\n缓存热点：\n大量数据都通过一个缓存服务器，导致访问量非常大","like_count":0},{"had_liked":false,"id":20698,"user_name":"文竹","can_delete":false,"product_type":"c1","uid":1103167,"ip_address":"","ucode":"74413B1975976B","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/3f/80bf4841.jpg","comment_is_top":false,"comment_ctime":1534676541,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"还没怎么深入接触过Redis，业务规模小，主要用来保存session，还没出现过问题。\n\n缓存穿透重在缓存无数据或失效，缓存雪崩重在缓存穿透后引起的崩溃，缓存热点重在热点数据。","like_count":0},{"had_liked":false,"id":13608,"user_name":"孙振超","can_delete":false,"product_type":"c1","uid":1101755,"ip_address":"","ucode":"0F9EABC6125350","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/bb/22af0e52.jpg","comment_is_top":false,"comment_ctime":1529846947,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"在对qps有高要求的系统通常都会采用缓存，正所谓解决了一个问题之后就会有一个新问题出现，引入缓存在提升qps后最大的问题在于缓存db数据一致性问题。使用缓存的通常做法是先读缓存，缓存没有命中，就查询db，而后将查询到的数据添加到缓存中。在这种使用方法下导致缓存db不一致的主要情况是db和缓存没有同步更新，比如先更新db后更新缓存可能会出现db更新成功而缓存更新失败的情况，如果是先更新缓存后更新db则可能会出现缓存更新成功而db更新失败的情况。而解决这个问题可能要引入消息中间件或者利用分布式锁来保证，这样又给系统带来了复杂性。","like_count":0},{"had_liked":false,"id":299853,"user_name":"ZHANGPING","can_delete":false,"product_type":"c1","uid":1918112,"ip_address":"","ucode":"7108812981C996","user_header":"https://static001.geekbang.org/account/avatar/00/1d/44/a0/16d0d300.jpg","comment_is_top":false,"comment_ctime":1624884499,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"内容和评论都很精彩，学习了~~~","like_count":0},{"had_liked":false,"id":282353,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1615204660,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"简单总结下今天的学习内容：\n前提：缓存是为了减轻存储系统的压力，不能要求缓存和存储系统一样(数据完全正确、准确的同时还得快)\n1、缓存穿透：缓存不生效，导致压力如洪峰般涌入存储系统。记得之前看过一个博客说可以加个熔断保护机制\n2、缓存雪崩：缓存挂了，拖垮整个业务系统。关键问题是何时同步缓存数据，可以分布式锁：减小并发或者消息队列削峰填谷程序更新缓存\n3、缓存热点。每次有大瓜，微博总会挂。解决方案多份数据，注意设置不同的过期时间，不然也会在未来某一刻给存储系统带来很大的压力。\n总结一下，我理解的缓存，定位和业务系统是不一样的，设计架构的适合不能单独只考虑性能如何，多个结构之间的协调联动以及问题发生的时候如何防范也得考虑清楚","like_count":0},{"had_liked":false,"id":244165,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1598415287,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"缓存的一致性问题这里讨论的比较少，自己的写读一致。","like_count":0},{"had_liked":false,"id":244150,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1598412072,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"缓存更新还有一种方式，读写都使用一致性hash，正常情况下都写都会落到相同的机器，因为写还没设置的缓存，可以在当前进程内缓存解决，对于失效的更新，本地的锁机制也可以防止雪崩。hash方式就是会牺牲一定的可用性，再比较短的时间内出现服务不可用。hash不一致可能导致多个线程去拉数据库，但是这种情况下并发还是更少很多。","like_count":0},{"had_liked":false,"id":200307,"user_name":"Ahaochan","can_delete":false,"product_type":"c1","uid":1726482,"ip_address":"","ucode":"2421EC162370FF","user_header":"https://wx.qlogo.cn/mmopen/vi_32/kibibtNMahiafQ3qM51Hu4yiaF3rybBiaJobRlBhUDTF67DtBKibKib66LcSSVOiaTmloA2noSic9hfntYlAsu9icIPKicE6Q/132","comment_is_top":false,"comment_ctime":1585571067,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"1. 缓存穿透\nQ1: 缓存不存在，流量直接打在db上\nA1: 给不存在的数据加上null的缓存，或者用布隆过滤器，过滤不存在数据的请求\nQ2: 缓存更新太久，流量直接打在db上\nA2: 后台线程检测过期时间，及时续命\n\n2. 缓存雪崩\nQ1: 缓存同时失效，流量全打在db上\nA1: 1失效重新生成缓存的动作加锁，2还是后台线程及时续命\n\n3. 缓存热点\nQ1: 热点数据导致缓存服务器压力过大\nA1: 缓存副本分流","like_count":0},{"had_liked":false,"id":62919,"user_name":"gkb111","can_delete":false,"product_type":"c1","uid":1224217,"ip_address":"","ucode":"9B3154BCC9046B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLLUic3XzxET3L3QXxcTbeg96GMx1HkiaiaZdudchmOmtPnuEPHK5vYEeMkvJR098XljMbXDialYib3z6w/132","comment_is_top":false,"comment_ctime":1548207501,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"缓存就是为了减少存储系统压力。如何解决缓存和存储系统不一致的问题，及时更新缓存，防止多机多线程同时更新缓存，这也会导致系统崩溃，两种方式，分布式锁，或者后台更新机制。","like_count":0},{"had_liked":false,"id":54402,"user_name":"Geek_58ezrw","can_delete":false,"product_type":"c1","uid":1119789,"ip_address":"","ucode":"3D1F0996CE65C8","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/2d/2753369a.jpg","comment_is_top":false,"comment_ctime":1545843869,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"像有些配置类的，商品类的数据，我之前的做法是直接通过后台预热到缓存中，并且没有失效时间。采用AOP思想，后台有改动了信息，缓存也跟着变动。","like_count":0},{"had_liked":false,"id":47062,"user_name":"Geek_fb3db2","can_delete":false,"product_type":"c1","uid":1218254,"ip_address":"","ucode":"8089B8311B6C80","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/ce/8c3bdbe5.jpg","comment_is_top":false,"comment_ctime":1544027334,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"缓存穿透：\n不通过缓存 ，直接获取数据库数据，可能会把应用拖的非常满\n缓存雪崩，大量缓存失效，需要重新加载缓存，导致线程间加载缓存缓存\n缓存热点：\n大量数据都通过一个缓存服务器，导致访问量非常大","like_count":0},{"had_liked":false,"id":20698,"user_name":"文竹","can_delete":false,"product_type":"c1","uid":1103167,"ip_address":"","ucode":"74413B1975976B","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/3f/80bf4841.jpg","comment_is_top":false,"comment_ctime":1534676541,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"还没怎么深入接触过Redis，业务规模小，主要用来保存session，还没出现过问题。\n\n缓存穿透重在缓存无数据或失效，缓存雪崩重在缓存穿透后引起的崩溃，缓存热点重在热点数据。","like_count":0},{"had_liked":false,"id":13608,"user_name":"孙振超","can_delete":false,"product_type":"c1","uid":1101755,"ip_address":"","ucode":"0F9EABC6125350","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/bb/22af0e52.jpg","comment_is_top":false,"comment_ctime":1529846947,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100006601,"comment_content":"在对qps有高要求的系统通常都会采用缓存，正所谓解决了一个问题之后就会有一个新问题出现，引入缓存在提升qps后最大的问题在于缓存db数据一致性问题。使用缓存的通常做法是先读缓存，缓存没有命中，就查询db，而后将查询到的数据添加到缓存中。在这种使用方法下导致缓存db不一致的主要情况是db和缓存没有同步更新，比如先更新db后更新缓存可能会出现db更新成功而缓存更新失败的情况，如果是先更新缓存后更新db则可能会出现缓存更新成功而db更新失败的情况。而解决这个问题可能要引入消息中间件或者利用分布式锁来保证，这样又给系统带来了复杂性。","like_count":0},{"had_liked":false,"id":13427,"user_name":"孙晓明","can_delete":false,"product_type":"c1","uid":1117094,"ip_address":"","ucode":"CAD28E4D5A3E76","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/a6/b234aa79.jpg","comment_is_top":false,"comment_ctime":1529625235,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100006601,"comment_content":"我们的一个系统缓存是这样的：在数据库中定义了视图，将视图的结果缓存，永不过期；如果数据发生变动，先更新视图，然后再将视图结果更新到缓存中。后来也有用存储过程定时统计复杂的数据，并将统计结果存储到临时表中，程序访问时读取临时表的数据。","like_count":0},{"had_liked":false,"id":12203,"user_name":"zwfec","can_delete":false,"product_type":"c1","uid":1110611,"ip_address":"","ucode":"6BDE8813580E24","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/53/2af50978.jpg","comment_is_top":false,"comment_ctime":1528683937,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100006601,"comment_content":"使用 update  +1 的系统挂过，其实就是一个信息页统计访问数，修改了解决方法，使用js写入内存，再定时写入库","like_count":0},{"had_liked":false,"id":12158,"user_name":"大雁小鱼","can_delete":false,"product_type":"c1","uid":1101017,"ip_address":"","ucode":"44090581E59FDA","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","comment_is_top":false,"comment_ctime":1528625136,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100006601,"comment_content":"分布式缓存的设计关键点是什么？","like_count":0},{"had_liked":false,"id":11539,"user_name":"天天平安","can_delete":false,"product_type":"c1","uid":1119208,"ip_address":"","ucode":"C4850F9655F4DD","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/e8/08b829a9.jpg","comment_is_top":false,"comment_ctime":1528187122,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100006601,"comment_content":"请问 阿里hybiddb for mysql,hybiddb for postgresql和maxcompute这三个产品有什么区别，分别在哪些情况选择对应的数据库合适？","like_count":0},{"had_liked":false,"id":11460,"user_name":"浪子恒心","can_delete":false,"product_type":"c1","uid":1008441,"ip_address":"","ucode":"2A5DCD25895E8F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/39/486faadf.jpg","comment_is_top":false,"comment_ctime":1528159313,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100006601,"comment_content":"朗读者声音不错，很清晰！","like_count":0},{"had_liked":false,"id":13427,"user_name":"孙晓明","can_delete":false,"product_type":"c1","uid":1117094,"ip_address":"","ucode":"CAD28E4D5A3E76","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/a6/b234aa79.jpg","comment_is_top":false,"comment_ctime":1529625235,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100006601,"comment_content":"我们的一个系统缓存是这样的：在数据库中定义了视图，将视图的结果缓存，永不过期；如果数据发生变动，先更新视图，然后再将视图结果更新到缓存中。后来也有用存储过程定时统计复杂的数据，并将统计结果存储到临时表中，程序访问时读取临时表的数据。","like_count":0},{"had_liked":false,"id":12203,"user_name":"zwfec","can_delete":false,"product_type":"c1","uid":1110611,"ip_address":"","ucode":"6BDE8813580E24","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/53/2af50978.jpg","comment_is_top":false,"comment_ctime":1528683937,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100006601,"comment_content":"使用 update  +1 的系统挂过，其实就是一个信息页统计访问数，修改了解决方法，使用js写入内存，再定时写入库","like_count":0},{"had_liked":false,"id":12158,"user_name":"大雁小鱼","can_delete":false,"product_type":"c1","uid":1101017,"ip_address":"","ucode":"44090581E59FDA","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","comment_is_top":false,"comment_ctime":1528625136,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100006601,"comment_content":"分布式缓存的设计关键点是什么？","like_count":0},{"had_liked":false,"id":11539,"user_name":"天天平安","can_delete":false,"product_type":"c1","uid":1119208,"ip_address":"","ucode":"C4850F9655F4DD","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/e8/08b829a9.jpg","comment_is_top":false,"comment_ctime":1528187122,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100006601,"comment_content":"请问 阿里hybiddb for mysql,hybiddb for postgresql和maxcompute这三个产品有什么区别，分别在哪些情况选择对应的数据库合适？","like_count":0},{"had_liked":false,"id":11460,"user_name":"浪子恒心","can_delete":false,"product_type":"c1","uid":1008441,"ip_address":"","ucode":"2A5DCD25895E8F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/39/486faadf.jpg","comment_is_top":false,"comment_ctime":1528159313,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100006601,"comment_content":"朗读者声音不错，很清晰！","like_count":0}]}