{"id":740800,"title":"第 2 章 Rust 导览(1)","content":"<p>写这样一本书并不容易：Rust 这门语言如此卓尔不群，我们固然有能力在一开始就展示出其独特的、令人惊叹的特性，但更为重要的是它的各个部分之间能够良好协作，共同服务于我们在第 1 章中设定的目标——安全、高性能的系统编程。该语言的每个部分都与其他部分配合得天衣无缝。</p>\n<p>因此，我们并不打算每次讲透一个语言特性，而是准备了一些小而完备的程序作为导览，每个程序都会在其上下文中介绍该语言的更多特性。</p>\n<ul>\n<li>作为暖场，我们会设计一个简单的程序，它可以解析命令行参数并进行简单计算，而且带有单元测试。这会展示 Rust 的一些核心类型并引入<strong>特型</strong>的概念。</li>\n<li>接下来，我们一起构建一个 Web 服务器。我们将使用第三方库来处理 HTTP 的细节，并介绍字符串处理、闭包和错误处理功能。</li>\n<li>第三个程序会绘制一张美丽的分形图，将计算工作分派到多个线程以提高效率。这包括一个泛型函数的示例，以说明该如何处理像素缓冲区之类的问题，并展示 Rust 对并发的支持。</li>\n<li>最后，我们会展示一个强大的命令行工具，它利用正则表达式来处理文件。这展示了 Rust 标准库的文件处理功能，以及最常用的第三方正则表达式库。</li>\n</ul>\n<p>Rust 承诺会在对性能影响最小的情况下防止未定义行为，这在潜移默化中引导着每个部分的设计——从标准数据结构（如向量和字符串）到使用第三方库的方式。关于如何做好这些的细节会贯穿全书。但就目前而言，我们只想向你证明 Rust 是一门功能强大且易于使用的语言。</p>\n<p>当然，你要先在计算机上安装 Rust。</p>\n<h2 id=\"nav_point_22\">2.1　<code>rustup</code> 与 Cargo</h2>\n<p>安装 Rust 的最佳方式是使用 <code>rustup</code>。请转到 rustup.rs 网站并按照那里的说明进行操作。</p>\n<p>还可以到 Rust 网站获取针对 Linux、macOS 和 Windows 的预构建包。Rust 也已经包含在某些操作系统的发行版中。建议使用 <code>rustup</code>，因为它是专门管理 Rust 安装的工具，就像 Ruby 中的 RVM 或 Node 中的 NVM。例如，当 Rust 发布新版本时，你就可以通过键入 <code>rustup update</code> 来实现一键升级。</p><!-- [[[read_end]]] -->\n<p>无论采用哪种方式，完成安装之后，你的命令行中都会有 3 条新命令：</p>\n<pre class=\"code-rows\"><code>$ cargo --version\ncargo 1.49.0 (d00d64df9 2020-12-05)\n$ rustc --version\nrustc 1.49.0 (e1884a8e3 2020-12-29)\n$ rustdoc --version\nrustdoc 1.49.0 (e1884a8e3 2020-12-29)</code></pre>\n<p>在这里，<code>$</code> 是命令提示符，在 Windows 上，则会是 <code>C:\\&gt;</code> 之类的文本。在刚才的记录中，我们运行了 3 条已安装的命令，并要求每条命令报告其版本号。下面来逐个看看每条命令。</p>\n<ul>\n<li><code>cargo</code> 是 Rust 的编译管理器、包管理器和通用工具。可以用 Cargo 启动新项目、构建和运行程序，并管理代码所依赖的任何外部库。</li>\n<li><code>rustc</code> 是 Rust 编译器。通常 Cargo 会替我们调用此编译器，但有时也需要直接运行它。</li>\n<li><code>rustdoc</code> 是 Rust 文档工具。如果你在程序源代码中以适当形式的注释编写文档，那么 <code>rustdoc</code> 就可以从中构建出格式良好的 HTML。与 <code>rustc</code> 一样，通常 Cargo 会替我们运行 <code>rustdoc</code>。</li>\n</ul>\n<p>为便于使用，Cargo 可以为我们创建一个新的 Rust 包，并适当准备一些标准化的元数据：</p>\n<pre class=\"code-rows\"><code>$ cargo new hello\n     Created binary (application) `hello` package</code></pre>\n<p>该命令会创建一个名为 hello 的新包目录，用于构建命令行可执行文件。</p>\n<p>查看包的顶层目录：</p>\n<pre class=\"code-rows\"><code>$ cd hello\n$ ls -la\ntotal 24\ndrwxrwxr-x.  4 jimb jimb 4096 Sep 22 21:09 .\ndrwx------. 62 jimb jimb 4096 Sep 22 21:09 ..\ndrwxrwxr-x.  6 jimb jimb 4096 Sep 22 21:09 .git\n-rw-rw-r--.  1 jimb jimb    7 Sep 22 21:09 .gitignore\n-rw-rw-r--.  1 jimb jimb   88 Sep 22 21:09 Cargo.toml\ndrwxrwxr-x.  2 jimb jimb 4096 Sep 22 21:09 src</code></pre>\n<p>我们看到 Cargo 已经创建了一个名为 Cargo.toml 的文件来保存此包的元数据。目前这个文件还没有多少内容：</p>\n<pre class=\"code-rows\"><code>[package]\nname = \"hello\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# 请到“The Cargo Book”查看更多的键及其定义\n\n[dependencies]</code></pre>\n<p>如果程序依赖于其他库，那么可以把它们记录在这个文件中，Cargo 将为我们下载、构建和更新这些库。第 8 章会详细介绍 Cargo.toml 文件。</p>\n<p>Cargo 已将我们的包设置为与版本控制系统 <code>git</code> 一起使用，并为此创建了一个元数据子目录 .git 和一个 .gitignore 文件。可以通过在命令行中将 <code>--vcs none</code> 传给 <code>cargo new</code> 来要求 Cargo 跳过此步骤。</p>\n<p>src 子目录包含实际的 Rust 代码：</p>\n<pre class=\"code-rows\"><code>$ cd src\n$ ls -l\ntotal 4\n-rw-rw-r--. 1 jimb jimb 45 Sep 22 21:09 main.rs</code></pre>\n<p>Cargo 似乎已经替我们写好一部分程序了。main.rs 文件包含以下文本：</p>\n<pre class=\"code-rows\"><code>fn main() {\n    println!(\"Hello, world!\");\n}</code></pre>\n<p>在 Rust 中，你甚至不需要编写自己的“Hello, World!”程序。这是 Rust 新程序样板的职责，该程序样板包括两个文件，总共 13 行代码。</p>\n<p>可以在包内的任意目录下调用 <code>cargo run</code> 命令来构建和运行程序：</p>\n<pre class=\"code-rows\"><code>$ cargo run\n   Compiling hello v0.1.0 (/home/jimb/rust/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.28s\n     Running `/home/jimb/rust/hello/target/debug/hello`\nHello, world!</code></pre>\n<p>这里 Cargo 先调用 Rust 编译器 <code>rustc</code>，然后运行了它生成的可执行文件。Cargo 将可执行文件放在此包顶层的 target 子目录中：</p>\n<pre class=\"code-rows\"><code>$ ls -l ../target/debug\ntotal 580\ndrwxrwxr-x. 2 jimb jimb   4096 Sep 22 21:37 build\ndrwxrwxr-x. 2 jimb jimb   4096 Sep 22 21:37 deps\ndrwxrwxr-x. 2 jimb jimb   4096 Sep 22 21:37 examples\n-rwxrwxr-x. 1 jimb jimb 576632 Sep 22 21:37 hello\n-rw-rw-r--. 1 jimb jimb    198 Sep 22 21:37 hello.d\ndrwxrwxr-x. 2 jimb jimb     68 Sep 22 21:37 incremental\n$ ../target/debug/hello\nHello, world!</code></pre>\n<p>完工之后，Cargo 还可以帮我们清理生成的文件。</p>\n<pre class=\"code-rows\"><code>$ cargo clean\n$ ../target/debug/hello\nbash: ../target/debug/hello: No such file or directory</code></pre>\n<h2 id=\"nav_point_23\">2.2　Rust 函数</h2>\n<p>Rust 在语法设计上刻意减少了原创性。如果你熟悉 C、C++、Java 或 JavaScript，那么就能通过 Rust 程序的一般性构造找到自己的快速学习之道。这是一个使用欧几里得算法计算两个整数的最大公约数的函数。可以将这些代码添加到 src/main.rs 的末尾：</p>\n<pre class=\"code-rows\"><code>fn gcd(mut n: u64, mut m: u64) -&gt; u64 {\n    assert!(n != 0 &amp;&amp; m != 0);\n    while m != 0 {\n        if m &lt; n {\n            let t = m;\n            m = n;\n            n = t;\n        }\n        m = m % n;\n    }\n    n\n}</code></pre>\n<p><code>fn</code>（发音为 /fʌn/）关键字引入了一个函数。这里我们定义了一个名为 <code>gcd</code> 的函数，它有两个参数（<code>n</code> 和 <code>m</code>），每个参数都是 <code>u64</code> 类型，即一个无符号的 64 位整数。<code>-&gt;</code> 标记后面紧跟着返回类型，表示此函数返回一个 <code>u64</code> 值。4 空格缩进是 Rust 的标准风格。</p>\n<p>Rust 的“机器整数类型名”揭示了它们的大小和符号：<code>i32</code> 是一个带符号的 32 位整数，<code>u8</code> 是一个无符号的 8 位整数（“字节”值），以此类推。<code>isize</code> 类型和 <code>usize</code> 类型保存着恰好等于“指针大小”的有符号整数和无符号整数，在 32 位平台上是 32 位长，在 64 位平台上则是 64 位长。Rust 还有 <code>f32</code> 和 <code>f64</code> 这两种浮点类型，它们分别是 IEEE 单精度浮点类型和 IEEE 双精度浮点类型，就像 C 和 C++ 中的 <code>float</code> 和 <code>double</code>。</p>\n<p>默认情况下，一经初始化，变量的值就不能再改变了，但是在参数 <code>n</code> 和 <code>m</code> 之前放置 <code>mut</code>（发音为 /mjuːt/，是 mutable 的缩写）关键字将会准许我们在函数体中赋值给它们。实际上，大多数变量是不需要被赋值的，而对于那些确实需要被赋值的变量，<code>mut</code> 关键字相当于用一个醒目的提示来帮我们阅读代码。</p>\n<p>函数的主体始于一次 <code>assert!</code> 宏调用，以验证这两个参数都不为 0。这里的 <code>!</code> 字符标明此句为宏调用，而不是函数调用。就像 C 和 C++ 中的 <code>assert</code> 宏一样，Rust 的 <code>assert!</code> 会检查其参数是否为真，如果非真，则终止本程序并提供一条有帮助的信息，其中包括导致本次检查失败的源代码位置。这种突然的终止在 Rust 中称为 panic。与可以跳过断言的 C 和 C++ 不同，Rust 总是会检查这些断言，而不管程序是如何编译的。还有一个 <code>debug_assert!</code> 宏，在编译发布版程序时会跳过其断言以提高速度。</p>\n<p>这个函数的核心是一个包含 <code>if</code> 语句和赋值语句的 <code>while</code> 循环。与 C 和 C++ 不同，Rust 不需要在条件表达式周围使用圆括号，但必须在受其控制的语句周围使用花括号。</p>\n<p><code>let</code> 语句会声明一个局部变量，比如本函数中的 <code>t</code>。只要 Rust 能从变量的使用方式中推断出 <code>t</code> 的类型，就不需要标注其类型。在此函数中，通过匹配 <code>m</code> 和 <code>n</code>，可以推断出唯一适用于 <code>t</code> 的类型是 <code>u64</code>。Rust 只会推断函数体内部的类型，因此必须像之前那样写出函数参数的类型和返回值的类型。如果想明确写出 <code>t</code> 的类型，那么可以这样写：</p>\n<pre class=\"code-rows\"><code>let t: u64 = m;</code></pre>\n<p>Rust 有 <code>return</code> 语句，但这里的 <code>gcd</code> 函数并不需要。如果一个函数体以<strong>没有</strong>尾随着分号的表达式结尾，那么这个表达式就是函数的返回值。事实上，花括号包起来的任意代码块都可以用作表达式。例如，下面是一个打印了一条信息然后以 <code>x.cos()</code> 作为其值的表达式：</p>\n<pre class=\"code-rows\"><code>{\n    println!(\"evaluating cos x\");\n    x.cos()\n}</code></pre>\n<p>在 Rust 中，当控制流“正常离开函数的末尾”时，通常会以上述形式创建函数的返回值，<code>return</code> 语句只会用在从函数中间显式地提前返回的场景中。</p>\n<h2 id=\"nav_point_24\">2.3　编写与运行单元测试</h2>\n<p>Rust 语言内置了对测试的简单支持。为了测试 <code>gcd</code> 函数，可以在 src/main.rs 的末尾添加下面这段代码：</p>\n<pre class=\"code-rows\"><code>#[test]\nfn test_gcd() {\n    assert_eq!(gcd(14, 15), 1);\n\n    assert_eq!(gcd(2 * 3 * 5 * 11 * 17,\n                   3 * 7 * 11 * 13 * 19),\n               3 * 11);\n}</code></pre>\n<p>这里我们定义了一个名为 <code>test_gcd</code> 的函数，该函数会调用 <code>gcd</code> 并检查它是否返回了正确的值。此定义顶部的 <code>#[test]</code> 将 <code>test_gcd</code> 标记为“测试函数”，在正常编译时会跳过它，但如果用 <code>cargo test</code> 命令运行我们的程序，则会自动包含并调用它。可以让测试函数分散在源代码树中，紧挨着它们所测试的代码，<code>cargo test</code> 会自动收集并运行它们。</p>\n<p><code>#[test]</code> 标记是<strong>属性</strong>（attribute）的示例之一。属性是一个开放式体系，可以用附加信息给函数和其他声明做标记，就像 C++ 和 C# 中的属性或 Java 中的注解（annotation）一样。属性可用于控制编译器警告和代码风格检查、有条件地包含代码（就像 C 和 C++ 中的 <code>#ifdef</code> 一样）、告诉 Rust 如何与其他语言编写的代码互动，等等。后面还会介绍更多的属性示例。</p>\n<p>将 <code>gcd</code> 和 <code>test_gcd</code> 的定义添加到本章开头创建的 hello 包中，如果当前目录位于此包子树中的任意位置，可以用如下方式运行测试。</p>\n<pre class=\"code-rows\"><code>$ cargo test\n   Compiling hello v0.1.0 (/home/jimb/rust/hello)\n    Finished test [unoptimized + debuginfo] target(s) in 0.35s\n     Running unittests (/home/jimb/rust/hello/target/debug/deps/hello-2375...)\n\nrunning 1 test\ntest test_gcd ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</code></pre>\n","neighbors":{"left":{"article_title":"第 1 章 系统程序员也能享受美好","id":740799},"right":{"article_title":"第 2 章 Rust 导览(2)","id":740801}},"comments":[{"had_liked":false,"id":387849,"user_name":"程序员吾真本","can_delete":false,"product_type":"c1","uid":1047630,"ip_address":"北京","ucode":"C63E268F02900B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/4e/c0f25dcb.jpg","comment_is_top":false,"comment_ctime":1708682154,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636604,"comment_content":"能收听，好方便👍","like_count":1}]}