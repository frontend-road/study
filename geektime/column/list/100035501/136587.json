{"id":136587,"title":"03 | 换个角度解决问题：服务端推送技术","content":"<p>你好，我是四火。</p><p>今天我们继续和 HTTP“过不去”。在上一讲，我们讲到了 HTTP 在安全传输方面的局限，并介绍了怎样使用经过 TLS 加密的 HTTPS 连接来解决这样的弊端。</p><p>今天，我要给你讲讲传统 HTTP的另一个在交互模式上的局限，就是只能由客户端主动发起消息传递，而服务端只能被动响应消息的局限，并介绍它的解决办法。</p><h2>Pull 模型的问题</h2><p>让我们来思考这样一个场景，假设你设计了一款网页版的即时聊天工具，现在你使用浏览器打开了聊天页面，正在和朋友愉快地聊天。这时有朋友给你发送了一条消息，可是由于 HTTP 本身机制的限制，服务端无法主动推送消息，告知浏览器上的聊天页面“你有一条消息”，进而影响到了消息的即时送达。那么，这个问题怎么解决？</p><p>你可能会立即想到<strong>轮询（Poll）</strong>，比如浏览器每隔十秒钟去问一下服务端是不是有新消息不就完了嘛。这看起来是个好思路，但明显存在这样两个问题：</p><ul>\n<li>消息还是不够即时。换言之，假如正好在某次询问之后服务器收到了消息，那么这条消息的获取延迟可能达到至少十秒。</li>\n<li>大量的请求-响应，带宽和服务器资源浪费。如果你开着聊天工具页面一个小时，除了这一条消息，却没有进一步的聊天行为，于是按照每十秒发送一次请求计算，一共发起了 360 次请求，而其中居然只有 1 次返回了聊天消息是有实际意义的。</li>\n</ul><!-- [[[read_end]]] --><p>显然，轮询这个方案不好。说到底，其实我们并没有抛开对 HTTP 的已有印象，从问题本身出发去思考解决问题的最佳方式，而是潜意识地受限于 HTTP 的传统交互模式，考虑其中的变通方法。</p><p>在进一步分析之前，我们先来看两个容易弄混的概念：Pull 和 Poll。</p><p>“Pull”指的是去主动发起行为获取消息，一般在客户端/服务器（C/S，Client/Server）或浏览器/服务器（B/S，Browser/Server）交互中，客户端或浏览器主动发起的网络请求数据的行为。</p><p>而“Poll”，尽管在某些场景下也和 Pull 通用了，但在计算机网络的领域里，通常把它解释为“轮询”，或者“周期性查询”，在 Pull 的基础上增加了“周期性”的概念，这也是它和 Pull 相比最本质的区别。</p><p>相应地，和 Pull  行为相对的，从服务端主动发起，发送数据到客户端的行为叫做“Push”。Push 相比 Pull 而言，具备这样两个明显的优势：</p><ul>\n<li><strong>高效性</strong>。如果没有更新发生，就不会有任何更新消息推送的动作，即每次消息推送都发生在确确实实的更新事件之后，都是有意义的，不会出现请求和响应的资源浪费。</li>\n<li><strong>实时性</strong>。事件发生后的第一时间即可触发通知操作，理论上不存在任何可能导致通知延迟的硬伤。</li>\n</ul><p>可是，有趣的是，事实上 Pull 的应用却远比 Push 更广泛，特别是在分布式系统中。这里有多个原因，其中很重要的一条是：</p><p>服务端不需要维护客户端的列表，不需要知晓客户端的情况，不需要了解客户端查询的策略。<strong>这有助于把服务端从对客户端繁重的管理工作中解放出来，而成为无状态的简单服务，变得具备幂等性（idempotent，指执行多次和执行一次的结果一样），更容易横向扩展。</strong></p><p>尤其在分布式系统中，状态经常成为毒药，有了状态，就不得不考虑状态的保存、丢失、一致性等问题，因此这种无状态往往可以很大程度地简化系统的设计。</p><h2>服务端推送技术</h2><p>有了这些基础知识，我们就可以来谈谈实际的服务端推送技术了，这些都从一定程度上解决了 HTTP 传统方式 Pull 的弊端。</p><h3>1. Comet</h3><p>严格说，Comet 是一种 Web 应用客户端和服务端交互的模型，它有几种服务端推送的具体实现，但是，它们的大致原理是一样的：<strong>客户端发送一个普通的 HTTP 请求到服务端以后，服务端不像以往一样在处理后立即返回数据，而是保持住连接不释放，每当有更新事件发生，就使用分块传输的方式返回数据</strong>（如果你忘记了块传输的方式，请回看 <a href=\"https://time.geekbang.org/column/article/134752\">[第1讲]</a>）。</p><p>若干次数据返回以后可以完成此次请求响应过程（分块传输返回长度为0的块，表示传输结束），等待客户端下一次请求发送。这种过程看起来也属于轮询，但是每个周期可包含多次服务端数据返回，因而也被形象地称为“长轮询”（Long Polling）。</p><p>在服务端推送技术中，Comet 最大的好处是，它 100% 由 HTTP 协议实现，当然，分块传输要求 HTTP 至少是 1.1 版本。但也正因为这点，它也存在一些弊端，比如，客户端必须在服务端结束当次传输后才能向服务端发送消息；HTTP 协议限制了它在每次请求和响应中必须携带完整的头部，这在一定程度上也造成了浪费（这种为了传输实际数据而使用的额外开销叫做 overhead）。</p><p>下面我给出了一个 Comet 实现的示例图。浏览器在发出 1 号请求要求数据，连接保持，接着陆续收到几个不同大小的响应数据，并且最后一个大小为0，浏览器被告知此次传输完成。过了一会儿，浏览器又发出 2 号请求，开始第二轮的类似交互。</p><p><img src=\"https://static001.geekbang.org/resource/image/f1/9d/f148cfbe65a6a0e98214095c46e0169d.png?wh=1156*1272\" alt=\"\"></p><p>在 Comet 方式下，<strong>看起来服务端有了推送行为，其实只是对于客户端请求有条件、讲时机的多次返回</strong>，因此我们把它称为服务端“假 Push”。</p><h3>2. WebSocket</h3><p>HTML 5 规范定义了 WebSocket 协议，它可以通过 HTTP 的端口（或者 HTTPS 的端口）来完成，从而最大程度上对 HTTP 协议通透的防火墙保持友好。但是，<strong>它是真正的双向、全双工协议，也就是说，客户端和服务端都可以主动发起请求，回复响应，而且两边的传输都互相独立。</strong></p><p>和上文的 Comet 不同，WebSocket 的服务端推送是完全可以由服务端独立、主动发起的，因此它是服务端的“真 Push”。</p><p>WebSocket 是一个可谓“科班出身”的二进制协议，也没有那么大的头部开销，因此它的传输效率更高。同时，和 HTTP 不一样的是，它是一个带有状态的协议，双方可以约定好一些状态，而不用在传输的过程中带来带去。而且，WebSocket 相比于 HTTP，它没有同源的限制，服务端的地址可以完全和源页面地址无关，即不会出现臭名昭著的浏览器“跨域问题”。</p><p>另外，它和我们之前学习的加密传输也丝毫不冲突，由于它在网络分层模型中位于 TLS 上方，因此他可以使用和 HTTP 一样的加密方式传输：</p><blockquote>\n<p>HTTP → WS<br>\nHTTPS → WSS</p>\n</blockquote><p>最后，最有意思的事情在于，和我们之前的认识不同，WebSocket 是使用 HTTP 协议“升级”的方法来帮助建立连接的，下面我们动手来试一试。</p><p>首先，我们需要找到一个可以支持 WebSocket 测试的网站，比如 websocket.org，然后我们将使用 Chrome 的网络工具来捕获和显示通过浏览器发送和接收的消息。如果这是你第一次使用 Chrome 的开发者工具，那么你需要好好熟悉它了，因为它将在你今后全栈的道路上派上大用场。</p><p>使用 Chrome 打开 <a href=\"https://www.websocket.org/echo.html\">Echo Test</a> 页面，在这里你可以发送建立一个 WebSocket 连接。但是别急，我们先打开 Chrome 的开发者工具，并选中 Network  标签，接着点击左上角的清除按钮，把已有页面加载的网络消息清除掉，以获得一个清爽的网络报文监视界面：</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/ae/ea65ac03047615ba8aafe1d7118d5dae.png?wh=2068*950\" alt=\"\"></p><p>接着，确保页面上建立 WebSocket 连接的对端地址和传递的信息都已经填写，比如：</p><pre><code>Location:\nwss://echo.websocket.org\nMessage:\nRock it with HTML5 WebSocket\n</code></pre><p>于是就可以点击“Connect”按钮了，旁边的日志框将出现“CONNECTED”字样，同时，Chrome 开发者工具将捕获这样的请求（如果在开发者工具中网络监视界面上，选中消息的消息头处于“parsed”展示模式，你需要点击 Request Headers 右侧的 “view source” 链接来查看原始消息头）：</p><pre><code>GET wss://echo.websocket.org/?encoding=text HTTP/1.1\nHost: echo.websocket.org\nOrigin: https://www.websocket.org\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Version: 13\nSec-WebSocket-Key: xxx\n... (省略其它 HTTP 头)\n</code></pre><p>好，你可以看到，这是一个普普通通的 HTTP GET 请求，但是 URL 是以加密连接“wss”开头的，并且有几个特殊的 HTTP 头：Origin 指出了请求是从哪个页面发起的，Connection: Upgrade 和 Upgrade: websocket 这两个表示客户端要求升级 HTTP 协议为 WebSocket。</p><p>好，再来看响应，消息的头部为：</p><pre><code>HTTP/1.1 101 Web Socket Protocol Handshake\nConnection: Upgrade\nSec-WebSocket-Accept: xxx\nUpgrade: websocket\n... (省略其它 HTTP 头)\n</code></pre><p>嗯，返回码是 101，描述是“Web Socket Protocol Handshake”，并且，它确认了连接升级为“websocket”的事实。</p><h3>3. 更多推送技术</h3><p>到这里，我已经介绍了几种服务端的推送技术，事实上还有更多，但是，<strong>如果你依次了解以后认真思考，就会发现，这些原理居然都在某种程度上和我介绍的 Comet 和 WebSocket 这两种类似，有的甚至来自于它们。</strong></p><p>这些技术包括：</p><ul>\n<li>SSE，即 Server-Sent Events，又叫 EventSource，是一种已被写入 HTML 5 标准的服务端事件推送技术，它允许客户端和服务端之间建立一个单向通道，以让服务端向客户端单方向持续推送事件消息；</li>\n<li>为了提高性能，HTTP/2 规范中新添加的服务端推送机制，我们在 <a href=\"https://time.geekbang.org/column/article/134752\">[第 01 讲]</a> 中提到过，并在该讲的扩展阅读中有它的原理介绍；</li>\n<li>WebRTC，即 Web Real-Time Communication，它是一个支持网页进行视频、语音通信的协议标准，不久前已被加入 W3C 标准，最新的 Chrome 和 Firefox 等主流浏览器都支持；</li>\n<li>还有一些利用浏览器插件和扩展达成的服务端推送技术，比如使用 Flash 的 XMLSocket，比如使用 Java 的 Applet，但这些随着 HTML 5 的普及，正慢慢被淘汰。</li>\n</ul><p>你看，通过学习一两个典型的技术，再拓展开，去类比了解和分析思考同一领域内的其它技术，就能掌握到最核心的东西，这就是我推荐的一种学习全栈技术的方式。</p><h2>总结思考</h2><p>今天我们从 HTTP 的交互局限性引出了网络交互中 Pull 和 Push 的两大模型，比较了它们的优劣。服务端 Push 的方式具备高效性和实时性的优势，而客户端 Pull 的方式令服务端免去状态的维护，从根本上简化了系统。</p><p>之后我们以 Comet 和 WebSocket 为重点，介绍了服务端推送的不同方式，尤其是用了实际抓包分析，介绍了通过 HTTP “升级”的方式来建立 WebSocket 连接的原理。</p><p>今天学习得怎样呢？来看这样两个问题：</p><ul>\n<li>文中介绍了 Push 和 Pull 在原理上的不同，在你的实际项目中，是否应用了 Push 或 Pull 的模型呢？</li>\n<li>文中介绍了 Push 比 Pull 具备高效性和实时性的优势，而 Pull 比 Push 则具备使得服务变得无状态的优势，除了最重要的这几个，你还能说出更多它们各自的优势吗？</li>\n</ul><p>今天的内容就到这里。以 HTTP 协议为核心，介绍网络协议的三讲文章已经更新完毕了，你是否对于全栈技术本身，还有适合自己的学习方法，有了新的理解呢？欢迎留言和我讨论。</p><h2>扩展阅读</h2><ul>\n<li>文中提到了跨域问题，如果感兴趣，推荐你阅读 MDN 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\">HTTP访问控制（CORS）</a>这篇文章。</li>\n<li>TutorialsPoint 的 <a href=\"https://www.tutorialspoint.com/websockets/\">WebSocket 系统教程</a>，对于本文介绍的 WebSocket 协议，需要进一步了解的一个好去处。</li>\n<li>关于 HTTP Update 头的 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.42\">RFC 2616 协议片段</a>和 WebSocket 的 <a href=\"https://tools.ietf.org/html/rfc6455\">RFC 6445</a>，你也许对响应和请求中的其它 HTTP 头心存疑问，和之前介绍的 HTTP 的 RFC 协议一样，你通常不需要仔细阅读，但它是对协议有问题时的最终去处。</li>\n<li><a href=\"https://www.html5rocks.com/en/tutorials/eventsource/basics/\">Stream Updates with Server-Sent Events</a>，一篇非常好的介绍 SSE 基础，和同类技术比较优劣，并给出代码示例的文章；如果你对 WebRTC 感兴趣，那么可以先看看这个<a href=\"http://io13webrtc.appspot.com/#1\">胶片</a>，再阅读这篇基础知识 <a href=\"https://www.html5rocks.com/en/tutorials/webrtc/basics/\">Getting Started with WebRTC</a>。</li>\n</ul><p></p>","comments":[{"had_liked":false,"id":170230,"user_name":"LiYanbin","can_delete":false,"product_type":"c1","uid":1129976,"ip_address":"","ucode":"2F50493F818909","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/f8/b13674e6.jpg","comment_is_top":false,"comment_ctime":1578554221,"is_pvip":false,"replies":[{"id":"66063","content":"我是这样认为的：<br><br>就像你说的，比如可靠性，保序性，拥塞控制等等，完全是可以放到应用层来做的。<br><br>但是，对应用层来说，它们关心的内容，不需要，也不应该包括这些传输方面的基本特性，或者说，已经有传输层的TCP把这些事做好了。而协议的设计者，关心他&#47;她设计的协议想解决的问题，这些传输方面的特性，拿来用就可以了，而不需要再实现一遍。<br><br>往大了说，软件分层的目的最大目的，就是解耦。解耦之后“谁”做“什么事”就是每一层的职责，7层&#47;5层模型里的传输层也一样。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1578588410,"ip_address":"","comment_id":170230,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10168488813","product_id":100035501,"comment_content":"感谢回答！我的表述有误，其实我是想知道，服务器推送技术，像websock这种技术，其实就是服务器和客户端建立一条连接，建立连接可以基于TCP也可以基于UDP，但是却很少见到基于UDP的上层应用协议。<br>    如果说是因为TCP可靠性，时序性，保活这些特性才选择TCP，那这些特性转移到应用层这一层来维护也非不可。<br>    那究竟是何原因导致在服务器推送技术领域中，没有广泛应用的基于UDP的上层应用协议呢？","like_count":2,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480893,"discussion_content":"我是这样认为的：\n\n就像你说的，比如可靠性，保序性，拥塞控制等等，完全是可以放到应用层来做的。\n\n但是，对应用层来说，它们关心的内容，不需要，也不应该包括这些传输方面的基本特性，或者说，已经有传输层的TCP把这些事做好了。而协议的设计者，关心他/她设计的协议想解决的问题，这些传输方面的特性，拿来用就可以了，而不需要再实现一遍。\n\n往大了说，软件分层的目的最大目的，就是解耦。解耦之后“谁”做“什么事”就是每一层的职责，7层/5层模型里的传输层也一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578588410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129976,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3d/f8/b13674e6.jpg","nickname":"LiYanbin","note":"","ucode":"2F50493F818909","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128177,"discussion_content":"感谢回答！回答中的角度是一个非常棒的角度。是的，如果没有性能，效率，资源限制等问题，没有必要再去应用层去自己实现一遍。具体应用要根据具体的应用场景去选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578618912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169226,"user_name":"LiYanbin","can_delete":false,"product_type":"c1","uid":1129976,"ip_address":"","ucode":"2F50493F818909","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/f8/b13674e6.jpg","comment_is_top":false,"comment_ctime":1578297381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10168231973","product_id":100035501,"comment_content":"服务端能够推送消息给客户端，就需要事先知道客户端开放的端口。这就不难理解各种服务端推送技术了。","like_count":3},{"had_liked":false,"id":137407,"user_name":"学不动了","can_delete":false,"product_type":"c1","uid":1235562,"ip_address":"","ucode":"6855C982ECC3A8","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/6a/6b96edbd.jpg","comment_is_top":false,"comment_ctime":1569733479,"is_pvip":true,"replies":[{"id":"52895","content":"好问题，是这样的，HTTP&#47;1.1 Comet 的一个局限性就在这里，也就是说，传输是单工的，从协议的角度来说，服务端的响应分多次返回，因此这个过程中，返回并没有传输完，那么对于该次 HTTP 连接来说，客户端也就无法发送新的请求。<br><br>当然，除了升级到 HTTP&#47;2 或者采用其他技术以外，对于这个问题本身，还是有一些改进办法的，你可以思考一下。:)","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569816620,"ip_address":"","comment_id":137407,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5864700775","product_id":100035501,"comment_content":"老师你好，我有个疑问，是关于comet: 客户端必须在服务端结束当次传输后才能向服务端发送消息，服务端会采用分块传输，也就是&quot;我说完你再说&quot;，客户端这时候有新的请求就只能等着才能发送？要是长时间不结束客户端的请求就没法发送了嘛？","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469074,"discussion_content":"好问题，是这样的，HTTP/1.1 Comet 的一个局限性就在这里，也就是说，传输是单工的，从协议的角度来说，服务端的响应分多次返回，因此这个过程中，返回并没有传输完，那么对于该次 HTTP 连接来说，客户端也就无法发送新的请求。\n\n当然，除了升级到 HTTP/2 或者采用其他技术以外，对于这个问题本身，还是有一些改进办法的，你可以思考一下。:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569816620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296742,"discussion_content":"改进办法可以这样吗？客户端这时主动结束此次连接，然后再重新发起来一个新连接来发送这次请求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596637531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133765,"user_name":"Chocolate","can_delete":false,"product_type":"c1","uid":1013822,"ip_address":"","ucode":"242CF0E3C10E97","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/3e/c39d86f1.jpg","comment_is_top":false,"comment_ctime":1568648221,"is_pvip":false,"replies":[{"id":"51365","content":"对于大多数分布式的系统来说，Pull 确实要比 Push 实现起来方便一些，但是也不绝对。至于你说的“是否引入新的框架”这个描述比较模糊，两种方式和是否引入框架没有必然联系。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568692536,"ip_address":"","comment_id":133765,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5863615517","product_id":100035501,"comment_content":"第一个问题，我们的后台系统里的二维码扫码登录用的就是 Pull 的形式，每隔一段时间就去轮询有没有扫码，有没有确认登录，对于后台这类系统是可以满足需求的；在调度系统里的状态实时推送里用到了 WebSocket 技术，可以实时反馈任务的执行情况。<br><br>第二个问题，Push 模型的优势是高效性和实时性，Pull 模型的优点除了无状态外，优势可能是实现起来更方便，不用引入新的框架<br><br>","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467499,"discussion_content":"对于大多数分布式的系统来说，Pull 确实要比 Push 实现起来方便一些，但是也不绝对。至于你说的“是否引入新的框架”这个描述比较模糊，两种方式和是否引入框架没有必然联系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568692536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296738,"discussion_content":"对于大多数分布式的系统来说，Pull 确实要比 Push 实现起来方便一些. 老师能举例具体解释一下吗？还是希望听更多的过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596636820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133669,"user_name":"记忆犹存","can_delete":false,"product_type":"c1","uid":1084441,"ip_address":"","ucode":"8ACCA77CF83F91","user_header":"https://static001.geekbang.org/account/avatar/00/10/8c/19/4e1989bf.jpg","comment_is_top":false,"comment_ctime":1568631103,"is_pvip":false,"replies":[{"id":"51358","content":"感谢分享！<br><br>对于 Push 模型，你说的内容都是正确的，就提一点，对于你提到的数据包堆积和流控的问题，可以引入第三方的消息队列服务来协调消息发布者和订阅者，来缓解你说的问题。<br><br>对于 Pull 模型，“传输失败不用重试”这个不对，因为是不是重试并非 Push 或 Pull 的区别，二者都可以重试，也都可以不重试，取决于设计。其它正确。<br><br>当然，这是一个开放性问题，还有其它的优缺点，你也可以看看其他人的答复。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568690697,"ip_address":"","comment_id":133669,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863598399","product_id":100035501,"comment_content":"Push 的模型<br>优点：响应及时<br>缺点：<br>a.如果客户端接收不及时，造成数据包堆积；<br>b. 需要客户端做流控处理；<br><br>Pull模型<br>优点：<br>a. 提取消息方便<br>b. 传输失败不用重试<br>缺点：实时性差","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467471,"discussion_content":"感谢分享！\n\n对于 Push 模型，你说的内容都是正确的，就提一点，对于你提到的数据包堆积和流控的问题，可以引入第三方的消息队列服务来协调消息发布者和订阅者，来缓解你说的问题。\n\n对于 Pull 模型，“传输失败不用重试”这个不对，因为是不是重试并非 Push 或 Pull 的区别，二者都可以重试，也都可以不重试，取决于设计。其它正确。\n\n当然，这是一个开放性问题，还有其它的优缺点，你也可以看看其他人的答复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568690697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133466,"user_name":"許敲敲","can_delete":false,"product_type":"c1","uid":1046681,"ip_address":"","ucode":"6486466820E7BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/99/8e760987.jpg","comment_is_top":false,"comment_ctime":1568588587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863555883","product_id":100035501,"comment_content":"谢谢老师给这么多资料","like_count":1},{"had_liked":false,"id":271191,"user_name":"richie","can_delete":false,"product_type":"c1","uid":1924421,"ip_address":"","ucode":"6923B8707088B8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/5d/45/705dd53c.jpg","comment_is_top":false,"comment_ctime":1609460001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609460001","product_id":100035501,"comment_content":"热情似火的优秀","like_count":0},{"had_liked":false,"id":245449,"user_name":"Geek_02f3e8","can_delete":false,"product_type":"c1","uid":2068129,"ip_address":"","ucode":"0DD51EF79A4952","user_header":"","comment_is_top":false,"comment_ctime":1598947228,"is_pvip":false,"replies":[{"id":"90348","content":"赞","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1599024616,"ip_address":"","comment_id":245449,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598947228","product_id":100035501,"comment_content":"老师讲的非常详细，我还想额外补充一个日常使用webcosket时需要注意的点。<br>websocket在解除跨域限制的同时，也产生了新的安全问题：在upgrade到ws协议时，服务端对于origin字段校验的缺失可能会导致websocket跨域劫持的安全问题。<br>攻击者诱导受害者点击包含一段以ws协议发送指定恶意内容的js的钓鱼页面，即可以受害者身份发送该ws数据，这是一个类似HTTP CSRF的问题：CSWH(Cross-site websocket-hijacking)。","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504882,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599024616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169200,"user_name":"LiYanbin","can_delete":false,"product_type":"c1","uid":1129976,"ip_address":"","ucode":"2F50493F818909","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/f8/b13674e6.jpg","comment_is_top":false,"comment_ctime":1578291918,"is_pvip":false,"replies":[{"id":"65864","content":"其实基于 UDP 的应用层协议也有一些，常听说的比如有 DHCP。之所以我们平时接触的不多，主要还是由它们的特点所决定的，你可以看一下 https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;User_Datagram_Protocol#Comparison_of_UDP_and_TCP 比如其中提到的可靠性和有序性就是我们一般应用层的基本通信要求。<br><br>另外一个，HTTP&#47;3 也会使用 UDP 代替 TCP，主要原因还是在物理设备改进，传输质量提升了以后，出于性能的考虑。可以参见：https:&#47;&#47;thenewstack.io&#47;http-3-replaces-tcp-with-udp-to-boost-network-speed-reliability&#47;","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1578438247,"ip_address":"","comment_id":169200,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578291918","product_id":100035501,"comment_content":"对于服务端推送技术，之前有考虑过，有一个疑问，为何客户端和服务器端为何不直接通过UDP进行通信呢？换句话说，为何在服务器推送技术中没有一种 比较被广泛应用的+基于UDP的 应用层协议呢？","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480453,"discussion_content":"其实基于 UDP 的应用层协议也有一些，常听说的比如有 DHCP。之所以我们平时接触的不多，主要还是由它们的特点所决定的，你可以看一下 https://en.wikipedia.org/wiki/User_Datagram_Protocol#Comparison_of_UDP_and_TCP 比如其中提到的可靠性和有序性就是我们一般应用层的基本通信要求。\n\n另外一个，HTTP/3 也会使用 UDP 代替 TCP，主要原因还是在物理设备改进，传输质量提升了以后，出于性能的考虑。可以参见：https://thenewstack.io/http-3-replaces-tcp-with-udp-to-boost-network-speed-reliability/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578438247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151988,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1573828946,"is_pvip":false,"replies":[{"id":"58436","content":"最佳实践那一章的最后一篇特别放送，我会讲一讲程序员怎么学英语。可以期待一下。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1573841712,"ip_address":"","comment_id":151988,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573828946","product_id":100035501,"comment_content":"老师我看不懂英文资料，是不是多看看就会有感觉了？有没有啥秘诀。。。","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474679,"discussion_content":"最佳实践那一章的最后一篇特别放送，我会讲一讲程序员怎么学英语。可以期待一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573841712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143688,"user_name":"liansng","can_delete":false,"product_type":"c1","uid":1013051,"ip_address":"","ucode":"6BA073817E5D08","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/3b/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1571756292,"is_pvip":false,"replies":[{"id":"55656","content":"这是你打开 https:&#47;&#47;www.websocket.org&#47;echo.html 的时候，它已经默认帮你填好的内容","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1571894467,"ip_address":"","comment_id":143688,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571756292","product_id":100035501,"comment_content":"<br>Location:<br>wss:&#47;&#47;echo.websocket.org<br>Message:<br>Rock it with HTML5 WebSocket<br><br>这个的操作方式我没太看懂，老师可以帮忙解释一下吗？","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471653,"discussion_content":"这是你打开 https://www.websocket.org/echo.html 的时候，它已经默认帮你填好的内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571894467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141560,"user_name":"vip3","can_delete":false,"product_type":"c1","uid":1317600,"ip_address":"","ucode":"2523A7625E0D92","user_header":"","comment_is_top":false,"comment_ctime":1571191082,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571191082","product_id":100035501,"comment_content":"老师您好，请教个问题。<br><br>我想让pad和PC之上的两个应用全双工通信，想到两种办法。<br><br>一是和服务器建立websocket连接，让其作为通讯的中转，但是这种方法网络不好的情况下容易挂掉；<br><br>为了解决办法一的问题，想了第二个方法，在PC上启动一个websocket server，让pad应用与PC应用内启的这个server建立连接，实现局域网内部全双工通信，但这有个限制，必须要求pad和PC连到同一局域网下。但是因为PC可能连接着网线，也可能在用无线网络，且无线网络不止一个，我检测不出来PC和pad连接的是否是同一子网。<br><br>所以想问问老师，有没有什么办法能解决上述两个办法的问题？","like_count":0,"discussions":[{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289890,"discussion_content":"根据IP不就可以判断了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594259371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136170,"user_name":"CC","can_delete":false,"product_type":"c1","uid":1021014,"ip_address":"","ucode":"2B732860C4231B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/56/4b8395f6.jpg","comment_is_top":false,"comment_ctime":1569376689,"is_pvip":true,"replies":[{"id":"52464","content":"👍，你也可以看看其他回答","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569510619,"ip_address":"","comment_id":136170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569376689","product_id":100035501,"comment_content":"思考题 1：<br><br>工作中主要用到 Pull，还没有使用到 Push。<br><br><br><br>思考题 2：<br><br>Push 的优势还有：<br>- 客户端可以提前 cache push 过来的内容，在其他页面上使用。<br>- 服务端可以决定 push 的优先级，把影响 performance 的重要资源优先 push。<br>- 客户端可以根据自己的情况，选择是否接受 push，或者限制数量。<br><br><br>Pull 的 stateless 带来的优势强大，其他的优势还没有查到。<br><br>","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468492,"discussion_content":"👍，你也可以看看其他回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569510619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135793,"user_name":"pyhhou","can_delete":false,"product_type":"c1","uid":1256496,"ip_address":"","ucode":"31EF8D50CF91A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","comment_is_top":false,"comment_ctime":1569281232,"is_pvip":false,"replies":[{"id":"52090","content":"感谢回复。<br><br>1. 正确。<br><br>2. 不一定。而且即便客户端需要保持服务端状态，也比服务端保持客户端状态，要简单得多（数量上是 1 和 N 的关系，在横向扩展的时候，这个 N 就可能成为瓶颈）<br><br>你说的这个 push-pull 结合的方式很好，其实它是一种非常常见的实现方式，你可以想想互联网有哪些应用。:)","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569298743,"ip_address":"","comment_id":135793,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1569281232","product_id":100035501,"comment_content":"思考题：<br>1. 在实际的项目中用 pull 的例子比较多，没怎么接触过 push，感觉上 push 的话是不是会相对来说复杂些，因为要维护不同 client 的状态；相对来说 pull 的话，只用基于 request 参数做相应的 response 即可<br><br>2. 这里我在想，pull 的无状态优势只是对于服务器端来说的，如果在客户端，对于 pull 来说，是不是需要保存服务器的状态？另外，由于 push 是有状态的，那么状态在服务器上的存储会不会成为一个难题？从分析来看，pull 的缺点是 push 的优点，push 的缺点又是 pull 的优点，我想到了前一章我们讲过对称加密和非对称加密，对称加密高效但是 key 不易分享，非对称加密 key 易分享但是不高效，因此 HTTPS 将他们两个做了个结合。这里或许我们也可以将 push 和 pull 结合起来使用，比如，消息更新的时候，服务器端使用 push 通知客户端更新资源，然后客户端使用 pull 获取资源，这样会不会比单一使用 pull 或 push 更好？<br><br>很赞同老师说的，学习就是需要去用自己学过的东西对比理解和分析新学的东西，深度理解他们的本质思想，以及区别和共同点，这样才能形成知识体系，这会对新知识的掌握更快，对技术也会有更高维度的认识<br><br>关于学习全栈专栏的认识：<br>学完了这几章，感觉自己知道的东西还是太少，老师推荐的文章都很好，也很有深度，但是有些文章真的没有时间去仔细推敲，我在想，先把整个专栏跟下来，对全栈知识有个宏观的认识，然后在仔细阅读这些著作，老师你觉得这样是否可行呢？<br><br>收获很多，谢谢老师","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468344,"discussion_content":"感谢回复。\n\n1. 正确。\n\n2. 不一定。而且即便客户端需要保持服务端状态，也比服务端保持客户端状态，要简单得多（数量上是 1 和 N 的关系，在横向扩展的时候，这个 N 就可能成为瓶颈）\n\n你说的这个 push-pull 结合的方式很好，其实它是一种非常常见的实现方式，你可以想想互联网有哪些应用。:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569298743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256496,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","nickname":"pyhhou","note":"","ucode":"31EF8D50CF91A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20713,"discussion_content":"一个之前看到的微博的例子，微博中有关注者（粉丝）和被关注者，push 就是说被关注者每发一个动态，服务器就会将动态推送到关注者这边；pull 就是关注者主动去取被关注者的动态。对于明星用户来说，关注者特别多，push 在这个时候实现动态更新的发送就会遇到难题，另一方面，对于 pull 来说，如果用户量上来的话，会有一个服务器数据库高频率读取的问题，有时候实时性没有办法保证。或许在这个时候 push + pull 不失为一个可以考虑的方向","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569351828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135303,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1569121552,"is_pvip":false,"replies":[{"id":"51925","content":"你可以自己尝试实现一个最简单的 Comet：<br><br>客户端，你甚至都不用写 JavaScript，一个普通的 get 请求即可——浏览器直接访问某一个服务端暴露的接口（URL）。<br><br>服务端则是往响应中写数据，使用按块传输，返回类型设置为 plain&#47;text，随便写一点数据并 flush，然后 sleep 10 秒，再写一点并 flush，再 sleep 10 秒，如是多次，这样可以模拟多次返回。<br><br>这样，你会看到浏览器一直在加载，页面十秒十秒地新增新的内容。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569174767,"ip_address":"","comment_id":135303,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569121552","product_id":100035501,"comment_content":"请问今天的课堂实例如果要自己用代码来实现，前后段代码是否有相关的实例代码可以做参考？","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468134,"discussion_content":"你可以自己尝试实现一个最简单的 Comet：\n\n客户端，你甚至都不用写 JavaScript，一个普通的 get 请求即可——浏览器直接访问某一个服务端暴露的接口（URL）。\n\n服务端则是往响应中写数据，使用按块传输，返回类型设置为 plain/text，随便写一点数据并 flush，然后 sleep 10 秒，再写一点并 flush，再 sleep 10 秒，如是多次，这样可以模拟多次返回。\n\n这样，你会看到浏览器一直在加载，页面十秒十秒地新增新的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569174767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134363,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1583321,"ip_address":"","ucode":"29692959077496","user_header":"https://static001.geekbang.org/account/avatar/00/18/28/d9/78dfd983.jpg","comment_is_top":false,"comment_ctime":1568813403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568813403","product_id":100035501,"comment_content":"之前一个项目中IM是用websocket实现的。","like_count":0},{"had_liked":false,"id":133885,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1568690741,"is_pvip":false,"replies":[{"id":"51368","content":"HTTP&#47;2 确实有了专门的 server push，但这个最主要用来解决资源的预加载问题。因此，如果要完全替代 Comet，实现任意时刻的推送，可以使用 SSE 等技术，或者是将 server push 和 SSE 等技术结合起来（即让浏览器端预留一个回调来响应服务端的推送）。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568695588,"ip_address":"","comment_id":133885,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568690741","product_id":100035501,"comment_content":"老师你好，文章写的真好？但是我有点疑问，就是看comet是一个单工的，也就是“我说完了，你再说”。但是他还是一个基于HTTP协议的，我的理解就是keep-alive。那问题来了我要是用HTTP2.0的话是不是可以把comet转化为双工的呢，因为HTTP2.0是双工通讯？","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467544,"discussion_content":"HTTP/2 确实有了专门的 server push，但这个最主要用来解决资源的预加载问题。因此，如果要完全替代 Comet，实现任意时刻的推送，可以使用 SSE 等技术，或者是将 server push 和 SSE 等技术结合起来（即让浏览器端预留一个回调来响应服务端的推送）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568695588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133696,"user_name":"四喜","can_delete":false,"product_type":"c1","uid":1071389,"ip_address":"","ucode":"C5EBED19C0F332","user_header":"https://static001.geekbang.org/account/avatar/00/10/59/1d/c89abcd8.jpg","comment_is_top":false,"comment_ctime":1568638170,"is_pvip":false,"replies":[{"id":"51359","content":"非常好的问题！<br><br>是的，完全正确。你可以考虑这样几点：<br>1. 客户端和服务端，还有网关等中间节点，都要商定好一个最大的超时时间。并且，业务端配置的超时时间要稍短于其它，以留足余量。<br>2. 服务端即便没有消息需要推送，也要定期返回一个无业务意义的消息，以避免超时发生。<br>3. 客户端如果在若干个推送周期后，可以结束连接，休息一段时间，再重新连接。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568691028,"ip_address":"","comment_id":133696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568638170","product_id":100035501,"comment_content":"老师讲得真好。<br><br>提问🙋，Comet这种假PUSH方式，由客户端发起的HTTP请求服务器不释放，但是会受超时限制吧？","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467475,"discussion_content":"非常好的问题！\n\n是的，完全正确。你可以考虑这样几点：\n1. 客户端和服务端，还有网关等中间节点，都要商定好一个最大的超时时间。并且，业务端配置的超时时间要稍短于其它，以留足余量。\n2. 服务端即便没有消息需要推送，也要定期返回一个无业务意义的消息，以避免超时发生。\n3. 客户端如果在若干个推送周期后，可以结束连接，休息一段时间，再重新连接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568691028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133551,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1568603143,"is_pvip":false,"replies":[{"id":"51333","content":"谢谢。<br>很多技术都是相通的，学习全栈技术都是可以用类比的方式进行的。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568675719,"ip_address":"","comment_id":133551,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568603143","product_id":100035501,"comment_content":"四火老师讲得真好，服务端推送模型最后都可以看作是Comet和WebSocket的变形。","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467424,"discussion_content":"谢谢。\n很多技术都是相通的，学习全栈技术都是可以用类比的方式进行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568675719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133527,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1568597140,"is_pvip":false,"replies":[{"id":"51357","content":"感谢分享！<br>关于第 2) 个答复：解包和封包其实并不是 push 和 poll 的本质区别，poll 也可以由解包封包，也可以定义一套消息结构。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1568690187,"ip_address":"","comment_id":133527,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568597140","product_id":100035501,"comment_content":"1)公司一个简单的聊天业务系统！就用了push模型！<br>2)push模型处理信息比poll稍微复杂一些！存在解包封包！需要定一套消息结构！<br>","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467415,"discussion_content":"感谢分享！\n关于第 2) 个答复：解包和封包其实并不是 push 和 poll 的本质区别，poll 也可以由解包封包，也可以定义一套消息结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568690187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13741,"discussion_content":"嗯嗯，明白了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568696908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}