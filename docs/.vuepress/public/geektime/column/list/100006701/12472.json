{"id":12472,"title":"第37讲 | 谈谈Spring Bean的生命周期和作用域？","content":"<p>在企业应用软件开发中，Java是毫无争议的主流语言，开放的Java EE规范和强大的开源框架功不可没，其中Spring毫无疑问已经成为企业软件开发的事实标准之一。今天这一讲，我将补充Spring相关的典型面试问题，并谈谈其部分设计细节。</p>\n<p>今天我要问你的问题是，<span class=\"orange\">谈谈Spring Bean的生命周期和作用域？</span></p>\n<h2>典型回答</h2>\n<p>Spring Bean生命周期比较复杂，可以分为创建和销毁两个过程。</p>\n<p>首先，创建Bean会经过一系列的步骤，主要包括：</p>\n<ul>\n<li>\n<p>实例化Bean对象。</p>\n</li>\n<li>\n<p>设置Bean属性。</p>\n</li>\n<li>\n<p>如果我们通过各种Aware接口声明了依赖关系，则会注入Bean对容器基础设施层面的依赖。具体包括BeanNameAware、BeanFactoryAware和ApplicationContextAware，分别会注入Bean ID、Bean Factory或者ApplicationContext。</p>\n</li>\n<li>\n<p>调用BeanPostProcessor的前置初始化方法postProcessBeforeInitialization。</p>\n</li>\n<li>\n<p>如果实现了InitializingBean接口，则会调用afterPropertiesSet方法。</p>\n</li>\n<li>\n<p>调用Bean自身定义的init方法。</p>\n</li>\n<li>\n<p>调用BeanPostProcessor的后置初始化方法postProcessAfterInitialization。</p>\n</li>\n<li>\n<p>创建过程完毕。</p>\n</li>\n</ul><!-- [[[read_end]]] -->\n<p>你可以参考下面示意图理解这个具体过程和先后顺序。<br />\n<img src=\"https://static001.geekbang.org/resource/image/3a/7e/3a51f06f56b905b8fbf1661359e1727e.png?wh=462*571\" alt=\"\" /></p>\n<p>第二，Spring Bean的销毁过程会依次调用DisposableBean的destroy方法和Bean自身定制的destroy方法。</p>\n<p>Spring Bean有五个作用域，其中最基础的有下面两种：</p>\n<ul>\n<li>\n<p>Singleton，这是Spring的默认作用域，也就是为每个IOC容器创建唯一的一个Bean实例。</p>\n</li>\n<li>\n<p>Prototype，针对每个getBean请求，容器都会单独创建一个Bean实例。</p>\n</li>\n</ul>\n<p>从Bean的特点来看，Prototype适合有状态的Bean，而Singleton则更适合无状态的情况。另外，使用Prototype作用域需要经过仔细思考，毕竟频繁创建和销毁Bean是有明显开销的。</p>\n<p>如果是Web容器，则支持另外三种作用域：</p>\n<ul>\n<li>\n<p>Request，为每个HTTP请求创建单独的Bean实例。</p>\n</li>\n<li>\n<p>Session，很显然Bean实例的作用域是Session范围。</p>\n</li>\n<li>\n<p>GlobalSession，用于Portlet容器，因为每个Portlet有单独的Session，GlobalSession提供一个全局性的HTTP Session。</p>\n</li>\n</ul>\n<h2>考点分析</h2>\n<p>今天我选取的是一个入门性质的高频Spring面试题目，我认为相比于记忆题目典型回答里的细节步骤，理解和思考Bean生命周期所体现出来的Spring设计和机制更有意义。</p>\n<p>你能看到，Bean的生命周期是完全被容器所管理的，从属性设置到各种依赖关系，都是容器负责注入，并进行各个阶段其他事宜的处理，Spring容器为应用开发者定义了清晰的生命周期沟通界面。</p>\n<p>如果从具体API设计和使用技巧来看，还记得我在<a href=\"http://time.geekbang.org/column/article/8471\">专栏第13讲</a>提到过的Marker Interface吗，Aware接口就是个典型应用例子，Bean可以实现各种不同Aware的子接口，为容器以Callback形式注入依赖对象提供了统一入口。</p>\n<p>言归正传，还是回到Spring的学习和面试。关于Spring，也许一整本书都无法完整涵盖其内容，专栏里我会有限地补充：</p>\n<ul>\n<li>\n<p>Spring的基础机制。</p>\n</li>\n<li>\n<p>Spring框架的涵盖范围。</p>\n</li>\n<li>\n<p>Spring AOP自身设计的一些细节，前面<a href=\"http://time.geekbang.org/column/article/10076\">第24讲</a>偏重于底层实现原理，这样还不够全面，毕竟不管是动态代理还是字节码操纵，都还只是基础，更需要Spring层面对切面编程的支持。</p>\n</li>\n</ul>\n<h2>知识扩展</h2>\n<p>首先，我们先来看看Spring的基础机制，至少你需要理解下面两个基本方面。</p>\n<ul>\n<li>控制反转（Inversion of Control），或者也叫依赖注入（Dependency Injection），广泛应用于Spring框架之中，可以有效地改善了模块之间的紧耦合问题。</li>\n</ul>\n<p>从Bean创建过程可以看到，它的依赖关系都是由容器负责注入，具体实现方式包括带参数的构造函数、setter方法或者<a href=\"https://docs.spring.io/spring-framework/docs/5.0.3.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html\">AutoWired</a>方式实现。</p>\n<ul>\n<li>AOP，我们已经在前面接触过这种切面编程机制，Spring框架中的事务、安全、日志等功能都依赖于AOP技术，下面我会进一步介绍。</li>\n</ul>\n<p>第二，Spring到底是指什么？</p>\n<p>我前面谈到的Spring，其实是狭义的<a href=\"https://github.com/spring-projects/spring-framework/blob/67ea4b3a050af3db5545f58ff85a0d132ee91c2a/spring-aop/src/main/java/org/aopalliance/aop/Advice.java\">Spring Framework</a>，其内部包含了依赖注入、事件机制等核心模块，也包括事务、O/R Mapping等功能组成的数据访问模块，以及Spring MVC等Web框架和其他基础组件。</p>\n<p>广义上的Spring已经成为了一个庞大的生态系统，例如：</p>\n<ul>\n<li>\n<p>Spring Boot，通过整合通用实践，更加自动、智能的依赖管理等，Spring Boot提供了各种典型应用领域的快速开发基础，所以它是以应用为中心的一个框架集合。</p>\n</li>\n<li>\n<p>Spring Cloud，可以看作是在Spring Boot基础上发展出的更加高层次的框架，它提供了构建分布式系统的通用模式，包含服务发现和服务注册、分布式配置管理、负载均衡、分布式诊断等各种子系统，可以简化微服务系统的构建。</p>\n</li>\n<li>\n<p>当然，还有针对特定领域的Spring Security、Spring Data等。</p>\n</li>\n</ul>\n<p>上面的介绍比较笼统，针对这么多内容，如果将目标定得太过宽泛，可能就迷失在Spring生态之中，我建议还是深入你当前使用的模块，如Spring MVC。并且，从整体上把握主要前沿框架（如Spring Cloud）的应用范围和内部设计，至少要了解主要组件和具体用途，毕竟如何构建微服务等，已经逐渐成为Java应用开发面试的热点之一。</p>\n<p>第三，我们来探讨一下更多有关Spring AOP自身设计和实现的细节。</p>\n<p>先问一下自己，我们为什么需要切面编程呢？</p>\n<p>切面编程落实到软件工程其实是为了更好地模块化，而不仅仅是为了减少重复代码。通过AOP等机制，我们可以把横跨多个不同模块的代码抽离出来，让模块本身变得更加内聚，进而业务开发者可以更加专注于业务逻辑本身。从迭代能力上来看，我们可以通过切面的方式进行修改或者新增功能，这种能力不管是在问题诊断还是产品能力扩展中，都非常有用。</p>\n<p>在之前的分析中，我们已经分析了AOP Proxy的实现原理，简单回顾一下，它底层是基于JDK动态代理或者cglib字节码操纵等技术，运行时动态生成被调用类型的子类等，并实例化代理对象，实际的方法调用会被代理给相应的代理对象。但是，这并没有解释具体在AOP设计层面，什么是切面，如何定义切入点和切面行为呢？</p>\n<p>Spring AOP引入了其他几个关键概念：</p>\n<ul>\n<li>\n<p>Aspect，通常叫作方面，它是跨不同Java类层面的横切性逻辑。在实现形式上，既可以是XML文件中配置的普通类，也可以在类代码中用“@Aspect”注解去声明。在运行时，Spring框架会创建类似<a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-aop/src/main/java/org/springframework/aop/Advisor.java\">Advisor</a>来指代它，其内部会包括切入的时机（Pointcut）和切入的动作（Advice）。</p>\n</li>\n<li>\n<p>Join Point，它是Aspect可以切入的特定点，在Spring里面只有方法可以作为Join Point。</p>\n</li>\n<li>\n<p><a href=\"https://github.com/spring-projects/spring-framework/blob/67ea4b3a050af3db5545f58ff85a0d132ee91c2a/spring-aop/src/main/java/org/aopalliance/aop/Advice.java\"></a><a href=\"https://github.com/spring-projects/spring-framework/blob/67ea4b3a050af3db5545f58ff85a0d132ee91c2a/spring-aop/src/main/java/org/aopalliance/aop/Advice.java\">Advice</a>，它定义了切面中能够采取的动作。如果你去看Spring源码，就会发现Advice、Join Point并没有定义在Spring自己的命名空间里，这是因为他们是源自<a href=\"http://aopalliance.sourceforge.net/\">AOP联盟</a>，可以看作是Java工程师在AOP层面沟通的通用规范。</p>\n</li>\n</ul>\n<p>Java核心类库中同样存在类似代码，例如Java 9中引入的Flow API就是Reactive Stream规范的最小子集，通过这种方式，可以保证不同产品直接的无缝沟通，促进了良好实践的推广。</p>\n<p>具体的Spring Advice结构请参考下面的示意图。<br />\n<img src=\"https://static001.geekbang.org/resource/image/5b/ba/5b6955b4757c1a5fd0ecacdaf835e3ba.png?wh=850*371\" alt=\"\" /></p>\n<p>其中，BeforeAdvice和AfterAdvice包括它们的子接口是最简单的实现。而Interceptor则是所谓的拦截器，用于拦截住方法（也包括构造器）调用事件，进而采取相应动作，所以Interceptor是覆盖住整个方法调用过程的Advice。通常将拦截器类型的Advice叫作Around，在代码中可以使用“@Around”来标记，或者在配置中使用“&lt;aop:around&gt;”。</p>\n<p>如果从时序上来看，则可以参考下图，理解具体发生的时机。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/85/cb/85205c0c0ddcdafd2fad4ff5a53af0cb.png?wh=479*309\" alt=\"\" /></p>\n<ul>\n<li>Pointcut，它负责具体定义Aspect被应用在哪些Join Point，可以通过指定具体的类名和方法名来实现，或者也可以使用正则表达式来定义条件。</li>\n</ul>\n<p>你可以参看下面的示意图，来进一步理解上面这些抽象在逻辑上的意义。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/de/4a/dee96c33619d76d33281332bb3d2494a.png?wh=475*413\" alt=\"\" /></p>\n<ul>\n<li>\n<p>Join Point仅仅是可利用的机会。</p>\n</li>\n<li>\n<p>Pointcut是解决了切面编程中的Where问题，让程序可以知道哪些机会点可以应用某个切面动作。</p>\n</li>\n<li>\n<p>而Advice则是明确了切面编程中的What，也就是做什么；同时通过指定Before、After或者Around，定义了When，也就是什么时候做。</p>\n</li>\n</ul>\n<p>在准备面试时，如果在实践中使用过AOP是最好的，否则你可以选择一个典型的AOP实例，理解具体的实现语法细节，因为在面试考察中也许会问到这些技术细节。</p>\n<p>如果你有兴趣深入内部，最好可以结合Bean生命周期，理解Spring如何解析AOP相关的注解或者配置项，何时何地使用到动态代理等机制。为了避免被庞杂的源码弄晕，我建议你可以从比较精简的测试用例作为一个切入点，如<a href=\"https://github.com/spring-projects/spring-framework/blob/da80502ea6ed4860f5bf7b668300644cdfe3bb5a/spring-context/src/test/java/org/springframework/aop/framework/CglibProxyTests.java\">CglibProxyTests</a>。</p>\n<p>另外，Spring框架本身功能点非常多，AOP并不是它所支持的唯一切面技术，它只能利用动态代理进行运行时编织，而不能进行编译期的静态编织或者类加载期编织。例如，在Java平台上，我们可以使用Java Agent技术，在类加载过程中对字节码进行操纵，比如修改或者替换方法实现等。在Spring体系中，如何做到类似功能呢？你可以使用AspectJ，它具有更加全面的能力，当然使用也更加复杂。</p>\n<p>今天我从一个常见的Spring面试题开始，浅谈了Spring的基础机制，探讨了Spring生态范围，并且补充分析了部分AOP的设计细节，希望对你有所帮助。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，请介绍一下Spring声明式事务的实现机制，可以考虑将具体过程画图。</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n<p></p>\n","neighbors":{"left":{"article_title":"第36讲 | 谈谈MySQL支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？","id":12288},"right":{"article_title":"第38讲 | 对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？","id":12629}},"comments":[{"had_liked":false,"id":21424,"user_name":"代码狂徒","can_delete":false,"product_type":"c1","uid":1030100,"ip_address":"","ucode":"F5918543E90321","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b7/d4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1535075728,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"624305333648","product_id":100006701,"comment_content":"感觉本篇文章跑题了呢，关于生命周期，只讨论了初始化过程和销毁过程，那么什么时候引发的初始化呢？什么时候触发销毁操作呢？spring容器管理的bean是在容器运行过程中不会被销毁吧？","like_count":146,"discussions":[{"author":{"id":1126538,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","nickname":"业余草","note":"","ucode":"99BDC1E629049D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291403,"discussion_content":"楼下总结的很好，生命周期和作用域还是最基本最简单的。建议看看这些https://mp.weixin.qq.com/s/mQ8ZM-jPvwY0rrUnhHYD8A","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1594805646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1305613,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ec/0d/596aa2b1.jpg","nickname":"Mr.NoBody","note":"","ucode":"E32A970865CF0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394636,"discussion_content":"其他的没看，这一篇真的纯属凑数啊，感觉抄都没好好抄，抄了一大堆空洞概念的堆砌","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631964764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2355521,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f1/41/76c0758f.jpg","nickname":"君战","note":"","ucode":"A8619A79A5CED9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374892,"discussion_content":"单例Bean，在IoC容器启动的过程中就会初始化；触发销毁是调用destroy()或close()方法；正常情况下是不会被销毁的，但是可以手动调用方法destroyBean()去销毁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621404589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58245,"user_name":"caoxile","can_delete":false,"product_type":"c1","uid":1023723,"ip_address":"","ucode":"11C17590F039EE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/eb/f68665b6.jpg","comment_is_top":false,"comment_ctime":1547017240,"is_pvip":false,"replies":[{"id":"23319","content":"谢谢反馈，每篇有3K左右的限制，有些细节就不面面俱到了，尽量让有限的内容起到抛砖引玉的作用","user_name":"作者回复","comment_id":58245,"uid":"1009360","ip_address":"","utype":1,"ctime":1549807504,"user_name_real":"杨晓峰"}],"discussion_count":4,"race_medal":0,"score":"285014858776","product_id":100006701,"comment_content":"@代码狂徒<br>感觉本篇文章跑题了呢，关于生命周期，只讨论了初始化过程和销毁过程，那么什么时候引发的初始化呢？什么时候触发销毁操作呢？spring容器管理的bean是在容器运行过程中不会被销毁吧？<br><br>我来讲讲吧:<br>首先理解scope:<br>1. Singleton(单例) 在整个应用中,只创建bean的一个实例<br>2. Propotype(原型) 每次注入或者通过Spring应用上下文获取的时候,都会创建一个新<br>的bean实例。<br>3. Session(会话) 在Web应用中,为每个会话创建一个bean实例。<br>4. Request(请求) 在Web应用中,为每个请求创建一个bean实例。<br><br>他们是什么时候创建的:<br>1一个单例的bean,而且lazy-init属性为false(默认),在Application Context创建的时候构造<br>2一个单例的bean,lazy-init属性设置为true,那么,它在第一次需要的时候被构造.<br>3 其他scope的bean,都是在第一次需要使用的时候创建<br><br>他们是什么时候销毁的:<br>1 单例的bean始终 存在与application context中, 只有当 application 终结的时候,才会销毁<br>2 和其他scope相比,Spring并没有管理prototype实例完整的生命周期,在实例化,配置,组装对象交给应用后,spring不再管理.只要bean本身不持有对另一个资源（如数据库连接或会话对象）的引用，只要删除了对该对象的所有引用或对象超出范围，就会立即收集垃圾.<br>3 Request: 每次客户端请求都会创建一个新的bean实例,一旦这个请求结束,实例就会离开scope,被垃圾回收.<br>4 Session: 如果用户结束了他的会话,那么这个bean实例会被GC.","like_count":67,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435969,"discussion_content":"谢谢反馈，每篇有3K左右的限制，有些细节就不面面俱到了，尽量让有限的内容起到抛砖引玉的作用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549807504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77075,"discussion_content":"我们花钱买砖有什么用，我们要的是玉","likes_number":30,"is_delete":false,"is_hidden":false,"ctime":1575886471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2355521,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f1/41/76c0758f.jpg","nickname":"君战","note":"","ucode":"A8619A79A5CED9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374893,"discussion_content":"单例Bean是可以通过手动调用destroyBean方法来销毁的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621404668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2008802,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/a6/e2/465eaa08.jpg","nickname":"Jimmy Chen","note":"","ucode":"B9912576885A5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311045,"discussion_content":"Prototype 原型 :-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602201573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18516,"user_name":"Meteor","can_delete":false,"product_type":"c1","uid":1180548,"ip_address":"","ucode":"3938D2A1474DD1","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/84/791fb8f1.jpg","comment_is_top":false,"comment_ctime":1533399157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"181922025589","product_id":100006701,"comment_content":"Spring容器初始化开始:<br>1.[BeanFactoryPostProcessor]接口实现类的构造器2.[BeanFactoryPostProcessor]的postProcessorBeanFactory方法<br>3.[BeanPostProcessor]接口实现类的构造器<br>4.[InstantiationAwareBeanPostProcessorAdapter]构造器<br>5.[InstantiationAwareBeanPostProcessorAdapter]的postProcessBeforeInstantiation方法(从这里开始初始化bean)<br>6.[Bean]的构造器<br>7.[InstantiationAwareBeanPostProcessorAdapter]的postProcessAfterInstantiation<br>8.[InstantiationAwareBeanPostProcessorAdapter]的postProcessPropertyValues方法<br>9.[Bean]属性注入，setter方<br>方法<br>10.[Bean]如果实现了各种XXXaware接口，依次调用各个setXXX(如BeanNameAware.setBeanName(),BeanFactoryAware.setBeanFactory())<br>11.[BeanPostProcessor]的postProcessBeforeInitialization方法<br>12.[InstantiationAwareBeanPostProcessorAdapter]的postProcessBeforeInitialization方法<br>13.[Bean]自定义的init-method<br>14.[Bean]如果实现了InitializingBean接口，此时会调用它的afterPropertiesSet方法<br>15.[BeanPostProcessor]的postProcessAfterInitialization方法(此时bean初始化完成)<br>16.[InstantiationAwareBeanPostProcessorAdapter]的postProcessInitialization方法(到这里容器初始化完成)<br>17.业务逻辑bean的使用<br><br>Bean的销毁过程:<br>1.[DisposableBean]的destory方法<br>2.[Bean]自定义的destory-method方法<br><br>说明:如果有多个bean需要初始化，会循环执行5--15。<br><br>重要说明:欢迎拍砖，欢迎拍，欢迎，欢，……","like_count":43},{"had_liked":false,"id":18809,"user_name":"虞飞","can_delete":false,"product_type":"c1","uid":1053075,"ip_address":"","ucode":"601B864214C4F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/93/8b41390b.jpg","comment_is_top":false,"comment_ctime":1533570462,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"130382589342","product_id":100006701,"comment_content":"声明式事务其实说白了是一种特殊的aop应用，它其实包括两种advice，一种是around，另外一种是after-throwing。利用around advice在方法执行前，先关闭数据库的自动提交功能，然后设定一个标志符。根据业务代码实际的情况，对标志符赋不同的值，如果数据更新成功赋true，否则false。在业务方法执行完之后的部分对标志符进行处理。如为true，则提交数据库操作，否则就进行回滚。<br>另外还会使用after-throwing，对出错的信息进行记录。然后再将错误抛出至上层。","like_count":31,"discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308746,"discussion_content":"声明式事务最主要的还是区别与编程式事务的另一种对事务进行配置声明的形式；而不是说“含两种特殊的advice的一种特殊的aop应用”吧？？？around，after-throwing也不过是两种通知类型并不是说是声明式事务特有的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601049529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18235,"user_name":"爪哇夜未眠","can_delete":false,"product_type":"c1","uid":1006025,"ip_address":"","ucode":"BBEB80EB670770","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/c9/f44cb7f3.jpg","comment_is_top":false,"comment_ctime":1533201880,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"83137580504","product_id":100006701,"comment_content":"Advice 的时序图的before,after画反了吗","like_count":19,"discussions":[{"author":{"id":1237986,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e3/e2/2b56a802.jpg","nickname":"菠萝睡不醒","note":"","ucode":"7E3884FD402ED1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288343,"discussion_content":"+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593735207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158963,"discussion_content":"我也有这个疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580644723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103365,"user_name":"拟梦","can_delete":false,"product_type":"c1","uid":1469223,"ip_address":"","ucode":"AD4D4F2D57F89D","user_header":"https://static001.geekbang.org/account/avatar/00/16/6b/27/b56f524c.jpg","comment_is_top":false,"comment_ctime":1560420913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57394995761","product_id":100006701,"comment_content":"讲springbean的生命周期，不介绍spring后置处理器的文章都是没有灵魂的","like_count":13},{"had_liked":false,"id":18264,"user_name":"yao_jn","can_delete":false,"product_type":"c1","uid":1189344,"ip_address":"","ucode":"CB22076F586580","user_header":"https://static001.geekbang.org/account/avatar/00/12/25/e0/a9b2123c.jpg","comment_is_top":false,"comment_ctime":1533219209,"is_pvip":false,"replies":[{"id":"6460","content":"坦白说，真的要提高还是要靠自己，建议你看看别人的思路而不只是他的观点，源码就和上学读英文一样，看多了就不犯困，尽量让自己有输出","user_name":"作者回复","comment_id":18264,"uid":"1009360","ip_address":"","utype":1,"ctime":1533398340,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"48777859465","product_id":100006701,"comment_content":"读老师的文章收益很大，希望老师再对框架多讲一些，还有底层原理，毕竟很多时候看源码很费力，提点下会好很多！","like_count":12,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421450,"discussion_content":"坦白说，真的要提高还是要靠自己，建议你看看别人的思路而不只是他的观点，源码就和上学读英文一样，看多了就不犯困，尽量让自己有输出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533398340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18165,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1533172693,"is_pvip":false,"replies":[{"id":"6363","content":"IOC容器负责打理这些事情。同样的依赖关系，一个是a自己负责，一个是ioc容器负责，相当于ab之间的直接联系，变成了间接的。再配合OO，更换实现只需要修改配置","user_name":"作者回复","comment_id":18165,"uid":"1009360","ip_address":"","utype":1,"ctime":1533193684,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"40187878357","product_id":100006701,"comment_content":"老师，IOC 为什么可以实现解耦吖？<br><br>在引入 IOC 容器之前，对象 A 依赖于对象 B，则需要 A 主动去创建对象 B，控制权都在 A。<br><br>在引入 IOC 容器之后，当对象 A 运行到需要对象 B 的时候，IOC 容器会主动创建一个对象 B 注入到对象 A，控制权在容器。<br><br>控制权发生了反转，为什么能降价系统耦合，或者说降低什么之间的耦合？（自己的理解：应该不是降低对象间的耦合，因为不管由 A 还是容器创建 B 对象，A 都是耦合 B 的。感觉自己理解的方向偏了。）<br><br>谢谢！<br><br>","like_count":10,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421416,"discussion_content":"IOC容器负责打理这些事情。同样的依赖关系，一个是a自己负责，一个是ioc容器负责，相当于ab之间的直接联系，变成了间接的。再配合OO，更换实现只需要修改配置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533193684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18258,"user_name":"铁拳阿牛","can_delete":false,"product_type":"c1","uid":1094950,"ip_address":"","ucode":"B8CB947995685B","user_header":"https://static001.geekbang.org/account/avatar/00/10/b5/26/d635d8d3.jpg","comment_is_top":false,"comment_ctime":1533215125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31597986197","product_id":100006701,"comment_content":"可以按照课程丢些demo到一个github项目里，配合章节理论，这样有理论有代码可能对课程，和对学员更有帮助！不过对老师的成本也提高了。","like_count":8},{"had_liked":false,"id":54338,"user_name":"arebya","can_delete":false,"product_type":"c1","uid":1142802,"ip_address":"","ucode":"074ECE8D6C1874","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/12/aa74da82.jpg","comment_is_top":false,"comment_ctime":1545831634,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27315635410","product_id":100006701,"comment_content":"加上jdk本身的@PostConstruct 和@PreDestroy分析整个生命周期会更好","like_count":6,"discussions":[{"author":{"id":1546081,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoV7kTQGEFG101jDKycJ4AroKgTn7oicvbaia4ibk7uElZLjKe6SFoQicuvsJodHibZiazsdraiae0qhuzZg/132","nickname":"Geek_e5d39f","note":"","ucode":"A4712DE9721E06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270159,"discussion_content":"“调用 BeanPostProcessor 的前置初始化方法 postProcessBeforeInitialization”这一步可以理解为包含了@PostConstruct 的调用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589983983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18287,"user_name":"汉斯·冯·拉特","can_delete":false,"product_type":"c1","uid":1102385,"ip_address":"","ucode":"29F14B0D938A02","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/31/f1bec7fc.jpg","comment_is_top":false,"comment_ctime":1533232439,"is_pvip":false,"replies":[{"id":"6458","content":"喜欢读读源码而已，不敢说有多深入，因为实际踩坑经验不足；补充本文是因为虽然已经36篇，但是Java开发者不会只用Java se自身，开源项目必不可少","user_name":"作者回复","comment_id":18287,"uid":"1009360","ip_address":"","utype":1,"ctime":1533398071,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"18713101623","product_id":100006701,"comment_content":"想不到博主对spring也有深入了解。声明式事务是通过beanPostProcessor来实现的，springioc会用beanPostProcessor的某个方法（具体方法名忘记了，这里假设为方法A）返回结果作为getBean的结果。所以spring的事务模块在方法A中，用代理的方式，在目标方法前后加入一些与事务有关的代码，方法A的返回值就是这个代理类。欢迎拍砖！","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421460,"discussion_content":"喜欢读读源码而已，不敢说有多深入，因为实际踩坑经验不足；补充本文是因为虽然已经36篇，但是Java开发者不会只用Java se自身，开源项目必不可少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533398071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133930,"user_name":"BewhY","can_delete":false,"product_type":"c1","uid":1079811,"ip_address":"","ucode":"4BC26D47A79967","user_header":"https://static001.geekbang.org/account/avatar/00/10/7a/03/c9b43b21.jpg","comment_is_top":false,"comment_ctime":1568701689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14453603577","product_id":100006701,"comment_content":"我来替作者回答下下面提出的问题吧<br>什么时候引发初始化呢？初始化就是项目启动时就开始初始化了，将xml配置信息解析成BeanDefanition，存放在IOC容器中(所谓IOC容器就是一个Map集合)，上面老师讲的是Bean创建阶段了，不是Bean的初始化阶段。<br>不管是单例Bean还是原型Bean，都会被解析成BeanDefanition存放在IOC容器中，只不过Spring不处理原型Bean的循环依赖","like_count":4},{"had_liked":false,"id":40920,"user_name":"XiaoYeGe","can_delete":false,"product_type":"c1","uid":1122953,"ip_address":"","ucode":"F07027153B6971","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/89/5757eb43.jpg","comment_is_top":false,"comment_ctime":1542695273,"is_pvip":false,"replies":[{"id":"15440","content":"的确是经典书籍，书比专栏要更系统、全面","user_name":"作者回复","comment_id":40920,"uid":"1009360","ip_address":"","utype":1,"ctime":1543194366,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"14427597161","product_id":100006701,"comment_content":"第一次写留言, 看了几个月了,中间有些篇幅关于JVM的介绍,建议去看&lt;&lt;深入理解Java虚拟机&gt;&gt;这本书, 讲的不错, 当然博主总结的也好. 总之, 谢谢博主","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429648,"discussion_content":"的确是经典书籍，书比专栏要更系统、全面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543194366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36616,"user_name":"孟老师","can_delete":false,"product_type":"c1","uid":1103169,"ip_address":"","ucode":"0ADB53FECE9CF1","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/41/99b90510.jpg","comment_is_top":false,"comment_ctime":1541195603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10131130195","product_id":100006701,"comment_content":"一直没明白为什么spring和springMVC有父子容器的关系？这么设计的目的是什么？求老师解答","like_count":2},{"had_liked":false,"id":20790,"user_name":"李峰","can_delete":false,"product_type":"c1","uid":1107209,"ip_address":"","ucode":"3DA3574DB432A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/09/ddabec76.jpg","comment_is_top":false,"comment_ctime":1534756309,"is_pvip":false,"replies":[{"id":"7559","content":"个人的建议：<br>明确目的、目标，尽量让自己有个清晰的体系；<br>如果有实际任务驱动更好，毕竟大多数情况是随便看看，没有收获感，也就浅尝辄止了；<br>有输出，能表达出来，才好验证","user_name":"作者回复","comment_id":20790,"uid":"1009360","ip_address":"","utype":1,"ctime":1535037647,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"10124690901","product_id":100006701,"comment_content":"能否分享下你看spring源码的技巧，和方法，我也读了一些其他的源码，感觉spring太全复杂度就很高，看着看着就迷失了","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422410,"discussion_content":"个人的建议：\n明确目的、目标，尽量让自己有个清晰的体系；\n如果有实际任务驱动更好，毕竟大多数情况是随便看看，没有收获感，也就浅尝辄止了；\n有输出，能表达出来，才好验证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535037647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18325,"user_name":"GL","can_delete":false,"product_type":"c1","uid":1084339,"ip_address":"","ucode":"735AF0B2C9EB75","user_header":"https://static001.geekbang.org/account/avatar/00/10/8b/b3/c340227c.jpg","comment_is_top":false,"comment_ctime":1533258113,"is_pvip":false,"replies":[{"id":"6462","content":"哦，我再翻翻代码看看","user_name":"作者回复","comment_id":18325,"uid":"1009360","ip_address":"","utype":1,"ctime":1533400022,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"10123192705","product_id":100006701,"comment_content":"漏了BeanFactoryPostProcessor，在BeanPostProcessor前执行","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421475,"discussion_content":"哦，我再翻翻代码看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533400022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258980,"user_name":"皓月冷千山","can_delete":false,"product_type":"c1","uid":2168352,"ip_address":"","ucode":"44D2E02F61279C","user_header":"https://static001.geekbang.org/account/avatar/00/21/16/20/77d41677.jpg","comment_is_top":false,"comment_ctime":1604589797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5899557093","product_id":100006701,"comment_content":"首先理解scope:<br>1. Singleton(单例) 在整个应用中,只创建bean的一个实例<br>2. Propotype(原型) 每次注入或者通过Spring应用上下文获取的时候,都会创建一个新<br>的bean实例。<br>3. Session(会话) 在Web应用中,为每个会话创建一个bean实例。<br>4. Request(请求) 在Web应用中,为每个请求创建一个bean实例。<br><br>他们是什么时候创建的:<br>1一个单例的bean,而且lazy-init属性为false(默认),在Application Context创建的时候构造<br>2一个单例的bean,lazy-init属性设置为true,那么,它在第一次需要的时候被构造.<br>3 其他scope的bean,都是在第一次需要使用的时候创建<br><br>他们是什么时候销毁的:<br>1 单例的bean始终 存在与application context中, 只有当 application 终结的时候,才会销毁<br>2 和其他scope相比,Spring并没有管理prototype实例完整的生命周期,在实例化,配置,组装对象交给应用后,spring不再管理.只要bean本身不持有对另一个资源（如数据库连接或会话对象）的引用，只要删除了对该对象的所有引用或对象超出范围，就会立即收集垃圾.<br>3 Request: 每次客户端请求都会创建一个新的bean实例,一旦这个请求结束,实例就会离开scope,被垃圾回收.<br>4 Session: 如果用户结束了他的会话,那么这个bean实例会被GC.","like_count":1},{"had_liked":false,"id":235500,"user_name":"dongge","can_delete":false,"product_type":"c1","uid":1008016,"ip_address":"","ucode":"CEFE4D0CC42907","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/90/de8c61a0.jpg","comment_is_top":false,"comment_ctime":1595063988,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5890031284","product_id":100006701,"comment_content":"接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。依赖注入的英文翻译是 Dependency Injection，缩写为 DI。对于这个概念，有一个非常形象的说法，那就是：依赖注入是一个标价 25 美元，实际上只值 5 美分的概念。也就是说，这个概念听起来很“高大上”，实际上，理解、应用起来非常简单。 这是 https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;177444 设计模式课程说法。这节课是是不是把 IOC 和 DI 搞错了","like_count":1},{"had_liked":false,"id":23984,"user_name":"白","can_delete":false,"product_type":"c1","uid":1159553,"ip_address":"","ucode":"F7A7BCFCDFDEF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/81/ae0277f1.jpg","comment_is_top":false,"comment_ctime":1536741676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5831708972","product_id":100006701,"comment_content":"拜读第二遍。","like_count":1},{"had_liked":false,"id":20788,"user_name":"李峰","can_delete":false,"product_type":"c1","uid":1107209,"ip_address":"","ucode":"3DA3574DB432A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/09/ddabec76.jpg","comment_is_top":false,"comment_ctime":1534756126,"is_pvip":false,"replies":[{"id":"7560","content":"已回复","user_name":"作者回复","comment_id":20788,"uid":"1009360","ip_address":"","utype":1,"ctime":1535037663,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"5829723422","product_id":100006701,"comment_content":"老师，请教下，因为我也读了几次spring的源码，相比其他我读过的源码个人觉得spring复杂度很复杂，很多细节看着看着就迷失在他的代码里面了能否分享下你看spring源码的方法，感谢","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422409,"discussion_content":"已回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535037663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19054,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1533653178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828620474","product_id":100006701,"comment_content":"这么给力多讲了老师一共多少讲啊","like_count":1},{"had_liked":false,"id":18142,"user_name":"sars","can_delete":false,"product_type":"c1","uid":1132974,"ip_address":"","ucode":"E725CDC3E7DC3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/ae/c0b8d835.jpg","comment_is_top":false,"comment_ctime":1533168508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828135804","product_id":100006701,"comment_content":"能否介绍一下热加载，还有目前第三方软件，class，jar都可以热加载。","like_count":1},{"had_liked":false,"id":349794,"user_name":"FiRerOUNd","can_delete":false,"product_type":"c1","uid":1315438,"ip_address":"","ucode":"571CB6565F9713","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/6e/3a0b4930.jpg","comment_is_top":false,"comment_ctime":1656330466,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656330466","product_id":100006701,"comment_content":"泛泛而谈谁都会，细微之处见真章。","like_count":1},{"had_liked":false,"id":325546,"user_name":"刘勇","can_delete":false,"product_type":"c1","uid":2003326,"ip_address":"","ucode":"4776CC4D2821FD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/91/7e/4bb77d45.jpg","comment_is_top":false,"comment_ctime":1639019753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639019753","product_id":100006701,"comment_content":"spring5中spring bean的作用域添加了application，websock，porlet已经被spring遗弃，添加新的webflux。已补充！","like_count":1},{"had_liked":false,"id":286445,"user_name":"KamTo  Hung","can_delete":false,"product_type":"c1","uid":1584786,"ip_address":"","ucode":"00D5A6479DB784","user_header":"https://static001.geekbang.org/account/avatar/00/18/2e/92/e1c38ca6.jpg","comment_is_top":false,"comment_ctime":1617323905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617323905","product_id":100006701,"comment_content":"主要分为三个阶段讲:创建实例，属性注入，初始化Bean（都在AbstractAutowiredcapableBeanFactory的doCreateBen方法上）。","like_count":0},{"had_liked":false,"id":245049,"user_name":"之渊","can_delete":false,"product_type":"c1","uid":1876212,"ip_address":"","ucode":"02B9299DBB4881","user_header":"https://static001.geekbang.org/account/avatar/00/1c/a0/f4/7e122a67.jpg","comment_is_top":false,"comment_ctime":1598794849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598794849","product_id":100006701,"comment_content":"spring aop 可以查看这篇博客https:&#47;&#47;blog.csdn.net&#47;qq_32331073&#47;article&#47;details&#47;80596084<br>对advice的执行顺序总结得很好，还有图","like_count":0},{"had_liked":false,"id":234696,"user_name":"李飞","can_delete":false,"product_type":"c1","uid":1555180,"ip_address":"","ucode":"930458850AA05B","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/ec/2b1c6afc.jpg","comment_is_top":false,"comment_ctime":1594775249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594775249","product_id":100006701,"comment_content":"二刷，深入理解","like_count":0},{"had_liked":false,"id":202744,"user_name":"地表十进制","can_delete":false,"product_type":"c1","uid":1855791,"ip_address":"","ucode":"C3B5B60748CE67","user_header":"","comment_is_top":false,"comment_ctime":1586061386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586061386","product_id":100006701,"comment_content":"spring security也是比较重要的，比较不好弄明白的一个模块","like_count":0},{"had_liked":false,"id":144783,"user_name":"hi兵哥","can_delete":false,"product_type":"c1","uid":1151209,"ip_address":"","ucode":"5425B0EBE5B624","user_header":"https://static001.geekbang.org/account/avatar/00/11/90/e9/87f2956a.jpg","comment_is_top":false,"comment_ctime":1572057690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572057690","product_id":100006701,"comment_content":"请教老师一个实际使用中的问题解决方案，多个jar包中有相同路径的相同class,如何让jvm加载制定包下的class?springcloud中有时引入了多个依赖，譬如引入的包使用@bean 生成了 restTemplate，而我自己项目中同样有要生restTemplate的需求，两个处理逻辑有区别，而我想基于robbin去实现负载均衡。基于上面我大致知道可以通过类加载，classScan方式去做一些处理，请问老师能否给出一些具体的可操作的解决方案，谢谢。","like_count":0},{"had_liked":false,"id":42633,"user_name":"static","can_delete":false,"product_type":"c1","uid":1138754,"ip_address":"","ucode":"1697966367370E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYfReHXMbPaxO890ib9GvY9iciclPIUvaAYMYON4scP7ElXCPVzicghF0SH5HN2LqibYOrdrppC7DuSpw/132","comment_is_top":false,"comment_ctime":1542984638,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1542984638","product_id":100006701,"comment_content":"老师好，在学习spring的过程中我遇到了一个ioc的一个疑问，刚好看到老师这篇文章又想起之前没有解决的疑惑，希望老师可以帮我解惑，感谢！背景：在ioc容器refresh方法的末尾会初始化所有单例bean，之后会在实例化bean之前先寻找bean的所有依赖bean并循环对依赖的bean调用getBean方法。问题：如果此时依赖的bean是原型的作用域，是否此时的getBean此原型bean是没有用浪费时间的一个过程呢？在我目前的理解感觉如果bean是单例才会将实例存放在ioc容器中，如果是原型就不会存下来，因为我一直找不到原型bean存放在哪里，所以对这个过程产生疑惑，觉得这样轮询依赖bean的过程如果bean为原型是在浪费时间去getBean。感谢老师抽空看完！","like_count":0,"discussions":[{"author":{"id":1005200,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/90/be01bb8d.jpg","nickname":"Asanz","note":"","ucode":"430AB7ED59EE3F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6997,"discussion_content":"应该是这样的，前提是bean非延迟加载。ApplicationContext容器初始化后实例化的bean就都是单例的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567247478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}