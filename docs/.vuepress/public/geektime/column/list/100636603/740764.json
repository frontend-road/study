{"id":740764,"title":"第 5 章 非原始值的响应式方案(1)","content":"<h1 id=\"nav_point_44\">第 5 章　非原始值的响应式方案</h1>\n<p>在上一章中，我们着重讨论了响应系统的概念与实现，并简单介绍了响应式数据的基本原理。本章中我们把目光聚焦在响应式数据本身，深入探讨实现响应式数据都需要考虑哪些内容，其中的难点又是什么。实际上，实现响应式数据要比想象中难很多，并不是像上一章讲述的那样，单纯地拦截 <code>get</code>/<code>set</code> 操作即可。举例来说，如何拦截 <code>for...in</code> 循环？<code>track</code> 函数如何追踪拦截到的 <code>for...in</code> 循环？类似的问题还有很多。除此之外，我们还应该考虑如何对数组进行代理。Vue.js 3 还支持集合类型，如 <code>Map</code>、<code>Set</code>、<code>WeakMap</code> 以及 <code>WeakSet</code> 等，那么应该如何对集合类型进行代理呢？实际上，想要实现完善的响应式数据，我们需要深入语言规范。本章在揭晓答案的同时，也会从语言规范的层面来分析原因，让你对响应式数据有更深入的理解。</p>\n<p>另外，本章会引用 ECMA-262 规范，如不作特殊说明，皆指该规范的 2021 版本。</p>\n<h2 id=\"nav_point_45\">5.1　理解 <code>Proxy</code> 和 <code>Reflect</code></h2>\n<p>既然 Vue.js 3 的响应式数据是基于 <code>Proxy</code> 实现的，那么我们就有必要了解 <code>Proxy</code> 以及与之相关联的 <code>Reflect</code>。什么是 <code>Proxy</code> 呢？简单地说，使用 <code>Proxy</code> 可以创建一个代理对象。它能够实现对<strong>其他对象</strong>的代理，这里的关键词是<strong>其他对象</strong>，也就是说，<code>Proxy</code> 只能代理对象，无法代理非对象值，例如字符串、布尔值等。那么，<strong>代理</strong>指的是什么呢？所谓代理，指的是对一个对象<strong>基本语义</strong>的代理。它允许我们<strong>拦截</strong>并<strong>重新定义</strong>对一个对象的基本操作。这句话的关键词比较多，我们逐一解释。</p><!-- [[[read_end]]] -->\n<p>什么是<strong>基本语义</strong>？给出一个对象 <code>obj</code>，可以对它进行一些操作，例如读取属性值、设置属性值：</p>\n<pre class=\"code-rows\"><code> obj.foo // 读取属性 foo 的值\n obj.foo++ // 读取和设置属性 foo 的值\n</code></pre>\n<p>类似这种读取、设置属性值的操作，就属于基本语义的操作，即基本操作。既然是基本操作，那么它就可以使用 <code>Proxy</code> 拦截：</p>\n<pre class=\"code-rows\"><code> const p = new Proxy(obj, {\n   // 拦截读取属性操作\n   get() { /*...*/ },\n   // 拦截设置属性操作\n   set() { /*...*/ }\n })\n</code></pre>\n<p>如以上代码所示，<code>Proxy</code> 构造函数接收两个参数。第一个参数是被代理的对象，第二个参数也是一个对象，这个对象是一组夹子（<code>trap</code>）。其中 <code>get</code> 函数用来拦截读取操作，<code>set</code> 函数用来拦截设置操作。</p>\n<p>在 JavaScript 的世界里，万物皆对象。例如一个函数也是一个对象，所以调用函数也是对一个对象的基本操作：</p>\n<pre class=\"code-rows\"><code> const fn = (name) =&gt; {\n   console.log('我是：', name)\n }\n<p>// 调用函数是对对象的基本操作<br />\nfn()<br />\n</code></pre></p>\n<p>因此，我们可以用 <code>Proxy</code> 来拦截函数的调用操作，这里我们使用 <code>apply</code> 拦截函数的调用：</p>\n<pre class=\"code-rows\"><code> const p2 = new Proxy(fn, {\n   // 使用 apply 拦截函数调用\n   apply(target, thisArg, argArray) {\n     target.call(thisArg, ...argArray)\n   }\n })\n<p>p2(‘hcy’) // 输出：‘我是：hcy’<br />\n</code></pre></p>\n<p>上面两个例子说明了什么是基本操作。<code>Proxy</code> 只能够拦截对一个对象的基本操作。那么，什么是非基本操作呢？其实调用对象下的方法就是典型的非基本操作，我们叫它<strong>复合操作</strong>：</p>\n<pre class=\"code-rows\"><code> obj.fn()\n</code></pre>\n<p>实际上，调用一个对象下的方法，是由两个基本语义组成的。第一个基本语义是 <code>get</code>，即先通过 <code>get</code> 操作得到 <code>obj.fn</code> 属性。第二个基本语义是函数调用，即通过 <code>get</code> 得到 <code>obj.fn</code> 的值后再调用它，也就是我们上面说到的 <code>apply</code>。理解 <code>Proxy</code> 只能够代理对象的基本语义很重要，后续我们讲解如何实现对数组或 <code>Map</code>、<code>Set</code> 等数据类型的代理时，都利用了 <code>Proxy</code> 的这个特点。</p>\n<p>理解了 <code>Proxy</code>，我们再来讨论 <code>Reflect</code>。<code>Reflect</code> 是一个全局对象，其下有许多方法，例如：</p>\n<pre class=\"code-rows\"><code> Reflect.get()\n Reflect.set()\n Reflect.apply()\n // ...\n</code></pre>\n<p>你可能已经注意到了，<code>Reflect</code> 下的方法与 <code>Proxy</code> 的拦截器方法名字相同，其实这不是偶然。任何在 <code>Proxy</code> 的拦截器中能够找到的方法，都能够在 <code>Reflect</code> 中找到同名函数，那么这些函数的作用是什么呢？其实它们的作用一点儿都不神秘。拿 <code>Reflect.get</code> 函数来说，它的功能就是提供了访问一个对象属性的默认行为，例如下面两个操作是等价的：</p>\n<pre class=\"code-rows\"><code> const obj = { foo: 1 }\n<p>// 直接读取<br />\nconsole.log(obj.foo) // 1<br />\n// 使用 Reflect.get 读取<br />\nconsole.log(Reflect.get(obj, ‘foo’)) // 1<br />\n</code></pre></p>\n<p>可能有的读者会产生疑问：既然操作等价，那么它存在的意义是什么呢？实际上 <code>Reflect.get</code> 函数还能接收第三个参数，即指定接收者 <code>receiver</code>，你可以把它理解为函数调用过程中的 <code>this</code>，例如：</p>\n<pre class=\"code-rows\"><code> const obj = {\n   get foo() {\n     return this.foo\n   }\n }\n console.log(Reflect.get(obj, 'foo', { foo: 2 })) // 输出的是 2 而不是 1\n</code></pre>\n<p>在这段代码中，我们指定第三个参数 <code>receiver</code> 为一个对象 <code>{ foo: 2 }</code>，这时读取到的值是 <code>receiver</code> 对象的 <code>foo</code> 属性值。实际上，<code>Reflect.*</code> 方法还有很多其他方面的意义，但这里我们只关心并讨论这一点，因为它与响应式数据的实现密切相关。为了说明问题，回顾一下在上一节中实现响应式数据的代码：</p>\n<pre class=\"code-rows\"><code> const obj = { foo: 1 }\n<p>const p = new Proxy(obj, {<br />\nget(target, key) {<br />\ntrack(target, key)<br />\n// 注意，这里我们没有使用 Reflect.get 完成读取<br />\nreturn target[key]<br />\n},<br />\nset(target, key, newVal) {<br />\n// 这里同样没有使用 Reflect.set 完成设置<br />\ntarget[key] = newVal<br />\ntrigger(target, key)<br />\n}<br />\n})<br />\n</code></pre></p>\n<p>这是上一章中用来实现响应式数据的最基本的代码。在 <code>get</code> 和 <code>set</code> 拦截函数中，我们都是直接使用原始对象 <code>target</code> 来完成对属性的读取和设置操作的，其中原始对象 <code>target</code> 就是上述代码中的 <code>obj</code> 对象。</p>\n<p>那么这段代码有什么问题吗？我们借助 <code>effect</code> 让问题暴露出来。首先，我们修改一下 <code>obj</code> 对象，为它添加 <code>bar</code> 属性：</p>\n<pre class=\"code-rows\"><code> const obj = {\n   foo: 1,\n   get bar() {\n     return this.foo\n   }\n }\n</code></pre>\n<p>可以看到，<code>bar</code> 属性是一个访问器属性，它返回了 <code>this.foo</code> 属性的值。接着，我们在 <code>effect</code> 副作用函数中通过代理对象 <code>p</code> 访问 <code>bar 属性</code>：</p>\n<pre class=\"code-rows\"><code> effect(() =&gt; {\n   console.log(p.bar) // 1\n })\n</code></pre>\n<p>我们来分析一下这个过程发生了什么。当 <code>effect</code> 注册的副作用函数执行时，会读取 <code>p.bar</code> 属性，它发现 <code>p.bar</code> 是一个访问器属性，因此执行 <code>getter</code> 函数。由于在 <code>getter</code> 函数中通过 <code>this.foo</code> 读取了 <code>foo</code> 属性值，因此我们认为副作用函数与属性 <code>foo</code> 之间也会建立联系。当我们修改 <code>p.foo</code> 的值时应该能够触发响应，使得副作用函数重新执行才对。然而实际并非如此，当我们尝试修改 <code>p.foo</code> 的值时：</p>\n<pre class=\"code-rows\"><code> p.foo++\n</code></pre>\n<p>副作用函数并没有重新执行，问题出在哪里呢？</p>\n<p>实际上，问题就出在 <code>bar</code> 属性的访问器函数 <code>getter</code> 里：</p>\n<pre class=\"code-rows\"><code> const obj = {\n   foo: 1,\n   get bar() {\n     // 这里的 this 指向的是谁？\n     return this.foo\n   }\n }\n</code></pre>\n<p>当我们使用 <code>this.foo</code> 读取 <code>foo</code> 属性值时，这里的 <code>this</code> 指向的是谁呢？我们回顾一下整个流程。首先，我们通过代理对象 <code>p</code> 访问 <code>p.bar</code>，这会触发代理对象的 <code>get</code> 拦截函数执行：</p>\n<pre class=\"code-rows\"><code> const p = new Proxy(obj, {\n   get(target, key) {\n     track(target, key)\n     // 注意，这里我们没有使用 Reflect.get 完成读取\n     return target[key]\n   },\n   // 省略部分代码\n })\n</code></pre>\n<p>在 <code>get</code> 拦截函数内，通过 <code>target[key]</code> 返回属性值。其中 <code>target</code> 是原始对象 <code>obj</code>，而 <code>key</code> 就是字符串 <code>'bar'</code>，所以 <code>target[key]</code> 相当于 <code>obj.bar</code>。因此，当我们使用 <code>p.bar</code> 访问 <code>bar</code> 属性时，它的 <code>getter</code> 函数内的 <code>this</code> 指向的其实是原始对象 <code>obj</code>，这说明我们最终访问的其实是 <code>obj.foo</code>。很显然，在副作用函数内通过原始对象访问它的某个属性是不会建立响应联系的，这等价于：</p>\n<pre class=\"code-rows\"><code> effect(() =&gt; {\n   // obj 是原始数据，不是代理对象，这样的访问不能够建立响应联系\n   obj.foo\n })\n</code></pre>\n<p>因为这样做不会建立响应联系，所以出现了无法触发响应的问题。那么这个问题应该如何解决呢？这时 <code>Reflect.get</code> 函数就派上用场了。先给出解决问题的代码：</p>\n<pre class=\"code-rows\"><code> const p = new Proxy(obj, {\n   // 拦截读取操作，接收第三个参数 receiver\n   get(target, key, receiver) {\n     track(target, key)\n     // 使用 Reflect.get 返回读取到的属性值\n     return Reflect.get(target, key, receiver)\n   },\n   // 省略部分代码\n })\n</code></pre>\n<p>如上面的代码所示，代理对象的 <code>get</code> 拦截函数接收第三个参数 <code>receiver</code>，它代表谁在读取属性，例如：</p>\n<pre class=\"code-rows\"><code> p.bar // 代理对象 p 在读取 bar 属性\n</code></pre>\n<p>当我们使用代理对象 <code>p</code> 访问 <code>bar</code> 属性时，那么 <code>receiver</code> 就是 <code>p</code>，你可以把它简单地理解为函数调用中的 <code>this</code>。接着关键的一步发生了，我们使用 <code>Reflect.get(target, key, receiver)</code> 代替之前的 <code>target[key]</code>，这里的关键点就是第三个参数 <code>receiver</code>。我们已经知道它就是代理对象 <code>p</code>，所以访问器属性 <code>bar</code> 的 <code>getter</code> 函数内的 <code>this</code> 指向代理对象 <code>p</code>：</p>\n<pre class=\"code-rows\"><code> const obj = {\n   foo: 1,\n   get bar() {\n     // 现在这里的 this 为代理对象 p\n     return this.foo\n   }\n }\n</code></pre>\n<p>可以看到，<code>this</code> 由原始对象 <code>obj</code> 变成了代理对象 <code>p</code>。很显然，这会在副作用函数与响应式数据之间建立响应联系，从而达到依赖收集的效果。如果此时再对 <code>p.foo</code> 进行自增操作，会发现已经能够触发副作用函数重新执行了。</p>\n<p>正是基于上述原因，后文讲解中将统一使用 <code>Reflect.*</code> 方法。</p>\n<h2 id=\"nav_point_46\">5.2　JavaScript 对象及 <code>Proxy</code> 的工作原理</h2>\n<p>我们经常听到这样的说法：“JavaScript 中一切皆对象。”那么，到底什么是对象呢？这个问题需要我们查阅 ECMAScript 规范才能得到答案。实际上，根据 ECMAScript 规范，在 JavaScript 中有两种对象，其中一种叫作<strong>常规对象</strong>（ordinary object），另一种叫作<strong>异质对象</strong>（exotic object）。这两种对象包含了 JavaScript 世界中的所有对象，任何不属于常规对象的对象都是异质对象。那么到底什么是常规对象，什么是异质对象呢？这需要我们先了解对象的内部方法和内部槽。</p>\n<p>我们知道，在 JavaScript 中，函数其实也是对象。假设给出一个对象 <code>obj</code>，如何区分它是普通对象还是函数呢？实际上，在 JavaScript 中，对象的实际语义是由对象的<strong>内部方法</strong>（internal method）指定的。所谓内部方法，指的是当我们对一个对象进行操作时在引擎内部调用的方法，这些方法对于 JavaScript 使用者来说是不可见的。举个例子，当我们访问对象属性时：</p>\n<pre class=\"code-rows\"><code> obj.foo\n</code></pre>\n<p>引擎内部会调用 <code>[[Get]]</code> 这个内部方法来读取属性值。这里补充说明一下，在 ECMAScript 规范中使用 <code>[[xxx]]</code> 来代表内部方法或内部槽。当然，一个对象不仅部署了 <code>[[Get]]</code> 这个内部方法，表 5-1 列出了规范要求的所有必要的内部方法<span class=\"comment-number\">1</span>。</p>\n<p><strong>表 5-1　对象必要的内部方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>内部方法</p></th>\n<th><p>签名</p></th>\n<th><p>描述</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>[[GetPrototypeOf]]</code></p></td>\n<td><p><code>( ) → Object | Null</code></p></td>\n<td><p>查明为该对象提供继承属性的对象，<code>null</code> 代表没有继承属性</p></td>\n</tr>\n<tr>\n<td><p><code>[[SetPrototypeOf]]</code></p></td>\n<td><p><code>(Object | Null) → Boolean</code></p></td>\n<td><p>将该对象与提供继承属性的另一个对象相关联。传递 <code>null</code> 表示没有继承属性，返回 <code>true</code> 表示操作成功完成，返回 <code>false</code> 表示操作失败</p></td>\n</tr>\n<tr>\n<td><p><code>[[IsExtensible]]</code></p></td>\n<td><p><code>( ) → Boolean</code></p></td>\n<td><p>查明是否允许向该对象添加其他属性</p></td>\n</tr>\n<tr>\n<td><p><code>[[PreventExtensions]]</code></p></td>\n<td><p><code>( ) → Boolean</code></p></td>\n<td><p>控制能否向该对象添加新属性。如果操作成功则返回 <code>true</code>，如果操作失败则返回 <code>false</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[GetOwnProperty]]</code></p></td>\n<td><p><code>(propertyKey) → Undefined | Property Descriptor</code></p></td>\n<td><p>返回该对象自身属性的描述符，其键为 <code>propertyKey</code>，如果不存在这样的属性，则返回 <code>undefined</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[DefineOwnProperty]]</code></p></td>\n<td><p><code>(propertyKey, PropertyDescriptor) → Boolean</code></p></td>\n<td><p>创建或更改自己的属性，其键为 <code>propertyKey</code>，以具有由 <code>PropertyDescriptor</code> 描述的状态。如果该属性已成功创建或更新，则返回 <code>true</code>；如果无法创建或更新该属性，则返回 <code>false</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[HasProperty]]</code></p></td>\n<td><p><code>(propertyKey) → Boolean</code></p></td>\n<td><p>返回一个布尔值，指示该对象是否已经拥有键为 <code>propertyKey</code> 的自己的或继承的属性</p></td>\n</tr>\n<tr>\n<td><p><code>[[Get]]</code></p></td>\n<td><p><code>(propertyKey, Receiver) → any</code></p></td>\n<td><p>从该对象返回键为 <code>propertyKey</code> 的属性的值。如果必须运行 ECMAScript 代码来检索属性值，则在运行代码时使用 <code>Receiver</code> 作为 <code>this</code> 值</p></td>\n</tr>\n<tr>\n<td><p><code>[[Set]]</code></p></td>\n<td><p><code>(propertyKey, value, Receiver) → Boolean</code></p></td>\n<td><p>将键值为 <code>propertyKey</code> 的属性的值设置为 <code>value</code>。如果必须运行 ECMAScript 代码来设置属性值，则在运行代码时使用 <code>Receiver</code> 作为 <code>this</code> 值。如果成功设置了属性值，则返回 <code>true</code>；如果无法设置，则返回 <code>false</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[Delete]]</code></p></td>\n<td><p><code>(propertyKey) → Boolean</code></p></td>\n<td><p>从该对象中删除属于自身的键为 <code>propertyKey</code> 的属性。如果该属性未被删除并且仍然存在，则返回 <code>false</code>；如果该属性已被删除或不存在，则返回 <code>true</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[OwnPropertyKeys]]</code></p></td>\n<td><p><code>( ) → List of propertyKey</code></p></td>\n<td><p>返回一个 <code>List</code>，其元素都是对象自身的属性键</p></td>\n</tr>\n</tbody>\n</table>\n<p>由表 5-1 可知，包括 <code>[[Get]]</code> 在内，一个对象必须部署 11 个必要的内部方法。除了表 5-1 所列的内部方法之外，还有两个额外的必要内部方法<span class=\"comment-number\">2</span>：<code>[[Call]]</code> 和 <code>[[Construct]]</code>，如表 5-2 所示。</p>\n<p><strong>表 5-2　额外的必要内部方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>内部方法</p></th>\n<th><p>签名</p></th>\n<th><p>描述</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>[[Call]]</code></p></td>\n<td><p><code>(any, a List of any) → any</code></p></td>\n<td><p>将运行的代码与 <code>this</code> 对象关联。由函数调用触发。该内部方法的参数是一个 <code>this</code> 值和参数列表</p></td>\n</tr>\n<tr>\n<td><p><code>[[Construct]]</code></p></td>\n<td><p><code>(a List of any, Object) → Object</code></p></td>\n<td><p>创建一个对象。通过 <code>new</code> 运算符或 <code>super</code> 调用触发。该内部方法的第一个参数是一个 <code>List</code>，该 <code>List</code> 的元素是构造函数调用或 <code>super</code> 调用的参数，第二个参数是最初应用 <code>new</code> 运算符的对象。实现该内部方法的对象称为构造函数</p></td>\n</tr>\n</tbody>\n</table>\n<p>如果一个对象需要作为函数调用，那么这个对象就必须部署内部方法 <code>[[Call]]</code>。现在我们就可以回答前面的问题了：如何区分一个对象是普通对象还是函数呢？一个对象在什么情况下才能作为函数调用呢？答案是，通过内部方法和内部槽来区分对象，例如函数对象会部署内部方法 <code>[[Call]]</code>，而普通对象则不会。</p>\n<p>内部方法具有多态性，这是什么意思呢？这类似于面向对象里多态的概念。这就是说，不同类型的对象可能部署了相同的内部方法，却具有不同的逻辑。例如，普通对象和 <code>Proxy</code> 对象都部署了 <code>[[Get]]</code> 这个内部方法，但它们的逻辑是不同的，普通对象部署的 <code>[[Get]]</code> 内部方法的逻辑是由 ECMA 规范的 10.1.8 节定义的，而 <code>Proxy</code> 对象部署的 <code>[[Get]]</code> 内部方法的逻辑是由 ECMA 规范的 10.5.8 节来定义的。</p>\n<p>了解了内部方法，就可以解释什么是常规对象，什么是异质对象了。满足以下三点要求的对象就是常规对象：</p>\n<ul>\n<li>对于表 5-1 列出的内部方法，必须使用 ECMA 规范 10.1.x 节给出的定义实现；</li>\n<li>对于内部方法 <code>[[Call]]</code>，必须使用 ECMA 规范 10.2.1 节给出的定义实现；</li>\n<li>对于内部方法 <code>[[Construct]]</code>，必须使用 ECMA 规范 10.2.2 节给出的定义实现。</li>\n</ul>\n<p>而所有不符合这三点要求的对象都是异质对象。例如，由于 <code>Proxy</code> 对象的内部方法 <code>[[Get]]</code> 没有使用 ECMA 规范的 10.1.8 节给出的定义实现，所以 <code>Proxy</code> 是一个异质对象。</p>\n<p>现在我们对 JavaScript 中的对象有了更加深入的理解。接下来，我们就具体看看 <code>Proxy</code> 对象。既然 <code>Proxy</code> 也是对象，那么它本身也部署了上述必要的内部方法，当我们通过代理对象访问属性值时：</p>\n<pre class=\"code-rows\"><code> const p = new Proxy(obj, {/* ... */})\n p.foo\n</code></pre>\n<p>实际上，引擎会调用部署在对象 <code>p</code> 上的内部方法 <code>[[Get]]</code>。到这一步，其实代理对象和普通对象没有太大区别。它们的区别在于对于内部方法 <code>[[Get]]</code> 的实现，这里就体现了内部方法的多态性，即不同的对象部署相同的内部方法，但它们的行为可能不同。具体的不同体现在，如果在创建代理对象时没有指定对应的拦截函数，例如没有指定 <code>get()</code> 拦截函数，那么当我们通过代理对象访问属性值时，代理对象的内部方法 <code>[[Get]]</code> 会调用原始对象的内部方法 <code>[[Get]]</code> 来获取属性值，这其实就是代理透明性质。</p>\n<p>现在相信你已经明白了，创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身的内部方法和行为的，而不是用来指定被代理对象的内部方法和行为的。表 5-3 列出了 <code>Proxy</code> 对象部署的所有内部方法以及用来自定义内部方法和行为的拦截函数名字<span class=\"comment-number\">3</span>。</p>\n<p><strong>表 5-3　<code>Proxy</code> 对象部署的所有内部方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>内部方法</p></th>\n<th><p>处理器函数</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>[[GetPrototypeOf]]</code></p></td>\n<td><p><code>getPrototypeOf</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[SetPrototypeOf]]</code></p></td>\n<td><p><code>setPrototypeOf</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[IsExtensible]]</code></p></td>\n<td><p><code>isExtensible</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[PreventExtensions]]</code></p></td>\n<td><p><code>preventExtensions</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[GetOwnProperty]]</code></p></td>\n<td><p><code>getOwnPropertyDescriptor</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[DefineOwnProperty]]</code></p></td>\n<td><p><code>defineProperty</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[HasProperty]]</code></p></td>\n<td><p><code>has</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[Get]]</code></p></td>\n<td><p><code>get</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[Set]]</code></p></td>\n<td><p><code>set</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[Delete]]</code></p></td>\n<td><p><code>deleteProperty</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[OwnPropertyKeys]]</code></p></td>\n<td><p><code>ownKeys</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[Call]]</code></p></td>\n<td><p><code>apply</code></p></td>\n</tr>\n<tr>\n<td><p><code>[[Construct]]</code></p></td>\n<td><p><code>construct</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>当然，其中 <code>[[Call]]</code> 和 <code>[[Construct]]</code> 这两个内部方法只有当被代理的对象是函数和构造函数时才会部署。</p>\n<p>由表 5-3 可知，当我们要拦截删除属性操作时，可以使用 <code>deleteProperty</code> 拦截函数实现：</p>\n<pre class=\"code-rows\"><code> const obj = { foo: 1 }\n const p = new Proxy(obj, {\n   deleteProperty(target, key) {\n     return Reflect.deleteProperty(target, key)\n   }\n })\n<p>console.log(p.foo) // 1<br />\ndelete p.foo<br />\nconsole.log(p.foo) // 未定义<br />\n</code></pre></p>\n<p>这里需要强调的是，<code>deleteProperty</code> 实现的是代理对象 <code>p</code> 的内部方法和行为，所以为了删除被代理对象上的属性值，我们需要使用 <code>Reflect.deleteProperty(target, key)</code> 来完成。</p>\n<h2 id=\"nav_point_47\">5.3　如何代理 <code>Object</code></h2>\n<p>从本节开始，我们将着手实现响应式数据。前面我们使用 <code>get</code> 拦截函数去拦截对属性的读取操作。但在响应系统中，“读取”是一个很宽泛的概念，例如使用 <code>in</code> 操作符检查对象上是否具有给定的 <code>key</code> 也属于“读取”操作，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> effect(() =&gt; {\n   'foo' in obj\n })\n</code></pre>\n<p>这本质上也是在进行“读取”操作。响应系统应该拦截一切读取操作，以便当数据变化时能够正确地触发响应。下面列出了对一个普通对象的所有可能的读取操作。</p>\n<ul>\n<li>访问属性：<code>obj.foo</code>。</li>\n<li>判断对象或原型上是否存在给定的 <code>key</code>：<code>key in obj</code>。</li>\n<li>使用 <code>for...in</code> 循环遍历对象：<code>for (const key in obj){}</code>。</li>\n</ul>\n<p>接下来，我们逐步讨论如何拦截这些读取操作。首先是对于属性的读取，例如 <code>obj.foo</code>，我们知道这可以通过 <code>get</code> 拦截函数实现：</p>\n<pre class=\"code-rows\"><code> const obj = { foo: 1 }\n<p>const p = new Proxy(obj, {<br />\nget(target, key, receiver) {<br />\n// 建立联系<br />\ntrack(target, key)<br />\n// 返回属性值<br />\nreturn Reflect.get(target, key, receiver)<br />\n},<br />\n})<br />\n</code></pre></p>\n<p>对于 <code>in</code> 操作符，应该如何拦截呢？我们可以先查看表 5-3，尝试寻找与 <code>in</code> 操作符对应的拦截函数，但表 5-3 中没有与 <code>in</code> 操作符相关的内容。怎么办呢？这时我们就需要查看关于 <code>in</code> 操作符的相关规范。在 ECMA-262 规范的 13.10.1 节中，明确定义了 <code>in</code> 操作符的运行时逻辑，如图 5-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00510.jpeg\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-1　<code>in</code> 操作符的运行时逻辑</strong></p>\n<p>图 5-1 描述的内容如下。</p>\n<blockquote>\n<ol>\n<li class=\"第2级有序列表\">让 <code>lref</code> 的值为 <code>RelationalExpression</code> 的执行结果。</li>\n<li class=\"第2级有序列表\">让 <code>lval</code> 的值为 <code>? GetValue(lref)</code>。</li>\n<li class=\"第2级有序列表\">让 <code>rref</code> 的值为 <code>ShiftExpression</code> 的执行结果。</li>\n<li class=\"第2级有序列表\">让 <code>rval</code> 的值为 <code>? GetValue(rref)</code>。</li>\n<li class=\"第2级有序列表\">如果 <code>Type(rval)</code> 不是对象，则抛出 <code>TypeError</code> 异常。</li>\n<li class=\"第2级有序列表\">返回 <code>? HasProperty(rval, ? ToPropertyKey(lval))</code>。</li>\n</ol>\n</blockquote>\n<p>关键点在第 6 步，可以发现，<code>in</code> 操作符的运算结果是通过调用一个叫作 <code>HasProperty</code> 的抽象方法得到的。关于 <code>HasProperty</code> 抽象方法，可以在 ECMA-262 规范的 7.3.11 节中找到，它的操作如图 5-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00511.jpeg\" alt=\"\" width=\"35%\" style=\"width: 35%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-2　<code>HasProperty</code> 抽象方法的逻辑</strong></p>\n<p>图 5-2 描述的内容如下。</p>\n<blockquote>\n<ol>\n<li class=\"第2级有序列表\">断言：<code>Type(O)</code> 是 <code>Object</code>。</li>\n<li class=\"第2级有序列表\">断言：<code>IsPropertyKey(P)</code> 是 <code>true</code>。</li>\n<li class=\"第2级有序列表\">返回 <code>? O.[[HasProperty]](P)</code>。</li>\n</ol>\n</blockquote>\n<p>在第 3 步中，可以看到 <code>HasProperty</code> 抽象方法的返回值是通过调用对象的内部方法 <code>[[HasProperty]]</code> 得到的。而 <code>[[HasProperty]]</code> 内部方法可以在表 5-3 中找到，它对应的拦截函数名叫 <code>has</code>，因此我们可以通过 <code>has</code> 拦截函数实现对 <code>in</code> 操作符的代理：</p>\n<pre class=\"code-rows\"><code> const obj = { foo: 1 }\n const p = new Proxy(obj, {\n   has(target, key) {\n     track(target, key)\n     return Reflect.has(target, key)\n   }\n })\n</code></pre>\n<p>这样，当我们在副作用函数中通过 <code>in</code> 操作符操作响应式数据时，就能够建立依赖关系：</p>\n<pre class=\"code-rows\"><code> effect(() =&gt; {\n   'foo' in p // 将会建立依赖关系\n })\n</code></pre>\n<p>再来看看如何拦截 <code>for...in</code> 循环。同样，我们能够拦截的所有方法都在表 5-3 中，而表 5-3 列出的是一个对象的所有基本语义方法，也就是说，任何操作其实都是由这些基本语义方法及其组合实现的，<code>for...in</code> 循环也不例外。为了搞清楚 <code>for...in</code> 循环依赖哪些基本语义方法，还需要看规范。</p>\n<p>由于这部分规范内容较多，因此这里只截取关键部分。在规范的 14.7.5.6 节中定义了 <code>for...in</code> 头部的执行规则，如图 5-3 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00512.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-3　<code>for...in</code> 头部的执行规则</strong></p>\n<p>图 5-3 中第 6 步描述的内容如下。</p>\n<blockquote>\n<p>6. 如果 <code>iterationKind</code> 是<strong>枚举</strong>（enumerate），则</p>\n<p>a. 如果 <code>exprValue</code> 是 <code>undefined</code> 或 <code>null</code>，那么</p>\n<p>　　i. 返回 <code>Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }</code>。</p>\n<p>b. 让 <code>obj</code> 的值为 <code>! ToObject(exprValue)</code>。</p>\n<p>c. 让 <code>iterator</code> 的值为 <code>? EnumerateObjectProperties(obj)</code>。</p>\n<p>d. 让 <code>nextMethod</code> 的值为 <code>! GetV(iterator, \"next\")</code>。</p>\n<p>e. 返回 <code>Record{ [[Iterator]]: iterator, [[NextMethod]]: nextMethod, [[Done]]: false }</code>。</p>\n</blockquote>\n<p>仔细观察第 6 步的第 c 子步骤：</p>\n<blockquote>\n<p>让 <code>iterator</code> 的值为 <code>? EnumerateObjectProperties(obj)</code>。</p>\n</blockquote>\n<p>其中的关键点在于 <code>EnumerateObjectProperties(obj)</code>。这里的 <code>EnumerateObjectProperties</code> 是一个抽象方法，该方法返回一个迭代器对象，规范的 14.7.5.9 节给出了满足该抽象方法的示例实现，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function* EnumerateObjectProperties(obj) {\n   const visited = new Set();\n   for (const key of Reflect.ownKeys(obj)) {\n     if (typeof key === \"symbol\") continue;\n     const desc = Reflect.getOwnPropertyDescriptor(obj, key);\n     if (desc) {\n       visited.add(key);\n       if (desc.enumerable) yield key;\n     }\n   }\n   const proto = Reflect.getPrototypeOf(obj);\n   if (proto === null) return;\n   for (const protoKey of EnumerateObjectProperties(proto)) {\n     if (!visited.has(protoKey)) yield protoKey;\n   }\n }\n</code></pre>\n<p>可以看到，该方法是一个 <code>generator</code> 函数，接收一个参数 <code>obj</code>。实际上，<code>obj</code> 就是被 <code>for...in</code> 循环遍历的对象，其关键点在于使用 <code>Reflect.ownKeys(obj)</code> 来获取只属于对象自身拥有的键。有了这个线索，如何拦截 <code>for...in</code> 循环的答案已经很明显了，我们可以使用 <code>ownKeys</code> 拦截函数来拦截 <code>Reflect.ownKeys</code> 操作：</p>\n<pre class=\"code-rows\"><code> const obj = { foo: 1 }\n const ITERATE_KEY = Symbol()\n<p>const p = new Proxy(obj, {<br />\nownKeys(target) {<br />\n// 将副作用函数与 ITERATE_KEY 关联<br />\ntrack(target, ITERATE_KEY)<br />\nreturn Reflect.ownKeys(target)<br />\n}<br />\n})<br />\n</code></pre></p>\n<p>如上面的代码所示，拦截 <code>ownKeys</code> 操作即可间接拦截 <code>for...in</code> 循环。但相信大家已经注意到了，我们在使用 <code>track</code> 函数进行追踪的时候，将 <code>ITERATE_KEY</code> 作为追踪的 <code>key</code>，为什么这么做呢？这是因为 <code>ownKeys</code> 拦截函数与 <code>get</code>/<code>set</code> 拦截函数不同，在 <code>set</code>/<code>get</code> 中，我们可以得到具体操作的 <code>key</code>，但是在 <code>ownKeys</code> 中，我们只能拿到目标对象 <code>target</code>。这也很符合直觉，因为在读写属性值时，总是能够明确地知道当前正在操作哪一个属性，所以只需要在该属性与副作用函数之间建立联系即可。而 <code>ownKeys</code> 用来获取一个对象的所有属于自己的键值，这个操作明显不与任何具体的键进行绑定，因此我们只能够构造唯一的 <code>key</code> 作为标识，即 <code>ITERATE_KEY</code>。</p>\n<p>既然追踪的是 <code>ITERATE_KEY</code>，那么相应地，在触发响应的时候也应该触发它才行：</p>\n<pre class=\"code-rows\"><code> trigger(target, ITERATE_KEY)\n</code></pre>\n<p>但是在什么情况下，对数据的操作需要触发与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行呢？为了搞清楚这个问题，我们用一段代码来说明。假设副作用函数内有一段 <code>for...in</code> 循环：</p>\n<pre class=\"code-rows\"><code> const obj = { foo: 1 }\n const p = new Proxy(obj, {/* ... */})\n<p>effect(() =&gt; {<br />\n// for…in 循环<br />\nfor (const key in p) {<br />\nconsole.log(key) // foo<br />\n}<br />\n})<br />\n</code></pre></p>\n<p>副作用函数执行后，会与 <code>ITERATE_KEY</code> 之间建立响应联系，接下来我们尝试为对象 <code>p</code> 添加新的属性 <code>bar</code>：</p>\n<pre class=\"code-rows\"><code> p.bar = 2\n</code></pre>\n<p>由于对象 <code>p</code> 原本只有 <code>foo</code> 属性，因此 <code>for...in</code> 循环只会执行一次。现在为它添加了新的属性 <code>bar</code>，所以 <code>for...in</code> 循环就会由执行一次变成执行两次。也就是说，当为对象添加新属性时，会对 <code>for...in</code> 循环产生影响，所以需要触发与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行。但目前的实现还做不到这一点。当我们为对象 <code>p</code> 添加新的属性 <code>bar</code> 时，并没有触发副作用函数重新执行，这是为什么呢？我们来看一下现在的 <code>set</code> 拦截函数的实现：</p>\n<pre class=\"code-rows\"><code> const p = new Proxy(obj, {\n   // 拦截设置操作\n   set(target, key, newVal, receiver) {\n     // 设置属性值\n     const res = Reflect.set(target, key, newVal, receiver)\n     // 把副作用函数从桶里取出并执行\n     trigger(target, key)\n<pre><code> return res\n</code></pre>\n<p>},<br />\n// 省略其他拦截函数<br />\n})<br />\n</code></pre></p>\n<p>当为对象 <code>p</code> 添加新的 <code>bar</code> 属性时，会触发 <code>set</code> 拦截函数执行。此时 <code>set</code> 拦截函数接收到的 <code>key</code> 就是字符串 <code>'bar'</code>，因此最终调用 <code>trigger</code> 函数时也只是触发了与 <code>'bar'</code> 相关联的副作用函数重新执行。但根据前文的介绍，我们知道 <code>for...in</code> 循环是在副作用函数与 <code>ITERATE_KEY</code> 之间建立联系，这和 <code>'bar'</code> 一点儿关系都没有，因此当我们尝试执行 <code>p.bar = 2</code> 操作时，并不能正确地触发响应。</p>\n<p>弄清楚了问题在哪里，解决方案也就随之而来了。当添加属性时，我们将那些与 <code>ITERATE_KEY</code> 相关联的副作用函数也取出来执行就可以了：</p>\n<pre class=\"code-rows\"><code> function trigger(target, key) {\n   const depsMap = bucket.get(target)\n   if (!depsMap) return\n   // 取得与 key 相关联的副作用函数\n   const effects = depsMap.get(key)\n   // 取得与 ITERATE_KEY 相关联的副作用函数\n   const iterateEffects = depsMap.get(ITERATE_KEY)\n<p>const effectsToRun = new Set()<br />\n// 将与 key 相关联的副作用函数添加到 effectsToRun<br />\neffects &amp;&amp; effects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})<br />\n// 将与 ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun<br />\niterateEffects &amp;&amp; iterateEffects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})</p>\n<p>effectsToRun.forEach(effectFn =&gt; {<br />\nif (effectFn.options.scheduler) {<br />\neffectFn.options.scheduler(effectFn)<br />\n} else {<br />\neffectFn()<br />\n}<br />\n})<br />\n}<br />\n</code></pre></p>\n<p>如以上代码所示，当 <code>trigger</code> 函数执行时，除了把那些直接与具体操作的 <code>key</code> 相关联的副作用函数取出来执行外，还要把那些与 <code>ITERATE_KEY</code> 相关联的副作用函数取出来执行。</p>\n<p>但相信细心的你已经发现了，对于添加新的属性来说，这么做没有什么问题，但如果仅仅修改已有属性的值，而不是添加新属性，那么问题就来了。看如下代码：</p>\n<pre class=\"code-rows\"><code> const obj = { foo: 1 }\n const p = new Proxy(obj, {/* ... */})\n<p>effect(() =&gt; {<br />\n// for…in 循环<br />\nfor (const key in p) {<br />\nconsole.log(key) // foo<br />\n}<br />\n})<br />\n</code></pre></p>\n<p>当我们修改 <code>p.foo</code> 的值时：</p>\n<pre class=\"code-rows\"><code> p.foo = 2\n</code></pre>\n<p>与添加新属性不同，修改属性不会对 <code>for...in</code> 循环产生影响。因为无论怎么修改一个属性的值，对于 <code>for...in</code> 循环来说都只会循环一次。所以在这种情况下，我们不需要触发副作用函数重新执行，否则会造成不必要的性能开销。然而无论是添加新属性，还是修改已有的属性值，其基本语义都是 <code>[[Set]]</code>，我们都是通过 <code>set</code> 拦截函数来实现拦截的，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> const p = new Proxy(obj, {\n   // 拦截设置操作\n   set(target, key, newVal, receiver) {\n     // 设置属性值\n     const res = Reflect.set(target, key, newVal, receiver)\n     // 把副作用函数从桶里取出并执行\n     trigger(target, key)\n<pre><code> return res\n</code></pre>\n<p>},<br />\n// 省略其他拦截函数<br />\n})<br />\n</code></pre></p>\n<p>所以要想解决上述问题，当设置属性操作发生时，就需要我们在 <code>set</code> 拦截函数内能够区分操作的类型，到底是添加新属性还是设置已有属性：</p>\n<pre class=\"code-rows\"><code> const p = new Proxy(obj, {\n   // 拦截设置操作\n   set(target, key, newVal, receiver) {\n     // 如果属性不存在，则说明是在添加新属性，否则是设置已有属性\n     const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\n<pre><code> // 设置属性值\n const res = Reflect.set(target, key, newVal, receiver)\n\n // 将 type 作为第三个参数传递给 trigger 函数\n trigger(target, key, type)\n\n return res\n</code></pre>\n<p>},<br />\n// 省略其他拦截函数<br />\n})<br />\n</code></pre></p>\n<p>如以上代码所示，我们优先使用 <code>Object.prototype.hasOwnProperty</code> 检查当前操作的属性是否已经存在于目标对象上，如果存在，则说明当前操作类型为 <code>'SET'</code>，即修改属性值；否则认为当前操作类型为 <code>'ADD'</code>，即添加新属性。最后，我们把类型结果 <code>type</code> 作为第三个参数传递给 <code>trigger</code> 函数。</p>\n<p>在 <code>trigger</code> 函数内就可以通过类型 <code>type</code> 来区分当前的操作类型，并且只有当操作类型 <code>type</code> 为 <code>'ADD'</code> 时，才会触发与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行，这样就避免了不必要的性能损耗：</p>\n<pre class=\"code-rows\"><code> function trigger(target, key, type) {\n   const depsMap = bucket.get(target)\n   if (!depsMap) return\n   const effects = depsMap.get(key)\n<p>const effectsToRun = new Set()<br />\neffects &amp;&amp; effects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})</p>\n<p>console.log(type, key)<br />\n// 只有当操作类型为 ‘ADD’ 时，才触发与 ITERATE_KEY 相关联的副作用函数重新执行<br />\nif (type === ‘ADD’) {<br />\nconst iterateEffects = depsMap.get(ITERATE_KEY)<br />\niterateEffects &amp;&amp; iterateEffects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})<br />\n}</p>\n<p>effectsToRun.forEach(effectFn =&gt; {<br />\nif (effectFn.options.scheduler) {<br />\neffectFn.options.scheduler(effectFn)<br />\n} else {<br />\neffectFn()<br />\n}<br />\n})<br />\n}<br />\n</code></pre></p>\n<p>通常我们会将操作类型封装为一个枚举值，例如：</p>\n<pre class=\"code-rows\"><code> const TriggerType = {\n   SET: 'SET',\n   ADD: 'ADD'\n }\n</code></pre>\n<p>这样无论是对后期代码的维护，还是对代码的清晰度，都是非常有帮助的。但这里我们就不讨论这些细枝末节了。</p>\n<p>关于对象的代理，还剩下最后一项工作需要做，即删除属性操作的代理：</p>\n<pre class=\"code-rows\"><code> delete p.foo\n</code></pre>\n<p>如何代理 <code>delete</code> 操作符呢？还是看规范，规范的 13.5.1.2 节中明确定义了 <code>delete</code> 操作符的行为，如图 5-4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00513.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-4　<code>delete</code> 操作符的行为</strong></p>\n<p>图 5-4 中的第 5 步描述的内容如下。</p>\n<blockquote>\n<p>5. 如果 <code>IsPropertyReference(ref)</code> 是 <code>true</code>，那么</p>\n<p>a. 断言：<code>! IsPrivateReference(ref)</code> 是 <code>false</code>。</p>\n<p>b. 如果 <code>IsSuperReference(ref)</code> 也是 <code>true</code>，则抛出 <code>ReferenceError</code> 异常。</p>\n<p>c. 让 <code>baseObj</code> 的值为 <code>! ToObject(ref,[[Base]])</code>。</p>\n<p>d. 让 <code>deleteStatus</code> 的值为 <code>? baseObj.[[Delete]](ref.[[ReferencedName]])</code>。</p>\n<p>e. 如果 <code>deleteStatus</code> 的值为 <code>false</code> 并且 <code>ref.[[Strict]]</code> 的值是 <code>true</code>，则抛出 <code>TypeError</code> 异常。</p>\n<p>f. 返回 <code>deleteStatus</code>。</p>\n</blockquote>\n<p>由第 5 步中的 d 子步骤可知，<code>delete</code> 操作符的行为依赖 <code>[[Delete]]</code> 内部方法。接着查看表 5-3 可知，该内部方法可以使用 <code>deleteProperty</code> 拦截：</p>\n<pre class=\"code-rows\"><code> const p = new Proxy(obj, {\n   deleteProperty(target, key) {\n     // 检查被操作的属性是否是对象自己的属性\n     const hadKey = Object.prototype.hasOwnProperty.call(target, key)\n     // 使用 Reflect.deleteProperty 完成属性的删除\n     const res = Reflect.deleteProperty(target, key)\n<pre><code> if (res &amp;amp;&amp;amp; hadKey) {\n   // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新\n   trigger(target, key, 'DELETE')\n }\n\n return res\n</code></pre>\n<p>}<br />\n})<br />\n</code></pre></p>\n<p>如以上代码所示，首先检查被删除的属性是否属于对象自身，然后调用 <code>Reflect.deleteProperty</code> 函数完成属性的删除工作，只有当这两步的结果都满足条件时，才调用 <code>trigger</code> 函数触发副作用函数重新执行。需要注意的是，在调用 <code>trigger</code> 函数时，我们传递了新的操作类型 <code>'DELETE'</code>。由于删除操作会使得对象的键变少，它会影响 <code>for...in</code> 循环的次数，因此当操作类型为 <code>'DELETE'</code> 时，我们也应该触发那些与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行：</p>\n<pre class=\"code-rows\"><code> function trigger(target, key, type) {\n   const depsMap = bucket.get(target)\n   if (!depsMap) return\n   const effects = depsMap.get(key)\n<p>const effectsToRun = new Set()<br />\neffects &amp;&amp; effects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})</p>\n<p>// 当操作类型为 ADD 或 DELETE 时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行<br />\nif (type === ‘ADD’ || type === ‘DELETE’) {<br />\nconst iterateEffects = depsMap.get(ITERATE_KEY)<br />\niterateEffects &amp;&amp; iterateEffects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})<br />\n}</p>\n<p>effectsToRun.forEach(effectFn =&gt; {<br />\nif (effectFn.options.scheduler) {<br />\neffectFn.options.scheduler(effectFn)<br />\n} else {<br />\neffectFn()<br />\n}<br />\n})<br />\n}<br />\n</code></pre></p>\n<p>在这段代码中，我们添加了 <code>type === 'DELETE'</code> 判断，使得删除属性操作能够触发与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行。</p>\n","neighbors":{"left":{"article_title":"第 4 章 响应系统的作用与实现(2)","id":740763},"right":{"article_title":"第 5 章 非原始值的响应式方案(2)","id":740765}},"comments":[]}