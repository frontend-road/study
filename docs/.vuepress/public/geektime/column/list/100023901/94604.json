{"id":94604,"title":"32 | Balking模式：再谈线程安全的单例模式","content":"<p>上一篇文章中，我们提到可以用“多线程版本的if”来理解Guarded Suspension模式，不同于单线程中的if，这个“多线程版本的if”是需要等待的，而且还很执着，必须要等到条件为真。但很显然这个世界，不是所有场景都需要这么执着，有时候我们还需要快速放弃。</p><p>需要快速放弃的一个最常见的例子是各种编辑器提供的自动保存功能。自动保存功能的实现逻辑一般都是隔一定时间自动执行存盘操作，存盘操作的前提是文件做过修改，如果文件没有执行过修改操作，就需要快速放弃存盘操作。下面的示例代码将自动保存功能代码化了，很显然AutoSaveEditor这个类不是线程安全的，因为对共享变量changed的读写没有使用同步，那如何保证AutoSaveEditor的线程安全性呢？</p><pre><code>class AutoSaveEditor{\n  //文件是否被修改过\n  boolean changed=false;\n  //定时任务线程池\n  ScheduledExecutorService ses = \n    Executors.newSingleThreadScheduledExecutor();\n  //定时执行自动保存\n  void startAutoSave(){\n    ses.scheduleWithFixedDelay(()-&gt;{\n      autoSave();\n    }, 5, 5, TimeUnit.SECONDS);  \n  }\n  //自动存盘操作\n  void autoSave(){\n    if (!changed) {\n      return;\n    }\n    changed = false;\n    //执行存盘操作\n    //省略且实现\n    this.execSave();\n  }\n  //编辑操作\n  void edit(){\n    //省略编辑逻辑\n    ......\n    changed = true;\n  }\n}\n</code></pre><p>解决这个问题相信你一定手到擒来了：读写共享变量changed的方法autoSave()和edit()都加互斥锁就可以了。这样做虽然简单，但是性能很差，原因是锁的范围太大了。那我们可以将锁的范围缩小，只在读写共享变量changed的地方加锁，实现代码如下所示。</p><pre><code>//自动存盘操作\nvoid autoSave(){\n  synchronized(this){\n    if (!changed) {\n      return;\n    }\n    changed = false;\n  }\n  //执行存盘操作\n  //省略且实现\n  this.execSave();\n}\n//编辑操作\nvoid edit(){\n  //省略编辑逻辑\n  ......\n  synchronized(this){\n    changed = true;\n  }\n}  \n</code></pre><p>如果你深入地分析一下这个示例程序，你会发现，示例中的共享变量是一个状态变量，业务逻辑依赖于这个状态变量的状态：当状态满足某个条件时，执行某个业务逻辑，其本质其实不过就是一个if而已，放到多线程场景里，就是一种“多线程版本的if”。这种“多线程版本的if”的应用场景还是很多的，所以也有人把它总结成了一种设计模式，叫做<strong>Balking模式</strong>。</p><!-- [[[read_end]]] --><h2>Balking模式的经典实现</h2><p>Balking模式本质上是一种规范化地解决“多线程版本的if”的方案，对于上面自动保存的例子，使用Balking模式规范化之后的写法如下所示，你会发现仅仅是将edit()方法中对共享变量changed的赋值操作抽取到了change()中，这样的好处是将并发处理逻辑和业务逻辑分开。</p><pre><code>boolean changed=false;\n//自动存盘操作\nvoid autoSave(){\n  synchronized(this){\n    if (!changed) {\n      return;\n    }\n    changed = false;\n  }\n  //执行存盘操作\n  //省略且实现\n  this.execSave();\n}\n//编辑操作\nvoid edit(){\n  //省略编辑逻辑\n  ......\n  change();\n}\n//改变状态\nvoid change(){\n  synchronized(this){\n    changed = true;\n  }\n}\n</code></pre><h2>用volatile实现Balking模式</h2><p>前面我们用synchronized实现了Balking模式，这种实现方式最为稳妥，建议你实际工作中也使用这个方案。不过在某些特定场景下，也可以使用volatile来实现，但<strong>使用volatile的前提是对原子性没有要求</strong>。</p><p>在<a href=\"https://time.geekbang.org/column/article/93154\">《29 | Copy-on-Write模式：不是延时策略的COW》</a>中，有一个RPC框架路由表的案例，在RPC框架中，本地路由表是要和注册中心进行信息同步的，应用启动的时候，会将应用依赖服务的路由表从注册中心同步到本地路由表中，如果应用重启的时候注册中心宕机，那么会导致该应用依赖的服务均不可用，因为找不到依赖服务的路由表。为了防止这种极端情况出现，RPC框架可以将本地路由表自动保存到本地文件中，如果重启的时候注册中心宕机，那么就从本地文件中恢复重启前的路由表。这其实也是一种降级的方案。</p><p>自动保存路由表和前面介绍的编辑器自动保存原理是一样的，也可以用Balking模式实现，不过我们这里采用volatile来实现，实现的代码如下所示。之所以可以采用volatile来实现，是因为对共享变量changed和rt的写操作不存在原子性的要求，而且采用scheduleWithFixedDelay()这种调度方式能保证同一时刻只有一个线程执行autoSave()方法。</p><pre><code>//路由表信息\npublic class RouterTable {\n  //Key:接口名\n  //Value:路由集合\n  ConcurrentHashMap&lt;String, CopyOnWriteArraySet&lt;Router&gt;&gt; \n    rt = new ConcurrentHashMap&lt;&gt;();    \n  //路由表是否发生变化\n  volatile boolean changed;\n  //将路由表写入本地文件的线程池\n  ScheduledExecutorService ses=\n    Executors.newSingleThreadScheduledExecutor();\n  //启动定时任务\n  //将变更后的路由表写入本地文件\n  public void startLocalSaver(){\n    ses.scheduleWithFixedDelay(()-&gt;{\n      autoSave();\n    }, 1, 1, MINUTES);\n  }\n  //保存路由表到本地文件\n  void autoSave() {\n    if (!changed) {\n      return;\n    }\n    changed = false;\n    //将路由表写入本地文件\n    //省略其方法实现\n    this.save2Local();\n  }\n  //删除路由\n  public void remove(Router router) {\n    Set&lt;Router&gt; set=rt.get(router.iface);\n    if (set != null) {\n      set.remove(router);\n      //路由表已发生变化\n      changed = true;\n    }\n  }\n  //增加路由\n  public void add(Router router) {\n    Set&lt;Router&gt; set = rt.computeIfAbsent(\n      route.iface, r -&gt; \n        new CopyOnWriteArraySet&lt;&gt;());\n    set.add(router);\n    //路由表已发生变化\n    changed = true;\n  }\n}\n</code></pre><p>Balking模式有一个非常典型的应用场景就是单次初始化，下面的示例代码是它的实现。这个实现方案中，我们将init()声明为一个同步方法，这样同一个时刻就只有一个线程能够执行init()方法；init()方法在第一次执行完时会将inited设置为true，这样后续执行init()方法的线程就不会再执行doInit()了。</p><pre><code>class InitTest{\n  boolean inited = false;\n  synchronized void init(){\n    if(inited){\n      return;\n    }\n    //省略doInit的实现\n    doInit();\n    inited=true;\n  }\n}\n</code></pre><p>线程安全的单例模式本质上其实也是单次初始化，所以可以用Balking模式来实现线程安全的单例模式，下面的示例代码是其实现。这个实现虽然功能上没有问题，但是性能却很差，因为互斥锁synchronized将getInstance()方法串行化了，那有没有办法可以优化一下它的性能呢？</p><pre><code>class Singleton{\n  private static\n    Singleton singleton;\n  //构造方法私有化  \n  private Singleton(){}\n  //获取实例（单例）\n  public synchronized static \n  Singleton getInstance(){\n    if(singleton == null){\n      singleton=new Singleton();\n    }\n    return singleton;\n  }\n}\n</code></pre><p>办法当然是有的，那就是经典的<strong>双重检查</strong>（Double Check）方案，下面的示例代码是其详细实现。在双重检查方案中，一旦Singleton对象被成功创建之后，就不会执行synchronized(Singleton.class){}相关的代码，也就是说，此时getInstance()方法的执行路径是无锁的，从而解决了性能问题。不过需要你注意的是，这个方案中使用了volatile来禁止编译优化，其原因你可以参考<a href=\"https://time.geekbang.org/column/article/83682\">《01 | 可见性、原子性和有序性问题：并发编程Bug的源头》</a>中相关的内容。至于获取锁后的二次检查，则是出于对安全性负责。</p><pre><code>class Singleton{\n  private static volatile \n    Singleton singleton;\n  //构造方法私有化  \n  private Singleton() {}\n  //获取实例（单例）\n  public static Singleton \n  getInstance() {\n    //第一次检查\n    if(singleton==null){\n      synchronize(Singleton.class){\n        //获取锁后二次检查\n        if(singleton==null){\n          singleton=new Singleton();\n        }\n      }\n    }\n    return singleton;\n  }\n}\n</code></pre><h2>总结</h2><p>Balking模式和Guarded Suspension模式从实现上看似乎没有多大的关系，Balking模式只需要用互斥锁就能解决，而Guarded Suspension模式则要用到管程这种高级的并发原语；但是从应用的角度来看，它们解决的都是“线程安全的if”语义，不同之处在于，Guarded Suspension模式会等待if条件为真，而Balking模式不会等待。</p><p>Balking模式的经典实现是使用互斥锁，你可以使用Java语言内置synchronized，也可以使用SDK提供Lock；如果你对互斥锁的性能不满意，可以尝试采用volatile方案，不过使用volatile方案需要你更加谨慎。</p><p>当然你也可以尝试使用双重检查方案来优化性能，双重检查中的第一次检查，完全是出于对性能的考量：避免执行加锁操作，因为加锁操作很耗时。而加锁之后的二次检查，则是出于对安全性负责。双重检查方案在优化加锁性能方面经常用到，例如<a href=\"https://time.geekbang.org/column/article/88909\">《17 | ReadWriteLock：如何快速实现一个完备的缓存？》</a>中实现缓存按需加载功能时，也用到了双重检查方案。</p><h2>课后思考</h2><p>下面的示例代码中，init()方法的本意是：仅需计算一次count的值，采用了Balking模式的volatile实现方式，你觉得这个实现是否有问题呢？</p><pre><code>class Test{\n  volatile boolean inited = false;\n  int count = 0;\n  void init(){\n    if(inited){\n      return;\n    }\n    inited = true;\n    //计算count的值\n    count = calc();\n  }\n}  \n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"31 | Guarded Suspension模式：等待唤醒机制的规范实现","id":94097},"right":{"article_title":"33 | Thread-Per-Message模式：最简单实用的分工方法","id":95098}},"comments":[{"had_liked":false,"id":93619,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1299615,"ip_address":"","ucode":"528DD5C8399AEC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKlwpFM3tkeG15YqyJTYWkfqkdmro9POq6SicYm57TaEFDOUZCXjoe0Z0Iz6UibGQqic3icJRsHdFzibtw/132","comment_is_top":false,"comment_ctime":1557536879,"is_pvip":true,"replies":[{"id":"33803","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557843670,"ip_address":"","comment_id":93619,"utype":1}],"discussion_count":3,"race_medal":0,"score":"224895836271","product_id":100023901,"comment_content":"是有问题的，volatile关键字只能保证可见性，无法保证原子性和互斥性。所以calc方法有可能被重复执行。","like_count":53,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449702,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557843670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1057179,"avatar":"https://static001.geekbang.org/account/avatar/00/10/21/9b/347301f6.jpg","nickname":"关羽","note":"","ucode":"6FC2CDA20191DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298692,"discussion_content":"那为什么签名单例的双重检查可以？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597379339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1057179,"avatar":"https://static001.geekbang.org/account/avatar/00/10/21/9b/347301f6.jpg","nickname":"关羽","note":"","ucode":"6FC2CDA20191DB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410992,"discussion_content":"双重效验在synchronized阻塞了多线程，保证了互斥性，里面的判断保证了安全性，在第一个线程修改了flag标识后，第二个线程不会跳过对flag标识的判断，不会有重复执行的问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635821995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298692,"ip_address":""},"score":410992,"extra":""}]}]},{"had_liked":false,"id":94548,"user_name":"leon","can_delete":false,"product_type":"c1","uid":1217955,"ip_address":"","ucode":"97610F35D2543A","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/a3/0a3cde60.jpg","comment_is_top":false,"comment_ctime":1557838803,"is_pvip":false,"replies":[{"id":"33798","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557842834,"ip_address":"","comment_id":94548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"194831367123","product_id":100023901,"comment_content":"思考题代码相当于：<br>if（intied == false） {  &#47;&#47; 1<br>     inited = true;          &#47;&#47;2<br>     count = calc()<br>}<br><br>可能有多条线程同时到1的位置，判断到inited为false，都进入2执行。<br>解决方案：<br>（1）加锁保护临界区<br>（2） AtomicBoolean.compareAndSet(false, true)<br>","like_count":46,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450103,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557842834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93735,"user_name":"Corner","can_delete":false,"product_type":"c1","uid":1446316,"ip_address":"","ucode":"7862D593172536","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg","comment_is_top":false,"comment_ctime":1557574483,"is_pvip":false,"replies":[{"id":"33943","content":"定时器任务只有一个线程，autosave加不加同步就无所谓了，多保存一次也没关系，这种概率毕竟很小<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557931081,"ip_address":"","comment_id":93735,"utype":1}],"discussion_count":4,"race_medal":0,"score":"65982083923","product_id":100023901,"comment_content":"最好就不要单独使用volatile防止产生线程安全问题。因为变量的读写是两个操作，和我们的直觉不一样，很容易出问题。老师的那个volatile就没有问题吗？如果一个线程修改了路由表，此时定时器任务判断共享变量为true，在将其修改为false之前，此时另一个线程又修改了路由表，然后定时任务继续执行会将其修改为false，这就出现问题了。最后还是要在autoSave方法上做同步的。","like_count":15,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449752,"discussion_content":"定时器任务只有一个线程，autosave加不加同步就无所谓了，多保存一次也没关系，这种概率毕竟很小\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557931081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1446728,"avatar":"https://static001.geekbang.org/account/avatar/00/16/13/48/54e8250b.jpg","nickname":"frandblinkc","note":"","ucode":"B5CD43CAA76866","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373813,"discussion_content":"路由表修改了两次, autosave一次没有问题啊, autosave存的是所有的路由表信息, 而不是改动的部分.\n\n这里之所以不要求change的原子性正是因为autoSave() 中, changed读和写之间有remove() 或者 add()方法将changed 更改为true, 然后被覆盖为false完全不影响autosave.\n\n而ScheduledExecutorService 保证一次只有一个线程执行 autoSave(), autoSave之间不存在contention.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620882262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167318,"discussion_content":"老师，这应该不是 多保存一次的关系吧。而是路由表修改有两次，但只执行了一次保存操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581477372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1135604,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","nickname":"bin.chen","note":"","ucode":"5BA49358AB8A1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283129,"discussion_content":"保存的一次也是最新的路由信息-不影响数据的正确性；不过为了防止错误概率还是使用CAS来简单的解决一下还是可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592191758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":167318,"ip_address":""},"score":283129,"extra":""}]}]},{"had_liked":false,"id":94368,"user_name":"孙志强","can_delete":false,"product_type":"c1","uid":1325997,"ip_address":"","ucode":"9C070F1E4EC6FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ad/31193b83.jpg","comment_is_top":false,"comment_ctime":1557796711,"is_pvip":true,"replies":[{"id":"33940","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557930686,"ip_address":"","comment_id":94368,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57392371559","product_id":100023901,"comment_content":"inited变量需要使用CAS的方式进行赋值，赋值失败就return，保证只有一个线程可以修改inited变量。","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450040,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557930686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93594,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1557512509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35917250877","product_id":100023901,"comment_content":"第8行 inited = true；改成cas操作<br>失败直接return。成功继续执行cal方法","like_count":9},{"had_liked":false,"id":121511,"user_name":"岥羽","can_delete":false,"product_type":"c1","uid":1391037,"ip_address":"","ucode":"0CD1C34BD7CD4F","user_header":"https://static001.geekbang.org/account/avatar/00/15/39/bd/74059999.jpg","comment_is_top":false,"comment_ctime":1565149662,"is_pvip":false,"replies":[{"id":"94109","content":"boolean变量读写是一条机器指令完成的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1604447042,"ip_address":"","comment_id":121511,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23039986142","product_id":100023901,"comment_content":"老师，自动保存路由表用 Balking 模式的volatile方式实现中，为什么对共享变量 changed 和 rt 的写操作不存在原子性的要求？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461828,"discussion_content":"boolean变量读写是一条机器指令完成的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604447042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596047,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","nickname":"Geek_8c5f9c","note":"","ucode":"70CD441EAF490F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187595,"discussion_content":"我觉得是有原子性的要求的, 只是原子性不需要额外写程序来保证。boolean类型的操作原本就是原子性的。ConcurrentHashMap和CopyOnWriteArraySet的写操作也是线程安全的，所以这里用volatile就保证可见性就够了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582738620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93621,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1557536947,"is_pvip":false,"replies":[{"id":"34451","content":"你没有办法控制调用方的线程数，autosave你是能控制的。不过加锁以后就串行了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558361816,"ip_address":"","comment_id":93621,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23032373427","product_id":100023901,"comment_content":"回答问题：<br>有问题，volatile不能保证原子性，题目要求只需计算一次Count，所以需要对共享变量inited加锁保护。<br><br>疑问：<br>public class RouterTable 类中AutoSave方法同一时刻只有一个线程调用，而Remove和Add方法也是要求使用方单线程访问吗？在实际开发中一般采用什么方式达成这种约定呢？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449703,"discussion_content":"你没有办法控制调用方的线程数，autosave你是能控制的。不过加锁以后就串行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558361816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104092,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1560649573,"is_pvip":false,"replies":[{"id":"38362","content":"局部变量是不会在线程间共享的，也没有volatile特性","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561192161,"ip_address":"","comment_id":104092,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18740518757","product_id":100023901,"comment_content":"volative修饰的属性。我见过在方法中。用局部变量接收该属性值，方法后续的操作都基于该局部变量。这样是不是就不再有volative的特性了？性能虽然提高了，毕竟能走缓存和编译优化了。但是就像上例双重检查的场景。这么个操作就依旧会有空指针异常的可能。请问老师我理解对吗。","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454122,"discussion_content":"局部变量是不会在线程间共享的，也没有volatile特性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561192161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129406,"user_name":"逆流的鱼","can_delete":false,"product_type":"c1","uid":1258399,"ip_address":"","ucode":"AA3DDE44A83C40","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/9f/8dbd9558.jpg","comment_is_top":false,"comment_ctime":1567126281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14452028169","product_id":100023901,"comment_content":"这两个模式怎么这么违和，突兀，虎头虎脑的","like_count":3},{"had_liked":false,"id":93661,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1557551163,"is_pvip":false,"replies":[{"id":"33676","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557758003,"ip_address":"","comment_id":93661,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442453051","product_id":100023901,"comment_content":"有问题，存在竞态条件","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449718,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557758003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93663,"user_name":"热台","can_delete":false,"product_type":"c1","uid":1316603,"ip_address":"","ucode":"7F49BBDD170CA8","user_header":"https://static001.geekbang.org/account/avatar/00/14/16/fb/c8a52099.jpg","comment_is_top":false,"comment_ctime":1557551858,"is_pvip":false,"replies":[{"id":"33675","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557757994,"ip_address":"","comment_id":93663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10147486450","product_id":100023901,"comment_content":"回答问题<br>1，cal（）可能被执行多次<br>2.  也可能cal（）执行结束前，count就被使用<br><br>解决方法<br>inited 赋值和cal（）执行放在一个同步块中，并增加双重check","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449720,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557757994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350367,"user_name":"码小呆","can_delete":false,"product_type":"c1","uid":2055809,"ip_address":"","ucode":"44532D6ABF9340","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg","comment_is_top":false,"comment_ctime":1656856171,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656856171","product_id":100023901,"comment_content":"感觉需要加锁,无法保证原子性","like_count":0},{"had_liked":false,"id":318298,"user_name":"花蛋壳","can_delete":false,"product_type":"c1","uid":1111006,"ip_address":"","ucode":"917BB219120BD2","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/de/c6509355.jpg","comment_is_top":false,"comment_ctime":1635235533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635235533","product_id":100023901,"comment_content":"把代码 inited = true; 放在 init方法第一行执行可不可行？","like_count":0},{"had_liked":false,"id":308414,"user_name":"听风有信","can_delete":false,"product_type":"c1","uid":2683430,"ip_address":"","ucode":"2CCB467114FF5C","user_header":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","comment_is_top":false,"comment_ctime":1629612368,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629612368","product_id":100023901,"comment_content":"AutoSaveEditor是不是也可以用volatile保证可见性就行了？","like_count":0},{"had_liked":false,"id":284196,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1616118551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616118551","product_id":100023901,"comment_content":"多个线程同时执行完if判断后进入到inited=true赋值操作，这一步无法确认单个线程通过，可以对if判断部分加锁","like_count":0},{"had_liked":false,"id":247623,"user_name":"geoxs","can_delete":false,"product_type":"c1","uid":1147331,"ip_address":"","ucode":"1B377DB0A58F89","user_header":"","comment_is_top":false,"comment_ctime":1599781651,"is_pvip":false,"replies":[{"id":"91015","content":"有没有并发问题可以多看看第一部分","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1599915913,"ip_address":"","comment_id":247623,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599781651","product_id":100023901,"comment_content":"我有个问题，如果需求不要求只执行一次呢，比如计算很简单，耗费资源不大，多计算几次是可以接受的，可不可以这样写，有没有并发问题呢，甚至我把volitale关键字去掉可不可以呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505455,"discussion_content":"有没有并发问题可以多看看第一部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599915913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226735,"user_name":"bin.chen","can_delete":false,"product_type":"c1","uid":1135604,"ip_address":"","ucode":"5BA49358AB8A1A","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","comment_is_top":false,"comment_ctime":1592191955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592191955","product_id":100023901,"comment_content":"1.计算count值会造成执行多次<br>解决方案1:不使用volatile 直接使用锁解决<br>解决方案2:设置inited=true的地方使用CAS类解决多次重复操作执行计算的问题","like_count":0},{"had_liked":false,"id":224682,"user_name":"Just","can_delete":false,"product_type":"c1","uid":2022626,"ip_address":"","ucode":"35FA6917DE1D04","user_header":"https://static001.geekbang.org/account/avatar/00/1e/dc/e2/a3abd320.jpg","comment_is_top":false,"comment_ctime":1591505974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591505974","product_id":100023901,"comment_content":"1）并发情况下，calc会被执行多次<br>2）count的值有可能不正确","like_count":0},{"had_liked":false,"id":217421,"user_name":"湮汐","can_delete":false,"product_type":"c1","uid":1106268,"ip_address":"","ucode":"FB6185621891E5","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/5c/86606d9c.jpg","comment_is_top":false,"comment_ctime":1589502674,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1589502674","product_id":100023901,"comment_content":"用一个全局变量，去控制业务代码的流程。但是要注意这个业务代码的流程会不会存在“并发”，如果不存在并发，可以只用volatile；如果存在，那么必须要用管程控制原子性！","like_count":0,"discussions":[{"author":{"id":1493907,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","nickname":"努力努力再努力","note":"","ucode":"0C6EEA28FCE8C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583970,"discussion_content":"哈哈哈，汐神，我欣健","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660539062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210215,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1587698824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587698824","product_id":100023901,"comment_content":"肯定有问题的，最简单的可以加个synchronize解决。就像上面InitTest类初始化一次一样解决。","like_count":0},{"had_liked":false,"id":203110,"user_name":"Geek_c22199","can_delete":false,"product_type":"c1","uid":1441876,"ip_address":"","ucode":"1CE5B65513E360","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2vn8hyjICTCletGs0omz28lhriaZKX2XX9icYzAEon2IEoRnlXqyOia2bEPP0j7T6xexTnr77JJic8w/132","comment_is_top":false,"comment_ctime":1586140986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586140986","product_id":100023901,"comment_content":"路由表的例子中不加锁的话就不能保证change=true会写入成功，写入不成功就可能会丢失一部分改变的路由表","like_count":0},{"had_liked":false,"id":195897,"user_name":"奔跑的猪","can_delete":false,"product_type":"c1","uid":1602593,"ip_address":"","ucode":"94375121A233F4","user_header":"https://static001.geekbang.org/account/avatar/00/18/74/21/6c64afa9.jpg","comment_is_top":false,"comment_ctime":1585222629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585222629","product_id":100023901,"comment_content":"volatile关键字只能保证可见性，无法保证互斥性，所以思考题中volatile变量的正确使用姿势如下：<br>public class Test {<br><br>    private volatile boolean inited = false;<br><br>    @Getter<br>    private int count = 0;<br><br>    public void init() {<br>        if (inited) {<br>            return;<br>        }<br><br>        &#47;&#47; 写volatile变量前先执行一段空循环，增加读到inited为false的并发几率<br>        IntStream.range(0, Integer.MAX_VALUE).forEach(i -&gt; { });<br>        &#47;&#47; 正确用法1：写volatile变量前先通过CAS判断是否可以写成功<br>        if (!new AtomicBoolean(inited).compareAndSet(false, true)) {<br>            return;<br>        }<br>        inited = true;<br>        &#47;&#47; 正确用法2：写volatile变量时加锁，并在写之前做双重Check<br>&#47;&#47;        synchronized (this) {<br>&#47;&#47;            if (inited) {<br>&#47;&#47;                return;<br>&#47;&#47;            }<br>&#47;&#47;            inited = true;<br>&#47;&#47;        }<br>        try {<br>            calc();<br>        } catch (Exception e) {<br>            inited = false;<br>            e.printStackTrace();<br>        }<br>    }<br><br>    private void calc() {<br>        count = count + 1;<br>    }<br><br>    public static void main(String[] args) throws InterruptedException {<br>        Test test = new Test();<br>        int taskTotal = 10000;<br>        CountDownLatch counter = new CountDownLatch(taskTotal);<br>        ExecutorService exec = Executors.newFixedThreadPool(5);<br>        for (int i = 0; i &lt; taskTotal; i++) {<br>            exec.submit(() -&gt; {<br>                test.init();<br>                counter.countDown();<br>            });<br>        }<br>        counter.await();<br>        System.out.println(&quot;count = &quot; + test.getCount());<br>        exec.shutdown();<br>    }<br>}","like_count":0},{"had_liked":false,"id":195674,"user_name":"Mr.wang","can_delete":false,"product_type":"c1","uid":1224805,"ip_address":"","ucode":"86F341A5316BBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/b0/65/90387745.jpg","comment_is_top":false,"comment_ctime":1585211245,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585211245","product_id":100023901,"comment_content":"Balking模式需要保持互斥性，这里没有保证互斥，只是有使用voliate关键字，没法保证原子性和一致性。","like_count":0},{"had_liked":false,"id":188213,"user_name":"Evan","can_delete":false,"product_type":"c1","uid":1344281,"ip_address":"","ucode":"B877ABD0CF4661","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","comment_is_top":false,"comment_ctime":1584327944,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584327944","product_id":100023901,"comment_content":"从表面上看，这段代码的性能还可以了，但从安全性方面考虑多线程会出现Data Race，也就没有办法原子性。 而volatiled只解决了可见性问题","like_count":0},{"had_liked":false,"id":154765,"user_name":"李湘河","can_delete":false,"product_type":"c1","uid":1349528,"ip_address":"","ucode":"DB078B5DAAE82E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","comment_is_top":false,"comment_ctime":1574557739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574557739","product_id":100023901,"comment_content":"Volatile只能保证可见性，无法保证互斥性","like_count":0},{"had_liked":false,"id":137406,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1569733369,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1569733369","product_id":100023901,"comment_content":"volatile没办法保证操作的原子性，也就是在第一个线程执行inited=true时可能会发生时间片的切换，导致下一个线程在判断是否初始化的时候继续执行calc()操作，也就是说没办法保证calc()的唯一性，对比老师给的代码，应该为整个方法加上synchronized以达到只计算一次calc()的目的","like_count":0},{"had_liked":false,"id":106020,"user_name":"熊熊周周","can_delete":false,"product_type":"c1","uid":1115763,"ip_address":"","ucode":"FE746FFC213226","user_header":"https://static001.geekbang.org/account/avatar/00/11/06/73/4d6b1f09.jpg","comment_is_top":false,"comment_ctime":1561128954,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561128954","product_id":100023901,"comment_content":"inited = true;<br>除非代码所工作的操作系统平台环境或者java官方指定这个操作是原子性操作，线程安全的。我们不应该把它当做原子性的操作，线程安全性的操作。<br>解决了原始数据类型赋值是否是原子性操作的疑问","like_count":0,"discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57590,"discussion_content":"赋值是原子性的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574619662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101217,"user_name":"奇奇","can_delete":false,"product_type":"c1","uid":1399097,"ip_address":"","ucode":"BC86B0CB55E35A","user_header":"","comment_is_top":false,"comment_ctime":1559743377,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559743377","product_id":100023901,"comment_content":"课后思考题应该是!inited 代码是错的","like_count":0},{"had_liked":false,"id":99707,"user_name":"points","can_delete":false,"product_type":"c1","uid":1315891,"ip_address":"","ucode":"2AB84EA7E6ACA6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/oY8Qg85SpcfqUzbAwe2suaFV9faxgtfG1nvfSe9uX5KlOWu5BkTBDXY1e5Z4fWLsThoJvWxVUiaWmqg3caQiauGA/132","comment_is_top":false,"comment_ctime":1559283312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559283312","product_id":100023901,"comment_content":"class Test{<br>\t<br>\tAtomicBoolean inited = new AtomicBoolean(false);<br>\t<br>\tvoid inited( ){<br>\t\tif( inited.getAndSet(true) ){<br>\t\t\treturn ;<br>\t\t}<br>\t\t<br>\t}<br>}","like_count":0},{"had_liked":false,"id":96857,"user_name":"Rancood","can_delete":false,"product_type":"c1","uid":1204333,"ip_address":"","ucode":"052BDF2221F480","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/6d/e2576fda.jpg","comment_is_top":false,"comment_ctime":1558523323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558523323","product_id":100023901,"comment_content":"这个Balking模式的好处就是将并发处理逻辑与业务逻辑分离吗","like_count":0},{"had_liked":false,"id":96470,"user_name":"贺宇","can_delete":false,"product_type":"c1","uid":1445040,"ip_address":"","ucode":"55854825CC4AD2","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/b0/26c0e53f.jpg","comment_is_top":false,"comment_ctime":1558430862,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558430862","product_id":100023901,"comment_content":"这个问题好像和信号量那章的问题很相似","like_count":0},{"had_liked":false,"id":95718,"user_name":"ZOU志伟","can_delete":false,"product_type":"c1","uid":1029179,"ip_address":"","ucode":"439779871CC992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","comment_is_top":false,"comment_ctime":1558148305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558148305","product_id":100023901,"comment_content":"竞态条件问题","like_count":0},{"had_liked":false,"id":95120,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1557970552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557970552","product_id":100023901,"comment_content":"没有锁 有共享变量 多个线程 可能同时读到false哇， 就可能有多个线程init而让count值超过1哇。 <br><br>尽管读到了init=false, 真正的cal()也应该在同步里面，并且init此时任然是false哇~","like_count":0},{"had_liked":false,"id":93878,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1557649431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557649431","product_id":100023901,"comment_content":"有问题，在执行calc()方法之前，如果有别的线程进来，则直接返回count=0了，但第一个线程还是会执行calc()方法更新count值，安全性问题。","like_count":0},{"had_liked":false,"id":93805,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1557623643,"is_pvip":false,"replies":[{"id":"33669","content":"不适用分布式情况的单例","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557757517,"ip_address":"","comment_id":93805,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1557623643","product_id":100023901,"comment_content":"在微服务的场景下，synchornize应该不适用了吧","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449778,"discussion_content":"不适用分布式情况的单例","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557757517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438352,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4akcIyIOXB2OqibTe7FF90hwsBicxkjdicUNTMorGeIictdr3OoMxhc20yznmZWwAvQVThKPFWgOyMw/132","nickname":"Chuan","note":"","ucode":"FACEC5DAC36A7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164906,"discussion_content":"请问下分布式情况的单例的场景和实现方式是怎样的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581234311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93733,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1557574139,"is_pvip":false,"replies":[{"id":"33674","content":"👍对的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557757953,"ip_address":"","comment_id":93733,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557574139","product_id":100023901,"comment_content":"老师，volatile只能保证变量的可见性，在多线程下，发生线程切换会都读取到变量为false，则计算count方法被调用多次，对吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449750,"discussion_content":"👍对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557757953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93649,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1557544958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557544958","product_id":100023901,"comment_content":"有问题，inited共享变量和cal（）写操作需要保证原子性执行，上面的初始化操作可能会执行多次","like_count":0},{"had_liked":false,"id":93603,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1557533520,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1557533520","product_id":100023901,"comment_content":"打卡，文中关于使用volatile不需要考虑原子性的情况是什么意思呢？","like_count":0,"discussions":[{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315346,"discussion_content":"单纯读的情况，不需要写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603265509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}