{"id":740811,"title":"第 11 章 特型与泛型(1)","content":"<blockquote>\n<p>计算机科学家倾向于处理非统一性结构（情形 1、情形 2、情形 3），而数学家则倾向于找一个统一的公理来管理整个体系。</p>\n<p style=\"text-align: right\">——高德纳</p>\n</blockquote>\n<p>&nbsp;</p>\n<p>编程领域的伟大发现之一，就是可以编写能对许多不同类型（<strong>甚至是尚未发明的类型</strong>）的值进行操作的代码。下面是两个例子。</p>\n<ul>\n<li><code>Vec&lt;T&gt;</code> 是泛型的：你可以创建任意类型值的向量，包括在你的程序中定义的连 <code>Vec</code> 的作者都不曾设想的类型。</li>\n<li>许多类型有 <code>.write()</code> 方法，包括 <code>File</code> 和 <code>TcpStream</code>。你的代码可以通过引用来获取任意写入器，并向它发送数据。你的代码不必关心写入器的类型。以后，如果有人添加了一种新型写入器，你的代码也能够直接支持。</li>\n</ul>\n<p>当然，这种能力对 Rust 来说并不是什么新鲜事。这就是所谓的<strong>多态性</strong>，在 20 世纪 70 年代，它是最新且最热门的编程语言技术。到了现在，多态性实际上已经成了通用技术。Rust 通过两个相关联的特性来支持多态：特型和泛型。许多程序员熟悉这些概念，但 Rust 受到 Haskell 类型类（typeclass）的启发，采用了一种全新的方式。</p>\n<p><strong>特型</strong>是 Rust 体系中的接口或抽象基类。乍一看，它们和 Java 或 C# 中的接口差不多。写入字节的特型称为 <code>std::io::Write</code>，它在标准库中的定义开头部分是这样的：</p>\n<pre class=\"code-rows\"><code>trait Write {\n    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;\n    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;\n\n    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt; { ... }\n    ...\n}</code></pre>\n<p>此特型还提供了几个方法，我们只展示了前 3 个。</p>\n<p><code>File</code> 和 <code>TcpStream</code> 这两个标准类型以及 <code>Vec&lt;u8&gt;</code> 都实现了 <code>std::io::Write</code>。这 3 种类型都提供了 <code>.write()</code>、<code>.flush()</code> 等方法。使用写入器而不关心其具体类型的代码如下所示：</p>\n<pre class=\"code-rows\"><code>use std::io::Write;\n\nfn say_hello(out: &amp;mut dyn Write) -&gt; std::io::Result&lt;()&gt; {\n    out.write_all(b\"hello world\\n\")?;\n    out.flush()\n}</code></pre>\n<p><code>out</code> 的类型是 <code>&amp;mut dyn Write</code>，意思是“对实现了 <code>Write</code> 特型的任意值的可变引用”。我们可以将任何此类值的可变引用传给 <code>say_hello</code>：</p>\n<pre class=\"code-rows\"><code>use std::fs::File;\nlet mut local_file = File::create(\"hello.txt\")?;\nsay_hello(&amp;mut local_file)?;  // 正常\n\nlet mut bytes = vec![];\nsay_hello(&amp;mut bytes)?;  // 同样正常\nassert_eq!(bytes, b\"hello world\\n\");</code></pre>\n<p>本章展示特型的用法、工作原理，以及如何定义你自己的特型。其实，除了前面介绍的用法，特型还有很多其他用法：我们会使用特型为现有类型添加扩展方法，甚至可以在 <code>str</code>、<code>bool</code> 等内置类型上添加；我们会解释为什么向类型添加特型不需要额外的内存，以及如何在不需要虚方法调用开销的情况下使用特型；我们会看到，某些内置特型其实是 Rust 为运算符重载和其他特性提供的语言级钩子；我们会介绍 <code>Self</code> 类型、关联函数和关联类型，这是 Rust 从 Haskell 中借来的三大特性，它们优雅地解决了其他语言中要通过变通和入侵才能解决的问题。</p><!-- [[[read_end]]] -->\n<p><strong>泛型</strong>是 Rust 中多态的另一种形式。与 C++ 模板一样，泛型函数或泛型类型可以和不同类型的值一起使用：</p>\n<pre class=\"code-rows\"><code>/// 给定两个值，找出哪个更小\nfn min&lt;T: Ord&gt;(value1: T, value2: T) -&gt; T {\n    if value1 &lt;= value2 {\n        value1\n    } else {\n        value2\n    }\n}</code></pre>\n<p>此函数中的 <code>&lt;T: Ord&gt;</code> 表明 <code>min</code> 函数可以与实现了 <code>Ord</code> 特型的任意类型（任意有序类型）<code>T</code> 的参数一起使用。像这样的要求称为<strong>限界</strong>，因为它对 <code>T</code> 可能的类型范围做了限制。编译器会针对你实际用到的每种类型 <code>T</code> 生成一份单独的机器码。</p>\n<p>泛型和特型紧密相关：泛型函数会在限界中使用特型来阐明它能针对哪些类型的参数进行调用。因此，我们还会讨论 <code>&amp;mut dyn Write</code> 和 <code>&lt;T: Write&gt;</code> 的相似之处、不同之处，以及如何在特型的这两种使用方式之间做出选择。</p>\n<h2 id=\"nav_point_184\">11.1　使用特型</h2>\n<p>特型是一种语言特性，我们<strong>可以</strong>说某类型支持或不支持某个特型。大多数情况下，特型代表着一种能力，即一个类型能做什么。</p>\n<ul>\n<li>实现了 <code>std::io::Write</code> 的值能写出一些字节。</li>\n<li>实现了 <code>std::iter::Iterator</code> 的值能生成一系列值。</li>\n<li>实现了 <code>std::clone::Clone</code> 的值能在内存中克隆自身。</li>\n<li>实现了 <code>std::fmt::Debug</code> 的值能用带有 <code>{:?}</code> 格式说明符的 <code>println!()</code> 打印出来。</li>\n</ul>\n<p>这 4 个特型都是 Rust 标准库的一部分，许多标准类型实现了它们。</p>\n<ul>\n<li><code>std::fs::File</code> 实现了 <code>Write</code> 特型，它能将一些字节写入本地文件。<code>std::net::TcpStream</code> 能写入网络连接。<code>Vec&lt;u8&gt;</code> 也实现了 <code>Write</code>，对字节向量的每次 <code>.write()</code> 调用都会将一些数据追加到向量末尾。</li>\n<li><code>Range&lt;i32&gt;</code>（表达式 <code>0..10</code> 的类型）实现了 <code>Iterator</code> 特型，一些与切片、哈希表等关联的迭代器类型同样实现了 <code>Iterator</code> 特型。</li>\n<li>大多数标准库类型实现了 <code>Clone</code>。没实现 <code>Clone</code> 的主要是一些像 <code>TcpStream</code> 这样的类型，因为它们代表的不仅仅是内存中的数据。</li>\n<li>同样，大多数标准库类型支持 <code>Debug</code>。</li>\n</ul>\n<p>关于特型方法有一条值得注意的规则：特型本身必须在作用域内。否则，它的所有方法都是不可见的：</p>\n<pre class=\"code-rows\"><code>let mut buf: Vec&lt;u8&gt; = vec![];\nbuf.write_all(b\"hello\")?;  // 错误：没有名为`write_all`的方法</code></pre>\n<p>在这种情况下，编译器会打印出一条友好的错误消息，建议添加 <code>use std::io::Write;</code>，这确实可以解决问题：</p>\n<pre class=\"code-rows\"><code>use std::io::Write;\n\nlet mut buf: Vec&lt;u8&gt; = vec![];\nbuf.write_all(b\"hello\")?;  // 正确</code></pre>\n<p>之所以 Rust 会有这条规则，是因为你可以使用特型为任意类型添加新方法——甚至是像 <code>u32</code> 和 <code>str</code> 这样的标准库类型（正如我们将在本章后面看到的那样）。而第三方 crate 也可以这样做。显然，这可能导致命名冲突。但是由于 Rust 会要求你导入自己想用的特型，因此 crate 可以放心地利用这种超能力。只有导入两个特型，才会发生冲突，将具有相同名称的方法添加到同一个类型中。这在实践中非常罕见。（如果确实遇到冲突，你可以使用带完全限定符的方法名明确写出自己想要的内容，本章后面会介绍。）</p>\n<p><code>Clone</code> 和 <code>Iterator</code> 的各个方法在没有任何特殊导入的情况下就能工作，因为默认情况下它们始终在作用域中：它们是标准库预导入的一部分，Rust 会把这些名称自动导入每个模块中。事实上，预导入主要就是一些精心挑选的特型。第 13 章会介绍其中的许多内容。</p>\n<p>C++ 程序员和 C# 程序员可能已经看出来了，特型方法类似于虚方法。不过，特型方法的调用仍然很快，与任何其他方法调用一样快。一言以蔽之，这里没有多态。很明显，<code>buf</code> 一定是向量，而不可能是文件或网络连接。编译器可以生成对 <code>Vec&lt;u8&gt;::write()</code> 的简单调用，甚至可以内联该方法。（C++ 和 C# 通常也会这样做，不过有时会因为子类的缘故而无法做到。）只有通过 <code>&amp;mut dyn Write</code> 调用时才会产生动态派发（也叫虚方法调用）的开销，类型上的 <code>dyn</code> 关键字指出了这一点。<code>dyn Write</code> 叫作<strong>特型对象</strong>，11.1.1 节会介绍特型对象的一些技术细节，以及它们与泛型函数的比较。</p>\n<h3 id=\"nav_point_185\">11.1.1　特型对象</h3>\n<p>在 Rust 中使用特型编写多态代码有两种方法：特型对象和泛型。我们将首先介绍特型对象，然后会在 11.1.2 节转向泛型。</p>\n<p>Rust 不允许 <code>dyn Write</code> 类型的变量：</p>\n<pre class=\"code-rows\"><code>use std::io::Write;\n\nlet mut buf: Vec&lt;u8&gt; = vec![];\nlet writer: dyn Write = buf;  // 错误：`Write`的大小不是常量</code></pre>\n<p>变量的大小必须是编译期已知的，而那些实现了 <code>Write</code> 的类型可以是任意大小。</p>\n<p>如果你是 C# 程序员或 Java 程序员，可能会对此感到惊讶，但原因其实很简单。在 Java 中，<code>OutputStream</code> 类型（类似于 <code>std::io::Write</code> 的 Java 标准接口）的变量其实是对任何实现了 <code>OutputStream</code> 的对象的引用。它本身就是引用，无须显式说明。C# 和大多数其他语言中的接口也一样。</p>\n<p>我们在 Rust 中也想这么做，但在 Rust 中，引用是显式的：</p>\n<pre class=\"code-rows\"><code>let mut buf: Vec&lt;u8&gt; = vec![];\nlet writer: &amp;mut dyn Write = &amp;mut buf;  // 正确</code></pre>\n<p>对特型类型（如 <code>writer</code>）的引用叫作<strong>特型对象</strong>。与任何其他引用一样，特型对象指向某个值，它具有生命周期，并且可以是可变或共享的。</p>\n<p>特型对象的与众不同之处在于，Rust 通常无法在编译期间知道引用目标的类型。因此，特型对象要包含一些关于引用目标类型的额外信息。这仅供 Rust 自己在幕后使用：当你调用 <code>writer.write(data)</code> 时，Rust 需要使用类型信息来根据 <code>*writer</code> 的具体类型动态调用正确的 <code>write</code> 方法。你不能直接查询这些类型信息，Rust 也不支持从特型对象 <code>&amp;mut dyn Write</code> 向下转型回像 <code>Vec&lt;u8&gt;</code> 这样的具体类型。</p>\n<p><strong>特型对象的内存布局</strong></p>\n<p>在内存中，特型对象是一个胖指针，由指向值的指针和指向表示该值类型的虚表的指针组成。因此，每个特型对象会占用两个机器字，如图 11-1 所示。</p>\n<p>C++ 也有这种运行期类型信息，叫作<strong>虚表</strong>或 vtable。就像在 C++ 中一样，在 Rust 中，虚表只会在编译期生成一次，并由同一类型的所有对象共享。图 11-1 中深色部分展示的所有内容（包括虚表）都是 Rust 的私有实现细节。同样，这些都不是你可以直接访问的字段和数据结构。当你调用特型对象的方法时，该语言会自动使用虚表来确定要调用哪个实现。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00856.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-1：内存中的特型对象</strong></p>\n<p>经验丰富的 C++ 程序员可能会注意到 Rust 和 C++ 在内存使用上略有不同。在 C++ 中，虚表指针或 vptr 是作为结构体的一部分存储的，而 Rust 使用的是胖指针方案。结构体本身只包含自己的字段。这样一来，每个结构体就可以实现几十个特型而不必包含几十个 vptr 了。甚至连 <code>i32</code> 这样大小不足以容纳 vptr 的类型都可以实现特型。</p>\n<p>Rust 在需要时会自动将普通引用转换为特型对象。这就是为什么我们能够在这个例子中把 <code>&amp;mut local_file</code> 传给 <code>say_hello</code>：</p>\n<pre class=\"code-rows\"><code>let mut local_file = File::create(\"hello.txt\")?;\nsay_hello(&amp;mut local_file)?;</code></pre>\n<p><code>&amp;mut local_file</code> 的类型是 <code>&amp;mut File</code>，<code>say_hello</code> 的参数类型是 <code>&amp;mut dyn Write</code>。由于 <code>File</code> 也是一种写入器，因此 Rust 允许这样操作，它会自动将普通引用转换为特型对象。</p>\n<p>同样，Rust 会愉快地将 <code>Box&lt;File&gt;</code> 转换为 <code>Box&lt;dyn Write&gt;</code>，这是一个拥有在堆中分配的写入器的值：</p>\n<pre class=\"code-rows\"><code>let w: Box&lt;dyn Write&gt; = Box::new(local_file);</code></pre>\n<p>和 <code>&amp;mut dyn Write</code> 一样，<code>Box&lt;dyn Write&gt;</code> 也是一个胖指针，即包含写入器本身的地址和虚表的地址。其他指针类型（如 <code>Rc&lt;dyn Write&gt;</code>）同样如此。</p>\n<p>这种转换是创建特型对象的唯一方法。编译器在这里真正做的事非常简单。在发生转换的地方，Rust 知道引用目标的真实类型（在本例中为 <code>File</code>），因此它只要加上适当的虚表的地址，把常规指针变成胖指针就可以了。</p>\n<h3 id=\"nav_point_186\">11.1.2　泛型函数与类型参数</h3>\n<p>本章在开头展示过一个以特型对象为参数的 <code>say_hello()</code> 函数。现在，让我们把该函数重写为泛型函数：</p>\n<pre class=\"code-rows\"><code>fn say_hello&lt;W: Write&gt;(out: &amp;mut W) -&gt; std::io::Result&lt;()&gt; {\n    out.write_all(b\"hello world\\n\")?;\n    out.flush()\n}</code></pre>\n<p>只有类型签名发生了变化：</p>\n<pre class=\"code-rows\"><code>fn say_hello(out: &amp;mut dyn Write)     // 普通函数\n\nfn say_hello&lt;W: Write&gt;(out: &amp;mut W)   // 泛型函数</code></pre>\n<p>短语 <code>&lt;W: Write&gt;</code> 把函数变成了泛型形式。此短语叫作<strong>类型参数</strong>。这意味着在这个函数的整个函数体中，<code>W</code> 都代表着某种实现了 <code>Write</code> 特型的类型。按照惯例，类型参数通常是单个大写字母。</p>\n<p><code>W</code> 代表哪种类型取决于泛型函数的使用方式：</p>\n<pre class=\"code-rows\"><code>say_hello(&amp;mut local_file)?;  // 调用say_hello::&lt;File&gt;\n\nsay_hello(&amp;mut bytes)?;       // 调用say_hello::&lt;Vec&lt;u8&gt;&gt;</code></pre>\n<p>当你将 <code>&amp;mut local_file</code> 传给泛型函数 <code>say_hello()</code> 时，其实调用的是 <code>say_hello::&lt;File&gt;()</code>。Rust 会为此函数生成一份机器码，以调用 <code>File::write_all()</code> 方法和 <code>File::flush()</code> 方法。当你传入 <code>&amp;mut bytes</code> 时，其实是在调用 <code>say_hello::&lt;Vec&lt;u8&gt;&gt;()</code>。Rust 会为这个版本的函数生成单独的机器码，以调用相应的 <code>Vec&lt;u8&gt;</code> 方法。在这两种情况下，Rust 都会从参数的类型推断出类型 <code>W</code>，这个过程叫作<strong>单态化</strong>，编译器会自动处理这一切。</p>\n<p>你总是可以明确写出类型参数：</p>\n<pre class=\"code-rows\"><code>say_hello::&lt;File&gt;(&amp;mut local_file)?;</code></pre>\n<p>但一般无此必要，因为 Rust 通常可以通过查看参数来推断出类型参数。在这里，<code>say_hello</code> 泛型函数需要一个 <code>&amp;mut W</code> 参数，我们向它传入了一个 <code>&amp;mut File</code>，所以 Rust 断定 <code>W = File</code>。</p>\n<p>如果你调用的泛型函数没有任何能提供有用线索的参数，则可能需要把它明确写出来：</p>\n<pre class=\"code-rows\"><code>// 调用无参数的泛型方法collect&lt;C&gt;()\nlet v1 = (0 .. 1000).collect();  // 错误：无法推断类型\nlet v2 = (0 .. 1000).collect::&lt;Vec&lt;i32&gt;&gt;(); // 正确</code></pre>\n<p>有时我们需要同一个类型参数的多种能力。如果想打印出向量中前十个最常用的值，那么就要让这些值是可打印的：</p>\n<pre class=\"code-rows\"><code>use std::fmt::Debug;\n\nfn top_ten&lt;T: Debug&gt;(values: &amp;Vec&lt;T&gt;) { ... }</code></pre>\n<p>但这还不够好。如果我们要确定哪些值是最常用的该怎么办呢？通常的做法是用这些值作为哈希表中的键。这意味着这些值还要支持 <code>Hash</code> 操作和 <code>Eq</code> 操作。<code>T</code> 的类型限界必须包括这些特型，就像 <code>Debug</code> 一样。这种情况下就要使用 <code>+</code> 号语法：</p>\n<pre class=\"code-rows\"><code>use std::hash::Hash;\nuse std::fmt::Debug;\n\nfn top_ten&lt;T: Debug + Hash + Eq&gt;(values: &amp;Vec&lt;T&gt;) { ... }</code></pre>\n<p>有些类型实现了 <code>Debug</code>，有些类型实现了 <code>Hash</code>，有些类型支持 <code>Eq</code>，还有一些类型（如 <code>u32</code> 和 <code>String</code>）实现了所有这 3 个，如图 11-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00857.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-2：把类型集用作特型</strong></p>\n<p>类型参数也可能完全没有限界，但是如果没有为它指定任何限界，则无法对它做什么。你可以移动它，也可以将它放入一个 <code>Box</code> 或向量中。但也只能做这些了。</p>\n<p>泛型函数可以有多个类型参数：</p>\n<pre class=\"code-rows\"><code>/// 在一个大型且分区的数据集上运行查询\n/// 参见&lt;http://research.google.com/archive/mapreduce.html&gt;\nfn run_query&lt;M: Mapper + Serialize, R: Reducer + Serialize&gt;(\n    data: &amp;DataSet, map: M, reduce: R) -&gt; Results\n{ ... }</code></pre>\n<p>如本示例所示，限界可能会变得很长，让人眼花缭乱。Rust 使用关键字 <code>where</code> 提供了另一种语法：</p>\n<pre class=\"code-rows\"><code>fn run_query&lt;M, R&gt;(data: &amp;DataSet, map: M, reduce: R) -&gt; Results\n    where M: Mapper + Serialize,\n          R: Reducer + Serialize\n{ ... }</code></pre>\n<p>类型参数 <code>M</code> 和 <code>R</code> 仍然放在前面声明，但限界移到了单独的行中。这种 <code>where</code> 子句也允许用于泛型结构体、枚举、类型别名和方法——任何允许使用限界的地方。</p>\n<p>当然，替代 <code>where</code> 子句的最佳方案是保持简单：找到一种无须大量使用泛型就能编写程序的方式。</p>\n<p>5.3.2 节中介绍了生命周期参数的语法。泛型函数可以同时具有生命周期参数和类型参数。生命周期参数要排在前面：</p>\n<pre class=\"code-rows\"><code>/// 返回对`candidates`中最接近`target`的点的引用\nfn nearest&lt;'t, 'c, P&gt;(target: &amp;'t P, candidates: &amp;'c [P]) -&gt; &amp;'c P\n    where P: MeasureDistance\n{\n    ...\n}</code></pre>\n<p>这个函数有两个参数，即 <code>target</code> 和 <code>candidates</code>。两者都是引用，但我们为它们赋予了不同的生命周期 <code>'t</code> 和 <code>'c</code>（参见 5.3.6 节）。此外，该函数适用于实现了 <code>MeasureDistance</code> 特型的任意类型 <code>P</code>，因此可以在一个程序中将其用于 <code>Point2d</code> 值，而在另一个程序中将其用于 <code>Point3d</code> 值。</p>\n<p>生命周期永远不会对机器码产生任何影响。如果对 <code>nearest()</code> 进行的两次调用使用了相同的类型 <code>P</code> 和不同的生命周期，那么就会调用同一个编译结果函数。只有不同的类型才会导致 Rust 编译出泛型函数的多个副本。</p>\n<p>除了类型和生命周期，泛型函数也可以接受常量参数，就像 9.9 节中介绍过的 <code>Polynomial</code> 结构体：</p>\n<pre class=\"code-rows\"><code>fn dot_product&lt;const N: usize&gt;(a: [f64; N], b: [f64; N]) -&gt; f64 {\n    let mut sum = 0.;\n    for i in 0..N {\n        sum += a[i] * b[i];\n    }\n    sum\n}</code></pre>\n<p>在这里，短语 <code>&lt;const N: usize&gt;</code> 指出函数 <code>dot_product</code> 需要一个泛型参数 <code>N</code>，该参数必须是一个 <code>usize</code>。给定了 <code>N</code>，这个函数就会接受两个 <code>[f64; N]</code> 类型的参数，并将其对应元素的乘积相加。<code>N</code> 与普通 <code>usize</code> 参数的区别是，你可以在 <code>dot_product</code> 的签名或函数体的类型中使用它。</p>\n<p>与类型参数一样，你既可以显式提供常量参数，也可以让 Rust 推断它们。</p>\n<pre class=\"code-rows\"><code>// 显式提供`3`作为`N`的值\ndot_product::&lt;3&gt;([0.2, 0.4, 0.6], [0., 0., 1.])\n\n// 让Rust推断`N`必然是`2`\ndot_product([3., 4.], [-5., 1.])</code></pre>\n<p>当然，函数并不是 Rust 中唯一的泛型代码。</p>\n<ul>\n<li>9.7 节和 10.1.4 节已经介绍过泛型类型。</li>\n<li><p>单独的方法也可以是泛型的，即使它并没有定义在泛型类型上。</p>\n<pre class=\"code-rows\"><code>impl PancakeStack {\n    fn push&lt;T: Topping&gt;(&amp;mut self, goop: T) -&gt; PancakeResult&lt;()&gt; {\n        goop.pour(&amp;self);\n        self.absorb_topping(goop)\n    }\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p>类型别名也可以是泛型的。</p>\n<pre class=\"code-rows\"><code>type PancakeResult&lt;T&gt; = Result&lt;T, PancakeError&gt;;</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p>本章在后面还会介绍一些泛型特型。</p>\n</li>\n</ul>\n<p>本节中介绍的特性（限界、<code>where</code> 子句、生命周期参数等）可用于所有泛型语法项，而不仅仅是函数。</p>\n<h3 id=\"nav_point_187\">11.1.3　使用哪一个</h3>\n<p>关于是使用特型对象还是泛型代码的选择相当微妙。由于这两个特性都基于特型，因此它们有很多共同点。</p>\n<p>当你需要一些混合类型值的集合时，特型对象是正确的选择。制作泛型沙拉在技术上是可行的：</p>\n<pre class=\"code-rows\"><code>trait Vegetable {\n    ...\n}\n\nstruct Salad&lt;V: Vegetable&gt; {\n    veggies: Vec&lt;V&gt;\n}</code></pre>\n<p>然而，这是一种相当严格的设计：每一样沙拉都要完全由一种蔬菜组成。但毕竟众口难调。本书的一位作者就曾花 14 美元买过一份 <code>Salad&lt;IcebergLettuce&gt;</code>（球形生菜沙拉），那味道真是让人终生难忘。</p>\n<p>怎样才能做出更好的沙拉呢？由于 <code>Vegetable</code> 的值可以有各种不同的大小，因此不能要求 Rust 接受 <code>Vec&lt;dyn Vegetable&gt;</code> 这种写法：</p>\n<pre class=\"code-rows\"><code>struct Salad {\n    veggies: Vec&lt;dyn Vegetable&gt;  // 错误：`dyn Vegetable`的大小不是常量\n}</code></pre>\n<p>解决方案是使用特型对象：</p>\n<pre class=\"code-rows\"><code>struct Salad {\n    veggies: Vec&lt;Box&lt;dyn Vegetable&gt;&gt;\n}</code></pre>\n<p>每个 <code>Box&lt;dyn Vegetable&gt;</code> 都可以拥有任意类型的蔬菜，但 <code>Box</code> 本身具有适合存储在向量中的常量大小（两个指针）。虽然把盒子（<code>Box</code>）放进某个食物里这种隐喻怪怪的，但这正是我们想要的，这种方式同样适用于绘图应用程序中的形状、游戏中的怪物、网络路由器中的可插接路由算法等。</p>\n<p>使用特型对象的另一个原因可能是想减少编译后代码的总大小。Rust 可能会不得不多次编译泛型函数，针对用到了它的每种类型各编译一次。而这可能会使二进制文件变大，这种现象在 C++ 圈子里叫作<strong>代码膨胀</strong>。如今，内存资源充裕，大多数人可以不在乎代码大小，但确实仍然存在着某种受限环境。</p>\n<p>除了像制作沙拉这种问题或是低资源环境之类的情况，与特型对象相比，泛型具有 3 个重要优势，因此在 Rust 中，泛型是更常见的选择。</p>\n<p>第一个优势是速度。请注意泛型函数签名中缺少 <code>dyn</code> 关键字。因为你要在编译期指定类型，所以无论是显式写出还是通过类型推断，编译器都知道要调用哪个 <code>write</code> 方法。没有使用 <code>dyn</code> 关键字是因为这里不涉及特型对象（因此也不涉及动态派发）。</p>\n<p>本章开头展示过的泛型函数 <code>min()</code> 运行起来与我们编写的单独的函数 <code>min_u8</code>、<code>min_i64</code>、<code>min_string</code> 等一样快。编译器可以像任何函数一样将其内联，因此在发布构建中，调用 <code>min::&lt;i32&gt;</code> 可能只有两三条指令。参数是常数的调用（如 <code>min(5, 3)</code>）会更快：Rust 可以在编译期对其求值，因此根本没有运行期开销。</p>\n<p>或者考虑这个泛型函数调用：</p>\n<pre class=\"code-rows\"><code>let mut sink = std::io::sink();\nsay_hello(&amp;mut sink)?;</code></pre>\n<p><code>std::io::sink()</code> 会返回类型为 <code>Sink</code> 的写入器，该写入器会悄悄地丢弃写入其中的所有字节。</p>\n<p>当 Rust 为此生成机器码时，它可以生成调用 <code>Sink::write_all</code> 的代码，检查错误，然后调用 <code>Sink::flush</code>。这就是泛型函数体所要求做的。</p>\n<p>Rust 还可以查看这些方法并注意到：</p>\n<ul>\n<li><code>Sink::write_all()</code> 什么都不做；</li>\n<li><code>Sink::flush()</code> 什么都不做；</li>\n<li>这两种方法都不会返回错误。</li>\n</ul>\n<p>简而言之，Rust 拥有完全优化此函数调用所需的全部信息。</p>\n<p>这与特型对象的行为不同。在那种方式下，Rust 直到运行期才能知道特型对象指向什么类型的值。因此，即使你传递了 <code>Sink</code>，调用虚方法和检查错误的开销仍然存在。</p>\n<p>泛型的第二个优势在于并不是每个特型都能支持特型对象。特型支持的几个特性（如关联函数）只适用于泛型：它们完全不支持特型对象。我们会在谈及这些特性时指出这一点。</p>\n<p>泛型的第三个优势是它很容易同时指定具有多个特型的泛型参数限界，就像我们的 <code>top_ten</code> 函数要求它的 <code>T</code> 参数必须实现 <code>Debug + Hash + Eq</code> 那样。特型对象不能这样做：Rust 不支持像 <code>&amp;mut (dyn Debug + Hash + Eq)</code> 这样的类型。（你可以使用本章稍后定义的子特型来解决这个问题，但有点儿复杂。）</p>\n<h2 id=\"nav_point_188\">11.2　定义与实现特型</h2>\n<p>定义特型很简单，给它一个名字并列出特型方法的类型签名即可。如果你正在编写游戏，那么可能会有这样的特型：</p>\n<pre class=\"code-rows\"><code>/// 角色、道具和风景的特型——游戏世界中可在屏幕上看见的任何东西\ntrait Visible {\n    /// 在给定的画布上渲染此对象\n    fn draw(&amp;self, canvas: &amp;mut Canvas);\n\n    /// 如果单击(x, y)时应该选中此对象，就返回true\n    fn hit_test(&amp;self, x: i32, y: i32) -&gt; bool;\n}</code></pre>\n<p>要实现特型，请使用语法 <code>impl <i>TraitName</i> for <i>Type</i></code>：</p>\n<pre class=\"code-rows\"><code>impl Visible for Broom {\n    fn draw(&amp;self, canvas: &amp;mut Canvas) {\n        for y in self.y - self.height - 1 .. self.y {\n            canvas.write_at(self.x, y, '|');\n        }\n        canvas.write_at(self.x, self.y, 'M');\n    }\n\n    fn hit_test(&amp;self, x: i32, y: i32) -&gt; bool {\n        self.x == x\n        &amp;&amp; self.y - self.height - 1 &lt;= y\n        &amp;&amp; y &lt;= self.y\n    }\n}</code></pre>\n<p>请注意，这个 <code>impl</code> 包含 <code>Visible</code> 特型中每个方法的实现，再无其他。特型的 <code>impl</code> 代码中定义的一切都必须是真正属于此特型的，如果想添加一个辅助方法来支持 <code>Broom::draw()</code>，就必须在单独的 <code>impl</code> 块中定义它：</p>\n<pre class=\"code-rows\"><code>impl Broom {\n    /// 供下面的Broom::draw()使用的辅助函数\n    fn broomstick_range(&amp;self) -&gt; Range&lt;i32&gt; {\n        self.y - self.height - 1 .. self.y\n    }\n}</code></pre>\n<p>这些辅助函数可以在特型的各个 <code>impl</code> 块中使用。</p>\n<pre class=\"code-rows\"><code>impl Visible for Broom {\n    fn draw(&amp;self, canvas: &amp;mut Canvas) {\n        for y in self.broomstick_range() {\n            ...\n        }\n        ...\n    }\n    ...\n}</code></pre>\n<h3 id=\"nav_point_189\">11.2.1　默认方法</h3>\n<p>我们之前讨论的 <code>Sink</code> 写入器类型可以用几行代码来实现。首先，定义如下类型：</p>\n<pre class=\"code-rows\"><code>/// 一个会忽略你写入的任何数据的写入器\npub struct Sink;</code></pre>\n<p><code>Sink</code> 是一个空结构体，因为我们不需要在其中存储任何数据。接下来，为 <code>Sink</code> 提供 <code>Write</code> 特型的实现：</p>\n<pre class=\"code-rows\"><code>use std::io::;\n\nimpl Write for Sink {\n    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt; {\n        // 声称已成功写入了整个缓冲区\n        Ok(buf.len())\n    }\n\n    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {\n        Ok(())\n    }\n}</code></pre>\n<p>迄今为止，这种写法和 <code>Visible</code> 特型非常相似。但我们看到 <code>Write</code> 特型中还有一个 <code>write_all</code> 方法：</p>\n<pre class=\"code-rows\"><code>let mut out = Sink;\nout.write_all(b\"hello world\\n\")?;</code></pre>\n<p>为什么 Rust 允许在未定义此方法的情况下 <code>impl Write for Sink</code> 呢？答案是标准库的 <code>Write</code> 特型定义中包含了对 <code>write_all</code> 的<strong>默认实现</strong>：</p>\n<pre class=\"code-rows\"><code>trait Write {\n    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;\n    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;\n\n    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt; {\n        let mut bytes_written = 0;\n        while bytes_written &lt; buf.len() {\n            bytes_written += self.write(&amp;buf[bytes_written..])?;\n        }\n        Ok(())\n    }\n\n    ...\n}</code></pre>\n<p><code>write</code> 方法和 <code>flush</code> 方法是每个写入器必须实现的基本方法。写入器也可以自行实现 <code>write_all</code>，但如果没实现，就会使用前面展示过的默认实现。</p>\n<p>你的自定义特型也可以包含一些使用同样语法的默认实现。</p>\n<p>标准库中对默认方法最引人注目的应用场景是 <code>Iterator</code> 特型，它有一个必要方法 (<code>.next()</code>) 和几十个默认方法。第 15 章会解释原因。</p>\n<h3 id=\"nav_point_190\">11.2.2　特型与其他人的类型</h3>\n<p>Rust 允许在任意类型上实现任意特型，但特型或类型二者必须至少有一个是在当前 crate 中新建的。</p>\n<p>这意味着任何时候如果你想为任意类型添加一个方法，都可以使用特型来完成：</p>\n<pre class=\"code-rows\"><code>trait IsEmoji {\n    fn is_emoji(&amp;self) -&gt; bool;\n}\n\n/// 为内置的字符类型实现IsEmoji特型\nimpl IsEmoji for char {\n    fn is_emoji(&amp;self) -&gt; bool {\n        ...\n    }\n}\n\nassert_eq!('$'.is_emoji(), false);</code></pre>\n<p>与任何其他特型方法一样，只有当 <code>IsEmoji</code> 在作用域内时这个新的 <code>is_emoji</code> 方法才是可见的。</p>\n<p>这个特殊特型的唯一目的是向现有类型 <code>char</code> 中添加一个方法。这称为<strong>扩展特型</strong>。当然，也可以通过 <code>impl IsEmoji for str { ... }</code> 等写法将此特型添加到其他类型中。</p>\n<p>甚至可以使用一个泛型的 <code>impl</code> 块来一次性向整个类型家族添加扩展特型。这个特型可以在任意类型上实现：</p>\n<pre class=\"code-rows\"><code>use std::io::;\n\n/// 能让你把HTML写入值里的特型\ntrait WriteHtml {\n    fn write_html(&amp;mut self, html: &amp;HtmlDocument) -&gt; io::Result&lt;()&gt;;\n}</code></pre>\n<p>为所有写入器实现特型会令其成为扩展特型，比如为所有 Rust 写入器添加一个方法：</p>\n<pre class=\"code-rows\"><code>/// 可以把HTML写入任何一个std::io writer\nimpl&lt;W: Write&gt; WriteHtml for W {\n    fn write_html(&amp;mut self, html: &amp;HtmlDocument) -&gt; io::Result&lt;()&gt; {\n        ...\n    }\n}</code></pre>\n<p><code>impl&lt;W: Write&gt; WriteHtml for W</code> 这一行的意思是“对于每个实现了 <code>Write</code> 的类型 <code>W</code>，这里有一个适用于 <code>W</code> 的 <code>WriteHtml</code> 实现”。</p>\n<p><code>serde</code> 库提供了一个很好的例子，表明在标准类型上实现用户定义的特型非常有用。<code>serde</code> 是一个序列化库。也就是说，你可以使用 <code>serde</code> 将 Rust 数据结构写入磁盘，稍后再重新加载它们。这个库定义了一个特型 <code>Serialize</code>，它为该库支持的每种数据类型都提供了实现。因此在 <code>serde</code> 源代码中，有一些代码为 <code>bool</code>、<code>i8</code>、<code>i16</code>、<code>i32</code>、数组类型和元组类型等内置类型，以及像 <code>Vec</code> 和 <code>HashMap</code> 这样的标准数据结构实现了 <code>Serialize</code>。</p>\n<p>所有这些工作的成果，就是 <code>serde</code> 为这些类型添加了一个 <code>.serialize()</code> 方法。它可以这样使用：</p>\n<pre class=\"code-rows\"><code>use serde::Serialize;\nuse serde_json;\n\npub fn save_configuration(config: &amp;HashMap&lt;String, String&gt;)\n    -&gt; std::io::Result&lt;()&gt;\n{\n    // 创建一个JSON序列化器以把数据写入文件\n    let writer = File::create(config_filename())?;\n    let mut serializer = serde_json::Serializer::new(writer);\n\n    // serde的`.serialize()`方法会完成剩下的工作\n    config.serialize(&amp;mut serializer)?;\n    Ok(())\n}</code></pre>\n<p>我们之前说过，在实现特型时，特型或类型二者必须至少有一个是在当前 crate 中新建的。这叫作<strong>孤儿规则</strong>。它会帮助 Rust 确保特型的实现是唯一的。你的代码不能写成 <code>impl Write for u8</code>，因为 <code>Write</code> 和 <code>u8</code> 都是在标准库中定义的。如果 Rust 允许 crate 这样做，那么在不同的 crate 中可能会有多个 <code>u8</code> 的 <code>Write</code> 实现，而 Rust 并没有合理的方法来决定把哪个实现用于给定的方法调用。</p>\n<p>（C++ 有一个类似的唯一性限制：单一定义规则。在典型的 C++ 流派中，除了一些最简单的情况，编译器不会强制执行此规则。如果你打破了此规则，就会得到未定义行为。）</p>\n<h3 id=\"nav_point_191\">11.2.3　特型中的 <code>Self</code></h3>\n<p>特型可以用关键字 <code>Self</code> 作为类型。例如，标准库的 <code>Clone</code> 特型看起来是这样的（稍作简化）：</p>\n<pre class=\"code-rows\"><code>pub trait Clone {\n    fn clone(&amp;self) -&gt; Self;\n    ...\n}</code></pre>\n<p>这里以 <code>Self</code> 作为返回类型意味着 <code>x.clone()</code> 的类型与 <code>x</code> 的类型相同，无论 <code>x</code> 是什么。如果 <code>x</code> 是 <code>String</code>，那么 <code>x.clone()</code> 的类型也必须是 <code>String</code>——而不能是 <code>dyn Clone</code> 或其他可克隆类型。</p>\n<p>同样，如果我们定义如下特型</p>\n<pre class=\"code-rows\"><code>pub trait Spliceable {\n    fn splice(&amp;self, other: &amp;Self) -&gt; Self;\n}</code></pre>\n<p>并有两个实现：</p>\n<pre class=\"code-rows\"><code>impl Spliceable for CherryTree {\n    fn splice(&amp;self, other: &amp;Self) -&gt; Self {\n        ...\n    }\n}\n\nimpl Spliceable for Mammoth {\n    fn splice(&amp;self, other: &amp;Self) -&gt; Self {\n        ...\n    }\n}</code></pre>\n<p>那么在第一个 <code>impl</code> 中，<code>Self</code> 只是 <code>CherryTree</code> 的别名，而在第二个 <code>impl</code> 中，它是 <code>Mammoth</code> 的别名。这意味着可以将两棵樱桃树或两头猛犸象拼接在一起，但不表示可以创造出猛犸象和樱桃树的混合体。<code>self</code> 的类型和 <code>other</code> 的类型必须匹配。</p>\n<p>使用了 <code>Self</code> 类型的特型与特型对象不兼容：</p>\n<pre class=\"code-rows\"><code>// 错误：特型`Spliceable`不能用作特型对象\nfn splice_anything(left: &amp;dyn Spliceable, right: &amp;dyn Spliceable) {\n    let combo = left.splice(right);\n    // ...\n}</code></pre>\n<p>至于其原因，当我们深入研究特型的高级特性时还会一次又一次看到。Rust 会拒绝此代码，因为它无法对 <code>left.splice(right)</code> 这个调用进行类型检查。特型对象的全部意义恰恰在于其类型要到运行期才能知道。Rust 在编译期无从了解 <code>left</code> 和 <code>right</code> 是否为同一类型。</p>\n<p>特型对象实际上是为最简单的特型类型而设计的，这些类型都可以使用 Java 中的接口或 C++ 中的抽象基类来实现。特型的高级特性很有用，但它们不能与特型对象共存，因为一旦有了特型对象，就会失去 Rust 对你的程序进行类型检查时所必需的类型信息。</p>\n<p>现在，如果想要实现这种在遗传意义上不可能的拼接，可以设计一个对特型对象友好的特型：</p>\n<pre class=\"code-rows\"><code>pub trait MegaSpliceable {\n    fn splice(&amp;self, other: &amp;dyn MegaSpliceable) -&gt; Box&lt;dyn MegaSpliceable&gt;;\n}</code></pre>\n<p>此特型与特型对象兼容。对 <code>.splice()</code> 方法的调用可以通过类型检查，因为参数 <code>other</code> 的类型不需要匹配 <code>self</code> 的类型，只要这两种类型都是 <code>MegaSpliceable</code> 就可以了。</p>\n<h3 id=\"nav_point_192\">11.2.4　子特型</h3>\n<p>我们可以声明一个特型是另一个特型的扩展：</p>\n<pre class=\"code-rows\"><code>/// 游戏世界中的生物，既可以是玩家，也可以是\n/// 其他小精灵、石像鬼、松鼠、食人魔等\ntrait Creature: Visible {\n    fn position(&amp;self) -&gt; (i32, i32);\n    fn facing(&amp;self) -&gt; Direction;\n    ...\n}</code></pre>\n<p>短语 <code>trait Creature : Visible</code> 表示所有生物都是可见的。每个实现了 <code>Creature</code> 的类型也必须实现 <code>Visible</code> 特型：</p>\n<pre class=\"code-rows\"><code>impl Visible for Broom {\n    ...\n}\n\nimpl Creature for Broom {\n    ...\n}</code></pre>\n<p>可以按任意顺序实现这两个特型，但是如果不为类型实现 <code>Visible</code> 只为其实现 <code>Creature</code> 则是错误的。在这里，我们说 <code>Creature</code> 是 <code>Visible</code> 的<strong>子特型</strong>，而 <code>Visible</code> 是 <code>Creature</code> 的<strong>超特型</strong>。</p>\n<p>子特型与 Java 或 C# 中的子接口类似，因为用户可以假设实现了子特型的任何值也会实现其超特型。但是在 Rust 中，子特型不会继承其超特型的关联项，如果你想调用超特型的方法，那么仍然要保证每个特型都在作用域内。</p>\n<p>事实上，Rust 的子特型只是对 <code>Self</code> 类型限界的简写。像下面这样的 <code>Creature</code> 定义与前面的定义完全等效。</p>\n<pre class=\"code-rows\"><code>trait Creature where Self: Visible {\n    ...\n}</code></pre>\n<h3 id=\"nav_point_193\">11.2.5　类型关联函数</h3>\n<p>在大多数面向对象语言中，接口不能包含静态方法或构造函数，但特型可以包含类型关联函数，这是 Rust 对静态方法的模拟：</p>\n<pre class=\"code-rows\"><code>trait StringSet {\n    /// 返回一个新建的空集合\n    fn new() -&gt; Self;\n\n    /// 返回一个包含`strings`中所有字符串的集合\n    fn from_slice(strings: &amp;[&amp;str]) -&gt; Self;\n\n    /// 判断这个集合中是否包含特定的`string`\n    fn contains(&amp;self, string: &amp;str) -&gt; bool;\n\n    /// 把一个字符串添加到此集合中\n    fn add(&amp;mut self, string: &amp;str);\n}</code></pre>\n<p>每个实现了 <code>StringSet</code> 特型的类型都必须实现这 4 个关联函数。前两个函数，即 <code>new()</code> 和 <code>from_slice()</code>，不接受 <code>self</code> 参数。它们扮演着构造函数的角色。在非泛型代码中，可以使用 <code>::</code> 语法调用这些函数，就像调用任何其他类型关联函数一样：</p>\n<pre class=\"code-rows\"><code>// 创建实现了StringSet的两个假想集合类型：\nlet set1 = SortedStringSet::new();\nlet set2 = HashedStringSet::new();</code></pre>\n<p>在泛型代码中，也可以使用 <code>::</code> 语法，不过其类型部分通常是类型变量，如下面对 <code>S::new()</code> 的调用所示：</p>\n<pre class=\"code-rows\"><code>/// 返回`document`中不存在于`wordlist`中的单词集合\nfn unknown_words&lt;S: StringSet&gt;(document: &amp;[String], wordlist: &amp;S) -&gt; S {\n    let mut unknowns = S::new();\n    for word in document {\n        if !wordlist.contains(word) {\n            unknowns.add(word);\n        }\n    }\n    unknowns\n}</code></pre>\n<p>与 Java 接口和 C# 接口一样，特型对象也不支持类型关联函数。如果想使用 <code>&amp;dyn StringSet</code> 特型对象，就必须修改此特型，为每个未通过引用接受 <code>self</code> 参数的关联函数加上类型限界 <code>where Self: Sized</code>：</p>\n<pre class=\"code-rows\"><code>trait StringSet {\n    fn new() -&gt; Self\n        where Self: Sized;\n\n    fn from_slice(strings: &amp;[&amp;str]) -&gt; Self\n        where Self: Sized;\n\n    fn contains(&amp;self, string: &amp;str) -&gt; bool;\n\n    fn add(&amp;mut self, string: &amp;str);\n}</code></pre>\n<p>这个限界告诉 Rust，特型对象不需要支持特定的关联函数<span class=\"comment-number\">1</span>。通过添加这些限界，就能把 <code>StringSet</code> 作为特型对象使用了。虽然特型对象仍不支持关联函数 <code>new</code> 或 <code>from_slice</code>，但你还是可以创建它们并用其调用 <code>.contains()</code> 和 <code>.add()</code>。同样的技巧也适用于其他与特型对象不兼容的方法。（我们暂且放弃对“为何这么改就行”的枯燥技术解释，但会在第 13 章介绍一下 <code>Sized</code> 特型，届时你就懂了。）</p>\n\n<h2 id=\"nav_point_194\">11.3　完全限定的方法调用</h2>\n<p>迄今为止，我们看到的所有调用特型方法的方式都依赖于 Rust 为你补齐了一些缺失的部分。假设你编写了以下内容：</p>\n<pre class=\"code-rows\"><code>\"hello\".to_string()</code></pre>\n<p>Rust 知道 <code>to_string</code> 指的是 <code>ToString</code> 特型的 <code>to_string</code> 方法（我们称之为 <code>str</code> 类型的实现）。所以这个游戏里有 4 个“玩家”：特型、特型的方法、方法的实现以及调用该实现时传入的值。很高兴我们不必在每次调用方法时都把它们完全写出来。但在某些情况下，你需要一种方式来准确表达你的意思。完全限定的方法调用符合此要求。</p>\n<p>首先，要知道方法只是一种特殊的函数。下面两个调用是等效的：</p>\n<pre class=\"code-rows\"><code>\"hello\".to_string()\n\nstr::to_string(\"hello\")</code></pre>\n<p>第二种形式看起来很像关联函数调用。尽管 <code>to_string</code> 方法需要一个 <code>self</code> 参数，但是仍然可以像关联函数一样调用。只需将 <code>self</code> 作为此函数的第一个参数传进去即可。</p>\n<p>由于 <code>to_string</code> 是标准 <code>ToString</code> 特型的方法之一，因此你还可以使用另外两种形式：</p>\n<pre class=\"code-rows\"><code>ToString::to_string(\"hello\")\n\n&lt;str as ToString&gt;::to_string(\"hello\")</code></pre>\n<p>所有这 4 种方法调用都会做同样的事情。大多数情况下，只要写 <code>value.method()</code> 就可以了。其他形式都是<strong>限定</strong>方法调用。它们要指定方法所关联的类型或特型。最后一种带有尖括号的形式，同时指定了两者，这就是<strong>完全限定</strong>的方法调用。</p>\n<p>当你写下 <code>\"hello\".to_string()</code> 时，使用的是 <code>.</code> 运算符，你并没有确切说明要调用哪个 <code>to_string</code> 方法。Rust 有一个“方法查找”算法，它可以根据类型、隐式解引用等来解决这个问题。通过完全限定的调用，你可以准确地指出是哪一个方法，这在一些奇怪的情况下会有所帮助。</p>\n<ul>\n<li><p>当两个方法具有相同的名称时。生拼硬凑的经典示例是 <code>Outlaw</code>（亡命之徒），它具有来自不同特型的两个 <code>.draw()</code> 方法，一个用于将其绘制在屏幕上，另一个用于犯罪。</p>\n<pre class=\"code-rows\"><code>outlaw.draw();  // 错误：画（draw）在屏幕上还是拔出（draw）手枪？\n\nVisible::draw(&amp;outlaw);  // 正确：画在屏幕上\nHasPistol::draw(&amp;outlaw);  // 正确：拔出手枪</code></pre>\n<p>通常你可以对其中一个方法改名，但有时实在没法改。</p>\n<p>&nbsp;</p>\n</li>\n<li><p>当无法推断 <code>self</code> 参数的类型时。</p>\n<pre class=\"code-rows\"><code>let zero = 0;  // 类型未指定：可能为`i8`、`u8`……\n\nzero.abs();  // 错误：无法在有歧义的数值类型上调用方法`abs`\n\ni64::abs(zero);  // 正确</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p>将函数本身用作函数类型的值时。</p>\n<pre class=\"code-rows\"><code>let words: Vec&lt;String&gt; =\n    line.split_whitespace()  // 迭代器生成&amp;str值\n        .map(ToString::to_string)  // 正确\n        .collect();</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p>在宏中调用特型方法时。第 21 章会对此进行解释。</p>\n</li>\n</ul>\n<p>完全限定语法也适用于关联函数。在 11.2.5 节中，我们编写了 <code>S::new()</code> 以在泛型函数中创建一个新集合。也可以写成 <code>StringSet::new()</code> 或 <code>&lt;S as StringSet&gt;::new()</code>。</p>\n","neighbors":{"left":{"article_title":"第 10 章 枚举与模式","id":740810},"right":{"article_title":"第 11 章 特型与泛型(2)","id":740812}},"comments":[]}