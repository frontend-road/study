{"id":201304,"title":"16 | 数据结构（上）：突破基本类型的限制，存储更大的整数","content":"<p>你好，我是胡光，咱们又见面了。</p><p>上两节呢，我们讲了素数筛这个算法，并且用素数筛算法演示了程序设计过程中的框架思维。其中提到了欧拉筛法，不知道勤奋的你有没有课后自己去学习一下呢？如果你学习了欧拉筛法以后，你会对我所说的框架思维有更深刻的体会。</p><p>在之前的文章中，我们介绍过算法和数据结构的作用。当时我讲到，算法的作用是做数据的计算，并且它对于编程的重要意义，不止是停留在那些叫得上来名字的具体算法上面，而是我们称之的算法思维。</p><p>算法思维的具体表现，就是我们处理得到相同信息时，所采用的不同的流程方法。这些方法呢，有好坏高低的比较，而评价的标准，主要就是<strong>从时空复杂度方面来考量</strong>。由于本专栏主要是教会你掌握编程思维，所以，即使你对时空复杂度不是很了解，也不用担心它会影响你的入门编程学习。你只需要知道，这是我们衡量算法好坏的重要指标即可。</p><p>前两篇文章呢，其实更多的就是给大家展示算法思维对于程序设计的重要性，并且，我还要在这里提醒一句，算法的底层是数学，适当的补充数学基础，对于算法的学习是有奇效的。</p><p>数据结构和算法，前者负责“表示数据”，后者负责“处理数据”。接下来，我将给你讲讲数据结构的重要性。</p><h2>今日任务</h2><p>表示数据到底是什么呢？为什么表示数据很重要？通过今天的 10 分钟任务，你就能明白其中的重要意义。这个任务很简单，就是请你实现一个程序，输出 2 的 1000 次方的结果是多少。</p><!-- [[[read_end]]] --><p>关于这个问题，你可能会意识到，C 语言中给我们提供的 int 类型，肯定是无法完成这个任务的，因为它表示不了这么大的数字。你可能想用 long long 类型来进行解决，那你这就要犯低级错误了。long long 是 64 位整型，也就是占 64 个 2 进制位，它顶多能表示 2 的 64 次方减 1 的结果，相对于 2 的 1000 次方来说，小太多了。</p><p>你可能又想到，既然 long long 表示不了，那就使用 double，不是说 double 是浮点数类型，可以表示很大很大的数字么？对，double 作为双精度浮点型，确实可以表示很大很大的数字，2 的 1000 次方这个数字，对于 double 的表示范围来说，也是不足挂齿的。</p><p>可这里面存在一个严重的问题，就是 double 是有精度损失的。什么意思呢？请耐心听我给你解释。</p><p>其实也很好理解，不管是long long 类型，还是double 类型，它们都是 64 位的信息，也就是说，它们都可以准确表示2的64次方个数量的数字。但是，即使 double 类型表示数字的范围比 long long 要大很多，可这个当中很多数字 double 是没有办法准确表示的。</p><p>至于 double 的表示精度，一般来说是有效数字 15 位，就是一个数字，由左向右，从第一个不为零的数字起，向后15位都是准确的。因此 double 类型实际上也没有办法，准确表示 2 的 1000 次方的计算结果。</p><p>那究竟应该如何来解决今天这个问题呢？带着这个疑问，让我们正式开始今天的释疑之行吧。</p><h2>必知必会，查缺补漏</h2><p>前面讲了这么多，我就是想让你明确一点，就是在我们所认识的 C 语言中，是没有任何一种数据类型，可以表示得下我们今天想要计算 2 的 1000 次方的结果。也就是说，基础类型表示不了我们今天所要计算的这个结果，那该怎么办呢？</p><p>还记得我讲过的关于结构体的相关知识么？当时我们使用结构体，创造了一个新的代表坐标点的数据类型。按照创造类型的思路去思考现在这个问题，也就是，如果我们能采用一种能够表示更大范围的整数的数字表示法，那今天这个问题，就可以解决了。这就是我们今天要学习的内容，它的大类名字叫做<strong>高精度表示法</strong>，更具体的叫做<strong>大整数表示法</strong>。</p><h4>1.大整数表示法</h4><p>为了完成今天这个任务，我们需要从数据的表示上下功夫。其实，数据的表示绝不是只有一种方法，就好像你想表达数字 1 的一半，你既可以用0.5来表示，也可以用1/2来表示。所以，今天我们想要表示很大很大的整数，其实也有很多方法，下面就看看我要给你介绍的方法吧。</p><p>首先我们先来思考一个事情，如果我想要存储一个 100 位的十进制数字，为什么现有的 int 数据类型做不到？本质上是因为这个数字的位数，超过了 int 能够表示数字的位数上限。int 能够表示的数字大小的上限，是一个以 2 开头的 10 位数字，而我们想要存储的，却是一个 100 位的数字。</p><p>看到了这个本质问题后，其实也就找到了解决问题的方向，那就是我们要创造的这种数字的表示方法，能够有足够的空间去容纳更多位数的数字。提起空间，你想到了什么？是不是我们之前讲到的数组？也就是说，我们开辟一个整型数组空间，让这个数组的每个位置存储一位数字，这样是不是就可以很轻松地存储 100 位数字了。</p><p>下面就来看看这种大整数表示法，是如何存储数字 3526 的吧：<br>\n<img src=\"https://static001.geekbang.org/resource/image/bf/6d/bf84afda4623d6e9471be24b6325896d.jpg?wh=2249*703\" alt=\"\" title=\"图1：大整数表示示意图\"></p><p>正如你所看到的，这种表示法中，使用数组的第0位存储数字的位数，因为 3526 有 4 位，所以数组的第 0 位就设置成了 4 这个值。接下来，数组从第 1 位到第 4 位记录的就是原数字 3526，可是你有没有发现，这个数字是好像是倒着放置的，数字的最高位，也放在数组的最高位中，在图上看着感觉怪怪的。</p><p>你可能会觉得别扭，可我要告诉你，这种存储方式不是无缘无故的，而是凝结了前人的智慧。最直接的一个好处，就是当你拿着两个这样的大整数做加法，产生一个新的大整数的时候，这个新产生的大整数会涉及到进位问题。</p><p>例如：95 + 12 = 107，两个两位的大整数相加，产生一个三位的大整数。在这种从右到左的倒着存储表示法中，是向着数组高位去进位，去扩充位数，这是便利可行的。可你要是从左到右去正着存储，你会发现一旦最高位产生进位，就很难处理。</p><h4>2.如何计算大整数加法</h4><p>你可能还是不太理解，这种大整数表示法的好处，下面我们就拿“大整数加法”来举个例子。顺便也向你展示一下，我们究竟是如何操作这种大整数。</p><p>大整数加法，顾名思义就是利用大整数表式法，做加法运算。具体怎么做，你应该还记得小学时候，老师教给我们的加法竖式吧？其实大整数加法，本质上就是参考这种竖式计算法，把每一位对齐，然后按位相加，加完以后再统一处理进位。下面，我用一张图说明大整数加法，是如何计算 445 + 9667 的：<br>\n<img src=\"https://static001.geekbang.org/resource/image/6a/44/6a054bbbc6cca21bfc20034f0466aa44.jpg?wh=2593*1522\" alt=\"\" title=\"图2：大整数加法示意图\"></p><p>正如你所看到的，首先我们用大整数表示法，分别表示 445 和 9667 这两个数字；然后以位数最长的那个大整数，作为计算结果大整数的基础位数，445和9667按位相加，得到一个 4 位的结果大整数，4 位分别是，9、10、10、12；最后我们再依次处理进位，就得到了底下那一行的结果：10112。</p><p>在这个过程中，你会看到最高位的 9 产生了进位，最终变成了一个 5 位的大整数，产生的新最高位，我们只需要继续向后放即可。这就是我刚刚所说的，这种大整数表示法，能够非常方便地处理进位。</p><p>看完了大整数加法的过程后，不可缺少的，就是代码的实现过程。下面我给你准备了一份代码，代码中有相关注释，这是需要你自己拿出时间，来进行自学的内容。</p><pre><code>// 定义一个交换两个变量值的宏 swap\n#define swap(a, b) { \\\n    __typeof(a) _t = a; \\\n    a = b, b = _t; \\\n}\n// 实现大整数加法 a + b 的结果，存放在 c 中\nvoid plus_big_integer(int *a, int *b, int *c) {\n    // 让 a 指向位数较长的那个数字\n    if (a[0] &lt; b[0]) swap(a, b);\n    // 大整数 c 的位数以 a 的位数为基准\n    c[0] = a[0];\n    // 循环模拟按位做加法\n    for (int i = 1; i &lt;= a[0]; i++) {\n        if (i &lt;= b[0]) c[i] = a[i] + b[i];      \n        else c[i] = a[i];\n    }\n    // 处理每一位的进位过程\n    for (int i = 1; i &lt;= c[0]; i++) {\n        if (c[i] &lt; 10) continue;\n        // 判断是不是最高位产生了进位\n        // 如果是最高位产生进位，就进行初始化\n        if (i == c[0]) c[++c[0]] = 0;\n        c[i + 1] += c[i] / 10;\n        c[i] %= 10;\n    }\n    return ;\n}\n</code></pre><h2>一起动手，搞事情</h2><p>今天给你留的作业题，和我给你准备的那个大整数加法的代码有关。就是请你完成一个，能够实现读入两个大整数，并且输出两个大整数相加之和的程序。关于这个程序作业，你不需要考虑负数的情况，我们假设所有数字均是正整数。</p><p>这里给你个提示：在读入两个大整数的时候，你可以按照两个字符串数据进行读入，然后再把字符串数据，转换成我们上面所说的大整数表示法，最后调用上面那个大整数加法的过程。程序的关键提示已经告诉你了，剩下的部分，试试自己完成吧，加油！</p><h2>突破类型，求解 ${2}^{1000}$ 的值</h2><p>最后，我们回到今天的任务。</p><p>要计算 2 的 1000次方的结果，就是要计算 1000次乘法，最终的结果由于数值太大，我们肯定要使用大整数表示法了。也就是说，我们要在大整数表示法的基础上，操作 1000 次乘法，每次都是乘以 2，那么怎么做大整数乘法呢？</p><p>要想理解这个计算过程，我们还是得回到大整数表示法本身，所对应的数学模型理解上，具体请看下图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/34/f4/34f31f36797356b51ce1205c4e45fef4.jpg?wh=2256*858\" alt=\"\" title=\"图3：大整数表示法的数学理解\"></p><p>如图所示，我们把大整数表示法中，每一个数字所对应的位权写出来，那么数组中所存储 3、5、2、6 的大整数信息，其实等价于下面的那一行数学公式，即$3 * 10^{3}+5 * 10^{2}+2 * 10^{1}+6 * 10^{0}$。</p><p>我们对3526这个大整数乘以 2，其实等价于对下面那个数学式子乘以 2，就可以得到如下结果：<br>\n<img src=\"https://static001.geekbang.org/resource/image/1e/df/1eea8ccb5a20819051d9b71e415ed7df.jpg?wh=2264*1176\" alt=\"\" title=\"图4：大整数乘法的理解\"></p><p>你会看到，对某个大整数乘 2 的操作，其实，可以看成是对这个大整数的每一位分别乘以 2 的操作，然后再仿照大整数加法的过程，依次处理进位即可。</p><p>最后，关于如何完成今天的任务，我给你一个参考程序。当然你也可以选择不看参考程序，自己实现这个过程。</p><pre><code>#include &lt;stdio.h&gt;\n\n// 将 num 数组初始化成大整数表示的 1\n// 作用就是做累乘变量\nint num[400] = {1, 1}; \n\nint main() {\n    // 计算 100 次 2 的 10 次方相乘的结果\n    for (int i = 0; i &lt; 100; i++) {\n        // 对大整数的每一位乘以 2 的 10 次方\n        for (int j = 1; j &lt;= num[0]; j++) num[j] *= 1024;      \n        // 处理进位\n        for (int j = 1; j &lt;= num[0]; j++) {\n            if (num[j] &lt; 10) continue;          \n            if (j == num[0]) num[++num[0]] = 0;\n            num[j + 1] += num[j] / 10;\n            num[j] %= 10;\n        }\n    }\n    // 输出大整数\n    // 由于大整数是倒着存的，所以输出的时候倒着遍历\n    for (int i = num[0]; i &gt;= 1; --i) printf(&quot;%d&quot;, num[i]);\n    printf(&quot;\\n&quot;);\n    return 0;\n}\n</code></pre><h2>课程小结</h2><p>解决了这个任务后，恭喜你，又变强了一点点。今天我们学习了大整数的表示法，以及大整数加法和乘法的基本操作，我希望你记住以下几点：</p><ol>\n<li>在大整数的表示法中，数字是从右到左，倒着存放在数组中的。</li>\n<li>大整数的表示法，体现的是数据结构对于程序设计的作用。</li>\n<li>大整数的加法和乘法过程，体现的则是算法对于程序设计的作用。</li>\n</ol><p>同时，你还可以看到，我们在理解大整数乘法的过程中，是从数组的表示法与数学公式的等价性这个角度出发讨论的。其实我就是想再次跟你强调那句话，就是<strong>算法的底层是数学</strong>。</p><p>而通过今天的学习，想必你已经对“<strong>数据结构本质是用作数据的表示</strong>”这句话，已经有所感觉了。综合“<strong>算法是做数据的计算</strong>”这句话，说明算法和数据结构是程序中可以独立进行设计的两个部分，关于这点呢，将是下一节咱们讲解的重点。</p><p>好了，今天就到这里了，我是胡光，我们下期见。</p>","comments":[{"had_liked":false,"id":238793,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1596299603,"is_pvip":true,"replies":[{"id":"88426","content":"非常不错。关于函数内部开大数组溢出的问题，你可以查一下malloc 的用法，或者将大数组开成全局数组，也可以解决这个问题，或者在定义数组的时候，加一个 static 关键字，也成。","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1596524891,"ip_address":"","comment_id":238793,"utype":1}],"discussion_count":1,"race_medal":5,"score":"10186234195","product_id":100043901,"comment_content":"茶艺师学编程<br><br>利用老师留下的模块，我多跨了几步<br><br>1、课文2的1000次方程序的完全体，计算任何正整数的正整数幂。代码如下：<br><br>&#47;*大数幂*&#47; <br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>void print_Big(int x, int n){<br>\tint a[100000] = {1,1};<br>\tfor(int i = 1; i &lt;= n; i++){<br>\t\tfor(int j = 1; j &lt;= a[0]; j++)a[j] *= x;<br>\t\tfor(int j = 1; j &lt;= a[0]; j++){<br>\t\t\tif(a[j] &lt; 10)continue;<br>\t\t\tif(j == a[0])a[++a[0]] = 0;<br>\t\t\ta[j + 1] += a[j] &#47; 10;<br>\t\t\ta[j] %= 10;<br>\t\t}<br>\t}<br>\tfor(int i = a[0]; i &gt;= 1; --i)printf(&quot;%d&quot;, a[i]);<br>\tprintf(&quot;\\n&quot;);<br>}<br><br>int main(){<br>\tint x, n;<br>\tscanf(&quot;%d %d&quot;, &amp;x, &amp;n);<br>\tprint_Big(x, n);<br>\treturn 0;<br>}<br>其中数组a的位数不能再大了，不然就是内存溢出······<br><br>2、大数阶乘，就是计算输入的任意正整数的阶乘。代码如下：<br><br>&#47;*大数阶乘*&#47; <br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>void print_factorial(int n){&#47;&#47;阶乘的函数<br>\tif(n &lt; 0){<br>\t\tprintf(&quot;error\\n&quot;);&#47;&#47;检查机制<br>\t\treturn; <br>\t}<br>\telse if(n == 0){<br>\t\tprintf(&quot;1&quot; );<br>\t\treturn;<br>\t}<br>\tint a[100000] = {1,1};<br>\tfor(int i = 2; i &lt;= n; i++){<br>\t\tfor(int j = 1; j &lt;= a[0]; j++)a[j] *= i;&#47;&#47;乘积的值<br>\t\tfor(int j = 1; j &lt;= a[0]; j++){<br>\t\t\tif(a[j] &lt; 10)continue;<br>\t\t\tif( j == a[0])a[++a[0]] = 0;<br>\t\t\ta[j + 1] += a[j] &#47;10;<br>\t\t\ta[j] %= 10; <br>\t\t\t}<br>\t}<br>\tfor(int i = a[0]; i &gt;= 1; --i)printf(&quot;%d&quot;, a[i]);&#47;&#47;输出结果<br>}<br><br>int main(){<br>\tint n;<br>\tscanf(&quot;%d&quot;, &amp;n);&#47;&#47;输入几的阶乘<br>\tprint_factorial(n);<br>\treturn 0;<br>}","like_count":3,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502854,"discussion_content":"非常不错。关于函数内部开大数组溢出的问题，你可以查一下malloc 的用法，或者将大数组开成全局数组，也可以解决这个问题，或者在定义数组的时候，加一个 static 关键字，也成。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596524891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237240,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1595754304,"is_pvip":true,"replies":[{"id":"88430","content":"哈哈哈，看到你的进步，真的替你开心，加油！d(^_^o)","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1596525126,"ip_address":"","comment_id":237240,"utype":1}],"discussion_count":1,"race_medal":5,"score":"10185688896","product_id":100043901,"comment_content":"茶艺师学编程<br><br>1、课文的例子代码是在的太漂亮了<br><br>2、课文的“搞事情”，看似很简单，老师也十分亲切地给出了思路，其中的关键就是读入字符串数字，然后处理成整数数组······我找到的方法就是利用字符ACSII码性质来实现，说起来没什么，但就是整整耗了两个星期·······<br><br>3、无心插柳，我居然把老师的大数数组加法给模块化了。明明在第一次尝试改造时各种出错······<br><br>&#47;*交作业：*&#47;<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>void printBIG(char a[], char b[]){&#47;&#47;定义函数printBIG，实现输入两个“字符串”大数，相加，输出“数字”大数 <br>\tint c[1000] = {1,1};<br>\tint len_a, len_b;<br>\tlen_a = strlen(a) ;<br>\tlen_b = strlen(b) ;<br>\tc[0] = ((len_a &gt; len_b) ? len_a : len_b);<br>\tfor(int i = 1; i &lt;= c[0]; i++){&#47;&#47;从最小位开始相加，从左往右地放在数组C里 <br>\t\tc[i] = (a[len_a - i] - &#39;0&#39;) + (b[len_b - i] - &#39;0&#39;) ;&#47;&#47;这里字符数字换成数字数字的窍门是，字符0-9的ACSII码-48（字符0的ACSII码）=数字0-9 <br>\t}<br>\tfor(int i = 1; i &lt;= c[0]; i++){&#47;&#47;进位处理 <br>\t\tif(c[i] &lt; 10)continue;&#47;&#47; 每一位是否满10？ <br>\t\tif(i == c[0])c[++c[0]] = 0;&#47;&#47;是否要进位 <br>\t\tc[i + 1] += c[i] &#47; 10;&#47;&#47;满10进1 <br>\t\tc[i] %= 10;&#47;&#47;原位除10求余 <br>\t}<br>\tfor(int i = c[0]; i &gt;= 1; --i)printf(&quot;%d&quot;, c[i]);&#47;&#47;胡老师给的倒序输出语句太漂亮了，我直接拿来用了 <br>\tprintf(&quot;\\n&quot;);<br>} <br><br>int main(){<br>\tchar a[1000], b[1000];<br>\tscanf(&quot;%s %s&quot;, a, b);<br>\tprintBIG(a, b);<br>\treturn 0;<br>}","like_count":2,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502347,"discussion_content":"哈哈哈，看到你的进步，真的替你开心，加油！d(^_^o)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596525126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238196,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1596093178,"is_pvip":true,"replies":[{"id":"88428","content":"非常不错！d(^_^o)","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1596524992,"ip_address":"","comment_id":238196,"utype":1}],"discussion_count":1,"race_medal":5,"score":"5891060474","product_id":100043901,"comment_content":"茶艺师学编程<br><br>之前发的代码后来发现有BUG，只要两个数的位数不一致的时候就不能正常运算。<br>现在修整了该BUG。<br>其中思路是把两个数的位数情况都遍历：相同、第一个数比第二个数多、第一个数比第二个数少。<br>以下是修整后的代码：<br><br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>void printBIG(char a[], char b[]){&#47;&#47;定义函数printBIG，实现输入两个“字符串”大数，相加，输出“数字”大数 <br>\tint c[1000] = {1,1};<br>\tint len_a, len_b;<br>\tlen_a = strlen(a) ;<br>\tlen_b = strlen(b) ;<br>\tc[0] = ((len_a &gt; len_b) ? len_a : len_b);<br>\tfor(int i = 1; i &lt;= c[0]; i++){&#47;&#47;从最小位开始相加，从左往右地放在数组C里 <br>\t\tif((len_a - i) &gt;= 0 &amp;&amp; (len_b - i) &gt;= 0)&#47;&#47;位数相同的情况 <br>\t\t\tc[i] = (a[len_a - i] - &#39;0&#39;) + (b[len_b - i] - &#39;0&#39;) ;&#47;&#47;这里字符数字换成数字数字的窍门是，字符0-9的ACSII码-48（字符0的ACSII码）=数字0-9 <br>\t\telse if((len_a - i) &gt;= 0 &amp;&amp; (len_b - i) &lt; 0)&#47;&#47;数1的位数比数2大的情况<br>\t\t\tc[i] = (a[len_a - i] - &#39;0&#39;);<br>\t\telse if((len_a - i) &lt; 0 &amp;&amp; (len_b - i) &gt;= 0)&#47;&#47;数1的位数比数2小的情况<br>\t\t\tc[i] = (b[len_b - i] - &#39;0&#39;);<br>\t}<br>\tfor(int i = 1; i &lt;= c[0]; i++){&#47;&#47;进位处理 <br>\t\tif(c[i] &lt; 10)continue;&#47;&#47; 每一位是否满10？ <br>\t\tif(i == c[0])c[++c[0]] = 0;&#47;&#47;是否要进位 <br>\t\tc[i + 1] += c[i] &#47; 10;&#47;&#47;满10进1 <br>\t\tc[i] %= 10;&#47;&#47;原位除10求余 <br>\t}<br>\tfor(int i = c[0]; i &gt;= 1; --i)printf(&quot;%d&quot;, c[i]);&#47;&#47;胡老师给的倒序输出语句太漂亮了，我直接拿来用了 <br>\tprintf(&quot;\\n&quot;);<br>} <br><br>int main(){<br>\tchar a[1000], b[1000];<br>\tscanf(&quot;%s %s&quot;, a, b);<br>\tprintBIG(a, b);<br>\treturn 0;<br>}","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502672,"discussion_content":"非常不错！d(^_^o)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596524992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183360,"user_name":"Jinlee","can_delete":false,"product_type":"c1","uid":1644723,"ip_address":"","ucode":"8EDA9B0C5184EA","user_header":"https://static001.geekbang.org/account/avatar/00/19/18/b3/848ffa10.jpg","comment_is_top":false,"comment_ctime":1583028867,"is_pvip":false,"replies":[{"id":"71082","content":"你注意观察 num[j + 1] += num[j] &#47; 10; 这行代码的上一行代码，上一行代码说明，如果发生进位的是 num 大整数的最高位，就给 num[0] + 1，并且给新增的1位，赋为初值 0。 你说的没错，i 应该是 j，笔误。<br>","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1583114409,"ip_address":"","comment_id":183360,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5877996163","product_id":100043901,"comment_content":"老师您好，计算2的10次方并输出的示例代码中，我始终没明白为什么 num[0] 会变呢？不是一直都是初始化的值 1 吗？还有， num[j + 1] += num[i] &#47; 10   这一行代码中的 I 是否应该为 j 呢？","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485661,"discussion_content":"你注意观察 num[j + 1] += num[j] / 10; 这行代码的上一行代码，上一行代码说明，如果发生进位的是 num 大整数的最高位，就给 num[0] + 1，并且给新增的1位，赋为初值 0。 你说的没错，i 应该是 j，笔误。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583114409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1917663,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","nickname":"罗耀龙@坐忘","note":"","ucode":"3CEA258DE7F3C7","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295723,"discussion_content":"好的老师，一语惊醒梦中人+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596299164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644723,"avatar":"https://static001.geekbang.org/account/avatar/00/19/18/b3/848ffa10.jpg","nickname":"Jinlee","note":"","ucode":"8EDA9B0C5184EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193008,"discussion_content":"好的老师，一语惊醒梦中人🤔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583115910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180570,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1582339469,"is_pvip":true,"replies":[{"id":"70094","content":"这个是有的。GNU 标准下，是支持 128 位整型数据的。对于你提出的内存浪费的事情，其实文中给出的是最基本的一种实现，真正应用的时候，你可以尝试每一个整型位置存储若干位的数字，<br>例如：123456--&gt; 12 | 34 | 56","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1582371017,"ip_address":"","comment_id":180570,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877306765","product_id":100043901,"comment_content":"对于原来的数据类型而言，我们的数组12345，底层使用64位存储的。而为了突破数据类型本身的限制，存放更大的数字，我们新建了一个数组，数组每个元素大小也是64位的话， 也就是说为了表示12345，实际上使用了更多的内存空间。<br>那么，有没有通过二进制本身，比如说在底层搞一个新的类型，比如说super long, 用128位或者更多位来表示这个大数据类型的方式呢？","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484717,"discussion_content":"这个是有的。GNU 标准下，是支持 128 位整型数据的。对于你提出的内存浪费的事情，其实文中给出的是最基本的一种实现，真正应用的时候，你可以尝试每一个整型位置存储若干位的数字，\n例如：123456--&amp;gt; 12 | 34 | 56","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582371017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180137,"user_name":"🤪HappyJoo","can_delete":false,"product_type":"c1","uid":1234591,"ip_address":"","ucode":"96E1858F06BABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","comment_is_top":false,"comment_ctime":1582196278,"is_pvip":false,"replies":[{"id":"70012","content":"1、是的，之前不注意的时候，踩过坑，后来习惯养成了，就顺手写__typeof了。<br>2、对于加法来说确实可以，写成%=只是为了不增加你们的学习负担，否则加法学一套，乘法又得学一套。你能发现这其中的问题，说明你是很认真看了的！给你点赞！<br>3、你理解的是对的。<br><br>我在手机上操作的，不方便打开你的链接，我盲猜一下，cnt是用来记录素数个数的。","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1582256849,"ip_address":"","comment_id":180137,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5877163574","product_id":100043901,"comment_content":"老师您好，可以麻烦您有空的话帮我解决几个问题吗？谢谢！：<br>1，在标准C中是 以“__”开头,所以在标准C中要写成“__typeof()”或“__typeof__()”，在GNU C 中还支持直接写“typeof()”，我看您写的都是”__typeof()&quot;，其实三个都是一样的，但是否为了不造成不必要的麻烦，才用了标准C的第一个呢？<br><br>2，“一起动手搞事情”前面的代码，第23行，“c[i + 1] += c[i] &#47; 10;”，请问这里直接用“+= 1”不行吗？我在这里看了好久才看明白就是一个“进一”的意思（笑哭）。<br><br>3，第22行，&quot;c[++c[0]]&quot;，这里是不是让“c[0]“先加一再拿来用？用&quot;c[0]++&quot;就会先用原来未加一的数值，然后才加一？我理解的对吗？<br><br>谢谢老师，欧拉筛法我看了一些blog，看的头晕，不知道他们的一些变量的作用是什么？例如（https:&#47;&#47;blog.csdn.net&#47;tianwei0822&#47;article&#47;details&#47;78309453），cnt 是用来干什么的？里面的for循环看不太懂哈哈哈~","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484539,"discussion_content":"1、是的，之前不注意的时候，踩过坑，后来习惯养成了，就顺手写__typeof了。\n2、对于加法来说确实可以，写成%=只是为了不增加你们的学习负担，否则加法学一套，乘法又得学一套。你能发现这其中的问题，说明你是很认真看了的！给你点赞！\n3、你理解的是对的。\n\n我在手机上操作的，不方便打开你的链接，我盲猜一下，cnt是用来记录素数个数的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582256849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234591,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","nickname":"🤪HappyJoo","note":"","ucode":"96E1858F06BABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181069,"discussion_content":"谢谢老师的回答~~很喜欢这门课，收获很多！~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582335818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234591,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","nickname":"🤪HappyJoo","note":"","ucode":"96E1858F06BABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179764,"discussion_content":"&#39;cnt&#39; 就是给prime计算有多少个素数的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582251484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360190,"user_name":"look for","can_delete":false,"product_type":"c1","uid":1459157,"ip_address":"山东","ucode":"B19F0DED81B2BD","user_header":"https://static001.geekbang.org/account/avatar/00/16/43/d5/a7eaf722.jpg","comment_is_top":false,"comment_ctime":1666260857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666260857","product_id":100043901,"comment_content":"作业：<br><br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br><br>&#47;&#47; 定义交换两个变量值的宏<br>#define swap(a, b)      \\<br>  {                     \\<br>    __typeof(a) _t = a; \\<br>    a = b;              \\<br>    b = _t;             \\<br>  }<br><br>&#47;&#47; 实现大整数加法，a + b的结果，存放在c中<br>void plus_big_integer(int *a, int *b, int *c)<br>{<br>  &#47;&#47; 让a指向位数较长的那个数<br>  if (a[0] &lt; b[0])<br>  {<br>    swap(a, b);<br>  }<br>  &#47;&#47; 大整数c的位数以a的位数为基准<br>  c[0] = a[0];<br>  &#47;&#47; 循环模拟按位加法<br>  for (int i = 1; i &lt;= a[0]; i++)<br>  {<br>    if (i &lt;= b[0])<br>    {<br>      c[i] = a[i] + b[i];<br>    }<br>    else<br>    {<br>      c[i] = a[i];<br>    }<br>  }<br>  &#47;&#47; 处理每一位的进位过程<br>  for (int i = 1; i &lt;= c[0]; i++)<br>  {<br>    if (c[i] &lt; 10)<br>    {<br>      continue;<br>    }<br>    &#47;&#47; 判断是不是最高位产生了进位，如果是则进行初始化<br>    if (i == c[0])<br>    {<br>      c[++c[0]] = 0;<br>    }<br>    c[i + 1] += c[i] &#47; 10;<br>    c[i] %= 10;<br>  }<br>}<br><br>&#47;&#47; 将一个数字字符串转换位大整数表示法<br>void trans_big_int_expression(char *str, int *arr)<br>{<br>  int slen = strlen(str);<br>  arr[0] = slen;<br>  for (int i = 0; i &lt; slen; i++)<br>  {<br>    arr[slen - i] = str[i] - 48;<br>  }<br>}<br><br>void main()<br>{<br>  int a[20], b[20], c[20] = {0};<br>  char stra[20], strb[20];<br>  scanf(&quot;%s%s&quot;, stra, strb);<br><br>  &#47;&#47; 转换为大整数表示法<br>  trans_big_int_expression(stra, a);<br>  trans_big_int_expression(strb, b);<br>  &#47;&#47; 进行大整数相加，并存入c中<br>  plus_big_integer(a, b, c);<br><br>  for (int i = 0; i &lt; 20; i++)<br>  {<br>    printf(&quot;%d&quot;, c[i]);<br>  }<br>}","like_count":0},{"had_liked":false,"id":251747,"user_name":"武汉李先生","can_delete":false,"product_type":"c1","uid":1995728,"ip_address":"","ucode":"F0CCB26C320238","user_header":"","comment_is_top":false,"comment_ctime":1601821550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601821550","product_id":100043901,"comment_content":"胡船长好，这行代码中<br>if (j == num[0]) num[++num[0]] = 0;<br>赋值为0的操作是不是可以省略，num数组在声明的时候已经初始元素全为0，还是说在有的情况下不是0，为了安全起见这样做的。","like_count":0},{"had_liked":false,"id":205646,"user_name":"1043","can_delete":false,"product_type":"c1","uid":1485365,"ip_address":"","ucode":"AAA69CC175AEE3","user_header":"https://static001.geekbang.org/account/avatar/00/16/aa/35/1a4884f9.jpg","comment_is_top":false,"comment_ctime":1586695014,"is_pvip":false,"replies":[{"id":"76901","content":"嗯，对的，这个差别，就是我们所谓的编码能力：将思想转换成代码的能力。(｡ì _ í｡)","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1586740337,"ip_address":"","comment_id":205646,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1586695014","product_id":100043901,"comment_content":"在计算机中虽然不用自己去计算，但是得理解计算机是怎么计算和存储与表达出来给人类能看懂的逻辑运算。越是高效的算法越简洁，计算机执行效率越高，但是越高效的算法需要数学能力和数学思维的水平也要越高才能做到。在数学思维上和数学在程序语言的表达逻辑上好像总有些差别。","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491541,"discussion_content":"嗯，对的，这个差别，就是我们所谓的编码能力：将思想转换成代码的能力。(｡ì _ í｡)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586740337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184472,"user_name":"一日","can_delete":false,"product_type":"c1","uid":1481316,"ip_address":"","ucode":"7A9EFF0BCE2674","user_header":"https://static001.geekbang.org/account/avatar/00/16/9a/64/63fd724b.jpg","comment_is_top":false,"comment_ctime":1583324423,"is_pvip":true,"replies":[{"id":"71445","content":"你要怎么合并呢？我看看你的代码？","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1583410991,"ip_address":"","comment_id":184472,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583324423","product_id":100043901,"comment_content":"有个疑问：并列的两个for循环：for (int j = 1; j &lt;= num[0]; j++); 虽然在时空复杂度，两个并列的时间复杂度取最高，那这两个循环合并为一个是不是效率也会提高一些，虽然现在计算机执行速度很快了。","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486025,"discussion_content":"你要怎么合并呢？我看看你的代码？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583410991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}