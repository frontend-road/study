{"id":219290,"title":"65 | 迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些优势？","content":"<p>上一节课，我们学习了状态模式。状态模式是状态机的一种实现方法。它通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，以此来避免状态机类中的分支判断逻辑，应对状态机类代码的复杂性。</p><p>今天，我们学习另外一种行为型设计模式，迭代器模式。它用来遍历集合对象。不过，很多编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时开发中，特别是业务开发，我们直接使用即可，很少会自己去实现一个迭代器。不过，知其然知其所以然，弄懂原理能帮助我们更好的使用这些工具类，所以，我觉得还是有必要学习一下这个模式。</p><p>我们知道，大部分编程语言都提供了多种遍历集合的方式，比如for循环、foreach循环、迭代器等。所以，今天我们除了讲解迭代器的原理和实现之外，还会重点讲一下，相对于其他遍历方式，利用迭代器来遍历集合的优势。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>迭代器模式的原理和实现</h2><p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。</p><p>在开篇中我们讲到，它用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p><!-- [[[read_end]]] --><p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及<strong>容器</strong>和<strong>容器迭代器</strong>两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。对于迭代器模式，我画了一张简单的类图，你可以看一看，先有个大致的印象。</p><p><img src=\"https://static001.geekbang.org/resource/image/cb/ec/cb72b5921681ac13d4fc05237597d2ec.jpg?wh=1623*951\" alt=\"\"></p><p>接下来，我们通过一个例子来具体讲，如何实现一个迭代器。</p><p>开篇中我们有提到，大部分编程语言都提供了遍历容器的迭代器类，我们在平时开发中，直接拿来用即可，几乎不大可能从零编写一个迭代器。不过，这里为了讲解迭代器的实现原理，我们假设某个新的编程语言的基础类库中，还没有提供线性容器对应的迭代器，需要我们从零开始开发。现在，我们一块来看具体该如何去做。</p><p>我们知道，线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应ArrayList和LinkedList两个类。除此之外，我们从两个类中抽象出公共的接口，定义为List接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换。</p><p>现在，我们针对ArrayList和LinkedList两个线性容器，设计实现对应的迭代器。按照之前给出的迭代器模式的类图，我们定义一个迭代器接口Iterator，以及针对两种容器的具体的迭代器实现类ArrayIterator和ListIterator。</p><p>我们先来看下Iterator接口的定义。具体的代码如下所示：</p><pre><code>// 接口定义方式一\npublic interface Iterator&lt;E&gt; {\n  boolean hasNext();\n  void next();\n  E currentItem();\n}\n\n// 接口定义方式二\npublic interface Iterator&lt;E&gt; {\n  boolean hasNext();\n  E next();\n}\n</code></pre><p>Iterator接口有两种定义方式。</p><p>在第一种定义中，next()函数用来将游标后移一位元素，currentItem()函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素与后移一位这两个操作，要放到同一个函数next()中完成。</p><p>第一种定义方式更加灵活一些，比如我们可以多次调用currentItem()查询当前元素，而不移动游标。所以，在接下来的实现中，我们选择第一种接口定义方式。</p><p>现在，我们再来看下ArrayIterator的代码实现，具体如下所示。代码实现非常简单，不需要太多解释。你可以结合着我给出的demo，自己理解一下。</p><pre><code>public class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; {\n  private int cursor;\n  private ArrayList&lt;E&gt; arrayList;\n\n  public ArrayIterator(ArrayList&lt;E&gt; arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n  }\n\n  @Override\n  public boolean hasNext() {\n    return cursor != arrayList.size(); //注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。\n  }\n\n  @Override\n  public void next() {\n    cursor++;\n  }\n\n  @Override\n  public E currentItem() {\n    if (cursor &gt;= arrayList.size()) {\n      throw new NoSuchElementException();\n    }\n    return arrayList.get(cursor);\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;xzg&quot;);\n    names.add(&quot;wang&quot;);\n    names.add(&quot;zheng&quot;);\n    \n    Iterator&lt;String&gt; iterator = new ArrayIterator(names);\n    while (iterator.hasNext()) {\n      System.out.println(iterator.currentItem());\n      iterator.next();\n    }\n  }\n}\n</code></pre><p>在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，我们可以在容器中定义一个iterator()方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在List接口中。具体的代码实现和使用示例如下所示：</p><pre><code>public interface List&lt;E&gt; {\n  Iterator iterator();\n  //...省略其他接口函数...\n}\n\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; {\n  //...\n  public Iterator iterator() {\n    return new ArrayIterator(this);\n  }\n  //...省略其他代码\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    List&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(&quot;xzg&quot;);\n    names.add(&quot;wang&quot;);\n    names.add(&quot;zheng&quot;);\n    \n    Iterator&lt;String&gt; iterator = names.iterator();\n    while (iterator.hasNext()) {\n      System.out.println(iterator.currentItem());\n      iterator.next();\n    }\n  }\n}\n</code></pre><p>对于LinkedIterator，它的代码结构跟ArrayIterator完全相同，我这里就不给出具体的代码实现了，你可以参照ArrayIterator自己去写一下。</p><p>结合刚刚的例子，我们来总结一下迭代器的设计思路。总结下来就三句话：迭代器中需要定义hasNext()、currentItem()、next()三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过iterator()方法来创建迭代器。</p><p>这里我画了一张类图，如下所示。实际上就是对上面那张类图的细化，你可以结合着一块看。</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/30/b685b61448aaa638b03b5bf3d9d93330.jpg?wh=2094*1323\" alt=\"\"></p><h2>迭代器模式的优势</h2><p>迭代器的原理和代码实现讲完了。接下来，我们来一块看一下，使用迭代器遍历集合的优势。</p><p>一般来讲，遍历集合数据有三种方法：for循环、foreach循环、iterator迭代器。对于这三种方式，我拿Java语言来举例说明一下。具体的代码如下所示：</p><pre><code>List&lt;String&gt; names = new ArrayList&lt;&gt;();\nnames.add(&quot;xzg&quot;);\nnames.add(&quot;wang&quot;);\nnames.add(&quot;zheng&quot;);\n\n// 第一种遍历方式：for循环\nfor (int i = 0; i &lt; names.size(); i++) {\n  System.out.print(names.get(i) + &quot;,&quot;);\n}\n\n// 第二种遍历方式：foreach循环\nfor (String name : names) {\n  System.out.print(name + &quot;,&quot;)\n}\n\n// 第三种遍历方式：迭代器遍历\nIterator&lt;String&gt; iterator = names.iterator();\nwhile (iterator.hasNext()) {\n  System.out.print(iterator.next() + &quot;,&quot;);//Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据\n}\n</code></pre><p>实际上，foreach循环只是一个语法糖而已，底层是基于迭代器来实现的。也就是说，上面代码中的第二种遍历方式（foreach循环代码）的底层实现，就是第三种遍历方式（迭代器遍历代码）。这两种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。</p><p>从上面的代码来看，for循环遍历方式比起迭代器遍历方式，代码看起来更加简洁。那我们为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三个。</p><p>首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用for循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。</p><p>前面也多次提到，应对复杂性的方法就是拆分。我们可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，我们就可以定义DFSIterator、BFSIterator两个迭代器类，让它们分别来实现深度优先遍历和广度优先遍历。</p><p>其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</p><p>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从LinkedIterator切换为ReversedLinkedIterator即可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器类，也更符合开闭原则。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>迭代器模式，也叫游标模式。它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。</p><p>一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。容器中需要定义iterator()方法，用来创建迭代器。迭代器接口中需要定义hasNext()、currentItem()、next()三个最基本的方法。容器对象通过依赖注入传递到迭代器类中。</p><p>遍历集合一般有三种方式：for循环、foreach循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于for循环遍历，利用迭代器来遍历有下面三个优势：</p><ul>\n<li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li>\n<li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</li>\n<li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li>\n</ul><h2>课堂讨论</h2><ol>\n<li>在Java中，如果在使用迭代器的同时删除容器中的元素，会导致迭代器报错，这是为什么呢？如何来解决这个问题呢？</li>\n<li>除了编程语言中基础类库提供的针对集合对象的迭代器之外，实际上，迭代器还有其他的应用场景，比如MySQL ResultSet类提供的first()、last()、previous()等方法，也可以看作一种迭代器，你能分析一下它的代码实现吗？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"64 | 状态模式：游戏、工作流引擎中常用的状态机是如何实现的？","id":218375},"right":{"article_title":"66 | 迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？","id":219964}},"comments":[{"had_liked":false,"id":201084,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1585713440,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"319413293344","product_id":100039001,"comment_content":"在 Java 中，如果在使用迭代器的同时删除容器中的元素，会导致迭代器报错，这是为什么呢？如何来解决这个问题呢？<br><br>通过阅读Java11 ArrayList#Iterator源码:<br><br>iterator#remove()中, 调用外部类ArrayList#remove(), 通过下标移除元素. ArrayList内部维护modCount成员变量, 表示一次遍历中修改次数. Iterator通过remove()修改前, 会核对Iterator自己的exceptedModCount和ArrayList的modCount是否一致, 若不一致, 说明出现了并发问题, 会抛出异常. 若一致, 正常移除数据, 并更新modCount<br><br><br><br>结论: 1. 通过Iterator遍历集合时, 必须通过Iterator#remove()移除元素. <br><br>​          2. 避免在并发情形修改集合, 或使用CopyOnWriteArrayList","like_count":75,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385061,"discussion_content":"你不觉得你的分析 一点都不搭嘎吗???? 明明抛出异常的是 String str = (String) iterator.next(); 这句; 也即是说  arrayList.remove(str); 这句已经删除成功了, 在执行 iterator.next(); 下一个元素时 才 抛出的异常 , 你一个劲的分析   iterator.remove(); 这个 干毛啊;","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626866203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1120019,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqnwc76trn2r5devKhw3CpBqLhBwib5IRCvbQe4zA1vt9KoXg1c7DbR3gGfgRBxxkTI032URhNeBww/132","nickname":"drafthj","note":"","ucode":"D150DE672B5189","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542402,"discussion_content":"有点暴躁了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640744238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":385061,"ip_address":""},"score":542402,"extra":""}]},{"author":{"id":1721251,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/a3/53f7f1fe.jpg","nickname":"唯有学习不止","note":"","ucode":"52DA78BBEC4D38","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261032,"discussion_content":"modCount并不是表示修改次数，楼下有正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588932100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2242740,"avatar":"https://static001.geekbang.org/account/avatar/00/22/38/b4/1843033d.jpg","nickname":"lh","note":"","ucode":"F048C6C0C7E8EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1721251,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/a3/53f7f1fe.jpg","nickname":"唯有学习不止","note":"","ucode":"52DA78BBEC4D38","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346500,"discussion_content":"那表示什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611975062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261032,"ip_address":""},"score":346500,"extra":""},{"author":{"id":1691447,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/37/6ed137b9.jpg","nickname":"Dunk","note":"","ucode":"A8F5AB98382719","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1721251,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/a3/53f7f1fe.jpg","nickname":"唯有学习不止","note":"","ucode":"52DA78BBEC4D38","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378369,"discussion_content":"The number of times this list has been structurally modified. ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623199466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261032,"ip_address":""},"score":378369,"extra":""},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1691447,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/37/6ed137b9.jpg","nickname":"Dunk","note":"","ucode":"A8F5AB98382719","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385056,"discussion_content":"此列表在结构上被修改的次数???","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626864553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378369,"ip_address":""},"score":385056,"extra":""}]}]},{"had_liked":false,"id":263015,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1605948091,"is_pvip":true,"replies":[{"id":"96112","content":"嗯嗯������","user_name":"作者回复","comment_id":263015,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700861,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"177699607227","product_id":100039001,"comment_content":"本质是因为迭代器从容器类抽象出来以后，一个容器的数据会被多个迭代器访问，这种类似数据库的并问题了，迭代器抽象出来可以让多个线程同时访问容器数据，但这也会带来一个问题：数据一致性。Java是通过在迭代器和容器中都维护了一个修改计数，remove的时候需要比较两个计数，不一致就会抛出异常","like_count":42,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510071,"discussion_content":"嗯嗯������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201049,"user_name":"国奉","can_delete":false,"product_type":"c1","uid":1338758,"ip_address":"","ucode":"9946ADFA81D92E","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/86/2a0717df.jpg","comment_is_top":false,"comment_ctime":1585709525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"169089434069","product_id":100039001,"comment_content":"漏掉状态模式实现电商的案例了","like_count":39},{"had_liked":false,"id":200956,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1585699089,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"104664914193","product_id":100039001,"comment_content":"第一个问题，使用 for-each 或者 iterator 进行迭代删除 remove 时，容易导致 next() 检测的 modCount 不等于 expectedModCount 从而引发 ConcurrentModificationException。<br>在单线程下，推荐使用 next() 得到元素，然后直接调用 remove(),注意是无参的 remove; 多线程情况下还是使用并发容器吧😃","like_count":25,"discussions":[{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218915,"discussion_content":"补充一下: iterator#next()得到元素并判断符合删除条件时, 应直接调用iterator#remove(),而不是list#remove()","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1585713532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385057,"discussion_content":"这么 细节的 话 愣是没人说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626864633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":218915,"ip_address":""},"score":385057,"extra":""}]}]},{"had_liked":false,"id":201037,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1585708573,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"91780021789","product_id":100039001,"comment_content":"课后题1:<br>      java中,容器中有int类型的变量ModCount来记录修改次数,每次新增或者删除容器内对象时都会给这个变量+1<br>      在创建迭代器时会初始化一个变量expectedModCount(期待的操作次数) = ModCount,记录当前容器的增删操作次数,在使用迭代器时会不断检查expectedModCount是否等于ModCount(这个方式类似版本号机制,CAS解决ABA问题的方法),当他们不相等时就会抛异常<br>解决方法:<br>1.利用Arrays.copy方法,每次迭代前复制出一份副本,迭代这个副本(有可能会导致迭代的数据不一致)<br>2.如果是轮询的方式去执行,可以不用管这个异常,交给下一次轮询去处理<br>3.如果这个迭代操作最后产生的数据要返回给用户,也可以catch到这个异常时直接返回&quot;数据正在处理中,请稍后再试&quot;<br>ps:如果这个场景有线程安全问题,建议用方法1,用副本来迭代 。<br>      使用并发安全容器并不能解决所有的并发安全问题,因为线程安全可以分为绝对安全,相对安全,线程兼容和线程对立,绝对安全的成本太高,我们通常说的线程安全都是相对安全,即这个对象的单次操作时是线程安全的(举例:一次delete或者一次fori循环处理操作,分别是安全的,但是如果一条线程在做delete操作,另一条线程用fori循环处理,那么fori循环这条线程势必会出现异常),而我们常说的并发安全容器HashTable,ConcurrentHashMap都是相对安全<br>    最后,没有最好的方案,只有最合适的方案,应该根据具体的场景选择合适的处理方式","like_count":21},{"had_liked":false,"id":200957,"user_name":"Corner","can_delete":false,"product_type":"c1","uid":1446316,"ip_address":"","ucode":"7862D593172536","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg","comment_is_top":false,"comment_ctime":1585699231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57420274079","product_id":100039001,"comment_content":"因为在迭代器中保存的游标和集合有一致性关系（大小，元素位置）。迭代器外部删除集合元素将导致其保存的游标位置与集合当前状态不一致。解决方法是由迭代器本身提供删除方法，这样可以感知到删除操作以便调整本身保存的游标。","like_count":13},{"had_liked":false,"id":202091,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1585901546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27355705322","product_id":100039001,"comment_content":"1.在 Java 中，如果在使用迭代器的同时两次删除容器中的元素，会导致迭代器报错，这是为什么呢？如何来解决这个问题呢？<br>java.util.AbstractList中名为modCount的filed用来记录这个集合被结构性修改的次数;<br>内部类迭代器java.util.ArrayList.Itr中会有个名为expectedModCount的field,用来记录当前集合被修改的次数,当删除元素时会modCount会加1,而expectedModCount却保持不变,当再继续遍历时会检查modCount与expectedModCount是否相等,如果不相等就会抛出异常,中止程序往下执行.<br>解决方式,当删除元素时将更新的modCount同步给expectedModCount.<br><br>2.除了编程语言中基础类库提供的针com.mysql.cj.jdbc.result.ResultSetImpl对集合对象的迭代器之外，实际上，迭代器还有其他的应用场景，比如 MySQL ResultSet 类提供的 first()、last()、previous() 等方法，也可以看作一种迭代器，你能分析一下它的代码实现吗？<br>com.mysql.cj.jdbc.result.ResultSetFactory将数据集com.mysql.cj.protocol.ResultsetRows作为构造参数传递给迭代器com.mysql.cj.jdbc.result.ResultSetImpl, ResultSetImpl实现了接口java.sql.ResultSet中的first()、last()、previous() 等函数,当我们上层遍历集合时只需调用操作java.sql.ResultSet既可以了,而当我们想要更换成oracle的jdbc时只需替换实现的依赖包即可,上层应用代码无需任何改动,迭代器模式将数据集与遍历操作进行了解耦才使我们可以轻松替换底层jdbc实现,这也符合软件开发中倡导的开闭原则.","like_count":7},{"had_liked":false,"id":201042,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1585708824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23060545304","product_id":100039001,"comment_content":"设计模式_65: <br># 作业<br>1. 刚看了一下源码，Java容器会校验修改次数`modCount`,与预期不一致就会抛出异常，这个设计是合理的：因为在使用迭代器的同时删除元素，很可能会带来数据的错误，甚至导致程序的崩溃，及时地暴露错误是正确的做法。<br><br>如何解决：单线程中使用`iterator.remove()`方法删除，多线程中使用并发集合。<br><br><br># 感想<br>最早使用迭代器，是因为for循环删除元素会导致错误，就像今天的问题1。<br>现在看来，迭代器更重要的作用是解耦，呼应前面的原则就是`开闭原则`、`单一职责原则`、`里氏替换原则`。。。","like_count":5},{"had_liked":false,"id":201013,"user_name":"攻城拔寨","can_delete":false,"product_type":"c1","uid":1053934,"ip_address":"","ucode":"CBC37183DAB6B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","comment_is_top":false,"comment_ctime":1585705631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23060542111","product_id":100039001,"comment_content":"第一个问题：迭代器中包含了集合的大小和位置信息。直接删除元素，迭代器感知不到，迭代器大小位置因为不正确，继续遍历下去出现问题（如 index 溢出）。<br>删除需要调用 iterator 本身的 remove 方法，而 foreach 并不能直接调用。所以只能通过原始的迭代器方法遍历。","like_count":5},{"had_liked":false,"id":200967,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1585700114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18765569298","product_id":100039001,"comment_content":"第二个问题，ResultSet 内部通过维护一个类型为 ResultSetRows 的 rowData 变量来实现迭代，而 rowData 的迭代方法本质就是实现了标准库的 Iterator 接口。","like_count":4},{"had_liked":false,"id":313281,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1724215,"ip_address":"","ucode":"FA8E8FD88886AF","user_header":"https://static001.geekbang.org/account/avatar/00/1a/4f/37/ad1ca21d.jpg","comment_is_top":false,"comment_ctime":1632363226,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10222297818","product_id":100039001,"comment_content":"迭代器在大数据框架应用广泛，比如spark、mapreduce，主要使用其将迭代器的嵌套实现计算逻辑的封装，最终在框架运行时，实现了数据的迭代计算。","like_count":2},{"had_liked":false,"id":222420,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1590802771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10180737363","product_id":100039001,"comment_content":"大家都说了删除报错的现有实现，为什么这样实现？原因是：比如数组，删除以后数组要移动后续位置，如果外部删除了元素，iterator无法感知，通过游标获取的next就会获取到当前元素，会导致遍历错误，所以要通过iterator去删除，这样iterater能感知到做相应处理","like_count":2},{"had_liked":false,"id":204141,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1586340988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176275580","product_id":100039001,"comment_content":"以前一直都不知道迭代器有啥用, 今天看完后感觉, 迭代器是为了拆分类的复杂度, 还是很有用的.","like_count":2},{"had_liked":false,"id":200944,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1585697153,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10175631745","product_id":100039001,"comment_content":"这是因为 Java 迭代器中实现了 fail-fast 的机制","like_count":2},{"had_liked":false,"id":200929,"user_name":"成立-Charlie","can_delete":false,"product_type":"c1","uid":1091556,"ip_address":"","ucode":"2970BB5446B70A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a7/e4/5a4515e9.jpg","comment_is_top":false,"comment_ctime":1585693285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175627877","product_id":100039001,"comment_content":"在使用迭代器遍历过程中，如果删除即其中的元素，因为集合中元素的数量发生了变化，会出错。我想到的解决方法是在遍历的过程中对集合进行加锁处理，但这样做会影响到效率。所以不确定是不是最好的办法。","like_count":2},{"had_liked":false,"id":201195,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1585731591,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5880698887","product_id":100039001,"comment_content":"以ArrayList为例，ArrayList.iterator()返回回来的Iterator&lt;E&gt;里面的hasNext()是不关心modification count的，参考链接：https:&#47;&#47;hg.openjdk.java.net&#47;jdk8&#47;jdk8&#47;jdk&#47;file&#47;tip&#47;src&#47;share&#47;classes&#47;java&#47;util&#47;ArrayList.java#l830， 而next()会去检查modification count, 参考https:&#47;&#47;hg.openjdk.java.net&#47;jdk8&#47;jdk8&#47;jdk&#47;file&#47;tip&#47;src&#47;share&#47;classes&#47;java&#47;util&#47;ArrayList.java#l835， 所以如果通过ArrayList.iterator()获取了一个新的iterator，然后删除了某个位置的元素，然后再调用iterator.hasNext()有可能会得到false，于是就退出了循环不会再继续执行，基于此考虑，JavaDoc定义了fast-fail原则，参考“https:&#47;&#47;hg.openjdk.java.net&#47;jdk8&#47;jdk8&#47;jdk&#47;file&#47;tip&#47;src&#47;share&#47;classes&#47;java&#47;util&#47;ArrayList.java#l73”。","like_count":1},{"had_liked":false,"id":354855,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"湖南","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1660823135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660823135","product_id":100039001,"comment_content":"java 里迭代器用的是继承啊","like_count":0},{"had_liked":false,"id":332044,"user_name":"ɴɪᴋᴇʀ","can_delete":false,"product_type":"c1","uid":1616622,"ip_address":"","ucode":"DB7D92CBB5FD15","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","comment_is_top":false,"comment_ctime":1642994853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642994853","product_id":100039001,"comment_content":"问题1，那如果不是改变元素个数，而是改变数据的结构呢？比如树结构。","like_count":0},{"had_liked":false,"id":324498,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1638458438,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638458438","product_id":100039001,"comment_content":"modCount是对容器的操作次数。迭代器维护的是modeCount和expectedMountCount.容器维护着自己的modCount.这就确保了在迭代器中操作，迭代器会维护两个count，次数相等。如果使用了迭代器的同时，对容器操作，容器只会维护自己的count，导致和迭代器中的count不相等，所以抛出异常。","like_count":0},{"had_liked":false,"id":288091,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1618296468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618296468","product_id":100039001,"comment_content":"树和图的遍历是我永远的痛，所以默认就把树和图的遍历忽略了。<br>而迭代器模式恰恰是高级工程师为我们这些初级工程师将痛苦的遍历封装起来的解决办法。","like_count":0},{"had_liked":false,"id":275501,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1611564363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611564363","product_id":100039001,"comment_content":"今天的内容贴近日常开发","like_count":0},{"had_liked":false,"id":274890,"user_name":"Airsaid","can_delete":false,"product_type":"c1","uid":1115302,"ip_address":"","ucode":"5B90BC0044F376","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","comment_is_top":false,"comment_ctime":1611211013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611211013","product_id":100039001,"comment_content":"课堂讨论问题一：<br><br>容器维护了一个 modCount 的变量，意思是结构修改的次数，当每次容器修改数据时（增加、删除等），modCount 就会改变。<br><br>在创建迭代器时，会将 modCount 赋值给迭代器内部维护的 expectedModCount 变量，并在每次调用迭代器的方法时，判断这两个值是否相等，如果不相等则抛出 ConcurrentModificationException 异常。<br><br>进行这个判断，就是不让外界在使用迭代器时去修改数据结构，因为这会导致不可预期的问题，例如漏遍历了，越界了等问题。<br><br>这是一个 fast-fail 机制，当发现问题时，马上将问题显现出来。<br><br>解决该问题：<br><br>1. 最简单的方法就是不要在迭代时去修改数据结构。<br>2. 或者直接用迭代器的 remove() 方法，使用迭代器的 remove() 方法有些限制，就是只能删除前一个已经遍历过的元素（内部会重新对 expectedModCount 进行赋值，所以不会出现异常）。<br>3. 使用支持并发的数据容器。<br><br>课堂讨论问题二：<br><br>由于并不是后端工程师，所以对问题二并不了解，略。","like_count":0},{"had_liked":false,"id":270594,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1609167471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609167471","product_id":100039001,"comment_content":"用iterator的 remove应该不会抛出concurrent的错误吧？ foreach用集合自己的remove倒是会因为modcount的数据问题导致报错","like_count":0},{"had_liked":false,"id":267798,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1607935265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607935265","product_id":100039001,"comment_content":"打卡：实现了文中迭代器的案例。","like_count":0},{"had_liked":false,"id":256189,"user_name":"flyCoder","can_delete":false,"product_type":"c1","uid":1074897,"ip_address":"","ucode":"82FB7B60775978","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/d1/8664c464.jpg","comment_is_top":false,"comment_ctime":1603548643,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603548643","product_id":100039001,"comment_content":"感觉迭代器模式没有什么对应业务场景的应用","like_count":0},{"had_liked":false,"id":253955,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1602990084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602990084","product_id":100039001,"comment_content":"不能在外部删除，只能通过迭代器提供的方法删除","like_count":0},{"had_liked":false,"id":246060,"user_name":"techwro","can_delete":false,"product_type":"c1","uid":1113744,"ip_address":"","ucode":"7AF2B319F0AE1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","comment_is_top":false,"comment_ctime":1599147454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599147454","product_id":100039001,"comment_content":"ResultSet是jdk提供的接口，而mysql-connector提供了具体实现，ResultSetImpl 内部通过维护一个类型为 ResultSetRows 的 rowData 变量来实现迭代。ref: https:&#47;&#47;jar-download.com&#47;artifacts&#47;mysql&#47;mysql-connector-java&#47;8.0.18&#47;source-code&#47;com&#47;mysql&#47;cj&#47;jdbc&#47;result&#47;ResultSetImpl.java","like_count":0},{"had_liked":false,"id":245992,"user_name":"Java垒墙工程师","can_delete":false,"product_type":"c1","uid":1937062,"ip_address":"","ucode":"E76AE44A9C76AE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","comment_is_top":false,"comment_ctime":1599126349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599126349","product_id":100039001,"comment_content":"补充一点：如果是使用迭代器的remove方法不会报错","like_count":0},{"had_liked":false,"id":242800,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1597845431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597845431","product_id":100039001,"comment_content":"学习笔记<br>利用迭代器来遍历有下面三个优势：<br>1. 迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。<br><br>2. 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；<br><br>3. 迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。","like_count":0},{"had_liked":false,"id":240120,"user_name":"咸鱼","can_delete":false,"product_type":"c1","uid":1179028,"ip_address":"","ucode":"5E79636DE48155","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","comment_is_top":false,"comment_ctime":1596766367,"is_pvip":false,"replies":[{"id":"89266","content":"快照本身就是我自己想出来的一个题目，确实没有需求啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1597453667,"ip_address":"","comment_id":240120,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1596766367","product_id":100039001,"comment_content":"这一章看的挺迷惑的，我的理解是快照是提供一个scope内的一致性读，不受“他人”的影响，但是ArrayList又是在一个非并发环境下使用，这种快照好像是增加了实现复杂度。并发场景下的快照迭代，感觉好像看起来也没那么大需求。希望争哥看到可以解惑下","like_count":0,"discussions":[{"author":{"id":2042568,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","nickname":"米豆丸","note":"","ucode":"CE99FE3A1EBCAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385072,"discussion_content":"你应该说的方法重写，按照协议走怎么会违背呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626869362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237473,"user_name":"Obed","can_delete":false,"product_type":"c1","uid":1399904,"ip_address":"","ucode":"8717488DD14AB4","user_header":"https://static001.geekbang.org/account/avatar/00/15/5c/60/3754399d.jpg","comment_is_top":false,"comment_ctime":1595840093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595840093","product_id":100039001,"comment_content":"其实还有一个好处 比如LinkedList 如果直接使用for循环遍历全部元素 时间复杂度是O(N^2)<br>如果使用迭代器模式的话就是O(N) 因为迭代器模式持有了当前的指针<br>(这个时间复杂度分析应该没有错吧)","like_count":0},{"had_liked":false,"id":232274,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593940142,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593940142","product_id":100039001,"comment_content":"迭代器就是用于方便遍历容器元素的<br>所以需要：是否还有元素，获取当前元素，将指标移向下一个元素几个方法<br>相比直接用for循环，可以实现基于接口的编程，如果替换了容器实现可以不用修改遍历代码。<br>其次相比for循环遍历，如果容器提供了多种遍历形式，这部分遍历方式是可以复用的，所以在框架上设计将循历抽出一个iterator会比较合适。能够实现遍历的职责单一，以及遍历的实现复用。","like_count":0},{"had_liked":false,"id":227425,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592378062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592378062","product_id":100039001,"comment_content":"迭代器模式，是将遍历算法和具体数据解耦的一种模式","like_count":0},{"had_liked":false,"id":224398,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1591367888,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1591367888","product_id":100039001,"comment_content":"迭代器模式，和适配器模式太像了…","like_count":0,"discussions":[{"author":{"id":1012815,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/74/4f/7975c7ee.jpg","nickname":"胡敏And","note":"","ucode":"8FA14B27F47F92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387806,"discussion_content":"？？？？。？。？。？。？。？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628425665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344787,"discussion_content":"那里像了， 你是不是晕乎了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611570714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221906,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1590631064,"is_pvip":false,"replies":[{"id":"85679","content":"好像也不算是~","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1593911588,"ip_address":"","comment_id":221906,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590631064","product_id":100039001,"comment_content":"在容器中定义一个Iterator这种方式，算不算是桥接设计模式?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496607,"discussion_content":"好像也不算是~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593911588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219407,"user_name":"kesen","can_delete":false,"product_type":"c1","uid":1672098,"ip_address":"","ucode":"C87860FCF78291","user_header":"","comment_is_top":false,"comment_ctime":1590023661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590023661","product_id":100039001,"comment_content":"java迭代器具有fail-fast机制。查看源码：<br>   public void remove() {<br>            if (lastRet &lt; 0)<br>                throw new IllegalStateException();<br>            checkForComodification();<br><br>            try {<br>                ArrayList.this.remove(lastRet);<br>                cursor = lastRet;<br>                lastRet = -1;<br>                expectedModCount = modCount;<br>            } catch (IndexOutOfBoundsException ex) {<br>                throw new ConcurrentModificationException();<br>            }<br>        }<br><br>删除时，会先检查是否被修改过，具体代码：根据modCount 和expectedModCount进行对比<br><br>迭代器初始化时，int expectedModCount = modCount;<br><br>modCount来记录修改次数,每次新增或者删除容器内对象时都会给这个变量+1<br><br>final void checkForComodification() {<br>            if (modCount != expectedModCount)<br>                throw new ConcurrentModificationException();<br>        }","like_count":0},{"had_liked":false,"id":214883,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1588841474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588841474","product_id":100039001,"comment_content":"modcount 和期望的不一致就抛exception","like_count":0},{"had_liked":false,"id":206590,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1586905211,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586905211","product_id":100039001,"comment_content":"删除的时候深拷贝出来删除再替换原来的对象","like_count":0},{"had_liked":false,"id":205234,"user_name":"与路同飞","can_delete":false,"product_type":"c1","uid":1138821,"ip_address":"","ucode":"2985F1440A1962","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","comment_is_top":false,"comment_ctime":1586574957,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586574957","product_id":100039001,"comment_content":"ArrayList内部实现的迭代器，有个expectedModCount,初始值和modCount相同，当迭代器触发remove方法的时候，modCount会增加，然后expectedModCount会和modCount数据不一致，这样会抛异常","like_count":0},{"had_liked":false,"id":204730,"user_name":"谷雨","can_delete":false,"product_type":"c1","uid":1225827,"ip_address":"","ucode":"E8566AD0E2A521","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkkZBpiaOo4dGUuOXnRusBwcYCcwPTU8Pn41zbKh9py4Nwcf1rtc8A6yH5AtVVbkv8iaoS6hFgKevg/132","comment_is_top":false,"comment_ctime":1586446321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586446321","product_id":100039001,"comment_content":"感悟：学习迭代器的原理，我们可以自己设计、拓展指定容器的迭代方式。","like_count":0},{"had_liked":false,"id":204428,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1586398602,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586398602","product_id":100039001,"comment_content":"1、 在使用迭代器的同事删除容器中的元素，会导致，迭代器中的 集合的modCount 和 迭代器期待的expectedModCount 不一致而报错 ConcurrentModificationException<br>可以使用迭代器的remove 方法删除元素","like_count":0},{"had_liked":false,"id":201995,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1585885344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585885344","product_id":100039001,"comment_content":"了解foreach两者的差异","like_count":0},{"had_liked":false,"id":201144,"user_name":"Geek_27a248","can_delete":false,"product_type":"c1","uid":1542778,"ip_address":"","ucode":"6AC3AC42E6EEC9","user_header":"https://static001.geekbang.org/account/avatar/00/17/8a/7a/54003392.jpg","comment_is_top":false,"comment_ctime":1585722863,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585722863","product_id":100039001,"comment_content":"看评论想到的都是迭代器性质的移除元素会报错，就是评论中给出的fail-fast机制吧，当时还看过源码，现在自己代码中删除元素都是用的普通的循环，也没使用加锁，，不知道有没有什么好的方案可以实现","like_count":0,"discussions":[{"author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297065,"discussion_content":"ArrayList本身就是非线程安全的实现，加锁干啥呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596765328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201143,"user_name":"勤劳的明酱","can_delete":false,"product_type":"c1","uid":1259140,"ip_address":"","ucode":"05EBE89B80371B","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/84/788f0c60.jpg","comment_is_top":false,"comment_ctime":1585722715,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585722715","product_id":100039001,"comment_content":"这里有哥问题是ArrayList和LinkedList都是线性的，那么为什么还要使用迭代器模式呢？","like_count":0,"discussions":[{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224971,"discussion_content":"为了统一啊, 其他的容器比如字典, 集合, 都用一样的代码结构来遍历元素. 不过图树这种结构好像一般的编程语言基础库都没有吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586340939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201134,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1585721556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585721556","product_id":100039001,"comment_content":"思考题一：迭代器外部删除元素会导致状态不一致，使得迭代器失效；解决方法是迭代器类提供删除方法。","like_count":0},{"had_liked":false,"id":201090,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1585713841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585713841","product_id":100039001,"comment_content":"对客户端而言，迭代器抽象掉了各种不同的数据结构遍历的底层细节，提供了统一的接口。","like_count":0},{"had_liked":false,"id":201081,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1585713204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585713204","product_id":100039001,"comment_content":"1.因为在一般的迭代器的内部维护了一个记录长度的属性,在进行删除之前,会进行对比,如果发现已经被修改了,那就意味着可能会造成删除了本不应该删得数值了,所以多线程下,考虑使用加锁吧,或者使用原子类<br>2.其实两者实现的功能相同,就是在ResultSet中,将原本的next和hashNext方法进行了集合,这可能是因为数据实际上还是存储在了MySQL中导致的,在遍历获取对应的数据的时候,直接while(rs.next())即可,不需要进行判断即可","like_count":0},{"had_liked":false,"id":200987,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1585703214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585703214","product_id":100039001,"comment_content":"java的迭代器中，容器size是保存在迭代器的变量里面的，如果remove则会导致size变化，所以fail-fast了。","like_count":0},{"had_liked":false,"id":200963,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1585699858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585699858","product_id":100039001,"comment_content":"和map集合一样快速失败机制；给遍历对象加把锁","like_count":0}]}