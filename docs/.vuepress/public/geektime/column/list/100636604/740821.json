{"id":740821,"title":"第 17 章 字符串与文本(2)","content":"<h2 id=\"nav_point_333\">17.4　格式化各种值</h2>\n<p>本书一直在使用像 <code>println!</code> 这样的文本格式化宏：</p>\n<pre class=\"code-rows\"><code>println!(\"{:.3}μs: relocated {} at {:#x} to {:#x}, {} bytes\",\n         0.84391, \"object\",\n         140737488346304_usize, 6299664_usize, 64);</code></pre>\n<p>上述调用会生成如下输出：</p>\n<pre class=\"code-rows\"><code>0.844μs: relocated object at 0x7fffffffdcc0 to 0x602010, 64 bytes</code></pre>\n<p>字符串字面量可以用作输出模板：模板中的每个 <code>{...}</code> 都会被其后跟随的某个参数的格式化形式替换。模板字符串必须是常量，以便 Rust 在编译期根据参数的类型检查它。每个参数在检查时必须都用到，否则 Rust 就会报告编译期错误。</p>\n<p>以下几个标准库特性中都有这种用于格式化字符串的小型语言。</p>\n<ul>\n<li><code>format!</code> 宏会用它来构建 <code>String</code>。</li>\n<li><code>println!</code> 宏和 <code>print!</code> 宏会将格式化后的文本写入标准输出流。</li>\n<li><code>writeln!</code> 宏和 <code>write!</code> 宏会将格式化后的文本写入指定的输出流。</li>\n<li><code>panic!</code> 宏会使用它构建一个信息丰富的异常终止描述。</li>\n</ul>\n<p>Rust 格式化工具的设计是开放式的。你可以通过实现 <code>std::fmt</code> 模块的格式化特型来扩展这些宏以支持自己的类型。也可以使用 <code>format_args!</code> 宏和 <code>std::fmt::Arguments</code> 类型来让自己的函数和宏支持格式化语言。</p>\n<p>格式化宏总会借入对其参数的共享引用，但永远不会拥有或修改它们。</p>\n<p>模板的 <code>{...}</code> 形式称为<strong>格式参数</strong>，具体形式为 <code>{<i>which</i>:<i>how</i>}</code>。<em><code>Which</code></em> 和 <em><code>how</code></em> 都是可选的，很多时候用 <code>{}</code> 就行。</p>\n<p><em><code>which</code></em>（哪个）值用于选择模板后面的哪个实参应该取代该形参的位置。可以按索引或名称选择实参。没有 <em><code>which</code></em> 值的形参只会简单地从左到右与实参配对。</p>\n<p><em><code>how</code></em>（如何）值表示应如何格式化参数：如何填补、精度如何、数值基数等。如果存在 <em><code>how</code></em>，则需要写上前面的冒号。</p>\n<p>表 17-4 给出了一些示例。</p>\n<p><strong>表 17-4：格式化字符串示例</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>模板字符串</p></th>\n<th><p>参数列表</p></th>\n<th><p>结果</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>\"number of {}: {}\"</code></p></td>\n<td><p><code>\"elephants\", 19</code></p></td>\n<td><p><code>\"number of elephants: 19\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>\"from  to \"</code></p></td>\n<td><p><code>\"the grave\", \"the cradle\"</code></p></td>\n<td><p><code>\"from the cradle to the grave\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>\"v = {:?}\"</code></p></td>\n<td><p><code>vec![0,1,2,5,12,29]</code></p></td>\n<td><p><code>\"v = [0, 1, 2, 5, 12, 29]\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>\"name = {:?}\"</code></p></td>\n<td><p><code>\"Nemo\"</code></p></td>\n<td><p><code>\"name = \\\"Nemo\\\"\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>\"{:8.2} km/s\"</code></p></td>\n<td><p><code>11.186</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;11.19 km/s\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>\"{:20} {:02x} {:02x}\"</code></p></td>\n<td><p><code>\"adc #42\", 105, 42</code></p></td>\n<td><p><code>\"adc #42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;69 2a\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>\"  \"</code></p></td>\n<td><p><code>\"adc #42\", 105, 42</code></p></td>\n<td><p><code>\"69 2a adc #42\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>\"  \"</code></p></td>\n<td><p><code>insn=\"adc #42\", lsb=105, msb=42</code></p></td>\n<td><p><code>\"69 2a adc #42\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>\"{:02?}\"</code></p></td>\n<td><p><code>[110, 11, 9]</code></p></td>\n<td><p><code>\"[110, 11, 09]\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>\"{:02x?}\"</code></p></td>\n<td><p><code>[110, 11, 9]</code></p></td>\n<td><p><code>\"[6e, 0b, 09]\"</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>如果要在输出中包含 <code>{</code> 或 <code>}</code> 字符，可将模板中的这些字符连写两个。</p>\n<pre class=\"code-rows\"><code>assert_eq!(format!(\"{} ⊂ {}\"),\n           \" ⊂ \");</code></pre>\n<h3 id=\"nav_point_334\">17.4.1　格式化文本值</h3>\n<p>当格式化像 <code>&amp;str</code> 或 <code>String</code>（将 <code>char</code> 视为单字符字符串）这样的文本类型时，参数的 <em>how</em> 值有几个部分，都是可选的。</p><!-- [[[read_end]]] -->\n<ul>\n<li><strong>文本长度限制</strong>。如果参数比这个值长，Rust 就会截断它。如果未指定限制，Rust 就使用全文。</li>\n<li><strong>最小字段宽度</strong>。在完成所有截断之后，如果参数比这个值短，Rust 就会在右边（默认）用空格（默认）填补它以让字段达到这个宽度。如果省略，Rust 则不会填补参数。</li>\n<li><strong>对齐方式</strong>。如果参数需要填补空白以满足最小字段宽度，那么这个值表示应将文本放置在字段中的什么位置。<code>&lt;</code>、<code>^</code> 和 <code>&gt;</code> 分别会将文本放在开头、中间和结尾。</li>\n<li>在此填补过程中使用的<strong>填补</strong>字符。如果省略，Rust 就会使用空格。如果指定了填补字符，则必须同时指定对齐方式。</li>\n</ul>\n<p>表 17-5 举例说明了如何编写这些格式字符串及其实际效果。所有这些示例都使用了相同的八字符参数 <code>\"bookends\"</code>。</p>\n<p><strong>表 17-5：文本的格式化字符串指令</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>使用的特性</p></th>\n<th><p>模板字符串</p></th>\n<th><p>结果</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>默认</p></td>\n<td><p><code>\"{}\"</code></p></td>\n<td><p><code>\"bookends\"</code></p></td>\n</tr>\n<tr>\n<td><p>最小字段宽度</p></td>\n<td><p><code>\"{:4}\"</code><br /><code>\"{:12}\"</code></p></td>\n<td><p><code>\"bookends\"</code><br /><code>\"bookends&nbsp;&nbsp;&nbsp;&nbsp;\"</code></p></td>\n</tr>\n<tr>\n<td><p>文本长度限制</p></td>\n<td><p><code>\"{:.4}\"</code><br /><code>\"{:.12}\"</code></p></td>\n<td><p><code>\"book\"</code><br /><code>\"bookends\"</code></p></td>\n</tr>\n<tr>\n<td><p>字段宽度、长度限制</p></td>\n<td><p><code>\"{:12.20}\"</code><br /><code>\"{:4.20}\"</code><br /><code>\"{:4.6}\"</code><br /><code>\"{:6.4}\"</code></p></td>\n<td><p><code>\"bookends&nbsp;&nbsp;&nbsp;&nbsp;\"</code><br /><code>\"bookends\"</code><br /><code>\"booken\"</code><br /><code>\"book&nbsp;&nbsp;\"</code></p></td>\n</tr>\n<tr>\n<td><p>左对齐，宽度</p></td>\n<td><p><code>\"{:&lt;12}\"</code></p></td>\n<td><p><code>\"bookends&nbsp;&nbsp;&nbsp;&nbsp;\"</code></p></td>\n</tr>\n<tr>\n<td><p>居中，宽度</p></td>\n<td><p><code>\"{:^12}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;bookends&nbsp;&nbsp;\"</code></p></td>\n</tr>\n<tr>\n<td><p>右对齐，宽度</p></td>\n<td><p><code>\"{:&gt;12}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;bookends\"</code></p></td>\n</tr>\n<tr>\n<td><p>用 <code>'='</code> 填补，居中，宽度</p></td>\n<td><p><code>\"{:=^12}\"</code></p></td>\n<td><p><code>\"==bookends==\"</code></p></td>\n</tr>\n<tr>\n<td><p>用 <code>'*'</code> 填补，右对齐，宽度，限制</p></td>\n<td><p><code>\"{:*&gt;12.4}\"</code></p></td>\n<td><p><code>\"********book\"</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>Rust 的格式化程序对宽度的处理方式比较“简陋”：它假设每个字符占据一列，而不会考虑组合字符、半角片假名、零宽度空格或 Unicode 的其他乱七八糟的情况。例如：</p>\n<pre class=\"code-rows\"><code>assert_eq!(format!(\"{:4}\", \"th\\u\"),   \"th\\u \");\nassert_eq!(format!(\"{:4}\", \"the\\u\"), \"the\\u\");</code></pre>\n<p>尽管 Unicode 规定这两个字符串都等效于 <code>\"thé\"</code>，但 Rust 的格式化程序可不知道像 <code>'\\u'</code> 这样的字符（组合重音符）需要做特殊处理。它正确地填补了第一个字符串，但假设第二个字符串是 4 列宽并且不需要填补。尽管很容易看出 Rust 该如何在这种特定情况下进行改进，但要支持所有 Unicode 脚本的真正多语言文本格式化是一项艰巨的任务。最好依靠所在平台的用户界面工具包来处理，或许也可以通过生成 HTML 和 CSS，让 Web 浏览器来处理。有一个流行的 crate（<code>unicode-width</code>）可以部分处理这个问题。</p>\n<p>除了 <code>&amp;str</code> 和 <code>String</code>，你也可以直接向格式化宏传入带有文本型引用目标的智能指针类型，比如 <code>Rc&lt;String&gt;</code> 或 <code>Cow&lt;'a, str&gt;</code>。</p>\n<p>由于文件名路径不一定是格式良好的 UTF-8，因此 <code>std::path::Path</code> 不完全是文本类型，不能将 <code>std::path::Path</code> 直接传给格式化宏。不过，<code>Path</code> 有个 <code>display</code> 方法会返回一个供格式化的 UTF-8 值，以适合所在平台的方式解决问题。</p>\n<pre class=\"code-rows\"><code>println!(\"processing file: {}\", path.display());</code></pre>\n<h3 id=\"nav_point_335\">17.4.2　格式化数值</h3>\n<p>当格式化参数具有 <code>usize</code> 或 <code>f64</code> 之类的数值类型时，参数的 <em><code>how</code></em> 值可以有如下几个部分，它们全是可选的。</p>\n<ul>\n<li><strong>填补</strong>与<strong>对齐</strong>，它们和对文本类型的含义一样。</li>\n<li><code>+</code> 字符，要求始终显示数值的符号，即使相应参数是正数。</li>\n<li><code>#</code> 字符，要求加显式基数前缀，比如 <code>0x</code> 或 <code>0b</code>。参见稍后要讲的“进制符号”那一项。</li>\n<li><code>0</code> 字符，要求通过在数值中包含前导零（而不是通常的填补方式）来满足最小字段宽度。</li>\n<li><strong>最小字段宽度</strong>。如果格式化后的数值没有这么宽，那么 Rust 会在左侧（默认）用空格（默认）填补它以构成给定宽度的字段。</li>\n<li>浮点参数的<strong>精度</strong>，指示 Rust 应在小数点后包含多少位数字。Rust 会根据需要进行舍入或零扩展以生成要求的小数位。如果省略精度，那么 Rust 会尝试使用尽可能少的数字来准确表示该值。对于整数类型的参数，精度会被忽略。</li>\n<li><strong>进制符号</strong>。对于整数类型，二进制是 <code>b</code>，八进制是 <code>o</code>，十六进制是小写字母 <code>x</code> 或大写字母 <code>X</code>。如果包含 <code>#</code> 字符，则它们会包含显式的 Rust 风格的基数前缀 <code>0b</code>、<code>0o</code>、<code>0x</code> 或 <code>0X</code>。对于浮点类型，<code>e</code> 或 <code>E</code> 的基数需要科学记数法，具有归一化系数，使用 <code>e</code> 或 <code>E</code> 作为指数。如果不指定任何进制符号，则 Rust 会将数值格式化为十进制。</li>\n</ul>\n<p>表 17-6 展示了格式化 <code>i32</code> 值 <code>1234</code> 的一些示例。</p>\n<p><strong>表 17-6：格式化整数的字符串指令</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>使用的特性</p></th>\n<th><p>模板字符串</p></th>\n<th><p>结果</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>默认</p></td>\n<td><p><code>\"{}\"</code></p></td>\n<td><p><code>\"1234\"</code></p></td>\n</tr>\n<tr>\n<td><p>强制正负号</p></td>\n<td><p><code>\"{:+}\"</code></p></td>\n<td><p><code>\"+1234\"</code></p></td>\n</tr>\n<tr>\n<td><p>最小字段宽度</p></td>\n<td><p><code>\"{:12}\"</code><br /><code>\"{:2}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1234\"</code><br /><code>\"1234\"</code></p></td>\n</tr>\n<tr>\n<td><p>正负号，宽度</p></td>\n<td><p><code>\"{:+12}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1234\"</code></p></td>\n</tr>\n<tr>\n<td><p>前导零，宽度</p></td>\n<td><p><code>\"{:012}\"</code></p></td>\n<td><p><code>\"000000001234\"</code></p></td>\n</tr>\n<tr>\n<td><p>正负号，前导零，宽度</p></td>\n<td><p><code>\"{:+012}\"</code></p></td>\n<td><p><code>\"+00000001234\"</code></p></td>\n</tr>\n<tr>\n<td><p>左对齐，宽度</p></td>\n<td><p><code>\"{:&lt;12}\"</code></p></td>\n<td><p><code>\"1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"</code></p></td>\n</tr>\n<tr>\n<td><p>居中，宽度</p></td>\n<td><p><code>\"{:^12}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;1234&nbsp;&nbsp;&nbsp;&nbsp;\"</code></p></td>\n</tr>\n<tr>\n<td><p>右对齐，宽度</p></td>\n<td><p><code>\"{:&gt;12}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1234\"</code></p></td>\n</tr>\n<tr>\n<td><p>左对齐，正负号，宽度</p></td>\n<td><p><code>\"{:&lt;+12}\"</code></p></td>\n<td><p><code>\"+1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"</code></p></td>\n</tr>\n<tr>\n<td><p>居中，正负号，宽度</p></td>\n<td><p><code>\"{:^+12}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;+1234&nbsp;&nbsp;&nbsp;&nbsp;\"</code></p></td>\n</tr>\n<tr>\n<td><p>右对齐，正负号，宽度</p></td>\n<td><p><code>\"{:&gt;+12}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1234\"</code></p></td>\n</tr>\n<tr>\n<td><p>用 <code>'='</code> 填补，居中，宽度</p></td>\n<td><p><code>\"{:=^12}\"</code></p></td>\n<td><p><code>\"====1234====\"</code></p></td>\n</tr>\n<tr>\n<td><p>二进制表示法</p></td>\n<td><p><code>\"{:b}\"</code></p></td>\n<td><p><code>\"10011010010\"</code></p></td>\n</tr>\n<tr>\n<td><p>宽度，八进制表示法</p></td>\n<td><p><code>\"{:12o}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2322\"</code></p></td>\n</tr>\n<tr>\n<td><p>正负号，宽度，十六进制表示法</p></td>\n<td><p><code>\"{:+12x}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+4d2\"</code></p></td>\n</tr>\n<tr>\n<td><p>正负号，宽度，用大写数字的十六进制</p></td>\n<td><p><code>\"{:+12X}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+4D2\"</code></p></td>\n</tr>\n<tr>\n<td><p>正负号，显式基数前缀，宽度，十六进制</p></td>\n<td><p><code>\"{:+#12x}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0x4d2\"</code></p></td>\n</tr>\n<tr>\n<td><p>正负号，基数，前导零，宽度，十六进制</p></td>\n<td><p><code>\"{:+#012x}\"</code><br /><code>\"{:+#06x}\"</code></p></td>\n<td><p><code>\"+0x0000004d2\"</code><br /><code>\"+0x4d2\"</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>如最后两个例子所示，最小字段宽度适用于整个数值、正负号、基数前缀等。</p>\n<p>负数总是包含它们的符号。结果和“强制正负号”例子中展示的一样。</p>\n<p>当你要求加前导零时，就会忽略对齐和填补字符，因为要用零扩展数值以填补整个字段。</p>\n<p>使用参数 <code>1234.5678</code>，可以展示对浮点类型的格式化效果，如表 17-7 所示。</p>\n<p><strong>表 17-7：格式化浮点数的字符串指令</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>使用的特性</p></th>\n<th><p>模板字符串</p></th>\n<th><p>结果</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>默认</p></td>\n<td><p><code>\"{}\"</code></p></td>\n<td><p><code>\"1234.5678\"</code></p></td>\n</tr>\n<tr>\n<td><p>精度</p></td>\n<td><p><code>\"{:.2}\"</code><br /><code>\"{:.6}\"</code></p></td>\n<td><p><code>\"1234.57\"</code><br /><code>\"1234.567800\"</code></p></td>\n</tr>\n<tr>\n<td><p>最小字段宽度</p></td>\n<td><p><code>\"{:12}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;1234.5678\"</code></p></td>\n</tr>\n<tr>\n<td><p>最小宽度，精度</p></td>\n<td><p><code>\"{:12.2}\"</code><br /><code>\"{:12.6}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1234.57\"</code><br /><code>\" 1234.567800\"</code></p></td>\n</tr>\n<tr>\n<td><p>前导零，最小宽度，精度</p></td>\n<td><p><code>\"{:012.6}\"</code></p></td>\n<td><p><code>\"01234.567800\"</code></p></td>\n</tr>\n<tr>\n<td><p>科学记数法</p></td>\n<td><p><code>\"{:e}\"</code></p></td>\n<td><p><code>\"1.2345678e3\"</code></p></td>\n</tr>\n<tr>\n<td><p>科学记数法，精度</p></td>\n<td><p><code>\"{:.3e}\"</code></p></td>\n<td><p><code>\"1.235e3\"</code></p></td>\n</tr>\n<tr>\n<td><p>科学记数法，最小宽度，精度</p></td>\n<td><p><code>\"{:12.3e}\"</code><br /><code>\"{:12.3E}\"</code></p></td>\n<td><p><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.235e3\"</code><br /><code>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.235E3\"</code></p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_336\">17.4.3　格式化其他类型</h3>\n<p>除了字符串和数值，还可以格式化标准库中的其他几种类型。</p>\n<ul>\n<li>错误类型全都可以直接格式化，从而很容易地将它们包含在错误消息中。每种错误类型都应该实现 <code>std::error::Error</code> 特型，该特型扩展了默认格式化特型 <code>std::fmt::Display</code>。因此，任何实现了 <code>Error</code> 的类型都可以格式化。</li>\n<li>可以格式化 <code>std::net::IpAddr</code>、<code>std::net::SocketAddr</code> 等互联网协议地址类型。</li>\n<li>布尔值 <code>true</code> 和 <code>false</code> 也可以被格式化，虽然它们通常不是直接呈现给最终用户的最佳格式。</li>\n</ul>\n<p>对上述类型来说，应该使用与字符串相同类型的格式参数。长度限制、字段宽度和对齐方式控制都会如预期般工作。</p>\n<h3 id=\"nav_point_337\">17.4.4　格式化值以进行调试</h3>\n<p>为了帮助调试和记录日志，<code>{:?}</code> 参数能以对程序员有帮助的方式格式化 Rust 标准库中的任何公共类型。你可以使用它来检查向量、切片、元组、哈希表、线程和其他数百种类型。</p>\n<p>例如，你可以编写如下代码：</p>\n<pre class=\"code-rows\"><code>use std::collections::HashMap;\nlet mut map = HashMap::new();\nmap.insert(\"Portland\", (45.5237606,-122.6819273));\nmap.insert(\"Shanghai\", (31.230416, 121.473701));\nprintln!(\"{:?}\", map);</code></pre>\n<p>这会打印出如下内容：</p>\n<pre class=\"code-rows\"><code>{\"Shanghai\": (31.230416, 121.473701), \"Portland\": (45.5237606, -122.6819273)}</code></pre>\n<p><code>HashMap</code> 和 <code>(f64, f64)</code> 类型都知道该如何格式化自身，你无须额外做什么。</p>\n<p>如果你在格式参数中包含了 <code>#</code> 字符，Rust 就会优美地打印出该值。将上面那行代码改成 <code>println!(\"{:#?}\", map)</code> 会输出如下内容：</p>\n<pre class=\"code-rows\"><code>{\n    \"Shanghai\": (\n        31.230416,\n        121.473701\n    ),\n    \"Portland\": (\n        45.5237606,\n        -122.6819273\n    )\n}</code></pre>\n<p>这些输出的精确格式并不能保证始终如一，比如升级 Rust 版本后就可能发生变化。</p>\n<p>供调试用的格式化通常会以十进制打印数值，但可以在问号前放置一个 <code>x</code> 或 <code>X</code> 以请求十六进制，并且会遵守前导零和字段宽度语法。例如，可以像下面这样写：</p>\n<pre class=\"code-rows\"><code>println!(\"ordinary: {:02?}\", [9, 15, 240]);\nprintln!(\"hex:      {:02x?}\", [9, 15, 240]);</code></pre>\n<p>这会打印出如下内容：</p>\n<pre class=\"code-rows\"><code>ordinary: [09, 15, 240]\nhex:      [09, 0f, f0]</code></pre>\n<p>如前所述，你可以用 <code>#[derive(Debug)]</code> 语法让自己的类型支持 <code>{:?}</code>：</p>\n<pre class=\"code-rows\"><code>#[derive(Copy, Clone, Debug)]\nstruct Complex { re: f64, im: f64 }</code></pre>\n<p>有了这个定义，就可以使用 <code>{:?}</code> 格式来打印 <code>Complex</code> 值了：</p>\n<pre class=\"code-rows\"><code>let third = Complex { re: -0.5, im: f64::sqrt(0.75) };\nprintln!(\"{:?}\", third);</code></pre>\n<p>这会打印出如下内容：</p>\n<pre class=\"code-rows\"><code>Complex { re: -0.5, im: 0.8660254037844386 }</code></pre>\n<p>这对调试来说已经很好了，但如果能用 <code>{}</code> 以更传统的形式（如 <code>-0.5 + 0.8660254037844386i</code>）打印它们就更好了。17.4.8 会展示如何做到这一点。</p>\n<h3 id=\"nav_point_338\">17.4.5　格式化指针以进行调试</h3>\n<p>正常情况下，如果将任何种类的指针传给格式化宏（引用、<code>Box</code> 或 <code>Rc</code>），宏都会简单地追踪指针并格式化它的引用目标，指针本身并不重要。但是在调试时，查看指针有时很有帮助：地址可以用作单个值的粗略“名称”，这在检查含有循环或共享指针的结构体时可能很有帮助。</p>\n<p><code>{:p}</code> 表示法会将引用、<code>Box</code> 和其他类似指针的类型格式化为地址：</p>\n<pre class=\"code-rows\"><code>use std::rc::Rc;\nlet original = Rc::new(\"mazurka\".to_string());\nlet cloned = original.clone();\nlet impostor = Rc::new(\"mazurka\".to_string());\nprintln!(\"text:     {}, {}, {}\",       original, cloned, impostor);\nprintln!(\"pointers: {:p}, {:p}, {:p}\", original, cloned, impostor);</code></pre>\n<p>这会打印出如下内容：</p>\n<pre class=\"code-rows\"><code>text:     mazurka, mazurka, mazurka\npointers: 0x7f99af80e000, 0x7f99af80e000, 0x7f99af80e030</code></pre>\n<p>当然，具体的指针值每次运行时可能都不一样，但即便如此，比较这些地址也能清晰地看出前两个是对同一个 <code>String</code> 的引用，而第三个指向了不同的值。</p>\n<p>地址确实看起来是可读性很差的十六进制，因此更精致的展现形式可能会更有用，但 <code>{:p}</code> 样式仍然是一种有效的快速解决方案。</p>\n<h3 id=\"nav_point_339\">17.4.6　按索引或名称引用参数</h3>\n<p>格式参数可以明确选择它要使用的参数。例如：</p>\n<pre class=\"code-rows\"><code>assert_eq!(format!(\",,\", \"zeroth\", \"first\", \"second\"),\n           \"first,zeroth,second\");</code></pre>\n<p>可以在冒号后包含格式参数：</p>\n<pre class=\"code-rows\"><code>assert_eq!(format!(\",,\", \"first\", 10, 100),\n           \"0x0064,1010,=====first\");</code></pre>\n<p>还可以按名称选择参数。这能让有许多参数的复杂模板更加清晰易读。例如：</p>\n<pre class=\"code-rows\"><code>assert_eq!(format!(\" @ \",\n                   price=3.25,\n                   quantity=3,\n                   description=\"Maple Turmeric Latte\"),\n           \"Maple Turmeric Latte..... 3 @  3.25\");</code></pre>\n<p>（这里的命名型参数类似于 Python 中的关键字参数，但它们只是这些格式化宏的独有特性，而不是 Rust 函数调用语法的一部分。）</p>\n<p>可以在单个格式化宏中将索引型参数、命名型参数和位置型（没有索引或名称的）参数混用。位置型参数会从左到右与参数配对，就仿佛索引型参数和命名型参数不存在一样（不参与位置编号）：</p>\n<pre class=\"code-rows\"><code>assert_eq!(format!(\"  {} {}\",\n                   \"people\", \"eater\", \"purple\", mode=\"flying\"),\n           \"flying purple people eater\");</code></pre>\n<p>命名型参数必须出现在列表的末尾。</p>\n<h3 id=\"nav_point_340\">17.4.7　动态宽度与动态精度</h3>\n<p>参数的最小字段宽度、文本长度限制和数值精度不必总是固定值，也可以在运行期进行选择。</p>\n<p>我们一直在研究类似于下面这个表达式的情况，它会生成在 20 个字符宽的字段中右对齐的字符串 <code>content</code>：</p>\n<pre class=\"code-rows\"><code>format!(\"{:&gt;20}\", content)</code></pre>\n<p>但是，如果想在运行期选择字段宽度，则可以这样写：</p>\n<pre class=\"code-rows\"><code>format!(\"{:&gt;1$}\", content, get_width())</code></pre>\n<p>将最小字段宽度写成 <code>1$</code> 就是在告诉 <code>format!</code> 使用第二个参数的值作为宽度。它引用的参数必须是 <code>usize</code>。还可以按名称引用参数：</p>\n<pre class=\"code-rows\"><code>format!(\"{:&gt;width$}\", content, width=get_width())</code></pre>\n<p>同样的方法也适用于文本长度限制：</p>\n<pre class=\"code-rows\"><code>format!(\"{:&gt;width$.limit$}\", content,\n        width=get_width(), limit=get_limit())</code></pre>\n<p>要代替文本长度限制或浮点精度，还可以写成 <code>*</code>，表示将下一个位置参数作为精度。下面的代码会把 <code>content</code> 裁剪成最多 <code>get_limit()</code> 个字符：</p>\n<pre class=\"code-rows\"><code>format!(\"{:.*}\", get_limit(), content)</code></pre>\n<p>用作精度的参数必须是 <code>usize</code>。字段宽度没有对应的语法。</p>\n<h3 id=\"nav_point_341\">17.4.8　格式化自己的类型</h3>\n<p>格式化宏会使用 <code>std::fmt</code> 模块中定义的一组特型将值转换为文本。通过自行实现这些特型中的一个或多个，就可以让 Rust 的格式化宏来格式化你的类型。</p>\n<p>格式参数中的符号指示了其参数类型必须实现的特型，如表 17-8 所示。</p>\n<p><strong>表 17-8：格式化字符串指令符号</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>符号</p></th>\n<th><p>例子</p></th>\n<th><p>特型</p></th>\n<th><p>目的</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>无</p></td>\n<td><p><code>{}</code></p></td>\n<td><p><code>std::fmt::Display</code></p></td>\n<td><p>文本、数值、错误：通用特型</p></td>\n</tr>\n<tr>\n<td><p><code>b</code></p></td>\n<td><p><code></code></p></td>\n<td><p><code>std::fmt::Binary</code></p></td>\n<td><p>二进制中的数值</p></td>\n</tr>\n<tr>\n<td><p><code>o</code></p></td>\n<td><p><code>{:#5o}</code></p></td>\n<td><p><code>std::fmt::Octal</code></p></td>\n<td><p>八进制中的数值</p></td>\n</tr>\n<tr>\n<td><p><code>x</code></p></td>\n<td><p><code>{:4x}</code></p></td>\n<td><p><code>std::fmt::LowerHex</code></p></td>\n<td><p>十六进制中的数值，小写数字</p></td>\n</tr>\n<tr>\n<td><p><code>X</code></p></td>\n<td><p><code>{:016X}</code></p></td>\n<td><p><code>std::fmt::UpperHex</code></p></td>\n<td><p>十六进制中的数值，大写数字</p></td>\n</tr>\n<tr>\n<td><p><code>e</code></p></td>\n<td><p><code>{:.3e}</code></p></td>\n<td><p><code>std::fmt::LowerExp</code></p></td>\n<td><p>科学记数法中的浮点数值</p></td>\n</tr>\n<tr>\n<td><p><code>E</code></p></td>\n<td><p><code>{:.3E}</code></p></td>\n<td><p><code>std::fmt::UpperExp</code></p></td>\n<td><p>同上，但大写 <code>E</code></p></td>\n</tr>\n<tr>\n<td><p><code>?</code></p></td>\n<td><p><code>{:#?}</code></p></td>\n<td><p><code>std::fmt::Debug</code></p></td>\n<td><p>调试视图，适用于开发人员</p></td>\n</tr>\n<tr>\n<td><p><code>p</code></p></td>\n<td><p><code>{:p}</code></p></td>\n<td><p><code>std::fmt::Pointer</code></p></td>\n<td><p>将指针作为地址，适用于开发人员</p></td>\n</tr>\n</tbody>\n</table>\n<p>当你将 <code>#[derive(Debug)]</code> 属性放在类型定义上，以期支持 <code>{:?}</code> 格式参数时，其实只是在要求 Rust 替你实现 <code>std::fmt::Debug</code> 特型。</p>\n<p>这些格式化特型都具有相同的结构，只是名称不同而已。我们将以 <code>std::fmt::Display</code> 为代表来讲解：</p>\n<pre class=\"code-rows\"><code>trait Display {\n    fn fmt(&amp;self, dest: &amp;mut std::fmt::Formatter)\n        -&gt; std::fmt::Result;\n}</code></pre>\n<p><code>fmt</code> 方法的任务是为 <code>self</code> 生成格式良好的表达形式并将其字符写入 <code>dest</code>。除了用作输出流，<code>dest</code> 参数还携带着从格式参数解析出的详细信息，比如对齐方式和最小字段宽度。</p>\n<p>例如，本章前面曾建议，如果 <code>Complex</code> 值能以通常的 <code>a + bi</code> 形式打印自己则会更好。下面是执行本操作的 <code>Display</code> 实现：</p>\n<pre class=\"code-rows\"><code>use std::fmt;\n\nimpl fmt::Display for Complex {\n    fn fmt(&amp;self, dest: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let im_sign = if self.im &lt; 0.0 { '-' } else { '+' };\n        write!(dest, \"{} {} {}i\", self.re, im_sign, f64::abs(self.im))\n    }\n}</code></pre>\n<p>这利用了 <code>Formatter</code> 本身就是一个输出流的事实，所以 <code>write!</code> 宏可以帮我们完成大部分工作。有了这个实现，就可以写出如下代码了：</p>\n<pre class=\"code-rows\"><code>let one_twenty = Complex { re: -0.5, im: 0.866 };\nassert_eq!(format!(\"{}\", one_twenty),\n           \"-0.5 + 0.866i\");\n\nlet two_forty = Complex { re: -0.5, im: -0.866 };\nassert_eq!(format!(\"{}\", two_forty),\n           \"-0.5 - 0.866i\");</code></pre>\n<p>有时以极坐标形式显示复数会很有帮助：想象在复平面上画一条从原点到数值的线，极坐标形式会给出线的长度，以及线与正向 <em>x</em> 轴之间的顺时针夹角。格式参数中的 <code>#</code> 字符通常会选择某种替代的显示形式，<code>Display</code> 实现可以将其视为要求使用极坐标形式：</p>\n<pre class=\"code-rows\"><code>impl fmt::Display for Complex {\n    fn fmt(&amp;self, dest: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let (re, im) = (self.re, self.im);\n        if dest.alternate() {\n            let abs = f64::sqrt(re * re + im * im);\n            let angle = f64::atan2(im, re) / std::f64::consts::PI * 180.0;\n            write!(dest, \"{} ∠ {}°\", abs, angle)\n        } else {\n            let im_sign = if im &lt; 0.0 { '-' } else { '+' };\n            write!(dest, \"{} {} {}i\", re, im_sign, f64::abs(im))\n        }\n    }\n}</code></pre>\n<p>使用此实现的代码如下所示：</p>\n<pre class=\"code-rows\"><code>let ninety = Complex { re: 0.0, im: 2.0 };\nassert_eq!(format!(\"{}\", ninety),\n           \"0 + 2i\");\nassert_eq!(format!(\"{:#}\", ninety),\n           \"2 ∠ 90°\");</code></pre>\n<p>尽管格式化特型的 <code>fmt</code> 方法会返回一个 <code>fmt::Result</code> 值（典型的模块专属的 <code>Result</code> 类型），但你只能从 <code>Formatter</code> 的操作中开始传播错误，就像刚才 <code>fmt::Display</code> 的实现中调用 <code>write!</code> 时的做法那样。你的格式化函数自身不应该引发错误。这样像 <code>format!</code> 这样的宏就可以简单地返回一个 <code>String</code> 而非 <code>Result&lt;String, ...&gt;</code>，因为将格式化后的文本追加到 <code>String</code> 上永远不会出错。这还会确保你从 <code>write!</code> 或 <code>writeln!</code> 上抛出的错误总能正确地反映出底层 I/O 流的实际问题，而不是某种格式问题。</p>\n<p><code>Formatter</code> 还有许多其他的有用的方法，包括一些用于处理结构化数据（如映射、列表等）的方法，本书并没有介绍它们，有关详细信息，请参阅在线文档。</p>\n<h3 id=\"nav_point_342\">17.4.9　在自己的代码中使用格式化语言</h3>\n<p>使用 Rust 的 <code>format_args!</code> 宏和 <code>std::fmt::Arguments</code> 类型，你可以编写能接受格式模板和参数的自定义函数和宏。假设你的程序需要在运行期记录状态消息，并且你想使用 Rust 的文本格式化语言来生成这些消息，那么可以参考以下代码：</p>\n<pre class=\"code-rows\"><code>fn logging_enabled() -&gt; bool { ... }\n\nuse std::fs::OpenOptions;\nuse std::io::Write;\n\nfn write_log_entry(entry: std::fmt::Arguments) {\n    if logging_enabled() {\n        // 尽量保持简单，所以每次只是打开文件\n        let mut log_file = OpenOptions::new()\n            .append(true)\n            .create(true)\n            .open(\"log-file-name\")\n            .expect(\"failed to open log file\");\n\n        log_file.write_fmt(entry)\n            .expect(\"failed to write to log\");\n    }\n}</code></pre>\n<p>可以像这样调用 <code>write_log_entry</code>：</p>\n<pre class=\"code-rows\"><code>write_log_entry(format_args!(\"Hark! {:?}\\n\", mysterious_value));</code></pre>\n<p>在编译期，<code>format_args!</code> 宏会解析模板字符串并据此检查参数的类型，如果有任何问题则报告错误。在运行期，它会对参数求值并构建一个 <code>Arguments</code> 值，其中包含格式化文本时需要的所有信息：模板的预解析形式，以及对参数值的共享引用。</p>\n<p>构造一个 <code>Arguments</code> 值的代价很低：只是收集一些指针而已。这时尚未进行任何格式化工作，仅收集稍后要用到的信息。这很重要，否则如果未启用日志，那么像把数值转换为十进制、填补值之类的任何开销都会白白浪费。</p>\n<p><code>File</code> 类型实现了 <code>std::io::Write</code> 特型，该特型的 <code>write_fmt</code> 方法会接受一个 <code>Argument</code> 并进行格式化，然后会将结果写入底层流。</p>\n<p>对 <code>write_log_entry</code> 的调用并不漂亮。这时宏就可以大显身手了：</p>\n<pre class=\"code-rows\"><code>macro_rules! log { // 在宏定义中的宏名后不需要叹号（!）\n    ($format:tt, $($arg:expr),*) =&gt; (\n        write_log_entry(format_args!($format, $($arg),*))\n    )\n}</code></pre>\n<p>第 21 章会详细介绍宏。现在，你只需知道这定义了一个新 <code>log!</code> 宏并将其参数传给 <code>format_args!</code>，然后在生成的 <code>Arguments</code> 值上调用 <code>write_log_entry</code> 函数即可。诸如 <code>println!</code>，<code>writeln!</code> 和 <code>format!</code> 之类的格式化宏都采用了大致相同的思路。</p>\n<p>可以像这样使用 <code>log!</code>：</p>\n<pre class=\"code-rows\"><code>log!(\"O day and night, but this is wondrous strange! {:?}\\n\",\n     mysterious_value);</code></pre>\n<p>理论上，这会好看一点儿。</p>\n<h2 id=\"nav_point_343\">17.5　正则表达式</h2>\n<p>外部的 <code>regex</code> crate 是 Rust 的官方正则表达式库，它提供了通常的搜索函数和匹配函数。该库对 Unicode 有很好的支持，但它也可以搜索字节串。尽管不支持其他正则表达式包中的某些特性（比如反向引用和环视模式），但这些简化允许 <code>regex</code> 确保搜索时间始终与表达式的大小、表达式的长度和待搜文本的长度呈线性关系。此外，这些保证还让 <code>regex</code> 即使在搜索不可信文本的不可信表达式时也能安全地使用。</p>\n<p>本书将只提供 <code>regex</code> 的概述。有关详细信息，可以查阅其在线文档。</p>\n<p>尽管 <code>regex</code> crate 不在 <code>std</code> 中，但它是由 Rust 库团队维护的，该团队也负责维护标准库 <code>std</code>。要使用 <code>regex</code>，请将下面这行代码放在 crate 的 Cargo.toml 文件的 <code>[dependencies]</code> 部分：</p>\n<pre class=\"code-rows\"><code>regex = \"1\"</code></pre>\n<p>在以下内容中，我们将假设你已做完了此项更改。</p>\n<h3 id=\"nav_point_344\">17.5.1　<code>Regex</code> 的基本用法</h3>\n<p><code>Regex</code> 值表示已经解析好的正则表达式。<code>Regex::new</code> 构造函数会尝试将 <code>&amp;str</code> 解析为正则表达式，并返回一个 <code>Result</code>：</p>\n<pre class=\"code-rows\"><code>use regex::Regex;\n\n// 语义化版本号，比如0.2.1\n// 可以包含预发行版本后缀，比如0.2.1-alpha\n// （为简洁起见，没有“构建编号”元信息后缀）\n//\n// 注意，使用原始字符串语法r\"...\"是为了避免一大堆反斜杠\nlet semver = Regex::new(r\"(\\d+)\\.(\\d+)\\.(\\d+)(-[-.[:alnum:]]*)?\")?;\n\n// 简单搜索，返回布尔型结果\nlet haystack = r#\"regex = \"0.2.5\"\"#;\nassert!(semver.is_match(haystack));</code></pre>\n<p><code>Regex::captures</code> 方法会在字符串中搜索第一个匹配项并返回一个 <code>regex::Captures</code> 值，其中包含表达式中每个组的匹配信息：</p>\n<pre class=\"code-rows\"><code>// 可以检索各个捕获组：\nlet captures = semver.captures(haystack)\n    .ok_or(\"semver regex should have matched\")?;\nassert_eq!(&amp;captures[0], \"0.2.5\");\nassert_eq!(&amp;captures[1], \"0\");\nassert_eq!(&amp;captures[2], \"2\");\nassert_eq!(&amp;captures[3], \"5\");</code></pre>\n<p>如果所请求的组不匹配，则对 <code>Captures</code> 值进行索引就会出现 panic。要测试特定组是否匹配，可以调用 <code>Captures::get</code>，它会返回 <code>Option&lt;regex::Match&gt;</code>，其中的 <code>Match</code> 值会记录单个组的匹配信息：</p>\n<pre class=\"code-rows\"><code>assert_eq!(captures.get(4), None);\nassert_eq!(captures.get(3).unwrap().start(), 13);\nassert_eq!(captures.get(3).unwrap().end(), 14);\nassert_eq!(captures.get(3).unwrap().as_str(), \"5\");</code></pre>\n<p>可以遍历字符串中的所有匹配项：</p>\n<pre class=\"code-rows\"><code>let haystack = \"In the beginning, there was 1.0.0. \\\n                For a while, we used 1.0.1-beta, \\\n                but in the end, we settled on 1.2.4.\";\n\nlet matches: Vec&lt;&amp;str&gt; = semver.find_iter(haystack)\n    .map(|match_| match_.as_str())\n    .collect();\nassert_eq!(matches, vec![\"1.0.0\", \"1.0.1-beta\", \"1.2.4\"]);</code></pre>\n<p><code>find_iter</code> 迭代器会为表达式的每个非重叠匹配生成一个 <code>Match</code> 值，从字符串的开头走到结尾。<code>captures_iter</code> 方法也类似，但会生成记录了所有捕获组的 <code>captures</code> 值。当必须报告出捕获组时搜索速度会变慢，因此如果并不实际需要捕获组，那么最好使用某个不返回它们的方法。</p>\n<h3 id=\"nav_point_345\">17.5.2　惰性构建正则表达式值</h3>\n<p><code>Regex::new</code> 构造函数的开销可能很高：在速度较快的开发机器上为 1200 个字符的正则表达式构造一个 <code>Regex</code> 会花费差不多 1 毫秒时间，即使是一个微不足道的表达式也要花费几微秒时间。最好让 <code>Regex</code> 构造远离繁重的计算循环，这就意味着应该只构建一次 <code>Regex</code>，然后重复使用它。</p>\n<p><code>lazy_static</code> crate 提供了一种在首次使用时惰性构造静态值的好办法。首先，请注意 Cargo.toml 文件中的依赖项：</p>\n<pre class=\"code-rows\"><code>[dependencies]\nlazy_static = \"1\"</code></pre>\n<p>这个 crate 提供了一个宏来声明这样的变量：</p>\n<pre class=\"code-rows\"><code>use lazy_static::lazy_static;\n\nlazy_static! {\n    static ref SEMVER: Regex\n        = Regex::new(r\"(\\d+)\\.(\\d+)\\.(\\d+)(-[-.[:alnum:]]*)?\")\n              .expect(\"error parsing regex\");\n}</code></pre>\n<p>该宏会扩展成名为 <code>SEMVER</code> 的静态变量的声明，但其类型不完全是 <code>Regex</code>，而是一个实现了 <code>Deref&lt;Target=Regex&gt;</code> 的由宏生成的类型，并公开了与 <code>Regex</code> 相同的全部方法。第一次解引用 <code>SEMVER</code> 时，会执行初始化程序，并保存该值供以后使用。由于 <code>SEMVER</code> 是一个静态变量，而不仅仅是局部变量，因此每次执行程序时初始化器都最多运行一次。</p>\n<p>有了这个声明，使用 <code>SEMVER</code> 就很简单了：</p>\n<pre class=\"code-rows\"><code>use std::io::BufRead;\n\nlet stdin = std::io::stdin();\nfor line_result in stdin.lock().lines() {\n    let line = line_result?;\n    if let Some(match_) = SEMVER.find(&amp;line) {\n        println!(\"{}\", match_.as_str());\n    }\n}</code></pre>\n<p>可以把 <code>lazy_static!</code> 声明放在模块中，甚至可以放在使用 <code>Regex</code> 的函数内部（如果这就是最合适的作用域的话）。无论采用哪种方式，每当程序执行时，正则表达式都只会编译一次。</p>\n<h2 id=\"nav_point_346\">17.6　规范化</h2>\n<p>大多数用户误以为法语单词 thé（意为“茶”）的长度是 3 个字符。然而，Unicode 实际上有两种方式来表示这个单词。</p>\n<ul>\n<li>在<strong>组合</strong>形式中，“thé”包含 3 个字符，即 <code>'t'</code>、<code>'h'</code> 和 <code>'é'</code>，其中 <code>'é'</code> 是码点为 <code>0xe9</code> 的单个 Unicode 字符。</li>\n<li>在<strong>分解</strong>形式中，“thé”包含 4 个字符，即 <code>'t'</code>、<code>'h'</code>、<code>'e'</code> 和 <code>'\\u'</code>，其中的 <code>'e'</code> 是纯 ASCII 字符，没有重音符号，而码点 <code>0x301</code> 是“结合性锐音符号”字符，它会为它前面的任意字符添加一个锐音符号。</li>\n</ul>\n<p>Unicode 并不认为 é 的组合形式或分解形式是“正确的”形式，相反，它认为它们是同一抽象字符的等价表示。Unicode 规定这两种形式应该以相同的方式显示，并且允许文本输入法生成任何一种形式，因此用户通常不知道他们正在查看或输入的是哪种形式。（Rust 允许直接在字符串字面量中使用 Unicode 字符，因此如果不关心自己获得的是哪种编码，则可以简单地写成 <code>\"thé\"</code>。但为了清楚起见，这里我们会使用 <code>\\u</code> 转义符。）</p>\n<p>然而，作为 Rust 的 <code>&amp;str</code> 值或 <code>String</code> 值，<code>\"th\\u\"</code> 和 <code>\"the\\u\"</code> 是完全不同的。它们具有不同的长度，比较起来不相等，具有不同的哈希值，并且相对于其他字符串会以不同的方式排序：</p>\n<pre class=\"code-rows\"><code>assert!(\"th\\u\" != \"the\\u\");\nassert!(\"th\\u\" &gt;  \"the\\u\");\n\n// 哈希器旨在累积求出一系列值的哈希值，因此仅哈希一个值有点儿大材小用\nuse std::hash::;\nuse std::collections::hash_map::DefaultHasher;\nfn hash&lt;T: ?Sized + Hash&gt;(t: &amp;T) -&gt; u64 {\n    let mut s = DefaultHasher::new();\n    t.hash(&amp;mut s);\n    s.finish()\n}\n\n// 这些值可能会在将来的Rust版本中发生变化\nassert_eq!(hash(\"th\\u\"),   0x53e2d0734eb1dff3);\nassert_eq!(hash(\"the\\u\"), 0x90d837f0a0928144);</code></pre>\n<p>显然，如果打算比较用户提供的文本或者将其用作哈希表或 B 树中的键，则需要先将每个字符串转换成某种规范形式。</p>\n<p>幸运的是，Unicode 指定了字符串的<strong>规范化</strong>形式。每当根据 Unicode 规则应将两个字符串视为等同时，它们的规范化形式是逐字符全同的。当使用 UTF-8 编码时，它们是逐字节全同的。这意味着可以使用 <code>==</code> 来比较规范化后的字符串，可以将它们用作 <code>HashMap</code> 或 <code>HashSet</code> 中的键，等等，这样就能获得 Unicode 规定的相等性概念了。</p>\n<p>如果未做规范化，则甚至会产生安全隐患。如果你的网站对用户名在某些情况下做了规范化，但在其他情况下未做规范化，那么最终可能会出现两个名为 <code>bananasflambé</code> 的不同用户，你的一部分代码会将其视为同一用户，但另一部分代码会认为这是两个用户，导致一个人的权限被错误地扩展到另一个人身上。当然，有很多方法可以避开这种问题，但历史表明也有很多方法不能避开。</p>\n<h3 id=\"nav_point_347\">17.6.1　规范化形式</h3>\n<p>Unicode 定义了 4 种规范化形式，每一种都适用于不同的用途。这里要回答两个问题。</p>\n<ul>\n<li><p>第一个问题是：你更喜欢让字符尽可能<strong>组合</strong>还是尽可能<strong>分解</strong>？\n̛̛\n例如，越南语单词 Phở 最常用的组合表示是三字符字符串 <code>\"Ph\\u\"</code>，其中声调标记 &nbsp;&#777; 和元音标记 &#795;&nbsp; 都应用于基本字符“o”上，而其单个 Unicode 字符是 <code>'\\u'</code>，Unicode 很质朴地将其命名为“带角和钩形的拉丁文小写字母 o”。</p>\n<p>最常用的分解表示是将基本字母及其两个标记拆分为 3 个单独的 Unicode 字符：<code>'o'</code>、<code>'\\u'</code>（组合角符）和 <code>'\\u'</code>（组合上钩符），其结果就是 <code>\"Pho\\u\\u\"</code>。（每当组合标记作为单独的字符出现，而不是作为组合字符的一部分时，所有规范化形式都指定了它们必须以固定顺序出现，因此即使字符有多个重音符号，也能很好地进行规范化。）</p>\n<p>组合形式通常具有较少的兼容性问题，因为它更接近于在 Unicode 建立之前用于其文本的大多数语言的表示。它也可以更好地与简单的字符串格式化特性（如 Rust 的 <code>format!</code> 宏）协作。而分解形式可能更适合显示文本或搜索，因为它使文本的详细结构更加明确。</p>\n<p>&nbsp;</p>\n</li>\n<li><p>第二个问题是：如果两个字符序列表示相同的基础文本，但文本的格式化方式不同，那么你是要将它们视为等同的还是坚持认为有差异？</p>\n<p>Unicode 对普通数字 <code>5</code>、上标数字 <code>⁵</code>（或 <code>'\\u'</code>）和带圆圈的数字 ⑤（或 <code>'\\u'</code>）都有单独的字符，但声明这 3 个字符是<strong>兼容性等效</strong>的。类似地，Unicode 对连字 ffi（<code>'\\u'</code>）也有一个单字符，但声明这与三字符序列 <code>ffi</code> 兼容性等效。</p>\n<p>兼容性等效对搜索很有意义：搜索仅使用了 ASCII 字符的 <code>\"difficult\"</code>，应该匹配使用了 ffi 连字符的字符串 <code>\"di\\ucult\"</code>。对后一个字符串应用兼容性分解会将连字替换为 3 个纯字母 <code>\"ffi\"</code>，从而让搜索更容易。但是将文本规范化为其兼容的等效形式可能会丢失重要信息，因此不应草率应用。例如，在大多数情况下将 <code>\"2⁵\"</code> 存储为 <code>\"25\"</code> 是不正确的。</p>\n</li>\n</ul>\n<p>Unicode 规范化形式 C（NFC）和规范化形式 D（NFD）会使用每个字符的最大组合形式和最大分解形式，但不会试图统一兼容性等价序列。NFKC 规范化形式和 NFKD 规范化形式类似于 NFC 和 NFD，但它们会将所有兼容性等效序列规范化为各自的一些简单表示法。</p>\n<p>万维网联盟的“WWW 字符模型”建议对所有内容都使用 NFC。Unicode 标识符和模式语法附件则建议使用 NFKC 作为编程语言中的标识符，并提供了在必要时适配此形式的原则。</p>\n<h3 id=\"nav_point_348\">17.6.2　<code>unicode-normalization</code> crate</h3>\n<p>Rust 的 <code>unicode-normalization</code> crate 提供了一个特型，可以将方法添加到 <code>&amp;str</code> 中，以便将文本转成四种规范化形式中的任何一种。要使用这个 crate，请将下面这行代码添加到 Cargo.toml 文件的 <code>[dependencies]</code> 部分：</p>\n<pre class=\"code-rows\"><code>unicode-normalization = \"0.1.17\"</code></pre>\n<p>有了这个声明，<code>&amp;str</code> 就有了 4 个新方法，它们会返回字符串的特定规范化形式的迭代器：</p>\n<pre class=\"code-rows\"><code>use unicode_normalization::UnicodeNormalization;\n\n// 不管左边的字符串使用哪种表示形式（无法仅仅通过观察得知），这些断言都成立\nassert_eq!(\"Phở\".nfd().collect::&lt;String&gt;(), \"Pho\\u\\u\");\nassert_eq!(\"Phở\".nfc().collect::&lt;String&gt;(), \"Ph\\u\");\n\n// 左侧使用了\"ffi\"连字符\nassert_eq!(\"① Di\\uculty\".nfkc().collect::&lt;String&gt;(), \"1 Difficulty\");</code></pre>\n<p>接受规范化的字符串并以相同的形式再次对其进行规范化可以保证返回相同的文本。</p>\n<p>尽管规范化字符串的任何子字符串本身也是规范化的，但两个规范化字符串拼接起来不一定是规范化的。例如，第二个字符串可能以组合字符开头，并且这个字符按规范应该排在第一个字符串末尾的组合字符之前。</p>\n<p>只要文本在规范化时没有使用未分配的码点，Unicode 就承诺其规范化形式在标准的未来版本中不会改变。这意味着规范化形式通常可以安全地用于持久存储，即使 Unicode 标准在不断发展也不会受影响。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 17 章 字符串与文本(1)","id":740820},"right":{"article_title":"第 18 章 输入与输出","id":740822}},"comments":[]}