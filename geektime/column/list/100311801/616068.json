{"id":616068,"title":"09｜分层架构：怎样逃离“大泥球”？","content":"<p>你好，我是钟敬。</p><p>上节课，我们完成了数据库设计，解决的是怎样保证数据库和领域模型一致的问题。接下来，我们来解决怎样保证代码与模型一致的问题。</p><p>这个问题又分成两个层面。第一个层面是要有一个合理的代码架构，第二个层面是更详细的代码编写。今天我们主要解决第一个层面的问题，通过引入DDD的分层架构，建立代码的骨架。</p><p>我们这节课的方法综合了《领域驱动设计：软件核心复杂性应对之道》（后面简称《DDD》）这本书里的内容以及“六边形架构”的思想。六边形架构是由敏捷软件开发专家 Cockburn提出的，用来分离技术和非技术关注点。如果你只是想掌握分层架构的最佳实践，那么学习这门课就可以了；如果还想进一步了解六边形架构的来龙去脉，可以读一下<a href=\"https://zhuanlan.zhihu.com/p/113681224\">作者本人的文章</a>。</p><p>那么，我们为什么要采用分层架构呢？原因就是为了避免“大泥球”式的代码。</p><h2>源代码仓库地址</h2><p>课程迭代一的配套代码，可以点<a href=\"https://github.com/zhongjinggz/geekdemo\">这里</a>获取。</p><h2>逃离“大泥球”</h2><p>我们知道，系统中的代码都有各自的目的，有些处理领域逻辑，有些处理用户界面，有些处理数据库的访问……这些代码的关注点各不相同。但在很多开发团队中，并没有明确的手段来分离代码的关注点，从而使不同关注点的代码混在一起，这样就会造成下面几个问题。</p><!-- [[[read_end]]] --><p><strong>首先</strong>，很难单独识别出反映领域逻辑的代码，从而难以保证与领域模型的一致性。</p><p><strong>其次</strong>，应该内聚的逻辑分散在不同地方，应该解耦的逻辑又混在一起，造成代码难以理解。</p><p><strong>再次</strong>，修改业务代码，可能会影响技术代码，修改技术代码，又可能会影响业务代码，造成代码很难维护。</p><p><strong>最后</strong>，经过一段时间的维护，代码变得日益混乱，代码中出现大量重复和不一致，经常出现质量问题。</p><p>这种难以维护，毫无规范的代码就被称为“大泥球”（big ball of mud），我们用这张图来表示：</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/9b/bd8b9309d84bc82284183257128ef39b.jpg?wh=3300x1950\" alt=\"\"></p><p>而分层架构就是解决大泥球问题的一种最佳实践，可以有两种等价的画法，一种由内而外，另一种自下而上，如下所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/a0/3b/a06f0ee50ca2ce313832734b79373f3b.jpg?wh=3591x1768\" alt=\"\"></p><p>不过，目前业界用左边这种圈层结构的比较多，所以我们在课程中也采用这种画法。</p><p>从图上面可以看到，分层架构把代码分成若干层，每层负责不同的关注点。图里的箭头表示依赖关系，这里的意思是只能外层依赖内层，内层不能依赖外层。</p><p>这背后其实是根据软件架构中的一个重要原则：<strong>代码中不稳定的部分，应该依赖稳定的部分</strong>。所以，分层架构中越是内层，就越稳定，越是外层，相对就越容易变化。</p><p>那么问题就来了，我们具体要怎么划分代码的层次呢？这就是我们这节课的重点。下面我们来具体学习每个层次。</p><h2>分离领域</h2><p>首先，<strong>DDD 对代码架构最核心的要求就是要将领域层分离出来</strong>。领域层封装了领域数据和逻辑，我们前面的领域模型所对应的代码，主要就体现在领域层。只有将领域层独立出来，才能保证与领域模型的一致，也才能让领域层独立演化。下面是分离领域层后的示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/0e/26/0e06b4f4eb72bbd3fd26984c6cbed726.jpg?wh=3300x1950\" alt=\"\"></p><p>在代码层面，一个层对应于一个Java包或者C#的命名空间，一般命名为domain。在domain 包里，我们要根据领域模型中的模块进一步分包。这样，就保证了在模块一级代码和模型的一致性。下面这张图包含了领域层和模块的程序结构：<br>\n<img src=\"https://static001.geekbang.org/resource/image/01/f3/0130e146574470ebd6716984b54115f3.jpg?wh=3300x1950\" alt=\"\"></p><p>图中的Unjuanable 是项目的根，这是咱们自造的单词，就是“不要卷了”（un-juan-able）的意思，这是开个玩笑。而Effortmng、orgmng、projectmng 和tenantmng就是领域模型中的四个模块，命名还是依据之前建立的词汇表。</p><p>这里再强调一句，<strong>分离领域是DDD的基本要求</strong>。当然对于简单应用，也可以不分离领域，但这时就不能宣称自己是按照DDD来编码了。</p><p>尽管领域层也会随着需求不断演化，但对于一会儿要介绍的其他层而言，这一层仍然是相对稳定的。所以，领域层处于我们架构的最内层，是整个系统的核心，这也符合DDD的基本理念。</p><p>按模块分包以后，我们接着按照领域模型，在模块包中建立实体类，这样就能在类的层面和模型保持一致了。这里先为每个类写一个“空壳”，至于怎么编写类的属性、关联、逻辑等，我们在后面的课程再介绍。下图是增加了实体类的代码结构，命名仍然是依据词汇表，后面就不重复说了：<br>\n<img src=\"https://static001.geekbang.org/resource/image/cf/94/cfca76567bde820b41db924bda29b894.jpg?wh=3300x2116\" alt=\"\"></p><h2>给领域一个“门面”</h2><p>那么，领域层封装的逻辑通常是细粒度的，并不适合直接作为API暴露给外部。另外，还有一些不属于领域层的横切关注点，比如像事务控制，应该单独处理。所以，我们往往要在领域层外面再加一层，DDD和六边形架构都将这一层称为Application，也就是<strong>应用层</strong>。如下图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/13/78/13495747e01b6241e7ed55849b287a78.jpg?wh=3733x2048\" alt=\"\"><br>\n这一层主要负责下面这些逻辑：</p><p>1.接受来自客户端的请求，调用和协调领域层的逻辑来解决问题；</p><p>2.将领域层的处理结果封装为更简单的粗粒度对象，作为对外 API 的参数。这里说的粗粒度对象一般是DTO（Data Transfer Object），也就是没有逻辑的数据传输对象，应用层负责 DTO 和领域对象的数据转换；</p><p>3.负责处理事务、日志、权限等等横切关注点。从设计模式的角度，这一层相当于<strong>“门面”</strong>（Facade）模式，如果你想更深入地了解这个模式，可以读一下相关书籍，例如 《Head First 设计模式》。</p><p><strong>应用层</strong>本身并不包含领域逻辑，而是对<strong>领域层</strong>中的逻辑进行封装和编排。我们不妨把应用层的逻辑称为<strong>应用逻辑。</strong>应用逻辑和领域逻辑的区别有时比较微妙，在后面的课程里我们还会再举例说明。</p><p>封装应用逻辑的类通常没有状态，只有方法，一般称为<strong>应用服务</strong>，我们可以用 XxxService的形式来命名。下面就是增加了一些主要应用服务的代码结构：<br>\n<img src=\"https://static001.geekbang.org/resource/image/32/yy/324bef2b80b7a155008dfa61c7c67ayy.jpg?wh=3300x2306\" alt=\"\"></p><h2>用“适配器”处理输入输出</h2><p>除了业务功能之外，程序里还有另一个重要的关注点——输入输出技术。我们的系统要和外界打交道，可以通过不同技术来实现，比如Restful API、 RPC，以及传统的Web页面等等。对于同一个业务功能，可能过去使用Restful API ，现在由于技术变革，需要改为 RPC。但不论具体技术是哪一种，背后实现的业务功能很可能都是一样的。所以，输入输出技术和业务功能是两个不同的关注点。</p><p>为了分离这两个关注点，我们在<strong>应用层</strong>外面再加一层，专门处理输入输出技术，如下图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/3c/40/3c68f2805774e9a8450aea3fe2053e40.jpg?wh=3300x1950\" alt=\"\"></p><p>六边形架构中将这层称为<strong>适配器</strong>，英文是adapter。这是因为，这一层的目的是把业务功能“适配”到不同的输入输出技术。</p><p>适配器会把和具体技术有关的请求，翻译成和技术无关的请求，再调用应用层来实现业务功能；在接收到应用层的返回值以后，又转化成技术相关的响应，返回给外界。也就是说适配器层屏蔽了输入输出技术的差异，从而使应用层与具体技术无关，这样就达到了分离关注点的目的。</p><p>下图是增加了适配器层的代码结构：<br>\n<img src=\"https://static001.geekbang.org/resource/image/32/7e/324bbf661b9c8896c67e45f8542d457e.jpg?wh=3300x2116\" alt=\"\"></p><p>如果我们的系统要处理多种输入输出技术，那么适配器层可以按照具体技术来分包。比如在上面的代码例子里， Restful包里是Resful Api，web包里面是传统的JSP页面。这些包里的适配器，在多数情况下，就是我们熟悉的Controller。不过，我们并不打算在这个项目里真的使用JSP，这里的web只是为了举例。</p><h2>用“适配器”处理数据持久化</h2><p>最后，我们还要处理一个关注点，就是数据的持久化。在传统上，数据持久化就是访问数据库。但是现在，对缓存、文件系统、对象存储服务等等的访问，一般也算作数据的持久化。</p><p>不过，在引入新的分层之前，我们先讲DDD里的另一个模式，叫做Repository，中文可以叫<strong>仓库</strong>。这个模式用于封装持久化的代码，大体上类似于传统上说的DAO（Data Access Object），也就是“数据访问对象”。</p><p>但和DAO不同的是，<strong>仓库是以聚合为单位的，每个聚合有一个仓库</strong>，而 DAO 是以表为单位的，每个表有一个DAO。我们在第二个迭代才会正式介绍<strong>聚合</strong>，现在咱们姑且认为，一个<strong>实体</strong>就对应一个<strong>仓库</strong>。</p><p>那么，<strong>仓库</strong>和<strong>适配器</strong>有什么关系呢？</p><p>其实，数据库访问也是和具体技术相关的。同样的数据，可以存到Oracle，也可以存到 MySQL；既可以用MyBatis访问，也可以用JPA访问。这些都是具体的技术，和前面一样，<strong>我们需要一种适配器把具体的持久化技术和应用层以及领域层隔离开，而仓库就充当了这种适配器。</strong></p><p>但是仔细想一下，你可能会发现，仓库和前面的Controller虽然都是适配器，但有一个重要的区别。Controller处理的是从外界向系统的调用，比如说来自HTTP客户端的调用；而<strong>仓库</strong>处理的是由系统向外界的调用，比如说对数据库的调用。也就是说，两者的方向不同。</p><p>在六边形架构里，把由外向内的适配器叫做 driving adapter，我把它译作<strong>主动适配器</strong>；而由内向外的适配器叫做 driven adapter，可以译作<strong>被动适配器</strong>。准确地说，<strong>被动适配器的作用不限于访问数据库，而是访问所有外部资源</strong>。</p><p>现在，我们可以把原来的适配器层分成两个部分，像下面这样。<br>\n<img src=\"https://static001.geekbang.org/resource/image/c8/58/c8c2c52683173b0e90769f5a560a5458.jpg?wh=3300x1950\" alt=\"\"></p><p>这两种适配器都处于同一层，但由于性质不同，因此又可以分成两个子层。相应的代码结构是下面这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/60/b2/6027718cb38f6709cd366902478bfbb2.jpg?wh=3300x2116\" alt=\"\"></p><p>我们可以看到，adaper包被分成了driving和driven两个子包，分别代表两种适配器。在driving里还是上一节说的Controller，而driven包下的内容则是新加的。Persistence是“持久化”的意思，这个包里面就是用于持久化的各个<strong>仓库</strong>。</p><h2>存放通用工具和框架</h2><p>到现在为止，我们已经讲了DDD分层架构中最主要的几层，但还有另外一些代码没有考虑。比如说，我们写了一些用于字符串和日期处理的工具类，这些工具可能被上面说的任何一层调用。又比如说，我们可能对Spring框架进行薄薄的一层封装，以便更适合自己的产品使用，甚至可以写一些自己的小框架，这些框架性的代码也可能用于上面说的任何一层。</p><p>既然这些代码可能被前面的所有层依赖，那么是不是说，这些代码应该处于整个系统的最内层呢？如果这样做，那么和DDD所强调的以领域层为核心的思想就矛盾了。但如果不这么做，是不是又违反了层间依赖原则呢？</p><p>事实上，我们可以认为这些代码和前面说的各层根本不在同一个维度，<strong>它们是对各层代码起到公共的支撑作用的</strong>。用下面这张图比较容易说明这个思路。<br>\n<img src=\"https://static001.geekbang.org/resource/image/5d/ae/5d1e1752b444bc1055867c977d6f71ae.jpg?wh=2900x1714\" alt=\"\"></p><p>你看，我们前面讲过的领域层、应用层和适配器层处于同一个平面，而公共支撑部分在另一个平面，对上面的平面进行支撑。这一层倒是没有什么统一的名字，不过业界很多人喜欢把它叫做 <strong>common</strong>。下面就是增加了common层的代码结构：<br>\n<img src=\"https://static001.geekbang.org/resource/image/96/83/96f37f483619eed838bfcdc6c08e4483.jpg?wh=3300x2116\" alt=\"\"></p><p>这里，我们增加了一个common包，下面又有两个子包。其中framework存放框架性的代码，而util存放工具性的代码。框架和工具的区别一般是，框架会调用我们自己写的代码，而工具则被我们写的代码所调用。</p><h2>分层架构的权衡</h2><p>那么，学完前面所有的内容，你可能会问：“我在自己的项目里一定要按这里方法分层吗？不这样分层就不是DDD了吗？”</p><p>其实，这节课的目的并不是让你在实际项目里照搬这里的架构，而是希望你能够理解分层架构背后的原理，然后针对自己项目中存在的痛点进行权衡，形成适合自己项目的架构规范。</p><p>在实际项目中，根据具体情况，有些层次可以合并，而有些层次则可以分得再细一些。在下面的表里，我列出了几种分层架构的变化，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/78/dfa072e191aa23b182cbea045521a978.jpg?wh=3544x1491\" alt=\"\"></p><h2>总结</h2><p>好，今天的主要内容就讲完了，下面来总结一下。</p><p>这节课，我们首先解释了分层架构的目的，也就是通过关注点分离，保证代码和领域模型的一致性，并避免大泥球式的代码，提高程序的可维护性。分层架构要求只能外层依赖内层，不能内层依赖外层。</p><p>然后，我们再结合《DDD》一书以及六边形架构，在代码里引入了各个层次：</p><p><strong>领域层</strong>，用来封装领域数据和逻辑。这一层与领域模型直接对应，是整个系统的核心。</p><p><strong>应用层</strong>，作为<strong>领域层</strong>的“门面”，把<strong>领域层</strong>封装成更粗粒度的服务供外部使用，并且处理事务、日志等横切关注点。</p><p><strong>主动适配器</strong>，用来接收来自外部的请求。屏蔽具体的输入输出技术。</p><p><strong>被动适配器</strong>，用来访问外部资源。被动适配器和主动适配器都属于适配器层，区别在于调用的方向不同。适配器层与具体输入输出和资源访问技术有关，而应用层和领域层与具体技术无关。这样我们就分离了技术和业务的关注点。</p><p>最后，我们引入了 <strong>common层</strong>，用于存放工具和框架。这一层对前面的各层进行支撑。</p><p>正如前面所说的，这节课的目的不是为了让你完全照搬这里的架构，而是希望你能够通过这节课的学习，理解背后的原理，并在实践中进行权衡，找到适合自己项目的架构。</p><h2>思考题</h2><p>最后是两道思考题：</p><p>1.在适配器中，我们举了Restful API、RPC、Web、Repository几种最常见的情况，根据你的经验，还有哪些其他种类的适配器？</p><p>2.分层架构规定只能外层依赖内层，在今天讲的几层中，有一处可能会破坏这种层间依赖关系，你能找出来吗，有没有解决办法？</p><p>好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们来一起编写具体的代码逻辑。</p>","comments":[{"had_liked":false,"id":367867,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"北京","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":true,"comment_ctime":1675688617,"is_pvip":true,"replies":[{"id":134000,"content":"分层架构，可以先把大的包结构定下来，然后逐步往里填内容。动手实践很棒👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675832129,"ip_address":"广东","comment_id":367867,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"分层架构的代码框架看上去不错，不知道后面有没有实际项目的代码示例，show me code。\n\ndomain\napplication\nadapter( driven &lt; restful &#47; web &gt; &#47; driving &lt; persistence &gt; )\ncommon( framework &#47; util )\n\n代码的分层是应该在一开始就按照领域模型来分 domain, application, adapter( driven &lt; restful &#47; web &gt; &#47; driving &lt; persistence &gt; ), common，并且填充不同的类型（对象）；还是按照业务用例，逐步推进？\n\n我觉的比较好的办法，可能是先建立框架，然后再按照用例逐步递增。\n\n在分层结构变化表里面，提到了应用层和被动适配层的合并，或者应用层和主动适配层的合并，那么是不是有可能应用层和适配层合并起来呢？\n\n对于课后题，\n\n1. 其他的适配器，没有出来，后来看留言提示，知道有消息队列和定时任务调用\n2. 同样没能想出来，主要是我之前觉得领域层依赖持久化层做数据持久化很自然。\n\n没有想到 DDD 居然会直接指导代码的目录结构。\n\n照抄了一份放在 github 上：\n\nhttps:&#47;&#47;github.com&#47;escray&#47;geektime&#47;tree&#47;master&#47;DDD-hand-in-hand","like_count":3,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602651,"discussion_content":"分层架构，可以先把大的包结构定下来，然后逐步往里填内容。动手实践很棒👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675832129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365402,"user_name":"leesper","can_delete":false,"product_type":"c1","uid":1351104,"ip_address":"广东","ucode":"CC76320571BECA","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/c0/cb5341ec.jpg","comment_is_top":false,"comment_ctime":1672457297,"is_pvip":false,"replies":[{"id":133259,"content":"两个问题都回答的挺到位 👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673090202,"ip_address":"广东","comment_id":365402,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"思考题：\n1. 跟输入输出具体技术有关的都算，那么命令行界面的访问（CLI）、消息队列服务、缓存服务这些的，都算适配器\n\n2. 内层依赖外层，我记得徐昊老师的课上提了一嘴，问题出在持久化层上，领域层依赖持久化层进行数据持久化，这就变成了内层依赖外层。方法就是“依赖倒置”原则，让领域层依赖于抽象的Repository，然后把真正的实现细节放到持久化层，这样只要接口不发生变化，实现怎么变都可以。这就叫“高层接口不依赖于底层接口，二者都应该依赖于抽象；细节依赖于抽象，而抽象不依赖于细节”。\n\n","like_count":25,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598790,"discussion_content":"两个问题都回答的挺到位 👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673090202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365581,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"广东","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1672796260,"is_pvip":false,"replies":[{"id":133266,"content":"没毛病 👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673091044,"ip_address":"广东","comment_id":365581,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1. 这里尝试理解了 DDD 的分层架构和目前比较大众的开发模式的关系，麻烦看看是否理解有偏差\n2. 领域层对应实体，领域层里面的逻辑处理是把以前的 Service 层的逻辑封装到了实体里，这里应该就是后面要讲的“贫血”&amp;“充血”对比\n3. 应用层对应以前的 Service 层，但是又有区别就在于，是把领域层的逻辑进行组装形成的逻辑，以前的 Service 层是直接硬写逻辑\n4. 适配器层这个就很好理解了，被动就是以前的 Controller 层等等，主动就是对 DB、Redis的操作封装类。\n5. 所以关键点区别就在于领域层的设计","like_count":5,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598797,"discussion_content":"没毛病 👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673091044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365009,"user_name":"zcc","can_delete":false,"product_type":"c1","uid":1046664,"ip_address":"广东","ucode":"58FB42400517A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/88/96b870fd.jpg","comment_is_top":false,"comment_ctime":1671911383,"is_pvip":false,"replies":[{"id":132900,"content":"非常棒","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1671968820,"ip_address":"广东","comment_id":365009,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"问题1：常见的还有MQ消息的订阅与发送\n问题2：应该是主动适配器层会破坏依赖原则","like_count":5,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597519,"discussion_content":"非常棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671968820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3506330,"avatar":"https://static001.geekbang.org/account/avatar/00/35/80/9a/692637f6.jpg","nickname":"曹坤明","note":"","ucode":"23B55F5F10881E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609330,"discussion_content":"主动适配器层怎么会破坏依赖关系呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1678947601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241842,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/f2/2a9a6e9a.jpg","nickname":"行与修","note":"","ucode":"11F21B663EF6D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3506330,"avatar":"https://static001.geekbang.org/account/avatar/00/35/80/9a/692637f6.jpg","nickname":"曹坤明","note":"","ucode":"23B55F5F10881E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626542,"discussion_content":"应该是被动适配层","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1693105118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609330,"ip_address":"江苏","group_id":0},"score":626542,"extra":""}]}]},{"had_liked":false,"id":368296,"user_name":"RED_Allen_Account","can_delete":false,"product_type":"c1","uid":3235957,"ip_address":"上海","ucode":"8D2B5E2F92425C","user_header":"","comment_is_top":false,"comment_ctime":1676124809,"is_pvip":false,"replies":[{"id":134206,"content":"嗯，没错","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1676420610,"ip_address":"广东","comment_id":368296,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1.常用的适配器还有MQ和定时任务\n2.在domain和repository之间会破坏层间依赖，一般在domain层中加入gateway的概念，使用DIP反转domain和repository的依赖关系","like_count":4,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604652,"discussion_content":"嗯，没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676420610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365048,"user_name":"Geek_1e04e7","can_delete":false,"product_type":"c1","uid":2996075,"ip_address":"广东","ucode":"95DDD87FF8ECC7","user_header":"","comment_is_top":false,"comment_ctime":1672033747,"is_pvip":false,"replies":[{"id":132997,"content":"没错","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672229113,"ip_address":"广东","comment_id":365048,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"问题2：领域层会依赖持久化层，能想到的方法是将持久化相关的接口抽象定义放在领域层保持稳定。就不会破坏关系。","like_count":4,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597786,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672229114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364991,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"广东","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1671865858,"is_pvip":false,"replies":[{"id":132901,"content":"是的👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1671968837,"ip_address":"广东","comment_id":364991,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"问题2. 领域层依赖持久化层做数据持久化?","like_count":4,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597520,"discussion_content":"是的👍🏻","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1671968837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":3501946,"avatar":"","nickname":"Geek_5ac193","note":"","ucode":"A10D486B81E2F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":601061,"discussion_content":"老师，这里可以用依赖反转原则吧，将持久化数据的接口定义在领域层，repository层依赖领域层实现该接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675040462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":597520,"ip_address":"广东","group_id":0},"score":601061,"extra":""},{"author":{"id":3506330,"avatar":"https://static001.geekbang.org/account/avatar/00/35/80/9a/692637f6.jpg","nickname":"曹坤明","note":"","ucode":"23B55F5F10881E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3501946,"avatar":"","nickname":"Geek_5ac193","note":"","ucode":"A10D486B81E2F0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609331,"discussion_content":"对呀，把repository的接口定义在领域层，实现放到端口适配器层不是就解决这个问题了么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678947655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":601061,"ip_address":"江苏","group_id":0},"score":609331,"extra":""}]},{"author":{"id":2673605,"avatar":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","nickname":"赵晏龙","note":"","ucode":"F15730BCA97EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598043,"discussion_content":"没有太明白，你说的是在领域层进行AOP标记的方式做持久化吗？我在EF Core中是完全没有采用AOP的方式，这样就能完全避免吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672465401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1703256,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","nickname":"6点无痛早起学习的和尚","note":"","ucode":"33A8A1CDA103F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2673605,"avatar":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","nickname":"赵晏龙","note":"","ucode":"F15730BCA97EE0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598361,"discussion_content":"我感觉应该是指持久化层就是主动适配器那层，领域层会调用持久化层去做 DB 存储等等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672795606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598043,"ip_address":"北京","group_id":0},"score":598361,"extra":""}]}]},{"had_liked":false,"id":366548,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"浙江","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1673920052,"is_pvip":false,"replies":[{"id":134773,"content":"总结得很好。继续点赞收藏转发 ：）","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677930384,"ip_address":"广东","comment_id":366548,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"继续第四篇两千字笔记《分离关注点构建领域核心——领域驱动设计中的分层架构》：\n领域驱动设计中分层架构与六边形架构结合的最大魅力是保持了领域模型作为核心的稳定性，核心思想是分离关注点，设计原则是依赖倒置，从而使得不依赖用户交互与持久化机制的领域模型独立演进成为可能\nhttps:&#47;&#47;juejin.cn&#47;post&#47;7188700862955388987","like_count":3,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607527,"discussion_content":"总结得很好。继续点赞收藏转发 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677930384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378504,"user_name":"Breakthrough","can_delete":false,"product_type":"c1","uid":2822757,"ip_address":"北京","ucode":"80EB01B5D6529D","user_header":"https://static001.geekbang.org/account/avatar/00/2b/12/65/846d566c.jpg","comment_is_top":false,"comment_ctime":1690352636,"is_pvip":false,"replies":[{"id":138087,"content":"领域模型（类图）\n业务规则表\n词汇表\n设计模型（包括分层架构）（可选）\n代码","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1691070126,"ip_address":"广东","comment_id":378504,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师，领域驱动设计最终交付给开发同学的输出物应该是什么是前面画的类图和这个分层架构吗","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624928,"discussion_content":"领域模型（类图）\n业务规则表\n词汇表\n设计模型（包括分层架构）（可选）\n代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691070126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365408,"user_name":"赵晏龙","can_delete":false,"product_type":"c1","uid":2673605,"ip_address":"广东","ucode":"F15730BCA97EE0","user_header":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","comment_is_top":false,"comment_ctime":1672466000,"is_pvip":false,"replies":[{"id":133258,"content":"我当初学六边形架构的时候，也有同感。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673090164,"ip_address":"广东","comment_id":365408,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"针对数据流入流出的途径，抽象为Driven&#47;Driving，这很Impressive，好像从来没有做过这方面的思考","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598789,"discussion_content":"我当初学六边形架构的时候，也有同感。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673090164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374750,"user_name":"Peter Yu","can_delete":false,"product_type":"c1","uid":1077598,"ip_address":"浙江","ucode":"D56786A6E85321","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg","comment_is_top":false,"comment_ctime":1684383456,"is_pvip":false,"replies":[{"id":137144,"content":"这取决于你从那个角度看。目前这种说法，来自于六边形架构最初的说法。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1685969186,"ip_address":"广东","comment_id":374750,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"我感觉controller层是被外界调用的，叫被驱动层才对吧（driven）；而repository层是由领域层主动调用的，归到驱动层（driving）更加合理","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620243,"discussion_content":"这取决于你从那个角度看。目前这种说法，来自于六边形架构最初的说法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685969187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367855,"user_name":"py","can_delete":false,"product_type":"c1","uid":1496577,"ip_address":"上海","ucode":"2372522D715419","user_header":"https://static001.geekbang.org/account/avatar/00/16/d6/01/2448b4a9.jpg","comment_is_top":false,"comment_ctime":1675681756,"is_pvip":false,"replies":[{"id":133999,"content":"不错","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675831912,"ip_address":"广东","comment_id":367855,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"1. 消息，pub&#47;sub\n2. domain层依赖persistence","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602650,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675831913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366686,"user_name":"龙腾","can_delete":false,"product_type":"c1","uid":2864424,"ip_address":"河北","ucode":"81E70A02EB02A0","user_header":"https://static001.geekbang.org/account/avatar/00/2b/b5/28/3de99570.jpg","comment_is_top":false,"comment_ctime":1674047243,"is_pvip":false,"replies":[{"id":133662,"content":"可以在common包里放一个configure目录，或者放在common外面，都无伤大雅。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674447995,"ip_address":"广东","comment_id":366686,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师，配置类放在哪里好呢，比如安全的、数据源的，还有本地配置文件（Properties、yml）读取的类。","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600487,"discussion_content":"可以在common包里放一个configure目录，或者放在common外面，都无伤大雅。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674447995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365025,"user_name":"沐瑞Lynn","can_delete":false,"product_type":"c1","uid":2419069,"ip_address":"广东","ucode":"07CE753F1A4DBC","user_header":"","comment_is_top":false,"comment_ctime":1671958281,"is_pvip":false,"replies":[{"id":133010,"content":"回答得好。之所以叫六边形，是因为原作者在图上每个边画一种端口，他认为6个就足够了，所以就画成了六边形。显然，六边形还是八边形，和本质无关。所以我干脆画圆形。参见课程中六边形架构原文链接。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672232674,"ip_address":"广东","comment_id":365025,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"先回答问题：\n1、常见的可能有消息中间件，搜索引擎\n2、领域层对外界的依赖，可能破坏层间依赖的关系。解决方法，将领域层依赖的方法抽象成接口（interface）。\n\n弱弱的问一句：明明讲的是六边形架构，为啥整个圆形？","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597802,"discussion_content":"回答得好。之所以叫六边形，是因为原作者在图上每个边画一种端口，他认为6个就足够了，所以就画成了六边形。显然，六边形还是八边形，和本质无关。所以我干脆画圆形。参见课程中六边形架构原文链接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672232674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392730,"user_name":"wuwenan","can_delete":false,"product_type":"c1","uid":1283280,"ip_address":"上海","ucode":"3386141CBC0186","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/d0/d478647c.jpg","comment_is_top":false,"comment_ctime":1721637705,"is_pvip":false,"replies":[{"id":143657,"content":"一两句话可能说不清楚，简单说一下：\n1）多数框架，例如MyBatis, Hibernate 都将Java 底层的异常封装成了Runtime Exception，在实际项目中，最好定义全局异常处理机制进行处理就好了\n2）如果确实要定义自己的异常，那么比较简单的方式是在comment包中定义统一的SystemException，使用这一种Exception就可以了\n3）如果确实要为不同的被动适配器定义异常，那么，与具体实现技术无关的异常定义应该和Repository接口定义在同一层，也就是聚合包内；与技术有关的则定义在被动适配器层，但定义为Repository层异常的子类，这样就不会有依赖问题了。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731484047,"ip_address":"广东","comment_id":392730,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"被动适配器层如果出现错误，是否应该向上抛出异常呢？\n如果被动适配器层向上抛出异常，那么该异常应该定义在哪里呢，是定义在被动适配器层吗？\n如果该异常定义在被动适配器层，那调用方是否依赖了被动适配器层呢？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653853,"discussion_content":"一两句话可能说不清楚，简单说一下：\n1）多数框架，例如MyBatis, Hibernate 都将Java 底层的异常封装成了Runtime Exception，在实际项目中，最好定义全局异常处理机制进行处理就好了\n2）如果确实要定义自己的异常，那么比较简单的方式是在comment包中定义统一的SystemException，使用这一种Exception就可以了\n3）如果确实要为不同的被动适配器定义异常，那么，与具体实现技术无关的异常定义应该和Repository接口定义在同一层，也就是聚合包内；与技术有关的则定义在被动适配器层，但定义为Repository层异常的子类，这样就不会有依赖问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731484048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391218,"user_name":"luo","can_delete":false,"product_type":"c1","uid":2741878,"ip_address":"广东","ucode":"9BE7559B0C88D1","user_header":"https://static001.geekbang.org/account/avatar/00/29/d6/76/eca918c3.jpg","comment_is_top":false,"comment_ctime":1717631933,"is_pvip":false,"replies":[{"id":143670,"content":"这个有点见仁见智了。这里考虑的是否容易变化，是逻辑上的问题。同样的领域对象，可以存入关系数据库;也可以存入NoSQL数据库，即使同样是关系数据库，也可以是Oracle或MySQL; 即使一直是 MySQL ，也可以用 MyBatis 或 JPA。诸如此类。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731491743,"ip_address":"广东","comment_id":391218,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"不是领域层更容易变化吗？像适配器层的数据库，mq，一般选定了就基本上不会动了","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653874,"discussion_content":"这个有点见仁见智了。这里考虑的是否容易变化，是逻辑上的问题。同样的领域对象，可以存入关系数据库;也可以存入NoSQL数据库，即使同样是关系数据库，也可以是Oracle或MySQL; 即使一直是 MySQL ，也可以用 MyBatis 或 JPA。诸如此类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731491744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383812,"user_name":"Geek_有心","can_delete":false,"product_type":"c1","uid":2379461,"ip_address":"广东","ucode":"A940B79C84329C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/kFuWg0sRPIT94SGU5Ciaic1LXlHpMkAf4vC0GlCURVFZczUnL0sMhf3TBombsTxReicxl7VhafI5uHyoShUpwoHOg/132","comment_is_top":false,"comment_ctime":1699696028,"is_pvip":false,"replies":[{"id":140482,"content":"是的，被你找到了：）\n后面会用依赖倒置的方法来解决","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1702801523,"ip_address":"广东","comment_id":383812,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"问题2:分层架构原则是外层依赖内层 ，内层不能依赖外层。但是ddd里面领域层依赖了持久化，持久化又是外层。违背了内层不能依赖外层的原则","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633924,"discussion_content":"是的，被你找到了：）\n后面会用依赖倒置的方法来解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702801523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379884,"user_name":"seamas","can_delete":false,"product_type":"c1","uid":1181500,"ip_address":"浙江","ucode":"26B92D201881B7","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/3c/ab8a4a6d.jpg","comment_is_top":false,"comment_ctime":1692666624,"is_pvip":true,"replies":[{"id":138371,"content":"收到，已经更新了，刷新可见。感谢捉虫","user_name":"编辑回复","user_name_real":"编辑","uid":1501385,"ctime":1692681766,"ip_address":"北京","comment_id":379884,"utype":2}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"捉虫cockburn\n六边形架构是由敏捷软件开发专家 Cockbun","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626239,"discussion_content":"收到，已经更新了，刷新可见。感谢捉虫","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692681766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378942,"user_name":"caisirius","can_delete":false,"product_type":"c1","uid":1060818,"ip_address":"北京","ucode":"865F1BF9777D68","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoyjYXsXpziaCfxDTjUIjyHnq1DOGNF7A4ozVNfdoyicia4icPTbTXneENfDsqJkg53C6MjS6Dmo9b9ag/132","comment_is_top":false,"comment_ctime":1691026770,"is_pvip":false,"replies":[{"id":138083,"content":"使用maven子模块的优点是通过模块之间的依赖关系配置，团队成员不容易破坏层间依赖关系，代价是比较复杂。没有绝对的好坏，自己的团队可以权衡一下。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1691069496,"ip_address":"广东","comment_id":378942,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"我看老师的demo是分包的方式，有的人做过另一种方式，就是分maven 子 module的方式，即application、domain、adapter甚至persistence都是独立的子module。\n从实践上看，哪种方式更合适呢？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624924,"discussion_content":"使用maven子模块的优点是通过模块之间的依赖关系配置，团队成员不容易破坏层间依赖关系，代价是比较复杂。没有绝对的好坏，自己的团队可以权衡一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691069497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378104,"user_name":"Geek_2197ae","can_delete":false,"product_type":"c1","uid":3665867,"ip_address":"北京","ucode":"D5ACD199CB6894","user_header":"","comment_is_top":false,"comment_ctime":1689758359,"is_pvip":false,"replies":[{"id":137961,"content":"github需要科学上网～","user_name":"编辑回复","user_name_real":"编辑","uid":1501385,"ctime":1690522743,"ip_address":"北京","comment_id":378104,"utype":2}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师，课程迭代一的配套代码，下载不下来，链接都进不去。","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624381,"discussion_content":"github需要科学上网～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690522743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377066,"user_name":"Mr.H","can_delete":false,"product_type":"c1","uid":1072357,"ip_address":"浙江","ucode":"FEAB798AB45F17","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/e5/5cd7fb17.jpg","comment_is_top":false,"comment_ctime":1687889172,"is_pvip":false,"replies":[{"id":137716,"content":"如果是用统一的接口发送所有消息，也就是说，这个消息接口本身没有业务意义，那么应该放在common。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1689498754,"ip_address":"","comment_id":377066,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"有个问题，适配器中如果有MQ，那么应该也要和persistence一样，定义一个接口来让应用层依赖反转，但是这个接口放在哪里呢？\n1、如果放在domain层，但是发送的信息可能和domain关系并不大\n2、domain层中应该是业务关心的逻辑，MQ更多的是一种技术手段\n这么看应该放在common层了，不知道对不对","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623443,"discussion_content":"如果是用统一的接口发送所有消息，也就是说，这个消息接口本身没有业务意义，那么应该放在common。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689498755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074736,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/30/ce2cc535.jpg","nickname":"小5","note":"","ucode":"F99936F37D04E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623923,"discussion_content":"我觉得MQ消息要分为 订阅消息 和 发布消息 两种情况；1 如果是订阅消息 那入口应该是和restfull api相同层级，要不要分子包就看实际业务，然后调用应用层服务代码； 2 如果是 发布消息，就应该是被动适配器，和persistence同级，具体要不要分子包要看业务。       上面问题中说的应该属于第二种情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690013380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376303,"user_name":"末日，成欢","can_delete":false,"product_type":"c1","uid":1812201,"ip_address":"陕西","ucode":"BBAEBB9C93558A","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLm8skz4F7FGGBTXWUMia6qVEc00BddeXapicv5FkAx62GmOnUNEcE4scSR60AmappQoNdIQhccKsBA/132","comment_is_top":false,"comment_ctime":1686655976,"is_pvip":false,"replies":[{"id":137249,"content":"你说的“在service中再加一个领域层”是指的service层调用领域层吗？如果是这个意思，那么对的。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1686837809,"ip_address":"广东","comment_id":376303,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"老师，有个疑问，现在可能面向过程开发习惯了， 从controller(外部入口)-&gt;service(逻辑层)-&gt;dao,\n从老师说的分层架构来说,我只需要将controller只关注处理输入,不做其他处理,交给service(逻辑层),做一些应用逻辑,比如日志打印,权限控制\n接着交给领域层处理, 做业务逻辑。 那其实我在service中再加一个领域层就行了,不知道我理解的对不对。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621127,"discussion_content":"你说的“在service中再加一个领域层”是指的service层调用领域层吗？如果是这个意思，那么对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686837809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372403,"user_name":"jiaoxn","can_delete":false,"product_type":"c1","uid":2056601,"ip_address":"四川","ucode":"28B8F253830DD1","user_header":"http://thirdwx.qlogo.cn/mmopen/KFgDEHIEpnSoiaOuJic93Mr1ObEFfebXQCIBvwotBPppVZTIZCAmZQQttI0lmpadSbVBibGN3Ob3OuHsibbwNia9YaDfDNDy2jibLR/132","comment_is_top":false,"comment_ctime":1681105860,"is_pvip":false,"replies":[{"id":136137,"content":"可以这样做：在领域层定义接口，然后在适配器层写仓库的实现，在仓库的实现中调用Mybatis的mapper。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1681633514,"ip_address":"广东","comment_id":372403,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"老师，有个问题想请教一下。参照文章的思路，在领域层定义了接口，在适配器层中实现这个接口，如果使用 MyBatis 做持久化，领域层和适配器层该怎么写呢？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614019,"discussion_content":"可以这样做：在领域层定义接口，然后在适配器层写仓库的实现，在仓库的实现中调用Mybatis的mapper。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1681633514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056601,"avatar":"http://thirdwx.qlogo.cn/mmopen/KFgDEHIEpnSoiaOuJic93Mr1ObEFfebXQCIBvwotBPppVZTIZCAmZQQttI0lmpadSbVBibGN3Ob3OuHsibbwNia9YaDfDNDy2jibLR/132","nickname":"jiaoxn","note":"","ucode":"28B8F253830DD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613261,"discussion_content":"我目前的解法是：\n1. 在领域层定义 User（领域模型）和 UserRepository（领域模型的操作接口）\n2. 在基础设施层定义 UserRepositoryMyBatisImpl（接口实现类），其中，将 UserDao（MyBatis 的接口文件）自动注入到该类里面，UserDao 也在适配器层；\n3. 在应用层定义 UserService，通过自动注入的方式，将 UserRepository 注入。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681217490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370636,"user_name":"SQY","can_delete":false,"product_type":"c1","uid":1700079,"ip_address":"福建","ucode":"EC90C53BFA03FA","user_header":"https://static001.geekbang.org/account/avatar/00/19/f0/ef/b9db4b4e.jpg","comment_is_top":false,"comment_ctime":1679039980,"is_pvip":false,"replies":[{"id":135251,"content":"同一个限界上下文内，直接调。不同上下文，通过适配器","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1679107268,"ip_address":"广东","comment_id":370636,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"领域层直接互相调用功能应该怎么办 用适配器层去调用吗？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609679,"discussion_content":"同一个限界上下文内，直接调。不同上下文，通过适配器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679107268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369669,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"北京","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1677802812,"is_pvip":false,"replies":[{"id":134716,"content":"给持续思考留言的你点赞，和钟老师确认了一下，老师回复如下：这个理解基本上是正确的。有一个细微之处，课程里也讲到了，原书里的基础设施，把我们课程里的适配器和common两部分混淆在了一起，从这一点而言，课程里会更清晰一点。","user_name":"编辑回复","user_name_real":"编辑","uid":1501385,"ctime":1677898691,"ip_address":"北京","comment_id":369669,"utype":2}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"回过头，重新再看这一章，有了一些新的问题\n1. 发现本文的分层架构对应书里 DDD 的分层架构是不一样的。\n文中的主动适配器应该对应 DDD 的基础层\n被动适配器对应用户接口层\n其他几层是一一对应的\n\n不知道理解的对不对","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607448,"discussion_content":"给持续思考留言的你点赞，和钟老师确认了一下，老师回复如下：这个理解基本上是正确的。有一个细微之处，课程里也讲到了，原书里的基础设施，把我们课程里的适配器和common两部分混淆在了一起，从这一点而言，课程里会更清晰一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677898691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368344,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1676219936,"is_pvip":false,"replies":[{"id":134188,"content":"感谢你的持续学习分享，点赞～","user_name":"编辑回复","user_name_real":"编辑","uid":1501385,"ctime":1676361000,"ip_address":"北京","comment_id":368344,"utype":2}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"第 9 课\n笔记 https:&#47;&#47;wyyl1.com&#47;post&#47;23&#47;04&#47;\n源码 https:&#47;&#47;github.com&#47;wyyl1&#47;geektime-ddd&#47;tree&#47;1","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604316,"discussion_content":"感谢你的持续学习分享，点赞～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1676361000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368339,"user_name":"RED_Allen_Account","can_delete":false,"product_type":"c1","uid":3235957,"ip_address":"上海","ucode":"8D2B5E2F92425C","user_header":"","comment_is_top":false,"comment_ctime":1676212961,"is_pvip":false,"replies":[{"id":134204,"content":"是笔误，但driving driven 命名本身就容易因为观察角度的原因造成歧义，等我想想怎么改。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1676419914,"ip_address":"广东","comment_id":368339,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"老师您好，在适配器层的定义上我在一篇文章中看到的和您的定义相反，请问这里是笔误或者是其它原因么，下面是原文的定义\n\n主适配器（别名Driving Adapter）代表用户如何使用应用，从技术上来说，它们接收用户输入，调用端口并返回输出。Rest API是目前最常见的应用使用方式，以取消订单为例，该适配器实现Rest API的Endpoint，并调用入口端口CancelOrderService。同一个端口可能被多种适配器调用，例如CancelOrderService也可能会被实现消息协议的Driving Adapter调用以便异步取消订单。\n\n次适配器（别名Driven Adapter）实现应用的出口端口，向外部工具执行操作，例如\n\n向MySQL执行SQL，存储订单\n使用Elasticsearch的API搜索产品\n使用邮件&#47;短信发送订单取消通知\n\n原文地址：https:&#47;&#47;insights.thoughtworks.cn&#47;port-and-adapter-architecture&#47;\n\n","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604649,"discussion_content":"是笔误，但driving driven 命名本身就容易因为观察角度的原因造成歧义，等我想想怎么改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676419914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365503,"user_name":"鱼叔","can_delete":false,"product_type":"c1","uid":1178825,"ip_address":"广东","ucode":"6DCBCBD6C57002","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/c9/52d8e1f0.jpg","comment_is_top":false,"comment_ctime":1672709567,"is_pvip":false,"replies":[{"id":133264,"content":"可能算，也可能不算。等我们第三个迭代讨论限界上下文的时候再细谈。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673090867,"ip_address":"广东","comment_id":365503,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"请问一下老师，「工时管理」，「组织管理」这些算限界上下文吗？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598795,"discussion_content":"可能算，也可能不算。等我们第三个迭代讨论限界上下文的时候再细谈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673090867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365120,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"广东","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1672129945,"is_pvip":false,"replies":[{"id":132981,"content":"第一题对的，第二题下节课有。看了读后感，读得够细👍🏽","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672204016,"ip_address":"广东","comment_id":365120,"utype":1}],"discussion_count":5,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"回答问题：\n\n1. 定时任务调用、收到 MQ 消息\n2. 找不出来\n\n读后感：\n\n图解很生动，瞬间明白了：主动适配器与被动适配器的区别；common 与 DDD 相关层的关系。\n\n之前一直以为在 DDD 中就是把数据库的相关操作放在 Repository 中就行，就是在 Service 与 DAO 再加一个 Repository 包装一下。\n现在知道 Repository 应该放在主动适配层。\n\n读了《【翻译】六边形架构》后明白了：“六边形架构” 中的六 “并不是因为“六”这个数字有多重要，而是为了让人们画图时有足够的空间摆放所需的端口和适配器，而不会受到一维层次结构的限制。术语“六边形架构”正是由这一图形而得名的。”\n\n看起来是一个非常好的资源：领域驱动设计中国（DDD-China）https:&#47;&#47;www.zhihu.com&#47;column&#47;ddd-china","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597746,"discussion_content":"第一题对的，第二题下节课有。看了读后感，读得够细👍🏽","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1672204016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2864424,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/b5/28/3de99570.jpg","nickname":"龙腾","note":"","ucode":"81E70A02EB02A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600164,"discussion_content":"定时任务算是“外部”向系统的调用吗？感觉比较牵强啊，除非你的调度器在另一个系统里吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674044764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北","group_id":0},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2864424,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/b5/28/3de99570.jpg","nickname":"龙腾","note":"","ucode":"81E70A02EB02A0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600169,"discussion_content":"我用的是 xxlJob 真是在系统之外的另一个独立系统","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674050839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":600164,"ip_address":"浙江","group_id":0},"score":600169,"extra":""},{"author":{"id":2864424,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/b5/28/3de99570.jpg","nickname":"龙腾","note":"","ucode":"81E70A02EB02A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600410,"discussion_content":"哦哦xxljob倒是，如果是spring内部的定时任务要放哪啊，是不是也算一种虚拟的外部调用😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674315245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":600169,"ip_address":"河北","group_id":0},"score":600410,"extra":""},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2864424,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/b5/28/3de99570.jpg","nickname":"龙腾","note":"","ucode":"81E70A02EB02A0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600450,"discussion_content":"我觉得是\n分离关注点：定时任务、领域服务应该分开\n推荐《领域驱动设计 软件核心复杂性应对之道》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674384784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":600410,"ip_address":"浙江","group_id":0},"score":600450,"extra":""}]}]},{"had_liked":false,"id":365026,"user_name":"zcc","can_delete":false,"product_type":"c1","uid":1046664,"ip_address":"广东","ucode":"58FB42400517A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/88/96b870fd.jpg","comment_is_top":false,"comment_ctime":1671959248,"is_pvip":false,"replies":[{"id":133011,"content":"下节课讲依赖倒置","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672232701,"ip_address":"广东","comment_id":365026,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"用包进行分层，怎么做到只能外层依赖内层？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597803,"discussion_content":"下节课讲依赖倒置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672232701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365019,"user_name":"喆","can_delete":false,"product_type":"c1","uid":1021657,"ip_address":"广东","ucode":"542E4D8FF40EEF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/d9/a252585b.jpg","comment_is_top":false,"comment_ctime":1671944598,"is_pvip":false,"replies":[{"id":133009,"content":"非常👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672232243,"ip_address":"广东","comment_id":365019,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100311801,"comment_content":"1.应用层向外调用的适配器，可能是走Http，可能是走消息中间件\n2.应用层如果直接调用主动适配器层会产生一个由内向外的依赖关系。可以在应用层加一个interface，通过依赖倒置解决这种问题","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597801,"discussion_content":"非常👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672232243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365013,"user_name":"Geek_8ac303","can_delete":false,"product_type":"c1","uid":1888721,"ip_address":"广东","ucode":"64A176DE7F498E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIERY97h7dmXbtur6rhZWA9Jb3TtSsJh7icDdFjdLmruTXC22qibOVTmW2a04TxMhxqtNJibYL1iaU7yQ/132","comment_is_top":false,"comment_ctime":1671934792,"is_pvip":false,"replies":[{"id":133008,"content":"1，这正是六边形架构的精髓，数据存储是适配器。\n2，首先同步一下术语，ddd中，domain层里就是entity.估计您说的entity其实是一些人说的po,也就是和表对应的持久化对象。表和领域对象相似度高，就直接，否则经po转一道。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672231358,"ip_address":"广东","comment_id":365013,"utype":1}],"discussion_count":3,"race_medal":0,"score":5,"product_id":100311801,"comment_content":"有两个疑问，问题1：持久化层为啥在最外层，一般不都是service调用repository\n问题2：repository是一步到位输出到domain，还是先输出到entity然后再转化为domain","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597799,"discussion_content":"1，这正是六边形架构的精髓，数据存储是适配器。\n2，首先同步一下术语，ddd中，domain层里就是entity.估计您说的entity其实是一些人说的po,也就是和表对应的持久化对象。表和领域对象相似度高，就直接，否则经po转一道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672231359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1068804,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4f/04/613c2611.jpg","nickname":"小珂","note":"","ucode":"983B917F0FFACD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":607897,"discussion_content":"老师，你好，请教一个问题:\n在六边形架构中，用feign client 声明式定义的远程http client接口类应该放哪一层呢，我理解应该放在适配器，但应用层又要调用它，这样的话应用层反向依赖适配器了，feign声明式的类已经是一个interface接口了，难道还要像repository一样，再定义一个接口来实现依赖倒置吗？\n期待老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678181351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":597799,"ip_address":"广东","group_id":0},"score":607897,"extra":""},{"author":{"id":1074736,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/30/ce2cc535.jpg","nickname":"小5","note":"","ucode":"F99936F37D04E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1068804,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4f/04/613c2611.jpg","nickname":"小珂","note":"","ucode":"983B917F0FFACD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623925,"discussion_content":"对于client所在的项目来说，和restfull api一样都是给别人调用的，本质也就是restfull api（请求数据流入）。  对于调用client的项目说，就是持久层（请求数据流出）。 mq的订阅和发布也类似。 个人看法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690013880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":607897,"ip_address":"广东","group_id":0},"score":623925,"extra":""}]}]},{"had_liked":false,"id":365925,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"福建","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1673240051,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":5,"product_id":100311801,"comment_content":"内容：\n1.这算是比较标准的分层思路了。但它在聚合重排，业务重组时并不灵活，因为应用层有代码依赖，要重拆和重写。（题外话，直接在最外层做模块分离如何）\n2.dto在应用层，导致应用层和开放主机层强绑定。不好做接口隔离，不必要的知识外泄。（当然，也可以一个对外接口做的足够泛化，这是一个思路。只是我个人钟爱隔离，优先隔离而不是复用）\n3.comm个人大多也都叫infr，然后util叫lib，想表达的是，它是原生代码库的扩展，还是属于代码库，代码库设计既语言设计，所以还在原生范围内，属于pojo的范涛内，为其正名。\n\n课后题：\n1.其实我个人接触到的，主被适配器，大家更常叫南北向网关。这个列举没意义，定性意义大点。只要是跨进层的访问，否该归为这个范围。（跨代码仓不一定，毕竟我们可以本地依赖&#47;混合部署）\n2.南向因为是领域逻辑依赖方，所以往往都要做接口与实现分离，用ioc反转依赖。","like_count":1,"discussions":[{"author":{"id":3326979,"avatar":"https://static001.geekbang.org/account/avatar/00/32/c4/03/511aa353.jpg","nickname":"H","note":"","ucode":"06D57447BF1A47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600438,"discussion_content":"大佬那边实践是不是每个模块一个包，每个包下好几层比如domain,南北网关，应用...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674359055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山西","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3326979,"avatar":"https://static001.geekbang.org/account/avatar/00/32/c4/03/511aa353.jpg","nickname":"H","note":"","ucode":"06D57447BF1A47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600480,"discussion_content":"模块的概念，挺多放在domain下面。表达一堆聚合的合集。 ddd写时是单体的时代。 微服务，该不该再这么玩另说哈，可能就没有模块啥事了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674445175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":600438,"ip_address":"福建","group_id":0},"score":600480,"extra":""}]}]},{"had_liked":false,"id":377494,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"重庆","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1688603881,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100311801,"comment_content":"1.其他适配器还有各种中间价的客户端，例如，redis的jedis,redission,luttuce，其他的还有kafka,zookeeper等中间件客户端\n2.领域层的逻辑一般会依赖外部数据，可以通过依赖倒置，定义抽象的接口，在基础技术层或者适配器层实现具体逻辑\n3.另外就是代码的组织结构一般有两种，一种是按照课程里面按照适配器层，应用层，领域层，再在下面按照业务区分。另外一种，先按照业务拆分，然后再在按照适配器，应用层，领域层拆分。个人更加喜欢后者，特别是变化多的业务，方便后期拆分微服务","like_count":0},{"had_liked":false,"id":377065,"user_name":"Mr.H","can_delete":false,"product_type":"c1","uid":1072357,"ip_address":"浙江","ucode":"FEAB798AB45F17","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/e5/5cd7fb17.jpg","comment_is_top":false,"comment_ctime":1687888550,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100311801,"comment_content":"适配器如果增加一个MQ，那么也就要和persistence一样依赖反转了，有个问题，这个抽象出来的MQ接口放在哪里比较合适呢？","like_count":0}]}