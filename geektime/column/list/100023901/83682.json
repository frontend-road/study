{"id":83682,"title":"01 | 可见性、原子性和有序性问题：并发编程Bug的源头","content":"<p>如果你细心观察的话，你会发现，不管是哪一门编程语言，并发类的知识都是在高级篇里。换句话说，这块知识点其实对于程序员来说，是比较进阶的知识。我自己这么多年学习过来，也确实觉得并发是比较难的，因为它会涉及到很多的底层知识，比如若你对操作系统相关的知识一无所知的话，那去理解一些原理就会费些力气。这是我们整个专栏的第一篇文章，我说这些话的意思是如果你在中间遇到自己没想通的问题，可以去查阅资料，也可以在评论区找我，以保证你能够跟上学习进度。</p><p>你我都知道，编写正确的并发程序是一件极困难的事情，并发程序的Bug往往会诡异地出现，然后又诡异地消失，很难重现，也很难追踪，很多时候都让人很抓狂。但要快速而又精准地解决“并发”类的疑难杂症，你就要理解这件事情的本质，追本溯源，深入分析这些Bug的源头在哪里。</p><p>那为什么并发编程容易出问题呢？它是怎么出问题的？今天我们就重点聊聊这些Bug的源头。</p><h2>并发程序幕后的故事</h2><p>这些年，我们的CPU、内存、I/O设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，有一个<strong>核心矛盾一直存在，就是这三者的速度差异</strong>。CPU和内存的速度差异可以形象地描述为：CPU是天上一天，内存是地上一年（假设CPU执行一条普通指令需要一天，那么CPU读写内存得等待一年的时间）。内存和I/O设备的速度差异就更大了，内存是天上一天，I/O设备是地上十年。</p><!-- [[[read_end]]] --><p>程序里大部分语句都要访问内存，有些还要访问I/O，根据木桶理论（一只水桶能装多少水取决于它最短的那块木板），程序整体的性能取决于最慢的操作——读写I/O设备，也就是说单方面提高CPU性能是无效的。</p><p>为了合理利用CPU的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p><ol>\n<li>CPU增加了缓存，以均衡与内存的速度差异；</li>\n<li>操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；</li>\n<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。</li>\n</ol><p>现在我们几乎所有的程序都默默地享受着这些成果，但是天下没有免费的午餐，并发程序很多诡异问题的根源也在这里。</p><h2>源头之一：缓存导致的可见性问题</h2><p>在单核时代，所有的线程都是在一颗CPU上执行，CPU缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个CPU的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程A和线程B都是操作同一个CPU里面的缓存，所以线程A更新了变量V的值，那么线程B之后再访问变量V，得到的一定是V的最新值（线程A写过的值）。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/da/a07e8182819e2b260ce85b2167d446da.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">CPU缓存与内存的关系图</span></center><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p><p>多核时代，每颗CPU都有自己的缓存，这时CPU缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的CPU上执行时，这些线程操作的是不同的CPU缓存。比如下图中，线程A操作的是CPU-1上的缓存，而线程B操作的是CPU-2上的缓存，很明显，这个时候线程A对变量V的操作对于线程B而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的“坑”。</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/ea/e2aa76928b2bc135e08e7590ca36e0ea.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">多核CPU的缓存与内存关系图</span></center><p>下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次add10K()方法，都会循环10000次count+=1操作。在calc()方法中我们创建了两个线程，每个线程调用一次add10K()方法，我们来想一想执行calc()方法得到的结果应该是多少呢？</p><pre><code>public class Test {\n  private long count = 0;\n  private void add10K() {\n    int idx = 0;\n    while(idx++ &lt; 10000) {\n      count += 1;\n    }\n  }\n  public static long calc() {\n    final Test test = new Test();\n    // 创建两个线程，执行add()操作\n    Thread th1 = new Thread(()-&gt;{\n      test.add10K();\n    });\n    Thread th2 = new Thread(()-&gt;{\n      test.add10K();\n    });\n    // 启动两个线程\n    th1.start();\n    th2.start();\n    // 等待两个线程执行结束\n    th1.join();\n    th2.join();\n    return count;\n  }\n}\n</code></pre><p>直觉告诉我们应该是20000，因为在单线程里调用两次add10K()方法，count的值就是20000，但实际上calc()的执行结果是个10000到20000之间的随机数。为什么呢？</p><p>我们假设线程A和线程B同时开始执行，那么第一次都会将 count=0 读到各自的CPU缓存里，执行完 count+=1 之后，各自CPU缓存里的值都是1，同时写入内存后，我们会发现内存中是1，而不是我们期望的2。之后由于各自的CPU缓存里都有了count的值，两个线程都是基于CPU缓存里的 count 值来计算，所以导致最终count的值都是小于20000的。这就是缓存的可见性问题。</p><p>循环10000次count+=1操作如果改为循环1亿次，你会发现效果更明显，最终count的值接近1亿，而不是2亿。如果循环10000次，count的值接近20000，原因是两个线程不是同时启动的，有一个时差。</p><p><img src=\"https://static001.geekbang.org/resource/image/ec/79/ec6743e74ccf9a3c6d6c819a41e52279.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">变量count在CPU缓存和内存的分布图</span></center><h2>源头之二：线程切换带来的原子性问题</h2><p>由于IO太慢，早期的操作系统就发明了多进程，即便在单核的CPU上我们也可以一边听着歌，一边写Bug，这个就是多进程的功劳。</p><p>操作系统允许某个进程执行一小段时间，例如50毫秒，过了50毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个50毫秒称为“<strong>时间片</strong>”。</p><p><img src=\"https://static001.geekbang.org/resource/image/25/fb/254b129b145d80e9bb74123d6e620efb.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">线程切换示意图</span></center><p>在一个时间片内，如果一个进程进行一个IO操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让CPU的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得CPU的使用权了。</p><p>这里的进程在等待IO时之所以会释放CPU使用权，是为了让CPU在这段等待时间里可以做别的事情，这样一来CPU的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样IO的使用率也上来了。</p><p>是不是很简单的逻辑？但是，虽然看似简单，支持多进程分时复用在操作系统的发展史上却具有里程碑意义，Unix就是因为解决了这个问题而名噪天下的。</p><p>早期的操作系统基于进程来调度CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p><p>Java并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异Bug的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条CPU指令完成，例如上面代码中的<code>count += 1</code>，至少需要三条CPU指令。</p><ul>\n<li>指令1：首先，需要把变量count从内存加载到CPU的寄存器；</li>\n<li>指令2：之后，在寄存器中执行+1操作；</li>\n<li>指令3：最后，将结果写入内存（缓存机制导致可能写入的是CPU缓存而不是内存）。</li>\n</ul><p>操作系统做任务切换，可以发生在任何一条<strong>CPU指令</strong>执行完，是的，是CPU指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设count=0，如果线程A在指令1执行完后做线程切换，线程A和线程B按照下图的序列执行，那么我们会发现两个线程都执行了count+=1的操作，但是得到的结果不是我们期望的2，而是1。</p><p><img src=\"https://static001.geekbang.org/resource/image/33/63/33777c468872cb9a99b3cdc1ff597063.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">非原子操作的执行路径示意图</span></center><p>我们潜意识里面觉得count+=1这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在count+=1之前，也可以发生在count+=1之后，但就是不会发生在中间。<strong>我们把一个或者多个操作在CPU执行的过程中不被中断的特性称为原子性</strong>。CPU能保证的原子操作是CPU指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。</p><h2>源头之三：编译优化带来的有序性问题</h2><p>那并发编程里还有没有其他有违直觉容易导致诡异Bug的技术呢？有的，就是有序性。顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的Bug。</p><p>在Java领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例getInstance()的方法中，我们首先判断instance是否为空，如果为空，则锁定Singleton.class并再次检查instance是否为空，如果还为空则创建Singleton的一个实例。</p><pre><code>public class Singleton {\n  static Singleton instance;\n  static Singleton getInstance(){\n    if (instance == null) {\n      synchronized(Singleton.class) {\n        if (instance == null)\n          instance = new Singleton();\n        }\n    }\n    return instance;\n  }\n}\n</code></pre><p>假设有两个线程A、B同时调用getInstance()方法，他们会同时发现 <code>instance == null</code> ，于是同时对Singleton.class加锁，此时JVM保证只有一个线程能够加锁成功（假设是线程A），另外一个线程则会处于等待状态（假设是线程B）；线程A会创建一个Singleton实例，之后释放锁，锁释放后，线程B被唤醒，线程B再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程B检查 <code>instance == null</code> 时会发现，已经创建过Singleton实例了，所以线程B不会再创建一个Singleton实例。</p><p>这看上去一切都很完美，无懈可击，但实际上这个getInstance()方法并不完美。问题出在哪里呢？出在new操作上，我们以为的new操作应该是：</p><ol>\n<li>分配一块内存M；</li>\n<li>在内存M上初始化Singleton对象；</li>\n<li>然后M的地址赋值给instance变量。</li>\n</ol><p>但是实际上优化后的执行路径却是这样的：</p><ol>\n<li>分配一块内存M；</li>\n<li>将M的地址赋值给instance变量；</li>\n<li>最后在内存M上初始化Singleton对象。</li>\n</ol><p>优化后会导致什么问题呢？我们假设线程A先执行getInstance()方法，当执行完指令2时恰好发生了线程切换，切换到了线程B上；如果此时线程B也执行getInstance()方法，那么线程B在执行第一个判断时会发现 <code>instance != null</code> ，所以直接返回instance，而此时的instance是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/d8/64c955c65010aae3902ec918412827d8.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">双重检查创建单例的异常执行路径</span></center><h2>总结</h2><p>要写好并发程序，首先要知道并发程序的问题在哪里，只有确定了“靶子”，才有可能把问题解决，毕竟所有的解决方案都是针对问题的。并发程序经常出现的诡异问题看上去非常无厘头，但是深究的话，无外乎就是直觉欺骗了我们，<strong>只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发Bug都是可以理解、可以诊断的</strong>。</p><p>在介绍可见性、原子性、有序性的时候，特意提到<strong>缓存</strong>导致的可见性问题，<strong>线程切换</strong>带来的原子性问题，<strong>编译优化</strong>带来的有序性问题，其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。但是技术在解决一个问题的同时，必然会带来另外一个问题，所以<strong>在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避</strong>。</p><p>我们这个专栏在讲解每项技术的时候，都会尽量将每项技术解决的问题以及产生的问题讲清楚，也希望你能够在这方面多思考、多总结。</p><h2>课后思考</h2><p>常听人说，在32位的机器上对long型变量进行加减操作存在并发隐患，到底是不是这样呢？现在相信你一定能分析出来。</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":71313,"user_name":"Jialin","can_delete":false,"product_type":"c1","uid":1112955,"ip_address":"","ucode":"12583269732A75","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/7b/2d4b38fb.jpg","comment_is_top":false,"comment_ctime":1551318708,"is_pvip":false,"replies":[{"id":"25666","content":"厉害厉害，比我回答的全面多了","user_name":"作者回复","comment_id":71313,"uid":"1269969","ip_address":"","utype":1,"ctime":1551369165,"user_name_real":"王宝令"}],"discussion_count":32,"race_medal":0,"score":"2509812219572","product_id":100023901,"comment_content":"对于双重锁的问题，我觉得任大鹏分析的蛮有道理，线程A进入第二个判空条件，进行初始化时，发生了时间片切换，即使没有释放锁，线程B刚要进入第一个判空条件时，发现条件不成立，直接返回instance引用，不用去获取锁。如果对instance进行volatile语义声明，就可以禁止指令重排序，避免该情况发生。<br>对于有些同学对CPU缓存和内存的疑问，CPU缓存不存在于内存中的，它是一块比内存更小、读写速度更快的芯片，至于什么时候把数据从缓存写到内存，没有固定的时间，同样地，对于有volatile语义声明的变量，线程A执行完后会强制将值刷新到内存中，线程B进行相关操作时会强制重新把内存中的内容写入到自己的缓存，这就涉及到了volatile的写入屏障问题，当然也就是所谓happen-before问题。","like_count":585,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441105,"discussion_content":"厉害厉害，比我回答的全面多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551369165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1015877,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/45/d719f7df.jpg","nickname":"李和桃","note":"","ucode":"97E66953070EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":552853,"discussion_content":"老师好，可以理解为volatile保证了高级语法层面的原子性吗？new对应的3个指令都完成的话，即使是无序执行，保证原子性、保证后续线程可见性，感觉也是可以说得通的。另外，如何甄别指令的顺序是否被优化过呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645613620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":441105,"ip_address":""},"score":552853,"extra":""},{"author":{"id":1433986,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e1/82/1c5d285d.jpg","nickname":"(￣o￣) . z Z","note":"","ucode":"42F97D91001DD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015877,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/45/d719f7df.jpg","nickname":"李和桃","note":"","ucode":"97E66953070EE0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591201,"discussion_content":"volatile是解决了可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666360051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":552853,"ip_address":"福建"},"score":591201,"extra":""}]},{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288169,"discussion_content":"java1.5之前volatile只能解决可见性，即cpu缓存问题，不能解决重排序问题，1.5对volatile进行了增强，线程A中对instance的写不会发生重排序，以上分析了java1.5对编译器的优化，实际上java也从语法层面给了承诺，这就是volatile的happens beffore规则:  volatile写始终对volatile读可见，即线程A对instance的写，在之后读的线程B中一定能读到完整的instance。\n\n可能还有些同学会疑惑java不是早就提供了锁的happens before规则么？这里也加锁了呀，为什么不能防止重排序呢？\n那是因为发生问题时线程B并没有获取锁，这里的问题是在第一个判断instance是否为空时错误的认为不为空，导致直接返回了。\n换句话说如果线程C在判断1时线程A还未给instance赋值，然后线程C等待锁，然后线程A给instance赋值内存地址，然后切换线程C，那切换多少次线程C也无法获得锁，只有线程A正确的在内存初始化对象以后释放锁，线程C才能获得锁，之后您说线程A对instance的写对于线程C是不是可见呢？答案是肯定的，这就是解锁前的操作对加锁后的线程可见。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1593668103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1654600,"avatar":"","nickname":"xanxus","note":"","ucode":"FFF1EFD2ABCBAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311122,"discussion_content":"如果instance中属性全部是final修饰，是不是就没有这个问题了？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602229345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288169,"ip_address":""},"score":311122,"extra":""},{"author":{"id":1068432,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/90/25b6f544.jpg","nickname":"马文龙","note":"","ucode":"679B0F0AB402C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334499,"discussion_content":"解锁前的操作对加锁后的线程可见 这句话没有理解？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607868017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288169,"ip_address":""},"score":334499,"extra":""},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348857,"discussion_content":"一句 发生问题时线程B并没有获取锁解惑了，感谢","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1612755459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288169,"ip_address":""},"score":348857,"extra":""}]},{"author":{"id":1534995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/6c/13/c4e2ea42.jpg","nickname":"憨鸠仔","note":"","ucode":"689FAD5469AEB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269674,"discussion_content":"new对象的直接码好像分为四步，要是在其中发生指令重拍，其他线程会判断到该对象不为Null（实际上只是引用被赋了值但是是实际上引用指向的那片堆内存里还没有把对象初始化）就直接不进入锁然后拿去用了，用的时候其实是一个未被初始化的对象。所有要加volatile关键字，通过内存屏障的原理（jvm实现规范里规定了四种写写 写读 读写 读读等要保证指令执行的顺序），来让读写该对象是不会发生指令重排。然后os会提供一下语义函数来达到上面的规范，不过hotspot为防止有些操作系统不支持，所以简单粗暴的在底层用了lock总线的方式去实现","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1589937121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2c/52/a681c260.jpg","nickname":"鳄鱼","note":"","ucode":"B59333FE2804BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36335,"discussion_content":"线程A把空对象的内存地址赋值给instance之后，发生线程切换（线程A的时间片正好用完），而线程B能马上读到instance更新之后的值，是不是意味着线程B和线程A在用同一个cpu，共享同一个cpu的缓存？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1571364145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1693414,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d6/e6/87234c32.jpg","nickname":"木心云影","note":"","ucode":"5F7244D779AD9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1256530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2c/52/a681c260.jpg","nickname":"鳄鱼","note":"","ucode":"B59333FE2804BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50884,"discussion_content":"很有可能","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573782671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36335,"ip_address":""},"score":50884,"extra":""},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1256530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2c/52/a681c260.jpg","nickname":"鳄鱼","note":"","ucode":"B59333FE2804BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286536,"discussion_content":"我也有这个疑问呢，实例变量没volatile修饰，又是怎么保证的可见性呢？仅仅同核这个情况是有可能，但是不同核呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593219875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36335,"ip_address":""},"score":286536,"extra":""},{"author":{"id":1494880,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cf/60/9100ad4f.jpg","nickname":"周星平","note":"","ucode":"1FDCB487392B03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1256530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2c/52/a681c260.jpg","nickname":"鳄鱼","note":"","ucode":"B59333FE2804BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287746,"discussion_content":"synchronized保证了可见性，释放锁之前cpu缓存的数据要更新到内存中，示例是对类对象加锁，所以数据修改是可见的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1593526348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36335,"ip_address":""},"score":287746,"extra":""}]},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560239,"discussion_content":"但是 图解Java并发编程书籍不推荐 volatile 做法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649236078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2291909,"avatar":"","nickname":"Geek_6f3f68","note":"","ucode":"537B28473CC217","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377213,"discussion_content":"等谢谢列子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622551300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2291909,"avatar":"","nickname":"Geek_6f3f68","note":"","ucode":"537B28473CC217","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375733,"discussion_content":"好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621834618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1185424,"avatar":"https://static001.geekbang.org/account/avatar/00/12/16/90/21f4035c.jpg","nickname":"聪","note":"","ucode":"EBF8A23383D59F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372459,"discussion_content":"这里我们以为的执行顺序 1, 2, 3， 是指指令正常的顺序么？ 主要是想了解一下变为1, 3, 2 是正常的指令顺序，还是指令重拍优化后的顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620346816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350889,"discussion_content":"专栏实例代码应该注意一下代码质量吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614065120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371571,"discussion_content":"我怀疑作者故意这样做，评论区讨论下，不是很热闹吗？看高手补充额外知识，多有意思😄😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619852391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350889,"ip_address":""},"score":371571,"extra":""},{"author":{"id":1662987,"avatar":"https://static001.geekbang.org/account/avatar/00/19/60/0b/d7dddf19.jpg","nickname":"皮皮","note":"","ucode":"8C986AA546B44E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586418,"discussion_content":"你指的是哪些？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662194397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350889,"ip_address":"江苏"},"score":586418,"extra":""}]},{"author":{"id":2282481,"avatar":"","nickname":"Geek_157395","note":"","ucode":"D00CBA7A104FE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341296,"discussion_content":"为什么指令重排序就能够避免该情况发生？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610370202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2343943,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c4/07/6960f55a.jpg","nickname":"Register","note":"","ucode":"D8C42B059FF9BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2282481,"avatar":"","nickname":"Geek_157395","note":"","ucode":"D00CBA7A104FE6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348567,"discussion_content":"避免指令重拍就会按顺序执行，就不会在没有实例化对象前就把对象空间返回给instance。计算在执行new操作第一步分配空间后切换线程，instance变量仍然是null，线程b会去执行获取锁的操作，因锁未释放而等待。这样线程b不会发生返回一个null对象的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612625704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":341296,"ip_address":""},"score":348567,"extra":""}]},{"author":{"id":2184887,"avatar":"https://static001.geekbang.org/account/avatar/00/21/56/b7/b26eee1b.jpg","nickname":"刘洋","note":"","ucode":"97658A8F49EF4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334749,"discussion_content":"懂了，由于指令重排的缘故，如果在内存指向变量后，时间片切换，这个变量就有内存地址不为空了，然后b线程就获取到这个变量，如果有什么操作就会报空指针异常，因为还没初始化，方法和变量什么的都还没有，初始化这方面还需要去了解了解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607957719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1404537,"avatar":"https://static001.geekbang.org/account/avatar/00/15/6e/79/772d64f8.jpg","nickname":"富大海","note":"","ucode":"365FACE3567CEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93285,"discussion_content":"为什么加volatile能解决这个问题，做下简单补充，因为volatile有和synchronized一样的内存语义，volatile的读/写==锁的释放/获取。volatile本身对于单个变量就是有可见性和原子性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576919004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1654600,"avatar":"","nickname":"xanxus","note":"","ucode":"FFF1EFD2ABCBAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1404537,"avatar":"https://static001.geekbang.org/account/avatar/00/15/6e/79/772d64f8.jpg","nickname":"富大海","note":"","ucode":"365FACE3567CEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179919,"discussion_content":"volatitle无法保证原子性","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1582261305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":93285,"ip_address":""},"score":179919,"extra":""},{"author":{"id":1115302,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","nickname":"Airsaid","note":"","ucode":"5B90BC0044F376","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1404537,"avatar":"https://static001.geekbang.org/account/avatar/00/15/6e/79/772d64f8.jpg","nickname":"富大海","note":"","ucode":"365FACE3567CEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192257,"discussion_content":"volatile 只能保证可见性无法保证原子性喔","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1583070296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":93285,"ip_address":""},"score":192257,"extra":""}]},{"author":{"id":1125985,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2e/61/72a083ea.jpg","nickname":"小公司都不给我进就赖门口哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈","note":"","ucode":"10C8AF52F68A29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2047,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563202310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1373230,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/x86UN2kFbJGGwiaw7yeVtyaf05y5eZmdOciaAF09WEBRVicbPGsej1b62UAH3icjeJqvibVc6aqB0EuFwDicicKKcF47w/132","nickname":"Eco","note":"","ucode":"5459B494753183","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1444,"discussion_content":"厉害👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562634882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71225,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1399673,"ip_address":"","ucode":"929E3FFD14EFC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/5b/79/d55044ac.jpg","comment_is_top":false,"comment_ctime":1551287942,"is_pvip":false,"replies":[{"id":"25643","content":"正解","user_name":"作者回复","comment_id":71225,"uid":"1269969","ip_address":"","utype":1,"ctime":1551367560,"user_name_real":"王宝令"}],"discussion_count":10,"race_medal":0,"score":"1470430103174","product_id":100023901,"comment_content":"long类型64位，所以在32位的机器上，对long类型的数据操作通常需要多条指令组合出来，无法保证原子性，所以并发的时候会出问题🌝🌝🌝","like_count":343,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441056,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551367560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1692756,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d4/54/7263deb2.jpg","nickname":"吃饭","note":"","ucode":"AF0D7165D5F049","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":538927,"discussion_content":"怎么证明这个事儿，我尝试很多demo，没有办法完美证明这个事儿","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639558251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":441056,"ip_address":""},"score":538927,"extra":""},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1692756,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d4/54/7263deb2.jpg","nickname":"吃饭","note":"","ucode":"AF0D7165D5F049","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560240,"discussion_content":"jvm 那本书上写过 就是理论上会出现 但是jvm的实现hotsot虚拟机实现了 long64位的原子性赋值，因此也就没有了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649236190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":538927,"ip_address":""},"score":560240,"extra":""},{"author":{"id":1133194,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","nickname":"makermade","note":"","ucode":"03386B90CB8F20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1692756,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d4/54/7263deb2.jpg","nickname":"吃饭","note":"","ucode":"AF0D7165D5F049","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574090,"discussion_content":"规范不等于实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653831572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":538927,"ip_address":""},"score":574090,"extra":""}]},{"author":{"id":1069203,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/93/e9755d47.jpg","nickname":"mbond","note":"","ucode":"41D88206637E96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240056,"discussion_content":"这个应该说的是赋值吧，对long操作本身就是非原子操作，就有线程安全问题，32位机器给64位long赋值应该存在多条指令，double也一样","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587317929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145942,"discussion_content":"你是怎么知道long类型是64位的，难道这就是和科班的差距吗😭","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579590226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1800886,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7a/b6/f54bbfaa.jpg","nickname":"花郎世纪","note":"","ucode":"301DF9B6375E08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":178599,"discussion_content":"Long在java中是8字节鸭","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582179344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":145942,"ip_address":""},"score":178599,"extra":""},{"author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":300737,"discussion_content":"Java基础知识","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598251478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":145942,"ip_address":""},"score":300737,"extra":""}]},{"author":{"id":1958492,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MxzHxqmS2L7ZJy160Immet3b5QhZbHSlx0bDeKzvKSCJvSt1DZMDIz4g2Pt2LpbOIicXsOInSJI5PDOWt1JCofg/132","nickname":"xty","note":"","ucode":"CC2625DC79431B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380090,"discussion_content":"请教下，这种情况解决方法是啥呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624338106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f0/a5/6934a639.jpg","nickname":"赖学良","note":"","ucode":"99E63A28E0CDAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1958492,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MxzHxqmS2L7ZJy160Immet3b5QhZbHSlx0bDeKzvKSCJvSt1DZMDIz4g2Pt2LpbOIicXsOInSJI5PDOWt1JCofg/132","nickname":"xty","note":"","ucode":"CC2625DC79431B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386636,"discussion_content":"AtomicLong了解下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627703464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380090,"ip_address":""},"score":386636,"extra":""}]}]},{"had_liked":false,"id":76758,"user_name":"别皱眉","can_delete":false,"product_type":"c1","uid":1177354,"ip_address":"","ucode":"D24F65EFF65586","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg","comment_is_top":false,"comment_ctime":1552702152,"is_pvip":false,"replies":[{"id":"27988","content":"没问题，总结的太到位了！！！","user_name":"作者回复","comment_id":76758,"uid":"1269969","ip_address":"","utype":1,"ctime":1552704995,"user_name_real":"王宝令"}],"discussion_count":18,"race_medal":0,"score":"710222305992","product_id":100023901,"comment_content":"周末了<br>对留言问题总结一下<br> <br>------可见性问题------<br>对于可见性那个例子我们先看下定义:<br>可见性:一个线程对共享变量的修改，另外一个线程能够立刻看到<br> <br>并发问题往往都是综合证，这里即使是单核CPU，只要出现线程切换就会有原子性问题。但老师的目的是为了让大家明白什么是可见性<br>或许我们可以把线程对变量的读可写都看作时原子操作，也就是cpu对变量的操作中间状态不可见，这样就能更加理解什么是可见性了。<br> <br>------CPU缓存刷新到内存的时机------<br>cpu将缓存写入内存的时机是不确定的。除非你调用cpu相关指令强刷<br> <br>------双重锁问题------<br>如果A线程与B线程如果同时进入第一个分支，那么这个程序就没有问题<br> <br>如果A线程先获取锁并出现指令重排序时，B线程未进入第一个分支，那么就可能出现空指针问题，这里说可能出现问题是因为当把内存地址赋值给共享变量后，CPU将数据写回缓存的时机是随机的<br> <br>------ synchronized------<br>线程在synchronized块中，发生线程切换，锁是不会释放的<br> <br>------指令优化------<br>除了编译优化,有一部分可以通过看汇编代码来看，但是CPU和解释器在运行期也会做一部分优化，所以很多时候都是看不到的，也很难重现。<br> <br>------JMM模型和物理内存、缓存等关系------<br>内存、cpu缓存是物理存在，jvm内存是软件存在的。<br>关于线程的工作内存和寄存器、cpu缓存的关系 大家可以参考这篇文章<br>https:&#47;&#47;blog.csdn.net&#47;u013851082&#47;article&#47;details&#47;70314778&#47;<br> <br>------IO操作------<br>io操作不占用cpu，读文件，是设备驱动干的事，cpu只管发命令。发完命令，就可以干别的事情了。<br> <br> <br>------寄存器切换------ <br>寄存器是共用的，A线程切换到B线程的时候，寄存器会把操作A的相关内容会保存到内存里，切换回来的时候，会从内存把内容加载到寄存器。可以理解为每个线程有自己的寄存器<br> <br>请老师帮忙看看，有没问题。希望我的总结能帮到更多人😄😄","like_count":165,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443436,"discussion_content":"没问题，总结的太到位了！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552704995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284293,"avatar":"https://static001.geekbang.org/account/avatar/00/13/98/c5/7105ea6c.jpg","nickname":"xuxq","note":"","ucode":"96E1C17D11F54E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160693,"discussion_content":"------JMM模型和物理内存、缓存等关系------\n内存、cpu缓存是物理存在，jvm内存是软件存在的。\n关于线程的工作内存和寄存器、cpu缓存的关系 大家可以参考这篇文章\nhttps://blog.csdn.net/u013851082/article/details/70314778/\n\n这个链接很受用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580823914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1306394,"avatar":"","nickname":"Aiome","note":"","ucode":"5D3A810C0FF56B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1284293,"avatar":"https://static001.geekbang.org/account/avatar/00/13/98/c5/7105ea6c.jpg","nickname":"xuxq","note":"","ucode":"96E1C17D11F54E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303048,"discussion_content":"这个说的是错的，建议看看这个\nhttps://blog.csdn.net/javazejian/article/details/72772461","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599121296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":160693,"ip_address":""},"score":303048,"extra":""}]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378422,"discussion_content":"这个寄存器怎么感觉那么像JVM运行时数据区的程序计数器。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623217956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2651360,"avatar":"https://static001.geekbang.org/account/avatar/00/28/74/e0/6be55bc4.jpg","nickname":"Petrichor","note":"","ucode":"DA41198FB15921","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378281,"discussion_content":"如果A线程与B线程如果同时进入第一个分支，就有可能会出现例子当中出现的情况吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623145600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200275,"avatar":"https://static001.geekbang.org/account/avatar/00/12/50/93/dfc3c214.jpg","nickname":"肉球明晖","note":"","ucode":"E5E3CAED3A1029","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367212,"discussion_content":"能否举一个例子说明，在单核CPU的情形下，多线程的切换因为可见性的问题引发安全问题？我以为单核CPU的情况下，可见性不是问题，毕竟CPU缓存只有一份，不存在数据不一致的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618295090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1200275,"avatar":"https://static001.geekbang.org/account/avatar/00/12/50/93/dfc3c214.jpg","nickname":"肉球明晖","note":"","ucode":"E5E3CAED3A1029","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371856,"discussion_content":"像你说的单核CPU下确实没有可见性问题。老师后面评论区里有讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620026577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367212,"ip_address":""},"score":371856,"extra":""}]},{"author":{"id":1909094,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/21/66/85f247e2.jpg","nickname":"谢作作的男人","note":"","ucode":"4F220EA8AEBFB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366758,"discussion_content":"寄存器不是共用的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618187473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361570,"discussion_content":"寄存器切换的说法不对吧，如果每回切换都写回内存，那就没可见性的问题了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616687943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1692756,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d4/54/7263deb2.jpg","nickname":"吃饭","note":"","ucode":"AF0D7165D5F049","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":538928,"discussion_content":"写回线程的工作内存，而不是主内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639558455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361570,"ip_address":""},"score":538928,"extra":""}]},{"author":{"id":2012694,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b6/16/25086a6c.jpg","nickname":"雨下一整晚","note":"","ucode":"A91D76105BF84C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298800,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597403855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288360,"discussion_content":"mark,解惑了关于线程切换保存现场的描述，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593737752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1308012,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f5/6c/15cf15fe.jpg","nickname":"李","note":"","ucode":"CAD59DDBB20C68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287306,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593413715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213887,"discussion_content":"大佬真的强，清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585131313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143501,"discussion_content":"牛啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579511417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257043,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","nickname":"狼的诱惑","note":"","ucode":"AE89DFC5963C42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73098,"discussion_content":"牛逼了老哥，不知道说啥了，总结的真牛逼🐮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575552770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1900,"discussion_content":"厉害了老哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563075709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344828,"avatar":"https://static001.geekbang.org/account/avatar/00/14/85/3c/9cf528ee.jpg","nickname":"大力出奇迹","note":"","ucode":"AEA7CD54BB4C57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361,"discussion_content":"清晰明了，受教了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561476973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71258,"user_name":"任大鹏","can_delete":false,"product_type":"c1","uid":1069049,"ip_address":"","ucode":"75D14B0FC68DA5","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/f9/1f0a9665.jpg","comment_is_top":false,"comment_ctime":1551314273,"is_pvip":false,"replies":[{"id":"25649","content":"正解！感谢回复。","user_name":"作者回复","comment_id":71258,"uid":"1269969","ip_address":"","utype":1,"ctime":1551367985,"user_name_real":"王宝令"}],"discussion_count":7,"race_medal":0,"score":"688746081633","product_id":100023901,"comment_content":"对于阿根一世同学的那个疑问，我个人认为CPU时间片切换后，线程B刚好执行到第一次判断instance==null，此时不为空，不用进入synchronized里，就将还未初始化的instance返回了","like_count":160,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441073,"discussion_content":"正解！感谢回复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551367985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014573,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","nickname":"SharpBB","note":"","ucode":"D30C5B798B8E8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404680,"discussion_content":"可是未初始化不是null吗 那==null 应该再进去里面啊。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634382671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1744468,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9e/54/175301d9.jpg","nickname":"不知水歌","note":"","ucode":"097A2C820D2EEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253456,"discussion_content":"那这样如何可以解决？第一次判断不用了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588236168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1744468,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9e/54/175301d9.jpg","nickname":"不知水歌","note":"","ucode":"097A2C820D2EEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289032,"discussion_content":"使用volatile避免指令重排。这样就不会有未初始化的内存被暴露了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1593959096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":253456,"ip_address":""},"score":289032,"extra":""}]},{"author":{"id":1481329,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9a/71/bc179e8f.jpg","nickname":"达拉崩巴斑得贝迪卜多比鲁翁·李","note":"","ucode":"37FA0958D8549A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49740,"discussion_content":"大佬我有个问题，instance未初始化时instance是不为null的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573627798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1693414,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d6/e6/87234c32.jpg","nickname":"木心云影","note":"","ucode":"5F7244D779AD9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1481329,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9a/71/bc179e8f.jpg","nickname":"达拉崩巴斑得贝迪卜多比鲁翁·李","note":"","ucode":"37FA0958D8549A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50889,"discussion_content":"给了你地址但是没有初始化，这就好像给你一块田，但是没有播种，那当然就么有粮食了，就是一块荒田，所以是null","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573782990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49740,"ip_address":""},"score":50889,"extra":""}]},{"author":{"id":1133702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","nickname":"angel😇txy🤓","note":"","ucode":"C0AEE0D8BAF7ED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5612,"discussion_content":"这是代码理解的问题，和线程安全问题关系不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566378486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71475,"user_name":"嘎嘎","can_delete":false,"product_type":"c1","uid":1442466,"ip_address":"","ucode":"69CDD8C80ECB3E","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/a2/6ff070ee.jpg","comment_is_top":false,"comment_ctime":1551349611,"is_pvip":false,"replies":[{"id":"25684","content":"厉害，一看就是经验丰富","user_name":"作者回复","comment_id":71475,"uid":"1269969","ip_address":"","utype":1,"ctime":1551371139,"user_name_real":"王宝令"}],"discussion_count":50,"race_medal":0,"score":"461112850283","product_id":100023901,"comment_content":"针对阿根一世的问题，问题其实出现在new Singleton()这里。<br>这一行分对于CPU来讲，有3个指令：<br>1.分配内存空间<br>2.初始化对象<br>3.instance引用指向内存空间<br>正常执行顺序1-2-3<br>但是CPU重排序后执行顺序可能为1-3-2，那么问题就来了<br>步骤如下：<br>1.A、B线程同时进入了第一个if判断<br>2.A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();<br>3.然后线程A执行1-&gt; JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance<br>4.在还没有进行第三步（将instance引用指向内存空间）的时候，线程A离开了synchronized块<br>5.线程B进入synchronized块，读取到了A线程返回的instance，此时这个instance并未进行物理地址指向，是一个空对象。<br>有人说将对象设置成volatile，其实也不能完全解决问题。volatile只是保证可见性，并不保证原子性。<br><br>现行的比较通用的做法就是采用静态内部类的方式来实现。<br>public class MySingleton {<br>\t<br>\t&#47;&#47;内部类<br>\tprivate static class MySingletonHandler{<br>\t\tprivate static MySingleton instance = new MySingleton();<br>\t} <br>\t<br>\tprivate MySingleton(){}<br>\t <br>\tpublic static MySingleton getInstance() { <br>\t\treturn MySingletonHandler.instance;<br>\t}<br>}","like_count":107,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441173,"discussion_content":"厉害，一看就是经验丰富","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551371139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143481,"discussion_content":"volatile是没问题的，上面问题的关键就是编译优化后排序不一致，而volatile可以阻止指令重排序","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1579509852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1909094,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/21/66/85f247e2.jpg","nickname":"谢作作的男人","note":"","ucode":"4F220EA8AEBFB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266520,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589525930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":143481,"ip_address":""},"score":266520,"extra":""},{"author":{"id":1488038,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","nickname":"渠梁","note":"","ucode":"DC86BDEC63C9BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305136,"discussion_content":"是的，正解。楼主别误导别人","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599792633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":143481,"ip_address":""},"score":305136,"extra":""}]},{"author":{"id":1555565,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","nickname":"汤小高","note":"","ucode":"D4AB7766273D52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141109,"discussion_content":"这个回答是有问题的，希望作者还是尽量先看清同学们回答的问题，再做回复，不然会误导很多人的@作者","likes_number":20,"is_delete":false,"is_hidden":false,"ctime":1579397702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1909094,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/21/66/85f247e2.jpg","nickname":"谢作作的男人","note":"","ucode":"4F220EA8AEBFB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1555565,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","nickname":"汤小高","note":"","ucode":"D4AB7766273D52","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266521,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589525944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":141109,"ip_address":""},"score":266521,"extra":""},{"author":{"id":1708271,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/10/ef/4c9b2383.jpg","nickname":"Everlaa","note":"","ucode":"9B4FFFABD62B07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1555565,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","nickname":"汤小高","note":"","ucode":"D4AB7766273D52","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328202,"discussion_content":"商业互吹，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606102345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":141109,"ip_address":""},"score":328202,"extra":""}]},{"author":{"id":1359862,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/f6/1051e608.jpg","nickname":"笑对人生","note":"","ucode":"6E97287E017A3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278981,"discussion_content":"线程B进入了synchronized块也是错误的，A没有释放怎么进入，感觉在误导，A线程拿到锁版初始化，切换到B线程，B在第一次判断空的时候，不为空，然后就反回了，所以出问题，B线程根本就拿不到锁，所以不要误导别人说B线程进入同步块synchronized","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1591267718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2220763,"avatar":"https://static001.geekbang.org/account/avatar/00/21/e2/db/97c6f756.jpg","nickname":"_patrick","note":"","ucode":"B24C6EEBCABB94","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1359862,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/f6/1051e608.jpg","nickname":"笑对人生","note":"","ucode":"6E97287E017A3B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571673,"discussion_content":"线程B 可以拿到锁，第一次判断的时候 还没有去抢锁。  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652341809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278981,"ip_address":""},"score":571673,"extra":""}]},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86112,"discussion_content":"你这个回答有点问题，借用后面哥子冯治刚的回答：volatile禁止指令重排，所以instance得初始化过程不会重排，也就不会存在拿到空内存地址的instance。这不就间接地解决了这个NPE问题了吗？虽然不保证原子性，但起码不会出现问题。所以我认为加volatile是没问题的。","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1576589944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301425,"discussion_content":"第一，出现空指针异常的原因，不是因为还没释放锁，只是因为外面的if判断，if判断到变量不为空，拿到了地址值，但是这块地址还没初始化对象，直接使用，会出现空指针异常。\n第二，加volatile是可以解决的，之所以new的三条指令中的赋值操作会放到初始化操作指令之前，这本身是编译器优化的结果，因为这样能节省执行时间，但是却带来了空指针异常问题，所以加volatile，禁止把赋值操作重排序到初始化操作之前，原理其实就是内存屏障，内存屏障也是靠cpu指令来实现的，这样保证了，先赋值操作，然后在把地址值赋给变量，就解决了空指针问题。","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1598522442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1057295,"avatar":"https://static001.geekbang.org/account/avatar/00/10/22/0f/3e092988.jpg","nickname":"Pony","note":"","ucode":"05AAC3C8A30326","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17525,"discussion_content":"【在还没有进行第三步（将instance引用指向内存空间）的时候，线程A离开了synchronized块】 @作者，这句话是不对的吧？","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1568968992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1510991,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0e/4f/b74d83af.jpg","nickname":"漠","note":"","ucode":"FDE237E129C45E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1057295,"avatar":"https://static001.geekbang.org/account/avatar/00/10/22/0f/3e092988.jpg","nickname":"Pony","note":"","ucode":"05AAC3C8A30326","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284875,"discussion_content":"应该是CPU时间片切换到了线程B，B判空不进入，直接返回了不完整的instance，此时线程A并未释放锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592665702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":17525,"ip_address":""},"score":284875,"extra":""}]},{"author":{"id":1518884,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2d/24/797bec43.jpg","nickname":"颖儿","note":"","ucode":"585FEBCBE0B5A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4160,"discussion_content":"我觉得volatile是可以的。happens-before规则volatile变量规则，对一个volatile域的写，happens-before于任意后续对这个volatile的读。《Java并发编程艺术》一书中p71~p72页中写，volatile修饰的变量，会禁止2,3的重排序，会是正常的顺序。","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1565178053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1920896,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4f/80/19f946ba.jpg","nickname":"Zain","note":"","ucode":"03EDF7B1BE9CF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1518884,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2d/24/797bec43.jpg","nickname":"颖儿","note":"","ucode":"585FEBCBE0B5A6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545418,"discussion_content":"正常顺序并不能保证原子性啊，一个线程操作了前32位，另外一个线程改32位，volatile只是保证可见性，不能原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641954532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4160,"ip_address":""},"score":545418,"extra":""}]},{"author":{"id":1961855,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/ef/7f/8b69e4aa.jpg","nickname":"二月","note":"","ucode":"0624B1B40CDBF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276566,"discussion_content":"这个评论回答明显有问题，还请老师看清回答，再回复是否正解，不然很容易误导人。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1590902942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1708271,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/10/ef/4c9b2383.jpg","nickname":"Everlaa","note":"","ucode":"9B4FFFABD62B07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1961855,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/ef/7f/8b69e4aa.jpg","nickname":"二月","note":"","ucode":"0624B1B40CDBF9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328201,"discussion_content":"商业互吹，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606102306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":276566,"ip_address":""},"score":328201,"extra":""}]},{"author":{"id":1625515,"avatar":"","nickname":"Thong2018","note":"","ucode":"DA05A3B08D1DEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5884,"discussion_content":"synchronized不是可以保证原子性吗？为什么将instance引用指向内存空间的时候，线程A会离开synchronized块呢？线程A不是应该将synchronized块执行完结束之后再离开吗？","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1566525310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1625515,"avatar":"","nickname":"Thong2018","note":"","ucode":"DA05A3B08D1DEA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357385,"discussion_content":"请问有答案了吗？这个问题也在困扰着我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615798836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5884,"ip_address":""},"score":357385,"extra":""},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":378471,"discussion_content":"这里应该不是从a切换出去，应该是在执行完指令2，还未执行完指令3的时候，新来了一个线程b，线程b这个时候由于可见性（此时instance的内存地址已经刷到主内存了），能看到instance不为空，其实为空，从而导致npe。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623238556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":357385,"ip_address":""},"score":378471,"extra":""},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":378473,"discussion_content":"synchronized保证的是代码块里面的原子性，线程a获取到代码块资源在行完代码块之前不会离开，但是cpu的执行权可能会由b抢占（总不可能在a获取到cpu资源之后，a不释放cpu，cpu资源就被阻塞，其他线程就不能获取cpu资源吧），","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623238922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":357385,"ip_address":""},"score":378473,"extra":""}]},{"author":{"id":1095584,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b7/a0/646a7926.jpg","nickname":"老挝国花","note":"","ucode":"F47C03CFEF9142","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7217,"discussion_content":"就算在单核里面，发生了时间片切换，线程A就出了管存吗？线程B就能进去吗？Happen-before规则呢 ","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1567420487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188517,"avatar":"http://thirdwx.qlogo.cn/mmopen/g7TWmGqjoiaSFWknFpTPAia5rPOmzEZiaGK8icd5HGEXlfaYJBoKvLn5BkqGkyTZOqDTC3NMHXUbH3tdLJzicAyickRYdP4xcM3ajia/132","nickname":"sudo","note":"","ucode":"EA0F8116999557","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3501,"discussion_content":"第一个if， 不需要加锁吧。 线程A切换的时候，就算没有释放锁。线程B也可以进入第一层if, 直接返回线程A未初始化的对象。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564539989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1662987,"avatar":"https://static001.geekbang.org/account/avatar/00/19/60/0b/d7dddf19.jpg","nickname":"皮皮","note":"","ucode":"8C986AA546B44E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586419,"discussion_content":"枚举呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662194515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591405,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqqtFTbZcJcKq4icuCF8I3VoLMK3W8sx9askp6vrnY3DLtghI7svXpMIchn44ySY24ic4l8ADWFibLJA/132","nickname":"jack","note":"","ucode":"5EE763FEA7D755","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413319,"discussion_content":"建议似懂非懂的同学还是不要评论了，以免误导我们这些新同学","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636444670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2291909,"avatar":"","nickname":"Geek_6f3f68","note":"","ucode":"537B28473CC217","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377214,"discussion_content":"学习下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622551692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1348822,"avatar":"https://static001.geekbang.org/account/avatar/00/14/94/d6/a0ea3d46.jpg","nickname":"何谐","note":"","ucode":"273BB45E4865A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280164,"discussion_content":"我理解的new发生了重排序，内存地址分配了，这是B线程看到的不是空，这样b线程获取的单例。但这个单例构造函数还没调用，field可能为空，直接使用就有问题了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591508741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1895320,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/KiaBJsepm9fHHicfPxiahhR3RqRaR4QH6YFibIHV5o5VspTIXmH72iaiaotb4cRpWtRvLC7mnh5KH1KlSNLGWlI7wUicQ/132","nickname":"Rorchachl","note":"","ucode":"7AABFF65A0033C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222261,"discussion_content":"这个估计得把java代码翻译成汇编 然后看汇编指令 但是我只会看一点😭","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586106207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581294,"avatar":"","nickname":"Geek_be4cec","note":"","ucode":"C87642D655EAC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3412,"discussion_content":"静态内部类也有一个弊端呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564467041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1601182,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6e/9e/377f5a9f.jpg","nickname":"刘凯","note":"","ucode":"0EB92A006E19E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1662,"discussion_content":"volatile是不可以防止编译器的指令顺序变化，从而防止这个问题？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562779006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1437158,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ed/e6/75a32708.jpg","nickname":"日拱一兵","note":"","ucode":"D6386E5CD7C061","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1601182,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6e/9e/377f5a9f.jpg","nickname":"刘凯","note":"","ucode":"0EB92A006E19E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5346,"discussion_content":"个人认为，老师给的例子确实是发生了重排序，但解决这个问题是要确保数据可见，是两个维度看待这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566197947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1662,"ip_address":""},"score":5346,"extra":""}]},{"author":{"id":1326060,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3b/ec/69848c5a.jpg","nickname":"醉歌","note":"","ucode":"6789093C19A633","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586470,"discussion_content":"就NPE","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662255351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326060,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3b/ec/69848c5a.jpg","nickname":"醉歌","note":"","ucode":"6789093C19A633","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586469,"discussion_content":"不过，既然存在这个可能性，就会存在B到时间片，但是是不经过锁的，直接判断，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662255334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326060,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3b/ec/69848c5a.jpg","nickname":"醉歌","note":"","ucode":"6789093C19A633","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586468,"discussion_content":"所以，别说啥资源切换，缪论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662255049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326060,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3b/ec/69848c5a.jpg","nickname":"醉歌","note":"","ucode":"6789093C19A633","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586467,"discussion_content":"在补充一点synchronized，保证了即便线程切换，锁不会释放","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662255023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326060,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3b/ec/69848c5a.jpg","nickname":"醉歌","note":"","ucode":"6789093C19A633","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586466,"discussion_content":"没有执行完怎么离开，4错了，5因锁没释放，不能进来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662254838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047127,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bOhve1DBV2oShl2JrXDib4J1T7LciagcB8jogD5c7pvt8Zv7Bq23Zfnl70cf2R81r8ia947Hbib9FZia56sdx9wcEibA/132","nickname":"小样","note":"","ucode":"0D670431F19A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554204,"discussion_content":"“4.在还没有进行第三步（将instance引用指向内存空间）的时候，线程A离开了synchronized块”步骤没有执行完之前不会离开synchronized块吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646270586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532941,"discussion_content":"对于评论区的讨论说一下自己的看法。\n1.首先线程A 初始化对象会分为三句话：\na.allocate(memory)\nb.init(instance)\nc. return instance\n\n因为a对于b，c来说是先后依赖关系，所以b c会发生重排序，那么对于线程A来说会不会有问题 ？其实也会有NPE风险\n\n2.对于线程B来说 当他第一次判断非空条件时是能看到变量的。为什么呢？因为此时线程A解锁了 但上述的b操作还没执行完，故根据JSR-133 unlock语义会flush 变量 ，此时线程B就因为是第一次加载要做一次load - read ，故能看到instance变量\n\n最后说下解决方法：加volatile","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637735944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1273891,"avatar":"https://static001.geekbang.org/account/avatar/00/13/70/23/92d188aa.jpg","nickname":"olivia-byte","note":"","ucode":"D54B3833995923","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277256,"discussion_content":"线程a被切换时间片后线程b能进入synchronized？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591021195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1175383,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ef/57/935c0ea1.jpg","nickname":"0+1","note":"","ucode":"03E5A11F8A3D37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1273891,"avatar":"https://static001.geekbang.org/account/avatar/00/13/70/23/92d188aa.jpg","nickname":"olivia-byte","note":"","ucode":"D54B3833995923","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283509,"discussion_content":"进入不了，但是进入之前的if判断，此时的instance是非空的，因为instance是在sync同步代码块里的，具备可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592286035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277256,"ip_address":""},"score":283509,"extra":""},{"author":{"id":1591405,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqqtFTbZcJcKq4icuCF8I3VoLMK3W8sx9askp6vrnY3DLtghI7svXpMIchn44ySY24ic4l8ADWFibLJA/132","nickname":"jack","note":"","ucode":"5EE763FEA7D755","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1175383,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ef/57/935c0ea1.jpg","nickname":"0+1","note":"","ucode":"03E5A11F8A3D37","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304756,"discussion_content":"第一个if判断，不是A,B两个线程都进来了吗，怎么还回去判断呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599657727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283509,"ip_address":""},"score":304756,"extra":""}]},{"author":{"id":1066046,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","nickname":"灰太狼","note":"","ucode":"C17DD5D5ED9DC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":133285,"discussion_content":"嗯，说得好！不过用枚举更合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578959775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3353,"discussion_content":"步骤23","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564413352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3350,"discussion_content":"看不懂2怎么到3的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564413270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105246,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/5e/ddbdde5a.jpg","nickname":"邢宇超","note":"","ucode":"3113F55E60ADE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1312,"discussion_content":"我也有黑牛同学的这个疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562556055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344828,"avatar":"https://static001.geekbang.org/account/avatar/00/14/85/3c/9cf528ee.jpg","nickname":"大力出奇迹","note":"","ucode":"AEA7CD54BB4C57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360,"discussion_content":"【4.在还没有进行第三步（将instance引用指向内存空间）的时候，线程A离开了synchronized块】即使指令重排 ，没有完成三个步骤是不会释放锁的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561476926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344828,"avatar":"https://static001.geekbang.org/account/avatar/00/14/85/3c/9cf528ee.jpg","nickname":"大力出奇迹","note":"","ucode":"AEA7CD54BB4C57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1899,"discussion_content":"对，不会释放锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563075349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360,"ip_address":""},"score":1899,"extra":""},{"author":{"id":1057295,"avatar":"https://static001.geekbang.org/account/avatar/00/10/22/0f/3e092988.jpg","nickname":"Pony","note":"","ucode":"05AAC3C8A30326","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344828,"avatar":"https://static001.geekbang.org/account/avatar/00/14/85/3c/9cf528ee.jpg","nickname":"大力出奇迹","note":"","ucode":"AEA7CD54BB4C57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17522,"discussion_content":"我也认为【线程A离开了synchronized块】这句话是不对的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568968935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360,"ip_address":""},"score":17522,"extra":""},{"author":{"id":1218076,"avatar":"","nickname":"13501018051","note":"","ucode":"D90E50B9C249AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344828,"avatar":"https://static001.geekbang.org/account/avatar/00/14/85/3c/9cf528ee.jpg","nickname":"大力出奇迹","note":"","ucode":"AEA7CD54BB4C57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":108216,"discussion_content":"我也这样认为，希望老师能给出正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577626888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360,"ip_address":""},"score":108216,"extra":""}]}]},{"had_liked":false,"id":71244,"user_name":"阿根一世","can_delete":false,"product_type":"c1","uid":1442576,"ip_address":"","ucode":"6BE8C93AAECC9F","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/10/15f82d62.jpg","comment_is_top":false,"comment_ctime":1551311735,"is_pvip":false,"replies":[{"id":"25647","content":"后面好多同学已经帮我作答了，教好学生，饿死师傅啊","user_name":"作者回复","comment_id":71244,"uid":"1269969","ip_address":"","utype":1,"ctime":1551367890,"user_name_real":"王宝令"}],"discussion_count":9,"race_medal":0,"score":"443932943223","product_id":100023901,"comment_content":"对于双重锁检查那个例子，我有一个疑问，A如果没有完成实例的初始化，锁应该不会释放的，B是拿不到锁的，怎么还会出问题呢？","like_count":103,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441064,"discussion_content":"后面好多同学已经帮我作答了，教好学生，饿死师傅啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551367890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1175383,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ef/57/935c0ea1.jpg","nickname":"0+1","note":"","ucode":"03E5A11F8A3D37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283507,"discussion_content":"b来的时候，如果a正好执行完给变量instance赋值但是还没有初始化里面的成员变量，注意这时候a还是处于sync代码块里，但是由于sync代码块也具备可见性语义，也就是说volatile关键字的特性sync都具备，这时候如果cpu切换到b（或者另一个cpu上调度了b），那么b也就能看到instance不为空了","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1592285899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359658,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/2a/e56244c8.jpg","nickname":"彭昀磊","note":"","ucode":"1B12F73B56ABBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5293,"discussion_content":"b来的时候，进入第一个if判断，发现不为null，就直接返回未初始化的对象，根本无需等待a去释放锁。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1566140261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2116190,"avatar":"https://static001.geekbang.org/account/avatar/00/20/4a/5e/cb7ee00f.jpg","nickname":"clouds","note":"","ucode":"F33CF7D0C26A27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310395,"discussion_content":"不加volitail修饰的后果","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601815388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288358,"discussion_content":"楼主说的是第二次判断，下意识的认为线程认为第一个判断为空了，第二次判断没问题，因为会应用锁的happens before规则，所以这里对任何变量判断都不会有重排序问题，其实出问题的是可能是第一次判断，这次判断了没有加锁，如果是普通变量，那是没有happens before规则的，如果发生编译器或者cpu重排序，那么会出错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593737610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dc/65/3da02c30.jpg","nickname":"once","note":"","ucode":"7026094E0B99BF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":707,"discussion_content":"第一个if判断，是在临界区之外的，b线程不需要拿到锁，也是会走到这个if判断的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561971978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2317711,"avatar":"https://static001.geekbang.org/account/avatar/00/23/5d/8f/498d9ea5.jpg","nickname":"清风","note":"","ucode":"62490AD4F949BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547438,"discussion_content":"第一层if判断存在的意义就在于一个线程校验实例是否为null时其他线程因为没锁只能进入阻塞，浪费资源；所以在锁外面加了层校验，如果已经非空直接返回非空实例即可。\n此处的场景为线程A完成实例初始化后进行线程切换，拿到CPU时间片的线程B经历第一层if校验是无序等待的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642673903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542778,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8a/7a/54003392.jpg","nickname":"Geek_27a248","note":"","ucode":"6AC3AC42E6EEC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292439,"discussion_content":"a有什么情况下可以切换到b呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595226694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2867465,"avatar":"","nickname":"Geek_73484e","note":"","ucode":"BFBF8878F186C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1542778,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8a/7a/54003392.jpg","nickname":"Geek_27a248","note":"","ucode":"6AC3AC42E6EEC9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553357,"discussion_content":"线程切换是操作系统调度的，只能说有可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645860429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292439,"ip_address":""},"score":553357,"extra":""}]}]},{"had_liked":false,"id":71355,"user_name":"MARK","can_delete":false,"product_type":"c1","uid":1126900,"ip_address":"","ucode":"9F429C9C5FEE6A","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/f4/467cf5d7.jpg","comment_is_top":false,"comment_ctime":1551326281,"is_pvip":false,"replies":[{"id":"25672","content":"厉害厉害","user_name":"作者回复","comment_id":71355,"uid":"1269969","ip_address":"","utype":1,"ctime":1551369602,"user_name_real":"王宝令"}],"discussion_count":5,"race_medal":0,"score":"340853742665","product_id":100023901,"comment_content":"刚看过《java并发实战》，又是看了个开始就看不下去了😂😂，希望订阅专栏可以跟老师和其他童鞋一起坚持学习并发编程😄😄<br><br>思考题：在32位的机器上对long型变量进行加减操作存在并发隐患的说法是正确的。<br>原因就是文章里的bug源头之二：线程切换带来的原子性问题。<br>非volatile类型的long和double型变量是8字节64位的，32位机器读或写这个变量时得把人家咔嚓分成两个32位操作，可能一个线程读了某个值的高32位，低32位已经被另一个线程改了。所以官方推荐最好把long\\double 变量声明为volatile或是同步加锁synchronize以避免并发问题。<br><br>贴一段java文档的说明<br>https:&#47;&#47;docs.oracle.com&#47;javase&#47;specs&#47;jls&#47;se8&#47;html&#47;jls-17.html#jls-17.7<br><br>17.7. Non-Atomic Treatment of double and long<br><br>For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.<br><br>Writes and reads of volatile long and double values are always atomic.<br><br>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.<br><br>Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency&#39;s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.<br><br>Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.","like_count":79,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441121,"discussion_content":"厉害厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551369602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/90/72/e17e7c61.jpg","nickname":"艺比天高","note":"","ucode":"F52AC257F834A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331994,"discussion_content":"评论区大神多呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607042833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098504,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/08/28c327d0.jpg","nickname":"冰河时代","note":"","ucode":"F4375FB7CE4FD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292606,"discussion_content":"个人理解：前提是Long类型是共用的变量并且需要计算等操作。 如果是在方法内部是栈封闭的， 如果只是一个DTO等对象用于赋值传递，这样的话也应该是没必要加volitile（内存屏障）等来保证了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595265309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098504,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/08/28c327d0.jpg","nickname":"冰河时代","note":"","ucode":"F4375FB7CE4FD4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550625,"discussion_content":"你这是废话，你说的这种情况都不能存在并发问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644644940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292606,"ip_address":""},"score":550625,"extra":""}]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128992,"discussion_content":"直接使用LongAdder是否可以？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578668865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71223,"user_name":"xx鼠","can_delete":false,"product_type":"c1","uid":1331863,"ip_address":"","ucode":"9ABBCE460C8484","user_header":"https://static001.geekbang.org/account/avatar/00/14/52/97/8f960ce9.jpg","comment_is_top":false,"comment_ctime":1551287453,"is_pvip":false,"replies":[{"id":"25642","content":"恭喜你，学会抢答了！","user_name":"作者回复","comment_id":71223,"uid":"1269969","ip_address":"","utype":1,"ctime":1551367547,"user_name_real":"王宝令"}],"discussion_count":6,"race_medal":0,"score":"186234881181","product_id":100023901,"comment_content":"Singleton instance改为volatile或者final就完美了，这里面其实涉及Java的happen-before原则。","like_count":43,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441054,"discussion_content":"恭喜你，学会抢答了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551367547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2291909,"avatar":"","nickname":"Geek_6f3f68","note":"","ucode":"537B28473CC217","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377215,"discussion_content":"说得好，Singleton instance改为volatile或者final就完美了，这里面其实涉及Java的happen-before原则。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622551745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1057295,"avatar":"https://static001.geekbang.org/account/avatar/00/10/22/0f/3e092988.jpg","nickname":"Pony","note":"","ucode":"05AAC3C8A30326","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17645,"discussion_content":"请问，为什么加上final就没问题了？很想知道","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568973146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1019254,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/76/994a9929.jpg","nickname":"OlafOO","note":"","ucode":"105F8B194ED37B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1057295,"avatar":"https://static001.geekbang.org/account/avatar/00/10/22/0f/3e092988.jpg","nickname":"Pony","note":"","ucode":"05AAC3C8A30326","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19801,"discussion_content":"可以看下这篇文章 http://ifeve.com/java-memory-model/","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1569226514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":17645,"ip_address":""},"score":19801,"extra":""},{"author":{"id":1182200,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/f8/5f74ff5b.jpg","nickname":"Owen","note":"","ucode":"ADE38F8D446860","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019254,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/76/994a9929.jpg","nickname":"OlafOO","note":"","ucode":"105F8B194ED37B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":267018,"discussion_content":"看了半个小时，确实学到了，感谢推荐","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589591252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":19801,"ip_address":""},"score":267018,"extra":""},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182200,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/f8/5f74ff5b.jpg","nickname":"Owen","note":"","ucode":"ADE38F8D446860","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560246,"discussion_content":"字数太多了 能不能精简点 描述","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649237472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":267018,"ip_address":""},"score":560246,"extra":""}]}]},{"had_liked":false,"id":88683,"user_name":"迷失的小伙伴","can_delete":false,"product_type":"c1","uid":1243836,"ip_address":"","ucode":"2C8509E73E5AEA","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/bc/a246831a.jpg","comment_is_top":false,"comment_ctime":1555982579,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"156174805235","product_id":100023901,"comment_content":"对于嘎嘎的回答：volatile只解决可见性问题，不保证原子性问题，这句话有点疑问。volatile禁止指令重排，所以instance得初始化过程不会重排，也就不会存在拿到空内存地址的instance。这不就间接地解决了这个NPE问题了吗？虽然不保证原子性，但起码不会出现问题。所以我认为加volatile是没问题的。","like_count":36,"discussions":[{"author":{"id":1241253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f0/a5/6934a639.jpg","nickname":"赖学良","note":"","ucode":"99E63A28E0CDAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386628,"discussion_content":"只能给你点个赞了，不能太同意你的说法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627700337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1694965,"avatar":"https://static001.geekbang.org/account/avatar/00/19/dc/f5/806bd1ff.jpg","nickname":"木子李","note":"","ucode":"815BAC4C950949","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387957,"discussion_content":"volatile保证了有序性，这样线程A能正确初始化及赋值，这样线程B第一次判空后，得到的对象就不会出现NPE了，防止重复创建由synchronized实现，这个理解对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628508827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2410444,"avatar":"https://static001.geekbang.org/account/avatar/00/24/c7/cc/92a3ef15.jpg","nickname":"桔橘橙辣，","note":"","ucode":"A0E5BE7852CA09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340963,"discussion_content":"我也觉得说的对\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610246081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2077761,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLibX06ACicicBdgWiaER4Ulobut55Gcwb57V3e84wqR2nwLY9wroIShMia6NBfICG4nURSKU7pfXwz4lg/132","nickname":"Geek_a3323b","note":"","ucode":"72629DEEF4DECC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302550,"discussion_content":"说的对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598952512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438212,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f2/04/993ec92d.jpg","nickname":"赵达铭","note":"","ucode":"8ED742EA118285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285552,"discussion_content":"说的对+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592877736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1171359,"avatar":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","nickname":"阿U","note":"","ucode":"161A8E74E0D612","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98867,"discussion_content":"我觉得你说的对，跟我想的一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577189538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71465,"user_name":"牧童纪年","can_delete":false,"product_type":"c1","uid":1263643,"ip_address":"","ucode":"7A98E8DD845C37","user_header":"https://static001.geekbang.org/account/avatar/00/13/48/1b/7de6e72e.jpg","comment_is_top":false,"comment_ctime":1551347495,"is_pvip":false,"replies":[{"id":"25683","content":"比如第1行：a=8<br>第1000行：a=a*2;<br>这个时候，把他们放到一起执行，是不是就能更好的利用缓存了？","user_name":"作者回复","comment_id":71465,"uid":"1269969","ip_address":"","utype":1,"ctime":1551371081,"user_name_real":"王宝令"}],"discussion_count":7,"race_medal":0,"score":"143285268263","product_id":100023901,"comment_content":"王老师，你文章中讲的 优化指令的执行次序 使得缓存能够更加合理的利用是什么意思？","like_count":33,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441167,"discussion_content":"比如第1行：a=8\n第1000行：a=a*2;\n这个时候，把他们放到一起执行，是不是就能更好的利用缓存了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551371081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155092,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/14/c3f6c745.jpg","nickname":"灰尘","note":"","ucode":"362C407B8E1307","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3573,"discussion_content":"这里优化的意思是直接拿8来操作，不需要再去读缓存了，少了一步操作，是这个意思吧","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564612676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1055092,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","nickname":"追风者","note":"","ucode":"879BC372A6B605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1155092,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/14/c3f6c745.jpg","nickname":"灰尘","note":"","ucode":"362C407B8E1307","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281604,"discussion_content":"不是不需要读缓存，而是缓存的提出是基于局部性原理的，这里编译器优化的结果可以使得a尽可能多的使用到，也就是时间局部性，最近访问过的数据项很快会被再次访问。从而提高了缓存命中率。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1591774875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3573,"ip_address":""},"score":281604,"extra":""}]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301426,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598522594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1051609,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0b/d9/3328dd12.jpg","nickname":"心浮天空","note":"","ucode":"3B2D0E6CC51EE6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199533,"discussion_content":"我的理解是，CPU寄存器容量有限，在代码执行过程中， 第1行的缓存在执行到第1000行的时候已经被其他数据覆盖，所以导致缓存未命中，需要再次从主存中加载，而指令或代码重排后，可以提高缓存命中率，从而提升性能。不知道这样的理解对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583592998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1051609,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0b/d9/3328dd12.jpg","nickname":"心浮天空","note":"","ucode":"3B2D0E6CC51EE6","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":301427,"discussion_content":"理解的不错，编译器并不会严格按照程序的顺序进行执行，编译器的优化很多，重排序只是其中一个，编译器重排序保证了单线程不出问题，但是它不管你多线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598522712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199533,"ip_address":""},"score":301427,"extra":""},{"author":{"id":1653218,"avatar":"https://static001.geekbang.org/account/avatar/00/19/39/e2/633f8b70.jpg","nickname":"恒星","note":"","ucode":"F6902B0291FCFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1051609,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0b/d9/3328dd12.jpg","nickname":"心浮天空","note":"","ucode":"3B2D0E6CC51EE6","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":544485,"discussion_content":"对，就是上面老哥提到的时间局部性，CPU加载缓存会把周围的一片都加载进去，这样在一块的能直接使用，不用再次加载","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641539069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199533,"ip_address":""},"score":544485,"extra":""}]}]},{"had_liked":false,"id":71728,"user_name":"何方妖孽","can_delete":false,"product_type":"c1","uid":1445608,"ip_address":"","ucode":"98B74EE791206B","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/e8/5d2c3e08.jpg","comment_is_top":false,"comment_ctime":1551421230,"is_pvip":false,"replies":[{"id":"25937","content":"在同步块里，线程也可能被操作系统剥夺cpu的使用权，但是其他线程此时是拿不到锁，所以其他线程不会执行同步块的代码<br>","user_name":"作者回复","comment_id":71728,"uid":"1269969","ip_address":"","utype":1,"ctime":1551433823,"user_name_real":"王宝令"}],"discussion_count":9,"race_medal":0,"score":"130400440110","product_id":100023901,"comment_content":"synchronized修饰的代码块里，会出现线程切换么？我理解的synchronized作用就是同步执行，不会线程切换，请作者给我解答下。","like_count":30,"discussions":[{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371860,"discussion_content":"允许线程切换的意义还在于：可能还有其他没有请求这个锁的线程呀，可能有100个线程，2个线程请求这个锁，其他98个线程就不执行了么。当然要允许线程切换了。而synchronized保证的是被修饰的代码块不会被多个线程同时执行。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1620027291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441301,"discussion_content":"在同步块里，线程也可能被操作系统剥夺cpu的使用权，但是其他线程此时是拿不到锁，所以其他线程不会执行同步块的代码\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1551433823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503063,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ef/57/0e128187.jpg","nickname":"菜鸟啊菜鸟","note":"","ucode":"2F764CEBD3FDAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304913,"discussion_content":"那其他线程拿不到锁的话，只是干等着它的时间片用完以后再切换回去吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599710018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1849931,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/3a/4b/defd0082.jpg","nickname":"你好呀_","note":"","ucode":"C76AD754E32AF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1503063,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ef/57/0e128187.jpg","nickname":"菜鸟啊菜鸟","note":"","ucode":"2F764CEBD3FDAC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318226,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603683322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304913,"ip_address":""},"score":318226,"extra":""},{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1503063,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ef/57/0e128187.jpg","nickname":"菜鸟啊菜鸟","note":"","ucode":"2F764CEBD3FDAC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364396,"discussion_content":"不会，这样效率很低。老师说的有点不对，老师主要强调的时候会发生线程切换。被阻塞的线程处于 BLOCKED 状态，而不是 RUNNABLE 状态，不会分配时间片给处于阻塞的线程的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617462220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304913,"ip_address":""},"score":364396,"extra":""},{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1849931,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/3a/4b/defd0082.jpg","nickname":"你好呀_","note":"","ucode":"C76AD754E32AF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364397,"discussion_content":"不会，这样效率很低。老师说的有点不对，老师主要强调的时候会发生线程切换。被阻塞的线程处于 BLOCKED 状态，而不是 RUNNABLE 状态，不会分配时间片给处于阻塞的线程的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617462233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318226,"ip_address":""},"score":364397,"extra":""}]},{"author":{"id":2637643,"avatar":"","nickname":"先生","note":"","ucode":"85B89FAF2519BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388722,"discussion_content":"主要是不会指令重排","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628926913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71338,"user_name":"summer_Day","can_delete":false,"product_type":"c1","uid":1334131,"ip_address":"","ucode":"41C5A129911B49","user_header":"https://static001.geekbang.org/account/avatar/00/14/5b/73/23040664.jpg","comment_is_top":false,"comment_ctime":1551323317,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"108925505717","product_id":100023901,"comment_content":"我觉得阿根一世的问题应该是<br>synchronized(Singleton.class) {<br>        if (instance == null)<br>          instance = new Singleton();<br>        }<br>对于synchronized关键字已经对代码块进行加锁了<br>我理解应该等价于<br>synchronized(Singleton.class) {<br>        if (instance == null) {<br>          分配一块内存 M；<br>          将 M 的地址赋值给 instance 变量；<br>          最后在内存 M 上初始化 Singleton 对象。<br>        }<br>  }<br> A如果没有完成实例的初始化，锁应该不会释放的，B是拿不到锁的，怎么还会出问题呢？<br>","like_count":25,"discussions":[{"author":{"id":1363243,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cd/2b/9b301f01.jpg","nickname":"谁在左路传中","note":"","ucode":"52A1E8ABA01024","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":826,"discussion_content":"线程1将M的地址赋值后，切换线程，线程2第一次判断，不满足直接返回， 线程2并没有获去锁","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1562080179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1542778,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8a/7a/54003392.jpg","nickname":"Geek_27a248","note":"","ucode":"6AC3AC42E6EEC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1363243,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cd/2b/9b301f01.jpg","nickname":"谁在左路传中","note":"","ucode":"52A1E8ABA01024","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292438,"discussion_content":"线程1切换线程，这个为什么会切换线程都是有什么原因可以造成呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595226643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":826,"ip_address":""},"score":292438,"extra":""},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1542778,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8a/7a/54003392.jpg","nickname":"Geek_27a248","note":"","ucode":"6AC3AC42E6EEC9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301428,"discussion_content":"线程切换，原因很多，只是在加锁的代码内部，别的线程不进来就行，你也管不了人家在门外随便转啊","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1598522811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292438,"ip_address":""},"score":301428,"extra":""}]},{"author":{"id":1440678,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/YPskWw3DQdwlJIs9acFFrmTu0MGN3ciaaLnMxOArFGYBy9yL2zDY6HZQ2bz8QLNt5qpkRicnoCCvryV8LawfQuTQ/132","nickname":"nick66","note":"","ucode":"D07841EE5D204F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":688,"discussion_content":"我理解，将 M 的地址赋值给 instance 变量之后，线程1随着时间片的用完切换线程，而线程2对象判空之后，没有获取锁，直接返回了对象","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1561960902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71337,"user_name":"落墨","can_delete":false,"product_type":"c1","uid":1120441,"ip_address":"","ucode":"283D59C6FA5E01","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo7ticAviaxUk04QAiadIo1O5G7ib03V0AEibWdVW6Zxwzy7xMaVgKjAVE4NXZuLqsbY8CFNiaoFwyRx3Aw/132","comment_is_top":false,"comment_ctime":1551323296,"is_pvip":false,"replies":[{"id":"25669","content":"并发程序的诡异之处，就在于：我实在也想不通。","user_name":"作者回复","comment_id":71337,"uid":"1269969","ip_address":"","utype":1,"ctime":1551369458,"user_name_real":"王宝令"}],"discussion_count":7,"race_medal":0,"score":"108925505696","product_id":100023901,"comment_content":"老师,运行文中的测试代码,有时会出现9000多的结果,不知道是什么原因?","like_count":25,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441113,"discussion_content":"并发程序的诡异之处，就在于：我实在也想不通。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551369458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1154670,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9e/6e/c4fa7cbc.jpg","nickname":"二师哥","note":"","ucode":"3BE4978417F082","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5115,"discussion_content":"这个是我类的内部实现, 可以参考一下\n... \nprivate long count = 0;\n\n    public static void main(String[] args) throws Exception {\n        long res = calculator();\n        System.out.println(res);\n    }\n\n    private void add10k() {\n        int idx = 0;\n        while (idx++ < 10000000) {\n            count += 1;\n        }\n    }\n\n    public static long calculator() throws InterruptedException {\n        final hello test = new hello();\n        Thread thread001 = new Thread(test::add10k);\n        Thread thread002 = new Thread(test::add10k);\n\n        thread001.start();\n        thread002.start();\n        thread001.join();\n        thread002.join();\n        return test.count;\n    }\n...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565951651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2291909,"avatar":"","nickname":"Geek_6f3f68","note":"","ucode":"537B28473CC217","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377216,"discussion_content":"可能你的电脑太好了，加个sleep","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622552034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064449,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3e/01/9bb11f13.jpg","nickname":"whyoyyx","note":"","ucode":"B111DDAF23AFE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135366,"discussion_content":"我觉得可以猜测一下应该是正常的，A，B两个线程， 执行完成后 为100 但是B线程读到的还是99 此时 B执行完成之后写入就是 100，但是此时A已经写入到主内存了，A继续写应该是101了，A继续执行第三次 写入是102 此时B才把第一次的100写入主内存，A第4次继续读取的时候，就是100  不知道这样是否可以解释的通","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579088674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1e/bc/6839e3ca.jpg","nickname":"叶鹏","note":"","ucode":"209A8B210C340B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2172,"discussion_content":"文档中的代码可以正常运行吗？好像复制下来会报错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563329262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1319215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/21/2f/b29e8af8.jpg","nickname":"轻风悠扬","note":"","ucode":"F2276CE113BED1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1253052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1e/bc/6839e3ca.jpg","nickname":"叶鹏","note":"","ucode":"209A8B210C340B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271159,"discussion_content":"要自己加个main函数去调用calculator","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590101121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2172,"ip_address":""},"score":271159,"extra":""},{"author":{"id":1572164,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fd/44/b114ec6a.jpg","nickname":"到点了上号","note":"","ucode":"A12690AFA3DA27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1253052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1e/bc/6839e3ca.jpg","nickname":"叶鹏","note":"","ucode":"209A8B210C340B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412309,"discussion_content":"老师的代码中，直接 return count; 了，要注意静态方法内部不能调用非静态变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636124192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2172,"ip_address":""},"score":412309,"extra":""}]}]},{"had_liked":false,"id":71215,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1106680,"ip_address":"","ucode":"7004C06B3E6A17","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/f8/6e5da436.jpg","comment_is_top":false,"comment_ctime":1551285252,"is_pvip":false,"replies":[{"id":"25641","content":"建议网上搜索 “闲话高并发的那些神话,看京东架构师如何把它拉下神坛”，这个里面的内容应该能解决你的困惑。这个题目是是京东小编加的，原来的题目是 闲话高并发。我怎么知道这么多？！","user_name":"作者回复","comment_id":71215,"uid":"1269969","ip_address":"","utype":1,"ctime":1551367517,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"104630500356","product_id":100023901,"comment_content":"NIO和并发有什么关系呢？","like_count":24,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441049,"discussion_content":"建议网上搜索 “闲话高并发的那些神话,看京东架构师如何把它拉下神坛”，这个里面的内容应该能解决你的困惑。这个题目是是京东小编加的，原来的题目是 闲话高并发。我怎么知道这么多？！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551367517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364399,"discussion_content":"并发是目的，NIO 是并发的一种模型。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617462277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560250,"discussion_content":"https://mp.weixin.qq.com/s/lAqn8CfSRta9iSvOR1Le6w","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649237923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71328,"user_name":"江楠大盗","can_delete":false,"product_type":"c1","uid":1241197,"ip_address":"","ucode":"D242C5EF70C176","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo5vic8QksE4b8ricXxKrEWJyOX9pwiadhk3kvHYoLXoKRTWvbFCxibFTbExNQWDG4nvNfpic9t1umibKww/132","comment_is_top":false,"comment_ctime":1551321075,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"83155699699","product_id":100023901,"comment_content":"双重检查那个，A进到第二个if里，刚把引用给变量，这时B到第一个if，一看不是null，直接就返回了，不会去抢锁，拿到一个没有初始化完成的引用，导致后续异常。","like_count":19},{"had_liked":false,"id":81836,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1554047244,"is_pvip":false,"replies":[{"id":"29667","content":"知音啊😂😂😂<br>","user_name":"作者回复","comment_id":81836,"uid":"1269969","ip_address":"","utype":1,"ctime":1554079825,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"78863458572","product_id":100023901,"comment_content":"看完文章来刷评论，看到阿根一世的童鞋问题，确实是这样，锁🔒都还没有释放，线程B根本获取不到对象，所以线程A创建的对象是完整的，线程B后续获取的对象也是初始化完成的对象。<br>然后回去再看了一遍那一小段，当我看到线程B竞争锁资源失败后被阻塞，我就更肯定，应该是文章描述有误。<br>当再往下看文章，发现后面有说：“一切都很完美，无懈可击”。soga，这是描述我们自己觉得正常的场景。<br>接着文章下面分析异常的原因，但是没提到线程B在哪停下来，因此我们的思维还是停留在前面那一段，线程A和线程B都过了第一个判空语句，来了竞争锁 syncronized 这，所以有阿根一世同样的疑问。建议老师调整一下，在分析异常原因时，说明一下在哪个语句时发生了线程切换，这样童鞋们也更好理解。<br><br>😂这理解有偏差，属于可见性问题，是我们大脑缓存了之前的描述，导致了异常的理解😂","like_count":18,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445364,"discussion_content":"知音啊😂😂😂\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554079825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330891,"discussion_content":"确实是被前面那段正常流程的描述给影响了，在描述异常场景时以为线程B是在执行第二个instance==null。\n\n不知道老师是否调整了内容，现在再看描述异常场景，对线程B的位置有进行说明：“如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的”。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606726996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":331017,"discussion_content":"应该是调整之后的了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606747573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":330891,"ip_address":""},"score":331017,"extra":""}]},{"author":{"id":2291909,"avatar":"","nickname":"Geek_6f3f68","note":"","ucode":"537B28473CC217","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377218,"discussion_content":"🍎🍎🍎锁🔒都还没有释放，线程B根本获取不到对象，所以线程A创建的对象是完整的，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622552302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71526,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1551363201,"is_pvip":false,"replies":[{"id":"25690","content":"进程和线程的关系，你可以看看操作系统原理。进程不占有CPU。操作系统会把CPU分配给线程。分到CPU的线程就能执行。<br>并行，是同一时刻，两个线程都在执行。并发，是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。","user_name":"作者回复","comment_id":71526,"uid":"1269969","ip_address":"","utype":1,"ctime":1551372287,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"78860774529","product_id":100023901,"comment_content":"老师 ，我有几个问题希望老师指点 ，也是涉及到操作系统的：<br><br>1.  操作系统是以进程为单位共享资源 ，以线程单位进行调用 。 多个线程共享一个进程的资源 。 一个java应用占一个进程（jvm的内存模型的资源也在这个进程中） ，一个进程占一个cpu ， 所以老师所说的多核cpu缓存，每个cpu有自己的缓存 ，AB两个线程在不同的cpu上操作不太理解 ， 一个应用的AB两个线程是不是应该处在同个cpu上面 ？？？<br><br>2. 如果按照老师所说不同线程在不同cpu上运行 ， 是不是有个叫并行和并发的概念 。 单个cpu的时候多线程实际上是模拟并发的并行，实际上cpu只能一次执行一个线程，两个线程交替执行。 而到了多核中，可以真正的将两个线程AB同时分给cpu1 .cpu2同时执行，称之为并发？？<br><br>3. 我感觉老师第二点原子性中也有包含可见性问题，由于时间片到了， 当把资源读到自己的工作线程中时，由于不可见性，以为自己是最新的导致值不准确，这个也对应了第一个问题 ， 两个线程是否在同个进程内共享资源<br><br>问题有点多 ， 可能自己的理解有偏差 ，希望老师指正<br>","like_count":18,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441189,"discussion_content":"进程和线程的关系，你可以看看操作系统原理。进程不占有CPU。操作系统会把CPU分配给线程。分到CPU的线程就能执行。\n并行，是同一时刻，两个线程都在执行。并发，是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551372287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2043825,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2f/b1/a00d7b0e.jpg","nickname":"Andersen","note":"","ucode":"06B9C344EEED56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288018,"discussion_content":"进程是操作系统可执行单位，线程是cpu调度单位。这样对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593613614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76370,"user_name":"小辉辉","can_delete":false,"product_type":"c1","uid":1189661,"ip_address":"","ucode":"9FF25E25C85350","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","comment_is_top":false,"comment_ctime":1552579140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74567023172","product_id":100023901,"comment_content":"看完这一篇，觉得我之前看的《Java高并发编程详解》和《深入理解Java虚拟机》两本书没白看，至少看懂老师说的问题了，看完评论（差不多半小时），原来高手都在评论区😀 😀 😀 ","like_count":17},{"had_liked":false,"id":71214,"user_name":"我会得到","can_delete":false,"product_type":"c1","uid":1441779,"ip_address":"","ucode":"67BF2E8821EF89","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqHMAwG4atmGJ6H1cs1o3yUE2UhEian6cmbp9BWC1V2S7zAQdQHWYtaZbjahKHsMSkje5GrGjo9Iug/132","comment_is_top":false,"comment_ctime":1551284775,"is_pvip":false,"replies":[{"id":"25640","content":"后面讲内存模型，会更有意思。","user_name":"作者回复","comment_id":71214,"uid":"1269969","ip_address":"","utype":1,"ctime":1551367333,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"74565728807","product_id":100023901,"comment_content":"零点一过刚好看到更新，果断一口气读完，带劲！可见性，原子性，有序性，操作系统作为基础，内存模型，机器指令，编译原理，一个都不能少，开始有点意思了👍","like_count":17,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441048,"discussion_content":"后面讲内存模型，会更有意思。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551367333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73928,"user_name":"suynan","can_delete":false,"product_type":"c1","uid":1023214,"ip_address":"","ucode":"0AAD1BA9D22D2C","user_header":"","comment_is_top":false,"comment_ctime":1552036149,"is_pvip":false,"replies":[{"id":"27012","content":"很透彻！","user_name":"作者回复","comment_id":73928,"uid":"1269969","ip_address":"","utype":1,"ctime":1552059177,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"53091643701","product_id":100023901,"comment_content":"<br>并发编程的场景中的三个bug源头：可见性、原子性、有序性<br>1.可见性：多核系统每个cpu自带高速缓存，彼此间不交换信息（列子：两个线程对同一份实列变量count累加，结果可能不等于累加之和，因为线程将内存值载入各自的缓存中，之后的累加操作基于缓存值进行，并不是累加一次往内存回写一次）<br>2.原子性：cpu分时操作导致线程的切换，（列子：AB两个线程同时进行count+=1，由于+=操作是3步指令①从内存加载②+1操作③回写到主内，线程A对其进行了①②操作后，切换到B线程，B线程进行了①②③，这时内存值是1，然后再切到A执行③操作，这时的值也还是1，PS:这貌似也存在可见性的问题）<br> 3.有序性：指令的重排序（列子：单列模式的双重检测，new指令也是3步操作，①分内存②初始化③赋值给引用变量，可能会发生①③②的重排序，这时候如果又有操作系统的分时操作的加持，导致A操作①③后挂起，时间片被分配给了B线程，而B线程甚至都不需要进行锁的获取，因为此时instance已经不等于null了，但是此时的instance可能未初始化）","like_count":12,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442343,"discussion_content":"很透彻！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552059177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/e8/d2e88567.jpg","nickname":"ssrsdzry","note":"","ucode":"89BCFA6A1997E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375107,"discussion_content":"同样有类似的疑问：感觉原子性的问题本质上也是由于可见性导致的。没有可见性问题就不存在原子性问题。不知道有没有反例？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621486396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213322,"discussion_content":"原子性这个例子，我感觉也是可见性的问题，貌似也能按照可见性的思路理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585063745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71247,"user_name":"黄朋飞","can_delete":false,"product_type":"c1","uid":1107062,"ip_address":"","ucode":"A1E7E0460A1BCC","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/76/a97242c0.jpg","comment_is_top":false,"comment_ctime":1551312320,"is_pvip":false,"replies":[{"id":"25648","content":"对不起，是我没说清楚，这里的缓存，指的是CPU缓存。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551367944,"ip_address":"","comment_id":71247,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48795952576","product_id":100023901,"comment_content":"老师你好，请问文章中的缓存和内存什么区别，缓存不是在内存中存放着吗？","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441067,"discussion_content":"对不起，是我没说清楚，这里的缓存，指的是CPU缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551367944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71837,"user_name":"波波","can_delete":false,"product_type":"c1","uid":1155827,"ip_address":"","ucode":"4344D9F4486D42","user_header":"https://static001.geekbang.org/account/avatar/00/11/a2/f3/aa504fa6.jpg","comment_is_top":false,"comment_ctime":1551448227,"is_pvip":false,"replies":[{"id":"26006","content":"这么夸我，我真的会骄傲的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551450608,"ip_address":"","comment_id":71837,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44501121187","product_id":100023901,"comment_content":"为老师点赞，讲了并发产生的前世今生，通俗易懂又不失深度。","like_count":10,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441351,"discussion_content":"这么夸我，我真的会骄傲的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551450608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72284,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1551574872,"is_pvip":true,"replies":[{"id":"26185","content":"我本地测试的代码是下面这样的，为了说明问题，为了不占用篇幅，做了删减。final Test test = new Test();使用test访问的，所以可以访问<br><br>public class Test {<br>    private int count = 0;<br>    private void add() {<br>        int idx = 0;<br>        while(idx++ &lt; 10000000) {<br>            count += 1;<br>        }<br>    }<br>    public static int calc() throws Exception {<br>        final Test test = new Test();<br>        Thread th1 = new Thread(()-&gt;{<br>            test.add();<br>        });<br>        Thread th2 = new Thread(()-&gt;{<br>            test.add();<br>        });<br><br>        th1.start();<br>        th2.start();<br>        th1.join();<br>        th2.join();<br>        return test.count;<br>    }<br><br>    public static void main(String[] args) throws Exception {<br>        long c =calc();<br>        System.out.println(c);<br>    }<br>}<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551584085,"ip_address":"","comment_id":72284,"utype":1}],"discussion_count":3,"race_medal":0,"score":"40206280536","product_id":100023901,"comment_content":"第一个测试代码是不是有点问题，在静态方法中怎么能访问非静态变量呢？","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441522,"discussion_content":"我本地测试的代码是下面这样的，为了说明问题，为了不占用篇幅，做了删减。final Test test = new Test();使用test访问的，所以可以访问\n\npublic class Test {\n    private int count = 0;\n    private void add() {\n        int idx = 0;\n        while(idx++ &amp;lt; 10000000) {\n            count += 1;\n        }\n    }\n    public static int calc() throws Exception {\n        final Test test = new Test();\n        Thread th1 = new Thread(()-&amp;gt;{\n            test.add();\n        });\n        Thread th2 = new Thread(()-&amp;gt;{\n            test.add();\n        });\n\n        th1.start();\n        th2.start();\n        th1.join();\n        th2.join();\n        return test.count;\n    }\n\n    public static void main(String[] args) throws Exception {\n        long c =calc();\n        System.out.println(c);\n    }\n}\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551584085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84113,"discussion_content":"代码是有问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576488976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179759,"avatar":"https://static001.geekbang.org/account/avatar/00/12/00/6f/f0c0841d.jpg","nickname":"小吴同学","note":"","ucode":"29F8C0575E32AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426,"discussion_content":"和思考题结合一下，64位机器 把private int count = 0; 改为 private volatile long count = 0;\n这时候为什么还出现了并发问题了呢，不明白，希望解答，谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561544300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71368,"user_name":"cfreedomc","can_delete":false,"product_type":"c1","uid":1295738,"ip_address":"","ucode":"91C4BEA7B155FF","user_header":"https://static001.geekbang.org/account/avatar/00/13/c5/7a/7da3cbe2.jpg","comment_is_top":false,"comment_ctime":1551329508,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40206035172","product_id":100023901,"comment_content":"今天主要学习了并发编程中三种类型的问题<br>1.缓存导致的可见性问题<br>2.线程切换导致的原子性问题<br>3.编译优化带来的有序性问题<br>也是让我认识到我们编程其实和医生看病一样，项目就是病人，当你给病人开药时，药的好处不必多说，更重要的是对于药的副作用有个清晰的认识才是一个好的医生<br><br>最后从这节课后，遇到并发问题，我也可以系统的通过将问题分类到是以上哪种或者哪几种问题去解决问题<br><br>如今天的课后题目，在java中 Long类型是64位的，在32位的系统中，Cpu指令要进行多次操作，无法保证原子性","like_count":9,"discussions":[{"author":{"id":1138583,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5f/97/00bb7e14.jpg","nickname":"Calm","note":"","ucode":"15995FDE13FBCF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552538,"discussion_content":"牛的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645504197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74283,"user_name":"Hank_Yan","can_delete":false,"product_type":"c1","uid":1110662,"ip_address":"","ucode":"86899B561C502B","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg","comment_is_top":false,"comment_ctime":1552177881,"is_pvip":false,"replies":[{"id":"27166","content":"你的建议很好！！！我这就改一下。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552190120,"ip_address":"","comment_id":74283,"utype":1}],"discussion_count":2,"race_medal":3,"score":"35911916249","product_id":100023901,"comment_content":"〔如果此时线程 B 也执行 getInstance() 方法，那么线程 B 会发现instance != null，所以直接返回 instance〕<br><br>这里加一句，线程B刚好执行到“第一个判断”，会发现  instance!=null ， 这样比较好，不然还是会有很多人误解是在执行第二个判断，然后问为什么锁没有释放，也能进行第二个判断。","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442509,"discussion_content":"你的建议很好！！！我这就改一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552190120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532943,"discussion_content":"单核因为每个栈内存上变量不一致仍然会有问题。 当然这里指的不是对象在栈上分配 而是说字段变量加载过一次后 就存在cpu缓存或是寄存器里 此时就不动了。所以单核仍然会有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637736358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71501,"user_name":"Geek_df1217","can_delete":false,"product_type":"c1","uid":1358875,"ip_address":"","ucode":"2BF7270F9E157A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbuZDOPPYrdmf7fRb0jmkB0LyT0wBdvxlKjVoZ4G8V1XAPPVcZCcryBH806b2EpoqTbEIujCF6IQ/132","comment_is_top":false,"comment_ctime":1551358650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31616129722","product_id":100023901,"comment_content":"volatile关键字可以禁止指令重排序，可以解决大部分人的疑惑","like_count":7},{"had_liked":false,"id":71229,"user_name":"diexue798","can_delete":false,"product_type":"c1","uid":1442234,"ip_address":"","ucode":"E39FBF201031FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo19qicyia7fD28fhVXB2dH2icFxIialY8ibmU30HicUJrLr8rOedVewgx1uhMKj0Gwl7FK44UKMNZOOicQQ/132","comment_is_top":false,"comment_ctime":1551288513,"is_pvip":false,"replies":[{"id":"25645","content":"spring 默认创建的是单例，多线程共享这个单例，自然就存在并发问题了。service是不是安全，要看是不是单例，如果是单例，也会有问题。当然，你也可以写线程安全的service。局部变量都安全。有共享就要使用线程安全的集合。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551367822,"ip_address":"","comment_id":71229,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31616059585","product_id":100023901,"comment_content":"好好学习，不是很了解spring线程安全，springmvc线程安全这里,如果有成员变量，就算是数据共享了，就不安全了么，那么注入的servie怎么又是安全的，还有加不加锁的集合如果是局部变量是不是也都安全，那什么时候用线程安全的加了锁的集合呢？","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441057,"discussion_content":"spring 默认创建的是单例，多线程共享这个单例，自然就存在并发问题了。service是不是安全，要看是不是单例，如果是单例，也会有问题。当然，你也可以写线程安全的service。局部变量都安全。有共享就要使用线程安全的集合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551367822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1559541,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/kEOm2xpFyn0WVH04ibTyadaXKPowWfzPaOv1ibGrM2Y4eTSbSGYibvibZKW0dRibJqX8dnwMEwGZoDAiaicJ4gR0JWeVw/132","nickname":"Lyn4ever","note":"","ucode":"D4D32B7A9EBFAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252385,"discussion_content":"单例的service确实不安全，但却从来没有操作过service的成员变量，所以并不存在安全问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588161488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97270,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1558624674,"is_pvip":false,"replies":[{"id":"34846","content":"单核没有可见性问题，原子性问题还是有的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558673047,"ip_address":"","comment_id":97270,"utype":1}],"discussion_count":1,"race_medal":1,"score":"27328428450","product_id":100023901,"comment_content":"老师，您的第一个例子，说单核cpu不会有线程安全问题。这个不对吧，多线程安全问题，与单核或多核没啥关系吧，希望老师能回复这个留言，谢谢老师","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451203,"discussion_content":"单核没有可见性问题，原子性问题还是有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558673047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71537,"user_name":"... ...","can_delete":false,"product_type":"c1","uid":1312354,"ip_address":"","ucode":"E214CAA6349A60","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/62/898449d3.jpg","comment_is_top":false,"comment_ctime":1551365015,"is_pvip":false,"replies":[{"id":"25692","content":"示例代码，只是为了说明问题。考虑到大家手机屏幕的尺寸，能省就省了<br>这个例子不仅仅是可见性的问题，并发问题往往都是综合证。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551372777,"ip_address":"","comment_id":71537,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27321168791","product_id":100023901,"comment_content":"老师，上面的两个线程的例子应该不是可见性导致而是原子性导致的吧！如果是可见性导致的话，我在变量count上加个volatile应该可以解决问题啊！还发现个小问题，非静态变量应该不能直接用于静态方法中吧！","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441192,"discussion_content":"示例代码，只是为了说明问题。考虑到大家手机屏幕的尺寸，能省就省了\n这个例子不仅仅是可见性的问题，并发问题往往都是综合证。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551372777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2797783,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/b0/d7/cb391b61.jpg","nickname":"ChesterChai","note":"","ucode":"E8C896CEF2B1A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403817,"discussion_content":"老师的例子是多cpu情况，多cpu情况存在可见性问题，单cpu存在原子性问题。这个例子可以同时举例可见性和原子性问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634169246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1386371,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NKKKlrmVDex70MuicAPLIQ4CVksVR1FvUrcvtJXq941iaichBDbYq3ViaXNYYWGtdo1JfRSLPvosEoL7h4QBmJ63UA/132","nickname":"jspkl","note":"","ucode":"E1527B0A24FC9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373808,"discussion_content":"第一个测试代码不仅仅是可见性导致的问题。可见性导致的问题，我觉得java并发实战中的一个线程写，另一个线程读的例子可能更准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620879304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132589,"user_name":"楼高","can_delete":false,"product_type":"c1","uid":1430375,"ip_address":"","ucode":"743B0C14687212","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLU3Dqic1Ssf2icrm6OtqFoG9vicoypKkk2lmKufo2BFZsFwPGt6NX1Sf1LLw448ayygykg3CMaqXEDw/132","comment_is_top":false,"comment_ctime":1568169547,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23043006027","product_id":100023901,"comment_content":"建议极客时间增加批注功能，由作者对评论中讨论的有争议的内容通过批注进行解释说明。","like_count":5},{"had_liked":false,"id":98093,"user_name":"magicHu","can_delete":false,"product_type":"c1","uid":1132342,"ip_address":"","ucode":"2C44FD8E77EDF2","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/36/cb57ac83.jpg","comment_is_top":false,"comment_ctime":1558914616,"is_pvip":false,"replies":[{"id":"35082","content":"你找个单核的cpu试试吧，如果一条这汇编的写指令把数据写进内存去，读出来不是它，可以给intel提bug","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558917933,"ip_address":"","comment_id":98093,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23033751096","product_id":100023901,"comment_content":"老师，缓存导致的可见性问题不是因为多核的原因吧，单核上也会有缓存导致可见性问题，求老师翻牌","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451551,"discussion_content":"你找个单核的cpu试试吧，如果一条这汇编的写指令把数据写进内存去，读出来不是它，可以给intel提bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558917933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560251,"discussion_content":"给力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649238255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72317,"user_name":"Sam_Deep_Thinking","can_delete":false,"product_type":"c1","uid":1001152,"ip_address":"","ucode":"8E4EF6F24B821B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/c0/bf880bda.jpg","comment_is_top":false,"comment_ctime":1551584809,"is_pvip":true,"replies":[{"id":"26203","content":"有你这样的读者，俺会更加努力地。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551591389,"ip_address":"","comment_id":72317,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23026421289","product_id":100023901,"comment_content":"良心专栏呀。目前正准备组织小组成员学习该专栏，概念和背景都讲的非常清楚。老板让俺给一个技术规划，我列的其中一个，便是全组人员学习该专栏，并以小组分享的方式讲出来。","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441540,"discussion_content":"有你这样的读者，俺会更加努力地。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551591389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71528,"user_name":"pdai","can_delete":false,"product_type":"c1","uid":1105040,"ip_address":"","ucode":"0948CC5294B880","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/90/330d5620.jpg","comment_is_top":false,"comment_ctime":1551363356,"is_pvip":false,"replies":[{"id":"25691","content":"什么时候会是1呢？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551372455,"ip_address":"","comment_id":71528,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23026199836","product_id":100023901,"comment_content":"Count那个应该是1到20000之间吧，而不是10000到20000之间吧？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441190,"discussion_content":"什么时候会是1呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551372455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1305608,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ec/08/8cbd5df3.jpg","nickname":"Geek_5562a2","note":"","ucode":"7F2D1ED389C969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212205,"discussion_content":"这就是买500万彩票的问题。概率是有的，你碰到到吗。😂😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584945940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71345,"user_name":"0928","can_delete":false,"product_type":"c1","uid":1240990,"ip_address":"","ucode":"03221745CF8141","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/9e/78420b67.jpg","comment_is_top":false,"comment_ctime":1551324455,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23026160935","product_id":100023901,"comment_content":"long和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作所以在并发时存在数据不一致的问题。","like_count":5,"discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532944,"discussion_content":"64位JVM不保证对一个机器字操作仍然是原子操作 这个计算机没有关系 而是因为JVM规范定义64位类型 long double 可以拆分成两个32位执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637736438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055854,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","nickname":"终结者999号","note":"","ucode":"33ADE61580B6DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158695,"discussion_content":"那如果是64位的JVM，就不会出现原子性问题了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580615516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2027015,"avatar":"","nickname":"Geek_da3185","note":"","ucode":"D347A52BA62C0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1055854,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","nickname":"终结者999号","note":"","ucode":"33ADE61580B6DD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":278298,"discussion_content":"会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591170967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":158695,"ip_address":""},"score":278298,"extra":""}]}]},{"had_liked":false,"id":98293,"user_name":"rock","can_delete":false,"product_type":"c1","uid":1126597,"ip_address":"","ucode":"A512CED4619E7A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJZhuQk0ibMqdsASdJib2aUKNjTiaVm1ib3EfjyyiaKBJAyzYFls9KTEQ3w60cpy5CPLRNHsX8uooDoB8g/132","comment_is_top":false,"comment_ctime":1558949520,"is_pvip":false,"replies":[{"id":"35180","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558967668,"ip_address":"","comment_id":98293,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18738818704","product_id":100023901,"comment_content":"对于文中提到的双重检查的问题.我理解这本质上是指令重排序引起的“安全构造问题”。（参见java并发编程实战3.5 安全发布一章）。<br>如宝令老师文中所讲，一个new操作，实际上是多个CPU指令，不是原子操作而是复合操作。<br>这个复合操作会被线程切换中断，导致此构造状态处于“未完成”状态。<br>中断此刻，获得CPU执行权的其他线程会通过第一个判空条件，通过读取instance内存地址获取到此处于“未完成”状态的实例。<br><br>指令重排序在这里起到了关键的“作恶”。即如老师文中所讲，把‘将新开辟的内存地址赋值于instance’指令排序到了‘实例化新开辟内存的各个域’指令前面。这就导致了不正确构造状态的产生。<br><br>针对上述2点，1.构造过程中的，对构造对象的并发访问；2.不正确构造状态的产生；<br>解决方法，杜绝其中任意一个即可。<br><br>杜绝第1点，加锁在整个构造过程，即提高了加锁的范围，这会比文中的实现牺牲并发度，降低性能。<br>杜绝第2点，使用volatile变量禁用指令重拍序。有效且不像第1种方法那样牺牲并发度。","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451632,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558967668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73918,"user_name":"suynan","can_delete":false,"product_type":"c1","uid":1023214,"ip_address":"","ucode":"0AAD1BA9D22D2C","user_header":"","comment_is_top":false,"comment_ctime":1552033358,"is_pvip":false,"replies":[{"id":"27010","content":"多谢你的正确解答","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552059070,"ip_address":"","comment_id":73918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18731902542","product_id":100023901,"comment_content":"关于二少的问题：<br>二少<br>2019-03-08<br><br>关于双重锁的问题，如果线程进入Asynchronized块中以后，在即将执行第三步的时候，发生线程切换了，那么线程A拿到的锁会释放么？<br><br>我的看法：我觉得线程A的锁不会释放。因为编译后，会在synchronized语句结束处或者异常出口处插入指令monitorexit，而只有当jvm执行到这个指令，才会释放锁，显然时间片的切换不会导致锁的释放","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442337,"discussion_content":"多谢你的正确解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552059070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73269,"user_name":"linus","can_delete":false,"product_type":"c1","uid":1240359,"ip_address":"","ucode":"F91EF78DCDB13E","user_header":"","comment_is_top":false,"comment_ctime":1551847343,"is_pvip":false,"replies":[{"id":"26720","content":"会出的，单核也有并发问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551882005,"ip_address":"","comment_id":73269,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18731716527","product_id":100023901,"comment_content":"关于文章开始说的单cpu的情况，如果也是非原子行操作，也会出现并发问题？<br>","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441995,"discussion_content":"会出的，单核也有并发问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551882005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378481,"discussion_content":"只有有分时执行，都会原子性问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623243331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378480,"discussion_content":"只有有分时执行，都会原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623243315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371855,"discussion_content":"单核下多线程也是分时间片执行的，都有运行机会 ，会有原子性问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620026505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72444,"user_name":"ystwo","can_delete":false,"product_type":"c1","uid":1344436,"ip_address":"","ucode":"1C3F8CB457915B","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/b4/1c459a48.jpg","comment_is_top":false,"comment_ctime":1551627721,"is_pvip":false,"replies":[{"id":"26251","content":"太贴切了！jvm压根管不到os，os想做切换就切换<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551660929,"ip_address":"","comment_id":72444,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18731496905","product_id":100023901,"comment_content":"是不是可以把多核cpu比做分布式服务，因为synchronized修饰的代码块里只能在单服务才能起到锁的作用，也就是说两个cpu，a和b同时执行相同的代码，虽然有关键字，但是也无法限定计算机底层对cpu切片的切换，所以在切换后因为new的时候不是原子操作，才会出现因为多线程并发的原因导致有线程拿到空对象","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441591,"discussion_content":"太贴切了！jvm压根管不到os，os想做切换就切换\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551660929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2797783,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/b0/d7/cb391b61.jpg","nickname":"ChesterChai","note":"","ucode":"E8C896CEF2B1A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403820,"discussion_content":"两个cpu的情况下和cpu切片切换有什么关系？不是只有单cpu才会出现切片切换吗？两个cpu应该是并行运行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634169795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71554,"user_name":"Wobum","can_delete":false,"product_type":"c1","uid":1234958,"ip_address":"","ucode":"5EBAD0B3D3D231","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/0e/45f18710.jpg","comment_is_top":false,"comment_ctime":1551368161,"is_pvip":false,"replies":[{"id":"25941","content":"感谢夸奖啊<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551434302,"ip_address":"","comment_id":71554,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18731237345","product_id":100023901,"comment_content":"哇，感觉讲的好通俗易懂啊，nice！","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441200,"discussion_content":"感谢夸奖啊\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551434302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71304,"user_name":"浪尘","can_delete":false,"product_type":"c1","uid":1303610,"ip_address":"","ucode":"DA82FBF16F47BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/3a/ca44a563.jpg","comment_is_top":false,"comment_ctime":1551317732,"is_pvip":false,"replies":[{"id":"25663","content":"总结的很到位","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551369019,"ip_address":"","comment_id":71304,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18731186916","product_id":100023901,"comment_content":"学习到了，以前没有想过简单的count++ 这样的操作都会被cpu拆分成几个指令而形成并发问题；<br>但是如果这么简单的操作都有并发问题，那我们写的多线程程序中对各个共享变量的操作都应该存在类似的问题，应用程序是怎样通过简单的类似于加锁的操作就避免了这种问题的，期待从下面的课程中得到一个答案；<br>总结：导致并发问题的起因主要是缓存可见性，线程切换导致的原子操作问题和编译器优化导致的有序性变化。归结就是多步骤的计算过程在空间或者时间上的混乱（空间上缓存和内存中数据变化没有及时同步，时间上各个线程操作时间线相互穿插，或者编译器优化导致的实际操作过程变化）<br>","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441100,"discussion_content":"总结的很到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551369019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162266,"user_name":"淞淞同学","can_delete":false,"product_type":"c1","uid":1179533,"ip_address":"","ucode":"529A326B898008","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","comment_is_top":false,"comment_ctime":1576489196,"is_pvip":true,"replies":[{"id":"62408","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1576911173,"ip_address":"","comment_id":162266,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14461391084","product_id":100023901,"comment_content":"循环 10000 次 count+=1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。  意思是指的  都有时差，但是基数越小，重复执行有并发问题的次数越少和时间越少，越接近应该的数字。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477994,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576911173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181265,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/51/1d24ead6.jpg","nickname":"一个卖火柴的老男人","note":"","ucode":"1227638C457F49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344222,"discussion_content":"受教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611337540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82035,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1554107467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14439009355","product_id":100023901,"comment_content":"重新温习了一遍，记得之前看过一篇文章，分析了java高级语言中的原子性操作：对于基本数据类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值操作也是原子性的，其他的操作均不具备原子性。因此new关键字不是原子性操作，当被解释器进行优化后，会出现cpu指令级的重新排序，导致并发问题。","like_count":3},{"had_liked":false,"id":76716,"user_name":"别皱眉","can_delete":false,"product_type":"c1","uid":1177354,"ip_address":"","ucode":"D24F65EFF65586","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg","comment_is_top":false,"comment_ctime":1552695532,"is_pvip":false,"replies":[{"id":"27992","content":"非volatile 变量写内存，不会通知其他线程更新缓存中的值<br><br>其他线程，只有缓存失效才会重新去内存加载","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552705153,"ip_address":"","comment_id":76716,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14437597420","product_id":100023901,"comment_content":"老师 <br>既然cpu将缓存写入内存的时机是不确定的 <br>假设共享变量没用volatile <br>那当缓存被写入内存时 会通知其他线程更新该值在缓存中的值吗？<br>还有就是其他线程会在随机时间内重新内存中的值吗？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443418,"discussion_content":"非volatile 变量写内存，不会通知其他线程更新缓存中的值\n\n其他线程，只有缓存失效才会重新去内存加载","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552705153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74055,"user_name":" 臣馟飞扬","can_delete":false,"product_type":"c1","uid":1116188,"ip_address":"","ucode":"F2F882B7678055","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","comment_is_top":false,"comment_ctime":1552095051,"is_pvip":false,"replies":[{"id":"27051","content":"我不知道很多人说的工作内存是啥，所以专栏就没提。我只能暂且认为是cpu缓存，或者问问有些书籍，网文的作者，工作内存究竟是啥<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552097199,"ip_address":"","comment_id":74055,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14436996939","product_id":100023901,"comment_content":"JAVA内存模型中说的每个线程都有自己的工作内存，然后将共享变量从主存读到自己的工作内存中进行操作，操作完后再回写到主存中。假如线程A在将共享变量读到自己的工作内存后，发生CPU切换，线程B读共享变量并操作，操作完回写主存后，线程A继续操作并回写结果，导致可见性问题。那线程的工作内存到底指什么呢？如果是指CPU缓存的话，指的是多个线程共享同一块CPU缓存还是每个线程隔离一块呢？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442412,"discussion_content":"我不知道很多人说的工作内存是啥，所以专栏就没提。我只能暂且认为是cpu缓存，或者问问有些书籍，网文的作者，工作内存究竟是啥\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552097199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1655725,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","nickname":"雷刚","note":"","ucode":"115FE2BE1AAB61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206129,"discussion_content":"一般JVM会尽量将CPU高速缓存分配给线程的工作内存，但如果不够用也分配内存给线程的工作内存。我们学习的时候可以简单的认为，CPU高速缓存是工作内存（栈），而内存则是主存（堆）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584368049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72532,"user_name":"ZYY","can_delete":false,"product_type":"c1","uid":1220744,"ip_address":"","ucode":"C8559A03A7C458","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/88/a7a96ef1.jpg","comment_is_top":false,"comment_ctime":1551665403,"is_pvip":false,"replies":[{"id":"26344","content":"为了让寄存器、缓存里面的值，利用的更充分。<br>i=12；<br>j=23；<br>i++；<br>这个就会优化成<br>i=12；<br>i++；<br>j=23；<br>你看看能不能想明白吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551709192,"ip_address":"","comment_id":72532,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14436567291","product_id":100023901,"comment_content":"编译程序优化指令执行次序，使得缓存能够得到更加合理地利用<br><br>这一句怎么理解呢？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441634,"discussion_content":"为了让寄存器、缓存里面的值，利用的更充分。\ni=12；\nj=23；\ni++；\n这个就会优化成\ni=12；\ni++；\nj=23；\n你看看能不能想明白吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551709192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71573,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1551372614,"is_pvip":false,"replies":[{"id":"25750","content":"io操作不占用cpu<br>是不是有两个io同时执行，要看是什么io设备<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551412227,"ip_address":"","comment_id":71573,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14436274502","product_id":100023901,"comment_content":"老师有两个疑问<br>1.io 操作(等待或者其他读写操作)的时候系统会出让cpu 资源让其执行其他任务，这里说明io 操作不会占用cpu 资源吗？<br>2.io 完成，会执行其他的io 操作这里io 操作都是顺序排队执行的吗？同一时间不会出现两个io 操作，可以这样理解吗？<br>谢谢","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441213,"discussion_content":"io操作不占用cpu\n是不是有两个io同时执行，要看是什么io设备\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551412227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71562,"user_name":"ok绷","can_delete":false,"product_type":"c1","uid":1441991,"ip_address":"","ucode":"7B2303B3319C4D","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/c7/59caefa7.jpg","comment_is_top":false,"comment_ctime":1551369812,"is_pvip":false,"replies":[{"id":"25945","content":"你受益，是对我最大的鼓励<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551434560,"ip_address":"","comment_id":71562,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14436271700","product_id":100023901,"comment_content":"最近在看设计模式，看到老师有说单例模式的双重检查锁模式有问题，但是没有具体解释，但是只是记下来了，今天终于明白了，感谢老师的讲解，受益匪浅。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441205,"discussion_content":"你受益，是对我最大的鼓励\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551434560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71527,"user_name":"蛤蟆先生","can_delete":false,"product_type":"c1","uid":1125703,"ip_address":"","ucode":"8353492D68DBBF","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/47/7c3baa15.jpg","comment_is_top":false,"comment_ctime":1551363256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14436265144","product_id":100023901,"comment_content":"对于创建单例那个问题，可以在声明变量的时候加上 volatile 关键字，有两个作用,一是可以禁止指令重排序(源头三)，二是保证了程序的可见性(源头一)","like_count":3},{"had_liked":false,"id":71515,"user_name":"言希","can_delete":false,"product_type":"c1","uid":1154218,"ip_address":"","ucode":"D7F80B86BCAF2E","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/aa/6f780187.jpg","comment_is_top":false,"comment_ctime":1551360543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14436262431","product_id":100023901,"comment_content":"今天才意识到一直写的饿汉式单例是有安全问题的，以前对导致并发问题的根源模糊不清，今天学习完之后清晰很多，原来技术后面都是有逻辑的。<br><br>思考题:因为long和double是64位的，在32位机器上进行加减操作会分高位和低位进行在线程上下文切换的大环境下，可能会出现其他线程读到一更新了一半的值","like_count":3},{"had_liked":false,"id":71463,"user_name":"牧童纪年","can_delete":false,"product_type":"c1","uid":1263643,"ip_address":"","ucode":"7A98E8DD845C37","user_header":"https://static001.geekbang.org/account/avatar/00/13/48/1b/7de6e72e.jpg","comment_is_top":false,"comment_ctime":1551346930,"is_pvip":false,"replies":[{"id":"25682","content":"volatile 语义下一期会讲。但是不会涉及具体如何实现的。如果大家感兴趣，可以参考《Java并发编程的艺术》","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551370820,"ip_address":"","comment_id":71463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14436248818","product_id":100023901,"comment_content":"对于Jialin同学的volatile 语义的理解，我不太认可，volatile关键字 应该是no cached ，所以不会出现“强制重新把内存中的内容写入到自己的缓存” 这一说，都是写操作完事后，如果不发生任务切换，则直接将修改的最新的值刷新到内存中的把？@王老师，你说呢？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441166,"discussion_content":"volatile 语义下一期会讲。但是不会涉及具体如何实现的。如果大家感兴趣，可以参考《Java并发编程的艺术》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551370820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71426,"user_name":"terry","can_delete":false,"product_type":"c1","uid":1111718,"ip_address":"","ucode":"AF0F4157E2A612","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/a6/3221900b.jpg","comment_is_top":false,"comment_ctime":1551340069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14436241957","product_id":100023901,"comment_content":"讲得真是通俗易懂，尤其是结合三张图的说明，真的是足够清晰了。之前都是靠去记一些概念和规则，老师讲的是通过原理结合图例去说明，并讲述了背景以及硬件和操作系统设计的原因，以及产生的新问题，这回理解了。","like_count":3},{"had_liked":false,"id":71302,"user_name":"石磊","can_delete":false,"product_type":"c1","uid":1252808,"ip_address":"","ucode":"A55C2D1579F7F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/c8/4a67ef73.jpg","comment_is_top":false,"comment_ctime":1551317618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14436219506","product_id":100023901,"comment_content":"B没有拿到锁 B进入第一个if后直接返回了，因为B线程认为这个singleton已经不是null了，故不存在争夺锁资源。","like_count":3},{"had_liked":false,"id":71269,"user_name":"书策稠浊","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1551315123,"is_pvip":false,"replies":[{"id":"25654","content":"目光如炬！是这样的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368374,"ip_address":"","comment_id":71269,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14436217011","product_id":100023901,"comment_content":"两次相加结果应该是10000到20000，两边都是闭区间。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441080,"discussion_content":"目光如炬！是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159619,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1575707646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10165642238","product_id":100023901,"comment_content":"第一次搞清楚单例双重检验为什么还会有bug...","like_count":2},{"had_liked":false,"id":150052,"user_name":"chenmg","can_delete":false,"product_type":"c1","uid":1312023,"ip_address":"","ucode":"A91367C51CE991","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/17/839f0251.jpg","comment_is_top":false,"comment_ctime":1573454236,"is_pvip":false,"replies":[{"id":"57824","content":"在add10k场景下，原子性问题出现的概率很小，相对可见性属于次要因素","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573526835,"ip_address":"","comment_id":150052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10163388828","product_id":100023901,"comment_content":"老师，我感觉两个线程执行add10K()这个方法结果不对，更多的应该是原子性的问题而不是可见性的问题吧？我认为就算是在单核CPU上执行这个问题应该也会有问题的，因为+=这个操作不是原子的","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474051,"discussion_content":"在add10k场景下，原子性问题出现的概率很小，相对可见性属于次要因素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573526835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141509,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1571186655,"is_pvip":false,"replies":[{"id":"54684","content":"读文件调用的是操作系统API，给硬件发送指令，之后挂起线程等待数据读完，用户看来自己的方法被阻塞了。建议去看Linux的源码","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571196674,"ip_address":"","comment_id":141509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10161121247","product_id":100023901,"comment_content":"在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。<br>王老师，这个标记为休眠状态，并让出CPU是在一个时间片结束的时候，还是在一个时间片内呢？<br>作者回复: 时间片内主动释放CPU使用权，无需等到结束<br><br>王老师，这个讲的是进程，线程也是这样吗？<br><br>作者回复: 也是这样，线程才是CPU最小的调度单元<br><br>王老师，还有一个问题，负责读文件的线程是在读这个指令执行完或者读这行代码执行完，才让出cpu吗？还是开始读就标记休眠状态让出cpu呢? 谢谢回答","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470776,"discussion_content":"读文件调用的是操作系统API，给硬件发送指令，之后挂起线程等待数据读完，用户看来自己的方法被阻塞了。建议去看Linux的源码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571196674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138571,"user_name":"約禮","can_delete":false,"product_type":"c1","uid":1338064,"ip_address":"","ucode":"98C315C59EAEC3","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/d0/af2e16f1.jpg","comment_is_top":false,"comment_ctime":1570342580,"is_pvip":false,"replies":[{"id":"53376","content":"程序指令就像菜谱，线程就像人，两个人做同样的菜，自然会执行两次，多线程和程序的关系建议再了解一下","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570430370,"ip_address":"","comment_id":138571,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10160277172","product_id":100023901,"comment_content":"老师，我有一个地方不是很理解，就是“非原子操作的执行路径示意图”，既然线程A已经执行了一条CPU 指令，此时切换给线程B，那么B为什么还会有将count=0加载到寄存器的操作，线程A不是已经执行过了吗？程序执行不应该是以cpu指令做分割吗？那如果按图所示，线程A执行了10条cpu指令，然后切换给了线程B，那是不是这10条指令又要重新在B执行一遍？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469576,"discussion_content":"程序指令就像菜谱，线程就像人，两个人做同样的菜，自然会执行两次，多线程和程序的关系建议再了解一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570430370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137059,"user_name":"小氘","can_delete":false,"product_type":"c1","uid":1622109,"ip_address":"","ucode":"DA55B9A02D9EE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","comment_is_top":false,"comment_ctime":1569587538,"is_pvip":false,"replies":[{"id":"52593","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569645825,"ip_address":"","comment_id":137059,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159522130","product_id":100023901,"comment_content":"并发编程bug的源头之一：多核cpu之间的缓存互相不可见，缓存写入内存不及时，导致别的cpu中的线程读内存时读的不是最新的数据；<br>并发编程bug的源头之二：线程切换是在cpu指令切换之间完成的，而一条高级编程语句包含多条cpu指令，例子中线程A还未完成计算的步骤就被中断，导致线程B读内存时读的不是最新的数据；<br>并发编程bug的源头之三：编译器优化可能会导致cpu指令不是有序的，然后又因为bug原因之二原子性问题，出现了例子3中的空指针异常。<br>写下学习笔记，为评论区添砖加瓦。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468922,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569645825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111420,"user_name":"邢宇超","can_delete":false,"product_type":"c1","uid":1105246,"ip_address":"","ucode":"3113F55E60ADE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/5e/ddbdde5a.jpg","comment_is_top":false,"comment_ctime":1562555576,"is_pvip":false,"replies":[{"id":"40591","content":"会","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562557670,"ip_address":"","comment_id":111420,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10152490168","product_id":100023901,"comment_content":"锁里面会发生线程切换吗  跪求老师解答  这个问题我不弄明白  后面的我就没法看了  ","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457347,"discussion_content":"会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562557670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107746,"user_name":"小吴同学","can_delete":false,"product_type":"c1","uid":1179759,"ip_address":"","ucode":"29F8C0575E32AD","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/6f/f0c0841d.jpg","comment_is_top":false,"comment_ctime":1561602920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151537512","product_id":100023901,"comment_content":"老师，我有个问题~<br>上面可见性代码案例，把private int count = 0; 改为 private volatile int count = 0;<br>这时候为什么还出现了并发问题了呢？用了volatile就没有了可见性和有序性问题了，那就是原子性问题了吧？<br>原子性问题的话，如果是64位，把int改成long后还是会出现并发问题，那是不是64位的long也有并发问题呢？<br>这块不理解，麻烦老师解答一下<br><br>","like_count":2},{"had_liked":false,"id":83250,"user_name":"阿May的海绵宝宝","can_delete":false,"product_type":"c1","uid":1203058,"ip_address":"","ucode":"AA2B28DF8BEF80","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/72/4f8a4297.jpg","comment_is_top":false,"comment_ctime":1554480228,"is_pvip":false,"replies":[{"id":"31826","content":"缓存失效的条件很复杂，不同cpu也不一样。即便跑的慢的把跑的快的数据覆盖了，暂时会下降，跑的慢的线程也会继续把count＋1，所以结果不会比10000小。<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556029464,"ip_address":"","comment_id":83250,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10144414820","product_id":100023901,"comment_content":"线程启动时将内存中的值加载到缓存中，所有计算基于缓存中的值，例子中线程计算10000次加法，在这10000次循环中，随机时间会将当前计算结果写回内存，也会在缓存失效时，缓存重新从内存中加载count值，继续进行计算。还要注意的是缓存中的值是线性的不会忽大忽小。1.是这样理解吗？2.缓存什么情况下失效？3.如果运行过程中，如果重新从内存加载值到缓存中，不就可能造成count值非线性变化吗？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445939,"discussion_content":"缓存失效的条件很复杂，不同cpu也不一样。即便跑的慢的把跑的快的数据覆盖了，暂时会下降，跑的慢的线程也会继续把count＋1，所以结果不会比10000小。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556029464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73754,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1551970266,"is_pvip":false,"replies":[{"id":"26977","content":"切换的时候，寄存器的内容会保存到内存里，切换回来的时候，会从内存加载到寄存器。所以不会重新从内存加载","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552047411,"ip_address":"","comment_id":73754,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10141904858","product_id":100023901,"comment_content":"老师 问下原子性问题，查了下线程切换时候寄存器内容会被清空，那么由线程 B切换回线程 A时候执行 count + 1的count重新从内存加载吧，那不就是读取到了 线程 B回写的结果了？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442262,"discussion_content":"切换的时候，寄存器的内容会保存到内存里，切换回来的时候，会从内存加载到寄存器。所以不会重新从内存加载","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552047411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252567,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","nickname":"绝尘而去","note":"","ucode":"690E4E6B3E39DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361761,"discussion_content":"这里的寄存器指的是cpu缓存吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616747200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1638187,"avatar":"","nickname":"Geek_94adb8","note":"","ucode":"B142F473E1A0B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199897,"discussion_content":"这个应该顶上去，原子性的例子应该需要好好思考一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583636627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73174,"user_name":"拨云见天","can_delete":false,"product_type":"c1","uid":1388409,"ip_address":"","ucode":"125FEE7AC7C2FF","user_header":"https://static001.geekbang.org/account/avatar/00/15/2f/79/61794fe2.jpg","comment_is_top":false,"comment_ctime":1551835124,"is_pvip":false,"replies":[{"id":"26701","content":"b线程在没有获取锁之前，也有可能读到instance，所以才会有文中说的 bug，cpu什么时候刷缓存这个事不确定<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551880164,"ip_address":"","comment_id":73174,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141769716","product_id":100023901,"comment_content":"   非常喜欢老师的讲课风格，让我对学习并发编程产生了信心！对于双重锁的问题，个人结合第二节课【java内存模型】-管程中锁的规则，如果A线程被切换了，但是没有释放锁，那么对于B线程来说如果它在第一处 instance == null判断，由于没有获取锁，那么A线程对instance变量的操作对B线程来说是不可见的，所以第一处的instance==null会通过，然后执行同步块的代码，B线程由于获取不到锁就会被挂起；直到A线程释放锁，然后B线程在第二处instance==null时，由于管程中锁的规则A线程的释放锁操作Happens-BeforeB线程的获取锁操作，只有这时才是可见的，所以B线程在第二处才会返回instance，可能跟有些同学理解的不一样。老师我这样理解正确不？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441951,"discussion_content":"b线程在没有获取锁之前，也有可能读到instance，所以才会有文中说的 bug，cpu什么时候刷缓存这个事不确定\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551880164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72974,"user_name":"tongmin_tsai","can_delete":false,"product_type":"c1","uid":1045090,"ip_address":"","ucode":"D9423E770D5846","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/62/f873cd8f.jpg","comment_is_top":false,"comment_ctime":1551768914,"is_pvip":false,"replies":[{"id":"26498","content":"两个线程可以同时读到同一个值（这个违背任何HB），然后同时+=1，写入内存（这个违背任何HB）。结果是少加了一个1<br><br>只保证可见性，不保证原子性","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551795675,"ip_address":"","comment_id":72974,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10141703506","product_id":100023901,"comment_content":"老师，volatile在这里的具体作用，能帮忙分析一下吗？是否他是让变量变成可见，那么如果按照这个程序执行，还是存在不一致的场景，只有加了锁，代码的执行才是20000，感谢老师解惑<br>public class VisiableTest2 {<br>    private volatile int count = 0;<br><br>    private void add() {<br>        int idx = 0;<br>        while (idx++ &lt; 10000) {<br>            count += 1;<br>        }<br>    }<br><br>    public static int calc() throws Exception {<br>        final VisiableTest2 test = new VisiableTest2();<br>        Thread th1 = new Thread(() -&gt; {<br>            test.add();<br>        });<br>        Thread th2 = new Thread(() -&gt; {<br>            test.add();<br>        });<br><br>        th1.start();<br>        th2.start();<br>        th1.join();<br>        th2.join();<br>        return test.count;<br>    }<br><br>    public static void main(String[] args) throws Exception {<br>        long c = calc();<br>        System.out.println(c);<br>    }<br>}","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441858,"discussion_content":"两个线程可以同时读到同一个值（这个违背任何HB），然后同时+=1，写入内存（这个违背任何HB）。结果是少加了一个1\n\n只保证可见性，不保证原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551795675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2208565,"avatar":"https://static001.geekbang.org/account/avatar/00/21/b3/35/64ccd5b0.jpg","nickname":"🌞","note":"","ucode":"EDE31C3E82A4AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384110,"discussion_content":"不是很懂这里，两个线程可以同时读到同一个使用volatile修饰的这个共享变量，一个线程读到后改了，这个修改的值会被写入到主内存，其他变量缓存行无效后还是会去主内存重新读取，为什么还能读到错的值，不能到两万呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626368909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179759,"avatar":"https://static001.geekbang.org/account/avatar/00/12/00/6f/f0c0841d.jpg","nickname":"小吴同学","note":"","ucode":"29F8C0575E32AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2124,"discussion_content":"本地使用64位，把int改成long后，还是不能到20000，请老师分析一下这是什么原因呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563270125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72028,"user_name":"gogo","can_delete":false,"product_type":"c1","uid":1003104,"ip_address":"","ucode":"E8F0F3B000020A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","comment_is_top":false,"comment_ctime":1551502021,"is_pvip":false,"replies":[{"id":"26103","content":"我的意思是，单核情况下，不存在可见性问题。当然volatile关键字不仅仅有这个作用，你可以看下一篇文章。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551522328,"ip_address":"","comment_id":72028,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141436613","product_id":100023901,"comment_content":"在单核时代，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。<br><br>老师您好，这句话的意思是说单核cpu的情况下共享变量就相当于加了volatile关键字修饰了吗<br>","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441429,"discussion_content":"我的意思是，单核情况下，不存在可见性问题。当然volatile关键字不仅仅有这个作用，你可以看下一篇文章。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551522328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71629,"user_name":"k2b_dll","can_delete":false,"product_type":"c1","uid":1391618,"ip_address":"","ucode":"0E4FD51E2039E5","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/02/d9a8c8ce.jpg","comment_is_top":false,"comment_ctime":1551402964,"is_pvip":false,"replies":[{"id":"25755","content":"volitail变量读写之前的代码，不会重排到之后<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551413725,"ip_address":"","comment_id":71629,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141337556","product_id":100023901,"comment_content":"各位大神回复的volitail关键字修饰instance的时候，是指哪些指令不会被重排序呢？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441242,"discussion_content":"volitail变量读写之前的代码，不会重排到之后\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551413725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71626,"user_name":"我用黑人我自信","can_delete":false,"product_type":"c1","uid":1443895,"ip_address":"","ucode":"60BFB0C806EDCC","user_header":"https://static001.geekbang.org/account/avatar/00/16/08/37/a98500d9.jpg","comment_is_top":false,"comment_ctime":1551402595,"is_pvip":false,"replies":[{"id":"25752","content":"单核也有并发问题，产生并发问题的原因有很多，单核上不用考虑可见性问题<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551412485,"ip_address":"","comment_id":71626,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10141337187","product_id":100023901,"comment_content":"在单核时代，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。<br><br>请问老师这意思是说单核cpu没有并发问题吗","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441239,"discussion_content":"单核也有并发问题，产生并发问题的原因有很多，单核上不用考虑可见性问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551412485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378482,"discussion_content":"有原子性问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623244083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71599,"user_name":"grandcool","can_delete":false,"product_type":"c1","uid":1000037,"ip_address":"","ucode":"7545E76CE3FEFC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/65/f444ea39.jpg","comment_is_top":false,"comment_ctime":1551399601,"is_pvip":false,"replies":[{"id":"25749","content":"寄存器是共用的，线程切换的时候，会把寄存器保存下来，这个在操作系统里叫上下文。你可以理解为每个线程有自己的寄存器<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551411456,"ip_address":"","comment_id":71599,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10141334193","product_id":100023901,"comment_content":"老师，源头二中，将count加载到cpu寄存器这步，对于单核来说，寄存器是给每个线程分配独立空间吗？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441227,"discussion_content":"寄存器是共用的，线程切换的时候，会把寄存器保存下来，这个在操作系统里叫上下文。你可以理解为每个线程有自己的寄存器\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551411456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1638187,"avatar":"","nickname":"Geek_94adb8","note":"","ucode":"B142F473E1A0B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199904,"discussion_content":"顶上去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583636941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71519,"user_name":"狂战俄洛伊","can_delete":false,"product_type":"c1","uid":1213269,"ip_address":"","ucode":"F6EACA321E6180","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUzv6S9wroydkGP6m3OsQ8QuI4jAibv21tNkm7KVGPffJibj8Y29yIdKl4qkDGd3iaGJCSGVarfxoibQ/132","comment_is_top":false,"comment_ctime":1551361963,"is_pvip":false,"replies":[{"id":"25688","content":"两个线程同时读到1，同时增加，同时写入，内存中是2，而不是3。保证可见性，也没用。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551371700,"ip_address":"","comment_id":71519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141296555","product_id":100023901,"comment_content":"就是那个计数的问题，我使用了volitile关键字来修饰count变量，可是还是得不到20000，为什么呢？volitile不就是保证共享变量的可见性的么","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441184,"discussion_content":"两个线程同时读到1，同时增加，同时写入，内存中是2，而不是3。保证可见性，也没用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551371700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71516,"user_name":"crudBoy","can_delete":false,"product_type":"c1","uid":1442091,"ip_address":"","ucode":"D2C94247152ADE","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/2b/2bc4f35b.jpg","comment_is_top":false,"comment_ctime":1551360656,"is_pvip":false,"replies":[{"id":"25687","content":"多核，可以同时跑多个线程。<br>单核，同一时刻只有一个执行，其他线程会挂起。但是你在一个时间段上看，他们是交叉执行的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551371558,"ip_address":"","comment_id":71516,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141295248","product_id":100023901,"comment_content":"你好，我想问一些问题，一个cup同一时刻只能运行一个线程吗？ 之所以想问这个是因为你文章中的代码示例。 你的代码里两个线程的分别调用了add10K这个方法。 如果说一个cup同一时刻可以运行多个线程，那你的配图我觉得有一定的误导，因为你并不知道那两个线程是否真的是跑在两个cup上。 如果说一个cpu同一时刻只能跑一个线程的话你这个配图没问题。  所以，我的问题很简单，cpu是不是同一时刻只能跑一个线程，如果有多个线程同时被启动且机器是单核那么其他的线程是会暂时被挂起还是交叉执行？ 谢谢","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441181,"discussion_content":"多核，可以同时跑多个线程。\n单核，同一时刻只有一个执行，其他线程会挂起。但是你在一个时间段上看，他们是交叉执行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551371558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71509,"user_name":"无为","can_delete":false,"product_type":"c1","uid":1441828,"ip_address":"","ucode":"D5030F322AA774","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/24/88d354e5.jpg","comment_is_top":false,"comment_ctime":1551359501,"is_pvip":false,"replies":[{"id":"25686","content":"会，操作系统不会让它执行100年的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551371315,"ip_address":"","comment_id":71509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141294093","product_id":100023901,"comment_content":"线程A加锁后，执行加锁中的代码的时候，会发生线程切换么？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441180,"discussion_content":"会，操作系统不会让它执行100年的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551371315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71447,"user_name":"小麦","can_delete":false,"product_type":"c1","uid":1216881,"ip_address":"","ucode":"55C7199A0D5659","user_header":"https://static001.geekbang.org/account/avatar/00/12/91/71/0b16655d.jpg","comment_is_top":false,"comment_ctime":1551344163,"is_pvip":true,"replies":[{"id":"25680","content":"缓存一致性协议，可以简单理解为CPU给你提供了一个指令，这个指令可以做到缓存一致性。但是如果你不调用这个指令，那CPU就不负责了。我们的程序，默认编译器都不会调用这个指令的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551370474,"ip_address":"","comment_id":71447,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141278755","product_id":100023901,"comment_content":"课后思考：32位机器的CPU一次最多只能处理32位数据，在Java中的long类型是64位的，所以对long类型的数据进行加减操作就需要多条指令（反正不止一条指令），那么就产生原子性的问题。<br>我的问题：处理器用缓存一致性协议来保证cache的一致，那么为什么还会存在缓存不一致的问题呢？缓存一致性协议到底是怎么起作用的？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441154,"discussion_content":"缓存一致性协议，可以简单理解为CPU给你提供了一个指令，这个指令可以做到缓存一致性。但是如果你不调用这个指令，那CPU就不负责了。我们的程序，默认编译器都不会调用这个指令的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551370474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71433,"user_name":"crazypokerk","can_delete":false,"product_type":"c1","uid":1158383,"ip_address":"","ucode":"9AAD5D9726E503","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/ef/494f56c3.jpg","comment_is_top":false,"comment_ctime":1551341777,"is_pvip":false,"replies":[{"id":"25678","content":"主要取决于编译器，至于解释器、CPU理论上也有优化。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551370215,"ip_address":"","comment_id":71433,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141276369","product_id":100023901,"comment_content":"想请问下老师，那个new对象的操作，是针对所有情况都会进行优化的吗?还是说取决于操作系统或其他什么因素呢？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441145,"discussion_content":"主要取决于编译器，至于解释器、CPU理论上也有优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551370215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71295,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1551317078,"is_pvip":false,"replies":[{"id":"25662","content":"你这么想是对的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368955,"ip_address":"","comment_id":71295,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141251670","product_id":100023901,"comment_content":"点赞 @xx鼠<br>另外，回答@阿根一世提出的问题。<br>出问题的情况并不需要A线程释放锁，只要instance指向内存M，instance==null就不成立了。<br><br> if (instance == null) {<br>      &#47;&#47;条件不成立跳过中间部分。<br> }<br>&#47;&#47;线程B拿到未初始化完成的对象，进行操作，会出问题，不太了解，感觉应该是不可预知的问题。比如那片内存上之前有其他内容<br> ","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441097,"discussion_content":"你这么想是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71280,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1551315888,"is_pvip":false,"replies":[{"id":"25658","content":"对","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368529,"ip_address":"","comment_id":71280,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141250480","product_id":100023901,"comment_content":"双重检锁是因为另外的线程在一个判空的地方拿到的还没进去锁那里，本人看法，不知道对不","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441087,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71266,"user_name":"多拉格·five","can_delete":false,"product_type":"c1","uid":1207914,"ip_address":"","ucode":"07023F43811EE3","user_header":"https://static001.geekbang.org/account/avatar/00/12/6e/6a/38a3fa8d.jpg","comment_is_top":false,"comment_ctime":1551314997,"is_pvip":false,"replies":[{"id":"25653","content":"Java内存模型告诉你解决方案了，敬请期待。优化后的路径，可以看Java的字节码。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368348,"ip_address":"","comment_id":71266,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141249589","product_id":100023901,"comment_content":"老师我想问一下,既然优化后会出现问题,那么怎么修改能避免这种问题,还有怎么打印出来或者是怎么能看到优化后的路径","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441078,"discussion_content":"Java内存模型告诉你解决方案了，敬请期待。优化后的路径，可以看Java的字节码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71235,"user_name":"邋遢的流浪剑客","can_delete":false,"product_type":"c1","uid":1260881,"ip_address":"","ucode":"32AF6F9070506D","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/51/9723276c.jpg","comment_is_top":false,"comment_ctime":1551308733,"is_pvip":false,"replies":[{"id":"25646","content":"感谢认可，我会继续努力！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551367840,"ip_address":"","comment_id":71235,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141243325","product_id":100023901,"comment_content":"老师讲的真好，结合之前看并发编程相关书籍的内容理解更深刻了","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441061,"discussion_content":"感谢认可，我会继续努力！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551367840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323783,"user_name":"小黄鸭","can_delete":false,"product_type":"c1","uid":2708370,"ip_address":"","ucode":"2800E3A723AEBD","user_header":"https://static001.geekbang.org/account/avatar/00/29/53/92/21c78176.jpg","comment_is_top":false,"comment_ctime":1638160071,"is_pvip":false,"replies":[{"id":"117737","content":"对于多核CPU，每个物理CPU核都有自己的寄存器。对于逻辑CPU，操作系统做上下文切换的时候，两个线程也不能共享寄存器","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1638447056,"ip_address":"","comment_id":323783,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5933127367","product_id":100023901,"comment_content":"老师，对于文中线程A和B同时操作count变量这个例子，我有疑问。<br>既然B在寄存器中完成了+1的操作，那寄存器中count值难道不是1吗？A接下来+1这样也是2了。<br>针对这个问题，是否是因为A、B线程在CPU中的使用的寄存器不是同一个呢？<br>如果是这样的话，线程中设置同一个变量为共享寄存器不就可以解决了吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535460,"discussion_content":"对于多核CPU，每个物理CPU核都有自己的寄存器。对于逻辑CPU，操作系统做上下文切换的时候，两个线程也不能共享寄存器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638447056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2708370,"avatar":"https://static001.geekbang.org/account/avatar/00/29/53/92/21c78176.jpg","nickname":"小黄鸭","note":"","ucode":"2800E3A723AEBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":537662,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639132297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":535460,"ip_address":""},"score":537662,"extra":""}]}]},{"had_liked":false,"id":302794,"user_name":"🌞","can_delete":false,"product_type":"c1","uid":2208565,"ip_address":"","ucode":"EDE31C3E82A4AD","user_header":"https://static001.geekbang.org/account/avatar/00/21/b3/35/64ccd5b0.jpg","comment_is_top":false,"comment_ctime":1626368988,"is_pvip":false,"replies":[{"id":"109670","content":"两个cpu寄存器里都有共享变量，加1操作是在寄存器里加的，加完后写内存。寄存器里同时都加1了，加1完成了以后就不会重新再去读新的值了。你想一想如果此时还要重新加载新值，重新计算，那cpu就变成有状态的了，这样的cpu得有多复杂，速度如何保证？组成原理部分的知识还是需要了解一下的，尤其是cpu的原理，不需要太深，了解即可。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1626589808,"ip_address":"","comment_id":302794,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5921336284","product_id":100023901,"comment_content":"老师，volatile在这里的具体作用，能帮忙分析一下吗？是否他是让变量变成可见，那么如果按照这个程序执行，还是存在不一致的场景，只有加了锁，代码的执行才是20000，感谢老师解惑<br>public class VisiableTest2 {<br>    private volatile int count = 0;<br><br>    private void add() {<br>        int idx = 0;<br>        while (idx++ &lt; 10000) {<br>            count += 1;<br>        }<br>    }<br><br>    public static int calc() throws Exception {<br>        final VisiableTest2 test = new VisiableTest2();<br>        Thread th1 = new Thread(() -&gt; {<br>            test.add();<br>        });<br>        Thread th2 = new Thread(() -&gt; {<br>            test.add();<br>        });<br><br>        th1.start();<br>        th2.start();<br>        th1.join();<br>        th2.join();<br>        return test.count;<br>    }<br><br>    public static void main(String[] args) throws Exception {<br>        long c = calc();<br>        System.out.println(c);<br>    }<br>}<br><br>我看您回答的：两个线程可以同时读到同一个值（这个违背任何HB），然后同时+=1，写入内存（这个违背任何HB）。结果是少加了一个1<br><br>只保证可见性，不保证原子性<br><br><br>但是我想问：<br>两个线程可以同时读到同一个使用volatile修饰的这个共享变量，一个线程读到后改了，这个修改的值会被写入到主内存，其他变量缓存行无效后还是会去主内存重新读取，为什么还能读到错的值，不能到两万呢<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523425,"discussion_content":"两个cpu寄存器里都有共享变量，加1操作是在寄存器里加的，加完后写内存。寄存器里同时都加1了，加1完成了以后就不会重新再去读新的值了。你想一想如果此时还要重新加载新值，重新计算，那cpu就变成有状态的了，这样的cpu得有多复杂，速度如何保证？组成原理部分的知识还是需要了解一下的，尤其是cpu的原理，不需要太深，了解即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626589808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255257,"user_name":"ddww","can_delete":false,"product_type":"c1","uid":1184678,"ip_address":"","ucode":"2871112FC9B3F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJDgV2qia6eAL7Fb4egX3odViclRRwOlkfCBrjhU9lLeib90KGkIDjdddSibNVs47N90L36Brgnr6ppiag/132","comment_is_top":false,"comment_ctime":1603290838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898258134","product_id":100023901,"comment_content":"通过王老师的精彩讲解，对于理解线程的原子性问题有很大帮助。一条高级语言的执行，可能需要多条cpu指令。以文中的count+=1来说，可能需要三条cpu指令。对于多线程而言，cpu指令的执行，存在线程切换，这不就是指令的切换。假设线程A，B，指令如文中所讲1，2，3。A-&gt;1-&gt;2,发生线程切换，B-&gt;1,这是把A辛辛苦苦改好的值又变成0，B-&gt;2-&gt;3，线程切换A-&gt;3。","like_count":1},{"had_liked":false,"id":247182,"user_name":"F","can_delete":false,"product_type":"c1","uid":1623985,"ip_address":"","ucode":"1C8EFA3B29DB5B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK3cxCib9BJKghiaSY5SicT3m5BN8EAx4SPYePEFGo4iaLGB9fiazXAdEzt6iamIiaOvjVsxWN7gqSuHDT3A/132","comment_is_top":false,"comment_ctime":1599627123,"is_pvip":false,"replies":[{"id":"90832","content":"不会，锁是java里的概念，cpu做上下文切换根本不知道有锁这东西","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1599661936,"ip_address":"","comment_id":247182,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5894594419","product_id":100023901,"comment_content":"线程切换时会释放持有的锁吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505334,"discussion_content":"不会，锁是java里的概念，cpu做上下文切换根本不知道有锁这东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599661936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217124,"user_name":"I am watermelon","can_delete":false,"product_type":"c1","uid":1771658,"ip_address":"","ucode":"009EFA2065221C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/08/8a/c141ff16.jpg","comment_is_top":false,"comment_ctime":1589423092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884390388","product_id":100023901,"comment_content":"想请教一下老师。java分配内存的时候，这个时候应该会赋默认值，Java虚拟机就会开始对新创建的对象按照程序猿的意志进行初始化。这种操作是连续性的，但是文章却说这个时候切出去，并且切出去之后报空指针。我感觉首先不应该切出去，其次就算切出去也不能报空指针，因为对象存在，只不过对象里面的属性都是默认值。","like_count":1},{"had_liked":false,"id":196171,"user_name":"苏暮沉觞","can_delete":false,"product_type":"c1","uid":1577580,"ip_address":"","ucode":"532B816D4EF47B","user_header":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","comment_is_top":false,"comment_ctime":1585241985,"is_pvip":false,"replies":[{"id":"76118","content":"理论上也有可能，不过编译优化后都是在寄存器里执行的，会写内存，但是不会读内存，数据都是在寄存器里完成的计算。所以应该是重现不了小于10000的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1586258195,"ip_address":"","comment_id":196171,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880209281","product_id":100023901,"comment_content":"老师，评论中讲到出现count小于10000的现象，我觉得可能是以下原因：<br>1、当线程1，线程2都从内存中获取count=0到CPU缓存。<br>2、线程1 不执行，线程2执行9999次，这时内存中的count=9999<br>3、线程1 执行count += 1，并写入内存。这时内存中的count = 1<br>4、线程2要执行最后一次+1，因为CPU的缓存失效了，要去内存中获取。于是获取了count=1的值。<br>5、这时候线程1执行了又执行了9999次，这时候内存中的count= 10000<br>6、当线程2将之前获取到的count+1，将最后的2写入内存中。这就导致了最后的count可能小于10000.<br>以上都是我很极限的假设。希望老师指点一下我的假设是否正确？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489237,"discussion_content":"理论上也有可能，不过编译优化后都是在寄存器里执行的，会写内存，但是不会读内存，数据都是在寄存器里完成的计算。所以应该是重现不了小于10000的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586258195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187901,"user_name":"灰太狼","can_delete":false,"product_type":"c1","uid":1066046,"ip_address":"","ucode":"C17DD5D5ED9DC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","comment_is_top":false,"comment_ctime":1584271307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879238603","product_id":100023901,"comment_content":"Java并发实战这本书太经典，都是大神写的，尤其Doug Lea，神一样的存在","like_count":1},{"had_liked":false,"id":155215,"user_name":"HapLe0","can_delete":false,"product_type":"c1","uid":1642097,"ip_address":"","ucode":"F64CDE42451A5C","user_header":"https://static001.geekbang.org/account/avatar/00/19/0e/71/b273831e.jpg","comment_is_top":false,"comment_ctime":1574665006,"is_pvip":false,"replies":[{"id":"59681","content":"如果没有线程切换，一个线程在一个CPU上执行不被中断，就没有原子问题了。反过来想想","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1574727626,"ip_address":"","comment_id":155215,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869632302","product_id":100023901,"comment_content":"老师，您将原子性问题归结为线程切换导致的，是不是不够全面呀，单CPU的线程切换和多CPU的并发执行都是原子性问题的原因吧","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475693,"discussion_content":"如果没有线程切换，一个线程在一个CPU上执行不被中断，就没有原子问题了。反过来想想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574727626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149513,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1125259,"ip_address":"","ucode":"7BF52ADBFD4F5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/8b/dd02189a.jpg","comment_is_top":false,"comment_ctime":1573261962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868229258","product_id":100023901,"comment_content":"老师好，关于“嘎嘎”同学的流程分析中的3和4有有不同意见<br>“<br>4.在还没有进行第三步（将instance引用指向内存空间）的时候，线程A离开了synchronized块<br>5.线程B进入synchronized块，读取到了A线程返回的instance，此时这个instance并未进行物理地址指向，是一个空对象。<br>”<br>第一，4中应该是指令重排后进行了第二步，但是没有进行第三步。也就是说instance已经指向了内存地址，但是没有完成对象初始化<br>第二，4中的A线程此时还占有了synchronized 块，但是发生了时间片切换。“嘎嘎”在5中描述的线程Ｂ进入synchronized 块也不对，因为此时线程A还在持有锁<br><br>所以我的改写一下“嘎嘎”的描述应该是<br>4.在线程在线程A在new语句中执行了步骤1和3（1分配内存空间，3instance执行所非配的内存空间）但是还没执行2（初始化对象）的时候发生了时间片切换<br>5.线程Ｂ进入第一个instance == null判断的时候，是false，所以线程Ｂ在此时A线程并未完成初始化对象指令的时候调用instance的属性就会出现空指针<br><br>还请宝令老师指正","like_count":1},{"had_liked":false,"id":148350,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1572997035,"is_pvip":false,"replies":[{"id":"57223","content":"所有的线程都是操作系统负责调度的，jvm不负责调度线程。你可以看操作系统原理。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573041778,"ip_address":"","comment_id":148350,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5867964331","product_id":100023901,"comment_content":"老师，我问一个计算机操作系统的问题：<br>CPU各个线程之间有调度，那对于多核CPU来说，一个PC上上各个CPU谁来控制如何分工协作呢？又听说过jvm是一个cpu抢占性，是每一个可以使用多核cpu的一个软件or工具都需要自己去来管理多核CPU之间的相关调度问题吗？如果觉得这个解释起来需要的篇幅太长，可以提供一些参考性的文章书籍等","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473466,"discussion_content":"所有的线程都是操作系统负责调度的，jvm不负责调度线程。你可以看操作系统原理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573041778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181265,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/51/1d24ead6.jpg","nickname":"一个卖火柴的老男人","note":"","ucode":"1227638C457F49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344221,"discussion_content":"换句话就是Java的线程调度其实还是由操作系统调度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611337315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181265,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/51/1d24ead6.jpg","nickname":"一个卖火柴的老男人","note":"","ucode":"1227638C457F49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344220,"discussion_content":"Java中的线程通过jvm映射到系统内核线程，所以用Java频繁创建和销毁线程消耗资源，一般使用线程池。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611337225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147299,"user_name":"苏阳华","can_delete":false,"product_type":"c1","uid":1442451,"ip_address":"","ucode":"B61CA619518BD5","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/93/2255ef9b.jpg","comment_is_top":false,"comment_ctime":1572856483,"is_pvip":false,"replies":[{"id":"67562","content":"程序员保证单例对象必须无状态，否则就可能存在并发问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579776386,"ip_address":"","comment_id":147299,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867823779","product_id":100023901,"comment_content":"两个线程同时对一个变量进行+1操作。是一直读取cpu缓存里面吗？在什么时候会把缓存里面的数据回填到内存里面去？<br>对于java里面的对象，初始化基本都是不带锁的，只要有多个线程共同使用，就会存在多线程的问题。<br>对于一个普通java web应用。spring管理着所有的对象，在很短时间内同时又100个用户请求进来，这种会产生什么并发问题？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473224,"discussion_content":"程序员保证单例对象必须无状态，否则就可能存在并发问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579776386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140798,"user_name":"黄浩特","can_delete":false,"product_type":"c1","uid":1018240,"ip_address":"","ucode":"C3A4BBF4FB8519","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/80/3666ced3.jpg","comment_is_top":false,"comment_ctime":1571050269,"is_pvip":false,"replies":[{"id":"54613","content":"😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571142949,"ip_address":"","comment_id":140798,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866017565","product_id":100023901,"comment_content":"看完这篇终于对可见性 原子性和有序性有个完整的认识, 老师通过流程图例子讲解真是太清晰了<br>可见性: 私有缓存导致<br>原子性: 高级语言语句对应多CPU指令加上任务切换的时间片粒度是单条CPU指令<br>有序性: 编译优化带来的指令重排序","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470566,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571142949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135057,"user_name":"LoveDlei","can_delete":false,"product_type":"c1","uid":1102916,"ip_address":"","ucode":"68065848DF518B","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/44/ec084136.jpg","comment_is_top":false,"comment_ctime":1568991828,"is_pvip":false,"replies":[{"id":"51897","content":"建议看一下计算机组成原理，极客时间也有这方面的课程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569121207,"ip_address":"","comment_id":135057,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863959124","product_id":100023901,"comment_content":"老师您好，非计算机科班出身，有些疑惑不解需要老师解惑。<br>CPU,内存，IO设备之间的访问关系是什么样的？<br>或者说这三个都是数据存储设备，<br>CPU读写CPU；<br>CPU读写内存；<br>内存读写内存；<br>内存读写IO设备；<br>CPU读写IO设备；<br><br>请问三者之间的关系是否是这样的嘛？<br><br>希望老师解惑？感谢🙏<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468024,"discussion_content":"建议看一下计算机组成原理，极客时间也有这方面的课程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569121207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133572,"user_name":"姜戈","can_delete":false,"product_type":"c1","uid":1058972,"ip_address":"","ucode":"45C4BE93C8E4CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/9c/73e76b19.jpg","comment_is_top":false,"comment_ctime":1568611539,"is_pvip":false,"replies":[{"id":"51313","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568633347,"ip_address":"","comment_id":133572,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5863578835","product_id":100023901,"comment_content":"有个疑问：单核单CPU，是不是就没有可见性的问题？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467432,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568633347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1058972,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/9c/73e76b19.jpg","nickname":"姜戈","note":"","ucode":"45C4BE93C8E4CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12963,"discussion_content":"不局限编程语言，单核单CPU，是不是不用考虑可见性？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568620277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125985,"user_name":"Geek_d267c4","can_delete":false,"product_type":"c1","uid":1635357,"ip_address":"","ucode":"991B1B29715819","user_header":"","comment_is_top":false,"comment_ctime":1566289488,"is_pvip":false,"replies":[{"id":"46469","content":"不存在，缓存一定能写到内存，如果写不进去，除非内存挂了，或者CPU有bug","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566310408,"ip_address":"","comment_id":125985,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861256784","product_id":100023901,"comment_content":"您好老师，我刚刚购买您的课程，正在从第一章开始看，我有一个疑惑，期待您的答复。是这样的，在第一章《并发编程Bug的源头》，我看到评论区的&quot;阿May的海绵宝宝&quot;的问题：<br>“线程启动时将内存中的值加载到缓存中，所有计算基于缓存中的值，例子中线程计算10000次加法，在这10000次循环中，随机时间会将当前计算结果写回内存，也会在缓存失效时，缓存重新从内存中加载count值，继续进行计算。还要注意的是缓存中的值是线性的不会忽大忽小。1.是这样理解吗？2.缓存什么情况下失效？3.如果运行过程中，如果重新从内存加载值到缓存中，不就可能造成count值非线性变化吗？”<br><br>您当时答复：&quot;缓存失效的条件很复杂，不同cpu也不一样。即便跑的慢的把跑的快的数据覆盖了，暂时会下降，跑的慢的线程也会继续把count＋1，所以结果不会比10000小。&quot;<br><br>那么我想问一下，可不可能存在这种情况？就是2个线程启动后，将内存中的值加载到缓存中，此时count=0，但是，等到2个线程中count计算完毕的时候，缓存突然全部失效了，在失效之前，也没有将缓存写到主内存中去。导致了count打印出来的结果还是0。这样的情况理论上存在吗？期待老师您的答复！谢谢。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463775,"discussion_content":"不存在，缓存一定能写到内存，如果写不进去，除非内存挂了，或者CPU有bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566310408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119322,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1564561212,"is_pvip":false,"replies":[{"id":"44020","content":"现在cpu指令的角度，没有什么工作内存，工作内存只是逻辑存在，物理上只有内存和cpu缓存。建议不要用工作内存来理解。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1564720007,"ip_address":"","comment_id":119322,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859528508","product_id":100023901,"comment_content":"老师，请问一下，可见性问题中描述的CPU 缓存与内存的关系图里，线程A和线程B分别有自己的工作内存且会存储共享变量的副本。那么如果CPU执行线程A把CPU缓存中的变量数据取到A的工作内存中后，时间片切换到执行线程B也把CPU缓存中的变量数据取到B的工作内存中并执行相关修改操作，执行完后回写到CPU缓存中。这时时间片切换到执行线程A，线程A执行完相关修改操作回写到CPU缓存时会覆盖调线程B的修改结果。这样的话还是存在可见性问题的。还是说我理解的有问题，求解答。<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460849,"discussion_content":"现在cpu指令的角度，没有什么工作内存，工作内存只是逻辑存在，物理上只有内存和cpu缓存。建议不要用工作内存来理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564720007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109659,"user_name":"itschenxiang","can_delete":false,"product_type":"c1","uid":1519547,"ip_address":"","ucode":"7D90194AC52435","user_header":"https://static001.geekbang.org/account/avatar/00/17/2f/bb/4236d712.jpg","comment_is_top":false,"comment_ctime":1562072742,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5857040038","product_id":100023901,"comment_content":"老师你画的图中，多核CPU的每个核为什么都称为CPU-1，CPU-2？？？","like_count":1,"discussions":[{"author":{"id":1058972,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/9c/73e76b19.jpg","nickname":"姜戈","note":"","ucode":"45C4BE93C8E4CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12949,"discussion_content":"简单标识吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568617677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109525,"user_name":"itschenxiang","can_delete":false,"product_type":"c1","uid":1519547,"ip_address":"","ucode":"7D90194AC52435","user_header":"https://static001.geekbang.org/account/avatar/00/17/2f/bb/4236d712.jpg","comment_is_top":false,"comment_ctime":1562050752,"is_pvip":false,"replies":[{"id":"39681","content":"不会","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562069346,"ip_address":"","comment_id":109525,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857018048","product_id":100023901,"comment_content":"老师你在可见性的部分提到了多核，多核一般不是应该还是一个CPU，多个内核处理器吗？一般多核不会用来指多个单核CPU吧","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456451,"discussion_content":"不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562069346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102464,"user_name":"狒狒","can_delete":false,"product_type":"c1","uid":1242295,"ip_address":"","ucode":"10A320ECEBF074","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/b7/5c775af5.jpg","comment_is_top":false,"comment_ctime":1560226822,"is_pvip":false,"replies":[{"id":"37121","content":"我觉得是对的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1560263302,"ip_address":"","comment_id":102464,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855194118","product_id":100023901,"comment_content":"循环次数为1万时，count结果[10000,2000]之间的随机数<br>循环次数为1亿时，count结果在[1亿,2亿]之间，接近1亿<br>**原因分析：**两个线程启动有一个时间差，即后执行线程初始count可能不为0，而是基于前一个执行并将CPU缓存count值写回内存后的线程，而这个值在[0,循环次数]之间，而内存众最终返回的count值取决与后执行的（初始count值较大的）那个线程的执行结果；而随着循环次数的增大，这个时间差造成的count值差异相对变小，故循环次数接近1亿时，返回count值接近1亿，启动时间查造成的差异值相对1亿这个循环次数微不足道，希望老师或者热心同学帮助解答，这样分析对不对","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453436,"discussion_content":"我觉得是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560263302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92503,"user_name":"唯爱龚迪","can_delete":false,"product_type":"c1","uid":1441350,"ip_address":"","ucode":"54382209E2B2CE","user_header":"https://static001.geekbang.org/account/avatar/00/15/fe/46/0b160701.jpg","comment_is_top":false,"comment_ctime":1557286676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852253972","product_id":100023901,"comment_content":" private static int x = 0, y = 0;<br>    private static int a = 0, b =0;<br><br>    public static void main(String[] args) throws InterruptedException {<br>        int i = 0;<br>        for(;;) {<br>            i++;<br>            x = 0; y = 0;<br>            a = 0; b = 0;<br>            CountDownLatch latch = new CountDownLatch(1);<br><br>            Thread one = new Thread(() -&gt; {<br>                try {<br>                    latch.await();<br>                } catch (InterruptedException e) {<br>                }<br>                a = 1;<br>                x = b;<br>            });<br><br>            Thread other = new Thread(() -&gt; {<br>                try {<br>                    latch.await();<br>                } catch (InterruptedException e) {<br>                }<br>                b = 1;<br>                y = a;<br>            });<br>            one.start();other.start();<br>            latch.countDown();<br>            one.join();other.join();<br><br>            String result = &quot;第&quot; + i + &quot;次 (&quot; + x + &quot;,&quot; + y + &quot;）&quot;;<br>            if(x == 0 &amp;&amp; y == 0) {<br>                System.err.println(result);<br>                break;<br>            } else {<br>                System.out.println(result);<br>            }<br>        }<br>    }<br><br>这里附加上一个演示指令重排序的例子。","like_count":1},{"had_liked":false,"id":89741,"user_name":"Geek_Bowen","can_delete":false,"product_type":"c1","uid":1510409,"ip_address":"","ucode":"EE97A8AD9052AB","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/09/e73e3709.jpg","comment_is_top":false,"comment_ctime":1556253948,"is_pvip":false,"replies":[{"id":"32182","content":"锁不会释放","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556280725,"ip_address":"","comment_id":89741,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851221244","product_id":100023901,"comment_content":"老师，我想请教一下。线程切换让出CPU是不是就意味着锁也释放了？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448243,"discussion_content":"锁不会释放","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556280725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89088,"user_name":"Bright丶","can_delete":false,"product_type":"c1","uid":1138016,"ip_address":"","ucode":"B1DEA8C8100538","user_header":"https://static001.geekbang.org/account/avatar/00/11/5d/60/38ea52c5.jpg","comment_is_top":false,"comment_ctime":1556074478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851041774","product_id":100023901,"comment_content":"对于文中例子最后结果出现9000小于10000这种结果，我想线程之间的执行大概是这样子的：线程A和线程B首先都读取到count的值为0，这时候线程A得到执行权，假如线程A将count的值操作到了5000后切换到线程B，线程B寄存器保存的count的值还是0，执行操作后为1再切换到线程A，线程A读取到的是1，前面5000次操作都白费了，操作后可能为2，并且线程A将2读取寄存器了，线程B读取到2，操作5000次后再切换为线程A，线程A操作后可能变成了3，线程B的5000次操作又白费了，以此类推，白费力气了很多次，最后结果可能小于10000","like_count":1},{"had_liked":false,"id":86507,"user_name":"ycfHH","can_delete":false,"product_type":"c1","uid":1498283,"ip_address":"","ucode":"084FF6C86CBCE4","user_header":"","comment_is_top":false,"comment_ctime":1555385689,"is_pvip":false,"replies":[{"id":"31153","content":"单纯的赋值操作，说volatile具备原子性也不错，看语境吧，不做口舌之争","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555414202,"ip_address":"","comment_id":86507,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850352985","product_id":100023901,"comment_content":"关于32 位的机器上对 long 型变量进行加减操作存在并发隐患<br>这个问题看到评论区说加volatile可以解决，完全不明白。原子性的问题咋就能用volatile关键字解决了呢？感觉long类型加volatile单纯是因为可见性吧。有序性感觉也没啥关系吧，高32位和低32位分开执行顺序即使错开也没什么关系。蒙圈了.....<br>望老师解答","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447043,"discussion_content":"单纯的赋值操作，说volatile具备原子性也不错，看语境吧，不做口舌之争","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555414202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80423,"user_name":"起风了","can_delete":false,"product_type":"c1","uid":1293977,"ip_address":"","ucode":"833C535ECB9706","user_header":"https://static001.geekbang.org/account/avatar/00/13/be/99/010f91a1.jpg","comment_is_top":false,"comment_ctime":1553659574,"is_pvip":false,"replies":[{"id":"29304","content":"是的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553694066,"ip_address":"","comment_id":80423,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848626870","product_id":100023901,"comment_content":"作者你好，在文中您说的创建一个对象是先 分配一个地址M，然后在地址M上实例化对象，在将M地址赋值给变量， 这种是正常的对象创建流程呢?，如果是的话，那 分配一个地址M，将M地址赋值给变量，然后在M地址上初始化对象 这种您在文中称之为优化，是指 指令重排 优化嘛？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444860,"discussion_content":"是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553694066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80179,"user_name":"new life","can_delete":false,"product_type":"c1","uid":1447866,"ip_address":"","ucode":"B817AC3909102B","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/ba/c56aa720.jpg","comment_is_top":false,"comment_ctime":1553614182,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5848581478","product_id":100023901,"comment_content":"以前这块总是似懂非懂，看了老师的文章有种豁然开朗的感觉，尤其是单例模式的线程安全问题，看完之后明白了👍","like_count":1},{"had_liked":false,"id":79891,"user_name":"子明","can_delete":false,"product_type":"c1","uid":1444690,"ip_address":"","ucode":"37F47F2A21E91F","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/52/faf3d80e.jpg","comment_is_top":false,"comment_ctime":1553569854,"is_pvip":false,"replies":[{"id":"29245","content":"概率太低，很难模拟。程序没有访问instance里的属性，永远都没有空指针","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553648965,"ip_address":"","comment_id":79891,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848537150","product_id":100023901,"comment_content":"public class SingletonTest {<br><br>    private static SingletonTest instance;<br><br>    static SingletonTest getInstance() {<br>        if (instance == null) {<br>            synchronized (SingletonTest.class) {<br>                if (instance == null) {<br>                    instance = new SingletonTest();<br>                }<br>            }<br>        }<br>        return instance;<br>    }<br><br>    public static void main(String[] args) {<br>        &#47;&#47; 计数器<br>        CountDownLatch countDownLatch = new CountDownLatch(1);<br>        for (int i = 0; i &lt; 100000; i++) {<br>            new Thread(() -&gt; {<br>                try {<br>                    &#47;&#47; 阻塞线程<br>                    countDownLatch.await();<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>                SingletonTest.getInstance();<br>            }).start();<br>        }<br>        &#47;&#47; 所有线程并发执行<br>        countDownLatch.countDown();<br>    }<br>}<br>这边写了一个类来模拟并发，没有出现空指针异常，是我模拟的有问题吗","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444669,"discussion_content":"概率太低，很难模拟。程序没有访问instance里的属性，永远都没有空指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553648965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78940,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1553304378,"is_pvip":false,"replies":[{"id":"28785","content":"无法保证<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553326087,"ip_address":"","comment_id":78940,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848271674","product_id":100023901,"comment_content":"王老师，您好，文中累加，如果使用volatile生命，也没法保证最终结果是正确的。volatile是只能保证可见性和有序性，无法保证原子性吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444296,"discussion_content":"无法保证\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553326087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77364,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1552912701,"is_pvip":true,"replies":[{"id":"28195","content":"初学者还是要多看几遍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552917399,"ip_address":"","comment_id":77364,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847879997","product_id":100023901,"comment_content":"long型变量是64位，在32位操作系统上对于long的加减操作是分高低位进行的，对于cpu来说一次操作的最小单位是一个操作指令，那么针对long的需要执行两次操作指令才能完成，出现了文中提到的线程切换带来的原子性问题，也就是并发情况下的隐患。学习过程中还是得边听、边停、边思考、最后总结。只是简单的听一遍，连留下印象都不算，转眼就忘。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443700,"discussion_content":"初学者还是要多看几遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552917399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77223,"user_name":"子曰","can_delete":false,"product_type":"c1","uid":1447299,"ip_address":"","ucode":"1DFF8D9D0D5C70","user_header":"https://static001.geekbang.org/account/avatar/00/16/15/83/b21a3305.jpg","comment_is_top":false,"comment_ctime":1552892075,"is_pvip":false,"replies":[{"id":"28173","content":"只有cpu指令是原子的，这个具体要看cpu的说明书了<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552909137,"ip_address":"","comment_id":77223,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847859371","product_id":100023901,"comment_content":"我怎么判断哪些指令是原子性的，哪些指令不是原子性的？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443643,"discussion_content":"只有cpu指令是原子的，这个具体要看cpu的说明书了\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552909137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75310,"user_name":"夏夏夏夏夏","can_delete":false,"product_type":"c1","uid":1246955,"ip_address":"","ucode":"16114CB647493A","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/eb/b2c110b9.jpg","comment_is_top":false,"comment_ctime":1552377046,"is_pvip":false,"replies":[{"id":"27491","content":"表述精准！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552400941,"ip_address":"","comment_id":75310,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847344342","product_id":100023901,"comment_content":"当A线程执行到&#47;&#47;3，假如发生了重排序，有可能会将instance指向空对象，此时A线程还没有执行完，也没有释放锁。假如此时B线程执行到&#47;&#47;1，则会判断出来instance！=null，所以会导致B线程获取的对象有问题。<br>public class Singleton {<br>  static Singleton instance;<br>  static Singleton getInstance(){<br>    if (instance == null) {                      &#47;&#47;1<br>      synchronized(Singleton.class) {    &#47;&#47;2<br>        if (instance == null)<br>          instance = new Singleton();      &#47;&#47;3<br>        }<br>    }<br>    return instance;<br>  }<br>}<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442857,"discussion_content":"表述精准！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552400941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74168,"user_name":"苏籍","can_delete":false,"product_type":"c1","uid":1396252,"ip_address":"","ucode":"4FA289E084B789","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erYNBIwAj3KdIXaXbeMBUjTMz31zAToHIJSdo7oQk8bfsibwViaLobVQ8miatwBlC5spLS9kVCzHMjUA/132","comment_is_top":false,"comment_ctime":1552125850,"is_pvip":false,"replies":[{"id":"27128","content":"硬件驱动做的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552137859,"ip_address":"","comment_id":74168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847093146","product_id":100023901,"comment_content":"对IO 的操作不占用CPU 吗，是谁做的，操作系统吗","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442479,"discussion_content":"硬件驱动做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552137859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74136,"user_name":"谢谢","can_delete":false,"product_type":"c1","uid":1451379,"ip_address":"","ucode":"13A046A7B9C518","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/73/cbbbaef1.jpg","comment_is_top":false,"comment_ctime":1552113195,"is_pvip":false,"replies":[{"id":"27124","content":"分析的很透彻！<br>A与B如果同时进入第一个分支，那么这个程序就没有问题，如果A线程先获取锁时，B线程未进入第一个分支，那么就可能出现问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552137145,"ip_address":"","comment_id":74136,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847080491","product_id":100023901,"comment_content":"针对嘎嘎所提的第4、5的现象，依据jsr标准是不应该出现，<br>1.A线程释放锁前不会出现B线程获得锁，2.A线程加锁后执行的所有指令都会优先于释放锁。<br>所以结论是A与B如果同时进入第一个分支，那么这个程序就没有问题，如果A线程先获取锁时，B线程未进入第一个分支，那么就可能出现因为指令重排序而先执行1、3指令后，发生线程切换，切换至A线程，此时A线程判断实例不为空进行返回，才会出错。不知是否这么理解，还请老师帮忙解答。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442461,"discussion_content":"分析的很透彻！\nA与B如果同时进入第一个分支，那么这个程序就没有问题，如果A线程先获取锁时，B线程未进入第一个分支，那么就可能出现问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552137145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73971,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1552049917,"is_pvip":false,"replies":[{"id":"27022","content":"volatile关键字 不能解决原子性问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552060833,"ip_address":"","comment_id":73971,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847017213","product_id":100023901,"comment_content":"在32位的jvm上面进行加减过程中，是把64位分为2段32进行的，不是原子性操作，为了解决上面单例有序性问题，应该在声明单例对象上加上volatile关键字，能够防止指令重排","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442364,"discussion_content":"volatile关键字 不能解决原子性问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552060833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73221,"user_name":"归心","can_delete":false,"product_type":"c1","uid":1036567,"ip_address":"","ucode":"985E3188A9F6FE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/17/356cc426.jpg","comment_is_top":false,"comment_ctime":1551842449,"is_pvip":false,"replies":[{"id":"26703","content":"如果两个线程没有并行，执行完一个线程再执行下一个就会是20000","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551880462,"ip_address":"","comment_id":73221,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846809745","product_id":100023901,"comment_content":"王老师，我在运行第一个例子Test类时，count的值会出现20000这个值，而且几率很大。和老师文章中说的 count值都是小于20000的 结论是冲突的，希望老师能解释下，谢谢！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441977,"discussion_content":"如果两个线程没有并行，执行完一个线程再执行下一个就会是20000","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551880462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72642,"user_name":"常银玲","can_delete":false,"product_type":"c1","uid":1252109,"ip_address":"","ucode":"894A34D9AD8942","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/0d/9c3e2241.jpg","comment_is_top":false,"comment_ctime":1551684030,"is_pvip":false,"replies":[{"id":"26350","content":"好认真，加油！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551709826,"ip_address":"","comment_id":72642,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846651326","product_id":100023901,"comment_content":"感觉看留言，学习非常多，大家都非常棒！Java新手，很认真的敲了老师的例子，发现老师对与变量count前面加上static，程序才可以运行起来！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441670,"discussion_content":"好认真，加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551709826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72482,"user_name":"warning","can_delete":false,"product_type":"c1","uid":1374944,"ip_address":"","ucode":"579F557067E94D","user_header":"https://static001.geekbang.org/account/avatar/00/14/fa/e0/0e80101a.jpg","comment_is_top":false,"comment_ctime":1551657684,"is_pvip":false,"replies":[{"id":"26341","content":"读文件，是设备驱动干的事，cpu只管发命令。发完命令，就可以干别的事情了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551708958,"ip_address":"","comment_id":72482,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846624980","product_id":100023901,"comment_content":"大神说到，一个线程执行io操作，比如读操作，这时候cpu会让出时间片，我有个疑问，让出时间片后，还能继续读文件吗，求解答","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441610,"discussion_content":"读文件，是设备驱动干的事，cpu只管发命令。发完命令，就可以干别的事情了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551708958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72374,"user_name":"dybai","can_delete":false,"product_type":"c1","uid":1241805,"ip_address":"","ucode":"5B28E11EF21B05","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/cd/a2ddcd33.jpg","comment_is_top":false,"comment_ctime":1551601722,"is_pvip":false,"replies":[{"id":"26210","content":"可以避免，就是性能差。<br>一定比volatile性能低。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551603161,"ip_address":"","comment_id":72374,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846569018","product_id":100023901,"comment_content":"老师，双重检查的例子里，把第一个if去掉是不是就可以避免指令重排带来的问题了？根据JVM对synchronized的优化(使用轻量级锁)，这种场景下应该不会比volatile性能低吧。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441563,"discussion_content":"可以避免，就是性能差。\n一定比volatile性能低。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551603161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72137,"user_name":"zhangwei","can_delete":false,"product_type":"c1","uid":1246639,"ip_address":"","ucode":"B71CBA5311846F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvrwfqAuRkaK8Pl2apHKFZxd5mjnFhROMNcg5qXUT4AxE2ZTTia5Hg6pmFM1vozq3vZiagJoaJ4Pyg/132","comment_is_top":false,"comment_ctime":1551527850,"is_pvip":false,"replies":[{"id":"26155","content":"是可能看到，只有解锁后才是一定刷缓存","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551544398,"ip_address":"","comment_id":72137,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846495146","product_id":100023901,"comment_content":"老师好，双重检查锁有个问题希望老师解答下，说CPU从线程A切换到了线程B，线程B就看到了对象。是一定能看到呢还是可能看到？如果是一定能看到，是不是说CPU切换到其他线程后，线程A一定会把缓存刷新到内存呢？切换到其他线程之前会不会也刷新缓存到内存呢？谢谢！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441478,"discussion_content":"是可能看到，只有解锁后才是一定刷缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551544398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71935,"user_name":"Colin","can_delete":false,"product_type":"c1","uid":1102992,"ip_address":"","ucode":"2413A85C40B7C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/90/a1e06e28.jpg","comment_is_top":false,"comment_ctime":1551489854,"is_pvip":false,"replies":[{"id":"26087","content":"双重检查创建单例的异常执行路径 这个图上面的文字再理解一下。我们假设线程 A 先执行 getInstance() 方法... ...切换到了线程 B 上；如果此时线程 B 也执行getInstance() 方法。这个时候线程B执行getInstance() 方法的第一行，第一行代码是直接判断instance是否为空，<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551520331,"ip_address":"","comment_id":71935,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846457150","product_id":100023901,"comment_content":"老师 看了其他评论关于双重检验那个还是有点疑惑，线程A还没初始化完毕，线程B怎么会拿到锁然后去判断instance是否为空呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441402,"discussion_content":"双重检查创建单例的异常执行路径 这个图上面的文字再理解一下。我们假设线程 A 先执行 getInstance() 方法... ...切换到了线程 B 上；如果此时线程 B 也执行getInstance() 方法。这个时候线程B执行getInstance() 方法的第一行，第一行代码是直接判断instance是否为空，\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551520331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71822,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1551444337,"is_pvip":false,"replies":[{"id":"26007","content":"高手啊，这个锁不知道哪里来的？<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551450732,"ip_address":"","comment_id":71822,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846411633","product_id":100023901,"comment_content":"因为long是64位的，对于一个32位的系统来说，只要是未被volatile修饰的变量，它的读写操作会被划分成两次32位操作进行的，也就是说只保证32位的原子性，也就是说当线程A写变量a的时候，当写完32位就释放锁，这个时候就存在锁竞争，如果锁被线程A竞争到则一切正常，如果被线程B竞争到，则对于线程B来说，他可能读到了线程A写的一半结果。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441346,"discussion_content":"高手啊，这个锁不知道哪里来的？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551450732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71679,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1551410623,"is_pvip":false,"replies":[{"id":"25947","content":"大家这么活跃，高兴啊！<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551434677,"ip_address":"","comment_id":71679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846377919","product_id":100023901,"comment_content":"评论区很活跃，受益匪浅!<br><br>老师专栏让我想起了这句话:<br><br>活生生地学，学地活生生!","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441273,"discussion_content":"大家这么活跃，高兴啊！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551434677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71662,"user_name":"Home","can_delete":false,"product_type":"c1","uid":1032373,"ip_address":"","ucode":"AAE2C3E539CA96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/b5/bd64c1ac.jpg","comment_is_top":false,"comment_ctime":1551408425,"is_pvip":false,"replies":[{"id":"25930","content":"单核没有可见性问题，单核cpu有线程安全问题，会有原子性问题，有序性问题<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551432971,"ip_address":"","comment_id":71662,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846375721","product_id":100023901,"comment_content":"老师您好，根据您前面提到的，多核cpu可能导致缓存的可见性问题会导致多线程安全问题，这里我有几点不太明白，单核是没有可见性问题了吗？第二，单核cpu是线程安全的吗？如果不是，那是违背了你这里提出的哪几个因素？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441263,"discussion_content":"单核没有可见性问题，单核cpu有线程安全问题，会有原子性问题，有序性问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551432971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71641,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1551405994,"is_pvip":false,"replies":[{"id":"25928","content":"正确，就是性能不好，有点过度<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551432777,"ip_address":"","comment_id":71641,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846373290","product_id":100023901,"comment_content":"想请老师或者评论区的朋友们 对下面这个方法做出优缺点评价。<br><br>class Singleton3 {<br>\t<br>\tprivate static Singleton3 instance;<br><br>\t&#47;**<br>\t * 0. 对 getInstance()方法添加 synchronized 关键字 后有两个问题：<br>\t * <br>\t * 1. 此时，缓存导致的可见性问题、线程切换带来的原子性、编译优化带来的有序性问题  都不存在了吧？<br>\t * <br>\t * 2. 但是，这个getInstance()方法上添加 synchronized 关键字，是不是太过度使用锁了？<br>\t * <br>\t * 3. 想请老师或者评论区的朋友们 对这个方法做出优缺点评价。<br>\t * <br>\t * @return instance<br>\t *&#47;<br>\tpublic static synchronized Singleton3 getInstance() {<br>\t\t<br>\t\tif (null == instance) {<br>\t\t\tinstance = new Singleton3();<br>\t\t}<br>\t\treturn instance;<br>\t}<br>\t<br>}<br><br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441249,"discussion_content":"正确，就是性能不好，有点过度\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551432777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71591,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1551398639,"is_pvip":false,"replies":[{"id":"25756","content":"是的，要加锁，要么使用原子类<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551414165,"ip_address":"","comment_id":71591,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846365935","product_id":100023901,"comment_content":"计数问题 光加volitile只能保证可见性 还不能保证原子性，所以多线程下要保证安全性，还是要对加操作加锁的吧？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441221,"discussion_content":"是的，要加锁，要么使用原子类\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551414165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71525,"user_name":"... ...","can_delete":false,"product_type":"c1","uid":1312354,"ip_address":"","ucode":"E214CAA6349A60","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/62/898449d3.jpg","comment_is_top":false,"comment_ctime":1551363133,"is_pvip":false,"replies":[{"id":"25689","content":"你可以将一个线程绑定到一颗CPU上。否则看操作系统心情。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551371761,"ip_address":"","comment_id":71525,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846330429","product_id":100023901,"comment_content":"多核系统，线程操作哪个cpu的缓存是不是完全随机的还是有一定规律性的？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441188,"discussion_content":"你可以将一个线程绑定到一颗CPU上。否则看操作系统心情。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551371761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71495,"user_name":"Junzi","can_delete":false,"product_type":"c1","uid":1004612,"ip_address":"","ucode":"4AC663769C1873","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/44/4e541a86.jpg","comment_is_top":false,"comment_ctime":1551357250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846324546","product_id":100023901,"comment_content":"总结<br>可见性：读取缓存导致，如 cpu缓存，缓存的时差性导致数据对其他线程不可见；<br>原子性：线程切换导致，如 count += 1 一条执行语句实际是由三个原子指令组成；<br>有序性：编译优化导致，如 双重检查创建单例，编译优化产生指令重排。<br><br>问题<br>long型是8个字节，需要64位进行存储。在32为机器上只能分两次读取到cpu寄存器中，执行两条指令。因此在32位机器上对long型的计算不是原子性的，如果有线程切换会导致并发问题","like_count":1},{"had_liked":false,"id":71480,"user_name":"ljp","can_delete":false,"product_type":"c1","uid":1109543,"ip_address":"","ucode":"44F4FE255F89A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/27/53c78632.jpg","comment_is_top":false,"comment_ctime":1551352630,"is_pvip":false,"replies":[{"id":"25685","content":"看CPU心情。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551371187,"ip_address":"","comment_id":71480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846319926","product_id":100023901,"comment_content":"“我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。”这段话最后一句说，cpu缓存里都有了count的值，之后计算就用cpu缓存里的值来计算，那什么时候刷回内存呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441175,"discussion_content":"看CPU心情。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551371187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71384,"user_name":"奔跑的小孩","can_delete":false,"product_type":"c1","uid":1304259,"ip_address":"","ucode":"0053193F7A9870","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/21uTMWr7bx5qMibp2hwmGvLbYuj5Aic2dqD3futlNo25eDGDt4t7zzN9cdnj7cVGwTot1U4AyADfWUpqjq1SicgWQ/132","comment_is_top":false,"comment_ctime":1551331833,"is_pvip":false,"replies":[{"id":"25673","content":"可能你的机器太好了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551369678,"ip_address":"","comment_id":71384,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846299129","product_id":100023901,"comment_content":"循环接近还是接近2亿啊，不过确实有误差，我跑的值199991022","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441132,"discussion_content":"可能你的机器太好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551369678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71319,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1551319660,"is_pvip":false,"replies":[{"id":"25668","content":"会的，但是为了大家理解，没有深入。JVM执行引擎也有优化。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551369319,"ip_address":"","comment_id":71319,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846286956","product_id":100023901,"comment_content":"在 32 位的机器上对 long 型变量进行加减操作是否存在并发问题？<br>简单说64位的long在32位上操作是有问题的，但据称某些cpu指令集的实现是可以解决这个问题的？<br>另外指令重排，除了发生在编译期，是否由于cpu流水线机制的指令buffer，也可能出现在运行时的乱序执行情况呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441108,"discussion_content":"会的，但是为了大家理解，没有深入。JVM执行引擎也有优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551369319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71286,"user_name":"antz","can_delete":false,"product_type":"c1","uid":1005589,"ip_address":"","ucode":"BDFDED6D7F0BD2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/15/56f4e62a.jpg","comment_is_top":false,"comment_ctime":1551316130,"is_pvip":false,"replies":[{"id":"25659","content":"没有问题，原子性在不同的语境里是不同的。在这里，原子性属于微观世界，像原子一样，不可分割。宏观的多条语句也会有原子性的问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368706,"ip_address":"","comment_id":71286,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846283426","product_id":100023901,"comment_content":"【我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性】，我的理解这里的原子性可能是cpu在时间片内的原子性操作，而不能是synchronized里的原子性操作，这个理解有问题吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441090,"discussion_content":"没有问题，原子性在不同的语境里是不同的。在这里，原子性属于微观世界，像原子一样，不可分割。宏观的多条语句也会有原子性的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71276,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1551315469,"is_pvip":false,"replies":[{"id":"25657","content":"正解","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368508,"ip_address":"","comment_id":71276,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846282765","product_id":100023901,"comment_content":"long类型是8字节，64位，cpu执行时，由于是32位CPU，long类型CPU指令至少两次执行，就会有原子性问题","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441085,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71273,"user_name":"书策稠浊","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1551315235,"is_pvip":false,"replies":[{"id":"25656","content":"因为是真的并发。如果循环10次，可能都没有并发。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368496,"ip_address":"","comment_id":71273,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846282531","product_id":100023901,"comment_content":"循环一亿次为什么是接近一亿？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441083,"discussion_content":"因为是真的并发。如果循环10次，可能都没有并发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71263,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1125189,"ip_address":"","ucode":"0617032294DC43","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg","comment_is_top":false,"comment_ctime":1551314707,"is_pvip":false,"replies":[{"id":"25652","content":"这个真难倒我了，CPU有专门的指令，这方面我还没研究过","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368228,"ip_address":"","comment_id":71263,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846282003","product_id":100023901,"comment_content":"老师，缓冲导致原子性问题，也可以理解，不同的cpu缓冲无法得到及时更新，同步，那，不同cpu是什么时候将自己的缓冲同步到内存，其他cpu是什么时候更新缓冲的呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441076,"discussion_content":"这个真难倒我了，CPU有专门的指令，这方面我还没研究过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71261,"user_name":"多拉格·five","can_delete":false,"product_type":"c1","uid":1207914,"ip_address":"","ucode":"07023F43811EE3","user_header":"https://static001.geekbang.org/account/avatar/00/12/6e/6a/38a3fa8d.jpg","comment_is_top":false,"comment_ctime":1551314595,"is_pvip":false,"replies":[{"id":"25651","content":"正解","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368069,"ip_address":"","comment_id":71261,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846281891","product_id":100023901,"comment_content":"在32位系统对32位变量读写是原子操作,但是long是64,所以是非原子操作,简单的说，在32位操作系统上，对64位的数据的读写是分两步的，一步取前32位数据，一步取后32位数据，通过这两步操作来实现对64位数据的读写.","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441074,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359619,"user_name":"小满同学","can_delete":false,"product_type":"c1","uid":2318377,"ip_address":"北京","ucode":"32832D6559246F","user_header":"https://static001.geekbang.org/account/avatar/00/23/60/29/08f23e70.jpg","comment_is_top":false,"comment_ctime":1665710950,"is_pvip":false,"replies":[{"id":"130860","content":"之前写过一篇文章，你可以参考一下https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;lZGzGYVRrryFfVtf45ZrwQ","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1665837122,"ip_address":"北京","comment_id":359619,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1665710950","product_id":100023901,"comment_content":"测试代码，用virtual box虚拟机模拟单核机器，openJDK 11，win7 64bit环境。想看看在单核心的情况下，多个线程间的共享变量是否具有可见性<br>public class TestVolatile {<br><br>\tstatic boolean shutdownlater;<br>\tpublic static void main(String[] args) {<br>\t\tThread thread = new Thread(()-&gt; {<br>\t\t\tSystem.out.println(&quot;will change flag&quot;);<br>\t\t\ttry {<br>\t\t\t\tThread.sleep(1000);<br>\t\t\t} catch (InterruptedException e) {<br>\t\t\t\te.printStackTrace();<br>\t\t\t}<br>\t\t\tshutdownlater = true;<br>\t\t\tSystem.out.println(&quot;flag already changed&quot;);<br>\t\t});<br>\t\tthread.start();<br>\t\tfor (int i = 0; i &lt; 2; i++) {<br>\t\t\tnew Thread(()-&gt;{<br>\t\t\t\twhile (true) {<br>                                        &#47;&#47;sleep here<br>\t\t\t\t\tif (shutdownlater) {<br>\t\t\t\t\t\tbreak;<br>\t\t\t\t\t}<br>\t\t\t\t}<br>\t\t\t}).start();<br>\t\t}<br>\t}<br>}<br>但是最后程序是没有退出的，另外如果在注释的地方sleep一会儿，竟然能读到最新的共享变量了，这个我有点困惑，是sleep过后，直接去内存拿数据了吗？望老师解答。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590524,"discussion_content":"之前写过一篇文章，你可以参考一下https://mp.weixin.qq.com/s/lZGzGYVRrryFfVtf45ZrwQ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665837122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2318377,"avatar":"https://static001.geekbang.org/account/avatar/00/23/60/29/08f23e70.jpg","nickname":"小满同学","note":"","ucode":"32832D6559246F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":590533,"discussion_content":"所以这块儿是由于编译器优化导致另一个线程只在循环第一次读取了flag是吗🤔。如果我加上sleep语句，另一个线程是可以读到flag新的值的，是sleep过后，会重新读最新的变量值吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665840667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":590524,"ip_address":"江苏"},"score":590533,"extra":""}]}]},{"had_liked":false,"id":359233,"user_name":"大明猩","can_delete":false,"product_type":"c1","uid":1494622,"ip_address":"北京","ucode":"61D330B42AE3C4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/5e/b103d538.jpg","comment_is_top":false,"comment_ctime":1665366527,"is_pvip":true,"replies":[{"id":"130861","content":"放眼望去，Java代码没有哪行是原子性的","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1665837340,"ip_address":"北京","comment_id":359233,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1665366527","product_id":100023901,"comment_content":"怎么判断一行代码的原子性呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590525,"discussion_content":"放眼望去，Java代码没有哪行是原子性的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665837340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357582,"user_name":"摊牌","can_delete":false,"product_type":"c1","uid":1453182,"ip_address":"北京","ucode":"F142596BFE4594","user_header":"https://static001.geekbang.org/account/avatar/00/16/2c/7e/f1efd18b.jpg","comment_is_top":false,"comment_ctime":1663419909,"is_pvip":true,"replies":[{"id":"130235","content":"线程是操作系统负责调度，最常见的情况是分配给线程的时间片用完了，操作系统强制收回该线程的CPU使用权，这个时候就会发生线程切换","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1663649577,"ip_address":"北京","comment_id":357582,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1663419909","product_id":100023901,"comment_content":"引用原文：<br>“我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。”<br><br>上述原文中，当执行完指令 2 时恰好发生了线程切换，请问老师，在什么情况下，会在执行完指令 2发生线程切换？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588282,"discussion_content":"线程是操作系统负责调度，最常见的情况是分配给线程的时间片用完了，操作系统强制收回该线程的CPU使用权，这个时候就会发生线程切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663649577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357299,"user_name":"卡牌","can_delete":false,"product_type":"c1","uid":1175484,"ip_address":"北京","ucode":"69DD2E5796D651","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/bc/60c55114.jpg","comment_is_top":false,"comment_ctime":1663142287,"is_pvip":false,"replies":[{"id":"130073","content":"https:&#47;&#47;github.com&#47;openjdk&#47;jcstress.git 这个工具里有个示例测试程序UnsafeDCL.java 你用jcstress工具是可以测试出bug来的","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1663218986,"ip_address":"北京","comment_id":357299,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1663142287","product_id":100023901,"comment_content":"想问一句：有没有 DCL 模式在不使用 volatile 的情况下报错的代码？我哪怕是用了 https:&#47;&#47;www.cs.umd.edu&#47;~pugh&#47;java&#47;memoryModel&#47;DoubleCheckedLocking.html 里提供的测试代码也没测出报错情况，线程数与单例数各种大小关系都试过了，都没有报异常，我提供的参数就差把heap塞爆。我谷歌了一圈也没找到可以报错的代码，你们这里也没看到，有谁能提供一个呗？还是说这玩意已经被修复了，哪怕不需要volatile也没问题？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587682,"discussion_content":"https://github.com/openjdk/jcstress.git 这个工具里有个示例测试程序UnsafeDCL.java 你用jcstress工具是可以测试出bug来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663218986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351748,"user_name":"Geek_561155","can_delete":false,"product_type":"c1","uid":2392271,"ip_address":"","ucode":"D7758DFD8AE321","user_header":"https://static001.geekbang.org/account/avatar/00/24/80/cf/346c395f.jpg","comment_is_top":false,"comment_ctime":1658148001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658148001","product_id":100023901,"comment_content":"我想问一下，`当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存`，线程对变量的操作不是应该在工作内存中进行的吗？这里如何把 JMM 工作内存和 CPU 缓存对应关联起来？","like_count":0},{"had_liked":false,"id":350209,"user_name":"技术人生","can_delete":false,"product_type":"c1","uid":1033977,"ip_address":"","ucode":"6610644BC0A660","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJZBOcesNKYJRJKR6noK2VClOS8iaeEsibpXSLlFT87mARozsicHSAo8VibSEOZSRVw2XWK4UyqjQDYJQ/132","comment_is_top":false,"comment_ctime":1656661695,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656661695","product_id":100023901,"comment_content":"最后一个例子是个bug 不能说明有序性问题，因为synchronized(Singleton.class)  这一句锁的是 Singleton class对象 只会有有一个线程执行，另一个只有对象构造完成，才会释放。monitor exit命令会主动触发CPU缓存的刷新，同时另一个线程拿到锁对象的时候也会主动失效本地CPU的缓存，所以最终数据一定是正确。<br>要想证明这个例子 只有把synchronized去掉才成立","like_count":0},{"had_liked":false,"id":347248,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1653873597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653873597","product_id":100023901,"comment_content":"请教一下：在CPU读取内存变量到cpu缓存中，计算count++操作，是完成10000次循环计算后，才将结果写回内存？还是中间会写入？","like_count":0},{"had_liked":false,"id":347236,"user_name":"月明风清","can_delete":false,"product_type":"c1","uid":2226367,"ip_address":"","ucode":"65A97CF2E320FA","user_header":"https://static001.geekbang.org/account/avatar/00/21/f8/bf/59f2e600.jpg","comment_is_top":false,"comment_ctime":1653835678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653835678","product_id":100023901,"comment_content":"我想问一下老师讲的 new 操作：<br>分配一块内存 M；<br>在内存 M 上初始化 Singleton 对象；<br>然后 M 的地址赋值给 instance 变量。<br><br>这里的分配一块内存在操作系统层面是什么意思呢？页表上建立一个页表项？<br>在内存 M 上初始化对象在操作系统层面是什么意思呢？修改物理内存地址上的值？<br>不知道我想的对不对<br>","like_count":0},{"had_liked":false,"id":345718,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652524194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652524194","product_id":100023901,"comment_content":"需要在总线上加锁才能解决，volatile不能解决原子操作。只是解决可见性，禁止重排序。","like_count":0},{"had_liked":false,"id":345507,"user_name":"_patrick","can_delete":false,"product_type":"c1","uid":2220763,"ip_address":"","ucode":"B24C6EEBCABB94","user_header":"https://static001.geekbang.org/account/avatar/00/21/e2/db/97c6f756.jpg","comment_is_top":false,"comment_ctime":1652341419,"is_pvip":true,"replies":[{"id":"126350","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1652968561,"ip_address":"","comment_id":345507,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652341419","product_id":100023901,"comment_content":"volatile禁止指令重排序，大家不要被字面意思迷惑了。   如果探究过内存屏障 就知道，不是不进行重排序，而是某一个 指令 相对另一个指定的顺序 不可改变。其他指令之间该怎么重排还是怎么重拍。  这个屏障此时就很形象了 屏障前后的指令 不可越过屏障。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572810,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652968561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344843,"user_name":"FARO_Z","can_delete":false,"product_type":"c1","uid":2410092,"ip_address":"","ucode":"B33BCC36C2A74E","user_header":"https://static001.geekbang.org/account/avatar/00/24/c6/6c/a400175a.jpg","comment_is_top":false,"comment_ctime":1651821747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651821747","product_id":100023901,"comment_content":"为什么可见性问题中举的那个例子，结果不会是 10000 以下的随机数呢？不是有个很有名的面试题吗：<br><br>线程A，线程B同时对 count=0 进行100次自增操作<br>线程A、B先将 count=0 读入本地内存<br><br>线程A在本地内存中将 count 加到 99 -&gt; 将99写入主存 ，此时主存 count 是99-&gt; 切换到线程B<br><br>线程B先将本地内存的0写入主存，此时主存由 99 变为了 0 -&gt; 线程 B 在本地内存中，将 count 加到 99 -&gt; 切换到线程 A<br><br>线程A先将主存的 0 读入本地内存 ，本地内存由99变为0 -&gt; 线程A最后一次自增操作，将本地内存0加为1 -&gt; 线程A 将1写回主存，主存由0变为1 -&gt; 切换到线程B <br><br>线程B 先将主存的 1 写入本地内存，本地内存由 99 变为1 -&gt; 线程B最后一次自增操作，将本地内存 1 加为 2 -&gt; 线程 B 将 2 写回主存<br><br>-&gt; 两个线程执行结束，最后主存中 count 的值为2，小于100，更小于200<br><br>所以为什么现实中不会出现这样的情况呢？是和 java 的主存刷新策略有关吗？求解<br>","like_count":0},{"had_liked":false,"id":343386,"user_name":"红豆成香","can_delete":false,"product_type":"c1","uid":1488601,"ip_address":"","ucode":"FB8FBB639B4BA6","user_header":"https://static001.geekbang.org/account/avatar/00/16/b6/d9/4d8a4d4c.jpg","comment_is_top":false,"comment_ctime":1650811323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650811323","product_id":100023901,"comment_content":"看了三回，两年了，才能看懂java并发实战","like_count":0},{"had_liked":false,"id":343025,"user_name":"李青","can_delete":false,"product_type":"c1","uid":1074564,"ip_address":"","ucode":"30E2CB7F3EFC14","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/84/5515dde0.jpg","comment_is_top":false,"comment_ctime":1650599254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650599254","product_id":100023901,"comment_content":"我都不知道这是读第几遍了，才有种醍醐灌顶的感觉。谢谢老师了。","like_count":0},{"had_liked":false,"id":341080,"user_name":"Geek_837deb","can_delete":false,"product_type":"c1","uid":2963287,"ip_address":"","ucode":"7F3462B4BE1DC5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dv9TS6icbzBEz8D6vXLrkSmER4TLRt6z2FKjo8b4XjibKydf7NWcwX4Fzf5XquGs88P25ApMBTWlcmGxibKzHuwtg/132","comment_is_top":false,"comment_ctime":1649333554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649333554","product_id":100023901,"comment_content":"双检锁创建单列，案例中存在问题，由于指令重排序导致，使用volatile 声明的变量 new M对象，解决此指令排序问题。","like_count":0},{"had_liked":false,"id":340277,"user_name":"龙行天下","can_delete":false,"product_type":"c1","uid":1231302,"ip_address":"","ucode":"90BEED7A164ADE","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/c6/16136ab3.jpg","comment_is_top":false,"comment_ctime":1648715135,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648715135","product_id":100023901,"comment_content":"关于文章中dcl问题，我有个问题，synchronized内的代码块有没有在硬件&#47;操作系统层面保证原子性(多个操作一起完成才允许线程切换到互斥线程)，如果有的话的，我觉得单核下dcl是不会出问题，多核下才有可能出问题，而且也不是分时切换导致的，而是并行导致的","like_count":0},{"had_liked":false,"id":340034,"user_name":"云晴","can_delete":false,"product_type":"c1","uid":1398845,"ip_address":"","ucode":"43A7E9071E50E0","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/3d/ad2bfebf.jpg","comment_is_top":false,"comment_ctime":1648548889,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648548889","product_id":100023901,"comment_content":"long是64位，在32位机器上会分为高32位和低32位两次写入，多线程情况下只能保证在每个CPU上执行的线程是连续的，并不能保证同一时刻只有一个线程执行，如果线程A和线程B同时写long型变量的高32位的话，就会出现并发隐患，导致写入内存的数据发生变化，重新读取不是之前写入的数据。","like_count":0},{"had_liked":false,"id":337786,"user_name":"Geek_2c8a24","can_delete":false,"product_type":"c1","uid":2334040,"ip_address":"","ucode":"5DDD7AEF3668A8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/4O0oeYUkS2GuRrhEQCYY62YISgSbLrWMNG3FjagMQm9icGlLTH2AIIibWia3ZYxGvI8mp8LXagv4DkNRjAgh4hCyg/132","comment_is_top":false,"comment_ctime":1647063236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647063236","product_id":100023901,"comment_content":"volatile变量规则：对一个volatile变量的写操作happen—before后面对该变量的读操作。","like_count":0},{"had_liked":false,"id":335398,"user_name":"Calm","can_delete":false,"product_type":"c1","uid":1138583,"ip_address":"","ucode":"15995FDE13FBCF","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/97/00bb7e14.jpg","comment_is_top":false,"comment_ctime":1645504381,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645504381","product_id":100023901,"comment_content":"long类型64位，所以在32位的机器上，对long类型的数据操作通常需要多条指令组合出来，如果发生线程切换，无法保证原子性，从而导致并发出现问题。","like_count":0},{"had_liked":false,"id":334161,"user_name":"一个工匠","can_delete":false,"product_type":"c1","uid":1038449,"ip_address":"","ucode":"2168BA6F926074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/71/d6f79534.jpg","comment_is_top":false,"comment_ctime":1644777237,"is_pvip":true,"replies":[{"id":"122134","content":"能保证，就是性能差","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1644899662,"ip_address":"","comment_id":334161,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1644777237","product_id":100023901,"comment_content":"源头一，MESI 不是可以解决缓存的一致性问题吗？为什么还会出现可见性？<br>如果MESI不能完全解决，是不是说MESI就没有存在的必要了？毕竟MESI已经不能保障缓存一致性了。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551105,"discussion_content":"能保证，就是性能差","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644899662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1038449,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/71/d6f79534.jpg","nickname":"一个工匠","note":"","ucode":"2168BA6F926074","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":551106,"discussion_content":"作者你好。我还要一些疑问，希望能解惑。\n1. mesi 是不是非硬件实现的必要条件？即有些硬件不会实现mesi协议？\n2. mesi 的store buffer 等优化按理说不能保障一致性了，为什么还会被提出来？毕竟开发人员不是每位同学都意识到需要加内存屏障，即很多软件都会出现问题。而且加上内存屏障后，即开发人员放弃了mesi的优化，那不还是等于没优化么？\n网上资源好杂，没啥系统性的说明，希望作者解惑🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644900176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":551105,"ip_address":""},"score":551106,"extra":""}]}]},{"had_liked":false,"id":333968,"user_name":"水目沾","can_delete":false,"product_type":"c1","uid":1274495,"ip_address":"","ucode":"FDD1D15C277D58","user_header":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","comment_is_top":false,"comment_ctime":1644644665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644644665","product_id":100023901,"comment_content":"问题来了：既然如此什么会出现三大性问题，文中解释的真的很好了。可见性：平衡CPU、内存和IO设备之间的速度，Jmm 必须要这么设计，当然其他语言肯定也存在这个问题。有序性：高级语言层面的语句在 CPU 层面并不是原子的，所以问题出现了。有序性：编译器和CPU 的优化。","like_count":0},{"had_liked":false,"id":333965,"user_name":"水目沾","can_delete":false,"product_type":"c1","uid":1274495,"ip_address":"","ucode":"FDD1D15C277D58","user_header":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","comment_is_top":false,"comment_ctime":1644644318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644644318","product_id":100023901,"comment_content":"第一次看的时候是三年前，理解错了以为可见性、有序性和原子性是并发编程的源头。现在再看，这个标题取的多美妙啊。如果没有这三大性，并发编程也会存在很多问题，也会有它的复杂度。就是因为这三大性的人存在，导致现在并发编程更容易写出 Bug，更加增加了并发编程的复杂度而已。","like_count":0},{"had_liked":false,"id":333929,"user_name":"Jit Gwan","can_delete":false,"product_type":"c1","uid":1389981,"ip_address":"","ucode":"CE2C8FC46D9D71","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/9d/4f23ec3d.jpg","comment_is_top":false,"comment_ctime":1644591103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644591103","product_id":100023901,"comment_content":"发现以前对「双重检测单例模式」的理解有偏差，重新梳理了一下：<br><br>1、考虑极端情况，一直不停地有多个线程「冲」到第一重检测面前，并且因为一开始 instance == null，所以所有线程都能通过这层检测<br><br>2、接着，通过了第一重检测的线程争夺类级别的锁，只有一个能胜出，进入 new 阶段<br><br>3、抢到锁的线程 new 完以后释放锁，此时第一重检测发挥效用，后续的冲向第一重检测的线程全都防出去了<br><br>4、但同时，原本通过了第一重检测但因未抢到锁被阻塞的其他线程之一拿到了锁，如果不加第二重检测，则它也可以 new，导致重复 new，所以要加第二重检测<br><br>5、由于 happens-before 规范之一，并不存在前一个线程 new 完，而 instance != null 的结果不对其他的线程立即可见的问题<br><br>6、抢到锁的其他线程不释放锁，别的线程不能访问临界区，但是从操作系统的层面来看，分给该线程的时间片耗尽了，会发出中断信号，让其他线程上，这些线程不能访问临界区，但能执行 synchronized 之前的代码<br><br>7、那么，如果恰好是内存块 M 的地址赋给引用变量了，但对象还没创建完（比较耗时）这个档口，时间片耗尽了，那么新抢占上 CPU 的线程就会发现 instance != null，直接快乐返回，但此时该线程返回的 instance 指向的 M 还是空的<br><br>8、volatile 通过插入内存屏障的方式保证可见性、禁止指令重排序（更高效的理解方式是直接看 volatile 的那条 happens-before 原则），因此用 volatile 修饰该变量可以解决上述问题<br><br>9、之所以要搞这个双重检测的原因是「先加锁，再判空」这个模式将所有 getInstance 操作串化了，但实际需要加锁的只有创建实例阶段，因此调换一下顺序「先判空，再加锁」，结果这个调换引入了新的问题，所以需要第二次检测<br><br>10、访问 volatile 变量的速度会比访问普通变量慢很多，所以双重检测的实际实现中会将 instance 赋给一个 local 变量<br><br>11、高版本的 JDK 支持设置参数将 new 定义为原子的，感觉不如按需加 volatile 来得灵活","like_count":0},{"had_liked":false,"id":333347,"user_name":"文公","can_delete":false,"product_type":"c1","uid":1059905,"ip_address":"","ucode":"32045D40E962F0","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/41/48cfdf89.jpg","comment_is_top":false,"comment_ctime":1644305399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644305399","product_id":100023901,"comment_content":"并发编程，从可见性，原子性，有序性方面分析。","like_count":0},{"had_liked":false,"id":329002,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1649057,"ip_address":"","ucode":"4F42DAA5DB5C38","user_header":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","comment_is_top":false,"comment_ctime":1641009766,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1641009766","product_id":100023901,"comment_content":"这上面的双重检测有个疑问，被优化后的程序在执行时是怎么保证instance 的可见性问题，线程A 不是还没释放锁吗？难道正如“0+1” 同学说的  sync代码块也具备可见性语义吗？管程中锁的规则不是说“对一个锁的解锁 Happens-Before 于后续对这个锁的加锁” ，所以这个地方怎么解啊？","like_count":0},{"had_liked":false,"id":326548,"user_name":"吃饭","can_delete":false,"product_type":"c1","uid":1692756,"ip_address":"","ucode":"AF0D7165D5F049","user_header":"https://static001.geekbang.org/account/avatar/00/19/d4/54/7263deb2.jpg","comment_is_top":false,"comment_ctime":1639558208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639558208","product_id":100023901,"comment_content":"可见性问题的实例，有个疑惑，这个demo不是纯粹的因为可见性导致，也会因为原子性问题出现最终结果不是2w，如果将原子性问题刨去只能使用unsafe自己实现一套，但是unsafe的语义包含violate的刷缓存功能，咋办？有没有方案单独证明可见性问题？<br><br>如果可以单独证明，我就能从结果反推两种结果所带来的的后果的严重程度，这是我的思考出发点","like_count":0},{"had_liked":false,"id":323121,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1637736093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637736093","product_id":100023901,"comment_content":"对于评论区的讨论说一下自己的看法。<br>1.首先线程A 初始化对象会分为三句话：<br>a.allocate(memory)<br>b.init(instance)<br>c. return instance<br><br>因为a对于b，c来说是先后依赖关系，所以b c会发生重排序，那么对于线程A来说会不会有问题 ？其实也会有NPE风险。因为b c重排了，所以外部使用未初始化完的对象自然就有风险<br><br>2.对于线程B来说 当他第一次判断非空条件时是能看到变量的。为什么呢？因为此时线程A解锁了 但上述的b操作还没执行完，故根据JSR-133 unlock语义会flush 变量 ，此时线程B就因为是第一次加载要做一次load - read ，故能看到instance变量<br><br>最后说下解决方法：加volatile","like_count":0},{"had_liked":false,"id":322299,"user_name":"最摇摆的鱼","can_delete":false,"product_type":"c1","uid":1255574,"ip_address":"","ucode":"DA19F4C4224719","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqgVXa8DyW0YsrdYtPNMOdGH6hfdwfjwyBPRyoc9yuS4Ml18l0kApOoOKwYkF6NlDPYpX1bVEWomw/132","comment_is_top":false,"comment_ctime":1637293290,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637293290","product_id":100023901,"comment_content":"CPU 的cache-coherence protocol不是应该已经解决了缓存不一致的问题吗？我自己的理解volatile在第一点的运用更多是指禁用了register. 希望老师可以确认一下。","like_count":0},{"had_liked":false,"id":321453,"user_name":"xty","can_delete":false,"product_type":"c1","uid":1958492,"ip_address":"","ucode":"CC2625DC79431B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/MxzHxqmS2L7ZJy160Immet3b5QhZbHSlx0bDeKzvKSCJvSt1DZMDIz4g2Pt2LpbOIicXsOInSJI5PDOWt1JCofg/132","comment_is_top":false,"comment_ctime":1636882803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636882803","product_id":100023901,"comment_content":"第一个count代码是不是有问题，calc是静态方法，变量count是非静态的。","like_count":0},{"had_liked":false,"id":318736,"user_name":"Geek_7a9e2c","can_delete":false,"product_type":"c1","uid":1265132,"ip_address":"","ucode":"00DC77B9C85EE3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er78PmxPDq4a3vNuvvX10fiaBC4FZ7XXuOX1nMjhCIqiaHWfpjfd5CDoVVB0GRGveChNmkSmuy7smxQ/132","comment_is_top":false,"comment_ctime":1635408125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635408125","product_id":100023901,"comment_content":"代码有问题，静态方法可以有非静态属性？","like_count":0},{"had_liked":false,"id":317314,"user_name":"蓝色~冰*羽","can_delete":false,"product_type":"c1","uid":1205873,"ip_address":"","ucode":"E2F6424766AD7C","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/71/8a5d02ab.jpg","comment_is_top":false,"comment_ctime":1634738733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634738733","product_id":100023901,"comment_content":"老师，上面提到线程1中执行将M的地址赋给了instance变量，但是没初始化；此时线程2进入第一个if，就会判断instance不为空，直接返回。我感觉不对呀，请问判断计算机null在底层是什么样呀？难道只要赋予了地址，不管这个地址里有没有东西，计算机判断都是非空？","like_count":0},{"had_liked":false,"id":307669,"user_name":"贺笃兴","can_delete":false,"product_type":"c1","uid":1436697,"ip_address":"","ucode":"A7151E419138BD","user_header":"https://static001.geekbang.org/account/avatar/00/15/ec/19/2fd42002.jpg","comment_is_top":false,"comment_ctime":1629194247,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629194247","product_id":100023901,"comment_content":"这个例子会报错吧？<br>public class Test {<br>  private long count = 0;<br>  private void add10K() {<br>    int idx = 0;<br>    while(idx++ &lt; 10000) {<br>      count += 1;<br>    }<br>  }<br>  public static long calc() {<br>    final Test test = new Test();<br>    &#47;&#47; 创建两个线程，执行add()操作<br>    Thread th1 = new Thread(()-&gt;{<br>      test.add10K();<br>    });<br>    Thread th2 = new Thread(()-&gt;{<br>      test.add10K();<br>    });<br>    &#47;&#47; 启动两个线程<br>    th1.start();<br>    th2.start();<br>    &#47;&#47; 等待两个线程执行结束<br>    th1.join();<br>    th2.join();<br>    return count;<br>  }<br>}","like_count":0},{"had_liked":false,"id":307374,"user_name":"风一样的男子","can_delete":false,"product_type":"c1","uid":1357985,"ip_address":"","ucode":"F02E87D5630DAB","user_header":"","comment_is_top":false,"comment_ctime":1629060113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629060113","product_id":100023901,"comment_content":"理论上是这样，但没有重现：<br>public class C02_Singleton {<br>\tstatic C02_Singleton instance;<br>\tstatic C02_Singleton getInstance() {<br>\t\tif (instance==null)<br>\t\t\tinstance = new C02_Singleton();<br>\t\t<br>\t\treturn instance;<br>\t}<br><br>\tpublic static void main(String[] args) throws InterruptedException {<br>\t\tfor (int i=0;i&lt;1000;i++) {<br>\t\t\tinstance = null;<br>\t\t\tThread th1 = new Thread(()-&gt;{<br>\t\t\t\tSystem.out.println(&quot;th1:&quot;  + getInstance());<br>\t\t\t});<br>\t\t\tThread th2 = new Thread(()-&gt;{<br>\t\t\t\tSystem.out.println(&quot;th2:&quot;  + getInstance());<br>\t\t\t});<br>\t\t\tThread th3 = new Thread(()-&gt;{<br>\t\t\t\tSystem.out.println(&quot;th3:&quot;  + getInstance());<br>\t\t\t});<br>\t\t\tThread th4 = new Thread(()-&gt;{<br>\t\t\t\tSystem.out.println(&quot;th4:&quot;  + getInstance());<br>\t\t\t});<br>\t\t\tThread th5 = new Thread(()-&gt;{<br>\t\t\t\tSystem.out.println(&quot;th5:&quot;  + getInstance());<br>\t\t\t});<br>\t\t\tThread th6 = new Thread(()-&gt;{<br>\t\t\t\tSystem.out.println(&quot;th6:&quot;  + getInstance());<br>\t\t\t});<br>\t\t\tThread th7 = new Thread(()-&gt;{<br>\t\t\t\tSystem.out.println(&quot;th7:&quot;  + getInstance());<br>\t\t\t});<br>\t\t\tThread th8 = new Thread(()-&gt;{<br>\t\t\t\tSystem.out.println(&quot;th8:&quot;  + getInstance());<br>\t\t\t});<br>\t\t\tth1.start();<br>\t\t\tth2.start();<br>\t\t\tth3.start();<br>\t\t\tth4.start();<br>\t\t\tth5.start();<br>\t\t\tth6.start();<br>\t\t\tth7.start();<br>\t\t\tth8.start();<br>\t\t\tth1.join();<br>\t\t\tth2.join();<br>\t\t\tth3.join();<br>\t\t\tth4.join();<br>\t\t\tth5.join();<br>\t\t\tth6.join();<br>\t\t\tth7.join();<br>\t\t\tth8.join();<br>\t\t}<br>\t}<br><br>}","like_count":0},{"had_liked":false,"id":307257,"user_name":"FARO_Z","can_delete":false,"product_type":"c1","uid":2410092,"ip_address":"","ucode":"B33BCC36C2A74E","user_header":"https://static001.geekbang.org/account/avatar/00/24/c6/6c/a400175a.jpg","comment_is_top":false,"comment_ctime":1628991963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628991963","product_id":100023901,"comment_content":"啊啊啊，才看的并发编程应该考虑到的问题，阿里面试官问的时候自己就忘记了","like_count":0},{"had_liked":false,"id":306354,"user_name":"木子李","can_delete":false,"product_type":"c1","uid":1694965,"ip_address":"","ucode":"815BAC4C950949","user_header":"https://static001.geekbang.org/account/avatar/00/19/dc/f5/806bd1ff.jpg","comment_is_top":false,"comment_ctime":1628508434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628508434","product_id":100023901,"comment_content":"线程A、B如果都过了第一个if判断，是不是就不会出现空指针的问题了，因为synchronized加锁了，也保证了可见性，只有线程A创建完并且初始化了，才会释放锁，线程B才能继续往下执行吗？","like_count":0},{"had_liked":false,"id":306185,"user_name":"Geek_yulu","can_delete":false,"product_type":"c1","uid":2051913,"ip_address":"","ucode":"E21A78F62F2712","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7uNqGmKnYpJRYJ8ogibsETPGluaVR1sPyIpslDbxKRKdMQ8cfmMm4b4RCZbRIiczZiadIZHhBfCBXTRldS4Nibc9fR/132","comment_is_top":false,"comment_ctime":1628424080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628424080","product_id":100023901,"comment_content":"double locking这个场景描述的指令重排绪在目前主流的JAVA编译器和虚拟机里执行都不会出现描述的情况","like_count":0},{"had_liked":false,"id":304636,"user_name":"六维","can_delete":false,"product_type":"c1","uid":1022887,"ip_address":"","ucode":"EB1C15AC06A8DF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/a7/440aff07.jpg","comment_is_top":false,"comment_ctime":1627527734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627527734","product_id":100023901,"comment_content":"在 32 位的机器上对 long 型变量进行加减操作不是原子的，所有存在并发的隐患。","like_count":0},{"had_liked":false,"id":304376,"user_name":"泰坦","can_delete":false,"product_type":"c1","uid":1805097,"ip_address":"","ucode":"AF8ABF2539E6D6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8b/29/c48f1a46.jpg","comment_is_top":false,"comment_ctime":1627376067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627376067","product_id":100023901,"comment_content":"老师，Java编程思想第四版，21章，21.3.5书上例子用lock锁不住，用synchronized就能锁住，这咋回事啊？代码见https:&#47;&#47;github.com&#47;tigerChen19&#47;java-train-notes&#47;blob&#47;main&#47;Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3lock%E9%94%81%E4%B8%8D%E4%BD%8F","like_count":0},{"had_liked":false,"id":300640,"user_name":"flykyle","can_delete":false,"product_type":"c1","uid":1031918,"ip_address":"","ucode":"F2DE3830F2482F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/ee/9c0b20cc.jpg","comment_is_top":false,"comment_ctime":1625282787,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625282787","product_id":100023901,"comment_content":"long 和 double 的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况。——《深入理解 Java 虚拟机》","like_count":0},{"had_liked":false,"id":297002,"user_name":"201201718","can_delete":false,"product_type":"c1","uid":2372133,"ip_address":"","ucode":"CDCAE51039E3E1","user_header":"","comment_is_top":false,"comment_ctime":1623254931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623254931","product_id":100023901,"comment_content":"优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。<br>这里为啥线程B没有获取锁也能运行被锁起来的代码呢？","like_count":0},{"had_liked":false,"id":296240,"user_name":"盛世半月","can_delete":false,"product_type":"c1","uid":1521691,"ip_address":"","ucode":"D4B9ED91189BB4","user_header":"https://static001.geekbang.org/account/avatar/00/17/38/1b/5c1fefd9.jpg","comment_is_top":false,"comment_ctime":1622856031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622856031","product_id":100023901,"comment_content":"很明显会出现问题，long类型是64位，在32位系统上被拆分成两条指令，多条指令会出现原子性的问题","like_count":0},{"had_liked":false,"id":296055,"user_name":"高书桓","can_delete":false,"product_type":"c1","uid":2649214,"ip_address":"","ucode":"B32CD7331B47FE","user_header":"https://static001.geekbang.org/account/avatar/00/28/6c/7e/74da9fe3.jpg","comment_is_top":false,"comment_ctime":1622720314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622720314","product_id":100023901,"comment_content":"你那代码有问题吧，静态方法里面怎么能使用非静态的变量呢，join方法会抛异常吧。你怎么也没有处理呢","like_count":0},{"had_liked":false,"id":295736,"user_name":"nodenota","can_delete":false,"product_type":"c1","uid":1292438,"ip_address":"","ucode":"6D5C9485CEB327","user_header":"https://static001.geekbang.org/account/avatar/00/13/b8/96/82a849e3.jpg","comment_is_top":false,"comment_ctime":1622565649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622565649","product_id":100023901,"comment_content":"&quot;假设我们在一个只有一个CPU核的机器上，进程P1调用了switch函数将CPU控制转给了调度器线程，调度器线程发现还有一个进程P2的内核线程正在等待被运行，所以调度器线程会切换到运行进程P2。假设P2也想使用磁盘，UART或者console，它会对P1持有的锁调用acquire，这是对于同一个锁的第二个acquire调用。当然这个锁现在已经被P1持有了，所以这里的acquire并不能获取锁。假设这里是spinlock，那么进程P2会在一个循环里不停的“旋转”并等待锁被释放。但是很明显进程P2的acquire不会返回，所以即使进程P2稍后愿意出让CPU，P2也没机会这么做。之所以没机会是因为P2对于锁的acquire调用在直到锁释放之前都不会返回，而唯一锁能被释放的方式就是进程P1恢复执行并在稍后release锁，但是这一步又还没有发生，因为进程P1通过调用switch函数切换到了P2，而P2又在不停的“旋转”并等待锁被释放。这是一种死锁，它会导致系统停止运行。&quot;，锁和上下文切换是两件事，线程持有锁，但是线程不一定是Running的，有可能是Runnable的，它只是让出了CPU，但是不会让出锁，要让出锁除非它把同步块的事情做完了。","like_count":0},{"had_liked":false,"id":293474,"user_name":"eagle","can_delete":false,"product_type":"c1","uid":1352179,"ip_address":"","ucode":"6487E7458F30D8","user_header":"https://static001.geekbang.org/account/avatar/00/14/a1/f3/ebf0c864.jpg","comment_is_top":false,"comment_ctime":1621400931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621400931","product_id":100023901,"comment_content":"这里所说的CPU缓存，本地内存，工作内存是什么关系呢","like_count":0},{"had_liked":false,"id":292232,"user_name":"Geek_b6e6bc","can_delete":false,"product_type":"c1","uid":2559741,"ip_address":"","ucode":"0F09EFE0BF48BD","user_header":"","comment_is_top":false,"comment_ctime":1620731001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620731001","product_id":100023901,"comment_content":"你好 老师，读完这节很受益，对于双重锁的案例，如果线程A执行一半cpu发生切换，B线程在第一个if分之返回的问题，有几个问题疑惑<br>1. 案例讲解的是由于指令重排导致的线程B拿到了一个还没有初始化的引用，这个可以归纳为由于指令重排导致的并发问题，那么这个代码会不会由于内存可见性导致并发安全问题呢 比如线程A正常执行完释放锁，线程B拿到了锁，判断对象是否为空，假设线程B拿的对象还是刚进入方法时的工作内存的对象还是为空，会不会重复创建对象  其实提这个问题的原因是不太清楚 sync锁里面 修改操作 是怎样原理更新到后续线程里面的，因为我的理解是线程B在一开始进入方法时去主存加载对象，这个时候对象为空，之后的执行一直是拿到这个为空的对象","like_count":0},{"had_liked":false,"id":290753,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1619741127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619741127","product_id":100023901,"comment_content":"缓存带来的可见性，线程切换导致的原子性，指令重排带来的有序性问题，是并发程序bug的来源","like_count":0},{"had_liked":false,"id":290368,"user_name":"我真不是地球","can_delete":false,"product_type":"c1","uid":1451048,"ip_address":"","ucode":"873F7222DE35BE","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/28/9b5b1396.jpg","comment_is_top":false,"comment_ctime":1619516665,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619516665","product_id":100023901,"comment_content":"双重检查创建单例的异常执行路径<br>这个例子，老师，及时cpu切换，不是加锁了么，线程B也没办法访问啊","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378483,"discussion_content":"没法访问的是临界区资源，syschroized代码块之外的资源是可以访问的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623245071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289001,"user_name":"Geek_6951f1","can_delete":false,"product_type":"c1","uid":2280569,"ip_address":"","ucode":"CDD264746F4A0B","user_header":"","comment_is_top":false,"comment_ctime":1618816636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618816636","product_id":100023901,"comment_content":"猜测：long类型 是  八字节 长度， 即  64位，那么 32位机器操作 long类型，可能就不能用单个cpu指令完成，所以会出现上面所说的原子性问题","like_count":0},{"had_liked":false,"id":288026,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1618277756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618277756","product_id":100023901,"comment_content":"long类型是8个字节，1个字节是8位，那么8个字节就是64位，如果运行在32位机器上，那32位是不够存储的，会导致64位的数据拆分为两个32位的。在多线程情况下是有可能发生线程切换的，导致并发问题","like_count":0},{"had_liked":false,"id":287066,"user_name":"洛奇","can_delete":false,"product_type":"c1","uid":1624355,"ip_address":"","ucode":"662B4005721119","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","comment_is_top":false,"comment_ctime":1617764898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617764898","product_id":100023901,"comment_content":"思考题的意思应该是想表达在32位机器上执行的long类型的赋值操作不是原子的吧？加减操作即使在64位机器上也不是原子的。","like_count":0},{"had_liked":false,"id":287061,"user_name":"洛奇","can_delete":false,"product_type":"c1","uid":1624355,"ip_address":"","ucode":"662B4005721119","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","comment_is_top":false,"comment_ctime":1617763952,"is_pvip":false,"replies":[{"id":"104319","content":"大部分内容能看懂了，有些还是会看不懂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1617894118,"ip_address":"","comment_id":287061,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617763952","product_id":100023901,"comment_content":"请问老师，学了这个专栏后，可以看懂《java并发编程艺术》这本书吗？我感觉这本书比较难看懂","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518179,"discussion_content":"大部分内容能看懂了，有些还是会看不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617894118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287050,"user_name":"洛奇","can_delete":false,"product_type":"c1","uid":1624355,"ip_address":"","ucode":"662B4005721119","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","comment_is_top":false,"comment_ctime":1617760322,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1617760322","product_id":100023901,"comment_content":"讲原子性问题里，举的A和B两线程切换例子是不是不恰当？因为，即使两个线程不发生切换，其结果count也是为1而不是2；而且从两个线程所得的count初始值都为0，可以推断出应该分别在不同cpu核上运行，在不同cpu核上也会发生线程切换吗？","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378506,"discussion_content":"单核CPU的机器运行两个线程A和B，都是对共享变量初始值count==0，逻辑count+=1的操作，如果A先执行，根据可见性，B在执行操作前肯定读取到了count=1了，那执行完B之后，最后的值肯定会是2，但根据后面的原子性，A和B都会分别执行CPU指令1，2，3；在线程切换时也可能会出问题，所以单核两线程的机器执行上面的逻辑，最后的结果可能是1也可能是2，因为count+=1是非原子性操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623250143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285350,"user_name":"源泉","can_delete":false,"product_type":"c1","uid":2096693,"ip_address":"","ucode":"41704DD46CBB5E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/fe/35/335b89fb.jpg","comment_is_top":false,"comment_ctime":1616749039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616749039","product_id":100023901,"comment_content":"怎么复现双重检测不加volatitle取到未初始化的instance这个现象，有人说synchronized可以保证代码执行完了里面的对象一定初始化完成了。无法复现无力反驳他","like_count":0},{"had_liked":false,"id":284823,"user_name":"keep","can_delete":false,"product_type":"c1","uid":2225566,"ip_address":"","ucode":"9764E27CA40944","user_header":"","comment_is_top":false,"comment_ctime":1616487824,"is_pvip":false,"replies":[{"id":"103328","content":"Cpu缓存是物理存在，主存一般指的就是内存，线程里的缓存这个说法有点模糊","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1616499432,"ip_address":"","comment_id":284823,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616487824","product_id":100023901,"comment_content":"请问下王老师,  &quot;指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）&quot;<br><br>这里说的写入CPU缓存,和Java内存模型里,线程把自己缓存里的值写入主存是同一个东西?如果是,那Java线程里的缓存,在硬件上是哪一个部分实现的呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517477,"discussion_content":"Cpu缓存是物理存在，主存一般指的就是内存，线程里的缓存这个说法有点模糊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616499432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284782,"user_name":"keep","can_delete":false,"product_type":"c1","uid":2225566,"ip_address":"","ucode":"9764E27CA40944","user_header":"","comment_is_top":false,"comment_ctime":1616469297,"is_pvip":false,"replies":[{"id":"103333","content":"无法确定","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1616499984,"ip_address":"","comment_id":284782,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616469297","product_id":100023901,"comment_content":"add10K() 放发里,每次把count读到自己cpu缓存后,什么时候写回内存里....","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517468,"discussion_content":"无法确定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616499984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284292,"user_name":"洛奇","can_delete":false,"product_type":"c1","uid":1624355,"ip_address":"","ucode":"662B4005721119","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/23/76511858.jpg","comment_is_top":false,"comment_ctime":1616152249,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1616152249","product_id":100023901,"comment_content":"请问，本文中，在讲源头二处，两个线程是分别运行在多核cpu上的两个不同核吗？如果是，那两个线程都有单独的cpu，为什么操作系统还要切换线程？如果不是，而是都在一个CPU内核上运行，那难道线程1在cpu缓存里的访问的count不是和线程2是同一个吗？(也就是两个线程都在一个cpu内核上运行，那么共享变量count是不是也在cpu缓存上共用？)","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378495,"discussion_content":"应该是单核下，cpu缓存是共用的，但是线程交替执行，线程A读取了count,+1，写到寄存器中（未写到主内存），此时cpu被B线程抢占，线程B从主内存读取count，此时还是0","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623246070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378505,"discussion_content":"这里说的是原子性问题，因为count+=1是非原子性操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623249970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284278,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1616147610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616147610","product_id":100023901,"comment_content":"有关双重检查，<br>简单的方案：整个方法加上synchronized修饰<br>巧妙的方案，给instance加上volatile来屏蔽指令重排序。","like_count":0},{"had_liked":false,"id":283491,"user_name":"绝尘而去","can_delete":false,"product_type":"c1","uid":1252567,"ip_address":"","ucode":"690E4E6B3E39DD","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/d7/c176ad9f.jpg","comment_is_top":false,"comment_ctime":1615798404,"is_pvip":true,"replies":[{"id":"102864","content":"不一定发生","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1615820573,"ip_address":"","comment_id":283491,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615798404","product_id":100023901,"comment_content":"老师，只要是new操作必然会发生指令重排吗？还是只是说有可能会发生。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517053,"discussion_content":"不一定发生","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615820573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283445,"user_name":"NavyChou","can_delete":false,"product_type":"c1","uid":1606805,"ip_address":"","ucode":"8D01EDDBF23B89","user_header":"https://static001.geekbang.org/account/avatar/00/18/84/95/4183d036.jpg","comment_is_top":false,"comment_ctime":1615785016,"is_pvip":false,"replies":[{"id":"102863","content":"可见性问题和多核的缓存关系非常大","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1615820432,"ip_address":"","comment_id":283445,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1615785016","product_id":100023901,"comment_content":"老师，我是刚开始学这个课程的，我想问一下，关于可见性的问题，是不是可以理解为：cpu多核带来的问题，跟缓存的关系不大？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517043,"discussion_content":"可见性问题和多核的缓存关系非常大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615820432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378493,"discussion_content":"单核cpu下没有可见性问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623245864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282890,"user_name":"安，然","can_delete":false,"product_type":"c1","uid":1124621,"ip_address":"","ucode":"71F9235EF97695","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/0d/8efa076a.jpg","comment_is_top":false,"comment_ctime":1615452703,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1615452703","product_id":100023901,"comment_content":"为了合理利用CPU，提高性能，采取了如下措施，同时也引入了一些问题<br>1.CPU增加缓存，平衡CPU和内存的速度差异问题。（可见性问题）<br>2.操作系统增加进程、线程，分时复用CPU。（原子性问题）<br>3.编译程序优化指令顺序，提高性能。（有序性问题）<br>","like_count":0},{"had_liked":false,"id":282533,"user_name":"Geek_aa23b7","can_delete":false,"product_type":"c1","uid":2461872,"ip_address":"","ucode":"DD89F30A04D5CC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL23Wicb0gO9RIXrRzpettuEYaSHLicA2LgRz3X7Npiagf1R4aB9bmePt1TY006z63ngKzhEONZvOsfw/132","comment_is_top":false,"comment_ctime":1615293573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615293573","product_id":100023901,"comment_content":"看了老师的文章，感悟很深。对可见性、有序性、原子性有以下感悟：开发人员如果对这块内容没有研究过，大概率不会意识到存在可见效、有序性问题。   而原子性应该有两个纬度去考虑：1、单核CPU的多线程（老师举的例子：线程切换带来的原子性问题指的就是针对的这种情况） 2、多核CPU（可以做到真正的并行天然的存在原子性问题)。针对如何避免这三个问题：分2种情况：1、一写多读：此种情况不存在原子性问题，使用关键字修饰volatile即可同时解决可见性、有序性。2、多写多读：为了解决原子性问题必然要加锁。这又分2种情况，如果对共享变量的访问都在受保护资源内部，那就不存在有序性和可见效问题。但如果存在其他地方也可以访问共享变量，那就要采用一写多读的解决方法。","like_count":0},{"had_liked":false,"id":282134,"user_name":"I am watermelon","can_delete":false,"product_type":"c1","uid":1771658,"ip_address":"","ucode":"009EFA2065221C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/08/8a/c141ff16.jpg","comment_is_top":false,"comment_ctime":1615104328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615104328","product_id":100023901,"comment_content":"老师，第一段代码count变量是不是应该用static 修饰？我执行后始终输出0，改为类变量才有文中提到的效果。","like_count":0},{"had_liked":false,"id":281522,"user_name":"合拍病友","can_delete":false,"product_type":"c1","uid":1940625,"ip_address":"","ucode":"5BA01383A58EEC","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9c/91/6642d43f.jpg","comment_is_top":false,"comment_ctime":1614772663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614772663","product_id":100023901,"comment_content":"1.分配一块内存 M；<br>2.将 M 的地址赋值给 instance 变量；<br>3.最后在内存 M 上初始化 Singleton 对象。<br>为什么会在第二步的时候把锁释放掉了，如果不释放就不会有问题了？","like_count":0},{"had_liked":false,"id":280900,"user_name":"八宝","can_delete":false,"product_type":"c1","uid":1324501,"ip_address":"","ucode":"89D991A930FDEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/35/d5/17833946.jpg","comment_is_top":false,"comment_ctime":1614473694,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1614473694","product_id":100023901,"comment_content":"源头之三：编译优化带来的有序性问题举例，双重检查锁创建单例对象多线程执行时可能出现NPE(空指针异常)的解释。<br>thread A “先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；”，<br>thread B 刚进入 getInstance()方法，进入第一个 instance==null 判定。从结果推NPE，可能的情况如下：<br>1) B与A线程共用同一CPU执行，共享CPU缓存。thread B 从CPU缓存中获取instance还没初始化，但!=null<br>2) B与A线程不再同一CPU上执行，不共享CPU缓存。假定 thread B 从内存中load instance 对象（只能是线程A切换后B执行前缓存写回内存的），未初始化但!=null<br>出现1）或2）时，B就不用进入synchronized代码块获取锁，直接返回instance对象。如果后面调用instance的方法时，会出现NPE。<br>解决方法如下：<br>a) instance 变量前面加上 volatile关键字，禁用编译优化(正常new并赋值)和CPU缓存(instance赋值之后直接写回内存)<br>b) 在 类中定义一个静态类，在其中定义静态实例并直接new对象，通过类加载机制保证实例唯一性。<br>private static class SingletonHolder{<br>    private static Singleton instance = new Singleton();<br>}<br>public static Singleton getInstance(){<br>    return SingletonHolder.instance;<br>}","like_count":0},{"had_liked":false,"id":280446,"user_name":"蒋波","can_delete":false,"product_type":"c1","uid":1526325,"ip_address":"","ucode":"611A1F0629F08E","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/35/16861bf8.jpg","comment_is_top":false,"comment_ctime":1614218284,"is_pvip":false,"replies":[{"id":"102074","content":"是两个独立的，都有可能导致乱序执行","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1614598853,"ip_address":"","comment_id":280446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1614218284","product_id":100023901,"comment_content":"老师，有个问题不明白，请老师解答一下。你的专栏中讲解是编译器的优化会导致程序有序性问题，那CPU得乱序执行会不会导致这个问题呢？编译器的优化和CPU的乱序是两个互相独立的优化吧，它们有关联吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516101,"discussion_content":"是两个独立的，都有可能导致乱序执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614598853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279765,"user_name":"A 付李珏","can_delete":false,"product_type":"c1","uid":1030544,"ip_address":"","ucode":"970D6EF916D6B4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b9/90/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1613959612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613959612","product_id":100023901,"comment_content":"下面是happens-before原则规则：<br>1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；<br>2.锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；<br>3.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；<br>4.传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；<br>5.线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；<br>6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；<br>7.线程结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；<br>8.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；","like_count":0},{"had_liked":false,"id":279368,"user_name":"Geek_181f08","can_delete":false,"product_type":"c1","uid":2439919,"ip_address":"","ucode":"B6F37744966A7F","user_header":"http://thirdwx.qlogo.cn/mmopen/h0KAdRFKjCOSLRjzictvlaGNtn5QX6weslmprR23icDZfy5X9j1gS9ONZia1yhtibdlnARx8gImuPR5gUK6tiazy11dXL77Th6BOg/132","comment_is_top":false,"comment_ctime":1613733344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613733344","product_id":100023901,"comment_content":"intel x86架构的cpu操作64位long可以做到ok才对。<br>inline Atomic64 NoBarrier_AtomicIncrement(volatile Atomic64* ptr,<br>                                          Atomic64 increment) {<br>  Atomic64 temp = increment;<br>  __asm__ __volatile__(&quot;lock; xaddq %0,%1&quot;<br>                       : &quot;+r&quot; (temp), &quot;+m&quot; (*ptr)<br>                       : : &quot;memory&quot;);<br>  &#47;&#47; temp now contains the previous value of *ptr<br>  return temp + increment;<br>}<br>","like_count":0},{"had_liked":false,"id":278084,"user_name":"时光守护者-基兰","can_delete":false,"product_type":"c1","uid":1554995,"ip_address":"","ucode":"F0B0887B1979D2","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","comment_is_top":false,"comment_ctime":1612754828,"is_pvip":false,"replies":[{"id":"100948","content":"初始化的过程中instance被赋值，但是构造函数尚没有执行时，正好其他线程读instance，此时是非空的。如果读instance也被synchronized包裹，就没问题了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1612780742,"ip_address":"","comment_id":278084,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612754828","product_id":100023901,"comment_content":"老师有个疑问，被synchronized包裹的代码块不是当前线程执行完了后才能执行下个线程吗，当前线程执行完instance = new Singleton();后为啥不会初始化Singleton对象呢，指令是重排了，但是也会执行完吧？<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515269,"discussion_content":"初始化的过程中instance被赋值，但是构造函数尚没有执行时，正好其他线程读instance，此时是非空的。如果读instance也被synchronized包裹，就没问题了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612780742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276221,"user_name":"悟_","can_delete":false,"product_type":"c1","uid":1881127,"ip_address":"","ucode":"24520649DDBDCF","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b4/27/92203fa6.jpg","comment_is_top":false,"comment_ctime":1611836393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611836393","product_id":100023901,"comment_content":"我这段程序跑的，结果为0，我这怎么弄的，我把calc改为非静态方法了，用主函数调用并获取返回结果，有知道为什么的么？","like_count":0},{"had_liked":false,"id":275186,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1611376014,"is_pvip":false,"replies":[{"id":"99877","content":"在缓存取，缓存会失效","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1611411363,"ip_address":"","comment_id":275186,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1611376014","product_id":100023901,"comment_content":"一个线程从内存取出一个变量的值之后进入CPU缓存，在计算过程中这个线程还会去内存取吗？还是一直用CPU缓存里的？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514251,"discussion_content":"在缓存取，缓存会失效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611411363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271066,"user_name":"Meike mu","can_delete":false,"product_type":"c1","uid":1183775,"ip_address":"","ucode":"B9FECA2F56C4D9","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/1f/d009a0ca.jpg","comment_is_top":false,"comment_ctime":1609390954,"is_pvip":false,"replies":[{"id":"98341","content":"操作系统有自己的调度算法，会保证相对公平的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1609507064,"ip_address":"","comment_id":271066,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1609390954","product_id":100023901,"comment_content":"线层切换是随机切换吗？如果同时存在多个线程，如果从当前A线程切换到了B线程，然后在B线程切换的时候是只能切换回A线程还是也可以切换到C线程？如果切换到C线程了，如果线程比较多，那A的等待时间也许会很长，有可能再也切换不回来了？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512831,"discussion_content":"操作系统有自己的调度算法，会保证相对公平的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609507064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268294,"user_name":"poordickey","can_delete":false,"product_type":"c1","uid":1810156,"ip_address":"","ucode":"2A436EC813AF97","user_header":"","comment_is_top":false,"comment_ctime":1608127902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608127902","product_id":100023901,"comment_content":"指令重排的问题怎么解决呢？","like_count":0},{"had_liked":false,"id":267045,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1607581058,"is_pvip":true,"replies":[{"id":"97132","content":"单核多线程也存在并发问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1607778064,"ip_address":"","comment_id":267045,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607581058","product_id":100023901,"comment_content":"老师关于 可见性，我试了下将两个线程都绑定到同一个cpu上，结果还是不是两万，这个应该是这样吗。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511493,"discussion_content":"单核多线程也存在并发问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607778064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263887,"user_name":"小小代码","can_delete":false,"product_type":"c1","uid":1290642,"ip_address":"","ucode":"F3D4E2C23FC9BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/92/f3dabcb1.jpg","comment_is_top":false,"comment_ctime":1606287843,"is_pvip":false,"replies":[{"id":"95717","content":"不是，默认情况下是不确定的，不过可以指定cpu的亲缘性来强制在一个核上执行","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1606311913,"ip_address":"","comment_id":263887,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606287843","product_id":100023901,"comment_content":"对于多核CPU来说，一个线程的所有指令是不是最终都调度在一个CPU上执行，不会出现一会在CPU1上执行，一会在CPU2上执行？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510346,"discussion_content":"不是，默认情况下是不确定的，不过可以指定cpu的亲缘性来强制在一个核上执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606311913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263657,"user_name":"森呢","can_delete":false,"product_type":"c1","uid":1239193,"ip_address":"","ucode":"B3D07ACF710B11","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/99/0ea71e63.jpg","comment_is_top":false,"comment_ctime":1606210202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606210202","product_id":100023901,"comment_content":"多核cpu导致的可见性问题，线程切换导致的原子性问题，编译优化导致的指令重排序都是在操作系统层面为我们解答了并发编程出现并发问题的根本原因。这也是上一节","like_count":0},{"had_liked":false,"id":261783,"user_name":"Frode","can_delete":false,"product_type":"c1","uid":1503064,"ip_address":"","ucode":"B7B8DBF9980EA1","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/58/d05ec302.jpg","comment_is_top":false,"comment_ctime":1605522801,"is_pvip":true,"replies":[{"id":"95327","content":"没有线程内存这东西","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1605833182,"ip_address":"","comment_id":261783,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605522801","product_id":100023901,"comment_content":"“在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。”<br><br>我开始认为是线程不安全的，然后看了这段后懵了，java中多线程访问成员变量时，是copy了一份副本到线程内存中么？这个内存和cpu缓存什么关系呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509606,"discussion_content":"没有线程内存这东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605833182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261684,"user_name":"Frode","can_delete":false,"product_type":"c1","uid":1503064,"ip_address":"","ucode":"B7B8DBF9980EA1","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/58/d05ec302.jpg","comment_is_top":false,"comment_ctime":1605489165,"is_pvip":true,"replies":[{"id":"95005","content":"不是","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1605520893,"ip_address":"","comment_id":261684,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605489165","product_id":100023901,"comment_content":"老师，单核cpu时代成员变量是线程安全的么","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509565,"discussion_content":"不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605520893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261364,"user_name":"carl","can_delete":false,"product_type":"c1","uid":1593385,"ip_address":"","ucode":"7C725C7D69855F","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqD7goM3NZGb77qicnUHX8qdrXpIH89Ziaul2475ko5VMpFxiajbQsJhv2aG0HxmX8vgswfz9WkvElBg/132","comment_is_top":false,"comment_ctime":1605288780,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1605288780","product_id":100023901,"comment_content":"两个问题，1. 在JDK8 开了上千个线程循环调用getInstance()方法，为了新增CPU切换的几率 并且在构造函数里让线程睡30s，始终没有复现描述的问题，是JVM做了调整吗？<br>2. 描述优化后出现的问题时，不会出现空指针吧? 因为 “将 M 的地址赋值给 instance 变量” 不就代表 instance != null 吗? 真正出现的问题是，假如该类 构造函数 会做一些初始化的工作，就会出现没有执行完构造方法 就将 instance 返回","like_count":0,"discussions":[{"author":{"id":1593385,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqD7goM3NZGb77qicnUHX8qdrXpIH89Ziaul2475ko5VMpFxiajbQsJhv2aG0HxmX8vgswfz9WkvElBg/132","nickname":"carl","note":"","ucode":"7C725C7D69855F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326399,"discussion_content":"老师说的是访问对象的成员变量可能会出现空指针异常，没有问题，我看错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605588266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259640,"user_name":"静心","can_delete":false,"product_type":"c1","uid":1335457,"ip_address":"","ucode":"EB264FA6519FDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","comment_is_top":false,"comment_ctime":1604799519,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1604799519","product_id":100023901,"comment_content":"看到过很多篇关于双重锁机制的介绍，这篇文章是我看到的文章里介绍的最清楚的。另外，老师对于并发总结的六字真言很棒：分工、同步、互斥","like_count":0},{"had_liked":false,"id":259224,"user_name":"小炭","can_delete":false,"product_type":"c1","uid":1109544,"ip_address":"","ucode":"E20E3958CAF06C","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/28/c04a0c83.jpg","comment_is_top":false,"comment_ctime":1604656194,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604656194","product_id":100023901,"comment_content":"为什么在 new 操作上，实际上优化后的执行路径却是下面这样的？<br>1. 分配一块内存 M；<br>2. 将 M 的地址赋值给 instance 变量；<br>3. 最后在内存 M 上初始化 Singleton 对象。","like_count":0},{"had_liked":false,"id":258924,"user_name":"小炭","can_delete":false,"product_type":"c1","uid":1109544,"ip_address":"","ucode":"E20E3958CAF06C","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/28/c04a0c83.jpg","comment_is_top":false,"comment_ctime":1604582202,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604582202","product_id":100023901,"comment_content":"没事就过来看看，百看不厌","like_count":0},{"had_liked":false,"id":257437,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1603971834,"is_pvip":false,"replies":[{"id":"93743","content":"没有手段保证绝对的同时，操作系统调度有自己的想法","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1604016546,"ip_address":"","comment_id":257437,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603971834","product_id":100023901,"comment_content":"“我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里”，如果第一次都是将count=0读到各自CPU缓存，那最终结果不是一定是10000吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508331,"discussion_content":"没有手段保证绝对的同时，操作系统调度有自己的想法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604016546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256196,"user_name":"蚝不鱿鱼","can_delete":false,"product_type":"c1","uid":1428043,"ip_address":"","ucode":"5DB98E406F1D3E","user_header":"https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg","comment_is_top":false,"comment_ctime":1603550452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603550452","product_id":100023901,"comment_content":"宝令考试的课得多刷，现在开始二刷，这样才能获得更多精华！","like_count":0},{"had_liked":false,"id":254013,"user_name":"A.Lyuweigh","can_delete":false,"product_type":"c1","uid":1443305,"ip_address":"","ucode":"0CCFA05639A9D1","user_header":"https://static001.geekbang.org/account/avatar/00/16/05/e9/91273c29.jpg","comment_is_top":false,"comment_ctime":1603016261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603016261","product_id":100023901,"comment_content":"32位机器cpu一次性处理不了长度达到64位的long,那就要线程分次处理,就有可能会出现上面说的原子性问题；","like_count":0},{"had_liked":false,"id":253152,"user_name":"Q罗","can_delete":false,"product_type":"c1","uid":1792098,"ip_address":"","ucode":"E797378F4DA1F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/58/62/346dd248.jpg","comment_is_top":false,"comment_ctime":1602636819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602636819","product_id":100023901,"comment_content":"写得太好了，逻辑非常清晰，还有一目了然的图解！","like_count":0},{"had_liked":false,"id":252304,"user_name":"xanxus","can_delete":false,"product_type":"c1","uid":1654600,"ip_address":"","ucode":"FFF1EFD2ABCBAA","user_header":"","comment_is_top":false,"comment_ctime":1602229380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602229380","product_id":100023901,"comment_content":"如果instance中的属性全部是final修饰的，是不是就没有这个问题了？？<br>","like_count":0},{"had_liked":false,"id":249955,"user_name":"Hi。","can_delete":false,"product_type":"c1","uid":1116664,"ip_address":"","ucode":"9E04714B1BE71D","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/f8/910555de.jpg","comment_is_top":false,"comment_ctime":1600866081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600866081","product_id":100023901,"comment_content":"关于Voliate的工作原理~：<br>Voliate关键字：用于解决可见性，原理是在操作被Voliate修饰的变量时，汇编指令中会有一个Lock前缀指令，这个指令会引起以下两个操作：<br>        1.发生修改后会强制将当前处理器缓存行写回系统内存<br>        2.这个写回操作会使其他缓存了该变量的处理器缓存失效，重新从内存中读取。","like_count":0},{"had_liked":false,"id":248384,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1600142236,"is_pvip":true,"replies":[{"id":"91345","content":"������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1600346926,"ip_address":"","comment_id":248384,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600142236","product_id":100023901,"comment_content":"简单总结一下，高级语言的指令和CPU指令之间不是1对1的，单条CPU指令本身可以保障原子性，但是高级语言的指令“被翻译”成CPU指令后，可能就会出现指令重排，以及一条高级语言指令变成多条CPU指令的情况，高级语言为了解决这些问题，会提供一些特殊的声明比如volatile，比如synchronized来帮助翻译CPU指令的程序，明确翻译需求。这些特殊的声明，并发编程模型的各种框架，都是对并发理论的实践。并发理论很多时候就是要解决资源(CPU&#47;内存&#47;IO...)利用率和协作的关系。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505641,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600346926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245569,"user_name":"Aiome","can_delete":false,"product_type":"c1","uid":1306394,"ip_address":"","ucode":"5D3A810C0FF56B","user_header":"","comment_is_top":false,"comment_ctime":1598980255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598980255","product_id":100023901,"comment_content":"老师，你应该跟大家强调一下这篇文章是在将计算机内存模型的可见性、原子性、有序性问题。和Java内存模型下的可见性、原子性、有序性问题还是有区别的。大家容易混淆，我就是看文章的时候觉得很爽，没有觉的这个说的是计算机的内存模型。","like_count":0},{"had_liked":false,"id":241633,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1597375464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597375464","product_id":100023901,"comment_content":"双重检查单例的例子中，为什么对instance 变量加上 volatile 就可以解决问题呢？<br>是因为volitile 关键字可以阻止编译器重排序吗？","like_count":0},{"had_liked":false,"id":241631,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1597374841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597374841","product_id":100023901,"comment_content":"会有隐患，32位机器上操作long类型64位的变量，在long类型是共享变量，并发的情况下，其中一个线程对long类型写入的时候会先写入上32位，下32位，在只写入了上32位的时候，有可能会发生线程切换，另外一个线程读long变量的值就是错的，所以会有原子性问题。","like_count":0},{"had_liked":false,"id":241620,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1597372716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597372716","product_id":100023901,"comment_content":"long类型是64位的，在32位机器上对long类型变量的读取、写入需要多次操作，就会有原子性的问题。","like_count":0},{"had_liked":false,"id":235752,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1595169968,"is_pvip":false,"replies":[{"id":"87241","content":"没有原子性问题，并不意味着线程安全","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1595341737,"ip_address":"","comment_id":235752,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1595169968","product_id":100023901,"comment_content":"老师，我对原子性有点疑惑。如果多核cpu，在核1上，对变量a进行+1操作，当核1刚从内存中取到数值的时候，而核2同时也对变量a进行+1操作，在内存中取到了a的数值。核1的+1指令也完整执行了，并没有切换时间片被其他指令中断。此时这个a在核1中是否可以说保证了原子性啊。但是核1核2都取到了相同的值，结果还是有错误。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501820,"discussion_content":"没有原子性问题，并不意味着线程安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595341737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296330,"discussion_content":"最后我的结论就是，java的原子性，拿a=a+1举例，原子性就是1.线程从主内存读取a的值 2.线程在本地内存对a+1   3.线程将修改后a的值刷新到主内存中。  期间此共享变量不会被其他线程操作。  这样看来，java的原子性其实也保证了可见性和有序性。这样对于这个变量来说它就是线程安全的。  至于老师说的保证了原子性也无法保证线程安全应该是指的是可能会出现竞态条件导致的线程安全问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596511671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296264,"discussion_content":"我说的这种是针对一条线程的原子性。而针对java的原子性，是多核条件下也可以保证的原子性。这条线程的操作，其他核上线程无法操作这个共享产量。那么即便保证了多核上的原子性，还是会出现线程安全问题吗？真的想不明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596500614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234368,"user_name":"V","can_delete":false,"product_type":"c1","uid":1060726,"ip_address":"","ucode":"7CA43B0FBFFA68","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/76/a382a707.jpg","comment_is_top":false,"comment_ctime":1594655205,"is_pvip":false,"replies":[{"id":"86538","content":"这个要看操作系统相关知识了，中断处理还有线程调度","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1594736023,"ip_address":"","comment_id":234368,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594655205","product_id":100023901,"comment_content":"请问 cpu 切换的时候当前线程上下文是存储在哪里？恢复执行的时候是如何操作的？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501368,"discussion_content":"这个要看操作系统相关知识了，中断处理还有线程调度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594736023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231692,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1593750607,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1593750607","product_id":100023901,"comment_content":"文中提到：<br>分配一块内存 M；<br>在内存 M 上初始化 Singleton 对象；<br>然后 M 的地址赋值给 instance 变量。<br>但是实际上优化后的执行路径却是这样的：<br>分配一块内存 M；<br>将 M 的地址赋值给 instance 变量；<br>最后在内存 M 上初始化 Singleton 对象。<br><br>可能有同学会疑惑，这里为什么可能进行从排序？java 不是有 as if serial规则么？<br><br>这是因为23步并没有数据依赖性，第3步依赖的是第1步分配的内存地址，但是不依赖第2步对内存的初始化。","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378498,"discussion_content":"为什么要优化，这里优化的点是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623247516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231500,"user_name":"何处天涯","can_delete":false,"product_type":"c1","uid":1574763,"ip_address":"","ucode":"6EAFA4E573ED67","user_header":"https://static001.geekbang.org/account/avatar/00/18/07/6b/fad9ebc4.jpg","comment_is_top":false,"comment_ctime":1593688699,"is_pvip":true,"replies":[{"id":"85628","content":"不一定","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1593856279,"ip_address":"","comment_id":231500,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593688699","product_id":100023901,"comment_content":"synchronized代码块未执行完的时候, 切换时间片, 那么CPU缓存会刷入主内存吗?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500321,"discussion_content":"不一定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593856279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231447,"user_name":"先改昵称","can_delete":false,"product_type":"c1","uid":1264271,"ip_address":"","ucode":"830B92005230F2","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/8f/a12adc33.jpg","comment_is_top":false,"comment_ctime":1593678674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593678674","product_id":100023901,"comment_content":"1.样例代码-1中 count需要设置成static 且join的异常需要处理","like_count":0},{"had_liked":false,"id":230888,"user_name":"小李讲源码","can_delete":false,"product_type":"c1","uid":1107484,"ip_address":"","ucode":"2573037D7C82C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","comment_is_top":false,"comment_ctime":1593514154,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593514154","product_id":100023901,"comment_content":"解决问题就要了解问题出现的源头，缓存带来的可见性问题，线程切换带来的原子性问题，指令重排带来的有序性问题。解决并发的问题就要从这几个去切入。<br><br>long和double是64位的，在32位虚拟机进行操作，可能操作的是高32位，也可能是低32位。得到的结果就不是我们想要的了。可以加上volatile来保证原子性。<br><br>","like_count":0},{"had_liked":false,"id":230222,"user_name":"lzxDchaser","can_delete":false,"product_type":"c1","uid":1196523,"ip_address":"","ucode":"7173DC3F9CA1BA","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/eb/6494dc04.jpg","comment_is_top":false,"comment_ctime":1593316194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593316194","product_id":100023901,"comment_content":"各位大佬，如果不进行双重检查，进去就锁，即下面这种写法，testInstance还需要增加volatile进行修饰吗？<br>class TestInstance{<br>\tprivate static TestInstance testInstance;<br><br>\tTestInstance getInstance(){<br>\t\tsynchronized(TestInstance.class){<br>\t\t\tif (testInstance == null) {<br>\t\t\t\ttestInstance = new TestInstance();<br>\t\t\t}<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":230000,"user_name":"拓荒者","can_delete":false,"product_type":"c1","uid":1714981,"ip_address":"","ucode":"13BE3AD90C330A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2b/25/ef82b260.jpg","comment_is_top":false,"comment_ctime":1593238819,"is_pvip":false,"replies":[{"id":"85355","content":"IO是外设到内存，不是内存到CPU,一般外设都有自己的驱动器，cpu会向外设发指令","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1593604128,"ip_address":"","comment_id":230000,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593238819","product_id":100023901,"comment_content":"当进程进行进行IO 操作时，会让出cpu的使用权。这里io是指把数据从磁盘读到内存？还是从内存读到cpu？另外io操作不需要cpu的参与吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499732,"discussion_content":"IO是外设到内存，不是内存到CPU,一般外设都有自己的驱动器，cpu会向外设发指令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593604128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229859,"user_name":"hello zero","can_delete":false,"product_type":"c1","uid":1028052,"ip_address":"","ucode":"D1F4B2A7D4635B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/d4/59e2bfd4.jpg","comment_is_top":false,"comment_ctime":1593165831,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593165831","product_id":100023901,"comment_content":"但是实际上优化后的执行路径却是这样的：分配一块内存 M；将 M 的地址赋值给 instance 变量；最后在内存 M 上初始化 Singleton 对象。<br>没搞懂为什么编译器要优化成这个样子，没看出有啥好处啊？","like_count":0},{"had_liked":false,"id":229236,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1592928350,"is_pvip":false,"replies":[{"id":"84696","content":"add()方法里不要输出到控制台","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1593003120,"ip_address":"","comment_id":229236,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592928350","product_id":100023901,"comment_content":"可见性的一个小问题，老师的代码估计是没跑过，直接是报错的，本地自己写了一个类似的，但有个很奇怪的现象，程序多次执行，绝大部分情况下，返回值是20000，偶尔会出现CPU缓存的问题，是不是IDEA优化导致一直使用一个CPU在执行这两个线程啊？<br>public class Test {<br>    private static final Logger logger = LoggerFactory.getLogger(Test.class);<br><br>    private static int num = 0;<br><br>    public static void main(String[] args) throws InterruptedException {<br>        Thread thread1 = new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                add();<br>            }<br>        });<br>        Thread thread2 = new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                add();<br>            }<br>        });<br>        thread1.start();<br>        thread2.start();<br>        thread1.join();<br>        thread2.join();<br>        System.out.println(&quot;num:&quot; + num);<br>    }<br><br>    private static void add() {<br>        for (int i = 0; i &lt; 1000; i++) {<br>            num++;<br>            System.out.println(num);<br>        }<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499393,"discussion_content":"add()方法里不要输出到控制台","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593003120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229088,"user_name":"杜总","can_delete":false,"product_type":"c1","uid":2046055,"ip_address":"","ucode":"C6600875A265E7","user_header":"","comment_is_top":false,"comment_ctime":1592895106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592895106","product_id":100023901,"comment_content":"锁释放和没有释放都可能出现问题，锁没释放可能在第一个判空的地方出问题，锁释放可能在第一个和第二个判空的地方出问题","like_count":0},{"had_liked":false,"id":227060,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1592273613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592273613","product_id":100023901,"comment_content":"首先从老师的分享中有很多收获，但是对老师提出的单核单CPU不存在可见性问题有点疑惑。希望老师指正<br>因为单核单CPU也是有可能按时间片进行线程切换的，只要存在线程切换，加上存在CPU缓存，即使是同一个CPU缓存（寄存器）也是会有可见性问题的，我举个例子 线程1要对某个共享变量执行加一操作，那么指令可能是存在三条<br>第一条：读取内存0001地址的内容到寄存器<br>第二条：对寄存器内容加一<br>第三条：将加一后寄存器的内容写到共享内存 <br><br>在这三条指令执行期间，因为不是原子操作。线程1在在单核CPU执行完第一条指令后，时间片到了，切换到线程2执行，线程2也执行完第一条指令后时间片到了，线程1继续执行第二条第三条指令，执行完后线程2继续执行，会覆盖共享变量的值，因为它没有重新从共享变量读取线程一写的最新值。所以单核单cpu还是存在可见性问题的吧","like_count":0},{"had_liked":false,"id":224052,"user_name":"MainLi","can_delete":false,"product_type":"c1","uid":1341770,"ip_address":"","ucode":"AF16C960A9BC2A","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/4a/12b679b2.jpg","comment_is_top":false,"comment_ctime":1591262988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591262988","product_id":100023901,"comment_content":"老师说的有序性问题时举出的例子是单例那个原子性问题导致 好像不是有序性问题的例子  可以举一个更贴切的有序性例子么","like_count":0},{"had_liked":false,"id":219740,"user_name":"我可以学","can_delete":false,"product_type":"c1","uid":1994715,"ip_address":"","ucode":"3FDF42B9AFE572","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjAzMVguDJpHsc8BqpzDVj5MBYbpPcFrVForXIU73gHex9VXb9s4q8oHK8ZrLRfRLG2IcCVgtO9w/132","comment_is_top":false,"comment_ctime":1590072920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590072920","product_id":100023901,"comment_content":"老师，我对 并发count++，1000次结果偏向2000，而一亿次结果偏向一亿，不是特别理解，望解惑","like_count":0},{"had_liked":false,"id":219409,"user_name":"Coeus","can_delete":false,"product_type":"c1","uid":1721889,"ip_address":"","ucode":"AAB2998E81B858","user_header":"https://static001.geekbang.org/account/avatar/00/1a/46/21/e502058b.jpg","comment_is_top":false,"comment_ctime":1590023815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590023815","product_id":100023901,"comment_content":"老师，我想问个问题，翻了评论好像没有类似的。为什么java要优化对象的初始化指令的顺序，在我看来优化前后并没有什么区别，望解答。","like_count":0},{"had_liked":false,"id":217104,"user_name":"I am watermelon","can_delete":false,"product_type":"c1","uid":1771658,"ip_address":"","ucode":"009EFA2065221C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/08/8a/c141ff16.jpg","comment_is_top":false,"comment_ctime":1589420886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589420886","product_id":100023901,"comment_content":"想问问老师，synchronized不是可以保证原子性吗？为什么将instance引用指向内存空间的时候，线程A会离开synchronized块呢？线程A不是应该将synchronized块执行完结束之后再离开吗？","like_count":0},{"had_liked":false,"id":216453,"user_name":"carl","can_delete":false,"product_type":"c1","uid":1593385,"ip_address":"","ucode":"7C725C7D69855F","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqD7goM3NZGb77qicnUHX8qdrXpIH89Ziaul2475ko5VMpFxiajbQsJhv2aG0HxmX8vgswfz9WkvElBg/132","comment_is_top":false,"comment_ctime":1589262627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589262627","product_id":100023901,"comment_content":"32位计算机应该是指CPU的寄存器的大小，java中一个long变量需要64位，也就是32位计算机要读一个long型变量需要读两次。假如两个线程对同一个变量进行操作，如果没有做处理，那么一个线程的修改，对于另外一个线程大部分时候都是不可见的，就会存在并发隐患，32位处理64位变量出现并发问题的几率更大，但是本质上与变量类型无关，个人看法，不知道对不对","like_count":0},{"had_liked":false,"id":215491,"user_name":"发飙的蜗牛","can_delete":false,"product_type":"c1","uid":1800868,"ip_address":"","ucode":"B2D96A2D0B6BA4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/a4/79ffe77c.jpg","comment_is_top":false,"comment_ctime":1589000871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589000871","product_id":100023901,"comment_content":"想问一下双重检查单例问题，CPU指令重排序之后，线程A执行完指令2以后会释放锁吗？因为锁是加到整一个new操作的，还没有执行完指令3的操作，是不是不会释放锁呢？","like_count":0},{"had_liked":false,"id":213125,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588307672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588307672","product_id":100023901,"comment_content":"缓存带来可见性问题; 线程带来原子性问题;  编译器带来有序性问题。<br>可见性问题是缓存在不同的cpu中，为了平衡cpu和内存的速度，会将数据加载进缓存，直接从缓存中读取数据。但针对共享变量，两个线程都将同一个共享变量加载进缓存，对其操作，就会出现共享变量不一致的问题;<br>原子性问题则是cpu切换线程是在cpu指令级别切换的，容易出现共享数据操作一半就切换了，造成数据不一致。<br>有序性问题则是编译器优化，会对某些操作的顺序优化，比如定义某个变量后，一直没用到或者出于内存的原因。最熟悉的就是单例的DCL检测","like_count":0},{"had_liked":false,"id":210786,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1923267,"ip_address":"","ucode":"FFCE9DE42920E2","user_header":"","comment_is_top":false,"comment_ctime":1587825329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587825329","product_id":100023901,"comment_content":"你好，老师，课后问题说到的对long加减存在并发隐患，我认为不应该是加减而是赋值，因为加减本身就不是原子操作。","like_count":0},{"had_liked":false,"id":210081,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1587680802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587680802","product_id":100023901,"comment_content":"前文讲数据操作本身不就会有并发问题吗？ count+=1会拆分为多条指令，为什么特别强调long类型数据操作呢？这个是什么情况下int不会发生而long发生呢","like_count":0},{"had_liked":false,"id":209446,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1587550307,"is_pvip":false,"replies":[{"id":"78695","content":"我觉得正确","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1588033165,"ip_address":"","comment_id":209446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587550307","product_id":100023901,"comment_content":"单cpu场景下，是线程切换导致的原子性问题。<br>多cpu场景下，不切换也有这个问题。本质上还是cpu指令是原子性的，而多个原子性的cpu指令并不是原子的<br>理解的对吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492800,"discussion_content":"我觉得正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588033165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209444,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1587550064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587550064","product_id":100023901,"comment_content":"单例的双重锁定，synchronize能保证可见性，但是原子性是通过互斥性保证的。在单例中，第一步判断instance＝＝null时，是不互斥的，因此在实例化过程中才会出现有序性导致的instance实例被获取后出现错误。<br>不知道理解对不对","like_count":0},{"had_liked":false,"id":208945,"user_name":"THROW","can_delete":false,"product_type":"c1","uid":1112141,"ip_address":"","ucode":"A3C089A8F5F941","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/4d/4b748ff1.jpg","comment_is_top":false,"comment_ctime":1587470929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587470929","product_id":100023901,"comment_content":"那直接synchronized修饰getInstance方法是不是就可以了？","like_count":0},{"had_liked":false,"id":204509,"user_name":"JM","can_delete":false,"product_type":"c1","uid":1444751,"ip_address":"","ucode":"940900318F4167","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/8f/9c27f3c6.jpg","comment_is_top":false,"comment_ctime":1586412647,"is_pvip":false,"replies":[{"id":"76487","content":"有并发问题，需要加同步关键字","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1586430582,"ip_address":"","comment_id":204509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586412647","product_id":100023901,"comment_content":"public class SerializeCode {<br><br>    private static Logger logger = LoggerFactory.getLogger(SerializeCode.class);<br><br>    private static ISerializeBytePacker packer = null;<br>    &#47;**<br>     * 是否覆盖了默认的packer<br>     *&#47;<br>    private static boolean packerHadSet = false;<br><br>    public static void setPacker(ISerializeBytePacker packer) {<br>        &#47;&#47;packer只能设定一次<br>        if (SerializeCode.packer == null &amp;&amp; (!packerHadSet)) {<br>            SerializeCode.packer = packer;<br>            SerializeCode.packerHadSet = true;<br>        }<br>    }<br><br>    private static ISerializeBytePacker getPacker() {<br>        if (packer == null) {<br>            setPacker(new JdkSerializeBytePacker());<br>        }<br>        return packer;<br>    }<br>}<br><br>老师，这个为了初始化一次packer变量，是否会有并发问题？需要加volatile和synchronize？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491205,"discussion_content":"有并发问题，需要加同步关键字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586430582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202266,"user_name":"Siping","can_delete":false,"product_type":"c1","uid":1487971,"ip_address":"","ucode":"48E685333C663D","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/63/21902253.jpg","comment_is_top":false,"comment_ctime":1585950076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585950076","product_id":100023901,"comment_content":"老师厉害","like_count":0},{"had_liked":false,"id":202208,"user_name":"总有一天","can_delete":false,"product_type":"c1","uid":1240856,"ip_address":"","ucode":"730405447A6E95","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/18/5bd7b1be.jpg","comment_is_top":false,"comment_ctime":1585923963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585923963","product_id":100023901,"comment_content":"多线程我也学了好多年了，今天买来老师的课看看，发现写的真的很细致。对于我这种老手来说，看着是很舒服的。","like_count":0},{"had_liked":false,"id":200127,"user_name":"诺言","can_delete":false,"product_type":"c1","uid":1249497,"ip_address":"","ucode":"2BFC9E6FDE6C74","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/d9/333ec6e0.jpg","comment_is_top":false,"comment_ctime":1585547468,"is_pvip":false,"replies":[{"id":"75057","content":"会发生","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1585630497,"ip_address":"","comment_id":200127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585547468","product_id":100023901,"comment_content":"老师， 我不懂得一点是加了synchronized 还会发生线程切换么？ 希望老师给与答复， 辛苦！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489941,"discussion_content":"会发生","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585630497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196998,"user_name":"To you","can_delete":false,"product_type":"c1","uid":1305419,"ip_address":"","ucode":"A38385B6599E84","user_header":"https://static001.geekbang.org/account/avatar/00/13/eb/4b/dfd824e8.jpg","comment_is_top":false,"comment_ctime":1585329521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585329521","product_id":100023901,"comment_content":"不加volatile禁止指令重排序也没问题，因为只有再低版本的jdk中才会有这种问题，现在高版本jdk已经在内部解决了该问题，对象的new操作和初始化已经是原子性了，也就禁止重排序","like_count":0},{"had_liked":false,"id":192544,"user_name":"Zain Zhu","can_delete":false,"product_type":"c1","uid":1125986,"ip_address":"","ucode":"5402E6FF76333A","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/62/ea49480e.jpg","comment_is_top":false,"comment_ctime":1584859071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584859071","product_id":100023901,"comment_content":"很有启发。突然想起来之前遇到过的一个超级诡异的bug，结合老师的讲解，现在感觉极有可能就是优化重排导致的了。","like_count":0},{"had_liked":false,"id":190513,"user_name":"hellojd","can_delete":false,"product_type":"c1","uid":1341697,"ip_address":"","ucode":"4E51807AE7E472","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","comment_is_top":false,"comment_ctime":1584666377,"is_pvip":false,"replies":[{"id":"73835","content":"看java版本，1.5以上可以","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1585007463,"ip_address":"","comment_id":190513,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584666377","product_id":100023901,"comment_content":"doublecheck 创建单例对象，使用volite 关键字 能解决这个问题吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487996,"discussion_content":"看java版本，1.5以上可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585007463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189061,"user_name":"Mr.wang","can_delete":false,"product_type":"c1","uid":1224805,"ip_address":"","ucode":"86F341A5316BBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/b0/65/90387745.jpg","comment_is_top":false,"comment_ctime":1584451393,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584451393","product_id":100023901,"comment_content":"王老师在上面提到的示例是单例模式在多线程场景中使用，会出现的问题。只有懒汉模式在多线程场景下才会出现线程安全的问题，而饿汉模式因为在类初始化的时候，已经加载到内存中，不会出现线程安全的问题。","like_count":0},{"had_liked":false,"id":188565,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1584369143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584369143","product_id":100023901,"comment_content":"并发编码涉及的东西确实太多了，学的越多不懂的就越多，到最后就全学混乱。这次再重头梳理一下，最主要的是抓重点，对于一些不是太重要的知识点或工作中暂时用不到的先略过去，不然又要学糊了。<br>double-check 实现单例，其它同学都说得很好，我从另一个方面谈一下单例。synchronized 锁加类上，实际是锁住对应 ClassLoader 下的 Singleton.class。因此即便是类级别的锁，对不同的 ClassLoader 加载的同一个类上锁，这两个锁其实都互相不干扰，没有任何关联的。当然，除非使用 Tomcat 这样的容器，我们项目中通常都是一个 ClassLoader 加载的，所以可以认为 synchronized 类锁是进程级别的。","like_count":0},{"had_liked":false,"id":187900,"user_name":"灰太狼","can_delete":false,"product_type":"c1","uid":1066046,"ip_address":"","ucode":"C17DD5D5ED9DC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","comment_is_top":false,"comment_ctime":1584271152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584271152","product_id":100023901,"comment_content":"对于单例并发问题，我觉得用枚举实现单例最好。","like_count":0},{"had_liked":false,"id":187056,"user_name":"悠悠小竹子","can_delete":false,"product_type":"c1","uid":1061786,"ip_address":"","ucode":"A5E6731D28EBF9","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/9a/a323b2f1.jpg","comment_is_top":false,"comment_ctime":1584002042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584002042","product_id":100023901,"comment_content":"为什么编译器会进行这样的重排序，好处是什么，不重排序又会怎样？","like_count":0},{"had_liked":false,"id":186189,"user_name":"王晨旭","can_delete":false,"product_type":"c1","uid":1860513,"ip_address":"","ucode":"AB7364E1809126","user_header":"https://static001.geekbang.org/account/avatar/00/1c/63/a1/e281d530.jpg","comment_is_top":false,"comment_ctime":1583777553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583777553","product_id":100023901,"comment_content":"用什么工具能够测试并展示代码在虚拟机里执行的情况？","like_count":0},{"had_liked":false,"id":185631,"user_name":"Geek_94adb8","can_delete":false,"product_type":"c1","uid":1638187,"ip_address":"","ucode":"B142F473E1A0B3","user_header":"","comment_is_top":false,"comment_ctime":1583650284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583650284","product_id":100023901,"comment_content":"关于源头3-&gt;双重检查的那个问题，个人觉得有个东西我们不能给忽略了，那就是“static Singleton instance”的&quot;static&quot;,我觉得正是因为这个才导致了有序性的发生，如果去掉“static”应该就不会有有序性的问题了，在源头2-&gt;线程切换中，有个知识点是每个线程都有自己的寄存器，但寄存器实际上是共用的，A线程切换到B线程的时候，寄存器会把操作A的相关内容会保存到内存里，切换回来的时候，会从内存把内容加载到寄存器。可以理解为每个线程有自己的寄存器，所以，如果不是static,我觉得线程B也会重新构造一个instance变量出来的，正是因为static,所以线程B使用的instance变量是和线程A使用的是同一个。个人理解，不知对不对。","like_count":0},{"had_liked":false,"id":184117,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1583226690,"is_pvip":false,"replies":[{"id":"71258","content":"java8的lambda表达式","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1583234625,"ip_address":"","comment_id":184117,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1583226690","product_id":100023901,"comment_content":"请教下老师，这是什么意思，没看懂，<br>Thread th2 = new Thread(()-&gt;{ test.add10K(); });","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485892,"discussion_content":"java8的lambda表达式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583234625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195648,"discussion_content":"老师，这个表达式需要花时间学习么？以后用处大么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583294301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289904,"discussion_content":"学，必须得学，用处很大的，至少方便啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594263120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":195648,"ip_address":""},"score":289904,"extra":""}]}]},{"had_liked":false,"id":182939,"user_name":"bin.chen","can_delete":false,"product_type":"c1","uid":1135604,"ip_address":"","ucode":"5BA49358AB8A1A","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","comment_is_top":false,"comment_ctime":1582893349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582893349","product_id":100023901,"comment_content":"随着计算机的发展和强大，对于效率的需求就会越来越高，为了提高计算机处理效率<br>1.计算机增加了缓存---但是导致了在多核多线程的情况下数据一致性(可见性问题)<br>2.计算机多线程之间的切换充分利用资源--但是导致了切片过程中违反了原子性操作(原子性问题)<br>3.计算机为了编译效率的高校会有指令重排机制---但是导致了代码执行的顺序性(原子性问题)<br><br>对于上面的三个问题，如果让我们自己去解决是非常的复杂<br>而JAVA对于上述三个问题的处理就虚拟除了一个JAVA内存模型,通过使用某些关键字或者是工具包就能跨平台的解决上面因为提高性能带来的问题","like_count":0},{"had_liked":false,"id":182508,"user_name":"日拱一兵","can_delete":false,"product_type":"c1","uid":1437158,"ip_address":"","ucode":"D6386E5CD7C061","user_header":"https://static001.geekbang.org/account/avatar/00/15/ed/e6/75a32708.jpg","comment_is_top":false,"comment_ctime":1582798860,"is_pvip":false,"replies":[{"id":"70649","content":"我觉得是这样的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1582806277,"ip_address":"","comment_id":182508,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582798860","product_id":100023901,"comment_content":"即便count++ 的cpu指令是一个操作，也是有问题的，因为cpu缓存回写到内存的时间是不固定的对吧","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485360,"discussion_content":"我觉得是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582806277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179584,"user_name":"Geek_bb89c3","can_delete":false,"product_type":"c1","uid":1331828,"ip_address":"","ucode":"0F97B5B0F2DDD6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IZKGetBZDuMEa2VwwtesTELvLORIyV749ItgfAqNPv30n4zEv71wuGNr1aNVIVltG0icvH53DHDuqPuzNpiauWAg/132","comment_is_top":false,"comment_ctime":1582034727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582034727","product_id":100023901,"comment_content":"在并发编程的基础上，为了优化整个系统，对内存模型进行一个优化。优化了性能，同时带来了一些额外的问题。主要分为三个：<br>可见性：多核中，在每一个cpu内部都维护了一个缓存。当两个cpu核修改同一个变量的时候。这个时候会带来一个问题是某一个线程修改了，另外一个线程是不可见的，从而引起并发编程的bug。<br>原子性：在java这种高级语言上，一条语言在jvm底层的时候是多条指令。在jvm中任务调度的维度是根据jvm指令来调度的。这样就会带来状态的异常。<br>有序性：为了提高单挑cpu执行，编译器会对高级指令进行编译优化，使得编译后的指令更加适合cpu执行。但是这样可能会使同步错误。<br>","like_count":0},{"had_liked":false,"id":178058,"user_name":"褚","can_delete":false,"product_type":"c1","uid":1387363,"ip_address":"","ucode":"C2AA96A2E0F55F","user_header":"https://static001.geekbang.org/account/avatar/00/15/2b/63/ea02349c.jpg","comment_is_top":false,"comment_ctime":1581580154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581580154","product_id":100023901,"comment_content":"在 32 位的机器上对 int 型变量进行加减操作不存在并发隐患吗，比如可见性问题；","like_count":0},{"had_liked":false,"id":173534,"user_name":"怕什么，抱紧我","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"","ucode":"CBCEA76E9EF33B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","comment_is_top":false,"comment_ctime":1579591094,"is_pvip":true,"replies":[{"id":"67404","content":"可以这样简单理解，读可见性问题是读到了完整的旧值，读原子性是读到了部分旧值，部分新值。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579743732,"ip_address":"","comment_id":173534,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1579591094","product_id":100023901,"comment_content":"老师，总感觉“原子性”问题是“可见行”问题造成的啊😭","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482105,"discussion_content":"可以这样简单理解，读可见性问题是读到了完整的旧值，读原子性是读到了部分旧值，部分新值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579743732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318633,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/e9/dcc63d8f.jpg","nickname":"怕什么，抱紧我","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":146363,"discussion_content":"谁能帮我解答啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579609541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171951,"user_name":"Dave","can_delete":false,"product_type":"c1","uid":1501982,"ip_address":"","ucode":"BF683DAB4DEF02","user_header":"https://static001.geekbang.org/account/avatar/00/16/eb/1e/28c5557f.jpg","comment_is_top":false,"comment_ctime":1579057373,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1579057373","product_id":100023901,"comment_content":"老师我仔细分析了一下您可见性问题所举的例子，发现不太对。可见性问题主要发生在先写再读的情况。而您的add10()归根结底还是count不是原子操作所导致的。t1在从操作数栈写入内存前，t2就读到了count的初值是0了","like_count":0},{"had_liked":false,"id":169869,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1641319,"ip_address":"","ucode":"E1184E76B14431","user_header":"https://static001.geekbang.org/account/avatar/00/19/0b/67/dc49a1a8.jpg","comment_is_top":false,"comment_ctime":1578465644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578465644","product_id":100023901,"comment_content":"在可见性那里有个疑问想问一下老师。<br>如果两个线程是在同一个cpu上，那这两个线程操作的是相同的缓存吗？如果是的话，那是不是同一个cpu上的线程它们的之间都是可见的？因为操作的是同一个cpu上的缓存？","like_count":0},{"had_liked":false,"id":169521,"user_name":"我的腿腿","can_delete":false,"product_type":"c1","uid":1239277,"ip_address":"","ucode":"2AAA36A7C3AD75","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/ed/f9347e5e.jpg","comment_is_top":false,"comment_ctime":1578369116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578369116","product_id":100023901,"comment_content":"最近遇到线程问题，二刷，果然书不能只读一遍。","like_count":0},{"had_liked":false,"id":166275,"user_name":"xfun","can_delete":false,"product_type":"c1","uid":1070581,"ip_address":"","ucode":"A9A08E9EA6E13B","user_header":"https://static001.geekbang.org/account/avatar/00/10/55/f5/8d1588bd.jpg","comment_is_top":false,"comment_ctime":1577430511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577430511","product_id":100023901,"comment_content":"事实上，线程A并不需要释放锁。因为这个synchronized修饰的是方法里的代码块，这不是一个阻塞操作，所以B线程是可以正常运行的。这个时候可能A线程还未初始化实例，B线程已经运行到return了，返回了一个null。所以B线程都压根儿没得到锁，也不存在判断，不存在创建实例的过程。<br>根据这个例子要讲述的内容，是不是应该把synchronized加到getInstance方法上去？","like_count":0},{"had_liked":false,"id":165974,"user_name":"卖火柴的托儿索","can_delete":false,"product_type":"c1","uid":1451295,"ip_address":"","ucode":"A9C7412E75DA82","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/1f/8e304ec0.jpg","comment_is_top":false,"comment_ctime":1577353540,"is_pvip":false,"replies":[{"id":"63411","content":"无可奈何，那就随他去吧，别影响心情就好😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1577444941,"ip_address":"","comment_id":165974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577353540","product_id":100023901,"comment_content":"我发现有很多人照搬老师的文章并且发布为原创，老师，这都可以吗？<br>比如：https:&#47;&#47;blog.csdn.net&#47;qq_41936805&#47;article&#47;details&#47;99700977","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479337,"discussion_content":"无可奈何，那就随他去吧，别影响心情就好😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577444941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165314,"user_name":"阿U","can_delete":false,"product_type":"c1","uid":1171359,"ip_address":"","ucode":"161A8E74E0D612","user_header":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","comment_is_top":false,"comment_ctime":1577199127,"is_pvip":false,"replies":[{"id":"63028","content":"次数少，线程1没来的及启动，线程2早就跑完了，这个时候没有并行。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1577233452,"ip_address":"","comment_id":165314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577199127","product_id":100023901,"comment_content":"老师 第一个代码例子没明白 ，例子中是循环10000次，是个区间值，但是我循环次数n 比较少(1-100)这种情况，结果都是2n呢 。没理解","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479117,"discussion_content":"次数少，线程1没来的及启动，线程2早就跑完了，这个时候没有并行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577233452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164095,"user_name":"遥遥无妻","can_delete":false,"product_type":"c1","uid":1251243,"ip_address":"","ucode":"30A765B411D059","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/ab/c0235b70.jpg","comment_is_top":false,"comment_ctime":1576862003,"is_pvip":false,"replies":[{"id":"62399","content":"CPU指令是原子性的，只有执行完才会响应中断，做上下文切换","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1576909696,"ip_address":"","comment_id":164095,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576862003","product_id":100023901,"comment_content":"老师问一下，一条cpu指令没执行完毕，但是按照时间片调度，现在时间到了需要切换线程，没执行完指令的线程此时会发生切换吗，如果切换了那对于这条指令来说拿到了执行权限，这条指令是从头开始重新执行一次还是把指令剩余没完成的后半部分继续执行","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478640,"discussion_content":"CPU指令是原子性的，只有执行完才会响应中断，做上下文切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576909696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160586,"user_name":"〆、维生素ゝ","can_delete":false,"product_type":"c1","uid":1230071,"ip_address":"","ucode":"7A2AB5A26F0F49","user_header":"https://static001.geekbang.org/account/avatar/00/12/c4/f7/3cff78f1.jpg","comment_is_top":false,"comment_ctime":1575980369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575980369","product_id":100023901,"comment_content":"老师，关于数据可见性有一点不理解：理论上来说两个add10k分别写自己的cpu缓存，假设不涉及到共享这个变量值，最终这个count值应该是10000，因为在操作这个共享变量的值（读，写），所以才会出出现这个变量值大概率是在10000到20000之间，那按照这个思路什么时间节点cpu缓存会去读取内存呐？","like_count":0},{"had_liked":false,"id":160176,"user_name":"慌张而黑糖","can_delete":false,"product_type":"c1","uid":1638878,"ip_address":"","ucode":"B4416885A301C8","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","comment_is_top":false,"comment_ctime":1575885823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575885823","product_id":100023901,"comment_content":"感觉jialin和作者讲的情况好像不太一样，作者说的好像是第二个判断条件，而他讲的是第一个判断条件，感觉都有可能，不知道是我理解错了，还是怎么样","like_count":0},{"had_liked":false,"id":159777,"user_name":"dingsai88","can_delete":false,"product_type":"c1","uid":1029484,"ip_address":"","ucode":"A725428A983ADC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/6c/617c0193.jpg","comment_is_top":false,"comment_ctime":1575785910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575785910","product_id":100023901,"comment_content":"32系统上long类型变量的读写操作可以拆分为高低两个32位数的运算，所以不具有原子性。但Long就没有问题，因为Long是不可变类型","like_count":0},{"had_liked":false,"id":159318,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1575598499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575598499","product_id":100023901,"comment_content":"老师，原子操作那一段没有看太懂，非原子操作示意图是那个样子，那原子操作示意图是啥样的呢？","like_count":0},{"had_liked":false,"id":158201,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1575346248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575346248","product_id":100023901,"comment_content":"老师，可见性真的和CPU缓存有关系么？<br><br>public class Test {<br>  private long count = 0;<br>  private void add10K() {<br>   synchronized (this) {<br>    int idx = 0;<br>    while(idx++ &lt; 10000) {<br>      count += 1;<br>    }<br>  ｝<br>  }<br>  public static long calc() {<br>    final Test test = new Test();<br>    &#47;&#47; 创建两个线程，执行add()操作<br>    Thread th1 = new Thread(()-&gt;{<br>      test.add10K();<br>    });<br>    Thread th2 = new Thread(()-&gt;{<br>      test.add10K();<br>    });<br>    &#47;&#47; 启动两个线程<br>    th1.start();<br>    th2.start();<br>    &#47;&#47; 等待两个线程执行结束<br>    th1.join();<br>    th2.join();<br>    return count;<br>  }<br>}<br><br>这段代码加个同步不就行了吗？","like_count":0},{"had_liked":false,"id":157036,"user_name":"Khirye","can_delete":false,"product_type":"c1","uid":1080985,"ip_address":"","ucode":"6C54C126FA54B8","user_header":"https://static001.geekbang.org/account/avatar/00/10/7e/99/c4302030.jpg","comment_is_top":false,"comment_ctime":1575016324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575016324","product_id":100023901,"comment_content":"有什么方法可以复现一下双重检查产生的问题吗？我通过JCStress工具写的测试代码也复现不了。这是我在stackoverflow上写的问题https:&#47;&#47;stackoverflow.com&#47;questions&#47;59098240&#47;jcstress-on-singleton-test-failing，烦请解惑！谢谢🙏","like_count":0},{"had_liked":false,"id":154348,"user_name":"爽了个爽","can_delete":false,"product_type":"c1","uid":1261326,"ip_address":"","ucode":"D5B10F75A02AB1","user_header":"https://static001.geekbang.org/account/avatar/00/13/3f/0e/3a2fb9ff.jpg","comment_is_top":false,"comment_ctime":1574412767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574412767","product_id":100023901,"comment_content":"修改了一下别人的答案。我觉得应该是这样的。<br>正常执行顺序1-2-3,但是CPU重排序后执行顺序可能为1-3-2，那么问题就来了<br>步骤如下：<br>1. A线程同时进入了第一个if判断<br>2. A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();<br>3. 然后线程A执行1-&gt; JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance<br>4. 在还没有进行第三步（将instance引用指向内存空间）的时候，线程进行了切换。此时锁未释放。<br>5. 切换到b线程。分两种情况。<br><br>第一种 b线程已经进入第一个synchronized，它还是没有锁，它会一直等到切换回a，并且结束对象的创建。最终b线程也正常执行。<br><br>第二种就有问题了。b线程还没有进行第一个if。这个时候install已经有值，但是还没有初始化。第一个if直接false，返回一个没有初始化的install。","like_count":0},{"had_liked":false,"id":152880,"user_name":"August","can_delete":false,"product_type":"c1","uid":1366394,"ip_address":"","ucode":"5311BAFAACB02C","user_header":"https://static001.geekbang.org/account/avatar/00/14/d9/7a/7d3f792c.jpg","comment_is_top":false,"comment_ctime":1574094912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574094912","product_id":100023901,"comment_content":"双重检验那里，操作系统为什么不让拿到锁的线程执行完，而要做cpu指令切换，其他线程抢不到锁，还是得原来拿到锁的线程继续执行","like_count":0},{"had_liked":false,"id":151004,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1573641454,"is_pvip":false,"replies":[{"id":"58161","content":"进程切换比线程切换要复杂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573654312,"ip_address":"","comment_id":151004,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573641454","product_id":100023901,"comment_content":"老师，你的这个线程切换示意图应该叫做进程切换示意图更贴切吧&gt;o&lt;<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474337,"discussion_content":"进程切换比线程切换要复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573654312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150130,"user_name":"追逐繁星的孩纸~","can_delete":false,"product_type":"c1","uid":1593884,"ip_address":"","ucode":"69DC37A9E39C7E","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/1c/e902de0f.jpg","comment_is_top":false,"comment_ctime":1573465704,"is_pvip":true,"replies":[{"id":"57778","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573475800,"ip_address":"","comment_id":150130,"utype":1}],"discussion_count":1,"race_medal":4,"score":"1573465704","product_id":100023901,"comment_content":"至少涉及到原子性问题。long型变量是64位的，在32位机器中，将其分为高位操作和低位操作，这两个操作不是原子性的，因此在多个线程对同一个long型变量进行操作时，就可能出现线程A写完高位后，线程B写了高位和低位，然后线程A又写了低位，这样这个long型的高位就是线程B写的，低位是线程A写的。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474072,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573475800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148443,"user_name":"朕爱吾妃","can_delete":false,"product_type":"c1","uid":1733692,"ip_address":"","ucode":"B10EB69934F9E2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/74/3c/da79d2a1.jpg","comment_is_top":false,"comment_ctime":1573007895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573007895","product_id":100023901,"comment_content":"对于阿根一世的问题，锁住的对象是类对象，而不是实例对象，所以，如果执行顺序是1-3-2，还没有给M赋予初始值的情况下，访问这个实例对象，这个对象是真实存在的，所以，instance == null 返回是false，所以就会出现nullpointException异常问题","like_count":0},{"had_liked":false,"id":147154,"user_name":"赵小丽","can_delete":false,"product_type":"c1","uid":1519306,"ip_address":"","ucode":"19ADE75E46F89D","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/ca/71c8a4e5.jpg","comment_is_top":false,"comment_ctime":1572828134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572828134","product_id":100023901,"comment_content":"请问~这里面原子性举得例子，根本原因也应该是可见性问题吧？","like_count":0},{"had_liked":false,"id":147031,"user_name":"Alpha 👀","can_delete":false,"product_type":"c1","uid":1200971,"ip_address":"","ucode":"3C0BAD36550718","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/4b/28991f30.jpg","comment_is_top":false,"comment_ctime":1572768689,"is_pvip":false,"replies":[{"id":"56809","content":"不是","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1572827596,"ip_address":"","comment_id":147031,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572768689","product_id":100023901,"comment_content":"循环 10000 次 count+=1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。<br><br>老师，请问下这句话怎么理解，为什么1亿和1万的循环效果不一样？cup的缓存什么时候刷新到内存，是线程切换的时候吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473103,"discussion_content":"不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572827596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200971,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/4b/28991f30.jpg","nickname":"Alpha 👀","note":"","ucode":"3C0BAD36550718","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42919,"discussion_content":"老师，那1亿次和1w次循环结果不一样怎么理解，求解惑\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572827784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144641,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1571988450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571988450","product_id":100023901,"comment_content":"编译器优化指令顺序，并不是为了缓存的有效利用，目的是：处理器采用流水线可以并发执行多条指令","like_count":0},{"had_liked":false,"id":143966,"user_name":"Athena","can_delete":false,"product_type":"c1","uid":1369754,"ip_address":"","ucode":"1183247AE864AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/e6/9a/d0725a24.jpg","comment_is_top":false,"comment_ctime":1571816563,"is_pvip":false,"replies":[{"id":"55673","content":"古老的C曾经是这样吧？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571919566,"ip_address":"","comment_id":143966,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571816563","product_id":100023901,"comment_content":"32位机器 long的长度不是只有 32位吗？怎么有些小伙伴们说是64位？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471764,"discussion_content":"古老的C曾经是这样吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571919566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143684,"user_name":"归零","can_delete":false,"product_type":"c1","uid":1103208,"ip_address":"","ucode":"C99B8E93009A46","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/68/2201b6b9.jpg","comment_is_top":false,"comment_ctime":1571756007,"is_pvip":true,"replies":[{"id":"55524","content":"线程之间，线程是最小的调度单位","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571802872,"ip_address":"","comment_id":143684,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571756007","product_id":100023901,"comment_content":" 老师好，有个问题请教一下，对于第二个源头：原子性，我理解，上下文切换指的是多进程之间为了提高效率，cpu通过时间片切换；而同一个进程内的多线程会对共享变量安全产生威胁。所以所谓的原子性是在进程之间呢？还是线程之间？谢谢！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471651,"discussion_content":"线程之间，线程是最小的调度单位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571802872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141989,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1571276341,"is_pvip":true,"replies":[{"id":"54818","content":"不是一回事","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571284620,"ip_address":"","comment_id":141989,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571276341","product_id":100023901,"comment_content":"老师，明确一个概念，cpu 寄存器和 cpu 缓存不是一回事把？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470947,"discussion_content":"不是一回事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571284620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141469,"user_name":"sdrunk","can_delete":false,"product_type":"c1","uid":1609426,"ip_address":"","ucode":"7197F0AF3CF8F8","user_header":"https://static001.geekbang.org/account/avatar/00/18/8e/d2/31208c2d.jpg","comment_is_top":false,"comment_ctime":1571163164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571163164","product_id":100023901,"comment_content":"并发bBug;;;;缓存-可见性 线程-一致性  编译（变异-顺序","like_count":0},{"had_liked":false,"id":140950,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1571098573,"is_pvip":false,"replies":[{"id":"54569","content":"时间片内主动释放CPU使用权，无需等到结束","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571113244,"ip_address":"","comment_id":140950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571098573","product_id":100023901,"comment_content":"在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。<br>王老师，这个标记为休眠状态，并让出CPU是在一个时间片结束的时候，还是在一个时间片内呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470630,"discussion_content":"时间片内主动释放CPU使用权，无需等到结束","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571113244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139333,"user_name":"退役的球童","can_delete":false,"product_type":"c1","uid":1196234,"ip_address":"","ucode":"CD5157830D9606","user_header":"https://static001.geekbang.org/account/avatar/00/12/40/ca/1313a90b.jpg","comment_is_top":false,"comment_ctime":1570613456,"is_pvip":false,"replies":[{"id":"53716","content":"不会重排主要是因为volatile相关的规则","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570622958,"ip_address":"","comment_id":139333,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570613456","product_id":100023901,"comment_content":"老师及各位同学你们好！<br><br>有关文中的示例代码我有一些疑问，请大家赐教。<br><br>之前有讲过编译器优化会带来有序性问题，请问下writer方法中 x = 42 和 v = true 为什么不会发生指令重排？<br><br>比如先后顺序发生改变，即先执行 v = true，再执行 x = 42。因为这两行代码本身是没有逻辑因果关系的，重排也并不会导致串行逻辑语义被破坏。如果重排，那其他的线程在执行reader方法时x就不一定是42了。<br><br>如果不会发生重排，是不是就是因为Happens-Before中的程序的顺序性规则？<br><br>但我之前看过的资料说的顺序性规则表达的是串行逻辑语义不能被破坏（如 a = 2; b = a + 1; 此时b依赖于a的结果，因此要保证顺序性），但这里显然并没有该问题。<br><br>希望给予解释，谢谢<br><br>&#47;&#47; 以下代码来源于【参考 1】<br>class VolatileExample {<br>  int x = 0;<br>  volatile boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      &#47;&#47; 这里 x 会是多少呢？<br>    }<br>  }<br>}<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469897,"discussion_content":"不会重排主要是因为volatile相关的规则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570622958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137106,"user_name":"245864982","can_delete":false,"product_type":"c1","uid":1238485,"ip_address":"","ucode":"AC47075A95B759","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/d5/680402fd.jpg","comment_is_top":false,"comment_ctime":1569606667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569606667","product_id":100023901,"comment_content":"打卡3","like_count":0},{"had_liked":false,"id":136401,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1569423698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569423698","product_id":100023901,"comment_content":"我觉得任大鹏同学的解释很准确，如果真的出现了阿根一世描述的情况，是不可能出现返回值为null问题的","like_count":0},{"had_liked":false,"id":135501,"user_name":"zhangyi","can_delete":false,"product_type":"c1","uid":1507024,"ip_address":"","ucode":"0C4CAE9DA878F3","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/d0/e80e4a7e.jpg","comment_is_top":false,"comment_ctime":1569199565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569199565","product_id":100023901,"comment_content":"双重检查锁竟然有问题！长见识了","like_count":0},{"had_liked":false,"id":134295,"user_name":"邢宇超","can_delete":false,"product_type":"c1","uid":1105246,"ip_address":"","ucode":"3113F55E60ADE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/5e/ddbdde5a.jpg","comment_is_top":false,"comment_ctime":1568796623,"is_pvip":false,"replies":[{"id":"51489","content":"合法的手段好像没有😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568806227,"ip_address":"","comment_id":134295,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568796623","product_id":100023901,"comment_content":"老师，我想打印出来看  但是我看复制不出来  有啥办法不","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467694,"discussion_content":"合法的手段好像没有😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568806227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132719,"user_name":"李青","can_delete":false,"product_type":"c1","uid":1074564,"ip_address":"","ucode":"30E2CB7F3EFC14","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/84/5515dde0.jpg","comment_is_top":false,"comment_ctime":1568201937,"is_pvip":false,"replies":[{"id":"50890","content":"不确定，如果需要确定，就需要使用同步手段","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568257775,"ip_address":"","comment_id":132719,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568201937","product_id":100023901,"comment_content":"老师，如果我开启一个线程，让它把共享资源里面的a变量从0+1+2...........1亿，它是何时把a的值刷新到内存中的？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467086,"discussion_content":"不确定，如果需要确定，就需要使用同步手段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568257775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126964,"user_name":"Thong2018","can_delete":false,"product_type":"c1","uid":1625515,"ip_address":"","ucode":"DA05A3B08D1DEA","user_header":"","comment_is_top":false,"comment_ctime":1566526454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566526454","product_id":100023901,"comment_content":"对象和锁是什么关系？线程进入synchronized代码块时，线程拿的是谁的锁？锁又是在锁什么东西呢？","like_count":0},{"had_liked":false,"id":126953,"user_name":"Thong2018","can_delete":false,"product_type":"c1","uid":1625515,"ip_address":"","ucode":"DA05A3B08D1DEA","user_header":"","comment_is_top":false,"comment_ctime":1566525396,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566525396","product_id":100023901,"comment_content":"synchronized不是可以保证原子性吗？为什么将instance引用指向内存空间的时候，线程A会离开synchronized块呢？线程A不是应该将synchronized块执行完结束之后再离开吗？","like_count":0,"discussions":[{"author":{"id":1541329,"avatar":"","nickname":"Geek_2bdf1f","note":"","ucode":"F367031D6592D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18060,"discussion_content":"不是线程离开，是cpu 时间片离开","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568998144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126278,"user_name":"再不吃胖我们就老了","can_delete":false,"product_type":"c1","uid":1017981,"ip_address":"","ucode":"63E9E9556B364F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/7d/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1566356551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566356551","product_id":100023901,"comment_content":"其实在可见性和原子性的例子上，几乎是一个意思。原子性这个例子里面本身也有可见性的问题，源头都是计算时数据保存在CPU缓存。只不过原子性问题将一句代码进行了进一步的拆分。","like_count":0},{"had_liked":false,"id":124308,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1565857434,"is_pvip":false,"replies":[{"id":"45661","content":"火眼金睛👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1565878684,"ip_address":"","comment_id":124308,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565857434","product_id":100023901,"comment_content":"<br>老师，计算机体系机构应该为计算机体系结构吧？哈哈<br><br><br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463109,"discussion_content":"火眼金睛👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565878684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123710,"user_name":"王二宝","can_delete":false,"product_type":"c1","uid":1042241,"ip_address":"","ucode":"E147D6E597EF5B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/41/2ea1f5dc.jpg","comment_is_top":false,"comment_ctime":1565746000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565746000","product_id":100023901,"comment_content":"缓存导致可见性问题，线程切换带来原子性问题，编译优化带来有序性问题，其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。","like_count":0},{"had_liked":false,"id":123355,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1565661153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565661153","product_id":100023901,"comment_content":"java设计的时候为什么不设计成对象完全初始化后再进行赋值操作呢？","like_count":0},{"had_liked":false,"id":122302,"user_name":"有态度的","can_delete":false,"product_type":"c1","uid":1274219,"ip_address":"","ucode":"2479D747B01684","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/6b/14ba2eb1.jpg","comment_is_top":false,"comment_ctime":1565335178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565335178","product_id":100023901,"comment_content":"Test calc()  是不是有问题","like_count":0},{"had_liked":false,"id":121829,"user_name":"MaO","can_delete":false,"product_type":"c1","uid":1083238,"ip_address":"","ucode":"3D839733E87435","user_header":"https://static001.geekbang.org/account/avatar/00/10/87/66/31629628.jpg","comment_is_top":false,"comment_ctime":1565230315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565230315","product_id":100023901,"comment_content":"线程切换和锁的管理是独立的，在锁的边界没有到达之前，锁是不会释放的。","like_count":0},{"had_liked":false,"id":115357,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1563541507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563541507","product_id":100023901,"comment_content":"---先做一下总结和延伸---<br>并发编程出现的原因：提高资源利用率。如CPU执行指令时遇到I&#47;O请求而阻塞时保证当前CPU不空置，如多核CPU能充分利用多个CPU核心并行执行程序。<br>并发程序中会遇到的三大问题：<br>1.多核CPU导致的可见性问题<br>核心原因是各CPU核心有各自的缓存，单个缓存和内存间的一致性由于缓存写策略的不同是无法保证的，即使采用write-through强制写回内存另一个CPU的缓存也是无法感应的，即无法保证缓存间的一致性。<br>JAVA中轻量级的解决方式是volitale关键字解决，其可以保证当前共享变量强制写入内存且让各CPU缓存中的缓存行失效。<br>2.线程切换导致的原子性问题<br>核心原因是在不施加外部控制下一条CPU指令才是原子的一个操作，而许多高级语言中的一条语句对应着多条CPU指令。<br>JAVA中轻量级的解决方式是CAS等原子性操作，其对应到操作系统中的一条CPU指令。<br>3.编译优化带来的有序性问题<br>核心原因是编译器为了优化性能（如提高缓存命中率）而在不影响程序最终结果的前提下调整了语句顺序，而其保证的往往只是单线程语义不改变。<br>JAVA中的volitale也可以控制指令重排序。<br>---存在的问题---<br>老师例子中给出的程序执行结果应该是2~20000次之间，下面分析下2是如何得出的：<br>1.thread1执行指令1，读取count（0）到寄存器<br>2.thread2执行指令1，读取count（0）到寄存器<br>3.thread1优先级非常高，一直执行多次到内存count写为9999<br>4.thread2执行指令2和3，将count+1后写回内存，此时内存中count为1<br>5.thread1再次执行指令1，读取count（1）到寄存器<br>6.thread2此时优先级也非常高，一直执行多次到内存count写为9999<br>7.thread1执行指令2和3，将count+1后写回内存，此时内存中count为2","like_count":0},{"had_liked":false,"id":114998,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1563446795,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1563446795","product_id":100023901,"comment_content":"&quot;编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。&quot;   为什么这么说？","like_count":0,"discussions":[{"author":{"id":1369077,"avatar":"","nickname":"陈善飞","note":"","ucode":"18A6FFDE0809F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5339,"discussion_content":"编译程序优化指令执行次序，其实是为了使得cpu能以流水线的形式执行指令，尽量在每个时间分片内不空闲，提高cpu运行效率。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566191405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114237,"user_name":"unanao","can_delete":false,"product_type":"c1","uid":1510485,"ip_address":"","ucode":"8F81ECF05D420C","user_header":"http://thirdwx.qlogo.cn/mmopen/ajNVdqHZLLAZUMxZDXiaVdiaEq6wK8XMBBXiaA6icoQykatgybzeqicLUv3420cCPqONmTwTZBydJG5V1TiamIyeiaTxw/132","comment_is_top":false,"comment_ctime":1563259376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563259376","product_id":100023901,"comment_content":"加上volatile保证可见性，解决双重检查时，第二个线程可能访问未初始化的instance。<br>volatile static Singleton instance。<br>","like_count":0},{"had_liked":false,"id":113828,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1308828,"ip_address":"","ucode":"F17F60D69308A5","user_header":"https://static001.geekbang.org/account/avatar/00/13/f8/9c/0eb80f20.jpg","comment_is_top":false,"comment_ctime":1563165044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563165044","product_id":100023901,"comment_content":"package cn.ipanda;<br>public class Test {<br>    static Test instance;<br>    static Test getInstance(){<br>        if (instance == null) {<br>            synchronized(Test.class) {<br>                if (instance == null)<br>                    instance = new Test();<br>            }<br>        }<br>        return instance;<br>    }<br>    private long count = 0;<br>    private void add10K() {<br>        int idx = 0;<br>        while(idx++ &lt; 1000000000) {<br>            count += 1;<br>        }<br>    }<br>    public static long calc() throws InterruptedException {<br>        final Test test = new Test();<br>        &#47;&#47; 创建两个线程，执行 add() 操作<br>        Thread th1 = new Thread(()-&gt;{<br>            test.add10K();<br>        });<br>        Thread th2 = new Thread(()-&gt;{<br>            test.add10K();<br>        });<br>        &#47;&#47; 启动两个线程<br>        th1.start();<br>        th2.start();<br>        &#47;&#47; 等待两个线程执行结束<br>        th1.join();<br>        th2.join();<br>        return test.count;<br>    }<br>}<br>这样写的吗老师请问！<br><br>package cn.ipanda;<br>public class Test1 {<br>    public static void main(String[] args) throws Exception {<br>        Test test=new Test();<br>        System.out.println(test.calc());<br>    }<br>}<br><br><br>","like_count":0},{"had_liked":false,"id":113825,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1308828,"ip_address":"","ucode":"F17F60D69308A5","user_header":"https://static001.geekbang.org/account/avatar/00/13/f8/9c/0eb80f20.jpg","comment_is_top":false,"comment_ctime":1563164745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563164745","product_id":100023901,"comment_content":"return count;请问老师这个不用改成这样吗？return test.count;！静态方法访问私有类成员！","like_count":0},{"had_liked":false,"id":113548,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1563075137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563075137","product_id":100023901,"comment_content":"count是不是要定义为static，不然在静态方法里没法return","like_count":0},{"had_liked":false,"id":111537,"user_name":"邢宇超","can_delete":false,"product_type":"c1","uid":1105246,"ip_address":"","ucode":"3113F55E60ADE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/5e/ddbdde5a.jpg","comment_is_top":false,"comment_ctime":1562565191,"is_pvip":false,"replies":[{"id":"40628","content":"这一篇没有调整过","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562590152,"ip_address":"","comment_id":111537,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562565191","product_id":100023901,"comment_content":"老师你文章是不是调整过   我看下面评论的同学有几个点和你文章描述不一致   我怕被下面的同学带到沟里","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457372,"discussion_content":"这一篇没有调整过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562590152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110047,"user_name":"沙漠胖胖树","can_delete":false,"product_type":"c1","uid":1592045,"ip_address":"","ucode":"FC352122E6BA1E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoKiaUID2xruIcHdtdT7vsx8tsVRIjTx4ZpxNP8RYibnJ0AVcU4DRUibBQwkHeovr7NSDUoib16sg5IWQ/132","comment_is_top":false,"comment_ctime":1562159899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562159899","product_id":100023901,"comment_content":"对这个双重检查锁一直有个疑问. 不是synchronized可以保证原子性么?锁还没释放, 其它线程怎么看到的这个还没有构造完成的对象?看到了这个对象, 不就是说明没保证原子性?","like_count":0},{"had_liked":false,"id":107020,"user_name":"。。","can_delete":false,"product_type":"c1","uid":1034922,"ip_address":"","ucode":"E75F20D89106B5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ca/aa/2ce2bdce.jpg","comment_is_top":false,"comment_ctime":1561439747,"is_pvip":true,"replies":[{"id":"38766","content":"写的是bug吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561465493,"ip_address":"","comment_id":107020,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561439747","product_id":100023901,"comment_content":"老师，我的跑出来是0，连续运行10次都是0，哈哈哈","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455330,"discussion_content":"写的是bug吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561465493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103245,"user_name":"古夜","can_delete":false,"product_type":"c1","uid":1341612,"ip_address":"","ucode":"0A82D3CFCEDF07","user_header":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","comment_is_top":false,"comment_ctime":1560403464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560403464","product_id":100023901,"comment_content":"评论区很精彩啊，值了。<br>另外老师是不是对文章进行过修改啊，看评论里Bithe和文章的内容对不上了似乎","like_count":0},{"had_liked":false,"id":102261,"user_name":"flory","can_delete":false,"product_type":"c1","uid":1044638,"ip_address":"","ucode":"179BAAC6980599","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f0/9e/b81eb4c0.jpg","comment_is_top":false,"comment_ctime":1560171507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560171507","product_id":100023901,"comment_content":"final在并发编程中的作用，一直没搞清楚，老师能详细讲讲吗？","like_count":0},{"had_liked":false,"id":99255,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1559182633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559182633","product_id":100023901,"comment_content":"嘎嘎的说法是不是和Blithe的说法有矛盾？若未出现指令重排序，线程A在在将初始化完成的内存区域赋值给instance时时间片切换，线程B依旧会判断到对象为空，进入加锁，然后也进行new操作，这样子是不是就没发生问题了？","like_count":0},{"had_liked":false,"id":97744,"user_name":"史月Shi Yue","can_delete":false,"product_type":"c1","uid":1071252,"ip_address":"","ucode":"83DF94258CB92F","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/94/e83d3e91.jpg","comment_is_top":false,"comment_ctime":1558761868,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558761868","product_id":100023901,"comment_content":"代码里的count要static修饰吧","like_count":0},{"had_liked":false,"id":95791,"user_name":"song","can_delete":false,"product_type":"c1","uid":1145335,"ip_address":"","ucode":"27A1C28F6D29D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/f7/bb17421c.jpg","comment_is_top":false,"comment_ctime":1558177840,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1558177840","product_id":100023901,"comment_content":"老师，您好，为什么例子的运行结果一定不会大于10000？<br>难道一定不会出现这样的情况：线程1先执行，线程2后执行，线程2把缓存中较小的count写入内存，然后线程1从内存中读出较小的count开始后续计算，最终导致结果小于10000.<br>期待您的回复","like_count":0,"discussions":[{"author":{"id":1105246,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/5e/ddbdde5a.jpg","nickname":"邢宇超","note":"","ucode":"3113F55E60ADE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1010,"discussion_content":"我来帮你猜一下   线程1先执行，线程2后执行，线程2把缓存中较小的count写入内存，但是线程1不从内存中读了，因为线程1的cpu缓存中有值，而且已经同步给内存了，cpu1就认为它这个值就是最新的，和内存中是一致的，然后继续对这个值++操作，在同步给内存，但是线程2又不是傻子   不会等到线程1都执行到9999了才去执行  所以这个值这样看不会小于10000，如果这个线程2真是个傻子 等到线程1都执行完了，线程2先读到count=0,然后等线程1再把执行完的结果10000同步到内存，线程2再去给他覆盖，从1开始覆盖  这样结果也不会小于10000，你纠结啥呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562232253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95707,"user_name":"Sam","can_delete":false,"product_type":"c1","uid":1183165,"ip_address":"","ucode":"701948553DB5FE","user_header":"https://static001.geekbang.org/account/avatar/00/12/0d/bd/57ab02f5.jpg","comment_is_top":false,"comment_ctime":1558146259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558146259","product_id":100023901,"comment_content":"深入浅出，没有操作系统这样基础课程的小白也能理解，赞！","like_count":0},{"had_liked":false,"id":95631,"user_name":"今夜秋风和","can_delete":false,"product_type":"c1","uid":1434066,"ip_address":"","ucode":"453C8197FFC81D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","comment_is_top":false,"comment_ctime":1558105917,"is_pvip":false,"replies":[{"id":"34217","content":"如果指令有写操作r=1，执行完就会写主存，但是其他核C2里可能已经缓存了r=0，r=1并不会立刻反映到C2里，通俗地说是C2看不到r的变化。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558143419,"ip_address":"","comment_id":95631,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558105917","product_id":100023901,"comment_content":"老师，您好，有几个问题想请教下您<br>1.cpu在执行一个原子性的指令的时，完成后是才会写cpu缓存，cpu缓存什么时候会写主存?<br>2cpu和内存的交互具体是怎么同步的?假如内存更新了，另一个线程在另一个cpu上执行，cpu怎么加拿大值的更新过程？<br>3编译器能为我们优化到什么程度，人为的意义的思考执行过程，怎么确定编译器的执行过程?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450538,"discussion_content":"如果指令有写操作r=1，执行完就会写主存，但是其他核C2里可能已经缓存了r=0，r=1并不会立刻反映到C2里，通俗地说是C2看不到r的变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558143419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95305,"user_name":"josancpp","can_delete":false,"product_type":"c1","uid":1533266,"ip_address":"","ucode":"0CDC39B3E716A3","user_header":"https://static001.geekbang.org/account/avatar/00/17/65/52/07c09c7f.jpg","comment_is_top":false,"comment_ctime":1558014217,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558014217","product_id":100023901,"comment_content":"xx鼠说，改为final欠妥，改为final，整个程序都没啥意义了。","like_count":0},{"had_liked":false,"id":95301,"user_name":"josancpp","can_delete":false,"product_type":"c1","uid":1533266,"ip_address":"","ucode":"0CDC39B3E716A3","user_header":"https://static001.geekbang.org/account/avatar/00/17/65/52/07c09c7f.jpg","comment_is_top":false,"comment_ctime":1558013804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558013804","product_id":100023901,"comment_content":"Blithe回答的很好，但出现的错误不是NPE错误，而不是使用了未初始化的空间","like_count":0},{"had_liked":false,"id":95123,"user_name":"LAMBO","can_delete":false,"product_type":"c1","uid":1214041,"ip_address":"","ucode":"10EDE0FC134FA8","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/59/e8f58a2a.jpg","comment_is_top":false,"comment_ctime":1557971163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557971163","product_id":100023901,"comment_content":"Java操作的不是内存里的数据吗？<br>也会去操作CPU或IO设备里的数据？<br>又颠覆了我对Java的认识。<br>可有Java读取内存、CPU、IO设备的讲解文章分享？谢谢大神","like_count":0},{"had_liked":false,"id":94850,"user_name":"Marvin","can_delete":false,"product_type":"c1","uid":1442337,"ip_address":"","ucode":"058F6AC5729DAC","user_header":"","comment_is_top":false,"comment_ctime":1557910043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557910043","product_id":100023901,"comment_content":"@jialin，看了你的留言，有一点没有明白，线程A改变完缓存中变量得值，会强制刷新到内存，如果这时切换到线程B，B已经读取过该变量的值到cpu缓存中，此时应该做+1操作，这时也会强制在内存中读取一下该变量么？","like_count":0},{"had_liked":false,"id":93325,"user_name":"新的起点，新的开始^_^","can_delete":false,"product_type":"c1","uid":1262068,"ip_address":"","ucode":"9C0810F472AC93","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/f4/5df17eff.jpg","comment_is_top":false,"comment_ctime":1557452693,"is_pvip":false,"replies":[{"id":"33508","content":"是的，单核CPU没有可见性问题，但是有原子性问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557643967,"ip_address":"","comment_id":93325,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557452693","product_id":100023901,"comment_content":"老师，那单核CPU的机器运行两个线程A和B，都是对共享变量初始值count==0，逻辑count+=1的操作，如果A先执行，根据可见性，B在执行操作前肯定读取到了count=1了，那执行完B之后，最后的值肯定会是2，但根据后面的原子性，A和B都会分别执行CPU指令1，2，3；在线程切换时也可能会出问题，所以我认为单核两线程的机器执行上面的逻辑，最后的结果可能是1也可能是2的对吗？请见谅，我的理解能力太差，对线程这块太欠缺。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449584,"discussion_content":"是的，单核CPU没有可见性问题，但是有原子性问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557643967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93073,"user_name":"新的起点，新的开始^_^","can_delete":false,"product_type":"c1","uid":1262068,"ip_address":"","ucode":"9C0810F472AC93","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/f4/5df17eff.jpg","comment_is_top":false,"comment_ctime":1557390592,"is_pvip":false,"replies":[{"id":"33206","content":"不会","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557411446,"ip_address":"","comment_id":93073,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557390592","product_id":100023901,"comment_content":"王老师，CPU执行完A线程java语言表达式的某个CPU指令后，发生线程切换，去执行B线程，会导致释放锁吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449480,"discussion_content":"不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557411446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93061,"user_name":"新的起点，新的开始^_^","can_delete":false,"product_type":"c1","uid":1262068,"ip_address":"","ucode":"9C0810F472AC93","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/f4/5df17eff.jpg","comment_is_top":false,"comment_ctime":1557387283,"is_pvip":false,"replies":[{"id":"33207","content":"单核不存在可见性问题，原子性问题还是有的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557411552,"ip_address":"","comment_id":93061,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557387283","product_id":100023901,"comment_content":"王老师你好，我这里有个疑问<br>count += 1，至少需要三条 CPU 指令。<br>CPU能保证的原子性是CPU指令级别的，在源头二那个例子中，在单核上运行两个线程，最后count的结果可能是1对吧，然后我又想到了源头1的上面的描述：<br>在单核时代，所有的线程都是在一颗 CPU 上执行，A线程对内存中count的操作对于B线程来说是可见的，所以不会出问题，但是您在讲CPU指令原子性问题的时候这不是出问题了吗<br><br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449476,"discussion_content":"单核不存在可见性问题，原子性问题还是有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557411552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92892,"user_name":"奔跑的蜗牛","can_delete":false,"product_type":"c1","uid":1384698,"ip_address":"","ucode":"C5277C80B423A0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6Nic6V6iawbbIF1RRbRlwNmC0Cmt3LlQRAiaiayCibpplSDPXticVyOp97CEypEuQm2Iib7ZYCjrrlIgWQ/132","comment_is_top":false,"comment_ctime":1557362553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557362553","product_id":100023901,"comment_content":"有个疑问就是A线程未完成instance指向内存，是否会释放锁呢？如果没释放，B线程就无法进入同步块中","like_count":0},{"had_liked":false,"id":91903,"user_name":"姚毛毛","can_delete":false,"product_type":"c1","uid":1145871,"ip_address":"","ucode":"24F189AAA50ECD","user_header":"https://static001.geekbang.org/account/avatar/00/11/7c/0f/58142505.jpg","comment_is_top":false,"comment_ctime":1557131908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557131908","product_id":100023901,"comment_content":"19995<br>19996<br>19997<br>19998<br>19999<br>20000<br>count:20000<br><br>为什么同样的代码，我得到的是顺序的结果？","like_count":0},{"had_liked":false,"id":90380,"user_name":"steventang","can_delete":false,"product_type":"c1","uid":1251638,"ip_address":"","ucode":"E3D89FDFC3499D","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/36/95246ba9.jpg","comment_is_top":false,"comment_ctime":1556503401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556503401","product_id":100023901,"comment_content":"课后思考讨论的场景应该都是 共享的临界区域吧","like_count":0},{"had_liked":false,"id":89850,"user_name":"melon-skin","can_delete":false,"product_type":"c1","uid":1073938,"ip_address":"","ucode":"BCAA30C66C1B15","user_header":"https://static001.geekbang.org/account/avatar/00/10/63/12/af32e9d4.jpg","comment_is_top":false,"comment_ctime":1556282743,"is_pvip":false,"replies":[{"id":"32367","content":"单核cpu没有缓存可见性的问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556500250,"ip_address":"","comment_id":89850,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556282743","product_id":100023901,"comment_content":"那么缓存造成的可见性问题是多核cpu并行造成的 单核cpu 的并发是不会有缓存可见性的问题的？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448289,"discussion_content":"单核cpu没有缓存可见性的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556500250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89567,"user_name":"胡小禾","can_delete":false,"product_type":"c1","uid":1132315,"ip_address":"","ucode":"1C23B7492C0C9E","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/1b/64262861.jpg","comment_is_top":false,"comment_ctime":1556208087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556208087","product_id":100023901,"comment_content":"public class Singleton<br>{<br>    private volatile static Singleton singleton = null;<br>    private Singleton()  {    }<br>    public static Singleton getInstance()   {<br>        if (singleton== null)  {<br>            synchronized (Singleton.class) {<br>                if (singleton== null)  {<br>                    singleton= new Singleton();<br>                }<br>            }<br>        }<br>        return singleton;<br>    }<br>}<br><br>对于 singleton= new Singleton() ，实际是三个操作<br>1、分配一块内存 M<br>2、在内存 M 上初始化 Singleton 对象<br>3、然后 M 的地址赋值给 instance 变量<br><br>那是不是说使用 volatile 修饰 Singleton 后就保证<br>一定按 1 --&gt; 2 --&gt; 3 的顺序来执行？<br>那么岂不是 volatile 保证了这个操作的原子性？<br>但是volatile应该是不能保证操作的原子性的啊？<br><br>求解！<br><br>","like_count":0},{"had_liked":false,"id":89495,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1556185786,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556185786","product_id":100023901,"comment_content":"请问对于双重检查的优化,使用静态内部类的方法吗?","like_count":0},{"had_liked":false,"id":88230,"user_name":"劉小强","can_delete":false,"product_type":"c1","uid":1178474,"ip_address":"","ucode":"07FC2F0CDED869","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/6a/be4956a3.jpg","comment_is_top":false,"comment_ctime":1555897232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555897232","product_id":100023901,"comment_content":"@嘎嘎   将对象设置成volatile，在new 的时候可以防止指令重排 也就不会在第一个判断空的时候返回没有初始化的对象了啊  在加上锁肯定是没问题的啊   你说 其实也不能完全解决问题。volatile只是保证可见性，并不保证原子性。没有太理解","like_count":0},{"had_liked":false,"id":88171,"user_name":"狼爷","can_delete":false,"product_type":"c1","uid":1080701,"ip_address":"","ucode":"71124BE4EC7DB4","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/7d/1a55d6ab.jpg","comment_is_top":false,"comment_ctime":1555867382,"is_pvip":false,"replies":[{"id":"31705","content":"大家说的是set方法同步了，get方法没同步","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555892307,"ip_address":"","comment_id":88171,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555867382","product_id":100023901,"comment_content":"看了留言，还是觉得奇怪，<br>第一synchronized不是可以保证可见性吗？<br>第二就是锁都没释放，其他线程不应该是等待吗？<br>第三synchronized不是会保证操作的原子性吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447756,"discussion_content":"大家说的是set方法同步了，get方法没同步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555892307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87925,"user_name":"Android 技师","can_delete":false,"product_type":"c1","uid":1005842,"ip_address":"","ucode":"F7691906C86655","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/12/2034b163.jpg","comment_is_top":false,"comment_ctime":1555754893,"is_pvip":false,"replies":[{"id":"31623","content":"int a=12；&#47;&#47;1<br>省略100万行；<br>int b=1+a；&#47;&#47;2<br>这个时候就会把1,2放到一起","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555769085,"ip_address":"","comment_id":87925,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555754893","product_id":100023901,"comment_content":"宝令老师，“编译器为了优化性能，有时候会改变程序中语句的先后顺序” 这个东西的标准是什么呢？可以举个例子讲一下吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447649,"discussion_content":"int a=12；//1\n省略100万行；\nint b=1+a；//2\n这个时候就会把1,2放到一起","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555769085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87605,"user_name":"蔡呆呆","can_delete":false,"product_type":"c1","uid":1074818,"ip_address":"","ucode":"51EDDEFB274CB3","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/82/c2acd57e.jpg","comment_is_top":false,"comment_ctime":1555640408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555640408","product_id":100023901,"comment_content":"文中所指的CPU缓存只是L1，L2和L3，cpu寄存器是缓存之外的部分？同时volitale对L1，L2和L3生效？","like_count":0},{"had_liked":false,"id":87236,"user_name":"🐳 蓓","can_delete":false,"product_type":"c1","uid":1268736,"ip_address":"","ucode":"87D3ECB88007DD","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/00/5b933841.jpg","comment_is_top":false,"comment_ctime":1555551764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555551764","product_id":100023901,"comment_content":"操作数据库是读写操作<br>读入excel文件是IO操作？","like_count":0},{"had_liked":false,"id":87156,"user_name":"轩辕豆豆","can_delete":false,"product_type":"c1","uid":1501713,"ip_address":"","ucode":"1FCFC608BD2B4A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eribUNj9ylC04DQdaM42AD0pLsVficcyTS3GdVBdibpnDrPSAo4ohNmBzRmiavOLuibCEj8wru0ibIJOZ1A/132","comment_is_top":false,"comment_ctime":1555518456,"is_pvip":false,"replies":[{"id":"32449","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556591240,"ip_address":"","comment_id":87156,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555518456","product_id":100023901,"comment_content":"老师，我总结一下，如果有问题帮忙指点一下<br>1.可见性：两个线程将变量加载到不同cpu缓存中进行计算操作，这时cpu缓存中的变量不算是同一个值。<br>2.原子性：多线程调用方法时，每个线程不会将方法跑完 会有交叉现象。<br>3.有序性：代码顺序可能在编译后不会按照预先顺序执行。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447328,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556591240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87121,"user_name":"qzm","can_delete":false,"product_type":"c1","uid":1117169,"ip_address":"","ucode":"0BFAB84A257081","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/f1/042df911.jpg","comment_is_top":false,"comment_ctime":1555513986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555513986","product_id":100023901,"comment_content":"在eclipse中单步无法复现双重检查导致返回为null的情况；同时开了1000个线程去执行也没有发生这种情况？不知道如何复现。另外大家对于在IDEA多线程debug是否很无语，在这方面eclipse的体验是否比IDEA好很多？","like_count":0},{"had_liked":false,"id":87078,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1555508319,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555508319","product_id":100023901,"comment_content":"long是64位的，在32位机器上是分高32位和低32位存储的，所以long的加减不是一个原子操作，会产生并发问题","like_count":0},{"had_liked":false,"id":86556,"user_name":"liian2019","can_delete":false,"product_type":"c1","uid":1503741,"ip_address":"","ucode":"22F639944F0EA0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epvjpicXzEv02d9ztRzIWIicbejyFTTtRA5K6oYmdicq9HQgGfRn3DLytTHQ6CHspb0TibqFkMibhBXj2g/132","comment_is_top":false,"comment_ctime":1555399481,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555399481","product_id":100023901,"comment_content":"单例还是通过内部类方式实现比较可靠","like_count":0},{"had_liked":false,"id":86555,"user_name":"liian2019","can_delete":false,"product_type":"c1","uid":1503741,"ip_address":"","ucode":"22F639944F0EA0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epvjpicXzEv02d9ztRzIWIicbejyFTTtRA5K6oYmdicq9HQgGfRn3DLytTHQ6CHspb0TibqFkMibhBXj2g/132","comment_is_top":false,"comment_ctime":1555399375,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555399375","product_id":100023901,"comment_content":"引用summer_Day的留言，我也觉得程序代码没有执行结束，为什么可以退出synchronized，是什么原因引起的？","like_count":0},{"had_liked":false,"id":86487,"user_name":"不贰过先生","can_delete":false,"product_type":"c1","uid":1496958,"ip_address":"","ucode":"B208B8DF5FA109","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/7e/6b6384e9.jpg","comment_is_top":false,"comment_ctime":1555381685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555381685","product_id":100023901,"comment_content":"flag，读完这一节，更加清楚的明白了双重检查锁声明instance实例为什么要加上volatile关键字了，static volatile Singleton instance = null了，禁止缓存优化。long上8字节64位，32位机器是4字节。故long在32位机器上一个字节是存储不下来的，故需要2次cpu读取指令，故会发生诡异问题。","like_count":0},{"had_liked":false,"id":85366,"user_name":"帝都牛人","can_delete":false,"product_type":"c1","uid":1027982,"ip_address":"","ucode":"53EC02284680C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/8e/6f0f4a56.jpg","comment_is_top":false,"comment_ctime":1555046779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555046779","product_id":100023901,"comment_content":"看了这么多同学对老师问题的解析，被惊到了。留言区都是如此的高手，相比之下我太弱了，没二话，努力！","like_count":0},{"had_liked":false,"id":85180,"user_name":"xiutao","can_delete":false,"product_type":"c1","uid":1388562,"ip_address":"","ucode":"C4D788C34D927C","user_header":"https://static001.geekbang.org/account/avatar/00/15/30/12/60af93e8.jpg","comment_is_top":false,"comment_ctime":1554995502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554995502","product_id":100023901,"comment_content":"看到一些同学说volatile可以禁止指令重排序，那么这个关键字应该加在哪里呢？它又是禁止的哪一部分的指令重排序的呢？<br>为什么把volatile加在了instance上，就可以解决了下面的getInstance()方法的问题？<br>看到这篇文章有这么一点疑惑，请各位指教一下","like_count":0},{"had_liked":false,"id":84955,"user_name":"盛权_vinc","can_delete":false,"product_type":"c1","uid":1459845,"ip_address":"","ucode":"4688DD06587CE2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LPnuO9GleKEwso2rSbibmbEwn49hnGl9qTQDBv2xLOOWOflQsc9oVEEuZgNBt7TrqRKvk8CX7Tc8iakhEicBCCfFg/132","comment_is_top":false,"comment_ctime":1554949318,"is_pvip":false,"replies":[{"id":"30620","content":"锁会在初始化之后才释放，但是有可能在初始化之前发生线程切换","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555067785,"ip_address":"","comment_id":84955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554949318","product_id":100023901,"comment_content":"老师，请问一下，本例中的锁是不是只要执行了=将内存地址赋给变量就马上释放了，就不管初始化完成没有？初始化的指令由其他地方完成？还是说锁释放就仅仅紧跟着赋值语句，如果不是的话是不是应该等初始化完再释放锁，其他线程才获得锁之后对变量进行操作？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446507,"discussion_content":"锁会在初始化之后才释放，但是有可能在初始化之前发生线程切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555067785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84547,"user_name":"Geek_9621ee","can_delete":false,"product_type":"c1","uid":1079138,"ip_address":"","ucode":"F136E7AC611A8B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLjrPm3HE2KwDa5zGK5N77KZwJEnPU5lgVhKuZicvQ1nL2iad92uetnCmdgIIxeCdu8lhoQ0w5uWEHA/132","comment_is_top":false,"comment_ctime":1554873853,"is_pvip":false,"replies":[{"id":"30452","content":"线程切换和原子性没必然联系，os想什么时候切就什么时候切<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554898870,"ip_address":"","comment_id":84547,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554873853","product_id":100023901,"comment_content":"关于双重检查锁，synchronized 块中的代码时为啥会发生线程切换呢，如果发生线程切换怎么保证原子性呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446388,"discussion_content":"线程切换和原子性没必然联系，os想什么时候切就什么时候切\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554898870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84546,"user_name":"Geek_9621ee","can_delete":false,"product_type":"c1","uid":1079138,"ip_address":"","ucode":"F136E7AC611A8B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLjrPm3HE2KwDa5zGK5N77KZwJEnPU5lgVhKuZicvQ1nL2iad92uetnCmdgIIxeCdu8lhoQ0w5uWEHA/132","comment_is_top":false,"comment_ctime":1554873694,"is_pvip":false,"replies":[{"id":"30453","content":"为什么不会？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554898919,"ip_address":"","comment_id":84546,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554873694","product_id":100023901,"comment_content":"关于双重检查锁，为什么在执行synchronized 块中的代码时会发生CPU切换，","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446387,"discussion_content":"为什么不会？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554898919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83656,"user_name":"kk","can_delete":false,"product_type":"c1","uid":1243876,"ip_address":"","ucode":"C3F70219B67A62","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/e4/2eff2a09.jpg","comment_is_top":false,"comment_ctime":1554691080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554691080","product_id":100023901,"comment_content":"看了评论区已经找到答案了，这个时候B线程是执行第一次判空的步骤不需要获取锁","like_count":0},{"had_liked":false,"id":83655,"user_name":"kk","can_delete":false,"product_type":"c1","uid":1243876,"ip_address":"","ucode":"C3F70219B67A62","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/e4/2eff2a09.jpg","comment_is_top":false,"comment_ctime":1554690935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554690935","product_id":100023901,"comment_content":"关于多线程下单例的问题，我有一点不懂，在A线程执行指令2的时候为什么会有可能切换到B线程，这个时候A线程不是加锁了吗而且没有释放，为什么B线程能被执行","like_count":0},{"had_liked":false,"id":83351,"user_name":"balance","can_delete":false,"product_type":"c1","uid":1007182,"ip_address":"","ucode":"324D909BBE69DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/4e/85502e98.jpg","comment_is_top":false,"comment_ctime":1554542716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554542716","product_id":100023901,"comment_content":"可见性、原子性、有序性，多线并发问题往往都是综合性问题","like_count":0},{"had_liked":false,"id":83297,"user_name":"阿May的海绵宝宝","can_delete":false,"product_type":"c1","uid":1203058,"ip_address":"","ucode":"AA2B28DF8BEF80","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/72/4f8a4297.jpg","comment_is_top":false,"comment_ctime":1554523630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554523630","product_id":100023901,"comment_content":"1.有位同学说寄存器切换，是上下文切换的概念吧，切换的时候是把上个任务的寄存器和程序计数器状态保存，下次切换回来用的上次保存的状态。是否理解正确？<br>2.count循环执行过程中，什么时候缓存会从内存中重新加载变量？","like_count":0},{"had_liked":false,"id":82837,"user_name":"Mr、Zeng","can_delete":false,"product_type":"c1","uid":1203063,"ip_address":"","ucode":"751E9870E404B7","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/77/30a6e874.jpg","comment_is_top":false,"comment_ctime":1554338199,"is_pvip":false,"replies":[{"id":"30004","content":"int a=1<br>int b=2<br>省略一万行<br><br>int c=a+b<br><br>最后一句放第三行就能让缓存更合理使用<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554431365,"ip_address":"","comment_id":82837,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554338199","product_id":100023901,"comment_content":"老师，还是没懂这句话的意思，望解释的更具体点，编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445745,"discussion_content":"int a=1\nint b=2\n省略一万行\n\nint c=a+b\n\n最后一句放第三行就能让缓存更合理使用\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554431365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82332,"user_name":"Aaron_涛","can_delete":false,"product_type":"c1","uid":1180617,"ip_address":"","ucode":"067F3CBB1F036C","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/c9/9a9d82ab.jpg","comment_is_top":false,"comment_ctime":1554186465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554186465","product_id":100023901,"comment_content":"那个new操作符号的我反编译追踪过<br>1.会开启一块内存<br>2.返回两个引用，一个去赋值给变量，一个去执行构造函数","like_count":0},{"had_liked":false,"id":82304,"user_name":"_light","can_delete":false,"product_type":"c1","uid":1324723,"ip_address":"","ucode":"ACE2ABC357C5FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/36/b3/c4a2f3fd.jpg","comment_is_top":false,"comment_ctime":1554180589,"is_pvip":false,"replies":[{"id":"29859","content":"有序性和可见性都能保证<br>不知道jvm怎么实现的，他做的事不仅仅是刷缓存，还要让其他核的缓存失效","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554217348,"ip_address":"","comment_id":82304,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554180589","product_id":100023901,"comment_content":"老师，我有两个问题，感谢😊<br>1：happens-before规则是规定了有序性还是可见性，还是说满足hb规则，可见性和有序性都会得到保证呢？有序性和可见性是不是只能通过hb规则保证呢？<br>2 ：unlock操作会将该cpu所有缓存都刷到主存，还是只将修改过的值刷到主存呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445547,"discussion_content":"有序性和可见性都能保证\n不知道jvm怎么实现的，他做的事不仅仅是刷缓存，还要让其他核的缓存失效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554217348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82137,"user_name":"Presley","can_delete":false,"product_type":"c1","uid":1215219,"ip_address":"","ucode":"D8F125835F4903","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/f3/7c89d00e.jpg","comment_is_top":false,"comment_ctime":1554129356,"is_pvip":false,"replies":[{"id":"29758","content":"是的，早期的操作系统单任务没有原子性问题。竞争很形象，不过我觉得用操作系统调度可能更准确","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554133583,"ip_address":"","comment_id":82137,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554129356","product_id":100023901,"comment_content":"老师，帮看一下理解对不对：“原子性：原子性由线程切换带来的”，我的理解：不切换行不？不行。不切换就是一条线程执行到底，其中耗时的部分可能导致其他任务完全处于阻塞状态，比如好像有些早期操作系统，任务获取cpu的模式是一个线程使用完了，才通知下一个，导致系统经常崩溃。后来都采用了竞争获取cpu的方式，不知道理解对不对？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445481,"discussion_content":"是的，早期的操作系统单任务没有原子性问题。竞争很形象，不过我觉得用操作系统调度可能更准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554133583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81569,"user_name":"侯大虎","can_delete":false,"product_type":"c1","uid":1345219,"ip_address":"","ucode":"6450C75089FDB2","user_header":"","comment_is_top":false,"comment_ctime":1553949815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553949815","product_id":100023901,"comment_content":"对于 阿根一世 那个问题，明白了明白了，终于明白了。  评论区人才真多","like_count":0},{"had_liked":false,"id":81559,"user_name":"侯大虎","can_delete":false,"product_type":"c1","uid":1345219,"ip_address":"","ucode":"6450C75089FDB2","user_header":"","comment_is_top":false,"comment_ctime":1553945330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553945330","product_id":100023901,"comment_content":"为什么我还是没能理解 阿根一世的问题呢？synchronized保证原子，cpu虽然重排序，但是在一个原子里面执行，怎么会发生错误呢？","like_count":0},{"had_liked":false,"id":81455,"user_name":"度尘","can_delete":false,"product_type":"c1","uid":1364884,"ip_address":"","ucode":"2A8B32D4F8D145","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/94/c9823bf6.jpg","comment_is_top":false,"comment_ctime":1553917399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553917399","product_id":100023901,"comment_content":"用CAS更好一点吧，就不需要双重检查了","like_count":0},{"had_liked":false,"id":81382,"user_name":"帽子丨影","can_delete":false,"product_type":"c1","uid":1225395,"ip_address":"","ucode":"2B34892A2DE83E","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","comment_is_top":false,"comment_ctime":1553880436,"is_pvip":false,"replies":[{"id":"29486","content":"a线程写到内存，此时内存为9999，缓存里也会是9999，a的缓存一定是线性增长的，不会变小","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553905955,"ip_address":"","comment_id":81382,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553880436","product_id":100023901,"comment_content":"我理解的count问题最小值应该是2，A线程读到0加到9999，b线程读到0，加到1，a线程写到内存，此时内存为9999，b线程再写，此时内存为1，a、b线程再读到各自的缓冲，b线程加到10000，写到内存，a线程加到1，最后写到内存，最终结果为2。不知道理解的是不是有问题。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445173,"discussion_content":"a线程写到内存，此时内存为9999，缓存里也会是9999，a的缓存一定是线性增长的，不会变小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553905955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80663,"user_name":"三叶","can_delete":false,"product_type":"c1","uid":1338840,"ip_address":"","ucode":"A2BC76CECBCFCA","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/d8/e52ec586.jpg","comment_is_top":false,"comment_ctime":1553696058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553696058","product_id":100023901,"comment_content":"谢谢老师，我懂了","like_count":0},{"had_liked":false,"id":80550,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1553679744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553679744","product_id":100023901,"comment_content":"老师请教个问题，对于第二点线程切换。当线程数&gt;cpu内核数目的时候就一定会发生切换，从而带来开销，那么比如一个n核的物理机，多大的并发数目m会遇到性能质变呢，这个有一般化的实践经验吗？","like_count":0},{"had_liked":false,"id":80246,"user_name":"三叶","can_delete":false,"product_type":"c1","uid":1338840,"ip_address":"","ucode":"A2BC76CECBCFCA","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/d8/e52ec586.jpg","comment_is_top":false,"comment_ctime":1553644630,"is_pvip":false,"replies":[{"id":"29306","content":"没有办法保证两个线程完全同时启动，同时两个线程不被中断，如果能做到结果很可能就是100000<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553694542,"ip_address":"","comment_id":80246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553644630","product_id":100023901,"comment_content":"老师我有个问题一直想不明白，a,b两线程执行count+1，循环100000次为什么是一个100000到200000的随机数？如果刚开始a,b两线程将count=0刷到各自的cpu缓存，基于各自cpu缓存里的count来计算count+1，那么循环万次那a,b线程里的count值都是100000","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444795,"discussion_content":"没有办法保证两个线程完全同时启动，同时两个线程不被中断，如果能做到结果很可能就是100000\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553694542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80117,"user_name":"石头","can_delete":false,"product_type":"c1","uid":1194174,"ip_address":"","ucode":"C3BDA3FE9D4CB2","user_header":"https://static001.geekbang.org/account/avatar/00/12/38/be/4b946340.jpg","comment_is_top":false,"comment_ctime":1553607759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553607759","product_id":100023901,"comment_content":"Add自加的测试代码，出现少的原因很有可能是不具备原子性吧","like_count":0},{"had_liked":false,"id":79697,"user_name":"Monster!","can_delete":false,"product_type":"c1","uid":1179101,"ip_address":"","ucode":"74F1D3BB5E3915","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/dd/baeda83e.jpg","comment_is_top":false,"comment_ctime":1553522856,"is_pvip":false,"replies":[{"id":"29055","content":"可以，你这真是在写bug","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553526814,"ip_address":"","comment_id":79697,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553522856","product_id":100023901,"comment_content":"老师，请教一下嘎嘎所说的在类中写一个静态私有的内部类，然后通过公共的方法返回内部类中的instance，如果通过反射的话，是否可以获取这个方法，然后再new出一个新的Singleton呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444587,"discussion_content":"可以，你这真是在写bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553526814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78637,"user_name":"兔2🐰🍃","can_delete":false,"product_type":"c1","uid":1096984,"ip_address":"","ucode":"1FEDA044BB6CBD","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/18/2af6bf4b.jpg","comment_is_top":false,"comment_ctime":1553188907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553188907","product_id":100023901,"comment_content":"专栏很有营养，持续学习中<br>双重检查锁的单例模式是面试中常见的一道题，听完老师讲解后知其所以然了。<br>public class Singleton {<br>  private static volatile Singleton instance;<br>  private Singleton(){}<br>  public static Singleton getInstance(){<br>    if (instance == null) {<br>      synchronized(Singleton.class) {<br>        if (instance == null)<br>          instance = new Singleton();<br>        }<br>    }<br>    return instance;<br>  }<br>}<br>","like_count":0},{"had_liked":false,"id":77998,"user_name":"东坡先生","can_delete":false,"product_type":"c1","uid":1081668,"ip_address":"","ucode":"CE3377B61C7A54","user_header":"https://static001.geekbang.org/account/avatar/00/10/81/44/a6cd7f8c.jpg","comment_is_top":false,"comment_ctime":1553051481,"is_pvip":false,"replies":[{"id":"28502","content":"时间片用完，操作系统会强行切换的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553092420,"ip_address":"","comment_id":77998,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553051481","product_id":100023901,"comment_content":"看了jialin的回答，我有个疑问，线程进入锁区后，线程应该走完才会去执行另一个线程吧，这时不应该会切换到另一个线程啊？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443929,"discussion_content":"时间片用完，操作系统会强行切换的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553092420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77424,"user_name":"雷明正","can_delete":false,"product_type":"c1","uid":1442549,"ip_address":"","ucode":"CDD22C774B92A5","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/f5/82659fc6.jpg","comment_is_top":false,"comment_ctime":1552922317,"is_pvip":false,"replies":[{"id":"28451","content":"也有可能刷，这个看cpu运行情况<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553042946,"ip_address":"","comment_id":77424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552922317","product_id":100023901,"comment_content":"对于双重判断，有个疑问，初始化的时候如果cpu时间片切换，但是此时变量还是处于线程工作内存中吧？并没有刷新到主内存吧？对于其他线程应该是不可见吧？如果是话，就不会出现异常了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443718,"discussion_content":"也有可能刷，这个看cpu运行情况\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553042946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76551,"user_name":"林健","can_delete":false,"product_type":"c1","uid":1035722,"ip_address":"","ucode":"07F07EC036A44F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/ca/ddbd461a.jpg","comment_is_top":false,"comment_ctime":1552631553,"is_pvip":false,"replies":[{"id":"27936","content":"count=0,所以count+1=1","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552651085,"ip_address":"","comment_id":76551,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552631553","product_id":100023901,"comment_content":"非原子操作的执行路径示意图 里面：描述 count+=1，为 count +1=1，不应该是count = count+1嘛？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443349,"discussion_content":"count=0,所以count+1=1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552651085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76303,"user_name":"格非","can_delete":false,"product_type":"c1","uid":1004569,"ip_address":"","ucode":"89FABFFC377131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/19/95ff4cbd.jpg","comment_is_top":false,"comment_ctime":1552569541,"is_pvip":false,"replies":[{"id":"27823","content":"个程序在多个CPU系统上运行是叫并行，并发的概念更大一些。<br><br>单核上不用考虑可见性问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552573404,"ip_address":"","comment_id":76303,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552569541","product_id":100023901,"comment_content":"老师，看完这篇文章收获很大，但是有一些疑问：<br>第一、一个程序在多个CPU系统上运行不是叫并行吗？Java中的一个多线程程序在多个CPU上是以并行方式运行，还是以并发方式运行呢？<br><br>第二、那个可见性问题，在单个CPU中是否存在呢？多核CPU由于都有各自缓存独立，所以对运行在不同CPU上的线程不可见，所以会导致一个线程更改了变量，对另外一个线程不可见的问题，这个好理解，但是不可见问题是否在单个CPU上的多线程是否存在呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443247,"discussion_content":"个程序在多个CPU系统上运行是叫并行，并发的概念更大一些。\n\n单核上不用考虑可见性问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552573404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76241,"user_name":"宇","can_delete":false,"product_type":"c1","uid":1401050,"ip_address":"","ucode":"5D34F7492B6F20","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/da/d1d70e57.jpg","comment_is_top":false,"comment_ctime":1552555598,"is_pvip":false,"replies":[{"id":"27799","content":"是这样的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552567245,"ip_address":"","comment_id":76241,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552555598","product_id":100023901,"comment_content":"64位变了在32位机器上存储cpu是不是就是分开两个存储，导致多线程中如果一个线程写完一个存储另外一个线程会介入导致存储值的错误，不知道说的对不","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443227,"discussion_content":"是这样的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552567245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75772,"user_name":"amourling","can_delete":false,"product_type":"c1","uid":1157578,"ip_address":"","ucode":"8E1A73B717A554","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/ca/2d8c4733.jpg","comment_is_top":false,"comment_ctime":1552466847,"is_pvip":false,"replies":[{"id":"27625","content":"我这里看不到上下文，vo不仅仅有防止重排的作用，得综合在一起看<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552476300,"ip_address":"","comment_id":75772,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552466847","product_id":100023901,"comment_content":"回复 嘎嘎的疑问，把变量设置为volatile的目的是防止重排序。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443027,"discussion_content":"我这里看不到上下文，vo不仅仅有防止重排的作用，得综合在一起看\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552476300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75561,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1552435852,"is_pvip":false,"replies":[{"id":"27605","content":"并发问题往往都是综合症，我实在想不出更简单的例子了<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552454475,"ip_address":"","comment_id":75561,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552435852","product_id":100023901,"comment_content":"我觉得有序性那个例子可能会让人产生歧义，关于有序性的说明太过于深。第一遍还以为是线程切换导致的问题，所以就没弄明白，回过头再来总结才看出来了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442942,"discussion_content":"并发问题往往都是综合症，我实在想不出更简单的例子了\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552454475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75557,"user_name":"linsen","can_delete":false,"product_type":"c1","uid":1187010,"ip_address":"","ucode":"1DBBBA0988DB63","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/05Wiazxo0OS5w9KdJ4OQAe3ezwaCXNY4DGoE0noPFzXtUhOGejgGKFR6WmMxr0KcEGOSahnjbOwxPSib88h0E6zA/132","comment_is_top":false,"comment_ctime":1552435422,"is_pvip":false,"replies":[{"id":"27609","content":"带着这个问题往后看吧，原因太多了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552455085,"ip_address":"","comment_id":75557,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552435422","product_id":100023901,"comment_content":"对于volatile语义一直有个疑问，我们都知道volatile能保证可见性，但不能保证线程安全，但是如果都保证了可见性为什么还不能保证线程安全，线程A对变量的操作对线程B来说都是可见的，那不就保证了线程B操作的变量都是线程A更新之后的值，那不就线程安全了嘛？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442939,"discussion_content":"带着这个问题往后看吧，原因太多了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552455085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74400,"user_name":"橘子","can_delete":false,"product_type":"c1","uid":1368522,"ip_address":"","ucode":"EDF6145878F897","user_header":"https://static001.geekbang.org/account/avatar/00/14/e1/ca/d8b0835f.jpg","comment_is_top":false,"comment_ctime":1552216359,"is_pvip":false,"replies":[{"id":"27188","content":"会多创建一个对象出来，其他的没啥问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552224191,"ip_address":"","comment_id":74400,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552216359","product_id":100023901,"comment_content":"对象是引用的当时，在双重检查里面，就算返回的是null，但是如果后面构造成功，这个引用对象还是正确的，只是当时使用的时候可能是null值？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442560,"discussion_content":"会多创建一个对象出来，其他的没啥问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552224191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74300,"user_name":"侯大虎","can_delete":false,"product_type":"c1","uid":1345219,"ip_address":"","ucode":"6450C75089FDB2","user_header":"","comment_is_top":false,"comment_ctime":1552184046,"is_pvip":false,"replies":[{"id":"27173","content":"内存、cpu缓存是物理存在的。jvm内存是软件存在的。线程内存你是指线程栈？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552191009,"ip_address":"","comment_id":74300,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552184046","product_id":100023901,"comment_content":"老师，线程内存，jvm内存，cpu缓存，内存 这是什么关系。。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442518,"discussion_content":"内存、cpu缓存是物理存在的。jvm内存是软件存在的。线程内存你是指线程栈？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552191009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74297,"user_name":"子焜🌈","can_delete":false,"product_type":"c1","uid":1446082,"ip_address":"","ucode":"CA6560BEB8D801","user_header":"https://static001.geekbang.org/account/avatar/00/16/10/c2/fec86652.jpg","comment_is_top":false,"comment_ctime":1552183586,"is_pvip":false,"replies":[{"id":"27171","content":"没看明白。。。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552190859,"ip_address":"","comment_id":74297,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552183586","product_id":100023901,"comment_content":"看了下一期的Happens-Before原则，jdk1.5以后的版本是不是在增加一个volatile对象在实例对象赋值后面，会不会对性能会更好一些，避免了单例对象读取时被volatile优化跳过cpu缓存？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442516,"discussion_content":"没看明白。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552190859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74290,"user_name":"子焜🌈","can_delete":false,"product_type":"c1","uid":1446082,"ip_address":"","ucode":"CA6560BEB8D801","user_header":"https://static001.geekbang.org/account/avatar/00/16/10/c2/fec86652.jpg","comment_is_top":false,"comment_ctime":1552182342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552182342","product_id":100023901,"comment_content":"对了，吧，对象再加volatile声明一下对象就可以解决对象的可见性了。","like_count":0},{"had_liked":false,"id":74288,"user_name":"子焜🌈","can_delete":false,"product_type":"c1","uid":1446082,"ip_address":"","ucode":"CA6560BEB8D801","user_header":"https://static001.geekbang.org/account/avatar/00/16/10/c2/fec86652.jpg","comment_is_top":false,"comment_ctime":1552181705,"is_pvip":false,"replies":[{"id":"27169","content":"spring注入啊，多简单。网上也有很多方案，我就不越俎代庖了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552190745,"ip_address":"","comment_id":74288,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552181705","product_id":100023901,"comment_content":"getInstance() 方法并不完美。以前总是用这个方法，怎么才能完美呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442512,"discussion_content":"spring注入啊，多简单。网上也有很多方案，我就不越俎代庖了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552190745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74172,"user_name":"shawn","can_delete":false,"product_type":"c1","uid":1101483,"ip_address":"","ucode":"9AF400BBF2E264","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/ab/e9d7811f.jpg","comment_is_top":false,"comment_ctime":1552127702,"is_pvip":true,"replies":[{"id":"27130","content":"有一部分可以通过看汇编代码来看，但是CPU和解释器在运行期也会做一部分优化，所以很多时候都是看不到的，也很难重现。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552138319,"ip_address":"","comment_id":74172,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552127702","product_id":100023901,"comment_content":"老师，我有个疑问，我们如何知道我们所写的代码优化后的执行顺序的。比如刚才单例那个例子，我们要知道优化后的顺序才能了解代码所存在的并发问题。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442480,"discussion_content":"有一部分可以通过看汇编代码来看，但是CPU和解释器在运行期也会做一部分优化，所以很多时候都是看不到的，也很难重现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552138319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74103,"user_name":"","can_delete":false,"product_type":"c1","uid":1031328,"ip_address":"","ucode":"1B73BA45ACD06C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/a0/97c7679b.jpg","comment_is_top":false,"comment_ctime":1552104375,"is_pvip":false,"replies":[{"id":"27073","content":"多看几遍，感觉吃力说明收获会很大<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552107058,"ip_address":"","comment_id":74103,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552104375","product_id":100023901,"comment_content":"果然博大精深。我这菜鸟看起来很吃力","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442444,"discussion_content":"多看几遍，感觉吃力说明收获会很大\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552107058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74089,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1552101770,"is_pvip":false,"replies":[{"id":"27103","content":"正确","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552113919,"ip_address":"","comment_id":74089,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552101770","product_id":100023901,"comment_content":"long是64位，32位操作系统字长是32位，一次加减操作分成了高32位和低32位操作，两个cpu指令操作不能保证原子性","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442436,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552113919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74025,"user_name":"左耳朵狮子","can_delete":false,"product_type":"c1","uid":1067280,"ip_address":"","ucode":"095DD787E58967","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/10/af49fa20.jpg","comment_is_top":false,"comment_ctime":1552080876,"is_pvip":false,"replies":[{"id":"27036","content":"放到下面有点晚，改成进程又可能引起误会，怕初学者以为现在的操作系统是做的进程切换，我再想想，你提的问题很好！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552091738,"ip_address":"","comment_id":74025,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552080876","product_id":100023901,"comment_content":"线程切换示意图 为什么放到进程的段落？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442393,"discussion_content":"放到下面有点晚，改成进程又可能引起误会，怕初学者以为现在的操作系统是做的进程切换，我再想想，你提的问题很好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552091738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74008,"user_name":" 臣馟飞扬","can_delete":false,"product_type":"c1","uid":1116188,"ip_address":"","ucode":"F2F882B7678055","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","comment_is_top":false,"comment_ctime":1552058731,"is_pvip":false,"replies":[{"id":"27044","content":"工作内存的概念我没有找到真正的出处，所以不敢瞎讲。我在jsr133规范里没找到它，你知道他哪里来的吗？<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552094340,"ip_address":"","comment_id":74008,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552058731","product_id":100023901,"comment_content":"请教一下，可见性那个例子，我觉得就算是单核的CPU，也会出现可见性问题吧，因为按照jvm内存模型，每个线程对共享变量的操作都是在自己的工作内存里，操作完再回写到主存中，所以这跟CPU是单核还是多核应该没有关系吧？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442382,"discussion_content":"工作内存的概念我没有找到真正的出处，所以不敢瞎讲。我在jsr133规范里没找到它，你知道他哪里来的吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552094340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73949,"user_name":"马克","can_delete":false,"product_type":"c1","uid":1106597,"ip_address":"","ucode":"C1D35AB8373444","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/a5/05276fad.jpg","comment_is_top":false,"comment_ctime":1552040907,"is_pvip":false,"replies":[{"id":"27018","content":"应该不会创建两个对象，因为B线程拿不到锁。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552059580,"ip_address":"","comment_id":73949,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552040907","product_id":100023901,"comment_content":"1、32位操作系统上执行long型数据的加减，会分高地位运算，存在并发问题。<br>2、双重检查，如果按照申请内存空间、创建对象、赋值的步骤执行，当A线程执行到步骤2时发生分片切换，B线程也会申请内存创建对象，就有可能产生两个对象的现象","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442355,"discussion_content":"应该不会创建两个对象，因为B线程拿不到锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552059580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73944,"user_name":"机遇号","can_delete":false,"product_type":"c1","uid":1105053,"ip_address":"","ucode":"A2940DE77BCAEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/9d/e20b37d7.jpg","comment_is_top":false,"comment_ctime":1552039720,"is_pvip":false,"replies":[{"id":"27013","content":"更新中","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552059189,"ip_address":"","comment_id":73944,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552039720","product_id":100023901,"comment_content":"学习中","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442352,"discussion_content":"更新中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552059189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73925,"user_name":"姜浩远","can_delete":false,"product_type":"c1","uid":1236739,"ip_address":"","ucode":"6ED5CA8283858B","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/03/6613bd63.jpg","comment_is_top":false,"comment_ctime":1552035891,"is_pvip":false,"replies":[{"id":"26976","content":"在这里是一回事<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552047208,"ip_address":"","comment_id":73925,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552035891","product_id":100023901,"comment_content":"老师，您好！请问您在文中提到的“CPU缓存”和“CPU寄存器”是指的同一个东西么？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442341,"discussion_content":"在这里是一回事\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552047208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73912,"user_name":"suynan","can_delete":false,"product_type":"c1","uid":1023214,"ip_address":"","ucode":"0AAD1BA9D22D2C","user_header":"","comment_is_top":false,"comment_ctime":1552031135,"is_pvip":false,"replies":[{"id":"26975","content":"你说的对，评论区里有我完整代码<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552047138,"ip_address":"","comment_id":73912,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552031135","product_id":100023901,"comment_content":"第一个例子给的代码不能编译通过吧，calc()方法作为静态方法，不能直接return count，应该是return test.count","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442333,"discussion_content":"你说的对，评论区里有我完整代码\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552047138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73785,"user_name":"二少","can_delete":false,"product_type":"c1","uid":1442885,"ip_address":"","ucode":"190983809CD3EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/45/0c474d47.jpg","comment_is_top":false,"comment_ctime":1551999861,"is_pvip":false,"replies":[{"id":"26996","content":"不会释放。后面会详细介绍什么时候锁会释放。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552058048,"ip_address":"","comment_id":73785,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551999861","product_id":100023901,"comment_content":"关于双重锁的问题，如果线程进入Asynchronized块中以后，在即将执行第三步的时候，发生线程切换了，那么线程A拿到的锁会释放么？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442277,"discussion_content":"不会释放。后面会详细介绍什么时候锁会释放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552058048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73779,"user_name":"你好呀","can_delete":false,"product_type":"c1","uid":1049361,"ip_address":"","ucode":"2E97656410BACA","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/11/f58c6278.jpg","comment_is_top":false,"comment_ctime":1551980676,"is_pvip":false,"replies":[{"id":"26993","content":"cpu将缓存写入内存的时机是不确定的。除非你调用cpu相关指令强刷。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552057923,"ip_address":"","comment_id":73779,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551980676","product_id":100023901,"comment_content":"cpu缓存是将  count与  idx两个变量读入缓存  计算完结果后   再写入内存 ？ 这样的话结果不就是只会是10000与20000","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442273,"discussion_content":"cpu将缓存写入内存的时机是不确定的。除非你调用cpu相关指令强刷。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552057923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73722,"user_name":"橘子","can_delete":false,"product_type":"c1","uid":1368522,"ip_address":"","ucode":"EDF6145878F897","user_header":"https://static001.geekbang.org/account/avatar/00/14/e1/ca/d8b0835f.jpg","comment_is_top":false,"comment_ctime":1551964394,"is_pvip":false,"replies":[{"id":"26923","content":"是的，就是慢","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551967350,"ip_address":"","comment_id":73722,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551964394","product_id":100023901,"comment_content":"第一个if可能存在逸出现象，发布了未构造好的instance，如果把第一个if条件去掉，应该是满足happen before的规则，所以是线程安全？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442244,"discussion_content":"是的，就是慢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551967350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73696,"user_name":"落落彩虹","can_delete":false,"product_type":"c1","uid":1264832,"ip_address":"","ucode":"F4CE1908DF149A","user_header":"https://static001.geekbang.org/account/avatar/00/13/4c/c0/73d52c05.jpg","comment_is_top":false,"comment_ctime":1551960383,"is_pvip":false,"replies":[{"id":"26915","content":"为了让寄存器、缓存里面的值，利用的更充分。<br>i=12；<br>j=23；<br>i++；<br>这个就会优化成<br>i=12；<br>i++；<br>j=23；<br>你看看能不能想明白吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551964714,"ip_address":"","comment_id":73696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551960383","product_id":100023901,"comment_content":"老师，我对“编译程序优化指令执行次序，使得缓存能够得到更加合理地利用”这个的因果关系没理解.","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442230,"discussion_content":"为了让寄存器、缓存里面的值，利用的更充分。\ni=12；\nj=23；\ni++；\n这个就会优化成\ni=12；\ni++；\nj=23；\n你看看能不能想明白吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551964714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73525,"user_name":"贼像样","can_delete":false,"product_type":"c1","uid":1447161,"ip_address":"","ucode":"95BEF65DCDA1A2","user_header":"https://static001.geekbang.org/account/avatar/00/16/14/f9/f5148008.jpg","comment_is_top":false,"comment_ctime":1551920551,"is_pvip":false,"replies":[{"id":"26853","content":"存在<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551956898,"ip_address":"","comment_id":73525,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551920551","product_id":100023901,"comment_content":"有个问题，双重验证单例的问题，在同步代码块中的代码执行途中，存在cpu切换吗？谢谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442131,"discussion_content":"存在\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551956898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73392,"user_name":"Lugyedo","can_delete":false,"product_type":"c1","uid":1011793,"ip_address":"","ucode":"EB5E456B638E70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/70/51/f1825adb.jpg","comment_is_top":false,"comment_ctime":1551876528,"is_pvip":true,"replies":[{"id":"26714","content":"重合比率越大，错的越离谱。若俩线程之间差十年，就没错误了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551881053,"ip_address":"","comment_id":73392,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551876528","product_id":100023901,"comment_content":"循环 10000 次 count+=1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。<br><br>启动有时差和执行次数为什么会导致结果不一样？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442061,"discussion_content":"重合比率越大，错的越离谱。若俩线程之间差十年，就没错误了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551881053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73274,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1401765,"ip_address":"","ucode":"2D6617CA026D79","user_header":"https://static001.geekbang.org/account/avatar/00/15/63/a5/9254c76d.jpg","comment_is_top":false,"comment_ctime":1551847638,"is_pvip":false,"replies":[{"id":"26704","content":"主流操作系统都是这样<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551880510,"ip_address":"","comment_id":73274,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551847638","product_id":100023901,"comment_content":"任何操作系统都是这样吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441998,"discussion_content":"主流操作系统都是这样\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551880510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73230,"user_name":"任洋爱吃肉","can_delete":false,"product_type":"c1","uid":1126168,"ip_address":"","ucode":"14AA217CB8C672","user_header":"https://static001.geekbang.org/account/avatar/00/11/2f/18/e437681f.jpg","comment_is_top":false,"comment_ctime":1551843380,"is_pvip":false,"replies":[{"id":"26741","content":"你么有办法保证两个线程是完全同时执行的。cpu刷缓存也是随机的。最终导致结果不可推断。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551883107,"ip_address":"","comment_id":73230,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551843380","product_id":100023901,"comment_content":"老师你好：文章中源头之一，缓存导致的可见性问题中 两个线程并发执行add10k()的示例里面。你提到A、B线程都是基于cpu缓存里的count值来计算。我的理解是A、B线程的count值一直都在缓存中，那么基于各自cpu中count缓存值来计算的话，那么最终的执行结果应该是10000才对啊，即在两个线程并行执行的最终结果都是10000，只是快慢完成而已，那为什么会是10000到20000之间的随机值呢？是线程cpu的缓存值在随机写入内存后会失效，下次执行指令时要重新从内存中读取吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441983,"discussion_content":"你么有办法保证两个线程是完全同时执行的。cpu刷缓存也是随机的。最终导致结果不可推断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551883107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73109,"user_name":"神码也不懂","can_delete":false,"product_type":"c1","uid":1063310,"ip_address":"","ucode":"2DA7453BAA0293","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8e/4439066c.jpg","comment_is_top":false,"comment_ctime":1551799931,"is_pvip":false,"replies":[{"id":"26580","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551831071,"ip_address":"","comment_id":73109,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551799931","product_id":100023901,"comment_content":"好多说法之前略有耳闻，比如count+=1不是原子操作、以及编译优化改变指令执行顺序会存在线程安全问题等，之前只是那么一听，知道里头有文章，但并不理解前因后果，这次终于知道其实都是由于CPU指令才是面向线程切换的原子操作而导致的。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441917,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551831071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73102,"user_name":"Hour","can_delete":false,"product_type":"c1","uid":1448748,"ip_address":"","ucode":"AA1045ACABC0BB","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","comment_is_top":false,"comment_ctime":1551798881,"is_pvip":false,"replies":[{"id":"26579","content":"问题在于，第一段我只是模拟错误的思维。第二段才指出问题。好多同学还是基于第一段来做推理。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551831033,"ip_address":"","comment_id":73102,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1551798881","product_id":100023901,"comment_content":"看到大家都在讨论阿根一世提的问题，觉得挺有意思，不过也有人没有理解阿根一世问题的点，所以顺理成章的被作者引导到NPE上了😂 <br><br>问题点在于，线程A，线程B都已经经过了第一层非空验证！<br><br>首先说下我的理解，第一：线程B访问时不会发生NPE；第二：会导致线程B再创建一个实例。<br><br>为什么线程B会再创建一个实例呢？答案是CPU的缓存导致了线程的不可见性，作者第一个例子已经提到过。线程B可能会从自己的CPU缓存拿出instance的时候，发现为空，所以又走了初始化的命令导致非单例。<br><br>那如何解决呢？通过valitale关键字修饰instance，这样线程A初始化后，释放锁，线程B拿到锁，二次非空验证时，知道了线程A已经对instance初始化了，就不再做任何操作，直接返回。保证真正实现单例。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441912,"discussion_content":"问题在于，第一段我只是模拟错误的思维。第二段才指出问题。好多同学还是基于第一段来做推理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551831033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284293,"avatar":"https://static001.geekbang.org/account/avatar/00/13/98/c5/7105ea6c.jpg","nickname":"xuxq","note":"","ucode":"96E1C17D11F54E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160623,"discussion_content":"请问一下，syn不会保证可见性么？基于你的如上描述，我认为应该是这样的执行流程：a、b都已经经过了第一层非空验证，a初始化后释放锁，然后b拿到锁，这时候b拿到最新的变量值，b判断第二次不为null，返回。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580820672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73069,"user_name":"轻歌赋","can_delete":false,"product_type":"c1","uid":1251574,"ip_address":"","ucode":"22F62446208805","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/f6/2ff7bc7a.jpg","comment_is_top":false,"comment_ctime":1551789523,"is_pvip":false,"replies":[{"id":"26504","content":"用汇编实现以下看看。万一有高级的指令呢","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551796946,"ip_address":"","comment_id":73069,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551789523","product_id":100023901,"comment_content":"存在，因为long在JAVA中是64位的，在32位机器上面需要分别对两个32位进行操作，因此指令不是原子的。<br>但是对此有个问题，请问老师，32位机器对lomg类型操作了几条机器指令呢？有没有多种情况？<br>个人看法是起码6条，对每一个位都要读写和赋值，不知道老师怎么看呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441896,"discussion_content":"用汇编实现以下看看。万一有高级的指令呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551796946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72908,"user_name":"math","can_delete":false,"product_type":"c1","uid":1432973,"ip_address":"","ucode":"7EE57777F86058","user_header":"https://static001.geekbang.org/account/avatar/00/15/dd/8d/0396fabe.jpg","comment_is_top":false,"comment_ctime":1551753752,"is_pvip":false,"replies":[{"id":"26488","content":"理论上不会啊。你把完整代码贴出来，让大家帮忙测试一下。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794752,"ip_address":"","comment_id":72908,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551753752","product_id":100023901,"comment_content":"count等于一没试出来，但是小于10000试出来了。得到一个9821的值","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441821,"discussion_content":"理论上不会啊。你把完整代码贴出来，让大家帮忙测试一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72862,"user_name":"ghost","can_delete":false,"product_type":"c1","uid":1247927,"ip_address":"","ucode":"19420A1B78EAB9","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/b7/9cc85537.jpg","comment_is_top":false,"comment_ctime":1551748389,"is_pvip":true,"replies":[{"id":"26456","content":"没有解决原子性<br>count+=1这个不是原子性<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551788178,"ip_address":"","comment_id":72862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551748389","product_id":100023901,"comment_content":"老师您好，看了您的文章，受益颇深。<br>我有一个疑问。我将您的示例代码修改为：<br>&#47;&#47;    private long count = 0;<br>    private volatile int count = 0;<br>结果依然是一个小于20000的随机值。<br>我理解的是：使用volatile 解决了可见性问题，使用int解决了原子性问题，但实际结果<br>却让人无法理解。<br>请老师帮忙解答下，谢谢。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441795,"discussion_content":"没有解决原子性\ncount+=1这个不是原子性\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551788178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72714,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1551700972,"is_pvip":false,"replies":[{"id":"26355","content":"为了让寄存器、缓存里面的值，利用的更充分。<br>i=12；<br>j=23；<br>i++；<br>这个就会优化成<br>i=12；<br>i++；<br>j=23；<br>你看看能不能想明白吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551710103,"ip_address":"","comment_id":72714,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551700972","product_id":100023901,"comment_content":"老师您好，文中说到，编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。这块不是很理解，可以举个例子吗？谢谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441704,"discussion_content":"为了让寄存器、缓存里面的值，利用的更充分。\ni=12；\nj=23；\ni++；\n这个就会优化成\ni=12；\ni++；\nj=23；\n你看看能不能想明白吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551710103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72698,"user_name":"鸠翱","can_delete":false,"product_type":"c1","uid":1116568,"ip_address":"","ucode":"7D498AF2BC4289","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/98/b11c372b.jpg","comment_is_top":false,"comment_ctime":1551696796,"is_pvip":false,"replies":[{"id":"26353","content":"我也不知道，看CPU心情吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551709968,"ip_address":"","comment_id":72698,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551696796","product_id":100023901,"comment_content":"CPU缓存什么时候会写会内存（触发条件是什么）？<br>比如说CPU1的count的值加了1000之后，将值写回内存，然后第1001次操作又需要重新读取一次内存是这样子的嘛？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441692,"discussion_content":"我也不知道，看CPU心情吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551709968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72686,"user_name":"袁艺🌸15001179414","can_delete":false,"product_type":"c1","uid":1445846,"ip_address":"","ucode":"5CC6395A5BC666","user_header":"https://static001.geekbang.org/account/avatar/00/16/0f/d6/30ae08a1.jpg","comment_is_top":false,"comment_ctime":1551694035,"is_pvip":false,"replies":[{"id":"26354","content":"虚拟机和位数有关系，java程序没关系","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551710086,"ip_address":"","comment_id":72686,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551694035","product_id":100023901,"comment_content":"但是java是运行在虚拟机上的 和位数有关系吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441686,"discussion_content":"虚拟机和位数有关系，java程序没关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551710086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72685,"user_name":"sheldon","can_delete":false,"product_type":"c1","uid":1005454,"ip_address":"","ucode":"0C9AB833A7E3DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/8e/67990114.jpg","comment_is_top":false,"comment_ctime":1551693458,"is_pvip":false,"replies":[{"id":"26352","content":"一个CPU情况下A线程还没结束，B线程也会执行。但是B线程不会执行到同步代码块里面。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551709916,"ip_address":"","comment_id":72685,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551693458","product_id":100023901,"comment_content":"阿根一世那个问题。<br>他应该想的是一个CPU的情况下，一个CPU情况下，锁还没释放，A线程还没结束，B线程就不会执行。<br>但是可以有多个CPU。<br>我这样理解，不知道对不对。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441685,"discussion_content":"一个CPU情况下A线程还没结束，B线程也会执行。但是B线程不会执行到同步代码块里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551709916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72671,"user_name":"云韵","can_delete":false,"product_type":"c1","uid":1025622,"ip_address":"","ucode":"3DE26DBAAAEDE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/56/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1551690086,"is_pvip":true,"replies":[{"id":"26351","content":"me too","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551709837,"ip_address":"","comment_id":72671,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1551690086","product_id":100023901,"comment_content":"评论区看的心潮澎湃","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441681,"discussion_content":"me too","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551709837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72535,"user_name":"尾戒","can_delete":false,"product_type":"c1","uid":1391897,"ip_address":"","ucode":"6790ADD9797E4F","user_header":"https://static001.geekbang.org/account/avatar/00/15/3d/19/9267792a.jpg","comment_is_top":false,"comment_ctime":1551665994,"is_pvip":false,"replies":[{"id":"26345","content":"CPU什么时候写回内存，要看CPU的心情。所以假定它一成不定是不行的。你把CPU刷缓存想的随机一些就明白了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551709336,"ip_address":"","comment_id":72535,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551665994","product_id":100023901,"comment_content":"老师您好，关于双重检查那个例子，有点疑问：<br>线程A执行：<br>1.分配一块内存 M； <br>2.将 M 的地址赋值给 instance 变量；&lt;----这里发生切换，并且线程B可以读到线程A分配的地址<br>3.最后在内存 M 上初始化 Singleton 对象。<br><br>那么按照之前说的CPU缓存，CPU会把对象读取到自己的缓存里，针对这种初始化对象的情况CPU是怎么处理的？<br>因为不是很懂：<br>①如果这块的操作全在内存里，那么即便是像一些同学说的加上volatile关键字也不会解决这个问题的。<br>②如果这些操作是在CPU缓存里完成的，最后才写回真正的内存，那么就不存在线程B在外层判断时就读到了线程A分配的对象。<br><br>以上是我的疑惑，求解答~~","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441636,"discussion_content":"CPU什么时候写回内存，要看CPU的心情。所以假定它一成不定是不行的。你把CPU刷缓存想的随机一些就明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551709336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72522,"user_name":"凌","can_delete":false,"product_type":"c1","uid":1441575,"ip_address":"","ucode":"E102C26684D5B2","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/27/136d59c4.jpg","comment_is_top":false,"comment_ctime":1551663910,"is_pvip":false,"replies":[{"id":"26343","content":"把简单的事情复杂化才是本事","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551709072,"ip_address":"","comment_id":72522,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551663910","product_id":100023901,"comment_content":"令哥就是可以把复杂的问题给简单化，让大家听起来通俗易懂，看了看大家的评论，让我这个菜鸡也提升不少，高手在民间！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441629,"discussion_content":"把简单的事情复杂化才是本事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551709072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72488,"user_name":"CityAnimal","can_delete":false,"product_type":"c1","uid":1139902,"ip_address":"","ucode":"206491F70572AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/64/be/12c37d15.jpg","comment_is_top":false,"comment_ctime":1551658827,"is_pvip":true,"replies":[{"id":"26342","content":"public class Test {<br>    private int count = 0;<br>    private void add() {<br>        int idx = 0;<br>        while(idx++ &lt; 10000000) {<br>            count += 1;<br>        }<br>    }<br>    public static int calc() throws Exception {<br>        final Test test = new Test();<br>        Thread th1 = new Thread(()-&gt;{<br>            test.add();<br>        });<br>        Thread th2 = new Thread(()-&gt;{<br>            test.add();<br>        });<br><br>        th1.start();<br>        th2.start();<br>        th1.join();<br>        th2.join();<br>        return test.count;<br>    }<br><br>    public static void main(String[] args) throws Exception {<br>        long c =calc();<br>        System.out.println(c);<br>    }<br>}","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551709033,"ip_address":"","comment_id":72488,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551658827","product_id":100023901,"comment_content":"提个bug: Test中的calc()方法是staticd的，test变量是实例变量，编译时会报<br> non-static variable count cannot be referenced from a static context","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441613,"discussion_content":"public class Test {\n    private int count = 0;\n    private void add() {\n        int idx = 0;\n        while(idx++ &amp;lt; 10000000) {\n            count += 1;\n        }\n    }\n    public static int calc() throws Exception {\n        final Test test = new Test();\n        Thread th1 = new Thread(()-&amp;gt;{\n            test.add();\n        });\n        Thread th2 = new Thread(()-&amp;gt;{\n            test.add();\n        });\n\n        th1.start();\n        th2.start();\n        th1.join();\n        th2.join();\n        return test.count;\n    }\n\n    public static void main(String[] args) throws Exception {\n        long c =calc();\n        System.out.println(c);\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551709033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72470,"user_name":"PK時頭髮不亂","can_delete":false,"product_type":"c1","uid":1207867,"ip_address":"","ucode":"08AAAC8F4DE71D","user_header":"https://static001.geekbang.org/account/avatar/00/12/6e/3b/88f14e2a.jpg","comment_is_top":false,"comment_ctime":1551651579,"is_pvip":false,"replies":[{"id":"26340","content":"先让我消化消化","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551708894,"ip_address":"","comment_id":72470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551651579","product_id":100023901,"comment_content":"太多计算机系统的知识了，可以开一门《深入理解计算机系统》的课程了，书太厚不好看，不好理解，老师帮我们拆解分析，我第一个到场^O^。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441604,"discussion_content":"先让我消化消化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551708894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72300,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1551581630,"is_pvip":false,"replies":[{"id":"26188","content":"可以，实现单例的方法有很多。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551584230,"ip_address":"","comment_id":72300,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551581630","product_id":100023901,"comment_content":"long类型站64位，所以32位操作系统无法做到原子性操作从而导致问题发生。<br>关于单例双检锁导致的问题，最终的解决方案是否可以采用内部类或枚举的方式解决呢？<br>还望老师可以百忙中解答疑惑，感谢~","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441530,"discussion_content":"可以，实现单例的方法有很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551584230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72282,"user_name":"高阳路人","can_delete":false,"product_type":"c1","uid":1017091,"ip_address":"","ucode":"E7AC074945CC1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/03/eb460eda.jpg","comment_is_top":false,"comment_ctime":1551574486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551574486","product_id":100023901,"comment_content":"java并发编程要用好有不少难度，作者讲的很好，系统学习一遍应该会有不错的效果。","like_count":0},{"had_liked":false,"id":72281,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1551573991,"is_pvip":true,"replies":[{"id":"26184","content":"普遍认可的是互斥和同步这两方面的问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551583437,"ip_address":"","comment_id":72281,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551573991","product_id":100023901,"comment_content":"那是不是意味着并发编程中出现的问题，基本都是互斥这个问题没有解决好？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441521,"discussion_content":"普遍认可的是互斥和同步这两方面的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551583437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72260,"user_name":"1","can_delete":false,"product_type":"c1","uid":1412124,"ip_address":"","ucode":"6964680459D085","user_header":"https://static001.geekbang.org/account/avatar/00/15/8c/1c/c564924f.jpg","comment_is_top":false,"comment_ctime":1551544548,"is_pvip":false,"replies":[{"id":"26181","content":"同步代码块结束的时候","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551582488,"ip_address":"","comment_id":72260,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551544548","product_id":100023901,"comment_content":"请问老师syn锁是什么时候释放的？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441513,"discussion_content":"同步代码块结束的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551582488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72066,"user_name":"August","can_delete":false,"product_type":"c1","uid":1366394,"ip_address":"","ucode":"5311BAFAACB02C","user_header":"https://static001.geekbang.org/account/avatar/00/14/d9/7a/7d3f792c.jpg","comment_is_top":false,"comment_ctime":1551511119,"is_pvip":false,"replies":[{"id":"26108","content":"这个我也没深入研究，猜测是更好地利用当前寄存器、缓存的值。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551523137,"ip_address":"","comment_id":72066,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551511119","product_id":100023901,"comment_content":"请问在双重锁检验的时候，编译器对new的优化，为什么要优化成先赋值再初始化呢？编译器优化出于什么目的这样优化呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441446,"discussion_content":"这个我也没深入研究，猜测是更好地利用当前寄存器、缓存的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551523137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72062,"user_name":"Tony Du","can_delete":false,"product_type":"c1","uid":1001661,"ip_address":"","ucode":"F5FCC400E615EA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/bd/6c7d4230.jpg","comment_is_top":false,"comment_ctime":1551510183,"is_pvip":false,"replies":[{"id":"26107","content":"是的，单核不存在可见性问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551522942,"ip_address":"","comment_id":72062,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551510183","product_id":100023901,"comment_content":"请问老师，同一个cpu上多个线程对同一共享变量的缓存是存在cpu同一个缓存上吗？如果是的，是不是可以理解为：单cpu的机器上的多线程编程不会有变量可见性问题？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441442,"discussion_content":"是的，单核不存在可见性问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551522942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72022,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1551500143,"is_pvip":false,"replies":[{"id":"26101","content":"这个要去问做Java编译器的那帮人，应该也是为了优化性能。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551522192,"ip_address":"","comment_id":72022,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551500143","product_id":100023901,"comment_content":"请问为什么双重锁的例子要对创建对象进行优化","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441427,"discussion_content":"这个要去问做Java编译器的那帮人，应该也是为了优化性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551522192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71892,"user_name":"褚超","can_delete":false,"product_type":"c1","uid":1202954,"ip_address":"","ucode":"76F6EAE673CE04","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/0a/e02b6a0f.jpg","comment_is_top":false,"comment_ctime":1551470111,"is_pvip":false,"replies":[{"id":"26083","content":"是的，多重保护总没有错。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551519841,"ip_address":"","comment_id":71892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551470111","product_id":100023901,"comment_content":"这个问题对64bit也试用吧，至少规范是这么多的。或许有些jvm的实现在64bit机器上可能可以保证是原子的，但是不能假定。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441381,"discussion_content":"是的，多重保护总没有错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551519841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71791,"user_name":"心安。","can_delete":false,"product_type":"c1","uid":1145246,"ip_address":"","ucode":"9DF230F4CFB475","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/9e/cb58102f.jpg","comment_is_top":false,"comment_ctime":1551433724,"is_pvip":false,"replies":[{"id":"25983","content":"是的，主要是硬盘和网卡<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551444570,"ip_address":"","comment_id":71791,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551433724","product_id":100023901,"comment_content":"老师，您好。我有一个问题，就是在文章最前面说的cpu会访问内存甚至IO，这里的IO指的的硬盘之类的持久化设备吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441331,"discussion_content":"是的，主要是硬盘和网卡\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551444570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71752,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1551426151,"is_pvip":false,"replies":[{"id":"25979","content":"io不止是dma，cpu把任务交给dma，cpu可以干别的工作，这样cpu利用率就上来了。否则cpu只能死等io,利用率就低t了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551440320,"ip_address":"","comment_id":71752,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551426151","product_id":100023901,"comment_content":"为什么说排队读文件会造成CPU使用率上升，文章中说的IO是DMA吗。CPU交给DMA就不管切换到别的线程了。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441314,"discussion_content":"io不止是dma，cpu把任务交给dma，cpu可以干别的工作，这样cpu利用率就上来了。否则cpu只能死等io,利用率就低t了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551440320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71727,"user_name":"布衣骇客","can_delete":false,"product_type":"c1","uid":1256280,"ip_address":"","ucode":"5226B0F67090D1","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/58/11c05ccb.jpg","comment_is_top":false,"comment_ctime":1551421213,"is_pvip":false,"replies":[{"id":"25935","content":"弄清楚和并发相关的就行，当然知道的越多越好。高级语言本来就要屏蔽那些底层细节，没屏蔽好，是语言没做好。可是语言就是没做好，怎么办呢，只能去钻底层了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551433511,"ip_address":"","comment_id":71727,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551421213","product_id":100023901,"comment_content":"理解老师的内存模型，JVM处理以及CPU指令等等是否需要把计算机原理这部分全都都弄清楚才能更好理解并发呢。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441300,"discussion_content":"弄清楚和并发相关的就行，当然知道的越多越好。高级语言本来就要屏蔽那些底层细节，没屏蔽好，是语言没做好。可是语言就是没做好，怎么办呢，只能去钻底层了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551433511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71726,"user_name":"一眼万年","can_delete":false,"product_type":"c1","uid":1018200,"ip_address":"","ucode":"7B0823E39AE809","user_header":"","comment_is_top":false,"comment_ctime":1551421152,"is_pvip":false,"replies":[{"id":"25936","content":"我写的有问题，是第一个线程进入同步块之后，另一个线程才开始调用<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551433614,"ip_address":"","comment_id":71726,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551421152","product_id":100023901,"comment_content":"双重检查问题，synchronized是作用在class下，表示所有class实例都被同步锁了，为什么还存在另一线程进入代码模块？老师请教下","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441299,"discussion_content":"我写的有问题，是第一个线程进入同步块之后，另一个线程才开始调用\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551433614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71716,"user_name":"腾达","can_delete":false,"product_type":"c1","uid":1079876,"ip_address":"","ucode":"72F9CFBA44FDEE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9hlAIKQ1sGDu16oWLOHyCSicr18XibygQSMLMjuDvKk73deDlH9aMphFsj41WYJh121aniaqBLiaMNg/132","comment_is_top":false,"comment_ctime":1551419782,"is_pvip":false,"replies":[{"id":"25933","content":"是的，要是能理解cpu微指令就更好了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551433327,"ip_address":"","comment_id":71716,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551419782","product_id":100023901,"comment_content":"getInstance() 单实例是否有问题，要是能有字节码级别或汇编级别的debug调试过程演示就更好了。否则都是在空谈","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441294,"discussion_content":"是的，要是能理解cpu微指令就更好了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551433327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71688,"user_name":"浪尘","can_delete":false,"product_type":"c1","uid":1303610,"ip_address":"","ucode":"DA82FBF16F47BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/3a/ca44a563.jpg","comment_is_top":false,"comment_ctime":1551414290,"is_pvip":false,"replies":[{"id":"25944","content":"所以有必要拜拜图灵，冯诺依曼","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551434509,"ip_address":"","comment_id":71688,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551414290","product_id":100023901,"comment_content":"现在感觉我写的代码平常在正常运行都是我运气好","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441277,"discussion_content":"所以有必要拜拜图灵，冯诺依曼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551434509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71643,"user_name":"深海","can_delete":false,"product_type":"c1","uid":1116765,"ip_address":"","ucode":"4C03ED20EA70CC","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/5d/72b34189.jpg","comment_is_top":false,"comment_ctime":1551406186,"is_pvip":false,"replies":[{"id":"25932","content":"线程安全的单例模式有很多方案，你可以在网上搜一下，都很容易理解。只有双重检查不太容易理解，所以就拿出来讲了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551433228,"ip_address":"","comment_id":71643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551406186","product_id":100023901,"comment_content":"那老师，关于有序性的正确写法是不是将这这双重判断方式改为同步方法？因为以前写单例的情况，findBugs 会提示改为同步方法，当时没有意识，现在想想好像是这个道理","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441251,"discussion_content":"线程安全的单例模式有很多方案，你可以在网上搜一下，都很容易理解。只有双重检查不太容易理解，所以就拿出来讲了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551433228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71596,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1551399433,"is_pvip":false,"replies":[{"id":"25948","content":"回头，要是有人能帮我写两篇就好了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551434729,"ip_address":"","comment_id":71596,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551399433","product_id":100023901,"comment_content":"老师的比喻太贴切了:<br><br> 教好学生，饿死师父!<br><br>给宝令老师点赞!","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441224,"discussion_content":"回头，要是有人能帮我写两篇就好了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551434729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71569,"user_name":"东海罗杰","can_delete":false,"product_type":"c1","uid":1349284,"ip_address":"","ucode":"AD8FF6BC796F66","user_header":"https://static001.geekbang.org/account/avatar/00/14/96/a4/c2063ce1.jpg","comment_is_top":false,"comment_ctime":1551371832,"is_pvip":false,"replies":[{"id":"25942","content":"下次要快<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551434372,"ip_address":"","comment_id":71569,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551371832","product_id":100023901,"comment_content":"评论区人才辈出，我一愣神的功夫已经失去答题的机会了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441210,"discussion_content":"下次要快\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551434372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71564,"user_name":"loading...","can_delete":false,"product_type":"c1","uid":1173826,"ip_address":"","ucode":"8670DAF96541F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/42/26c386ae.jpg","comment_is_top":false,"comment_ctime":1551370364,"is_pvip":false,"replies":[{"id":"25946","content":"话说高手都在留言区，不在民间啊！<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551434624,"ip_address":"","comment_id":71564,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551370364","product_id":100023901,"comment_content":"看了留言，大神好多啊，我要虚心学习了。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441206,"discussion_content":"话说高手都在留言区，不在民间啊！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551434624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71539,"user_name":"... ...","can_delete":false,"product_type":"c1","uid":1312354,"ip_address":"","ucode":"E214CAA6349A60","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/62/898449d3.jpg","comment_is_top":false,"comment_ctime":1551365480,"is_pvip":false,"replies":[{"id":"25938","content":"可见性是问题之一，还有原子性问题<br>示例代码只用来描述问题，考虑到手机屏幕小，所以省略了很多细节<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551433993,"ip_address":"","comment_id":71539,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551365480","product_id":100023901,"comment_content":"你好老师，文中两个线程的例子应该是原子性导致的吧！在count++上同步每次直一样。如果是可见性导致的话，那么在count上加上volatile就可以解决问题啊！<br>还有个小问题，实例变量不能直接用于静态方法中吧！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441193,"discussion_content":"可见性是问题之一，还有原子性问题\n示例代码只用来描述问题，考虑到手机屏幕小，所以省略了很多细节\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551433993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71535,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1551364627,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1551364627","product_id":100023901,"comment_content":"return test.count;","like_count":0},{"had_liked":false,"id":71512,"user_name":"小黄","can_delete":false,"product_type":"c1","uid":1049839,"ip_address":"","ucode":"519BF8191D3A6B","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/ef/fea0fdbd.jpg","comment_is_top":false,"comment_ctime":1551359651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551359651","product_id":100023901,"comment_content":"你在示例中已经说了count = count + 1存在可见性问题，那么说明普通的加法 都存在可见性问题，除非是原子加法。对吗？","like_count":0},{"had_liked":false,"id":71508,"user_name":"一塌糊涂","can_delete":false,"product_type":"c1","uid":1106566,"ip_address":"","ucode":"B55DAEFB98D83C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/86/90041355.jpg","comment_is_top":false,"comment_ctime":1551359501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551359501","product_id":100023901,"comment_content":"形象生动","like_count":0},{"had_liked":false,"id":71507,"user_name":"长眉_张永","can_delete":false,"product_type":"c1","uid":1442279,"ip_address":"","ucode":"B3DCA68BDD473E","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/e7/091804b7.jpg","comment_is_top":false,"comment_ctime":1551359221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551359221","product_id":100023901,"comment_content":"应该是A在锁后 创建对象  分配空间   此时cpu切换了到B了，才出现的问题不为null了","like_count":0},{"had_liked":false,"id":71502,"user_name":"长眉_张永","can_delete":false,"product_type":"c1","uid":1442279,"ip_address":"","ucode":"B3DCA68BDD473E","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/e7/091804b7.jpg","comment_is_top":false,"comment_ctime":1551358856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551358856","product_id":100023901,"comment_content":"讲的真带劲，好好消化！对于实际中双重检查的问题，真出现了，可能就当作灵异事件了","like_count":0},{"had_liked":false,"id":71496,"user_name":"jmdxy","can_delete":false,"product_type":"c1","uid":1189626,"ip_address":"","ucode":"445505E9C52BBB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epHS3pkexn0ibNg8kWxywRVavX7UIBBZ4kwhcmNYccvrLaP4fe0wcuHx550fTmzQwEAnoq3Rgw61RQ/132","comment_is_top":false,"comment_ctime":1551357661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551357661","product_id":100023901,"comment_content":"对于阿根一世同学的问题 文章里面已经说清楚了， new关键字 是先赋值，对象的地址。","like_count":0},{"had_liked":false,"id":71483,"user_name":"Knight²º¹⁸","can_delete":false,"product_type":"c1","uid":1089754,"ip_address":"","ucode":"BDCB830B6A730F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg","comment_is_top":false,"comment_ctime":1551353927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551353927","product_id":100023901,"comment_content":"其实阿根一屁世同学已经理解老师所讲的，但是对Synchronize的规则没有理解。","like_count":0},{"had_liked":false,"id":71468,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1551347874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551347874","product_id":100023901,"comment_content":"long数据类型64位在32位机器上会有并发产生，原因会产生原子性性问题，老师对底层原理讲的非常透彻，明天原理后就知道如何用哪种方法解决问题了","like_count":0},{"had_liked":false,"id":71451,"user_name":"沸羊羊","can_delete":false,"product_type":"c1","uid":1444143,"ip_address":"","ucode":"08B5B2C38A505D","user_header":"","comment_is_top":false,"comment_ctime":1551344681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551344681","product_id":100023901,"comment_content":"回复：【黄朋飞】文中的cache指的是cpu cache，cup-cache又分为L1-cache、L2-cache、L2-cache。建议补补组成原理再来看这个专栏","like_count":0},{"had_liked":false,"id":71449,"user_name":"ljp","can_delete":false,"product_type":"c1","uid":1109543,"ip_address":"","ucode":"44F4FE255F89A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/27/53c78632.jpg","comment_is_top":false,"comment_ctime":1551344423,"is_pvip":false,"replies":[{"id":"25681","content":"看完下一期的内容，你再想想，看能不能想通","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551370659,"ip_address":"","comment_id":71449,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551344423","product_id":100023901,"comment_content":"volatile有个疑问，加了这个关键字的变量，每次都先从缓存中同步到内存中才能使用，如果做同步之后，缓存的值被更改了，那当时同步的数据将变成脏数据。既然volatile无法保证数据的正确性，就只剩禁用指令重排的效果了，如果为了禁用指令重排，那为什么每次还从cpu的缓存取值呢？这样岂不是增加了复杂度吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441156,"discussion_content":"看完下一期的内容，你再想想，看能不能想通","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551370659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71446,"user_name":"17702158422","can_delete":false,"product_type":"c1","uid":1230682,"ip_address":"","ucode":"226342D3CB73BA","user_header":"","comment_is_top":false,"comment_ctime":1551344140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551344140","product_id":100023901,"comment_content":"@Gavin 说下我的理解，nio属于网络通信框架，相对于socket而言支持更多的并发连接，同一时刻多个线程同时如果对同一块内存变量操作就会引发线程不安全问题","like_count":0},{"had_liked":false,"id":71442,"user_name":"ljp","can_delete":false,"product_type":"c1","uid":1109543,"ip_address":"","ucode":"44F4FE255F89A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/27/53c78632.jpg","comment_is_top":false,"comment_ctime":1551343567,"is_pvip":false,"replies":[{"id":"25679","content":"什么时候写回，要看CPU的心情","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551370291,"ip_address":"","comment_id":71442,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551343567","product_id":100023901,"comment_content":"阅读第一个例子时，有个疑问：count的值0，从内存同步到cpu的缓存，执行+1指令后，在不加volatile的情况下，何时再从缓存写回内存呢？<br>我的理解是，执行+1指令后，立刻将缓存的值同步到内存，让出cpu缓存的空间。在下次+1的时候，重新将内存的值同步回缓存做+1操作。当多个线程同时从cpu缓存同步数据回内存时，由于各个cpu缓存的数据不一定相等，所以会导致内存值的不确定性。再次执行count+1时，重新从内存同步回缓存的值，将会以最近一次从缓存同步回内存的值为准，这样一直恶性循环下去，最终的结果会与预期差异很大。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441150,"discussion_content":"什么时候写回，要看CPU的心情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551370291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71417,"user_name":"哈哈哈","can_delete":false,"product_type":"c1","uid":1248876,"ip_address":"","ucode":"C40ABE7161EFAE","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/6c/1f3b1372.jpg","comment_is_top":false,"comment_ctime":1551337469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551337469","product_id":100023901,"comment_content":"双重检查的有疑问，重点应该不是线程切换，而是第一个线程对成员变量赋值，第二个线程可能看不到","like_count":0},{"had_liked":false,"id":71413,"user_name":"carryyou_sister","can_delete":false,"product_type":"c1","uid":1116537,"ip_address":"","ucode":"175DE9AF71377D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/UqX0llmKiabBHa8PvOUA4QMv3qmx4MfYBjia2gNvJ4X291CttHNtIjLeTyeh9ze0umJHLpQwxL8YTSiaagnMt4OAQ/132","comment_is_top":false,"comment_ctime":1551335865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551335865","product_id":100023901,"comment_content":"我也像上面那位老铁那样有9000多的值，求解释啊","like_count":0},{"had_liked":false,"id":71407,"user_name":"吴小仙","can_delete":false,"product_type":"c1","uid":1442639,"ip_address":"","ucode":"7C194C3BFEA246","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVMCWZkjAquKFLD2Gl9eSysz4xSVc7OicnPG4VR1g2x8S1uYbaSBw8iaRqCVZU1VugCvicLFBmGxxicw/132","comment_is_top":false,"comment_ctime":1551334787,"is_pvip":false,"replies":[{"id":"25676","content":"我还没模拟出来，不过你可以通过看字节码来确认问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551369992,"ip_address":"","comment_id":71407,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551334787","product_id":100023901,"comment_content":"老师，怎么模拟编译优化带来的问题？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441138,"discussion_content":"我还没模拟出来，不过你可以通过看字节码来确认问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551369992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71406,"user_name":"CCC","can_delete":false,"product_type":"c1","uid":1003738,"ip_address":"","ucode":"2E254444098267","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/da/ed4803cb.jpg","comment_is_top":false,"comment_ctime":1551334709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551334709","product_id":100023901,"comment_content":"针对这个问题：「对于双重锁检查那个例子，我有一个疑问，A如果没有完成实例的初始化，锁应该不会释放的，B是拿不到锁的，怎么还会出问题呢？」<br><br>其实线程B判断instance != null不是在synchronized块里，而是在第一个instance != null的地方，这地方是没锁的。","like_count":0},{"had_liked":false,"id":71404,"user_name":"你好呀","can_delete":false,"product_type":"c1","uid":1049361,"ip_address":"","ucode":"2E97656410BACA","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/11/f58c6278.jpg","comment_is_top":false,"comment_ctime":1551334368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551334368","product_id":100023901,"comment_content":"老王   催更了。。。。","like_count":0},{"had_liked":false,"id":71398,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1551332885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551332885","product_id":100023901,"comment_content":"老师讲地很深刻，<br><br>我回答一下 @阿根一世:<br><br>线程A还没到synchronized（Singleton.vlass）就被切换，也就是说，线程A刚进入instance方法就被切换了； 然后线程B开始执行，线程B进入getInstance方法，进入synchronized(Singleton.class) 拿到锁， 又按排序后new对应的CPU指令执行了前两条，1.先开辟一段内侧M，2.把M的地址赋给instance,第3步还没执行，线程B被切换了，但是线程B是拿着锁的，线程A是还没拿到锁的，但是线程A也不需要锁了，原因是什么呢？就是因为线程A的第一次 if(null == instance)<br>是false啊， 所以直接返回了，因此才会在多线程getInstance时第一次初始化还没完成的时候就可能会报诡异的空指针。","like_count":0},{"had_liked":false,"id":71394,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1551332195,"is_pvip":false,"replies":[{"id":"25674","content":"不能保证不被切换。线程B要执行synchronized{}里面的内容，需要获得锁，这个时候是获取不到的，因为被线程A占着呢。所以线程B会被挂起。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551369840,"ip_address":"","comment_id":71394,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551332195","product_id":100023901,"comment_content":"另外，像getInstance方法， synchronized lock 这些锁能保证多线程下抢占被这些修饰的方法或者变量时， 当前获取到锁的线程 能不被切换吗？  <br><br>或者， 假设只有线程A和线程B， A抢到锁后，cpu调度可能被切换到线程B吗？ 如果切换到线程B是不是就是继续等待线程A释放当前锁？ 然后时间片执行完之后，又切回到线程A, 线程A继续正常执行？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441133,"discussion_content":"不能保证不被切换。线程B要执行synchronized{}里面的内容，需要获得锁，这个时候是获取不到的，因为被线程A占着呢。所以线程B会被挂起。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551369840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71340,"user_name":"boyLi","can_delete":false,"product_type":"c1","uid":1251030,"ip_address":"","ucode":"3FD75E9B197A37","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/d6/97f6af3f.jpg","comment_is_top":false,"comment_ctime":1551323424,"is_pvip":false,"replies":[{"id":"25670","content":"不会，JVM能保证。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551369531,"ip_address":"","comment_id":71340,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551323424","product_id":100023901,"comment_content":"老师，使用静态内部类的方式实现单例模式，会不会出现线程安全的问题呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441114,"discussion_content":"不会，JVM能保证。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551369531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71339,"user_name":"better789","can_delete":false,"product_type":"c1","uid":1103033,"ip_address":"","ucode":"39B92D6405A4D4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ergYdR0OZhfht5f0BhZ6tdzvMcnZqLGshwj2mj3nuuKIfqBXYxOicxHUR97dVqNapHZztibEF2AXImw/132","comment_is_top":false,"comment_ctime":1551323346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551323346","product_id":100023901,"comment_content":"Null是值不是对象，判断为Null直接返回对象，而不会去获取锁。","like_count":0},{"had_liked":false,"id":71336,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1551323072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551323072","product_id":100023901,"comment_content":"大家有疑问的是，锁没有释放，为啥线程2能够获取，其实线程二无法获取锁的，第一个instance==null线程2直接返回了一个未创建完成的对象，当使用这个对象时就有问题了","like_count":0},{"had_liked":false,"id":71321,"user_name":"青年术摄","can_delete":false,"product_type":"c1","uid":1390415,"ip_address":"","ucode":"F8C5E379BEAB8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/4f/bc5f120d.jpg","comment_is_top":false,"comment_ctime":1551319842,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1551319842","product_id":100023901,"comment_content":"双锁检查那个线程B拿到未初始化的实例，老师的意思是：线程A，B不在同时进行，当线程A执行完将M的地址赋值给instance变量时，CPU切换时间片，恰好线程B执行了，并且拿到了CPU的使用权，在第一个条件判断的后就拿到了未初始化的instance。","like_count":0},{"had_liked":false,"id":71309,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1551317910,"is_pvip":false,"replies":[{"id":"25664","content":"目前编译器还没这么智能","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551369101,"ip_address":"","comment_id":71309,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551317910","product_id":100023901,"comment_content":"课后思考题：<br>      32位操作系统对long进行加减操作存在并发隐患，我的答案是会存在并发隐患。<br>long是64位的，在加载到缓存的时候，需要两个缓存行存储。如果线程A操作完低32位，时间片耗尽，切换另外一个线程，操作了两个缓存行，然后线程A进行执行，结果可能会不可预期。感觉编译器会通过同步机制把对两个缓存行的操作变成原子操作。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441103,"discussion_content":"目前编译器还没这么智能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551369101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71293,"user_name":"wwj","can_delete":false,"product_type":"c1","uid":1053787,"ip_address":"","ucode":"B98AE5F5D85A87","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzvaL724GwtzZ5mcldUnlicicSlI8BXL9icRZbUOB10qjRMlmog7UTvwxSBHXagnPGGR1BYdjWcGGSg/132","comment_is_top":false,"comment_ctime":1551316923,"is_pvip":false,"replies":[{"id":"25661","content":"下一期讲内存模型","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368751,"ip_address":"","comment_id":71293,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551316923","product_id":100023901,"comment_content":"对内存模型理解不深刻、实际上书和资料都不少、但感觉都一样、只说结果、没有细致分析、希望这次有所收获","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441095,"discussion_content":"下一期讲内存模型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71291,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1551316644,"is_pvip":false,"replies":[{"id":"25660","content":"多谢！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368730,"ip_address":"","comment_id":71291,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551316644","product_id":100023901,"comment_content":"看到很多同学对双重检锁有疑问，我解释下:线程B指的是对第一个if语句进行判断，因为instance有地址，所以直接返回。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441094,"discussion_content":"多谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71271,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1551315204,"is_pvip":false,"replies":[{"id":"25655","content":"YES","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551368402,"ip_address":"","comment_id":71271,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551315204","product_id":100023901,"comment_content":"双重检测加锁是在内部第二次，如果线程Ｂ在第一次检测是否为空，此时A线程部分初始化，但是对象也不为空，Ｂ线程获取到的对象没有完全初始化的对象，使用会有问题","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441081,"discussion_content":"YES","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551368402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71270,"user_name":"刘凯","can_delete":false,"product_type":"c1","uid":1443775,"ip_address":"","ucode":"90A7A0D5177C64","user_header":"https://static001.geekbang.org/account/avatar/00/16/07/bf/120e10ea.jpg","comment_is_top":false,"comment_ctime":1551315139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551315139","product_id":100023901,"comment_content":"双重检查讲的是对的，我看错了，判断是否为null不需要锁就能判断","like_count":0}]}