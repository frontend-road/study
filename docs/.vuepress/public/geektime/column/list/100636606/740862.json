{"id":740862,"title":"第 2 章 Spring Framework 中的 IoC 容器(2)","content":"<h2 id=\"nav_point_33\">2.3　定制容器与 Bean 的行为</h2>\n<p>通常，Spring Framework 包揽了大部分工作，替我们管理 Bean 的创建与依赖，将各种组件装配成一个可运行的应用。然而，有些情况下，我们会有自己的特殊需求。例如，在 Bean 的依赖被注入后，我们想要触发 Bean 的回调方法做一些初始化；在 Bean 销毁前，我们想要执行一些清理工作；我们想要 Bean 感知容器的一些信息，拿到当前的上下文自行进行判断或处理……</p>\n<p>这时候，怎么做？Spring Framework 为我们预留了发挥空间。本节我们就来探讨一下如何根据自己的需求来定制容器与 Bean 的行为。</p>\n<h3 id=\"nav_point_34\">2.3.1　Bean 的生命周期</h3>\n<p>Spring 容器接管了 Bean 的整个生命周期管理，具体如图 2-2 所示。一个 Bean 先要经过 Java 对象的创建（也就是通过 <code>new</code> 关键字创建一个对象），随后根据容器里的配置注入所需的依赖，最后调用初始化的回调方法，经过这三个步骤才算完成了 Bean 的初始化。若不再需要这个 Bean，则要进行销毁操作，在正式销毁对象前，会先调用容器的销毁回调方法。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00757.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2-2　Bean 的生命周期</strong></p>\n<p>由于一切都是由 Spring 容器管理的，所以我们无法像自己控制这些动作时那样任意地在 <strong>Bean 创建后</strong>或 <strong>Bean 销毁前</strong>增加某些操作。为此，Spring Framework 为我们提供了几种途径，在这两个时间点调用我们提供给容器的回调方法。可以根据不同情况选择以下三种方式之一：</p><!-- [[[read_end]]] -->\n<ul>\n<li>实现 <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口；</li>\n<li>使用 JSR-250 的 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解；</li>\n<li><p>在 <code>&lt;bean/&gt;</code> 或 <code>@Bean</code> 里配置初始化和销毁方法。</p>\n</li>\n<li><p><strong>创建 Bean 后的回调动作</strong></p>\n<p>如果我们希望在创建 Bean 后做一些特别的操作，比如查询数据库初始化缓存等，Spring Framework 可以提供一个初始化方法。<code>InitializingBean</code> 接口有一个 <code>afterPropertiesSet()</code> 方法——顾名思义，就是在所有依赖都注入后自动调用该方法。在方法上添加 <code>@PostConstruct</code> 注解也有相同的效果。</p>\n<p>也可以像下面这样，在 XML 文件中进行配置：</p>\n<pre class=\"code-rows\"><code>&lt;bean id=\"hello\" class=\"learning.spring.helloworld.Hello\" init-method=\"init\" /&gt;</code></pre>\n<p>或者在 Java 配置中指定：</p>\n<pre class=\"code-rows\"><code>@Bean(initMethod=\"init\")\npublic Hello hello() {...}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>销毁 Bean 前的回调动作</strong></p>\n<p>Spring Framework 既然有创建 Bean 后的回调动作，自然也有销毁 Bean 前的触发操作。<code>DisposableBean</code> 接口中的 <code>destroy()</code> 方法和添加了 <code>@PreDestroy</code> 注解的方法都能实现这个目的，如代码示例 2-16 所示。</p>\n<blockquote>\n<p><strong>代码示例 2-16</strong>　实现了 <code>DisposableBean</code> 接口的类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.helloworld;\n\nimport org.springframework.beans.factory.DisposableBean;\n\npublic class Hello implements DisposableBean {\n    public String hello() {\n        return \"Hello World!\";\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        System.out.println(\"See you next time.\");\n    }\n}</code></pre>\n<p>当然，也可以在 <code>&lt;bean/&gt;</code> 中指定 <code>destroy-method</code>，或者在 <code>@Bean</code> 中指定 <code>destroyMethod</code>。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>生命周期动作的组合</strong></p>\n<p>如果我们混合使用上文提到的几种不同的方式，而且这些方式指定的方法还不尽相同，那就需要明确它们的执行顺序了。</p>\n<p>无论是初始化还是销毁，Spring 都会按照如下顺序依次进行调用：</p>\n<p>(1) 添加了 <code>@PostConstruct</code> 或 <code>@PreDestroy</code> 的方法；</p>\n<p>(2) 实现了 <code>InitializingBean</code> 的 <code>afterPropertiesSet()</code> 方法，或 <code>DisposableBean</code> 的 <code>destroy()</code> 方法；</p>\n<p>(3) 在 <code>&lt;bean/&gt;</code> 中配置的 <code>init-method</code> 或 <code>destroy-method</code>，<code>@Bean</code> 中配置的 <code>initMethod</code> 或 <code>destroyMethod</code>。</p>\n<p>在代码示例 2-17<span class=\"comment-number\">19</span> 的 Java 类中，同时提供了三个销毁的方法。</p>\n<blockquote>\n<p><strong>代码示例 2-17</strong>　添加了多个销毁方法的 <code>Hello</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.helloworld;\n\nimport javax.annotation.PreDestroy;\nimport org.springframework.beans.factory.DisposableBean;\n\npublic class Hello implements DisposableBean {\n    public String hello() {\n        return \"Hello World!\";\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        System.out.println(\"destroy()\");\n    }\n\n    public void close() {\n        System.out.println(\"close()\");\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        System.out.println(\"shutdown()\");\n    }\n}</code></pre>\n<p>在对应的 XML 文件中配置 <code>destroy-method</code>，要用 <code>&lt;context:annotation-config /&gt;</code> 开启注解支持，如代码示例 2-18 所示。</p>\n<blockquote>\n<p><strong>代码示例 2-18</strong>　对应的 beans.xml 文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n\n    &lt;context:annotation-config /&gt;\n\n    &lt;bean id=\"hello\" class=\"learning.spring.helloworld.Hello\" destroy-method=\"close\" /&gt;\n&lt;/beans&gt;</code></pre>\n<p>代码示例 2-19 对运行类简单做了些调整，增加了关闭容器的动作，以便能让我们观察到 Bean 销毁的动作。</p>\n<blockquote>\n<p><strong>代码示例 2-19</strong>　启动用的 <code>Application</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class Application {\n    private ClassPathXmlApplicationContext applicationContext;\n\n    public static void main(String[] args) {\n        Application application = new Application();\n        application.sayHello();\n        application.close();\n    }\n\n    public Application() {\n        applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\");\n    }\n\n    public void sayHello() {\n        Hello hello = (Hello) applicationContext.getBean(\"hello\");\n        System.out.println(hello.hello());\n    }\n\n    public void close() {\n        applicationContext.close();\n    }\n}</code></pre>\n<p>这段代码运行后的输出即代表了三个方法的调用顺序，是与上述顺序一致的：</p>\n<pre class=\"code-rows\"><code>Hello World!\nshutdown()\ndestroy()\nclose()</code></pre>\n<p>当然，在一般情况下，我们并不会在一个 Bean 上写几个作用不同的初始化或销毁方法。这种情况并不常见，大家了解即可。</p>\n</li>\n</ul>\n\n<h3 id=\"nav_point_35\">2.3.2　Aware 接口的应用</h3>\n<p>在大部分情况下，我们的 Bean 感知不到 Spring 容器的存在，也无须感知。但总有那么一些场景中我们要用到容器的一些特殊功能，这时就可以使用 Spring Framework 提供的很多 <code>Aware</code> 接口，让 Bean 能感知到容器的诸多信息。此外，有些容器相关的 Bean 不能由我们自己来创建，必须由容器创建后注入我们的 Bean 中。</p>\n<p>例如，如果希望在 Bean 中获取容器信息，可以通过如下两种方式：</p>\n<ul>\n<li>实现 <code>BeanFactoryAware</code> 或 <code>ApplicationContextAware</code> 接口；</li>\n<li>用 <code>@Autowired</code> 注解来注入 <code>BeanFactory</code> 或 <code>ApplicationContext</code>。</li>\n</ul>\n<p>两种方式的本质都是一样的，即让容器注入一个 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 对象。<code>ApplicationContextAware</code> 是下面这样的：</p>\n<pre class=\"code-rows\"><code>public interface ApplicationContextAware {\n    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n}</code></pre>\n<p>在拿到 <code>ApplicationContext</code> 后，就能操作该对象，比如调用 <code>getBean()</code> 方法取得想要的 Bean。能直接操作 <code>ApplicationContext</code> 有时可以带来很多便利，因此这个接口相比其他的 <code>Aware</code> 接口“出镜率”更高一些。</p>\n<p>如果 Bean 希望获得自己在容器中定义的 Bean 名称，可以实现 <code>BeanNameAware</code> 接口。这个接口的 <code>setBeanName()</code> 方法就是注入一个代表名称的字符串，也算是一个依赖，因此会在 2.3.1 节提到的初始化方法前被执行。</p>\n<p>在 2.3.3 节中会提到 Spring 容器的事件机制，这时就会用到 <code>ApplicationEventPublisher</code> 来发送事件，可以实现 <code>ApplicationEventPublisherAware</code> 接口，从容器中获得 <code>ApplicationEventPublisher</code> 实例。</p>\n<p>Spring Framework 中还有很多其他 <code>Aware</code> 接口，感兴趣的话，大家可以查阅官方文档了解更多详情。</p>\n<h3 id=\"nav_point_36\">2.3.3　事件机制</h3>\n<p><code>ApplicationContext</code> 提供了一套事件机制，在容器发生变动时我们可以通过 <code>ApplicationEvent</code> 的子类通知到 <code>ApplicationListener</code> 接口的实现类，做对应的处理。例如，<code>ApplicationContext</code> 在启动、停止、关闭和刷新 <span class=\"comment-number\">20</span> 时，分别会发出 <code>ContextStartedEvent</code>、<code>ContextStoppedEvent</code>、<code>ContextClosedEvent</code> 和 <code>ContextRefreshedEvent</code> 事件，这些事件就让我们有机会感知当前容器的状态。</p>\n\n<p>我们也可以自己监听这些事件，只需实现 <code>ApplicationListener</code> 接口或者在某个 Bean 的方法上增加 <code>@EventListener</code> 注解即可，例如代码示例 2-20 和代码示例 2-21<span class=\"comment-number\">21</span> 就用以上两种方式分别处理了 <code>ContextClosedEvent</code> 事件。</p>\n\n<blockquote>\n<p><strong>代码示例 2-20</strong>　用 <code>ApplicationListener</code> 接口处理 <code>ContextClosedEvent</code> 事件的 <code>ContextClosedEventListener</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Order(1)\npublic class ContextClosedEventListener implements ApplicationListener&lt;ContextClosedEvent&gt; {\n    @Override\n    public void onApplicationEvent(ContextClosedEvent event) {\n        System.out.println(\"[ApplicationListener]ApplicationContext closed.\");\n    }\n}</code></pre>\n<blockquote>\n<p><strong>代码示例 2-21</strong>　用 <code>@EventListener</code> 注解处理 <code>ContextClosedEvent</code> 事件的 <code>ContextClosedEventAnnotationListener</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\npublic class ContextClosedEventAnnotationListener {\n    @EventListener\n    @Order(2)\n    public void onEvent(ContextClosedEvent event) {\n        System.out.println(\"[@EventListener]ApplicationContext closed.\");\n    }\n}</code></pre>\n<p>在运行 ch2/helloworld-event 中的 <code>Application</code> 后会得到如下输出：</p>\n<pre class=\"code-rows\"><code>上略……\n[ApplicationListener]ApplicationContext closed.\n[@EventListener]ApplicationContext closed.</code></pre>\n<p>可以看到两个类都处理了 <code>ContextClosedEvent</code> 事件，我们通过 <code>@Order</code> 可以指定处理的顺序。</p>\n<p>这套机制不仅适用于 Spring Framework 的内置事件，也非常方便我们定义自己的事件，不过该事件必须继承 <code>ApplicationEvent</code>，而且产生事件的类需要实现 <code>ApplicationEventPublisherAware</code>，还要从上下文中获取到 <code>ApplicationEventPublisher</code>，用它来发送事件。代码示例 2-22 是事件生产者 <code>CustomEventPublisher</code> 类的代码片段。</p>\n<blockquote>\n<p><strong>代码示例 2-22</strong>　生产事件的 <code>CustomEventPublisher</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\npublic class CustomEventPublisher implements ApplicationEventPublisherAware {\n    private ApplicationEventPublisher publisher;\n\n    public void fire() {\n        publisher.publishEvent(new CustomEvent(\"Hello\"));\n    }\n\n    @Override\n    public void setApplicationEventPublisher( ApplicationEventPublisher applicationEventPublisher) {\n        this.publisher = applicationEventPublisher;\n    }\n}</code></pre>\n<p>对应的事件监听代码也非常简单，对应方法如下：</p>\n<pre class=\"code-rows\"><code>@EventListener\npublic void onEvent(CustomEvent customEvent) {\n    System.out.println(\"CustomEvent Source: \" + customEvent.getSource());\n}</code></pre>\n<p>在运行 ch2/helloworld-event 中的 <code>Application</code> 后会得到如下输出：</p>\n<pre class=\"code-rows\"><code>上略……\nCustomEvent Source: Hello\n下略……</code></pre>\n<p><code>@EventListener</code> 还有一些其他的用法，比如，在监听到事件后希望再发出另一个事件，这时可以将方法返回值从 <code>void</code> 修改为对应事件的类型；<code>@EventListener</code> 也可以与 <code>@Async</code> 注解结合，实现在另一个线程中处理事件。关于 <code>@Async</code> 注解，我们会在 2.4.2 节中进行说明。</p>\n<h3 id=\"nav_point_37\">2.3.4　容器的扩展点</h3>\n<p>Spring 容器是非常灵活的，Spring Framework 中有很多机制是通过容器自身的扩展点来实现的，比如 Spring AOP 等。如果我们想在 Spring Framework 上封装自己的框架或功能，也可以充分利用容器的扩展点。</p>\n<p><code>BeanPostProcessor</code> 接口是用来定制 Bean 的，顾名思义，这个接口是 Bean 的后置处理器，在 Spring 容器初始化 Bean 时可以加入我们自己的逻辑。该接口中有两个方法，<code>postProcessBeforeInitialization()</code> 方法在 Bean 初始化前执行，<code>postProcessAfterInitialization()</code> 方法在 Bean 初始化之后执行。如果有多个 <code>BeanPostProcessor</code>，可以通过 <code>Ordered</code> 接口或者 <code>@Order</code> 注解来指定运行的顺序。代码示例 2-23<span class=\"comment-number\">22</span> 演示了 <code>BeanPostProcessor</code> 的基本用法。</p>\n\n<blockquote>\n<p><strong>代码示例 2-23</strong>　打印信息的 <code>HelloBeanPostProcessor</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class HelloBeanPostProcessor implements BeanPostProcessor {\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        if (\"hello\".equals(beanName)) {\n            System.out.println(\"Hello postProcessBeforeInitialization\");\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        if (\"hello\".equals(beanName)) {\n            System.out.println(\"Hello postProcessAfterInitialization\");\n        }\n        return bean;\n    }\n}</code></pre>\n<p>我们在对应的 <code>Hello</code> 中，也增加一个带 <code>@PostConstruct</code> 注解的方法，执行 ch2/helloworld-processor 中的 <code>Application</code> 类，验证一下方法的执行顺序是否与大家预想的一样：</p>\n<pre class=\"code-rows\"><code>Hello postProcessBeforeInitialization\nHello PostConstruct\nHello postProcessAfterInitialization</code></pre>\n<p>如果说 <code>BeanPostProcessor</code> 是 Bean 的后置处理器，那 <code>BeanFactoryPostProcessor</code> 就是 <code>BeanFactory</code> 的后置处理器，我们可以通过它来定制 Bean 的配置元数据，其中的 <code>postProcessBeanFactory()</code> 方法会在 <code>BeanFactory</code> 加载所有 Bean 定义但尚未对其进行初始化时介入。它的用法与 <code>BeanPostProcessor</code> 类似，此处就不再赘述了。需要注意的是，如果用 Java 配置类来注册，那么方法需要声明为 <code>static</code>。2.4.1 节中会讲到的 <code>PropertySourcesPlaceholderConfigurer</code> 就是一个 <code>BeanFactoryPostProcessor</code> 的实现。</p>\n<p>需要重点说明一下，由于 Spring AOP 也是通过 <code>BeanPostProcessor</code> 实现的，因此实现该接口的类，以及其中直接引用的 Bean 都会被特殊对待，<strong>不会</strong>被 AOP 增强。此外，<code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 都仅对当前容器上下文的 Bean 有效，不会去处理其他上下文。</p>\n<h3 id=\"nav_point_38\">2.3.5　优雅地关闭容器</h3>\n<p>Java 进程在退出时，我们可以通过 <code>Runtime.getRuntime().addShutdownHook()</code> 方法添加一些钩子，在关闭进程时执行特定的操作。如果是 Spring 应用，在进程退出时也要能正确地执行一些清理的方法。</p>\n<p><code>ConfigurableApplicationContext</code> 接口扩展自 <code>ApplicationContext</code>，其中提供了一个 <code>registerShutdownHook()</code>。<code>AbstractApplicationContext</code> 类实现了该方法，正是调用了前面说到的 <code>Runtime.getRuntime().addShutdownHook()</code>，并且在其内部调用了 <code>doClose()</code> 方法。</p>\n<p>设想在生产代码里有这么一种情况：一个 Bean 通过 <code>ApplicationContextAware</code> 注入了 <code>ApplicationContext</code>，业务代码根据逻辑判断从 <code>ApplicationContext</code> 中取出对应名称的 Bean，再进行调用；问题出现在应用程序关闭时，容器已经开始销毁 Bean 了，可是这段业务代码还在执行，仍在继续尝试从容器中获取 Bean，而且代码还没正确处理此处的异常……这该如何是好？</p>\n<p>针对这种情况，我们可以借助 Spring Framework 提供的 <code>Lifecycle</code> 来感知容器的启动和停止，容器会将启动和停止的信号传播给实现了该接口的组件和上下文。为了让例子能够简单一些，我们把问题简化一下：<code>Hello.hello()</code> 在容器关闭前后返回不同的内容，如代码示例 2-24<span class=\"comment-number\">23</span> 所示。</p>\n\n<blockquote>\n<p><strong>代码示例 2-24</strong>　实现了 <code>Lifecycle</code> 接口的 <code>Hello</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class Hello implements Lifecycle {\n    private boolean flag = false;\n\n    public String hello() {\n        return flag ? \"Hello World!\" : \"Bye!\";\n    }\n\n    @Override\n    public void start() {\n        System.out.println(\"Context Started.\");\n        flag = true;\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"Context Stopped.\");\n        flag = false;\n    }\n\n    @Override\n    public boolean isRunning() {\n        return flag;\n    }\n}</code></pre>\n<p>我们将对应的 <code>Application</code> 类也做相应调整，具体如代码示例 2-25 所示。</p>\n<blockquote>\n<p><strong>代码示例 2-25</strong>　调整后的 <code>Application</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\npublic class Application {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext applicationContext =\n            new AnnotationConfigApplicationContext(Application.class);\n        applicationContext.start(); // 这会触发Lifecycle的start()\n        Hello hello = applicationContext.getBean(\"hello\", Hello.class);\n        System.out.println(hello.hello());\n        applicationContext.close(); // 这会触发Lifecycle的stop()\n        System.out.println(hello.hello());\n    }\n\n    @Bean\n    public Hello hello() {\n        return new Hello();\n    }\n}</code></pre>\n<p>上述代码的执行结果如下：</p>\n<pre class=\"code-rows\"><code>Context Started.\nHello World!\nContext Stopped.\nBye!</code></pre>\n<p>除此之外，我们还可以借助 Spring Framework 的事件机制，在上下文关闭时会发出 <code>ContextClosedEvent</code>，监听该事件也可以触发业务代码做对应的操作。</p>\n<blockquote>\n<p><strong>茶歇时间：Linux 环境下如何关闭进程</strong></p>\n<p>在 Linux 环境下，大家常用 <code>kill</code> 命令来关闭进程，其实是 <code>kill</code> 命令给进程发送了一个信号（通过 <code>kill -l</code> 命令可以查看信号列表）。不带参数的“<code>kill 进程号</code>”发送的是 <code>SIGTERM(15)</code>，一般程序在收到这个信号后都会先释放资源，再停止；但有时程序可能还是无法退出，这时就可以使用“<code>kill -9 进程号</code>”，发送 <code>SIGKILL(9)</code>，直接杀死进程。</p>\n<p>一般不建议直接使用 <code>-9</code>，因为非正常地中断程序可能会造成一些意料之外的情况，比如业务逻辑处理到一半，恢复手段不够健全的话，可能需要人工介入处理那些执行到一半的内容。</p>\n</blockquote>\n<h2 id=\"nav_point_39\">2.4　容器中的几种抽象</h2>\n<p>Spring Framework 针对研发和运维过程中的很多常见场景做了抽象处理，比如本节中会讲到的针对运行环境的抽象，后续章节中会聊到的事务抽象等。正是因为存在这些抽象层，Spring Framework 才能为我们屏蔽底层的很多细节。</p>\n<h3 id=\"nav_point_40\">2.4.1　环境抽象</h3>\n<p>自诞生之日起，Java 程序就一直宣传自己是“Write once, run anywhere”，但往往现实并非如此——虽然有 JVM 这层隔离，但我们的程序还是需要应对不同的运行环境细节：比如使用了 WebLogic 的某些特性会导致程序很难迁移到 Tomcat 上；此外，程序还要面对开发、测试、预发布、生产等环境的配置差异；在云上，不同可用区（availability zone）可能也有细微的差异。Spring Framework 的环境抽象可以简化大家在处理这些问题时的复杂度，代表程序运行环境的 <code>Environment</code> 接口包含两个关键信息——Profile 和 Properties，下面我们将详细展开这两项内容。</p>\n<ol>\n<li><p><strong>Profile 抽象</strong></p>\n<p>假设我们的系统在测试环境中不需要加载监控相关的 Bean，而在生产环境中则需要加载；亦或者针对不同的客户要求，A 客户要求我们部署的系统直接配置数据库连接池，而 B 客户要求通过 JNDI 获取连接池。此时，就可以利用 Profile 帮我们解决这些问题。</p>\n<p>如果使用 XML 进行配置，可以在 <code>&lt;beans/&gt;</code> 的 <code>profile</code> 属性中进行设置。如果使用 Java 类的配置方式，可以在带有 <code>@Configuration</code> 注解的类上，或者在带有 <code>@Bean</code> 注解的方法上添加 <code>@Profile</code> 注解，并在其中指定该配置生效的具体 Profile，就像代码示例 2-26 那样。</p>\n<blockquote>\n<p><strong>代码示例 2-26</strong>　针对开发和测试环境的不同 Java 配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@Profile(\"dev\")\npublic class DevConfig {\n    @Bean\n    public Hello hello() {\n        Hello hello = new Hello();\n        hello.setName(\"dev\");\n        return hello;\n    }\n}\n\n@Configuration\n@Profile(\"test\")\npublic class TestConfig {\n    @Bean\n    public Hello hello() {\n        Hello hello = new Hello();\n        hello.setName(\"test\");\n        return hello;\n    }\n}</code></pre>\n<p>通过如下两种方式可以指定要激活的 Profile（多个 Profile 用逗号分隔）：</p>\n<ul>\n<li><code>ConfigurableEnvironment.setActiveProfiles()</code> 方法指定要激活的 Profile（通过 <code>ApplicationContext.getEnvironment()</code> 方法可获得 <code>Environment</code>）；</li>\n<li><code>spring.profiles.active</code> 属性指定要激活的 Profile（可以用系统环境变量、JVM 参数等方式指定，能通过 <code>PropertySource</code> 找到即可，在第 4 章会详细介绍 Spring Boot 的属性加载机制）。</li>\n</ul>\n<p>例如，启动程序时，在命令行中增加 <code>spring.profiles.active</code>：</p>\n<pre class=\"code-rows\"><code>▸ java -Dspring.profiles.active=\"dev\" -jar xxx.jar</code></pre>\n<p>Spring Framework 还提供了默认的 Profile，一般名为 <code>default</code>，但也可以通过 <code>ConfigurableEnvironment.setDefaultProfiles()</code> 和 <code>spring.profiles.default</code> 来修改这个名称。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>PropertySource 抽象</strong></p>\n<p>Spring Framework 中会频繁用到属性值，而这些属性又来自于很多地方，<code>PropertySource</code> 抽象就屏蔽了这层差异，例如，可以从 JNDI、JVM 系统属性（<code>-D</code> 命令行参数，<code>System.getProperties()</code> 方法能取得系统属性）和操作系统环境变量中加载属性。</p>\n<p>在 Spring 中，一般属性用小写单词表示并用点分隔，比如 <code>foo.bar</code>，如果是从环境变量中获取属性，会按照 <code>foo.bar</code>、<code>foo_bar</code>、<code>FOO.BAR</code> 和 <code>FOO_BAR</code> 的顺序来查找。4.3.2 节还有加载属性相关的内容，届时还会进一步说明。</p>\n<p>我们可以像下面这样来获得属性 <code>foo.bar</code>：</p>\n<pre class=\"code-rows\"><code>public class Hello {\n    @Autowired\n    private Environment environment;\n\n    public void hello() {\n        System.out.println(\"foo.bar: \" + environment.getProperty(\"foo.bar\"));\n    }\n}</code></pre>\n<p>我们在 2.2.3 节中看到过 <code>@Value</code> 注解，它也能获取属性，获取不到时则返回默认值：</p>\n<pre class=\"code-rows\"><code>public class Hello {\n    @Value(\"$\") // :后是默认值\n    private String value;\n\n    public void hello() {\n        System.out.println(\"foo.bar: \" + value);\n    }\n}</code></pre>\n<p><code>${}</code> 占位符可以出现在 Java 类配置或 XML 文件中，Spring 容器会试图从各种已经配置了的来源中解析属性。要添加属性来源，可以在 <code>@Configuration</code> 类上增加 <code>@PropertySource</code> 注解，例如：</p>\n<pre class=\"code-rows\"><code>@Configuration\n@PropertySource(\"classpath:/META-INF/resources/app.properties\")\npublic class Config {...}</code></pre>\n<p>如果使用 XML 进行配置，可以像下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;context:property-placeholder location=\"classpath:/META-INF/resources/app.properties\" /&gt;</code></pre>\n<p>通常我们的预期是一定能找到需要的属性，但也有这个属性可有可无的情况，这时将注解的 <code>ignoreResourceNotFound</code> 或者 XML 文件的 <code>ignore-resource-not-found</code> 设置为 <code>true</code> 即可。如果存在多个配置，则可以通过 <code>@Order</code> 注解或 XML 文件的 <code>order</code> 属性来指定顺序。</p>\n<p>也许大家会好奇，Spring Framework 是如何实现占位符解析的，这一切要归功于 <code>PropertySourcesPlaceholderConfigurer</code> 这个 <code>BeanFactoryPostProcessor</code>。如果使用 <code>&lt;context:property-placeholder/&gt;</code>，Spring Framework 会自动注册一个 <code>PropertySourcesPlaceholderConfigurer</code><span class=\"comment-number\">24</span>，如果是 Java 配置，则需要我们自己用 <code>@Bean</code> 来注册一个，例如：</p>\n<pre class=\"code-rows\"><code>@Bean\npublic static PropertySourcesPlaceholderConfigurer configurer() {\n    return new PropertySourcesPlaceholderConfigurer();\n}</code></pre>\n<p>在它的 <code>postProcessBeanFactory()</code> 方法中，Spring 会尝试用找到的属性值来替换上下文中的对应占位符，这样在 Bean 正式初始化时我们就不会再看到占位符，而是实际替换后的值。</p>\n<p>我们也可以定义自己的 <code>PropertySource</code> 实现，将它添加到 <code>ConfigurableEnvironment.getPropertySources()</code> 返回的 <code>PropertySources</code> 中即可，Spring Cloud Config 其实就使用了这种方式。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_41\">2.4.2　任务抽象</h3>\n<p>看过了与环境相关的抽象后，我们再来看看与任务执行相关的内容。Spring Framework 通过 <code>TaskExecutor</code> 和 <code>TaskScheduler</code> 这两个接口分别对任务的异步执行与定时执行进行了抽象，接下来就让我们一起来了解一下。</p>\n<ol>\n<li><p><strong>异步执行</strong></p>\n<p>Spring Framework 的 <code>TaskExecutor</code> 抽象是在 2.0 版本时引入的，<code>Executor</code> 是 Java 5 对线程池概念的抽象，如果了解 JUC（<code>java.util.concurrent</code>）的话，一定会知道 <code>java.util.concurrent.Executor</code> 这个接口，而 <code>TaskExecutor</code> 就是在它的基础上又做了一层封装，让我们可以方便地在 Spring 容器中配置多线程相关的细节。</p>\n<p><code>TaskExecutor</code> 有很多实现，例如，同步的 <code>SyncTaskExecutor</code>；每次创建一个新线程的 <code>SimpleAsyncTaskExecutor</code>；内部封装了 <code>Executor</code>，非常灵活的 <code>ConcurrentTaskExecutor</code>；还有我们用的最多的 <code>ThreadPoolTaskExecutor</code>。</p>\n<p>我们可以像下面这样直接配置一个 <code>ThreadPoolTaskExecutor</code>：</p>\n<pre class=\"code-rows\"><code>&lt;bean id=\"taskExecutor\" class=\"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\"&gt;\n    &lt;property name=\"corePoolSize\" value=\"4\"/&gt;\n    &lt;property name=\"maxPoolSize\" value=\"8\"/&gt;\n    &lt;property name=\"queueCapacity\" value=\"32\"/&gt;\n&lt;/bean&gt;</code></pre>\n<p>也可使用 <code>&lt;task:executor/&gt;</code>，下面是一个等价的配置：</p>\n<pre class=\"code-rows\"><code>&lt;task:executor id=\"taskExecutor\" pool-size=\"4-8\" queue-capacity=\"32\"/&gt;</code></pre>\n<blockquote>\n<p><strong>茶歇时间：该怎么配置线程池</strong></p>\n<p>如果要在程序中使用线程，请不要自行创建 <code>Thread</code>，而应该尽可能考虑使用线程池，并且明确线程池的大小—不能无限制地创建线程。</p>\n<p>网上有这样的建议，对于 CPU 密集型的系统，要尽可能减少线程数，建议线程池大小配置为“CPU 核数 +1”；对于 IO 密集型系统，为了避免 CPU 浪费在等待 IO 上，建议线程池大小为“CPU 核数 ×2”。当然，这只是一个建议值，具体还是可以根据情况来做调整的。</p>\n<p>线程池的等待队列默认为 <code>Integer.MAX_VALUE</code>，这样可能会造成任务的大量堆积，所以设置一个合理的等待队列大小后，就要应对“队列满”的情况。“队列满”时的处理策略是由 <code>RejectedExecutionHandler</code> 决定的，默认是 <code>ThreadPoolExecutor.AbortPolicy</code>，即直接抛出一个 <code>RejectedExecutionException</code> 异常。如果我们能接受直接抛弃任务，也可以将策略设置为 <code>ThreadPoolExecutor.DiscardPolicy</code> 或 <code>ThreadPoolExecutor.DiscardOldestPolicy</code>。</p>\n<p>此外，<code>ThreadPoolTaskExecutor</code> 还有一个 <code>keepAliveSeconds</code> 的属性，通过它可以调整空闲状态线程的存活时间。如果当前线程数大于核心线程数，到存活时间后就会清理线程。</p>\n</blockquote>\n<p>在配置好了 <code>TaskExecutor</code> 后，可以直接调用它的 <code>execute()</code> 方法，传入一个 <code>Runnable</code> 对象；也可以在方法上使用 <code>@Async</code> 注解，这个方法可以是空返回值，也可以返回一个 <code>Future</code>：</p>\n<pre class=\"code-rows\"><code>@Async\npublic void runAsynchronous() {...}</code></pre>\n<p>为了让该注解生效，需要在配置类上增加 <code>@EnableAsync</code> 注解，或者在 XML 文件中增加 <code>&lt;task:annotation-driven/&gt;</code> 配置，开启对它的支持。</p>\n<p>默认情况下，Spring 会为 <code>@Async</code> 寻找合适的线程池定义：例如上下文里唯一的 <code>TaskExecutor</code>；如果存在多个，则用 ID 为 <code>taskExecutor</code> 的那个；前面两个都找不到的话会降级使用 <code>SimpleAsyncTaskExecutor</code>。当然，也可以在 <code>@Async</code> 注解中指定一个。</p>\n<blockquote>\n<p><strong>请注意</strong>　对于异步执行的方法，由于在触发时主线程就返回了，我们的代码在遇到异常时可能根本无法感知，而且抛出的异常也不会被捕获，因此最好我们能自己实现一个 <code>AsyncUncaughtExceptionHandler</code> 对象来处理这些异常，最起码打印一个异常日志，方便问题排查。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>定时任务</strong></p>\n<p>定时任务，顾名思义，就是在特定的时间执行的任务，既可以是在某个特定的时间点执行一次的任务，也可以是多次重复执行的任务。</p>\n<p><code>TaskScheduler</code> 对两者都有很好的支持，其中的几个 <code>schedule()</code> 方法是处理单次任务的，而 <code>scheduleAtFixedRate()</code> 和 <code>scheduleWithFixedDelay()</code> 则是处理多次任务的。<code>scheduleAtFixedRate()</code> 按固定频率触发任务执行，<code>scheduleWithFixedDelay()</code> 在第一次任务执行完毕后等待指定的时间后再触发第二次任务。</p>\n<p><code>TaskScheduler.schedule()</code> 可以通过 <code>Trigger</code> 来指定触发的时间，其中最常用的就是接收 Cron 表达式 <span class=\"comment-number\">25</span> 的 <code>CronTrigger</code> 了，可以像下面这样在周一到周五的下午 3 点 15 分触发任务：</p>\n<pre class=\"code-rows\"><code>scheduler.schedule(task, new CronTrigger(\"0 15 15 * * 1-5\"));</code></pre>\n<p>与 <code>TaskExecutor</code> 类似，Spring Framework 也提供了不少 <code>TaskScheduler</code> 的实现，其中最常用的也是 <code>ThreadPoolTaskScheduler</code>。上述例子中的 <code>scheduler</code> 就可以是一个注入的 <code>ThreadPoolTaskScheduler</code> Bean。</p>\n<p>我们可以选择用 <code>&lt;task:scheduler/&gt;</code> 来配置 <code>TaskScheduler</code>：</p>\n<pre class=\"code-rows\"><code>&lt;task:scheduler id=\"taskScheduler\" pool-size=\"10\" /&gt;</code></pre>\n<p>也可以使用注解，默认情况下，Spring 会在同一上下文中寻找唯一的 <code>TaskScheduler</code> Bean，有多个的话用 ID 是 <code>taskScheduler</code> 的，再不行就用一个单线程的 <code>TaskScheduler</code>。在配置任务前，需要先在配置类上添加 <code>@EnableScheduling</code> 注解或在 XML 文件中添加 <code>&lt;task:annotation-driven/&gt;</code> 开启注解支持：</p>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableScheduling\npublic class Config {...}</code></pre>\n<p>随后，在方法上添加 <code>@Scheduled</code> 注解就能让方法定时执行，例如：</p>\n<pre class=\"code-rows\"><code>@Scheduled(fixedRate=1000) // 每隔1000ms执行\npublic void task1() {...}\n\n@Scheduled(fixedDelay=1000) // 每次执行完后等待1000ms再执行下一次\npublic void task2() {...}\n\n@Scheduled(initialDelay=5000, fixedRate=1000) // 先等待5000ms开始执行第一次，后续每隔1000ms执行一次\npublic void task3() {...}\n\n@Scheduled(cron=\"0 15 15 * * 1-5\") // 按Cron表达式执行\npublic void task4() {...}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：本地调度 vs. 分布式调度</strong></p>\n<p>上文提到的调度任务都是在一个 JVM 内部执行的，一般我们的系统都是以集群方式部署的，因此并非所有任务都需要在每台服务器上执行，同一时间，集群中的一台服务器能执行就够了。这时，仅有本节所提供的调度任务支持是不够的，我们还可以借助其他调度服务来实现我们的需求，例如，当当开源的 ElasticJob。</p>\n<p>举个例子，为了提升性能，我们会使用多级缓存，代码优先读取 JVM 本地缓存，没有命中的话再去读取 Redis 分布式缓存。缓存要靠定时任务来刷新，此时本地调度任务就用来刷新 JVM 缓存，而分布式调度任务就用来刷新 Redis 缓存。当然，我们也可以通过分布式调度来管理每台机器上的调度任务。</p>\n<p>甚至在一些场景中我们还需要对调度任务进行复杂的拆分：一台机器接收到任务被触发，接着进行一系列的准备工作，随后将任务分发到集群中的其他节点上进行后续处理，以此充分发挥集群的作用。</p>\n<p>总之，调度任务可以是非常复杂的，本节只是简单地引入这个话题，感兴趣的话，大家可以再深入研究。</p>\n</blockquote>\n</li>\n</ol>\n\n<h2 id=\"nav_point_42\">2.5　小结</h2>\n<p>通过本章的学习，我们对 Spring Framework 的核心容器及 Bean 的概念已经有了一个大概的了解。不仅知道了如何去使用它们，更是深入了解了如何对一些特性进行定制，如何通过类似事件通知这样的机制来应对某些问题。</p>\n<p>Spring Framework 为了让大家专心于业务逻辑，为我们提供了很多抽象来屏蔽底层的实现。本章中的环境抽象和任务抽象就是很好的例子。</p>\n<p>下一章，我们将看到 Spring Framework 中的另一个重要内容——AOP 支持。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 2 章 Spring Framework 中的 IoC 容器(1)","id":740861},"right":{"article_title":"第 3 章 Spring Framework 中的 AOP","id":740863}},"comments":[{"had_liked":false,"id":396332,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1053390,"ip_address":"山东","ucode":"ABB3F1A63E102A","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","comment_is_top":false,"comment_ctime":1733993704,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636606,"comment_content":"干货满满，感谢老师的付出。","like_count":0},{"had_liked":false,"id":395132,"user_name":"90后男人","can_delete":false,"product_type":"c1","uid":1283127,"ip_address":"北京","ucode":"1D8DC1D39E7269","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/37/e16ffb82.jpg","comment_is_top":false,"comment_ctime":1729567100,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636606,"comment_content":"老大你说的ch2&#47;helloworld-event  这个项目在那里","like_count":0}]}