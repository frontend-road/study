{"id":191714,"title":"25 | 两个单元测试库：C++里如何进行单元测试?","content":"<p>你好，我是吴咏炜。</p><p>单元测试已经越来越成为程序员工作密不可分的一部分了。在 C++ 里，我们当然也是可以很方便地进行单元测试的。今天，我就来介绍两个单元测试库：一个是 Boost.Test <span class=\"orange\">[1]</span>，一个是 Catch2 <span class=\"orange\">[2]</span>。</p><h2>Boost.Test</h2><p>单元测试库有很多，我选择 Boost 的原因我在上一讲已经说过：“如果我需要某个功能，在标准库里没有，在 Boost 里有，我会很乐意直接使用 Boost 里的方案，而非另外去查找。”再说，Boost.Test 提供的功能还挺齐全的，我需要的都有了。作为开胃小菜，我们先看一个单元测试的小例子：</p><pre><code class=\"language-c++\">#define BOOST_TEST_MAIN\n#include &lt;boost/test/unit_test.hpp&gt;\n#include &lt;stdexcept&gt;\n\nvoid test(int n)\n{\n  if (n == 42) {\n    return;\n  }\n  throw std::runtime_error(\n    \"Not the answer\");\n}\n\nBOOST_AUTO_TEST_CASE(my_test)\n{\n  BOOST_TEST_MESSAGE(\"Testing\");\n  BOOST_TEST(1 + 1 == 2);\n  BOOST_CHECK_THROW(\n    test(41), std::runtime_error);\n  BOOST_CHECK_NO_THROW(test(42));\n\n  int expected = 5;\n  BOOST_TEST(2 + 2 == expected);\n  BOOST_CHECK(2 + 2 == expected);\n}\n\nBOOST_AUTO_TEST_CASE(null_test)\n{\n}\n</code></pre><!-- [[[read_end]]] --><p>我们从代码里可以看到：</p><ul>\n<li>我们在包含单元测试的头文件之前定义了 <code>BOOST_TEST_MAIN</code>。如果编译时用到了多个源文件，只有一个应该定义该宏。多文件测试的时候，我一般会考虑把这个定义这个宏加包含放在一个单独的文件里（只有两行）。</li>\n<li>我们用 <code>BOOST_AUTO_TEST_CASE</code> 来定义一个测试用例。一个测试用例里应当有多个测试语句（如 <code>BOOST_CHECK</code>）。</li>\n<li>我们用 <code>BOOST_CHECK</code> 或 <code>BOOST_TEST</code> 来检查一个应当成立的布尔表达式（区别下面会讲）。</li>\n<li>我们用 <code>BOOST_CHECK_THROW</code> 来检查一个应当抛出异常的语句。</li>\n<li>我们用 <code>BOOST_CHECK_NO_THROW</code> 来检查一个不应当抛出异常的语句。</li>\n</ul><p>如<a href=\"https://time.geekbang.org/column/article/187980\">[第 21 讲]</a> 所述，我们可以用下面的命令行来进行编译：</p><ul>\n<li>MSVC：<code>cl /DBOOST_TEST_DYN_LINK /EHsc /MD test.cpp</code></li>\n<li>GCC：<code>g++ -DBOOST_TEST_DYN_LINK test.cpp -lboost_unit_test_framework</code></li>\n<li>Clang：<code>clang++ -DBOOST_TEST_DYN_LINK test.cpp -lboost_unit_test_framework</code></li>\n</ul><p>运行结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/fc/2e71b25e154d6609bd5cd3f4bf4911fc.png?wh=1024*168\" alt=\"\"></p><p>我们现在能看到 <code>BOOST_CHECK</code> 和 <code>BOOST_TEST</code> 的区别了。后者是一个较新加入 Boost.Test 的宏，能利用模板技巧来输出表达式的具体内容。但在某些情况下，<code>BOOST_TEST</code> 试图输出表达式的内容会导致编译出错，这时可以改用更简单的 <code>BOOST_CHECK</code>。</p><p>不管是 <code>BOOST_CHECK</code> 还是 <code>BOOST_TEST</code>，在测试失败时，执行仍然会继续。在某些情况下，一个测试失败后继续执行后面的测试已经没有意义，这时，我们就可以考虑使用 <code>BOOST_REQUIRE</code> 或 <code>BOOST_TEST_REQUIRE</code>——表达式一旦失败，整个测试用例会停止执行（但其他测试用例仍会正常执行）。</p><p>缺省情况下单元测试的输出只包含错误信息和结果摘要，但输出的详细程度是可以通过命令行选项来进行控制的。如果我们在运行测试程序时加上命令行参数 <code>--log_level=all</code>（或 <code>-l all</code>），我们就可以得到下面这样更详尽的输出：</p><p><img src=\"https://static001.geekbang.org/resource/image/4e/73/4ead9a603e0f5c4703637c905a2faf73.png?wh=1024*504\" alt=\"\"></p><p>我们现在额外可以看到：</p><ul>\n<li>在进入、退出测试模块和用例时的提示</li>\n<li><code>BOOST_TEST_MESSAGE</code> 的输出</li>\n<li>正常通过的测试的输出</li>\n<li>用例里无测试断言的警告</li>\n</ul><p>使用 Windows 的同学如果运行了测试程序的话，多半会惊恐地发现终端上的文字颜色已经发生了变化。这似乎是 Boost.Test 在 Windows 上特有的一个问题：建议你把单元测试的色彩显示关掉。你可以在系统高级设置里添加下面这个环境变量，也可以直接在命令行上输入：</p><pre><code class=\"language-batch\">set BOOST_TEST_COLOR_OUTPUT=0\n</code></pre><hr><p>下面我们看一个更真实的例子。</p><p>假设我们有一个 <code>split</code> 函数，定义如下：</p><pre><code class=\"language-c++\">template &lt;typename String,\n          typename Delimiter&gt;\nclass split_view {\npublic:\n  typedef\n    typename String::value_type\n      char_type;\n  class iterator { … };\n\n  split_view(const String&amp; str,\n             Delimiter delimiter);\n  iterator begin() const;\n  iterator end() const;\n  vector&lt;basic_string&lt;char_type&gt;&gt;\n  to_vector() const;\n  vector&lt;basic_string_view&lt;char_type&gt;&gt;\n  to_vector_sv() const;\n};\n\ntemplate &lt;typename String,\n          typename Delimiter&gt;\nsplit_view&lt;String, Delimiter&gt;\nsplit(const String&amp; str,\n      Delimiter delimiter);\n</code></pre><p>这个函数的意图是把类似于字符串的类型（<code>string</code> 或 <code>string_view</code>）分割开，并允许对分割的结果进行遍历。为了方便使用，结果也可以直接转化成字符串的数组（<code>to_vector</code>）或字符串视图的数组（<code>to_vector_sv</code>）。我们不用关心这个函数是如何实现的，我们就需要测试一下，该如何写呢？</p><p>首先，当然是写出一个测试用例的框架，把试验的待分割字符串写进去：</p><pre><code class=\"language-c++\">BOOST_AUTO_TEST_CASE(split_test)\n{\n  string_view str{\n    \"&amp;grant_type=client_credential\"\n    \"&amp;appid=\"\n    \"&amp;secret=APPSECRET\"};\n}\n</code></pre><p>最简单直白的测试，显然就是用 <code>to_vector</code> 或 <code>to_vector_sv</code> 来查看结果是否匹配了。这个非常容易加进去：</p><pre><code class=\"language-c++\">  vector&lt;string&gt;\n    split_result_expected{\n      \"\",\n      \"grant_type=client_\"\n      \"credential\",\n      \"appid=\",\n      \"secret=APPSECRET\"};\n  auto result = split(str, '&amp;');\n  auto result_s =\n    result.to_vector();\n  BOOST_TEST(result_s ==\n             split_result_expected);\n</code></pre><p>如果 <code>to_vector</code> 实现正确的话，我们现在运行程序就能在终端输出上看到：</p><blockquote>\n<p><code>*** No errors detected</code></p>\n</blockquote><p>下面，我们进一步检查 <code>to_vector</code> 和 <code>to_vector_sv</code> 的结果是否一致：</p><pre><code class=\"language-c++\">  auto result_sv =\n    result.to_vector_sv();\n  BOOST_TEST_REQUIRE(\n    result_s.size() ==\n    result_sv.size());\n  {\n    auto it = result_sv.begin();\n    for (auto&amp; s : result_s) {\n      BOOST_TEST(s == *it);\n      ++it;\n    }\n  }\n</code></pre><p>最后我们再测试可以遍历 <code>result</code>，并且结果和之前的相同：</p><pre><code class=\"language-c++\">  size_t i = 0;\n  auto it = result.begin();\n  auto end = result.end();\n  for (; it != end &amp;&amp;\n         i &lt; result_s.size();\n       ++it) {\n    BOOST_TEST(*it == result_s[i]);\n    ++i;\n  }\n  BOOST_CHECK(it == end);\n</code></pre><p>而这，差不多就接近我实际的  <code>split</code> 测试代码了。完整代码可参见：</p><p><a href=\"https://github.com/adah1972/nvwa/blob/master/test/boosttest_split.cpp\">https://github.com/adah1972/nvwa/blob/master/test/boosttest_split.cpp</a></p><hr><p>Boost.Test 产生的可执行代码支持很多命令行参数，可以用 <code>--help</code> 命令行选项来查看。常用的有：</p><ul>\n<li><code>build_info</code> 可用来展示构建信息</li>\n<li><code>color_output</code> 可用来打开或关闭输出中的色彩</li>\n<li><code>log_format</code> 可用来指定日志输出的格式，包括纯文本、XML、JUnit 等</li>\n<li><code>log_level</code> 可指定日志输出的级别，有 all、test_suite、error、fatal_error、nothing 等一共 11 个级别</li>\n<li><code>run_test</code> 可选择只运行指定的测试用例</li>\n<li><code>show_progress</code> 可在测试时显示进度，在测试数量较大时比较有用（见下图）</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/c2/e5/c21168d96cd55836575a7e5b44e3a7e5.png?wh=1024*196\" alt=\"\"></p><p>我这儿只是个简单的介绍。完整的 Boost.Test 的功能介绍还是请你自行参看文档。</p><h2>Catch2</h2><p>说完了 Boost.Test，我们再来看一下另外一个单元测试库，Catch2。仍然是和上一讲里说的一样，我要选择 Boost 之外的库，一定有一个比较强的理由。Catch2 有着它自己独有的优点：</p><ul>\n<li>只需要单个头文件即可使用，不需要安装和链接，简单方便</li>\n<li>可选使用 BDD（Behavior-Driven Development）风格的分节形式</li>\n<li>测试失败可选直接进入调试器（Windows 和 macOS 上）</li>\n</ul><p>我们拿前面 Boost.Test 的示例直接改造一下：</p><pre><code class=\"language-c++\">#define CATCH_CONFIG_MAIN\n#include \"catch.hpp\"\n#include &lt;stdexcept&gt;\n\nvoid test(int n)\n{\n  if (n == 42) {\n    return;\n  }\n  throw std::runtime_error(\n    \"Not the answer\");\n}\n\nTEST_CASE(\"My first test\", \"[my]\")\n{\n  INFO(\"Testing\");\n  CHECK(1 + 1 == 2);\n  CHECK_THROWS_AS(\n    test(41), std::runtime_error);\n  CHECK_NOTHROW(test(42));\n\n  int expected = 5;\n  CHECK(2 + 2 == expected);\n}\n\nTEST_CASE(\"A null test\", \"[null]\")\n{\n}\n</code></pre><p>可以看到，两者之间的相似性非常多，基本只是宏的名称变了一下。唯一值得一提的，是测试用例的参数：第一项是名字，第二项是标签，可以一个或多个。你除了可以直接在命令行上写测试的名字（不需要选项）来选择运行哪个测试外，也可以写测试的标签来选择运行哪些测试。</p><p>这是它在 Windows 下用 MSVC 编译的输出：</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/c7/6faf4113a57d9c4b65d203de52c8bfc7.png?wh=1026*560\" alt=\"\"></p><p>终端的色彩不会被搞乱。缺省的输出清晰程度相当不错。至少在 Windows 下，它看起来可能是个比 Boost.Test 更好的选择。但反过来，在浅色的终端里，Catch2 的色彩不太友好。Boost.Test 在 Linux 和 macOS 下则不管终端的色彩设定，都有比较友好的输出。</p><p>和 Boost.Test 类似，Catch2 的测试结果输出格式也是可以修改的。默认格式是纯文本，但你可以通过使用 <code>-r junit</code> 来设成跟 JUnit 兼容的格式，或使用 <code>-r xml</code> 输出成 Catch2 自己的 XML 格式。这方面，它比 Boost.Test 明显易用的一个地方是格式参数大小写不敏感，而在 Boost.Test 里你必须用全大写的形式，如 <code>-f JUNIT</code>，麻烦！</p><hr><p>下面我们通过另外一个例子来展示一下所谓的 BDD <span class=\"orange\">[3]</span> 风格的测试。</p><p>BDD 风格的测试一般采用这样的结构：</p><ul>\n<li>Scenario：场景，我要做某某事</li>\n<li>Given：给定，已有的条件</li>\n<li>When：当，某个事件发生时</li>\n<li>Then：那样，就应该发生什么</li>\n</ul><p>如果我们要测试一个容器，那代码就应该是这个样子的：</p><pre><code class=\"language-c++\">SCENARIO(\"Int container can be accessed and modified\",\n         \"[container]\")\n{\n  GIVEN(\"A container with initialized items\")\n  {\n    IntContainer c{1, 2, 3, 4, 5};\n    REQUIRE(c.size() == 5);\n\n    WHEN(\"I access existing items\")\n    {\n      THEN(\"The items can be retrieved intact\")\n      {\n          CHECK(c[0] == 1);\n          CHECK(c[1] == 2);\n          CHECK(c[2] == 3);\n          CHECK(c[3] == 4);\n          CHECK(c[4] == 5);\n      }\n    }\n\n    WHEN(\"I modify items\")\n    {\n      c[1] = -2;\n      c[3] = -4;\n\n      THEN(\"Only modified items are changed\")\n      {\n        CHECK(c[0] == 1);\n        CHECK(c[1] == -2);\n        CHECK(c[2] == 3);\n        CHECK(c[3] == -4);\n        CHECK(c[4] == 5);\n      }\n    }\n  }\n}\n</code></pre><p>你可以在程序前面加上类型定义来测试你自己的容器类或标准容器（如 <code>vector&lt;int&gt;</code>）。这是一种非常直观的写测试的方式。正常情况下，你当然应该看到：</p><blockquote>\n<p><code>All tests passed (12 assertions in 1 test case)</code></p>\n</blockquote><p>如果你没有留意到的话，在 GIVEN 里 WHEN 之前的代码是在每次 WHEN 之前都会执行一遍的。这也是 BDD 方式的一个非常方便的地方。</p><p>如果测试失败，我们就能看到类似下面这样的信息输出了（我存心制造了一个错误）：</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/8b/fe7e7efbbc6e69418b378ea27701998b.png?wh=1030*588\" alt=\"\"></p><p>如果没有失败的情况下，想看到具体的测试内容，可以传递参数 <code>--success</code>（或 <code>-s</code>）。</p><hr><p>如果你发现 Catch2 的编译速度有点慢的话，那我得告诉你，那是非常正常的。在你沮丧之前，我还应该马上告诉你，这在实际项目中完全不是一个问题。因为慢的原因通常主要是构建 Catch2 的主程序部分，而这部份在项目中只需要做一次，以后不会再有变动。你需要的是分离下面这部分代码在主程序里：</p><pre><code class=\"language-c++\">#define CATCH_CONFIG_MAIN\n#include \"catch.hpp\"\n</code></pre><p>只要这两行，来单独编译 Catch2 的主程序部分。你的实际测试代码里，则不要再定义 <code>CATCH_CONFIG_MAIN</code> 了。你会发现，这样一分离后，编译速度会大大加快。事实上，如果 Catch2 的主程序部分不需要编译的话，Catch2 的测试用例的编译速度在我的机器上比 Boost.Test 的还要快。</p><p>我觉得 Catch2 是一个很现代、很好用的测试框架。它的宏更简单，一个 <code>CHECK</code> 可以替代 Boost.Test 中的 <code>BOOST_TEST</code> 和 <code>BOOST_CHECK</code>，也没有 <code>BOOST_TEST</code> 在某些情况下不能用、必须换用 <code>BOOST_CHECK</code> 的问题。对于一个新项目，使用 Catch2 应该是件更简单、更容易上手的事——尤其如果你在 Windows 上开发的话。</p><p>目前，在 GitHub 上，Catch2 的收藏数超过一万，复刻（fork）数达到一千七，也已经足以证明它的流行程度。</p><h2>内容小结</h2><p>今天我们介绍了两个单元测试库，Boost.Test 和 Catch2。整体上来看，这两个都是很优秀的单元测试框架，可以满足日常开发的需要。</p><h2>课后思考</h2><p>请你自己试验一下本讲中的例子，来制造一些成功和失败的情况。使用一下，才能更容易确定哪一个更适合你的需求。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Gennadiy Rozental and Raffi Enficiaud, Boost.Test. <a href=\"https://www.boost.org/doc/libs/release/libs/test/doc/html/index.html\">https://www.boost.org/doc/libs/release/libs/test/doc/html/index.html</a> </span></p><p><span class=\"reference\">[2] Two Blue Cubes Ltd., Catch2. <a href=\"https://github.com/catchorg/Catch2\">https://github.com/catchorg/Catch2</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “Behavior-driven development”. <a href=\"https://en.wikipedia.org/wiki/Behavior-driven_development\">https://en.wikipedia.org/wiki/Behavior-driven_development</a> </span></p>","neighbors":{"left":{"article_title":"24 | Boost：你需要的“瑞士军刀”","id":191136},"right":{"article_title":"26 | Easylogging++和spdlog：两个好用的日志库","id":193203}},"comments":[{"had_liked":false,"id":173674,"user_name":"承君此诺","can_delete":false,"product_type":"c1","uid":1159765,"ip_address":"","ucode":"1B25D59743C0AD","user_header":"https://static001.geekbang.org/account/avatar/00/11/b2/55/61b3e9e3.jpg","comment_is_top":false,"comment_ctime":1579656812,"is_pvip":false,"replies":[{"id":67336,"content":"这两个都没有实际使用经验。如果你需要的功能都有，那就没有切换的理由吧。如果不足，就试试其他的。鉴于选择实在太多，重点试几个，满足需求就行了。我一直用 Boost.Test 的理由就是没找到换门的理由，而不是它有多好。当然，至少它是不差的。从下面这个列表里看（几十个 C++ 单元测试框架的概要对比），看起来没有严重缺的东西：\n\nhttps:&#47;&#47;en.wikipedia.org&#47;wiki&#47;List_of_unit_testing_frameworks#C++","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579683956,"ip_address":"","comment_id":173674,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我用的是cmake ctest，个人观点，它很适合测试整个程序，不适合细分到测试某个功能函数。所以，我在看google的gtest。这2个测试框架，您怎么看","like_count":10},{"had_liked":false,"id":316491,"user_name":"杨超然","can_delete":false,"product_type":"c1","uid":1121905,"ip_address":"","ucode":"A40331670F06E2","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/71/7a516c76.jpg","comment_is_top":false,"comment_ctime":1634354142,"is_pvip":false,"replies":[{"id":114636,"content":"恐怕没有——至少我不知道。数组尤其复杂，因为你还可以用指针加偏移量访问，静态分析理论上就不可能能完整分析出来。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634447983,"ip_address":"","comment_id":316491,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，有什么工具可以自动分析代码，展示变量之间的调用关系呢？我遇到的代码还牵涉到数组，数组的每个字段都有特定的含义，而代码直接用下标读写和修改数组的字段，且没有标字段的名称。因此，有代码分析工具可以精确到数组里的某一字段，展示它跟其它变量的关系吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482162,"discussion_content":"这两个都没有实际使用经验。如果你需要的功能都有，那就没有切换的理由吧。如果不足，就试试其他的。鉴于选择实在太多，重点试几个，满足需求就行了。我一直用 Boost.Test 的理由就是没找到换门的理由，而不是它有多好。当然，至少它是不差的。从下面这个列表里看（几十个 C++ 单元测试框架的概要对比），看起来没有严重缺的东西：\n\nhttps://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#C++","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579683956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287087,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1617770814,"is_pvip":false,"replies":[{"id":104252,"content":"你是说这种？\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;tree&#47;master&#47;25&#47;catch2","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1617801482,"ip_address":"","comment_id":287087,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"BDD有完整运行代码吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518189,"discussion_content":"你是说这种？\n\nhttps://github.com/adah1972/geek_time_cpp/tree/master/25/catch2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617801482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227259,"user_name":"易轻尘","can_delete":false,"product_type":"c1","uid":1136684,"ip_address":"","ucode":"0D0CB9D6D45A70","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","comment_is_top":false,"comment_ctime":1592334376,"is_pvip":false,"replies":[{"id":83825,"content":"嗯。我介绍的是最常用&#47;推荐的方式。Header-only上手快，看起来很美；但实际工程中出于编译速度等各方面考量通常不用。Catch2比较异类的地方是一共只有一个文件，所以上手就更快了。即便如此，实际用起来也是不用header-only更好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1592395641,"ip_address":"","comment_id":227259,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"很有用的一节\n不过Boost.Test也可以使用header-only的方式，使用&lt;boost&#47;test&#47;included&#47;unit_test.hpp&gt;头文件就可以了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518189,"discussion_content":"你是说这种？\n\nhttps://github.com/adah1972/geek_time_cpp/tree/master/25/catch2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617801482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173829,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1579711792,"is_pvip":false,"replies":[{"id":67401,"content":"全部清空吗？用clear()有问题？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579743102,"ip_address":"","comment_id":173829,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，map里面插入成万条数据，如何释放内存呢","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498557,"discussion_content":"嗯。我介绍的是最常用/推荐的方式。Header-only上手快，看起来很美；但实际工程中出于编译速度等各方面考量通常不用。Catch2比较异类的地方是一共只有一个文件，所以上手就更快了。即便如此，实际用起来也是不用header-only更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592395641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173823,"user_name":"EricHu","can_delete":false,"product_type":"c1","uid":1317260,"ip_address":"","ucode":"D49865ACB1B2CD","user_header":"https://static001.geekbang.org/account/avatar/00/14/19/8c/a11cfc0a.jpg","comment_is_top":false,"comment_ctime":1579708291,"is_pvip":false,"replies":[{"id":67400,"content":"尽量不用，但有时候必须用啊。比如我在智能指针的实现里就用了。\n\n跟Java的比较，你说的情况我不熟。泛泛而言，不要在C++里模拟其他语言的做法。退一步，看你要达到的目的是什么，再看语言有什么机制可以满足目标。C++里目前没反射机制，可预见的将来也大概只会有供编译期使用的静态反射。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579742984,"ip_address":"","comment_id":173823,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，我想请教一下C++的友元类，它会破坏类的封装性，实际在开发中建议使用吗？要怎么做到类似JAVA反射的效果，访问修改内部静态变量","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482214,"discussion_content":"尽量不用，但有时候必须用啊。比如我在智能指针的实现里就用了。\n\n跟Java的比较，你说的情况我不熟。泛泛而言，不要在C++里模拟其他语言的做法。退一步，看你要达到的目的是什么，再看语言有什么机制可以满足目标。C++里目前没反射机制，可预见的将来也大概只会有供编译期使用的静态反射。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579742984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179341,"user_name":"fl260919784","can_delete":false,"product_type":"c1","uid":1045678,"ip_address":"","ucode":"D6E10B8BDD0BB8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/ae/3b101c00.jpg","comment_is_top":false,"comment_ctime":1581984999,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"gtest有人有吗😂","like_count":15,"discussions":[{"author":{"id":1698595,"avatar":"https://static001.geekbang.org/account/avatar/00/19/eb/23/a38bd3ef.jpg","nickname":"罗文杰","note":"","ucode":"48CA8B6437957B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220210,"discussion_content":"有呢兄弟，gtest测试框架","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585840676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173674,"user_name":"承君此诺","can_delete":false,"product_type":"c1","uid":1159765,"ip_address":"","ucode":"1B25D59743C0AD","user_header":"https://static001.geekbang.org/account/avatar/00/11/b2/55/61b3e9e3.jpg","comment_is_top":false,"comment_ctime":1579656812,"is_pvip":false,"replies":[{"id":67336,"content":"这两个都没有实际使用经验。如果你需要的功能都有，那就没有切换的理由吧。如果不足，就试试其他的。鉴于选择实在太多，重点试几个，满足需求就行了。我一直用 Boost.Test 的理由就是没找到换门的理由，而不是它有多好。当然，至少它是不差的。从下面这个列表里看（几十个 C++ 单元测试框架的概要对比），看起来没有严重缺的东西：\n\nhttps:&#47;&#47;en.wikipedia.org&#47;wiki&#47;List_of_unit_testing_frameworks#C++","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579683956,"ip_address":"","comment_id":173674,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我用的是cmake ctest，个人观点，它很适合测试整个程序，不适合细分到测试某个功能函数。所以，我在看google的gtest。这2个测试框架，您怎么看","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482162,"discussion_content":"这两个都没有实际使用经验。如果你需要的功能都有，那就没有切换的理由吧。如果不足，就试试其他的。鉴于选择实在太多，重点试几个，满足需求就行了。我一直用 Boost.Test 的理由就是没找到换门的理由，而不是它有多好。当然，至少它是不差的。从下面这个列表里看（几十个 C++ 单元测试框架的概要对比），看起来没有严重缺的东西：\n\nhttps://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#C++","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579683956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316491,"user_name":"杨超然","can_delete":false,"product_type":"c1","uid":1121905,"ip_address":"","ucode":"A40331670F06E2","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/71/7a516c76.jpg","comment_is_top":false,"comment_ctime":1634354142,"is_pvip":false,"replies":[{"id":114636,"content":"恐怕没有——至少我不知道。数组尤其复杂，因为你还可以用指针加偏移量访问，静态分析理论上就不可能能完整分析出来。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634447983,"ip_address":"","comment_id":316491,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，有什么工具可以自动分析代码，展示变量之间的调用关系呢？我遇到的代码还牵涉到数组，数组的每个字段都有特定的含义，而代码直接用下标读写和修改数组的字段，且没有标字段的名称。因此，有代码分析工具可以精确到数组里的某一字段，展示它跟其它变量的关系吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528392,"discussion_content":"恐怕没有——至少我不知道。数组尤其复杂，因为你还可以用指针加偏移量访问，静态分析理论上就不可能能完整分析出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634447983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287087,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1617770814,"is_pvip":false,"replies":[{"id":104252,"content":"你是说这种？\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;tree&#47;master&#47;25&#47;catch2","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1617801482,"ip_address":"","comment_id":287087,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"BDD有完整运行代码吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528392,"discussion_content":"恐怕没有——至少我不知道。数组尤其复杂，因为你还可以用指针加偏移量访问，静态分析理论上就不可能能完整分析出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634447983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227259,"user_name":"易轻尘","can_delete":false,"product_type":"c1","uid":1136684,"ip_address":"","ucode":"0D0CB9D6D45A70","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","comment_is_top":false,"comment_ctime":1592334376,"is_pvip":false,"replies":[{"id":83825,"content":"嗯。我介绍的是最常用&#47;推荐的方式。Header-only上手快，看起来很美；但实际工程中出于编译速度等各方面考量通常不用。Catch2比较异类的地方是一共只有一个文件，所以上手就更快了。即便如此，实际用起来也是不用header-only更好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1592395641,"ip_address":"","comment_id":227259,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"很有用的一节\n不过Boost.Test也可以使用header-only的方式，使用&lt;boost&#47;test&#47;included&#47;unit_test.hpp&gt;头文件就可以了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498557,"discussion_content":"嗯。我介绍的是最常用/推荐的方式。Header-only上手快，看起来很美；但实际工程中出于编译速度等各方面考量通常不用。Catch2比较异类的地方是一共只有一个文件，所以上手就更快了。即便如此，实际用起来也是不用header-only更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592395641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173829,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1579711792,"is_pvip":false,"replies":[{"id":67401,"content":"全部清空吗？用clear()有问题？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579743102,"ip_address":"","comment_id":173829,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，map里面插入成万条数据，如何释放内存呢","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482215,"discussion_content":"全部清空吗？用clear()有问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579743102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155338,"discussion_content":"内存好像没有被真正释放掉😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580225564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1362403,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","nickname":"三味","note":"","ucode":"A580F715D1CC96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157097,"discussion_content":"对啊，没有真正释放。clear完了之后，你要shrink一下啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580441312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":155338,"ip_address":"","group_id":0},"score":157097,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174458,"discussion_content":"结合你后面问的问题，你想的是内存还给操作系统。一般没有必要彻底还给操作系统。在绝大部分情况下，交给运行时库的内存管理器和操作系统的内存管理器就行。除非进程后面不再要求内存、并且操作系统没有虚拟内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581919744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":155338,"ip_address":"","group_id":0},"score":174458,"extra":""}]},{"author":{"id":1073087,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/bf/4bd3eb4b.jpg","nickname":"米 虫","note":"","ucode":"6F35AA8BB8195B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154735,"discussion_content":"如果value 是new 出来的指针，估计只能循环delete 了。没啥好办法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580178253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173823,"user_name":"EricHu","can_delete":false,"product_type":"c1","uid":1317260,"ip_address":"","ucode":"D49865ACB1B2CD","user_header":"https://static001.geekbang.org/account/avatar/00/14/19/8c/a11cfc0a.jpg","comment_is_top":false,"comment_ctime":1579708291,"is_pvip":false,"replies":[{"id":67400,"content":"尽量不用，但有时候必须用啊。比如我在智能指针的实现里就用了。\n\n跟Java的比较，你说的情况我不熟。泛泛而言，不要在C++里模拟其他语言的做法。退一步，看你要达到的目的是什么，再看语言有什么机制可以满足目标。C++里目前没反射机制，可预见的将来也大概只会有供编译期使用的静态反射。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579742984,"ip_address":"","comment_id":173823,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，我想请教一下C++的友元类，它会破坏类的封装性，实际在开发中建议使用吗？要怎么做到类似JAVA反射的效果，访问修改内部静态变量","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482215,"discussion_content":"全部清空吗？用clear()有问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579743102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155338,"discussion_content":"内存好像没有被真正释放掉😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580225564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1362403,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","nickname":"三味","note":"","ucode":"A580F715D1CC96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157097,"discussion_content":"对啊，没有真正释放。clear完了之后，你要shrink一下啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580441312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":155338,"ip_address":"","group_id":0},"score":157097,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174458,"discussion_content":"结合你后面问的问题，你想的是内存还给操作系统。一般没有必要彻底还给操作系统。在绝大部分情况下，交给运行时库的内存管理器和操作系统的内存管理器就行。除非进程后面不再要求内存、并且操作系统没有虚拟内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581919744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":155338,"ip_address":"","group_id":0},"score":174458,"extra":""}]},{"author":{"id":1073087,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/bf/4bd3eb4b.jpg","nickname":"米 虫","note":"","ucode":"6F35AA8BB8195B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154735,"discussion_content":"如果value 是new 出来的指针，估计只能循环delete 了。没啥好办法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580178253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179341,"user_name":"fl260919784","can_delete":false,"product_type":"c1","uid":1045678,"ip_address":"","ucode":"D6E10B8BDD0BB8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/ae/3b101c00.jpg","comment_is_top":false,"comment_ctime":1581984999,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"gtest有人有吗😂","like_count":15,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482214,"discussion_content":"尽量不用，但有时候必须用啊。比如我在智能指针的实现里就用了。\n\n跟Java的比较，你说的情况我不熟。泛泛而言，不要在C++里模拟其他语言的做法。退一步，看你要达到的目的是什么，再看语言有什么机制可以满足目标。C++里目前没反射机制，可预见的将来也大概只会有供编译期使用的静态反射。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579742984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}