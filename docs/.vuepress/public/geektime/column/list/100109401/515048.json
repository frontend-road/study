{"id":515048,"title":"28｜DI Container（16）：行为封装会对测试产生什么影响？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式来实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code>InjectProvider.java:\n\npackage geektime.tdd.di;\n\nimport jakarta.inject.Inject;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.stream.Stream;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Stream.concat;\n\nclass InjectionProvider&lt;T&gt; implements ContextConfig.ComponentProvider&lt;T&gt; {\n\n    private Constructor&lt;T&gt; injectConstructor;\n    private List&lt;Field&gt; injectFields;\n    private List&lt;Method&gt; injectMethods;\n    \n    public InjectionProvider(Class&lt;T&gt; component) {\n        if (Modifier.isAbstract(component.getModifiers())) throw new IllegalComponentException();\n        this.injectConstructor = getInjectConstructor(component);\n        this.injectFields = getInjectFields(component);\n        this.injectMethods = getInjectMethods(component);\n        if (injectFields.stream().anyMatch(f -&gt; Modifier.isFinal(f.getModifiers())))\n            throw new IllegalComponentException();\n        if (injectMethods.stream().anyMatch(m -&gt; m.getTypeParameters().length != 0))\n            throw new IllegalComponentException();\n    }\n    \n@Override\npublic T get(Context context) {\n    try {\n        T instance = injectConstructor.newInstance(toDependencies(context, injectConstructor));\n        for (Field field : injectFields) field.set(instance, toDependency(context, field));\n        for (Method method : injectMethods) method.invoke(instance, toDependencies(context, method));\n        return instance;\n    } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {\n        throw new RuntimeException(e);\n    }\n}\n\n@Override\npublic List&lt;Context.Ref&gt; getDependencies() {\n    return concat(concat(stream(injectConstructor.getParameters()).map(Parameter::getParameterizedType),\n                    injectFields.stream().map(Field::getGenericType)),\n            injectMethods.stream().flatMap(m -&gt; stream(m.getParameters()).map(Parameter::getParameterizedType)))\n            .map(Context.Ref::of).toList();\n}\n\nprivate static &lt;T&gt; List&lt;Method&gt; getInjectMethods(Class&lt;T&gt; component) {\n    List&lt;Method&gt; injectMethods = traverse(component, (methods, current) -&gt; injectable(current.getDeclaredMethods())\n            .filter(m -&gt; isOverrideByInjectMethod(methods, m))\n            .filter(m -&gt; isOverrideByNoInjectMethod(component, m)).toList());\n    Collections.reverse(injectMethods);\n    return injectMethods;\n}\n\nprivate static &lt;T&gt; List&lt;Field&gt; getInjectFields(Class&lt;T&gt; component) {\n    return traverse(component, (fields, current) -&gt; injectable(current.getDeclaredFields()).toList());\n}\n\nprivate static &lt;Type&gt; Constructor&lt;Type&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n    List&lt;Constructor&lt;?&gt;&gt; injectConstructors = injectable(implementation.getConstructors()).toList();\n    if (injectConstructors.size() &gt; 1) throw new IllegalComponentException();\n    return (Constructor&lt;Type&gt;) injectConstructors.stream().findFirst().orElseGet(() -&gt; defaultConstructor(implementation));\n}\n\nprivate static &lt;Type&gt; Constructor&lt;Type&gt; defaultConstructor(Class&lt;Type&gt; implementation) {\n    try {\n        return implementation.getDeclaredConstructor();\n    } catch (NoSuchMethodException e) {\n        throw new IllegalComponentException();\n    }\n}\n\nprivate static &lt;T&gt; List&lt;T&gt; traverse(Class&lt;?&gt; component, BiFunction&lt;List&lt;T&gt;, Class&lt;?&gt;, List&lt;T&gt;&gt; finder) {\n    List&lt;T&gt; members = new ArrayList&lt;&gt;();\n    Class&lt;?&gt; current = component;\n    while (current != Object.class) {\n        members.addAll(finder.apply(members, current));\n        current = current.getSuperclass();\n    }\n    return members;\n}\n\nprivate static &lt;T extends AnnotatedElement&gt; Stream&lt;T&gt; injectable(T[] declaredFields) {\n    return stream(declaredFields).filter(f -&gt; f.isAnnotationPresent(Inject.class));\n}\n\nprivate static boolean isOverride(Method m, Method o) {\n    return o.getName().equals(m.getName()) &amp;&amp; Arrays.equals(o.getParameterTypes(), m.getParameterTypes());\n}\n\nprivate static &lt;T&gt; boolean isOverrideByNoInjectMethod(Class&lt;T&gt; component, Method m) {\n    return stream(component.getDeclaredMethods()).filter(m1 -&gt; !m1.isAnnotationPresent(Inject.class)).noneMatch(o -&gt; isOverride(m, o));\n}\nprivate static boolean isOverrideByInjectMethod(List&lt;Method&gt; injectMethods, Method m) {\n    return injectMethods.stream().noneMatch(o -&gt; isOverride(m, o));\n}\n\nprivate static Object[] toDependencies(Context context, Executable executable) {\n    return stream(executable.getParameters()).map(p -&gt; toDependency(context, p.getParameterizedType())).toArray(Object[]::new);\n}\n\nprivate static Object toDependency(Context context, Field field) {\n    return toDependency(context, field.getGenericType());\n}\n    \n    private static Object toDependency(Context context, Type type) {\n        return context.get(Context.Ref.of(type)).get();\n    }\n}\n\nContext.java: \n\npackage geektime.tdd.di;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Objects;\nimport java.util.Optional;\n\npublic interface Context {\n    &lt;ComponentType&gt; Optional&lt;ComponentType&gt; get(Ref&lt;ComponentType&gt; ref);\n    \n    class Ref&lt;ComponentType&gt; {\n    public static &lt;ComponentType&gt; Ref&lt;ComponentType&gt; of(Class&lt;ComponentType&gt; component) {\n        return new Ref(component);\n    }\n    public static Ref of(Type type) {\n        return new Ref(type);\n    }\n    private Type container;\n    private Class&lt;ComponentType&gt; component;\n    Ref(Type type) {\n       init(type);\n    }\n    protected Ref() {\n        Type type = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n        init(type);\n    }\n    private void init(Type type) {\n        if (type instanceof ParameterizedType container) {\n            this.container = container.getRawType();\n            this.component = (Class&lt;ComponentType&gt;) container.getActualTypeArguments()[0];\n        } else\n            this.component = (Class&lt;ComponentType&gt;) type;\n    }\n    public Type getContainer() {\n        return container;\n    }\n    public Class&lt;?&gt; getComponent() {\n        return component;\n    }\n    public boolean isContainer() {\n        return container != null;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Ref ref = (Ref) o;\n        return Objects.equals(container, ref.container) &amp;&amp; component.equals(ref.component);\n    }\n    @Override\n    public int h\n\nashCode() {\n            return Objects.hash(container, component);\n        }\n    }\n}\n\nContextConfig.java:\n\npackage geektime.tdd.di;\n\nimport jakarta.inject.Provider;\nimport java.util.*;\n\npublic class ContextConfig {\n\n    private Map&lt;Class&lt;?&gt;, ComponentProvider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n    \npublic &lt;Type&gt; void bind(Class&lt;Type&gt; type, Type instance) {\n    providers.put(type, (ComponentProvider&lt;Type&gt;) context -&gt; instance);\n}\n\npublic &lt;Type, Implementation extends Type&gt; void bind(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation) {\n    providers.put(type, new InjectionProvider&lt;&gt;(implementation));\n}\n\npublic Context getContext() {\n    providers.keySet().forEach(component -&gt; checkDependencies(component, new Stack&lt;&gt;()));\n    return new Context() {\n        @Override\n        public Optional&lt;?&gt; get(Ref ref) {\n            if (ref.isContainer()) {\n                if (ref.getContainer() != Provider.class) return Optional.empty();\n                return Optional.ofNullable(providers.get(ref.getComponent()))\n                        .map(provider -&gt; (Provider&lt;Object&gt;) () -&gt; provider.get(this));\n            }\n            return Optional.ofNullable(providers.get(ref.getComponent())).map(provider -&gt; provider.get(this));\n        }\n    };\n}\n\nprivate void checkDependencies(Class&lt;?&gt; component, Stack&lt;Class&lt;?&gt;&gt; visiting) {\n    for (Context.Ref dependency : providers.get(component).getDependencies()) {\n        if (!providers.containsKey(dependency.getComponent())) throw new DependencyNotFoundException(component, dependency.getComponent());\n        if (!dependency.isContainer()) {\n            if (visiting.contains(dependency.getComponent())) throw new CyclicDependenciesFoundException(visiting);\n            visiting.push(dependency.getComponent());\n            checkDependencies(dependency.getComponent(), visiting);\n            visiting.pop();\n        }\n    }\n}\n\ninterface ComponentProvider&lt;T&gt; {\n    T get(Context context);\n    default List&lt;Context.Ref&gt; getDependencies() {\n        return List.of();\n    }\n}\n}\n</code></pre><p>任务列表的状态为：</p><ul>\n<li>\n<p><s>无需构造的组件——组件实例</s></p>\n</li>\n<li>\n<p><s>如果注册的组件不可实例化，则抛出异常</s></p>\n<ul>\n<li><s>抽象类</s></li>\n<li><s>接口</s></li>\n</ul>\n</li>\n<li>\n<p><s>构造函数注入</s></p>\n<ul>\n<li><s>无依赖的组件应该通过默认构造函数生成组件实例</s></li>\n<li><s>有依赖的组件，通过Inject标注的构造函数生成组件实例</s></li>\n<li><s>如果所依赖的组件也存在依赖，那么需要对所依赖的组件也完成依赖注入</s></li>\n<li><s>如果组件有多于一个Inject标注的构造函数，则抛出异常</s></li>\n<li><s>如果组件没有Inject标注的构造函数，也没有默认构造函数（新增任务）</s></li>\n<li><s>如果组件需要的依赖不存在，则抛出异常</s></li>\n<li><s>如果组件间存在循环依赖，则抛出异常</s></li>\n</ul>\n</li>\n<li>\n<p><s>字段注入</s></p>\n<ul>\n<li><s>通过Inject标注将字段声明为依赖组件</s></li>\n<li><s>如果字段为final则抛出异常</s></li>\n<li><s>依赖中应包含Inject Field声明的依赖</s></li>\n</ul>\n</li>\n<li>\n<p><s>方法注入</s></p>\n<ul>\n<li><s>通过Inject标注的方法，其参数为依赖组件</s></li>\n<li><s>通过Inject标注的无参数方法，会被调用</s></li>\n<li><s>按照子类中的规则，覆盖父类中的Inject方法</s></li>\n<li><s>如果方法定义类型参数，则抛出异常</s></li>\n<li><s>依赖中应包含Inject Method声明的依赖</s></li>\n</ul>\n</li>\n<li>\n<p><s>对Provider类型的依赖</s></p>\n<ul>\n<li><s>从容器中取得组件的Provider（新增任务）</s></li>\n<li><s>注入构造函数中可以声明对于Provider的依赖</s></li>\n<li><s>注入字段中可以声明对于Provider的依赖</s></li>\n<li><s>注入方法中可声明对于Provider的依赖</s></li>\n<li><s>将构造函数中的Provider加入依赖（新增任务）</s></li>\n<li><s>将字段中的Provider加入依赖（新增任务）</s></li>\n<li><s>将方法中的Provider加入依赖（新增任务）</s></li>\n</ul>\n</li>\n<li>\n<p>自定义Qualifier的依赖</p>\n<ul>\n<li>注册组件时，可额外指定Qualifier</li>\n<li>寻找依赖时，需同时满足类型与自定义Qualifier标注</li>\n<li>支持默认Qualifier——Named</li>\n<li>注册组件时，可从类对象上提取Qualifier</li>\n</ul>\n</li>\n<li>\n<p>Singleton生命周期</p>\n<ul>\n<li>注册组件时，可额外指定是否为Singleton</li>\n<li>注册组件时，可从类对象上提取Singleton标注</li>\n<li>对于包含Singleton标注的组件，在容器范围内提供唯一实例</li>\n<li>容器组件默认不是Single生命周期</li>\n</ul>\n</li>\n<li>\n<p>自定义Scope标注</p>\n<ul>\n<li>可向容器注册自定义Scope标注的回调</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><h2>视频演示</h2><p>让我们进入今天的部分：</p><p><video poster=\"https://media001.geekbang.org/ab717dc86eca4d83bf3056a4e68bc3e0/snapshots/f6e91fe4adab47d8ab2ab50357e8c895-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/37783be6-180a44a3861-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/09ac8c92e8294bfeabec6dd0fe6a25a4/1cde6d38483b4032af2acac2c1f14c4a-7c402b44674f3a2d2931e721f523474f-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>在进入下节课之前，希望你能认真思考如下两个问题，并选择最有感触的一道进行回答。</p><ol>\n<li>我们要如何重构ContextConfig内部的实现，从而可以使用Component代替Class&lt;?&gt; ?</li>\n<li>你最近是怎样学习TDD的？可以分享一下你的学习方式，为其他同学提供参考。</li>\n</ol><p><strong>编辑来信</strong>：</p><blockquote>\n<p>第二期“TDD·代码评点”活动启动啦！为了帮助你更平滑地过渡到第三个实战项目，徐老师发起了代码评点活动。<br>\n<strong>　</strong><br>\n你可以填写<a href=\"https://jinshuju.net/f/fnh84B\">学习问卷</a>提交项目代码，而后，徐老师会一一查看，并进行评点与答疑。关于评点的详细内容，我们也将制成加餐展示在专栏里，供其他同学学习与参考。<br>\n<strong>　</strong><br>\n请注意，此次收集时间截至5月27日晚上12点。此外，我也会从中选出1-2位同学，送出《重构与模式》一书。请抓紧上车，入股不亏哦！</p>\n</blockquote><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码的链接分享出来。相信经过你的思考与实操，学习效果会更好！</p>","comments":[{"had_liked":false,"id":345545,"user_name":"张铁林","can_delete":false,"product_type":"c1","uid":1108258,"ip_address":"","ucode":"4AB8BC6CDAC0A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/22/7606c6ba.jpg","comment_is_top":false,"comment_ctime":1652369989,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"这章又要开启替换大法，先完成一个同级别的实现，再替换。","like_count":1},{"had_liked":false,"id":355101,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"北京","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1661079367,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"我们要如何重构 ContextConfig 内部的实现，从而可以使用 Component 代替 Class ?\n所有bind時先components.put()一份，然後所有providers.get()都替換為components.get()，然後刪掉providers","like_count":0},{"had_liked":false,"id":355072,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"北京","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1661054065,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"老師能講講測試數據的組織嗎？像不同case都要用的，或有微小差別的，位置放在哪些文件，哪些類，哪些行？","like_count":0},{"had_liked":false,"id":346419,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1653125906,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"如何学习 TDD\n1. 跟着老师敲代码\n2.参与微信群互动\n- 例如我丢掉了30多个测试，在群里请教同学，同学说“不影响”，还真是！\n- 微信群笔记（更新中）https:&#47;&#47;wyyl1.com&#47;post&#47;19&#47;wq&#47;\n3. 工作中使用 TDD","like_count":0}]}