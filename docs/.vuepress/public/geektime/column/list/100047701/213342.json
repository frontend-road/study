{"id":213342,"title":"07 | 数据库索引：索引并不是万能药","content":"<p>你好，我是朱晔。今天，我要和你分享的主题是，数据库的索引并不是万能药。</p><p>几乎所有的业务项目都会涉及数据存储，虽然当前各种NoSQL和文件系统大行其道，但MySQL等关系型数据库因为满足ACID、可靠性高、对开发友好等特点，仍然最常被用于存储重要数据。在关系型数据库中，索引是优化查询性能的重要手段。</p><p>为此，我经常看到一些同学一遇到查询性能问题，就盲目要求运维或DBA给数据表相关字段创建大量索引。显然，这种想法是错误的。今天，我们就以MySQL为例来深入理解下索引的原理，以及相关误区。</p><h2>InnoDB是如何存储数据的？</h2><p>MySQL把数据存储和查询操作抽象成了存储引擎，不同的存储引擎，对数据的存储和读取方式各不相同。MySQL支持多种存储引擎，并且可以以表为粒度设置存储引擎。因为支持事务，我们最常使用的是InnoDB。为方便理解下面的内容，我先和你简单说说InnoDB是如何存储数据的。</p><p>虽然数据保存在磁盘中，但其处理是在内存中进行的。为了减少磁盘随机读取次数，InnoDB采用页而不是行的粒度来保存数据，即数据被分成若干页，以页为单位保存在磁盘中。InnoDB的页大小，一般是16KB。</p><p>各个数据页组成一个双向链表，每个数据页中的记录按照主键顺序组成单向链表；每一个数据页中有一个页目录，方便按照主键查询记录。数据页的结构如下：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/13/d1/1302b4a8d877609486c9a9eed2d8d8d1.png?wh=1924*1396\" alt=\"\"></p><p>页目录通过槽把记录分成不同的小组，每个小组有若干条记录。如图所示，记录中最前面的小方块中的数字，代表的是当前分组的记录条数，最小和最大的槽指向2个特殊的伪记录。有了槽之后，我们按照主键搜索页中记录时，就可以采用二分法快速搜索，无需从最小记录开始遍历整个页中的记录链表。</p><p>举一个例子，如果要搜索主键（PK）=15的记录：</p><ul>\n<li>先二分得出槽中间位是(0+6)/2=3，看到其指向的记录是12＜15，所以需要从#3槽后继续搜索记录；</li>\n<li>再使用二分搜索出#3槽和#6槽的中间位是(3+6)/2=4.5取整4，#4槽对应的记录是16＞15，所以记录一定在#4槽中；</li>\n<li>再从#3槽指向的12号记录开始向下搜索3次，定位到15号记录。</li>\n</ul><p>理解了InnoDB存储数据的原理后，我们就可以继续学习MySQL索引相关的原理和坑了。</p><h2>聚簇索引和二级索引</h2><p>说到索引，页目录就是最简单的索引，是通过对记录进行一级分组来降低搜索的时间复杂度。但，这样能够降低的时间复杂度数量级，非常有限。当有无数个数据页来存储表数据的时候，我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p><p>为了解决这个问题，InnoDB引入了B+树。如下图所示，B+树是一棵倒过来的树：</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/65/e76adf029e63a045e05956039f81f265.png?wh=1996*1224\" alt=\"\"></p><p>B+树的特点包括：</p><ul>\n<li>最底层的节点叫作叶子节点，用来存放数据；</li>\n<li>其他上层节点叫作非叶子节点，仅用来存放目录项，作为索引；</li>\n<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>\n<li>所有节点按照索引键大小排序，构成一个双向链表，加速范围查找。</li>\n</ul><p>因此，InnoDB使用B+树，既可以保存实际数据，也可以加速数据搜索，这就是聚簇索引。如果把上图叶子节点下面方块中的省略号看作实际数据的话，那么它就是聚簇索引的示意图。<strong>由于数据在物理上只会保存一份，所以包含实际数据的聚簇索引只能有一个</strong>。</p><p>InnoDB会自动使用主键（唯一定义一条记录的单个或多个字段）作为聚簇索引的索引键（如果没有主键，就选择第一个不包含NULL值的唯一列）。上图方框中的数字代表了索引键的值，对聚簇索引而言一般就是主键。</p><p>我们再看看B+树如何实现快速查找主键。比如，我们要搜索PK=4的数据，通过根节点中的索引可以知道数据在第一个记录指向的2号页中，通过2号页的索引又可以知道数据在5号页，5号页就是实际的数据页，然后再通过二分法查找页目录马上可以找到记录的指针。</p><p>为了实现非主键字段的快速搜索，就引出了二级索引，也叫作非聚簇索引、辅助索引。二级索引，也是利用的B+树的数据结构，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/3a/4be8f22d993bd92878209d00a1264b3a.png?wh=1952*1176\" alt=\"\"></p><p>这次二级索引的叶子节点中保存的不是实际数据，而是主键，获得主键值后去聚簇索引中获得数据行。这个过程就叫作回表。</p><p>举个例子，有个索引是针对用户名字段创建的，索引记录上面方块中的字母是用户名，按照顺序形成链表。如果我们要搜索用户名为b的数据，经过两次定位可以得出在#5数据页中，查出所有的主键为7和6，再拿着这两个主键继续使用聚簇索引进行两次回表得到完整数据。</p><h2>考虑额外创建二级索引的代价</h2><p>创建二级索引的代价，主要表现在维护代价、空间代价和回表代价三个方面。接下来，我就与你仔细分析下吧。</p><p><strong>首先是维护代价</strong>。创建N个二级索引，就需要再创建N棵B+树，新增数据时不仅要修改聚簇索引，还需要修改这N个二级索引。</p><p>我们通过实验测试一下创建索引的代价。假设有一个person表，有主键ID，以及name、score、create_time三个字段：</p><pre><code>CREATE TABLE `person` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) NOT NULL,\n  `score` int(11) NOT NULL,\n  `create_time` timestamp NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n</code></pre><p>通过下面的存储过程循环创建10万条测试数据，我的机器的耗时是140秒（本文的例子均在MySQL 5.7.26中执行）：</p><pre><code>CREATE DEFINER=`root`@`%` PROCEDURE `insert_person`()\nbegin\n    declare c_id integer default 1;\n    while c_id&lt;=100000 do\n    insert into person values(c_id, concat('name',c_id), c_id+100, date_sub(NOW(), interval c_id second));\n    set c_id=c_id+1;\n    end while;\nend\n</code></pre><p>如果再创建两个索引，一个是name和score构成的联合索引，另一个是单一列create_time的索引，那么创建10万条记录的耗时提高到154秒：</p><pre><code>KEY `name_score` (`name`,`score`) USING BTREE,\nKEY `create_time` (`create_time`) USING BTREE\n</code></pre><p>这里，我再额外提一下，页中的记录都是按照索引值从小到大的顺序存放的，新增记录就需要往页中插入数据，现有的页满了就需要新创建一个页，把现有页的部分数据移过去，这就是页分裂；如果删除了许多数据使得页比较空闲，还需要进行页合并。页分裂和合并，都会有IO代价，并且可能在操作过程中产生死锁。</p><p>你可以查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/index-page-merge-threshold.html\">这个文档</a>，以进一步了解如何设置合理的合并阈值，来平衡页的空闲率和因为再次页分裂产生的代价。</p><p><strong>其次是空间代价</strong>。虽然二级索引不保存原始数据，但要保存索引列的数据，所以会占用更多的空间。比如，person表创建了两个索引后，使用下面的SQL查看数据和索引占用的磁盘：</p><pre><code>SELECT DATA_LENGTH, INDEX_LENGTH FROM information_schema.TABLES WHERE TABLE_NAME='person'\n</code></pre><p>结果显示，数据本身只占用了4.7M，而索引占用了8.4M。</p><p><strong>最后是回表的代价</strong>。二级索引不保存原始数据，通过索引找到主键后需要再查询聚簇索引，才能得到我们要的数据。比如，使用SELECT * 按照name字段查询用户，使用EXPLAIN查看执行计划：</p><pre><code>EXPLAIN SELECT * FROM person WHERE NAME='name1'\n</code></pre><p>执行计划如下，可以发现：</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/21/f380ee99efb997a8520d16f5433f7e21.png?wh=1654*98\" alt=\"\"></p><ul>\n<li>key字段代表实际走的是哪个索引，其值是name_score，说明走的是name_score这个索引。</li>\n<li>type字段代表了访问表的方式，其值ref说明是二级索引等值匹配，符合我们的查询。</li>\n</ul><p>把SQL中的*修改为NAME和SCORE，也就是SELECT name_score联合索引包含的两列：</p><pre><code>EXPLAIN SELECT NAME,SCORE FROM person WHERE NAME='name1'\n</code></pre><p>再来看看执行计划：</p><p><img src=\"https://static001.geekbang.org/resource/image/88/e7/88809b6f547238596d141eab27f3d7e7.png?wh=1712*100\" alt=\"\"></p><p>可以看到，Extra列多了一行Using index的提示，证明这次查询直接查的是二级索引，免去了回表。</p><p>原因很简单，联合索引中其实保存了多个索引列的值，对于页中的记录先按照字段1排序，如果相同再按照字段2排序，如图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/80/72/803c3e6a8df1d6031db70473dc948472.png?wh=1984*1500\" alt=\"\"></p><p>图中，叶子节点每一条记录的第一和第二个方块是索引列的数据，第三个方块是记录的主键。如果我们需要查询的是索引列索引或联合索引能覆盖的数据，那么查询索引本身已经“覆盖”了需要的数据，不再需要回表查询。因此，这种情况也叫作<strong>索引覆盖</strong>。我会在最后一小节介绍如何查看不同查询的成本，和你一起看看索引覆盖和索引查询后回表的代价差异。</p><p>最后，我和你总结下关于索引开销的最佳实践吧。</p><p>第一，无需一开始就建立索引，可以等到业务场景明确后，或者是数据量超过1万、查询变慢后，再针对需要查询、排序或分组的字段创建索引。创建索引后可以使用EXPLAIN命令，确认查询是否可以使用索引。我会在下一小节展开说明。</p><p>第二，尽量索引轻量级的字段，比如能索引int字段就不要索引varchar字段。索引字段也可以是部分前缀，在创建的时候指定字段索引长度。针对长文本的搜索，可以考虑使用Elasticsearch等专门用于文本搜索的索引数据库。</p><p>第三，尽量不要在SQL语句中SELECT *，而是SELECT必要的字段，甚至可以考虑使用联合索引来包含我们要搜索的字段，既能实现索引加速，又可以避免回表的开销。</p><h2>不是所有针对索引列的查询都能用上索引</h2><p>在上一个案例中，我创建了一个name+score的联合索引，仅搜索name时就能够用上这个联合索引。这就引出两个问题：</p><ul>\n<li>是不是建了索引一定可以用上？</li>\n<li>怎么选择创建联合索引还是多个独立索引？</li>\n</ul><p>首先，我们通过几个案例来分析一下索引失效的情况。</p><p>第一，<strong>索引只能匹配列前缀</strong>。比如下面的LIKE语句，搜索name后缀为name123的用户无法走索引，执行计划的type=ALL代表了全表扫描：</p><pre><code>EXPLAIN SELECT * FROM person WHERE NAME LIKE '%name123' LIMIT 100\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/e1/c9/e1033c6534938f8381fce051fb8ef8c9.png?wh=1806*126\" alt=\"\"></p><p>把百分号放到后面走前缀匹配，type=range表示走索引扫描，key=name_score看到实际走了name_score索引：</p><pre><code>EXPLAIN SELECT * FROM person WHERE NAME LIKE 'name123%' LIMIT 100\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/95/5a/95074c69e68039738046fd4275c4d85a.png?wh=1824*104\" alt=\"\"></p><p>原因很简单，索引B+树中行数据按照索引值排序，只能根据前缀进行比较。如果要按照后缀搜索也希望走索引的话，并且永远只是按照后缀搜索的话，可以把数据反过来存，用的时候再倒过来。</p><p>第二，<strong>条件涉及函数操作无法走索引</strong>。比如搜索条件用到了LENGTH函数，肯定无法走索引：</p><pre><code>EXPLAIN SELECT * FROM person WHERE LENGTH(NAME)=7\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/f1/08/f1eadcdd35b96c9f982115e528ee6808.png?wh=1684*120\" alt=\"\"></p><p>同样的原因，索引保存的是索引列的原始值，而不是经过函数计算后的值。如果需要针对函数调用走数据库索引的话，只能保存一份函数变换后的值，然后重新针对这个计算列做索引。</p><p>第三，<strong>联合索引只能匹配左边的列</strong>。也就是说，虽然对name和score建了联合索引，但是仅按照score列搜索无法走索引：</p><pre><code>EXPLAIN SELECT * FROM person WHERE SCORE&gt;45678\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/0d/e3/0d3d1a4ad0ae545f0264be3de781e0e3.png?wh=1714*122\" alt=\"\"></p><p>原因也很简单，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。尝试把搜索条件加入name列，可以看到走了name_score索引：</p><pre><code>EXPLAIN SELECT * FROM person WHERE SCORE&gt;45678 AND NAME LIKE 'NAME45%'\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/77/17/77c946fcf49059d40673cf6075119d17.png?wh=1916*102\" alt=\"\"></p><p>需要注意的是，因为有查询优化器，所以name作为WHERE子句的第几个条件并不是很重要。</p><p>现在回到最开始的两个问题。</p><ul>\n<li>是不是建了索引一定可以用上？并不是，只有当查询能符合索引存储的实际结构时，才能用上。这里，我只给出了三个肯定用不上索引的反例。其实，有的时候即使可以走索引，MySQL也不一定会选择使用索引。我会在下一小节展开这一点。</li>\n<li>怎么选择建联合索引还是多个独立索引？如果你的搜索条件经常会使用多个字段进行搜索，那么可以考虑针对这几个字段建联合索引；同时，针对多字段建立联合索引，使用索引覆盖的可能更大。如果只会查询单个字段，可以考虑建单独的索引，毕竟联合索引保存了不必要字段也有成本。</li>\n</ul><h2>数据库基于成本决定是否走索引</h2><p>通过前面的案例，我们可以看到，查询数据可以直接在聚簇索引上进行全表扫描，也可以走二级索引扫描后到聚簇索引回表。看到这里，你不禁要问了，MySQL到底是怎么确定走哪种方案的呢。</p><p>其实，MySQL在查询数据之前，会先对可能的方案做执行计划，然后依据成本决定走哪个执行计划。</p><p>这里的成本，包括IO成本和CPU成本：</p><ul>\n<li>IO成本，是从磁盘把数据加载到内存的成本。默认情况下，读取数据页的IO成本常数是1（也就是读取1个页成本是1）。</li>\n<li>CPU成本，是检测数据是否满足条件和排序等CPU操作的成本。默认情况下，检测记录的成本是0.2。</li>\n</ul><p>基于此，我们分析下全表扫描的成本。</p><p>全表扫描，就是把聚簇索引中的记录依次和给定的搜索条件做比较，把符合搜索条件的记录加入结果集的过程。那么，要计算全表扫描的代价需要两个信息：</p><ul>\n<li>聚簇索引占用的页面数，用来计算读取数据的IO成本；</li>\n<li>表中的记录数，用来计算搜索的CPU成本。</li>\n</ul><p>那么，MySQL是实时统计这些信息的吗？其实并不是，MySQL维护了表的统计信息，可以使用下面的命令查看：</p><pre><code>SHOW TABLE STATUS LIKE 'person'\n</code></pre><p>输出如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/55/32/5554af3acf1005fac1b6a494b6578732.png?wh=1614*1118\" alt=\"\"></p><p>可以看到：</p><ul>\n<li>总行数是100086行（之前EXPLAIN时，也看到rows为100086）。你可能说，person表不是有10万行记录吗，为什么这里多了86行？其实，MySQL的统计信息是一个估算，其统计方式比较复杂我就不再展开了。但不妨碍我们根据这个值估算CPU成本，是100086*0.2=20017左右。</li>\n<li>数据长度是4734976字节。对于InnoDB来说，这就是聚簇索引占用的空间，等于聚簇索引的页面数量*每个页面的大小。InnoDB每个页面的大小是16KB，大概计算出页面数量是289，因此IO成本是289左右。</li>\n</ul><p>所以，全表扫描的总成本是20306左右。</p><p>接下来，我还是用person表这个例子，和你分析下MySQL如何基于成本来制定执行计划。现在，我要用下面的SQL查询name&gt;‘name84059’ AND create_time&gt;‘2020-01-24 05:00:00’</p><pre><code>EXPLAIN SELECT * FROM person WHERE NAME &gt;'name84059' AND create_time&gt;'2020-01-24 05:00:00'\n</code></pre><p>其执行计划是全表扫描：</p><p><img src=\"https://static001.geekbang.org/resource/image/54/a8/54c6e60d390b54d5e1ae1e8bc2451fa8.png?wh=1912*116\" alt=\"\"></p><p>只要把create_time条件中的5点改为6点就变为走索引了，并且走的是create_time索引而不是name_score联合索引：</p><p><img src=\"https://static001.geekbang.org/resource/image/25/aa/2501093bce47944d4a9c2b090c2f8baa.png?wh=2052*112\" alt=\"\"></p><p><strong>我们可以得到两个结论：</strong></p><ul>\n<li>MySQL选择索引，并不是按照WHERE条件中列的顺序进行的；</li>\n<li>即便列有索引，甚至有多个可能的索引方案，MySQL也可能不走索引。</li>\n</ul><p>其原因就是，MySQL并不是猜拳决定是否走索引的，而是根据成本来判断的。虽然表的统计信息不完全准确，但足够用于策略的判断了。</p><p>不过，有时会因为统计信息的不准确或成本估算的问题，实际开销会和MySQL统计出来的差距较大，导致MySQL选择错误的索引或是直接选择走全表扫描，这个时候就需要人工干预，使用强制索引了。比如，像这样强制走name_score索引：</p><pre><code>EXPLAIN SELECT * FROM person FORCE INDEX(name_score) WHERE NAME &gt;'name84059' AND create_time&gt;'2020-01-24 05:00:00' \n</code></pre><p>我们介绍了MySQL会根据成本选择执行计划，也通过EXPLAIN知道了优化器最终会选择怎样的执行计划，但MySQL如何制定执行计划始终是一个黑盒。那么，有没有什么办法可以了解各种执行计划的成本，以及MySQL做出选择的依据呢？</p><p>在MySQL 5.6及之后的版本中，我们可以使用optimizer trace功能查看优化器生成执行计划的整个过程。有了这个功能，我们不仅可以了解优化器的选择过程，更可以了解每一个执行环节的成本，然后依靠这些信息进一步优化查询。</p><p>如下代码所示，打开optimizer_trace后，再执行SQL就可以查询information_schema.OPTIMIZER_TRACE表查看执行计划了，最后可以关闭optimizer_trace功能：</p><pre><code>SET optimizer_trace=&quot;enabled=on&quot;;\nSELECT * FROM person WHERE NAME &gt;'name84059' AND create_time&gt;'2020-01-24 05:00:00';\nSELECT * FROM information_schema.OPTIMIZER_TRACE;\nSET optimizer_trace=&quot;enabled=off&quot;;\n</code></pre><p>对于按照create_time&gt;'2020-01-24 05:00:00’条件走全表扫描的SQL，我从OPTIMIZER_TRACE的执行结果中，摘出了几个重要片段来重点分析：</p><ul>\n<li>使用name_score对name84059&lt;name条件进行索引扫描需要扫描25362行，成本是30435，因此最终没有选择这个方案。这里的30435是查询二级索引的IO成本和CPU成本之和，再加上回表查询聚簇索引的IO成本和CPU成本之和，我就不再具体分析了：</li>\n</ul><pre><code>{\n\t&quot;index&quot;: &quot;name_score&quot;,\n\t&quot;ranges&quot;: [\n\t\t&quot;name84059 &lt; name&quot;\n\t],\n\t&quot;rows&quot;: 25362,\n\t&quot;cost&quot;: 30435,\n\t&quot;chosen&quot;: false,\n\t&quot;cause&quot;: &quot;cost&quot;\n},\n</code></pre><ul>\n<li>使用create_time进行索引扫描需要扫描23758行，成本是28511，同样因为成本原因没有选择这个方案：</li>\n</ul><pre><code>{\n\t&quot;index&quot;: &quot;create_time&quot;,\n\t&quot;ranges&quot;: [\n\t\t&quot;0x5e2a79d0 &lt; create_time&quot;\n\t],\n\t&quot;rows&quot;: 23758,\n\t&quot;cost&quot;: 28511,\n\t&quot;chosen&quot;: false,\n\t&quot;cause&quot;: &quot;cost&quot;\n}\n</code></pre><ul>\n<li>最终选择了全表扫描方式作为执行计划。可以看到，全表扫描100086条记录的成本是20306，和我们之前计算的一致，显然是小于其他两个方案的28511和30435：</li>\n</ul><pre><code>{\n\t&quot;considered_execution_plans&quot;: [{\n\t\t&quot;table&quot;: &quot;`person`&quot;,\n\t\t&quot;best_access_path&quot;: {\n\t\t\t&quot;considered_access_paths&quot;: [{\n\t\t\t\t&quot;rows_to_scan&quot;: 100086,\n\t\t\t\t&quot;access_type&quot;: &quot;scan&quot;,\n\t\t\t\t&quot;resulting_rows&quot;: 100086,\n\t\t\t\t&quot;cost&quot;: 20306,\n\t\t\t\t&quot;chosen&quot;: true\n\t\t\t}]\n\t\t},\n\t\t&quot;rows_for_plan&quot;: 100086,\n\t\t&quot;cost_for_plan&quot;: 20306,\n\t\t&quot;chosen&quot;: true\n\t}]\n},\n</code></pre><p>把SQL中的create_time条件从05:00改为06:00，再次分析OPTIMIZER_TRACE可以看到，这次执行计划选择的是走create_time索引。因为是查询更晚时间的数据，走create_time索引需要扫描的行数从23758减少到了16588。这次走这个索引的成本19907小于全表扫描的20306，更小于走name_score索引的30435：</p><pre><code>{\n\t&quot;index&quot;: &quot;create_time&quot;,\n\t&quot;ranges&quot;: [\n\t\t&quot;0x5e2a87e0 &lt; create_time&quot;\n\t],\n\t&quot;rows&quot;: 16588,\n\t&quot;cost&quot;: 19907,\n\t&quot;chosen&quot;: true\n}\n</code></pre><p>有关optimizer trace的更多信息，你可以参考<a href=\"https://dev.mysql.com/doc/internals/en/optimizer-tracing.html\">MySQL的文档</a>。</p><h2>重点回顾</h2><p>今天，我先和你分析了MySQL InnoDB存储引擎页、聚簇索引和二级索引的结构，然后分析了关于索引的两个误区。</p><p>第一个误区是，考虑到索引的维护代价、空间占用和查询时回表的代价，不能认为索引越多越好。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。</p><p>第二个误区是，不能认为建了索引就一定有效，对于后缀的匹配查询、查询中不包含联合索引的第一列、查询条件涉及函数计算等情况无法使用索引。此外，即使SQL本身符合索引的使用条件，MySQL也会通过评估各种查询方式的代价，来决定是否走索引，以及走哪个索引。</p><p>因此，在尝试通过索引进行SQL性能优化的时候，务必通过执行计划或实际的效果来确认索引是否能有效改善性能问题，否则增加了索引不但没解决性能问题，还增加了数据库增删改的负担。如果对EXPLAIN给出的执行计划有疑问的话，你还可以利用optimizer_trace查看详细的执行计划做进一步分析。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>在介绍二级索引代价时，我们通过EXPLAIN命令看到了索引覆盖和回表的两种情况。你能用optimizer trace来分析一下这两种情况的成本差异吗？</li>\n<li>索引除了可以用于加速搜索外，还可以在排序时发挥作用，你能通过EXPLAIN来证明吗？你知道，在什么情况下针对排序索引会失效吗？</li>\n</ol><p>针对数据库索引，你还有什么心得吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","comments":[{"had_liked":false,"id":194146,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":true,"comment_ctime":1585030909,"is_pvip":true,"replies":[{"id":"73958","content":"👍🏻","user_name":"作者回复","comment_id":194146,"uid":"1001470","ip_address":"","utype":1,"ctime":1585034197,"user_name_real":"朱晔"}],"discussion_count":7,"race_medal":0,"score":"9.223372364857301e+18","product_id":100047701,"comment_content":"第一个问题：<br>覆盖索引的cost是1.21而回表的是2.21<br>覆盖索引：<br>analyzing_range_alternatives&quot;: {<br>                    &quot;range_scan_alternatives&quot;: [<br>                      {<br>                        &quot;index&quot;: &quot;name_score&quot;,<br>                        &quot;ranges&quot;: [<br>                          &quot;name1 &lt;= name &lt;= name1&quot;<br>                        ] &#47;* ranges *&#47;,<br>                        &quot;index_dives_for_eq_ranges&quot;: true,<br>                        &quot;rowid_ordered&quot;: false,<br>                        &quot;using_mrr&quot;: false,<br>                        &quot;index_only&quot;: true,<br>                        &quot;rows&quot;: 1,<br>                        &quot;cost&quot;: 1.21,<br>                        &quot;chosen&quot;: true<br>                      }<br>                    ]<br>回表：<br>&quot;range_scan_alternatives&quot;: [<br>                      {<br>                        &quot;index&quot;: &quot;name_score&quot;,<br>                        &quot;ranges&quot;: [<br>                          &quot;name1 &lt;= name &lt;= name1&quot;<br>                        ] &#47;* ranges *&#47;,<br>                        &quot;index_dives_for_eq_ranges&quot;: true,<br>                        &quot;rowid_ordered&quot;: false,<br>                        &quot;using_mrr&quot;: false,<br>                        &quot;index_only&quot;: false,<br>                        &quot;rows&quot;: 1,<br>                        &quot;cost&quot;: 2.21,<br>                        &quot;chosen&quot;: true<br>                      }<br>                    ]<br><br>第二个问题：<br>SQL中带order by且执行计划中Extra 这个字段中有&quot;Using index&quot;或者&quot;Using index condition&quot;表示用到索引，并且不用专门排序，因为索引本身就是有序的；<br>如果Extra有“Using filesort”表示的就是需要排序；<br><br>排序时：MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。sort_buffer_size（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。<br>上述排序中，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。所以如果单行很大，这个方法效率不够好。max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。称为 rowid 排序；<br>rowid排序简单的描述就是先取出ID和排序字段进行排序，排序结束后，用ID回表去查询select中出现的其他字段，多了一次回表操作，<br>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。","like_count":77,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488770,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585034197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1968721,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/unkzY52hVDjTmZJGNkrBR75tFs4XTGBoYYcOYkIcPvHlQrLibwc94aBfj1uWiawoKeEMwHbkvgThXZarfoP8Dzag/132","nickname":"她","note":"","ucode":"FAC6851866C9C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406587,"discussion_content":"难道是 《MySQL 45讲》学友？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1634800167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549134,"discussion_content":"真的专业","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643604635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324501,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/d5/17833946.jpg","nickname":"八宝","note":"","ucode":"89D991A930FDEA","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406859,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634861215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074491,"avatar":"https://static001.geekbang.org/account/avatar/00/10/65/3b/c1c6b16a.jpg","nickname":"Alex","note":"","ucode":"20BA92E4F914D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385599,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627151665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306032,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","nickname":"桂城老托尼","note":"","ucode":"139E4B8EE88B79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367701,"discussion_content":"很详细","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618445910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297723,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKPuKKjuhiaOGQ8kfMmEnMkQAwdZib5NI3EQzn9lAU0ewX8msoqt36T2k7Z9Sh1JUUDCCn6jwBTvgHA/132","nickname":"于","note":"","ucode":"46D459C025D30B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217179,"discussion_content":"感觉很专业，学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585525978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194178,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1585033864,"is_pvip":true,"replies":[{"id":"73960","content":"感谢分享","user_name":"作者回复","comment_id":194178,"uid":"1001470","ip_address":"","utype":1,"ctime":1585035559,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"194858562184","product_id":100047701,"comment_content":"另外分享下之前在公司分享的MySQL相关的PPT，主要从MySQL整体架构，引擎、索引、锁和MVCC这及部分分享的，感兴趣的同学可以看看，然后大家交流交流。<br><br>https:&#47;&#47;github.com&#47;y645194203&#47;geektime-java-100&#47;blob&#47;master&#47;MySQL-%E5%88%86%E4%BA%AB%E4%BA%A4%E6%B5%81%E7%9A%84%E5%89%AF%E6%9C%AC.pptx","like_count":46,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488776,"discussion_content":"感谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585035559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382237,"discussion_content":"扫了眼。。。囧 隔壁 丁奇老师mysql 45讲 摘要。。期待能 触类旁通讲点别的。。么有。。例如存储的地方 类比下常见的mq 文件存储，或者 redis的存储 针对不同场景大家咋玩的，有啥异同点。。额。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1625483331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194880,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1585114537,"is_pvip":true,"replies":[{"id":"74105","content":"觉得好可以多分享","user_name":"作者回复","comment_id":194880,"uid":"1001470","ip_address":"","utype":1,"ctime":1585115446,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"53124722089","product_id":100047701,"comment_content":"老师的文章真的是太用心了，讲的太好了，赞👍","like_count":12,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488918,"discussion_content":"觉得好可以多分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585115446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194187,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1585035502,"is_pvip":false,"replies":[{"id":"73962","content":"总结的不错","user_name":"作者回复","comment_id":194187,"uid":"1001470","ip_address":"","utype":1,"ctime":1585035637,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"48829675758","product_id":100047701,"comment_content":"过早的优化，是万恶之源。不需要提前考虑建立索引。等性能出现问题，真正的需求降临的时候再考虑优化。<br>建立索引之前，需要考虑索引带来的副作用：维护成本，空间成本，回表成本。<br>更重要的是还要考虑，你的查询是否能用到索引。如果花费大量成本建立的索引，最后还用不上。那就赔了夫人又折兵了。<br>索引又牵扯到了很多注意事项，例如：尽量使用前缀匹配，而避免使用后缀匹配。因为后缀匹配会使得索引失效，走全表匹配。","like_count":12,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488777,"discussion_content":"总结的不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585035637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223367,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1591074311,"is_pvip":false,"replies":[{"id":"82305","content":"可以进一步阅读MySQL实战45讲专栏来了解相关内容，比如：<br>09 | 普通索引和唯一索引，应该怎么选择？<br>10 | MySQL为什么有时候会选错索引？","user_name":"作者回复","comment_id":223367,"uid":"1001470","ip_address":"","utype":1,"ctime":1591075228,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"35950812679","product_id":100047701,"comment_content":"老师这里讲的查询优化器选择流程详细一些，可否加个餐，说一说普通索引和唯一索引在什么业务场景下使用？","like_count":7,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497109,"discussion_content":"可以进一步阅读MySQL实战45讲专栏来了解相关内容，比如：\n09 | 普通索引和唯一索引，应该怎么选择？\n10 | MySQL为什么有时候会选错索引？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591075228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1877862,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu3MgZBAyyiavX2CMF2KRib791j3bBGiaQDzuQwBF2k6AKHANV2uTAAss2vVaeC7xcSYYD8vjmibRpTQ/132","nickname":"纵不朽","note":"","ucode":"DB2CA2C46B2EF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401886,"discussion_content":"老师平常是不是也会买其他专栏来看？，(→_→)","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1633758982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014573,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","nickname":"SharpBB","note":"","ucode":"D30C5B798B8E8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555599,"discussion_content":"一般来讲无脑用普通索引就好了  唯一索引有检查唯一性的开销","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646985495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194220,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1585038515,"is_pvip":false,"replies":[{"id":"73980","content":"聚簇索引的规则是：<br><br>When you define a PRIMARY KEY on your table, InnoDB uses it as the clustered index. Define a primary key for each table that you create. If there is no logical unique and non-null column or set of columns, add a new auto-increment column, whose values are filled in automatically.<br><br>If you do not define a PRIMARY KEY for your table, MySQL locates the first UNIQUE index where all the key columns are NOT NULL and InnoDB uses it as the clustered index.<br><br>If the table has no PRIMARY KEY or suitable UNIQUE index, InnoDB internally generates a hidden clustered index named GEN_CLUST_INDEX on a synthetic column containing row ID values. The rows are ordered by the ID that InnoDB assigns to the rows in such a table. The row ID is a 6-byte field that increases monotonically as new rows are inserted. Thus, the rows ordered by the row ID are physically in insertion order.<br><br>因为这些太细节的东西和坑点没有太多关系，为了节省篇幅就不展开说了。<br><br>是的，当你读一些文章的时候发现99%的知识点自己都知道，完全是复习一遍的感觉，这种契合的感觉很舒服","user_name":"作者回复","comment_id":194220,"uid":"1001470","ip_address":"","utype":1,"ctime":1585042040,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"18764907699","product_id":100047701,"comment_content":"如果没有主键，就选择第一个不包含 NULL 值的唯一列。<br>没有主键的话，mysql不是会为每行数据默认生成一个rowid字段作为主键吗？？<br><br>排序索引失效应该也是对索引做了一些函数操作。<br><br>研读过mysql的专栏，所以这一节感觉的知识感觉都了解，不过这种感觉还是很爽的，期待老师更多的干货。","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488786,"discussion_content":"聚簇索引的规则是：\n\nWhen you define a PRIMARY KEY on your table, InnoDB uses it as the clustered index. Define a primary key for each table that you create. If there is no logical unique and non-null column or set of columns, add a new auto-increment column, whose values are filled in automatically.\n\nIf you do not define a PRIMARY KEY for your table, MySQL locates the first UNIQUE index where all the key columns are NOT NULL and InnoDB uses it as the clustered index.\n\nIf the table has no PRIMARY KEY or suitable UNIQUE index, InnoDB internally generates a hidden clustered index named GEN_CLUST_INDEX on a synthetic column containing row ID values. The rows are ordered by the ID that InnoDB assigns to the rows in such a table. The row ID is a 6-byte field that increases monotonically as new rows are inserted. Thus, the rows ordered by the row ID are physically in insertion order.\n\n因为这些太细节的东西和坑点没有太多关系，为了节省篇幅就不展开说了。\n\n是的，当你读一些文章的时候发现99%的知识点自己都知道，完全是复习一遍的感觉，这种契合的感觉很舒服","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585042040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194014,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1585015020,"is_pvip":false,"replies":[{"id":"73886","content":"select *，你select仅仅是索引列，那么走索引更划算了","user_name":"作者回复","comment_id":194014,"uid":"1001470","ip_address":"","utype":1,"ctime":1585018724,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"18764884204","product_id":100047701,"comment_content":"第二个问题，我使用 EXPLAIN SELECT create_time from person ORDER BY create_time LIMIT 10; 语句，分析该 SQL，结果果然是 type = index，Extra = using index，证明排序走了索引并且是索引覆盖没有回表；我本以为加上函数就可以使索引失效，于是分别使用了 ORDER BY YEAR(create_time) 和 ORDER BY  substring(create_time,1,3)，发现 type 还是 index，我的数据库版本是8.0，请问老师，有什么方式可以让索引失效呢？","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488729,"discussion_content":"select *，你select仅仅是索引列，那么走索引更划算了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585018724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206031,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1586776259,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"14471678147","product_id":100047701,"comment_content":"这一篇文章，我感觉哪里都是重点，哈哈哈哈","like_count":4},{"had_liked":false,"id":194672,"user_name":"海战","can_delete":false,"product_type":"c1","uid":1232690,"ip_address":"","ucode":"309FF034BA2E91","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/32/fd71af86.jpg","comment_is_top":false,"comment_ctime":1585096796,"is_pvip":false,"replies":[{"id":"74085","content":"文中回表是指二级索引查询后回聚簇索引，这个和jpa没什么关系","user_name":"作者回复","comment_id":194672,"uid":"1001470","ip_address":"","utype":1,"ctime":1585103269,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"14469998684","product_id":100047701,"comment_content":"利用jpa 完成查询，是不是都会发生回表呀，不知道会不会产生影响","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488869,"discussion_content":"文中回表是指二级索引查询后回聚簇索引，这个和jpa没什么关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585103269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232690,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cf/32/fd71af86.jpg","nickname":"海战","note":"","ucode":"309FF034BA2E91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213541,"discussion_content":"哦，是想多了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585103435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276545,"user_name":"三分之二","can_delete":false,"product_type":"c1","uid":2224364,"ip_address":"","ucode":"1756803F29AAA2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/OrfXQWvE0jIuibibw0dnicPM02gKia0iaBHYMF6RgEDX1kjlKjOf2f36PXe8h0HtrgUGibcP4l6ndcRqlAHUYSNYe2dA/132","comment_is_top":false,"comment_ctime":1611996968,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10201931560","product_id":100047701,"comment_content":"再使用二分搜索出 #3 槽和 #6 槽的中间位是 (3+6)&#47;2=4.5 取整 4，#4 槽对应的记录是 16＞15，所以记录一定在 #4 槽中；<br>【所以记录一定在 #4 槽中；】这里应该是#3槽。","like_count":2,"discussions":[{"author":{"id":2023634,"avatar":"","nickname":"秦晨普","note":"","ucode":"6C5474313FB039","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550811,"discussion_content":"是#4槽。我本来也没理解，后来看了作者回复，又查了一下，发现这里有一些细节作者没完全讲清楚。\n1. 最小记录所在分组只能有 1 条记录，即最小记录本身占用一个槽；\n2. 槽1包含有pk=1-4四条记录，pk=4前面的数字4代表槽#1中有4条记录，对应地，#4中包含的其实是pk=12-16四条记录；\n3. 数据页中进行二分法查找时，比较的是槽中主键值最大的一条记录，然后搜索需要从前一个槽开始搜索","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644742932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195464,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1585189655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175124247","product_id":100047701,"comment_content":"讲解非常细致谢谢老师","like_count":2},{"had_liked":false,"id":244533,"user_name":"小胡子","can_delete":false,"product_type":"c1","uid":1018182,"ip_address":"","ucode":"79FEC6400D25DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/46/0b7828a1.jpg","comment_is_top":false,"comment_ctime":1598573409,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5893540705","product_id":100047701,"comment_content":"尽量不要在 SQL 语句中 SELECT *，而是 SELECT 必要的字段，实际使用中能做到实在太少了","like_count":1,"discussions":[{"author":{"id":2378309,"avatar":"https://static001.geekbang.org/account/avatar/00/24/4a/45/e048531a.jpg","nickname":"迪米乌格斯","note":"","ucode":"1D4393746DCBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340376,"discussion_content":"感觉在业务中curd的时候大部分都是select必要的字段,但是在直接连接数据库看效果的时候还是*, 尤其是不知道到底哪个字段的数据出问题的时候.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609990209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211729,"user_name":"LiG❄️","can_delete":false,"product_type":"c1","uid":1357566,"ip_address":"","ucode":"0FE01F25ADD1F9","user_header":"https://static001.geekbang.org/account/avatar/00/14/b6/fe/c5d7f0dc.jpg","comment_is_top":false,"comment_ctime":1587999612,"is_pvip":false,"replies":[{"id":"78715","content":"：）","user_name":"作者回复","comment_id":211729,"uid":"1001470","ip_address":"","utype":1,"ctime":1588038612,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5882966908","product_id":100047701,"comment_content":"老师好优秀，讲的非常透彻~自己还要要实操，加深理解！","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493347,"discussion_content":"：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588038612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197503,"user_name":"hellojd","can_delete":false,"product_type":"c1","uid":1341697,"ip_address":"","ucode":"4E51807AE7E472","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","comment_is_top":false,"comment_ctime":1585382277,"is_pvip":false,"replies":[{"id":"74604","content":"是的","user_name":"作者回复","comment_id":197503,"uid":"1001470","ip_address":"","utype":1,"ctime":1585389127,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5880349573","product_id":100047701,"comment_content":"有时候一个表索引太多，也会带来成本","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489535,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585389127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194028,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1585016115,"is_pvip":false,"replies":[{"id":"73887","content":"我这边做实验的结果在源码的coveringindex.jpg中可以看一下","user_name":"作者回复","comment_id":194028,"uid":"1001470","ip_address":"","utype":1,"ctime":1585018844,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5879983411","product_id":100047701,"comment_content":"第一个问题，我仔细对比了 optimizer trace 下的索引覆盖和回表，发现索引覆盖的如下项：<br>                    &quot;range_scan_alternatives&quot;: [<br>                      {<br>                        &quot;index&quot;: &quot;name_score&quot;,<br>                        &quot;ranges&quot;: [<br>                          &quot;name1 &lt;= name &lt;= name1&quot;<br>                        ],<br>                        &quot;index_dives_for_eq_ranges&quot;: true,<br>                        &quot;rowid_ordered&quot;: false,<br>                        &quot;using_mrr&quot;: false,<br>                        &quot;index_only&quot;: true,<br>                        &quot;rows&quot;: 1,<br>                        &quot;cost&quot;: 1.1056,<br>                        &quot;chosen&quot;: true<br>                      }<br>我猜测是 index_only =true 告诉我们这是索引覆盖而不需回表，可以索引覆盖的 cost_for_plan 为 1.1056 而回表的 cost_for_plan 为 0.61，这是不是证明索引覆盖所付出的损耗还要高于回表了？ ","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488737,"discussion_content":"我这边做实验的结果在源码的coveringindex.jpg中可以看一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585018844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341655,"user_name":"夏天＃风之友","can_delete":false,"product_type":"c1","uid":1195532,"ip_address":"","ucode":"28010A4D48935D","user_header":"https://static001.geekbang.org/account/avatar/00/12/3e/0c/b8b15a96.jpg","comment_is_top":false,"comment_ctime":1649753113,"is_pvip":false,"replies":[{"id":"124851","content":"数量大，字段多，这种搜索就用ES好了","user_name":"作者回复","comment_id":341655,"uid":"1001470","ip_address":"","utype":1,"ctime":1649813944,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1649753113","product_id":100047701,"comment_content":"老师，你好，看到文章很受启发。我这里有个问题请教一下，项目经常遇到多条件查询，例如，记录表数量级大，想着添加多字段的二级索引（比如 index_test(a,b,c)）来提升效率，但由于查询条件字段是动态拼接，数量不定(比如：abc,ac,bc,a,b,c)。这样会导致无法每次查询都会命中索引。 像这样的情况，老师有什么更好的查询方案？感谢","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562350,"discussion_content":"数量大，字段多，这种搜索就用ES好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649813944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337905,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1647154820,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647154820","product_id":100047701,"comment_content":"秀啊 特别是不走索引的情况 原来mysql会自行判断成本  难怪dba是一个单独的职位 数据库方面的学问很深啊","like_count":0},{"had_liked":false,"id":309115,"user_name":"Chasel👻","can_delete":false,"product_type":"c1","uid":2563225,"ip_address":"","ucode":"7DB9E8FA5307EF","user_header":"https://static001.geekbang.org/account/avatar/00/27/1c/99/5e738818.jpg","comment_is_top":false,"comment_ctime":1629947275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629947275","product_id":100047701,"comment_content":"老师，根据阿里的开发文档，业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。这个字段组合如果特别长的话也需要建立唯一索引么？实际开发中是怎么考量的","like_count":0},{"had_liked":false,"id":302864,"user_name":"防腐基","can_delete":false,"product_type":"c1","uid":2696605,"ip_address":"","ucode":"0FF3BF30631995","user_header":"https://static001.geekbang.org/account/avatar/00/29/25/9d/d612cbf8.jpg","comment_is_top":false,"comment_ctime":1626416103,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626416103","product_id":100047701,"comment_content":"二分法什么的一头雾水，下面也就看不下去了……","like_count":0},{"had_liked":false,"id":300451,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1625182957,"is_pvip":true,"replies":[{"id":"108895","content":"磁盘+内存","user_name":"作者回复","comment_id":300451,"uid":"1001470","ip_address":"","utype":1,"ctime":1625196967,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":1,"score":"1625182957","product_id":100047701,"comment_content":"主键聚族索引是存在磁盘还是内存，如果是磁盘，每次都查磁盘岂不是很慢，如果是内存，怎么能放下那么数据","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522736,"discussion_content":"磁盘+内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625196967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269604,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1608712996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608712996","product_id":100047701,"comment_content":"数据库基于成本决定是否走索引 长知识了","like_count":0},{"had_liked":false,"id":257293,"user_name":"seckiller","can_delete":false,"product_type":"c1","uid":1540757,"ip_address":"","ucode":"CCA66F155A2022","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er3Ey0Uq2w4wDUKbLgqUHIkeH9oYeG2KW92CvBgYviczRMdbk6xxFO8mxMOVxGBozUUZDyfLKEhFFA/132","comment_is_top":false,"comment_ctime":1603931477,"is_pvip":false,"replies":[{"id":"93819","content":"查询二级索引中不覆盖的字段就需要回表聚簇索引","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1604054490,"ip_address":"","comment_id":257293,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603931477","product_id":100047701,"comment_content":"老师解释一下回表，什么时候容易回表，回表只影响性能吗？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508287,"discussion_content":"查询二级索引中不覆盖的字段就需要回表聚簇索引","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604054490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249780,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1600788998,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1600788998","product_id":100047701,"comment_content":"之前和同事突然想到一个问题，就是唯一索引也是最左匹配吗？","like_count":0,"discussions":[{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341253,"discussion_content":"都是b+树","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610362479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240357,"user_name":"李和桃","can_delete":false,"product_type":"c1","uid":1015877,"ip_address":"","ucode":"97E66953070EE0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/45/d719f7df.jpg","comment_is_top":false,"comment_ctime":1596875934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596875934","product_id":100047701,"comment_content":"针对第二个问题，可以从type,rows,extra三个字段上面看到原因。如果没有索引的话，排序就需要把表中所有的数据放入sort_buffer，如果放不下，就要借助file去排序（extra的filesort），效率相当慢。如果是有索引，那么B+tree帮我们维护了一个有序的结构，可以直接进行b+tree搜索。","like_count":0},{"had_liked":false,"id":240354,"user_name":"李和桃","can_delete":false,"product_type":"c1","uid":1015877,"ip_address":"","ucode":"97E66953070EE0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/45/d719f7df.jpg","comment_is_top":false,"comment_ctime":1596875511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596875511","product_id":100047701,"comment_content":"老师，为什么我使用覆盖索引发现覆盖索引的cost更高呢？<br>不使用覆盖索引：<br>select * from person where name = &#39;name123&#39;;<br>&quot;range_scan_alternatives&quot;: [<br>                      {<br>                        &quot;index&quot;: &quot;idx_name_score&quot;,<br>                        &quot;ranges&quot;: [<br>                          &quot;name123 &lt;= name &lt;= name123&quot;<br>                        ],<br>                        &quot;index_dives_for_eq_ranges&quot;: true,<br>                        &quot;rowid_ordered&quot;: false,<br>                        &quot;using_mrr&quot;: false,<br>                        &quot;index_only&quot;: false,<br>                        &quot;rows&quot;: 1,<br>                        &quot;cost&quot;: 0.61,<br>                        &quot;chosen&quot;: true<br>                      }<br>                    ]<br>使用覆盖索引：<br>select name,score from person where name = &#39;name123&#39;;<br>&quot;range_scan_alternatives&quot;: [<br>                      {<br>                        &quot;index&quot;: &quot;idx_name_score&quot;,<br>                        &quot;ranges&quot;: [<br>                          &quot;name123 &lt;= name &lt;= name123&quot;<br>                        ],<br>                        &quot;index_dives_for_eq_ranges&quot;: true,<br>                        &quot;rowid_ordered&quot;: false,<br>                        &quot;using_mrr&quot;: false,<br>                        &quot;index_only&quot;: true,<br>                        &quot;rows&quot;: 1,<br>                        &quot;cost&quot;: 1.1056,<br>                        &quot;chosen&quot;: true<br>                      }<br>]","like_count":0},{"had_liked":false,"id":238192,"user_name":"Geek_299a34","can_delete":false,"product_type":"c1","uid":1928441,"ip_address":"","ucode":"79AECE06F08E87","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/cfNtHoAbHvia1O0jIopiafYbnppEPiawgicKa8vdI2FxMMEdqORB4VLzkYTuGJGA7HibustnU0hDTOD7YSDAWuxhmrg/132","comment_is_top":false,"comment_ctime":1596092228,"is_pvip":false,"replies":[{"id":"88011","content":"As previously described, all pages at each level are doubly-linked to each other, and within each page, records are singly-linked in ascending order. Non-leaf pages contain “pointers” (containing the child page number) rather than non-key row data.<br><br><br>https:&#47;&#47;blog.jcole.us&#47;2013&#47;01&#47;10&#47;btree-index-structures-in-innodb&#47;","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1596094076,"ip_address":"","comment_id":238192,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1596092228","product_id":100047701,"comment_content":"老师，B+树同一层的非叶子结点之间应该不是双向链表吧，你那个图画的看起来是双向链表","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502671,"discussion_content":"As previously described, all pages at each level are doubly-linked to each other, and within each page, records are singly-linked in ascending order. Non-leaf pages contain “pointers” (containing the child page number) rather than non-key row data.\n\n\nhttps://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596094076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1928441,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/cfNtHoAbHvia1O0jIopiafYbnppEPiawgicKa8vdI2FxMMEdqORB4VLzkYTuGJGA7HibustnU0hDTOD7YSDAWuxhmrg/132","nickname":"Geek_299a34","note":"","ucode":"79AECE06F08E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295149,"discussion_content":"老师太厉害了，为老师点赞，感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596103096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237788,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1595952787,"is_pvip":false,"replies":[{"id":"87890","content":"analyze table弄一下","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1596009507,"ip_address":"","comment_id":237788,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595952787","product_id":100047701,"comment_content":"文中的例子，person 表建立后，在增加 两个索引。index_length 还是0.这是为什么呢","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502538,"discussion_content":"analyze table弄一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596009507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230839,"user_name":"你当像鸟飞向你的山","can_delete":false,"product_type":"c1","uid":1915046,"ip_address":"","ucode":"D20279F2D2867B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a1nDkic8T3LRWe4hAWqCd32C6x3SM7IsmxKticU0icDt0oO95FYlmWhBnWdjiboaRh6c5fxu8t7E6VSElVfUZGe6Ww/132","comment_is_top":false,"comment_ctime":1593508144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593508144","product_id":100047701,"comment_content":"听说写一个符号也会提高学习的效果：<br>第一，在需要优化性能的时候，再根据经常作为查询条件的字段来建立索引，建立索引不是字段越多越好，而要考虑到建立索引带来的空间成本，建立之后的维护成本，查询使用索引的回表成本。<br>第二，在查询过程中 ，并不是一定会走索引查询，如果根据统计信息计算出来走索引的成本比全表扫描还大，则走全表扫描了，其他的情况比如：多字段联合索引不按索引字段顺序排列条件，索引字段使用函数，使用索引字段前缀模糊匹配","like_count":0},{"had_liked":false,"id":223271,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1591053023,"is_pvip":false,"replies":[{"id":"82245","content":"可以看看我对Joker的回复","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1591056377,"ip_address":"","comment_id":223271,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591053023","product_id":100047701,"comment_content":"“再使用二分搜索出 #3 槽和 #6 槽的中间位是 (3+6)&#47;2=4.5 取整 4，#4 槽对应的记录是 16＞15，所以记录一定在 #4 槽中；”这里的#4是不是应该是#3？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497083,"discussion_content":"可以看看我对Joker的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591056377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222336,"user_name":"Mq","can_delete":false,"product_type":"c1","uid":1178359,"ip_address":"","ucode":"041F572AFAB275","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg","comment_is_top":false,"comment_ctime":1590751668,"is_pvip":false,"replies":[{"id":"82020","content":"排序使用到索引，执行计划中体现的就是key一列，如果没有用到索引，会在Extra中看到Using filesort","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590754954,"ip_address":"","comment_id":222336,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590751668","product_id":100047701,"comment_content":"老师好，看文档页里面的数据是单向的，为什么我在索引里从大到小检索数据，看不到排序的执行计划","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496755,"discussion_content":"排序使用到索引，执行计划中体现的就是key一列，如果没有用到索引，会在Extra中看到Using filesort","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590754954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178359,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg","nickname":"Mq","note":"","ucode":"041F572AFAB275","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275959,"discussion_content":"我的意思是使用到了索引，假设id是索引，值是1-100，我查100-1，执行计划是走的索引，没有排序，但是我看数据页里面的数据是单向的，他是怎么做到不排序的，如果是双向的就好理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590793143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221457,"user_name":"张fore fore","can_delete":false,"product_type":"c1","uid":1913432,"ip_address":"","ucode":"3AE90B5B7B2D19","user_header":"https://static001.geekbang.org/account/avatar/00/1d/32/58/b3f156bf.jpg","comment_is_top":false,"comment_ctime":1590502630,"is_pvip":false,"replies":[{"id":"81662","content":"：）","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590503834,"ip_address":"","comment_id":221457,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590502630","product_id":100047701,"comment_content":"老师真的很用心，细致入微~( 0 x 0 )","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496458,"discussion_content":"：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590503834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220499,"user_name":"岳宜波","can_delete":false,"product_type":"c1","uid":1975581,"ip_address":"","ucode":"5043CA250FDCB1","user_header":"http://thirdwx.qlogo.cn/mmopen/2kpMNDYsSfCnhAYmvAsNcYKyNLUJG5iax9BKgXAJzxypEJGRVwhibjZ53S5icgEDibn8uqrqwsKcxzEXfRRUXTdqjA/132","comment_is_top":false,"comment_ctime":1590251160,"is_pvip":false,"replies":[{"id":"81372","content":"嗯 这是一种透明缓存的做法 不过这个也要看业务是否适合","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590281716,"ip_address":"","comment_id":220499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590251160","product_id":100047701,"comment_content":"我们项目中是使用JPA，在查询时进行了封装，将数据根据ID缓存在Redis 里，查询时根据查询条件只查出ID，然后根据ID去Redis里获取数据，避免了回表","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496156,"discussion_content":"嗯 这是一种透明缓存的做法 不过这个也要看业务是否适合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590281716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219895,"user_name":"tongzi","can_delete":false,"product_type":"c1","uid":2002210,"ip_address":"","ucode":"7349A6E42EDF17","user_header":"https://static001.geekbang.org/account/avatar/00/1e/8d/22/0bf540be.jpg","comment_is_top":false,"comment_ctime":1590115326,"is_pvip":false,"replies":[{"id":"81175","content":"1、根据目录页中PK的范围确定目录页<br>2、在目录页中二分法确定下层目录页<br>3、重复1和2一直到找到叶子页<br>4、在叶子页中同样二分法定位到记录","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590119996,"ip_address":"","comment_id":219895,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590115326","product_id":100047701,"comment_content":"老师你好，请教个问题（关于本篇开头，mysql利用索引搜索定位数据），以下问题可能本身就是一个假命题<br>     mysql的索引是B+树结构存储，B+树的叶子节点是我们的数据页<br>     当把数据页加载到内存后，如本篇开头，当前叶子节点是3个数据页组成的双向链表，这里叶子节点有可能是3个数据页组成的吧？（假设判pk为1-768；数据页1存储1-256，数据页2存储257-512，数据页3存储513-768）<br>如果现在定位pk = 544，是从数据页1开始查，只到数据页3，然后采用二分法定位到pk=544<br>还是利用其它方式的，直接定位到数据3？<br>","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495981,"discussion_content":"1、根据目录页中PK的范围确定目录页\n2、在目录页中二分法确定下层目录页\n3、重复1和2一直到找到叶子页\n4、在叶子页中同样二分法定位到记录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590119996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215931,"user_name":"Heiky","can_delete":false,"product_type":"c1","uid":1623626,"ip_address":"","ucode":"03AA79E1BC4AE4","user_header":"https://static001.geekbang.org/account/avatar/00/18/c6/4a/3bd896fc.jpg","comment_is_top":false,"comment_ctime":1589154982,"is_pvip":false,"replies":[{"id":"79888","content":"InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1589158275,"ip_address":"","comment_id":215931,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589154982","product_id":100047701,"comment_content":"老师，有个问题，簇聚索引叶子节点存储是真实的数据，还是指向数据的指针。","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494617,"discussion_content":"InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589158275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206460,"user_name":"Ant_D","can_delete":false,"product_type":"c1","uid":1111116,"ip_address":"","ucode":"9C8C8417D0AF09","user_header":"https://static001.geekbang.org/account/avatar/00/10/f4/4c/aac5165c.jpg","comment_is_top":false,"comment_ctime":1586865204,"is_pvip":false,"replies":[{"id":"77148","content":"受篇幅限制文中说的比较简洁，理解了大概之后，还可以继续找其他资料看<br><br>如果觉得对你有帮助欢迎点赞&amp;转发","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586870172,"ip_address":"","comment_id":206460,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586865204","product_id":100047701,"comment_content":"受益匪浅","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491799,"discussion_content":"受篇幅限制文中说的比较简洁，理解了大概之后，还可以继续找其他资料看\n\n如果觉得对你有帮助欢迎点赞&amp;amp;转发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586870172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205733,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1586716617,"is_pvip":false,"replies":[{"id":"76899","content":"没错，文中没有详细说这块，每个槽对应的记录是该组中主键值最大的记录，所以还是#4，然后搜索需要从前一个槽开始搜索","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586739769,"ip_address":"","comment_id":205733,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1586716617","product_id":100047701,"comment_content":"再使用二分搜索出 #3 槽和 #6 槽的中间位是 (3+6)&#47;2=4.5 取整 4，#4 槽对应的记录是 16＞15，所以记录一定在 #4 槽中；<br>---<br>这个是不是出错了？应该是 #3 槽中吧","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491571,"discussion_content":"没错，文中没有详细说这块，每个槽对应的记录是该组中主键值最大的记录，所以还是#4，然后搜索需要从前一个槽开始搜索","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586739769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2357964,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fa/cc/d4b3ce87.jpg","nickname":"秃如其来","note":"","ucode":"9130CE773F31B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552317,"discussion_content":"#3的最大记录刚好就是15啊 恰好就对上了 还需要继续二分么 不太懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645410737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1630174,"avatar":"https://static001.geekbang.org/account/avatar/00/18/df/de/8f844ff7.jpg","nickname":"小捕快","note":"","ucode":"9B4DB5D1B9C46C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2357964,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fa/cc/d4b3ce87.jpg","nickname":"秃如其来","note":"","ucode":"9130CE773F31B3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553864,"discussion_content":"第一次二分时候写了#3槽最大值是12，第二次得到#4槽最大值是16，#4槽记录的值16是最后一个位置。所以15应该在#4槽。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646121240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":552317,"ip_address":""},"score":553864,"extra":""}]}]},{"had_liked":false,"id":197068,"user_name":"终结者999号","can_delete":false,"product_type":"c1","uid":1055854,"ip_address":"","ucode":"33ADE61580B6DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","comment_is_top":false,"comment_ctime":1585356233,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585356233","product_id":100047701,"comment_content":"老师的文章很好，因为平常都是Oracle，我们一般都是一般考虑索引太多会占用索引空间，还没有考虑到为什么索引没用到","like_count":0},{"had_liked":false,"id":195462,"user_name":"张珮磊想静静","can_delete":false,"product_type":"c1","uid":1084732,"ip_address":"","ucode":"2E582ED7BB178E","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/3c/9025c2ca.jpg","comment_is_top":false,"comment_ctime":1585189535,"is_pvip":true,"replies":[{"id":"74262","content":"可以看文中『原因很简单，联合索引中其实保存了多个索引列的值，对于页中的记录先按照字段 1 排序，如果相同再按照字段 2 排序，如图所示』这一段下面的图，还是索引结构的原因。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585190845,"ip_address":"","comment_id":195462,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585189535","product_id":100047701,"comment_content":"老师您好，想问下联合索引在B+tree中是怎么排列的呢，为什么会有最佳左前缀法则，是和索引结构有关吗","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489076,"discussion_content":"可以看文中『原因很简单，联合索引中其实保存了多个索引列的值，对于页中的记录先按照字段 1 排序，如果相同再按照字段 2 排序，如图所示』这一段下面的图，还是索引结构的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585190845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195446,"user_name":"陈天柱","can_delete":false,"product_type":"c1","uid":1696225,"ip_address":"","ucode":"917BFDC845760D","user_header":"https://static001.geekbang.org/account/avatar/00/19/e1/e1/441df85d.jpg","comment_is_top":false,"comment_ctime":1585188658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585188658","product_id":100047701,"comment_content":"我这里也分享一下我之前遇到的一个排序没走索引的问题，不知道其他人有没有遇到类似的<br>假设有一张表test, 表结构的DDL：<br>CREATE TABLE `test` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `a` int(11) DEFAULT NULL,<br>  `status` int(11) DEFAULT NULL,<br>  `delete_sign` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `idx_a` (`a`)<br>) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8<br>表字段a是索引字段，<br>select * from test order by a; &#47;&#47; 这里排序走的还是using filesort， 原因老师有提过，因为需要走回表，无法直接在索引字段上排序<br>select id, a from test order by a; &#47;&#47; 这里排序走的就是索引排序， 不会真正去做排序<br>select id, a from test order a desc, id asc; &#47;&#47; 这里就不会走索引排序了，因为一升一降，而我们创建索引的时候，都是同升或者同降，之前在一个慢查询里想优化排序，但是一升一降问题无法从索引层面优化，需要从业务上将含义倒转，实现同升同降才能走索引排序。<br>","like_count":0},{"had_liked":false,"id":193967,"user_name":"Holly","can_delete":false,"product_type":"c1","uid":1903064,"ip_address":"","ucode":"4C09CCAB4554A5","user_header":"https://static001.geekbang.org/account/avatar/00/1d/09/d8/9bacc831.jpg","comment_is_top":false,"comment_ctime":1585008597,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1585008597","product_id":100047701,"comment_content":"你好！CPU成本计算为什么是乘以0.2","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212740,"discussion_content":"0.2是一个常量 或者叫成本常数","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585012047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1895585,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ec/a1/cfc44efe.jpg","nickname":"Geek_2ad702","note":"","ucode":"0014C0AE89FB0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":302815,"discussion_content":"这个0.2是怎么得出来的，为什么不是0.3或其他数，而是0.2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599037201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":212740,"ip_address":""},"score":302815,"extra":""}]}]}]}