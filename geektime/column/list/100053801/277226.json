{"id":277226,"title":"27 | 案例：如何实现简单的3D可视化图表？","content":"<p>你好，我是月影。</p><p>学了这么多图形学的基础知识和WebGL的视觉呈现技术，你一定已经迫不及待地想要开始实战了吧？今天，我带你完成一个小型的可视化项目，带你体会一下可视化开发的全过程。也正好借此机会，复习一下我们前面学过的全部知识。</p><p>这节课，我们要带你完成一个<strong>GitHub贡献图表的可视化作品</strong>。GitHub贡献图表是一个统计表，它统计了我们在GitHub中提交开源项目代码的次数。我们可以在GitHub账号信息的个人详情页中找到它。</p><p>下图中的红框部分就是我的贡献图表。你会看到，GitHub默认的贡献图表可视化展现是二维的，那我们要做的，就是把它改造为简单的动态3D柱状图表。</p><p><img src=\"https://static001.geekbang.org/resource/image/4a/0b/4a44441b2431ce98d6139b89ae16f70b.jpg?wh=1335*730\" alt=\"\" title=\"GitHub默认的贡献图表可视化展现示意图\"></p><h2>第一步：准备要展现的数据</h2><p>想要实现可视化图表，第一步就是准备数据。GitHub上有第三方API可以获得指定用户的GitHub贡献数据，具体可以看<a href=\"https://github.com/sallar/github-contributions-api\">这个项目</a>。</p><p>通过API，我们可以事先保存好一份JSON格式的数据，具体的格式和内容大致如下：</p><pre><code>// github_contributions_akira-cn.json\n\n{\n  &quot;contributions&quot;: [\n    {\n      &quot;date&quot;: &quot;2020-06-12&quot;,\n      &quot;count&quot;: 1,\n      &quot;color&quot;:&quot;#c6e48b&quot;,\n    },\n    ...\n  ],\n}\n</code></pre><p>从这份JSON文件中，我们可以取出每一天的提交次数count，以及一个颜色数据color。每天提交的次数越多，颜色就越深。有了这份数据内容，我们就可以着手实现具体的展现了。不过，因为数据很多，所以这次我们只想展现最近一年的数据。我们可以写一个函数，根据传入的时间对数据进行过滤。</p><!-- [[[read_end]]] --><p>这个函数的代码如下：</p><pre><code>let cache = null;\nasync function getData(toDate = new Date()) {\n  if(!cache) {\n    const data = await (await fetch('../assets/github_contributions_akira-cn.json')).json();\n    cache = data.contributions.map((o) =&gt; {\n      o.date = new Date(o.date.replace(/-/g, '/'));\n      return o;\n    });\n  }\n  // 要拿到 toData 日期之前大约一年的数据（52周）\n  let start = 0,\n    end = cache.length;\n  // 用二分法查找\n  while(start &lt; end - 1) {\n    const mid = Math.floor(0.5 * (start + end));\n    const {date} = cache[mid];\n    if(date &lt;= toDate) end = mid;\n    else start = mid;\n  }\n  // 获得对应的一年左右的数据\n  let day;\n  if(end &gt;= cache.length) {\n    day = toDate.getDay();\n  } else {\n    const lastItem = cache[end];\n    day = lastItem.date.getDay();\n  }\n  // 根据当前星期几，再往前拿52周的数据\n  const len = 7 * 52 + day + 1;\n  const ret = cache.slice(end, end + len);\n  if(ret.length &lt; len) {\n    // 日期超过了数据范围，补齐数据\n    const pad = new Array(len - ret.length).fill({count: 0, color: '#ebedf0'});\n    ret.push(...pad);\n  }\n  return ret;\n}\n</code></pre><p>这个函数的逻辑是，先从JSON文件中读取数据并缓存起来，然后传入对应的日期对象，获取该日期之前大约一年的数据（准确来说是该日期的前52周数据，再加上该日期当前周直到该日期为止的数据，公式为 7*52 + day + 1）。</p><p>这样，我们就准备好了要用来展现的数据。</p><h2>第二步：用SpriteJS渲染数据、完成绘图</h2><p>有了数据之后，接下来我们就要把数据渲染出来，完成绘图。这里，我们要用到一个新的JavaScript库SpriteJS来绘制。</p><p>既然如此，我们先来熟悉一下SpriteJS库。</p><p><a href=\"https://spritejs.org/#/\">SpriteJS</a>是基于WebGL的图形库，也是我设计和维护的开源可视化图形渲染引擎项目。它是一个支持树状元素结构的渲染库。也就是说，它和我们前端操作DOM类似，通过将元素一一添加到渲染树上，就可以完成最终的渲染。所以在后续的课程中，我们也会更多地用到它。</p><p>我们要用到的是SpriteJS的3D部分，它是基于我们熟悉的OGL库实现的。那我们为什么不直接用OGL库呢？这是因为SpriteJS在OGL的基础上，对几何体元素进行了类似DOM元素的封装。这样我们创建几何体元素就可以像操作DOM一样方便了，直接用d3库的selection子模块来操作就可以了。</p><h3>1.  创建Scene对象</h3><p>像DOM有documentElement作为根元素一样，SpriteJS也有根元素。SpriteJS的根元素是一个Scene对象，对应一个DOM元素作为容器。更形象点来说，我们可以把Scene理解为一个“场景”。那SpriteJS中渲染图形，都要在这个“场景”中进行。</p><p>接下来，我们就创建一个Scene对象，代码如下：</p><pre><code>const container = document.getElementById('stage');\n\nconst scene = new Scene({\n  container,\n  displayRatio: 2,\n});\n</code></pre><p>创建Scene对象，我们需要两个参数。一个参数是container，它是一个HTML元素，在这里是一个id为stage的元素，这个元素会作为SpriteJS的容器元素，之后SpriteJS会在这个元素上创建Canvas子元素。</p><p>第二个参数是displayRatio，这个参数是用来设置显示分辨率的。你应该还记得，在讲Canvas绘图的时候，我们提到过，为了让绘制出来的图形能够适配不同的显示设备，我们要把Canvas的像素宽高和CSS样式宽高设置成不同的值。所以这里，我们把displayRatio设为2，就可以让像素宽高是CSS样式宽高的2倍，对于一些像素密度为2的设备（如iPhone的屏幕），这么设置才不会让画布上绘制的图片、文字变得模糊。</p><h3>2.  创建Layer对象</h3><p>有了scene对象，我们再创建一个或多个Layer对象，也可以理解为是一个或者多个“图层”。在SpriteJS中，一个Layer对象就对应于一个Canvas画布。</p><pre><code>const layer = scene.layer3d('fglayer', {\n  camera: {\n    fov: 35,\n  },\n});\nlayer.camera.attributes.pos = [2, 6, 9];\nlayer.camera.lookAt([0, 0, 0]);\n\n</code></pre><p>如上面代码所示，我们通过调用scene.layer3d方法，就可以在scene对象上创建了一个3D（WebGL）上下文的Canvas画布。而且这里，我们把相机的视角设置为35度，坐标位置为（2, 6, 9），相机朝向坐标原点。</p><h3>3.  将数据转换成柱状元素</h3><p>接着，我们就要把数据转换成画布上的长方体元素。我们可以借助<a href=\"https://github.com/d3/d3-selection\">d3-selection</a>，d3是一个数据驱动文档的模型，d3-selection能够通过数据操作文档树，添加元素节点。当然，在使用d3-selection添加元素前，我们要先创建用来3D展示的WebGL程序。</p><p>因为SpriteJS提供了一些预置的着色器，比如shaders.GEOMETRY着色器，就是默认支持phong反射模型的一组着色器，我们直接调用它就可以了。</p><pre><code>const program = layer.createProgram({\n  vertex: shaders.GEOMETRY.vertex,\n  fragment: shaders.GEOMETRY.fragment,\n});\n</code></pre><p>创建好WebGL程序之后，我们就可以获取数据，用数据来操作文档树了。</p><pre><code>const dataset = await getData();\nconst max = d3.max(dataset, (a) =&gt; {\n  return a.count;\n});\n\n/* globals d3 */\nconst selection = d3.select(layer);\nconst chart = selection.selectAll('cube')\n  .data(dataset)\n  .enter()\n  .append(() =&gt; {\n    return new Cube(program);\n  })\n  .attr('width', 0.14)\n  .attr('depth', 0.14)\n  .attr('height', 1)\n  .attr('scaleY', (d) =&gt; {\n    return d.count / max;\n  })\n  .attr('pos', (d, i) =&gt; {\n    const x0 = -3.8 + 0.0717 + 0.0015;\n    const z0 = -0.5 + 0.05 + 0.0015;\n    const x = x0 + 0.143 * Math.floor(i / 7);\n    const z = z0 + 0.143 * (i % 7);\n    return [x, 0.5 * d.count /max, z];\n  })\n  .attr('colors', (d, i) =&gt; {\n    return d.color;\n  });\n</code></pre><p>如上面代码所示，我们先通过d3.select(layer)对象获得一个selection对象，再通过getData()获得数据，接着通过selection.selectAll(‘cube’).data(dataset).enter().append(…)遍历数据，创建元素节点。</p><p>这里，我们创建了Cube元素，就是长方体在SpriteJS中对应的对象，然后让dataset的每一条记录对应一个Cube元素，接着我们还要设置每个Cube元素的样式，让数据进入cube以后，能体现出不同的形状。</p><p>具体来说，我们要设置长方体Cube的长(width)、宽(depth)、高(height)属性，以及y轴的缩放(scaleY)，还有Cube的位置(pos)坐标和长方体的颜色(colors)。其中与数据有关的参数是scaleY、pos和colors，我就来详细说说它们。</p><p>对于scaleY，我们把它设置为d.count与max的比值。这里的max是指一年的提交记录中，提交代码最多那天的数值。这样，我们就可以保证scaleY的值在0~1之间，既不会太小、也不会太大。这种用相对数值来做可视化展现的做法，是可视化处理数据的一种常用基础技巧，在数据篇我们还会深入去讲。</p><p>而pos是根据数据的索引设置x和z来决定的。由于Cube的坐标基于中心点对齐的，现在我们想让它们变成底部对齐，所以需要把y设置为d.count/max的一半。</p><p>最后，我们再根据数据中的color值设置Cube的颜色。这样，我们通过数据将元素添加之后，画布上渲染出来的结果就是一个3D柱状图了，效果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/0c/a6/0c7a265e05d79336fc5a045dd6b3c0a6.gif?wh=520*414\" alt=\"\"></p><h2>第三步：补充细节，实现更好的视觉效果</h2><p>现在这个3D柱状图，还很粗糙。我们可以在此基础上，增加一些视觉上的细节效果。比如说，我们可以给这个柱状图添加光照。比如，我们可以修改环境光，把颜色设置成(0.5, 0.5, 0.5, 1)，再添加一道白色的平行光，方向是(-3, -3, -1)。这样的话，柱状图就会有光照效果了。具体的代码和效果图如下：</p><pre><code>const layer = scene.layer3d('fglayer', {\n  ambientColor: [0.5, 0.5, 0.5, 1],\n  camera: {\n    fov: 35,\n  },\n});\nlayer.camera.attributes.pos = [2, 6, 9];\nlayer.camera.lookAt([0, 0, 0]);\n\nconst light = new Light({\n  direction: [-3, -3, -1],\n  color: [1, 1, 1, 1],\n});\n\nlayer.addLight(light);\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/0e/fb/0e9764123667yy18329ef01a4a6771fb.gif?wh=520*414\" alt=\"\"></p><p>除此之外，我们还可以给柱状图增加一个底座，代码和效果图如下：</p><pre><code>const fragment = `\n  precision highp float;\n  precision highp int;\n  varying vec4 vColor;\n  varying vec2 vUv;\n  void main() {\n    float x = fract(vUv.x * 53.0);\n    float y = fract(vUv.y * 7.0);\n    x = smoothstep(0.0, 0.1, x) - smoothstep(0.9, 1.0, x);\n    y = smoothstep(0.0, 0.1, y) - smoothstep(0.9, 1.0, y);\n    gl_FragColor = vColor * (x + y);\n  }    \n`;\n\nconst axisProgram = layer.createProgram({\n  vertex: shaders.TEXTURE.vertex,\n  fragment,\n});\n\nconst ground = new Cube(axisProgram, {\n  width: 7.6,\n  height: 0.1,\n  y: -0.049, // not 0.05 to avoid z-fighting\n  depth: 1,\n  colors: 'rgba(0, 0, 0, 0.1)',\n});\n\nlayer.append(ground);\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/b1/ce/b1c0dec29b6e6b16c4d86e786f7d12ce.gif?wh=520*414\" alt=\"\"></p><p>上面的代码不复杂，我想重点解释其中两处。首先是片元着色器代码，我们使用了根据纹理坐标来实现重复图案的技术。这个方法和我们<a href=\"https://time.geekbang.org/column/article/262330\">第11节课</a>说的思路完全一样，如果你对这个方法感到陌生了，可以回到前面复习一下。</p><p>其次，我们将底座的高度设置为0.1，y的值本来应该是-0.1的一半，也就是-0.05，但是我们设置为了-0.049。少了0.001是为了让上层的柱状图稍微“嵌入”到底座里，从而避免因为底座上部和柱状图底部的z坐标一样，导致渲染的时候由于次序问题出现闪烁，这个问题在图形学术语里面有一个名字叫做z-fighting。</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/f8/9da3bdd37c5e269b551b63b8ac7510f8.gif?wh=552*414\" alt=\"\" title=\"z-fighting 现象\"></p><p>z-fighting是3D绘图中的一个常见问题，所以我再多解释一下。在WebGL中绘制3D物体，一般我们开启了深度检测之后，引擎会自动计算3D物体的深度，让离观察者很近的物体面，把离观察者比较远和背对着观察者的物体面遮挡住。那具体是怎么遮挡的呢？其实是根据物体在相机空间中的z坐标来判断的。</p><p>但有一种特殊情况，就是两个面的z坐标相同，又有重叠的部分。这时候，引擎就可能一会儿先渲染A面，过一会儿又先去渲染B面，这样渲染出来的内容就出现了“闪烁”现象，这就是z-fighting。</p><p><img src=\"https://static001.geekbang.org/resource/image/37/8c/3718a4e779004624f44ce952923c348c.jpg?wh=1360*944\" alt=\"\" title=\"如果A和B深度（z坐标）相同，那么A、B重叠部分渲染次序可能每次不同，从而产生z-fighting\"></p><p>z-fighting有很多解决方法，比如可以人为指定一下几何体渲染的次序，或者，就是让它们的坐标不要完全相同，在上面的例子里，我们就采用了让坐标不完全相同的处理办法。</p><p>最后，为了让实现出来的图形更有趣，我们再增加一个过渡动画，让柱状图的高度从不显示，到慢慢显示出来。</p><p><img src=\"https://static001.geekbang.org/resource/image/88/08/887d3e8b4e356b9139934eee7bb70c08.gif?wh=604*444\" alt=\"\"></p><p>要实现这个效果，我们需要稍微修改一下d3.selection的代码。</p><pre><code>  const chart = selection.selectAll('cube')\n    .data(dataset)\n    .enter()\n    .append(() =&gt; {\n      return new Cube(program);\n    })\n    .attr('width', 0.14)\n    .attr('depth', 0.14)\n    .attr('height', 1)\n    .attr('scaleY', 0.001)\n    .attr('pos', (d, i) =&gt; {\n      const x0 = -3.8 + 0.0717 + 0.0015;\n      const z0 = -0.5 + 0.05 + 0.0015;\n      const x = x0 + 0.143 * Math.floor(i / 7);\n      const z = z0 + 0.143 * (i % 7);\n      return [x, 0, z];\n    })\n    .attr('colors', (d, i) =&gt; {\n      return d.color;\n    });\n</code></pre><p>如上面代码所示，我们先把scaleY直接设为0.001，然后我们用d3.scaleLinear来创建一个线性的缩放过程，最后，我们通过chart.trainsition来实现这个线性动画。</p><pre><code>const linear = d3.scaleLinear()\n  .domain([0, max])\n  .range([0, 1.0]);\n\nchart.transition()\n  .duration(2000)\n  .attr('scaleY', (d, i) =&gt; {\n    return linear(d.count);\n  })\n  .attr('y', (d, i) =&gt; {\n    return 0.5 * linear(d.count);\n  });\n</code></pre><p>到这里呢，我们就实现了我们想要实现的所有效果了。</p><h2>要点总结</h2><p>这节课，我们一起实现了3D动态的GitHub贡献图表，整个实现过程可以总结为两步。</p><p>第一步是处理数据，我们可以通过API获取JSON数据，然后得到我们想要的数据格式。第二步是渲染数据，今天我们是使用SpriteJS来渲染的，它的API类似于DOM，对d3非常友好。所以我们可以直接使用d3-selection，以数据驱动文档的方式就可以构建几何体元素。</p><p>并且，为了更好地展现数据之间的变换关系，我们根据数据创建了Cube元素，并将它们渲染了出来。而且，我们还给实现的柱状元素设置了光照、实现了过渡动画，算是实现了一个比较完整的可视化效果。</p><p>此外，我们还要注意，在实现过渡动画的过程中，很容易出现z-fighting问题，也就是我们实现的元素由于次序问题，在渲染的时候出现闪烁。这个问题在可视化中非常常见，不过，我们通过设置渲染次序或者避免坐标相同就可以避免。</p><p>到这里，我们视觉进阶篇的内容就全部讲完了。这一篇，我从实现简单的动画，讲到了3D物体的绘制、旋转、移动，以及给它们添加光照效果、法线贴图，让它们能更贴近真实的物体。</p><p>说实话，这一篇的内容单看真的不简单。但你认真看了会发现，所有的知识都是环环相扣的，只要有了前几篇的基础，我们再来学肯定可以学会。为了帮助你梳理这一篇的内容，我总结了一张知识脑图放在了下面，你可以看看。</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/65/fd8eb76869dc873a816f92ddbd76c265.jpg?wh=1354*1590\" alt=\"\"></p><h2>小试牛刀</h2><p>我们今天讲的这个例子，你学会了吗？你可以用自己的GitHub贡献数据，来实现同样的图表，也可以稍微修改一下它的样式，比如采用不同的颜色、不同的光照效果等等。</p><p>另外，课程中的例子是默认获取最近一年到当天的数据，你也可以扩展一下功能，让这个图表可以设置日期范围，根据日期范围来呈现数据。</p><p>如果你的GitHub贡献数据不是很多，也可以去找相似平台上的数据，来实现类似的图表。</p><p>今天的实战项目有没有让你体会到可视化的魅力呢？那就快把它分享出去吧！我们下节课再见！</p><hr><h2><span class=\"reference\">源码</span></h2><p><span class=\"reference\"><a href=\"https://github.com/akira-cn/graphics/tree/master/github-contributions\">实现3D可视化图表详细代码</a></span></p><h2><span class=\"reference\">推荐阅读</span></h2><p><span class=\"reference\">[1] <a href=\"https://spritejs.org\">SpriteJS官网</a></span><br>\n<span class=\"reference\">[2] <a href=\"https://github.com/d3/d3/blob/master/API.md\">d3-api</a></span></p>","comments":[{"had_liked":false,"id":243652,"user_name":"Geek_frank","can_delete":false,"product_type":"c1","uid":2049021,"ip_address":"","ucode":"CF973E61ED2E59","user_header":"https://static001.geekbang.org/account/avatar/00/1f/43/fd/cf190699.jpg","comment_is_top":false,"comment_ctime":1598240537,"is_pvip":true,"replies":[{"id":"89822","content":"一共53周，每周7天。x0, z0根据不同天对应图表中的格子","user_name":"作者回复","comment_id":243652,"uid":"1159792","ip_address":"","utype":1,"ctime":1598313617,"user_name_real":"月影"}],"discussion_count":2,"race_medal":0,"score":"10188175129","product_id":100053801,"comment_content":"fragment 中53、7是怎么得到的？pos属性中x0,z0的数值设定有什么讲究的？","like_count":2,"discussions":[{"author":{"id":1159792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b2/70/ba9cecc6.jpg","nickname":"月影","note":"","ucode":"298582FA7DBF27","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504349,"discussion_content":"一共53周，每周7天。x0, z0根据不同天对应图表中的格子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598313617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2049021,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/43/fd/cf190699.jpg","nickname":"Geek_frank","note":"","ucode":"CF973E61ED2E59","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300720,"discussion_content":"53是列数，7是行数。x0,z0还不明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598247842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248335,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1600128044,"is_pvip":false,"replies":[{"id":"94966","content":"不需要每个都设置，关键的一些设置一下就好了","user_name":"作者回复","comment_id":248335,"uid":"1159792","ip_address":"","utype":1,"ctime":1605493299,"user_name_real":"月影"}],"discussion_count":1,"race_medal":0,"score":"5895095340","product_id":100053801,"comment_content":"你好，在绘制大场景的时候，设置每个模型的绘制顺序，好像不太合适吧？有没有其他解决z-fighting的方法？","like_count":1,"discussions":[{"author":{"id":1159792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b2/70/ba9cecc6.jpg","nickname":"月影","note":"","ucode":"298582FA7DBF27","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505625,"discussion_content":"不需要每个都设置，关键的一些设置一下就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605493299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335844,"user_name":"Geek_25714e","can_delete":false,"product_type":"c1","uid":2925206,"ip_address":"","ucode":"08887C8E7B732A","user_header":"","comment_is_top":false,"comment_ctime":1645716228,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1645716228","product_id":100053801,"comment_content":"失效了","like_count":0,"discussions":[{"author":{"id":2925206,"avatar":"","nickname":"Geek_25714e","note":"","ucode":"08887C8E7B732A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553123,"discussion_content":"spitejs url","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645719081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251968,"user_name":"Noah","can_delete":false,"product_type":"c1","uid":1018526,"ip_address":"","ucode":"A13DBCE8BA74CC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/9e/94bdcdc5.jpg","comment_is_top":false,"comment_ctime":1602020261,"is_pvip":false,"replies":[{"id":"94956","content":"两个库都挺好的哈，我个人没有什么特别偏好","user_name":"作者回复","comment_id":251968,"uid":"1159792","ip_address":"","utype":1,"ctime":1605492743,"user_name_real":"月影"}],"discussion_count":1,"race_medal":0,"score":"1602020261","product_id":100053801,"comment_content":"老师可不可以点评比较一下ThreeJS和BabylonJS这两个库？","like_count":0,"discussions":[{"author":{"id":1159792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b2/70/ba9cecc6.jpg","nickname":"月影","note":"","ucode":"298582FA7DBF27","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506676,"discussion_content":"两个库都挺好的哈，我个人没有什么特别偏好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605492743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}