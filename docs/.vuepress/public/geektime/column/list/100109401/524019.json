{"id":524019,"title":"40｜RESTful Web Services（4）：在当前架构愿景下，要如何分解任务？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式实现RESTful Web Services。</p><p>现在请回想一下TDD的流程（参看<a href=\"https://time.geekbang.org/column/article/496703\">第11讲</a>）：</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/3a/d0f2ee19dba1881d14013930de7c173a.jpg?wh=8000x4500\" alt=\"\"></p><p>目前的架构愿景如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/c4/b889c031c6dff9254522928cc50856c4.jpg?wh=2284x1315\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/cc/97/cc54561589ff2ab51df4150fed195997.jpg?wh=8000x4500\" alt=\"\"></p><h2>将需求分解为任务列表</h2><p>JAX-RS的需求非常庞杂，根据前面我们介绍过的部分（参看第36讲），主要的功能有这样几个方面：</p><ul>\n<li>将请求派分给对应的资源（Resource），并根据返回的状态、超媒体类型、内容，响应Http请求。</li>\n<li>在处理请求派分时，可以支持多级子资源（Sub-Resource）。</li>\n<li>在处理请求派分时，可以根据客户端提供的超媒体类型，选择对应的资源方法（Resource Method）。</li>\n<li>在处理请求派分时，可以根据客户端提供的Http方法，选择对应的资源方法。</li>\n<li>资源方法可以返回Java对象，由Runtime自行推断正确的返回状态。</li>\n<li>资源方法可以不明确指定返回的超媒体类型，由Runtime自行推断。比如资源方法标注了Produces，那么就使用标注提供的超媒体类型等。</li>\n<li>可通过扩展点MessageBodyWriter处理不同类型的返回内容。</li>\n<li>当资源方法抛出异常时，根据异常影响Http请求。</li>\n<li>可通过扩展点ExceptionMapper处理不同类型的异常。</li>\n<li>资源方法可按照期望的类型，访问Http请求的内容。</li>\n<li>可通过扩展点MessageBodyReader处理不同类型的请求内容。</li>\n<li>资源对象和资源方法可接受环境组件的注入。</li>\n</ul><!-- [[[read_end]]] --><p>正如在DI Container项目中看到的那样，这并不一定是最终完成的功能。随着项目的进行，我们还可能会增加更多的功能点。下一步，是根据架构愿景，将功能点关联到不同的功能上下文（也就是架构愿景中的组件）：</p><ul>\n<li>\n<p>将请求派分给对应的资源（Resource），并根据返回的状态、超媒体类型、内容，响应Http请求</p>\n<ul>\n<li>ResourceServlet</li>\n<li>ResourceRouter</li>\n</ul>\n</li>\n<li>\n<p>在处理请求派分时，可以支持多级子资源（Sub-Resource）</p>\n<ul>\n<li>ResourceRouter</li>\n</ul>\n</li>\n<li>\n<p>在处理请求派分时，可以根据客户端提供的超媒体类型，选择对应的资源方法（Resource Method）</p>\n<ul>\n<li>ResourceRouter</li>\n</ul>\n</li>\n<li>\n<p>在处理请求派分时，可以根据客户端提供的Http方法，选择对应的资源方法</p>\n<ul>\n<li>ResourceRouter</li>\n</ul>\n</li>\n<li>\n<p>资源方法可以返回Java对象，由Runtime自行推断正确的返回状态</p>\n<ul>\n<li>ResourceRouter</li>\n</ul>\n</li>\n<li>\n<p>资源方法可以不明确指定返回的超媒体类型，由Runtime自行推断，比如，资源方法标注了Produces，那么就使用标注提供的超媒体类型等</p>\n<ul>\n<li>ResourceRouter</li>\n</ul>\n</li>\n<li>\n<p>可通过扩展点MessageBodyWriter处理不同类型的返回内容</p>\n<ul>\n<li>Providers</li>\n</ul>\n</li>\n<li>\n<p>当资源方法抛出异常时，根据异常影响Http请求</p>\n<ul>\n<li>ResourceServlet</li>\n</ul>\n</li>\n<li>\n<p>可通过扩展点ExceptionMapper处理不同类型的异常</p>\n<ul>\n<li>Providers</li>\n</ul>\n</li>\n<li>\n<p>资源方法可按找期望的类型，访问Http请求的内容</p>\n<ul>\n<li>ResourceRouter</li>\n</ul>\n</li>\n<li>\n<p>可通过扩展点MessageBodyReader处理不同类型的请求内容</p>\n<ul>\n<li>Providers</li>\n</ul>\n</li>\n<li>\n<p>资源对象和资源方法可接受环境组件的注入</p>\n<ul>\n<li>ResourceContext</li>\n<li>ReosurceRouter</li>\n</ul>\n</li>\n</ul><p>如果是应用系统，那么我们可以继续分解到任务项。然而对于技术框架，特别是从头开始研发的技术框架，按照技术组件重组功能列表是更常用的手法：</p><ul>\n<li>\n<p>ResourceServlet</p>\n<ul>\n<li>将请求派分给对应的资源（Resource），并根据返回的状态、超媒体类型、内容，响应Http请求</li>\n<li>当资源方法抛出异常时，根据异常影响Http请求</li>\n</ul>\n</li>\n<li>\n<p>ResourceRouter</p>\n<ul>\n<li>将请求派分给对应的资源（Resource），并根据返回的状态、超媒体类型、内容，响应Http请求</li>\n<li>在处理请求派分时，可以支持多级子资源（Sub-Resource）</li>\n<li>在处理请求派分时，可以根据客户端提供的超媒体类型，选择对应的资源方法（Resource Method）</li>\n<li>在处理请求派分时，可以根据客户端提供的Http方法，选择对应的资源方法</li>\n<li>资源方法可以返回Java对象，由Runtime自行推断正确的返回状态</li>\n<li>资源方法可以不明确指定返回的超媒体类型，由Runtime自行推断，比如，资源方法标注了Produces，那么就使用标注提供的超媒体类型等</li>\n<li>资源方法可按找期望的类型，访问Http请求的内容</li>\n<li>资源对象和资源方法可接受环境组件的注入</li>\n</ul>\n</li>\n<li>\n<p>Providers</p>\n<ul>\n<li>可通过扩展点MessageBodyWriter处理不同类型的返回内容</li>\n<li>可通过扩展点ExceptionMapper处理不同类型的异常</li>\n</ul>\n</li>\n<li>\n<p>ResourceContext</p>\n<ul>\n<li>资源对象和资源方法可接受环境组件的注入</li>\n</ul>\n</li>\n</ul><p>在这个任务列表中，会发现并没有涉及架构愿景中的全部组件。比如Runtime，这类组件通常是支撑性的组件，可以在主要组件功能完成之后，再分解相关的需求。也可以在主要功能实现的过程中，逐渐明确它们的需求。</p><p>当采用伦敦学派时，会按照调用栈顺序从外而内地实现不同的组件。因而，我们首先需要先实现的是ResourceServlet。那么细化任务列表：</p><ul>\n<li>\n<p>ResourceServlet</p>\n<ul>\n<li>\n<p>将请求派分给对应的资源（Resource），并根据返回的状态、超媒体类型、内容，响应Http请求</p>\n</li>\n<li>\n<p>使用OutboundResponse的status作为Http Response的状态；</p>\n</li>\n<li>\n<p>使用OutboundResponse的headers作为Http Response的Http Headers；</p>\n</li>\n<li>\n<p>通过MessageBodyWriter将OutboundResponse的GenericEntity写回为Body；</p>\n</li>\n<li>\n<p>如果找不到对应的MessageBodyWriter，则返回500族错误</p>\n</li>\n<li>\n<p>当资源方法抛出异常时，根据异常影响Http请求</p>\n</li>\n<li>\n<p>如果抛出WebApplicationException，且response不为null，则使用response响应Http</p>\n</li>\n<li>\n<p>如果抛出WebApplicationException，而response为null，则通过异常的具体类型查找ExceptionMapper，生产response响应Http请求</p>\n</li>\n<li>\n<p>如果抛出的不是WebApplicationException，则通过异常的具体类型查找ExceptionMapper，生产response响应Http请求</p>\n</li>\n</ul>\n</li>\n</ul><h2>进入红/绿循环</h2><p>现在依照这个任务列表，进入TDD的红/绿循环，所使用的build.grade.kts文件为：</p><pre><code>plugins {\n    `java-library`\n    &quot;jacoco&quot;\n}\nrepositories {\n    mavenCentral()\n}\ndependencies {\n    implementation(&quot;jakarta.inject:jakarta.inject-api:2.0.1.MR&quot;)\n    implementation(&quot;jakarta.ws.rs:jakarta.ws.rs-api:3.1.0&quot;)\n    implementation(&quot;jakarta.servlet:jakarta.servlet-api:5.0.0&quot;)\n    implementation(project(&quot;:01.di.container&quot;))\n    testImplementation(&quot;org.junit.jupiter:junit-jupiter:5.8.2&quot;)\n    testImplementation(&quot;org.mockito:mockito-core:4.5.1&quot;)\n    testImplementation(&quot;org.eclipse.jetty:jetty-server:11.0.9&quot;)\n    testImplementation(&quot;org.eclipse.jetty:jetty-servlet:11.0.9&quot;)\n    \n}\ntasks.withType&lt;Test&gt;() {\n    useJUnitPlatform()\n}\njava {\n    sourceCompatibility = JavaVersion.VERSION_17\n    targetCompatibility = JavaVersion.VERSION_17\n}\n</code></pre><p><video poster=\"https://media001.geekbang.org/445a89ebf2ae47739b741c1df586bd99/snapshots/b92e4e6a3094429e9dbae3942bd96322-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/32b6660-1813797c7fc-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/97573dec387647faa0202273ca52ea7b/deb3ef26ae3c40bc93f31ba06c45740b-628d8b5835ae6b5527a1d587057770ed-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>在进入下节课之前，希望你能认真思考如下两个问题。</p><ol>\n<li>针对RuntimeDelegate，我们要如何调整任务列表和架构愿景？</li>\n<li>你是怎么理解任务分解的？</li>\n</ol><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码的链接分享出来。相信经过你的思考与实操，学习效果会更好！</p>","neighbors":{"left":{"article_title":"39｜RESTful Web Services（3）：明确架构愿景与调用栈顺序","id":524018},"right":{"article_title":"41｜RESTful Web Services（5）：如何通过对数据测试的管理来凸显意图？","id":526940}},"comments":[{"had_liked":false,"id":348897,"user_name":"枫中的刀剑","can_delete":false,"product_type":"c1","uid":1322387,"ip_address":"","ucode":"4B086F538184AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/93/0f1cbf44.jpg","comment_is_top":false,"comment_ctime":1655521481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655521481","product_id":100109401,"comment_content":"缺少两个依赖<br>    implementation(&quot;org.slf4j:slf4j-api:2.0.0-alpha7&quot;)<br>    implementation(&quot;org.slf4j:slf4j-simple:2.0.0-alpha7&quot;)<br>不然在视频最后那几个因缺少stub的报错无法出现。<br><br>","like_count":0},{"had_liked":false,"id":348791,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1655395712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655395712","product_id":100109401,"comment_content":"你是怎么理解任务分解的？<br><br>将抽象的任务不断具体化，直到可以编码实现。<br>例如：用户登录是一个抽象的任务。<br>第一步可以分解为通过手机短信、微信、微博登录；<br>第二步再对上面步骤中的每个任务进行分解，例如：手机短信登陆需要获得手机号码、生成验证码、发送验证码<br>以此类推直到消除抽象，实现愿望<br><br>代码 https:&#47;&#47;github.com&#47;wyyl1&#47;geektime-tdd-framework&#47;tree&#47;4","like_count":0}]}