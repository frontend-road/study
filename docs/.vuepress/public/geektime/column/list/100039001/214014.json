{"id":214014,"title":"60 | 策略模式（上）：如何避免冗长的if-else/switch分支判断代码？","content":"<p>上两节课中，我们学习了模板模式。模板模式主要起到代码复用和扩展的作用。除此之外，我们还讲到了回调，它跟模板模式的作用类似，但使用起来更加灵活。它们之间的主要区别在于代码实现，模板模式基于继承来实现，回调基于组合来实现。</p><p>今天，我们开始学习另外一种行为型模式，策略模式。在实际的项目开发中，这个模式也比较常用。最常见的应用场景是，利用它来避免冗长的if-else或switch分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。</p><p>对于策略模式，我们分两节课来讲解。今天，我们讲解策略模式的原理和实现，以及如何用它来避免分支判断逻辑。下一节课，我会通过一个具体的例子，来详细讲解策略模式的应用场景以及真正的设计意图。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>策略模式的原理与实现</h2><p>策略模式，英文全称是Strategy Design Pattern。在GoF的《设计模式》一书中，它是这样定义的：</p><blockquote>\n<p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>\n</blockquote><!-- [[[read_end]]] --><p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p><p>我们知道，工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。接下来，我就详细讲讲一个完整的策略模式应该包含的这三个部分。</p><h3>1.策略的定义</h3><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。示例代码如下所示：</p><pre><code>public interface Strategy {\n  void algorithmInterface();\n}\n\npublic class ConcreteStrategyA implements Strategy {\n  @Override\n  public void  algorithmInterface() {\n    //具体的算法...\n  }\n}\n\npublic class ConcreteStrategyB implements Strategy {\n  @Override\n  public void  algorithmInterface() {\n    //具体的算法...\n  }\n}\n</code></pre><h3>2.策略的创建</h3><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据type创建策略的逻辑抽离出来，放到工厂类中。示例代码如下所示：</p><pre><code>public class StrategyFactory {\n  private static final Map&lt;String, Strategy&gt; strategies = new HashMap&lt;&gt;();\n\n  static {\n    strategies.put(&quot;A&quot;, new ConcreteStrategyA());\n    strategies.put(&quot;B&quot;, new ConcreteStrategyB());\n  }\n\n  public static Strategy getStrategy(String type) {\n    if (type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n    }\n    return strategies.get(type);\n  }\n}\n</code></pre><p>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用getStrategy()的时候，都创建一个新的策略对象。针对这种情况，我们可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p><p>相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实现策略工厂类。</p><pre><code>public class StrategyFactory {\n  public static Strategy getStrategy(String type) {\n    if (type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n    }\n\n    if (type.equals(&quot;A&quot;)) {\n      return new ConcreteStrategyA();\n    } else if (type.equals(&quot;B&quot;)) {\n      return new ConcreteStrategyB();\n    }\n\n    return null;\n  }\n}\n</code></pre><h3>3.策略的使用</h3><p>刚刚讲了策略的定义和创建，现在，我们再来看一下，策略的使用。</p><p>我们知道，策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p><p>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。接下来，我们通过一个例子来解释一下。</p><pre><code>// 策略接口：EvictionStrategy\n// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...\n// 策略工厂：EvictionStrategyFactory\n\npublic class UserCache {\n  private Map&lt;String, User&gt; cacheData = new HashMap&lt;&gt;();\n  private EvictionStrategy eviction;\n\n  public UserCache(EvictionStrategy eviction) {\n    this.eviction = eviction;\n  }\n\n  //...\n}\n\n// 运行时动态确定，根据配置文件的配置决定使用哪种策略\npublic class Application {\n  public static void main(String[] args) throws Exception {\n    EvictionStrategy evictionStrategy = null;\n    Properties props = new Properties();\n    props.load(new FileInputStream(&quot;./config.properties&quot;));\n    String type = props.getProperty(&quot;eviction_type&quot;);\n    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);\n    UserCache userCache = new UserCache(evictionStrategy);\n    //...\n  }\n}\n\n// 非运行时动态确定，在代码中指定使用哪种策略\npublic class Application {\n  public static void main(String[] args) {\n    //...\n    EvictionStrategy evictionStrategy = new LruEvictionStrategy();\n    UserCache userCache = new UserCache(evictionStrategy);\n    //...\n  }\n}\n</code></pre><p>从上面的代码中，我们也可以看出，“非运行时动态确定”，也就是第二个Application中的使用方式，并不能发挥策略模式的优势。在这种应用场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。</p><h2>如何利用策略模式避免分支判断？</h2><p>实际上，能够移除分支判断逻辑的模式不仅仅有策略模式，后面我们要讲的状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。</p><p>我们先通过一个例子来看下，if-else或switch-case分支判断逻辑是如何产生的。具体的代码如下所示。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直接耦合在一起。</p><pre><code>public class OrderService {\n  public double discount(Order order) {\n    double discount = 0.0;\n    OrderType type = order.getType();\n    if (type.equals(OrderType.NORMAL)) { // 普通订单\n      //...省略折扣计算算法代码\n    } else if (type.equals(OrderType.GROUPON)) { // 团购订单\n      //...省略折扣计算算法代码\n    } else if (type.equals(OrderType.PROMOTION)) { // 促销订单\n      //...省略折扣计算算法代码\n    }\n    return discount;\n  }\n}\n</code></pre><p>如何来移除掉分支判断逻辑呢？那策略模式就派上用场了。我们使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。具体的代码如下所示：</p><pre><code>// 策略的定义\npublic interface DiscountStrategy {\n  double calDiscount(Order order);\n}\n// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...\n\n// 策略的创建\npublic class DiscountStrategyFactory {\n  private static final Map&lt;OrderType, DiscountStrategy&gt; strategies = new HashMap&lt;&gt;();\n\n  static {\n    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());\n    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());\n    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());\n  }\n\n  public static DiscountStrategy getDiscountStrategy(OrderType type) {\n    return strategies.get(type);\n  }\n}\n\n// 策略的使用\npublic class OrderService {\n  public double discount(Order order) {\n    OrderType type = order.getType();\n    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);\n    return discountStrategy.calDiscount(order);\n  }\n}\n</code></pre><p>重构之后的代码就没有了if-else分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，我们用Map来缓存策略，根据type直接从Map中获取对应的策略，从而避免if-else分支判断逻辑。等后面讲到使用状态模式来避免分支判断逻辑的时候，你会发现，它们使用的是同样的套路。本质上都是借助“查表法”，根据type查表（代码中的strategies就是表）替代根据type分支判断。</p><p>但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方式了。具体的代码如下所示：</p><pre><code>public class DiscountStrategyFactory {\n  public static DiscountStrategy getDiscountStrategy(OrderType type) {\n    if (type == null) {\n      throw new IllegalArgumentException(&quot;Type should not be null.&quot;);\n    }\n    if (type.equals(OrderType.NORMAL)) {\n      return new NormalDiscountStrategy();\n    } else if (type.equals(OrderType.GROUPON)) {\n      return new GrouponDiscountStrategy();\n    } else if (type.equals(OrderType.PROMOTION)) {\n      return new PromotionDiscountStrategy();\n    }\n    return null;\n  }\n}\n</code></pre><p>这种实现方式相当于把原来的if-else分支逻辑，从OrderService类中转移到了工厂类中，实际上并没有真正将它移除。关于这个问题如何解决，我今天先暂时卖个关子。你可以在留言区说说你的想法，我在下一节课中再讲解。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p><p>策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p><ul>\n<li>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</li>\n<li>策略的创建由工厂类来完成，封装策略创建的细节。</li>\n<li>策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</li>\n</ul><p>除此之外，我们还可以通过策略模式来移除if-else分支判断。实际上，这得益于策略工厂类，更本质上点讲，是借助“查表法”，根据type查表替代根据type分支判断。</p><h2>课堂讨论</h2><p>今天我们讲到，在策略工厂类中，如果每次都要返回新的策略对象，我们还是需要在工厂类中编写if-else分支判断逻辑，那这个问题该如何解决呢？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"59 | 模板模式（下）：模板模式与Callback回调函数有何区别和联系？","id":212802},"right":{"article_title":"61 | 策略模式（下）：如何实现一个支持给不同大小文件排序的小程序？","id":215132}},"comments":[{"had_liked":false,"id":190427,"user_name":"宁锟","can_delete":false,"product_type":"c1","uid":1249781,"ip_address":"","ucode":"815FC9A9EBB109","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","comment_is_top":false,"comment_ctime":1584659581,"is_pvip":false,"discussion_count":22,"race_medal":0,"score":"1066736548989","product_id":100039001,"comment_content":"仍然可以用查表法，只不过存储的不再是实例，而是class，使用时获取对应的class，再通过反射创建实例","like_count":249},{"had_liked":false,"id":190619,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1584673114,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"323707220314","product_id":100039001,"comment_content":"策略模式和工厂模式区别：<br><br>工厂模式<br>1.目的是创建不同且相关的对象<br>2.侧重于&quot;创建对象&quot;<br>3.实现方式上可以通过父类或者接口<br>4.一般创建对象应该是现实世界中某种事物的映射，有它自己的属性与方法！<br><br>策略模式<br>1.目的实现方便地替换不同的算法类<br>2.侧重于算法(行为)实现<br>3.实现主要通过接口<br>4.创建对象对行为的抽象而非对对象的抽象，很可能没有属于自己的属性。","like_count":76,"discussions":[{"author":{"id":1322366,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7e/335a9b9d.jpg","nickname":"🐝null","note":"","ucode":"16F5E4965F8D5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314040,"discussion_content":"关注点不一样，一个是创建对象，一个是方法执行策略。  两者不要放到一起对比\n策略也是一种对象，所以策略的创建要用到工厂模式。（当然不用工厂也可以）","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603114097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309124,"discussion_content":"我说说我的看法哈：\n策略模式用到了一部分工厂模式，我觉得俩根本就不搭嘎。\n甚至我不创建策略工厂，直接注入List<Stragegy>.stream().filter(Predicate).forEach(策略方法)，我觉得也行。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1601193124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218403,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/63/d2e24ed2.jpg","nickname":"一只酸奶牛","note":"","ucode":"10E2BE972D4E0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538392,"discussion_content":"感觉考验是思维方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639401971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190469,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1584662904,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"164793420152","product_id":100039001,"comment_content":"一般而言Java web开发中我们均使用spring框架，可以使用运行时自定义注解给具体的策略类打上注解，将具体的策略类放于spring 容器中，工厂中注入直接根据类型获取即可.不实用spring框架的话，也可以用Java的反射做到获取到具体的策略类","like_count":39},{"had_liked":false,"id":190547,"user_name":"攻城拔寨","can_delete":false,"product_type":"c1","uid":1053934,"ip_address":"","ucode":"CBC37183DAB6B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","comment_is_top":false,"comment_ctime":1584667953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"100368915761","product_id":100039001,"comment_content":"策略模式通常跟工厂一起配合使用。<br>策略侧重如何灵活选择替换，<br>工厂侧重怎么创建实例","like_count":23},{"had_liked":false,"id":214559,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1588765504,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"91783078720","product_id":100039001,"comment_content":"查表策略还是挺常见的，搭配java.util.function各种接口挺好用的。<br><br>    private final Map&lt;String, Function&lt;String, String&gt;&gt; PHONE_FUN_FACTORY =<br>        ImmutableMap.of(<br>            MessageDestination.LEGAL_PERSON.name(), legalPersonPhoneFunc(),<br>            MessageDestination.ACTUAL_CONTROL.name(), actualPersonPhoneFunc()<br>        );<br><br>我比较喜欢建一个StrategyContext类，简单工厂+策略模式。<br>Context类存在一个成员变量xxx，new StrategyContext(xxx).apply();<br>然后StrategyContext内部存放一个表，value是一堆function，通过成员变量查表找对应的func.apply即可","like_count":21,"discussions":[{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539600,"discussion_content":"mark，还没这么用过，学习了。 private final Map&lt;String, Function&lt;String, String&gt;&gt; PHONE_FUN_FACTORY =\n        ImmutableMap.of(\n            MessageDestination.LEGAL_PERSON.name(), legalPersonPhoneFunc(),\n            MessageDestination.ACTUAL_CONTROL.name(), actualPersonPhoneFunc()\n        );","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639760113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1185673,"avatar":"https://static001.geekbang.org/account/avatar/00/12/17/89/b43884ea.jpg","nickname":"High-five!!!","note":"","ucode":"F0A67636A99C24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582624,"discussion_content":"fp思想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659537554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605058,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","nickname":"东方拓睿","note":"","ucode":"1FD25D75CAC7C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576105,"discussion_content":"结合java8来使用，学到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655279280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100631,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/57/67292e5a.jpg","nickname":"@123","note":"","ucode":"70170D27F05201","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545835,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642062921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193525,"user_name":"Jasongrass","can_delete":false,"product_type":"c1","uid":1732634,"ip_address":"","ucode":"7159E533D1D764","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/1a/cf0dbaac.jpg","comment_is_top":false,"comment_ctime":1584923593,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"66009433033","product_id":100039001,"comment_content":"if else 不是必须要解决的问题，如果放在工厂类中，逻辑比较简单，未来的变动也不会很大，就是 OK 的。","like_count":15},{"had_liked":false,"id":237763,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1595945816,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"44545618776","product_id":100039001,"comment_content":"原来策略模式的精髓就是：用Map代替冗长的if-else&#47;switch分支判断！<br>哇！","like_count":10,"discussions":[{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91302,"discussion_content":"不要太在意代码的写法, 里面有很多写错的😂, 主要看思路吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576825394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202193,"user_name":"东征","can_delete":false,"product_type":"c1","uid":1234314,"ip_address":"","ucode":"DC557A1631A493","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/8a/7050236a.jpg","comment_is_top":false,"comment_ctime":1585920204,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40240625868","product_id":100039001,"comment_content":"仍然使用查表法，表中存类型和class，根据类型获取对象时，使用class动态创建。或者表中存类型和一个创建函数，根据类型获取对象时，获取到创建函数，调用创建函数创建新对象（java里可以用lambda或者对象代替函数）","like_count":10,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476973,"discussion_content":"你可以看下其他同学的答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599016701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201364,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1585756254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27355560030","product_id":100039001,"comment_content":"课堂讨论<br>字典里保存好创建新对象的闭包代码块即可，或者说是回调函数，这样就可以创建出新的对象了，我们项目就是用的这个方法","like_count":7},{"had_liked":false,"id":190683,"user_name":"Geek_3231cf","can_delete":false,"product_type":"c1","uid":1697945,"ip_address":"","ucode":"922CB5478DB3EF","user_header":"","comment_is_top":false,"comment_ctime":1584681878,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27354485654","product_id":100039001,"comment_content":"可以在策略接口中，再抽象出来一个bool switch(T condition)方法，将判断移至具体策略实现类<br>工厂中getDiscountStrategy()方法中拿到所有策略类，根据condition找到符合的策略<br>伪代码：<br>DiscountStrategy getDiscountStrategy(T condition)<br>{ <br>allStartegys.foreach(<br>if(switch(condition) <br>return thisStartegy;<br>))}<br>使用起来就是DiscountStrategyFactory.getDiscountStrategy(condition).discount(order);","like_count":6,"discussions":[{"author":{"id":1198046,"avatar":"https://static001.geekbang.org/account/avatar/00/12/47/de/7b923db2.jpg","nickname":"曦","note":"","ucode":"AFB48B6C606EB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406532,"discussion_content":"同感分不清","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634786091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190672,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1584680120,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"27354483896","product_id":100039001,"comment_content":"1.业务代码少用反射。这个场景和原型模式的应用场景很贴合。依旧是type查表，只是每次使用的都是type对应策略实例的copy对象。详细请参照spring原型模式的实现。<br><br>2.往往业务场景里面，往往不是选择策略这一场景，而是编排策略这一场景。即利用type查表拿出一堆要用到的策略，并按顺序去执行。对于这种场景，栏主怎么看？","like_count":6,"discussions":[{"author":{"id":1907446,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/1a/f6/5f31c067.jpg","nickname":"Kirito U2","note":"","ucode":"D69F02FDBCC41B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399063,"discussion_content":"编排策略就是DAG了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632898925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309126,"discussion_content":"我觉得哈，每个策略里就要写自己 什么情况下，执行自己，而不仅仅只写方法\ntype也变为一个封装类，List<Strategy>, forEach() 执行，让每个策略类自己判断是否需要被执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601193341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309316,"discussion_content":"这是根据你对复杂性隔离的认知以及如何保证系统有序的理解来做决定的。有些业务适合放在内部，遵循高内聚。有些适合外部统一调度，隔离复杂性，分离关注点，比如saas。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601256838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309126,"ip_address":""},"score":309316,"extra":""}]},{"author":{"id":1021847,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/97/97/b4c95726.jpg","nickname":"犀利小柯南💤","note":"","ucode":"7C3B603B49B695","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217294,"discussion_content":"感觉更像是组合模式？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585539466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1021847,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/97/97/b4c95726.jpg","nickname":"犀利小柯南💤","note":"","ucode":"7C3B603B49B695","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309127,"discussion_content":"组合模式多适用于树形结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601193358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":217294,"ip_address":""},"score":309127,"extra":""}]}]},{"had_liked":false,"id":262947,"user_name":"Geek_78eadb","can_delete":false,"product_type":"c1","uid":1712955,"ip_address":"","ucode":"843C6C380D28FA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/OYQh8KlUgMx0sZ35felqqRlboXkcOFib0qGgRHuvFCNIMzxRzxN8SjZpwtDuS0PGV0L0Pneiak7yzcd043f2efbg/132","comment_is_top":false,"comment_ctime":1605915277,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23080751757","product_id":100039001,"comment_content":"如果我说，这个例子就是工厂模式，并且可以放到工厂方法的那一章，该怎么反驳我？<br>1. 为什么算法类的实例化就不是对象（工厂解决的是创建对象的问题，算法类难道不是对象吗）？<br>2. 工厂模式为什么不能用查表法解决，如果可以，为什么不能说工厂模式与策略模式一样（不要说关注角度不一样，我粗俗认为对象和类可以包含任何情况，比如算法类）？","like_count":5,"discussions":[{"author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536082,"discussion_content":"我也有这个疑问，不过工厂应该侧重于创建，策略侧重于算法，我看别的策略文章一般都有带一个上下文的类，比如Cache就是一个Context，Context中组合了策略类，Cache包含了外部属性（如数据），可以通过Cache来设置策略类（如LRU、LFU），并通过Cache提供的方法来使用策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638679205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2161628,"avatar":"https://static001.geekbang.org/account/avatar/00/20/fb/dc/82a49ce7.jpg","nickname":"ChingeWang","note":"","ucode":"48F96666220853","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":547032,"discussion_content":"如果使用Cache提供的接口来调用方法，那Cache不就是策略的调用方(客户端)啦？如果说还需要这个Cache来设置具体策略的话，那这个Cache同时也担任了工厂的角色啦？这个是不是职责耦合了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642500615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536082,"ip_address":""},"score":547032,"extra":""}]}]},{"had_liked":false,"id":210938,"user_name":"卖火柴的托儿索","can_delete":false,"product_type":"c1","uid":1451295,"ip_address":"","ucode":"A9C7412E75DA82","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/1f/8e304ec0.jpg","comment_is_top":false,"comment_ctime":1587867571,"is_pvip":false,"replies":[{"id":"78762","content":"完全两个东西 一个是模式 一个是技术 一个侧重应用场景 一个侧重代码实现","user_name":"作者回复","comment_id":210938,"uid":"1190123","ip_address":"","utype":1,"ctime":1588042478,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"23062704051","product_id":100039001,"comment_content":"这个策略和多态有什么区别？感觉用法差不多","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493151,"discussion_content":"完全两个东西 一个是模式 一个是技术 一个侧重应用场景 一个侧重代码实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588042478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2875547,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e0/9b/21f6f607.jpg","nickname":"L","note":"","ucode":"46E1848E786751","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542816,"discussion_content":"策略模式里面用到了多态","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640853238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192630,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1584864571,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18764733755","product_id":100039001,"comment_content":"我觉得结合下Spring中的应用场景讲下，毕竟大家都是依赖Spring开发的","like_count":4},{"had_liked":false,"id":190423,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1584658892,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18764528076","product_id":100039001,"comment_content":"就像老师说的，替换麻烦的ifelse本质上靠的是查表法，也就是if 里的条件成立绑定对应的方法地址，所以其实感觉和策略模式本身没有半毛钱关系，只不过在策略模式这个上下文下，每个条件分支是可扩展的策略实现而不是差别很大的功能代码。","like_count":4},{"had_liked":false,"id":208443,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1004462,"ip_address":"","ucode":"8F7DE6E7B3D74F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/ae/a08024b2.jpg","comment_is_top":false,"comment_ctime":1587359385,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14472261273","product_id":100039001,"comment_content":"想到的一个「策略模式」使用场景是: 根据数据查看权限进行列表筛选。<br>比如，数据表中有三类数据:<br> - 分类 A<br> - 分类 B<br> - 分类 C<br>针对这三类数据，是提供给不同角色的人员查看:<br> - 角色 1<br> - 角色 2<br> - 角色 3<br>通过策略对数据进行筛选，分别是: <br> - 「角色 1」对应 「分类 A」数据<br> - 「角色 2」对应 「分类 B」数据<br> - 「角色 3」对应 「分类 C」数据<br>不知道这种方式是否是符合「策略模式」的使用场景。是否还有更好的方式来解耦人员和数据的关系呢？","like_count":3},{"had_liked":false,"id":203991,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1586315985,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14471217873","product_id":100039001,"comment_content":"实际上，今天举的例子不用访问者模式也可以搞定，你能够想到其他实现思路吗？<br>可以使用策略模式.<br>定义读取策略接口ExtractorStrategy并实现三个策略,再定义一个策略工厂类,以文件类型作为key,以对应策略实现作为value,使用时通过具体的ResourceFile类型获取对应的策略实现类型,然后再调用实现函数.","like_count":3,"discussions":[{"author":{"id":1477359,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8a/ef/ac2937ac.jpg","nickname":"Geek_342489","note":"","ucode":"40610664021607","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72273,"discussion_content":"我理解是为了接口和实现隔离吧，如果改天鉴权需要用别的方法实现，不是token，只需要新增一个 xxxApiAuthencatorImpl 类即可，我们项目中一般会有一个鉴权队列，不同的业务方鉴权方法不同，只要有一个通过即可正确访问接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575472959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1477359,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8a/ef/ac2937ac.jpg","nickname":"Geek_342489","note":"","ucode":"40610664021607","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72532,"discussion_content":"大概有点明白了！感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575502614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":72273,"ip_address":""},"score":72532,"extra":""}]}]},{"had_liked":false,"id":198250,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1585438722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14470340610","product_id":100039001,"comment_content":"课后问题回答：<br>在springboot框架下很容易实现。<br>private final List&lt;DiscountStrategy&gt; strategyList;<br><br>spring 的特性会自动将所有的DiscountStrategy实现类注入到strategyList，<br>然后strategyList.stream().filter(DiscountStrategy::match).findFirst().map(ApplicatonContext::getBean).orElseThrow(()-&gt;new Exception(&quot;找不到合适的策略&quot;));<br>将每一个DiscountStrategy的实现类的scope注解设置为原型模式。<br><br>不过这样两个缺点：<br>1.每一个策略类都会先创建一个对象，作用仅仅是为了可以调用match方法。<br>2.像这种每一个都需要一个新的bean场景，一般这种策略也依赖当时的场景参数，但是当时的场景参数却无法通过构造函数传达，只能作为方法的参数<br>","like_count":3},{"had_liked":false,"id":190680,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1584681198,"is_pvip":false,"discussion_count":3,"race_medal":1,"score":"14469583086","product_id":100039001,"comment_content":"我们的项目就使用了这种动态的策略模式，减少 if-else","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476849,"discussion_content":"先了解整体结构，再了解细节，思路是对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190493,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1584664551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14469566439","product_id":100039001,"comment_content":"用查表法缓存clasa","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476810,"discussion_content":"后面讲到代码的可测试性的时候会讲到TDD的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575898058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316514,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634367238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10224301830","product_id":100039001,"comment_content":"思考：<br>工厂模式和策略模式等区别， 学到这里大概理解了一些争哥之前谈到的，模式都是为了应对某些场景，今天这个就很典型，如果只看代码，觉得和简单工厂很像，但是从问题入手，从场景谈起，两者解决的就完全是不同的问题，一个是解决对象创建相关，一个是不同策略不同行为。从这个层面两者又是不同。最近学了设计模式，所以有个毛病就是看一些源码，总是想往某个模式套，心里总是想这里是不是用到了某个模式，但常常又是一脸懵逼，其实是搞错了顺序，应该是看代码这样写时为了解决什么问题，是问题定义了模式，具体到模式名称，其实都不重要了，甚至你完全为了解决某个问题，创造一个新的模式（当然有可能应用场景不多罢了），所以还是见的少，后边继续加强实战，忘记模式，代码合一的境界，那就差不多了","like_count":2},{"had_liked":false,"id":305397,"user_name":"Geek_1f0e17","can_delete":false,"product_type":"c1","uid":1975877,"ip_address":"","ucode":"C7309788798807","user_header":"","comment_is_top":false,"comment_ctime":1627959553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10217894145","product_id":100039001,"comment_content":"还是用查表法，工厂方法模式就行，value存工厂，第44讲已经提过了","like_count":2},{"had_liked":false,"id":281165,"user_name":"建锋","can_delete":false,"product_type":"c1","uid":1616445,"ip_address":"","ucode":"DF4AAE135B152B","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/3d/c14e338e.jpg","comment_is_top":false,"comment_ctime":1614603440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5909570736","product_id":100039001,"comment_content":"spring环境下，可以通过  @Autowire  Map&lt;String, Strategy&gt; map；实现工厂的功能。其中Key为Bean名称，value为具体的对应策略类<br>","like_count":1},{"had_liked":false,"id":201786,"user_name":"kingcall","can_delete":false,"product_type":"c1","uid":1056982,"ip_address":"","ucode":"508884DC684B5B","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/d6/b9513db0.jpg","comment_is_top":false,"comment_ctime":1585837088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880804384","product_id":100039001,"comment_content":"工厂模式和策略模式有类似的流程，就是对象的创建，但是使用场景是不同的，策略模式的场景是行为切换，而工厂模式是对象创建；或者说是策略模式中使用到了工厂模式","like_count":1},{"had_liked":false,"id":192728,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1584869937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879837233","product_id":100039001,"comment_content":"一、定义（理解）：<br>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。<br><br>二、使用场景：<br>需要根据情况使用不同的算法类。<br><br>三、实现方式：<br>1、策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。<br>2、策略的创建由工厂类来完成，封装策略创建的细节。<br>3、策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。<br><br>四、工厂模式和策略模式的区别<br>工厂模式<br>1.目的是创建不同且相关的对象<br>2.侧重于&quot;创建对象&quot;<br>3.实现方式上可以通过父类或者接口<br><br>策略模式<br>1.目的实现方便地替换不同的算法类<br>2.侧重于算法(行为)实现<br>3.实现主要通过接口","like_count":1},{"had_liked":false,"id":191266,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1584759830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879727126","product_id":100039001,"comment_content":"打卡 今日学习策略模式，收获如下：<br>策略模式，理解有多种策略可供使用，怎么使用。文章中提到三部分：策略的定义，策略的创建，策略的使用。定义：需要定义策略接口和一组实现类，使用基于接口而非实现编程可灵活替换不同的类，各个实现类可独立变化。创建： 创建策略类时，为了封装创建细节，<br>使用简单工厂方法。根据策略类状态特性（可变类与不可变类）来判断是使用可缓存的，还是每次都返回新的。使用：基于两种方式：运行时动态确定和编译时静态确定，前者使用灵活，外界可灵活介入，后者硬编码，存在一定维护成本。<br>课堂讨论中的问题可通过工厂方法即将不同的折扣策略计算对象的创建在拆分出来形成一个个小工厂，在小工厂里创建折扣策略对象，然后再使用简单工厂模式里面的第二种方式缓存这些小工厂，使用的时候根据类型返回小工厂，进而通过小工厂拿到相应的折扣策略对象。","like_count":1},{"had_liked":false,"id":190620,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1584673306,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5879640602","product_id":100039001,"comment_content":"课堂讨论: 使用反射+静态工厂方式实现.<br>public class ReflectFactory {<br>    private static final String TAG = &quot;ReflectFactory&quot;;<br><br>    private ReflectFactory(){<br>        throw new IllegalStateException(&quot;&quot;);<br>    }<br><br>    public static DiscountStrategy getStrategy(Class&lt;?&gt; clazz){<br><br>        try {<br>            Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();<br>            constructor.setAccessible(true);<br>            return (DiscountStrategy) constructor.newInstance();<br>        } catch (NoSuchMethodException e) {<br>            e.printStackTrace();<br>        } catch (IllegalAccessException e) {<br>            e.printStackTrace();<br>        } catch (InstantiationException e) {<br>            e.printStackTrace();<br>        } catch (InvocationTargetException e) {<br>            e.printStackTrace();<br>        }<br><br>        throw new IllegalArgumentException(&quot; class type error! &quot;);<br>    }<br><br>}<br><br>public class Test {<br>    public static void main(String[] args) {<br>        double value = ReflectFactory.getStrategy(NormalStrategy.class).cal();<br>        System.out.println(&quot; discount: &quot; + value);<br>    }<br>}","like_count":1},{"had_liked":false,"id":190608,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1584672306,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5879639602","product_id":100039001,"comment_content":"课后思考：<br>在工厂类中做如下操作<br>1. 将策略类对应的类名和对应的Order类型保存在map中，对应的key是order类型，value是类名<br>2. 根据输入的order类型获取类名，然后用反射生成实际的类对象，<br>示意代码如下：<br>public class DiscountStrategyFactory {<br>    private static final map&lt;OrderType, String&gt; typeClassPair = new HashMap&lt;&gt;();<br><br>    static {<br>        typeClassPair.put(OrderType.NORMAL, &quot;NormalDiscountStrategy&quot;);<br>        typeClassPair.put(OrderType.GROUPON,&quot;GrouponDiscountStrategy&quot;);<br>        typeClassPair.put(OrderType.PROMOTION, &quot;PromotionDiscountStrategy&quot;)<br>    }<br><br>    public static DiscountStrategy getDiscountStrategy(OrderType type) {<br>        if (type == null) {<br>            throw new IllegalArgumentException(&quot;Type should not be null.&quot;);<br>        }<br><br>        String className = typeClassPair.get(type);<br>        return (DiscountStrategy)Class.forName(className).NewInstance(); <br>    }<br>}","like_count":1},{"had_liked":false,"id":190471,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1584663097,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"5879630393","product_id":100039001,"comment_content":"王老师，若是决定具体策略类的条件不是一个简单的type，而是多个条件决定一个具体的策略，如何处理？比如A和B有四种组合的这种","like_count":1,"discussions":[{"author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71766,"discussion_content":"提到了，就是类图中的create方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575456565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252977,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","nickname":"成楠Peter","note":"","ucode":"4D13E7368D8CF2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71476,"discussion_content":"这个应该是服务端生成的token，可以根据函数名推测出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575424106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360322,"user_name":"许勇","can_delete":false,"product_type":"c1","uid":1527200,"ip_address":"北京","ucode":"20A6EA5A539DC3","user_header":"https://static001.geekbang.org/account/avatar/00/17/4d/a0/e547b7a1.jpg","comment_is_top":false,"comment_ctime":1666428264,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666428264","product_id":100039001,"comment_content":"可以在工厂类中的map缓存各个策略的工厂，这样可根据type选择策略工厂，再用工厂创建对应的策略。","like_count":0},{"had_liked":false,"id":357506,"user_name":"英雄","can_delete":false,"product_type":"c1","uid":1546612,"ip_address":"四川","ucode":"D1033C83C6CDE9","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/74/0203bf17.jpg","comment_is_top":false,"comment_ctime":1663320086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663320086","product_id":100039001,"comment_content":"我觉得策略模式和模板方法一模一样啊","like_count":0},{"had_liked":false,"id":356000,"user_name":"Geek_6d23e0","can_delete":false,"product_type":"c1","uid":3162611,"ip_address":"广东","ucode":"470BC2D398754B","user_header":"","comment_is_top":false,"comment_ctime":1661912171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661912171","product_id":100039001,"comment_content":"给每个策略类 定义一个静态的 getInstance 方法","like_count":0},{"had_liked":false,"id":354945,"user_name":"英雄","can_delete":false,"product_type":"c1","uid":1546612,"ip_address":"四川","ucode":"D1033C83C6CDE9","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/74/0203bf17.jpg","comment_is_top":false,"comment_ctime":1660899811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660899811","product_id":100039001,"comment_content":"怎么感觉策略模式和模版方法一样啊","like_count":0},{"had_liked":false,"id":352056,"user_name":"遇见阳光","can_delete":false,"product_type":"c1","uid":1203576,"ip_address":"","ucode":"378E5D37B3CD0E","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/78/f011d586.jpg","comment_is_top":false,"comment_ctime":1658368670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658368670","product_id":100039001,"comment_content":"策略模式更多的是体现一种关注点分离的思想, 如对于a类的请求我们交给处理器a来进行,对于b类的请求交给b处理器; 这也侧面体现了解耦的思想,使得业务逻辑尽可能的保持单一职责; 仔细想想各种设计模式不外乎是让我们的整个流程变得更加清晰,不同的职责交给不同的业务类处理,避免耦合.","like_count":0},{"had_liked":false,"id":351527,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1657867688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657867688","product_id":100039001,"comment_content":"课堂讨论<br>1. Java<br>(1)可以反射创建<br>(2)加一层构造器接口, 不同的接口实例调用 New() 返回不同的策略, hashmap 储存构造器接口的实现, 创建的时候拿到构造器实例, 调用构造器 New() 方法<br>2. Golang可以函数指针","like_count":0},{"had_liked":false,"id":348648,"user_name":"东方拓睿","can_delete":false,"product_type":"c1","uid":1605058,"ip_address":"","ucode":"1FD25D75CAC7C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","comment_is_top":false,"comment_ctime":1655279156,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655279156","product_id":100039001,"comment_content":"怎么感觉查表法也是if-else判断的一种，事情是一样做，但是if-else还更直观一点，别人来看代码还要先理解你的策略类，而且随着策略的增多，策略类也增多？","like_count":0},{"had_liked":false,"id":347631,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1654241151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654241151","product_id":100039001,"comment_content":"用哈希表将类型和对应的策略类保存起来就可以了，在类创建的时候初始化这部分映射即可。","like_count":0},{"had_liked":false,"id":338201,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1647351688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647351688","product_id":100039001,"comment_content":"对于问题 我觉得根据场景来说吧，如果策略不多，if else 或者 switch 都是可以接受的，话说策略模式真的是我平时用的最多的了……今天还用来着，才知道是策略模式😅","like_count":0},{"had_liked":false,"id":338165,"user_name":"清凉","can_delete":false,"product_type":"c1","uid":1343565,"ip_address":"","ucode":"15E52B44C857CC","user_header":"https://static001.geekbang.org/account/avatar/00/14/80/4d/058e6b6d.jpg","comment_is_top":false,"comment_ctime":1647332994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647332994","product_id":100039001,"comment_content":"缓存 type以及对应创建对象的class","like_count":0},{"had_liked":false,"id":324846,"user_name":"迈向架构师","can_delete":false,"product_type":"c1","uid":1637228,"ip_address":"","ucode":"2476594CF76001","user_header":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","comment_is_top":false,"comment_ctime":1638679475,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638679475","product_id":100039001,"comment_content":"有的评论说比较像工厂类，我也有这个疑问，示例中的代码看起来好，<br><br>不过按照我的理解，工厂应该侧重于创建，策略侧重于算法<br><br><br>我看别的策略模式文章一般都有带一个上下文的类，比如Cache就是一个Context，Context中组合了策略类，Cache包含了外部属性（如数据），可以通过Cache来设置策略类（如LRU、LFU），并通过Cache提供的方法来使用策略。让你能够在**同一个上下文**类中切换算法。<br><br>","like_count":0},{"had_liked":false,"id":324373,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1638407905,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638407905","product_id":100039001,"comment_content":"hashMap 加　Bean 的ｃｏｐｙ？","like_count":0},{"had_liked":false,"id":316513,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634366729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634366729","product_id":100039001,"comment_content":"思考：<br>1.JDBC驱动的创建方式给了我启发，Class.forName(c.getName()).newInstance()  每次用工厂类创建，传入对应策略的Class对象具体代码如下：<br>public static &lt;T extends IDiscountStrategy&gt; T createStrategy(Class&lt;T&gt; c) {<br>        try {<br>            return (T) Class.forName(c.getName()).newInstance();<br>        } catch (InstantiationException e) {<br>            e.printStackTrace();<br>        } catch (IllegalAccessException e) {<br>            e.printStackTrace();<br>        } catch (ClassNotFoundException e) {<br>            e.printStackTrace();<br>        }<br>        return null;<br>    }","like_count":0},{"had_liked":false,"id":312036,"user_name":"加肥猫","can_delete":false,"product_type":"c1","uid":1043098,"ip_address":"","ucode":"C31B7CF54296A5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/9a/c324a7de.jpg","comment_is_top":false,"comment_ctime":1631600001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631600001","product_id":100039001,"comment_content":"这策略模式感觉和简单工厂差不多啊","like_count":0},{"had_liked":false,"id":308264,"user_name":"马建华","can_delete":false,"product_type":"c1","uid":1185974,"ip_address":"","ucode":"928189590259AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","comment_is_top":false,"comment_ctime":1629498696,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629498696","product_id":100039001,"comment_content":"没明白这里的不同指的是不同在什么地方？为何不能用字典存储不同策略类？","like_count":0,"discussions":[{"author":{"id":1185974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","nickname":"马建华","note":"","ucode":"928189590259AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389910,"discussion_content":"【如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方式了。】","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629498841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305710,"user_name":"连星科技","can_delete":false,"product_type":"c1","uid":2642229,"ip_address":"","ucode":"C84FF7FF4AAE56","user_header":"https://static001.geekbang.org/account/avatar/00/28/51/35/d3a1144b.jpg","comment_is_top":false,"comment_ctime":1628128825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628128825","product_id":100039001,"comment_content":"设计模式单独使用毫无意义，策略模式可以结合观察者模式、工厂模式使用。","like_count":0},{"had_liked":false,"id":303097,"user_name":"麦抠","can_delete":false,"product_type":"c1","uid":1227107,"ip_address":"","ucode":"875DEA26F38BAB","user_header":"https://static001.geekbang.org/account/avatar/00/12/b9/63/a3b11794.jpg","comment_is_top":false,"comment_ctime":1626587849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626587849","product_id":100039001,"comment_content":"正所谓，代码的复杂性从来不会消失，只能被转移","like_count":0},{"had_liked":false,"id":301906,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1625970300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625970300","product_id":100039001,"comment_content":"用反射","like_count":0},{"had_liked":false,"id":299897,"user_name":"Aibo","can_delete":false,"product_type":"c1","uid":2115387,"ip_address":"","ucode":"2CE3E77BD2D014","user_header":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","comment_is_top":false,"comment_ctime":1624896134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624896134","product_id":100039001,"comment_content":"函数式编程也可以，如map[string] = func(){ newxxx()}","like_count":0},{"had_liked":false,"id":298959,"user_name":"Amon Tin","can_delete":false,"product_type":"c1","uid":2618193,"ip_address":"","ucode":"25391BEEB6A719","user_header":"https://static001.geekbang.org/account/avatar/00/27/f3/51/c8eb2d0c.jpg","comment_is_top":false,"comment_ctime":1624408978,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1624408978","product_id":100039001,"comment_content":"除了用反射，也可以考虑为每个策略再加一种工厂类，策略工厂的map里不再直接保存策略对象，而是保存具体策略的工厂，get时先从map中取出对应策略工厂类，再用对应策略工厂创建具体的策略对象返回","like_count":0},{"had_liked":false,"id":298505,"user_name":"qlmmys","can_delete":false,"product_type":"c1","uid":1558222,"ip_address":"","ucode":"B9C6B37FF80F06","user_header":"https://static001.geekbang.org/account/avatar/00/17/c6/ce/c1376d80.jpg","comment_is_top":false,"comment_ctime":1624160765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624160765","product_id":100039001,"comment_content":"仍使用查表法获取实例，然后使用圆形模式，调用实例的clone方法","like_count":0},{"had_liked":false,"id":290885,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1619834007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619834007","product_id":100039001,"comment_content":"那就只能维护Class表，通过key获取后new Instance反射创建对象了","like_count":0},{"had_liked":false,"id":288119,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","comment_is_top":false,"comment_ctime":1618309044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618309044","product_id":100039001,"comment_content":"想了一下可以把手头项的一个不同保存但节点类似的多个接口统一改为策略类型","like_count":0},{"had_liked":false,"id":286697,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1617507989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617507989","product_id":100039001,"comment_content":"工厂模式和策略模式的区别：<br>工厂模式侧重于对象的创建。<br>而策略模式侧重于策略过程：将策略的定义、创建、使用进行解耦。而其中策略的创建往往会使用到工厂模式。","like_count":0},{"had_liked":false,"id":286148,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1617169633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617169633","product_id":100039001,"comment_content":"简单的就存class 表，复杂创建就存具体策略的工厂，可以用 IOC 来解决","like_count":0},{"had_liked":false,"id":283534,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","comment_is_top":false,"comment_ctime":1615810900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615810900","product_id":100039001,"comment_content":"将if else隐藏<br>将接口呈现<br>比如我的业务，<br>根据不同的枚举值<br>调用不同的service进行select into<br>接口可以将service作为通用的<br>调用不同的Mapper进行SQL执行","like_count":0},{"had_liked":false,"id":283518,"user_name":"Geek_8593e5","can_delete":false,"product_type":"c1","uid":1736807,"ip_address":"","ucode":"B316E40C400CC8","user_header":"","comment_is_top":false,"comment_ctime":1615804158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615804158","product_id":100039001,"comment_content":"用反射或者注入解决","like_count":0},{"had_liked":false,"id":282145,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1615107084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615107084","product_id":100039001,"comment_content":"策略模式，就是依赖倒置原则","like_count":0},{"had_liked":false,"id":271272,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1609505336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609505336","product_id":100039001,"comment_content":"策略模式的主要意图如文中所说的，就是**解耦**策略的实现逻辑与主业务逻辑。从这个角度说，策略模式与模板方法模式（包括回调）类似：策略模式传入的是策略类型标志（后续将会被映射为具体的函数方法），而模板方法模式或者传入的是具体类型（后续会被映射为具体的函数方法），或者（回调情况下）干脆传入的就是函数方法。当然两者的意图仍有明显差异：模板方法模式下的扩展方法往往只有一种情况，因为只需要实现一种来扩展即可，而策略模式下的策略方法往往有多种情况，因为需要根据情况选择一种。简言之，模板方法模式的重点是做扩展实现，而策略模式的重点是做决策选择。<br>另外减少if&#47;else并不是主要意图，只是一种附加效果。","like_count":0},{"had_liked":false,"id":270522,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1609149827,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609149827","product_id":100039001,"comment_content":"改造工厂去掉if else<br>1. 使用原型模式+工厂模式 每次clone一个对象出来<br>2. Factory存储class对象 通过反射创建","like_count":0},{"had_liked":false,"id":268582,"user_name":"Geek_3e636e","can_delete":false,"product_type":"c1","uid":1679267,"ip_address":"","ucode":"ADF9E346F87A63","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL8D6wvhCszzJeTsMS3F9yAib2icialw2gibFgDibvehKzeujSxn2GACMPqGhdQOHqmZS791148gibAVBLA/132","comment_is_top":false,"comment_ctime":1608263060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608263060","product_id":100039001,"comment_content":"工厂加原型模式（克隆）","like_count":0},{"had_liked":false,"id":255966,"user_name":"flyCoder","can_delete":false,"product_type":"c1","uid":1074897,"ip_address":"","ucode":"82FB7B60775978","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/d1/8664c464.jpg","comment_is_top":false,"comment_ctime":1603468512,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603468512","product_id":100039001,"comment_content":"结合抽象工厂模式去实现。","like_count":0},{"had_liked":false,"id":254004,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1603011980,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603011980","product_id":100039001,"comment_content":"if-else逻辑无论如何避免，都需要有一个地方存储对应关系的，只是和业务代码的耦合度和可扩展度的大小的区别吧","like_count":0},{"had_liked":false,"id":253111,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1602601512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602601512","product_id":100039001,"comment_content":"查表法 +  反射自动创建类","like_count":0},{"had_liked":false,"id":251452,"user_name":"Geek_bbbef1","can_delete":false,"product_type":"c1","uid":1662380,"ip_address":"","ucode":"83604A63565FF9","user_header":"https://static001.geekbang.org/account/avatar/00/19/5d/ac/00ba8f70.jpg","comment_is_top":false,"comment_ctime":1601567679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601567679","product_id":100039001,"comment_content":"这个讲的比在网上搜到的免费的要好的多，他们千篇一律的就是给一个类图说 context 包含 startegy 对象，我看了就很疑惑context类是干嘛的，策略模式是如何减少 if 语句使用的。<br>在这我明白了，如果每次都使用相同的策略对象，那么可以用map查表替代if。如果每次使用不同的对象，那么还是需要if语句，只是将if语句写在了工厂类里面，减少了策略定义、创建和使用的耦合，不过通过反射应该也可以代替这里的if语句。","like_count":0},{"had_liked":false,"id":251319,"user_name":"好名字","can_delete":false,"product_type":"c1","uid":1951501,"ip_address":"","ucode":"E2BFD96F912A67","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c7/0d/0dab398b.jpg","comment_is_top":false,"comment_ctime":1601459802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601459802","product_id":100039001,"comment_content":"策略模式包括策略定义，策略创建，策略使用。如果策略是无状态的，策略创建可以使用map保存所有策略的实例，如果策略是有状态的，策略创建就需要用到工厂模式去创建。所以工厂模式是一个直勾拳，策略模式就是一个组合拳而且其中一个动作是直勾拳且是可选的。","like_count":0},{"had_liked":false,"id":251295,"user_name":"查理","can_delete":false,"product_type":"c1","uid":1111297,"ip_address":"","ucode":"A9FEA901E3A05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/01/5389295c.jpg","comment_is_top":false,"comment_ctime":1601452466,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601452466","product_id":100039001,"comment_content":"课后讨论：用反射创建对象","like_count":0},{"had_liked":false,"id":248966,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1600392699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600392699","product_id":100039001,"comment_content":"注解+反射的方式。动态创建","like_count":0},{"had_liked":false,"id":247742,"user_name":"杨陆伟","can_delete":false,"product_type":"c1","uid":1108457,"ip_address":"","ucode":"3BC968447406EB","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/e9/1f95e422.jpg","comment_is_top":false,"comment_ctime":1599813867,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599813867","product_id":100039001,"comment_content":"课后问题：通过反射可以解决","like_count":0},{"had_liked":false,"id":244899,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1598732599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598732599","product_id":100039001,"comment_content":"这时候就要用到工厂的工厂了：<br>Map 里面存的不是实例，而是这个实例对应的工厂，将对应的工厂取出来后，调用工厂的 create() 方法创建一个实例，这样返回的就是不同的实例了。","like_count":0},{"had_liked":false,"id":242553,"user_name":"希川","can_delete":false,"product_type":"c1","uid":1144227,"ip_address":"","ucode":"AEE921C330A2DE","user_header":"https://static001.geekbang.org/account/avatar/00/11/75/a3/ed29ef71.jpg","comment_is_top":false,"comment_ctime":1597759088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597759088","product_id":100039001,"comment_content":"请教一下老师，对于策略模式，针对不同的业务类型抽象出的CURD接口，不同的业务类型实现不同的CURD逻辑，但是，接口隔离原则应当如何保障呢？<br>比如说，我有的业务类型不想实现update和delete的方法<br>谢谢老师~","like_count":0},{"had_liked":false,"id":239586,"user_name":"一木一米","can_delete":false,"product_type":"c1","uid":1471725,"ip_address":"","ucode":"CAE39B2836E137","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/ed/02771d6d.jpg","comment_is_top":false,"comment_ctime":1596592136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596592136","product_id":100039001,"comment_content":"1.可以用类前缀方式，用反射加载实例：例如AtypeStrategy、BtypeStrategy，使用时出入 Atype 或 Btype，分别对应 AtypeStrategy 和 BtypeStrategy <br>2.用map 做映射，key 是 Atype、Btype，对应的是AtypeStrategy、BtypeStrategy 的类，反射加载创建对象。","like_count":0},{"had_liked":false,"id":239191,"user_name":"Geek_jackli","can_delete":false,"product_type":"c1","uid":2052007,"ip_address":"","ucode":"DD6B91E486DE40","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLajLoBBBPgMCl5eibqWpzUSKtJRtNGaYzkKeNTCFY1IeicjpXSxDmEjf0z1JzjtzUR3maJXQzebSWA/132","comment_is_top":false,"comment_ctime":1596455949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596455949","product_id":100039001,"comment_content":"有点类似C语言的函数指针数组，索引即是类型","like_count":0},{"had_liked":false,"id":238105,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1596071707,"is_pvip":false,"replies":[{"id":"88016","content":"要是自己new的，spring容器是不管理的，也就是你在其他地方无法自动注入","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1596108523,"ip_address":"","comment_id":238105,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1596071707","product_id":100039001,"comment_content":"请问各位一个问题：如果在spring应用中，Map策略表中的对象应该是new创建的，还是用autowired注入？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502645,"discussion_content":"要是自己new的，spring容器是不管理的，也就是你在其他地方无法自动注入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596108523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521181,"avatar":"https://static001.geekbang.org/account/avatar/00/17/36/1d/874dc1e3.jpg","nickname":"你的笑忘书","note":"","ucode":"9665D5E9EDBEA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576689,"discussion_content":"其实是可以不用自己手动 new 的。再写一个类，然后通过构造的方式注入 Map。需要注意的是，我说的这个 Map 和上面的 Map 写法是不同的，构造方法中，是你的每一个策略实现类的 Bean。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655734549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144227,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/a3/ed29ef71.jpg","nickname":"希川","note":"","ucode":"AEE921C330A2DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299647,"discussion_content":"应该是可以使用 ContextLoader.getCurrentWebApplicationContext().getBean() 这个方法从上下文中拿到，然后放进Map策略表中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597758679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237744,"user_name":"Geek3340","can_delete":false,"product_type":"c1","uid":2028953,"ip_address":"","ucode":"C64D302CD53513","user_header":"","comment_is_top":false,"comment_ctime":1595940392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595940392","product_id":100039001,"comment_content":"我一般是在启动的时候，获取interface下所有的实现类，缓冲在map中，key为可以处理的策略类型，value为实现类对象","like_count":0},{"had_liked":false,"id":235517,"user_name":"lengrongfu","can_delete":false,"product_type":"c1","uid":1494681,"ip_address":"","ucode":"FD6F35CA561E0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/99/447c33d4.jpg","comment_is_top":false,"comment_ctime":1595071734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595071734","product_id":100039001,"comment_content":"问题的一些思考：<br>如果是spring项目的话会比较简单，对于注入对象是指点对象的生命周期为prototype类型即可。","like_count":0},{"had_liked":false,"id":233036,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1594199293,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1594199293","product_id":100039001,"comment_content":"通过配置文件配置映射关系加载到内存","like_count":0},{"had_liked":false,"id":213931,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1588591857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588591857","product_id":100039001,"comment_content":"今天我们讲到，在策略工厂类中，如果每次都要返回新的策略对象，我们还是需要在工厂类中编写 if-else 分支判断逻辑，那这个问题该如何解决呢？<br>那就将依赖工厂改为依赖接口，维护一个上下文对象，通过传入特定的算法对象处理业务","like_count":0},{"had_liked":false,"id":213806,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1588566039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588566039","product_id":100039001,"comment_content":"用好反射。","like_count":0},{"had_liked":false,"id":206574,"user_name":"ttxser","can_delete":false,"product_type":"c1","uid":1022694,"ip_address":"","ucode":"47C3FCB59F8027","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/e6/e8439f9a.jpg","comment_is_top":false,"comment_ctime":1586886834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586886834","product_id":100039001,"comment_content":"工厂模式里的 if-else 没有必要考虑如何去掉，已经上层封装了；<br>查表，或者也可以考虑 type 使用枚举，实现 abstract getInstance() 方法","like_count":0},{"had_liked":false,"id":203615,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1586241599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586241599","product_id":100039001,"comment_content":"关于思考题 还是可以用map缓存类型和创建过程之间的映射关系啊","like_count":0},{"had_liked":false,"id":201482,"user_name":"星期八","can_delete":false,"product_type":"c1","uid":1185504,"ip_address":"","ucode":"34A37F73A48E7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/e0/7abad3cc.jpg","comment_is_top":false,"comment_ctime":1585794513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585794513","product_id":100039001,"comment_content":"每次创建的新的实例，还是查表法，表里可以放（类型，class）获取时根据类型找class，反射创建实例","like_count":0},{"had_liked":false,"id":199714,"user_name":"酱油党","can_delete":false,"product_type":"c1","uid":1262907,"ip_address":"","ucode":"B342FD4878DEAD","user_header":"https://static001.geekbang.org/account/avatar/00/13/45/3b/c938ff45.jpg","comment_is_top":false,"comment_ctime":1585494468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585494468","product_id":100039001,"comment_content":"既然策略模式可以搞定，创建工厂再策略一次就可以了，有点绕","like_count":0},{"had_liked":false,"id":199125,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1585479485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585479485","product_id":100039001,"comment_content":"设计模式_61:<br><br># 作业<br>1. 用过，就是为了解决if-else的问题，记得当时是刚看完*HeadFirst 设计模式*的策略模式，可能有点过度设计了，毕竟拿着锤子看什么都像钉子。。。<br><br>2. 什么时候有必要去掉if-else&#47;switch-case，可以从信息量的角度来理解，如果这个信息有重复(好多地方都硬编码地使用if-else来表示映射表信息)，这个时候就有必要去掉if-else&#47;switch-case了。如果整个项目只有当前方法保存了这个映射表，而且变化可能不大，也可以保留。<br><br># 感想<br>策略模式其实是对某一可变行为的抽象。","like_count":0},{"had_liked":false,"id":199014,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1585475934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585475934","product_id":100039001,"comment_content":"设计模式_60:<br># 作业<br>如果是Java，可以在表中存储type与class的映射关系。<br><br># 感想<br>今天的内容有一个感受，我们为什么想要避免if-else&#47;switch？<br><br>从信息量的角度分析一下：<br>一个业务函数中如果涉及多个if-else&#47;switch，那么该函数包含了两个信息：<br>(1)业务的运行逻辑<br>(2)每一个 type 与 implement 的映射关系<br><br>这一点已经违反了单一职责原则，业务函数最好只包含业务逻辑。另外，type 与 implement 的映射关系这个信息(查表法的&quot;表&quot;)通常不会只在这里出现，如果多个地方出现又会导致更新遗漏的问题，所以避免if-else&#47;switch除了可以让代码看起来舒服，也可以减少不必要的信息量(所谓解耦)，让代码易读且可扩展。","like_count":0},{"had_liked":false,"id":198561,"user_name":"弹簧人","can_delete":false,"product_type":"c1","uid":1697679,"ip_address":"","ucode":"BCB4A6FC76EA17","user_header":"https://static001.geekbang.org/account/avatar/00/19/e7/8f/56387f77.jpg","comment_is_top":false,"comment_ctime":1585456687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585456687","product_id":100039001,"comment_content":"这种情况还比较常见。比如某一个业务场景有多种情况，有时候就会if&#47;else多个。每种情况包一个方法。这样看起来简洁，但是有时候会出现很多类似的代码逻辑，并且整个service类会很长。 <br><br>使用策略方法的话，可以申明成不同的策略类，然后调用。减少代码量。但是如果，分情况的代码范围不长，分成多个类又过于臃肿了。 个人感觉视情况而定。","like_count":0},{"had_liked":false,"id":198366,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1585448106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585448106","product_id":100039001,"comment_content":"将每个策略类的创建放到单独的工厂里，Map的value保存的是工厂，而不是对象。这样使用同一个对象还是不同的对象，只需要修改工厂。","like_count":0},{"had_liked":false,"id":198248,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1585438162,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585438162","product_id":100039001,"comment_content":"感觉从代码层面来看，工厂模式和策略模式没有什么区别，只是人在解释的时候或者人的着眼点在对象or 一种行为能力的问题。真正到实际开发时，估计不好区分使用的是策略模式还是工厂模式。如果按照从业务需求角度来说，可能是策略模式吧。<br><br>另外我难道是学习偏了，没有人觉得策略模式和前面讲的装饰器模式有点像吗？不同策略的一个是自己定义的统一接口，一个需要转换包装一下不同的第三方为统一接口。然后根据场景的不同做不同的选择<br><br><br>","like_count":0,"discussions":[{"author":{"id":2095026,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f7/b2/b9d2d7d8.jpg","nickname":"","note":"","ucode":"79DB151C0BFC63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300383,"discussion_content":"装饰器是对原有功能的业务增强","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598071894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197670,"user_name":"悠游","can_delete":false,"product_type":"c1","uid":1222834,"ip_address":"","ucode":"4FDDDDF29AE3F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/b2/998448ca.jpg","comment_is_top":false,"comment_ctime":1585390778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585390778","product_id":100039001,"comment_content":"老师，我在实际开发中遇到一个问题，就是每一个策略的type有很多，或者说满足一定规则的type使用一个策略，这种除了为每个type创建一个Entry，还有没有更好的办法呢","like_count":0},{"had_liked":false,"id":197667,"user_name":"悠游","can_delete":false,"product_type":"c1","uid":1222834,"ip_address":"","ucode":"4FDDDDF29AE3F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/b2/998448ca.jpg","comment_is_top":false,"comment_ctime":1585390636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585390636","product_id":100039001,"comment_content":"还是用Map 来缓存策略，只不过缓存的是类对象而不是类实例，根据type拿到类对象，再根据反射创建类对象实例","like_count":0},{"had_liked":false,"id":197004,"user_name":"石头","can_delete":false,"product_type":"c1","uid":1342281,"ip_address":"","ucode":"25A0957D5E4DFF","user_header":"https://static001.geekbang.org/account/avatar/00/14/7b/49/e5f99a67.jpg","comment_is_top":false,"comment_ctime":1585331673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585331673","product_id":100039001,"comment_content":"简单却很实用的模式","like_count":0},{"had_liked":false,"id":196264,"user_name":"mghio","can_delete":false,"product_type":"c1","uid":1213078,"ip_address":"","ucode":"74883EDE4FD0DC","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","comment_is_top":false,"comment_ctime":1585268159,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585268159","product_id":100039001,"comment_content":"项目最近重构也使用策略模式的动态绑定方式，去除了大部分冗长的 if else 代码","like_count":0},{"had_liked":false,"id":195626,"user_name":"嘻哈","can_delete":false,"product_type":"c1","uid":1402535,"ip_address":"","ucode":"AEE1512822A399","user_header":"https://static001.geekbang.org/account/avatar/00/15/66/a7/5b7a7523.jpg","comment_is_top":false,"comment_ctime":1585206717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585206717","product_id":100039001,"comment_content":"工厂的工厂可以解决","like_count":0},{"had_liked":false,"id":194060,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1585020007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585020007","product_id":100039001,"comment_content":"思考题，“工厂的工厂”，对每个策略类都建立相应的工厂类，根据type查表得到工厂类，通过工厂类来创建新的策略对象。","like_count":0},{"had_liked":false,"id":193979,"user_name":"Bern","can_delete":false,"product_type":"c1","uid":1765806,"ip_address":"","ucode":"5A979552D5800D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlxr0eX6ZPlpiaUkH8SXoNibmOK9MJz2ZDYq5y57UfFHBu6dDc5VxKic1rAPiawLBVdSMl8y1Mwtp9Yg/132","comment_is_top":false,"comment_ctime":1585010182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585010182","product_id":100039001,"comment_content":"可以使用枚举","like_count":0},{"had_liked":false,"id":193936,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1584997882,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1584997882","product_id":100039001,"comment_content":"对于课后思考题，可以使用反射实现。对于各个策略类，可以是用表记录。<br>也在思考一个问题，对于争哥举的购物的例子，如果现实情况并非单一策略，而是不同策略的组合呢？例如我既满足满减同时也能使用优惠券呢？这种情况简单的解决方法就是再定一个新策略。至于策略组合爆炸的问题，显然不是所有策略的组合现实中都是合理的。","like_count":0,"discussions":[{"author":{"id":1217230,"avatar":"https://static001.geekbang.org/account/avatar/00/12/92/ce/9d24cb2c.jpg","nickname":"小学一年级","note":"","ucode":"59B9805D7C2D92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307565,"discussion_content":"我怎么感觉商城的满减跟优惠劵用装饰者模式更适用？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600687743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193661,"user_name":"葛强强","can_delete":false,"product_type":"c1","uid":1711759,"ip_address":"","ucode":"E9E8B4047AAC63","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/8f/e0cddb8f.jpg","comment_is_top":false,"comment_ctime":1584945344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584945344","product_id":100039001,"comment_content":"使用动态工厂模式，即通过反射创建。","like_count":0},{"had_liked":false,"id":193259,"user_name":"hetiu","can_delete":false,"product_type":"c1","uid":1056127,"ip_address":"","ucode":"35D9338C3ABD20","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/7f/aabc1b66.jpg","comment_is_top":false,"comment_ctime":1584887441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584887441","product_id":100039001,"comment_content":"课后题: 用工厂的工厂可以解决。不过，查表的方式，不见得就比switch&#47;case优雅多少！","like_count":0},{"had_liked":false,"id":193143,"user_name":"徐同学呀","can_delete":false,"product_type":"c1","uid":1252813,"ip_address":"","ucode":"03383EE820514D","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","comment_is_top":false,"comment_ctime":1584884717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584884717","product_id":100039001,"comment_content":"查表法，value值存class，用反射创建。<br>策略类也可以继承一个抽象类吧，不一定是接口。策略类的一些公共处理可以放在抽象类里","like_count":0},{"had_liked":false,"id":192902,"user_name":"Aze","can_delete":false,"product_type":"c1","uid":1053926,"ip_address":"","ucode":"F2F5E10E2432DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/e6/ab69e495.jpg","comment_is_top":false,"comment_ctime":1584877998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584877998","product_id":100039001,"comment_content":"可用Spring的applicationContext.getBeansOfType(Interface.class);","like_count":0},{"had_liked":false,"id":192743,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1584870453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584870453","product_id":100039001,"comment_content":"策略模式可以有效的解决 if else  过多的问题,  用 map 存放 具体的策略, 运行时生成对应的策略","like_count":0},{"had_liked":false,"id":192024,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1584814255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584814255","product_id":100039001,"comment_content":"学习查表法","like_count":0},{"had_liked":false,"id":191709,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1584791517,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584791517","product_id":100039001,"comment_content":"讲解清晰简洁，期待下一节","like_count":0,"discussions":[{"author":{"id":1514957,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1d/cd/22dc6dd5.jpg","nickname":"Ᏸlack|Ꮚhite࿐","note":"","ucode":"9C9CE2F55FC25F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309301,"discussion_content":"哈哈哈 刷到你了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601255599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191486,"user_name":"howdyli","can_delete":false,"product_type":"c1","uid":1190718,"ip_address":"","ucode":"DD949639D29F5E","user_header":"https://static001.geekbang.org/account/avatar/00/12/2b/3e/7ef8f24c.jpg","comment_is_top":false,"comment_ctime":1584777244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584777244","product_id":100039001,"comment_content":"老师结合spring和应用场景讲解一下，这样更适用。","like_count":0},{"had_liked":false,"id":191282,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1584760744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584760744","product_id":100039001,"comment_content":"策略：侧重不同算法实现，通过接口实现，方便动态替换不同的算法实现","like_count":0},{"had_liked":false,"id":191215,"user_name":"孙自友","can_delete":false,"product_type":"c1","uid":1516101,"ip_address":"","ucode":"5FAAF8670509AE","user_header":"https://static001.geekbang.org/account/avatar/00/17/22/45/9a4d2479.jpg","comment_is_top":false,"comment_ctime":1584755258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584755258","product_id":100039001,"comment_content":"用type枚举类有创建策略类方法","like_count":0},{"had_liked":false,"id":191187,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1584753113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584753113","product_id":100039001,"comment_content":"这个设计模式场景，刚好可以在目前着手的项目试一下～打卡","like_count":0},{"had_liked":false,"id":191062,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1584721124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584721124","product_id":100039001,"comment_content":"每次都要返回新的策略对象时，工厂类中避免写 if-else 的解决方法想到两个：<br><br>1. 用个 hash 表做 type 到类的映射。工厂函数传入 type 作为哈希表的 key，返回对应的策略类，然后创建对象即可。（不清楚 Java 中类能不能作为值进行传递。如果不可以的话，可以利用建造者模式模式做 type 到具体策略建造类的映射，这种方案要多写几个建造类）<br>2. 将缓存的策略对象进行克隆。","like_count":0},{"had_liked":false,"id":191043,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1584719574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584719574","product_id":100039001,"comment_content":"使用工厂方法工厂模式么？","like_count":0},{"had_liked":false,"id":190984,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1584715793,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584715793","product_id":100039001,"comment_content":"期待下一节！！！","like_count":0},{"had_liked":false,"id":190968,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1584714524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584714524","product_id":100039001,"comment_content":"可以通过注解来觉得取哪个策略。工厂类里面通过注解的类来动态生成。","like_count":0},{"had_liked":false,"id":190870,"user_name":"梦寻解语花","can_delete":false,"product_type":"c1","uid":1389130,"ip_address":"","ucode":"BA68D9D888E8C9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo3UZZWiaVrpgFYp31KH8e8lBXLsbV8r4bia0sd5UlEZQYKoFz5hdPEshm0XsuiajH86DJiaEdu7eDhLg/132","comment_is_top":false,"comment_ctime":1584702427,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584702427","product_id":100039001,"comment_content":"策略类过多膨胀的问题，有什么解决办法吗","like_count":0},{"had_liked":false,"id":190860,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1584700276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584700276","product_id":100039001,"comment_content":"这个简单,Map中维护对应的class,使用反射创建,甚至可以指定init的方法,去给设备注入组装对象","like_count":0},{"had_liked":false,"id":190778,"user_name":"大头","can_delete":false,"product_type":"c1","uid":1315367,"ip_address":"","ucode":"C1FB2C8A0FB0C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/27/32746bbf.jpg","comment_is_top":false,"comment_ctime":1584691677,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584691677","product_id":100039001,"comment_content":"工厂模式和策略模式通常是组合使用的，既然用到了工厂模式，返回的必然是继承或实现同一父类的实例，也就是其中的一个策略。但是从不同的角度来看，工厂模式侧重于创建，策略模式侧重于实现。","like_count":0},{"had_liked":false,"id":190691,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1584683495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584683495","product_id":100039001,"comment_content":"通过工厂缓存class，再通过动态代理实例化","like_count":0},{"had_liked":false,"id":190615,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1584672802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584672802","product_id":100039001,"comment_content":"为何感觉很多模式看起来都是一样的套路","like_count":0},{"had_liked":false,"id":190559,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1584668724,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1584668724","product_id":100039001,"comment_content":"没看太明白策略模式和工厂模式有啥区别😂","like_count":0,"discussions":[{"author":{"id":1077406,"avatar":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","nickname":"jaryoung","note":"","ucode":"6E72D107DB7E51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209757,"discussion_content":"得益于工厂模式，将封装好不同算法的放到工厂里面，让客户端调用更加简单而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584669733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261674,"avatar":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","nickname":"小兵","note":"","ucode":"AA3BA727C25179","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210791,"discussion_content":"策略模式可以看成是工厂模式的一个子集，要从面向问题的角度去看设计模式，各种设计模式的本质都是遵从设计原则与思想的，看起来类似是正常的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584774237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1735740,"avatar":"","nickname":"Geek_bb8d16","note":"","ucode":"964BD4DB3D9653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1261674,"avatar":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","nickname":"小兵","note":"","ucode":"AA3BA727C25179","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217394,"discussion_content":"反了，工厂模式是为了创建一些类似的对象，策略模式是用这些对象和查表法去简化调用逻辑，并使定义，实现和使用这些行为分离，从而达到消除ifelse的目的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585554359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":210791,"ip_address":""},"score":217394,"extra":""}]}]},{"had_liked":false,"id":190553,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1584668431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584668431","product_id":100039001,"comment_content":"策略模式平时用的太多了，而且确实随着策略越来越多，if else还是避免不了的，我觉得这个是可以接受的，因为我平时就是这么干的，。","like_count":0},{"had_liked":false,"id":190490,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1584664485,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584664485","product_id":100039001,"comment_content":"怎么感觉就是工厂模式呢？策略模式和工厂模式有什么不同吗？我感觉平时用工厂模式的时候就是这样的……","like_count":0,"discussions":[{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209766,"discussion_content":"具体策略就是工厂模式的产品. ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584670776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190483,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1584663839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584663839","product_id":100039001,"comment_content":"通过输入不同参数用反射的方式来创建新对象","like_count":0},{"had_liked":false,"id":190431,"user_name":"木头","can_delete":false,"product_type":"c1","uid":1099319,"ip_address":"","ucode":"32EACA5DCA857D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/37/8d22be0a.jpg","comment_is_top":false,"comment_ctime":1584660515,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1584660515","product_id":100039001,"comment_content":"怎么看都是工厂模式！<br>","like_count":0,"discussions":[{"author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237906,"discussion_content":"相关的“在一起”，叫内聚，不相关的“在一起”，叫耦合。","likes_number":71,"is_delete":false,"is_hidden":false,"ctime":1587196204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2833619,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","nickname":"探雪","note":"","ucode":"2332650D9C8D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":531550,"discussion_content":"牛逼的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637333244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":237906,"ip_address":""},"score":531550,"extra":"{\"user_type\":1}"}]},{"author":{"id":2628119,"avatar":"https://static001.geekbang.org/account/avatar/00/28/1a/17/9e925f61.jpg","nickname":"雾都","note":"","ucode":"198CDE0F864C77","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381143,"discussion_content":"相关的都放在一起叫高内聚，不放在一起叫低内聚；不相关的放在一起叫高耦合，不相关的不放在一起叫低耦合","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1624929874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1158109,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ab/dd/31942fb9.jpg","nickname":"Canon.Din","note":"","ucode":"2C5448AAF7CF46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2628119,"avatar":"https://static001.geekbang.org/account/avatar/00/28/1a/17/9e925f61.jpg","nickname":"雾都","note":"","ucode":"198CDE0F864C77","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":381236,"discussion_content":"哈哈不绕口, 竟然看到同一天刷这一章的伙伴","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624963143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381143,"ip_address":""},"score":381236,"extra":""},{"author":{"id":2516041,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/1UV7tTtMTM8hyvGl2YaSVczZve3e2aOcrRafvg64WQo7hYRRzGnondFElhGv0RnQZQgn6PycYzal2b5oAwYXtg/132","nickname":"太行山人","note":"","ucode":"66EB8BFD311A45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2628119,"avatar":"https://static001.geekbang.org/account/avatar/00/28/1a/17/9e925f61.jpg","nickname":"雾都","note":"","ucode":"198CDE0F864C77","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":542232,"discussion_content":"对，和我想的一样，同类的在一起叫内聚，不同类的在一起就是耦合了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640687089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381143,"ip_address":""},"score":542232,"extra":""}]},{"author":{"id":1042753,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/p6kkT7nsViayxazIrxx7p0pklPRvet933nEGBupj1phL2zArLStC3MnHFFyBYZ9fDGbPWJxS6WOICkxCCLia7nhw/132","nickname":"Qfxl","note":"","ucode":"4554F28BB10F21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109195,"discussion_content":"想法不错，个人观点补充下耦合描述模块间的关系，内聚则是单一模块","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1577673508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066102,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/76/a86cfd2a.jpg","nickname":"Akira","note":"","ucode":"A0BFD54A95012D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394501,"discussion_content":"分析的很有道理。把序列化反序列化拆开，突然对高内聚和低耦合有加深了点理解。\n拆的越单一不代表越内聚。把相关的功能放一起叫高内聚。把不相关的拆开叫低耦合","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631925874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2708697,"avatar":"","nickname":"李海龙","note":"","ucode":"766E49D0AE1434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574585,"discussion_content":"功能相关的放在一起，是内聚，不相关的放在一起，是耦合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654161115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048314,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/fa/2a046821.jpg","nickname":"人间四月天","note":"","ucode":"11BE219C23EEBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569114,"discussion_content":"一切还是看需求，看功能，看需求变化的原因，单一职责是需求变化的原因只有一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651328057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2882086,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/fa/26/a38f4b5d.jpg","nickname":"jl","note":"","ucode":"3EC1591B396600","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544764,"discussion_content":"你这写的太好了，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641701809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2833619,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","nickname":"探雪","note":"","ucode":"2332650D9C8D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531549,"discussion_content":"自古评论出人才~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637333226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294870,"discussion_content":"很明显你是从内聚要求的“高”和耦合要求的“低”的角度来分析的，还是相当片面的 duck不必","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596020555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294975,"discussion_content":"很明显你说错了，你大可不必这么自信。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1596041389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294870,"ip_address":""},"score":294975,"extra":""}]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294574,"discussion_content":"这个角度刁钻不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595930104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1785231,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3d/8f/b06ec41f.jpg","nickname":"frankieci","note":"","ucode":"0020F03AED7483","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291503,"discussion_content":"说实话，王争讲的不怎么样，讲的都是一些废话，我推荐看goF设计模式书，设计原则是诊断问题的所在用设计模式去解决，体现设计流程，不是把代码一下子粘出来，光说说就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594858894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785231,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3d/8f/b06ec41f.jpg","nickname":"frankieci","note":"","ucode":"0020F03AED7483","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291885,"discussion_content":"说实话，我可不这么认为。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1594986104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291503,"ip_address":""},"score":291885,"extra":""},{"author":{"id":2273754,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/da/5602cb4b.jpg","nickname":"king","note":"","ucode":"1E5BD0E2A789C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785231,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3d/8f/b06ec41f.jpg","nickname":"frankieci","note":"","ucode":"0020F03AED7483","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319100,"discussion_content":"说实话，我可不认为你明白了王争的意思，而你的需求可能是不一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603942508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291503,"ip_address":""},"score":319100,"extra":""},{"author":{"id":1622696,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","nickname":"一格状语","note":"","ucode":"EBA9ED5F97416D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785231,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3d/8f/b06ec41f.jpg","nickname":"frankieci","note":"","ucode":"0020F03AED7483","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339641,"discussion_content":"你给我们讲讲？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609750519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291503,"ip_address":""},"score":339641,"extra":""}]},{"author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80834,"discussion_content":"耦合不单单是功能无关吧\n比如说文中的例子UserInfo还没拆分时，当你只需要地址信息的时候，你都需要使用UserInfo来获取，每个使用地址的地方都是有UserInfo，这算不算是紧耦合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576199099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80950,"discussion_content":"耦合要单单是功能无关，王争老师也就不用说这么多了。我也没说什么“单单是”或类似的意思。\n\n我说的是耦合是：\n\n1，从功能无关的方向来谈“合在一块儿”这个意思；\n\n2，把功能“明显无关”的内容“随意地”结合起来，就会增加耦合性，“明显无关”和“随意地”当然都是基于特定的应用场景、需求背景、业务层面而言的，不然是否明显无关和随意就无法确定。\n\n最后，友善地提醒一句，你的中文阅读理解能力需要加强。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576206453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80834,"ip_address":""},"score":80950,"extra":""},{"author":{"id":1083559,"avatar":"https://static001.geekbang.org/account/avatar/00/10/88/a7/fb383ef7.jpg","nickname":"MaLu","note":"","ucode":"A5E900B6B94FB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227549,"discussion_content":"还是公司业务发展决定的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586500216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80834,"ip_address":""},"score":227549,"extra":""},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269222,"discussion_content":"大可不必","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589880946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80950,"ip_address":""},"score":269222,"extra":""}]}]}]}