{"id":740830,"title":"第 22 章 不安全代码(2)","content":"<h2 id=\"nav_point_448\">22.6　未定义行为</h2>\n<p>如本章开头所述，术语<strong>未定义行为</strong>的意思是“Rust 坚定地认为你的代码永远不会出现的行为”。这是一个奇怪的措辞，特别是因为我们从使用其他语言的经验中就能知道这些行为<strong>确实</strong>会以某种频率偶然发生。为什么这个概念对厘清不安全代码的责任有帮助？</p>\n<p>编译器是从一种编程语言到另一种编程语言的翻译器。Rust 编译器是将 Rust 程序翻译成等效的机器语言的程序。但是，说“两个使用完全不同语言的程序是等效的”意味着什么呢？</p>\n<p>幸运的是，这个问题对程序员来说比对语言学家更容易理解。我们通常说两个程序是等效的，意思是它们在执行时总是具有相同的可见行为，比如会进行相同的系统调用，以等效的方式与外部库交互，等等。这有点儿像程序界的图灵测试：如果不能分辨自己是在与原文交互还是与译文交互，那它们就是等效的。</p>\n<p>现在考虑以下代码：</p>\n<pre class=\"code-rows\"><code>let i = 10;\nvery_trustworthy(&amp;i);\nprintln!(\"{}\", i * 100);</code></pre>\n<p>即使对 <code>very_trustworthy</code> 的定义一无所知，也可以看到它仅接收对 <code>i</code> 的共享引用，因此该调用肯定无法更改 <code>i</code> 的值。由于传给 <code>println!</code> 的值永远是 <code>1000</code>，因此 Rust 可以将这段代码翻译成机器语言，就像我们写过的一样：</p>\n<pre class=\"code-rows\"><code>very_trustworthy(&amp;10);\nprintln!(\"{}\", 1000);</code></pre>\n<p>这个转换后的版本与原始版本具有相同的可见行为，而且速度可能更快一点儿。但只有在保证它与原始版本具有相同含义的前提下，才值得去考虑此版本的性能。如果 <code>very_trustworthy</code> 的定义是下面这样的该怎么办？</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code>fn very_trustworthy(shared: &amp;i32) {\n    unsafe {\n        // 把共享引用转换成可变指针\n        // 这是一种未定义行为\n        let mutable = shared as *const i32 as *mut i32;\n        *mutable = 20;\n    }\n}</code></pre>\n<p>这段代码打破了共享引用的规则：它将 <code>i</code> 的值更改为 <code>20</code>，即使这个值应该被冻结（因为 <code>i</code> 是为了共享而借用的）。结果，我们对调用者所做的转换现在有了非常明显的效果：如果 <code>Rust</code> 转换这段代码，那么程序就会打印 <code>1000</code>；如果它保留代码并使用 <code>i</code> 的新值，则程序会打印 <code>2000</code>。在 <code>very_trustworthy</code> 中打破共享引用的规则意味着共享引用在其调用者中的行为可能不再符合预期了。</p>\n<p>这种问题几乎会出现在 Rust 可能尝试的每一种转换中，其中就包括：即使把一个函数内联到它的调用点，也仍然可以假设当被调用者完成时，控制流就会返回到调用点。然而我们在本章开头就给出过一个违反了该假设的问题代码示例。</p>\n<p>Rust（或任何其他语言）基本上不可能评估出对程序的转换是否保留了其含义，除非它可以相信语言的基本特性会按原本的设计运行。一段代码是否可信，不仅取决于手头的这部分代码，还取决于程序中隔得比较远的其他部分的代码。为了对代码做任何处理，Rust 必须假设你的程序的其余部分是“遵纪守法”的。</p>\n<p>下面是 Rust 判断程序是否“遵纪守法”的规则。</p>\n<ul>\n<li>程序不得读取未初始化的内存。</li>\n<li>程序不得创建无效的原始值。<ul>\n<li>引用、Box 值或 <code>fn</code> 指针为空（<code>null</code>）。</li>\n<li><code>bool</code> 值非 <code>0</code> 且非 <code>1</code>。</li>\n<li><code>enum</code> 值具有无效判别值。</li>\n<li><code>char</code> 值无效，比如存在半代用区的 Unicode 码点。</li>\n<li><code>str</code> 值不是格式良好的 UTF-8。</li>\n<li>胖指针具有无效虚表或 slice 长度。</li>\n<li><code>never</code> 类型的任何值，可以写作 <code>!</code>，只能用于不会返回的函数。</li>\n</ul>\n</li>\n<li>程序必须遵守第 5 章中解释过的引用规则。任何引用的生命周期都不能超出其引用目标，共享访问是只读访问，可变访问是独占访问。</li>\n<li>程序不得对空指针、未正确对齐的指针或悬空指针进行解引用。</li>\n<li>程序不得使用指针访问与此指针关联的分配区之外的内存。22.8.1 节会详细解释此规则。</li>\n<li>程序必须没有数据竞争。当两个线程在没有同步保护的情况下访问同一个内存位置，并且至少有一个访问是写入时，就会发生数据竞争。</li>\n<li>程序不得对借助外部函数接口进行的跨语言调用进行栈展开（参见 7.1.1 节）。</li>\n<li>程序必须遵守标准库函数的契约。</li>\n</ul>\n<p>由于还没有针对 <code>unsafe</code> 代码的 Rust 语义的完整模型，因此该列表可能会随着时间的推移而演变，但上述这些规则仍然有效。</p>\n<p>任何违反这些规则的行为都构成了未定义行为，并让 Rust 试图优化你的程序并将其翻译成机器语言的努力变得不可信。如果你违反最后一条规则并将格式错误的 UTF-8 传给 <code>String::from_utf8_unchecked</code>，那么没准儿 2097151 真会不等于 2097151。</p>\n<p>未使用不安全特性的 Rust 代码只要编译通过就可以保证会遵守前面的所有规则。（假设编译器自身没有 bug——我们正为之努力，但没有 bug 永远只能是个理想。）只有在使用不安全特性时，遵守这些规则才会成为你的责任。</p>\n<p>而在 C 和 C++ 中，你的程序“在编译期没有错误或警告”这件事意义不大。正如本书前面所提到的，即使那些一直坚持着高标准且备受推崇的项目所编写的最好的 C 程序和 C++ 程序，也会在实践中表现出未定义行为。</p>\n<h2 id=\"nav_point_449\">22.7　不安全特型</h2>\n<p><strong>不安全特型</strong>是一种特型，用于表示这里存在某种 Rust 无法检查也无法强制保障的契约。实现者必须满足它，以规避未定义行为。要实现不安全特型，就必须将实现标记为不安全的。你需要了解此特型的契约并确保自己的类型能满足它。</p>\n<p>类型变量以某个不安全特型为限界的函数通常是自身使用了不安全特型的函数，并且只能依靠此不安全特型的契约来满足那些不安全特型的契约。对此特型的不正确实现可能导致这样的函数出现未定义行为。</p>\n<p><code>std::marker::Send</code> 和 <code>std::marker::Sync</code> 是不安全特型的典型示例。这些特型没有定义任何方法，因此你可以用喜欢的任意类型来轻松实现它们。但它们确实有契约：<code>Send</code> 要求实现者能安全地转移给另一个线程，而 <code>Sync</code> 要求实现者能安全地通过共享引用在线程之间共享。如果为不合适的类型实现了 <code>Send</code>，就会使 <code>std::sync::Mutex</code> 在数据竞争中不再安全。</p>\n<p>举个简单的例子，Rust 标准库曾包含一个不安全特型 <code>core::nonzero::Zeroable</code>，该特型用于标记出可通过将所有字节设置为 0 来进行安全初始化的类型。显然，将 <code>usize</code> 变量归零肯定没问题，但将 <code>&amp;T</code> 归零就会带来一个空引用，如果解引用，则会导致崩溃。对于 <code>Zeroable</code> 的类型，可以进行一些优化：可以使用 <code>std::ptr::write_bytes</code>（<code>memset</code> 在 Rust 中的等价物）或者用能分配全零内存页的系统调用来快速初始化数组。（<code>Zeroable</code> 是不稳定的，在 Rust 1.26 的 <code>num</code> crate 中被转移到仅供内部使用，但它是一个优秀、简单且真实的例子。）</p>\n<p><code>Zeroable</code> 是一个典型的标记特型，缺少方法或关联类型：</p>\n<pre class=\"code-rows\"><code>pub unsafe trait Zeroable {}</code></pre>\n<p>它对适用类型的实现同样简单明了：</p>\n<pre class=\"code-rows\"><code>unsafe impl Zeroable for u8 {}\nunsafe impl Zeroable for i32 {}\nunsafe impl Zeroable for usize {}\n// 以及所有整数类型</code></pre>\n<p>有了这些定义，就可以编写一个函数来快速分配给定长度的包含 <code>Zeroable</code> 类型的向量了：</p>\n<pre class=\"code-rows\"><code>use core::nonzero::Zeroable;\n\nfn zeroed_vector&lt;T&gt;(len: usize) -&gt; Vec&lt;T&gt;\n    where T: Zeroable\n{\n    let mut vec = Vec::with_capacity(len);\n    unsafe {\n        std::ptr::write_bytes(vec.as_mut_ptr(), 0, len);\n        vec.set_len(len);\n    }\n    vec\n}</code></pre>\n<p>这个函数会首先创建一个具有所需容量的空 <code>Vec</code>，然后调用 <code>write_bytes</code> 以用 0 填充未占用的缓冲区。（<code>write_byte</code> 函数会将 <code>len</code> 视为 <code>T</code> 元素的数量，而不是字节数，因此该调用确实会填充整个缓冲区。）向量的 <code>set_len</code> 方法只会更改其长度而不会对缓冲区做任何事，这是不安全的，因为必须保证新的缓冲区空间确实包含已正确初始化的 <code>T</code> 类型值。不过这正是 <code>T: Zeroable</code> 类型限界所保证的：全零的字节块表示有效的 <code>T</code> 值。我们对 <code>set_len</code> 的使用是安全的。</p>\n<p>下面我们来使用这个函数：</p>\n<pre class=\"code-rows\"><code>let v: Vec&lt;usize&gt; = zeroed_vector(100_000);\nassert!(v.iter().all(|&amp;u| u == 0));</code></pre>\n<p>显然，<code>Zeroable</code> 一定是一个不安全特型，因为不遵守其契约的实现可能会导致未定义行为：</p>\n<pre class=\"code-rows\"><code>struct HoldsRef&lt;'a&gt;(&amp;'a mut i32);\n\nunsafe impl&lt;'a&gt; Zeroable for HoldsRef&lt;'a&gt; { }\n\nlet mut v: Vec&lt;HoldsRef&gt; = zeroed_vector(1);\n*v[0].0 = 1;   // 崩溃：对空指针解引用</code></pre>\n<p>Rust 不知道 <code>Zeroable</code> 意味着什么，所以无从判断它何时会被实现为不合适的类型。与其他任何不安全特性一样，如何理解并遵守不安全特型的契约由你来决定。</p>\n<p>请注意，不安全代码不得依赖于普通的、安全的特型在实现上的正确性。假设有一个 <code>std::hash::Hasher</code> 特型的实现，它只会返回一个随机哈希值，与被哈希的值无关。该特型要求对一些相同的位进行两次哈希后必须生成相同的哈希值，但此实现无法满足该要求，这根本就不正确。但因为 <code>Hasher</code> 并不是不安全特型，所以不安全代码在使用这个哈希器时不得表现出未定义行为。<span class=\"comment-number\">2</span>为了满足“可以使用不安全特性”这条契约，<code>std::collections::HashMap</code> 类型是经过精心编写的，但并未考虑哈希器自身行为出错的可能性。当然，这样一来该哈希表将无法正常运行：查找将失败，条目将随机出现和消失。但该哈希表并不存在未定义行为。</p>\n\n<h2 id=\"nav_point_450\">22.8　裸指针</h2>\n<p>裸指针在 Rust 中就是一种不受约束的指针。你可以使用裸指针来创建 Rust 的受检查指针类型不能创建的各种结构，比如双向链表或任意对象图。但是因为裸指针非常灵活，Rust 无法判断你是否在安全地使用它们，所以只能在 <code>unsafe</code> 块中对它们解引用。</p>\n<p>裸指针本质上等效于 C 指针或 C++ 指针，因此在与这些语言编写的代码进行交互时它们也很有用。</p>\n<p>裸指针有以下两种类型。</p>\n<ul>\n<li><code>*mut T</code> 是指向 <code>T</code> 的允许修改其引用目标的裸指针。</li>\n<li><code>*const T</code> 是指向 <code>T</code> 的只允许读取其引用目标的裸指针。</li>\n</ul>\n<p>（没有单纯的 <code>*T</code> 类型，必须始终指定 <code>const</code> 或 <code>mut</code>。）</p>\n<p>可以把引用转换成裸指针，并使用 <code>*</code> 运算符对其解引用：</p>\n<pre class=\"code-rows\"><code>let mut x = 10;\nlet ptr_x = &amp;mut x as *mut i32;\n\nlet y = Box::new(20);\nlet ptr_y = &amp;*y as *const i32;\n\nunsafe {\n    *ptr_x += *ptr_y;\n}\nassert_eq!(x, 30);</code></pre>\n<p>与 Box 和引用不同，裸指针可以为空，就像 C 中的 <code>NULL</code> 或 C++ 中的 <code>nullptr</code>：</p>\n<pre class=\"code-rows\"><code>fn option_to_raw&lt;T&gt;(opt: Option&lt;&amp;T&gt;) -&gt; *const T {\n    match opt {\n        None =&gt; std::ptr::null(),\n        Some(r) =&gt; r as *const T\n    }\n}\n\nassert!(!option_to_raw(Some(&amp;(\"pea\", \"pod\"))).is_null());\nassert_eq!(option_to_raw::&lt;i32&gt;(None), std::ptr::null());</code></pre>\n<p>这个例子中没有 <code>unsafe</code> 块：创建裸指针、传递裸指针和比较裸指针都是安全的。只有解引用裸指针是不安全的。</p>\n<p>指向无固定大小类型的裸指针是胖指针，就像相应的引用或 <code>Box</code> 类型一样。<code>*const [u8]</code> 指针包括一个长度和地址，而像 <code>*mut dyn std::io::Write</code> 指针这样的特型对象则会携带一个虚表。</p>\n<p>尽管 Rust 会在各种情况下隐式解引用安全指针类型，但对裸指针解引用必须是显式的。</p>\n<ul>\n<li><code>.</code> 运算符不会隐式解引用裸指针，必须写成 <code>(*raw).field</code> 或 <code>(*raw).method(...)</code>。</li>\n<li>裸指针没有实现 <code>Deref</code>，因此隐式解引用不适合它们。</li>\n<li><code>==</code>、<code>&lt;</code> 等运算符将裸指针作为地址进行比较：如果两个裸指针指向内存中的相同位置，那它们就相等。类似地，对裸指针进行哈希处理会针对其指向的地址值本身，而不会针对其引用目标的值。</li>\n<li>像 <code>std::fmt::Display</code> 这样的格式化特型会自动追踪引用，但根本不会处理裸指针。<code>std::fmt::Debug</code> 和 <code>std::fmt::Pointer</code> 是例外，它们会将裸指针展示为十六进制地址，而不会解引用它们。</li>\n</ul>\n<p>与 C 和 C++ 中的 <code>+</code> 运算符不同，Rust 的 <code>+</code> 不会处理裸指针，但可以通过它们的 <code>offset</code> 方法和 <code>wrapping_offset</code> 方法或更方便的 <code>add</code> 方法、<code>sub</code> 方法、<code>wrapping_add</code> 方法和 <code>wrapping_sub</code> 方法执行指针运算。反过来，<code>offset_from</code> 方法会以字节为单位求出两个指针之间的距离，不过需要确保开始和结束位于同一个内存区域，比如在同一个 <code>Vec</code> 中：</p>\n<pre class=\"code-rows\"><code>let trucks = vec![\"garbage truck\", \"dump truck\", \"moonstruck\"];\nlet first: *const &amp;str = &amp;trucks[0];\nlet last: *const &amp;str = &amp;trucks[2];\nassert_eq!(unsafe { last.offset_from(first) }, 2);\nassert_eq!(unsafe { first.offset_from(last) }, -2);</code></pre>\n<p><code>first</code> 和 <code>last</code> 不需要显式转换，只需指定类型即可。Rust 会将引用隐式转换成裸指针（当然，反过来肯定不成立）。</p>\n<p><code>as</code> 运算符允许从引用到裸指针或两个裸指针类型之间几乎所有的合理转换。但是，可能需要将复杂的转换分解为一系列更简单的步骤。例如：</p>\n<pre class=\"code-rows\"><code>&amp;vec![42_u8] as *const String;  // 错误：无效的转换\n&amp;vec![42_u8] as *const Vec&lt;u8&gt; as *const String;  // 这样可以转换</code></pre>\n<p>请注意，<code>as</code> 不会将裸指针转换为引用。这样的转换不安全，<code>as</code> 应该保持安全操作。因此，必须在 <code>unsafe</code> 块中对裸指针解引用，然后再借用其结果值。</p>\n<p>这样操作时要非常小心：以这种方式生成的引用具有不受约束的生命周期，它可以存续多长时间没有限制，因为裸指针没有给 Rust 提供任何能做出这种决定的依据。23.5 节会展示几个如何正确限制生命周期的示例。</p>\n<p>许多类型有 <code>as_ptr</code> 方法和 <code>as_mut_ptr</code> 方法，它们会返回指向其内容的裸指针。例如，数组切片和字符串会返回指向它们第一个元素的指针，而一些迭代器会返回指向它们将生成的下一个元素的指针。像 <code>Box</code>、<code>Rc</code> 和 <code>Arc</code> 这样的拥有型指针类型都有 <code>into_raw</code> 函数和 <code>from_raw</code> 函数，可以与裸指针相互转换，其中一些方法的契约强加了出人意料的要求，因此在使用之前务必检查一下它们的文档。</p>\n<p>还可以通过转换整数来构造裸指针，不过你唯一可以信任的整数通常就是从指针转换来的。22.8.2 节就以这种方式使用了裸指针。</p>\n<p>与引用不同，裸指针既不是 <code>Send</code> 的也不是 <code>Sync</code> 的。因此，在默认情况下，任何包含裸指针的类型都不会实现这些特型。在线程之间发送或共享裸指针本身其实并没有什么不安全的，毕竟，无论它们“走”到哪里，你都需要一个 <code>unsafe</code> 块来解引用它们。但是考虑到裸指针经常扮演的角色，语言设计者认为还是现在这种默认使用方式更好。22.7 节讨论过如何自己实现 <code>Send</code> 和 <code>Sync</code>。</p>\n<h3 id=\"nav_point_451\">22.8.1　安全地解引用裸指针</h3>\n<p>以下是安全使用裸指针的一些常识性指南。</p>\n<ul>\n<li>解引用空指针或悬空指针是未定义行为，引用未初始化的内存或超出作用域的值也一样。</li>\n<li>解引用未针对其引用目标的类型正确对齐的指针是未定义行为。</li>\n<li>只有在遵守了第 5 章解释过的引用安全规则（任何引用的生命周期都不能超出其引用目标，共享访问是只读访问，可变访问是独占访问）的前提下，才能从解引用的裸指针中借用值。（很容易意外违反这条规则，因为裸指针通常用于创建具有非标准共享或所有权的数据结构。）</li>\n<li>仅当引用目标是所属类型的格式良好的值时，才能使用裸指针的引用目标。例如，必须确保解引用 <code>*const char</code> 后会产生一个正确的、不在半代用区的 Unicode 码点。</li>\n<li><p>如果想在特定的裸指针上使用 <code>offset</code> 方法和 <code>wrapping_offset</code> 方法，那么该裸指针只能指向原初（original）指针所引用的变量内部的字节或分配在堆上的内存块内部的字节，或者指向上述两个区域之外的第一字节。</p>\n<p>如果通过将指针转换为整数，对整数进行运算，然后将其转换回指针的方式进行指针运算，则结果必须是 <code>offset</code> 方法的规则允许生成的指针。</p>\n<p>&nbsp;</p>\n</li>\n<li><p>如果要给裸指针的引用目标赋值，则不得违反引用目标所属的任何类型的不变条件。如果你有一个 <code>*mut u8</code> 指向 <code>String</code> 中的一字节，那么在该 <code>u8</code> 中存储的值必须能让 <code>String</code> 保持为格式良好的 UTF-8。</p>\n</li>\n</ul>\n<p>抛开借用规则不谈，上述规则与在 C 或 C++ 中使用指针时必须遵守的规则基本上是一样的。</p>\n<p>不得违反类型不变条件的原因应该很清楚。许多 Rust 标准库类型在其实现中使用了不安全代码，但仍然提供了安全接口，前提是 Rust 的安全检查、模块系统和可见性规则能得到遵守。使用裸指针来规避这些保护措施可能会导致未定义行为。</p>\n<p>裸指针的完整、准确的契约不容易表述，并且可能随着语言的发展而改变。但本节概要表述的这些原则应该让你处于安全地带。</p>\n<h3 id=\"nav_point_452\">22.8.2　示例：<code>RefWithFlag</code></h3>\n<p>下面这个例子说明了如何采用裸指针实现经典<span class=\"comment-number\">3</span>的位级 hack，并将其包装为完全安全的 Rust 类型。这个模块定义了一个类型 <code>RefWithFlag&lt;'a, T&gt;</code>，它同时包含一个 <code>&amp;'a T</code> 和一个 <code>bool</code>，就像元组 <code>(&amp;'a T, bool)</code> 一样，但仍然设法只占用了一个机器字而不是两个。这种技术在垃圾回收器和虚拟机中经常使用，其中某些类型（比如表示对象的类型）的数量多到就算只向每个值添加一个机器字都会大大增加内存占用：</p>\n\n<pre>\nmod ref_with_flag {\n    use std::marker::PhantomData;\n    use std::mem::align_of;\n\n    /// 包装在单个机器字中的`&amp;T`和`bool`\n    /// 类型`T`要求必须至少按两字节对齐\n    ///\n    /// 如果你是那种中规中矩的程序员，从未想过还能从某个指针中偷出\n    /// 第 2<sup>0</sup> 位（数据的最低位），那么现在可以安全地做到这一点了！\n    /// （“但这样做并不像想象中那么刺激啊……”）\n    pub struct RefWithFlag&lt;'a, T&gt; {\n        ptr_and_bit: usize,\n        behaves_like: PhantomData&lt;&amp;'a T&gt; // 不占空间\n    }\n\n    impl&lt;'a, T: 'a&gt; RefWithFlag&lt;'a, T&gt; {\n        pub fn new(ptr: &amp;'a T, flag: bool) -&gt; RefWithFlag&lt;T&gt; {\n            assert!(align_of::&lt;T&gt;() % 2 == 0);\n            RefWithFlag {\n                ptr_and_bit: ptr as *const T as usize | flag as usize,\n                behaves_like: PhantomData\n            }\n        }\n\n        pub fn get_ref(&amp;self) -&gt; &amp;'a T {\n            unsafe {\n                let ptr = (self.ptr_and_bit &amp; !1) as *const T;\n                &amp;*ptr\n            }\n        }\n\n        pub fn get_flag(&amp;self) -&gt; bool {\n            self.ptr_and_bit &amp; 1 != 0\n        }\n    }\n}\n</pre>\n\n<p>这段代码利用了这样一个事实，即许多类型在内存中必须放置在偶数地址：由于偶数地址的最低有效位始终为 0，因此可以在那里存储其他内容，然后通过屏蔽最低位来可靠地重建原始地址。并非所有类型都符合条件，比如类型 <code>u8</code> 和 <code>(bool, [i8; 2])</code> 可以放在任何地址。但是我们可以检查此类型在构造方面的对齐情况，并拒绝不适用的类型。</p>\n<p>可以像下面这样使用 <code>RefWithFlag</code>：</p>\n<pre class=\"code-rows\"><code>use ref_with_flag::RefWithFlag;\n\nlet vec = vec![10, 20, 30];\nlet flagged = RefWithFlag::new(&amp;vec, true);\nassert_eq!(flagged.get_ref()[1], 20);\nassert_eq!(flagged.get_flag(), true);</code></pre>\n<p>构造函数 <code>RefWithFlag::new</code> 会接受一个引用和一个 <code>bool</code> 值，并断言此引用具有适当的类型，然后把它转换为裸指针，再转换为 <code>usize</code> 类型。<code>usize</code> 类型大小的定义是足够在我们正在编译的任何处理器上保存一个指针，因此将裸指针转换为 <code>usize</code> 并返回它是有明确定义的。一旦有了 <code>usize</code>，我们就知道它必然是偶数，所以可以使用按位或运算符 <code>|</code> 将其与已转换为整数 0 或 1 的 <code>bool</code> 值组合起来。</p>\n<p><code>get_flag</code> 方法用于提取 <code>RefWithFlag</code> 的 <code>bool</code> 部分。这很简单：只要取出最低位并检查结果是否非零就可以了（<code>self.ptr_and_bit &amp; 1 != 0</code>）。</p>\n<p><code>get_ref</code> 方法用于从 <code>RefWithFlag</code> 中提取引用。首先，它会屏蔽 <code>usize</code> 的最低位（<code>self.ptr_and_bit &amp; !1</code>）并将其转换为裸指针。<code>as</code> 运算符无法将裸指针转换为引用，但我们可以解引用裸指针（当然是在 <code>unsafe</code> 块中）并借用它。借用一个裸指针的引用目标会得到一个无限生命周期的引用：Rust 会赋予引用任何生命周期来检查它周围的代码（如果有的话）。但是，通常还有一些更准确的特定生命周期，因此会发现更多错误。在这个例子中，由于 <code>get_ref</code> 的返回类型是 <code>&amp;'a T</code>，因此 Rust 认为该引用的生命周期与 <code>RefWithFlag</code> 的生命周期参数 <code>'a</code> 相同，这正是我们想要的，因为这个生命周期就是最初那个引用的生命周期。</p>\n<p>在内存中，<code>RefWithFlag</code> 看起来很像 <code>usize</code>：由于 <code>PhantomData</code>（意思是虚构的数据）是零大小的类型，因此 <code>behaves_like</code> 字段并不会占用结构体中的空间。但是，为了让 Rust 知道该如何处理使用 <code>RefWithFlag</code> 的代码中的生命周期，<code>PhantomData</code> 是必需的。想象一下没有 <code>behaves_like</code> 字段的类型会是什么样子：</p>\n<pre class=\"code-rows\"><code>// 这无法编译\npub struct RefWithFlag&lt;'a, T: 'a&gt; {\n    ptr_and_bit: usize\n}</code></pre>\n<p>如第 5 章所述，任何包含引用的结构体，其生命周期都不能超出它们借用的值，以免引用变成悬空指针。这个结构体必须遵守适用于其字段的限制。这当然也适用于 <code>RefWithFlag</code>：在刚刚看到的示例代码中，<code>flagged</code> 的生命周期不能超出 <code>vec</code>，因为 <code>flagged.get_ref()</code> 会返回对它的引用。但是我们简化版的 <code>RefWithFlag</code> 类型根本不包含任何引用，并且从不使用其生命周期参数 <code>'a</code>，因为这只是一个 <code>usize</code>。怎么让 Rust 知道应该如何限制 <code>flagged</code> 的生命周期呢？包含一个 <code>PhantomData&lt;&amp;'a T&gt;</code> 字段就是为了告诉 Rust 应该将 <code>RefWithFlag&lt;'a, T&gt;</code> <strong>视为</strong>包含一个 <code>&amp;'a T</code>，却不会实际影响此结构体的表示方式。</p>\n<p>尽管 Rust 并不真正知道发生了什么（这就是 <code>RefWithFlag</code> 不安全的原因），但它会尽力帮助你解决这个问题。如果省略了 <code>behaves_like</code> 字段，那么 Rust 就会报错说参数 <code>'a</code> 和 <code>T</code> 未使用，并建议使用 <code>PhantomData</code>。</p>\n<p><code>RefWithFlag</code> 使用了与之前介绍的 <code>Ascii</code> 类型相同的策略来避免其 <code>unsafe</code> 块中的未定义行为。类型本身是 <code>pub</code> 的，但其字段不是，这意味着只有 <code>ref_with_flag</code> 模块中的代码才能创建或查看 <code>RefWithFlag</code> 值。你不必检查太多代码就可以确信 <code>ptr_and_bit</code> 字段是构造良好的。</p>\n<h3 id=\"nav_point_453\">22.8.3　可空指针</h3>\n<p>Rust 中的空裸指针是一个零地址，与 C 和 C++ 中一样。对于任意类型 <code>T</code>，<code>std::ptr::null&lt;T&gt;</code> 函数会返回一个 <code>*const T</code> 空指针，而 <code>std::ptr::null_mut&lt;T&gt;</code> 会返回一个 <code>*mut T</code> 空指针。</p>\n<p>检查裸指针是否为空有几种方法。最简单的是 <code>is_null</code> 方法，但 <code>as_ref</code> 方法可能更方便。<code>as_ref</code> 方法会接受 <code>*const T</code> 指针并返回 <code>Option&lt;&amp;'a T&gt;</code>，以便将一个空指针变成 <code>None</code>。同样，<code>as_mut</code> 方法会将 <code>*mut T</code> 指针转换为 <code>Option&lt;&amp;'a mut T&gt;</code> 值。</p>\n<h3 id=\"nav_point_454\">22.8.4　类型大小与对齐方式</h3>\n<p>任何固定大小类型（<code>Sized</code>）的值都会在内存中占用固定数量的字节，并且必须放置在由机器体系结构决定的某个<strong>对齐</strong>值的倍数的地址处。例如，一个 <code>(i32, i32)</code> 元组占用 8 字节，而大多数处理器更喜欢将其放置在 4 的倍数地址处。</p>\n<p>调用 <code>std::mem::size_of::&lt;T&gt;()</code> 会返回类型 <code>T</code> 值的大小（以字节为单位），而调用 <code>std::mem::align_of::&lt;T&gt;()</code> 会返回其所需的对齐方式。例如：</p>\n<pre class=\"code-rows\"><code>assert_eq!(std::mem::size_of::&lt;i64&gt;(), 8);\nassert_eq!(std::mem::align_of::&lt;(i32, i32)&gt;(), 4);</code></pre>\n<p>任何类型总是对齐到二的 <em>n</em> 次幂。</p>\n<p>即使在技术上可以填入更小的空间，类型的大小也总是会四舍五入为其对齐方式的倍数。例如，尽管像 <code>(f32, u8)</code> 这样的元组只需要 5 字节，但 <code>size_of::&lt;(f32, u8)&gt;()</code> 是 <code>8</code>，因为 <code>align_of::&lt;(f32, u8)&gt;()</code> 是 <code>4</code>。这会确保如果你有一个数组，那么元素类型的大小总能反映出一个元素与其下一个元素的间距。</p>\n<p>对于无固定大小类型，其大小和对齐方式取决于手头的值。给定对无固定大小值的引用，<code>std::mem::size_of_val</code> 函数和 <code>std::mem::align_of_val</code> 函数会返回值的大小和对齐方式。这两个函数可以对固定大小类型和无固定大小类型的引用进行操作。</p>\n<pre class=\"code-rows\"><code>// 指向切片的胖指针包含其引用目标的长度\nlet slice: &amp;[i32] = &amp;[1, 3, 9, 27, 81];\nassert_eq!(std::mem::size_of_val(slice), 20);\n\nlet text: &amp;str = \"alligator\";\nassert_eq!(std::mem::size_of_val(text), 9);\n\nuse std::fmt::Display;\nlet unremarkable: &amp;dyn Display = &amp;193_u8;\nlet remarkable: &amp;dyn Display = &amp;0.0072973525664;\n\n// 这些会返回特型对象指向的值的大小/对齐方式，而不是特型对象\n// 本身的大小/对齐方式。此信息来自特型对象引用的虚表\nassert_eq!(std::mem::size_of_val(unremarkable), 1);\nassert_eq!(std::mem::align_of_val(remarkable), 8);</code></pre>\n<h3 id=\"nav_point_455\">22.8.5　指针运算</h3>\n<p>Rust 会将数组、切片或向量的元素排布为单个连续的内存块，如图 22-1 所示。元素的间隔很均匀，因此如果每个元素占用 <code>size</code> 字节，则第 <code>i</code> 个元素就从第 <code>i * size</code> 字节开始。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00900.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 22-1：内存中的数组</strong></p>\n<p>这样做有一个好处：如果你有两个指向数组元素的裸指针，那么比较指针就会得到与比较元素索引相同的结果。如果 <code>i &lt; j</code>，则指向第 <code>i</code> 个元素的裸指针一定小于指向第 <code>j</code> 个元素的裸指针。这使得裸指针可用作数组遍历的边界。事实上，标准库对切片的简单迭代器最初就是这样定义的：</p>\n<pre class=\"code-rows\"><code>struct Iter&lt;'a, T&gt; {\n    ptr: *const T,\n    end: *const T,\n    ...\n}</code></pre>\n<p><code>ptr</code> 字段指向迭代应该生成的下一个元素，<code>end</code> 字段作为界限：当 <code>ptr == end</code> 时，迭代完成。</p>\n<p>数组布局的另一个好处是：如果 <code>element_ptr</code> 是指向某个数组的第 <code>i</code> 个元素的 <code>*const T</code> 或 <code>*mut T</code> 裸指针，那么 <code>element_ptr.offset(o)</code> 就是指向第 <code>(i + o)</code> 个元素的裸指针。它的定义等效于如下内容：</p>\n<pre class=\"code-rows\"><code>fn offset&lt;T&gt;(ptr: *const T, count: isize) -&gt; *const T\n    where T: Sized\n{\n    let bytes_per_element = std::mem::size_of::&lt;T&gt;() as isize;\n    let byte_offset = count * bytes_per_element;\n    (ptr as isize).checked_add(byte_offset).unwrap() as *const T\n}</code></pre>\n<p><code>std::mem::size_of::&lt;T&gt;</code> 函数会返回类型 <code>T</code> 的字节大小。根据定义，由于 <code>isize</code> 大到足以容纳一个地址，因此可以将基指针转换为 <code>isize</code>，对得到的值进行算术运算，然后将结果转换回指针。</p>\n<p>可以生成指向数组末尾之后第一字节的指针。虽然不能对这样的指针解引用，但可以用它来表示循环的界限或用于边界检查。</p>\n<p>但是，使用 <code>offset</code> 生成超出该点或指向数组开头之前的指针是未定义行为，即使从未对它解引用也是如此。为了方便优化，Rust 会假设当 <code>i</code> 为正值时 <code>ptr.offset(i) &gt; ptr</code>，当 <code>i</code> 为负值时 <code>ptr.offset(i) &lt; ptr</code>。这个假设似乎是安全的，但如果 <code>offset</code> 中的算术溢出了 <code>isize</code> 值，那么可能就不成立了。如果把 <code>i</code> 限制在 <code>ptr</code> 的同一个数组范围内，则肯定不会发生溢出：毕竟数组本身不会溢出地址空间的边界。（为了让指向结尾之后第一字节的指针安全，Rust 从来都不会将值放在地址空间的上端。）</p>\n<p>如果确实需要将指针偏移到与其关联的数组的界限之外，则可以使用 <code>wrapping_offset</code> 方法。该方法与 <code>offset</code> 等效，但 Rust 不会假设 <code>ptr.wrapping_offset(i)</code> 和 <code>ptr</code> 本身的相对顺序。当然，你仍然不能对此类指针解引用，除非确信它们会落在数组中。</p>\n<h3 id=\"nav_point_456\">22.8.6　移动入和移动出内存</h3>\n<p>如果你正在实现的类型需要管理自己的内存，那么就要跟踪内存中哪些部分保存了有效值，而哪些是未初始化的，就像 Rust 处理局部变量一样。考虑下面这段代码：</p>\n<pre class=\"code-rows\"><code>let pot = \"pasta\".to_string();\nlet plate = pot;</code></pre>\n<p>上述代码运行后，情况如图 22-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00901.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 22-2：将字符串从一个局部变量转移给另一个局部变量</strong></p>\n<p>赋值后，<code>pot</code> 处于未初始化状态，而 <code>plate</code> 成了字符串的拥有者。</p>\n<p>在机器层面，没有指定移动对源值的作用，但实际上它通常什么都不做。该赋值可能会使 <code>pot</code> 仍然保存着字符串的指针、容量和长度。当然，如果继续将其视为有效值将是灾难性的，但 Rust 会确保你不会这样做。</p>\n<p>同样的考虑也适用于管理自己内存的数据结构。假设你运行了下面这段代码：</p>\n<pre class=\"code-rows\"><code>let mut noodles = vec![\"udon\".to_string()];\nlet soba = \"soba\".to_string();\nlet last;</code></pre>\n<p>在内存中，状态如图 22-3 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00902.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 22-3：具有未初始化的空闲容量的向量</strong></p>\n<p>这个向量有空闲容量可以再容纳一个元素，但空闲容量中存放的是垃圾数据，可能是以前的内存残余。假设你随后运行了如下代码：</p>\n<pre class=\"code-rows\"><code>noodles.push(soba);</code></pre>\n<p>将字符串压入向量会将未初始化的内存转换为新元素，如图 22-4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00903.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 22-4：将 <code>soba</code> 的值推入向量之后</strong></p>\n<p>该向量已初始化其空白空间，以便拥有该字符串，并增加其长度，以便将其标记为新的有效元素。向量现在是字符串的拥有者，你可以引用它的第二个元素了，而丢弃此向量将释放两个字符串。<code>soba</code> 现在处于未初始化状态。</p>\n<p>最后，考虑一下当从向量中弹出一个值时会发生什么：</p>\n<pre class=\"code-rows\"><code>    last = noodles.pop().unwrap();</code></pre>\n<p>在内存中，现在看起来如图 22-5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00904.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 22-5：把向量中的一个元素弹出到 <code>last</code> 之后</strong></p>\n<p>变量 <code>last</code> 取得了字符串的所有权。向量已减小其 <code>length</code> 以指示用于保存字符串的空间现在未初始化。</p>\n<p>就像之前的 <code>pot</code> 和 <code>pasta</code> 一样，<code>soba</code>、<code>last</code> 和向量的可用空间这三者可能存有相同的位模式。但只有 <code>last</code> 被认为拥有这个值。将其他两个位置中的任何一个视为有效位置都是错误的。</p>\n<p>初始化值的真正定义是<strong>应视为有效</strong>的值。写入值的字节通常是初始化的必要部分，但这只是为了将其视为有效的而做的准备工作。移动和复制对内存的影响是一样的，两者之间的区别在于，在移动之后，源不再被视为有效值，而在复制之后，源和目标都处于有效状态。</p>\n<p>Rust 会在编译期跟踪哪些局部变量处于有效状态，并阻止你使用值已转移给其他地方的变量。<code>Vec</code>、<code>HashMap</code>、<code>Box</code> 等类型会动态跟踪它们的缓冲区。如果你实现了一个管理自己内存的类型，则也需要这样做。</p>\n<p>Rust 为实现这些类型提供了两个基本操作。</p>\n<blockquote>\n<p><code>std::ptr::read(src)</code>（读取）</p>\n</blockquote>\n<p>将值移动出 <code>src</code> 指向的位置，将所有权转移给调用者。<code>src</code> 参数应该是一个 <code>*const T</code> 裸指针，其中 <code>T</code> 是一个固定大小类型。调用此函数后，<code>*src</code> 的内容不受影响，但除非 <code>T</code> 是 <code>Copy</code> 类型，否则你必须确保自己的程序会将它们视为未初始化内存。</p>\n<p>这是 <code>Vec::pop</code> 背后的操作。要弹出一个值，就要调用 <code>read</code> 将该值移出缓冲区，然后递减长度以将该空间标记为未初始化容量。</p>\n<blockquote>\n<p><code>std::ptr::write(dest, value)</code>（写入）</p>\n</blockquote>\n<p>将 <code>value</code> 转移给 <code>dest</code> 指向的位置，该位置在调用之前必须是未初始化内存。引用目标现在拥有该值。在这里，<code>dest</code> 必须是一个 <code>*mut T</code> 裸指针并且 <code>value</code> 是一个 <code>T</code> 值，其中 <code>T</code> 是固定大小类型。</p>\n<p>这就是 <code>Vec::push</code> 背后的操作。压入一个值会调用 <code>write</code> 将值转移给下一个可用空间，然后增加长度以将该空间标记为有效元素。</p>\n<p>两者都是自由函数，而不是裸指针类型的方法。</p>\n<p>请注意，不能使用任何 Rust 的安全指针类型来执行这些操作。安全指针类型会要求其引用目标始终是初始化的，因此将未初始化内存转换为值或相反的操作都超出了它们的能力范围。而裸指针符合这种要求。</p>\n<p>标准库还提供了将值数组从一个内存块移动到另一个内存块的函数。</p>\n<blockquote>\n<p><code>std::ptr::copy(src, dst, count)</code>（复制）</p>\n</blockquote>\n<p>将内存中从 <code>src</code> 开始的 <code>count</code> 个值数组移动到 <code>dst</code> 处，就像编写了一个 <code>read</code> 和 <code>write</code> 调用循环以一次性移动它们一样。调用之前目标内存必须是未初始化的，调用之后源内存要保持未初始化状态。<code>src</code> 参数和 <code>dest</code> 参数必须是 <code>*const T</code> 裸指针和 <code>*mut T</code> 裸指针，并且 <code>count</code> 必须是 <code>usize</code>。</p>\n<blockquote>\n<p><code>ptr.copy_to(dst, count)</code>（复制到）</p>\n</blockquote>\n<p>一个更方便的 <code>copy</code> 版本，它会将内存中从 <code>ptr</code> 开始的 <code>count</code> 个值的数组转移给 <code>dst</code>，而不用以其起点作为参数。</p>\n<blockquote>\n<p><code>std::ptr::copy_nonoverlapping(src, dst, count)</code>（复制，无重叠版）</p>\n</blockquote>\n<p>就像对 <code>copy</code> 的类似调用一样，但是它的契约进一步要求源内存块和目标内存块不能重叠。这可能比调用 <code>copy</code> 略微快一些。</p>\n<blockquote>\n<p><code>ptr.copy_to_nonoverlapping(dst, count)</code>（复制到，无重叠版）</p>\n</blockquote>\n<p>一个更方便的 <code>copy_nonoverlapping</code> 版本，就像 <code>copy_to</code>。</p>\n<p>还有另外两组 <code>read</code> 函数和 <code>write</code> 函数，它们也位于 <code>std::ptr</code> 模块中。</p>\n<blockquote>\n<p><code>read_unaligned</code>（读取，未对齐版）和 <code>write_unaligned</code>（写入，未对齐版）</p>\n</blockquote>\n<p>与 <code>read</code> 和 <code>write</code> 类似，但是这两个函数的指针不需要像引用目标类型通常要求的那样对齐。它们可能比普通的 <code>read</code> 函数和 <code>write</code> 函数慢一点儿。</p>\n<blockquote>\n<p><code>read_volatile</code>（读取，易变版）和 <code>write_volatile</code>（写入，易变版）</p>\n</blockquote>\n<p>这两个函数对应于 C 或 C++ 中的易变（<code>volatile</code>）读取和易变写入。</p>\n<h3 id=\"nav_point_457\">22.8.7　示例：<code>GapBuffer</code></h3>\n<p>下面是一个使用刚刚讲过的裸指针函数的示例。</p>\n<p>假设你正在编写一个文本编辑器，并且正在寻找一种类型来表示文本。可以选择 <code>String</code> 并使用 <code>insert</code> 方法和 <code>remove</code> 方法在用户键入时插入字符和移除字符。但是如果在一个大文件的开头编辑文本，则这些方法可能开销会很高：插入新字符需要在内存中将整个字符串的其余部分都移到右侧，而删除则要将其全部移回左侧。你希望此类常见操作的开销低一些。</p>\n<p>Emacs 文本编辑器使用了一种称为<strong>间隙缓冲区</strong>的简单数据结构，该数据结构可以在恒定时间内插入字符和删除字符。<code>String</code> 会将其所有空闲容量保留在文本的末尾，这使得 <code>push</code> 和 <code>pop</code> 的开销变得更低，而间隙缓冲区会将其空闲容量保留在文本中间，即正在进行编辑的位置。这种空闲容量称为<strong>间隙</strong>。在间隙处插入元素或删除元素的开销很低，只要根据需要缩小或扩大间隙即可。可以通过将文本从间隙的一侧移动到另一侧，来让间隙移动到你喜欢的任何位置。当间隙为空时，就迁移到更大的缓冲区。</p>\n<p>虽然间隙缓冲区中的插入和删除速度很快，但如果想更改这些操作发生的位置就要将间隙移动到新位置。移动元素需要的时间与移动的距离成正比。幸运的是，典型的编辑活动通常都会在转移到别处之前，在缓冲区的临近区域中进行一系列更改。</p>\n<p>本节将在 Rust 中实现间隙缓冲区。为了避免被 UTF-8 分散注意力，我们会让该缓冲区直接存储 <code>char</code> 值，但即使以其他形式存储文本，这些操作的原则也是一样的。</p>\n<p>首先，我们会展示间隙缓冲区的实际应用。下列代码会创建一个 <code>GapBuffer</code>，在其中插入一些文本，然后将插入点移动到最后一个单词之前：</p>\n<pre class=\"code-rows\"><code>let mut buf = GapBuffer::new();\nbuf.insert_iter(\"Lord of the Rings\".chars());\nbuf.set_position(12);</code></pre>\n<p>运行上述代码后，缓冲区如图 22-6 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00905.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 22-6：包含一些文本的间隙缓冲区</strong></p>\n<p>插入就是要用新文本填补间隙。下面这段代码添加了一个单词并破坏了原句要表达的意思：</p>\n<pre class=\"code-rows\"><code>buf.insert_iter(\"Onion \".chars());</code></pre>\n<p>这会导致如图 22-7 所示的状态。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00906.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 22-7：包含更多文本的间隙缓冲区</strong></p>\n<p>下面是我们的 <code>GapBuffer</code> 类型：</p>\n<pre class=\"code-rows\"><code>use std;\nuse std::ops::Range;\n\npub struct GapBuffer&lt;T&gt; {\n    // 元素的存储区。这个存储区具有我们需要的容量，但它的长度始终保持为0。\n    // GapBuffer会将其元素和间隙放入此`Vec`的“未使用”容量中\n    storage: Vec&lt;T&gt;,\n\n    // `storage`中间未初始化元素的范围\n    // 这个范围前后的元素始终是已初始化的\n    gap: Range&lt;usize&gt;\n}</code></pre>\n<p><code>GapBuffer</code> 会以一种奇怪的方式使用它的 <code>storage</code> 字段。<span class=\"comment-number\">4</span>它实际上从未在向量中存储任何元素（不过这么说也不太准确），而只是简单地调用 <code>Vec::with_capacity(n)</code> 来获取一块足够大的内存以容纳 <code>n</code> 值，通过向量的 <code>as_ptr</code> 方法和 <code>as_mut_ptr</code> 方法获得指向该内存的裸指针，然后直接将该缓冲区用于自己的目的。向量的长度始终保持为 0。当 <code>Vec</code> 被丢弃时，<code>Vec</code> 不会尝试释放自己的元素（因为它不认为自己有任何元素），而只会释放内存块。这正是 <code>GapBuffer</code> 想要的行为，它有自己的 <code>Drop</code> 实现，知道有效元素在哪里并能正确地丢弃它们。</p>\n\n<p><code>GapBuffer</code> 中最简单的方法正如你所预期的：</p>\n<pre class=\"code-rows\"><code>impl&lt;T&gt; GapBuffer&lt;T&gt; {\n    pub fn new() -&gt; GapBuffer&lt;T&gt; {\n        GapBuffer { storage: Vec::new(), gap: 0..0 }\n    }\n\n    /// 返回在不重新分配的情况下这个GapBuffer可以容纳的元素数\n    pub fn capacity(&amp;self) -&gt; usize {\n        self.storage.capacity()\n    }\n\n    /// 返回这个GapBuffer当前包含的元素数\n    pub fn len(&amp;self) -&gt; usize {\n        self.capacity() - self.gap.len()\n    }\n\n    /// 返回当前插入点\n    pub fn position(&amp;self) -&gt; usize {\n        self.gap.start\n    }\n\n    ...\n}</code></pre>\n<p>它为后面的很多函数提供了一个工具方法，简化了那些函数的实现。该工具方法会返回指向缓冲区中给定索引处元素的裸指针。为了满足 Rust 的要求，需要为 <code>mut</code> 指针和 <code>const</code> 指针分别定义一个方法。与前面的方法不同，这些方法都不是公共的。继续看这个 <code>impl</code> 块：</p>\n<pre class=\"code-rows\"><code>/// 返回底层存储中第`index`个元素的指针，不考虑间隙\n///\n/// 安全性: `index`必须是`self.storage`中的有效索引\nunsafe fn space(&amp;self, index: usize) -&gt; *const T {\n    self.storage.as_ptr().offset(index as isize)\n}\n\n/// 返回底层存储中第`index`个元素的可变指针，不考虑间隙\n///\n/// 安全性：`index`必须是`self.storage`中的有效索引\nunsafe fn space_mut(&amp;mut self, index: usize) -&gt; *mut T {\n    self.storage.as_mut_ptr().offset(index as isize)\n}</code></pre>\n<p>要找到给定索引处的元素，就必须考虑该索引是落在间隙之前还是之后，并适当调整：</p>\n<pre class=\"code-rows\"><code>/// 返回缓冲区中第`index`个元素的偏移量，并将间隙考虑在内。\n/// 这个方法不检查索引是否在范围内，但永远不会返回间隙中的索引\nfn index_to_raw(&amp;self, index: usize) -&gt; usize {\n    if index &lt; self.gap.start {\n        index\n    } else {\n        index + self.gap.len()\n    }\n}\n\n/// 返回对第`index`个元素的引用，如果`index`超出了范围，则返回`None`\npub fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {\n    let raw = self.index_to_raw(index);\n    if raw &lt; self.capacity() {\n        unsafe {\n            // 刚刚针对self.capacity()检查过`raw`，而index_to_raw\n            // 跳过了间隙，所以这是安全的\n            Some(&amp;*self.space(raw))\n        }\n    } else {\n        None\n    }\n}</code></pre>\n<p>当开始在缓冲区的不同部分进行插入和删除时，需要将间隙移动到新位置。向右移动间隙就要向左移动元素，反之亦然，这就像水平仪中的气泡向一个方向移动而液体会向另一个方向移动一样：</p>\n<pre class=\"code-rows\"><code>/// 将当前插入点设置为`pos`。如果`pos`越界，就panic\npub fn set_position(&amp;mut self, pos: usize) {\n    if pos &gt; self.len() {\n        panic!(\"index {} out of range for GapBuffer\", pos);\n    }\n\n    unsafe {\n        let gap = self.gap.clone();\n        if pos &gt; gap.start {\n            // `pos`位于间隙之后。通过将间隙之后的元素移动到间隙之前来向右移动间隙\n            let distance = pos - gap.start;\n            std::ptr::copy(self.space(gap.end),\n                           self.space_mut(gap.start),\n                           distance);\n        } else if pos &lt; gap.start {\n            // `pos`位于间隙之前。通过将间隙之前的元素移动到间隙之后来向左移动间隙\n            let distance = gap.start - pos;\n            std::ptr::copy(self.space(pos),\n                           self.space_mut(gap.end - distance),\n                           distance);\n        }\n\n        self.gap = pos .. pos + gap.len();\n    }\n}</code></pre>\n<p>这个函数使用 <code>std::ptr::copy</code> 方法来平移元素，<code>copy</code> 要求目标是未初始化的并且会让源保持未初始化。源和目标范围可以重叠，<code>copy</code> 会正确处理这种情况。由于间隙是调用前尚未初始化的内存，而这个函数会调整间隙的位置以覆盖 <code>copy</code> 腾出的空间，因此可以满足 <code>copy</code> 函数的契约。</p>\n<p>元素的插入和移除都比较简单。插入会从间隙中为新元素占用一个空间，而移除会将值移出并扩大间隙以覆盖此值曾占据的空间：</p>\n<pre class=\"code-rows\"><code>/// 在当前插入点插入`elt`，并在插入后把插入点后移\npub fn insert(&amp;mut self, elt: T) {\n    if self.gap.len() == 0 {\n        self.enlarge_gap();\n    }\n\n    unsafe {\n        let index = self.gap.start;\n        std::ptr::write(self.space_mut(index), elt);\n    }\n    self.gap.start += 1;\n}\n\n/// 在当前插入点插入`iter`生成的元素，并在插入后把插入点后移\npub fn insert_iter&lt;I&gt;(&amp;mut self, iterable: I)\n    where I: IntoIterator&lt;Item=T&gt;\n{\n    for item in iterable {\n        self.insert(item)\n    }\n}\n\n/// 删除插入点之后的元素并返回它，如果插入点位于GapBuffer的末尾，则返回`None`\npub fn remove(&amp;mut self) -&gt; Option&lt;T&gt; {\n    if self.gap.end == self.capacity() {\n        return None;\n    }\n\n    let element = unsafe {\n        std::ptr::read(self.space(self.gap.end))\n    };\n    self.gap.end += 1;\n    Some(element)\n}</code></pre>\n<p>与 <code>Vec</code> 使用 <code>std::ptr::write</code> 进行 <code>push</code> 和使用 <code>std::ptr::read</code> 进行 <code>pop</code> 的方式类似，<code>GapBuffer</code> 使用 <code>write</code> 进行 <code>insert</code>，使用 <code>read</code> 进行 <code>remove</code>。与 <code>Vec</code> 必须调整其长度以维持已初始化元素和空闲容量之间的边界一样，<code>GapBuffer</code> 也会调整其间隙。</p>\n<p>填补此间隙后，<code>insert</code> 方法必须扩大缓冲区以获得更多可用空间。<code>enlarge_gap</code> 方法（<code>impl</code> 块中的最后一个）会处理这个问题：</p>\n<pre class=\"code-rows\"><code>/// 将`self.storage`的容量翻倍\nfn enlarge_gap(&amp;mut self) {\n    let mut new_capacity = self.capacity() * 2;\n    if new_capacity == 0 {\n        // 现有向量是空的\n        // 选择一个合理的初始容量\n        new_capacity = 4;\n    }\n\n    // 我们不知道调整Vec的大小会对其“（表面看）未使用的”容量\n    // 有何影响，所以只好创建一个新向量并把元素移了过去\n    let mut new = Vec::with_capacity(new_capacity);\n    let after_gap = self.capacity() - self.gap.end;\n    let new_gap = self.gap.start .. new.capacity() - after_gap;\n\n    unsafe {\n        // 移动位于此间隙之前的元素\n        std::ptr::copy_nonoverlapping(self.space(0),\n                                      new.as_mut_ptr(),\n                                      self.gap.start);\n\n        // 移动位于此间隙之后的元素\n        let new_gap_end = new.as_mut_ptr().offset(new_gap.end as isize);\n        std::ptr::copy_nonoverlapping(self.space(self.gap.end),\n                                      new_gap_end,\n                                      after_gap);\n    }\n\n    // 这会释放旧的Vec，但不会丢弃任何元素，因为此Vec的长度为0\n    self.storage = new;\n    self.gap = new_gap;\n}</code></pre>\n<p><code>set_position</code> 必须使用 <code>copy</code> 在间隙中来回移动元素，<code>enlarge_gap</code> 则可以使用 <code>copy_nonoverlapping</code>，因为它会将元素移动到一个全新的缓冲区。</p>\n<p>将新向量转移给 <code>self.storage</code> 会丢弃旧向量。由于旧向量的长度为 0，它认为自己没有要丢弃的元素，因此只释放了自己的缓冲区。巧妙的是，<code>copy_nonoverlapping</code> 也有把源变成未初始化状态的语义，因此旧向量的做法恰巧是正确的：现在所有元素都归新向量所有了。</p>\n<p>最后，需要确保丢弃 <code>GapBuffer</code> 也会丢弃它的所有元素：</p>\n<pre class=\"code-rows\"><code>impl&lt;T&gt; Drop for GapBuffer&lt;T&gt; {\n    fn drop(&amp;mut self) {\n        unsafe {\n            for i in 0 .. self.gap.start {\n                std::ptr::drop_in_place(self.space_mut(i));\n            }\n            for i in self.gap.end .. self.capacity() {\n                std::ptr::drop_in_place(self.space_mut(i));\n            }\n        }\n    }\n}</code></pre>\n<p>这些元素都位于间隙前后，因此需要遍历每个区域并使用 <code>std::ptr::drop_in_place</code> 函数丢弃每个元素。<code>drop_in_place</code> 函数是一个行为类似于 <code>drop(std::ptr::read(ptr))</code> 的实用程序，但不会“费心”地将值转移给其调用者（因此适用于无固定大小类型）。就像在 <code>enlarge_gap</code> 中一样，当向量 <code>self.storage</code> 被丢弃时，它的缓冲区实际上是未初始化的。</p>\n<p>与本章展示过的其他类型一样，<code>GapBuffer</code> 会确保自己的不变条件足以遵守所使用的每个不安全特性的契约，因此它的所有公共方法都不需要标记为不安全。<code>GapBuffer</code> 为无法用安全代码高效编写的特性实现了一个安全的接口。</p>\n<h3 id=\"nav_point_458\">22.8.8　不安全代码中的 panic 安全性</h3>\n<p>在 Rust 中，panic 通常不会导致未定义行为，<code>panic!</code> 宏并不是不安全特性。但是，当你决定使用不安全代码时，就得考虑 panic 安全性的问题了。</p>\n<p>考虑 22.8.7 节中的 <code>GapBuffer::remove</code> 方法：</p>\n<pre class=\"code-rows\"><code>pub fn remove(&amp;mut self) -&gt; Option&lt;T&gt; {\n    if self.gap.end == self.capacity() {\n        return None;\n    }\n\n    let element = unsafe {\n        std::ptr::read(self.space(self.gap.end))\n    };\n    self.gap.end += 1;\n    Some(element)\n}</code></pre>\n<p>对 <code>read</code> 的调用会将紧随间隙之后的元素移出缓冲区，留下未初始化的空间。此时，<code>GapBuffer</code> 处于不一致状态：我们打破了间隙外的所有元素都必须是初始化的这个不变条件。幸运的是，下一条语句扩大了间隙以覆盖这个空间，因此当我们返回时，不变条件会再次成立。</p>\n<p>但是请考虑一下，如果在调用 <code>read</code> 之后、调整 <code>self.gap.end</code> 之前，此代码尝试使用可能引发 panic 的特性（如索引切片），那么会发生什么呢？在这两个操作之间的任何地方突然退出该方法都会使 <code>GapBuffer</code> 在间隙外留下未初始化的元素。下一次调用 <code>remove</code> 可能会尝试再次读取（<code>read</code>）它，即使仅仅丢弃 <code>GapBuffer</code> 也会尝试运行其 <code>drop</code> 方法。这两者都是未定义行为，因为它们会访问未初始化内存。</p>\n<p>类型的方法在执行工作时几乎不可避免地会暂时放松类型的不变条件，然后在返回之前让其回到正轨。方法中间出现的 panic 可能会中断清理过程，使类型处于不一致状态。</p>\n<p>如果类型只使用安全代码，那么这种不一致可能会使类型行为诡异，但并不会引入未定义行为。不过使用不安全特性的代码通常会依赖其不变条件来满足这些特性的契约。破坏不变条件会导致契约破损，从而导致未定义行为。</p>\n<p>使用不安全特性时，必须特别注意识别这些暂时放松了不变条件的敏感代码区域，并确保它们不会执行任何可能引起 panic 的事情。</p>\n<h2 id=\"nav_point_459\">22.9　用联合体重新解释内存</h2>\n<p>虽然 Rust 提供了许多有用的抽象，但最终我们编写的软件只是在操纵字节。联合体是 Rust 最强大的特性之一，用于操纵这些字节并选择如何解释它们。例如，任何 32 位（4 字节）的集合都可以解释为整数或浮点数。任何一种解释都是有效的，不过，将一种数据解释为另一种数据可能会导致其失去意义。</p>\n<p>下面是一个用来表示可解释为整数或浮点数的字节集合的联合体：</p>\n<pre class=\"code-rows\"><code>union FloatOrInt {\n    f: f32,\n    i: i32,\n}</code></pre>\n<p>这是一个包含两个字段（<code>f</code> 和 <code>i</code>）的联合体。这两个字段可以像结构体的字段一样被赋值，但在构造联合体时，只能选择一个字段，这与结构体不同。结构体的字段会引用内存中的不同位置，而联合体的字段会引用相同位序列的不同解释。赋值给不同的字段只是意味着根据适当的类型覆盖这些位中的一部分或全部。在下面的代码中，<code>one</code> 指向的是单个 32 位内存范围，它首先存储一个按简单整数编码的 <code>1</code>，然后存储一个按 IEEE 754 浮点数编码的 <code>1.0</code>。一旦写入了 <code>f</code>，先前写入的 <code>FloatOrInt</code> 值就会被覆盖：</p>\n<pre class=\"code-rows\"><code>let mut one = FloatOrInt { i: 1 };\nassert_eq!(unsafe { one.i }, 0x00_00_00_01);\none.f = 1.0;\nassert_eq!(unsafe { one.i }, 0x3F_80_00_00);</code></pre>\n<p>出于同样的原因，联合体的大小会由其最大字段决定。例如，下面这个联合体的大小为 64 位，虽然 <code>SmallOrLarge::s</code> 只是一个 <code>bool</code>：</p>\n<pre class=\"code-rows\"><code>union SmallOrLarge {\n    s: bool,\n    l: u64\n}</code></pre>\n<p>虽然构建联合体或对它的字段赋值是完全安全的，但读取联合体的任何字段都是不安全的：</p>\n<pre class=\"code-rows\"><code>let u = SmallOrLarge { l: 1337 };\nprintln!(\"{}\", unsafe ); // 打印出1337</code></pre>\n<p>这是因为与枚举不同，联合体没有标签。编译器不会添加额外的位来区分各种变体。在运行期无法判断 <code>SmallOrLarge</code> 是要该解释为 <code>u64</code> 还是 <code>bool</code>，除非程序有一些额外的上下文。</p>\n<p>同时，并没有什么内置手段可以保证给定字段的位模式是有效的。例如，写入 <code>SmallOrLarge</code> 值的 <code>l</code> 字段将覆盖其 <code>s</code> 字段，但它创建的这个位模式并无任何用处，甚至可能都不是有效的 <code>bool</code>。因此，虽然写入联合体字段是安全的，但每次读取都需要 <code>unsafe</code> 代码。仅当 <code>s</code> 字段的各个位可以形成有效的 <code>bool</code> 时才允许从 <code>u.s</code> 读取，否则，这就是未定义行为。</p>\n<p>只要把这些限制牢记在心，联合体仍然可以成为临时重新解释某些数据的有用方法，尤其是在针对值的表观而非值本身进行计算时。例如，前面提到的 <code>FloatOrInt</code> 类型可以轻松地打印出浮点数的各个位——即便 <code>f32</code> 没有实现过 <code>Binary</code> 格式化程序：</p>\n<pre class=\"code-rows\"><code>let float = FloatOrInt { f: 31337.0 };\n// 打印出1000110111101001101001000000000\nprintln!(\"{:b}\", unsafe { float.i });</code></pre>\n<p>虽然几乎可以肯定这些简单示例会在任何版本的编译器上如预期般工作，但并不能保证任何字段都从特定位置开始，除非将某个属性添加到 <code>union</code> 定义中，告诉编译器如何在内存中排布数据。添加属性 <code>#[repr(C)]</code> 可以保证所有字段都从偏移量 <code>0</code> 而不是编译器喜欢的任何位置开始。有了这个保证，这种改写行为就可以用来提取像整数的符号位这样的单独二进制位了：</p>\n<pre class=\"code-rows\"><code>#[repr(C)]\nunion SignExtractor {\n    value: i64,\n    bytes: [u8; 8]\n}\n\nfn sign(int: i64) -&gt; bool {\n    let se = SignExtractor { value: int };\n    println!(\"{:b} ({:?})\", unsafe { se.value }, unsafe { se.bytes });\n    unsafe { se.bytes[7] &gt;= 0b10000000 }\n}\n\nassert_eq!(sign(-1), true);\nassert_eq!(sign(1), false);\nassert_eq!(sign(i64::MAX), false);\nassert_eq!(sign(i64::MIN), true);</code></pre>\n<p>在这里，符号位是最高有效字节的最高有效位。因为 x86 处理器是小端（低位在前）的，所以这些字节的顺序是相反的，其最高有效字节不是 <code>bytes[0]</code>，而是 <code>bytes[7]</code>。通常，这不是 Rust 代码必须处理的事情，但是因为这段代码要直接与 <code>i64</code> 的内存中表示法打交道，所以这些底层细节就变得很重要了。</p>\n<p>因为不知道该如何丢弃其内容，所以联合体的所有字段都必须是可 <code>Copy</code> 的。但是，如果必须在联合体中存储一个 <code>String</code>，那么也有相应的解决方案，详情请参阅 <code>std::mem::ManuallyDrop</code> 的标准库文档。</p>\n<h2 id=\"nav_point_460\">22.10　匹配联合体</h2>\n<p>在 Rust 联合体上进行匹配和在结构体上匹配类似，但每个模式必须指定一个字段：</p>\n<pre class=\"code-rows\"><code>unsafe {\n    match u {\n        SmallOrLarge { s: true } =&gt; { println!(\"boolean true\"); }\n        SmallOrLarge { l: 2 } =&gt; { println!(\"integer 2\"); }\n        _ =&gt; { println!(\"something else\"); }\n    }\n}</code></pre>\n<p>与联合体变体匹配但不指定值的 <code>match</code> 分支永远都会成功。如果 <code>u</code> 的最后一个写入字段是 <code>u.i</code>，则以下代码将导致未定义行为：</p>\n<pre class=\"code-rows\"><code>// 未定义行为！\nunsafe {\n    match u {\n        FloatOrInt { f } =&gt; { println!(\"float {}\", f) },\n        // 警告：无法抵达的模式\n        FloatOrInt { i } =&gt; { println!(\"int {}\", i) }\n    }\n}</code></pre>\n<h2 id=\"nav_point_461\">22.11　借用联合体</h2>\n<p>借用联合体的一个字段就是借用整个联合体。这意味着，按照正常的借用规则，将一个字段作为可变借用会排斥对该字段或其他字段的任何其他借用，而将一个字段作为不可变借用则意味着对任何字段都不能再进行可变借用。</p>\n<p>正如我们将在第 23 章中看到的，Rust 不仅可以帮你为自己的不安全代码构建出安全接口，还可以为用其他语言编写的代码构建出安全接口。从字面来看，“不安全”是充满危险的，但如果谨慎使用，那么也可以构建出高性能代码，同时还能让 Rust 程序员继续享有安全感。</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}