{"id":2711,"title":"33 | 编程范式游记（4）- 函数式编程","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p><p>从前三章内容中，我们了解到，虽然C语言简单灵活，能够让程序员在高级语言特性之上轻松进行底层上的微观控制，被誉为“高级语言中的汇编语言”，但其基于过程和底层的设计初衷又成了它的短板。</p><p>在程序世界中，编程工作更多的是解决业务上的问题，而不是计算机的问题，我们需要更为贴近业务、更为抽象的语言，如典型的面向对象语言C++和Java等。</p><p>C++很大程度上解决了C语言中的各种问题和不便，尤其是通过类、模板、虚函数和运行时识别等解决了C语言的泛型编程问题。然而，如何做更为抽象的泛型呢？答案就是函数式编程（Functional Programming）。</p><h1>函数式编程</h1><p>相对于计算机的历史而言，函数式编程其实是一个非常古老的概念。函数式编程的基础模型来源于 λ 演算，而 λ 演算并没有被设计在计算机上执行。它是由 Alonzo Church 和 Stephen Cole Kleene 在 20 世纪 30 年代引入的一套用于研究函数定义、函数应用和递归的形式系统。</p><p>如 Alonzo 所说，像 booleans、integers 或者其他的数据结构都可以被函数取代掉。</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/cd/7fac133e887bb91f6619887e6a6dcfcd.png?wh=1330*997\" alt=\"\"></p><p>我们来看一下函数式编程，它的理念就来自于数学中的代数。</p><pre><code>f(x)=5x^2+4x+3\ng(x)=2f(x)+5=10x^2+8x+11\nh(x)=f(x)+g(x)=15x^2+12x+14\n</code></pre><!-- [[[read_end]]] --><p>假设f(x)是一个函数，g(x)是第二个函数，把f(x)这个函数套下来，并展开。然后还可以定义一个由两个一元函数组合成的二元函数，还可以做递归，下面这个函数定义就是斐波那契数列。</p><pre><code>f(x)=f(x-1)+f(x-2)\n</code></pre><p>对于函数式编程来说，它只关心<strong>定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的</strong>。</p><p>函数式编程有以下特点。</p><p><strong>特征</strong></p><ul>\n<li><strong>stateless</strong>：函数不维护任何状态。函数式编程的核心精神是stateless，简而言之就是它不能存在状态，打个比方，你给我数据我处理完扔出来。里面的数据是不变的。</li>\n<li><strong>immutable</strong>：输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。</li>\n</ul><p><strong>优势</strong></p><ul>\n<li>没有状态就没有伤害。</li>\n<li>并行执行无伤害。</li>\n<li>Copy-Paste重构代码无伤害。</li>\n<li>函数的执行没有顺序上的问题。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/13/a2/134bd812c06ca16d8f29bc40174055a2.png?wh=1020*795\" alt=\"\"></p><p>函数式编程还带来了以下一些好处。</p><ul>\n<li>\n<p><strong>惰性求值</strong>。这需要编译器的支持，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。也就是说，语句如 <code>x:=expression;</code>  (把一个表达式的结果赋值给一个变量)显式地调用这个表达式被计算并把结果放置到 <code>x</code> 中，但是先不管实际在 <code>x</code> 中的是什么，直到通过后面的表达式中到 <code>x</code> 的引用而有了对它的值的需求的时候，而后面表达式自身的求值也可以被延迟，最终为了生成让外界看到的某个符号而计算这个快速增长的依赖树。</p>\n</li>\n<li>\n<p><strong>确定性</strong>。所谓确定性，就是像在数学中那样，<code>f(x) = y</code> 这个函数无论在什么场景下，都会得到同样的结果，而不是像程序中的很多函数那样。同一个参数，在不同的场景下会计算出不同的结果，这个我们称之为函数的确定性。所谓不同的场景，就是我们的函数会根据运行中的状态信息的不同而发生变化。</p>\n</li>\n</ul><p>我们知道，因为状态，在并行执行和copy-paste时引发bug的概率是非常高的，所以没有状态就没有伤害，就像没有依赖就没有伤害一样，并行执行无伤害，copy代码无伤害，因为没有状态，代码怎样拷都行。</p><p><strong>劣势</strong></p><ul>\n<li>数据复制比较严重。</li>\n</ul><blockquote>\n<p><strong>注</strong>：有一些人可能会觉得这会对性能造成影响。其实，这个劣势不见得会导致性能不好。因为没有状态，所以代码在并行上根本不需要锁（不需要对状态修改的锁），所以可以拼命地并发，反而可以让性能很不错。比如：Erlang就是其中的代表。</p>\n</blockquote><p>对于纯函数式（也就是完全没有状态的函数）的编程来说，各个语言支持的程度如下：</p><ul>\n<li>完全纯函数式 Haskell</li>\n<li>容易写纯函数 F#, Ocaml, Clojure, Scala</li>\n<li>纯函数需要花点精力 C#, Java, JavaScript</li>\n</ul><p>完全纯函数的语言，很容易写成函数，纯函数需要花精力。只要所谓的纯函数的问题，传进来的数据不改，改完的东西复制一份拷出去，然后没有状态显示。</p><p>但是很多人并不习惯函数式编程，因为函数式编程和过程式编程的思维方式完全不一样。过程式编程是在把具体的流程描述出来，所以可以不假思索，而函数式编程的抽象度更大，在实现方式上，有函数套函数、函数返回函数、函数里定义函数……把人搞得很糊涂。</p><h1>函数式编程用到的技术</h1><p>下面是函数式编程用到的一些技术。</p><ul>\n<li>\n<p><strong>first class function（头等函数）</strong> ：这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建、修改，并当成变量一样传递、返回，或是在函数中嵌套函数。</p>\n</li>\n<li>\n<p><strong>tail recursion optimization（尾递归优化）</strong> ： 我们知道递归的害处，那就是如果递归很深的话，stack受不了，并会导致性能大幅度下降。因此，我们使用尾递归优化技术——每次递归时都会重用stack，这样能够提升性能。当然，这需要语言或编译器的支持。Python就不支持。</p>\n</li>\n<li>\n<p><strong>map &amp; reduce</strong> ：这个技术不用多说了，函数式编程最常见的技术就是对一个集合做Map和Reduce操作。这比起过程式的语言来说，在代码上要更容易阅读。（传统过程式的语言需要使用for/while循环，然后在各种变量中把数据倒过来倒过去的）这个很像C++ STL中foreach、find_if、count_if等函数的玩法。</p>\n</li>\n<li>\n<p><strong>pipeline（管道）</strong>：这个技术的意思是，将函数实例成一个一个的action，然后将一组action放到一个数组或是列表中，再把数据传给这个action list，数据就像一个pipeline一样顺序地被各个函数所操作，最终得到我们想要的结果。</p>\n</li>\n<li>\n<p><strong>recursing（递归）</strong> ：递归最大的好处就是简化代码，它可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。</p>\n</li>\n<li>\n<p><strong>currying（柯里化）</strong> ：将一个函数的多个参数分解成多个函数， 然后将函数多层封装起来，每层函数都返回一个函数去接收下一个参数，这可以简化函数的多个参数。在C++中，这很像STL中的bind1st或是bind2nd。</p>\n</li>\n<li>\n<p><strong>higher order function（高阶函数）</strong>：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象满天飞一样。这个技术用来做 Decorator 很不错。</p>\n</li>\n</ul><p>上面这些技术太抽象了，我们还是从一个最简单的例子开始。</p><pre><code>// 非函数式，不是pure funciton，有状态\nint cnt;\nvoid increment(){\n    cnt++;\n}\n</code></pre><p>这里有个全局变量，调这个全局函数变量++，这里面是有状态的，这个状态在外部。所以，如果是多线程的话，这里面的代码是不安全的。</p><p>如果写成纯函数，应该是下面这个样子。</p><pre><code>// 函数式，pure function， 无状态\nint increment(int cnt){\n    return cnt+1;\n}\n</code></pre><p>这个是你传给我什么，我就返回这个值的+1值，你会发现，代码随便拷，而且与线程无关，代码在并行时候不用锁，因为是复制了原有的数据，并返回了新的数据。</p><p>我们再来看另一个例子：</p><pre><code>def inc(x):\n    def incx(y):\n        return x+y\n    return incx\n \ninc2 = inc(2)\ninc5 = inc(5)\n \nprint inc2(5) # 输出 7\nprint inc5(5) # 输出 10\n</code></pre><p>上面这段Python的代码，开始有点复杂了。我们可以看到上面那个例子<code>inc()</code>函数返回了另一个函数<code>incx()</code>，于是可以用<code>inc()</code>函数来构造各种版本的inc函数，比如：<code>inc2()</code>和<code>inc5()</code>。这个技术其实就是上面所说的 currying 技术。从这个技术上，你可能体会到函数式编程的理念。</p><ul>\n<li>\n<p><strong>把函数当成变量来用，关注描述问题而不是怎么实现，这样可以让代码更易读</strong>。</p>\n</li>\n<li>\n<p><strong>因为函数返回里面的这个函数，所以函数关注的是表达式，关注的是描述这个问题，而不是怎么实现这个事情</strong>。</p>\n</li>\n</ul><h1>Lisp 语言介绍</h1><p>要说函数式语言，不可避免地要说一下Lisp。</p><p>下面，我们再来看看Scheme语言（Lisp的一个方言）的函数式玩法。在Scheme里，所有的操作都是函数，包括加减乘除这样的东西。所以，一个表达式是这样的形式—— <em>（函数名 参数1 参数1）</em></p><pre><code>(define (plus x y)  (+ x y))\n(define (times x y) (* x y))\n(define (square x)  (times x x))\n</code></pre><p>上面三个函数：</p><ul>\n<li>用内置的 <code>+</code> 函数定义了一个新的 <code>plus</code> 函数。</li>\n<li>用内置的 <code>*</code> 函数定义了一个新的 <code>times</code> 函数。</li>\n<li>用之前的 <code>times</code> 函数定义了一个 <code>square</code> 函数。</li>\n</ul><p>下面这个函数定义了： f(x) = 5 * x^2 +10</p><pre><code>(define (f1 x) ;;; f(x) = 5 * x^2 + 10\n    (plus 10 (times 5 (square x))))\n</code></pre><p>也可以这样定义——使用 lambda 匿名函数。</p><pre><code>(define f2\n    (lambda (x)\n        (define plus\n            (lambda (a b) (+ a b)))\n        (define times\n            (lambda (a b) (* a b)))\n        (plus 10 (times 5 (times x x)))))\n</code></pre><p>在上面的这个代码里，我们使用 lambda 来定义函数 <code>f2</code> ，然后也同样用 lambda 定义了两个函数—— <code>plus</code> 和 <code>times</code>。 最后，由 <code>(plus 10 (times 5 (times x x)))</code> 定义了 <code>f2</code> 。</p><p>我们再来看一个阶乘的示例：</p><pre><code>;;; recursion\n(define factoral (lambda (x)\n    (if (&lt;= x 1) 1\n        (* x (factoral (- x 1))))))\n\n(newline)\n(display(factoral 6))\n</code></pre><p>下面是另一个版本的，使用了尾递归。</p><pre><code>;;; another version of recursion\n(define (factoral_x n)\n    (define (iter product counter)\n        (if (&lt; counter n)\n            product\n            (iter (* counter product) (+ counter 1))))\n    (iter 1 1))\n\n(newline)\n(display(factoral_x 5))\n</code></pre><h1>函数式编程的思维方式</h1><p>前面提到过多次，函数式编程关注的是：describe what to do, rather than how to do it。于是，我们把以前的过程式编程范式叫做 Imperative Programming – 指令式编程，而把函数式编程范式叫做 Declarative Programming – 声明式编程。</p><h2>传统方式的写法</h2><p>下面我们看一下相关的示例。比如，我们有3辆车比赛，简单起见，我们分别给这3辆车70%的概率让它们可以往前走一步，一共有5次机会，然后打出每一次这3辆车的前行状态。</p><p>对于Imperative Programming来说，代码如下（Python）：</p><pre><code>from random import random\n \ntime = 5\ncar_positions = [1, 1, 1]\n \nwhile time:\n    # decrease time\n    time -= 1\n \n    print ''\n    for i in range(len(car_positions)):\n        # move car\n        if random() &gt; 0.3:\n            car_positions[i] += 1\n \n        # draw car\n        print '-' * car_positions[i]\n</code></pre><p>我们可以把这两重循环变成一些函数模块，这样有利于更容易地阅读代码：</p><pre><code>from random import random\n \ndef move_cars():\n    for i, _ in enumerate(car_positions):\n        if random() &gt; 0.3:\n            car_positions[i] += 1\n \ndef draw_car(car_position):\n    print '-' * car_position\n \ndef run_step_of_race():\n    global time\n    time -= 1\n    move_cars()\n \ndef draw():\n    print ''\n    for car_position in car_positions:\n        draw_car(car_position)\n \ntime = 5\ncar_positions = [1, 1, 1]\n \nwhile time:\n    run_step_of_race()\n    draw()\n</code></pre><p>上面的代码，从主循环开始，我们可以很清楚地看到程序的主干，因为我们把程序的逻辑分成了几个函数。这样一来，代码逻辑就会变成几个小碎片，于是我们读代码时要考虑的上下文就少了很多，阅读代码也会更容易。不像第一个示例，如果没有注释和说明，你还是需要花些时间理解一下。而将代码逻辑封装成了函数后，我们就相当于给每个相对独立的程序逻辑取了个名字，于是代码成了自解释的。</p><p>但是，你会发现，封装成函数后，这些函数都会依赖于共享的变量来同步其状态。于是，在读代码的过程中，每当我们进入到函数里，读到访问了一个外部的变量时，我们马上要去查看这个变量的上下文，然后还要在大脑里推演这个变量的状态， 才能知道程序的真正逻辑。也就是说，这些函数必须知道其它函数是怎么修改它们之间的共享变量的，所以，这些函数是有状态的。</p><h2>函数式的写法</h2><p>我们知道，有状态并不是一件很好的事情，无论是对代码重用，还是对代码的并行来说，都是有副作用的。因此，要想个方法把这些状态搞掉，于是出现了函数式编程的编程范式。下面，我们来看看函数式的方式应该怎么写？</p><pre><code>from random import random\n \ndef move_cars(car_positions):\n    return map(lambda x: x + 1 if random() &gt; 0.3 else x,\n               car_positions)\n \ndef output_car(car_position):\n    return '-' * car_position\n \ndef run_step_of_race(state):\n    return {'time': state['time'] - 1,\n            'car_positions': move_cars(state['car_positions'])}\n \ndef draw(state):\n    print ''\n    print '\\n'.join(map(output_car, state['car_positions']))\n \ndef race(state):\n    draw(state)\n    if state['time']:\n        race(run_step_of_race(state))\n \nrace({'time': 5,\n      'car_positions': [1, 1, 1]})\n</code></pre><p>上面的代码依然把程序的逻辑分成了函数。不过这些函数都是函数式的，它们有三个特点：它们之间没有共享的变量；函数间通过参数和返回值来传递数据；在函数里没有临时变量。</p><p>我们还可以看到，for循环被递归取代了（见race函数）—— 递归是函数式编程中常用到的技术，正如前面所说的，递归的本质就是描述问题是什么。</p><h1>函数式语言的三套件</h1><p>函数式语言有三套件，<strong>Map</strong>、<strong>Reduce</strong> 和 <strong>Filter</strong>。这在谈C++的泛型编程时已经介绍过。下面我们来看一下Python语言中的一个示例。这个示例的需求是，我们想把一个字符串数组中的字符串都转成小写。</p><p>用常规的面向过程的方式，代码如下所示：</p><pre><code># 传统的非函数式\nupname =['HAO', 'CHEN', 'COOLSHELL']\nlowname =[] \nfor i in range(len(upname)):\n    lowname.append( upname[i].lower() )\n</code></pre><p>如果写成函数式，用 <code>map()</code> 函数，是下面这个样子。</p><pre><code># 函数式\ndef toUpper(item):\n      return item.upper()\n \nupper_name = map(toUpper, [&quot;hao&quot;, &quot;chen&quot;, &quot;coolshell&quot;])\n\nprint upper_name\n# 输出 ['HAO', 'CHEN', 'COOLSHELL']\n</code></pre><p>顺便说一下，上面的例子是不是和我们C++语言中的STL的<code>transform()</code>函数有些像？</p><pre><code>string s=&quot;hello&quot;;\ntransform(s.begin(), s.end(), back_inserter(out), ::toupper);\n</code></pre><p>在上面Python的那个例子中可以看到，我们定义了一个函数toUpper，这个函数没有改变传进来的值，只是把传进来的值做个简单的操作，然后返回。然后，我们把它用在map函数中，就可以很清楚地描述出我们想要干什么，而不是去理解一个在循环中怎么实现的代码，最终在读了很多循环的逻辑后才发现是什么意思。</p><p>如果你觉得上面的代码在传统的非函数式的方式下还是很容易读的，那么我们再来看一个计算数组平均值的代码：</p><pre><code># 计算数组中正数的平均值\nnum =  [2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]\npositive_num_cnt = 0\npositive_num_sum = 0\nfor i in range(len(num)):\n    if num[i] &gt; 0:\n        positive_num_cnt += 1\n        positive_num_sum += num[i]\n \nif positive_num_cnt &gt; 0:\n    average = positive_num_sum / positive_num_cnt\n \nprint average\n</code></pre><p>上面的代码如果没有注释的话，你需要看一会儿才能明白，只是计算数组中正数的平均值。</p><p>我们再来看看函数式下使用 filter/reduce 函数的玩法。</p><pre><code>#计算数组中正数的平均值\npositive_num = filter(lambda x: x&gt;0, num)\naverage = reduce(lambda x,y: x+y, positive_num) / len( positive_num )\n</code></pre><p>首先，我们使用 filter 函数把正数过滤出来（注意： <code>lambda x : x&gt;0</code> 这个lambda表达式），保存在一个新的数组中 —— <code>positive_num</code>。然后，我们使用 reduce 函数对数组 <code>positive_num</code> 求和后，再除以其个数，就得到正数的平均值了。</p><p>我们可以看到， <strong>隐藏了数组遍历并过滤数组控制流程的 filter 和 reduce， 不仅让代码更为简洁，因为代码里只有业务逻辑了，而且让我们能更容易地理解代码</strong>。</p><ol>\n<li>对 <code>num</code> 数组 <code>filter</code> 条件 <code>x &gt; 0</code> 的数据。</li>\n<li>然后对 <code>positive_num</code> 进行  <code>x + y</code> 操作的 reduce，即求和。</li>\n<li>……</li>\n</ol><p>感觉代码更亲切了，不是吗？因为：</p><ul>\n<li>数据集、对数据的操作和返回值都放在了一起。</li>\n<li>没有了循环体，就可以少了些临时用来控制程序执行逻辑的变量，也少了把数据倒来倒去的控制逻辑。</li>\n<li><strong>代码变成了在描述你要干什么，而不是怎么干</strong>。</li>\n</ul><p>当然，如果你是第一次见到 map/reduce/filter，那你可能还是会有点儿陌生和不解，这只是你不了解罢了。</p><p>对于函数式编程的思路，下图是一个比较形象的例子，面包和蔬菜map到切碎的操作上，再把结果给reduce成汉堡。</p><p><img src=\"https://static001.geekbang.org/resource/image/bf/45/bf01b67b872021c5e159683c61250a45.jpg?wh=1830x1791\" alt=\"\"><br>\n在这个图中，<strong>我们可以看到map和reduce不关心源输入数据，它们只是控制，并不是业务。控制是描述怎么干，而业务是描述要干什么</strong>。</p><h1>函数式的pipeline模式</h1><p>pipeline（管道）借鉴于Unix Shell的管道操作——把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。（注：管道绝对是一个伟大的发明，它的设计哲学就是KISS – 让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装会变得更为简单和直观。这个设计理念影响非常深远，包括今天的Web Service、云计算，以及大数据的流式计算等。）</p><p>比如，我们如下的shell命令：</p><pre><code>ps auwwx | awk '{print $2}' | sort -n | xargs echo\n</code></pre><p>上面的例子是要查看一个用户执行的进程列表，列出来以后，然后取第二列，第二列是它的进程ID，排个序，再把它显示出来。</p><p>抽象成函数式的样子，我们就可以反过来，一层套一层。</p><pre><code>xargs(  echo, sort(n, awk('print $2', ps(auwwx)))  )\n</code></pre><p>我们也可以把函数放进数组里面，然后顺序执行一下。</p><pre><code>pids = for_each(result, [ps_auwwx, awk_p2, sort_n, xargs_echo])\n</code></pre><p>多说一句，如果我们把这些函数比作微服务，那么管道这个事是在干什么呢？其实就是在做服务的编排。像Unix这些经典的技术上的实践或理论，往往是可以反映到分布式架构的，所以，一般来说，一个好的分布式架构师，通常都是对这些传统的微观上的经典技术有非常深刻的认识，因为这些东西在方法论上都是相通的。</p><p>好了，还是让我们用一个简单的示例来看一下如何实现pipeline。</p><p>我们先来看一个程序，这个程序的process()有三个步骤：</p><ol>\n<li>找出偶数；</li>\n<li>乘以3；</li>\n<li>转成字符串返回。</li>\n</ol><p>传统的非函数式的实现如下：</p><pre><code>def process(num):\n    # filter out non-evens\n    if num % 2 != 0:\n        return\n    num = num * 3\n    num = 'The Number: %s' % num\n    return num\n \nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n \nfor num in nums:\n    print process(num)\n    \n# 输出：\n# None\n# The Number: 6\n# None\n# The Number: 12\n# None\n# The Number: 18\n# None\n# The Number: 24\n# None\n# The Number: 30\n</code></pre><p>我们可以看到，输出的结果并不够完美，另外，代码阅读上如果没有注释，你也会比较晕。下面，我们来看看函数式的pipeline（第一种方式）应该怎么写？</p><p>第一步，我们先把三个“子需求”写成函数：</p><pre><code>def even_filter(nums):\n    for num in nums:\n        if num % 2 == 0:\n            yield num\ndef multiply_by_three(nums):\n    for num in nums:\n        yield num * 3\ndef convert_to_string(nums):\n    for num in nums:\n        yield 'The Number: %s' % num\n</code></pre><p>然后，我们再把这三个函数串起来：</p><pre><code>nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\npipeline = convert_to_string(multiply_by_three(even_filter(nums)))\nfor num in pipeline:\n    print num\n# 输出：\n# The Number: 6\n# The Number: 12\n# The Number: 18\n# The Number: 24\n# The Number: 30\n</code></pre><p>上面，我们动用了Python的关键字 yield，它是一个类似 return 的关键字，只是这个函数返回的是Generator（生成器）。所谓生成器，指的是yield返回的是一个可迭代的对象，并没有真正的执行函数。也就是说，只有其返回的迭代对象被迭代时，yield函数才会真正运行，运行到yield语句时就会停住，然后等下一次的迭代。（ yield 是个比较诡异的关键字）这就是lazy evluation（懒惰加载）。</p><p>好了，根据前面的原则——“<strong>使用Map &amp; Reduce，不要使用循环</strong>”（还记得吗？使用循环会让我们只能使用顺序型的数据结构），那我们用比较纯朴的Map &amp; Reduce吧。</p><pre><code>def even_filter(nums):\n    return filter(lambda x: x%2==0, nums)\n \ndef multiply_by_three(nums):\n    return map(lambda x: x*3, nums)\n \ndef convert_to_string(nums):\n    return map(lambda x: 'The Number: %s' % x,  nums)\n \nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\npipeline = convert_to_string(\n               multiply_by_three(\n                   even_filter(nums)\n               )\n            )\nfor num in pipeline:\n    print num\n</code></pre><p>上面的代码是不是更容易读了，但需要嵌套使用函数，这个有点儿令人不爽，如果我们能像下面这个样子就好了（第二种方式）。</p><pre><code>pipeline_func(nums, [even_filter,\n                     multiply_by_three,\n                     convert_to_string])\n</code></pre><p>可以看到，其实，就是对一堆函数做一个reduce， 于是，pipeline函数可以实现成下面这样：</p><pre><code>def pipeline_func(data, fns):\n    return reduce(lambda a, x: x(a),   fns,   data)\n</code></pre><p>当然，使用Python的 <code>force</code> 函数以及decorator模式可以把上面的代码写得更像管道：</p><pre><code>class Pipe(object):\n    def __init__(self, func):\n        self.func = func\n \n    def __ror__(self, other):\n        def generator():\n            for obj in other:\n                if obj is not None:\n                    yield self.func(obj)\n        return generator()\n \n@Pipe\ndef even_filter(num):\n    return num if num % 2 == 0 else None\n \n@Pipe\ndef multiply_by_three(num):\n    return num*3\n \n@Pipe\ndef convert_to_string(num):\n    return 'The Number: %s' % num\n \n@Pipe\ndef echo(item):\n    print item\n    return item\n \ndef force(sqs):\n    for item in sqs: pass\n \nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n \nforce(nums | even_filter | multiply_by_three | convert_to_string | echo)\n</code></pre><h1>小结</h1><p>相对于计算机发展史，函数式编程是个非常古老的概念，它的核心思想是将运算过程尽量写成一系列嵌套的函数调用，关注的是做什么而不是怎么做，因而被称为声明式编程。以Stateless（无状态）和Immutable（不可变）为主要特点，代码简洁，易于理解，能便于进行并行执行，易于做代码重构，函数执行没有顺序上的问题，支持惰性求值，具有函数的确定性——无论在什么场景下都会得到同样的结果。</p><p>这一讲我们结合递归、map和reduce，以及pipeline等技术，对比了非函数式编程和函数式编程在解决相同问题时的不同处理思路，让你对函数式编程范式有了清晰明确的认知。并在文末引入了decorator（修饰器），使得将普通函数管道化成为一件轻而易举的事情。此时你可能有疑问，decorator到底是什么呢？怎样使用它呢？敬请关注下一章中的内容，来得到这些答案。</p><p>了解了这么多函数式编程的知识，想请你深入思考一个问题：你是偏好在命令式编程语言中使用函数式编程风格呢，还是坚持使用函数式语言编程？原因是什么？欢迎在评论区留言和我一起探讨。</p><p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。*</p><ul>\n<li><a href=\"https://time.geekbang.org/column/article/301\">01 | 编程范式游记：起源</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/303\">02 | 编程范式游记：泛型编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2017\">03 | 编程范式游记：类型系统和泛型的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2711\">04 | 编程范式游记：函数式编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2723\">05 | 编程范式游记：修饰器模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2729\">06 | 编程范式游记：面向对象编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2741\">07 | 编程范式游记：基于原型的编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2748\">08 | 编程范式游记：Go 语言的委托模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2751\">09 | 编程范式游记：编程的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2752\">10 | 编程范式游记：逻辑编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2754\">11 | 编程范式游记：程序世界里的编程范式</a></li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/40/18/40341574317cc135385c6946a17d2818.jpg?wh=1082*535\" alt=\"\"></p><p><a href=\"https://time.geekbang.org/activity/sale-poster?utm_source=geektime&utm_medium=chenhao&utm_campaign=201803&utm_content=chenhaofxbanner\">戳此获取你的专属海报</a></p>","comments":[{"had_liked":false,"id":2286,"user_name":"硕根","can_delete":false,"product_type":"c1","uid":1027754,"ip_address":"","ucode":"6C8D33036F76DF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/aa/5d75359c.jpg","comment_is_top":false,"comment_ctime":1516673500,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"160430463452","product_id":100002201,"comment_content":"同样是业务代码的实现（抛开框架，中间件，基础设施的研发），前端更多的是声明式，函数式，反应式的编程，后端更多的是面向过程，事务，对象的编程，不知道皓叔怎么看这种差异的根源？","like_count":38,"discussions":[{"author":{"id":1542630,"avatar":"https://static001.geekbang.org/account/avatar/00/17/89/e6/15deb499.jpg","nickname":"xima","note":"","ucode":"4200245CEB3A02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298655,"discussion_content":"2333333。我记得作者在经常说的，很讨厌“知乎体”，也就是“怎么看xxx”，“怎么评价xxx”。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597371953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1617452,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ae/2c/e00f5de5.jpg","nickname":"🤖","note":"","ucode":"4F373CE1654516","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318786,"discussion_content":"后端响应式编程也逐渐兴起，后端多的面向对象，面向过程也可能是国内比较盛行而已。拿 java 来说，大部分人都停留在 JDK 8，并没有提供太多响应式编程的特性，直到 JDK 9 乃至 JDK11 才逐渐完善，那就只能用流式编程，事实上现在组里的后端能用 stream 也就尽量用，很方便的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603850141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047212,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/ac/6383e8d3.jpg","nickname":"Dr.Strangelove","note":"","ucode":"4DB604323CCAF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312082,"discussion_content":"要看你在什么样的团队里了，之前react里的函数式以及不可变，可那不也是是fb后端工程师写出来的东西么？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602580232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1474326,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7f/16/7f7d6f85.jpg","nickname":"连欣","note":"","ucode":"A10FF3C5A41A26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554516,"discussion_content":"从业务特性来看，客户端的难点在于复杂状态的管理，所以更需要函数式、响应式的方法，去做状态的修改和管理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646410584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052994,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/226NabDEu1IGMN7Om1gQqG22hk2dZKojpB0KDpAK0vtujQLdlgZsVaPbIc4ymcib0NdH3Syh8YibRuL7Lv5kVCkg/132","nickname":"果子","note":"","ucode":"D7B288A3E722F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404862,"discussion_content":"差异的根源就是业务不同啊。前端关注的是可视化界面，与用户的交互，对响应性要求高。后端主要关注的是数据的计算和存储，也就是所谓的业务逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634439020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1266698,"avatar":"https://static001.geekbang.org/account/avatar/00/13/54/0a/9a002ad5.jpg","nickname":"Adam Lau","note":"","ucode":"7E542D6E789500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270282,"discussion_content":"这么好的问题作者不回答一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589987943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":2345,"user_name":"JZ","can_delete":false,"product_type":"c1","uid":1004986,"ip_address":"","ucode":"869A0DB3AC7A0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/ba/d738255c.jpg","comment_is_top":false,"comment_ctime":1516846909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"130365865789","product_id":100002201,"comment_content":"整体设计面向对象，细节能用函数式就用函数式，算法相关过程式。稍微复杂点的场景想使用纯函数式，必然绕不过monad，hkt这样的概念。为了追求函数式风格而把程序写的艰深难懂，我觉得不是一件值得夸耀的事。","like_count":31},{"had_liked":false,"id":3155,"user_name":"minghu6","can_delete":false,"product_type":"c1","uid":1050269,"ip_address":"","ucode":"F44058E21B14C9","user_header":"","comment_is_top":false,"comment_ctime":1518590742,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"87417936662","product_id":100002201,"comment_content":"一直不太明白一点，函数式编程的特点之一就是就是immutable，这就是说函数总是应该返回新的值而不是修改旧的值。但是，如果要处理一个很大的list，深拷贝的代价是不是太大了？<br><br>进一步说，在编程解决实际问题的时候，往往需要依赖第三方的库。一方面大多数的第三方的库往往不是函数式的，引入后就被传染，变成了有状态的，可变的；另一方面，很难找到多少维护良好的通用编程方面的函数式的库。初步学习过common lisp，clojure，以及prolog和erlang，感觉除了这些语言都被局限在了“学术研究”，”语言玩具“，以及由高手组成的小团体的内部“秘密“使用。（erlang还好一些，但是被局限在了很小的领域）。<br><br>最后还是感觉，一门语言，语言特性再好，还是得有杀手级应用，就像支柱产业能带动一大量上下游的发展。就像clojure过去要是没有Storm，可能不会发展这么繁荣。<br><br>个人现在最常用的跟函数式风格有关的还是Java8的stream操作，对于理清思路，减少代码，提高开发效率来说非常有帮助。<br>","like_count":20,"discussions":[{"author":{"id":1050269,"avatar":"","nickname":"minghu6","note":"","ucode":"F44058E21B14C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352583,"discussion_content":"2021.3.3 的我来回答的话， 我当时面临的问题其实是\n我用的LISP不是纯函数，它有修改状态的解决方法。\n而对于纯函数的Haskell，它不存在这样的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614775359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1903827,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0c/d3/84bd965e.jpg","nickname":"戴晓峰","note":"","ucode":"B29C6DF53A416A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350490,"discussion_content":"针对你举的这个list的例子，函数间传输的应该是list中的某一项，而不是整个list，会更加合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613894196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374062,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvTiamekQCgN24eyDEZ8HdAgsEDJUOXpqBhBeMJlB7wBZjKM9QMnzSvSicRbzFibrh2F0qntH0ZibtxQ/132","nickname":"棱角00","note":"","ucode":"6BF4DDAACEEC4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46770,"discussion_content":"函数式编程的特点之一就是就是immutable，这就是说函数总是应该返回新的值而不是修改旧的值。但是，如果要处理一个很大的list，深拷贝的代价是不是太大了？\n结构可以复用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573204659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1067981,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4b/cd/185e5378.jpg","nickname":"泊浮目","note":"","ucode":"182A7CC2F6BDAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3705,"discussion_content":"kotlin和scala也可以用的很爽","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564727322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1062864,"avatar":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","nickname":"aof","note":"","ucode":"5815D63C4926BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1067981,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4b/cd/185e5378.jpg","nickname":"泊浮目","note":"","ucode":"182A7CC2F6BDAB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199484,"discussion_content":"天天写Spark代码，用Scala比用Java真是爽到天上了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583591679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3705,"ip_address":""},"score":199484,"extra":""}]}]},{"had_liked":false,"id":15750,"user_name":"wang","can_delete":false,"product_type":"c1","uid":1156962,"ip_address":"","ucode":"83C8B8D533D974","user_header":"https://static001.geekbang.org/account/avatar/00/11/a7/62/7a4c4a0b.jpg","comment_is_top":false,"comment_ctime":1531446799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"78840858127","product_id":100002201,"comment_content":"在我看来，面向对象编程和函数式编程他们的关注点不一样，面向对象编程帮助你设计更复杂的应用程序，函数式编程帮助你简化更复杂的计算，我身为java后端，一直都是面向对象为主，函数式只是帮助我简化代码。","like_count":18},{"had_liked":false,"id":3083,"user_name":"五柳","can_delete":false,"product_type":"c1","uid":1052391,"ip_address":"","ucode":"B1976EC3CC5E00","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/e7/ff239a4d.jpg","comment_is_top":false,"comment_ctime":1518536717,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"57353111565","product_id":100002201,"comment_content":"有幸得以做自己喜欢的事情。一路走来，先是过程式，后是面向对象式，现在则是函数式。每次转变都感觉焕然一新，思路上了一级台阶。<br><br>函数式能帮我们更容易写出精简、易于复用的代码。优势耗子哥已经写的很详细了。我安利一下，学函数式，一定要了解一下 Elixir，会从新的角度理解编程。比如 Elixir 的 pipeline 的设计绝对会有所启发。<br><br>语言不止是工具。语言和编程范式极大影响了我们的思维。","like_count":13,"discussions":[{"author":{"id":1104850,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/d2/e29f8834.jpg","nickname":"lidashuang","note":"","ucode":"560ABE8032760E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379096,"discussion_content":"elixir很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623680698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1090266,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a2/da/a8a32113.jpg","nickname":"太子长琴","note":"","ucode":"0627D0FA370AD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350663,"discussion_content":"没想到看到熟人了😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613970166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":2300,"user_name":"zcom","can_delete":false,"product_type":"c1","uid":1017059,"ip_address":"","ucode":"70507B19E5B581","user_header":"","comment_is_top":false,"comment_ctime":1516694291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44466367251","product_id":100002201,"comment_content":"之前一直不是很理解函数式编程，直到我看了sicp，推荐朋友们有时间可以去看看。当然在工作中很少用过函数式编程，所以耗子哥最后的问题我答不上来……","like_count":10},{"had_liked":false,"id":8448,"user_name":"mingshun","can_delete":false,"product_type":"c1","uid":1096508,"ip_address":"","ucode":"731C2DCEEBB655","user_header":"","comment_is_top":false,"comment_ctime":1526221667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31590992739","product_id":100002201,"comment_content":"从过程式编程、面向对象编程、函数式编程一路走来，已经回不去了。对比机械化的过程式编程和层级结构复杂的面向对象编程，函数式编程能够很自然地描述现实世界。特别是用了 Elixir 之后，深感世界本应如此。其 pipeline 设计用起来比其他语言更灵活些，加上继承了 Erlang 的面向进程编程，可直接使用 OTP 开发分布式应用，语法更加人性化，还提供宏作为元编程手段，原生函数库也非常丰富。<br>当然也要承认 Elixir 还是很小众。要从底层更多地考虑机器运作的思维向更多地考虑现实问题的思维转换对大部分人来说有难度，毕竟需要转变的还有世界观，而不仅仅是换个编程语言那么简单。","like_count":7},{"had_liked":false,"id":2292,"user_name":"郎哲","can_delete":false,"product_type":"c1","uid":1007926,"ip_address":"","ucode":"EE2F5F061E2F7A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/36/343a8ef8.jpg","comment_is_top":false,"comment_ctime":1516684311,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"22991520791","product_id":100002201,"comment_content":"Erlang程序员<br>默默地走过 只提了一下Erlang…","like_count":5,"discussions":[{"author":{"id":1543599,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8d/af/01deb987.jpg","nickname":"xtepCool","note":"","ucode":"6181687E98524E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336538,"discussion_content":"大厂？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608621379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15339,"user_name":"4Neutrino","can_delete":false,"product_type":"c1","uid":1137181,"ip_address":"","ucode":"364917083B7CC3","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/1d/13dc1937.jpg","comment_is_top":false,"comment_ctime":1531130794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18710999978","product_id":100002201,"comment_content":"耗哥，尾递归的示例代码有一处笔误导致死循环，应为(&gt; counter n)","like_count":4},{"had_liked":false,"id":2596,"user_name":"JK.Ryan","can_delete":false,"product_type":"c1","uid":1014467,"ip_address":"","ucode":"D1E533F3DEC481","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/c3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1517923713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18697792897","product_id":100002201,"comment_content":"很早就读过coolshell里那篇函数式编程，很受教，今天这篇又加了许多干货，很赞，特别是讲到分布式理论和我们微观处理，其实有异曲同工之处，很有共鸣～👍🏾","like_count":4},{"had_liked":false,"id":2346,"user_name":"ryerh","can_delete":false,"product_type":"c1","uid":1042567,"ip_address":"","ucode":"D65B915B1674D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/87/a6110d14.jpg","comment_is_top":false,"comment_ctime":1516847073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18696716257","product_id":100002201,"comment_content":"@硕根<br>我对这种现象的个人理解是，前端的业务特点是“单App、单节点、UI驱动”，后端的业务特点是“多Service、分布式、数据驱动”，业务特点上的不同导致彼此适应的范式不同。","like_count":4},{"had_liked":false,"id":23430,"user_name":"fulljay","can_delete":false,"product_type":"c1","uid":1175456,"ip_address":"","ucode":"F9D8AB0C105F94","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/a0/a2816041.jpg","comment_is_top":false,"comment_ctime":1536369330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14421271218","product_id":100002201,"comment_content":"我做web前端开发的，我觉得面向对象和面向函数，应该结合一起，界面（对象）及对应的事件回调（对象的方法），但到了状态机的处理用pipeline（函数式），所以我会选择在命令式编程语言中使用函数式编程风格","like_count":3},{"had_liked":false,"id":2315,"user_name":"Yano","can_delete":false,"product_type":"c1","uid":1028394,"ip_address":"","ucode":"742EA1602E9A52","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b1/2a/c1432fff.jpg","comment_is_top":false,"comment_ctime":1516754942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14401656830","product_id":100002201,"comment_content":"Java服务端开发，还在使用jdk6。可以说我是完完全全面向对象的思维，对于java 8的函数式编程都没有搞透彻。这篇文章很赞！","like_count":3},{"had_liked":false,"id":222775,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1590910209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10180844801","product_id":100002201,"comment_content":"看了耗子叔的文章，更加想用函数式编程了。高并发利器、代码更易懂、更简洁。","like_count":2},{"had_liked":false,"id":210604,"user_name":"learning","can_delete":false,"product_type":"c1","uid":1236953,"ip_address":"","ucode":"14CE94C24F9C87","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/d9/a90b2488.jpg","comment_is_top":false,"comment_ctime":1587794802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10177729394","product_id":100002201,"comment_content":"函数式编程：输入无状态、不可变，输出结果确定，处理过程易读","like_count":2},{"had_liked":false,"id":101994,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1560089691,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"10150024283","product_id":100002201,"comment_content":"这篇不太容易看懂，拖延了很久。其中的代码能够看懂，但是的确没有在工作中使用过函数式编程的语言，很久以前看过一点点 Lisp。<br><br>之前用过一段 C# 语言，大概是到 .NET Framework 4.0 之后提供了一些类似于 lamda 的语法糖，以及 LINQ 之类的查询，感觉和这里的函数式编程有点类似。不过当时只是在编辑器插件的帮助下，将命令式（过程式）的语言，转换成函数式的。看上去的确简洁了不少，但是感觉调试起来比较困难。<br><br>后来转而使用 Ruby，Ruby 本身也提供了类似于 map, reduce 之类的函数，似乎有函数式编程的影子。<br><br>感觉似乎命令式编程和函数式编程又相互借鉴、互相印证的地方。<br><br>函数式编程可能更适合高性能计算、或分布式领域，因为更容易发挥其优势。","like_count":2},{"had_liked":false,"id":101662,"user_name":"karas","can_delete":false,"product_type":"c1","uid":1349594,"ip_address":"","ucode":"836873D0D9973B","user_header":"https://static001.geekbang.org/account/avatar/00/14/97/da/ae765e15.jpg","comment_is_top":false,"comment_ctime":1559904530,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10149839122","product_id":100002201,"comment_content":"```python3<br>def move_car(car_positions):<br>\treturn  map(lambda x:(x+1) if random() &gt; 0.3 else x,car_positions)<br>```<br>这段代码map出来貌似是`&lt;map object at 0x7fec36218908&gt;`这种对象，导致下一步解析state的时候无法解析，然而如果使用表达式`[x+1 if random() &gt; 0.3 else x for x in car_positions]<br>`就完全没问题返回的还是list，这啥原因，python版本的关系？","like_count":2,"discussions":[{"author":{"id":2066246,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/87/46/125e5997.jpg","nickname":"Thyyyy","note":"","ucode":"EF90097F54784E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376636,"discussion_content":"py3里map返回的是一个迭代器而不是迭代器展开后的list，这样的话是惰性计算，需要下一步也处理迭代器，比如再叠一个map或者用for循环遍历，用习惯的话可以有效节约空间复杂度（因为没有用中间数据结构存储中间结果），这也算是py3对函数式的一种支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622245909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023130,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/9a/150e480e.jpg","nickname":"jay","note":"","ucode":"7D7AF1E9C920BA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70133,"discussion_content":"map的返回值py2py3不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575331279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":5753,"user_name":"大黄","can_delete":false,"product_type":"c1","uid":1029270,"ip_address":"","ucode":"51EB1A5C032253","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/96/d2481b7d.jpg","comment_is_top":false,"comment_ctime":1523924650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10113859242","product_id":100002201,"comment_content":"一直对函数式编程一知半解，耗子哥的讲解实在太棒了，有种顿悟的感觉。","like_count":2},{"had_liked":false,"id":5212,"user_name":"fsj","can_delete":false,"product_type":"c1","uid":1017571,"ip_address":"","ucode":"5DA2B549C9B5FE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/86/e3/28d1330a.jpg","comment_is_top":false,"comment_ctime":1522853662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10112788254","product_id":100002201,"comment_content":"现在有很多语言不仅提供了面向对象功能，也提供了函数式编程的功能（比如Swift），在合适的场景选择合适的编程范式就好，当然，统一的编程范式还是让人赏心悦目的","like_count":2},{"had_liked":false,"id":277984,"user_name":"老袁","can_delete":false,"product_type":"c1","uid":1215637,"ip_address":"","ucode":"0968F54699BCDB","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/95/a6d85a18.jpg","comment_is_top":false,"comment_ctime":1612689940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907657236","product_id":100002201,"comment_content":"为什么一会用这种语言举例，一会用那种语言举例？统一用java不好么？ 很多看不懂的语言反而更看的莫名其妙，不能领悟其精髓","like_count":1},{"had_liked":false,"id":256082,"user_name":"爱学习的大叔","can_delete":false,"product_type":"c1","uid":1085152,"ip_address":"","ucode":"91F9ABF1EC98D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/e0/847348b1.jpg","comment_is_top":false,"comment_ctime":1603522562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898489858","product_id":100002201,"comment_content":"现在理解了前端reduce,map这些函数存在的意义了，面向对象的语言中也可以使用函数式的思想去编程，个人感觉函数式可以让代码变得优雅，但是在处理一些复杂业务逻辑时还是要混用。","like_count":1},{"had_liked":false,"id":255968,"user_name":"Blue","can_delete":false,"product_type":"c1","uid":1495127,"ip_address":"","ucode":"51CF38466A1135","user_header":"https://static001.geekbang.org/account/avatar/00/16/d0/57/d6070ed9.jpg","comment_is_top":false,"comment_ctime":1603469536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898436832","product_id":100002201,"comment_content":"大部分不能减少代码量的函数式都是耍流氓，见了太多强行写函数式的代码，逻辑跳来跳去","like_count":1},{"had_liked":false,"id":105259,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1560949680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855916976","product_id":100002201,"comment_content":"请教下 将运算过程尽量写成一系列嵌套的函数调用,  例如文中的pipeline demo是3个函数进行嵌套，3个函数的入参数都是nums， 我的问题是： pipeline这种编程模型是否要求 所有链式函数中的入参格式都相同，因为入参需要一级一级向下传递","like_count":1},{"had_liked":false,"id":18241,"user_name":"北风一叶","can_delete":false,"product_type":"c1","uid":1087302,"ip_address":"","ucode":"30310E66341D2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","comment_is_top":false,"comment_ctime":1533208230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828175526","product_id":100002201,"comment_content":"定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的<br><br>","like_count":1},{"had_liked":false,"id":10736,"user_name":"衡子","can_delete":false,"product_type":"c1","uid":1109433,"ip_address":"","ucode":"0AED79FC9D14BB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/b9/825b2411.jpg","comment_is_top":false,"comment_ctime":1527681382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5822648678","product_id":100002201,"comment_content":"过程式编程到函数式编程，不是一门语言的转换。写了两年的Scala，回过头来想想，最多的是用到了Scala提供的filter、map等函数，真正用函数思维去设计、处理问题还是少！","like_count":1},{"had_liked":false,"id":5655,"user_name":"昵称","can_delete":false,"product_type":"c1","uid":1025680,"ip_address":"","ucode":"FD6A58AB271E5D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/90/5295fce8.jpg","comment_is_top":false,"comment_ctime":1523711557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5818678853","product_id":100002201,"comment_content":"看了三遍，欲犹未尽，yield也终于搞明白了，感谢","like_count":1},{"had_liked":false,"id":3991,"user_name":"hxx","can_delete":false,"product_type":"c1","uid":1039898,"ip_address":"","ucode":"753A9F27DE1529","user_header":"https://static001.geekbang.org/account/avatar/00/0f/de/1a/4f29dfd3.jpg","comment_is_top":false,"comment_ctime":1521138956,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5816106252","product_id":100002201,"comment_content":"比较好奇就是像spark这种系统，设计思想是基于函数式编程吗","like_count":1,"discussions":[{"author":{"id":2027323,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIyPPFIyvytj0LJrpHicVrTqibuLWLWcR5VqzArSHZicwJYC6gKrIF6GTxx4MakS6xiaxZBCw8icCPB8wQ/132","nickname":"Geek_2e6a7e","note":"","ucode":"BCDD3367AC16FD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298476,"discussion_content":"核心设计（RDD）基于函数式，工程框架基于面向对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597306953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348097,"user_name":"游客","can_delete":false,"product_type":"c1","uid":1340001,"ip_address":"","ucode":"ED85398180B861","user_header":"https://static001.geekbang.org/account/avatar/00/14/72/61/ecdcf6d3.jpg","comment_is_top":false,"comment_ctime":1654739137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654739137","product_id":100002201,"comment_content":"这篇讲得不错","like_count":0},{"had_liked":false,"id":342277,"user_name":"paradox","can_delete":false,"product_type":"c1","uid":2303715,"ip_address":"","ucode":"552B27CF75B7C5","user_header":"https://static001.geekbang.org/account/avatar/00/23/26/e3/06a2ef54.jpg","comment_is_top":false,"comment_ctime":1650166514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650166514","product_id":100002201,"comment_content":"面向对象关注的是类之间的关系以及类本身的职责，抽象层次更高，适用于大的功能模块的抽象。而函数式关心的是具体实现的拆解，细粒度，单一职责。而管道技术，则是对其进行编排，实现业务功能需求。其无状态的特性决定了它更适合处理数据流，而不是处理业务流。至于面向过程，个人觉得对于函数的编排就是面向过程编程。","like_count":0},{"had_liked":false,"id":323079,"user_name":"cv0cv0","can_delete":false,"product_type":"c1","uid":1360093,"ip_address":"","ucode":"93FF9277F03FD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","comment_is_top":false,"comment_ctime":1637722112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637722112","product_id":100002201,"comment_content":"文章中举例的语言的函数式编程没有Kotlin的函数式编程好懂。","like_count":0},{"had_liked":false,"id":322540,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1637474553,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1637474553","product_id":100002201,"comment_content":"race({&#39;time&#39;: 5,  &#39;car_positions&#39;: [1, 1, 1]}) 这个代码有问题，但对 python 不是太了解，这个输出前两次有能打出正常的结果，后面就全部为空了","like_count":0},{"had_liked":false,"id":316946,"user_name":"seedjyh","can_delete":false,"product_type":"c1","uid":2309641,"ip_address":"","ucode":"D590E526A9A1D7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er4IPqj4H3jQHq4C1lgKh6ZroK3CVmGLiadic7S1rxbuy09JM9x8Aib6VkozPkO4lrUTHAhicX1z9Cg2w/132","comment_is_top":false,"comment_ctime":1634624359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634624359","product_id":100002201,"comment_content":"函数式编程容易并发，但对于较大的数据（比如长度100万的数组）就需要多次申请额外堆内存。","like_count":0},{"had_liked":false,"id":262642,"user_name":"Baldwin","can_delete":false,"product_type":"c1","uid":1615836,"ip_address":"","ucode":"7AF0328FEB7336","user_header":"https://static001.geekbang.org/account/avatar/00/18/a7/dc/2438f394.jpg","comment_is_top":false,"comment_ctime":1605789377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605789377","product_id":100002201,"comment_content":"纠正一下，函数式编程是可以有状态的，比如go；如实现斐波那契数列：在初始值确定的情况下，返回函数可以无限生成需要的下一个数。这功能类似于又强于puthon的列表生成式。","like_count":0},{"had_liked":false,"id":257091,"user_name":"🤖","can_delete":false,"product_type":"c1","uid":1617452,"ip_address":"","ucode":"4F373CE1654516","user_header":"https://static001.geekbang.org/account/avatar/00/18/ae/2c/e00f5de5.jpg","comment_is_top":false,"comment_ctime":1603850232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603850232","product_id":100002201,"comment_content":"编程范式系列文章不错，读一次还不大通透，和我的敲的代码不够多有关，得多看几遍了","like_count":0},{"had_liked":false,"id":253673,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1602827710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602827710","product_id":100002201,"comment_content":"在一些编程语言的框架下，控制显得更加简单了，这时候业务就可以单独编写为函数。达到控制和业务的区分。","like_count":0},{"had_liked":false,"id":229654,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1593089003,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1593089003","product_id":100002201,"comment_content":"本来以为按编程语言的发展顺序，这一节应该是讲面向对象，结果是最不熟悉的函数式编程。<br><br>曾经瞅过一眼 a little Lisp，括号实在太多，没有看下去。<br><br>文中使用 Python 进行函数式的编程，看的眼花缭乱。函数式语言的 Map、Reduce 和 Filter 三件套，现在似乎在 C# 和 Java 里面也都有实现。<br><br>我比较偏好在命令式编程语言中使用函数式编程风格，因为感觉上自己似乎更熟悉一些。<br><br>函数式的代码看上去感觉不是很“熟悉”，可能还是因为自己见得太少。<br><br>感觉上，面向过程和面向对象都比较容易和身边的世界联系起来，而面向函数似乎更多的是从计算的角度考虑，对这种思考的角度不是很熟练。","like_count":0},{"had_liked":false,"id":211792,"user_name":"BeginYan","can_delete":false,"product_type":"c1","uid":1082843,"ip_address":"","ucode":"BB06C4712E6383","user_header":"https://static001.geekbang.org/account/avatar/00/10/85/db/f978ddcd.jpg","comment_is_top":false,"comment_ctime":1588007114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588007114","product_id":100002201,"comment_content":"原来自己之前理解的函数式编程是错误的。。","like_count":0},{"had_liked":false,"id":211501,"user_name":"高科","can_delete":false,"product_type":"c1","uid":1107568,"ip_address":"","ucode":"81A4DDF41D3C1C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/70/b9907b0e.jpg","comment_is_top":false,"comment_ctime":1587974261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587974261","product_id":100002201,"comment_content":"函数式编程是个非常古老的概念","like_count":0},{"had_liked":false,"id":183175,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1582967631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582967631","product_id":100002201,"comment_content":"面向过程<br>面向对象<br>面向函数<br>这三种编程范式中，面向对象接触的最多，容易理解，面向函数几乎没怎么接触，不过看示例确实代码更简洁更易懂，受教了。","like_count":0},{"had_liked":false,"id":169116,"user_name":"slark","can_delete":false,"product_type":"c1","uid":1143574,"ip_address":"","ucode":"7E8DE962AA23A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/73/16/595b0342.jpg","comment_is_top":false,"comment_ctime":1578276639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578276639","product_id":100002201,"comment_content":"无状态，不可变。以函数为变量，基于map reduce filter来构造程序，更精确地描述做什么，而不是怎么做。函数式编程首先改变的是编程的思维，要理解它的优点，在实际编码工作中掌握并贯彻运行它是很困难的。go最终也还是面向对象，最多语言层面对函数式提供支持。那么，函数式编程其实只是我们考虑问题的方式，实现是程序员看到的内容。自己能清晰看清楚自己的代码，也是程序员的一种幸福","like_count":0},{"had_liked":false,"id":105377,"user_name":"edisonhuang","can_delete":false,"product_type":"c1","uid":1530167,"ip_address":"","ucode":"BB2F639A779F96","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg","comment_is_top":false,"comment_ctime":1560991197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560991197","product_id":100002201,"comment_content":"相对于过程式的编程方法，强调做的步骤和执行细节，函数式编程则更直观的表达业务，强调做什么而不是怎么做。<br>函数式编程以Stateless（无状态）和 Immutable（不可变）为主要特点。<br>代码简洁，易于理解，能便于进行并行执行，易于做代码重构，函数执行没有顺序上的问题，支持惰性求值，具有函数的确定性——无论在什么场景下都会得到同样的结果","like_count":0},{"had_liked":false,"id":60313,"user_name":"HF","can_delete":false,"product_type":"c1","uid":1060150,"ip_address":"","ucode":"EA504931C0B932","user_header":"https://static001.geekbang.org/account/avatar/00/10/2d/36/d3c8d272.jpg","comment_is_top":false,"comment_ctime":1547457292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547457292","product_id":100002201,"comment_content":"用函数存储运行状态，并且函数是幂等的。不过值之间的copy会占用大量内存。过程式和声明式各有适用场景！","like_count":0},{"had_liked":false,"id":23431,"user_name":"fulljay","can_delete":false,"product_type":"c1","uid":1175456,"ip_address":"","ucode":"F9D8AB0C105F94","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/a0/a2816041.jpg","comment_is_top":false,"comment_ctime":1536369353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536369353","product_id":100002201,"comment_content":"我做web前端开发的，我觉得面向对象和面向函数，应该结合一起，界面（对象）及对应的事件回调（对象的方法），但到了状态机的处理用pipeline（函数式），所以我会选择在命令式编程语言中使用函数式编程风格","like_count":0},{"had_liked":false,"id":17663,"user_name":"DavidHao","can_delete":false,"product_type":"c1","uid":1154165,"ip_address":"","ucode":"6F898BC02D01E5","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/75/7e480131.jpg","comment_is_top":false,"comment_ctime":1532853065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532853065","product_id":100002201,"comment_content":"之前是只管写代码，几乎都是过程式的，我的编程认知都是老耗子哥的博客得来的。","like_count":0},{"had_liked":false,"id":15331,"user_name":"墨汁","can_delete":false,"product_type":"c1","uid":1017522,"ip_address":"","ucode":"8165DD6C968808","user_header":"","comment_is_top":false,"comment_ctime":1531121520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1531121520","product_id":100002201,"comment_content":"最后一个示例能否再解释一下？ 我用python3.5敲了一下发现没法跑。。","like_count":0},{"had_liked":false,"id":3318,"user_name":"balance","can_delete":false,"product_type":"c1","uid":1007182,"ip_address":"","ucode":"324D909BBE69DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/4e/85502e98.jpg","comment_is_top":false,"comment_ctime":1519049258,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1519049258","product_id":100002201,"comment_content":"还是没有理解怎么就是“干什么”，怎么就是“怎么干”","like_count":0,"discussions":[{"author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312828,"discussion_content":"我觉得文中关于 数组对正数求平均数 的例子就很适合解答。\n\n可以看到例子中的过程式编程，先遍历每一个数，遇到正数，则相加，最后求平均值。这是我们传统编程的习惯，可以解答此问题，属于：怎么干。特点是，控制+业务结合才一起。\n\n换一个思路，为了解决这个问题，我们构造一个正数过滤器，一个数组平均器。这些就是：干什么，我们理解为子业务代码。接着，编写控制代码，编写一个流水线，先执行正数过滤器，再执行数组平均器。业务 = 控制+子业务，就可以解答问题了。\n\n这是两种思路的不同，函数式的实现做到控制和业务分析，我觉得更加适合我们思考习惯。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602828512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":2288,"user_name":"👻wusir 👻","can_delete":false,"product_type":"c1","uid":1004693,"ip_address":"","ucode":"050D2921D87C5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/95/25a64f8a.jpg","comment_is_top":false,"comment_ctime":1516680133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1516680133","product_id":100002201,"comment_content":"第一时间来看，感谢皓哥","like_count":0}]}