{"id":281671,"title":"12 | 隔离性：看不见的读写冲突，要怎么处理？","content":"<p>你好，我是王磊，你也可以叫我Ivan。</p><p>我们今天继续聊读写冲突。上一讲我们谈的都是显式的读写冲突，也就是写操作和读操作都在同一时间发生。但其实，还有一种看不见的读写冲突，它是由于时间的不确定性造成的，更加隐蔽，处理起来也更复杂。</p><p>关于时间，我们在<a href=\"https://time.geekbang.org/column/article/274908\">第5讲</a>中已经做了深入讨论，最后我们接受了一个事实，那就是无法在工程层面得到绝对准确的时间。其实，任何度量标准都没有绝对意义上的准确，这是因为量具本身就是有误差的，时间、长度、重量都是这样的。</p><h2>不确定时间窗口</h2><p>那么，时间误差会带来什么问题呢？我们用下面这张图来说明。</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/74/9a6b93299744yye0cbfa6b00b9170474.jpg?wh=2700*915\" alt=\"\"></p><p>我们这里还是沿用上一讲的例子，图中共有7个数据库事务，T1到T7，其中T6是读事务，其他都是写事务。事务T2结束的时间点（记为T2-C）早于事务T6启动的时间点（记为T6-S），这是基于数据记录上的时间戳得出的判断，但实际上这个判断很可能是错的。</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/fe/acbce9810c15354948e4217ef37279fe.jpg?wh=2700*917\" alt=\"\"></p><p>为什么这么说呢？这是因为时间误差的存在，T2-C时间点附近会形成一个不确定时间窗口，也称为置信区间或可信区间。严格来说，我们只能确定T2-C在这个时间窗口内，但无法更准确地判断具体时间点。同样，T6-S也只是一个时间窗口。时间误差不能消除，但可以通过工程方式控制在一定范围内，例如在Spanner中这个不确定时间窗口（记为ɛ）最大不超过7毫秒，平均是4毫秒。</p><!-- [[[read_end]]] --><p>在这个案例中，当我们还原两个时间窗口后，发现两者存在重叠，所以无法判断T2-C与T6-S的先后关系。这真是个棘手的问题，怎么解决呢？</p><p>只有避免时间窗口出现重叠。 那么如何避免重叠呢？</p><p>答案是等待。“waiting out the uncertainty”，用等待来消除不确定性。</p><p>具体怎么做呢？在实践中，我们看到有两种方式可供选择，分别是写等待和读等待。</p><h2>写等待：Spanner</h2><p>Spanner选择了写等待方式，更准确地说是用提交等待（commit-wait）来消除不确定性。</p><p>Spanner是直接将时间误差暴露出来的，所以调用当前时间函数TT.now()时，会获得的是一个区间对象TTinterval。它的两个边界值earliest和latest分别代表了最早可能时间和最晚可能时间，而绝对时间就在这两者之间。另外，Spanner还提供了TT.before()和TT.after()作为辅助函数，其中TT.after()用于判断当前时间是否晚于指定时间。</p><h3>理论等待时间</h3><p>那么，对于一个绝对时间点S，什么时候TT.after(S)为真呢？至少需要等到S + ɛ时刻才可以，这个ɛ就是我们前面说的不确定时间窗口的宽度。我画了张图来帮你理解这个概念。</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/5a/3c2f4aaee4e705cea55e5493027af05a.jpg?wh=2700*1002\" alt=\"\"></p><p>从直觉上说，标识数据版本的“提交时间戳”和事务的真实提交时间应该是一个时间，那么我们推演一下这个过程。有当前事务Ta，已经获得了一个绝对时间S作为“提交时间戳”。Ta在S时刻写盘，保存的时间戳也是S。事务Tb在Ta结束后的S+X时刻启动，获得时间区间的最小值是TT1.earliest。如果X小于时间区间ɛ，则TT1.earliest就会小于S，那么Tb就无法读取到Ta写入的数据。</p><p>你看，Tb在Ta提交后启动却读取不到Ta写入的数据，这显然不符合线性一致性的要求。</p><p><img src=\"https://static001.geekbang.org/resource/image/e1/a1/e11652424523966e9532ba2e3f80fda1.jpg?wh=2700*937\" alt=\"\"></p><p>写等待的处理方式是这样的。事务Ta在获得“提交时间戳”S后，再等待ɛ时间后才写盘并提交事务。真正的提交时间是晚于“提交时间戳”的，中间这段时间就是等待。这样Tb事务启动后，能够得到的最早时间TT2.earliet肯定不会早于S时刻，所以Tb就一定能够读取到Ta。这样就符合线性一致性的要求了。</p><p>综上，事务获得“提交时间戳”后必须等待ɛ时间才能写入磁盘，即commit-wait。</p><p>到这里，写等待算是说清楚了。但是，你仔细想想，有什么不对劲的地方吗？</p><p>对，就是那个绝对时间S。都说了半天时间有误差，那又怎么可能拿到一个绝对时间呢？这不是自相矛盾吗？</p><p>Spanner确实拿不到绝对时间，为了说清楚这个事情，我们稍微延伸一下话题。</p><h3>实际等待时间</h3><p>Spanner将含有写操作的事务定义为读写事务。读写事务的写操作会以两阶段提交（2PC）的方式执行。有关2PC的内容在<a href=\"https://time.geekbang.org/column/article/278949\">第9讲</a>中已经介绍过，如果你已经记不清了，可以去复习一下。</p><p>2PC的第一阶段是预备阶段，每个参与者都会获取一个“预备时间戳”，与数据一起写入日志。第二阶段，协调节点写入日志时需要一个“提交时间戳”，而它必须要大于任何参与者的“预备时间戳”。所以，协调节点调用 TT.now()函数后，要取该时间区间的lastest值（记为s），而且s必须大于所有参与者的“预备时间戳”，作为“提交时间戳”。</p><p>这样，事务从拿到提交时间戳到TT.after(s)为true，实际等待了两个单位的时间误差。我们还是画图来解释一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/52/d500c5b4e7ebd365fa7d3199c5a38e52.jpg?wh=2700*916\" alt=\"\"></p><p>针对同一个数据项，事务T8和T9分别对进行写入和读取操作。T8在绝对时间100ms的时候，调用TT.now()函数，得到一个时间区间[99,103]，选择最大值103作为提交时间戳，而后等待8毫秒（即2ɛ）后提交。</p><p>这样，无论如何T9事务启动时间都晚于T8的“提交时间戳”，也就能读取到T8的更新。</p><p>回顾一下这个过程，第一个时间差是2PC带来的，如果换成其他事务模型也许可以避免，而第二个时间差是真正的commit-wait，来自时间的不确定性，是不能避免的。</p><p>TrueTime的平均误差是4毫秒，commit-wait需要等待两个周期，那Spanner读写事务的平均延迟必然大于等于8毫秒。为啥有人会说Spanner的TPS是125呢？原因就是这个了。其实，这只是事务操作数据出现重叠时的吞吐量，而无关的读写事务是可以并行处理的。</p><p>对数据库来说，8毫秒的延迟虽然不能说短，但对多数场景来说还是能接受的。可是，TrueTime是Google的独门招式，其他分布式数据库怎么办呢？它们的时间误差远大于8毫秒，难道也用commit-wait，那一定是灾难啊！</p><p>这就要说到第二种方式，读等待。</p><h2>读等待：CockroachDB</h2><p>读等待的代表产品是CockroachDB。</p><p>因为CockroachDB采用混合逻辑时钟（HLC），所以对于没有直接关联的事务，只能用物理时钟比较先后关系。CockroachDB各节点的物理时钟使用NTP机制同步，误差在几十至几百毫秒之间，用户可以基于网络情况通过参数”maximum clock offset”设置这个误差，默认配置是250毫秒。</p><p>写等待模式下，所有包含写操作的事务都受到影响，要延后提交；而读等待只在特殊条件下才被触发，影响的范围要小得多。</p><p>那到底是什么特殊条件呢？我们还是使用开篇的那个例子来说明。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/94/5f0a996cc5b59b1aa3c865c1d7eeb694.jpg?wh=2700*1031\" alt=\"\"></p><p>事务T6启动获得了一个时间戳T6-S1，此时虽然事务T2已经在T2-C提交，但T2-C与T6-S1的间隔小于集群的时间偏移量，所以无法判断T6的提交是否真的早于T2。</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/38/3c1cee51d8420cfeac7a447ceac55238.jpg?wh=2700*1019\" alt=\"\"></p><p>这时，CockroachDB的办法是重启（Restart）读操作的事务，就是让T6获得一个更晚的时间戳T6-S2，使得T6-S2与T2-C的间隔大于offset，那么就能读取T2的写入了。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/02/61fb158ecb462e4f7b97951b8ff9be02.jpg?wh=2700*1005\" alt=\"\"></p><p>不过，接下来又出现更复杂的情况， T6-S2与T3的提交时间戳T3-C间隔太近，又落入了T3的不确定时间窗口，所以T6事务还需要再次重启。而T3之后，T6还要重启越过T4的不确定时间窗口。</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/68/c5fddd5dd83df2718637758ac82dd568.jpg?wh=2700*937\" alt=\"\"></p><p>最后，当T6拿到时间戳T6-S4后，终于跳过了所有不确定时间窗口，读等待过程到此结束，T6可以正式开始它的工作了。</p><p>在这个过程中，可以看到读等待的两个特点：一是偶发，只有当读操作与已提交事务间隔小于设置的时间误差时才会发生；二是等待时间的更长，因为事务在重启后可能落入下一个不确定时间窗口，所以也许需要经过多次重启。</p><h2>小结</h2><p>到这里，今天的内容就告一段落了，时间误差的问题比较抽象，你可能会学得比较辛苦，让我帮你整理一下今天内容。</p><ol>\n<li>时间误差是客观存在的，任何系统都不能获得准确的绝对时间，只能得到一个时间区间，差别仅在于有些系统承认这点，而有些系统不承认。</li>\n<li>有两种方式消除时间误差的影响，分别是写等待和读等待。写等待影响范围大，所有包含写操作的事务都要至少等待一个误差周期。读等待的影响范围小，只有当读操作时间戳与访问数据项的提交时间戳落入不确定时间窗口后才会触发，但读等待的周期可能更长，可能是数个误差周期。</li>\n<li>写等待适用于误差很小的系统，Spanner能够将时间误差控制在7毫秒以内，所以有条件使用该方式。读等待适用于误差更大的系统，CockroachDB对误差的预期达到250毫秒。</li>\n</ol><p>总之，处理时间误差的方式就是等待，“waiting out the uncertainty”，等待不确定性过去。你可能觉得写等待和读等待都不完美，但这就是全球化部署的代价。我想你肯定会追问，那为什么要实现全球化部署呢？简单地说，全球化部署最突出的优势就是可以让所有节点都处于工作状态，就近服务客户；而缺失这种能力就只能把所有主副本限制在同机房或者同城机房的范围内，异地机房不具备真正的服务能力，这会带来资源浪费、用户体验下降、切换演练等一系列问题。我会在第24讲专门讨论全球化部署的问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/f4/b2fa54f1221d2dbef83924dyy673f2f4.jpg?wh=2700*1581\" alt=\"\"></p><h2>思考题</h2><p>最后，我要留给你一道思考题。</p><p>今天，我们继续探讨了读写冲突的话题，在引入了时间误差后，整个处理过程变得更复杂了，而无论是“读等待”还是“写等待”都会让系统的性能明显下降。说到底是由多个独立时间源造成的，而多个时间源是为了支持全球化部署。那么，今天的问题就是，你觉得在什么情况下，不用“等待”也能达到线性一致性或因果一致性呢？</p><p>欢迎你在评论区留言和我一起讨论，我会在答疑篇和你继续讨论这个问题。如果你身边的朋友也对时间误差下的读写冲突这个话题感兴趣，你也可以把今天这一讲分享给他，我们一起讨论。</p>","neighbors":{"left":{"article_title":"11｜隔离性：读写冲突时，快照是最好的办法吗？","id":280925},"right":{"article_title":"13 | 隔离性：为什么使用乐观协议的分布式数据库越来越少?","id":282401}},"comments":[{"had_liked":false,"id":246809,"user_name":"_______Harvey凝枫😗","can_delete":false,"product_type":"c1","uid":1693393,"ip_address":"","ucode":"91F03CA28935D1","user_header":"https://static001.geekbang.org/account/avatar/00/19/d6/d1/dc09b604.jpg","comment_is_top":false,"comment_ctime":1599483203,"is_pvip":false,"replies":[{"id":"90695","content":"这个问题本质上是读写操作落入了一个时间置信区间，无法判断是否该读取已写入的数据。写等待是在写入时处理掉这个误差，读取时不再处理；而读等待则相反。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599491644,"ip_address":"","comment_id":246809,"utype":1}],"discussion_count":5,"race_medal":0,"score":"27369286979","product_id":100057401,"comment_content":"有个点看了几遍还是没能理解清楚：这个写等待与读等待  与  具体的事务类型（读写）有关系么：<br>Spanner的写等待只是针对写事务么，那读事务时怎么办？<br>CockroachDB的读等待只是在遇到读事务的时候才进行，那写事务的时候不管吗？","like_count":6,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505233,"discussion_content":"这个问题本质上是读写操作落入了一个时间置信区间，无法判断是否该读取已写入的数据。写等待是在写入时处理掉这个误差，读取时不再处理；而读等待则相反。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599491644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378787,"discussion_content":"写等待过程中，读事物是启动不了？不然读事物的时间点还是落在时间窗口内。这几篇都好难啊，基本看不懂，可能是想象不出来使用场景，没有通俗易懂的例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623400915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1299763,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d5/33/d79fae5c.jpg","nickname":"Hommin","note":"","ucode":"C020CA5DE785DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":403581,"discussion_content":"这也是我纠结了很久的地方，对此我的理解是，此篇主要讨论的读事务中能够扫描到的数据是否应该被读取。而在写的等待过程中，由于写还没有正式提交，读事务自然是扫描不到该部分数据的，因此无需考虑这类情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634112514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378787,"ip_address":""},"score":403581,"extra":""},{"author":{"id":1257418,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","nickname":"梦想的优惠券","note":"","ucode":"D3B44F6C618CA7","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":408024,"discussion_content":"写等待：只要数据写入了，读取的事物就能读取，并发问题，在数据写入的时候就处理了。写数据过程中，读事物是可以读的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635168420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378787,"ip_address":""},"score":408024,"extra":""}]},{"author":{"id":2278559,"avatar":"https://static001.geekbang.org/account/avatar/00/22/c4/9f/a01e4bd1.jpg","nickname":"海浪","note":"","ucode":"091941B3556B4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338636,"discussion_content":"理解了，老师图中左边的是写事务，右边的是读事务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609327556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246454,"user_name":"OliviaHu","can_delete":false,"product_type":"c1","uid":1505322,"ip_address":"","ucode":"7316E79FBFD5ED","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0Qwib3PcoRRxTZSoxAdJ1hELibJeoEqSKP6Ksyu0e7MrGickk1COuv6oQ1w9W2kqM8gUg0Oj057UBw/132","comment_is_top":false,"comment_ctime":1599357712,"is_pvip":false,"replies":[{"id":"90584","content":"回答的很好，说明那个知识掌握的很扎实，点赞。关于这道思考题，我在15讲还留了一个彩蛋，可以关注下^Q^。<br><br>拼写确实错了，谢谢指出，已经请编辑同学帮忙调整了。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599383355,"ip_address":"","comment_id":246454,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27369161488","product_id":100057401,"comment_content":"关于思考题，我想老师的问题已经透露出了答案。时间误差是由多个独立时间源造成的。那么，在“单时间源”的情况下，就能够保证线性或因果一致性。但是，受限于单点，可用性和集群部署范围大大受限。关于可用性，TiDB是通过落盘全局时钟+多个PD构成Raft组来解决。集群部署范围，对于绝大多数公司的应用场景来说，都用不到全球化部署。<br>PS: 老师，TrueTime拼错了。","like_count":7,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505145,"discussion_content":"回答的很好，说明那个知识掌握的很扎实，点赞。关于这道思考题，我在15讲还留了一个彩蛋，可以关注下^Q^。\n\n拼写确实错了，谢谢指出，已经请编辑同学帮忙调整了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599383355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379426,"discussion_content":"同样的疑问，tidb的全局时钟，高位是物理时间，也就是操作系统的毫秒时间，所以误差是不是在 1 毫秒之内？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623900591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1247006,"avatar":"https://static001.geekbang.org/account/avatar/00/13/07/1e/bdbe93f4.jpg","nickname":"尘封","note":"","ucode":"CEE0C006387A03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350635,"discussion_content":"那么，tidb因为是全局时钟，所以不存在这个问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613961809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246888,"user_name":"武功不高","can_delete":false,"product_type":"c1","uid":1072190,"ip_address":"","ucode":"E7EA0A765F87A8","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/3e/a9c91e9f.jpg","comment_is_top":false,"comment_ctime":1599524097,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18779393281","product_id":100057401,"comment_content":"跟谈恋爱一样，距离不一定产生美，但肯定容易引起误会……所以确定关系的两人尽量住的近点，同居最好，最大限度消除误会的可能😄","like_count":4,"discussions":[{"author":{"id":1289588,"avatar":"","nickname":"王俊","note":"","ucode":"007F6848E5C596","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577539,"discussion_content":"共同的时空必然加据冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656168788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1076487,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIKoEicqUZTJly55qoUXRmK4wia7YbnibsMncJaO6tKgKAQNJRfpMsibvfeiaukIibsCsuaic8QjQ3gOoTGA/132","nickname":"张可夫斯基","note":"","ucode":"3B8DF6D98583F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554628,"discussion_content":"文章不是说的避免误会，要拉开距离吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646495495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031970,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bf/22/26530e66.jpg","nickname":"趁早","note":"","ucode":"949FB3AA250D80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304893,"discussion_content":"这类比 ，牛批","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599707532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246674,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1599450261,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5894417557","product_id":100057401,"comment_content":"commit wait是保障rc，因为只需要判断时间戳，可以不用管当前活跃事务，应该是更简洁稳定的实现。读等待是因为没有高精度的时钟，所以不能接受每个写2个时钟误差的延迟，只在有数据冲突的情况下重启后续事务。","like_count":2,"discussions":[{"author":{"id":2250114,"avatar":"https://static001.geekbang.org/account/avatar/00/22/55/82/985411a8.jpg","nickname":"xyx","note":"","ucode":"1AECC9DDAC3D11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335270,"discussion_content":"代码实现简单 但是物理硬件得跟得上..","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608133517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316136,"user_name":"Hommin","can_delete":false,"product_type":"c1","uid":1299763,"ip_address":"","ucode":"C020CA5DE785DB","user_header":"https://static001.geekbang.org/account/avatar/00/13/d5/33/d79fae5c.jpg","comment_is_top":false,"comment_ctime":1634176048,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634176048","product_id":100057401,"comment_content":"关于读等待的事务重启，如果是可重复读级别的数据库，且为多条SQL的事务，该怎么重启？比如SQL1查询了10行数据，业务处理，SQL2在读的时候遇到了不确定时间，那么该怎么办，因为SQL1的数据已经返回给了客户端进行业务处理。是数据库让整个事务失败吗？还是说本文说的根本不包含这类事务？","like_count":0},{"had_liked":false,"id":313744,"user_name":"叶东富","can_delete":false,"product_type":"c1","uid":2687467,"ip_address":"","ucode":"13E15682FAEB37","user_header":"https://static001.geekbang.org/account/avatar/00/29/01/eb/9f066505.jpg","comment_is_top":false,"comment_ctime":1632643601,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632643601","product_id":100057401,"comment_content":"commit-wait原理是事务T在S时刻提交写盘，但是暂时不汇报提交成功。等待e之后，再汇报提交成功，即S+e之后，T才结束。这种情况下，T之后的读，即S+e之后的读，能够确保读出S写入的结果，保证了线性一致性。<br>不是等待e之后再提交写盘，而是提交写盘后等待e再汇报事务T完成。","like_count":1},{"had_liked":false,"id":273549,"user_name":"wy","can_delete":false,"product_type":"c1","uid":1064681,"ip_address":"","ucode":"41C1B304E7F032","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/e9/116f1dee.jpg","comment_is_top":false,"comment_ctime":1610635238,"is_pvip":false,"replies":[{"id":"99151","content":"一个最直接的理由就是数据库要支持时点快照查询。比如，在可重复读隔离级别下，在事务执行过程中任何两个时点，对目标表执行同样的SQL应该得到同样的结果，当然前提是事务本身没有修改目标表。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1610675010,"ip_address":"","comment_id":273549,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610635238","product_id":100057401,"comment_content":"老师，请教一个问题，如果是判断读写冲突的话，根据文中举的例子，直接标记写事务是否完成不就好了吗？为什么要通过时间戳去判断呢？","like_count":0,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513628,"discussion_content":"一个最直接的理由就是数据库要支持时点快照查询。比如，在可重复读隔离级别下，在事务执行过程中任何两个时点，对目标表执行同样的SQL应该得到同样的结果，当然前提是事务本身没有修改目标表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610675010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261170,"user_name":"幼儿编程教学","can_delete":false,"product_type":"c1","uid":1237199,"ip_address":"","ucode":"F13F3150E6CAE9","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/cf/43f201f2.jpg","comment_is_top":false,"comment_ctime":1605233096,"is_pvip":false,"replies":[{"id":"94787","content":"只有读写操作的间隔在全局时钟的误差范围内，才会引发等待。如果采用写等待方式，数据库就不会对读操作再做检验，反之亦然。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1605236874,"ip_address":"","comment_id":261170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605233096","product_id":100057401,"comment_content":"请教老师。这个等待，是因为像上一篇文章中说的，因为操作了相同的数据，所以等待了呢？还是所有事务，不管是否操作相同数据，都要等待？如果不管内容，都要等待，那tps就有极限值了。<br><br>你在文章中说的，spanner，8ms，tps是125，就是同一块数据吧。所以，提交的时候，db还会校验，是否已有未提交的事务操作了相同的数据，是吧？","like_count":0,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509402,"discussion_content":"只有读写操作的间隔在全局时钟的误差范围内，才会引发等待。如果采用写等待方式，数据库就不会对读操作再做检验，反之亦然。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605236874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258641,"user_name":"熊潇","can_delete":false,"product_type":"c1","uid":1851092,"ip_address":"","ucode":"AC5C289573A815","user_header":"","comment_is_top":false,"comment_ctime":1604532512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604532512","product_id":100057401,"comment_content":"请问写等待那里，TA事务从S启动写入到延迟∈之后再启动写入是怎么消除不确定性的呢？TB事务的启动时间确保不早于S+∈才行吧，是TA延迟写如何达到这种效果的呢？","like_count":0},{"had_liked":false,"id":258412,"user_name":"贺","can_delete":false,"product_type":"c1","uid":1047983,"ip_address":"","ucode":"63FCE592EDABC5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/af/ca57c38b.jpg","comment_is_top":false,"comment_ctime":1604416444,"is_pvip":false,"replies":[{"id":"97595","content":"写等待是要确保一个写事务中所有持久化的数据在一条正确的时间线上，也就是保证它们的先后次序是无误的。在任何一点的读操作都不会影响这个处理过程","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1608517428,"ip_address":"","comment_id":258412,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1604416444","product_id":100057401,"comment_content":"读等待我很好理解，就是通过延迟以便能确定读到更新后的值。<br>但是写等待和我理解的不一样，我理解的是让写延迟提交，以便读取的事务确定能读到提交前的值，而不是提交后的值。<br>不知道我理解的哪里有问题？","like_count":0,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508643,"discussion_content":"写等待是要确保一个写事务中所有持久化的数据在一条正确的时间线上，也就是保证它们的先后次序是无误的。在任何一点的读操作都不会影响这个处理过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608517428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2250114,"avatar":"https://static001.geekbang.org/account/avatar/00/22/55/82/985411a8.jpg","nickname":"xyx","note":"","ucode":"1AECC9DDAC3D11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335271,"discussion_content":"写延迟其实也是为了拖过不确定时间 一旦过了那个时间点 之后的读事务就一定能读到之前的写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608133641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/af/ca57c38b.jpg","nickname":"贺","note":"","ucode":"63FCE592EDABC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321386,"discussion_content":"不理解文章这里的观点&#34;写延迟是为了能读到写提交的值&#34; ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604574695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249563,"user_name":"扩散性百万咸面包","can_delete":false,"product_type":"c1","uid":1905171,"ip_address":"","ucode":"6D703D51553B42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","comment_is_top":false,"comment_ctime":1600693728,"is_pvip":false,"replies":[{"id":"93675","content":"你的理解大体上是对的，第一个等待是因为所有参与者各自取写入时间戳，注意不是提交；而提交时间戳要确保大于任何一个写入时间戳。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1603948952,"ip_address":"","comment_id":249563,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600693728","product_id":100057401,"comment_content":"理解了为什么普通读等待等一个误差就行，不理解Spanner要等2个。感觉老师这里还可以说的更详细点。<br><br>我的理解是，等的第一个误差是等所有预备时间戳都已经真正提交，第二个误差就是和之前介绍的一样。","like_count":0,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505956,"discussion_content":"你的理解大体上是对的，第一个等待是因为所有参与者各自取写入时间戳，注意不是提交；而提交时间戳要确保大于任何一个写入时间戳。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603948952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248559,"user_name":"J","can_delete":false,"product_type":"c1","uid":1305483,"ip_address":"","ucode":"B4E3A29857CCFF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIERY97h7dmXWic58E44CdCSx1NicA8oYfuFwgjbsZjAsfblib4551owRibW3zsfCa2K6WAibkzQ50qHmA/132","comment_is_top":false,"comment_ctime":1600221675,"is_pvip":false,"replies":[{"id":"91278","content":"没有写等待时，Ta写盘先于Tb发生，所以Tb有可能读到Ta写的数据，这点你可以再思考一下。这个有可能就是时钟误差的不确定性，它影响了数据一致性。而写等待带来了一个确定性的结果，保证了数据一致性。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1600233418,"ip_address":"","comment_id":248559,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1600221675","product_id":100057401,"comment_content":"老师写等待有个问题不能理解，文中写等待后TB是在S+E启动的，如果TB还是在S+X启动，且X&lt;E，当么当时TA还没落盘，就读不到数据。和之前没有写等待的情况是一样的","like_count":0,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505685,"discussion_content":"没有写等待时，Ta写盘先于Tb发生，所以Tb有可能读到Ta写的数据，这点你可以再思考一下。这个有可能就是时钟误差的不确定性，它影响了数据一致性。而写等待带来了一个确定性的结果，保证了数据一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600233418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1305483,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIERY97h7dmXWic58E44CdCSx1NicA8oYfuFwgjbsZjAsfblib4551owRibW3zsfCa2K6WAibkzQ50qHmA/132","nickname":"J","note":"","ucode":"B4E3A29857CCFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306287,"discussion_content":"好的，谢谢老师，基本能理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600239754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248282,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1031113,"ip_address":"","ucode":"5948D359734193","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/c9/37924ad4.jpg","comment_is_top":false,"comment_ctime":1600089323,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1600089323","product_id":100057401,"comment_content":"所以，这一讲的前提是，集群部署(高大上点，全球部署)，且集群中有多个数据源，且各个数据源各自都要支持读写事务！<br>所以在各个数据源间，如何保证各个事务逻辑上的一致性，因果性？<br>而谷歌因为牛叉，可以保证在复杂集群环境下，各个数据源服务器时间误差在7毫秒平均4毫秒！所以他们可以按照这个可信区间，去落地读等待方案，还是写等待方案都可以<br>而其他公司保证不了这个基础设施的牛叉性，所以要用raft之类的协议弥补这个能力缺失，进而达到集群中事务后数据的一致性因果性的逻辑正确","like_count":0,"discussions":[{"author":{"id":1161637,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b9/a5/c16157b6.jpg","nickname":"Young","note":"","ucode":"343332673F1A35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337702,"discussion_content":"raft跟事务的隔离性有啥关系？raft是共识协议，确定同一个分片里的副本的一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609050985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2250114,"avatar":"https://static001.geekbang.org/account/avatar/00/22/55/82/985411a8.jpg","nickname":"xyx","note":"","ucode":"1AECC9DDAC3D11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335274,"discussion_content":"不是使用raft协议弥补&#34;多时间源4ms内误差&#34;\n而是干脆不进行全球化部署, 例如tidb leader一般都在一个机房内.\n多时间源误差小只能更容易的弥补&#34;因为时钟误差带来的不一致&#34;\nraft是用来保证多副本数据的一致性 两个点不一样哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608133892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246910,"user_name":"myrfy","can_delete":false,"product_type":"c1","uid":1169401,"ip_address":"","ucode":"2814BAE5D70098","user_header":"","comment_is_top":false,"comment_ctime":1599528818,"is_pvip":false,"replies":[{"id":"90716","content":"4ms是Google官方给出的TrueTime的误差均值。后面的计算也都是基于均值的。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599538152,"ip_address":"","comment_id":246910,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1599528818","product_id":100057401,"comment_content":"spanner的e为什么是4ms呢？如果误差区间在±7ms，可靠的时间窗口就应该是14ms了 所以怎么理解这个误差呢？","like_count":0,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505256,"discussion_content":"4ms是Google官方给出的TrueTime的误差均值。后面的计算也都是基于均值的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599538152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1158138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ab/fa/2967c8eb.jpg","nickname":"zhcc","note":"","ucode":"2AB9D306DBFAC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328952,"discussion_content":"我也很好奇这个问题，8ms只能保证评论没问题不能保证较差情况下没问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606282956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}