{"id":510495,"title":"21｜DI Container（9）：怎样重构测试代码？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code>ContextConfig.java:\n\npackage geektime.tdd.di;\n\nimport java.util.*;\nimport static java.util.List.of;\n\npublic class ContextConfig {\n    private Map&lt;Class&lt;?&gt;, ComponentProvider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n    \n    public &lt;Type&gt; void bind(Class&lt;Type&gt; type, Type instance) {\n        providers.put(type, new ComponentProvider&lt;Type&gt;() {\n            @Override\n            public Type get(Context context) {\n                return instance;\n            }\n            @Override\n            public List&lt;Class&lt;?&gt;&gt; getDependencies() {\n                return of();\n            }\n        });\n    }\n    \n    public &lt;Type, Implementation extends Type&gt;\n    void bind(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation) {\n        providers.put(type, new ConstructorInjectionProvider&lt;&gt;(implementation));\n    }\n    \n    public Context getContext() {\n        providers.keySet().forEach(component -&gt; checkDependencies(component, new Stack&lt;&gt;()));\n        return new Context() {\n            @Override\n            public &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type) {\n                return Optional.ofNullable(providers.get(type)).map(provider -&gt; (Type) provider.get(this));\n            }\n        };\n    }\n    \n    private void checkDependencies(Class&lt;?&gt; component, Stack&lt;Class&lt;?&gt;&gt; visiting) {\n        for (Class&lt;?&gt; dependency: providers.get(component).getDependencies()) {\n            if (!providers.containsKey(dependency)) throw new DependencyNotFoundException(component, dependency);\n            if (visiting.contains(dependency)) throw new CyclicDependenciesFoundException(visiting);\n            visiting.push(dependency);\n            checkDependencies(dependency, visiting);\n            visiting.pop();\n        }\n    }\n    \n    interface ComponentProvider&lt;T&gt; {\n        T get(Context context);\n        List&lt;Class&lt;?&gt;&gt; getDependencies();\n    }\n}\n\nConstructorInjectionProvider.java:\n\npackage geektime.tdd.di;\n\nimport jakarta.inject.Inject;\nimport java.lang.reflect.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Stream.concat;\n\nclass ConstructorInjectionProvider&lt;T&gt; implements ContextConfig.ComponentProvider&lt;T&gt; {\n    private Constructor&lt;T&gt; injectConstructor;\n    private List&lt;Field&gt; injectFields;\n    private List&lt;Method&gt; injectMethods;\n    \n    public ConstructorInjectionProvider(Class&lt;T&gt; component) {\n        this.injectConstructor = getInjectConstructor(component);\n        this.injectFields = getInjectFields(component);\n        this.injectMethods = getInjectMethods(component);\n    }\n\n    @Override\n    public T get(Context context) {\n        try {\n            Object[] dependencies = stream(injectConstructor.getParameters())\n                    .map(p -&gt; context.get(p.getType()).get())\n                    .toArray(Object[]::new);\n            T instance = injectConstructor.newInstance(dependencies);\n            for (Field field : injectFields)\n                field.set(instance, context.get(field.getType()).get());\n            for (Method method : injectMethods)\n                method.invoke(instance, stream(method.getParameterTypes()).map(t -&gt; context.get(t).get())\n                        .toArray(Object[]::new));\n            return instance;\n        } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public List&lt;Class&lt;?&gt;&gt; getDependencies() {\n        return concat(concat(stream(injectConstructor.getParameters()).map(Parameter::getType),\n                        injectFields.stream().map(Field::getType)),\n                injectMethods.stream().flatMap(m -&gt; stream(m.getParameterTypes()))\n        ).toList();\n    }\n    \n    private static &lt;T&gt; List&lt;Method&gt; getInjectMethods(Class&lt;T&gt; component) {\n        List&lt;Method&gt; injectMethods = new ArrayList&lt;&gt;();\n        Class&lt;?&gt; current = component;\n        while(current != Object.class) {\n            injectMethods.addAll(stream(current.getDeclaredMethods()).filter(m -&gt; m.isAnnotationPresent(Inject.class))\n                            .filter(m -&gt; injectMethods.stream().noneMatch(o -&gt; o.getName().equals(m.getName()) &amp;&amp;\n                                    Arrays.equals(o.getParameterTypes(), m.getParameterTypes())))\n                            .filter(m -&gt; stream(component.getDeclaredMethods()).filter(m1 -&gt; !m1.isAnnotationPresent(Inject.class))\n                                    .noneMatch(o -&gt; o.getName().equals(m.getName()) &amp;&amp;\n                                            Arrays.equals(o.getParameterTypes(), m.getParameterTypes())))\n                    .toList());\n            current = current.getSuperclass();\n        }\n        Collections.reverse(injectMethods);\n        return injectMethods;\n    }\n\n    private static &lt;T&gt; List&lt;Field&gt; getInjectFields(Class&lt;T&gt; component) {\n        List&lt;Field&gt; injectFields = new ArrayList&lt;&gt;();\n        Class&lt;?&gt; current = component;\n        while (current != Object.class) {\n            injectFields.addAll(stream(current.getDeclaredFields()).filter(f -&gt; f.isAnnotationPresent(Inject.class))\n                    .toList());\n            current = current.getSuperclass();\n        }\n        return injectFields;\n    }\n    \n    private static &lt;Type&gt; Constructor&lt;Type&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n        List&lt;Constructor&lt;?&gt;&gt; injectConstructors = stream(implementation.getConstructors())\n                .filter(c -&gt; c.isAnnotationPresent(Inject.class)).collect(Collectors.toList());\n        if (injectConstructors.size() &gt; 1) throw new IllegalComponentException();\n        return (Constructor&lt;Type&gt;) injectConstructors.stream().findFirst().orElseGet(() -&gt; {\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new IllegalComponentException();\n            }\n        });\n    }\n}\n\nContext.java:\npackage geektime.tdd.di;\n\nimport java.util.Optional;\n\npublic interface Context {\n    &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type);\n}\n</code></pre><p>测试代码为：</p><pre><code>package geektime.tdd.di;\nimport jakarta.inject.Inject;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.platform.commons.annotation.Testable;\nimport org.mockito.Mockito;\nimport org.mockito.internal.util.collections.Sets;\nimport java.util.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.ArgumentMatchers.eq;\npublic class ContainerTest {\n    ContextConfig config;\n    @BeforeEach\n    public void setup() {\n        config = new ContextConfig();\n    }\n    @Nested\n    public class ComponentConstruction {\n        @Test\n        public void should_bind_type_to_a_specific_instance() {\n            Component instance = new Component() {\n            };\n            config.bind(Component.class, instance);\n            Context context = config.getContext();\n            assertSame(instance, context.get(Component.class).get());\n        }\n\n        @Test\n        public void should_return_empty_if_component_not_defined() {\n            Optional&lt;Component&gt; component = config.getContext().get(Component.class);\n            assertTrue(component.isEmpty());\n        }\n        @Nested\n        public class ConstructorInjection {\n            //TODO: abstract class\n            //TODO: interface\n            @Test\n            public void should_bind_type_to_a_class_with_default_constructor() {\n                config.bind(Component.class, ComponentWithDefaultConstructor.class);\n                Component instance = config.getContext().get(Component.class).get();\n                assertNotNull(instance);\n                assertTrue(instance instanceof ComponentWithDefaultConstructor);\n            }\n            @Test\n            public void should_bind_type_to_a_class_with_inject_constructor() {\n                Dependency dependency = new Dependency() {\n                };\n                config.bind(Component.class, ComponentWithInjectConstructor.class);\n                config.bind(Dependency.class, dependency);\n                Component instance = config.getContext().get(Component.class).get();\n                assertNotNull(instance);\n                assertSame(dependency, ((ComponentWithInjectConstructor) instance).getDependency());\n            }\n            @Test\n            public void should_bind_type_to_a_class_with_transitive_dependencies() {\n                config.bind(Component.class, ComponentWithInjectConstructor.class);\n                config.bind(Dependency.class, DependencyWithInjectConstructor.class);\n                config.bind(String.class, &quot;indirect dependency&quot;);\n                Component instance = config.getContext().get(Component.class).get();\n                assertNotNull(instance);\n                Dependency dependency = ((ComponentWithInjectConstructor) instance).getDependency();\n                assertNotNull(dependency);\n                assertEquals(&quot;indirect dependency&quot;, ((DependencyWithInjectConstructor) dependency).getDependency());\n            }\n            @Test\n            public void should_throw_exception_if_multi_inject_constructors_provided() {\n                assertThrows(IllegalComponentException.class, () -&gt; {\n                    config.bind(Component.class, ComponentWithMultiInjectConstructors.class);\n                });\n            }\n            @Test\n            public void should_throw_exception_if_no_inject_nor_default_constructor_provided() {\n                assertThrows(IllegalComponentException.class, () -&gt; {\n                    config.bind(Component.class, ComponentWithNoInjectConstructorNorDefaultConstructor.class);\n                });\n            }\n            @Test\n            public void should_throw_exception_if_dependency_not_found() {\n                config.bind(Component.class, ComponentWithInjectConstructor.class);\n                DependencyNotFoundException exception = assertThrows(DependencyNotFoundException.class, () -&gt; config.getContext());\n                assertEquals(Dependency.class, exception.getDependency());\n                assertEquals(Component.class, exception.getComponent());\n            }\n            @Test\n            public void should_throw_exception_if_transitive_dependency_not_found() {\n                config.bind(Component.class, ComponentWithInjectConstructor.class);\n                config.bind(Dependency.class, DependencyWithInjectConstructor.class);\n                DependencyNotFoundException exception = assertThrows(DependencyNotFoundException.class, () -&gt; config.getContext());\n                assertEquals(String.class, exception.getDependency());\n                assertEquals(Dependency.class, exception.getComponent());\n            }\n            @Test\n            public void should_throw_exception_if_cyclic_dependencies_found() {\n                config.bind(Component.class, ComponentWithInjectConstructor.class);\n                config.bind(Dependency.class, DependencyDependedOnComponent.class);\n                CyclicDependenciesFoundException exception = assertThrows(CyclicDependenciesFoundException.class, () -&gt; config.getContext());\n                Set&lt;Class&lt;?&gt;&gt; classes = Sets.newSet(exception.getComponents());\n                assertEquals(2, classes.size());\n                assertTrue(classes.contains(Component.class));\n                assertTrue(classes.contains(Dependency.class));\n            }\n            @Test\n            public void should_throw_exception_if_transitive_cyclic_dependencies_found() {\n                config.bind(Component.class, ComponentWithInjectConstructor.class);\n                config.bind(Dependency.class, DependencyDependedOnAnotherDependency.class);\n                config.bind(AnotherDependency.class, AnotherDependencyDependedOnComponent.class);\n                CyclicDependenciesFoundException exception = assertThrows(CyclicDependenciesFoundException.class, () -&gt; config.getContext());\n                List&lt;Class&lt;?&gt;&gt; components = Arrays.asList(exception.getComponents());\n                assertEquals(3, components.size());\n                assertTrue(components.contains(Component.class));\n                assertTrue(components.contains(Dependency.class));\n                assertTrue(components.contains(AnotherDependency.class));\n            }\n        }\n        @Nested\n        public class FieldInjection {\n            static class ComponentWithFieldInjection {\n                @Inject\n                Dependency dependency;\n            }\n            static class SubclassWithFieldInjection extends ComponentWithFieldInjection {\n            }\n            @Test\n            public void should_inject_dependency_via_field() {\n                Dependency dependency = new Dependency() {\n                };\n                config.bind(Dependency.class, dependency);\n                config.bind(ComponentWithFieldInjection.class, ComponentWithFieldInjection.class);\n                ComponentWithFieldInjection component = config.getContext().get(ComponentWithFieldInjection.class).get();\n                assertSame(dependency, component.dependency);\n            }\n            @Test\n            public void should_inject_dependency_via_superclass_inject_field() {\n                Dependency dependency = new Dependency() {\n                };\n                config.bind(Dependency.class, dependency);\n                config.bind(SubclassWithFieldInjection.class, SubclassWithFieldInjection.class);\n                SubclassWithFieldInjection component = config.getContext().get(SubclassWithFieldInjection.class).get();\n                assertSame(dependency, component.dependency);\n            }\n            //TODO throw exception if field is final\n            @Test\n            public void should_include_field_dependency_in_dependencies() {\n                ConstructorInjectionProvider&lt;ComponentWithFieldInjection&gt; provider = new ConstructorInjectionProvider&lt;&gt;(ComponentWithFieldInjection.class);\n                assertArrayEquals(new Class&lt;?&gt;[]{Dependency.class}, provider.getDependencies().toArray(Class&lt;?&gt;[]::new));\n            }\n        }\n        @Nested\n        public class MethodInjection {\n            static class InjectMethodWithNoDependency {\n                boolean called = false;\n                @Inject\n                void install() {\n                    this.called = true;\n                }\n            }\n            @Test\n            public void should_call_inject_method_even_if_no_dependency_declared() {\n                config.bind(InjectMethodWithNoDependency.class, InjectMethodWithNoDependency.class);\n                InjectMethodWithNoDependency component = config.getContext().get(InjectMethodWithNoDependency.class).get();\n                assertTrue(component.called);\n            }\n            static class InjectMethodWithDependency {\n                Dependency dependency;\n                @Inject\n                void install(Dependency dependency) {\n                    this.dependency = dependency;\n                }\n            }\n            @Test\n            public void should_inject_dependency_via_inject_method() {\n                Dependency dependency = new Dependency() {\n                };\n                config.bind(Dependency.class, dependency);\n                config.bind(InjectMethodWithDependency.class, InjectMethodWithDependency.class);\n                InjectMethodWithDependency component = config.getContext().get(InjectMethodWithDependency.class).get();\n                assertSame(dependency, component.dependency);\n            }\n            static class SuperClassWithInjectMethod {\n                int superCalled = 0;\n                @Inject\n                void install() {\n                    superCalled++;\n                }\n            }\n            static class SubclassWithInjectMethod extends SuperClassWithInjectMethod {\n                int subCalled = 0;\n                @Inject\n                void installAnother() {\n                    subCalled = superCalled + 1;\n                }\n            }\n            @Test\n            public void should_inject_dependencies_via_inject_method_from_superclass() {\n                config.bind(SubclassWithInjectMethod.class, SubclassWithInjectMethod.class);\n                SubclassWithInjectMethod component = config.getContext().get(SubclassWithInjectMethod.class).get();\n                assertEquals(1, component.superCalled);\n                assertEquals(2, component.subCalled);\n            }\n            static class SubclassOverrideSuperClassWithInject extends SuperClassWithInjectMethod {\n                @Inject\n                void install() {\n                    super.install();\n                }\n            }\n            @Test\n            public void should_only_call_once_if_subclass_override_inject_method_with_inject() {\n                config.bind(SubclassOverrideSuperClassWithInject.class, SubclassOverrideSuperClassWithInject.class);\n                SubclassOverrideSuperClassWithInject component = config.getContext().get(SubclassOverrideSuperClassWithInject.class).get();\n                assertEquals(1, component.superCalled);\n            }\n            static class SubclassOverrideSuperClassWithNoInject extends SuperClassWithInjectMethod {\n                void install() {\n                    super.install();\n                }\n            }\n            @Test\n            public void should_not_call_inject_method_if_override_with_no_inject() {\n                config.bind(SubclassOverrideSuperClassWithNoInject.class, SubclassOverrideSuperClassWithNoInject.class);\n                SubclassOverrideSuperClassWithNoInject component = config.getContext().get(SubclassOverrideSuperClassWithNoInject.class).get();\n                assertEquals(0, component.superCalled);\n            }\n            @Test\n            public void should_include_dependencies_from_inject_method() {\n                ConstructorInjectionProvider&lt;InjectMethodWithDependency&gt; provider = new ConstructorInjectionProvider&lt;&gt;(InjectMethodWithDependency.class);\n                assertArrayEquals(new Class&lt;?&gt;[]{Dependency.class}, provider.getDependencies().toArray(Class&lt;?&gt;[]::new));\n            }\n            //TODO throw exception if type parameter defined\n        }\n    }\n    @Nested\n    public class DependenciesSelection {\n    }\n    @Nested\n    public class LifecycleManagement {\n    }\n}\ninterface Component {\n}\ninterface Dependency {\n}\ninterface AnotherDependency {\n}\nclass ComponentWithDefaultConstructor implements Component {\n    public ComponentWithDefaultConstructor() {\n    }\n}\nclass ComponentWithInjectConstructor implements Component {\n    private Dependency dependency;\n    @Inject\n    public ComponentWithInjectConstructor(Dependency dependency) {\n        this.dependency = dependency;\n    }\n    public Dependency getDependency() {\n        return dependency;\n    }\n}\nclass ComponentWithMultiInjectConstructors implements Component {\n    @Inject\n    public ComponentWithMultiInjectConstructors(String name, Double value) {\n    }\n    @Inject\n    public ComponentWithMultiInjectConstructors(String name) {\n    }\n}\nclass ComponentWithNoInjectConstructorNorDefaultConstructor implements Component {\n    public ComponentWithNoInjectConstructorNorDefaultConstructor(String name) {\n    }\n}\nclass DependencyWithInjectConstructor implements Dependency {\n    private String dependency;\n    @Inject\n    public DependencyWithInjectConstructor(String dependency) {\n        this.dependency = dependency;\n    }\n    public String getDependency() {\n        return dependency;\n    }\n}\nclass DependencyDependedOnComponent implements Dependency {\n    private Component component;\n    @Inject\n    public DependencyDependedOnComponent(Component component) {\n        this.component = component;\n    }\n}\nclass AnotherDependencyDependedOnComponent implements AnotherDependency {\n    private Component component;\n    @Inject\n    public AnotherDependencyDependedOnComponent(Component component) {\n        this.component = component;\n    }\n}\nclass DependencyDependedOnAnotherDependency implements Dependency {\n    private AnotherDependency anotherDependency;\n    @Inject\n    public DependencyDependedOnAnotherDependency(AnotherDependency anotherDependency) {\n        this.anotherDependency = anotherDependency;\n    }\n}\n</code></pre><p>任务列表状态为：</p><ul>\n<li>\n<p><s>无需构造的组件——组件实例</s></p>\n</li>\n<li>\n<p>如果注册的组件不可实例化，则抛出异常</p>\n<ul>\n<li>抽象类</li>\n<li>接口</li>\n</ul>\n</li>\n<li>\n<p><s>构造函数注入</s></p>\n<ul>\n<li><s>无依赖的组件应该通过默认构造函数生成组件实例</s></li>\n<li><s>有依赖的组件，通过Inject标注的构造函数生成组件实例</s></li>\n<li><s>如果所依赖的组件也存在依赖，那么需要对所依赖的组件也完成依赖注入</s></li>\n<li><s>如果组件有多于一个Inject标注的构造函数，则抛出异常</s></li>\n<li><s>如果组件没有Inject标注的构造函数，也没有默认构造函数（新增任务）</s></li>\n<li><s>如果组件需要的依赖不存在，则抛出异常</s></li>\n<li><s>如果组件间存在循环依赖，则抛出异常</s></li>\n</ul>\n</li>\n<li>\n<p>字段注入</p>\n<ul>\n<li><s>通过Inject标注将字段声明为依赖组件</s></li>\n<li>如果字段为final则抛出异常</li>\n<li><s>依赖中应包含Inject Field声明的依赖</s></li>\n</ul>\n</li>\n<li>\n<p>方法注入</p>\n<ul>\n<li><s>通过Inject标注的方法，其参数为依赖组件</s></li>\n<li><s>通过Inject标注的无参数方法，会被调用</s></li>\n<li><s>按照子类中的规则，覆盖父类中的Inject方法</s></li>\n<li>如果方法定义类型参数，则抛出异常</li>\n<li><s>依赖中应包含Inject Method声明的依赖</s></li>\n</ul>\n</li>\n<li>\n<p>对Provider类型的依赖</p>\n<ul>\n<li>注入构造函数中可以声明对于Provider的依赖</li>\n<li>注入字段中可以声明对于Provider的依赖</li>\n<li>注入方法中可声明对于Provider的依赖</li>\n</ul>\n</li>\n<li>\n<p>自定义Qualifier的依赖</p>\n<ul>\n<li>注册组件时，可额外指定Qualifier</li>\n<li>注册组件时，可从类对象上提取Qualifier</li>\n<li>寻找依赖时，需同时满足类型与自定义Qualifier标注</li>\n<li>支持默认Qualifier——Named</li>\n</ul>\n</li>\n<li>\n<p>Singleton生命周期</p>\n<ul>\n<li>注册组件时，可额外指定是否为Singleton</li>\n<li>注册组件时，可从类对象上提取Singleton标注</li>\n<li>对于包含Singleton标注的组件，在容器范围内提供唯一实例</li>\n<li>容器组件默认不是Single生命周期</li>\n</ul>\n</li>\n<li>\n<p>自定义Scope标注</p>\n<ul>\n<li>可向容器注册自定义Scope标注的回调</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><h2>视频演示</h2><p>让我们进入今天的部分：</p><p><video poster=\"https://media001.geekbang.org/696c2db8d7ed4e58ad8b87e0fcfd235b/snapshots/6c69fdc191f94bc887a8480660396d63-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/700b4c1-180600571dc-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/f641b9ca24014bf2af5f1fb1eadb3bc8/6d4d68135fc7425d928dda9089f775d2-b830b25fe255cc1324212963d40cc4c8-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>在进入下节课之前，希望你能认真思考如下两个问题，并选择最有感触的一道进行回答。</p><ol>\n<li>要怎样将大粒度的测试，重构为等效的小粒度测试代码？可以分享一下你的大致思路。</li>\n<li>请对比一下重构前后的代码结构，体会其中的改变。这会让你逐渐养成习惯，建立重构的大局观。</li>\n</ol><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码的链接分享出来。相信经过你的思考与实操，学习效果会更好！</p>","neighbors":{"left":{"article_title":"20｜DI Container（8）：如何实现Method Injection部分的功能？","id":510492},"right":{"article_title":"22｜DI Container（10）：怎样将大粒度的测试重构为等效的小粒度测试代码？","id":510503}},"comments":[{"had_liked":false,"id":344400,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1651507211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5946474507","product_id":100109401,"comment_content":"- 通过 TDD 获得的测试，可以驱动我们的开发，但不代表获得的是一个良好的 Test Case 组合<br>- TDD 主要是为我们开发生产代码提供驱动力<br>- 天然得出的结果并不能认为是很好的 Test Case<br>- 所以需要对 Test Case 进行重构<br>  - 消除在构造 TDD 过程中留下的不一样的印记（架构选择、设计决策等）<br>  - 使 Test Case 能真实反应代码的意图<br>  - 按测试意图将零散的测试方法收集到一起（放入同一个 Nested 中或者单独的测试类中）<br>  - 同一个上下文中，测试粒度尽量保持一致<br>  - 清理没有用的测试","like_count":2},{"had_liked":false,"id":344350,"user_name":"枫中的刀剑","can_delete":false,"product_type":"c1","uid":1322387,"ip_address":"","ucode":"4B086F538184AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/93/0f1cbf44.jpg","comment_is_top":false,"comment_ctime":1651485318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5946452614","product_id":100109401,"comment_content":"本篇总结：<br>测试重构的目的：让TDD的 Test Case 更好的反映出我们代码的意图，而不仅仅是单纯展示实现功能的过程。<br>测试代码的坏味道：<br>主要体现在「不一致」。<br>1. 设计决策变化导致的测试冗余。<br>2. 同类型功能不同架构选择导致的不一致。（同一类功能测试中包含不同上下文）<br>3. 不同功能，相似结构的测试中表现的不一致。其中某些特有功能可能不在属于当前上下文。（这种情况稍微难发现一些）。<br><br>体会：测试的重构也很重要，结构优良的Test Case 更加清晰地呈现实现代码的真实意图。","like_count":0},{"had_liked":false,"id":346800,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1653443433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653443433","product_id":100109401,"comment_content":"才知道TDD寫過的cases要重新組織，之前看到的TDD介紹太淺，都未提過。<br>請教老師，developer寫的test cases的好標準是啥？有延展閱讀嗎？","like_count":0},{"had_liked":false,"id":343994,"user_name":"Flynn","can_delete":false,"product_type":"c1","uid":1174517,"ip_address":"","ucode":"293321CC198C0C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aY5QA2COoiaGy7P3MJzUIam3GG94GpA0fTx8yJN3OyBiaP3eNL65ia99H4RbaqC4fypg7JhBOujlJs7bBTdJKdMUQ/132","comment_is_top":false,"comment_ctime":1651160907,"is_pvip":false,"replies":[{"id":"125616","content":"回用","user_name":"作者回复","user_name_real":"编辑","uid":"2537798","ctime":1651220586,"ip_address":"","comment_id":343994,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651160907","product_id":100109401,"comment_content":"DI这个项目会在下个项目用上不","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568746,"discussion_content":"回用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651220586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}