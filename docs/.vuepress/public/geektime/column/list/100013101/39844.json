{"id":39844,"title":"17 | go语句及其执行规则（下）","content":"<p>你好，我是郝林，今天我们继续分享go语句执行规则的内容。</p>\n<p>在上一篇文章中，我们讲到了goroutine在操作系统的并发编程体系，以及在Go语言并发编程模型中的地位和作用等一系列内容，今天我们继续来聊一聊这个话题。</p>\n<h2>知识扩展</h2>\n<p><strong>问题1：怎样才能让主goroutine等待其他goroutine？</strong></p>\n<p>我刚才说过，一旦主goroutine中的代码执行完毕，当前的Go程序就会结束运行，无论其他的goroutine是否已经在运行了。那么，怎样才能做到等其他的goroutine运行完毕之后，再让主goroutine结束运行呢？</p>\n<p>其实有很多办法可以做到这一点。其中，最简单粗暴的办法就是让主goroutine“小睡”一会儿。</p>\n<pre><code>for i := 0; i &lt; 10; i++ {\n\tgo func() {\n\t\tfmt.Println(i)\n\t}()\n}\ntime.Sleep(time.Millisecond * 500)\n</code></pre>\n<p>在<code>for</code>语句的后边，我调用了<code>time</code>包的<code>Sleep</code>函数，并把<code>time.Millisecond * 500</code>的结果作为参数值传给了它。<code>time.Sleep</code>函数的功能就是让当前的goroutine（在这里就是主goroutine）暂停运行一段时间，直到到达指定的恢复运行时间。</p>\n<p>我们可以把一个相对的时间传给该函数，就像我在这里传入的“500毫秒”那样。<code>time.Sleep</code>函数会在被调用时用当前的绝对时间，再加上相对时间计算出在未来的恢复运行时间。显然，一旦到达恢复运行时间，当前的goroutine就会从“睡眠”中醒来，并开始继续执行后边的代码。</p><!-- [[[read_end]]] -->\n<p>这个办法是可行的，只要“睡眠”的时间不要太短就好。不过，问题恰恰就在这里，我们让主goroutine“睡眠”多长时间才是合适的呢？如果“睡眠”太短，则很可能不足以让其他的goroutine运行完毕，而若“睡眠”太长则纯属浪费时间，这个时间就太难把握了。</p>\n<p>你可能会想到，既然不容易预估时间，那我们就让其他的goroutine在运行完毕的时候告诉我们好了。这个思路很好，但怎么做呢？</p>\n<p>你是否想到了通道呢？我们先创建一个通道，它的长度应该与我们手动启用的goroutine的数量一致。在每个手动启用的goroutine即将运行完毕的时候，我们都要向该通道发送一个值。</p>\n<p>注意，这些发送表达式应该被放在它们的<code>go</code>函数体的最后面。对应的，我们还需要在<code>main</code>函数的最后从通道接收元素值，接收的次数也应该与手动启用的goroutine的数量保持一致。关于这些你可以到demo39.go文件中，去查看具体的写法。</p>\n<p>其中有一个细节你需要注意。我在声明通道<code>sign</code>的时候是以<code>chan struct{}</code>作为其类型的。其中的类型字面量<code>struct{}</code>有些类似于空接口类型<code>interface{}</code>，它代表了既不包含任何字段也不拥有任何方法的空结构体类型。</p>\n<p>注意，<code>struct{}</code>类型值的表示法只有一个，即：<code>struct{}{}</code>。并且，它占用的内存空间是<code>0</code>字节。确切地说，这个值在整个Go程序中永远都只会存在一份。虽然我们可以无数次地使用这个值字面量，但是用到的却都是同一个值。</p>\n<p>当我们仅仅把通道当作传递某种简单信号的介质的时候，用<code>struct{}</code>作为其元素类型是再好不过的了。顺便说一句，我在讲“结构体及其方法的使用法门”的时候留过一道与此相关的思考题，你可以返回去看一看。</p>\n<p>再说回当下的问题，有没有比使用通道更好的方法？如果你知道标准库中的代码包<code>sync</code>的话，那么可能会想到<code>sync.WaitGroup</code>类型。没错，这是一个更好的答案。不过具体的使用方式我在后边讲<code>sync</code>包的时候再说。</p>\n<p><strong>问题2：怎样让我们启用的多个goroutine按照既定的顺序运行？</strong></p>\n<p>在很多时候，当我沿着上面的主问题以及第一个扩展问题一路问下来的时候，应聘者往往会被这第二个扩展问题难住。</p>\n<p>所以基于上一篇主问题中的代码，怎样做到让从<code>0</code>到<code>9</code>这几个整数按照自然数的顺序打印出来？你可能会说，我不用goroutine不就可以了嘛。没错，这样是可以，但是如果我不考虑这样做呢。你应该怎么解决这个问题？</p>\n<p>当然了，众多应聘者回答的其他答案也是五花八门的，有的可行，有的不可行，还有的把原来的代码改得面目全非。我下面就来说说我的思路，以及心目中的答案吧。这个答案并不一定是最佳的，也许你在看完之后还可以想到更优的答案。</p>\n<p>首先，我们需要稍微改造一下<code>for</code>语句中的那个<code>go</code>函数，要让它接受一个<code>int</code>类型的参数，并在调用它的时候把变量<code>i</code>的值传进去。为了不改动这个<code>go</code>函数中的其他代码，我们可以把它的这个参数也命名为<code>i</code>。</p>\n<pre><code>for i := 0; i &lt; 10; i++ {\n\tgo func(i int) {\n\t\tfmt.Println(i)\n\t}(i)\n}\n</code></pre>\n<p>只有这样，Go语言才能保证每个goroutine都可以拿到一个唯一的整数。其原因与<code>go</code>函数的执行时机有关。</p>\n<p>我在前面已经讲过了。在<code>go</code>语句被执行时，我们传给<code>go</code>函数的参数<code>i</code>会先被求值，如此就得到了当次迭代的序号。之后，无论<code>go</code>函数会在什么时候执行，这个参数值都不会变。也就是说，<code>go</code>函数中调用的<code>fmt.Println</code>函数打印的一定会是那个当次迭代的序号。</p>\n<p>然后，我们在着手改造<code>for</code>语句中的<code>go</code>函数。</p>\n<pre><code>for i := uint32(0); i &lt; 10; i++ {\n\tgo func(i uint32) {\n\t\tfn := func() {\n\t\t\tfmt.Println(i)\n\t\t}\n\t\ttrigger(i, fn)\n\t}(i)\n}\n</code></pre>\n<p>我在<code>go</code>函数中先声明了一个匿名的函数，并把它赋给了变量<code>fn</code>。这个匿名函数做的事情很简单，只是调用<code>fmt.Println</code>函数以打印<code>go</code>函数的参数<code>i</code>的值。</p>\n<p>在这之后，我调用了一个名叫<code>trigger</code>的函数，并把<code>go</code>函数的参数<code>i</code>和刚刚声明的变量<code>fn</code>作为参数传给了它。注意，<code>for</code>语句声明的局部变量<code>i</code>和<code>go</code>函数的参数<code>i</code>的类型都变了，都由<code>int</code>变为了<code>uint32</code>。至于为什么，我一会儿再说。</p>\n<p>再来说<code>trigger</code>函数。该函数接受两个参数，一个是<code>uint32</code>类型的参数<code>i</code>, 另一个是<code>func()</code>类型的参数<code>fn</code>。你应该记得，<code>func()</code>代表的是既无参数声明也无结果声明的函数类型。</p>\n<pre><code>trigger := func(i uint32, fn func()) {\n\tfor {\n\t\tif n := atomic.LoadUint32(&amp;count); n == i {\n\t\t\tfn()\n\t\t\tatomic.AddUint32(&amp;count, 1)\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(time.Nanosecond)\n\t}\n}\n</code></pre>\n<p><code>trigger</code>函数会不断地获取一个名叫<code>count</code>的变量的值，并判断该值是否与参数<code>i</code>的值相同。如果相同，那么就立即调用<code>fn</code>代表的函数，然后把<code>count</code>变量的值加<code>1</code>，最后显式地退出当前的循环。否则，我们就先让当前的goroutine“睡眠”一个纳秒再进入下一个迭代。</p>\n<p>注意，我操作变量<code>count</code>的时候使用的都是原子操作。这是由于<code>trigger</code>函数会被多个goroutine并发地调用，所以它用到的非本地变量<code>count</code>，就被多个用户级线程共用了。因此，对它的操作就产生了竞态条件（race condition），破坏了程序的并发安全性。</p>\n<p>所以，我们总是应该对这样的操作加以保护，在<code>sync/atomic</code>包中声明了很多用于原子操作的函数。</p>\n<p>另外，由于我选用的原子操作函数对被操作的数值的类型有约束，所以我才对<code>count</code>以及相关的变量和参数的类型进行了统一的变更（由<code>int</code>变为了<code>uint32</code>）。</p>\n<p>纵观<code>count</code>变量、<code>trigger</code>函数以及改造后的<code>for</code>语句和<code>go</code>函数，我要做的是，让<code>count</code>变量成为一个信号，它的值总是下一个可以调用打印函数的<code>go</code>函数的序号。</p>\n<p>这个序号其实就是启用goroutine时，那个当次迭代的序号。也正因为如此，<code>go</code>函数实际的执行顺序才会与<code>go</code>语句的执行顺序完全一致。此外，这里的<code>trigger</code>函数实现了一种自旋（spinning）。除非发现条件已满足，否则它会不断地进行检查。</p>\n<p>最后要说的是，因为我依然想让主goroutine最后一个运行完毕，所以还需要加一行代码。不过既然有了<code>trigger</code>函数，我就没有再使用通道。</p>\n<pre><code>trigger(10, func(){})\n</code></pre>\n<p>调用<code>trigger</code>函数完全可以达到相同的效果。由于当所有我手动启用的goroutine都运行完毕之后，<code>count</code>的值一定会是<code>10</code>，所以我就把<code>10</code>作为了第一个参数值。又由于我并不想打印这个<code>10</code>，所以我把一个什么都不做的函数作为了第二个参数值。</p>\n<p>总之，通过上述的改造，我使得异步发起的<code>go</code>函数得到了同步地（或者说按照既定顺序地）执行，你也可以动手自己试一试，感受一下。</p>\n<p><strong>总结</strong></p>\n<p>在本篇文章中，我们接着上一篇文章的主问题，讨论了当我们想让运行结果更加可控的时候，应该怎样去做。</p>\n<p>主goroutine的运行若过早结束，那么我们的并发程序的功能就很可能无法全部完成。所以我们往往需要通过一些手段去进行干涉，比如调用<code>time.Sleep</code>函数或者使用通道。我们在后面的文章中还会讨论更高级的手段。</p>\n<p>另外，<code>go</code>函数的实际执行顺序往往与其所属的<code>go</code>语句的执行顺序（或者说goroutine的启用顺序）不同，而且默认情况下的执行顺序是不可预知的。那怎样才能让这两个顺序一致呢？其实复杂的实现方式有不少，但是可能会把原来的代码改得面目全非。我在这里提供了一种比较简单、清晰的改造方案，供你参考。</p>\n<p>总之，我希望通过上述基础知识以及三个连贯的问题帮你串起一条主线。这应该会让你更快地深入理解goroutine及其背后的并发编程模型，从而更加游刃有余地使用<code>go</code>语句。</p>\n<p><strong>思考题</strong></p>\n<p>1.<code>runtime</code>包中提供了哪些与模型三要素G、P和M相关的函数？（模型三要素内容在上一篇）</p>\n<p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p>\n<p></p>\n","neighbors":{"left":{"article_title":"16 | go语句及其执行规则（上）","id":39841},"right":{"article_title":"18 | if语句、for语句和switch语句","id":39858}},"comments":[{"had_liked":false,"id":81982,"user_name":"枫林火山","can_delete":false,"product_type":"c1","uid":1199855,"ip_address":"","ucode":"66099C9D1AD36C","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/ef/2ad3effd.jpg","comment_is_top":false,"comment_ctime":1554095147,"is_pvip":true,"replies":[{"id":"29704","content":"我又看了一下“来碗绿豆汤”同学写的代码。我可能当时没看清楚，或者没说清楚。<br><br>他写的这段代码单从“顺序打印数字”的要求上看是可以的。但是这样做就变成纯同步的流程了，go函数就完全没必要写了。把go函数中的代码拿出来、删掉go函数，再把通道的相关代码也删掉，岂不是更直截了当？像这样：<br><br>\tfor i := 0; i &lt; num; i++ {<br>\t\tfmt.Println(i)<br>\t}<br><br>这个题目的要求是“使得在for循环中启用的多个goroutine按照既定的顺序运行”。你也可以把它理解为“在异步的情况下顺序的打印数字”。所以，“来碗绿豆汤”同学写的代码只满足了其中一个要求，而没有让go函数们自由的异步执行。<br><br>我的那个版本demo40.go是让各个go函数（确切地说，是它们调用的trigger函数）自行地检查所需条件，然后再在条件允许的情况下打印数字。这也叫“自旋”。这与纯同步的流程是有本质上的区别的。<br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1554128270,"ip_address":"","comment_id":81982,"utype":1}],"discussion_count":3,"race_medal":0,"score":"267842067499","product_id":100013101,"comment_content":"老师，关于顺序打印的demo40.go的优化版本，同来碗绿豆汤同学的实现<br>package main<br><br>import &quot;fmt&quot;<br><br>func main() {<br><br>\tvar num = 10<br>\tsign := make(chan struct{}, 1)<br><br>\tfor i := 0; i &lt; num; i++ {<br>\t\tgo func(i int) {<br>\t\t\tfmt.Println(i)<br>\t\t\tsign &lt;- struct{}{}<br>\t\t}(i)<br>\t\t&lt;-sign<br>\t}<br><br>}<br>这样写为什么不能保证同步，能不能再详细解释下呢。这个实现和您demo39.go 相比，只是合并了两处for循环，我看好多同学也有这个疑问，向您求解。<br>demo40.go的实现相当于实现了每个异步线程的一个轮询loop。 上面的实现相当于单步间加了一个barrier。执行1-&gt;等待-&gt;执行2-&gt;等待。 实在没理解为什么不能保证同步","like_count":63,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445415,"discussion_content":"我又看了一下“来碗绿豆汤”同学写的代码。我可能当时没看清楚，或者没说清楚。\n\n他写的这段代码单从“顺序打印数字”的要求上看是可以的。但是这样做就变成纯同步的流程了，go函数就完全没必要写了。把go函数中的代码拿出来、删掉go函数，再把通道的相关代码也删掉，岂不是更直截了当？像这样：\n\n\tfor i := 0; i &amp;lt; num; i++ {\n\t\tfmt.Println(i)\n\t}\n\n这个题目的要求是“使得在for循环中启用的多个goroutine按照既定的顺序运行”。你也可以把它理解为“在异步的情况下顺序的打印数字”。所以，“来碗绿豆汤”同学写的代码只满足了其中一个要求，而没有让go函数们自由的异步执行。\n\n我的那个版本demo40.go是让各个go函数（确切地说，是它们调用的trigger函数）自行地检查所需条件，然后再在条件允许的情况下打印数字。这也叫“自旋”。这与纯同步的流程是有本质上的区别的。\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1554128270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2687948,"avatar":"https://static001.geekbang.org/account/avatar/00/29/03/cc/e58dac56.jpg","nickname":"xyg","note":"","ucode":"1F9A252515690A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571783,"discussion_content":"哈哈哈哈 来碗绿豆汤同学大才！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652409240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541037,"discussion_content":"作者有大才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640240391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25473,"user_name":"xiao豪","can_delete":false,"product_type":"c1","uid":1026417,"ip_address":"","ucode":"F7969A9785E37B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/71/78796fd5.jpg","comment_is_top":false,"comment_ctime":1537337376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"160451127328","product_id":100013101,"comment_content":"回楼上，atomic的加操作和读操作只有32位和64位整数型，所以必须要把int转为intxx。之所以这么做是因为int位数是根据系统决定的，而原子级操作要求速度尽可能的快，所以明确了整数的位数才能最大地提高性能。","like_count":38},{"had_liked":false,"id":25435,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1537327683,"is_pvip":false,"replies":[{"id":"9365","content":"这些go函数的真正执行谁先谁后是不可控的，所以这样做不行的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537442536,"ip_address":"","comment_id":25435,"utype":1}],"discussion_count":9,"race_medal":0,"score":"160451117635","product_id":100013101,"comment_content":"我有一个更简单的实现方式， 如下<br>func main(){<br>\tch := make(chan struct{})<br>\tfor i:=0; i &lt; 100; i++{<br>\t\tgo func(i int){<br>\t\t\tfmt.Println(i)<br>\t\t\tch &lt;- struct{}{}<br>\t\t}(i)<br>\t\t&lt;-ch<br>\t}<br>}<br>这样，每次循环都包装goroutine 执行结束才进入下一次循环，就可以保证顺序执行了","like_count":37,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424306,"discussion_content":"这些go函数的真正执行谁先谁后是不可控的，所以这样做不行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537442536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311299,"avatar":"https://static001.geekbang.org/account/avatar/00/14/02/43/1c2fb7b3.jpg","nickname":"Bourne","note":"","ucode":"1286279F70B13F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308610,"discussion_content":"func main() {\n\tch := make(chan struct{})\n\tfor i := 0; i < 10; i++ {\n\t\tgo func(i int) {\n\t\t\tfmt.Println(i)\n\t\t\tch <- struct{}{}\n\t\t}(i)\n\t\t<-ch\n\t\tfmt.Printf(&#34;no %d goroutine finished.\\n&#34;, i)\n\t}\n}\n上面打印如下: \n0\nno 0 goroutine finished.\n1\nno 1 goroutine finished.\n2\nno 2 goroutine finished.\n3\nno 3 goroutine finished.\n4\nno 4 goroutine finished.\n5\nno 5 goroutine finished.\n6\nno 6 goroutine finished.\n7\nno 7 goroutine finished.\n8\nno 8 goroutine finished.\n9\nno 9 goroutine finished.\n\n这就意味着主协程每次都是创建一个子协程,等这个子协程运行完了再创建下一个,这已经不是并发了,编程串行了","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1601005233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1340120,"avatar":"https://static001.geekbang.org/account/avatar/00/14/72/d8/9eedbc5e.jpg","nickname":"FreeMason","note":"","ucode":"3D58AC2F9AB345","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1311299,"avatar":"https://static001.geekbang.org/account/avatar/00/14/02/43/1c2fb7b3.jpg","nickname":"Bourne","note":"","ucode":"1286279F70B13F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576085,"discussion_content":"兄弟你这是串行执行了，并不是并发工执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655274267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":308610,"ip_address":""},"score":576085,"extra":""}]},{"author":{"id":1099513,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","nickname":"大王叫我来巡山","note":"","ucode":"1B8D0C701BC95E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8506,"discussion_content":"原子性是指令级别的，不是语句级别的，一条语句可能会对应很多条指令，这个是很多初学者理解并发的一个障碍","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1568013063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2295511,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/FMrT2lyJhJu1fQAWiadGMUGhNuXWpHkLrAEYWP975IhCticeXDIqlPqibl7QaNkaEFpmuI6834FFVkQOQoWAu1gew/132","nickname":"Geek_d05b33","note":"","ucode":"874391AD73DB7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381549,"discussion_content":"我的理解是，题目要求是每个goroutine都进入待执行队列，自己检查运行条件是否满足，满足则执行。这个过程是由各G自己控制的。主G只负责启动各G。\n上面的语句是上一个循环体执行完毕，才将下一个循环体放入执行队列，这个过程中，是由主G调度的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1625124206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2818527,"avatar":"","nickname":"Geek_d094ea","note":"","ucode":"C137051985EF34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558721,"discussion_content":"如果每个goroutine执行的内部逻辑不一样，或者有阻塞等待资源的，就不能保证了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648438455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1166373,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cc/25/8c6eab2c.jpg","nickname":"ArtistLu","note":"","ucode":"2E641A3EB4F9AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2908,"discussion_content":"func main(){\nch := make(chan struct{})\nfor i:=0; i < 100; i++{\ngo func(i int){\nfmt.Println(i)\nch <- struct{}{}\n}(i)\n<-ch\n}\n}\n\n老师 这个我试了可以😆强制每次执行在下次循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564032479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1166373,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cc/25/8c6eab2c.jpg","nickname":"ArtistLu","note":"","ucode":"2E641A3EB4F9AC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":3802,"discussion_content":"这是每次都阻塞了主G的for循环，已经不是并发了。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1564824033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2908,"ip_address":""},"score":3802,"extra":""},{"author":{"id":1014692,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/a4/24955994.jpg","nickname":"progyoung","note":"","ucode":"0B4898AE78F9F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29334,"discussion_content":"正解，初看没理解，仔细研究下确实是，郝老师的是让并发启动的goroutine按要求的顺序执行了，楼主的是阻塞非并发执行","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1570762549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3802,"ip_address":""},"score":29334,"extra":""}]}]},{"had_liked":false,"id":128028,"user_name":"Geek_3241ef","can_delete":false,"product_type":"c1","uid":1596800,"ip_address":"","ucode":"3258AFDD5D9730","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKbHJIeiaXIApbom8Yx325VvUouL4auhC62JBSpwY8Ao5VbrvCWDq2UUIl4XM6SicnGCW5LrHibQZwjQ/132","comment_is_top":false,"comment_ctime":1566822607,"is_pvip":false,"replies":[{"id":"47686","content":"这主要是因为：Go 调度器在需要的时候只会对正在运行的 goroutine 发出通知，试图让它停下来。但是，它却不会也不能强行让一个 goroutine 停下来。<br><br>所以，如果一条 for 语句过于简单的话，比如这里的 for 语句就很简单（因为里面只有一条 if 语句），那么当前的 goroutine 就可能不会去正常响应（或者说没有机会响应）Go 调度器的停止通知。<br><br>因此，这里加一个 sleep 是为了：在任何情况下（如任何版本的 Go、任何计算平台下的 Go、任何的 CPU 核心数等），内含这条 for 语句的这些 goroutine 都能够正常地响应停止通知。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1566906355,"ip_address":"","comment_id":128028,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57401397455","product_id":100013101,"comment_content":"你好，郝老师，请问这里为什么需要sleep呢，我理解的如果不加sleep，其中某个g会一直轮询count的值，当另一个g更改这个值时，那么第一个g就会判断相等才对呀。<br>但实际上去掉sleep后，程序确实没有按照我理解的逻辑执行，请问这是为什么呢","like_count":14,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464761,"discussion_content":"这主要是因为：Go 调度器在需要的时候只会对正在运行的 goroutine 发出通知，试图让它停下来。但是，它却不会也不能强行让一个 goroutine 停下来。\n\n所以，如果一条 for 语句过于简单的话，比如这里的 for 语句就很简单（因为里面只有一条 if 语句），那么当前的 goroutine 就可能不会去正常响应（或者说没有机会响应）Go 调度器的停止通知。\n\n因此，这里加一个 sleep 是为了：在任何情况下（如任何版本的 Go、任何计算平台下的 Go、任何的 CPU 核心数等），内含这条 for 语句的这些 goroutine 都能够正常地响应停止通知。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566906355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25387,"user_name":"Askerlve","can_delete":false,"product_type":"c1","uid":1178535,"ip_address":"","ucode":"BF29F9A8674507","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/a7/12c90699.jpg","comment_is_top":false,"comment_ctime":1537322076,"is_pvip":false,"replies":[{"id":"9364","content":"可以加个sleep","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537441119,"ip_address":"","comment_id":25387,"utype":1}],"discussion_count":7,"race_medal":0,"score":"53076929628","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;sync&#47;atomic&quot;<br>)<br><br>func main() {<br>\tvar count uint32<br>\ttrigger := func(i uint32, fn func()) {<br>\t\tfor {<br>\t\t\tif n := atomic.LoadUint32(&amp;count); n == i {<br>\t\t\t\tfn()<br>\t\t\t\tatomic.AddUint32(&amp;count, 1)<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t}<br>\t}<br>\tfor i := uint32(0); i &lt; 10; i++ {<br>\t\tgo func(i uint32) {<br>\t\t\tfn := func() {<br>\t\t\t\tfmt.Println(i)<br>\t\t\t}<br>\t\t\ttrigger(i, fn)<br>\t\t}(i)<br>\t}<br>\ttrigger(10, func() {})<br>}<br><br>测试了下，这个函数的输出不受控，并且好像永远也不会结束，有人能帮忙解释下吗，go小白~😀","like_count":12,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424282,"discussion_content":"可以加个sleep","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537441119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217554,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","nickname":"Jason","note":"","ucode":"C5A540BC5A60B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572763,"discussion_content":"这里的sleep其实就是告诉调度器，我让出了cpu，让其他协程执行。还有channel读取不到数据，或向满的channel写入数据或io阻塞都会让出CPU，等待下次调度","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652949346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1848474,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/34/9a/1587bc6f.jpg","nickname":"JDY","note":"","ucode":"4B6F55332BE6DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582128,"discussion_content":"单纯为了程序能执行加sleep，这种方式不可取吧，线上代码可不能这么搞。所以脱离生产环境的代码，都是伪代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659253948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209078,"discussion_content":"我觉得 有可能 你那个n已经超过了i 所以某一个goroutine死了 上面CCCZZZ也回答了最重要的一点 你本来就是一个死循环 万一一直不释放对cpu的占用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584607136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369165,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e4/4d/c7b5f20a.jpg","nickname":"黄伟洪","note":"","ucode":"97331040A49EAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3839,"discussion_content":"为什么要加sleep才能正常运行。。。。。。。我也是不明白。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564848901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1369165,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e4/4d/c7b5f20a.jpg","nickname":"黄伟洪","note":"","ucode":"97331040A49EAD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122998,"discussion_content":"我觉得是trigger函数里都是for循环，多个goroutine会一直占用原子变量的获取操作，即LoadUint32，导致判断相等条件一直不成立，又会一直循环获取并等待，可能造成死锁，或许隔很长时间就能打印。\n增加 sleep可能是为了等其他的groutine有机会执行获取count吧","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1578384640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3839,"ip_address":""},"score":122998,"extra":""},{"author":{"id":1252164,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1b/44/82acaafc.jpg","nickname":"无为","note":"","ucode":"81D7AF5E1FDD30","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1369165,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e4/4d/c7b5f20a.jpg","nickname":"黄伟洪","note":"","ucode":"97331040A49EAD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329475,"discussion_content":"如果最先获得执行的goroutine 不是第一个, 那 if 条件就不成立了, trigger()一旦执行就死循环了, 如果是单进程, 其他的goroutine就没有机会执行了.  sleep的作用, 就是释放当前goroutine执行机会, 进入等待区, 其他的 goroutine 就有可能获取执行的机会, 这样count 就有机会发生变化了, 当前这个 goroutine 中的if就有可能在某次循环的时候成立了, 就可以退出了, 其他的goroutine也是一样的. 不保证理解完全正确, 如有错误, 大家帮忙指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606388557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3839,"ip_address":""},"score":329475,"extra":""}]}]},{"had_liked":false,"id":32370,"user_name":"老茂","can_delete":false,"product_type":"c1","uid":1199722,"ip_address":"","ucode":"5EB1171921758C","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/6a/ad3707f4.jpg","comment_is_top":false,"comment_ctime":1539562508,"is_pvip":false,"replies":[{"id":"11826","content":"Go语言调度goroutine是准抢占式的，虽然会防止某个goroutine运行太久，并做换下处理。但是像简单的死循环这种有可能会换下失败，尤其是windows下，这跟操作系统的底层支持有关。不过一般情况下不用担心。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539578414,"ip_address":"","comment_id":32370,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35899300876","product_id":100013101,"comment_content":"不加sleep程序不能正常结束的情况貌似跟cpu核数有关，我是4核cpu，打印0到2每次都可以正常执行；0到3以上就会有卡主的情况，卡主时cpu达到100%，load会超过4。猜测是不是此时所有cpu都在处理count==0的for循环，没有空闲的cpu执行atomic.AddUint32(&amp;count, 1)？","like_count":9,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426744,"discussion_content":"Go语言调度goroutine是准抢占式的，虽然会防止某个goroutine运行太久，并做换下处理。但是像简单的死循环这种有可能会换下失败，尤其是windows下，这跟操作系统的底层支持有关。不过一般情况下不用担心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539578414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171541,"user_name":"言午木杉","can_delete":false,"product_type":"c1","uid":1201009,"ip_address":"","ucode":"300BEDC1B07DF1","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/71/a4e9f20e.jpg","comment_is_top":false,"comment_ctime":1578964824,"is_pvip":false,"replies":[{"id":"66483","content":"正式学习一个新东西的首要任务就是“重要名词解析”。一旦熟悉了这些名词以及它们背后的深意，后面的学习效率就会高很多。更重要的是，后面会学得更扎实（或者说很稳）。因为你真正融入了这个新东西所处的世界，站在了它的地基之上。这也是我的一点学习经验。共勉。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1578968391,"ip_address":"","comment_id":171541,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31643735896","product_id":100013101,"comment_content":"这篇加了代码，一下子就容易很多了，老师前面的几篇都太多名词了，需要琢磨去好几遍","like_count":7,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481405,"discussion_content":"正式学习一个新东西的首要任务就是“重要名词解析”。一旦熟悉了这些名词以及它们背后的深意，后面的学习效率就会高很多。更重要的是，后面会学得更扎实（或者说很稳）。因为你真正融入了这个新东西所处的世界，站在了它的地基之上。这也是我的一点学习经验。共勉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578968391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018200,"avatar":"","nickname":"一眼万年","note":"","ucode":"7B0823E39AE809","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298646,"discussion_content":"知其然知其所以然","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597370274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1896164,"avatar":"","nickname":"Geek_73af59","note":"","ucode":"7885D16EB735B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204453,"discussion_content":"而且是用自己的话去解释，不能死记硬背","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584175029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25386,"user_name":"Askerlve","can_delete":false,"product_type":"c1","uid":1178535,"ip_address":"","ucode":"BF29F9A8674507","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/a7/12c90699.jpg","comment_is_top":false,"comment_ctime":1537321975,"is_pvip":false,"replies":[{"id":"9367","content":"Win下可能会有问题，你在bif语句后边加一句time.sleep(time.Nanosecond)。github上的代码我已经更新了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537442812,"ip_address":"","comment_id":25386,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31602093047","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;sync&#47;atomic&quot;<br>)<br><br>func main() {<br>\tvar count uint32<br>\ttrigger := func(i uint32, fn func()) {<br>\t\tfor {<br>\t\t\tif n := atomic.LoadUint32(&amp;count); n == i {<br>\t\t\t\tfn()<br>\t\t\t\tatomic.AddUint32(&amp;count, 1)<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t}<br>\t}<br>\tfor i := uint32(0); i &lt; 10; i++ {<br>\t\tgo func(i uint32) {<br>\t\t\tfn := func() {<br>\t\t\t\tfmt.Println(i)<br>\t\t\t}<br>\t\t\ttrigger(i, fn)<br>\t\t}(i)<br>\t}<br>\ttrigger(10, func() {})<br>}<br><br>这个函数的执行还是不可控诶，并且好像永远也不会结束，是因为我的go版本问题吗？","like_count":7,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424281,"discussion_content":"Win下可能会有问题，你在bif语句后边加一句time.sleep(time.Nanosecond)。github上的代码我已经更新了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537442812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92747,"user_name":"肖恩","can_delete":false,"product_type":"c1","uid":1242463,"ip_address":"","ucode":"78F91260284C21","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/5f/01b82ba1.jpg","comment_is_top":false,"comment_ctime":1557320514,"is_pvip":false,"replies":[{"id":"33119","content":"祝贺你升级了；）","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1557325499,"ip_address":"","comment_id":92747,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27327124290","product_id":100013101,"comment_content":"第一遍看好多都看不懂，看到后边回过头来看，发现用自旋goroutine实现，真实奇妙；现在想想，除了文章中实现方式，可以用channel同步实现；还可以用sync.WaitGroup实现","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449368,"discussion_content":"祝贺你升级了；）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557325499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":26190,"user_name":"新垣结裤","can_delete":false,"product_type":"c1","uid":1198555,"ip_address":"","ucode":"BFE7CB24C4EDC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/49/db/ee5e8b43.jpg","comment_is_top":false,"comment_ctime":1537515585,"is_pvip":false,"replies":[{"id":"9669","content":"搞这么多通道有些浪费啊。另外切片不是并发安全的数据类型，最好不要这样用。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537690669,"ip_address":"","comment_id":26190,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27307319361","product_id":100013101,"comment_content":"func main() {<br>\tnum := 10<br>\tchs := [num+1]chan struct{}{}<br>\tfor i := 0; i &lt; num+1; i++ {<br>\t\tchs[i] = make(chan struct{})<br>\t}<br>\tfor i := 0; i &lt; num; i++ {<br>\t\tgo func(i int) {<br>\t\t\t&lt;- chs[i]<br>\t\t\tfmt.Println(i)<br>\t\t\tchs[i+1] &lt;- struct{}{}<br>\t\t}(i)<br>\t}<br>\tchs[0] &lt;- struct{}{}<br>\t&lt;- chs[num]<br>}<br>每个goroutine执行完通过channel通知下一个goroutine，在主goroutine里控制第一个goroutine的开始，并接收最后一个goroutine结束的信号","like_count":7,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424556,"discussion_content":"搞这么多通道有些浪费啊。另外切片不是并发安全的数据类型，最好不要这样用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537690669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25755,"user_name":"嗷大猫的鱼","can_delete":false,"product_type":"c1","uid":1204931,"ip_address":"","ucode":"BF980405C8E7DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/62/c3/d7f2bd8f.jpg","comment_is_top":false,"comment_ctime":1537436627,"is_pvip":false,"replies":[{"id":"9389","content":"很好，加油！","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537447600,"ip_address":"","comment_id":25755,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27307240403","product_id":100013101,"comment_content":"老师，最近从头学习，前面一直没跟着动手，也没自己总结。这几天在整理每章的重点！<br><br>https:&#47;&#47;github.com&#47;wenxuwan&#47;go36<br><br>刚写完第二章，突然发现自己动手总结和只看差好多。我会继续保持喜欢总结！","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424411,"discussion_content":"很好，加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537447600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387172,"discussion_content":"哥们，怎么GitHub没更新了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628037778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93605,"user_name":"志鑫","can_delete":false,"product_type":"c1","uid":1095392,"ip_address":"","ucode":"408869664EEA13","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/e0/52a07898.jpg","comment_is_top":false,"comment_ctime":1557533721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18737402905","product_id":100013101,"comment_content":"&#47;&#47;个人笔记：使用一个通道来控制<br>package main<br><br>import &quot;fmt&quot;<br><br>func main() {<br>\tconst n = 10<br>\tm := 0<br>\tch := make(chan int, 10) &#47;&#47;通道长度0~10之间，能够影响性能<br>\tfor i := 0; i &lt; n; i++ {<br>\t\tgo func(i int) {<br>\t\t\tfor v := &lt;-ch; v != i; v = &lt;-ch {<br>\t\t\t\tm++<br>\t\t\t\tch &lt;- v &#47;&#47;如果不是自己的轮次，则把值再放回去<br>\t\t\t}<br>\t\t\tfmt.Println(i)<br>\t\t\tch &lt;- i + 1<br>\t\t}(i)<br>\t}<br>\tch &lt;- 0<br>\tfor v := &lt;-ch; v != 10; v = &lt;-ch {<br>\t\tch &lt;- v<br>\t}<br>\tfmt.Println(m)<br>}","like_count":4},{"had_liked":false,"id":190141,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584606460,"is_pvip":false,"replies":[{"id":"73159","content":"更确切地说，是顺序地送给某个M执行。不过。它们又可以是并发的，因为如果前一个G进入了等待状态，那么同一个G队列中的后一个G就很可能会获得运行的机会。这时，前一个G并没有运行完成，它可能是在等待计时器到时或者IO操作完成。所以，我们可以说，在这种情况下，前后这两个G就是在并发运行。<br><br>进一步讲，同一个G队列中的G都可以如此。所以我们还可以说，Go调度器中的所有可运行G都是有并发运行的能力的，只不过实际上是怎样的，还要看实时调度的具体情况。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1584612468,"ip_address":"","comment_id":190141,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14469508348","product_id":100013101,"comment_content":"本节内容主要是讲了 goroutine同步那一块 <br>主要通过通道 信号 应该sync包中也会有同步相关的函数<br>我又去把16讲那个G队列再想了一遍<br>实际上可能存在多个G队列 G队列之间属于并发关系<br>但是G队列当中他们又是队列储存 顺序执行的","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487900,"discussion_content":"更确切地说，是顺序地送给某个M执行。不过。它们又可以是并发的，因为如果前一个G进入了等待状态，那么同一个G队列中的后一个G就很可能会获得运行的机会。这时，前一个G并没有运行完成，它可能是在等待计时器到时或者IO操作完成。所以，我们可以说，在这种情况下，前后这两个G就是在并发运行。\n\n进一步讲，同一个G队列中的G都可以如此。所以我们还可以说，Go调度器中的所有可运行G都是有并发运行的能力的，只不过实际上是怎样的，还要看实时调度的具体情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584612468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209136,"discussion_content":"是的呢，谢谢指出😬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584613470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31660,"user_name":"SuperP ❤ 飝","can_delete":false,"product_type":"c1","uid":1203011,"ip_address":"","ucode":"FCA4E2C5BECB8F","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/43/edf22486.jpg","comment_is_top":false,"comment_ctime":1539257868,"is_pvip":false,"replies":[{"id":"11818","content":"对，可以。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1539577220,"ip_address":"","comment_id":31660,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14424159756","product_id":100013101,"comment_content":"runtime.GOMAXPROCS  这个应该能控制P的数量","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426454,"discussion_content":"对，可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539577220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25479,"user_name":"cygnus","can_delete":false,"product_type":"c1","uid":1120452,"ip_address":"","ucode":"C60A86E3084754","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/c4/e55fdc1c.jpg","comment_is_top":false,"comment_ctime":1537339811,"is_pvip":false,"replies":[{"id":"9362","content":"你在win下执行的嘛？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537441043,"ip_address":"","comment_id":25479,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14422241699","product_id":100013101,"comment_content":"demo40的执行结果不是幂等的，程序经常无法正常结束退出，只有极少数几次有正确输出。","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424318,"discussion_content":"你在win下执行的嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537441043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25468,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1082187,"ip_address":"","ucode":"FC323371453C97","user_header":"https://static001.geekbang.org/account/avatar/00/10/83/4b/0e96fcae.jpg","comment_is_top":false,"comment_ctime":1537336256,"is_pvip":false,"replies":[{"id":"9363","content":"可以加个sleep。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537441064,"ip_address":"","comment_id":25468,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14422238144","product_id":100013101,"comment_content":"win64版本：go1.10.2<br>linux64版本：go1.11<br><br>linux下实际运行和预期一样，但为何win下会一直运行不会停止呢，且CPU也已经是100% 表示不解呀","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424316,"discussion_content":"可以加个sleep。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537441064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25383,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1537321677,"is_pvip":false,"replies":[{"id":"9368","content":"代码已经更新了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537442828,"ip_address":"","comment_id":25383,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14422223565","product_id":100013101,"comment_content":"‘’否则，我们就先让当前的 goroutine“睡眠”一个纳秒再进入下一个迭代。‘’<br><br>示例代码里没有这个睡眠代码","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424280,"discussion_content":"代码已经更新了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537442828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289381,"user_name":"Geek_d6cfa7","can_delete":false,"product_type":"c1","uid":1581741,"ip_address":"","ucode":"7AF89E9A91A04D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8bkRNKwpPicpibupozsqsbR6apibQyWXyyvrhmdSHIzMXk0lbNRYfRa6ZklQSNib6QrHunxueEFb9x2gJK6GfxSq0A/132","comment_is_top":false,"comment_ctime":1618993020,"is_pvip":false,"replies":[{"id":"105029","content":"变量值的改变也不是并发安全的，所以这样做可能会出问题。而且这个方案有些复杂了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1619060561,"ip_address":"","comment_id":289381,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10208927612","product_id":100013101,"comment_content":"go 通道传递达到顺序执行目的：<br>func TestTransmitChan(t *testing.T) {<br>\tstart, end := make(chan bool), make(chan bool)<br>\thead := start<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tend = make(chan bool)<br>\t\ttemp := i<br>\t\tgo func(head, end chan bool, i int) {<br>\t\t\t&lt;-head<br>\t\t\tt.Logf(&quot;goroutine %v doing&quot;, i)<br>\t\t\tend &lt;- true<br>\t\t}(head, end, temp)<br>\t\thead = end<br>\t}<br>\tstart &lt;- true<br>\t&lt;-end<br><br>\tt.Logf(&quot;main goroutine is end&quot;)<br>}","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518899,"discussion_content":"变量值的改变也不是并发安全的，所以这样做可能会出问题。而且这个方案有些复杂了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619060561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25585,"user_name":"Pixar","can_delete":false,"product_type":"c1","uid":1197659,"ip_address":"","ucode":"E653387BA8EA16","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/5b/07858c33.jpg","comment_is_top":false,"comment_ctime":1537369438,"is_pvip":false,"replies":[{"id":"9361","content":"并发情况下必须利用某种同步工具，否则就不是并发安全的，生产环境中很可能出现不可控的问题。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537440972,"ip_address":"","comment_id":25585,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10127304030","product_id":100013101,"comment_content":"func trigger(i int64, fn func()) {<br>\tfor {<br>\t\t&#47;&#47;if i != 10 {<br>\t\t&#47;&#47;\tfmt.Print(&quot;&quot;)<br>\t\t&#47;&#47;}<br><br>\t\tif count == i {<br>\t\t\tfn()<br>\t\t\tcount += 1<br>\t\t\tbreak<br>\t\t}<br>\t}<br>}<br><br>func main() {<br>\tfor i := int64(0); i &lt;= 9; i++ {<br>\t\tgo func(i int64) {<br>\t\t\tfn := func() {<br>\t\t\t\tfmt.Println(i)<br>\t\t\t}<br>\t\t\ttrigger(i, fn)<br>\t\t}(i)<br>\t}<br>\ttrigger(10, func() {})<br>}<br><br>取消注释后代码可顺序 0 ~9 输出. 而注释后则会莫名卡主, 怀疑是不是golang runtime 针对这些循环做了些什么,  而且感觉没必要加锁.","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424352,"discussion_content":"并发情况下必须利用某种同步工具，否则就不是并发安全的，生产环境中很可能出现不可控的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537440972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25380,"user_name":"timmy21","can_delete":false,"product_type":"c1","uid":1174860,"ip_address":"","ucode":"9D6DED247B1F38","user_header":"https://static001.geekbang.org/account/avatar/00/11/ed/4c/8674b6ad.jpg","comment_is_top":false,"comment_ctime":1537321094,"is_pvip":false,"replies":[{"id":"9369","content":"代码已经更新了，漏掉了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537442846,"ip_address":"","comment_id":25380,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10127255686","product_id":100013101,"comment_content":"有一个问题不太清楚，当i和count不相等时，您提到了睡眠1纳秒，可是我没看到有相关的sleep被调用。这是如何做到的？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424279,"discussion_content":"代码已经更新了，漏掉了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537442846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329632,"user_name":"NeoMa","can_delete":false,"product_type":"c1","uid":1228079,"ip_address":"","ucode":"9EABAF2DCF0263","user_header":"","comment_is_top":false,"comment_ctime":1641452915,"is_pvip":false,"replies":[{"id":"120119","content":"在这里用锁的话有些重了（说的是性能方面），不过使用的方式基本没问题。那条 defer 语句可以去掉，代码可以这样改写：<br><br>    <br>    mu.Lock()<br>    local := index<br>    index++<br>    mu.Unlock()<br>    fmt.Println(local)<br>    ch &lt;- local<br><br>因为即使现在 defer 语句在性能方面已经优化很多次了，但终归还是有性能开销的。在这么简单的场景下，我们是可以人为保证“在锁定期间不会有 panic ”的，所以没必要用 defer 语句。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1641539151,"ip_address":"","comment_id":329632,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5936420211","product_id":100013101,"comment_content":"您好，看完了后面的sync.Mutex，写了一个版本，请多多指正<br>package main<br><br>import (<br>    &quot;fmt&quot;<br>    &quot;sync&quot;<br>)<br><br>func main() {<br>    ch := make(chan int, 10)<br>    var mu sync.Mutex<br>    var index = 1<br>    for i := 1; i &lt;= 10; i++ {<br>        go func(ch chan int) {<br>            mu.Lock()<br>            defer mu.Unlock()<br>            fmt.Println(index)<br>            index++<br>            ch &lt;- index<br>        }(ch)<br>    }<br>    for j := 1; j &lt;= 10; j++ {<br>        &lt;- ch<br>    }<br>}","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544488,"discussion_content":"在这里用锁的话有些重了（说的是性能方面），不过使用的方式基本没问题。那条 defer 语句可以去掉，代码可以这样改写：\n\n    \n    mu.Lock()\n    local := index\n    index++\n    mu.Unlock()\n    fmt.Println(local)\n    ch &lt;- local\n\n因为即使现在 defer 语句在性能方面已经优化很多次了，但终归还是有性能开销的。在这么简单的场景下，我们是可以人为保证“在锁定期间不会有 panic ”的，所以没必要用 defer 语句。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641539151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324145,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1638322099,"is_pvip":false,"replies":[{"id":"117719","content":"乐观锁：总是假设在“我”操作共享资源的过程中没有“其他人”竞争操作。如果发现“其他人”确实在此期间竞争了，也就是发现假设失败，那就等一等再操作。CAS原子操作基本上能够体现出这种思想。通常，低频的并发操作适合用乐观锁。乐观锁一般会用比较轻量级的同步方法（如原子操作），但也不是100%。注意，高频的操作用乐观锁的话反而有可能影响性能，因为多了一步“探查是否有人与我竞争”的操作（当然了，标准的CAS操作可以把这种影响降到最低）。<br><br>悲观锁：总是假设在“我”操作共享资源的过程中一定有“其他人”竞争操作。所以“我”会先用某种同步方法（如互斥锁）保护我的操作。这样的话，“我”在将要操作的时候就没必要去探查是否有人与我竞争（因为“我”总是假设肯定有竞争，而且已经做好了保护）。通常，频次较高的并发操作适合用悲观锁。不过，如果并发操作的频次非常低，用悲观锁也是可以的，因为这种情况下对性能影响不大。<br><br>最后，一定要注意，使用任何同步方法和异步方法都首先要考虑程序的正确性，并且还要考虑程序的性能。程序的正确性一定要靠功能测试来保障，程序的性能一定要靠性能测试来保障。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1638421376,"ip_address":"","comment_id":324145,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5933289395","product_id":100013101,"comment_content":"其他地方也有类似的spinning操作，说道其实是一种乐观锁，先通过原子操作读取值，再在修改值的时候检查，符合条件才能修改，我的问题是这段代码是否就是乐观锁的定义诠释，这里仍然读取了原值再修改，而没有直接修改，是否足够乐观，不太理解乐观的真是含义，另外如果用悲观锁的话应该怎么实现","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535371,"discussion_content":"乐观锁：总是假设在“我”操作共享资源的过程中没有“其他人”竞争操作。如果发现“其他人”确实在此期间竞争了，也就是发现假设失败，那就等一等再操作。CAS原子操作基本上能够体现出这种思想。通常，低频的并发操作适合用乐观锁。乐观锁一般会用比较轻量级的同步方法（如原子操作），但也不是100%。注意，高频的操作用乐观锁的话反而有可能影响性能，因为多了一步“探查是否有人与我竞争”的操作（当然了，标准的CAS操作可以把这种影响降到最低）。\n\n悲观锁：总是假设在“我”操作共享资源的过程中一定有“其他人”竞争操作。所以“我”会先用某种同步方法（如互斥锁）保护我的操作。这样的话，“我”在将要操作的时候就没必要去探查是否有人与我竞争（因为“我”总是假设肯定有竞争，而且已经做好了保护）。通常，频次较高的并发操作适合用悲观锁。不过，如果并发操作的频次非常低，用悲观锁也是可以的，因为这种情况下对性能影响不大。\n\n最后，一定要注意，使用任何同步方法和异步方法都首先要考虑程序的正确性，并且还要考虑程序的性能。程序的正确性一定要靠功能测试来保障，程序的性能一定要靠性能测试来保障。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638421376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295053,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1622196140,"is_pvip":true,"replies":[{"id":"107240","content":"相信不少同学会有类似的问题，我在这里完整地解释一下：<br><br>这与Go语言的调度器以及你运行代码的机器有关。这也从侧面说明了，Go语言调度器的灵活性，或者说随机性。对于你我而言，这里的“随机性”的意思是：<br><br>Go语言调度G在M上运行，操作系统调度进程和线程在CPU核心上运行，以及CPU对自身核心和各级缓存的利用和协调，这些都不是我们自己能够直接控制的，或者说我们即使知道了原理也无法做出基于此的判断（判断什么时刻一定会运行什么代码）。<br><br>我们作为应用程序的开发者，与计算机底层的软硬件之间的信息差如此之大。这是我们必须理解的一个关键点。所以，我们才会想到（以及必须）利用种种同步编程工具和异步编程手段来防止代码的无序执行，以及更重要的，保证程序运行的正确性。<br><br>这其实就是我想通过这个例子告诉大家的。在这里，打印的是不是10其实不重要（它只是一个表象），重要的是，一个Go程序中的各个goroutine（或者说go函数）的执行顺序是我们无法确定的（也就上面说的“随机的”）。要想让go函数按照我们的意愿“既完全并发又部分有序”的运行，那就需要合理地使用后面讲的channel（通道），以及各种同步工具。<br><br>最后，我再用最直接的方式回答一下你的问题：<br><br>打印10代表着，程序中的“主goroutine中的for语句”先于我们在其中“新启用的goroutine”执行完成了，所以变量i的值才会定格在10这个最后的数字。<br><br>如果打印的不是10，或者每次都不一样，就说明，在这些“新启用的goroutine”当中有一些先于“主goroutine中的for语句”执行完成了。这是由Go语言中的调度引起的。Go语言会在触及各个调度点（比如在执行各个语句之间的时间缝隙）时以“高效和公平”为基本原则来选择“在接下来的时刻，运行哪一个goroutine。<br><br>我们在上面说了，这个调度对于你我这样的应用程序开发者而言可以看做是“随机的”。因此，即使情况多变也是正常的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1622446540,"ip_address":"","comment_id":295053,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5917163436","product_id":100013101,"comment_content":"最上面的代码 加了sleep 并不是10个10 最后的结果 每次都不一样啊？老师","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520927,"discussion_content":"相信不少同学会有类似的问题，我在这里完整地解释一下：\n\n这与Go语言的调度器以及你运行代码的机器有关。这也从侧面说明了，Go语言调度器的灵活性，或者说随机性。对于你我而言，这里的“随机性”的意思是：\n\nGo语言调度G在M上运行，操作系统调度进程和线程在CPU核心上运行，以及CPU对自身核心和各级缓存的利用和协调，这些都不是我们自己能够直接控制的，或者说我们即使知道了原理也无法做出基于此的判断（判断什么时刻一定会运行什么代码）。\n\n我们作为应用程序的开发者，与计算机底层的软硬件之间的信息差如此之大。这是我们必须理解的一个关键点。所以，我们才会想到（以及必须）利用种种同步编程工具和异步编程手段来防止代码的无序执行，以及更重要的，保证程序运行的正确性。\n\n这其实就是我想通过这个例子告诉大家的。在这里，打印的是不是10其实不重要（它只是一个表象），重要的是，一个Go程序中的各个goroutine（或者说go函数）的执行顺序是我们无法确定的（也就上面说的“随机的”）。要想让go函数按照我们的意愿“既完全并发又部分有序”的运行，那就需要合理地使用后面讲的channel（通道），以及各种同步工具。\n\n最后，我再用最直接的方式回答一下你的问题：\n\n打印10代表着，程序中的“主goroutine中的for语句”先于我们在其中“新启用的goroutine”执行完成了，所以变量i的值才会定格在10这个最后的数字。\n\n如果打印的不是10，或者每次都不一样，就说明，在这些“新启用的goroutine”当中有一些先于“主goroutine中的for语句”执行完成了。这是由Go语言中的调度引起的。Go语言会在触及各个调度点（比如在执行各个语句之间的时间缝隙）时以“高效和公平”为基本原则来选择“在接下来的时刻，运行哪一个goroutine。\n\n我们在上面说了，这个调度对于你我这样的应用程序开发者而言可以看做是“随机的”。因此，即使情况多变也是正常的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622446540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3043622,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/71/26/773e6dcb.jpg","nickname":"枫","note":"","ucode":"2850902F61B46C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":579591,"discussion_content":"老师，我有个小问题，就是说如果新启用的goroutine先于主goroutine执行，那终端就会在不使用sleep函数的情况下就会输出这些已经执行的goroutine的执行结果，而不是什么都不会输出。这是为什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657542293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":520927,"ip_address":""},"score":579591,"extra":""}]}]},{"had_liked":false,"id":286725,"user_name":"Geek_9b9769","can_delete":false,"product_type":"c1","uid":1312225,"ip_address":"","ucode":"48A1DEC02CFAE3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/tmVLphkQHLxRsAOZOzJNhJKXvAhkvvT8koMjMUpIQbJN1e8Uico1habQvNibvibI14yM7DWVicJIgNriaib9tRv735mg/132","comment_is_top":false,"comment_ctime":1617527358,"is_pvip":false,"replies":[{"id":"104177","content":"可以倒是可以，但是搞这么多通道出来，太重了。<br><br>这类同步工具从重到轻：通道 =&gt; 读写锁 =&gt; 互斥锁 =&gt; 原子操作。<br><br>能轻尽量轻啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1617682925,"ip_address":"","comment_id":286725,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5912494654","product_id":100013101,"comment_content":" 老师，您看下，我的思路是用一个通道数组控制<br><br>func main() {<br><br>\t&#47;&#47;预先创建11个通道数组,最后一个阻塞主gorouting<br>\tchArr := [11]chan struct{}{}<br>\tfor i := 0; i &lt; 11; i++ {<br>\t\tchArr[i] = make(chan struct{})<br>\t}<br><br>\t&#47;&#47;不阻塞第一个通道<br>\tgo func() {<br>\t\tchArr[0] &lt;- struct{}{}<br>\t}()<br><br>\t&#47;&#47;开始循环<br>\tfor i := 0; i &lt; 10; i++ {<br><br>\t\tgo func(i2 int) {<br>\t\t\t&#47;&#47;阻塞当前通道<br>\t\t\t&lt;-chArr[i2]<br>\t\t\tfmt.Println(i2)<br>\t\t\t&#47;&#47;每次执行完通知下一个通道<br>\t\t\tchArr[i2+1] &lt;- struct{}{}<br>\t\t}(i)<br>\t}<br><br>\t&#47;&#47;阻塞主gorouting<br>\t&lt;-chArr[10]<br><br>}","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518075,"discussion_content":"可以倒是可以，但是搞这么多通道出来，太重了。\n\n这类同步工具从重到轻：通道 =&amp;gt; 读写锁 =&amp;gt; 互斥锁 =&amp;gt; 原子操作。\n\n能轻尽量轻啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617682925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285133,"user_name":"lzh","can_delete":false,"product_type":"c1","uid":1336951,"ip_address":"","ucode":"C3D83DF4230109","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","comment_is_top":false,"comment_ctime":1616637535,"is_pvip":false,"replies":[{"id":"103454","content":"不会啊，最后，当前的M也会与这个G分离，然后运行调度程序去寻找其他的可运行G。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1616653392,"ip_address":"","comment_id":285133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5911604831","product_id":100013101,"comment_content":"老师，问个问题<br>《go并发编程实战-第2版》第136页中说过，P和M绑定后，其内的G会被M执行，如果G进入系统调用阻塞，M和P会被分离，P去找其他空闲M执行内部剩下的G<br>那刚刚阻塞的G和M就一直这么绑定了吗，相当于M对应的系统线程一直在等着吗？<br><br>","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517593,"discussion_content":"不会啊，最后，当前的M也会与这个G分离，然后运行调度程序去寻找其他的可运行G。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616653392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284203,"user_name":"sanmao","can_delete":false,"product_type":"c1","uid":1395689,"ip_address":"","ucode":"D695D88677E3D9","user_header":"https://static001.geekbang.org/account/avatar/00/15/4b/e9/bbccf643.jpg","comment_is_top":false,"comment_ctime":1616121376,"is_pvip":false,"replies":[{"id":"103098","content":"没看懂你说的，++了两次？<br><br>哦...我大概知道了，count++ 不是并发安全的（对 count 的简单读取也不是并发安全的），所以在这次迭代正在 ++ 的时候，另一个迭代可能也执行这块代码。<br><br>所以，可能会导致：<br><br>G2 发现 n 与自己的 i 相等，比方说值都是 2，因此执行了 fn。随后，G2 要执行 count++。但这条语句还没执行完，恰巧 G3 开始执行 n := count，这可能会导致 n 的值是一个即非 2 又非 3 的数（因为 count 所指的内存地址上的二进制位还没有全部变更完毕），所以 G3 （以及后续的 G）永远不会执行 fn。<br><br>首先，我们要知道，CPU和操作系统对这种针对同一个共享资源的非并发安全操作是不保证正确性的。<br><br>其次，上述情况虽然属于小概率事件，但要知道，CPU切换任务的速度相当快，这种“对对碰”的小概率事件在如此快的速度下发生的可能性也不可小觑。<br><br>最后，一旦这种情况发生，问题排查和定位起来就会相当困难，因为情况非常不容易复现，只能碰运气，这极大的增加了程序的维护成本。<br><br>所以，为了程序维护成本考虑，编写程序时多写一点点代码、程序运行时损失一点点性能绝对是上上之策。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1616137101,"ip_address":"","comment_id":284203,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5911088672","product_id":100013101,"comment_content":"\tvar count int32 = 0<br>\ttrigger := func(i int32, fn func()) {<br>\t\tfor {<br>\t\t\tif n := count; n == i {<br>\t\t\t\tfn()<br>\t\t\t\t&#47;&#47;atomic.AddInt32(&amp;count, 1)<br>\t\t\t\tcount++<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t\t&#47;&#47;time.Sleep(time.Nanosecond)<br>\t\t}<br>\t}<br>@郝哥 那种理论情况会发生 count++ 两次的情况？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517269,"discussion_content":"没看懂你说的，++了两次？\n\n哦...我大概知道了，count++ 不是并发安全的（对 count 的简单读取也不是并发安全的），所以在这次迭代正在 ++ 的时候，另一个迭代可能也执行这块代码。\n\n所以，可能会导致：\n\nG2 发现 n 与自己的 i 相等，比方说值都是 2，因此执行了 fn。随后，G2 要执行 count++。但这条语句还没执行完，恰巧 G3 开始执行 n := count，这可能会导致 n 的值是一个即非 2 又非 3 的数（因为 count 所指的内存地址上的二进制位还没有全部变更完毕），所以 G3 （以及后续的 G）永远不会执行 fn。\n\n首先，我们要知道，CPU和操作系统对这种针对同一个共享资源的非并发安全操作是不保证正确性的。\n\n其次，上述情况虽然属于小概率事件，但要知道，CPU切换任务的速度相当快，这种“对对碰”的小概率事件在如此快的速度下发生的可能性也不可小觑。\n\n最后，一旦这种情况发生，问题排查和定位起来就会相当困难，因为情况非常不容易复现，只能碰运气，这极大的增加了程序的维护成本。\n\n所以，为了程序维护成本考虑，编写程序时多写一点点代码、程序运行时损失一点点性能绝对是上上之策。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616137101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603571,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKgNge1sNXIWCFeUOa53cU5Glfw24sjxibBxTiaTb45LmU9bRDlDgBib9goFZXmoKwXTOJ4JMvVHHbiaA/132","nickname":"潘林林","note":"","ucode":"31576141FE4A1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408279,"discussion_content":"针对同一个i值的go程只有一个，不会出现并发问题吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635216607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109433,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ed/b9/825b2411.jpg","nickname":"衡子","note":"","ucode":"0AED79FC9D14BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377934,"discussion_content":"理论上count++不安全，存在并发问题，也只会少加，那种情况会有加两次情况？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622970832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281686,"user_name":"Rico","can_delete":false,"product_type":"c1","uid":2040512,"ip_address":"","ucode":"9EFA5A95F78CCB","user_header":"https://static001.geekbang.org/account/avatar/00/1f/22/c0/177d6750.jpg","comment_is_top":false,"comment_ctime":1614847648,"is_pvip":false,"replies":[{"id":"102262","content":"差不多，但是这里有两个问题：<br><br>1. 不要把 wg 的指针值传来传去，程序复杂之后很容易误操作。在这里可以把 wg 写到函数外边去。<br>2. 这里只用 if 语句是不够的，因为很有可能因条件不满足而错失打印的机会，应该用 for 语句（或者说用自制的简易自旋锁）。<br><br>你的答案在整体思路上是正确的。<br><br>其实这里的流程就是一个“顺序的任务分发”，到“乱序的条件判断”，再到“同步控制下的有序执行（打印）”的过程。考察的是大家对Go异步语句和同步工具的合理使用和配合。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1614855228,"ip_address":"","comment_id":281686,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5909814944","product_id":100013101,"comment_content":"var counter int32<br>func main(){<br><br>\tvar wg sync.WaitGroup<br>\twg.Add(10)<br>    var i int32<br>\tfor i = 0;i&lt;10;i++{<br>\t\tgo printNum(&amp;wg,i)<br>\t\ttime.Sleep(time.Nanosecond)<br>\t}<br><br>}<br><br>func printNum(wg *sync.WaitGroup,i int32){<br>    if i == atomic.LoadInt32(&amp;counter){<br>\t\tfmt.Println(i)<br>\t\tatomic.AddInt32(&amp;counter,1)<br>\t\twg.Done()<br>\t}<br>}<br>---结果顺序打印出 0-9<br><br>老师，这种方法正确不？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516470,"discussion_content":"差不多，但是这里有两个问题：\n\n1. 不要把 wg 的指针值传来传去，程序复杂之后很容易误操作。在这里可以把 wg 写到函数外边去。\n2. 这里只用 if 语句是不够的，因为很有可能因条件不满足而错失打印的机会，应该用 for 语句（或者说用自制的简易自旋锁）。\n\n你的答案在整体思路上是正确的。\n\n其实这里的流程就是一个“顺序的任务分发”，到“乱序的条件判断”，再到“同步控制下的有序执行（打印）”的过程。考察的是大家对Go异步语句和同步工具的合理使用和配合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614855228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247945,"user_name":"梁辉","can_delete":false,"product_type":"c1","uid":1809024,"ip_address":"","ucode":"07A83A2801E6AE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9a/80/3a8781a4.jpg","comment_is_top":false,"comment_ctime":1599927673,"is_pvip":false,"replies":[{"id":"91126","content":"有几个问题：<br>1. count 是共享变量，对它的读写必须有同步工具的保护。<br>2. subChan 是多余的。<br>3. wg.Done() 最好写在 defer 函数里，否则万一出了异常会锁死程序。<br>4. struct{}{} 本身就是个全局唯一的常量，没必要再赋给一个变量。 <br>5. 为什么非要用闭包？能不用闭包就不要用闭包。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1599982134,"ip_address":"","comment_id":247945,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5894894969","product_id":100013101,"comment_content":"试了一下，下面代码可以：<br>package main<br><br>import &quot;fmt&quot;<br>import &quot;sync&quot;<br>import &quot;time&quot;<br><br>func main() {<br>\twg := sync.WaitGroup{}<br>\tsubChan := make(chan struct {}, 1)<br>\twg.Add(10)<br>\tst := struct{}{}<br>\tsubChan &lt;- st<br>\tfuncPrint := subPrint(subChan, &amp;wg)<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tfuncPrint(i)<br>\t}<br>\twg.Wait()<br>}<br><br>func subPrint(subChan chan struct{}, wg *sync.WaitGroup) func(int) {<br>\tcount := 0<br>\tsubCount := func (sub int) {<br>\t\tfor {<br>\t\t\tif count == sub {<br>\t\t\t\t&lt;-subChan<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t\ttime.Sleep(time.Nanosecond)<br>\t\t}<br><br>\t\tfmt.Println(&quot;sub : &quot;, sub)<br>\t\tcount++<br>\t\tst := struct{}{}<br>\t\tsubChan &lt;- st<br>\t\twg.Done()<br>\t}<br>\treturn subCount<br>}","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505534,"discussion_content":"有几个问题：\n1. count 是共享变量，对它的读写必须有同步工具的保护。\n2. subChan 是多余的。\n3. wg.Done() 最好写在 defer 函数里，否则万一出了异常会锁死程序。\n4. struct{}{} 本身就是个全局唯一的常量，没必要再赋给一个变量。 \n5. 为什么非要用闭包？能不用闭包就不要用闭包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599982134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240450,"user_name":"onlyzzw","can_delete":false,"product_type":"c1","uid":1071832,"ip_address":"","ucode":"A29EB66014EFAD","user_header":"https://static001.geekbang.org/account/avatar/00/10/5a/d8/cb1045ed.jpg","comment_is_top":false,"comment_ctime":1596936377,"is_pvip":false,"replies":[{"id":"88834","content":"这是一种“取巧”的方式，不可取。异步代码的天性就是执行顺序的不确定。一秒钟是足够如此简单的goroutine启动并执行了，但真实的情况要比这复杂的多。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1597031132,"ip_address":"","comment_id":240450,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5891903673","product_id":100013101,"comment_content":"func main() {<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\ttime.Sleep(time.Duration(1)*time.Second)<br>\t\tgo func() {<br>\t\t\tfmt.Println(i)<br>\t\t}()<br>\t}<br>}<br><br>结果也能按照顺序打印输出：1，2，3，4，5，6，7，8，9","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503448,"discussion_content":"这是一种“取巧”的方式，不可取。异步代码的天性就是执行顺序的不确定。一秒钟是足够如此简单的goroutine启动并执行了，但真实的情况要比这复杂的多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597031132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233565,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1594355631,"is_pvip":false,"replies":[{"id":"86330","content":"count是多goroutine都能访问到的变量，不是说你感觉上不会有竞争就没竞争，你要考虑CPU指令和cache、核心间的通讯及同步，以及操作系统的调度策略和行为。<br><br>如果没有任何同步措施，count 在 ++ 的时候有可能加到一半就被撤下CPU了（这时的count的值就不一定是你规定好的那些了）。另外，多个CPU的cache中缓存的count的值也可能出现不一致的情况。这些都是隐患。CPU级别的同步，各级cache间的协调，其最小粒度都是CPU指令，决不是说编程语言的语句上不能再拆分就不会有并发安全问题。这两者的粒度完全不在一个级别。<br><br>更具体的东西，你可以看我写的那本《Go并发编程实战》第二版，里边描述的并发模型是历久弥新的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1594548924,"ip_address":"","comment_id":233565,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5889322927","product_id":100013101,"comment_content":"trigger := func(i uint32, fn func()) { for { if n := atomic.LoadUint32(&amp;count); n == i { fn() atomic.AddUint32(&amp;count, 1) break } time.Sleep(time.Nanosecond) }}<br><br>个人感觉这个不需要用原子操作也可以，虽然发生了竞争，只是增加了判断的次数，不知道理解的对不对？<br>可以改成这样<br> for {<br>    if i == count {<br>       fn()<br>       count++<br>       break<br>     }<br>}<br><br>作者回复: 连原子操作都不加，就有可能会出现不完全写或读出脏数据的情况，最终导致程序死锁在那里。在写并发程序时不要有侥幸心理。不管概率有多大（况且不会是小概率），都是有可能发生的。一旦发生，损失和成本都是不容小觑的。<br><br>对您说的发生死锁的情况不太理解，能理解脏读的情况，但是针对这个题目来说，传过来的i肯定是0到10之前不会重复的，就算读到了脏数据，也和count的值不一致，不会进入到if语句里面。而且不存在并行的count++ 操作，只有并行的获取count。所以最后肯定是已顺序读出来的。 所以并不理解所说的导致死锁的情况，能否指明一种情况产生死锁","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501089,"discussion_content":"count是多goroutine都能访问到的变量，不是说你感觉上不会有竞争就没竞争，你要考虑CPU指令和cache、核心间的通讯及同步，以及操作系统的调度策略和行为。\n\n如果没有任何同步措施，count 在 ++ 的时候有可能加到一半就被撤下CPU了（这时的count的值就不一定是你规定好的那些了）。另外，多个CPU的cache中缓存的count的值也可能出现不一致的情况。这些都是隐患。CPU级别的同步，各级cache间的协调，其最小粒度都是CPU指令，决不是说编程语言的语句上不能再拆分就不会有并发安全问题。这两者的粒度完全不在一个级别。\n\n更具体的东西，你可以看我写的那本《Go并发编程实战》第二版，里边描述的并发模型是历久弥新的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594548924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1987829,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoOia8n2xdlIBYWVBmevjIuaMickvceJ2JX4IHOaibrmEWmia1gM29jhjLCJcYU9lSXLInNlToAbc5Gg/132","nickname":"张伟","note":"","ucode":"3A45B9536F91E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371367,"discussion_content":"和数据库的事务一致性很像，事务必须保证事务未提交前，其他事务是看不到这个值的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619748543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1987829,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoOia8n2xdlIBYWVBmevjIuaMickvceJ2JX4IHOaibrmEWmia1gM29jhjLCJcYU9lSXLInNlToAbc5Gg/132","nickname":"张伟","note":"","ucode":"3A45B9536F91E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371365,"discussion_content":"可以这样抽象理解，如果count++执行到一半，得到了100的一个值，而恰好另个grontine 正好要检测100于是乎，100前面的可能还没执行完成就，先把100打印出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619748408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1563985,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","nickname":"Geek_a8be59","note":"","ucode":"BEC0F57B51DC44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291070,"discussion_content":"谢谢 ，这样一说我总算明白了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594697913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231356,"user_name":"刘小贱","can_delete":false,"product_type":"c1","uid":1199861,"ip_address":"","ucode":"3BCBA391F92828","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/f5/1d3f13f3.jpg","comment_is_top":false,"comment_ctime":1593657139,"is_pvip":false,"replies":[{"id":"85455","content":"肉眼看上去应该可以，不过signal没必要存在，用WaitGroup更简单高效。另外，通道做起来要比原子操作慢不少。请记住，通道的主要目的是并发安全地传递数据，而不是存储数据。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1593668104,"ip_address":"","comment_id":231356,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5888624435","product_id":100013101,"comment_content":"&#47;&#47;老师  两个通道实现方式 不知道对不对<br>\tch := make(chan int,1)<br>\tsignal := make(chan struct{})<br>\tvar num = 10<br>\tfor i := 0; i &lt; num; i++ {<br>\t\tgo func(i int) {<br>\t\t\tfor  {<br>\t\t\t\t&#47;&#47; 先阻塞在这里<br>\t\t\t\tt := &lt;-ch<br>\t\t\t\tif t == i {<br>\t\t\t\t\tfmt.Printf(&quot;%d\\n&quot;, i)<br>\t\t\t\t\tp := i+1<br>\t\t\t\t\tif p == num {<br>\t\t\t\t\t\t&#47;&#47; 结束信号<br>\t\t\t\t\t\tsignal &lt;- struct{}{}<br>\t\t\t\t\t\tbreak<br>\t\t\t\t\t} else  {<br>\t\t\t\t\t\tch &lt;- p<br>\t\t\t\t\t\tbreak<br>\t\t\t\t\t}<br>\t\t\t\t} else {<br>\t\t\t\t\tch &lt;- t<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}(i)<br>\t}<br><br>\tch &lt;- 0<br><br>\t&lt;- signal","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500271,"discussion_content":"肉眼看上去应该可以，不过signal没必要存在，用WaitGroup更简单高效。另外，通道做起来要比原子操作慢不少。请记住，通道的主要目的是并发安全地传递数据，而不是存储数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593668104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228064,"user_name":"杉松壁","can_delete":false,"product_type":"c1","uid":1080578,"ip_address":"","ucode":"ED904CE27CD3C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/02/4862f849.jpg","comment_is_top":false,"comment_ctime":1592547191,"is_pvip":false,"replies":[{"id":"84680","content":"当然会平衡，详见《Go并发编程实战》这本书。至于 CPU Cache 失效，就是另外一个问题了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1592989156,"ip_address":"","comment_id":228064,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5887514487","product_id":100013101,"comment_content":"调度器会平衡各个G任务的执行时间吗？会不会导致CPU的上下文切换，cpu cache失效","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498910,"discussion_content":"当然会平衡，详见《Go并发编程实战》这本书。至于 CPU Cache 失效，就是另外一个问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592989156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190715,"user_name":"Cyril","can_delete":false,"product_type":"c1","uid":1024693,"ip_address":"","ucode":"29FFFAC32F911B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/b5/4dc0c109.jpg","comment_is_top":false,"comment_ctime":1584686566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879653862","product_id":100013101,"comment_content":"重点记录：<br><br>Go 调度器在需要的时候只会对正在运行的 goroutine 发出通知，试图让它停下来。但是，它却不会也不能强行让一个 goroutine 停下来。<br><br>所以，如果一条 for 语句过于简单的话，比如这里的 for 语句就很简单（因为里面只有一条 if 语句），那么当前的 goroutine 就可能不会去正常响应（或者说没有机会响应）Go 调度器的停止通知。<br><br>因此，这里加一个 sleep 是为了：在任何情况下（如任何版本的 Go、任何计算平台下的 Go、任何的 CPU 核心数等），内含这条 for 语句的这些 goroutine 都能够正常地响应停止通知。","like_count":1},{"had_liked":false,"id":180528,"user_name":"waterd","can_delete":false,"product_type":"c1","uid":1499106,"ip_address":"","ucode":"30F4FE973CF221","user_header":"","comment_is_top":false,"comment_ctime":1582306122,"is_pvip":false,"replies":[{"id":"70217","content":"应该是demo39。你可以把sign的大小设置成1，但是那样的话就相当于完全串行了，也就失去了使用go语句的意义。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1582459646,"ip_address":"","comment_id":180528,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5877273418","product_id":100013101,"comment_content":"demo38的代码中sign的通道大小可以设置为1对吧?","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484695,"discussion_content":"应该是demo39。你可以把sign的大小设置成1，但是那样的话就相当于完全串行了，也就失去了使用go语句的意义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582459646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","nickname":"沐夜星光","note":"","ucode":"22F699E237B179","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269955,"discussion_content":"设置成1 ，go语句中的Print（i）也是并发执行的吧，只不过每个goroutine的结束需要等待通道了，如果设置成10，10个goroutine的结束是不需要等待的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589968353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174361,"user_name":"MigToLoveYou","can_delete":false,"product_type":"c1","uid":1525620,"ip_address":"","ucode":"7509C573AF4CB3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJzxnS95wOcdxepAOBZxJlvxNAEryDsV7GaJ5dOPHicqqcj1PtSFK4pibqJD03ic0U88jOkvYiaBLCAKg/132","comment_is_top":false,"comment_ctime":1580180720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875148016","product_id":100013101,"comment_content":"老师写的例子相当于用异步的go routine实现了一个全局变量count的递增，并且这些帮助全局变量递增的go routine是按照参数i的顺序依次帮助这个全局变量递增，在轮到i这个go routine时，它递增变量count并且打印当前的count值。这个例子设计非常巧妙，短小的例子涵盖了非常多的知识点。","like_count":1},{"had_liked":false,"id":144242,"user_name":"Jee","can_delete":false,"product_type":"c1","uid":1198458,"ip_address":"","ucode":"B80BBF2D2EB116","user_header":"https://static001.geekbang.org/account/avatar/00/12/49/7a/b567de82.jpg","comment_is_top":false,"comment_ctime":1571881678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866848974","product_id":100013101,"comment_content":"runtime.GOMAXPROCS  runtime.NumCPU runtime.NumGoroutine","like_count":1},{"had_liked":false,"id":120377,"user_name":"黄伟洪","can_delete":false,"product_type":"c1","uid":1369165,"ip_address":"","ucode":"97331040A49EAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/e4/4d/c7b5f20a.jpg","comment_is_top":false,"comment_ctime":1564848824,"is_pvip":false,"replies":[{"id":"44302","content":"在某些计算平台下，过于简单的 for 语句有可能会造成 CPU 时间片无法让出的问题。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1564972365,"ip_address":"","comment_id":120377,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859816120","product_id":100013101,"comment_content":"demo40.go 我注释了time.Sleep(time.Nanosecond)后，程序就停着一直不动了。。。。。想不明白为什么","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461306,"discussion_content":"在某些计算平台下，过于简单的 for 语句有可能会造成 CPU 时间片无法让出的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564972365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73057,"user_name":"Wind","can_delete":false,"product_type":"c1","uid":1211134,"ip_address":"","ucode":"1F16D751DBBAF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/7a/fe/9263d515.jpg","comment_is_top":false,"comment_ctime":1551786368,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"5846753664","product_id":100013101,"comment_content":"func main(){<br>    ch := make(chan struct{})<br>    for i:=0; i &lt; 100; i++{<br>        go func(i int){<br>            fmt.Println(i)<br>            ch &lt;- struct{}{}<br>        }(i)<br>        &lt;-ch<br>    }<br>}<br>亲测可以，而且循环的前提是必须上一个通道不阻塞的情况下才能继续，这样的确可以保证按顺序输出","like_count":1,"discussions":[{"author":{"id":1018685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/3d/0c3a2fd4.jpg","nickname":"偶尔复活下","note":"","ucode":"18B1D525CD50D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401580,"discussion_content":"只是实现了顺序输出数字，但与题意要求的不符","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633695342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1557834,"avatar":"https://static001.geekbang.org/account/avatar/00/17/c5/4a/340bda41.jpg","nickname":"水阡墨","note":"","ucode":"87C949F0E295A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341096,"discussion_content":"明白了，你这完全是同步逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610288818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1557834,"avatar":"https://static001.geekbang.org/account/avatar/00/17/c5/4a/340bda41.jpg","nickname":"水阡墨","note":"","ucode":"87C949F0E295A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341095,"discussion_content":"这个例子可以？？？没看懂这怎么会可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610288705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1084378,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8b/da/c3c2a324.jpg","nickname":"空白","note":"","ucode":"1E1E05CF8A7B1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322343,"discussion_content":"这样不就变成阻塞同步逻辑了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604727806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62287,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1548002007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5842969303","product_id":100013101,"comment_content":"打卡：<br>trigger处理按顺序输出，如果不符合count的递增顺序那就死循环着ing；最后一次调用trigger是阻塞主goroutine，以保证一定要输出到9才结束","like_count":1},{"had_liked":false,"id":25859,"user_name":"cygnus","can_delete":false,"product_type":"c1","uid":1120452,"ip_address":"","ucode":"C60A86E3084754","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/c4/e55fdc1c.jpg","comment_is_top":false,"comment_ctime":1537454737,"is_pvip":false,"replies":[{"id":"9675","content":"demo40.go我小改进了下，你再试试。我在服务器上也没出现你说的这个问题。Go语言很早的版本有可能这样，但是现在肯定不会了。你可联系下极客时间编辑，让她们把你加到群里。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537691168,"ip_address":"","comment_id":25859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5832422033","product_id":100013101,"comment_content":"“””demo40的执行结果不是幂等的，程序经常无法正常结束退出，只有极少数几次有正确输出。<br>2018-09-19<br> 作者回复<br>你在win下执行的嘛？“”“<br>是在ubuntu 1804下执行的","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424435,"discussion_content":"demo40.go我小改进了下，你再试试。我在服务器上也没出现你说的这个问题。Go语言很早的版本有可能这样，但是现在肯定不会了。你可联系下极客时间编辑，让她们把你加到群里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537691168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355359,"user_name":"花见笑","can_delete":false,"product_type":"c1","uid":1219485,"ip_address":"广东","ucode":"8A5122BC11E695","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/9d/d487c368.jpg","comment_is_top":false,"comment_ctime":1661314993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661314993","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;sync&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tvar mu sync.Mutex<br>\tq := 0<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func(i int) {<br>\t\t\tmu.Lock()<br>\t\t\tq = q + 1<br>\t\t\tfmt.Println(q,i)<br>\t\t\tmu.Unlock()<br>\t\t}(i)<br>\t}<br>\ttime.Sleep(10*time.Second)<br>}","like_count":0},{"had_liked":false,"id":347707,"user_name":"Jonathan","can_delete":false,"product_type":"c1","uid":1484965,"ip_address":"","ucode":"031E0DC776E8A0","user_header":"https://static001.geekbang.org/account/avatar/00/16/a8/a5/27466113.jpg","comment_is_top":false,"comment_ctime":1654332266,"is_pvip":true,"replies":[{"id":"126790","content":"问题：这里的 count 属于共享变量，然而它并没有受到应用的读&#47;写保护。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1654495616,"ip_address":"","comment_id":347707,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1654332266","product_id":100013101,"comment_content":"让并行的 goroutine 按照某一个条件顺序执行，主要是多个goroutine有一个共同的判断条件。只需要声明一个全局变量即可，不需要用原子类型也能做到，因为判断条件在某一个时刻，只有一个goroutine会符合要求。<br><br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tcount := 0<br>\tfor i := 0; i &lt; 100; i++ {<br>\t\tgo func(i int) {<br>\t\t\tfor {<br>\t\t\t\tif count == i {<br>\t\t\t\t\tfmt.Println(i)<br>\t\t\t\t\tcount += 1<br>\t\t\t\t\tbreak<br>\t\t\t\t} else {<br>\t\t\t\t\ttime.Sleep(time.Nanosecond)<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}(i)<br>\t}<br>\ttime.Sleep(time.Second * 5)<br>}<br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574956,"discussion_content":"问题：这里的 count 属于共享变量，然而它并没有受到应用的读/写保护。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654495616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346256,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1652948934,"is_pvip":false,"replies":[{"id":"126632","content":"不错。通道是比较重的同步&#47;异步工具，主要的目的是传递“消息”。所以，如果是单纯做同步的话，优先考虑原子操作和锁。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1653893227,"ip_address":"","comment_id":346256,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652948934","product_id":100013101,"comment_content":"受到老师的启发，我用单纯的通道去实现了一下，只是代码的优雅性和消耗比老师的大<br>func Comp(i, max int, c, out chan int) {<br>\tfor {<br>\t\tin := &lt;-c<br>\t\tif i == in {<br>\t\t\tfmt.Println(i)<br>\t\t\tin++<br>\t\t\tif in == max {<br>\t\t\t\tout &lt;- in<br>\t\t\t} else {<br>\t\t\t\tc &lt;- in<br>\t\t\t}<br>\t\t\tbreak<br>\t\t} else {<br>\t\t\tc &lt;- in<br>\t\t\ttime.Sleep(10 * time.Millisecond)<br>\t\t}<br>\t}<br><br>}<br>func main() {<br>\tinChan := make(chan int, 1)<br>\toutChan := make(chan int, 1)<br>\tinChan &lt;- 0<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func(i int, max int) {<br>\t\t\tComp(i, max, inChan, outChan)<br>\t\t}(i, 10)<br>\t}<br><br>\t&lt;-outChan<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574189,"discussion_content":"不错。通道是比较重的同步/异步工具，主要的目的是传递“消息”。所以，如果是单纯做同步的话，优先考虑原子操作和锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653893227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342620,"user_name":"Ll","can_delete":false,"product_type":"c1","uid":2035323,"ip_address":"","ucode":"72F7F5907BE4AB","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0e/7b/800784a9.jpg","comment_is_top":false,"comment_ctime":1650366850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650366850","product_id":100013101,"comment_content":"\taction := func(i int) {<br>\t\tfmt.Println(&quot;第&quot;+strconv.Itoa(i+1)+&quot;个子协程要第&quot;+strconv.Itoa(i+1)+&quot;个执行&quot;)<br>\t}<br>\twg := sync.WaitGroup{}<br>\tvar actionNum uint32 = 0<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\twg.Add(1)<br>\t\tgo func(i int) {<br>\t\t\tfor {<br>\t\t\t\tif n := atomic.LoadUint32(&amp;actionNum); n == uint32(i) {<br>\t\t\t\t\tatomic.AddUint32(&amp;actionNum, 1)<br>\t\t\t\t\taction(i)<br>\t\t\t\t\tbreak<br>\t\t\t\t}<br>\t\t\t\ttime.Sleep(time.Nanosecond)<br>\t\t\t}<br>\t\t\twg.Done()<br>\t\t}(i)<br>\t}<br>\tfmt.Println(&quot;这里有可能在某些子协程之前执行&quot;)<br>\twg.Wait()","like_count":0},{"had_liked":false,"id":333498,"user_name":"小嘟嘟","can_delete":false,"product_type":"c1","uid":1285055,"ip_address":"","ucode":"1584DD1402502D","user_header":"https://static001.geekbang.org/account/avatar/00/13/9b/bf/a76eadff.jpg","comment_is_top":false,"comment_ctime":1644388100,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644388100","product_id":100013101,"comment_content":"for循环中也可以使用 i := i,   这种也可以让go func 获取到正常变量值","like_count":0},{"had_liked":false,"id":329175,"user_name":"符佳成fjc","can_delete":false,"product_type":"c1","uid":2875604,"ip_address":"","ucode":"DAC86F7BBF8085","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e0/d4/63647ae9.jpg","comment_is_top":false,"comment_ctime":1641196699,"is_pvip":false,"replies":[{"id":"119914","content":"任何编程语言的普通数据读写都不能保证原子性啊，都需要手动添加保护措施的。<br><br>这条语句 atomic.LoadUint32(&amp;count) 的含义是，在访问存有 count 值的存储空间时保证原子性的读取。<br><br>至于后续把这项数据与标识符 n 绑定，那就是另一件事了。如果 n 也代表着共享资源，那么在赋给它值的时候，或者说在把某项数据与 n 绑定的时候，也应该手动施加保护措施。<br><br>相对应的，n := count 没有任何的保护措施，它是非并发安全的。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1641267155,"ip_address":"","comment_id":329175,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641196699","product_id":100013101,"comment_content":"1，golang读取数据都不是原子操作？<br>2，n := atomic.LoadUint32(&amp;count)，把一个原子操作得到的临时变量赋值给n 和 直接把count拷贝给n有什么区别？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543679,"discussion_content":"任何编程语言的普通数据读写都不能保证原子性啊，都需要手动添加保护措施的。\n\n这条语句 atomic.LoadUint32(&amp;count) 的含义是，在访问存有 count 值的存储空间时保证原子性的读取。\n\n至于后续把这项数据与标识符 n 绑定，那就是另一件事了。如果 n 也代表着共享资源，那么在赋给它值的时候，或者说在把某项数据与 n 绑定的时候，也应该手动施加保护措施。\n\n相对应的，n := count 没有任何的保护措施，它是非并发安全的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641267155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324383,"user_name":"vash_ace","can_delete":false,"product_type":"c1","uid":1128044,"ip_address":"","ucode":"057B4EC8850187","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqmEvxVYib6zYId0bUFdt7ogolM4blZllpzaU1HIju63ib4cut4xHdm4ibTxG8vPoEJEwq5KwBdpkKibw/132","comment_is_top":false,"comment_ctime":1638410858,"is_pvip":false,"replies":[{"id":"117716","content":"你怎么知道 count 在某一时刻一定是某个完整的值呢？如果它在被修改到一半的时候被读取呢？在某些机器上确实有可能发生这种情况的。（你所假设的“count 的值一定会是一个范围在 [0, 10) 的整数”其实是不成立的）<br><br>另外，在这个例子里，如果某个 goroutine 错过了 n==i 这个条件成立，那么它将永远没有打印序号的机会。<br><br>所以，不要存在侥幸心理，访问共享资源的所有操作都一定要有相应的保护，否则一旦上线后发生问题，你定位问题将会非常非常困难（这将会是噩梦）。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1638418792,"ip_address":"","comment_id":324383,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1638410858","product_id":100013101,"comment_content":"if n := atomic.LoadUint32(&amp;count); n == i <br>老师，在多个go顺序打印的例子中，我觉得atomic.LoadUint32(&amp;count);完全没必要，因为你有n==i(这个i相当于线程ID了，是固定的)这个逻辑控制着，并发读count值，顶多是获取不到最新的count值(因为if中的atomic count++保证了)，然后sleep而已，等待下一轮的并发读取。我不知道这样理解，对不对？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535361,"discussion_content":"你怎么知道 count 在某一时刻一定是某个完整的值呢？如果它在被修改到一半的时候被读取呢？在某些机器上确实有可能发生这种情况的。（你所假设的“count 的值一定会是一个范围在 [0, 10) 的整数”其实是不成立的）\n\n另外，在这个例子里，如果某个 goroutine 错过了 n==i 这个条件成立，那么它将永远没有打印序号的机会。\n\n所以，不要存在侥幸心理，访问共享资源的所有操作都一定要有相应的保护，否则一旦上线后发生问题，你定位问题将会非常非常困难（这将会是噩梦）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638418792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128044,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqmEvxVYib6zYId0bUFdt7ogolM4blZllpzaU1HIju63ib4cut4xHdm4ibTxG8vPoEJEwq5KwBdpkKibw/132","nickname":"vash_ace","note":"","ucode":"057B4EC8850187","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535611,"discussion_content":"我是java用户，但我猜想golang也会有类似内存屏障的概念吧，所以我不知道老师您说的什么情况下会读取不到完整的count值呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638495603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322892,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1252353,"ip_address":"","ucode":"70351D4FAE47F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","comment_is_top":false,"comment_ctime":1637648737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637648737","product_id":100013101,"comment_content":"```<br>func orderRoutine() {<br>\tcount := uint32(0) &#47;&#47;信号量<br>\ttrigger := func(n uint32, fn func()) {<br>\t\tfor {<br>\t\t\tif nc := atomic.LoadUint32(&amp;count); n == nc {<br>\t\t\t\tfn()<br>\t\t\t\tatomic.AddUint32(&amp;count, 1) &#47;&#47;信号的值总是下一个可以调用打印函数的go函数的序号<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t\ttime.Sleep(time.Nanosecond) &#47;&#47;进入下一个迭代<br>\t\t}<br>\t}<br><br>\tprint := func(ii int) {<br>\t\tfn := func() {<br>\t\t\tfmt.Println(ii)<br>\t\t}<br>\t\ttrigger(uint32(ii), fn) &#47;&#47; 安全进行并发打印<br>\t}<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo print(i)<br>\t}<br><br>\ttrigger(uint32(10), func() {}) &#47;&#47; 确保count达到10后退出<br>}<br>```","like_count":0},{"had_liked":false,"id":311796,"user_name":"5-刘新波(Arvin)","can_delete":false,"product_type":"c1","uid":1174199,"ip_address":"","ucode":"DBD135D2587A93","user_header":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","comment_is_top":false,"comment_ctime":1631464453,"is_pvip":false,"replies":[{"id":"112982","content":"别急，接着往后看。<br><br>这里主要是为了给大家演示 goroutine 的“运行时机的不确定性”，还没有讲到 channel 和各种同步工具。另外，这里也考察和展示了一下最基本的同步手段（很多同步工具都含有“自旋”的逻辑）。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1631512578,"ip_address":"","comment_id":311796,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631464453","product_id":100013101,"comment_content":"异步改同步，感觉trigger函数自旋利用率不高哇","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526748,"discussion_content":"别急，接着往后看。\n\n这里主要是为了给大家演示 goroutine 的“运行时机的不确定性”，还没有讲到 channel 和各种同步工具。另外，这里也考察和展示了一下最基本的同步手段（很多同步工具都含有“自旋”的逻辑）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631512578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281710,"user_name":"Rico","can_delete":false,"product_type":"c1","uid":2040512,"ip_address":"","ucode":"9EFA5A95F78CCB","user_header":"https://static001.geekbang.org/account/avatar/00/1f/22/c0/177d6750.jpg","comment_is_top":false,"comment_ctime":1614854297,"is_pvip":false,"replies":[{"id":"102310","content":"小问题：通道算是比较重的工具，这里可以用更轻一些的工具。<br><br>大问题：“counter1 == i”这里，如果要保护 counter1 就要保护完全，读的时候也要用原子操作。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1614923478,"ip_address":"","comment_id":281710,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1614854297","product_id":100013101,"comment_content":"package main<br><br>import (<br>   &quot;fmt&quot;<br>   &quot;sync&#47;atomic&quot;<br>   &quot;time&quot;<br>)<br><br>&#47;&#47; 启用goroutine,使用 channel控制,按顺序打印出0-9<br>var counter1 int32<br><br>func main(){<br>   var i int32<br>   coutCh := make(chan struct{},1)<br>   coutCh &lt;- struct{}{}<br><br>   for i= 0;i&lt;10;i++{<br>      go printfNum(i,coutCh)<br>      time.Sleep(time.Nanosecond)<br>   }<br><br>}<br>func printfNum(i int32,ch chan struct{})  {<br>   for  {<br>      if counter1 == i {<br>         &lt;- ch<br>         fmt.Println(i)<br>         atomic.AddInt32(&amp;counter1,1)<br>         ch &lt;- struct{}{}<br>         return<br>      }<br><br>   }<br><br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516479,"discussion_content":"小问题：通道算是比较重的工具，这里可以用更轻一些的工具。\n\n大问题：“counter1 == i”这里，如果要保护 counter1 就要保护完全，读的时候也要用原子操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614923478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247950,"user_name":"梁辉","can_delete":false,"product_type":"c1","uid":1809024,"ip_address":"","ucode":"07A83A2801E6AE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9a/80/3a8781a4.jpg","comment_is_top":false,"comment_ctime":1599929390,"is_pvip":false,"replies":[{"id":"91127","content":"不要为了使用闭包而闭包，尽量简化程序。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1599982176,"ip_address":"","comment_id":247950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599929390","product_id":100013101,"comment_content":"刚学一个月，老师的课程有些难懂，我使用了闭包，测试也是可以达到效果，代码如下，请老师指正：<br>package main<br><br>import &quot;fmt&quot;<br>import &quot;sync&quot;<br>import &quot;time&quot;<br><br>func main() {<br>\twg := sync.WaitGroup{}<br>\twg.Add(10)<br>\tfuncPrint := subPrint(&amp;wg)<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func(x int) {<br>\t\t\tfuncPrint(x)<br>\t\t}(i)<br>\t}<br>\twg.Wait()<br>}<br><br>func subPrint(wg *sync.WaitGroup) func(int) {<br>\tcount := 0<br>\tsubChan := make(chan struct {}, 1)<br>\tst := struct{}{}<br>\tsubChan &lt;- st<br>\tsubCount := func (sub int) {<br>\t\tfor {<br>\t\t\tif count == sub {<br>\t\t\t\t&lt;-subChan<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t\ttime.Sleep(time.Nanosecond)<br>\t\t}<br><br>\t\tfmt.Println(&quot;sub : &quot;, sub)<br>\t\tcount++<br>\t\tst := struct{}{}<br>\t\tsubChan &lt;- st<br>\t\twg.Done()<br>\t}<br>\treturn subCount<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505538,"discussion_content":"不要为了使用闭包而闭包，尽量简化程序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599982176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247948,"user_name":"梁辉","can_delete":false,"product_type":"c1","uid":1809024,"ip_address":"","ucode":"07A83A2801E6AE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9a/80/3a8781a4.jpg","comment_is_top":false,"comment_ctime":1599928095,"is_pvip":false,"replies":[{"id":"91130","content":"这个我就不重复说了，问题类似。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1599982242,"ip_address":"","comment_id":247948,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599928095","product_id":100013101,"comment_content":"使用闭包的方式也可以，复杂了些，代码如下，测试过，是可以的：<br>package main<br><br>import &quot;fmt&quot;<br>import &quot;sync&quot;<br>import &quot;time&quot;<br><br>func main() {<br>\twg := sync.WaitGroup{}<br>\tsubChan := make(chan struct {}, 1)<br>\twg.Add(10)<br>\tst := struct{}{}<br>\tsubChan &lt;- st<br>\tfuncPrint := subPrint(subChan, &amp;wg)<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tfuncPrint(i)<br>\t}<br>\twg.Wait()<br>}<br><br>func subPrint(subChan chan struct{}, wg *sync.WaitGroup) func(int) {<br>\tcount := 0<br>\tsubCount := func (sub int) {<br>\t\tfor {<br>\t\t\tif count == sub {<br>\t\t\t\t&lt;-subChan<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t\ttime.Sleep(time.Nanosecond)<br>\t\t}<br><br>\t\tfmt.Println(&quot;sub : &quot;, sub)<br>\t\tcount++<br>\t\tst := struct{}{}<br>\t\tsubChan &lt;- st<br>\t\twg.Done()<br>\t}<br>\treturn subCount<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505537,"discussion_content":"这个我就不重复说了，问题类似。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599982242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240212,"user_name":"小奕","can_delete":false,"product_type":"c1","uid":1171471,"ip_address":"","ucode":"5294DD5895D602","user_header":"https://static001.geekbang.org/account/avatar/00/11/e0/0f/12e08ce9.jpg","comment_is_top":false,"comment_ctime":1596789421,"is_pvip":false,"replies":[{"id":"88729","content":"因为这些 goroutine 几乎在第一次检查 counter 的值的时候就发现符合自己的期望（根本就没有再循环检查的必要）。别忘了，CPU时钟那是极快的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1596862229,"ip_address":"","comment_id":240212,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596789421","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;sync&#47;atomic&quot;<br>\t&quot;time&quot;<br>)<br><br>var counter int32<br><br>func trigger(i int32)  {<br>\tfor {<br>\t\tif atomic.LoadInt32(&amp;counter) == i {<br>\t\t\tfmt.Println(i)<br>\t\t\tatomic.AddInt32(&amp;counter, 1)<br>\t\t\tbreak<br>\t\t}<br>\t\ttime.Sleep(time.Second)<br>\t}<br>}<br><br>func main() {<br>\tfor i:=0; i&lt;10; i++ {<br>\t\tgo trigger(int32(i))<br>\t}<br>\ttrigger(int32(10))<br>}<br>按我的理解，抛开创建10个goroutine的过程不计，此实现，相当于创建10个等待器，通过原子操作共享一个counter值，各等待器分别进行循环匹配，如果counter值与自身的i值相同就进行打印、增加counter值并退出自身循环，那正常来说应该是10秒钟结束，为什么实际运行都会低于10秒，有时候2秒就处理完了？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503375,"discussion_content":"因为这些 goroutine 几乎在第一次检查 counter 的值的时候就发现符合自己的期望（根本就没有再循环检查的必要）。别忘了，CPU时钟那是极快的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596862229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236094,"user_name":"Geek_17ce06","can_delete":false,"product_type":"c1","uid":2066975,"ip_address":"","ucode":"7EA9ECC3C88FF6","user_header":"","comment_is_top":false,"comment_ctime":1595314188,"is_pvip":false,"replies":[{"id":"87317","content":"你好，这里考察的是：怎样控制多个goroutine的执行顺序，而不是结果的打印顺序。如果考察的是后者，那未免也太小儿科了。：）","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1595388434,"ip_address":"","comment_id":236094,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1595314188","product_id":100013101,"comment_content":"package main<br><br>import (<br>&quot;fmt&quot;<br>&quot;sync&quot;<br>)<br><br>type fn func()<br>type AAA struct {<br>id int<br>do fn<br>}<br><br>func main() {<br>slice := make([]fn, 10)<br>waitCh := make(chan AAA, 10)<br>var wg sync.WaitGroup<br>for i := 0; i &lt; 10; i++ {<br>wg.Add(1)<br>go func(i int, wg *sync.WaitGroup) {<br>defer wg.Done()<br>fn := func() {<br>fmt.Println(i)<br>}<br>waitCh &lt;- AAA{<br>id: i,<br>do: fn,<br>}<br>}(i, &amp;wg)<br>}<br>wg.Wait()<br>close(waitCh)<br>for aaa := range waitCh {<br>slice[aaa.id] = aaa.do<br>}<br>for _, do := range slice {<br>do()<br>}<br>}<br><br>作者回复: 绕远了。<br><br>郝老师您好,这是我第二次新注册个账号来看36讲,因为之前试看的7天已经到期了哈哈哈,因为刚刚毕业兜里囊中羞涩,我的理解是这样子的,问题的本质是对并发程序发出后,控制返回的顺序,那么我就想到先建10个槽,当某个go程任务完成后就把结果返回到与自己id对应的那个槽中,当所有的go程都完成了之后不是按照go程返回的顺序打印,而是按照槽的顺序打印,这样就实现了控制.比用原子操作的好处在于go程返回的时候没有阻塞.在性能测试中表现也好一点.<br>BenchmarkAtomic-8 100 12360024 ns&#47;op<br>BenchmarkAAA-8 390 4312883 ns&#47;op","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501939,"discussion_content":"你好，这里考察的是：怎样控制多个goroutine的执行顺序，而不是结果的打印顺序。如果考察的是后者，那未免也太小儿科了。：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595388434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2066975,"avatar":"","nickname":"Geek_17ce06","note":"","ucode":"7EA9ECC3C88FF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292975,"discussion_content":"额  准备面试题魔怔了，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595400807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233278,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1594277881,"is_pvip":false,"replies":[{"id":"86217","content":"连原子操作都不加，就有可能会出现不完全写或读出脏数据的情况，最终导致程序死锁在那里。在写并发程序时不要有侥幸心理。不管概率有多大（况且不会是小概率），都是有可能发生的。一旦发生，损失和成本都是不容小觑的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1594354585,"ip_address":"","comment_id":233278,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1594277881","product_id":100013101,"comment_content":"trigger := func(i uint32, fn func()) { for { if n := atomic.LoadUint32(&amp;count); n == i { fn() atomic.AddUint32(&amp;count, 1) break } time.Sleep(time.Nanosecond) }}<br><br>个人感觉这个不需要用原子操作也可以，虽然发生了竞争，只是增加了判断的次数，不知道理解的对不对？<br>可以改成这样<br> for {<br>    if  i == count {<br>       fn()<br>       count++<br>       break<br>     }<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500970,"discussion_content":"连原子操作都不加，就有可能会出现不完全写或读出脏数据的情况，最终导致程序死锁在那里。在写并发程序时不要有侥幸心理。不管概率有多大（况且不会是小概率），都是有可能发生的。一旦发生，损失和成本都是不容小觑的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594354585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1563985,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","nickname":"Geek_a8be59","note":"","ucode":"BEC0F57B51DC44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290138,"discussion_content":"理解脏读的情况，但是针对这个题目来说，传过来的i肯定是0到10之前不会重复的，就算读到了脏数据，也和count的值不一致，不会进入到if语句里面。而且不存在并行的count++ 操作，只有并行的获取count。所以最后肯定是已顺序读出来的。 所以并不理解所说的导致死锁的情况，能否指明一种情况产生死锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594355531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219201,"user_name":"沐夜星光","can_delete":false,"product_type":"c1","uid":1447220,"ip_address":"","ucode":"22F699E237B179","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","comment_is_top":false,"comment_ctime":1589965705,"is_pvip":false,"replies":[{"id":"81060","content":"你说的信号是指“操作系统中的信号”吗？如果是的话，你可以用&quot;os&#47;signal&quot;包。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1590032985,"ip_address":"","comment_id":219201,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589965705","product_id":100013101,"comment_content":"我感觉第二个问题的应用场景在于，如果多个goroutine之间存在数据依赖，或者信号依赖，那么该如何实现数据的通信。而郝老师的做法就是典型的“communicate by sharing memory” =。=   ，不知道能不能通过chan在多个goroutine之间传递信号？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495713,"discussion_content":"你说的信号是指“操作系统中的信号”吗？如果是的话，你可以用&amp;quot;os/signal&amp;quot;包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590032985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173282,"user_name":"2018","can_delete":false,"product_type":"c1","uid":1107371,"ip_address":"","ucode":"4C2CD47AD70177","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","comment_is_top":false,"comment_ctime":1579493352,"is_pvip":true,"replies":[{"id":"67254","content":"在旧版的Go语言中（尤其是Win下的），这种简单的循环可能会一直占据CPU不放。所以这里为了所有读者都能够成功运行示例，我才加了这一行。<br><br>实际开发当中，除非Go语言版本很旧并且for语句超级简单，否则不用添加那行代码。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1579576374,"ip_address":"","comment_id":173282,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1579493352","product_id":100013101,"comment_content":"在trigger方法中，退出循环睡眠一纳秒是等待下一个goroutine进入trigger方法嘛？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482021,"discussion_content":"在旧版的Go语言中（尤其是Win下的），这种简单的循环可能会一直占据CPU不放。所以这里为了所有读者都能够成功运行示例，我才加了这一行。\n\n实际开发当中，除非Go语言版本很旧并且for语句超级简单，否则不用添加那行代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579576374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107371,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","nickname":"2018","note":"","ucode":"4C2CD47AD70177","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148344,"discussion_content":"感谢老师解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579698648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146887,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1572686872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572686872","product_id":100013101,"comment_content":"可以通过striger函数，控制goroutine的执行顺序。","like_count":0},{"had_liked":false,"id":110408,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1562250266,"is_pvip":false,"replies":[{"id":"40103","content":"signi &lt;- signNum","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1562252061,"ip_address":"","comment_id":110408,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562250266","product_id":100013101,"comment_content":"package main<br><br>import (<br>    &quot;fmt&quot;<br>    &quot;time&quot;<br><br>)<br><br>type test func(int)<br>func main() {<br>    var num = 1000<br>    var signi = make(chan int,1)<br>    signi&lt;-0<br>    for i:=0;i&lt;num;i++ {<br><br>        go func(i int) {<br>            for {<br>                signNum :=&lt;-signi<br>                if signNum == i {<br>                    fmt.Println(i)<br>                    signi&lt;-i+1<br>                    break<br>                }<br>                signi &lt;- signNum<br>                time.Sleep(time.Nanosecond)<br>            }<br>        }(i)<br>    }<br>    for {<br>        signNum :=&lt;-signi<br>        if signNum == num {<br>            fmt.Println(&quot;Program finished!&quot;)<br>            break;<br>        }<br>        signi&lt;-signNum<br>        time.Sleep(time.Nanosecond)<br>    }<br><br><br>}<br><br><br>就是为了让他输出不乱呀。刚开始我往通道里放了0，只有0被打印出来了才会把数字加1放进通道。就是说能被第一个打印出来的就是0.  第二个1以此类推，怎么会乱呢。   可能自己了解不够！","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456864,"discussion_content":"signi &amp;lt;- signNum","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562252061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110365,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1562242675,"is_pvip":false,"replies":[{"id":"40099","content":"你把序号从 signNum 拿出来，判断是不是自己的序号，如果不是再放回去。这样肯定会乱啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1562249832,"ip_address":"","comment_id":110365,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562242675","product_id":100013101,"comment_content":"老实您好，根据您提供的 我用chan改造了一下 ，是不是和您这个同样的效果<br>package main<br><br>import (<br>    &quot;fmt&quot;<br>    &quot;time&quot;<br><br>)<br><br>type test func(int)<br>func main() {<br>    var num = 1000<br>    var signi = make(chan int,1)<br>    signi&lt;-0<br>    for i:=0;i&lt;num;i++ {<br><br>        go func(i int) {<br>            for {<br>                signNum :=&lt;-signi<br>                if signNum == i {<br>                    fmt.Println(i)<br>                    signi&lt;-i+1<br>                    break<br>                }<br>                signi &lt;- signNum<br>                time.Sleep(time.Nanosecond)<br>            }<br>        }(i)<br>    }<br>    for {<br>        signNum :=&lt;-signi<br>        if signNum == num {<br>            fmt.Println(&quot;Program finished!&quot;)<br>            break;<br>        }<br>        signi&lt;-signNum<br>        time.Sleep(time.Nanosecond)<br>    }<br><br><br>}<br><br><br>根据您的回答说顺序很有可能会乱，能不能指点一下那个地方可能会打印乱，真的看不出来","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456842,"discussion_content":"你把序号从 signNum 拿出来，判断是不是自己的序号，如果不是再放回去。这样肯定会乱啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562249832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109470,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1562038478,"is_pvip":false,"replies":[{"id":"39851","content":"你这样很可能会把顺序搞乱。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1562156851,"ip_address":"","comment_id":109470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562038478","product_id":100013101,"comment_content":"老实您好，根据您提供的 我用chan改造了一下 ，是不是和您这个同样的效果<br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br><br>)<br><br>type test func(int)<br>func main() {<br>\tvar num = 1000<br>\tvar signi = make(chan int,1)<br>\tsigni&lt;-0<br>\tfor i:=0;i&lt;num;i++ {<br><br>\t\tgo func(i int) {<br>\t\t\tfor {<br>\t\t\t\tsignNum :=&lt;-signi<br>\t\t\t\tif signNum == i {<br>\t\t\t\t\tfmt.Println(i)<br>\t\t\t\t\tsigni&lt;-i+1<br>\t\t\t\t\tbreak<br>\t\t\t\t}<br>\t\t\t\tsigni &lt;- signNum<br>\t\t\t\ttime.Sleep(time.Nanosecond)<br>\t\t\t}<br>\t\t}(i)<br>\t}<br>\tfor {<br>\t\tsignNum :=&lt;-signi<br>\t\tif signNum == num {<br>\t\t\tfmt.Println(&quot;Program finished!&quot;)<br>\t\t\tbreak;<br>\t\t}<br>\t\tsigni&lt;-signNum<br>\t\ttime.Sleep(time.Nanosecond)<br>\t}<br><br><br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456425,"discussion_content":"你这样很可能会把顺序搞乱。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562156851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103843,"user_name":"火火寻","can_delete":false,"product_type":"c1","uid":1120541,"ip_address":"","ucode":"B6DC003A5D89AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/1d/d2b6e006.jpg","comment_is_top":false,"comment_ctime":1560528333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560528333","product_id":100013101,"comment_content":"这样可以：<br>func main() {<br>\tc := make(chan int, 10)<br>\tq := make(chan struct{})<br>\tc &lt;- 0<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func(i int) {<br>\t\t\tfor {<br>\t\t\t\tj := &lt;-c<br>\t\t\t\tif i == j {<br>\t\t\t\t\tfmt.Println(i)<br>\t\t\t\t\tif i == 9 {<br>\t\t\t\t\t\tq &lt;- struct{}{}<br>\t\t\t\t\t} else {<br>\t\t\t\t\t\tc &lt;- i + 1<br>\t\t\t\t\t}<br>\t\t\t\t\tbreak<br>\t\t\t\t} else {<br>\t\t\t\t\tc &lt;- j<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}(i)<br>\t}<br>\t&lt;- q<br>}","like_count":0},{"had_liked":false,"id":99332,"user_name":"曾春云","can_delete":false,"product_type":"c1","uid":1197308,"ip_address":"","ucode":"5569D3EC9AD3B4","user_header":"https://static001.geekbang.org/account/avatar/00/12/44/fc/1ca9c88c.jpg","comment_is_top":false,"comment_ctime":1559194870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559194870","product_id":100013101,"comment_content":"package main<br><br>import &quot;fmt&quot;<br><br>func main() {<br>\tconst num = 10<br>\twg := WaitGroup{}<br>\tfor i := 0; i &lt; num; i++ {<br>\t\tgo func(i int) {<br>\t\t\tif wg.Done(i) {<br>\t\t\t\tfmt.Println(i)<br>\t\t\t\twg.Add()<br>\t\t\t}<br>\t\t}(i)<br>\t}<br>\twg.Wait(num)<br>}<br><br>type WaitGroup struct {<br>\tflag int<br>}<br><br>func (wg *WaitGroup) Add() {<br>\twg.flag += 1<br>}<br><br>func (wg *WaitGroup) Done(n int) bool {<br>\tfor {<br>\t\tif n == wg.flag {<br>\t\t\tbreak<br>\t\t}<br>\t}<br>\treturn true<br>}<br><br>func (wg *WaitGroup) Wait(n int) {<br>\tfor {<br>\t\tif wg.flag == n {<br>\t\t\tbreak<br>\t\t}<br>\t}<br>}<br>","like_count":0},{"had_liked":false,"id":94794,"user_name":"Zzz","can_delete":false,"product_type":"c1","uid":1116272,"ip_address":"","ucode":"4AA47797F48315","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIu1n1DhUGGKTjelrQaLYOSVK2rsFeia0G8ASTIftib5PTOx4pTqdnfwb0NiaEFGRgS661nINyZx9sUg/132","comment_is_top":false,"comment_ctime":1557898736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557898736","product_id":100013101,"comment_content":"很多同学都提到在循环内部增加&lt;-ch的方式保证上面的go语句执行完再继续下一次循环。这种方式虽然达到了顺序打印的效果，但是实际上整个程序只需要一个goroutine就可以完成：主函数阻塞时执行go语句，然后再唤醒主函数。","like_count":0},{"had_liked":false,"id":85518,"user_name":"🄽🄸🅇🅄🅂","can_delete":false,"product_type":"c1","uid":1000060,"ip_address":"","ucode":"853763C229A5AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","comment_is_top":false,"comment_ctime":1555093010,"is_pvip":false,"replies":[{"id":"30821","content":"这样做倒是可以顺序打印出数字，但是跟原题不太对应。另外，在正式的程序中，用 len(ch) 判断通道是否已经使用完毕不是一个好办法。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1555216826,"ip_address":"","comment_id":85518,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1555093010","product_id":100013101,"comment_content":"func main() {<br>\tch := make(chan int, 10)<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tch &lt;- i<br>\t\tgo func() {<br>\t\t\tfmt.Println(&lt;-ch)<br>\t\t}()<br>\t}<br>\tfor {<br>\t\tif len(ch) == 0 {<br>\t\t\tbreak<br>\t\t}<br>\t}<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446693,"discussion_content":"这样做倒是可以顺序打印出数字，但是跟原题不太对应。另外，在正式的程序中，用 len(ch) 判断通道是否已经使用完毕不是一个好办法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555216826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","nickname":"沐夜星光","note":"","ucode":"22F699E237B179","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269967,"discussion_content":"。。这只不过是从用10个线程从一个通道中取数据罢了。我感觉郝老师的本意是如何在线程之间同步信号。你这个顺序是通道保证的，不是线程保证的，没有意义啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589969031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1614922,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a4/4a/25c60a94.jpg","nickname":"gofer","note":"","ucode":"246CD48AF018BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234938,"discussion_content":"这段程序无法保证输出的顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587006825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83367,"user_name":"左氧佛沙星人","can_delete":false,"product_type":"c1","uid":1195278,"ip_address":"","ucode":"0D8295E1DABA8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/3d/0e/92176eaa.jpg","comment_is_top":false,"comment_ctime":1554545712,"is_pvip":true,"replies":[{"id":"30254","content":"你这段代码里的go函数的真正执行顺序实际上是不确定的啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1554691708,"ip_address":"","comment_id":83367,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554545712","product_id":100013101,"comment_content":"func main() {<br>\tch := make(chan int,100)<br>\tfor i := int(0); i &lt; 100; i++ {<br>\t\tgo func() {<br>\t\t\tfmt.Println(i)<br>\t\t\tch &lt;- i<br>\t\t}()<br>\t\t&lt;- ch<br>\t}<br>}<br>这样不行吗？郝老师","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445993,"discussion_content":"你这段代码里的go函数的真正执行顺序实际上是不确定的啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554691708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82139,"user_name":"枫林火山","can_delete":false,"product_type":"c1","uid":1199855,"ip_address":"","ucode":"66099C9D1AD36C","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/ef/2ad3effd.jpg","comment_is_top":false,"comment_ctime":1554129497,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554129497","product_id":100013101,"comment_content":"谢谢老师的讲解","like_count":0},{"had_liked":false,"id":73261,"user_name":"恍然大明白🐶","can_delete":false,"product_type":"c1","uid":1227071,"ip_address":"","ucode":"907C63D4CB4844","user_header":"https://static001.geekbang.org/account/avatar/00/12/b9/3f/3ceddcac.jpg","comment_is_top":false,"comment_ctime":1551846148,"is_pvip":false,"replies":[{"id":"26848","content":"你那行代码跟这个问题没啥关系。顺序没有保障的意思是可能乱序也可能恰好有序，但有序只是凑巧。影响因素的很多，比如你的计算机性能、你使用的go版本，你设定的P数量、你写代码的顺序。<br><br>你加了那一句使得这些goroutine的启用时间之间有了一点点间隔，它们可能因此被挂到了不同的P下面。这些都是影响因素。<br><br>你只要记住：go函数的执行是无序的就好了。这是Go语言内部调度器的源码决定的。你这样的试验实际上没有什么意义。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551953314,"ip_address":"","comment_id":73261,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551846148","product_id":100013101,"comment_content":"在go语句被执行时，我们传给go函数的参数i会先被求值，如此得到当前迭代的序号，那么<br>func main() {<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\t&#47;&#47;s := i<br>\t\tgo func(int) {<br>\t\t\tfmt.Println(i)<br>\t\t}(i)<br>\t}<br>\ttime.Sleep(time.Second)<br>}输出的应该是无序的1～10，但是事实不是这样，除非多加个s := i，这是为什么啊","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441993,"discussion_content":"你那行代码跟这个问题没啥关系。顺序没有保障的意思是可能乱序也可能恰好有序，但有序只是凑巧。影响因素的很多，比如你的计算机性能、你使用的go版本，你设定的P数量、你写代码的顺序。\n\n你加了那一句使得这些goroutine的启用时间之间有了一点点间隔，它们可能因此被挂到了不同的P下面。这些都是影响因素。\n\n你只要记住：go函数的执行是无序的就好了。这是Go语言内部调度器的源码决定的。你这样的试验实际上没有什么意义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551953314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71661,"user_name":"画船听雨眠","can_delete":false,"product_type":"c1","uid":1204530,"ip_address":"","ucode":"7BF99B0B26F3B2","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/32/61112578.jpg","comment_is_top":false,"comment_ctime":1551408378,"is_pvip":false,"replies":[{"id":"26218","content":"这样没法保证这些数字按顺序打印，因为这10个go函数的执行顺序是不确定的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551610554,"ip_address":"","comment_id":71661,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551408378","product_id":100013101,"comment_content":" 我用缓冲通道实现了一种方式：<br><br>\tarray_chan := make(chan int, 1)<br>\tfor i :=0; i&lt;10; i++ {<br>\t\tarray_chan &lt;- i<br>\t\tgo func() {<br>\t\t\tfmt.Println(&lt;-array_chan)<br>\t\t}()<br>\t}<br>        time.Sleep(time.Millisecond * 500)<br><br>通道缓冲长度为1，写入1个以后阻塞，goroutine中取出以后继续取出操作会阻塞，等待发送操作。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441262,"discussion_content":"这样没法保证这些数字按顺序打印，因为这10个go函数的执行顺序是不确定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551610554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68038,"user_name":"ahauyuanjun","can_delete":false,"product_type":"c1","uid":1202997,"ip_address":"","ucode":"BB8B66596929EC","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/35/ff2c2f49.jpg","comment_is_top":false,"comment_ctime":1550394846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550394846","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>)<br><br>func main() {<br>\tc := make(chan int, 1)<br>\tc &lt;- 0<br><br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func(i int, c chan int) {<br>\t\t\tfor {<br>\t\t\t\tselect {<br>\t\t\t\tcase w := &lt;-c:<br>\t\t\t\t\tif w == i {<br>\t\t\t\t\t\tfmt.Println(i)<br>\t\t\t\t\t\tw += 1<br>\t\t\t\t\t\tc &lt;- w<br>\t\t\t\t\t\treturn<br>\t\t\t\t\t} else {<br>\t\t\t\t\t\tc &lt;- w<br>\t\t\t\t\t}<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}(i, c)<br>\t}<br><br>\tfor {<br>\t\tselect {<br>\t\tcase w := &lt;-c:<br>\t\t\tif w == 10 {<br>\t\t\t\tfmt.Println(&quot;end&quot;, w)<br>\t\t\t\tclose(c)<br>\t\t\t\treturn<br>\t\t\t} else {<br>\t\t\t\tc &lt;- w<br>\t\t\t}<br>\t\t}<br>\t}<br>}<br>","like_count":0},{"had_liked":false,"id":55602,"user_name":"溜哥","can_delete":false,"product_type":"c1","uid":1200642,"ip_address":"","ucode":"8FEA184059AE7A","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/02/798c2461.jpg","comment_is_top":false,"comment_ctime":1546240676,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1546240676","product_id":100013101,"comment_content":"Go小白请教一个问题：为啥注释 &#47;&#47;trigger(10, func() {})  demo40.go 就不输出任何内容？","like_count":0,"discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123835,"discussion_content":"最后一次调用trigger是阻塞主goroutine，以保证一定要输出到9才结束。如果不加这行的话，主 goroutine 代码执行完成时，就结束运行了，还没有机会运行其他 goroutine","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578408872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35257,"user_name":"Steven","can_delete":false,"product_type":"c1","uid":1022513,"ip_address":"","ucode":"C304D73EDD7389","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoJ7I3viacLvC6gSUQaOF9NJTUlPvXtSFCIlSL9nBHyGxxAkcBEX4hj1zQwwvDPRXdhqVTJ71HZbvQ/132","comment_is_top":false,"comment_ctime":1540477986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540477986","product_id":100013101,"comment_content":"func main() {<br>\tpreDone := make(chan bool, 0)<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tj := i<br>\t\tdone := make(chan bool, 0)<br>\t\tgo func(preDone, done chan bool) {<br>\t\t\t&lt;-preDone<br>\t\t\tfmt.Println(j)<br>\t\t\tdone &lt;- true<br>\t\t}(preDone, done)<br><br>\t\tif i == 0 {<br>\t\t\tpreDone &lt;- true<br>\t\t}<br><br>\t\tpreDone = done<br>\t}<br><br>\t&lt;-preDone<br>}","like_count":0},{"had_liked":false,"id":31609,"user_name":"拉铁","can_delete":false,"product_type":"c1","uid":1224912,"ip_address":"","ucode":"4286AEAD0A6E6C","user_header":"","comment_is_top":false,"comment_ctime":1539245247,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539245247","product_id":100013101,"comment_content":"来碗绿豆汤<br><br>我有一个更简单的实现方式， 如下<br>func main(){<br>ch := make(chan struct{})<br>for i:=0; i &lt; 100; i++{<br>go func(i int){<br>fmt.Println(i)<br>ch &lt;- struct{}{}<br>}(i)<br>&lt;-ch<br>}<br>}<br>这样，每次循环都包装goroutine 执行结束才进入下一次循环，就可以保证顺序执行了<br>2018-09-19<br> 作者回复<br>这些go函数的真正执行谁先谁后是不可控的，所以这样做不行的。<br><br>您好，从i=0开始，如果没有对ch做接收操作，就会发生堵塞，直到有数据发送到ch，也就是说如果当前循环内的goroutine没有运行结束，是不会运行到下一次迭代的，所以这样做也是可以保证顺序的。请问，我这么说是正确的吗？","like_count":0},{"had_liked":false,"id":30552,"user_name":"卒迹","can_delete":false,"product_type":"c1","uid":1202095,"ip_address":"","ucode":"FAE1AA6038402C","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/af/0b39cab7.jpg","comment_is_top":false,"comment_ctime":1538920386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538920386","product_id":100013101,"comment_content":"郝老师，问个问题<br>\ttrigger := func(i uint32, fn func()) {<br>\t\tfor {<br>\t\t\tif n := atomic.LoadUint32(&amp;count); n == i {<br>\t\t\t\tfn()<br>\t\t\t\tatomic.AddUint32(&amp;count, 1)<br>\t\t\t\tbreak<br>\t\t\t}<br>&#47;&#47;为什么这里如果没有休眠的话，运行程序电脑会卡死呢<br>\t\t\ttime.Sleep(time.Nanosecond)<br>\t\t}<br>\t}<br>","like_count":0},{"had_liked":false,"id":29687,"user_name":"Lever","can_delete":false,"product_type":"c1","uid":1071921,"ip_address":"","ucode":"20C0D381677E1D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/31/b26b56bf.jpg","comment_is_top":false,"comment_ctime":1538487633,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1538487633","product_id":100013101,"comment_content":"【来碗绿豆汤】写的程序感觉没有问题啊，在读 channel 的时候应该会一直等待吧，直到读到之后才会进行下一次循环，所以输出也应该是顺序的吧？再贴一遍他的代码：<br>func main(){<br>  ch := make(chan struct{})<br>  for i:=0; i &lt; 100; i++{<br>    go func(i int){<br>      fmt.Println(i)<br>      ch &lt;- struct{}{}<br>    }(i)<br>    &lt;-ch<br>  }<br>}","like_count":0,"discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123853,"discussion_content":"这就不算是并发的执行了，都是阻塞非并发了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578409078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28984,"user_name":"任性😀","can_delete":false,"product_type":"c1","uid":1209711,"ip_address":"","ucode":"F80DB5E6896105","user_header":"https://static001.geekbang.org/account/avatar/00/12/75/6f/8a6e0a14.jpg","comment_is_top":false,"comment_ctime":1538214519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538214519","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tvar count uint32<br>\ttrigger := func(i uint32, fn func()) {<br>\t\tfor {<br>\t\t\t&#47;* if n := atomic.LoadUint32(&amp;count); n == i {<br>\t\t\t\tfn()<br>\t\t\t\tatomic.AddUint32(&amp;count, 1)<br>\t\t\t\tbreak<br>\t\t\t} *&#47;<br>\t\t\tif count == i {<br>\t\t\t\tfn()<br>\t\t\t\tcount++<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t\ttime.Sleep(time.Nanosecond) &#47;&#47;纳秒<br>\t\t}<br>\t}<br>\tfor i := uint32(0); i &lt; 10; i++ {<br>\t\tgo func(i uint32) {<br>\t\t\tfn := func() {<br>\t\t\t\tfmt.Println(i, &quot;=&gt;&quot;, count)<br>\t\t\t}<br>\t\t\ttrigger(i, fn)<br>\t\t}(i)<br>\t}<br>\ttrigger(10, func() {})<br>}<br><br><br>老师这个代码会有问题吗","like_count":0}]}