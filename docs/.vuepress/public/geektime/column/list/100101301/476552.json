{"id":476552,"title":"13 | OpenFeign 实战：如何实现服务间调用功能？","content":"<p>你好，我是姚秋辰。</p><p>在上一讲中，我带你了解了OpenFeign组件的设计目标和要解决的问题。今天我们来学习如何使用OpenFeign实现<strong>跨服务的调用</strong>，通过这节课的学习，你可以对实战项目中的WebClient请求做大幅度的简化，让跨服务请求就像调用本地方法一样简单。</p><p>今天我要带你改造的项目是coupon-customer-serv服务，因为它内部需要调用template和calculation两个服务完成自己的业务逻辑，非常适合用Feign来做跨服务调用的改造。</p><p>在集成OpenFeign组件之前，我们需要把它的依赖项spring-cloud-starter-OpenFeign添加到coupon-customer-impl子模块内的pom.xml文件中。</p><pre><code>&lt;!-- OpenFeign组件 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>在上面的代码中，你并不需要指定组件的版本号，因为我们在顶层项目中定义的spring-cloud-dependencies依赖项中已经定义了各个Spring Cloud的版本号，它们会随着Maven项目的继承关系传递到子模块中。</p><p>添加好依赖项之后，我们就可以进行大刀阔斧的OpenFeign改造了。在coupon-customer-impl子模块下的CouponCustomerServiceImpl类中，我们通过WebClient分别调用了template和calculation的服务。这节课我先来带你对template的远程调用过程进行改造，将其替换为OpenFeign风格的调用。</p><!-- [[[read_end]]] --><h2>改造Template远程调用</h2><p>通过上节课的内容我们了解到，OpenFeign组件通过接口代理的方式发起远程调用，那么我们改造过程的第一步就是要定义一个OpenFeign接口。</p><p>我在coupon-customer-impl项目下创建了一个package，它的路径是com.geekbang.coupon.customer.feign。在这个路径下我定义了一个叫做TemplateService的Interface，用来实现对coupon-template-serv的远程调用代理。我们来看一下这个接口的源代码。</p><pre><code>@FeignClient(value = &quot;coupon-template-serv&quot;, path = &quot;/template&quot;)\npublic interface TemplateService {\n    // 读取优惠券\n    @GetMapping(&quot;/getTemplate&quot;)\n    CouponTemplateInfo getTemplate(@RequestParam(&quot;id&quot;) Long id);\n    \n    // 批量获取\n    @GetMapping(&quot;/getBatch&quot;)\n    Map&lt;Long, CouponTemplateInfo&gt; getTemplateInBatch(@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids);\n}\n</code></pre><p>在上面的代码中，我们在接口上声明了一个FeignClient注解，它专门用来标记被OpenFeign托管的接口。</p><p>在FeignClient注解中声明的value属性是目标服务的名称，在代码中我指定了coupon-template-serv，你需要确保这里的服务名称和Nacos服务器上显示的服务注册名称是一样的。</p><p>此外，FeignClient注解中的path属性是一个可选项，如果你要调用的目标服务有一个统一的前置访问路径，比如coupon-template-serv所有接口的访问路径都以/template开头，那么你可以通过path属性来声明这个前置路径，这样一来，你就不用在每一个方法名上的注解中带上前置Path了。</p><p>在项目的启动阶段，OpenFeign会查找所有被FeignClient注解修饰的接口，并代理该接口的所有方法调用。当我们调用接口方法的时候，OpenFeign就会根据方法上定义的注解自动拼装HTTP请求路径和参数，并向目标服务发起真实调用。</p><p>因此，我们还需要在方法上定义spring-web注解（如GetMapping、PostMapping），让OpenFeign拼装出正确的Request URL和请求参数。这时你要注意，<strong>OpenFeign接口中定义的路径和参数必须与你要调用的目标服务中的保持一致</strong>。</p><p>完成了Feign接口的定义，接下来你就可以替换CouponCustomerServiceImpl中的业务逻辑调用了。</p><p>首先，我们在CouponCustomerServiceImpl接口中注入刚才定义的TemplateService接口。</p><pre><code>@Autowired\nprivate TemplateService templateService;\n</code></pre><p>被FeignClient注解修饰的对象，也会被添加到Spring上下文中。因此我们可以通过Autowired注入的方式来使用这些接口。</p><p>然后，我们就可以对具体的业务逻辑进行替换了。以CouponCustomerServiceImpl类中的placeOrder下单接口为例，其中有一步是调用coupon-template-serv获取优惠券模板数据，这个服务请求是使用WebClient发起的，我们来看一下改造之前的方法实现。</p><pre><code>webClientBuilder.build().get()\n    .uri(&quot;http://coupon-template-serv/template/getTemplate?id=&quot; + templateId)\n    .retrieve()\n    .bodyToMono(CouponTemplateInfo.class)\n    .block();        \n</code></pre><p>从上面的代码中你可以看出，我们写了一大长串的代码，只为了发起一次服务请求。如果使用<strong>OpenFeign接口</strong>来替换，那画风就不一样了，我们看一下改造后的服务调用过程。</p><pre><code>templateService.getTemplate(couponInfo.getTemplateId())\n</code></pre><p>你可以看到，使用OpenFeign接口发起远程调用就像使用本地服务一样简单。和WebClient的调用方式相比，<strong>OpenFeign组件不光可以提高代码可读性和可维护性，还降低了远程调用的Coding成本</strong>。</p><p>在CouponCustomerServiceImpl类中的findCoupon方法里，我们调用了coupon-template-serv的批量查询接口获取模板信息，这个过程也可以使用OpenFeign接口实现，下面是具体的实现代码。</p><pre><code>// 获取这些优惠券的模板ID\nList&lt;Long&gt; templateIds = coupons.stream()\n        .map(Coupon::getTemplateId)\n        .distinct()\n        .collect(Collectors.toList());\n\n// 发起请求批量查询券模板\nMap&lt;Long, CouponTemplateInfo&gt; templateMap = templateService\n        .getTemplateInBatch(templateIds);\n</code></pre><p>到这里，我们已经把template服务的远程调用改成了OpenFeign接口调用的方式，那么接下来让我们趁热打铁，去搞定calculation服务的远程调用。</p><h2>改造Calculation远程调用</h2><p>首先，我们在TemplateService同样的目录下创建一个新的接口，名字是CalculationService，后面你会使用它作为coupon-calculation-serv的代理接口。我们来看一下这个接口的源码。</p><pre><code>@FeignClient(value = &quot;coupon-calculation-serv&quot;, path = &quot;/calculator&quot;)\npublic interface CalculationService {\n\n    // 订单结算\n    @PostMapping(&quot;/checkout&quot;)\n    ShoppingCart checkout(ShoppingCart settlement);\n\n    // 优惠券试算\n    @PostMapping(&quot;/simulate&quot;)\n    SimulationResponse simulate(SimulationOrder simulator);\n}\n</code></pre><p>我在接口类之上声明了一个FeignClient注解，指向了coupon-calculation-serv服务，并且在path属性中注明了服务访问的前置路径是/calculator。</p><p>在接口中我还定义了两个方法，分别指向checkout用户下单接口和simulate优惠券试算接口，这两个接口的访问路径和coupon-calculation-serv中定义的路径是一模一样的。</p><p>有了前面template服务的改造经验，相信你应该很轻松就能搞定calculation服务调用的改造。首先，我们需要把刚才定义的CalculationService注入到CouponCustomerServiceImpl中。</p><pre><code>@Autowired\nprivate CalculationService calculationService;\n</code></pre><p>然后，你只用在调用coupon-calculation-serv服务的地方，将WebClient调用替换成下面这种OpenFeign调用的方式就可以了，是不是很简单呢？</p><pre><code>// order清算\nShoppingCart checkoutInfo = calculationService.checkout(order);\n\n// order试算\ncalculationService.simulate(order)\n</code></pre><p>到这里，我们就完成了template和calculation服务调用过程的改造。在我们启动项目来验证改造成果之前，还有最为关键的一步需要完成，那就是配置OpenFeign的加载路径。</p><h2>配置OpenFeign的加载路径</h2><p>我们打开coupon-customer-serv项目的启动类，你可以通过在类名之上添加一个EnableFeignClients注解的方式定义OpenFeign接口的加载路径，你可以参考以下代码。</p><pre><code>// 省略其他无关注解\n@EnableFeignClients(basePackages = {&quot;com.geekbang&quot;})\npublic class Application {\n\n}\n</code></pre><p>在这段代码中，我们在EnableFeignClients注解的basePackages属性中定义了一个com.geekbang的包名，这个注解就会告诉OpenFeign在启动项目的时候做一件事儿：找到所有位于com.geekbang包路径（包括子package）之下使用FeignClient修饰的接口，然后生成相关的代理类并添加到Spring的上下文中。这样一来，我们才能够在项目中用Autowired注解注入OpenFeign接口。</p><p>如果你忘记声明EnableFeignClients注解了呢？那么启动项目的时候，你就会收到一段异常，告诉你目标服务在Spring上下文中未找到。我把具体的报错信息贴在了这里，你可以参考一下。如果碰到这类启动异常，你就可以先去查看启动类上有没有定义EnableFeignClients注解。</p><pre><code>Field templateService in com.geekbang.coupon.customer.service.CouponCustomerServiceImpl \nrequired a bean of type 'com.geekbang.coupon.customer.feign.TemplateService' that could not be found.\n</code></pre><p>上面就是使用包路径扫描的方式来加载FeignClient接口。除此之外，你还可以通过直接加载指定FeignClient接口类的方式，或者从指定类所在的目录进行扫包的方式来加载FeignClient接口。我把这两种加载方式的代码写在了下面，你可以参考一下。</p><pre><code>// 通过指定Client类来加载\n@EnableFeignClients(clients = {TemplateService.class, CalculationService.class})\n\n// 扫描特定类所在的包路径下的FeignClient\n@EnableFeignClients(basePackageClasses = {TemplateService.class})\n</code></pre><p>在这三种加载方式中，我比较推荐你在项目中使用一劳永逸的“包路径”加载的方式。因为不管以后你添加了多少新的FeignClient接口，只要这些接口位于com.geekbang包路径之下，你就不用操心加载路径的配置。</p><p>到这里，我们就完成了OpenFeign的实战项目改造，你可以在本地启动项目来验证改造后的程序是否可以正常工作。</p><h2>总结</h2><p>现在，我们来回顾一下这节课的重点内容。今天我们使用OpenFeign替代了项目中的WebClient组件，实现了跨服务的远程调用。在这个过程中有两个重要步骤。</p><ul>\n<li><strong>FeignClient</strong>：使用该注解修饰OpenFeign的代理接口，你需要确保接口中每个方法的寻址路径和你要调用的目标服务保持一致。除此之外，FeignClient中指定的服务名称也要和Nacos服务端中的服务注册名称保持一致；</li>\n<li><strong>EnableFeignClients</strong>：在启动类上声明EnableFeignClients注解，使用本课程中学习的三种扫包方式的任意一种加载FeignClient接口，这样OpenFeign组件才能在你的程序启动之后对FeignClient接口进行初始化和动态代理。</li>\n</ul><p>通过这节课的学习，相信你已经能够掌握Spring Cloud体系下的微服务远程调用的方法了。在后面的课程中，我将带你进一步了解OpenFeign组件的其他高级玩法。</p><h2>思考题</h2><p>在这节课中，我把OpenFeign接口定义在了调用方这一端。如果你的服务需要暴露给很多业务方使用，每个业务方都要维护一套独立的OpenFeign接口似乎也不太方便，你能想到什么更好的接口管理办法吗？欢迎在留言区写下自己的思考，与我一起讨论。</p><p>好啦，这节课就结束啦。欢迎你把这节课分享给更多对Spring Cloud感兴趣的朋友。我是姚秋辰，我们下节课再见！</p>","neighbors":{"left":{"article_title":"12 | OpenFeign：服务间调用组件 OpenFeign 是怎么“隔空取物”的？","id":475927},"right":{"article_title":"14 | OpenFeign 实战：OpenFeign 组件有哪些高级玩法？","id":477297}},"comments":[{"had_liked":false,"id":330121,"user_name":"金灶沐","can_delete":false,"product_type":"c1","uid":1408553,"ip_address":"","ucode":"997DE6CD343179","user_header":"https://static001.geekbang.org/account/avatar/00/15/7e/29/2fc94ee7.jpg","comment_is_top":false,"comment_ctime":1641804783,"is_pvip":true,"replies":[{"id":"120284","content":"Bingo！同学在extends的时候加上@FeignClients的方式很好，规避了bean override的问题","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641821497,"ip_address":"","comment_id":330121,"utype":1}],"discussion_count":4,"race_medal":0,"score":"70361281519","product_id":100101301,"comment_content":"服务提供方提取一层接口出来， 由服务提供方维护请求路径，    服务消费方，直接声明一个接口extends消费方的接口， 加上@FeignClients即可<br>","like_count":17,"discussions":[{"author":{"id":2961263,"avatar":"","nickname":"李士超","note":"","ucode":"3155335675F6D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564962,"discussion_content":"我觉得也可以在服务模块方面下手，所有的FeignClients接口都单独抽层为独立的api模块，所以服务依赖项，其它服务需要调用，可以依赖它直接调用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650361209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571688,"discussion_content":"抽象出一层接口，服务提供方和使用方都继承这个接口，好像在官方文档上看到说，不太建议使用这种方式，理由是通过 Java 接口的共享，导致服务提供者和消费者的耦合，而微服务的目的是为了服务提供者和消费者的解耦，存在一定的冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652347719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545083,"discussion_content":"Bingo！同学在extends的时候加上@FeignClients的方式很好，规避了bean override的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641821497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1506940,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/7c/33e55038.jpg","nickname":"一刀流小依","note":"","ucode":"91FED4C0037470","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":583293,"discussion_content":"没太理解。\n首先@FeignClients是什么注解，项目里引不到，是指@FeignClient或者@EnableFeignClients中的一个吗。\n另外bean override具体是指什么呢。是指服务提供方提供的api接口定义，是不带上@FeignClient这个注解的吗。那不是会丢失value\\path等信息了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660014608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545083,"ip_address":"中国香港"},"score":583293,"extra":""}]}]},{"had_liked":false,"id":330095,"user_name":"so long","can_delete":false,"product_type":"c1","uid":1449679,"ip_address":"","ucode":"2A6B47BB32FC18","user_header":"https://static001.geekbang.org/account/avatar/00/16/1e/cf/97cd8be1.jpg","comment_is_top":false,"comment_ctime":1641796205,"is_pvip":false,"replies":[{"id":"120288","content":"讲真loadbalancer的功能相比ribbon是差一截的，奈何spring cloud不愿意带ribbon玩了，也没辙。ribbon规避懒加载的原因是RibbonClient在调用期才进行初始化，不过ribbon在这个过程花费的时间并不多，只会在网络环境不好的情况下超时概率有所增加。对于loadbalancer来说，实际场景下大多数公司的做法是设置connection timeout + retry的方式来解决。如果对于一致性要求高的接口，底层要注意实现幂等性以防多次调用","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641822515,"ip_address":"","comment_id":330095,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27411599981","product_id":100101301,"comment_content":"老师，我用spring cloud alibaba搭建了公司的一个项目，服务启动后，接口的首次请求需要2-3秒钟，后续请求都在100ms左右，请问有哪些优化措施可以提高首次接口请求速度？之前使用ribbon可是设置为饿汉式加载，但是spring cloud loadbalancer好像没有饿汉式加载的配置。","like_count":7,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545089,"discussion_content":"讲真loadbalancer的功能相比ribbon是差一截的，奈何spring cloud不愿意带ribbon玩了，也没辙。ribbon规避懒加载的原因是RibbonClient在调用期才进行初始化，不过ribbon在这个过程花费的时间并不多，只会在网络环境不好的情况下超时概率有所增加。对于loadbalancer来说，实际场景下大多数公司的做法是设置connection timeout + retry的方式来解决。如果对于一致性要求高的接口，底层要注意实现幂等性以防多次调用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641822515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330085,"user_name":"so long","can_delete":false,"product_type":"c1","uid":1449679,"ip_address":"","ucode":"2A6B47BB32FC18","user_header":"https://static001.geekbang.org/account/avatar/00/16/1e/cf/97cd8be1.jpg","comment_is_top":false,"comment_ctime":1641792602,"is_pvip":false,"replies":[{"id":"120283","content":"bingo，我也推荐这种做法","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641820845,"ip_address":"","comment_id":330085,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27411596378","product_id":100101301,"comment_content":"每个服务提供方单独添加一个openfeign的模块，服务调用方添加对应的openfeign模块即可","like_count":7,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545081,"discussion_content":"bingo，我也推荐这种做法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641820845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1155437,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a1/6d/a4ff33bb.jpg","nickname":"Lee","note":"","ucode":"0FF1C4EAF7F98A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":571845,"discussion_content":"请教一下老师，比如有a b两个服务 b服务有个单独module 里面只有openfeign client的定义，那么A服务调用b服务的，是需要在A服务写个类来实现，然后做服务降级吗？如果把b的client直接引入注入，那么服务降级是不是就比较复杂？如果是老师，老师会怎么做 谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652428539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545081,"ip_address":""},"score":571845,"extra":""}]}]},{"had_liked":false,"id":333270,"user_name":"Mars","can_delete":false,"product_type":"c1","uid":1300378,"ip_address":"","ucode":"84E7821DF19382","user_header":"https://static001.geekbang.org/account/avatar/00/13/d7/9a/38d14e5f.jpg","comment_is_top":false,"comment_ctime":1644241745,"is_pvip":false,"replies":[{"id":"121836","content":"如果是外部对接，其实用feign就没啥好处了，因为feign的服务发现负载均衡都用不上，外部对接直接用最土的resttemplate或者webclient就可以。我们不用考虑它背后的负载均衡，咱调用的应该是对方给提暴露出来的一个vip url，负载均衡都在对向端管理","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1644327143,"ip_address":"","comment_id":333270,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23119078225","product_id":100101301,"comment_content":"老师，能问下微服务下调用其他服务，其他服务是其他厂商的web接口，只提供过输入输出和请求地址这种，注册中心也不在一个，这种常规的http请求在微服务架构下的最佳调用实践是咋样的呢？还是继续open feign做url吗？","like_count":4,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550004,"discussion_content":"如果是外部对接，其实用feign就没啥好处了，因为feign的服务发现负载均衡都用不上，外部对接直接用最土的resttemplate或者webclient就可以。我们不用考虑它背后的负载均衡，咱调用的应该是对方给提暴露出来的一个vip url，负载均衡都在对向端管理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644327143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1300378,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d7/9a/38d14e5f.jpg","nickname":"Mars","note":"","ucode":"84E7821DF19382","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":550014,"discussion_content":"是的，谢谢解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644329294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550004,"ip_address":""},"score":550014,"extra":""}]},{"author":{"id":1183703,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0f/d7/31d07471.jpg","nickname":"牛年榴莲","note":"","ucode":"230C076193C6C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560601,"discussion_content":"实践中调用第三方接口的时候，我也用到了feign，还是很方便的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1649402355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330331,"user_name":"ᯤ⁵ᴳ","can_delete":false,"product_type":"c1","uid":1621494,"ip_address":"","ucode":"BA8F60B05D1389","user_header":"https://static001.geekbang.org/account/avatar/00/18/bd/f6/558bb119.jpg","comment_is_top":false,"comment_ctime":1641914692,"is_pvip":false,"replies":[{"id":"120457","content":"feign自带的重试策略比较初级，可以结合openfeign+resilience4j的方式做复杂重试规则，https:&#47;&#47;resilience4j.readme.io&#47;docs&#47;retry","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1642006709,"ip_address":"","comment_id":330331,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18821783876","product_id":100101301,"comment_content":"请求异常，多次重试等使用Webclient会比较方便，@FeignClient 如何处理呢","like_count":5,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545644,"discussion_content":"feign自带的重试策略比较初级，可以结合openfeign+resilience4j的方式做复杂重试规则，https://resilience4j.readme.io/docs/retry","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642006709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330061,"user_name":"Geek_e93c48","can_delete":false,"product_type":"c1","uid":2878664,"ip_address":"","ucode":"4418236B0BF4DE","user_header":"","comment_is_top":false,"comment_ctime":1641781117,"is_pvip":false,"replies":[{"id":"120287","content":"同学这个建议很好，专栏整体偏入门，没有加入太多线上案例分析，后面会分享一些线上的使用场景","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641822115,"ip_address":"","comment_id":330061,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18821650301","product_id":100101301,"comment_content":"关于老师的思考题：<br>做成将提供方的OpenFeign做成中间件抽离出来。<br>个人建议：老师是否可以在后边的文章中不仅仅讲技术落地，加入一些使用该技术在生产上的遇到的问题和排查思路，这些才是我们需要的（手动滑稽）","like_count":4,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545086,"discussion_content":"同学这个建议很好，专栏整体偏入门，没有加入太多线上案例分析，后面会分享一些线上的使用场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641822116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335882,"user_name":"欢沁","can_delete":false,"product_type":"c1","uid":1487183,"ip_address":"","ucode":"4696E9B05C696C","user_header":"https://static001.geekbang.org/account/avatar/00/16/b1/4f/61a98c13.jpg","comment_is_top":false,"comment_ctime":1645753180,"is_pvip":false,"replies":[{"id":"122854","content":"其实在三高应用中同一个微服务库我们也不推荐使用join这类操作，如果是实时性要求不高的场景，把各个微服务表里的数据做一层数据异构，异构到非结构化数据库里，比如opensearch, ES里面，然后再做查找。<br><br>如果是实时性要求很高的数据必须查DB，三高服务我推荐你把join逻辑放到代码层来实现，给到DB的尽可能都走主键索引计划。如果非要用join，一定确保调出sql执行计划确保每一步都走索引并且复杂度尽可能低","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1645971050,"ip_address":"","comment_id":335882,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10235687772","product_id":100101301,"comment_content":"老师你好，微服务的数据库分库后，如果A服务要展示的数据需要和B数据库的表关联，微服务划分后，数据库层面就没法做join操作，企业现在通用的方式是怎么处理的。我目前的解决方法是通过feign来调用其他服务获取数据，再插到A服务的对象中，如果遇到关联的表多，就需要feign调用多次，我不认为这是一个好的解决方法，这样的话代码量会堆积非常多，如果没有划分数据库的话，只要通过join就解决问题了。<br><br><br>所以概括就是，我需要关联到其他服务的数据库的表，没法join，我应该怎么做，谢谢老师。","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553583,"discussion_content":"其实在三高应用中同一个微服务库我们也不推荐使用join这类操作，如果是实时性要求不高的场景，把各个微服务表里的数据做一层数据异构，异构到非结构化数据库里，比如opensearch, ES里面，然后再做查找。\n\n如果是实时性要求很高的数据必须查DB，三高服务我推荐你把join逻辑放到代码层来实现，给到DB的尽可能都走主键索引计划。如果非要用join，一定确保调出sql执行计划确保每一步都走索引并且复杂度尽可能低","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645971050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338611,"user_name":"Geek_a5c816","can_delete":false,"product_type":"c1","uid":2929016,"ip_address":"","ucode":"FB269F6B9C7A58","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ib7ymR5sdB4GVSx3DBHV0fpDP877zs3ia0ia0j0DAI9UDuZtxssgknyyUgmgfmqnXJdMVCkA5ll6NZvIl0w4NmZ7g/132","comment_is_top":false,"comment_ctime":1647594590,"is_pvip":false,"replies":[{"id":"123908","content":"就像rpc接口调用，其实微服务之间的request大多不需要把业务参数放到header里，但openfeign依然提供了一种定制header的方式，在后面的章节里我们会结合Sentinel了解到","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1647870216,"ip_address":"","comment_id":338611,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5942561886","product_id":100101301,"comment_content":"这种原始openFegin的实现消费者调用提供者的时候,无法传递headers中的参数,怎么处理呢?","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557579,"discussion_content":"就像rpc接口调用，其实微服务之间的request大多不需要把业务参数放到header里，但openfeign依然提供了一种定制header的方式，在后面的章节里我们会结合Sentinel了解到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647870216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337758,"user_name":"寥若晨星","can_delete":false,"product_type":"c1","uid":1447739,"ip_address":"","ucode":"2E87E43687DE72","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eou1BMETumU21ZI4yiaLenOMSibzkAgkw944npIpsJRicmdicxlVQcgibyoQ00rdGk9Htp1j0dM5CP2Fibw/132","comment_is_top":false,"comment_ctime":1647012839,"is_pvip":false,"replies":[{"id":"123554","content":"FeignClient注解的目的是为了不写实现，通过接口完成远程调用，所以底层的动态代理注册流程里有一个Assert断言，限定了是从接口读取<br><br>Assert.isTrue(annotationMetadata.isInterface(), &quot;@FeignClient can only be specified on an interface&quot;);<br>","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1647180879,"ip_address":"","comment_id":337758,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5941980135","product_id":100101301,"comment_content":"为啥不可以直接在服务实现的接口上加@FeignClient注解呢","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556047,"discussion_content":"FeignClient注解的目的是为了不写实现，通过接口完成远程调用，所以底层的动态代理注册流程里有一个Assert断言，限定了是从接口读取\n\nAssert.isTrue(annotationMetadata.isInterface(), &#34;@FeignClient can only be specified on an interface&#34;);\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647180879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336122,"user_name":"Geek_f76b23","can_delete":false,"product_type":"c1","uid":2917449,"ip_address":"","ucode":"0300CD137BA854","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/3icaaUibVCz5gYiaj5gZ4wV8ick5RhEMpe47XKkdK1nAhA9qic6rwhSrpiasDSQYAwfiaIulhE4YKsbwoOXUfvL76EPSw/132","comment_is_top":false,"comment_ctime":1645940275,"is_pvip":false,"replies":[{"id":"122855","content":"value指定了你要调用的目标服务名称，模拟集群的话不用复制一份代码，直接在IDE里设置一个参数，允许并行启动，然后以不同端口启动就可以了","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1645971156,"ip_address":"","comment_id":336122,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5940907571","product_id":100101301,"comment_content":"cusmter服务通过openFeign调用template提供的服务，@FeignClient(value = &quot;coupon-template-serv&quot;), @FeignClient的value指定了调用服务的名称？<br><br>如果我把项目里的template-serv复制一份命名为template-serv-copy,用来模拟集群，这个时候copy的服务名称也要叫coupon-template-serv","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553584,"discussion_content":"value指定了你要调用的目标服务名称，模拟集群的话不用复制一份代码，直接在IDE里设置一个参数，允许并行启动，然后以不同端口启动就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645971156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333606,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1644421182,"is_pvip":true,"replies":[{"id":"122049","content":"方法有很多，RequestMapping里有注解属性可以支持header，也可以使用Headers注解，还可以在Feign的拦截器里加header","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1644749495,"ip_address":"","comment_id":333606,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5939388478","product_id":100101301,"comment_content":"要加自定义的header头怎么办？","like_count":2,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550824,"discussion_content":"方法有很多，RequestMapping里有注解属性可以支持header，也可以使用Headers注解，还可以在Feign的拦截器里加header","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644749495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330922,"user_name":"黄叶","can_delete":false,"product_type":"c1","uid":2332411,"ip_address":"","ucode":"8D8C566F7772A6","user_header":"https://static001.geekbang.org/account/avatar/00/23/96/fb/af39abb1.jpg","comment_is_top":false,"comment_ctime":1642302491,"is_pvip":true,"replies":[{"id":"120931","content":"freestyle啦，两种方式都行，挑一个自己喜欢的口味就可以","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1642426136,"ip_address":"","comment_id":330922,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5937269787","product_id":100101301,"comment_content":"老师，命名方面，我喜欢写成TestServiceFeign进行命名（方面我知道这是个Feign远程调用接口），但看老师是TestService来命名，想请问 这两种方式那种更好","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546798,"discussion_content":"freestyle啦，两种方式都行，挑一个自己喜欢的口味就可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642426136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2332411,"avatar":"https://static001.geekbang.org/account/avatar/00/23/96/fb/af39abb1.jpg","nickname":"黄叶","note":"","ucode":"8D8C566F7772A6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546805,"discussion_content":"好的谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642428068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546798,"ip_address":""},"score":546805,"extra":""}]}]},{"had_liked":false,"id":351736,"user_name":"Geek_eca226","can_delete":false,"product_type":"c1","uid":3021110,"ip_address":"上海","ucode":"E738A5618F3218","user_header":"","comment_is_top":false,"comment_ctime":1658137150,"is_pvip":true,"replies":[{"id":"128715","content":"其实rpc的定义相当宽泛，如果已字面意义来远程调用的都算作是rpc，包括openfeign这种http protocal框架。但是实践中我们一般是把dubbo，HSF这类protocal的叫做rpc框架，从体感上看，确实使用起来比feign更方便，只需要提供一个interface就可以调用，不像feign需要一些额外的开发","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1659935021,"ip_address":"上海","comment_id":351736,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1658137150","product_id":100101301,"comment_content":"openfeign是rpc框架吗，和dubbo那个用的多呢","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583153,"discussion_content":"其实rpc的定义相当宽泛，如果已字面意义来远程调用的都算作是rpc，包括openfeign这种http protocal框架。但是实践中我们一般是把dubbo，HSF这类protocal的叫做rpc框架，从体感上看，确实使用起来比feign更方便，只需要提供一个interface就可以调用，不像feign需要一些额外的开发","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659935021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3021110,"avatar":"","nickname":"Geek_eca226","note":"","ucode":"E738A5618F3218","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":583167,"discussion_content":"明白了，感谢半仙😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659936198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":583153,"ip_address":"北京"},"score":583167,"extra":""}]}]},{"had_liked":false,"id":330761,"user_name":"~","can_delete":false,"product_type":"c1","uid":2495621,"ip_address":"","ucode":"BE5E3BD6EE3665","user_header":"https://static001.geekbang.org/account/avatar/00/26/14/85/73e55be5.jpg","comment_is_top":false,"comment_ctime":1642148875,"is_pvip":false,"replies":[{"id":"120829","content":"是的，如果发生bug（不过feign这层没有业务逻辑，出bug的可能性很低），就发个新版通知业务方来替换就可以了","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1642314945,"ip_address":"","comment_id":330761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642148875","product_id":100101301,"comment_content":"思考题：既然每个业务方都要自行维护一套 OpenFeign 接口，还容易出现沟通不利接口出错的问题，不如业务提供方自行创建一套 OpenFeign 接口，单独抽出作为一个依赖，调用方只需要依赖这个就可以调用了。以后业务有改动也可以提供方自行维护，有变动或者需求更改直接给通知就可以了<br>但是一旦是重大的 bug 需要改动已经被多个调用方使用的依赖，会不会通知起来很麻烦，配合改动也很麻烦？这样改动也不是直接删除吧，新添加一个，之前的改为不建议使用就可以了吧","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546479,"discussion_content":"是的，如果发生bug（不过feign这层没有业务逻辑，出bug的可能性很低），就发个新版通知业务方来替换就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642314945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330198,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1641863787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641863787","product_id":100101301,"comment_content":"由服务提供者，把自己的服务接口封装成一个 jar 包，把 jar 提供给调用方使用即可","like_count":0},{"had_liked":false,"id":330100,"user_name":"tornado","can_delete":false,"product_type":"c1","uid":1486129,"ip_address":"","ucode":"306BF0D61DDFAB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/45iaRt3S6936b6KLRgpHnonnxXW4vbdMdJdgJX1TAKaN1Xv3GV0ziaN0hHRBicU6FcPKicnZd2M75ViaWqZ3Fjr6Wsw/132","comment_is_top":false,"comment_ctime":1641797365,"is_pvip":false,"replies":[{"id":"120281","content":"在早期版本里是使用的ribbon，但由于Ribbon在最新版本里已经被剔除出局了，你会发现依赖项里已经找不到netflix组件的身影了，所以现在大家在需要负载均衡的地方就用官方的loadbalancer组件就可以了","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641820631,"ip_address":"","comment_id":330100,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1641797365","product_id":100101301,"comment_content":"能讲讲feign的负载均衡么？查了一下了解的是feign集成了robbin？那robbin和LoadBalancer之间有什么关系呢？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545079,"discussion_content":"在早期版本里是使用的ribbon，但由于Ribbon在最新版本里已经被剔除出局了，你会发现依赖项里已经找不到netflix组件的身影了，所以现在大家在需要负载均衡的地方就用官方的loadbalancer组件就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641820631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1486129,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/45iaRt3S6936b6KLRgpHnonnxXW4vbdMdJdgJX1TAKaN1Xv3GV0ziaN0hHRBicU6FcPKicnZd2M75ViaWqZ3Fjr6Wsw/132","nickname":"tornado","note":"","ucode":"306BF0D61DDFAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545094,"discussion_content":"谢谢，明白了，确实找不到ribbon的影子了，找到了和loadbalancer相关的配置类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641822948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1486129,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/45iaRt3S6936b6KLRgpHnonnxXW4vbdMdJdgJX1TAKaN1Xv3GV0ziaN0hHRBicU6FcPKicnZd2M75ViaWqZ3Fjr6Wsw/132","nickname":"tornado","note":"","ucode":"306BF0D61DDFAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544999,"discussion_content":"之前把feign剥离出来，用在非微服务的项目里面，试过name和url的配置，感觉其实和Android里面用过的retrofit挺像的。现在搞晕的就是负载均衡组件的配合，希望老师简单梳理一下，谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641798922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330098,"user_name":"会飞的鱼","can_delete":false,"product_type":"c1","uid":2220587,"ip_address":"","ucode":"9498D63BA769F3","user_header":"https://static001.geekbang.org/account/avatar/00/21/e2/2b/5eab1490.jpg","comment_is_top":false,"comment_ctime":1641796777,"is_pvip":false,"replies":[{"id":"120266","content":"预计到3月中旬哦~","user_name":"编辑回复","user_name_real":"编辑","uid":"2843182","ctime":1641803455,"ip_address":"","comment_id":330098,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1641796777","product_id":100101301,"comment_content":"老师，这个课程啥时候可以全部更新完咧，有点着急。。。","like_count":0,"discussions":[{"author":{"id":2843182,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/62/2e/6cd7e076.jpg","nickname":"Angela","note":"","ucode":"0C144DE7ECB865","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545022,"discussion_content":"预计到3月中旬哦~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641803455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]}]}