{"id":132639,"title":"17 | TCP并不总是“可靠”的？","content":"<p>你好，我是盛延敏，这里是网络编程实战第17讲，欢迎回来。</p><p>在前面一讲中，我们讲到如何理解TCP数据流的本质，进而引出了报文格式和解析。在这一讲里，我们讨论通过如何增强读写操作，以处理各种“不可靠”的场景。</p><h2>TCP是可靠的？</h2><p>你可能会认为，TCP是一种可靠的协议，这种可靠体现在端到端的通信上。这似乎给我们带来了一种错觉，从发送端来看，应用程序通过调用send函数发送的数据流总能可靠地到达接收端；而从接收端来看，总是可以把对端发送的数据流完整无损地传递给应用程序来处理。</p><p>事实上，如果我们对TCP传输环节进行详细的分析，你就会沮丧地发现，上述论断是不正确的。</p><p>前面我们已经了解，发送端通过调用send函数之后，数据流并没有马上通过网络传输出去，而是存储在套接字的发送缓冲区中，由网络协议栈决定何时发送、如何发送。当对应的数据发送给接收端，接收端回应ACK，存储在发送缓冲区的这部分数据就可以删除了，但是，发送端并无法获取对应数据流的ACK情况，也就是说，发送端没有办法判断对端的接收方是否已经接收发送的数据流，如果需要知道这部分信息，就必须在应用层自己添加处理逻辑，例如显式的报文确认机制。</p><p>从接收端来说，也没有办法保证ACK过的数据部分可以被应用程序处理，因为数据需要接收端程序从接收缓冲区中拷贝，可能出现的状况是，已经ACK的数据保存在接收端缓冲区中，接收端处理程序突然崩溃了，这部分数据就没有办法被应用程序继续处理。</p><!-- [[[read_end]]] --><p>你有没有发现，TCP协议实现并没有提供给上层应用程序过多的异常处理细节，或者说，TCP协议反映链路异常的能力偏弱，这其实是有原因的。要知道，TCP诞生之初，就是为美国国防部服务的，考虑到军事作战的实际需要，TCP不希望暴露更多的异常细节，而是能够以无人值守、自我恢复的方式运作。</p><p>TCP连接建立之后，能感知TCP链路的方式是有限的，一种是以read为核心的读操作，另一种是以write为核心的写操作。接下来，我们就看下如何通过读写操作来感知异常情况，以及对应的处理方式。</p><h2>故障模式总结</h2><p>在实际情景中，我们会碰到各种异常的情况。在这里我把这几种异常情况归结为两大类：</p><p><img src=\"https://static001.geekbang.org/resource/image/39/af/39b060fa90628db95fd33305dc6fc7af.png?wh=1466*490\" alt=\"\"><br>\n第一类，是对端无FIN包发送出来的情况；第二类是对端有FIN包发送出来。而这两大类情况又可以根据应用程序的场景细分，接下来我们详细讨论。</p><h2>网络中断造成的对端无FIN包</h2><p>很多原因都会造成网络中断，在这种情况下，TCP程序并不能及时感知到异常信息。除非网络中的其他设备，如路由器发出一条ICMP报文，说明目的网络或主机不可达，这个时候通过read或write调用就会返回Unreachable的错误。</p><p>可惜大多数时候并不是如此，在没有ICMP报文的情况下，TCP程序并不能理解感应到连接异常。如果程序是阻塞在read调用上，那么很不幸，程序无法从异常中恢复。这显然是非常不合理的，不过，我们可以通过给read操作设置超时来解决，在接下来的第18讲中，我会讲到具体的方法。</p><p>如果程序先调用了write操作发送了一段数据流，接下来阻塞在read调用上，结果会非常不同。Linux系统的TCP协议栈会不断尝试将发送缓冲区的数据发送出去，大概在重传12次、合计时间约为9分钟之后，协议栈会标识该连接异常，这时，阻塞的read调用会返回一条TIMEOUT的错误信息。如果此时程序还执着地往这条连接写数据，写操作会立即失败，返回一个SIGPIPE信号给应用程序。</p><h2>系统崩溃造成的对端无FIN包</h2><p>当系统突然崩溃，如断电时，网络连接上来不及发出任何东西。这里和通过系统调用杀死应用程序非常不同的是，没有任何FIN包被发送出来。</p><p>这种情况和网络中断造成的结果非常类似，在没有ICMP报文的情况下，TCP程序只能通过read和write调用得到网络连接异常的信息，超时错误是一个常见的结果。</p><p>不过还有一种情况需要考虑，那就是系统在崩溃之后又重启，当重传的TCP分组到达重启后的系统，由于系统中没有该TCP分组对应的连接数据，系统会返回一个RST重置分节，TCP程序通过read或write调用可以分别对RST进行错误处理。</p><p>如果是阻塞的read调用，会立即返回一个错误，错误信息为连接重置（Connection Reset）。</p><p>如果是一次write操作，也会立即失败，应用程序会被返回一个SIGPIPE信号。</p><h2>对端有FIN包发出</h2><p>对端如果有FIN包发出，可能的场景是对端调用了close或shutdown显式地关闭了连接，也可能是对端应用程序崩溃，操作系统内核代为清理所发出的。从应用程序角度上看，无法区分是哪种情形。</p><p>阻塞的read操作在完成正常接收的数据读取之后，FIN包会通过返回一个EOF来完成通知，此时，read调用返回值为0。这里强调一点，收到FIN包之后read操作不会立即返回。你可以这样理解，收到FIN包相当于往接收缓冲区里放置了一个EOF符号，之前已经在接收缓冲区的有效数据不会受到影响。</p><p>为了展示这些特性，我分别编写了服务器端和客户端程序。</p><pre><code>//服务端程序\nint main(int argc, char **argv) {\n    int connfd;\n    char buf[1024];\n\n    connfd = tcp_server(SERV_PORT);\n\n    for (;;) {\n        int n = read(connfd, buf, 1024);\n        if (n &lt; 0) {\n            error(1, errno, &quot;error read&quot;);\n        } else if (n == 0) {\n            error(1, 0, &quot;client closed \\n&quot;);\n        }\n\n        sleep(5);\n\n        int write_nc = send(connfd, buf, n, 0);\n        printf(&quot;send bytes: %zu \\n&quot;, write_nc);\n        if (write_nc &lt; 0) {\n            error(1, errno, &quot;error write&quot;);\n        }\n    }\n\n    exit(0);\n}\n</code></pre><p>服务端程序是一个简单的应答程序，在收到数据流之后回显给客户端，在此之前，休眠5秒，以便完成后面的实验验证。</p><p>客户端程序从标准输入读入，将读入的字符串传输给服务器端：</p><pre><code>//客户端程序\nint main(int argc, char **argv) {\n    if (argc != 2) {\n        error(1, 0, &quot;usage: reliable_client01 &lt;IPaddress&gt;&quot;);\n    }\n\n    int socket_fd = tcp_client(argv[1], SERV_PORT);\n    char buf[128];\n    int len;\n    int rc;\n\n    while (fgets(buf, sizeof(buf), stdin) != NULL) {\n        len = strlen(buf);\n        rc = send(socket_fd, buf, len, 0);\n        if (rc &lt; 0)\n            error(1, errno, &quot;write failed&quot;);\n        rc = read(socket_fd, buf, sizeof(buf));\n        if (rc &lt; 0)\n            error(1, errno, &quot;read failed&quot;);\n        else if (rc == 0)\n            error(1, 0, &quot;peer connection closed\\n&quot;);\n        else\n            fputs(buf, stdout);\n    }\n    exit(0);\n}\n</code></pre><h3>read直接感知FIN包</h3><p>我们依次启动服务器端和客户端程序，在客户端输入good字符之后，迅速结束掉服务器端程序，这里需要赶在服务器端从睡眠中苏醒之前杀死服务器程序。</p><p>屏幕上打印出：peer connection closed。客户端程序正常退出。</p><pre><code>$./reliable_client01 127.0.0.1\n$ good\n$ peer connection closed\n</code></pre><p>这说明客户端程序通过read调用，感知到了服务端发送的FIN包，于是正常退出了客户端程序。</p><p><img src=\"https://static001.geekbang.org/resource/image/b0/ec/b0922e1b1824f1e4735f2788eb3527ec.png?wh=636*466\" alt=\"\"><br>\n注意如果我们的速度不够快，导致服务器端从睡眠中苏醒，并成功将报文发送出来后，客户端会正常显示，此时我们停留，等待标准输入。如果不继续通过read或write操作对套接字进行读写，是无法感知服务器端已经关闭套接字这个事实的。</p><h3>通过write产生RST，read调用感知RST</h3><p>这一次，我们仍然依次启动服务器端和客户端程序，在客户端输入bad字符之后，等待一段时间，直到客户端正确显示了服务端的回应“bad”字符之后，再杀死服务器程序。客户端再次输入bad2，这时屏幕上打印出”peer connection closed“。</p><p>这是这个案例的屏幕输出和时序图。</p><pre><code>$./reliable_client01 127.0.0.1\n$bad\n$bad\n$bad2\n$peer connection closed\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/a9/f2/a95d3b87a9a93421774d7aeade8efbf2.png?wh=1438*760\" alt=\"\"><br>\n在很多书籍和文章中，对这个程序的解读是，收到FIN包的客户端继续合法地向服务器端发送数据，服务器端在无法定位该TCP连接信息的情况下，发送了RST信息，当程序调用read操作时，内核会将RST错误信息通知给应用程序。这是一个典型的write操作造成异常，再通过read操作来感知异常的样例。</p><p>不过，我在Linux 4.4内核上实验这个程序，多次的结果都是，内核正常将EOF信息通知给应用程序，而不是RST错误信息。</p><p>我又在Max OS 10.13.6上尝试这个程序，read操作可以返回RST异常信息。输出和时序图也已经给出。</p><pre><code>$./reliable_client01 127.0.0.1\n$bad\n$bad\n$bad2\n$read failed: Connection reset by peer (54)\n</code></pre><h3>向一个已关闭连接连续写，最终导致SIGPIPE</h3><p>为了模拟这个过程，我对服务器端程序和客户端程序都做了如下修改。</p><pre><code>nt main(int argc, char **argv) {\n    int connfd;\n    char buf[1024];\n    int time = 0;\n\n    connfd = tcp_server(SERV_PORT);\n\n    while (1) {\n        int n = read(connfd, buf, 1024);\n        if (n &lt; 0) {\n            error(1, errno, &quot;error read&quot;);\n        } else if (n == 0) {\n            error(1, 0, &quot;client closed \\n&quot;);\n        }\n\n        time++;\n        fprintf(stdout, &quot;1K read for %d \\n&quot;, time);\n        usleep(1000);\n    }\n\n    exit(0);\n}\n</code></pre><p>服务器端每次读取1K数据后休眠1秒，以模拟处理数据的过程。</p><p>客户端程序在第8行注册了SIGPIPE的信号处理程序，在第14-22行客户端程序一直循环发送数据流。</p><pre><code>int main(int argc, char **argv) {\n    if (argc != 2) {\n        error(1, 0, &quot;usage: reliable_client02 &lt;IPaddress&gt;&quot;);\n    }\n\n    int socket_fd = tcp_client(argv[1], SERV_PORT);\n\n    signal(SIGPIPE, SIG_IGN);\n\n    char *msg = &quot;network programming&quot;;\n    ssize_t n_written;\n\n    int count = 10000000;\n    while (count &gt; 0) {\n        n_written = send(socket_fd, msg, strlen(msg), 0);\n        fprintf(stdout, &quot;send into buffer %ld \\n&quot;, n_written);\n        if (n_written &lt;= 0) {\n            error(1, errno, &quot;send error&quot;);\n            return -1;\n        }\n        count--;\n    }\n    return 0;\n}\n</code></pre><p>如果在服务端读取数据并处理过程中，突然杀死服务器进程，我们会看到客<strong>户端很快也会退出</strong>，并在屏幕上打印出“Connection reset by peer”的提示。</p><pre><code>$./reliable_client02 127.0.0.1\n$send into buffer 5917291\n$send into buffer -1\n$send: Connection reset by peer\n</code></pre><p>这是因为服务端程序被杀死之后，操作系统内核会做一些清理的事情，为这个套接字发送一个FIN包，但是，客户端在收到FIN包之后，没有read操作，还是会继续往这个套接字写入数据。这是因为根据TCP协议，连接是双向的，收到对方的FIN包只意味着<strong>对方不会再发送任何消息</strong>。 在一个双方正常关闭的流程中，收到FIN包的一端将剩余数据发送给对面（通过一次或多次write），然后关闭套接字。</p><p>当数据到达服务器端时，操作系统内核发现这是一个指向关闭的套接字，会再次向客户端发送一个RST包，对于发送端而言如果此时再执行write操作，立即会返回一个RST错误信息。</p><p>你可以看到针对这个全过程的一张描述图，你可以参考这张图好好理解一下这个过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/42/ebf533a453573b85ff03a46103fc5b42.png?wh=1436*528\" alt=\"\"><br>\n以上是在Linux 4.4内核上测试的结果。</p><p>在很多书籍和文章中，对这个实验的期望结果不是这样的。大部分的教程是这样说的：在第二次write操作时，由于服务器端无法查询到对应的TCP连接信息，于是发送了一个RST包给客户端，客户端第二次操作时，应用程序会收到一个SIGPIPE信号。如果不捕捉这个信号，应用程序会在毫无征兆的情况下直接退出。</p><p>我在Max OS 10.13.6上尝试这个程序，得到的结果确实如此。你可以看到屏幕显示和时序图。</p><pre><code>#send into buffer 19 \n#send into buffer -1 \n#send error: Broken pipe (32)\n</code></pre><p>这说明，Linux4.4的实现和类BSD的实现已经非常不一样了。限于时间的关系，我没有仔细对比其他版本的Linux，还不清楚是新的内核特性，但有一点是可以肯定的，我们需要记得为SIGPIPE注册处理函数，通过write操作感知RST的错误信息，这样可以保证我们的应用程序在Linux 4.4和Mac OS上都能正常处理异常。</p><h2>总结</h2><p>在这一讲中，我们意识到TCP并不是那么“可靠”的。我把故障分为两大类，一类是对端无FIN包，需要通过巡检或超时来发现；另一类是对端有FIN包发出，需要通过增强read或write操作的异常处理，帮助我们发现此类异常。</p><h2>思考题</h2><p>和往常一样，给大家布置两道思考题。</p><p>第一道，你不妨在你的Linux系统中重新模拟一下今天文章里的实验，看看运行结果是否和我的一样。欢迎你把内核版本和结果贴在评论里。</p><p>第二道题是，如果服务器主机正常关闭，已连接的程序会发生什么呢？</p><p>你不妨思考一下这两道题，欢迎你在评论区写下你的模拟结果和思考，我会和你一起交流，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","comments":[{"had_liked":false,"id":134974,"user_name":"张立华","can_delete":false,"product_type":"c1","uid":1231713,"ip_address":"","ucode":"173B938DD9478A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/61/b62d8a3b.jpg","comment_is_top":false,"comment_ctime":1568966112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"100353213920","product_id":100032701,"comment_content":"这篇文章提醒我们的是，从代码的角度将注意三点：<br>1，程序启动的时候，忽略 SIGPIPE<br>2，read, write 要判断返回值，根据返回值知道socket断开了<br>3，应用层使用 心跳包，心跳包达到超时阀值，则认定socket断开了<br>","like_count":24},{"had_liked":false,"id":132084,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1568020617,"is_pvip":false,"replies":[{"id":"50780","content":"正解。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568189197,"ip_address":"","comment_id":132084,"utype":1}],"discussion_count":4,"race_medal":0,"score":"74582464649","product_id":100032701,"comment_content":"看到后面我好像理解了我上面那个提问,当崩溃重启过后是重新三次握手建立连接,创建新的套接字,只是在网络上传输的包,因为是通过ip地址和端口方式进行的寻址,所以新连接上去的客户端会接收到之前还没接收到的包,然后新连接的客户端没有这些包的tcp分组信息所以就会给服务器端(对端)发送一个RST","like_count":17,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466754,"discussion_content":"正解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568189197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2109519,"avatar":"https://static001.geekbang.org/account/avatar/00/20/30/4f/8684040d.jpg","nickname":"Jason °","note":"","ucode":"77AE294DE60497","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376129,"discussion_content":"tcp是通过两端的ip和端口来区分链接的，如果两边it和端口一致，会认为是一条链接，这时候收到rst不是因为没有分组信息，而是因为数据的序列号不对","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1621988392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1688939,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAia6hRmnSZyuLtKvxxXvg9vgUfwSReCOaHKGLKuRcNX2BCNdmCFSlXyBZvpSXia5LXKjAZKeBXKuw/132","nickname":"Geek_guan","note":"","ucode":"592603EB5F042D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220880,"discussion_content":"新连接的客户端不是会重新分配端口吗？怎么还能接受到之前没有接收到的包呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585927652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1307067,"avatar":"","nickname":"super-ck","note":"","ucode":"02F036E53E1130","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1688939,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAia6hRmnSZyuLtKvxxXvg9vgUfwSReCOaHKGLKuRcNX2BCNdmCFSlXyBZvpSXia5LXKjAZKeBXKuw/132","nickname":"Geek_guan","note":"","ucode":"592603EB5F042D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263165,"discussion_content":"采用随机分配还是有可能分配到同一个\n如果指定端口，肯定就是同一个了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589181924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":220880,"ip_address":""},"score":263165,"extra":""}]}]},{"had_liked":false,"id":234683,"user_name":"melon","can_delete":false,"product_type":"c1","uid":1023773,"ip_address":"","ucode":"7A80C20EBCAAA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/1d/ec173090.jpg","comment_is_top":false,"comment_ctime":1594773452,"is_pvip":false,"replies":[{"id":"86816","content":"所以需要在客户端程序里加sleep就可以了？","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1594908072,"ip_address":"","comment_id":234683,"utype":1}],"discussion_count":3,"race_medal":0,"score":"44544446412","product_id":100032701,"comment_content":"最后的例子没有触发SIGPIPE，是因为老师例子设计的有点儿瑕疵。client 在不断的发送数据，server 则每次接受数据之后都 sleep 一会，也就导致接收速度小于发送速度，进而导致 server 终止的时候接收缓冲区还有数据没有被读取，server 终止触发 close 调用，close 调用时如果接收缓冲区有尚未被应用程序读取的数据时，不发 FIN 包，直接发 RST 包。client 每次发送数据之后 sleep 2秒，再试就会出SIGPIPE 了。","like_count":10,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501466,"discussion_content":"所以需要在客户端程序里加sleep就可以了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594908072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023773,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/1d/ec173090.jpg","nickname":"melon","note":"","ucode":"7A80C20EBCAAA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291689,"discussion_content":"对的，本质就是让服务器端程序终止的时候，套接字接收缓冲区的数据都被应用读走了，这样协议栈就会发出FIN包了，否则协议栈就直接粗暴的发RST包了事。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1594908927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2944638,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/ee/7e/519b6808.jpg","nickname":"哦","note":"","ucode":"8DC2C012FEFA68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1023773,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/1d/ec173090.jpg","nickname":"melon","note":"","ucode":"7A80C20EBCAAA4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564229,"discussion_content":"服务端终止时直接发送RST的话，为什么客户端的write不直接出SIGPIPE呀？这个时候不是在对已经接收了RST的socket做write吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650195480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291689,"ip_address":""},"score":564229,"extra":""}]}]},{"had_liked":false,"id":191753,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1584794589,"is_pvip":false,"replies":[{"id":"73532","content":"说明新版的内核在这些特性上有所改进。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1584863295,"ip_address":"","comment_id":191753,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35944532957","product_id":100032701,"comment_content":"我的电脑，结果也是一样的，<br>第二个问题，服务器正常关闭，客户端应该是受到了fin包，read返回eOF,wirte返回rst","like_count":8,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488248,"discussion_content":"说明新版的内核在这些特性上有所改进。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584863295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329845,"discussion_content":"客户端在收到FIN包后,write会把剩余的包继续发完,再发送ACK包和自己的FIN包,最后在收到自己FIN包的ACK包后关闭连接","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606467406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169191,"user_name":"盘尼西林","can_delete":false,"product_type":"c1","uid":1197347,"ip_address":"","ucode":"B59569FC25144F","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/23/28311447.jpg","comment_is_top":false,"comment_ctime":1578289433,"is_pvip":false,"replies":[{"id":"68081","content":"一个是TCP RST的状态异常，一个是SIGPIPE 信号将进程进行回收。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1580631476,"ip_address":"","comment_id":169191,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18758158617","product_id":100032701,"comment_content":"没有理解 reset by peer 和 broken pipe 的区别。。","like_count":5,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480451,"discussion_content":"一个是TCP RST的状态异常，一个是SIGPIPE 信号将进程进行回收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580631476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139270,"user_name":"tim","can_delete":false,"product_type":"c1","uid":1065570,"ip_address":"","ucode":"50F90216B4640B","user_header":"https://static001.geekbang.org/account/avatar/00/10/42/62/536aef06.jpg","comment_is_top":false,"comment_ctime":1570598054,"is_pvip":false,"replies":[{"id":"54323","content":"这里是从应用层报文数据角度出发来说的，因为数据是一个流，没有办法判断数据的哪些部分没对端收到。<br><br>从TCP角度来说，确实是通过ACK来感知TCP包的接收情况的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570973415,"ip_address":"","comment_id":139270,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18750467238","product_id":100032701,"comment_content":"&gt;&gt;&quot;但是，发送端并无法获取对应数据流的 ACK 情况&quot;<br>对上面这段话不理解，TCP 的 ACK不是带着序号的吗？发送端根据这个序号能计算出是哪次发送的ACK。<br>哪位大牛能解释一下吗？","like_count":4,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469869,"discussion_content":"这里是从应用层报文数据角度出发来说的，因为数据是一个流，没有办法判断数据的哪些部分没对端收到。\n\n从TCP角度来说，确实是通过ACK来感知TCP包的接收情况的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570973415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170796,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/6c/abb7bfe3.jpg","nickname":"JAMES","note":"","ucode":"63015120144DDB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30960,"discussion_content":"同问","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570873336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1154146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","nickname":"酸葡萄","note":"","ucode":"9D059C4FB327C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30271,"discussion_content":"同问，老师能解答下吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570808847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245504,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/40/a203a3b9.jpg","nickname":"爱学习不害怕","note":"","ucode":"BE325C02E4C92F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297692,"discussion_content":"我想老师的意思是说：发送端不清楚接收端的应用层到底实际处理了数据没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597025296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232361,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1053390,"ip_address":"","ucode":"ABB3F1A63E102A","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","comment_is_top":false,"comment_ctime":1593966046,"is_pvip":false,"replies":[{"id":"86787","content":"根据错误码打印错误信息，并且可以退出当前程序。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1594903857,"ip_address":"","comment_id":232361,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5888933342","product_id":100032701,"comment_content":"error(1, 0, &quot;usage: reliable_client01 &lt;IPaddress&gt;&quot;);这个error函数，具体是什么作用？","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500611,"discussion_content":"根据错误码打印错误信息，并且可以退出当前程序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594903857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140393,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1570927123,"is_pvip":false,"replies":[{"id":"54287","content":"到现在为止，都是阻塞的，后面会切成非阻塞的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570968250,"ip_address":"","comment_id":140393,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5865894419","product_id":100032701,"comment_content":"老师，你文章的案例默认fd都是阻塞的吧，如果是非阻塞的话，返回的n &lt; 0 不一定是错误啊","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470370,"discussion_content":"到现在为止，都是阻塞的，后面会切成非阻塞的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570968250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512599,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/88nXicqmkJWm3IXVfPfGQSk8SKIBVKjuC4qhzaCkf5Ud88uvKgS4Vf5AzCJ1uaFO0gpPnxdh4CowfhpxV1kSbXw/132","nickname":"lixin","note":"","ucode":"94D99DAFB6C929","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584745,"discussion_content":"超哥，即刻活跃任务\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661074834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133523,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1568596997,"is_pvip":false,"replies":[{"id":"51614","content":"这就是为什么需要使用select、poll等事件分发机制，正确的解法是一旦有事件发生，比如这里read读到EOF，就应用直接去处理此类事件，而不是阻塞在这里等待用户的输入。好消息是，很快我们就会详细学习这部分内容了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568886088,"ip_address":"","comment_id":133523,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863564293","product_id":100032701,"comment_content":"老师 我提一个read直接感知FIN包的疑问哈:<br><br>我停留在 stdin这里 等我输入完之后，就能调用read感知到对端已经关闭了呀？ 是因为等到stdin之后，再感知是不是太晚了呀？","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467412,"discussion_content":"这就是为什么需要使用select、poll等事件分发机制，正确的解法是一旦有事件发生，比如这里read读到EOF，就应用直接去处理此类事件，而不是阻塞在这里等待用户的输入。好消息是，很快我们就会详细学习这部分内容了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568886088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132677,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1568190602,"is_pvip":false,"replies":[{"id":"51754","content":"我猜想是会直接关闭的，没有对ACK的ACK包。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568960537,"ip_address":"","comment_id":132677,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5863157898","product_id":100032701,"comment_content":"第二题  客户端--------服务器<br><br>1.  客户端发送FIN包，处于发送缓冲区的数据会逐一发送（可能通过一次或多次write操作发送），FIN包处于这段数据的末尾，当数据到达接收端的接收缓冲区时，FIN起到了一个结束符的作用，当接收端接收数据时遇到FIN包，read操作返回EOF通知应用层。然后接收端返回一个ACK表示对这次发送的确认。（此时客户端进入FIN_WAIT1，服务端进入CLOSE_WAIT状态）<br><br>2.  客户端接收到ACK之后，关闭自己的发送通道，客户端此时处于半关闭状态。等待服务器发送FIN包。<br><br>  (客户端进入FIN_WAIT2状态)<br><br>3.  服务端发送FIN包，同上类似处于发送缓冲区的内容会连同FIN包一起发过去，当客户端接收成功后同时将FIN解析为EOF信号使得上层调用返回。（客户端进入TIME_WAIT状态 服务端进入LAST_ACK状态）<br><br>4. 客户端等待2MSL的时间，在此期间向服务器发送ACK。如果丢包进行重传。如果服务器收到ACK后 服务器进入CLOSED状态 客户端也进入CLOSED状态。<br><br>5. 连接关闭<br>我想问一下  如果最后一次挥手一直丢包  在2MSL的时间内都没到  TCP会咋办  会重置计时器么 还是就不管了直接关闭呢","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467063,"discussion_content":"我猜想是会直接关闭的，没有对ACK的ACK包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568960537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1452675,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhbjhkN9mVxxA3wfMCmZ5BmoFVHXyaOkqDH5uRXGQNFngDdJDYqkf82ictdicZ9WibLjoiapcom4XbGw/132","nickname":"木易","note":"","ucode":"7CCA6255570E6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296956,"discussion_content":"FIN也会重传吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596714135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131977,"user_name":"yusuf","can_delete":false,"product_type":"c1","uid":1170784,"ip_address":"","ucode":"9F32149B2ADDA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/60/eae432c6.jpg","comment_is_top":false,"comment_ctime":1567997910,"is_pvip":false,"replies":[{"id":"50779","content":"基本和我的Linux下结果一致。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568189103,"ip_address":"","comment_id":131977,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862965206","product_id":100032701,"comment_content":"# uname -a<br>Linux tst 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU&#47;Linux<br># <br># .&#47;reliable_client01 127.0.0.1<br>good<br>peer connection closed<br># <br># .&#47;reliable_client01 127.0.0.1<br>bad<br>bad<br>bad2<br>peer connection closed<br># <br># .&#47;reliable_client02 127.0.0.1<br>send into buffer 19 <br>send into buffer -1 <br>send error: Connection reset by peer (104)<br>","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466707,"discussion_content":"基本和我的Linux下结果一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568189103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350133,"user_name":"Geek_573990","can_delete":false,"product_type":"c1","uid":3035685,"ip_address":"","ucode":"D004FB1694442A","user_header":"","comment_is_top":false,"comment_ctime":1656587634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656587634","product_id":100032701,"comment_content":"做实验时想抓包，输入<br>#sudo tcpdump host 127.0.0.1<br>然后分别开启server和client做实验，完成后得到结果<br>0 packet captured<br>请问老师这个抓包命令应该怎么写","like_count":0},{"had_liked":false,"id":329823,"user_name":"Bin Watson","can_delete":false,"product_type":"c1","uid":2622364,"ip_address":"","ucode":"33E3487896E859","user_header":"https://static001.geekbang.org/account/avatar/00/28/03/9c/5a0b8825.jpg","comment_is_top":false,"comment_ctime":1641552630,"is_pvip":false,"replies":[{"id":"120798","content":"内核的版本，确实是会影响某些细微的行为。","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1642310186,"ip_address":"","comment_id":329823,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641552630","product_id":100032701,"comment_content":"在内核4.15.0-158-generic版本中，在服务器关闭后，客户端是返SIGPIPE错误。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546438,"discussion_content":"内核的版本，确实是会影响某些细微的行为。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642310186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307757,"user_name":"乔纳森","can_delete":false,"product_type":"c1","uid":1045107,"ip_address":"","ucode":"51EC9FAE071388","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/73/1c7bceae.jpg","comment_is_top":false,"comment_ctime":1629248351,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629248351","product_id":100032701,"comment_content":"客户端和服务端keep-alive 的timeout 时间不同的情况下，有可能出现老师说的场景，服务端keep-alive 超时时间小于客户端，先发FIN 报文，在服务端发FIN 报文的同时，客户端也想服务端发送P 数据包，这个时候，服务端就会收到P数据报后，就会向客户端回复一个R包；","like_count":0},{"had_liked":false,"id":303771,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1626973162,"is_pvip":false,"replies":[{"id":"111682","content":"这里想要表达的是，从应用层协议出发，没有办法保证应用层数据流，被完美的处理过和应答过，如果要做到这一点，是需要应用层加以处理逻辑的。而TCP这一层，只能做到报文级别的接收和发送，而不是真正的程序处理。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1629637244,"ip_address":"","comment_id":303771,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626973162","product_id":100032701,"comment_content":"当对应的数据发送给接收端，接收端回应 ACK，存储在发送缓冲区的这部分数据就可以删除了，但是，发送端并无法获取对应数据流的 ACK 情况，也就是说，发送端没有办法判断对端的接收方是否已经接收发送的数据流，如果需要知道这部分信息，就必须在应用层自己添加处理逻辑，例如显式的报文确认机制<br><br><br>不是很明白，为什么发送端无法获取对应数据流的ACK情况？  不是收到对方回的ACK包了吗？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523816,"discussion_content":"这里想要表达的是，从应用层协议出发，没有办法保证应用层数据流，被完美的处理过和应答过，如果要做到这一点，是需要应用层加以处理逻辑的。而TCP这一层，只能做到报文级别的接收和发送，而不是真正的程序处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629637244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296938,"user_name":"highfly029","can_delete":false,"product_type":"c1","uid":2038039,"ip_address":"","ucode":"F1B0BE5097B61A","user_header":"","comment_is_top":false,"comment_ctime":1623230903,"is_pvip":false,"replies":[{"id":"108673","content":"你都已经网络中断了，只能是通过客户端的response来确定服务端消息是不是发送出去了，肯定没办法保证消息不丢了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1624805150,"ip_address":"","comment_id":296938,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623230903","product_id":100032701,"comment_content":"老师好，请教个问题，对于网络中断导致的故障，我们的处理是服务端因为timeout而主动close连接，在timeout之前的这段时间内，服务端会不断的发送消息，如果保证这段时间的消息不丢失？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521657,"discussion_content":"你都已经网络中断了，只能是通过客户端的response来确定服务端消息是不是发送出去了，肯定没办法保证消息不丢了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624805150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283637,"user_name":"James","can_delete":false,"product_type":"c1","uid":1036309,"ip_address":"","ucode":"7A0DC75746CB3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/15/c5dc2b0d.jpg","comment_is_top":false,"comment_ctime":1615862120,"is_pvip":false,"replies":[{"id":"103188","content":"对于很多高可靠性的场景，考虑到各种复杂的条件，应用层是需要保证的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1616314066,"ip_address":"","comment_id":283637,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615862120","product_id":100032701,"comment_content":"想问下接收端为什么接受不到ACK,你说从应用层的角度看，网络层保证可靠性就可以了，应用层还需要再次保证吗","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517101,"discussion_content":"对于很多高可靠性的场景，考虑到各种复杂的条件，应用层是需要保证的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616314066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276453,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1611931970,"is_pvip":false,"replies":[{"id":"100428","content":"如果没有捕捉到这个信号，就会自动退出。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1612101829,"ip_address":"","comment_id":276453,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1611931970","product_id":100032701,"comment_content":"write触发SIGPIPE后，程序会自动退出，还是继续执行？？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514707,"discussion_content":"如果没有捕捉到这个信号，就会自动退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612101829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266947,"user_name":"duckman","can_delete":false,"product_type":"c1","uid":2184325,"ip_address":"","ucode":"0184C26C4B6C1B","user_header":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","comment_is_top":false,"comment_ctime":1607532042,"is_pvip":false,"replies":[{"id":"98877","content":"基本是等价的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1610286104,"ip_address":"","comment_id":266947,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607532042","product_id":100032701,"comment_content":"本系列的代码中send 和 write 都有用，搜了一下, 确实可以替换<br><br>There should be no difference. Quoting from man 2 send:<br><br>The only difference between send() and write() is the presence of flags. With zero flags parameter, send() is equivalent to write().<br><br>https:&#47;&#47;stackoverflow.com&#47;questions&#47;1100432&#47;performance-impact-of-using-write-instead-of-send-when-writing-to-a-socket","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511457,"discussion_content":"基本是等价的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610286104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241014,"user_name":"Passion","can_delete":false,"product_type":"c1","uid":1365412,"ip_address":"","ucode":"71EC499C1315CF","user_header":"https://static001.geekbang.org/account/avatar/00/14/d5/a4/5dd93357.jpg","comment_is_top":false,"comment_ctime":1597151060,"is_pvip":false,"replies":[{"id":"89398","content":"可以通过抓包来看","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1597640869,"ip_address":"","comment_id":241014,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597151060","product_id":100032701,"comment_content":"老师 我的数据通过send函数写入内核发送缓冲区没问题， 我抓取发送的端口 发现与我写入的数据对不上 怎么定位  比如我写入缓冲区100sql  发出去的只找到80个sql","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503620,"discussion_content":"可以通过抓包来看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597640869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238426,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1596164822,"is_pvip":false,"replies":[{"id":"89340","content":"read、write操作可能返回的错误和异常包含了FIN、RST等这些操作得到的结果。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1597585298,"ip_address":"","comment_id":238426,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596164822","product_id":100032701,"comment_content":"有个疑问，FIN包这些底层操作，怎么与READ,WRITE有关，不是TCP底层直接处理好了吗？read,write不是操作用户应用层的数据吗？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502746,"discussion_content":"read、write操作可能返回的错误和异常包含了FIN、RST等这些操作得到的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597585298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231348,"user_name":"郑祖煌","can_delete":false,"product_type":"c1","uid":1469608,"ip_address":"","ucode":"49A0D2E3279826","user_header":"https://static001.geekbang.org/account/avatar/00/16/6c/a8/1922a0f5.jpg","comment_is_top":false,"comment_ctime":1593656012,"is_pvip":false,"replies":[{"id":"85728","content":"确实有可能，我再MAC OS 10.13.6和Linux 4.4上的结果就不一样。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1593954390,"ip_address":"","comment_id":231348,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593656012","product_id":100032701,"comment_content":"第一题我的服务器关闭，但是客户端并没有打印Connection reset by peer，而是打印send into buffer 4294967295,同时打印send error。是不是版本的原因。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500269,"discussion_content":"确实有可能，我再MAC OS 10.13.6和Linux 4.4上的结果就不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593954390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222634,"user_name":"Geek_76f04f","can_delete":false,"product_type":"c1","uid":2020720,"ip_address":"","ucode":"2A3D34C303E19A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d5/70/93a34aa5.jpg","comment_is_top":false,"comment_ctime":1590853358,"is_pvip":false,"replies":[{"id":"82177","content":"你内核的版本？环境？<br><br>而且杀死服务端的时间也很关键，在客户端输入 bad 字符之后，等待一段时间，直到客户端正确显示了服务端的回应“bad”字符之后，再杀死服务器程序。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1590931284,"ip_address":"","comment_id":222634,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590853358","product_id":100032701,"comment_content":"老师您好，我在运行第二个程序的时候，当关闭服务端的时候，客户端很大的概率不会收到RST，相反会持续的write，直到wireshark抓包显示窗口为0 。 请教老师为什么客户端收不到RST，窗口为0是不是因为内核缓冲区满了？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496870,"discussion_content":"你内核的版本？环境？\n\n而且杀死服务端的时间也很关键，在客户端输入 bad 字符之后，等待一段时间，直到客户端正确显示了服务端的回应“bad”字符之后，再杀死服务器程序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590931284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210650,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1134539,"ip_address":"","ucode":"11C598D0723D08","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/cb/ede92cd5.jpg","comment_is_top":false,"comment_ctime":1587802718,"is_pvip":false,"replies":[{"id":"79183","content":"是的，真正鲁棒的程序是需要各种异常和极端情况的考验的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1588497918,"ip_address":"","comment_id":210650,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587802718","product_id":100032701,"comment_content":"SIGPIPE的处理对出错处理很重要，深有体会","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493075,"discussion_content":"是的，真正鲁棒的程序是需要各种异常和极端情况的考验的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588497918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185847,"user_name":"吴向兵","can_delete":false,"product_type":"c1","uid":1350398,"ip_address":"","ucode":"918DFE98556A05","user_header":"https://static001.geekbang.org/account/avatar/00/14/9a/fe/c451a509.jpg","comment_is_top":false,"comment_ctime":1583711777,"is_pvip":false,"replies":[{"id":"72376","content":"我认为epoll不需要感知tcp连接的异常，tcp连接异常应该是应用程序利用轮询或者tcp自身的机制来发现，转而调用epoll的接口进行连接套接字的清理工作。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1584174071,"ip_address":"","comment_id":185847,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583711777","product_id":100032701,"comment_content":"老师，你好，想问一下，epoll能感知到tcp连接的异常吗？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486524,"discussion_content":"我认为epoll不需要感知tcp连接的异常，tcp连接异常应该是应用程序利用轮询或者tcp自身的机制来发现，转而调用epoll的接口进行连接套接字的清理工作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584174071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170174,"user_name":"HerofH","can_delete":false,"product_type":"c1","uid":1480252,"ip_address":"","ucode":"84EB3243FAB432","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/86QEF74Mhc6ECbBBMr62hVz0ezOicI2Kbv8QBA7qR7KepeoDib9W6KLxxMPuQ24JGusvjC03NNr8uj8GyK0DxKiaw/132","comment_is_top":false,"comment_ctime":1578543048,"is_pvip":false,"replies":[{"id":"68063","content":"为啥要区分这两种情况呢？程序这端都是连接无效，无法进行数据的有效传输。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1580630463,"ip_address":"","comment_id":170174,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578543048","product_id":100032701,"comment_content":"老师您好，我想请问一个关于感知到RST后的一个处理问题。<br>如前所述，如果对端调用shutdown(SD_RD)关闭读端，那么此时本端向对端进行写操作后收到对端的RST；而如果对端是突然崩溃后重启，由于本端不知道对端已经崩溃，此时本端发送的数据到达对端，也会收到RST。<br>针对这两种情况的处理方式，根据我的理解，前者应该是关闭本端的写，而后者则应该直接关闭本端到对端的连接。那么如何区分这两种情况呢？我感觉在本端的反应都是同样的read返回，然后errno被设置为ECONNRESET，我该怎么知道到底是哪种情况呢？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480871,"discussion_content":"为啥要区分这两种情况呢？程序这端都是连接无效，无法进行数据的有效传输。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580630463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154697,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1574514105,"is_pvip":false,"replies":[{"id":"60387","content":"这个问题很大。。。。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1575189317,"ip_address":"","comment_id":154697,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574514105","product_id":100032701,"comment_content":"假如让你设计一个网络通信协议，你会怎么设计？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475551,"discussion_content":"这个问题很大。。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575189317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153562,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1574258809,"is_pvip":false,"replies":[{"id":"59336","content":"kill掉A进程后，B进程如果收不到FIN包，它的却能保持ESTABLISHED状态，通过对链路进行读写可以感知链路的状态，当然，你也可以加上心跳检测，检测出链路的状态。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1574498924,"ip_address":"","comment_id":153562,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574258809","product_id":100032701,"comment_content":"老师好，有个问题想请教下。<br>有进程A和B(在同一物理机下)，A会监听B的连接。在我对进程A kill -2后，B与A的连接一直保持着ESTABILISH,  进程A重启时，绑定监听端口会出现端口被占用的异常。<br><br>这种情况是否表示B没有收到A的fin包，所以才一直保持着ESTABILISH的状态？ 这种情况应该怎么解决？<br><br>如果我给进程B加上一个对A的心跳检测，能否解决这个问题？<br><br>期待老师能给我答疑","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475211,"discussion_content":"kill掉A进程后，B进程如果收不到FIN包，它的却能保持ESTABLISHED状态，通过对链路进行读写可以感知链路的状态，当然，你也可以加上心跳检测，检测出链路的状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574498924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141779,"user_name":"JasonZhi","can_delete":false,"product_type":"c1","uid":1282818,"ip_address":"","ucode":"6C23DCD592636D","user_header":"https://static001.geekbang.org/account/avatar/00/13/93/02/fcab58d1.jpg","comment_is_top":false,"comment_ctime":1571223593,"is_pvip":true,"replies":[{"id":"55110","content":"如文中所说，我在MAC系统上实验的结果却是是SIGPIPE，但是在Linux 4.4内核上的实验结果却是直接返回了RST结果，传统教科书都是说应该返回SIGPIPE，但是我得到的Linux 4.4上的结果却不是这样的。<br><br>我建议你通过实验再尝试一下。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1571455504,"ip_address":"","comment_id":141779,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571223593","product_id":100032701,"comment_content":"老师你好，文章的最后一个例子还有一些疑问。我的理解是对于一个已经关闭的socket ，执行两次write ，第一次write 会导致对端返回RST，第二次write 由于对收到RST的socket 执行写操作，会触发SIGPIPE。但是为什么例子却说会返回peer reset的错误呢？是不是我哪里理解错了。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470885,"discussion_content":"如文中所说，我在MAC系统上实验的结果却是是SIGPIPE，但是在Linux 4.4内核上的实验结果却是直接返回了RST结果，传统教科书都是说应该返回SIGPIPE，但是我得到的Linux 4.4上的结果却不是这样的。\n\n我建议你通过实验再尝试一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571455504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139144,"user_name":"JasonZhi","can_delete":false,"product_type":"c1","uid":1282818,"ip_address":"","ucode":"6C23DCD592636D","user_header":"https://static001.geekbang.org/account/avatar/00/13/93/02/fcab58d1.jpg","comment_is_top":false,"comment_ctime":1570556614,"is_pvip":true,"replies":[{"id":"54319","content":"休眠4秒之后往一个已经关闭的套接字记下写数据，于是得到了SIGPIPE信号。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570973157,"ip_address":"","comment_id":139144,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1570556614","product_id":100032701,"comment_content":"老师你好，我在linux环境下测试最后一个例子时，在客户端代码的count--后面加上sleep(4)，那么关闭服务端后，连续向服务端写入就会返回PIPIE错误，并且会收到SIGPIPIE信号，能解释其中原因吗？<br>贴上代码：<br> while (count &gt; 0) {<br>        n_written = send(socket_fd, msg, strlen(msg), 0);<br>        fprintf(stdout, &quot;send into buffer %ld \\n&quot;, n_written);<br><br>        if (n_written &lt;= 0) {<br>            error(1, errno, &quot;send error&quot;);<br>            return -1;<br>        }<br>        count--;<br><br>        sleep(4);<br>    }","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469811,"discussion_content":"休眠4秒之后往一个已经关闭的套接字记下写数据，于是得到了SIGPIPE信号。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570973157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282818,"avatar":"https://static001.geekbang.org/account/avatar/00/13/93/02/fcab58d1.jpg","nickname":"JasonZhi","note":"","ucode":"6C23DCD592636D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34132,"discussion_content":"还是有点不太明白，这种情况跟老师你举的最后一个例子有什么不一样吗？我的理解它们都应该属于同一种情况才对吧？第一次write返回RST，第二次write触发SIGPIPE","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571166209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135316,"user_name":"微思","can_delete":false,"product_type":"c1","uid":1004349,"ip_address":"","ucode":"853C48AA183A7B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/3d/1189e48a.jpg","comment_is_top":false,"comment_ctime":1569124509,"is_pvip":true,"replies":[{"id":"52192","content":"是打印出来的error信息，<br>if (err)<br>   fprintf(stderr, &quot;: %s (%d)\\n&quot;, strerror(err), err);","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569406376,"ip_address":"","comment_id":135316,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1569124509","product_id":100032701,"comment_content":"老师，最后一行的Connection reset by peer是从哪里打印输出的？是内核协议栈打印输出到终端上的吗？在程序代码中没找到对应的printf语句","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468140,"discussion_content":"是打印出来的error信息，\nif (err)\n   fprintf(stderr, &amp;quot;: %s (%d)\\n&amp;quot;, strerror(err), err);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569406376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132152,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1568033405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568033405","product_id":100032701,"comment_content":"Linux VM-0-13-ubuntu 4.15.0-54-generic #58-Ubuntu SMP Mon Jun 24 10:55:24 UTC 2019 x86_64 x86_64 x86_64 GNU&#47;Linux<br>这个是客户端不停的发送然后服务器端突然关闭<br>.&#47;client: send error: Connection reset by peer","like_count":0},{"had_liked":false,"id":132137,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1568030160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568030160","product_id":100032701,"comment_content":"第一问因为要写代码所以等会来回答先回答第二问<br>其实服务器正常退出和异常突出我觉得都差不多,都需要靠read或者write去感知,如果对方已经断开连接就会发送一个fin到本方的接收缓冲区变为eof,read函数也返回0,调用write会失败","like_count":0},{"had_liked":false,"id":132065,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1568017849,"is_pvip":false,"replies":[{"id":"50781","content":"你已经回答自己的问题了，当然是新的连接。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568189225,"ip_address":"","comment_id":132065,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568017849","product_id":100032701,"comment_content":"其实我也一直想问 比如 我客户端突然崩溃了 然后再启动客户端连接上服务器 到底是新建立一个链接 还是老的连接 并且发送rst?","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466742,"discussion_content":"你已经回答自己的问题了，当然是新的连接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568189225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131966,"user_name":"石将从","can_delete":false,"product_type":"c1","uid":1375617,"ip_address":"","ucode":"12F43E643D1D58","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/81/1864f266.jpg","comment_is_top":false,"comment_ctime":1567994245,"is_pvip":false,"replies":[{"id":"50784","content":"因为TCP是双向的，对端是一个相对的概念，连接建立之后，服务器和客户端彼此互为对方的对端。<br><br>建议你再多理几遍，欢迎提具体的问题。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568189518,"ip_address":"","comment_id":131966,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567994245","product_id":100032701,"comment_content":"这篇读了几遍还是很懵，很多概念理不清楚，不知道对端到底是服务器端还是客户端，都混淆了","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466699,"discussion_content":"因为TCP是双向的，对端是一个相对的概念，连接建立之后，服务器和客户端彼此互为对方的对端。\n\n建议你再多理几遍，欢迎提具体的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568189518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8643,"discussion_content":"我觉得并不一定非要分清 服务器还是客户端 比如 你关闭了连接 我调用recv或者write的现象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568030490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131911,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1567962217,"is_pvip":false,"replies":[{"id":"50785","content":"这里想要表达的就是通过read&#47;write来感知TCP链路的状态，一个是通过read来感知，一个是在没有read的情况下使用write来感知。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568189643,"ip_address":"","comment_id":131911,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567962217","product_id":100032701,"comment_content":"没有看出“通过 write 产生 RST，read 调用感知 RST”和“向一个已关闭连接连续写，产生SIGPIPE”二者有什么区别呀。前者两个write之间多了一次read，为何在linux下的返回结果就不一样了呀？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466677,"discussion_content":"这里想要表达的就是通过read/write来感知TCP链路的状态，一个是通过read来感知，一个是在没有read的情况下使用write来感知。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568189643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101226,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/aa/33d48789.jpg","nickname":"卫江","note":"","ucode":"DE2F7A6916F1A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8483,"discussion_content":"linux内核收到tcp分组，就会查找对应的连接，如果找不到或已经关闭等都会回复rst，对端的linux内核收到之后，就会标记本地对应的连接的状态，比如已经接受了rst，如果这个时候，再次进行write，内核会直接产生sigpipe信号，如果这个时候，进行read，也会立即返回，并通过返回值和错误码来标识原因。所以，上面并没有什么不同，只是想说，对于收到rst的连接，再次write会产生sigpipe信号，如果这个时候，继续read和收到rst之后read没有什么不同，所以，从这个角度来说，我们可以通过read和write来感知异常情况，不过主要还是需要read，同时因为网络中断，机器挂掉等影响对tcp分组的回复，从而只能依赖超时来配合完善所有可能，比如我们应用层中的心跳包。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1568009324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}