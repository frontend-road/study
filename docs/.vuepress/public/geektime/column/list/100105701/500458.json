{"id":500458,"title":"18 | 加解密服务平台：如何让敏感数据存储与传输更安全？","content":"<p>你好，我是李智慧。</p><p>在一个应用系统运行过程中，需要记录、传输很多数据，这些数据有的是非常敏感的，比如用户姓名、手机号码、密码、甚至信用卡号等等。这些数据如果直接存储在数据库，记录在日志中，或者在公网上传输的话，一旦发生数据泄露，不但可能会产生重大的经济损失，还可能会使公司陷入重大的公关与法律危机。公司上下辛苦十几年，一夜回到解放前。</p><p>所以，敏感信息必须进行加密处理，也就是把敏感数据以密文的形式存储、传输。这样即使被黑客攻击，发生数据泄露，被窃取的数据也是密文，获取数据的人无法得到真实的明文内容，敏感数据依然被保护着。而当应用程序需要访问这些密文的时候，只需要进行数据解密，即可还原得到原始明文数据。加解密处理既保证了数据的安全，又保证了数据的正常访问。</p><p>但是，这一切的前提是<strong>加密和解密过程的安全</strong>。加密、解密过程由加密算法、加密密钥、解密算法、解密密钥组成。下图是一个对称加密、解密过程。对称加密密钥和解密密钥是同一个密钥，调用加密算法可将明文加密为密文，调用解密算法可将密文还原为明文。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/68/77f666f32fb506a4a73cd41a0d51dc68.jpg?wh=1920x423\" alt=\"图片\"></p><p>所以，如果窃取数据的人知道了解密算法和密钥，即使数据是加密的，也可以轻松对密文进行还原，得到原始的明文数据。而很多时候，解密算法和密钥都以源代码的方式保存在代码仓库里，黑客如果窃取了源代码，或者内部人泄露了源代码，那么所有的秘密就都不是秘密了。</p><!-- [[[read_end]]] --><p>此外，在某些情况下，我们的系统需要和外部系统进行对称加密数据传输，比如和银行加密传输信用卡卡号，这时候涉及到密钥交换，即我方人员和银行人员对接，直接传递密钥。如果因密钥泄露导致重大经济损失，那么持有密钥的人员将无法自证清白，这又会导致没有人愿意保管密钥。</p><p>因此，我们设计了一个加解密服务系统，系统名称为“Venus”，统一管理所有的加解密算法和密钥。应用程序只需要依赖加解密服务SDK，调用接口进行加解密即可，而真正的算法和密钥在系统服务端进行管理，保证算法和密钥的安全。</p><h2>需求分析</h2><p>一般说来，日常开发中的加解密程序存在如下问题：</p><ol>\n<li>密钥（包括非对称加解密证书）保存在源文件或者配置文件中，存储分散而不安全。</li>\n<li>密钥没有分片交换机制，不能满足高安全级密钥管理和交换的要求。</li>\n<li>密钥缺乏版本管理，不能灵活升级，一旦修改密钥，此前加密的数据就可能无法解密。</li>\n<li>加密解密算法程序不统一，同样算法不同实现，内部系统之间密文不能正确解析。</li>\n<li>部分加解密算法程序使用了弱加解密算法和弱密钥，存在安全隐患。</li>\n</ol><p>为此，我们需要设计开发一个专门的加解密服务及密钥管理系统，以解决以上问题。</p><p>Venus是一个加解密服务系统，核心功能是加解密服务，辅助功能是密钥与算法管理。此外，Venus还需要满足以下非功能需求：</p><ul>\n<li>\n<p><strong>安全性需求</strong><br>\n必须保证密钥的安全性，保证没有人能够有机会看到完整的密钥。因此一个密钥至少要拆分成两片，分别存储在两个异构的、物理隔离的存储服务器中 。在需要进行密钥交换的场景中，将密钥至少拆分成两个片段，每个管理密钥的人只能看到一个密钥片段，需要双方所有人分别交接才能完成一次密钥交换。</p>\n</li>\n<li>\n<p><strong>可靠性需求</strong><br>\n加解密服务必须可靠，即保证高可用。无论在加解密服务系统服务器宕机、还是网络中断等各种情况下，数据正常加解密都需要得到保障。</p>\n</li>\n<li>\n<p><strong>性能需求</strong><br>\n加解密计算的时间延迟主要花费在加解密算法上，也就是说，加载加解密算法程序、获取加解密密钥的时间必须短到可以忽略不计。</p>\n</li>\n</ul><p>根据以上加解密服务系统功能和非功能需求，系统用例图设计如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/ba/1c0f89yy0163a142385f3a7b11b03fba.jpg?wh=1920x1215\" alt=\"图片\"></p><p>系统主要参与者（Actor）包括：</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/c4/6eba9d961b89797e68d158ed1d7698c4.jpg?wh=1920x766\" alt=\"图片\"></p><p>系统主要用例过程和功能包括：</p><ol>\n<li>开发工程师使用密钥管理功能为自己开发的应用申请加解密算法和密钥；</li>\n<li>安全工程师使用密钥管理功能审核算法和密钥的强度是否满足数据安全要求；</li>\n<li>（经过授权的）密钥管理者使用密钥管理功能可以查看密钥（的一个分片）；</li>\n<li>应用程序调用加解密功能完成数据的加密、解密；</li>\n<li>加密解密功能和密钥管理功能调用密钥服务功能完成密钥的存储和读取；</li>\n<li>密钥服务功能访问一个安全、可靠的密钥存储系统读写密钥。</li>\n</ol><p>总地说来，Venus应满足如下需求：</p><ol>\n<li>集中、分片密钥存储与管理，多存储备份，保证密钥安全易管理。</li>\n<li>密钥申请者、密钥管理者、密钥访问者，多角色多权限管理，保证密钥管理与传递的安全。</li>\n<li>通过密钥管理控制台完成密钥申请、密钥管理、密钥访问控制等一系列密钥管理操作，实现便捷的密钥管理。</li>\n<li>统一加解密服务API，简单接口，统一算法，为内部系统提供一致的加解密算法实现。</li>\n</ol><h2>概要设计</h2><p>针对上述加解密服务及密钥安全管理的需求，设计加解密服务系统Venus整体结构如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/69/ea95154aef0b8d3d2975406d95488069.jpg?wh=1920x1215\" alt=\"图片\"></p><p>应用程序调用Venus提供的加解密SDK服务接口，对信息进行加解密，该SDK接口提供了常用的加密解密算法并可根据需求任意扩展。SDK加解密服务接口调用Venus密钥服务器的密钥服务，以取得加解密密钥，并缓存在本地。而密钥服务器中的密钥则来自多个密钥存储服务器，一个密钥分片后存储在多个存储服务器中，每个服务器都由不同的人负责管理。密钥申请者、密钥管理者、安全审核人员通过密钥管理控制台管理更新密钥，每个人各司其事，没有人能查看完整的密钥信息。</p><h4>部署模型</h4><p>Venus部署模型如图：</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/cd/0a74fc0354a422b74a7a22e3ea8125cd.jpg?wh=1920x1215\" alt=\"图片\"></p><p>Venus系统的核心服务器是Key Server服务器，提供密钥管理服务。密钥分片存储在文件服务器File Store和数据库DB中。</p><p>使用Venus加解密服务的应用程序（Application）部署在应用程序服务器（App Server）中，依赖Venus提供的SDK API进行数据加解密。而Venus SDK 则是访问密钥服务器（Key Server）来获取加解密算法代码和密钥。</p><p>安全起见，密钥将被分片存储在文件服务器（Key File Store）和数据库服务器（Key DB）中。所以Key Server服务器中部署了密钥管理组件（Key Manager），用于访问数据库中的应用程序密钥元信息（Key Meta Data），以此获取密钥分片存储信息。Key Server服务器根据这些信息访问File Store和DB，获取密钥分片，并把分片拼接为完整密钥，最终返回给SDK。</p><p>此外，密钥管理控制台（Key Console）提供一个web页面，供开发工程师、安全工程师、密钥管理者进行密钥申请、更新、审核、查看等操作。</p><h4>加解密调用时序图</h4><p>加解密调用过程如下时序图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/51/0b/517ec6bf8ea55ce12a873083e0bbyy0b.jpg?wh=1920x1215\" alt=\"图片\"></p><ol>\n<li>应用程序App调用Venus SDK对数据进行加密（解密）。</li>\n<li>SDK检查在本地是否有缓存加解密需要的密钥和加解密算法代码，如果有缓存，就直接使用该算法和密钥进行加解密。</li>\n<li>如果本地没有缓存密钥和算法，请求远程服务器返回密钥和算法。</li>\n<li>部署在Venus服务器的Key Manager收到请求后，访问数据库，检查该应用配置的密钥和算法Meta信息。</li>\n<li>数据库返回的Mata信息中包括了密钥的分片信息和存储位置，Key Manager访问文件服务器和数据库，获取密钥分片，并将多个分片合并成一个完整密钥，返回给客户端SDK。</li>\n<li>SDK收到密钥后，缓存在本地进程内存中，并完成对App加解密调用的处理。</li>\n</ol><p>通过该设计，我们可以看到，Venus对密钥进行分片存储，不同存储服务器由不同运维人员管理。就算需要进行密钥交换，那么参与交换的人员，每个人也只能获得一个密钥分片，无法得到完整的密钥，这样就保证了密钥的安全性。</p><p>密钥缓存在SDK所在的进程（也就是应用程序App所在的进程）中，只有第一次调用时会访问远程的Venus服务器，其他调用只访问本进程缓存。因此加解密的性能只受加解密的数据大小和算法的影响，不受Venus服务的性能影响，满足了性能要求。</p><p>同时，由于密钥在缓存中，如果Venus服务器临时宕机，或者网络通信中断，也不会影响到应用程序的正常使用，保证了Venus的可靠性。但是如果Venus服务器长时间宕机，那么应用重新启动，本地缓存被清空，就需要重新请求密钥，这时候应用就不可用了。那么Venus如何在这种情况下仍然保证高可用呢？</p><p>解决方案就是对Venus服务器、数据库和文件服务器做高可用备份。Venus服务器部署2-3台服务器，构建一个小型集群，SDK通过软负载均衡访问Venus服务器集群，若发现某台Venus服务器宕机，就进行失效转移。同样，数据库和文件服务器也需要做主从备份。</p><h2>详细设计</h2><p>Venus详细设计主要关注SDK核心类设计。其他的例如数据库结构设计、服务器密钥管理Console设计等，这里不做展开。</p><h4>密钥领域模型</h4><p>为了便于SDK缓存、管理密钥信息以及SDK与Venus服务端传输密钥信息，我们设计了一个密钥领域模型，如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/0d/c9cd240b8f27e38e0027656ed512da0d.jpg?wh=1920x1106\" alt=\"图片\"></p><ol>\n<li>一个应用程序使用的所有密钥信息都记录在KeyBox对象中，KeyBox对象中有一个keySuitMap成员变量，这个map的key是密钥名称，value是一个KeySuit对象。</li>\n<li>KeySuit类中有一个keyChainMap成员变量，这个map类的key是版本号，value是一个KeyChain对象。Venus因为安全性需求，需要支持多版本的密钥。也就是说，对同一类数据的加密密钥过一段时间就会进行版本升级，这样即使密钥泄露，也只会影响一段时间的数据，不会导致所有的数据都被解密。</li>\n<li>KeySuit类的另一个成员变量currentVersion记录当前最新的密钥版本号，也就是当前用来进行数据加密的密钥版本号。而解密的时候，则需要从密文数据中提取出加密密钥版本号（或者由应用程序自己记录密钥版本号，在解密的时候提供给Venus SDK API），根据这个版本号获取对应的解密密钥。</li>\n<li>具体每个版本的密钥信息记录在KeyChain中，包含了密钥名称name、密钥版本号version、加入本地缓存的时间cache_time、该版本密钥创建的时间versionTime、对应的加解密算法algorithm，当然，还有最重要的密钥分片列表keyChipList，里面按序记录着这个密钥的分片信息。</li>\n<li>KeyChip记录每个密钥分片，包括分片编号no，以及分片密钥内容chip。</li>\n</ol><h4>核心服务类设计</h4><p>应用程序通过调用加解密API VenusService完成数据加解密。如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/a5/f012b372fa95b2468a0042e37yyb5ca5.jpg?wh=1920x1106\" alt=\"图片\"></p><ol>\n<li>Venus SDK的核心类是VenusService，应用程序调用该对象的encrypt方法进行加密，decrypt方法进行解密。应用程序需要构造VenusData对象，将加解密数据传给VenusService，VenusService加解密完成后创建一个新的VenusData对象，将加解密的结果写入该对象并返回。VenusData成员变量在后面详细讲解。</li>\n<li>VenusService通过VenusConnector类连接Venus服务器获取密钥KeyBox和算法Algorithm，并调用Algorithm的对应方法完成加解密。</li>\n</ol><p>以加密为例，具体处理过程时序图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/25/6e/25fb2958a3f84c3f2b09dd09d35de96e.jpg?wh=1920x1215\" alt=\"图片\"></p><p>首先，应用程序App创建VenusData对象，并将待加密数据写入该对象。接着，App调用VenusService的encrypt方法进行加密，VenusService检查加密需要的密钥和算法是否已经有缓存，如果没有，就调用VenusConnector请求服务器，返回密钥和算法。VenusConnector将根据返回的算法字节码来构造加密算法的实例对象，同时根据返回的密钥构造相关密钥对象，并写入KeyBox，完成更新。</p><p>下一步，VenusService会根据更新后的KeyBox中的密钥和算法进行加密，并将加密结果写入VenusData。最后，应用程序App从返回的VenusData中获取加密后的数据即可。</p><h4>加解密数据接口VenusData设计</h4><p>VenusData用于表示Venus加解密操作输入和输出的数据，也就是说，加解密的时候构造VenusData对象调用Service对应的方法，加解密完成后返回值还是一个VenusData对象。</p><p>VenusData包含的属性如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/a0/e595e1f0882df1ea415e841f6657f2a0.jpg?wh=1920x948\" alt=\"图片\"></p><p>VenusData用作输入时：</p><ol>\n<li>属性bytes和text只要设置一个，即要么处理的是二进制bytes数据，要么是Striing数据，如果两个都设置了，Venus会抛出异常。</li>\n<li>属性version可以不设置（即null），表示Venus操作使用的密钥版本是当前版本。</li>\n<li>属性outputWithText表示输出的VenusData是否处理为text类型，缺省值是true。</li>\n<li>属性dataWithVersion表示加密后的VenusData的bytes和text 中是否包含使用密钥的版本信息，这样在解密的时候可以不指定版本，缺省值是false。</li>\n</ol><p>如果dataWithVersion设置为true，即表示加密后密文内包含版本号，这种情况下，VenusService需要在密文头部增加3个字节的版本号信息，其中头两个字节为固定的magic code：0x5E、0x23，第三个字节为版本号（也就是说，密钥版本号只占用一个字节，最多支持256个版本）。</p><p>VenusData用作输出时，Venus会设置属性keyName（和输入时的值一样）、version、 bytes、 outputWithText、dataWithVersion（和输入时的值一样），并根据输入的 outputWithText决定是否设置text属性。</p><h4>测试用例代码demo</h4><pre><code class=\"language-java\">    public static void testVenusService() throws Exception {\n        // 准备数据\n        VenusData data1 = new VenusData();\n        data1.setKeyName(\"aeskey1\");\n        data1.setText(\"PlainText\");\n        // 加密操作\n        VenusData encrypt = VenusService.encrypt(data1);\n        System.out.printf(\"Key Name: %s, Secret Text: %s, Version: %d.\\n\", encrypt.getKeyName(),\n                encrypt.getText(), encrypt.getVersion());\n        // 准备数据\n        VenusData data2 = new VenusData();\n        data2.setKeyName(\"aeskey1\");\n        data2.setBytes(encrypt.getBytes());\n        data2.setVersion(encrypt.getVersion());\n        // 解密操作\n        VenusData decrypt = VenusService.decrypt(data2);\n        System.out.printf(\"Key Name: %s, Plain Text: %s, Version: %d.\\n\", decrypt.getKeyName(),\n                decrypt.getText(), decrypt.getVersion());\n    }\n</code></pre><h2>小结</h2><p>随着国家信息安全法规的逐步完善以及用户对个人信息安全意识的增强，互联网信息安全也变得越来越重要了。据估计，我国每年涉及互联网信息安全的灰色产业达1000亿，很多应用在自己不知情的情况下，已经被窃取了信息并进行交易了。</p><p>Venus是根据某大厂真实设计改编的，如果你所在的公司还没有类似安全的加解密服务平台，不妨参考Venus的设计，开发实现一个这样的系统。</p><h2>思考题</h2><p>在你的工作中使用了哪些加密算法，算法以及密钥是否安全？有什么改进的思路吗？</p><p>欢迎在评论区分享你的思考，我们共同进步。</p><blockquote>\n<p>【编辑温馨提示】4月10日12点前，提交<a href=\"http://https://time.geekbang.org/column/article/495175\">期中测试</a>作业，有机会获得老师精心准备的奖励哦~</p>\n</blockquote>","neighbors":{"left":{"article_title":"17 | Web 应用防火墙：怎样拦截恶意用户的非法请求？","id":499714},"right":{"article_title":"19 | 许可型区块链重构：无中心的区块链怎么做到可信任？","id":501341}},"comments":[{"had_liked":false,"id":340116,"user_name":"Realm","can_delete":false,"product_type":"c1","uid":1081299,"ip_address":"","ucode":"30CBEBE619D1A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/d3/b5896293.jpg","comment_is_top":false,"comment_ctime":1648610193,"is_pvip":true,"replies":[{"id":"124423","content":"原文 ： 属性 dataWithVersion 表示加密后的 VenusData 的 bytes 和 text 中是否包含使用密钥的版本信息<br><br>这个属性为true，加密内容自带版本号，解密的时候使用对应版本号密钥解密。","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648690542,"ip_address":"","comment_id":340116,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10238544785","product_id":100105701,"comment_content":"老师，有没有可能遇到切换版本，造成解密的密钥和加密密钥不一致的情况？","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559289,"discussion_content":"原文 ： 属性 dataWithVersion 表示加密后的 VenusData 的 bytes 和 text 中是否包含使用密钥的版本信息\n\n这个属性为true，加密内容自带版本号，解密的时候使用对应版本号密钥解密。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648690542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1081299,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7f/d3/b5896293.jpg","nickname":"Realm","note":"","ucode":"30CBEBE619D1A2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":559290,"discussion_content":"谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648690604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":559289,"ip_address":""},"score":559290,"extra":""}]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579496,"discussion_content":"参考jwks的玩法。。一开始引入 key id 或者版本号即可 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657502016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343415,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1650845012,"is_pvip":false,"replies":[{"id":"125404","content":"一般公司的运维安全审计可以防止这种情况，如果觉得运维安全审计的安全等级不够，那就需要部署专门的加解密服务，并提升这些服务的访问权限和安全审计级别。这个专门的加解密服务依然可以用文中的设计，就是文中的应用程序角色。","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1650877532,"ip_address":"","comment_id":343415,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5945812308","product_id":100105701,"comment_content":"老师，有个疑问，如果密钥缓存在本地。会不会被JVM分析工具解析出来","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567292,"discussion_content":"一般公司的运维安全审计可以防止这种情况，如果觉得运维安全审计的安全等级不够，那就需要部署专门的加解密服务，并提升这些服务的访问权限和安全审计级别。这个专门的加解密服务依然可以用文中的设计，就是文中的应用程序角色。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650877532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340128,"user_name":"Steven","can_delete":false,"product_type":"c1","uid":1253652,"ip_address":"","ucode":"3FE64459842015","user_header":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","comment_is_top":false,"comment_ctime":1648618283,"is_pvip":false,"replies":[{"id":"124424","content":"缓存是指缓存在本地内存中，其实就是指创建的密钥对象不释放，不会增加风险。","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648690690,"ip_address":"","comment_id":340128,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5943585579","product_id":100105701,"comment_content":"加解密用过：AES、RSA<br>单向加密用过：MD5, SHA1<br><br>有个疑问：“SDK 加解密服务接口取得加解密密钥，并缓存在本地”，这样会不会有安全风险？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559291,"discussion_content":"缓存是指缓存在本地内存中，其实就是指创建的密钥对象不释放，不会增加风险。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648690690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346690,"user_name":"knife","can_delete":false,"product_type":"c1","uid":1123262,"ip_address":"","ucode":"55EBB099BC5CBB","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/be/81bd6a7b.jpg","comment_is_top":false,"comment_ctime":1653362102,"is_pvip":true,"replies":[{"id":"126463","content":"Venus应用于系统内部加解密服务，数据在内网传输，一般认为这种网络环境是安全的。","user_name":"作者回复","user_name_real":"作者","uid":"1007349","ctime":1653394012,"ip_address":"","comment_id":346690,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653362102","product_id":100105701,"comment_content":"请问老师，在获取密匙服务的时候 需要一次远程调用，这时候如果被拦截，有可能泄露密匙，是否只能通过不断升级版本进行解决","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573408,"discussion_content":"Venus应用于系统内部加解密服务，数据在内网传输，一般认为这种网络环境是安全的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653394012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345521,"user_name":"王肖武","can_delete":false,"product_type":"c1","uid":1282385,"ip_address":"","ucode":"561AF05284EBE2","user_header":"https://static001.geekbang.org/account/avatar/00/13/91/51/234f9a73.jpg","comment_is_top":false,"comment_ctime":1652348174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652348174","product_id":100105701,"comment_content":"2个小问题帮忙解答一下：<br>1.我们公司在做密评，直接用老师的这个设计能通过不呢？<br>2.听说RSA1024、MD5、SHA-1等不是安全的加密算法，老师推荐哪些对应的算法呢？","like_count":0},{"had_liked":false,"id":344777,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1651762753,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651762753","product_id":100105701,"comment_content":"可以优化的点：<br>1、多数据中心需要做异地双活；而且密钥绝对不能丢失；<br>2、可以增加机构和APP的概念，机构下有多个APP，APP可以绑定一到多个KeyBox，便于权限管理，也可以防止一些误操作；<br>3、在确认密钥及加密算法规则时，可以让安全团队全程参与评审的；后续按需选择算法，密钥自动生成即可，可以减少后续安全评审工作量；<br>4、金融行业还会用到密码机，否则可能无法达到合规性要求；<br><br>几个可能痛苦的过程：<br>1、系统先上线，加密后上线，历史数据加密+去除明文数据会痛苦；<br>2、系统模糊查询灵活性下降，无法做like类似查询。但可以预先将前缀或后缀进行hash，用前缀或后缀做一些匹配；<br>3、DB加密后，基于ETL或DB日志的部分任务就无法进行了，需要做调整；<br>4、密钥版本功能挺好的，换密钥很痛苦；","like_count":0},{"had_liked":false,"id":343251,"user_name":"闪耀之星","can_delete":false,"product_type":"c1","uid":1062497,"ip_address":"","ucode":"784389C5A5A598","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/61/d22371da.jpg","comment_is_top":false,"comment_ctime":1650726638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650726638","product_id":100105701,"comment_content":"老师，您好，请教个问题： 如果像敏感字段都以加密的方式存储在数据库中，那么像一些复杂的脚本包含加密字段做函数处理的情况或者加密字段作为查询条件进行部分匹配检索、模糊匹配的情况是否有比较搞效的解决方案呢？ ","like_count":1},{"had_liked":false,"id":340625,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1315541,"ip_address":"","ucode":"346EC4B30294F6","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/d5/38764102.jpg","comment_is_top":false,"comment_ctime":1648976157,"is_pvip":false,"replies":[{"id":"124617","content":"查询条件也加密","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1649210301,"ip_address":"","comment_id":340625,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1648976157","product_id":100105701,"comment_content":"老师，如果数据加密存储的话，如果要以这些字段做查询条件有没比较高效的搞法？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560134,"discussion_content":"查询条件也加密","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649210301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1315541,"avatar":"https://static001.geekbang.org/account/avatar/00/14/12/d5/38764102.jpg","nickname":"无名","note":"","ucode":"346EC4B30294F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":570844,"discussion_content":"老师，万一是模糊查询呢)(（￣□￣；）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651936522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":560134,"ip_address":""},"score":570844,"extra":""}]}]},{"had_liked":false,"id":340196,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1648651378,"is_pvip":false,"replies":[{"id":"124427","content":"赞。<br>盐也是一种密钥，动态的盐也是由确定的信息计算来的，相当于增加了算法复杂度，还是有泄漏风险，保管好密钥才是王道。","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648691134,"ip_address":"","comment_id":340196,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648651378","product_id":100105701,"comment_content":"现在工作中，其实主要是两个，一个是摘要算法，也就是MD5这种。众所周知，安全性不是很高，容易被破解。不过，对于安全系数要求不是特别高的业务场景，也足够用了。（不涉及钱的场景）<br>另一种是，可逆的加密。主要用于处理敏感信息。比如手机号。手机号，通过盐，在数据库存储密文。然后，配置文件里存盐。取出来的时候，逆运算一波即可。<br><br>其实，我的理解，加密的核心无非就是防止数据泄漏的风险。这个很好理解，就好像，一个宝箱存着你的所有财产，如果只有一把钥匙，那这把钥匙丢了或者被人复制了，那你的财产就全丢了。所以，可以多上几把锁。每把钥匙放在你不同的亲信那里，必须要集齐所有的钥匙才能打开你的宝箱。比如，如果数据库明文，数据库泄漏了那用户密码就泄漏了。如果加上密钥，就需要同时获取数据库和密钥，如果再加上分片，就需要同时搜集多个分片。大幅度降低了泄漏的几率。毕竟，那么多数据同时泄漏还是太离谱了。<br><br>优化的点的话，我认为，我们系统的盐存配置文件也不是很安全。我在想，盐是不是可以做成动态的。通过用户部分不会改变的摘要信息去换取盐。<br><br>","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559295,"discussion_content":"赞。\n盐也是一种密钥，动态的盐也是由确定的信息计算来的，相当于增加了算法复杂度，还是有泄漏风险，保管好密钥才是王道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648691134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340086,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1648599946,"is_pvip":true,"replies":[{"id":"124364","content":"1 等缓存过期。另外，密码和算法不能修改，只能升级版本，修改的话已经加密了的数据怎么办<br>2 只能在内存中，在硬盘就不安全了<br>3 建议3片，系统不做要求","user_name":"作者回复","user_name_real":"作者","uid":"1007349","ctime":1648605521,"ip_address":"","comment_id":340086,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648599946","product_id":100105701,"comment_content":"请教老师几个问题啊：<br>Q1：在客户端有缓存的情况下，服务端修改密码和算法以后，客户端怎么同步？<br>Q2：客户端的缓存只存于内存中吗？还是会存到硬盘上？<br>Q3：密码一般分几片？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559080,"discussion_content":"1 等缓存过期。另外，密码和算法不能修改，只能升级版本，修改的话已经加密了的数据怎么办\n2 只能在内存中，在硬盘就不安全了\n3 建议3片，系统不做要求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648605521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}