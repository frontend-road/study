{"id":740867,"title":"第 5 章 面向生产的 Spring Boot(2)","content":"<h2 id=\"nav_point_84\">5.3　部署 Spring Boot 应用程序</h2>\n<p>在 Spring Boot Actuator 的帮助下，我们早早地就准备好了一些手段来掌握系统在运行时的各种指标，现在就差临门一脚，让系统在服务器上跑起来了，而这也是一门学问，在这一节里就让我们一同来了解一下其中的秘诀。</p>\n<h3 id=\"nav_point_85\">5.3.1　可执行 Jar 及其原理</h3>\n<p>放到以前，要运行 Java EE 的应用程序需要一个应用容器，比如 JBoss 或者 Tomcat。但随着技术的发展，外置容器已经不再是必选项了，Spring Boot 可以内嵌 Tomcat、Jetty 等容器，一句简单的 <code>java -jar</code> 命令就能让我们的工程像个普通进程一样运行起来。</p>\n<ol>\n<li><p><strong>通过 Maven 打包整个工程</strong></p>\n<p>在用 Maven 命令打包前，先来回顾一下 pom.xml 中配置的插件：</p>\n<pre class=\"code-rows\"><code>&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;</code></pre>\n<p><code>spring-boot-maven-plugin</code> 会在 Maven 的打包过程中自动介入，除了生成普通的 Jar 包外，还会生成一个包含所有依赖的 Fat Jar。以上一节用到的 ch5/binarytea-export 为例，打开一个终端（macOS 中的终端，对应 Windows 中的 CMD 或者 PowerShell），在工程目录中（即 pom.xml 的目录）键入如下命令 <span class=\"comment-number\">16</span>：</p>\n<pre class=\"code-rows\"><code>▸ mvn clean package -Dmaven.test.skip</code></pre>\n<p>随后，查看 <code>target</code> 目录的内容，大致会是下面这样的：</p>\n<pre class=\"code-rows\"><code>total 38712\n-rw-r--r--  1 digitalsonic  staff    19M  2  7 22:43 binarytea-0.0.1-SNAPSHOT.jar\n-rw-r--r--  1 digitalsonic  staff   8.3K  2  7 22:43 binarytea-0.0.1-SNAPSHOT.jar.original\ndrwxr-xr-x  5 digitalsonic  staff   160B  2  7 22:43 classes\ndrwxr-xr-x  3 digitalsonic  staff    96B  2  7 22:43 generated-sources\ndrwxr-xr-x  3 digitalsonic  staff    96B  2  7 22:43 maven-archiver\ndrwxr-xr-x  3 digitalsonic  staff    96B  2  7 22:43 maven-status</code></pre>\n<p>其中的 <code>binarytea-0.0.1-SNAPSHOT.jar.original</code> 是原始的 Jar 包，仅包含工程代码编译后的内容，大小只有 8.3KB；而 <code>binarytea-0.0.1-SNAPSHOT.jar</code> 则有 19MB，这就是生成的可执行 Jar 包。只需简单的一条命令就能将工程运行起来：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code>▸ java -jar target/binarytea-0.0.1-SNAPSHOT.jar</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>可执行 Jar 背后的原理</strong></p>\n<p><code>binarytea-0.0.1-SNAPSHOT.jar</code> 相比 <code>binarytea-0.0.1-SNAPSHOT.jar.original</code> 而言，简直就是一个庞然大物，通过 <code>unzip</code> 命令查看 Jar 包内容，我们可以看到它基本由以下几部分组成：</p>\n<ul>\n<li><strong><code>META-INF</code></strong>，工程的元数据，例如 Maven 的描述文件与 <code>spring.factories</code> 文件；</li>\n<li><strong><code>org/springframework/boot/loader</code></strong>，Spring Boot 用来引导工程启动的 Loader 相关类；</li>\n<li><strong><code>BOOT-INF/classes</code></strong>，工程自身的类与资源文件；</li>\n<li><strong><code>BOOT-INF/lib</code></strong>，工程所依赖的各种其他 Jar 文件。</li>\n</ul>\n<p>大概就像下面这样：</p>\n<pre>\n▸ unzip -l binarytea-0.0.1-SNAPSHOT.jar\nArchive:  binarytea-0.0.1-SNAPSHOT.jar\n  Length      Date    Time    Name\n&#45;--------  ---------- -----   ----\n        0  02-07-2022 22:43   META-INF/\n      472  02-07-2022 22:43   META-INF/MANIFEST.MF\n      103  02-07-2022 22:43   META-INF/spring.factories\n# 省略大量META-INF/下的文件\n        0  02-01-1980 00:00   org/\n        0  02-01-1980 00:00   org/springframework/\n        0  02-01-1980 00:00   org/springframework/boot/\n        0  02-01-1980 00:00   org/springframework/boot/loader/\n     5871  02-01-1980 00:00   org/springframework/boot/loader/ClassPathIndexFile.class\n# 省略大量org/下的文件\n        0  02-07-2022 22:43   BOOT-INF/\n        0  02-07-2022 22:43   BOOT-INF/classes/\n\n      242  02-07-2022 22:43   BOOT-INF/classes/application.properties\n        0  02-07-2022 22:43   BOOT-INF/classes/learning/\n        0  02-07-2022 22:43   BOOT-INF/classes/learning/spring/\n# 省略大量BOOT-INF/classes/下的文件\n        0  02-07-2022 22:43   BOOT-INF/lib/\n  1423985  01-20-2022 14:03   BOOT-INF/lib/spring-boot-2.6.3.jar\n  1627754  01-20-2022 14:02   BOOT-INF/lib/spring-boot-autoconfigure-2.6.3.jar\n# 省略大量BOOT-INF/lib/下的文件\n&#45;--------                     -------\n 19930105                     141 files\n</pre>\n\n<p>运行这个 Jar 所需要的信息都记录在了 <code>META-INF/MANIFEST.MF</code> 中，具体内容如下所示：</p>\n<pre class=\"code-rows\"><code>Manifest-Version: 1.0\nCreated-By: Maven JAR Plugin 3.2.2\nBuild-Jdk-Spec: 11\nImplementation-Title: BinaryTea\nImplementation-Version: 0.0.1-SNAPSHOT\nMain-Class: org.springframework.boot.loader.JarLauncher\nStart-Class: learning.spring.binarytea.BinaryTeaApplication\nSpring-Boot-Version: 2.6.3\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nSpring-Boot-Classpath-Index: BOOT-INF/classpath.idx\nSpring-Boot-Layers-Index: BOOT-INF/layers.idx</code></pre>\n<p><code>java</code> 命令会找到 <code>Main-Class</code> 作为启动类，Spring Boot 提供了三种不同的 <code>Launcher</code>，可以从内嵌文件中加载启动所需的资源：</p>\n<ul>\n<li><strong><code>JarLauncher</code></strong>，从 Jar 包的固定位置加载内嵌资源，即 <code>BOOT-INF/lib/</code>；</li>\n<li><strong><code>WarLauncher</code></strong>，从 War 包的固定位置加载内嵌资源，分别为 <code>WEB-INF/lib/</code> 和 <code>WEB-INF/lib-provided/</code>；</li>\n<li><strong><code>PropertiesLauncher</code></strong><span class=\"comment-number\">17</span>，默认从 <code>BOOT-INF/lib/</code> 加载资源，但可以通过环境变量来指定额外的位置。</li>\n</ul>\n<p>默认生成的工程会使用 <code>JarLauncher</code> 生成可执行 Jar 包，而启动后执行的具体代码则由 <code>StartClass</code> 指定，我们可以看到这个类就是添加了 <code>@SpringBootApplication</code> 注解的类。</p>\n<p>用这种方式打包有两个<strong>局限</strong>。</p>\n<ul>\n<li>Jar 文件其实就是一个 ZIP 文件，ZIP 文件可以设置压缩力度，从仅存储（不压缩）到最大化压缩，在内嵌 Jar 的情况下，我们只能使用 <code>ZipEntry.STORED</code>，即仅存储，不压缩的方式。</li>\n<li>要获取 <code>ClassLoader</code> 时必须使用 <code>Thread.getContextClassLoader()</code>，而不能使用 <code>ClassLoader.getSystemClassLoader()</code>。</li>\n</ul>\n<p>Spring Boot 中还有一种更激进的方式，生成可以直接在 Linux 中运行的 Jar 文件，不再需要 <code>java -jar</code> 命令（当然，这个文件中不包含 JRE），具体修改 <code>spring-boot-maven-plugin</code> 配置的方式如下：</p>\n<pre class=\"code-rows\"><code>&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;configuration&gt;\n                &lt;executable&gt;true&lt;/executable&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;</code></pre>\n<p>这样通过 <code>mvn package</code> 打出的 Jar 包会更特殊一些，用文本编辑器或者 <code>less</code> 命令查看这个文件，我们会发现这个文件的头部其实是个 Shell 脚本，后面才是压缩的 Jar 包内容。这背后的“魔法”正是<strong>利用了 Shell 脚本是从前往后解析，而 Jar 文件则是从后往前解析的特性</strong>。</p>\n<p>现在要运行这个文件只需简单的 <code>./target/binarytea-0.0.1-SNAPSHOT.jar</code> 就可以了。对应的一些类似 JVM 参数和运行的参数，可以放在同名的 <code>.conf</code> 配置文件中，一些基本的执行配置项见表 5-12。</p>\n<p><strong>表 5-12　一些基本的执行配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>说明</th></tr><tr><td>`CONF_FOLDER`</td><td>`.conf` 文件的目录位置，因为要靠它加载配置文件，所以这个参数必须放在环境变量里</td></tr><tr><td>`JAVA_OPTS`</td><td>启动 Java 程序使用的 JVM 参数，比如 JVM 内存和 GC 相关的参数</td></tr><tr><td>`RUN_ARGS`</td><td>运行程序所需提供的运行时参数</td></tr></table>\n\n<p>这样一来就可以把这个 Jar 文件放在 init.d 或 systemd 里运行了，但不得不说，相比 <code>java -jar</code>，这种用法还是很少见的。此外，更新的技术出现了，不仅能代替这种方式，而且还带来了更好的体验，这就是 GraalVM<span class=\"comment-number\">18</span>。GraalVM 能把 Java 程序编译为 Linux 二进制，系统启动速度更快，所占内存更小。</p>\n</li>\n</ol>\n\n\n\n<h3 id=\"nav_point_86\">5.3.2　构建启动代码</h3>\n<p>在之前的例子中我们已经多次看到过带有 <code>@SpringBootApplication</code> 注解的主类，其中用 <code>SpringApplication.run()</code> 方法来运行我们的代码。Spring Boot 为我们预留了很多自定义工程启动的扩展点，比如可以设置启动的各种参数，能针对失败进行各种处理、还能定制自己的 Banner 栏等。</p>\n<ol>\n<li><p><strong>自定义 SpringApplication</strong></p>\n<p>通过 Spring Initializr 生成的工程，其中的 <code>main()</code> 方法应该是下面这样的，它可以满足绝大部分的需求：</p>\n<pre class=\"code-rows\"><code>public static void main(String[] args) {\n    SpringApplication.run(BinaryTeaApplication.class, args);\n}</code></pre>\n<p>我们也完全可以自己新建一个 <code>SpringApplication</code> 对象，设置各种属性，例如 <code>bannerMode</code> 和 <code>lazyInitialization</code> 等，随后再调用它的 <code>run()</code> 方法。</p>\n<p>当然，这样的操作略显繁琐，Spring Boot 贴心地提供了一个 <code>SpringApplicationBuilder</code> 构造器，通过它我们可以流畅地编写类似代码示例 5-10 这样的代码。<span class=\"comment-number\">19</span></p>\n<blockquote>\n<p><strong>代码示例 5-10</strong>　通过 <code>SpringApplicationBuilder</code> 启动应用程序</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public static void main(String[] args) {\n    new SpringApplicationBuilder()\n        .sources(BinaryTeaApplication.class)\n        .main(BinaryTeaApplication.class)\n        .bannerMode(Banner.Mode.OFF)\n        .web(WebApplicationType.SERVLET)\n        .run(args);\n}</code></pre>\n<p>上面的一些设置代码，也可以改用配置文件的方式，在 <code>application.properties</code> 或 <code>application.yml</code> 里进行设置，例如在 <code>application.properties</code> 里可以像下面这样来关闭 Web 容器和 Banner 栏：</p>\n<pre class=\"code-rows\"><code>spring.main.web-application-type=none\nspring.main.banner-mode=off</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>通过 FailureAnalyzer 提供失败原因分析</strong></p>\n<p>程序启动时，如果遇到异常就会退出，这时需要查看日志，分析原因，那有没有可能让系统自己分析原因，然后告诉我们为什么失败了呢？答案是肯定的，因为 Spring Boot 可以通过 <code>FailureAnalyzer</code> 来分析失败，并打印分析出的原因。表 5-13 罗列了一些内置的 <code>FailureAnalyzer</code> 实现类，Spring Boot 内置了近 20 种不同的分析器，表 5-13 里展示的只是其中的一小部分。</p>\n<p><strong>表 5-13　Spring Boot 的部分内置 <code>FailureAnalyzer</code> 实现类</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>`FailureAnalyzer` 实现类</th><th>功能</th></tr><tr><td>`BindFailureAnalyzer`</td><td>提示属性绑定相关异常</td></tr><tr><td>`DataSourceBeanCreationFailureAnalyzer`</td><td>提示数据源创建相关异常</td></tr><tr><td>`InvalidConfigurationPropertyNameFailureAnalyzer`</td><td>提示配置属性名不正确</td></tr><tr><td>`NoSuchBeanDefinitionFailureAnalyzer`</td><td>提示 Spring 上下文中找不到需要的 Bean 定义</td></tr><tr><td>`NoUniqueBeanDefinitionFailureAnalyzer`</td><td>提示要注入一个 Bean，但实际却找到了不止一个</td></tr></table>\n\n<p>我们也可以根据实际情况，提供自己的 <code>FailureAnalyzer</code> 实现类。方便起见，Spring Boot 提供了一个 <code>AbstractFailureAnalyzer&lt;T extends Throwable&gt;</code> 抽象类，其中的泛型 <code>T</code> 就是要分析的异常，实现这个抽象类会更简单，框架内置的大部分实现都是基于这个抽象类来开发的。我们以 Spring Boot 的 <code>PortInUseFailureAnalyzer</code> 为例，看到传入待分析的异常是 <code>PortInUseException</code> 就能知道端口已经被占用了，从而直观地提示 Web 服务器端口已被占用：</p>\n<pre class=\"code-rows\"><code>class PortInUseFailureAnalyzer extends AbstractFailureAnalyzer&lt;PortInUseException&gt; {\n    @Override\n    protected FailureAnalysis analyze(Throwable rootFailure, PortInUseException cause) {\n        return new FailureAnalysis(\"Web server failed to start. Port \" + cause.getPort() + \" was already in use.\",\n               \"Identify and stop the process that's listening on port \" + cause.getPort() + \" or configure this \"\n               + \"application to listen on another port.\", cause);\n    }\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>自定义 Banner 栏</strong></p>\n<p>启动程序时，默认会打出 Spring 的字样，这是由 ASCII 字符组成的图案，看起来非常的酷炫。我们可以通过 <code>spring.main.banner-mode</code> 属性来控制 Banner 的输出方式：</p>\n<ul>\n<li><strong><code>Banner.Mode.OFF</code></strong>（属性值为 <code>off</code>），关闭输出；</li>\n<li><strong><code>Banner.Mode.CONSOLE</code></strong>（属性值为 <code>console</code>），输出到控制台，即标准输出 STDOUT；</li>\n<li><strong><code>Banner.Mode.LOG</code></strong>（属性值为 <code>log</code>），输出到日志。</li>\n</ul>\n<p>如果要自定义输出的内容，可以在 CLASSPATH 中放置一个 banner.txt<span class=\"comment-number\">20</span>，也可以通过 <code>spring.banner.location</code> 指定文件位置，文件中除了 ASCII 图案，还可以写一些占位符，例如，可以从 MANIFEST.MF 文件中获取一些信息：</p>\n<ul>\n<li><strong><code>$</code></strong>，对应 <code>Implementation-Title</code>；</li>\n<li><strong><code>$</code></strong>，对应 <code>Implementation-Version</code>；</li>\n<li><strong><code>$</code></strong>，同样对应 <code>Implementation-Version</code>，但会添加 <code>v</code> 前缀，再将版本放在括号内。</li>\n</ul>\n<p>当然，如果还希望做得更彻底，我们可以直接写一个自己的 <code>org.springframework.boot.Banner</code> 接口实现，在其中的 <code>printBanner()</code> 方法里打印 Banner。</p>\n<blockquote>\n<p><strong>茶歇时间：如何优雅地关闭系统</strong></p>\n<p>系统有启动，自然就会有关闭的时候。如果说异常宕机时损失一个实例对整个集群的服务造成部分影响还情有可原，那常规的系统升级发布就不应该对整体服务有任何影响。</p>\n<p>在我们打算关闭系统时，可能会遇到如下的情况（不仅限于此）：</p>\n<ul>\n<li class=\"第3级无序列表\"><strong>系统仍在接收同步请求</strong>，例如，在处理 HTTP 请求；</li>\n<li class=\"第3级无序列表\"><strong>系统仍在消费消息</strong>，例如，在消费 Kafka 消息；</li>\n<li class=\"第3级无序列表\"><strong>系统有定时任务在运行</strong>，可能是分布式调度，也可能是单机的调度任务。</li>\n</ul>\n<p>当系统处于处理中的状态时，直接关闭系统可能会影响当前的处理。</p>\n<p>为此，我们要针对性地做一些处理，例如，将当前节点从负载均衡中剔除，如果使用 Nginx 进行负载均衡，就调整 <code>upstream</code> 的配置；如果是动态发现的，就让健康检查失败（可以使用 5.1 节中提到的 <code>health</code> 端点），让服务注册中心将节点下线。（在第 13 章中我们还会聊到服务的注册中心。）</p>\n<p>消息的消费要力争做到可重复消费，因为消费本身就要考虑到消息的乱序和重发等情况。如果一条消息消费到一半，进程被杀掉了，那么消息中间件会认为该消息未被正常处理，会再重新发送。当然，我们也可以做些优化，在停止进程前，不再接收新消息，针对拉（PULL）模式的客户端，不再从服务端拉取新消息，推（PUSH）模式的则不再处理新消息，等待或拒绝也不失为一个好办法。</p>\n<p>对调度任务也是一样的，任务需要能够支持“重跑”，高频任务不必多说，低频任务万一被中断，需要有补偿机制，能够快速恢复。例如，分布式调度（诸如 ElasticJob 之类的调度）可以设置故障转移。</p>\n<p>Spring Boot 提供了优雅关闭的能力，通过 <code>server.shutdown=graceful</code> 这个配置可以开启 Web 服务器优雅关闭的支持，让系统在收到关闭信号时等待一段时间（通过 <code>spring.lifecycle.timeout-per-shutdown-phase</code> 设置），以便等待当前正在处理的请求处理结束。但通过前面的描述，我们不难发现，仅提供这些能力并不足以在生产环境中做到无损的节点下线，还有大量的工作需要我们自己来实现。</p>\n</blockquote>\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_87\">5.3.3　启动后的一次性执行逻辑</h3>\n<p>在系统启动时，可能会有些初始化后需要立即执行的逻辑，也有可能这就是一个命令行程序 <span class=\"comment-number\">21</span>，执行完特定逻辑后程序就该退出了。这时我们该怎么办？写一个 Bean，在它的 <code>@PostConstruct</code> 方法中执行逻辑么？其实，在 Spring Boot 中有更好的选择。</p>\n\n<p>Spring Boot 为我们提供了两个接口，分别是 <code>ApplicationRunner</code> 与 <code>CommandLineRunner</code>，它们的功能基本是相同的，只是方法的参数不同，具体如下所示：</p>\n<pre class=\"code-rows\"><code>public interface ApplicationRunner {\n    void run(ApplicationArguments args) throws Exception;\n}\n\npublic interface CommandLineRunner {\n    void run(String... args) throws Exception;\n}</code></pre>\n<p><code>CommandLineRunner</code> 的 <code>run(String... args)</code> 传入的参数与 <code>main(String... args)</code> 方法一样，就是命令行的所有参数。而通过 <code>ApplicationArguments</code>，我们可以更方便灵活地控制命令行中的参数。如果 Spring 上下文中存在多个 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> Bean，可以通过 <code>@Order</code> 注解或 <code>Ordered</code> 接口来指定运行的顺序。接下来，让我们看个例子。</p>\n<blockquote>\n<p><strong>需求描述</strong>　有奶茶店，自然就会有顾客，每次都让顾客跑到门店找服务员点单多少有些不方便，我们需要一个程序让顾客可以自己下单。所以，为顾客开发一个程序吧。</p>\n</blockquote>\n<p>为了方便演示，建立一个新的 Customer 工程，代表二进制奶茶店的顾客，放在 ch5/customer 项目中，其详细信息如表 5-14 所示。</p>\n<p><strong>表 5-14　Customer 工程的详细信息</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>条目</p></th>\n<th><p>内容</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>项目</p></td>\n<td><p>Maven Project</p></td>\n</tr>\n<tr>\n<td><p>语言</p></td>\n<td><p>Java</p></td>\n</tr>\n<tr>\n<td><p>Spring Boot 版本</p></td>\n<td><p>2.6.3</p></td>\n</tr>\n<tr>\n<td><p>Group</p></td>\n<td><p><code>learning.spring</code></p></td>\n</tr>\n<tr>\n<td><p>Artifact</p></td>\n<td><p><code>customer</code></p></td>\n</tr>\n<tr>\n<td><p>名称</p></td>\n<td><p>Customer</p></td>\n</tr>\n<tr>\n<td><p>Java 包名</p></td>\n<td><p><code>learning.spring.customer</code></p></td>\n</tr>\n<tr>\n<td><p>打包方式</p></td>\n<td><p>Jar</p></td>\n</tr>\n<tr>\n<td><p>Java 版本</p></td>\n<td><p>11</p></td>\n</tr>\n<tr>\n<td><p>依赖</p></td>\n<td><p>Lombok</p></td>\n</tr>\n</tbody>\n</table>\n<p>这个项目会模拟顾客的操作，目前我们的奶茶店还没开门营业，可以让顾客选择等待奶茶店开门，还是直接离开。</p>\n<p>代码示例 5-11<span class=\"comment-number\">22</span> 是一个 <code>CommandLineRunner</code> 的实现，它的作用是打印所有的命令行参数，其中的日志输出通过 Lombok 的 <code>@Slf4j</code> 指定了使用 SLF4J 日志框架，无须我们自己定义 <code>log</code> 成员变量。</p>\n\n<blockquote>\n<p><strong>代码示例 5-11</strong>　<code>ArgsPrinterRunner</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\n@Order(1)\npublic class ArgsPrinterRunner implements CommandLineRunner {\n    @Override\n    public void run(String... args) throws Exception {\n        log.info(\"共传入了{}个参数。分别是：{}\", args.length, StringUtils.arrayToCommaDelimitedString(args));\n    }\n}</code></pre>\n<p>代码示例 5-12 是一个 <code>ApplicationRunner</code> 的实现，它会根据命令行上传入的参数来决定是否等待，如果我们通过 <code>wait</code> 选项设置了等待时间，则等待时间即为程序里 <code>sleep</code> 对应的秒数，没有 <code>wait</code> 就直接结束。其中演示了几个方法：</p>\n<ul>\n<li><strong><code>containsOption()</code></strong>，是否包含指定选项（所谓选项，其形式是 <code>--</code> 选项名 <code>=</code> 值）；</li>\n<li><strong><code>getOptionValues()</code></strong>，获取指定选项的值，返回的是一个 <code>List</code>，因为可以多次设值，例如 <code>--wait=5--wait=6</code>；</li>\n<li><strong><code>getNonOptionArgs()</code></strong>，获取非选项类型的其他参数。</li>\n</ul>\n<blockquote>\n<p><strong>代码示例 5-12</strong>　<code>WaitForOpenRunner</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\n@Order(2)\npublic class WaitForOpenRunner implements ApplicationRunner {\n    @Override\n\n    public void run(ApplicationArguments args) throws Exception {\n        boolean needWait = args.containsOption(\"wait\");\n        if (!needWait) {\n            log.info(\"如果没开门，就不用等了。\");\n            return;\n        }\n        List&lt;String&gt; waitSeconds = args.getOptionValues(\"wait\");\n        if (!waitSeconds.isEmpty()) {\n            int seconds = NumberUtils.parseNumber(waitSeconds.get(0), Integer.class);\n            log.info(\"还没开门，先等{}秒。\", seconds);\n            Thread.sleep(seconds * 1000);\n        }\n\n        log.info(\"其他参数：{}\",StringUtils.collectionToCommaDelimitedString(args.getNonOptionArgs()));\n    }\n}</code></pre>\n<p>使用 <code>mvn clean package -Dmaven.test.skip</code> 命令打包后，通过如下命令启动程序：</p>\n<pre class=\"code-rows\"><code>▸ java -jar target/customer-0.0.1-SNAPSHOT.jar --wait=3 Hello</code></pre>\n<p>运行的结果应该与下面的输出类似：</p>\n<pre class=\"code-rows\"><code>INFO 85578 --- [main] l.spring.customer.CustomerApplication : Started CustomerApplication in 1.059\nseconds (JVM running for 1.482)\nINFO 85578 --- [main] l.spring.customer.ArgsPrinterRunner : 共传入了2个参数。分别是：--wait=3,Hello\nINFO 85578 --- [main] l.spring.customer.WaitForOpenRunner : 准备等待3秒。\nINFO 85578 --- [main] l.spring.customer.WaitForOpenRunner : 其他参数：Hello</code></pre>\n<p>程序退出时可以指定一个退出码，在 Linux 或 macOS 操作系统中，可以用 <code>echo $?</code> 命令看到上一条命令的退出码。通常，退出码 <code>0</code> 表示<strong>正常结束</strong>，其他的退出码都表示<strong>非正常结束</strong>。在 Shell 脚本中往往都会根据某条命令的退出码决定后续的动作。</p>\n<p>在 Java 里，可以调用 <code>System.exit()</code> 退出程序，这个方法能够传入需要返回的退出码。Spring Boot 为我们提供了 <code>ExitCodeGenerator</code> 接口，通过实现该接口我们可以加入自己的逻辑来控制退出码，如果存在多个 Bean，可以和前文一样用 <code>@Order</code> 注解或 <code>Ordered</code> 接口来控制顺序。调用 <code>SpringApplication.exit()</code> 方法即可获得最终计算出的退出码，把它传入 <code>System.exit()</code> 就可以了。</p>\n<p>作为经营者，我们当然是希望顾客来自己店里，而且如果顾客愿意等我们开门最好了，为此，我们编写一个自己的 <code>ExitCodeGenerator</code> 实现，命令行里提供了 <code>wait</code> 选项则视为正常，否则不正常，具体代码如代码示例 5-13 所示。</p>\n<blockquote>\n<p><strong>代码示例 5-13</strong>　直接在 <code>@Bean</code> 方法中实现 <code>ExitCodeGenerator</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\npublic class CustomerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(CustomerApplication.class, args);\n    }\n\n    /**\n     * 如果命令行里给了wait选项，返回0，否则返回1\n    */\n    @Bean\n    public ExitCodeGenerator waitExitCodeGenerator(ApplicationArguments args) {\n        return () -&gt; (args.containsOption(\"wait\") ? 0 : 1);\n    }\n}</code></pre>\n<p>框架会自动把上下文中的 ApplicationArguments 作为参数传入 waitExitCodeGenerator()，这里取到的值和我们在 ApplicationRunner 里取到的值是一样的。</p>\n<p>随后，简单调整一下 <code>WaitForOpenRunner</code>，在执行完日志输出后调用退出逻辑，如代码示例 5-14 所示。<code>SpringApplication.exit()</code> 需要传入 <code>ApplicationContext</code>，因此我们让 <code>WaitForOpenRunner</code> 实现 <code>ApplicationContextAware</code>，这里的 <code>Setter</code> 方法直接通过 Lombok 的 <code>@Setter</code> 来实现。</p>\n<blockquote>\n<p><strong>代码示例 5-14</strong>　调整后的 <code>WaitForOpenRunner</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\n@Order(2)\npublic class WaitForOpenRunner implements ApplicationRunner, ApplicationContextAware {\n    @Setter\n    private ApplicationContext applicationContext;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        boolean needWait = args.containsOption(\"wait\");\n        if (!needWait) {\n            log.info(\"如果没开门，就不用等了。\");\n        } else {\n            List&lt;String&gt; waitSeconds = args.getOptionValues(\"wait\");\n            if (!waitSeconds.isEmpty()) {\n                int seconds = NumberUtils.parseNumber(waitSeconds.get(0), Integer.class);\n                log.info(\"还没开门，先等{}秒。\", seconds);\n                Thread.sleep(seconds * 1000);\n            }\n\n            log.info(\"其他参数：{}\", StringUtils.collectionToCommaDelimitedString(args.getNonOptionArgs()));\n        }\n\n        System.exit(SpringApplication.exit(applicationContext));\n    }\n}</code></pre>\n<p>现在重新打包运行我们的程序，如果命令行里没有 <code>--wait</code>，退出码就是 <code>1</code>。</p>\n<blockquote>\n<p><strong>茶歇时间：通过 Lombok 简化代码</strong></p>\n<p>相信只要是写过 Java 的人都会写过 <code>Getter</code> 和 <code>Setter</code> 方法，虽然绝大多数人会选择让 IDE 来自动生成，但本着“懒惰是程序员的第一大美德”的理念，能不要这些代码，我们还是希望就不出现这些代码。与之类似的还有简单的用于成员变量赋值的构造方法、<code>Logger</code> 对象的定义语句等。</p>\n<p>Lombok<span class=\"comment-number\">23</span> 就是这样一个解放生产力的利器，它通过一系列注解消灭了上述冗长繁琐的语句。常用的一些注解如表 5-15 所示。</p>\n<p><strong>表 5-15　常用的 Lombok 注解</strong></p>\n</blockquote>\n\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>注解</p></th>\n<th><p>作用</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>@Getter / @Setter</code></p></td>\n<td><p>自动生成成员属性的 <code>Getter</code> 和 <code>Setter</code> 方法</p></td>\n</tr>\n<tr>\n<td><p><code>@ToString</code></p></td>\n<td><p>自动生成 <code>toString()</code> 方法，默认拼接所有的成员属性，也可以排除指定的属性</p></td>\n</tr>\n<tr>\n<td><p><code>@NoArgsConstructor</code> / <code>@RequiredArgsConstructor</code> / <code>@AllArgsConstructor</code></p></td>\n<td><p>自动生成无参数的构造方法，必要参数的构造方法以及包含全部参数的构造方法</p></td>\n</tr>\n<tr>\n<td><p><code>@EqualsAndHashCode</code></p></td>\n<td><p>自动生成 <code>equals()</code> 与 <code>hashCode()</code> 方法</p></td>\n</tr>\n<tr>\n<td><p><code>@Data</code></p></td>\n<td><p>相当于添加了 <code>@ToString</code>、<code>@EqualsAndHashCode</code>、<code>@Getter</code>、<code>@Setter</code> 和 <code>@RequiredArgsConstructor</code> 注解</p></td>\n</tr>\n<tr>\n<td><p><code>@Builder</code></p></td>\n<td><p>提供了一个灵活的构造器，能够设置各个成员变量，再据此创建对象实例</p></td>\n</tr>\n<tr>\n<td><p><code>@Slf4j</code> / <code>@CommonsLog</code> / <code>@Log4j2</code></p></td>\n<td><p>自动生成对应日志框架的日志类，例如定义了一个 <code>Logger</code> 类型的 <code>log</code>，方便输出日志</p></td>\n</tr>\n</tbody>\n</table>\n<p>需要注意的是，虽然编译时没有什么特殊设置，但在 IDE 中，为了开启对 Lombok 的支持，我们需要安装对应 IDE 的 Lombok 插件，例如，IDEA 中要安装 IntelliJ Lombok plugin。</p>\n<h2 id=\"nav_point_88\">5.4　小结</h2>\n<p>本章我们学习了 Spring Boot 提供的面向生产环境的诸多功能，例如，Spring Boot Actuator 的各种端点，如何自己定制健康检查信息。还学习了生产环境中所必不可少的度量方法，通过 Micrometer 输出各种内容，帮助我们了解系统的运行情况。最后，把开发好的代码打包成了实际可以部署的 Jar 包，Spring Boot 的 Jar 包可以直接执行，我们对这背后的原理也做了说明。除此之外，还聊了聊怎么编写用来启动整个工程的 <code>SpringAppliation</code> 代码，控制整个启动和运行的逻辑。</p>\n<p>在代码示例中，我们第一次引入了 Lombok，它可以在很大程度上简化我们的代码，在日常工作中也强烈建议大家使用。</p>\n<p>全书的第一部分到此就告一段落了，我们学习了 Spring Framework 与 Spring Boot 的一些基础知识和用法，从下一章开始，我们将进入新的环节，编写与数据库交互的系统。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发进度</strong></p>\n<p>本章我们为二进制奶茶店的程序增加了一些面向生产环境的功能：</p>\n<ul>\n<li>添加了可在运行时了解营业情况的健康检查项和端点；</li>\n<li>添加了可获得累计营收情况的监控项。</li>\n</ul>\n<p>此外，我们还初始化了代表顾客的 Customer 工程，它目前可以接受一些命令行参数，判断是否等待店铺开门。</p>\n</blockquote>\n\n<br style=\"page-break-after:always\" />","comments":[]}