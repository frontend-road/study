{"id":803251,"title":"06｜SQL Mode对程序有怎样的影响？","content":"<p>你好，我是俊达。</p><p>SQL Mode是MySQL中比较特殊的一个概念，可以通过参数sql_mode进行设置。设置SQL Mode会影响数据库对SQL的语法支持，也会影响数据写入时的校验规则。早期的MySQL使用非严格模式，这样有一些不符合SQL标准的语句在MySQL中也能执行，一些按SQL标准来说不合法的数据，也能写到表里面。</p><p>不过从MySQL 5.7开始，默认就开启了严格模式。这一讲中，我们一起来看看SQL Mode是怎么影响到SQL语句的，以及应该怎么设置SQL Mode。</p><h2>非严格模式</h2><p>非严格模式下，MySQL会允许你执行一些不符合SQL标准的语句。我们通过一些例子来说明这种情况。先创建一个测试表，写入一些数据。</p><pre><code class=\"language-go\">mysql&gt; create table tab2(\n    b int, \n    c varchar(10), \n    d varchar(30)\n) engine=innodb;\n\nQuery OK, 0 rows affected (10.16 sec)\n\nmysql&gt; insert into tab2 values\n    (10, 'AAA1', 'BBB1'),\n    (20, 'AAA4', 'BBB4'), \n    (10, 'AAA3', 'BBB3'), \n    (20, 'AAA2', 'BBB2')\n\nQuery OK, 4 rows affected (0.56 sec)\nRecords: 4  Duplicates: 0  Warnings: 0\n\nmysql&gt; select * from tab2;\n+------+------+------+\n| b    | c    | d    |\n+------+------+------+\n|   10 | AAA1 | BBB1 |\n|   20 | AAA4 | BBB4 |\n|   10 | AAA3 | BBB3 |\n|   20 | AAA2 | BBB2 |\n+------+------+------+\n4 rows in set (0.00 sec)\n</code></pre><!-- [[[read_end]]] --><p>执行下面这个带了GROUP BY的语句时，你会发现执行会报错。因为按SQL标准语法，如果SQL带了GROUP BY，那么SELECT列表中的字段，要么也出现在GROUP BY的字段列表中，要么就加上聚合函数，比如avg、max、min等。</p><pre><code class=\"language-go\">mysql&gt; select b,c,d from tab2 group by b;\nERROR 1055 (42000): Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'src_db.tab2.c' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by\n</code></pre><p>但是在MySQL中，如果你把SQL Mode中的only_full_group_by选项去掉，就可以正常执行上面这个SQL。从输出结果看，字段C和D的取值跟数据写入的顺序有关。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select b, c, d from tab2 group by b;\n+------+------+------+\n| b    | c    | d    |\n+------+------+------+\n|   10 | AAA1 | BBB1 |\n|   20 | AAA4 | BBB4 |\n+------+------+------+\n</code></pre><p>严格模式下，下面这两个SQL都会报错。第一个SQL是因为往int类型的字段中写入了非数字的字符，第二个SQL是因为写入的字符串长度超过了字段定义时允许的范围。</p><pre><code class=\"language-go\">mysql&gt; insert into tab3(b,c,d) values('a', 'a', 'a');\nERROR 1366 (HY000): Incorrect integer value: 'a' for column 'b' at row 1\n\nmysql&gt; insert into tab3(b,c) values('100', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');\nERROR 1406 (22001): Data too long for column 'c' at row 1\n</code></pre><p>但是在非严格模式下，这两个SQL都能执行，虽然执行时会有Warning。</p><pre><code class=\"language-go\">mysql&gt; delete from tab3;\nQuery OK, 4 rows affected (0.54 sec)\n\nmysql&gt; set sql_mode='';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into tab3 values('a', 'a', 'a');\nQuery OK, 1 row affected, 1 warning (0.45 sec)\n\nmysql&gt; show warnings;\n+---------+------+------------------------------------------------------+\n| Level   | Code | Message                                              |\n+---------+------+------------------------------------------------------+\n| Warning | 1366 | Incorrect integer value: 'a' for column 'b' at row 1 |\n+---------+------+------------------------------------------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; insert into tab3(b,c) values('100', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');\nQuery OK, 1 row affected, 1 warning (0.70 sec)\n\nmysql&gt; show warnings;\n+---------+------+----------------------------------------+\n| Level   | Code | Message                                |\n+---------+------+----------------------------------------+\n| Warning | 1265 | Data truncated for column 'c' at row 1 |\n+---------+------+----------------------------------------+\n1 row in set (0.00 sec)\n</code></pre><p>我们再来查看数据，第一个SQL插入的数据，非法的整数值被替换成了0。第二个SQL插入的数据，超出长度的字符串被截去了，留下了一个前缀。</p><pre><code class=\"language-go\">mysql&gt; select * from tab3;\n+------+------------+------+\n| b    | c          | d    |\n+------+------------+------+\n|    0 | a          | a    |\n|  100 | ABCDEFGHIJ | NULL |\n+------+------------+------+\n2 rows in set (0.01 sec)\n</code></pre><p>在MySQL 5.6和更早版本中，默认使用非严格模式，上面这样的SQL都可以正常执行。如果你的应用中存在这些情况，然后由于某种原因SQL Mode切换成了严格模式，那么原先正常的应用程序，就可能无法正常运行了。</p><h2>SQL Mode的各种选项</h2><p>SQL Mode有很多选项，MySQL 8.0中，sql_mode的默认设置可以通过下面这个方法获取。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode=default;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; show variables like 'sql_mode'\\G\n*************************** 1. row ***************************\nVariable_name: sql_mode\n        Value: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION\n1 row in set (0.01 sec)\n</code></pre><p>这些选项中，ONLY_FULL_GROUP_BY和STRICT_TRANS_TABLES我们已经遇到过了。此外，还有一些选项不在这个默认的设置中，后面我们也会分别进行介绍。</p><h3>ONLY_FULL_GROUP_BY</h3><p>前面的例子已经演示过ONLY_FULL_GROUP_BY的效果了。设置ONLY_FULL_GROUP_BY后，对有GROUP BY的SQL，SELECT的字段要么也出现GROUP BY中，要么使用聚合函数，否则SQL执行会报错。</p><p>我们可以对SQL进行改写，在GROUP BY之外的那些字段上使用ANY_VALUE函数，这样SQL就可以正常执行了。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='ONLY_FULL_GROUP_BY';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select b,c,d from tab2 group by b;\nERROR 1055 (42000): Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'src_db.tab2.c' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by\n\nmysql&gt; select b, any_value(c) as c, any_value(d) as d from tab2 group by b;\n+------+------+------+\n| b    | c    | d    |\n+------+------+------+\n|   10 | AAA1 | BBB1 |\n|   20 | AAA4 | BBB4 |\n+------+------+------+\n2 rows in set (0.00 sec)\n</code></pre><h3>STRICT_TRANS_TABLES</h3><p>设置STRICT_TRANS_TABLES后，在数据写入时，如果数据不符合字段定义，比如字符串超出长度，或者数值类型数据超出范围时，SQL会报错。如果不设置STRICT模式，会对异常数据进行截断处理，SQL会显示Warning，但不报错。</p><pre><code class=\"language-go\">mysql&gt; create table t_strict(a tinyint, b tinyint unsigned, c decimal(6,2), d varchar(10));\nQuery OK, 0 rows affected (6.36 sec)\n\nmysql&gt; set sql_mode='strict_trans_tables';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; insert into t_strict(a) values(512);\nERROR 1264 (22003): Out of range value for column 'a' at row 1\n\nmysql&gt; insert into t_strict(b) values(512);\nERROR 1264 (22003): Out of range value for column 'b' at row 1\n\nmysql&gt; insert into t_strict(c) values(1000000);\nERROR 1264 (22003): Out of range value for column 'c' at row 1\n\nmysql&gt; insert into t_strict(d) values('0123456789ABCDEF');\nERROR 1406 (22001): Data too long for column 'd' at row 1\n</code></pre><p>去掉STRICT_TRANS_TABLES后，虽然能写入数据，但是数据被截断了，和应用本来想写入的数据有很大的差异。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into t_strict(a,b,c,d) values(512, 512, 1000000, '0123456789ABCDEF');\nQuery OK, 1 row affected, 4 warnings (0.04 sec)\n\n\nmysql&gt; select * from t_strict;\n+------+------+---------+------------+\n| a    | b    | c       | d          |\n+------+------+---------+------------+\n|  127 |  255 | 9999.99 | 0123456789 |\n+------+------+---------+------------+\n1 row in set (0.00 sec)\n</code></pre><p>对不支持事务的存储引擎，比如MyISAM，STRICT_TRANS_TABLES的作用就比较复杂了。如果使用了批量INSERT，也就是同时INSERT了多行记录，那么当第一行记录中有数据和字段定义不符合时，SQL会报错，如果第一行数据没问题，但是后续的记录有问题，那么SQL能执行成功，但是会对超出范围的数据进行截断处理。下面这个例子中的第二个INSERT语句，插入了两行记录，第二行记录的数据被截断了。</p><pre><code class=\"language-go\">mysql&gt; create table t_strict_myisam(a tinyint, b tinyint unsigned, c decimal(6,2), d varchar(10)) engine=myisam;\nQuery OK, 0 rows affected (0.19 sec)\n\nmysql&gt; set sql_mode='strict_trans_tables';\nQuery OK, 0 rows affected, 1 warning (0.01 sec)\n\nmysql&gt; insert into t_strict_myisam values(512, 512, 1000000, '0123456789ABCDEF');\nERROR 1264 (22003): Out of range value for column 'a' at row 1\n\nmysql&gt; insert into t_strict_myisam values(100, 200, 9999, '0123456789'), (512, 512, 1000000, '0123456789ABCDEF');\nQuery OK, 2 rows affected, 4 warnings (0.01 sec)\nRecords: 2  Duplicates: 0  Warnings: 4\n\nmysql&gt; select * from t_strict_myisam;\n+------+------+---------+------------+\n| a    | b    | c       | d          |\n+------+------+---------+------------+\n|  100 |  200 | 9999.00 | 0123456789 |\n|  127 |  255 | 9999.99 | 0123456789 |\n+------+------+---------+------------+\n2 rows in set (0.00 sec)\n</code></pre><h3>STRICT_ALL_TABLES</h3><p>STRICT_ALL_TABLES对所有存储引擎都生效。对于MyISAM这类不支持事务的存储引擎，使用批量INSERT时，如果SQL中存在超出范围的值，SQL执行就会报错，但是对于已经写入的数据，无法回滚。下面这个例子就演示了这种情况。</p><p>例子中INSERT语句的第一行数据是合法的，第二行数据超出了范围，SQL执行时，第一行数据写入成功，第二行数据无法写入，因此SQL就报错了，第三行数据虽然没问题，但是也不会再写入了。虽然SQL失败了，但是第一行数据已经写入了，而MyISAM不支持事务，无法回滚这一行记录。</p><pre><code class=\"language-go\">mysql&gt; create table t_strict_all(a tinyint, b tinyint unsigned, c decimal(6,2), d varchar(10)) engine=myisam;\nQuery OK, 0 rows affected (0.40 sec)\n\n\nmysql&gt; set  sql_mode='strict_all_tables';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\n\nmysql&gt; insert into t_strict_all values(100, 200, 9999, '0123456789'), (512, 512, 1000000, '0123456789ABCDEF'), (10, 20, 1000, 'ABCD');\nERROR 1264 (22003): Out of range value for column 'a' at row 2\n\n\nmysql&gt; select * from t_strict_all;\n+------+------+---------+------------+\n| a    | b    | c       | d          |\n+------+------+---------+------------+\n|  100 |  200 | 9999.00 | 0123456789 |\n+------+------+---------+------------+\n</code></pre><h3>NO_ZERO_DATE和NO_ZERO_IN_DATE</h3><p>设置STRICT_TRANS_TABLES和STRICT_ALL_TABLES后，表中无法写入非法的日期值。</p><pre><code class=\"language-go\">mysql&gt; create table t_date(a date, b datetime, c timestamp);\nQuery OK, 0 rows affected (5.47 sec)\n\nmysql&gt; set sql_mode='strict_trans_tables';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; insert into t_date(a) values('2024-02-30');\nERROR 1292 (22007): Incorrect date value: '2024-02-30' for column 'a' at row 1\n\nmysql&gt; insert into t_date(b) values('2024-02-30 01:23:45');\nERROR 1292 (22007): Incorrect datetime value: '2024-02-30 01:23:45' for column 'b' at row 1\n\nmysql&gt; insert into t_date(c) values('2024-02-30 01:23:45');\nERROR 1292 (22007): Incorrect datetime value: '2024-02-30 01:23:45' for column 'c' at row 1\n</code></pre><p>但是却可以往date和datetime类型的字段中写入日期为0或年月日中存在0的数据。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into t_date values('0000-00-00', '0000-01-00 01:23:45', '1970-01-02 01:23:45');\nQuery OK, 1 row affected (0.98 sec)\n\n\nmysql&gt; select * from t_date;\n+------------+---------------------+---------------------+\n| a          | b                   | c                   |\n+------------+---------------------+---------------------+\n| 0000-00-00 | 0000-01-00 01:23:45 | 1970-01-02 01:23:45 |\n+------------+---------------------+---------------------+\n</code></pre><p>如果要阻止往数据库中写入年月日为0的数据，就需要设置NO_ZERO_DATE和NO_ZERO_IN_DATE。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='no_zero_date,no_zero_in_date,strict_trans_tables';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; insert into t_date(a) values('0000-00-00');\nERROR 1292 (22007): Incorrect date value: '0000-00-00' for column 'a' at row 1\n\nmysql&gt; insert into t_date(a) values('0000-01-00');\nERROR 1292 (22007): Incorrect date value: '0000-01-00' for column 'a' at row 1\n\nmysql&gt; insert into t_date(b) values('0001-00-00 01:23:45');\nERROR 1292 (22007): Incorrect datetime value: '0001-00-00 01:23:45' for column 'b' at row 1\n</code></pre><p>需要注意的是，NO_ZERO_DATE和NO_ZERO_IN_DATE需要跟STRICT_TRANS_TABLES一起设置，如果只是设置了NO_ZERO_DATE和NO_ZERO_IN_DATE，还是能往数据库中写入日期为0或年月日中有0的数据。</p><pre><code class=\"language-go\">mysql&gt; delete from t_date;\nQuery OK, 1 row affected (0.85 sec)\n\nmysql&gt; set sql_mode='no_zero_date,no_zero_in_date';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; insert into t_date(a,b,c) values('0000-00-00', '0000-01-00 01:23:45', '1970-01-02 01:23:45');\nQuery OK, 1 row affected, 2 warnings (0.83 sec)\n\nmysql&gt; show warnings;\n+---------+------+--------------------------------------------+\n| Level   | Code | Message                                    |\n+---------+------+--------------------------------------------+\n| Warning | 1264 | Out of range value for column 'a' at row 1 |\n| Warning | 1264 | Out of range value for column 'b' at row 1 |\n+---------+------+--------------------------------------------+\n2 rows in set (0.00 sec)\n\nmysql&gt; select * from t_date;\n+------------+---------------------+---------------------+\n| a          | b                   | c                   |\n+------------+---------------------+---------------------+\n| 0000-00-00 | 0000-00-00 00:00:00 | 1970-01-02 01:23:45 |\n+------------+---------------------+---------------------+\n1 row in set (0.00 sec)\n</code></pre><h3>ALLOW_INVALID_DATES</h3><p>MySQL中默认无法写入不合法的日期。不开启严格模式时，非法的日期值都会被转换成0000-00-00。</p><pre><code class=\"language-go\">mysql&gt; create table t_date2(a date, b datetime, c timestamp);\nQuery OK, 0 rows affected (5.15 sec)\n\nmysql&gt; set sql_mode='';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into t_date2 values('2024-02-30', '2024-02-30 01:23:45', '2024-02-30 01:23:45');\nQuery OK, 1 row affected, 3 warnings (0.26 sec)\n\nmysql&gt; select * from t_date2;\n+------------+---------------------+---------------------+\n| a          | b                   | c                   |\n+------------+---------------------+---------------------+\n| 0000-00-00 | 0000-00-00 00:00:00 | 0000-00-00 00:00:00 |\n+------------+---------------------+---------------------+\n</code></pre><p>但如果设置了ALLOW_INVALID_DATES这个SQL Mode，就可以在date和datetime类型中写入不存在的日期值了。注意，即使设置了ALLOW_INVALID_DATES，timestamp类型的字段中还是无法写入这些日期值。</p><pre><code class=\"language-go\">mysql&gt; insert into t_date2 values('2024-02-30', '2024-02-30 01:23:45', '2024-02-30 01:23:45');\nQuery OK, 1 row affected, 1 warning (1.53 sec)\n\nmysql&gt; show warnings;\n+---------+------+--------------------------------------------+\n| Level   | Code | Message                                    |\n+---------+------+--------------------------------------------+\n| Warning | 1264 | Out of range value for column 'c' at row 1 |\n+---------+------+--------------------------------------------+\n\nmysql&gt; select * from t_date2;\n+------------+---------------------+---------------------+\n| a          | b                   | c                   |\n+------------+---------------------+---------------------+\n| 2024-02-30 | 2024-02-30 01:23:45 | 0000-00-00 00:00:00 |\n+------------+---------------------+---------------------+\n</code></pre><h3>ERROR_FOR_DIVISION_BY_ZERO</h3><p>我们知道，从数学的意义上看，除数不能为0。在MySQL中，如果除数为0，会出现什么结果呢？这其实和SQL Mode有关系。如果SQL Mode中同时设置了ERROR_FOR_DIVISION_BY_ZERO和STRICT_TRANS_TABLES，那么当除数为0时，SQL会报错。否则除数为0时，结果为NULL。</p><pre><code class=\"language-go\">mysql&gt; create table t_n(a int);\nQuery OK, 0 rows affected (4.25 sec)\n\n\nmysql&gt; set sql_mode='strict_trans_tables';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; insert into t_n values(1/0);\nQuery OK, 1 row affected (2.10 sec)\n\nmysql&gt; set sql_mode='ERROR_FOR_DIVISION_BY_ZERO';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; insert into t_n values(1/0);\nQuery OK, 1 row affected, 1 warning (0.83 sec)\n\nmysql&gt; show warnings;\n+---------+------+---------------+\n| Level   | Code | Message       |\n+---------+------+---------------+\n| Warning | 1365 | Division by 0 |\n+---------+------+---------------+\n\nmysql&gt; select * from t_n;\n+------+\n| a    |\n+------+\n| NULL |\n| NULL |\n+------+\n2 rows in set (0.01 sec)\n</code></pre><p>同时设置ERROR_FOR_DIVISION_BY_ZERO和STRICT_TRANS_TABLES后，如果除数为0，SQL会报错。</p><pre><code class=\"language-go\">mysql&gt;  set sql_mode='ERROR_FOR_DIVISION_BY_ZERO,strict_trans_tables';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; insert into t_n values(1/0);\nERROR 1365 (22012): Division by 0\n</code></pre><h3>NO_BACKSLASH_ESCAPES</h3><p>在MySQL中，反斜杠“\\”是一个转义符，有特殊的含义。下面这个例子中，本来我们想写入一个Windows下的文件路径，但是查询数据时，发现路径分隔符“\\”不见了。</p><pre><code class=\"language-go\">mysql&gt; create table t_char(a varchar(100));\nQuery OK, 0 rows affected (3.23 sec)\n\nmysql&gt; set sql_mode=default;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into t_char values('C:\\Downloads\\File');\nQuery OK, 1 row affected (0.80 sec)\n\nmysql&gt; select * from t_char;\n+-----------------+\n| a               |\n+-----------------+\n| C:DownloadsFile |\n+-----------------+\n1 row in set (0.00 sec)\n</code></pre><p>这是因为在MySQL中“\\”是一个转义符，如果你想写入“\\”这个符号，需要对它进行转义。</p><pre><code class=\"language-go\">mysql&gt; delete from t_char;\nQuery OK, 1 row affected (1.50 sec)\n\nmysql&gt; insert into t_char values('C:\\\\Downloads\\\\File');\nQuery OK, 1 row affected (0.89 sec)\n\nmysql&gt; select * from t_char;\n+-------------------+\n| a                 |\n+-------------------+\n| C:\\Downloads\\File |\n+-------------------+\n1 row in set (0.00 sec)\n</code></pre><p>但是在别的数据库中，符号“\\”可能没有任何特殊含义。如果你需要将数据从别的数据库迁移到MySQL中，需要对数据进行转换。</p><p>其实MySQL中可以通过SQL Mode来进行控制，设置NO_BACKSLASH_ESCAPES选项后，反斜杠“\\”就变成一个普通的字符了，没有特殊含义。所以如果你需要从别的数据库迁移到MySQL，设置NO_BACKSLASH_ESCAPES可能会帮你减少一些麻烦。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='NO_BACKSLASH_ESCAPES';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; delete from t_char;\nQuery OK, 1 row affected (0.32 sec)\n\nmysql&gt;  insert into t_char values('C:\\Downloads\\File');\nQuery OK, 1 row affected (1.18 sec)\n\nmysql&gt; select * from t_char;\n+-------------------+\n| a                 |\n+-------------------+\n| C:\\Downloads\\File |\n+-------------------+\n1 row in set (0.00 sec)\n</code></pre><h3>ANSI_QUOTES</h3><p>在MySQL中，字符串常量可以使用单引号或双引号来引用。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode=default;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into t_quote values(\"Let's go\");\nQuery OK, 1 row affected (1.41 sec)\n\nmysql&gt; insert into t_quote values('String s = \"Helloworld\"');\nQuery OK, 1 row affected (1.79 sec)\n\nmysql&gt; select * from t_quote;\n+-------------------------+\n| a                       |\n+-------------------------+\n| Let's go                |\n| String s = \"Helloworld\" |\n+-------------------------+\n</code></pre><p>但是在其他数据库中，双引号用来引用标识符，和在MySQL中的反引号“`”的作用类似。比如下面这个例子中，order是MySQL中的一个关键词，不能用作表名，但是加上反引号之后就可以了。</p><pre><code class=\"language-go\">mysql&gt; create table order(a int);\nERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'order(a int)' at line 1\n\nmysql&gt; create table `order`(a int);\nQuery OK, 0 rows affected (8.92 sec)\n\nmysql&gt; select * from `order`;\nEmpty set (0.00 sec)\n</code></pre><p>在SQL Mode中设置ANSI_QUOTES选项可以改变双引号的作用。设置ANSI_QUOTES，双引号不再是用来引用字符串常量，而是用来引用标识符。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='ANSI_QUOTES';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from \"order\";\nEmpty set (0.00 sec)\n\nmysql&gt; insert into t_quote values (\"some data\");\nERROR 1054 (42S22): Unknown column 'some data' in 'field list'\n</code></pre><h3>NO_ENGINE_SUBSTITUTION</h3><p>MySQL支持多种存储引擎，存储引擎可以用插件的方式动态加载。在编译MySQL时，也可以通过cmake选项指定是否要将某个存储引擎编译出来。我们在建表的时候可以指定使用哪个存储引擎。如果指定的存储引擎不存在，那么MySQL可以将引擎替换为默认的存储引擎。在下面这个例子中，我们想创建一个federated表，但是我们的环境中没有federated存储引擎，因此存储引擎被改成了InnoDB。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; create table t_engine(a int) engine=federated;\nQuery OK, 0 rows affected, 2 warnings (8.95 sec)\n\nmysql&gt; show warnings;\n+---------+------+--------------------------------------------------+\n| Level   | Code | Message                                          |\n+---------+------+--------------------------------------------------+\n| Warning | 1286 | Unknown storage engine 'federated'               |\n| Warning | 1266 | Using storage engine InnoDB for table 't_engine' |\n+---------+------+--------------------------------------------------+\n\nmysql&gt; show create table t_engine\\G\n*************************** 1. row ***************************\n       Table: t_engine\nCreate Table: CREATE TABLE `t_engine` (\n  `a` int DEFAULT NULL\n) ENGINE=InnoDB \n1 row in set (0.00 sec)\n</code></pre><p>如果SQL Mode中开启NO_ENGINE_SUBSTITUTION选项，建表时如果指定的存储引擎不可用或不存在，SQL就会报错。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='NO_ENGINE_SUBSTITUTION';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; create table t_engine2(a int) engine=federated;\nERROR 1286 (42000): Unknown storage engine 'federated'\n</code></pre><h3>PIPES_AS_CONCAT</h3><p>在MySQL中，管道符“||”相当于OR，这可能和别的数据库不一样。比如在Oracle中，经常使用管道符连接字符串。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode=default;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select 'a' || 'b';\n+------------+\n| 'a' || 'b' |\n+------------+\n|          0 |\n+------------+\n1 row in set, 3 warnings (0.00 sec)\n</code></pre><p>SQL Mode中设置PIPES_AS_CONCAT选项后，管道符就变成了字符串连接符。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='pipes_as_concat';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select 'a' || 'b';\n+------------+\n| 'a' || 'b' |\n+------------+\n| ab         |\n+------------+\n1 row in set (0.00 sec)\n</code></pre><h3>REAL_AS_FLOAT</h3><p>设置REAL_AS_FLOAT后，MySQL会将REAL类型映射为Float类型。不设置REAL_AS_FLOAT的话，REAL类型映射为Double类型。</p><h3>IGNORE_SPACE</h3><p>MySQL中，函数和参数列表之间默认是不允许加空格的。比如下面这个例子中，函数count和括号之间加了几个空格，语句就无法执行了。</p><pre><code class=\"language-go\">mysql&gt; select count  (*) from information_schema.tables;\nERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '*) from information_schema.tables' at line 1\n\nmysql&gt; select count(*) from information_schema.tables;\n+----------+\n| count(*) |\n+----------+\n|      438 |\n+----------+\n1 row in set (2.56 sec)\n</code></pre><p>这种行为有时候可能比较讨厌。你可以在SQL Mode中加上IGNORE_SPACE选项，这样函数名之后有空格也不影响SQL的正确执行。</p><pre><code class=\"language-go\">mysql&gt; set sql_mode='ignore_space';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select count  (*) from information_schema.tables;\n+------------+\n| count  (*) |\n+------------+\n|        438 |\n+------------+\n1 row in set (0.06 sec)\n</code></pre><h3>ANSI</h3><p>ANSI是一个组合的SQL Mode，设置ANSI相当于同时设置REAL_AS_FLOAT、PIPES_AS_CONCAT、ANSI_QUOTES、IGNORE_SPACE和ONLY_FULL_GROUP_BY这几个选项。设置ANSI后，MySQL的语法支持和标准SQL更接近。</p><h3>TRADITIONAL</h3><p>TRADITIONAL也是一个组合的SQL Mode，设置TRADITIONAL相当于同时设置STRICT_TRANS_TABLES、STRICT_ALL_TABLES、NO_ZERO_IN_DATE、NO_ZERO_DATE、ERROR_FOR_DIVISION_BY_ZERO和NO_ENGINE_SUBSTITUTION这几个选项。</p><h2>如何设置SQL Mode？</h2><p>SQL Mode有这么多的选项，那么我们平时应该怎么设置呢？大部分情况下，我建议使用默认的严格模式设置，也就是设置上ONLY_FULL_GROUP_BY、STRICT_TRANS_TABLES、NO_ZERO_IN_DATE、NO_ZERO_DATE、ERROR_FOR_DIVISION_BY_ZERO和NO_ENGINE_SUBSTITUTION这几个选项，这可以避免往表中写入意外的错误数据。尽量在所有的环境中将SQL Mode设置成一样的，避免因为SQL Mode设置不一样引起一些不必要的麻烦。</p><p>如果你是从别的数据库迁移到MySQL，一些SQL可能和MySQL的默认模式不兼容，比如使用管道符“||”连接字符串，使用引号“\"”引用标识符，如果你可以修改SQL，我的建议是将SQL按MySQL的方式进行修改。如果实在是无法修改SQL，或者修改SQL的成本太高了，再考虑设置某些SQL Mode选项来解决。</p><p>MySQL数据库从低版本升级或迁移到高版本时，也需要全面测试应用程序。MySQL 5.7开始默认开启严格模式，避免由于SQL Mode默认值的变化而影响程序的正常运行。</p><p>下面这个表格对一些SQL Mode的作用做了简单总结，你可以参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/ba/2c2193d813bea7aa6445a7795d9900ba.png?wh=1740x1496\" alt=\"图片\"></p><h2>总结时刻</h2><p>设置SQL_MODE可能会使原先能执行的SQL无法执行，也可能影响数据写入操作，因此在生产环境修改这个参数前，需要对应用进行完整的测试验证。</p><p>如果你进行了数据库迁移或升级，新环境数据库sql_mode和原先的设置不一样，也可能引起应用程序出错。因此需要注意迁移或升级前后sql_mode的设置。MySQL 5.7开始，sql_mode的默认设置跟之前的版本相比，有很大的改动，如果你是从更早的版本升级过来，需要特别注意。</p><h2>思考题</h2><p>MySQL的备库复制中断了，查看错误信息，发现是有一个建表的语句报错了。</p><pre><code class=\"language-go\">               Last_SQL_Error: Coordinator stopped because there were error(s) in the worker(s). The most recent failure being: Worker 1 failed executing transaction 'c1a67221-f9fc-11ed-bffd-fa8338b09400:106' at master log binlog.000020, end_log_pos 4203259. See error log and/or performance_schema.replication_applier_status_by_worker table for more details about this failure or others, if any.\n  Replicate_Ignore_Server_Ids:\n</code></pre><pre><code class=\"language-go\">mysql&gt; select * from performance_schema.replication_applier_status_by_worker\\G\n*************************** 1. row ***************************\n                                           CHANNEL_NAME:\n                                              WORKER_ID: 1\n                                              THREAD_ID: NULL\n                                          SERVICE_STATE: OFF\n                                      LAST_ERROR_NUMBER: 1118\n                                     LAST_ERROR_MESSAGE: Worker 1 failed executing transaction 'c1a67221-f9fc-11ed-bffd-fa8338b09400:106' at master log binlog.000020, end_log_pos 4203259; Error 'Row size too large (&gt; 8126). Changing some columns to TEXT or BLOB or using ROW_FORMAT=DYNAMIC or ROW_FORMAT=COMPRESSED may help. In current row format, BLOB prefix of 768 bytes is stored inline.' on query. Default database: 'repl'. Query: 'create table t_inno1(\n       c01 varchar(768),\n       c02 varchar(768),\n       c03 varchar(768),\n       c04 varchar(768),\n       c05 varchar(768),\n       c06 varchar(768),\n       c07 varchar(768),\n       c08 varchar(768),\n       c09 varchar(768),\n       c10 varchar(768),\n       c11 varchar(398)\n    ) engine=innodb row_format=compact charset latin1'\n</code></pre><p>但是到主库上查看后，发现这个表创建成功了。</p><pre><code class=\"language-go\">mysql &gt;show create table t_inno1\\G\n*************************** 1. row ***************************\n       Table: t_inno1\nCreate Table: CREATE TABLE `t_inno1` (\n  `c01` varchar(768) DEFAULT NULL,\n  `c02` varchar(768) DEFAULT NULL,\n  `c03` varchar(768) DEFAULT NULL,\n  `c04` varchar(768) DEFAULT NULL,\n  `c05` varchar(768) DEFAULT NULL,\n  `c06` varchar(768) DEFAULT NULL,\n  `c07` varchar(768) DEFAULT NULL,\n  `c08` varchar(768) DEFAULT NULL,\n  `c09` varchar(768) DEFAULT NULL,\n  `c10` varchar(768) DEFAULT NULL,\n  `c11` varchar(398) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=latin1 ROW_FORMAT=COMPACT\n1 row in set (0.00 sec)\n</code></pre><p>为什么会出现这种情况呢？</p><p>期待你的思考，欢迎在留言区中与我交流。如果今天的课程让你有所收获，也欢迎转发给有需要的朋友。我们下节课再见！</p>","neighbors":{"left":{"article_title":"05｜你用对数据类型了吗？","id":803088},"right":{"article_title":"07｜乱码是怎么产生的，以及如何避免？","id":804947}},"comments":[{"had_liked":false,"id":394165,"user_name":"一本书","can_delete":false,"product_type":"c1","uid":2767251,"ip_address":"湖北","ucode":"4C07047F052BB4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/39/93/f0247cf8.jpg","comment_is_top":false,"comment_ctime":1726034557,"is_pvip":true,"replies":[{"id":143093,"content":"对于非事物表，同时设置STRICT_TRANS_TABLES、STRICT_ALL_TABLES和只设置STRICT_ALL_TABLES的效果应该是一样的。\n\nmysql&gt; set sql_mode=&#39;strict_all_tables,strict_trans_tables&#39;;\nmysql&gt; create table t_aa(a tinyint) engine=myisam;\nmysql&gt; insert into t_aa values(100),(200),(300),(400);\nERROR 1264 (22003): Out of range value for column &#39;a&#39; at row 2\n\nmysql&gt; select * from t_aa;\n+------+\n| a    |\n+------+\n|  100 |\n+------+\n1 row in set (0.00 sec)","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1726057843,"ip_address":"浙江","comment_id":394165,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"如果同时设置STRICT_TRANS_TABLES、STRICT_ALL_TABLES，那在非事务表中 INSERT 超出范围的值，处理方式是什么呢？","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651012,"discussion_content":"对于非事物表，同时设置STRICT_TRANS_TABLES、STRICT_ALL_TABLES和只设置STRICT_ALL_TABLES的效果应该是一样的。\n\nmysql&gt; set sql_mode=&#39;strict_all_tables,strict_trans_tables&#39;;\nmysql&gt; create table t_aa(a tinyint) engine=myisam;\nmysql&gt; insert into t_aa values(100),(200),(300),(400);\nERROR 1264 (22003): Out of range value for column &#39;a&#39; at row 2\n\nmysql&gt; select * from t_aa;\n+------+\n| a    |\n+------+\n|  100 |\n+------+\n1 row in set (0.00 sec)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726057843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393840,"user_name":"Amosヾ","can_delete":false,"product_type":"c1","uid":1567014,"ip_address":"广东","ucode":"833F6FCB4042AD","user_header":"https://static001.geekbang.org/account/avatar/00/17/e9/26/472e16e4.jpg","comment_is_top":false,"comment_ctime":1725071229,"is_pvip":true,"replies":[{"id":143013,"content":"非严格模式下，数据溢出时，会截断数据，但SQL还是能正常执行。\n这样会导致数据库中有异常数据，还不能及时发现这些问题。\n\n比如下面这个例子：\nmysql&gt; create table t_overflow(id int not null auto_increment, val tinyint, primary key(id)) engine=innodb;\n\nmysql&gt; insert into t_overflow(val) values(100),(200),(300),(400),(500);\nQuery OK, 5 rows affected, 4 warnings (0.96 sec)\nRecords: 5  Duplicates: 0  Warnings: 4\n\nmysql&gt; select * from t_overflow;\n+----+------+\n| id | val  |\n+----+------+\n|  1 |  100 |\n|  2 |  127 |\n|  3 |  127 |\n|  4 |  127 |\n|  5 |  127 |\n+----+------+\n5 rows in set (0.00 sec)\n\n","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1725243303,"ip_address":"浙江","comment_id":393840,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"为什么建议设置严格模式？非严格模式会有哪些危害呢？","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650551,"discussion_content":"非严格模式下，数据溢出时，会截断数据，但SQL还是能正常执行。\n这样会导致数据库中有异常数据，还不能及时发现这些问题。\n\n比如下面这个例子：\nmysql&gt; create table t_overflow(id int not null auto_increment, val tinyint, primary key(id)) engine=innodb;\n\nmysql&gt; insert into t_overflow(val) values(100),(200),(300),(400),(500);\nQuery OK, 5 rows affected, 4 warnings (0.96 sec)\nRecords: 5  Duplicates: 0  Warnings: 4\n\nmysql&gt; select * from t_overflow;\n+----+------+\n| id | val  |\n+----+------+\n|  1 |  100 |\n|  2 |  127 |\n|  3 |  127 |\n|  4 |  127 |\n|  5 |  127 |\n+----+------+\n5 rows in set (0.00 sec)\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725243303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393814,"user_name":"123","can_delete":false,"product_type":"c1","uid":2662872,"ip_address":"新加坡","ucode":"5A343B568B9524","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/d8/42252c48.jpg","comment_is_top":false,"comment_ctime":1724980718,"is_pvip":false,"replies":[{"id":142991,"content":"思考题里那个问题就是参数innodb_strict_mode在主备库不一样引起的。\n\n一般都建议用严格模式，这样能尽早暴露错误。warning很多时候都会被忽略。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1724999366,"ip_address":"浙江","comment_id":393814,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"思考题：\n\n首先查看数据库的版本是否一致，mysql在5.7默认开启严格模式，通过show variables like &#39;innodb_strict_mode&#39;查看，当前情况下，主库是在非严格模式下，而备库在严格模式下\n\n解决方案：\n1、设置备库为非严格模式，除非是业务需求，尽量不要使用非严格模式\n2、修改主库表的DDL，开启严格模式（在业务改动不大的情况下），让备库忽略该GTID，不执行该语句，后由主库重新创建后会自动同步\n\n另外，请教下老师，非严格模式使用会多吗，我们生产要求必须要使用严格模式","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650444,"discussion_content":"思考题里那个问题就是参数innodb_strict_mode在主备库不一样引起的。\n\n一般都建议用严格模式，这样能尽早暴露错误。warning很多时候都会被忽略。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724999366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}