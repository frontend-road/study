{"id":109980,"title":"28 | 原型模式与享元模式：提升系统性能的利器","content":"<p>你好，我是刘超。</p><p>原型模式和享元模式，前者是在创建多个实例时，对创建过程的性能进行调优；后者是用减少创建实例的方式，来调优系统性能。这么看，你会不会觉得两个模式有点相互矛盾呢？</p><p>其实不然，它们的使用是分场景的。在有些场景下，我们需要重复创建多个实例，例如在循环体中赋值一个对象，此时我们就可以采用原型模式来优化对象的创建过程；而在有些场景下，我们则可以避免重复创建多个实例，在内存中共享对象就好了。</p><p>今天我们就来看看这两种模式的适用场景，了解了这些你就可以更高效地使用它们提升系统性能了。</p><h2>原型模式</h2><p>我们先来了解下原型模式的实现。原型模式是通过给出一个原型对象来指明所创建的对象的类型，然后使用自身实现的克隆接口来复制这个原型对象，该模式就是用这种方式来创建出更多同类型的对象。</p><p><span class=\"orange\">使用这种方式创建新的对象的话，就无需再通过new实例化来创建对象了。</span>这是因为Object类的clone方法是一个本地方法，它可以直接操作内存中的二进制流，所以性能相对new实例化来说，更佳。</p><h3>实现原型模式</h3><p>我们现在通过一个简单的例子来实现一个原型模式：</p><pre><code>   //实现Cloneable 接口的原型抽象类Prototype \n   class Prototype implements Cloneable {\n        //重写clone方法\n        public Prototype clone(){\n            Prototype prototype = null;\n            try{\n                prototype = (Prototype)super.clone();\n            }catch(CloneNotSupportedException e){\n                e.printStackTrace();\n            }\n            return prototype;\n        }\n    }\n    //实现原型类\n    class ConcretePrototype extends Prototype{\n        public void show(){\n            System.out.println(&quot;原型模式实现类&quot;);\n        }\n    }\n\n    public class Client {\n        public static void main(String[] args){\n            ConcretePrototype cp = new ConcretePrototype();\n            for(int i=0; i&lt; 10; i++){\n                ConcretePrototype clonecp = (ConcretePrototype)cp.clone();\n                clonecp.show();\n            }\n        }\n    }\n</code></pre><p><strong>要实现一个原型类，需要具备三个条件：</strong></p><ul>\n<li>实现Cloneable接口：Cloneable接口与序列化接口的作用类似，它只是告诉虚拟机可以安全地在实现了这个接口的类上使用clone方法。在JVM中，只有实现了Cloneable接口的类才可以被拷贝，否则会抛出CloneNotSupportedException异常。</li>\n<li>重写Object类中的clone方法：在Java中，所有类的父类都是Object类，而Object类中有一个clone方法，作用是返回对象的一个拷贝。</li>\n<li>在重写的clone方法中调用super.clone()：默认情况下，类不具备复制对象的能力，需要调用super.clone()来实现。</li>\n</ul><!-- [[[read_end]]] --><p>从上面我们可以看出，原型模式的主要特征就是使用clone方法复制一个对象。通常，有些人会误以为  Object a=new Object();Object b=a;  这种形式就是一种对象复制的过程，然而这种复制只是对象引用的复制，也就是a和b对象指向了同一个内存地址，如果b修改了，a的值也就跟着被修改了。</p><p>我们可以通过一个简单的例子来看看普通的对象复制问题：</p><pre><code>class Student {  \n    private String name;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name= name;  \n    }  \n      \n}  \npublic class Test {  \n      \n    public static void main(String args[]) {  \n        Student stu1 = new Student();  \n        stu1.setName(&quot;test1&quot;);  \n\n        Student stu2 = stu1;  \n        stu2.setName(&quot;test2&quot;);  \n \n        System.out.println(&quot;学生1:&quot; + stu1.getName());  \n        System.out.println(&quot;学生2:&quot; + stu2.getName());  \n    }  \n}\n</code></pre><p>如果是复制对象，此时打印的日志应该为：</p><pre><code>学生1:test1\n学生2:test2\n</code></pre><p>然而，实际上是：</p><pre><code>学生1:test2\n学生2:test2\n</code></pre><p><span class=\"orange\">通过clone方法复制的对象才是真正的对象复制，clone方法赋值的对象完全是一个独立的对象。</span>刚刚讲过了，Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。我们可以用 clone 方法再实现一遍以上例子。</p><pre><code>//学生类实现Cloneable接口\nclass Student implements Cloneable{  \n    private String name;  //姓名\n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name= name;  \n    } \n   //重写clone方法\n   public Student clone() { \n        Student student = null; \n        try { \n            student = (Student) super.clone(); \n            } catch (CloneNotSupportedException e) { \n            e.printStackTrace(); \n            } \n            return student; \n   } \n      \n}  \npublic class Test {  \n      \n    public static void main(String args[]) {  \n        Student stu1 = new Student();  //创建学生1\n        stu1.setName(&quot;test1&quot;);  \n\n        Student stu2 = stu1.clone();  //通过克隆创建学生2\n        stu2.setName(&quot;test2&quot;);  \n \n        System.out.println(&quot;学生1:&quot; + stu1.getName());  \n        System.out.println(&quot;学生2:&quot; + stu2.getName());  \n    }  \n}\n</code></pre><p>运行结果：</p><pre><code>学生1:test1\n学生2:test2\n</code></pre><h3>深拷贝和浅拷贝</h3><p>在调用super.clone()方法之后，首先会检查当前对象所属的类是否支持clone，也就是看该类是否实现了Cloneable接口。</p><p>如果支持，则创建当前对象所属类的一个新对象，并对该对象进行初始化，使得新对象的成员变量的值与当前对象的成员变量的值一模一样，但对于其它对象的引用以及List等类型的成员属性，则只能复制这些对象的引用了。所以简单调用super.clone()这种克隆对象方式，就是一种浅拷贝。</p><p>所以，当我们在使用clone()方法实现对象的克隆时，就需要注意浅拷贝带来的问题。我们再通过一个例子来看看浅拷贝。</p><pre><code>//定义学生类\nclass Student implements Cloneable{  \n    private String name; //学生姓名\n    private Teacher teacher; //定义老师类\n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    } \n\n    public Teacher getTeacher() {  \n        return teacher;  \n    }  \n  \n    public void setTeacher(Teacher teacher) {  \n        this.teacher = teacher;  \n    } \n   //重写克隆方法\n   public Student clone() { \n        Student student = null; \n        try { \n            student = (Student) super.clone(); \n            } catch (CloneNotSupportedException e) { \n            e.printStackTrace(); \n            } \n            return student; \n   } \n      \n}  \n\n//定义老师类\nclass Teacher implements Cloneable{  \n    private String name;  //老师姓名\n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name= name;  \n    } \n\n   //重写克隆方法，堆老师类进行克隆\n   public Teacher clone() { \n        Teacher teacher= null; \n        try { \n            teacher= (Teacher) super.clone(); \n            } catch (CloneNotSupportedException e) { \n            e.printStackTrace(); \n            } \n            return student; \n   } \n      \n}\npublic class Test {  \n      \n    public static void main(String args[]) {\n        Teacher teacher = new Teacher (); //定义老师1\n        teacher.setName(&quot;刘老师&quot;);\n        Student stu1 = new Student();  //定义学生1\n        stu1.setName(&quot;test1&quot;);           \n        stu1.setTeacher(teacher);\n        \n        Student stu2 = stu1.clone(); //定义学生2\n        stu2.setName(&quot;test2&quot;);  \n        stu2.getTeacher().setName(&quot;王老师&quot;);//修改老师\n        System.out.println(&quot;学生&quot; + stu1.getName + &quot;的老师是:&quot; + stu1.getTeacher().getName);  \n        System.out.println(&quot;学生&quot; + stu1.getName + &quot;的老师是:&quot; + stu2.getTeacher().getName);  \n    }  \n}\n</code></pre><p>运行结果：</p><pre><code>学生test1的老师是：王老师\n学生test2的老师是：王老师\n</code></pre><p>观察以上运行结果，我们可以发现：在我们给学生2修改老师的时候，学生1的老师也跟着被修改了。这就是浅拷贝带来的问题。</p><p>我们可以通过深拷贝来解决这种问题，<span class=\"orange\">其实深拷贝就是基于浅拷贝来递归实现具体的每个对象，</span>代码如下：</p><pre><code>   public Student clone() { \n        Student student = null; \n        try { \n            student = (Student) super.clone(); \n            Teacher teacher = this.teacher.clone();//克隆teacher对象\n            student.setTeacher(teacher);\n            } catch (CloneNotSupportedException e) { \n            e.printStackTrace(); \n            } \n            return student; \n   } \n</code></pre><h3>适用场景</h3><p>前面我详述了原型模式的实现原理，那到底什么时候我们要用它呢？</p><p>在一些重复创建对象的场景下，我们就可以使用原型模式来提高对象的创建性能。例如，我在开头提到的，循环体内创建对象时，我们就可以考虑用clone的方式来实现。</p><p>例如：</p><pre><code>for(int i=0; i&lt;list.size(); i++){\n  Student stu = new Student(); \n  ...\n}\n\n</code></pre><p>我们可以优化为：</p><pre><code>Student stu = new Student(); \nfor(int i=0; i&lt;list.size(); i++){\n Student stu1 = (Student)stu.clone();\n  ...\n}\n</code></pre><p>除此之外，原型模式在开源框架中的应用也非常广泛。例如Spring中，@Service默认都是单例的。用了私有全局变量，若不想影响下次注入或每次上下文获取bean，就需要用到原型模式，我们可以通过以下注解来实现，@Scope(“prototype”)。</p><h2>享元模式</h2><p>享元模式是运用共享技术有效地最大限度地复用细粒度对象的一种模式。该模式中，以对象的信息状态划分，可以分为内部数据和外部数据。内部数据是对象可以共享出来的信息，这些信息不会随着系统的运行而改变；外部数据则是在不同运行时被标记了不同的值。</p><p>享元模式一般可以分为三个角色，分别为 Flyweight（抽象享元类）、ConcreteFlyweight（具体享元类）和 FlyweightFactory（享元工厂类）。抽象享元类通常是一个接口或抽象类，向外界提供享元对象的内部数据或外部数据；具体享元类是指具体实现内部数据共享的类；享元工厂类则是主要用于创建和管理享元对象的工厂类。</p><h3>实现享元模式</h3><p>我们还是通过一个简单的例子来实现一个享元模式：</p><pre><code>//抽象享元类\ninterface Flyweight {\n    //对外状态对象\n    void operation(String name);\n    //对内对象\n    String getType();\n}\n</code></pre><pre><code>//具体享元类\nclass ConcreteFlyweight implements Flyweight {\n    private String type;\n\n    public ConcreteFlyweight(String type) {\n        this.type = type;\n    }\n\n    @Override\n    public void operation(String name) {\n        System.out.printf(&quot;[类型(内在状态)] - [%s] - [名字(外在状态)] - [%s]\\n&quot;, type, name);\n    }\n\n    @Override\n    public String getType() {\n        return type;\n    }\n}\n</code></pre><pre><code>//享元工厂类\nclass FlyweightFactory {\n    private static final Map&lt;String, Flyweight&gt; FLYWEIGHT_MAP = new HashMap&lt;&gt;();//享元池，用来存储享元对象\n\n    public static Flyweight getFlyweight(String type) {\n        if (FLYWEIGHT_MAP.containsKey(type)) {//如果在享元池中存在对象，则直接获取\n            return FLYWEIGHT_MAP.get(type);\n        } else {//在响应池不存在，则新创建对象，并放入到享元池\n            ConcreteFlyweight flyweight = new ConcreteFlyweight(type);\n            FLYWEIGHT_MAP.put(type, flyweight);\n            return flyweight;\n        }\n    }\n}\n</code></pre><pre><code>public class Client {\n\n    public static void main(String[] args) {\n        Flyweight fw0 = FlyweightFactory.getFlyweight(&quot;a&quot;);\n        Flyweight fw1 = FlyweightFactory.getFlyweight(&quot;b&quot;);\n        Flyweight fw2 = FlyweightFactory.getFlyweight(&quot;a&quot;);\n        Flyweight fw3 = FlyweightFactory.getFlyweight(&quot;b&quot;);\n        fw1.operation(&quot;abc&quot;);\n        System.out.printf(&quot;[结果(对象对比)] - [%s]\\n&quot;, fw0 == fw2);\n        System.out.printf(&quot;[结果(内在状态)] - [%s]\\n&quot;, fw1.getType());\n    }\n}\n</code></pre><p>输出结果：</p><pre><code>[类型(内在状态)] - [b] - [名字(外在状态)] - [abc]\n[结果(对象对比)] - [true]\n[结果(内在状态)] - [b]\n</code></pre><p>观察以上代码运行结果，我们可以发现：如果对象已经存在于享元池中，则不会再创建该对象了，而是共用享元池中内部数据一致的对象。这样就减少了对象的创建，同时也节省了同样内部数据的对象所占用的内存空间。</p><h3>适用场景</h3><p>享元模式在实际开发中的应用也非常广泛。例如Java的String字符串，在一些字符串常量中，会共享常量池中字符串对象，从而减少重复创建相同值对象，占用内存空间。代码如下：</p><pre><code> String s1 = &quot;hello&quot;;\n String s2 = &quot;hello&quot;;\n System.out.println(s1==s2);//true\n</code></pre><p>还有，在日常开发中的应用。例如，线程池就是享元模式的一种实现；将商品存储在应用服务的缓存中，那么每当用户获取商品信息时，则不需要每次都从redis缓存或者数据库中获取商品信息，并在内存中重复创建商品信息了。</p><h2>总结</h2><p>通过以上讲解，相信你对原型模式和享元模式已经有了更清楚的了解了。两种模式无论是在开源框架，还是在实际开发中，应用都十分广泛。</p><p>在不得已需要重复创建大量同一对象时，我们可以使用原型模式，通过clone方法复制对象，这种方式比用new和序列化创建对象的效率要高；在创建对象时，如果我们可以共用对象的内部数据，那么通过享元模式共享相同的内部数据的对象，就可以减少对象的创建，实现系统调优。</p><h2>思考题</h2><p><span class=\"orange\">上一讲的单例模式和这一讲的享元模式都是为了避免重复创建对象，你知道这两者的区别在哪儿吗？</span></p><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p><img src=\"https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg?wh=1110*659\" alt=\"unpreview\"></p>","comments":[{"had_liked":false,"id":117600,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1564101723,"is_pvip":false,"replies":[{"id":"43126","content":"一个对象通过new创建的过程为：<br>1、在内存中开辟一块空间； <br>2、在开辟的内存空间中创建对象；  <br>3、调用对象的构造函数进行初始化对象。<br><br>而一个对象通过clone创建的过程为：<br>1、根据原对象内存大小开辟一块内存空间；<br>2、复制已有对象，克隆对象中所有属性值。<br><br>相对new来说，clone少了调用构造函数。如果构造函数中存在大量属性初始化或大对象，则使用clone的复制对象的方式性能会好一些。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564122703,"ip_address":"","comment_id":117600,"utype":1}],"discussion_count":1,"race_medal":0,"score":"323686648923","product_id":100028001,"comment_content":"new一个对象和clone一个对象，性能差在哪里呢？文中提到直接从内存复制二进制这里不是很理解","like_count":76,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460046,"discussion_content":"一个对象通过new创建的过程为：\n1、在内存中开辟一块空间； \n2、在开辟的内存空间中创建对象；  \n3、调用对象的构造函数进行初始化对象。\n\n而一个对象通过clone创建的过程为：\n1、根据原对象内存大小开辟一块内存空间；\n2、复制已有对象，克隆对象中所有属性值。\n\n相对new来说，clone少了调用构造函数。如果构造函数中存在大量属性初始化或大对象，则使用clone的复制对象的方式性能会好一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564122703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117232,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1564013770,"is_pvip":false,"replies":[{"id":"43181","content":"言简意赅！","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564201235,"ip_address":"","comment_id":117232,"utype":1}],"discussion_count":3,"race_medal":0,"score":"207722443978","product_id":100028001,"comment_content":"单例模式是针对某个类的单例，享元模式可以针对一个类的不同表现形式的单例，享元模式是单例模式的超集。","like_count":49,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459871,"discussion_content":"言简意赅！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564201235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338294,"discussion_content":"6p","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609234803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232984,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d0/58/ac40120f.jpg","nickname":"biubiubiu","note":"","ucode":"3310E95533D22B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282090,"discussion_content":"tql","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591884664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118056,"user_name":"东方奇骥","can_delete":false,"product_type":"c1","uid":1354850,"ip_address":"","ucode":"DEE7085F7E55A4","user_header":"https://static001.geekbang.org/account/avatar/00/14/ac/62/37912d51.jpg","comment_is_top":false,"comment_ctime":1564219717,"is_pvip":true,"replies":[{"id":"43410","content":"这里纠正下，不是每次请求，而是每次bean注入或通过上下文获取bean时。<br><br>如果我们使用的是单例，假设有一个全局变量private int a=1，我们通过上下文获取到实例，调用A方法修改了变量a=2，此时下一个通过上下文获取到实例调用B方法获取变量，则a=2。<br><br>如果我们使用的是原型模式，假设有一个全局变量private int a=1，我们通过上下文获取到实例，调用A方法修改了变量a=2，此时下一个通过上下文获取到实例调用B方法获取变量，则还是a=1。<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564368103,"ip_address":"","comment_id":118056,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61693761861","product_id":100028001,"comment_content":"老师，请教一下，文中说的，@service默认是单例模式，若不想影响下次请求，就要使用原型模式。能举个例子吗，什么时候会影响下次请求，不是很理解，因为我的项目里基本都是单例模式","like_count":15,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460242,"discussion_content":"这里纠正下，不是每次请求，而是每次bean注入或通过上下文获取bean时。\n\n如果我们使用的是单例，假设有一个全局变量private int a=1，我们通过上下文获取到实例，调用A方法修改了变量a=2，此时下一个通过上下文获取到实例调用B方法获取变量，则a=2。\n\n如果我们使用的是原型模式，假设有一个全局变量private int a=1，我们通过上下文获取到实例，调用A方法修改了变量a=2，此时下一个通过上下文获取到实例调用B方法获取变量，则还是a=1。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564368103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117479,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1564057505,"is_pvip":false,"replies":[{"id":"43087","content":"理解很透彻，点赞","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564106203,"ip_address":"","comment_id":117479,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35923795873","product_id":100028001,"comment_content":"享元模式可以再次创建对象 也可以取缓存对象<br><br>单例模式则是严格控制单个进程中只有一个实例对象<br><br>享元模式可以通过自己实现对外部的单例 也可以在需要的使用创建更多的对象<br><br>单例模式是自身控制 需要增加不属于该对象本身的逻辑","like_count":9,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459991,"discussion_content":"理解很透彻，点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564106203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117583,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1564099529,"is_pvip":false,"replies":[{"id":"51398","content":"是的，通过反射创建对象的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568725593,"ip_address":"","comment_id":117583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31628870601","product_id":100028001,"comment_content":"老师好，文中举例Spring的prototype貌似不是原型模式的实现吧，每次spring都是通过反射创建的对象，并没有通过clone的方式吧","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460038,"discussion_content":"是的，通过反射创建对象的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568725593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161521,"user_name":"Mr wind","can_delete":false,"product_type":"c1","uid":1217874,"ip_address":"","ucode":"484F02D1962239","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","comment_is_top":false,"comment_ctime":1576222866,"is_pvip":false,"replies":[{"id":"61975","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1576669125,"ip_address":"","comment_id":161521,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23051059346","product_id":100028001,"comment_content":"1、如果对象的构造中有逻辑处理，而clone不会调用构造会更快，但是既然构造中存在逻辑，一般情况下我们都是希望new对象的时候能够用到这些逻辑；  2、如果对象的构造中没有逻辑，那么通常情况下clone的速度反而较之下降。3、所以有点感觉clone存在的意义就是，某个对象构造中有逻辑代码，而我们在大量创建对象的时候不需要构造中逻辑。否则直接new还更快。","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477747,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576669125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542055,"discussion_content":"更多的是解耦吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640653719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161417,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1184658,"ip_address":"","ucode":"0641211EE9DA5C","user_header":"https://static001.geekbang.org/account/avatar/00/12/13/92/0b4c8e30.jpg","comment_is_top":false,"comment_ctime":1576202958,"is_pvip":false,"replies":[{"id":"61962","content":"可以的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1576668542,"ip_address":"","comment_id":161417,"utype":1}],"discussion_count":1,"race_medal":1,"score":"23051039438","product_id":100028001,"comment_content":"深拷贝用json的序列化或者反序列化可以吗，或者用一个叫orika的框架也可以做递归深拷贝","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477713,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576668542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118182,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1564283605,"is_pvip":true,"replies":[{"id":"43382","content":"需要的。共享数据尽量不要涉及到线程安全问题，否则就没有什么优势了。例如字符串则利用了不可变性来避免线程安全问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564364835,"ip_address":"","comment_id":118182,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23039120085","product_id":100028001,"comment_content":"享元模式的实例也需要考虑线程安全哇？<br>","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460290,"discussion_content":"需要的。共享数据尽量不要涉及到线程安全问题，否则就没有什么优势了。例如字符串则利用了不可变性来避免线程安全问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117622,"user_name":"一个卖火柴的老男人","can_delete":false,"product_type":"c1","uid":1181265,"ip_address":"","ucode":"1227638C457F49","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/51/1d24ead6.jpg","comment_is_top":false,"comment_ctime":1564102874,"is_pvip":false,"replies":[{"id":"43179","content":"建议加一个图片验证码","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564201045,"ip_address":"","comment_id":117622,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23038939354","product_id":100028001,"comment_content":"老师请教你个问题，线上短信业务被轰炸，流量费倍增……求推荐个解决思路，监测发现是爬虫程序","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460055,"discussion_content":"建议加一个图片验证码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564201045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387208,"discussion_content":"ip限流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628052599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1229202,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c1/92/3856b71d.jpg","nickname":"雨中漫步","note":"","ucode":"48F5F65D36F764","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22809,"discussion_content":"短信包月","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569684884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163470,"user_name":"遇见","can_delete":false,"product_type":"c1","uid":1624590,"ip_address":"","ucode":"FAF53CD4C28494","user_header":"https://static001.geekbang.org/account/avatar/00/18/ca/0e/5009c5ff.jpg","comment_is_top":false,"comment_ctime":1576726806,"is_pvip":false,"replies":[{"id":"62974","content":"用==就好了，Java中判断两个对象是否相等是==。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1577186894,"ip_address":"","comment_id":163470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14461628694","product_id":100028001,"comment_content":"&quot;如果对象已经存在于享元池中，则不会再创建该对象了，而是共用享元池中内部数据一致的对象。&quot;<br><br>要获得&quot;数据一致的对象&quot; , 遍历享元池, 用equals判断是不是更好一些呢?<br><br>前面有提到spring的单例的实现其实就是享元模式, 那么spring中, 判断对象数据一致, 是用key来判断的还是用equals判断的呢?","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478404,"discussion_content":"用==就好了，Java中判断两个对象是否相等是==。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577186894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117234,"user_name":"全有","can_delete":false,"product_type":"c1","uid":1488139,"ip_address":"","ucode":"D16B42B1F71E4E","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/0b/df89c357.jpg","comment_is_top":false,"comment_ctime":1564013965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14448915853","product_id":100028001,"comment_content":"享元模式的给工厂类，是用HashMap 来存储共享对象，在多线程下并不安全，同时也没有加锁判定，依然会存在创建个对象，只是会覆盖掉","like_count":3},{"had_liked":false,"id":144365,"user_name":"Alsace","can_delete":false,"product_type":"c1","uid":1702972,"ip_address":"","ucode":"2B83ACE05B688B","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIFr9x9UtgJEpiaUMWxO9GOrlARIhSCAiaZe4npv4ricWYJowgl5eO3s19yZ7ibOjfGyDicfxPD6Yc8beA/132","comment_is_top":false,"comment_ctime":1571904106,"is_pvip":false,"replies":[{"id":"55861","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1572081154,"ip_address":"","comment_id":144365,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10161838698","product_id":100028001,"comment_content":"如果在程序中利用一个map容器缓存对象，实现懒加载，存在的话直接取，不存在生成新对象维护到容器中，是不是也算是享元模式呢？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471904,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572081154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592159,"discussion_content":"。。。。直接localcache。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667180237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1615818,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a7/ca/f0c90475.jpg","nickname":"争分夺秒","note":"","ucode":"A29E3BC69F196F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286662,"discussion_content":"我代码立马也有些基础的实例用了map 缓存某些实例的引用，看到这里才知道自己居然是享元模式，嘿嘿，我太机智了。聪明人永远能想到一块去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593258137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139842,"user_name":"kyle","can_delete":false,"product_type":"c1","uid":1213128,"ip_address":"","ucode":"55EF7FC99C0BF7","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/c8/6924e551.jpg","comment_is_top":false,"comment_ctime":1570754955,"is_pvip":false,"replies":[{"id":"54273","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570955992,"ip_address":"","comment_id":139842,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865722251","product_id":100028001,"comment_content":"个人理解是这样，单例模式，就是单个实例的模式，一般针对类来说的，也就是类实例，一个单例模式包含一个类实例。而享元模式，就是共享元对象的模式，元对象除了可以是类实例，也可以是其他可以共享的对象，比如普通类型变量，字符常量等。一个享元模式可以包含多个元对象。简单说就是，享元模式是单例模式的超集，单例模式是享元模式的子集。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470137,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570955992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117247,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1564015490,"is_pvip":false,"replies":[{"id":"43180","content":"因为name是对外状态的一个对象，不存在共享。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564201175,"ip_address":"","comment_id":117247,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5858982786","product_id":100028001,"comment_content":"&#47;&#47; 抽象享元类<br>interface Flyweight {<br>    &#47;&#47; 对外状态对象<br>    void operation(String name);<br>    &#47;&#47; 对内对象<br>    String getType();<br>}<br>老师好!享员工厂为啥不用operation的入参name做key?","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459880,"discussion_content":"因为name是对外状态的一个对象，不存在共享。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564201175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1124948,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","nickname":"bro.","note":"","ucode":"D65283CD869804","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2931,"discussion_content":"那个就是外部数据了呀,内部数据是不会隋着系统运行而改变的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564042087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117200,"user_name":"a、","can_delete":false,"product_type":"c1","uid":1532404,"ip_address":"","ucode":"590FE8DB111492","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","comment_is_top":false,"comment_ctime":1563988878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858956174","product_id":100028001,"comment_content":"我觉得单例模式和享元模式的区别，享元模式可以看成是一组单例模式。","like_count":1},{"had_liked":false,"id":336476,"user_name":"Geek_ee3fe8","can_delete":false,"product_type":"c1","uid":2854845,"ip_address":"","ucode":"4FF8A113699909","user_header":"","comment_is_top":false,"comment_ctime":1646182138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646182138","product_id":100028001,"comment_content":"享元模式在写业务代码的时候什么时候用到。举个例子呗","like_count":0},{"had_liked":false,"id":305420,"user_name":"书策稠浊","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1627966266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627966266","product_id":100028001,"comment_content":"浅拷贝拷贝栈，深拷贝拷贝堆，这样理解对吗","like_count":0},{"had_liked":false,"id":274354,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1610975659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610975659","product_id":100028001,"comment_content":"老师,大量属性初始化和大量属性拷贝复制相比有性能劣势吗?","like_count":0},{"had_liked":false,"id":270740,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609233699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609233699","product_id":100028001,"comment_content":"用了私有全局变量，若不想影响下次注入或每次上下文获取 bean，就需要用到原型模式，我们可以通过以下注解来实现，@Scope(“prototype”)。<br>老师 这里是不是私有有什么区别吗?不太明白这块的描述.","like_count":0},{"had_liked":false,"id":254112,"user_name":"慌张而黑糖","can_delete":false,"product_type":"c1","uid":1638878,"ip_address":"","ucode":"B4416885A301C8","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","comment_is_top":false,"comment_ctime":1603068295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603068295","product_id":100028001,"comment_content":"享元模式中的接口类，在文中的例子里没看出作用是什么","like_count":0},{"had_liked":false,"id":227239,"user_name":"耿嘉艺","can_delete":false,"product_type":"c1","uid":2023401,"ip_address":"","ucode":"727A22BD41E8AF","user_header":"","comment_is_top":false,"comment_ctime":1592321422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592321422","product_id":100028001,"comment_content":"如果不重写clone方法，直接调用有什么问题，继承了object类，这个方法不能直接用吗","like_count":0},{"had_liked":false,"id":213873,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1588581077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588581077","product_id":100028001,"comment_content":"享元模式中，使用HashMap是线程不安全的吧，应该用ConcurrentHashMap吧","like_count":0},{"had_liked":false,"id":213863,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1588579397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588579397","product_id":100028001,"comment_content":"<br>Student stu = new Student(); <br>for(int i=0; i&lt;list.size(); i++){<br> Student stu1 = (Student)stu.clone();<br>  ...<br>}<br>这种用法其实并不好，首先阅读起来不容易那么理解，其次，stu在循环中设置了一些属性值，这样直接clone就克隆到新对象了，如果新对象不需要设置该属性，还得根据一些条件判断设置成null，更增加了代码的复杂度。","like_count":0},{"had_liked":false,"id":202417,"user_name":"楠楠嘻嘻","can_delete":false,"product_type":"c1","uid":1503202,"ip_address":"","ucode":"3B99180DD8501D","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/e2/df2a1823.jpg","comment_is_top":false,"comment_ctime":1585985820,"is_pvip":false,"replies":[{"id":"77108","content":"没差距，这个是一个结果集转换为对象的过程，暂时没有过优化经验，不知道其他同学有没有优化的经验","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1586863464,"ip_address":"","comment_id":202417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585985820","product_id":100028001,"comment_content":"仅仅构造函数初始化的话，那对于普通的dto new 和clone 那就没什么差距了是吧？<br>再请教一下 对于反射方式下的jdbc result转换 有什么优化措施吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490577,"discussion_content":"没差距，这个是一个结果集转换为对象的过程，暂时没有过优化经验，不知道其他同学有没有优化的经验","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586863464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190025,"user_name":".","can_delete":false,"product_type":"c1","uid":1083502,"ip_address":"","ucode":"83F583994F4F72","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/6e/3bd860d3.jpg","comment_is_top":false,"comment_ctime":1584594919,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1584594919","product_id":100028001,"comment_content":"作者回复: 一个对象通过new创建的过程为：<br>1、在内存中开辟一块空间；<br>2、在开辟的内存空间中创建对象；<br>3、调用对象的构造函数进行初始化对象。<br><br>而一个对象通过clone创建的过程为：<br>1、根据原对象内存大小开辟一块内存空间；<br>2、复制已有对象，克隆对象中所有属性值。<br><br>相对new来说，clone少了调用构造函数。如果构造函数中存在大量属性初始化或大对象，则使用clone的复制对象的方式性能会好一些。","like_count":0,"discussions":[{"author":{"id":1183002,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/1a/2c364284.jpg","nickname":"隔离样","note":"","ucode":"34BC6CED888FFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249870,"discussion_content":"小对象还是new好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587969057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174112,"user_name":"asura","can_delete":false,"product_type":"c1","uid":1105148,"ip_address":"","ucode":"4AF66C19B4AE65","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/fc/5c3ad841.jpg","comment_is_top":false,"comment_ctime":1579998276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579998276","product_id":100028001,"comment_content":"单例模式：是对某一个类的单例，做到精简使用。不能拓展，不能修改。享元模式：有抽象元类+具体实现类+工厂类，可以灵活扩展和延伸。能达到单例的效果，但比单例更有宏观调控和管理。","like_count":0},{"had_liked":false,"id":166239,"user_name":"insist","can_delete":false,"product_type":"c1","uid":1054536,"ip_address":"","ucode":"1EE2800A900BA7","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/48/3ab39c86.jpg","comment_is_top":false,"comment_ctime":1577421636,"is_pvip":false,"replies":[{"id":"65930","content":"需要占用大量连续内存空间的java对象一般称为大对象，比如很长的字符串、数组以及类对象。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1578485428,"ip_address":"","comment_id":166239,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577421636","product_id":100028001,"comment_content":"老师  请问大对象的衡量标准是什么？什么样的对象算是大对象","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479452,"discussion_content":"需要占用大量连续内存空间的java对象一般称为大对象，比如很长的字符串、数组以及类对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578485428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147705,"user_name":"玉骢哒哒","can_delete":false,"product_type":"c1","uid":1320842,"ip_address":"","ucode":"6F12F476079B7D","user_header":"https://static001.geekbang.org/account/avatar/00/14/27/8a/1a184ee9.jpg","comment_is_top":false,"comment_ctime":1572880139,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1572880139","product_id":100028001,"comment_content":"   private static void test(){<br>        long startTime = System.currentTimeMillis();<br>        for(int i=0;i&lt;100000000;i++){<br>            Student student = new Student();<br>        }<br>        long endTime = System.currentTimeMillis();<br>        System.out.println(&quot;startTime=&quot;+startTime+&quot;,endTime=&quot;+endTime+&quot;,差值&quot;+(endTime-startTime));<br>    }<br>    private static void test2(){<br>        long startTime = System.currentTimeMillis();<br>        Student student = new Student();<br>        for(int i=0;i&lt;100000000;i++){<br>            Student stu = (Student)student.clone();<br>        }<br>        long endTime = System.currentTimeMillis();<br>        System.out.println(&quot;startTime=&quot;+startTime+&quot;,endTime=&quot;+endTime+&quot;,差值&quot;+(endTime-startTime));<br>    }<br>为什么使用clone反而耗时增加了很多","like_count":0,"discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542058,"discussion_content":"我也测试了一下 属性不多的情况 性能是下降的\n  public static void compare() {\n        Student student = new Student();\n        student.setName(&#34;hello&#34;);\n        Teacher teacher = new Teacher();\n        teacher.setName(&#34;world&#34;);\n        student.setTeacher(teacher);\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i &lt; 100000000; i++) {\n            Student stu = new Student();\n            stu.setName(student.getName());\n            stu.setTeacher(student.getTeacher());\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(&#34;startTime=&#34; + startTime + &#34;,endTime=&#34; + endTime + &#34;,差值&#34; + (endTime - startTime));\n        long startTime1 = System.currentTimeMillis();\n        for (int i = 0; i &lt; 100000000; i++) {\n            Student stu = (Student) student.clone();\n        }\n        long endTime1 = System.currentTimeMillis();\n        System.out.println(&#34;startTime=&#34; + startTime1 + &#34;,endTime=&#34; + endTime1 + &#34;,差值&#34; + (endTime1 - startTime1));\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640654500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1320842,"avatar":"https://static001.geekbang.org/account/avatar/00/14/27/8a/1a184ee9.jpg","nickname":"玉骢哒哒","note":"","ucode":"6F12F476079B7D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43962,"discussion_content":"上述代码Student对象中只有两个属性。当属性增加至50多个时，使用clone会更快，或者构造方法中当使用计算、截取等操作时，clone也可能更快。我觉得文中应该指明：clone在文中for循环例子中，不一定能做到优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572919322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133274,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1568473074,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1568473074","product_id":100028001,"comment_content":"---1000万<br>22:50:16.799 [main] INFO com.learn.geektime.javafamily.performance.ch28.PrototypeTest - original way cost: 16100, stuList.size: 10000000<br>22:51:08.762 [main] INFO com.learn.geektime.javafamily.performance.ch28.PrototypeTest - prototype way cost: 16319, stuList2.size: 10000000<br><br>---100万<br>22:54:08.289 [main] INFO com.learn.geektime.javafamily.performance.ch28.PrototypeTest - original way cost: 195, stuList.size: 1000000<br>22:53:31.767 [main] INFO com.learn.geektime.javafamily.performance.ch28.PrototypeTest - prototype way cost: 199, stuList2.size: 1000000<br><br>---10万<br>22:54:49.290 [main] INFO com.learn.geektime.javafamily.performance.ch28.PrototypeTest - original way cost: 39, stuList.size: 100000<br>22:55:03.003 [main] INFO com.learn.geektime.javafamily.performance.ch28.PrototypeTest - prototype way cost: 58, stuList2.size: 100000<br><br>---我猜测原型模式不适合这种简单的pojo，估计适合大对象","like_count":0},{"had_liked":false,"id":132831,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568248702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568248702","product_id":100028001,"comment_content":"课后思考及问题<br>1：原型模式——通过使用更高效的对象创建方式来创建大量重复对象，已提高创建对象的性能。<br>2：享员模式——通过减少内部公享数据的创建来创建对象，以提高创建对象的性能。<br>3：单列模式我觉得可以认为是一个缩小版的享员模式，它的所有数据都可以看着共享的数据，都无需重复创建。<br>请问老师，我们可以使用原型模式，通过 clone 方法复制对象，这种方式比用 new 和序列化创建对象的效率要高。<br>这个结论有定量的测试数据嘛？性能大概能提升多少？如果性能提高不少，我觉得可以作为我们系统的一个性能优化点，我们复制对象采用深拷贝的方式，担心序列化反序列化性能差都是new后重新赋值的方式实现的，对于对象属性是层层递归创建对象赋值实现的。<br>或者换个问题老师觉得最佳的对象深拷贝方案是什么？为啥？","like_count":0},{"had_liked":false,"id":129955,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1567338746,"is_pvip":false,"replies":[{"id":"48610","content":"是的，感谢提醒","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567424317,"ip_address":"","comment_id":129955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567338746","product_id":100028001,"comment_content":"代码是不是写错了应该是：<br>学生 1:test2<br>学生 2:test2<br>","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465734,"discussion_content":"是的，感谢提醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567424317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119612,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1564637190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564637190","product_id":100028001,"comment_content":"变一下不就是工厂模式吗？","like_count":0},{"had_liked":false,"id":118076,"user_name":"一个卖火柴的老男人","can_delete":false,"product_type":"c1","uid":1181265,"ip_address":"","ucode":"1227638C457F49","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/51/1d24ead6.jpg","comment_is_top":false,"comment_ctime":1564232563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564232563","product_id":100028001,"comment_content":"谢谢🙏老师提供的思路🙏","like_count":0},{"had_liked":false,"id":117523,"user_name":"门窗小二","can_delete":false,"product_type":"c1","uid":1006424,"ip_address":"","ucode":"0BF3780C247F22","user_header":"","comment_is_top":false,"comment_ctime":1564066518,"is_pvip":true,"replies":[{"id":"43085","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564106150,"ip_address":"","comment_id":117523,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564066518","product_id":100028001,"comment_content":"通过老师这次的讲解算是彻底明白了单例模式与享元模式的区别，享元模式可以理解为一组单例模式<br>","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460009,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564106150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117347,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1564027709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564027709","product_id":100028001,"comment_content":"单例模式的运用场景一般是一个系统中的全局事物，比如数据库连接池，多线程连接池等<br>享元模式的运用场景则是是业务流程中，需要频繁获取元数据的的情况，比如老师说的用户获取商品的情况。","like_count":0},{"had_liked":false,"id":117291,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1564019330,"is_pvip":false,"replies":[{"id":"43577","content":"想法很好，不建议这样曲线救国。我们没有必要针对每一个类去做原型设计，仅仅针对一些特殊场景的类实现clone方法即可。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564453202,"ip_address":"","comment_id":117291,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564019330","product_id":100028001,"comment_content":"实现一个公共父类，实现原型模式，并反射完成深拷贝。对需要大量创建新对象的类继承该父类。老师这样做行不？反射有开销，继承这种结构也不好（但组合实现感觉不直观）。不确定这样抽象后是否利大于弊。毕竟如果反射开销冲掉了clone带来的性能优化，还不如直接new","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459901,"discussion_content":"想法很好，不建议这样曲线救国。我们没有必要针对每一个类去做原型设计，仅仅针对一些特殊场景的类实现clone方法即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564453202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117263,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1564016858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564016858","product_id":100028001,"comment_content":"享元模式和策略模式感觉有点像啊，根据某个值，去上下文容器中取对应的handler类处理","like_count":0},{"had_liked":false,"id":117256,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1564016176,"is_pvip":false,"replies":[{"id":"43575","content":"是的，感谢提醒！","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564453023,"ip_address":"","comment_id":117256,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564016176","product_id":100028001,"comment_content":"在a=b的地方的代码是否有问题，第二个stu1.setName(&quot;test2&quot;);应该改为stu2.setName(&quot;test2&quot;)","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459885,"discussion_content":"是的，感谢提醒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564453023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117250,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1564015698,"is_pvip":false,"replies":[{"id":"43574","content":"我相信大部分同学都很少使用到原型模式来创建对象，如果每个类实现clone方法，有点走极端优化了，这里只是针对一些特殊场景，比如在一些循环中创建对象的类，我们可以实现clone方法来复制对象。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564452950,"ip_address":"","comment_id":117250,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564015698","product_id":100028001,"comment_content":"老师好，具体啥时候用原型模式啊?循环有很多，中不能每个DTO都搞个原型类吧能透露下评价原则么?谢谢老师pojo,dto,vo，再加一个原型类爆炸。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459882,"discussion_content":"我相信大部分同学都很少使用到原型模式来创建对象，如果每个类实现clone方法，有点走极端优化了，这里只是针对一些特殊场景，比如在一些循环中创建对象的类，我们可以实现clone方法来复制对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564452950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}