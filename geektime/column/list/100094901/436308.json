{"id":436308,"title":"06 | 静态链接：变量与内存地址是如何映射的？","content":"<p>你好，我是海纳。</p><p>在第3节课里，我们看到进程的内存空间包含代码段、数据段、bss段、堆和栈等区域。在第4节和第5节课里，我们对栈的相关知识进行了深入学习。今天我们来看看内存中的另一个重要部分：代码段和数据段的组织方式。</p><p>我们知道，编程的代码无非是由函数和各种变量，以及对这些变量的读、写所组成，而不管是变量还是函数，它们最终都要存储在内存里。为每个变量和函数正确地分配内存空间，记录它们的地址，并把这个地址复写回调用或引用它们的地方，这是一个十分重要且困难的任务。</p><p>在我们使用gcc时，往往执行一个命令后，就能得到可执行程序，所以你可能会误以为是编译器负责为变量分配内存地址，但是实际上，这个工作是由链接器来完成的。每个变量和函数都有自己的名称，通常我们把这些名称叫做符号。简单来讲，链接器的作用就是为符号转换成地址，一般来说可以分为三种情况：</p><ol>\n<li>生成二进制可执行文件的过程中。这种情况称为静态链接；</li>\n<li>在二进制文件被加载进内存时。这种情况是在二进制文件保留符号，在加载时再把符号解析成真实的内存地址，这种被称为动态链接；</li>\n<li>在运行期间解析符号。这种情况会把符号的解析延迟到最后不得不做时才去做符号的解析，这也是动态链接的一种。</li>\n</ol><!-- [[[read_end]]] --><p>相信你在工作中，尤其是在编译各种开源项目时，肯定遇到过“找不到符号”，或者“undefined reference to X”这样的报错信息，其实这些错误都和编译链接的过程有关系。所以，接下来的3节课，我们就重点来分析一下链接器是怎么完成内存地址的映射工作的，了解了这个原理后，再遇到类似的问题，你就知道如何着手去分析了。</p><p>今天这节课我们先来探讨静态链接的过程。</p><h3>关于链接的小例子</h3><p>我们先用一个具体的例子展示一遍编译和链接的全部过程，然后再分析每一步的原理。这个例子包含两个文件，第一个文件是example.c：</p><pre><code>// example.c\nextern int extern_var;\nint global_var = 1;\nstatic int static_var = 2;\n \nextern int extern_func();\nint global_func() {\n    return 10;\n}\n \nstatic int static_func() {\n    return 20;\n}\n \nint main() {\n    int var0 = extern_var;\n    int var1 = global_var;\n    int var2 = static_var;\n    int var3 = extern_func();\n    int var4 = global_func();\n    int var5 = static_func();\n    return var0 + var1 + var2 + var3 + var4 + var5;\n}\n</code></pre><p>第二个文件是external.c：</p><pre><code>// external.c\nint extern_var = 3;\nint extern_func() {\n    return 30;\n}\n</code></pre><p>我们先使用gcc将两个c文件分别编译成.o目标文件，这个过程称为编译，命令如下：</p><pre><code># gcc example.c -c -o example.o -fno-PIC -g\n# gcc external.c -c -o external.o -fno-PIC -g\n</code></pre><p>这里我给你解释一下命令中的几个选项：</p><ul>\n<li>-c意思是告诉gcc不要进行链接，只要编译到.o就可以了；</li>\n<li>-o指定了输出文件名;</li>\n<li>-fno-PIC是告诉编译器不要生成PIC的代码。因为我使用的是gcc4.8版本，在编译的过程中默认的模式是PIC模式，由于我们今天讨论的内容主要是静态链接的部分，所以需要打开-fno-PIC选项。这个选项对动态链接的意义比较大，在下节课讲动态链接时，我会对这个选项给你做详细解释。</li>\n<li>-g选项是打开调试信息，让我们在分析过程中能够对源码有更完整的对应关系。</li>\n</ul><p>然后，我们将两个.o文件链接生成可执行文件，由目标文件生成可执行文件的过程就是链接。命令如下：</p><pre><code># gcc external.o example.o -o a.out -no-pie\n</code></pre><p>在这个命令中，-no-pie表示关闭pie的模式。gcc会默认打开pie模式，也就意味着系统loader对加载可执行文件时的起始地址，会随机加载。关闭pie之后，在Linux 64位的系统下，默认的加载起始地址是0x400000。关于这个选项，我们将在下节课详细讲解。</p><p>这样，我们就得到了可执行二进制文件a.out，以上内容就是编译和链接的全过程了。接下来我们详细看一看链接器在这个过程中发挥的作用。</p><h3>链接器的作用</h3><p>我们继续结合上面的例子来说明，这个例子其实涵盖了程序员在开发过程中，最常用的几种变量类型以及函数类型，分别是：</p><ol>\n<li>\n<p>全局变量：global_var。</p>\n</li>\n<li>\n<p>静态变量：static_var。</p>\n</li>\n<li>\n<p>外部变量：extern_var，在example.c中使用extern关键字进行声明，定义在external.c里。</p>\n</li>\n<li>\n<p>局部变量：var0 … var5。</p>\n</li>\n<li>\n<p>全局函数：global_func。</p>\n</li>\n<li>\n<p>静态函数：static_func。</p>\n</li>\n<li>\n<p>外部函数：extern_func，在example.c中使用extern关键字进行声明，定义在external.c里。</p>\n</li>\n</ol><p>程序员在开发代码的过程中，也是直接跟这些符号打交道的。如果想获取某个变量的值，就直接从变量符号里读取内容；如果想调用某个函数，也是直接写一个函数符号的调用语句。</p><p>但是，我们知道，CPU在执行程序代码的时候，并不理解符号的概念，它所能理解的只有内存地址的概念。不管是读数据，调用函数还是读指令，对于CPU而言都是一个个的内存地址。因此，<strong>这里就需要一个连接CPU与程序员之间的桥梁，把程序中的符号转换成CPU执行时的内存地址</strong>。<strong>这个桥梁就是链接器，它负责将符号转换为地址。</strong></p><p><strong>链接器的第一个作用就是把多个中间文件合并成一个可执行文件</strong>。我们在第3节课分析过，每个中间文件都有自己的代码段和数据段等多个section，在合并成一个可执行程序时，多个中间文件的代码段会被合并到可执行文件的代码段，它们数据段也会被合并为可执行文件的数据段。具体的过程可以参考下面这个图：</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/82/e22cc1820a1e9b5e3fc44b844dba7182.jpg?wh=2284x1301\" alt=\"\"></p><p>但是链接器在合并多个目标文件的时候并不是简单地将各个section合并就可以了，它还需要考虑每个目标中的符号的地址。这就引出了<strong>链接器的第二个任务：重定位</strong>。所谓重定位，就是当被调用者的地址变化了，要让调用者知道新的地址是什么。</p><h4>两步链接</h4><p>根据上边的分析，链接器的工作流程也主要分为两步：</p><p><strong>第一步是，链接器需要对编译器生成的多个目标（.o)文件进行合并，一般采取的策略是相似段的合并，最终生成共享文件(.so)或者可执行文件</strong>。这个阶段中，链接器对输入的各个目标文件进行扫描，获取各个段的大小，并且同时会收集所有的符号定义以及引用信息，构建一个全局的符号表。当链接器构造好了最终的文件布局以及虚拟内存布局后，我们根据符号表，也就能确定了每个符号的虚拟地址了。</p><p><strong>第二步是，链接器会对整个文件再进行第二遍扫描，这一阶段，会利用第一遍扫描得到的符号表信息，依次对文件中每个符号引用的地方进行地址替换。也就是对符号的解析以及重定位过程</strong>。</p><p>这就是链接器常用的两步链接(Two-pass linking)的步骤。简单来讲就是进行两遍扫描：第一遍扫描完成文件合并、虚拟内存布局的分配以及符号信息收集；第二遍扫描则是完成了符号的重定位过程。</p><p>重定位是符号解析的重要步骤，是我们理解静态链接和动态链接的基础原理。在JVM或者V8虚拟机中，对符号的解析的原理与链接器的重定位过程是十分相似的，可见重定位应用得非常广泛，所以接下来我们要重点了解一下重定位的原理。</p><h3>深入分析重定位过程</h3><p>工欲善其事，必先利其器，在GNU/linux下，GNU的binutils提供了一系列编程语言的工具程序，用来查看不同格式下的目标文件。今天我要给你重点介绍两个工具：readelf和objdump，这两个工具可以用来解析和读取上一节编译阶段生成的目标文件信息。</p><p>一般情况下，我在对二进制文件进行反汇编时会使用objdump工具，因为readelf工具没有提供反汇编的能力，它更多是用来解析二进制文件信息。</p><p>在前面的例子中，我们已经编译出两个.o目标文件，以及最终链接后的a.out可执行文件，接下来我们通过对比.o文件以及a.out文件中符号的差异来分析重定位的过程。</p><p>首先，我们通过objdump看一下此时目标文件里的反汇编是什么样子的。</p><pre><code># objdump -S example.o\n0000000000000000 &lt;global_func&gt;:\n   0:   55                      push   %rbp\n   1:   48 89 e5                mov    %rsp,%rbp\n   4:   b8 0a 00 00 00          mov    $0xa,%eax\n   9:   5d                      pop    %rbp\n   a:   c3                      retq\n \n000000000000000b &lt;static_func&gt;:\n   b:   55                      push   %rbp\n   c:   48 89 e5                mov    %rsp,%rbp\n   f:   b8 14 00 00 00          mov    $0x14,%eax\n  14:   5d                      pop    %rbp\n  15:   c3                      retq\n \n0000000000000016 &lt;main&gt;:\nint main() {\n  16:   55                      push   %rbp\n  17:   48 89 e5                mov    %rsp,%rbp\n  1a:   48 83 ec 20             sub    $0x20,%rsp\n    int var0 = extern_var;\n  1e:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 24 &lt;main+0xe&gt;\n  24:   89 45 e8                mov    %eax,-0x18(%rbp)\n    int var1 = global_var;\n  27:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 2d &lt;main+0x17&gt;\n  2d:   89 45 ec                mov    %eax,-0x14(%rbp)\n    int var2 = static_var;\n  30:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 36 &lt;main+0x20&gt;\n  36:   89 45 f0                mov    %eax,-0x10(%rbp)\n    int var3 = extern_func();\n  39:   b8 00 00 00 00          mov    $0x0,%eax\n  3e:   e8 00 00 00 00          callq  43 &lt;main+0x2d&gt;\n  43:   89 45 f4                mov    %eax,-0xc(%rbp)\n    int var4 = global_func();\n  46:   b8 00 00 00 00          mov    $0x0,%eax\n  4b:   e8 00 00 00 00          callq  50 &lt;main+0x3a&gt;\n  50:   89 45 f8                mov    %eax,-0x8(%rbp)\n    int var5 = static_func();\n  53:   b8 00 00 00 00          mov    $0x0,%eax\n  58:   e8 ae ff ff ff          callq  b &lt;static_func&gt;\n  5d:   89 45 fc                mov    %eax,-0x4(%rbp)\n  …\n} \n</code></pre><p>由于空间的限制，我只保留了main函数中源码与汇编码对应的部分内容。你需要注意的是，上边源码与汇编的对应，需要在编译.o文件时打开-g选项，否则就只有汇编代码。</p><p>下面我们来分类讨论各种符号的处理方式。</p><h4>各种符号的处理方式</h4><p><strong>首先，我来看看局部变量的处理过程</strong>。从反汇编的结果里，我们可以看到，局部变量在程序中的地址，都是基于%rbp的偏移这种形式，rbp寄存器存放的是当前函数栈帧的基地址。这些局部变量的内存分配与释放，都是在运行时通过%rbp的改变来进行的，因此，局部变量的内存地址不需要链接器来操心。</p><p><strong>然后，再来看看比较简单的static_func，它是唯一不需要重定位的类型</strong>。对static_func的调用，所生成的指令的二进制是 e8 ae ff ff ff。其中，e8是callq指令的编码，后边4个字节就对应被调函数的地址。注意，这里生成的ae ff ff ff，如果采用小端的字节序数值来表示，应该是0xffffffae，也就是对应十进制的-82。</p><p>此时，当CPU执行到callq这条指令时，rip寄存器的值指向的是下一条指令的内存地址，也就是5d这条指令的内存地址，通过计算0x5d – 82可以得到0xb。从反汇编中可以得到，0xb刚好是static_func的地址。static_func的链接原理，你可以参考下面这幅图：</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/3f/ae5b19734d342453826b41538d2d603f.jpg?wh=2284x1304\" alt=\"\"></p><p>从上图中可以看出，同一个编译单元内部，static_func与main函数的相对位置是固定不变的，即便链接的过程中会对不同.o文件中的代码段进行合并，但是同一个.o文件内部不同函数之间的位置也会保持不变，因此，我们在编译的时候，就能确定对静态函数调用的偏移。也就是说，静态函数的调用地址在编译阶段就可以确定下来。</p><p>我们可以在最终生成的可执行文件的main函数中，查看对应位置代码的反汇编。可以验证的是，这里确实没有进行重定位的修正：</p><pre><code>0000000004004ad &lt;main&gt;:\n  ...\n  4004ef:       e8 ae ff ff ff          callq  4004a2 &lt;static_func&gt;\n  ... \n</code></pre><p><strong>接下来，我们再看第三类符号，也就是外部变量、全局变量以及静态变量的处理过程</strong>。你可以从反汇编结果中看到，前三条语句对extern_var、global_var和static_var的访问，都生成了一条 mov 0x0(%rip)，%eax的指令。这是因为在这个时候，编译器还无法确定这三个变量的地址，因此，这里先通过0来进行占位，以后链接器会将真正的地址回填在这里。</p><p><strong>最后，我们来看对于extern_func和global_func的调用</strong>，call指令同样是通过0来进行占位，这和全局变量的处理方式一样。</p><h4>处理占位符</h4><p>我们前面说到，在无法确定变量的真实地址时，先通过0来进行占位。所以，我们这里继续观察链接器对extern_var，static_var，global_var，global_func以及extern_func的重定位过程，看看它们的占位符是如何处理的。</p><p>这里我们需要通过readelf工具来查看一下目标文件里有哪些信息：</p><pre><code># readelf -S example.o\nThere are 12 section headers, starting at offset 0x478:\n \nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .text             PROGBITS         0000000000000000  00000040\n       000000000000007e  0000000000000000  AX       0     0     1\n  [ 2] .rela.text        RELA             0000000000000000  00000358\n       0000000000000078  0000000000000018   I       9     1     8\n  [ 3] .data             PROGBITS         0000000000000000  000000c0\n       0000000000000004  0000000000000000  WA       0     0     4\n  [ 4] .bss              NOBITS           0000000000000000  000000c4\n       0000000000000004  0000000000000000  WA       0     0     4\n  [ 5] .comment          PROGBITS         0000000000000000  000000c4\n       000000000000002a  0000000000000001  MS       0     0     1\n  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000ee\n       0000000000000000  0000000000000000           0     0     1\n  [ 7] .eh_frame         PROGBITS         0000000000000000  000000f0\n       0000000000000078  0000000000000000   A       0     0     8\n  [ 8] .rela.eh_frame    RELA             0000000000000000  000003d0\n       0000000000000048  0000000000000018   I       9     7     8\n  [ 9] .symtab           SYMTAB           0000000000000000  00000168\n       0000000000000180  0000000000000018          10    10     8\n  [10] .strtab           STRTAB           0000000000000000  000002e8\n       000000000000006b  0000000000000000           0     0     1\n  [11] .shstrtab         STRTAB           0000000000000000  00000418\n       0000000000000059  0000000000000000           0     0     1\n</code></pre><p>其中的readelf -S选项是打印出二进制文件中所有section-header的信息。我们可以看到example.o里总共包含了12个section，其中，.text段、.data段和.bss段我在前面的课程里都提到过，这里我们重点看下.rela.text段。</p><p>从section-header的信息里可以看到，.rela.text段的类型是RELA类型，也就是重定位表。我们在前面讲到，链接器在处理目标文件的时候，需要对目标文件里代码段和数据段引用到的符号进行重定位，而这些重定位的信息都记录在对应的重定位表里。</p><p>一般来说，重定位表的名字都是以.rela开头，比如.rela.text就是对.text段的重定位表，.rela.data是对.data段的重定位表。因为我们的例子中并没有涉及.data段的重定位，所以，在上面打印的信息中没有出现.rela.data段。</p><p>好了，接下来我们具体看一下.rela.text重定位表里的内容。你可以通过readelf -r选项来打印二进制文件中的重定位表信息，输出如下：</p><pre><code>Relocation section '.rela.text' at offset 0x330 contains 5 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000020  000d00000002 R_X86_64_PC32     0000000000000000 extern_var - 4\n000000000029  000a00000002 R_X86_64_PC32     0000000000000000 global_var - 4\n000000000032  000300000002 R_X86_64_PC32     0000000000000000 .data + 0\n00000000003f  000e00000002 R_X86_64_PC32     0000000000000000 extern_func - 4\n00000000004c  000b00000002 R_X86_64_PC32     0000000000000000 global_func - 4\n</code></pre><p>.rela.text的重定位表里存放了text段中需要进行重定位的每一处信息。所以，每个重定位项都会包含需要重定位的偏移、重定位类型和重定位符号。重定位表的数据结构是这样的：</p><pre><code>  typedef struct {\n    Elf64_Addr›   r_offset; /* 重定位表项的偏移地址 */\n    Elf64_Xword›  r_info;   /* 重定位的类型以及重定位符号的索引 */\n    Elf64_Sxword› r_addend; /* 重定位过程中需要的辅助信息 */\n  } Elf64_Rela;\n</code></pre><p>其中，r_info的高32bit存放的是重定位符号在符号表的索引，r_info的低32bit存放的是重定位的类型的索引。符号表就是.symtab段，可以把它看成是一个字典，这个字典以整数为key，以符号名为value。</p><p>在我们的例子中，根据上文的汇编代码来看，.rela.text段中的重定位表总共有5项，分别对应到.text的0x20, 0x29, 0x32, 0x3f, 0x4c偏移处。我们以0x20为例，它对应的汇编指令是0x1e位置的8b 05 00 00 00 00。0x20指向的是这条指令的操作数，在没有重定位之前，它是一个四字节填充的0，对应的是对变量extern_var的访问。</p><p>同样地，其余的几处偏移位置分别是访问global_var、static_var、global_func和extern_func这四个符号（函数和变量都可统一看成是符号）的地方。</p><p>接下来，我们着重分析这四个符号的重定位过程。我们可以看到重定位表中的这四项，<strong>它们的类型都是R_X86_64_PC32。这种类型的重定位计算方式为：S + A – P</strong>。</p><ul>\n<li>\n<p>这里的S表示完成链接后该符号的实际地址。在链接器将多个中间文件的段合并以后，每个符号就按先后顺序依次都会分配到一个地址，这就是它的最终地址S。</p>\n</li>\n<li>\n<p>A表示Addend的值，它代表了占位符的长度。它的具体用法我们下文还会详细分析。</p>\n</li>\n<li>\n<p>P表示要进行重定位位置的地址或偏移，可以通过r_offset的值获取到，这是引用符号的地方，也就是我们要回填地址的地方，简单说，它就是我们上文提到的用0填充的占位符的地址。</p>\n</li>\n</ul><p>这里S与P所表示的地址都是文件合并之后最终的虚拟地址，由于我们无法获取链接器中间过程的文件，所以，我们需要通过查看链接完成后的可执行文件，来寻找这两个地址。</p><p>我们以extern_var的变量为例，具体跟踪一遍重定位的过程。</p><pre><code>00000000004004ad &lt;main&gt;:\n  4004ad:       55                      push   %rbp\n  4004ae:       48 89 e5                mov    %rsp,%rbp\n  4004b1:       48 83 ec 20             sub    $0x20,%rsp\n  4004b5:       8b 05 75 0b 20 00       mov    0x200b75(%rip),%eax        # 601030 &lt;extern_var&gt;\n  4004bb:       89 45 e8                mov    %eax,-0x18(%rbp)\n</code></pre><p>上边输出部分是对生成可执行文件的反汇编。根据S、A、P的定义，我们知道对于extern_var来讲：</p><ul>\n<li>S是其最终符号的真实地址，如上汇编里边的注释所示  也就是上面注释的0x601030这个地址；</li>\n<li>A是Addend的值，可以从重定位表里查到是-4，对于A的具体含义我还会进一步解释；</li>\n<li>P是重定位offset的地址，这里是0x4004b7。</li>\n</ul><p>根据公式，我们算出重定位处需要填写的值应该是 0x601030 + (-4) – 0x4004b7 = 0x200b75，也就是最终可执行文件中这条mov指令里的值。</p><p>到目前为止，我们从链接器的视角推出了最终重定位位置的值，你可能会比较迷糊：系统为什么搞这么一套复杂的公式来计算出这么一个值呢？这个值的真正含义是什么？</p><p>针对这个问题，我们再从CPU的角度来看下这里的取值关系。从上面main函数的反编译的结果可以看到，我们最终对extern_var的访问生成的汇编是：</p><pre><code>mov    0x200b75(%rip), %eax\n</code></pre><p>这是一条PC相对偏移的寻址方式。当CPU执行到这条指令的时候，%rip的值存放的是下一条指令的地址，也就是0x4004bb。这时候可以算出0x4004bb + 0x200b75 = 0x601030，刚好是extern_var的实际地址。</p><p>经过正面分析这个重定位的值的作用后，这里我们再来理解一下S+A-P这个公式的作用。链接器有了整体的虚拟内存布局后，知道的信息是：需要重定位符号的地址S的值是(0x601030)，以及需要重定位的位置地址P的值是(0x4004b7)。</p><p>这时候，链接器需要在指令中占位符的位置填一个值，让程序运行的时候能够找到S。但程序运行到这条指令的时候，能够拿到的地址就只有PC的值，也就是下一条指令的地址(0x4004bb)。你会发现，重定位地址的值跟下一条pc的值，相差的就是这个Addend(-4)，这个Addend实际上就是用来调整P的值和执行时PC的值之间的差异的，所以它刚好就是占位符的宽度。</p><h4>静态变量</h4><p>除了上述所讲的四个符号之外，还有一个比较特殊的是static_var变量。我们可以从Sym. Name里找到其余变量的符号，但static_var的符号没有出现，只有一个.data的符号。</p><p>这是因为static_var变量本身是一个静态变量，只在本编译单元内可见，不会对外进行暴露，所以它是根据本编译单元的.data段的地址来进行重定位。也就是说，<strong>static_var的最终地址就是本编译单元的.data段的最终地址</strong>。所以，它的重定义方法与extern_var等符号的重定位方法是一样的，区别仅仅在于它的符号被隐藏了。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/be/2e29c9c26a715015ce08d3946dee6fbe.jpg?wh=2284x1032\" alt=\"\"></p><p>你可能会有疑问，既然静态函数可以在编译的时候确定相对偏移，那为什么静态变量做不到这一点呢？</p><p>这是因为静态变量的位置是在data段，而对静态函数的访问是在text段。对应text段内部的偏移可以保证在链接的过程中不发生改变，但由于text段和data段分属不同的段，在链接的时候大概率会进行重新排布，所以它和引用它的地方之间的相对位置就发生变化了。所以静态变量的地址就需要链接器来进行重定位了。</p><p>好，到这里我们就对整个重定位的过程有了清晰的了解。</p><h3>总结</h3><p>我们今天讲解了在静态链接过程中，变量与内存地址是如何对应起来的。其中，链接器的重定位操作是这个过程中的核心步骤。</p><p>我们说，从源文件生成二进制可执行文件，这一过程主要包含了编译和链接两个步骤。其中，编译的作用是生成性能优越的机器码。对于编译单元内部的静态函数，可以在编译时通过相对地址的办法，生成call指令，因为无论将来调用者和被调用者被安置到什么地方，它们之间的相对距离不会发生变化。</p><p>而其他类型的变量和函数在编译时，编译器并不知道它们的最终地址，所以只能使用占位符（比如0）来临时代替目标地址。</p><p>而链接器的任务是为所有变量和函数分配地址，并把被分配到的地址回写到调用者处。链接的过程主要分为两步，第一步是多文件合并，同时为符号分配地址，第二步则是将符号的地址回写到引用它的地方。其中，地址回写有一个专门的名字叫做重定位。重定位的过程依赖目标文件中的重定位表。</p><p>到这里，我们已经对例子中的几种不同类型符号的静态链接有了一个清晰的认识。下面的课程我会继续讲解loader和动态链接的过程。</p><h3>思考题</h3><p>经过了这节课的学习，我们深刻地理解了全局变量，静态变量的用法。请你思考一下，全局变量和静态变量的初值是在哪个阶段决定的？更具体地说，是编译、链接、加载和运行这四个阶段中的哪一个阶段决定的？或者你也可以进行这样的思考，我们在目标文件、可执行文件和运行时内存里，能不能观察到全局变量和静态变量的初始值？欢迎你在留言区和我交流你的想法，我在留言区等你。</p><p><img src=\"https://static001.geekbang.org/resource/image/78/3a/78039e07de9e869b6e966da9a61e963a.jpg?wh=2284x1523\" alt=\"\"><br>\n好啦，这节课到这就结束啦。欢迎你把这节课分享给更多对计算机内存感兴趣的朋友。我是海纳，我们下节课再见！</p>","comments":[{"had_liked":false,"id":320301,"user_name":"keepgoing","can_delete":false,"product_type":"c1","uid":1471387,"ip_address":"","ucode":"A2FE0687FB17E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/73/9b/67a38926.jpg","comment_is_top":false,"comment_ctime":1636209757,"is_pvip":false,"replies":[{"id":"116153","content":"总结得真好！来，来，来，笔给你，你来写。哈哈哈。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636279556,"ip_address":"","comment_id":320301,"utype":1}],"discussion_count":2,"race_medal":0,"score":"113305359453","product_id":100094901,"comment_content":"自己的话总结：<br><br>1. 静态函数不需要重定位因为和执行单元代码都在.text段，相对位置在编译的时候就能确定了，因为链接器合并中间文件时相对位置不会变。<br>2. 静态变量需要重定位，因为和编译单元代码段.text分属不同的section，在.data，链接器合并文件时会重新排布，所以需要重定位。<br>3. 全局变量&#47;函数，外部变量&#47;函数都是需要被重定位的，大致方法就是：<br>编译器先用0占位符号、链接重定位表找符号、定位符号地址、然后在当前代码段计算RIP相对偏移位置填上。<br><br>编译器：生成机器码、符号0占位<br>链接器：合并文件，分配符号地址，给符号地址写回编译出的代码","like_count":27,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529949,"discussion_content":"总结得真好！来，来，来，笔给你，你来写。哈哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636279556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2304123,"avatar":"","nickname":"Geek_ed84ef","note":"","ucode":"D64973A23FCAA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":587544,"discussion_content":"老师，请教一下，对于example.c中的全局函数global_func，当本编译单元内引用它时，为什么不能像静态函数那样使用相对偏移解析符号呢？他们不是都处于text段吗？这样就不需要链接器来进行重定位了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663139090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":529949,"ip_address":"广东"},"score":587544,"extra":""}]}]},{"had_liked":false,"id":320304,"user_name":"慢动作","can_delete":false,"product_type":"c1","uid":1133945,"ip_address":"","ucode":"62C944F4A4D8AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","comment_is_top":false,"comment_ctime":1636211522,"is_pvip":true,"replies":[{"id":"116152","content":"S是绝对地址，而S+A-P算出来的是相对地址。使用相对地址的好处是只要引用者和被引用者的相对位置不变，那么它们就可以被安排到任意的位置上。这就可以支持加载地址随机化等安全增强技术啦。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636279520,"ip_address":"","comment_id":320304,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48880851778","product_id":100094901,"comment_content":"为什么要S＋A－P，直接用S有什么不好的？","like_count":12,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529950,"discussion_content":"S是绝对地址，而S+A-P算出来的是相对地址。使用相对地址的好处是只要引用者和被引用者的相对位置不变，那么它们就可以被安排到任意的位置上。这就可以支持加载地址随机化等安全增强技术啦。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636279520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702566,"avatar":"","nickname":"GEEKBANG_6400905","note":"","ucode":"1F89B6CBD3FB00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586629,"discussion_content":"我觉得应该这么理解，怎么计算取决于你是怎么引用的，你引用的指令采用绝对地址就是绝对地址，你引用的地方采用相对地址就是相对地址，mov    0x0(%rip),%eax指令其本身就是采用相对地址寻址方式，所以你要放一个相对地址进去，这样才能正确找到extern_var变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662383695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321210,"user_name":"鵼","can_delete":false,"product_type":"c1","uid":1101766,"ip_address":"","ucode":"F6561743835F7E","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/c6/6a2d0a5e.jpg","comment_is_top":false,"comment_ctime":1636708713,"is_pvip":false,"replies":[{"id":"117076","content":"very good:)","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637375555,"ip_address":"","comment_id":321210,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14521610601","product_id":100094901,"comment_content":"全局变量和静态变量的初值在编译阶段吧。初始值应该都在.data段。链接的主要工作是合并目标文件以及重定向符号。可以看到重定向是进行地址的转换。目标文件中，可以看到变量和函数的地址都用0占位，静态方法除外，因为静态方法是计算的相对偏移量，地址怎么变无所谓，偏移量是固定的。但是链接主要是符号地址转化，并不代表是值，值应该是在 data段保存好的，只是通过链接把地址值回填。因此，我猜测是编译阶段，目标文件应该是能看到初始值的。对于数组类型的全局变量，因为都是0，所以放在bss段，应该是在加载的时候再分配内存吧，这个应该是在加载的时候决定吧。","like_count":4,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531656,"discussion_content":"very good:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637375555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153978,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","nickname":"Linuxer","note":"","ucode":"272D9D8089C3D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547605,"discussion_content":"基本类型可以理解，请问如果是类实例呢？谁去负责调用构造方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642764730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2839104,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/52/40/1fe5be2b.jpg","nickname":"联通","note":"","ucode":"EAA1331CFAFDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1153978,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","nickname":"Linuxer","note":"","ucode":"272D9D8089C3D6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551355,"discussion_content":"类实例化的时候才会调用构造方法，也就是程序运行的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644996573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547605,"ip_address":""},"score":551355,"extra":""}]}]},{"had_liked":false,"id":320767,"user_name":"郑童文","can_delete":false,"product_type":"c1","uid":1030733,"ip_address":"","ucode":"3D193715CB8549","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg","comment_is_top":false,"comment_ctime":1636508248,"is_pvip":false,"replies":[{"id":"116618","content":"栈是在用户空间的顶部，这是操作系统决定的位置。对于编译器和链接器来说，栈基址在哪里都是可以的。因为对栈的操作都是通过栈顶指针完成的。只要栈顶的数据是对的，就都是对的。堆的起始边界是brk指针决定的。而brk是代码段长度+数据段长度+bss段长度决定的。当加载器在加载各个段的时候会计算brk指针的。所以答案是文件中不用保存，但加载器会根据文件中的信息去计算brk指针。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636698647,"ip_address":"","comment_id":320767,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10226442840","product_id":100094901,"comment_content":"谢谢老师对我前一个问题的回答，可能我当时没有表达清楚。 再接着问一下。 我的意思是栈和堆区域在虚拟内存布局的起始虚拟地址（也就是它们的起始边界）是如何确定的？ 会保存在可执行文件中吗？ 谢谢！","like_count":2,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530104,"discussion_content":"栈是在用户空间的顶部，这是操作系统决定的位置。对于编译器和链接器来说，栈基址在哪里都是可以的。因为对栈的操作都是通过栈顶指针完成的。只要栈顶的数据是对的，就都是对的。堆的起始边界是brk指针决定的。而brk是代码段长度+数据段长度+bss段长度决定的。当加载器在加载各个段的时候会计算brk指针的。所以答案是文件中不用保存，但加载器会根据文件中的信息去计算brk指针。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636698647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2170263,"avatar":"https://static001.geekbang.org/account/avatar/00/21/1d/97/9a8b2d0c.jpg","nickname":"🙃","note":"","ucode":"6E41B3D10A33CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413677,"discussion_content":"堆栈区的起始地址不会保存在可执行文件中，因为堆栈可以看做是进程的地址空间资源，也就是由操作系统管理的内存空间，具体的进程空间分配可以参考《程序员的自我修养》第六章——可执行文件的装载与进程。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636539558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324739,"user_name":"小时候可鲜啦","can_delete":false,"product_type":"c1","uid":1050777,"ip_address":"","ucode":"C88B3EDF758230","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","comment_is_top":false,"comment_ctime":1638597325,"is_pvip":false,"replies":[{"id":"117857","content":"已修复，谢谢","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1638719752,"ip_address":"","comment_id":324739,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5933564621","product_id":100094901,"comment_content":"小标题静态变量和总结之间的那张讲述静态变量重定位的示意图中（有错误）：<br>227地址处的指令长度应该为6字节：8b 05 00 00 00 00, 那么根据OFFSET = S + A - P = (102 + (- 4) -  227） = 0x12D 而不是图中的0x12C","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536236,"discussion_content":"已修复，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638719752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1026818,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/02/8688abed.jpg","nickname":"nightn","note":"","ucode":"39FC4FF0281637","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":536744,"discussion_content":"「小时候可鲜啦」同学的计算过程有点小问题。static_var 的地址是 0x100，即 S 是 0x100，这条 mov 指令的地址是 0x227，共 6 字节，需要重定位的是这条指令的后 4 个字节，因此重定位入口是 0x229，即 P 是 0x229。A 是 -4。计算结果为：S + A - P = (0x100 + (-4) - 0x229) = 0x12D。另外有个疑惑想请教一下海纳老师，addend 是 PC 到重定位入口的距离，文章也提到 addend 代表了占位符的长度。如果需要重定位的那几个字节并不位于指令的末端，而是位于指令的中间，那么 addend 和占位符长度就不一样了吧？（比如这样一条指令：xx 00 00 00 00 xx，一共 6 字节，中间 4 字节需要重定位，addend 应该是 -5，但占位符长度是 4）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638860982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536236,"ip_address":""},"score":536744,"extra":""}]}]},{"had_liked":false,"id":322559,"user_name":"杨军","can_delete":false,"product_type":"c1","uid":1988156,"ip_address":"","ucode":"AF881224E54C14","user_header":"https://static001.geekbang.org/account/avatar/00/1e/56/3c/f9ff3ed8.jpg","comment_is_top":false,"comment_ctime":1637481570,"is_pvip":false,"replies":[{"id":"117189","content":"从注释里看到的。objdump在反编译的时候，会把地址放在注释里给你看。实际上，反编译的过程就是从文件中把这些信息读出来并展示给你的过程。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637587601,"ip_address":"","comment_id":322559,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5932448866","product_id":100094901,"comment_content":"老师，S+A-P，这里的S 是其最终符号的真实地址，也就是 0x601030 ；A 是 Addend 的值，可以从重定位表里查到是 -4，；P 是重定位 offset 的地址，这里是 0x4004b7。0x601030，0x4004b7可以从哪里查到了？","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532371,"discussion_content":"从注释里看到的。objdump在反编译的时候，会把地址放在注释里给你看。实际上，反编译的过程就是从文件中把这些信息读出来并展示给你的过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637587601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019138,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","nickname":"liu_liu","note":"","ucode":"24283806A07759","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532844,"discussion_content":"在未链接时，可以看到 1e: 8b 05 00 00 00 00 需要重定位地址是 0x20（1e 后两个字节），相对于 main 的偏移是 0x20 - 0x16 = 0xa；\n\n在链接后，main 的地址变成 0x4004ad，那么需要重定位符号的地址变成：0x4004ad + 0xa = 0x4004b7。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1637718538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320804,"user_name":"Geek_27eb54","can_delete":false,"product_type":"c1","uid":2715118,"ip_address":"","ucode":"7D1EE10A61C7C0","user_header":"","comment_is_top":false,"comment_ctime":1636515338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5931482634","product_id":100094901,"comment_content":"海纳老师，您好，我在分析程序装载过程中有几个疑问:<br>readelf -l 查看程序,有以下内容<br>```<br>TYPE    Offset         VirtAddr          PhysAddr       FileSiz         MemSiz      Flg   Align<br>LOAD   0x000000   0x00000000   0x00000000   0x12272c    0x12272c    R E  0X1000<br>LOAD   0x122814   0x00123814   0x00123814   0x04bdc      0x7210        RW  0x1000<br>...<br>00 .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini.rodata .eh_frame_hdr .eh_frame<br>01 .init_array .fini_array .jcr .data.rel.ro .dynamic .got .got.plt .data .bss<br>```<br>加载到内存中后，<br>```<br>7dcef000 -7de12000 r-xp 00000000 08:01 1598491     &#47;lib&#47;i386-linux-gnu&#47;libSDL2-2.0.so.0.4.0<br>7de12000-7de15000 r--p  00122000 08:01 1598491    &#47;lib&#47;i386-linux-gnu&#47;libSDL2-2.0.so.0.4.0<br>7de15000-7de18000 rw-p 00125000 08:01 1598491   &#47;lib&#47;i386-linux-gnu&#47;libSDL2-2.0.so.0.4.0<br>7de18000-7de1a000 rw-p 00000000 00:00 0<br>```<br>q1: readelf -l读取的信息中，第二段中的filesize跟memsize为什么不一样？ld链接器加载过程中申请内存应该按照哪个去申请?<br>q2: elf中显示需要加载两个段，但是实际上有3次文件映射，其中第一第二次是否就是elf中加载的第一个段，为什么会映射两次？<br>q3: 第3次文件映射是否就是elf中的第二个需要加载的段，这里文件映射的大小是0x3000，明显小于elf中显示的需要的大小，这块又是怎么回事？第4次匿名映射是否也是加载了文件映射?","like_count":1},{"had_liked":false,"id":346006,"user_name":"后视镜","can_delete":false,"product_type":"c1","uid":1250406,"ip_address":"","ucode":"0975031017BA02","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/66/70a6a206.jpg","comment_is_top":false,"comment_ctime":1652763731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652763731","product_id":100094901,"comment_content":"本来想问是不是下面的情况不需要PIC了，后来在深入研究发现了一下，老师帮忙看下是不是不是对的。<br><br>我理解动态库里面可能会需要GOT表来处理依赖。但一个main.c依赖了一个libfoo.so，而libfoo.so不依赖任何其他库动态库了，我手动测试了下：<br><br> ```<br> readelf -S main<br> [21] .got              PROGBITS        0804bffc 002ffc 000004 04  WA  0   0  4<br>  [22] .got.plt          PROGBITS        0804c000 003000 000014 04  WA  0   0  4<br>  [23] .data             PROGBITS        0804c014 003014 00000c 00  WA  0   0  4<br>   [24] .bss              NOBITS          0804c020 003020 000008 00  WA  0   0  4<br>```<br>```<br> objdump  -d .&#47;main | grep &quot;&lt;main&gt;&quot; -A 15<br><br> 8049173:       a1 1c c0 04 08          mov    0x804c01c,%eax<br> 8049178:       89 45 f4                mov    %eax,-0xc(%ebp)<br> 804917b:       a1 20 c0 04 08          mov    0x804c020,%eax ; my_var 外部变量<br> 8049180:       89 45 f0                mov    %eax,-0x10(%ebp)<br>```<br>```<br>objdump -s -d main<br>Contents of section .got:<br> 804bffc 00000000                             ....<br>Contents of section .data:<br> 804c014 00000000 00000000 0a000000           ............<br>Contents of section .comment:<br> 0000 4743433a 20284465 6269616e 20382e33  GCC: (Debian 8.3<br> 0010 2e302d36 2920382e 332e3000           .0-6) 8.3.0.<br>```<br><br>```<br>readelf -r main<br>Relocation section &#39;.rel.dyn&#39; at offset 0x300 contains 2 entries:<br> Offset     Info    Type            Sym.Value  Sym. Name<br>0804bffc  00000206 R_386_GLOB_DAT    00000000   __gmon_start__<br>0804c020  00000405 R_386_COPY        0804c020   my_var<br>```<br>main程序编译后，我虽然用readelf -S main看到.got，但引用动态库的变量my_var我看到地址还是落在.bss段查找了一下，发现说是在链接的时候会从共享库复制到可执行文件中的已分配空间。<br><br>&gt;将在动态可执行文件的 .bss 中分配空间，空间的大小等于共享库中的数据项的大小。还为此空间指定在共享库中定义的符号名称。分配此数据时，链接编辑器会生成特殊的复制重定位记录，指示运行时链接程序将数据从共享库复制到动态可执行文件中的已分配空间。<br><br>","like_count":0},{"had_liked":false,"id":331900,"user_name":"Geek_Lawrence","can_delete":false,"product_type":"c1","uid":1578549,"ip_address":"","ucode":"B4EF5B124AF082","user_header":"","comment_is_top":false,"comment_ctime":1642859631,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1642859631","product_id":100094901,"comment_content":"请问机器码是如何驱动cpu内存等硬件执行的？","like_count":0,"discussions":[{"author":{"id":2839104,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/52/40/1fe5be2b.jpg","nickname":"联通","note":"","ucode":"EAA1331CFAFDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551357,"discussion_content":"不是机器码驱动cpu等硬件，是cpu中的有个pc指针读取机器码中的指令执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644996649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327024,"user_name":"i Love 3🍀","can_delete":false,"product_type":"c1","uid":2336991,"ip_address":"","ucode":"3AC31D3B2BA6FE","user_header":"https://static001.geekbang.org/account/avatar/00/23/a8/df/f3eaf89e.jpg","comment_is_top":false,"comment_ctime":1639843349,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1639843349","product_id":100094901,"comment_content":"“P 是重定位 offset 的地址，这里是 0x4004b7。”，问一下0x4004b7这个地址是哪里得出来的？谢谢","like_count":0,"discussions":[{"author":{"id":2419502,"avatar":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","nickname":"柒","note":"","ucode":"D41241629321A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547179,"discussion_content":"P是这个变量/函数的offest地址，你看那段代码，就是在0x4004b5，所以变量就是在0x4004b7了。opcode占了两个字节，操作数（即变量）占用后面4个字节。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1642570179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325446,"user_name":"喵吉豆豆","can_delete":false,"product_type":"c1","uid":1144651,"ip_address":"","ucode":"1F3322FF5EDF58","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/4b/ede8aa13.jpg","comment_is_top":false,"comment_ctime":1638958945,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1638958945","product_id":100094901,"comment_content":"同一个文件内的函数之间的位置关系在合并的过程中也会改变吗？如果不变，这样之间的函数调用为什么不可以像静态函数一样处理呢？","like_count":0,"discussions":[{"author":{"id":2419502,"avatar":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","nickname":"柒","note":"","ucode":"D41241629321A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540779,"discussion_content":"它被其他文件的函数引用的时候，他们之间就不能用相对位置了呀，都属于两个不同的.o文件了，鬼知道他们的text段合并的先后顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640165478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235551,"avatar":"https://static001.geekbang.org/account/avatar/00/12/da/5f/3c68103d.jpg","nickname":"郭梓良","note":"","ucode":"50E57E6A723E14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538239,"discussion_content":"静态函数只能在本文件被调用，而其他函数有可能被其他文件调用，感觉是这个原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639378481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324742,"user_name":"小时候可鲜啦","can_delete":false,"product_type":"c1","uid":1050777,"ip_address":"","ucode":"C88B3EDF758230","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","comment_is_top":false,"comment_ctime":1638599843,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1638599843","product_id":100094901,"comment_content":"对于静态变量的S值（最终地址）得获取有疑问：<br>static_var 的最终地址就是本编译单元的.data 段的最终地址。<br>在本地的测试中 readelf -S a.out获得的.data的地址为0x601018，而用objdump -S a.out获得的反汇编中可以看到static_var对应的真实地址值为0x601030，两者不一致。","like_count":0,"discussions":[{"author":{"id":1959822,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","nickname":"Spoon","note":"","ucode":"2FF9193AD482C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590705,"discussion_content":"我也发现了这个问题。。。。可以交流一下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666018618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324379,"user_name":"IT小僧","can_delete":false,"product_type":"c1","uid":1036906,"ip_address":"","ucode":"4DC9B291AAD748","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/6a/a9039139.jpg","comment_is_top":false,"comment_ctime":1638409323,"is_pvip":true,"replies":[{"id":"117799","content":"一般来说，是为了让栈帧对齐，有利于加速访存速度。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1638537809,"ip_address":"","comment_id":324379,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638409323","product_id":100094901,"comment_content":"老师，请教个跑题的问题，上面main函数有6个整形变量，共需24字节内存，为啥编译器会预分配内存空间sub    $0x20,%rsp，分配了32字节呢？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535767,"discussion_content":"一般来说，是为了让栈帧对齐，有利于加速访存速度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638537809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322633,"user_name":"姑射仙人","can_delete":false,"product_type":"c1","uid":1008517,"ip_address":"","ucode":"3EFC1F3E592165","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","comment_is_top":false,"comment_ctime":1637506896,"is_pvip":false,"replies":[{"id":"117270","content":"java也有符号解析的过程。基本原理和第8课里说的运行时解析比较相似。符号的地址都是运行时得到的。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637733559,"ip_address":"","comment_id":322633,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637506896","product_id":100094901,"comment_content":"Java语言的编译和链接和这个不一样吧，还有JVM里应该没有虚拟内存的概念，大家都在一个内存空间内。那些字变量的地址什么的，是在什么时候确定的？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532923,"discussion_content":"java也有符号解析的过程。基本原理和第8课里说的运行时解析比较相似。符号的地址都是运行时得到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637733559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322236,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1637251602,"is_pvip":false,"replies":[{"id":"117043","content":"不如自己动手试一下？你可以通过cat命令，查看&amp;#47;proc&amp;#47;pid&amp;#47;map和&amp;#47;proc&amp;#47;pid&amp;#47;smap文件，看看他们的各个字段的作用。它的信息是非常全面的，我这里无法一一列举。你可以通过man命令进行学习。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637325462,"ip_address":"","comment_id":322236,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637251602","product_id":100094901,"comment_content":"我经常听人说要查看一下map文件，请问老师map文件有什么作用呢？查看map文件能看出什么？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531499,"discussion_content":"不如自己动手试一下？你可以通过cat命令，查看&amp;#47;proc&amp;#47;pid&amp;#47;map和&amp;#47;proc&amp;#47;pid&amp;#47;smap文件，看看他们的各个字段的作用。它的信息是非常全面的，我这里无法一一列举。你可以通过man命令进行学习。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637325462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322199,"user_name":"我是内存","can_delete":false,"product_type":"c1","uid":1711838,"ip_address":"","ucode":"3D763D4F434D50","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/de/cdee1780.jpg","comment_is_top":false,"comment_ctime":1637230153,"is_pvip":false,"replies":[{"id":"117014","content":"你说的局部函数是什么？问题在于你不加static的话，C的编译器只能把它当做全局函数处理。所以我们说的局部函数时，就是指static函数。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637290991,"ip_address":"","comment_id":322199,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637230153","product_id":100094901,"comment_content":"局部函数，也就是没有导出给其他编译单元使用的那些常规函数，和静态函数一样，它们都在本编译单元的.text段内，链接的时候也是整体把本编译单元的.text和其他编译单元的.text合并，也不需要重定位吧?","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531349,"discussion_content":"你说的局部函数是什么？问题在于你不加static的话，C的编译器只能把它当做全局函数处理。所以我们说的局部函数时，就是指static函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637290991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1711838,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/1e/de/cdee1780.jpg","nickname":"我是内存","note":"","ucode":"3D763D4F434D50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":531352,"discussion_content":"嗯，后来想想好像没有局部函数这种说法。当时草率的按照全局函数全局变量，外部函数外部变量，静态函数静态变量，局部变量和局部函数来排列的。硬生生排比的造出了一个局部函数….","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637291344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531349,"ip_address":""},"score":531352,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":321222,"user_name":"鵼","can_delete":false,"product_type":"c1","uid":1101766,"ip_address":"","ucode":"F6561743835F7E","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/c6/6a2d0a5e.jpg","comment_is_top":false,"comment_ctime":1636713508,"is_pvip":false,"replies":[{"id":"117075","content":"是的。全局变量在data段，在磁盘文件中就能看到了。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637375506,"ip_address":"","comment_id":321222,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636713508","product_id":100094901,"comment_content":" readelf -S example.o<br><br>[ 3] .data             PROGBITS         0000000000000000  000000c0<br>       0000000000000008  0000000000000000  WA       0     0     4<br><br>od -Ax -t x1 -j  192 -N 8 example.o<br>0000c0 01 00 00 00 02 00 00 00<br><br>这是不是就是值初始化在编译的佐证。<br>","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531655,"discussion_content":"是的。全局变量在data段，在磁盘文件中就能看到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637375506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320625,"user_name":"郑童文","can_delete":false,"product_type":"c1","uid":1030733,"ip_address":"","ucode":"3D193715CB8549","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg","comment_is_top":false,"comment_ctime":1636426959,"is_pvip":false,"replies":[{"id":"116322","content":"不是。代码段和数据段是可以确定地址的。栈和堆是运行时，应用程序向操作系统申请来的。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636507778,"ip_address":"","comment_id":320625,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1636426959","product_id":100094901,"comment_content":"请问老师，堆和栈在虚拟内存的中的起始地址（虚拟地址）是在生成可执行文件时就确定了的吗？ 是保存在可执行文件中的吗？ 谢谢！","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530067,"discussion_content":"不是。代码段和数据段是可以确定地址的。栈和堆是运行时，应用程序向操作系统申请来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636507778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg","nickname":"郑童文","note":"","ucode":"3D193715CB8549","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413518,"discussion_content":"谢谢老师的回答，我的意思是栈和堆区域在虚拟内存布局的起始虚拟地址（也就是它们的起始边界）是如何确定的？ 会保存在可执行文件中吗？ 谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636508106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320584,"user_name":"Benjamin","can_delete":false,"product_type":"c1","uid":1940162,"ip_address":"","ucode":"C661E5358FE764","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/c2/8fcd5a2d.jpg","comment_is_top":false,"comment_ctime":1636386546,"is_pvip":false,"replies":[{"id":"116327","content":"sorry。图片有误，多谢指出。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636508265,"ip_address":"","comment_id":320584,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636386546","product_id":100094901,"comment_content":"我感觉在”静态变量“那一部分的插图有问题：<br>1）127: mov 0x127(%rip), %eax # 这里应该是一个负向的地址偏移，所以应该是-0x127<br>2）此时rip寄存器指向的是mov指令的下一条指令，假设当前mov指令(包括操作数)大小5byte，那么正确的汇编指令是：227：mov -0x12c(%rip), %eax","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530055,"discussion_content":"sorry。图片有误，多谢指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636508265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320548,"user_name":"kylin","can_delete":false,"product_type":"c1","uid":1351248,"ip_address":"","ucode":"3588B62A4F9534","user_header":"https://static001.geekbang.org/account/avatar/00/14/9e/50/21e0beca.jpg","comment_is_top":false,"comment_ctime":1636375343,"is_pvip":true,"replies":[{"id":"116329","content":"这里要记住的是重定位表的作用是描述“需要被重定位”的位置。所以它描述的是“引用”符号的地方，不是符号所在的位置。你可以试试声明一个指针变量，初始化时给他一个外部变量的地址。一定要记住，重定位表描述的是“引用者”，不是被引用者。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636509025,"ip_address":"","comment_id":320548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636375343","product_id":100094901,"comment_content":"一般来说，重定位表的名字都是以.rela 开头，比如.rela.text 就是对.text 段的重定位表，.rela.data 是对.data 段的重定位表。因为我们的例子中并没有涉及.data 段的重定位，所以，在上面打印的信息中没有出现.rela.data 段。<br>---<br>请问上面代码的 extern_var为啥不在rela.data中，而是在rela.text里面呢？静态变量不是应该在rela.data中吗？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530040,"discussion_content":"这里要记住的是重定位表的作用是描述“需要被重定位”的位置。所以它描述的是“引用”符号的地方，不是符号所在的位置。你可以试试声明一个指针变量，初始化时给他一个外部变量的地址。一定要记住，重定位表描述的是“引用者”，不是被引用者。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636509025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320231,"user_name":"kylin","can_delete":false,"product_type":"c1","uid":1351248,"ip_address":"","ucode":"3588B62A4F9534","user_header":"https://static001.geekbang.org/account/avatar/00/14/9e/50/21e0beca.jpg","comment_is_top":false,"comment_ctime":1636165639,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636165639","product_id":100094901,"comment_content":"大端和小端都是从内存的低地址向高地址顺序写入大端 先写字面值高位小端 先写字面值低位例如：0x ff ff ff ae大端 从低地址到高地址写入顺序为：ff ff ff ae小端 从低地址到高地址写入顺序为：ae ff ff ff","like_count":0}]}