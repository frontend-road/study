{"id":70891,"title":"31 | 深度和广度优先搜索：如何找出社交网络中的三度好友关系？","content":"<p>上一节我们讲了图的表示方法，讲到如何用有向图、无向图来表示一个社交网络。在社交网络中，有一个<a href=\"https://zh.wikipedia.org/wiki/%E5%85%AD%E5%BA%A6%E5%88%86%E9%9A%94%E7%90%86%E8%AE%BA\">六度分割理论</a>，具体是说，你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人。</p><p>一个用户的一度连接用户很好理解，就是他的好友，二度连接用户就是他好友的好友，三度连接用户就是他好友的好友的好友。在社交网络中，我们往往通过用户之间的连接关系，来实现推荐“可能认识的人”这么一个功能。今天的开篇问题就是，<strong><span class=\"orange\">给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？</span></strong></p><p>这就要用到今天要讲的深度优先和广度优先搜索算法。</p><h2>什么是“搜索”算法？</h2><p>我们知道，算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。这是因为，图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。</p><p>图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如今天要讲的两种最简单、最“暴力”的深度优先、广度优先搜索，还有A*、IDA*等启发式搜索算法。</p><p>我们上一节讲过，图有两种主要存储方法，邻接表和邻接矩阵。今天我会用邻接表来存储图。</p><!-- [[[read_end]]] --><p>我这里先给出图的代码实现。需要说明一下，深度优先搜索算法和广度优先搜索算法，既可以用在无向图，也可以用在有向图上。在今天的讲解中，我都针对无向图来讲解。</p><pre><code>public class Graph { // 无向图\n  private int v; // 顶点的个数\n  private LinkedList&lt;Integer&gt; adj[]; // 邻接表\n\n  public Graph(int v) {\n    this.v = v;\n    adj = new LinkedList[v];\n    for (int i=0; i&lt;v; ++i) {\n      adj[i] = new LinkedList&lt;&gt;();\n    }\n  }\n\n  public void addEdge(int s, int t) { // 无向图一条边存两次\n    adj[s].add(t);\n    adj[t].add(s);\n  }\n}\n</code></pre><h2>广度优先搜索（BFS）</h2><p>广度优先搜索（Breadth-First-Search），我们平常都简称BFS。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。理解起来并不难，所以我画了一张示意图，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/00/ea/002e9e54fb0d4dbf5462226d946fa1ea.jpg?wh=1142*759\" alt=\"\"></p><p>尽管广度优先搜索的原理挺简单，但代码实现还是稍微有点复杂度。所以，我们重点讲一下它的代码实现。</p><p>这里面，bfs()函数就是基于之前定义的，图的广度优先搜索的代码实现。其中s表示起始顶点，t表示终止顶点。我们搜索一条从s到t的路径。实际上，这样求得的路径就是从s到t的最短路径。</p><pre><code>public void bfs(int s, int t) {\n  if (s == t) return;\n  boolean[] visited = new boolean[v];\n  visited[s]=true;\n  Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n  queue.add(s);\n  int[] prev = new int[v];\n  for (int i = 0; i &lt; v; ++i) {\n    prev[i] = -1;\n  }\n  while (queue.size() != 0) {\n    int w = queue.poll();\n   for (int i = 0; i &lt; adj[w].size(); ++i) {\n      int q = adj[w].get(i);\n      if (!visited[q]) {\n        prev[q] = w;\n        if (q == t) {\n          print(prev, s, t);\n          return;\n        }\n        visited[q] = true;\n        queue.add(q);\n      }\n    }\n  }\n}\n\nprivate void print(int[] prev, int s, int t) { // 递归打印s-&gt;t的路径\n  if (prev[t] != -1 &amp;&amp; t != s) {\n    print(prev, s, prev[t]);\n  }\n  System.out.print(t + &quot; &quot;);\n}\n</code></pre><p>这段代码不是很好理解，里面有三个重要的辅助变量visited、queue、prev。只要理解这三个变量，读懂这段代码估计就没什么问题了。</p><p><strong>visited</strong>是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点q被访问，那相应的visited[q]会被设置为true。</p><p><strong>queue</strong>是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第k层的顶点都访问完成之后，才能访问第k+1层的顶点。当我们访问到第k层的顶点的时候，我们需要把第k层的顶点记录下来，稍后才能通过第k层的顶点来找第k+1层的顶点。所以，我们用这个队列来实现记录的功能。</p><p><strong>prev</strong>用来记录搜索路径。当我们从顶点s开始，广度优先搜索到顶点t后，prev数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w]存储的是，顶点w是从哪个前驱顶点遍历过来的。比如，我们通过顶点2的邻接表访问到顶点3，那prev[3]就等于2。为了正向打印出路径，我们需要递归地来打印，你可以看下print()函数的实现方式。</p><p>为了方便你理解，我画了一个广度优先搜索的分解图，你可以结合着代码以及我的讲解一块儿看。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/3a/4fea8c4505b342cfaf8cb0a93a65503a.jpg?wh=1142*653\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/ea/23/ea00f376d445225a304de4531dd82723.jpg?wh=1142*641\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/4c/39/4cd192d4c220cc9ac8049fd3547dba39.jpg?wh=1142*636\" alt=\"\"></p><p>掌握了广度优先搜索算法的原理，我们来看下，广度优先搜索的时间、空间复杂度是多少呢？</p><p>最坏情况下，终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是O(V+E)，其中，V表示顶点的个数，E表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E肯定要大于等于V-1，所以，广度优先搜索的时间复杂度也可以简写为O(E)。</p><p>广度优先搜索的空间消耗主要在几个辅助变量visited数组、queue队列、prev数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是O(V)。</p><h2>深度优先搜索（DFS）</h2><p>深度优先搜索（Depth-First-Search），简称DFS。最直观的例子就是“走迷宫”。</p><p>假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。</p><p>走迷宫的例子很容易能看懂，我们现在再来看下，如何在图中应用深度优先搜索，来找某个顶点到另一个顶点的路径。</p><p>你可以看我画的这幅图。搜索的起始顶点是s，终止顶点是t，我们希望在图中寻找一条从顶点s到顶点t的路径。如果映射到迷宫那个例子，s就是你起始所在的位置，t就是出口。</p><p>我用深度递归算法，把整个搜索的路径标记出来了。这里面实线箭头表示遍历，虚线箭头表示回退。从图中我们可以看出，深度优先搜索找出来的路径，并不是顶点s到顶点t的最短路径。</p><p><img src=\"https://static001.geekbang.org/resource/image/87/85/8778201ce6ff7037c0b3f26b83efba85.jpg?wh=1142*554\" alt=\"\"></p><p>实际上，深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。回溯思想我们后面会有专门的一节来讲，我们现在还回到深度优先搜索算法上。</p><p>我把上面的过程用递归来翻译出来，就是下面这个样子。我们发现，深度优先搜索代码实现也用到了prev、visited变量以及print()函数，它们跟广度优先搜索代码实现里的作用是一样的。不过，深度优先搜索代码实现里，有个比较特殊的变量found，它的作用是，当我们已经找到终止顶点t之后，我们就不再递归地继续查找了。</p><pre><code>boolean found = false; // 全局变量或者类成员变量\n\npublic void dfs(int s, int t) {\n  found = false;\n  boolean[] visited = new boolean[v];\n  int[] prev = new int[v];\n  for (int i = 0; i &lt; v; ++i) {\n    prev[i] = -1;\n  }\n  recurDfs(s, t, visited, prev);\n  print(prev, s, t);\n}\n\nprivate void recurDfs(int w, int t, boolean[] visited, int[] prev) {\n  if (found == true) return;\n  visited[w] = true;\n  if (w == t) {\n    found = true;\n    return;\n  }\n  for (int i = 0; i &lt; adj[w].size(); ++i) {\n    int q = adj[w].get(i);\n    if (!visited[q]) {\n      prev[q] = w;\n      recurDfs(q, t, visited, prev);\n    }\n  }\n}\n</code></pre><p>理解了深度优先搜索算法之后，我们来看，深度优先搜索的时间、空间复杂度是多少呢？</p><p>从我前面画的图可以看出，每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是O(E)，E表示边的个数。</p><p>深度优先搜索算法的消耗内存主要是visited、prev数组和递归调用栈。visited、prev数组的大小跟顶点的个数V成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是O(V)。</p><h2>解答开篇</h2><p>了解了深度优先搜索和广度优先搜索的原理之后，开篇的问题是不是变得很简单了呢？我们现在来一起看下，如何找出社交网络中某个用户的三度好友关系？</p><p>上一节我们讲过，社交网络可以用图来表示。这个问题就非常适合用图的广度优先搜索算法来解决，因为广度优先搜索是层层往外推进的。首先，遍历与起始顶点最近的一层顶点，也就是用户的一度好友，然后再遍历与用户距离的边数为2的顶点，也就是二度好友关系，以及与用户距离的边数为3的顶点，也就是三度好友关系。</p><p>我们只需要稍加改造一下广度优先搜索代码，用一个数组来记录每个顶点与起始顶点的距离，非常容易就可以找出三度好友关系。</p><h2>内容小结</h2><p>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如A*、IDA*等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。所以，这两种搜索算法仅适用于状态空间不大，也就是说图不大的搜索。</p><p>广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是O(E)，空间复杂度是O(V)。</p><h2>课后思考</h2><ol>\n<li>\n<p>我们通过广度优先搜索算法解决了开篇的问题，你可以思考一下，能否用深度优先搜索来解决呢？</p>\n</li>\n<li>\n<p>学习数据结构最难的不是理解和掌握原理，而是能灵活地将各种场景和问题抽象成对应的数据结构和算法。今天的内容中提到，迷宫可以抽象成图，走迷宫可以抽象成搜索算法，你能具体讲讲，如何将迷宫抽象成一个图吗？或者换个说法，如何在计算机中存储一个迷宫？</p>\n</li>\n</ol><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","comments":[{"had_liked":false,"id":45887,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1543813112,"is_pvip":false,"replies":[{"id":"16680","content":"😂","user_name":"作者回复","comment_id":45887,"uid":"1190123","ip_address":"","utype":1,"ctime":1543974716,"user_name_real":"gg"}],"discussion_count":29,"race_medal":0,"score":"1088170539000","product_id":100017301,"comment_content":"朗读者原谅我的有强迫症：queue这个单词读错了，付上正确的音标如下［kju］<br><br>我觉得避免这种问题，有个方法就是，朗读之前，逐个查询一下单词的正确发音，一篇文章中的单词屈指可数，这个工作量按理说应该不大。<br><br>但是这个简单的举措，能大大提高听文章的体验，不然听起来总觉得很怪<br><br>往大了说影响，毕竟咱们极客时间做的是知识，做的是学问","like_count":253,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431253,"discussion_content":"😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543974716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344118,"discussion_content":"这些内容你们都听语音学习吗，这么强？","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1611299010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1991279,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/62/6f/06d476f7.jpg","nickname":"Geek_Akara","note":"","ucode":"E86A5A9EEC8BFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274173,"discussion_content":"哈哈，但是美国的大部分码农呢是印度人，所以大部分时候听到的不是[kju]，而是[gju].加上工科大部分是亚洲人，所以听到的可能是日本味的，韩国味的，咖喱味的，萨瓦迪卡味的，中国细分有东北味的，广东味的等，所以在美国混久了，发音呢，只要大家听得懂就不会纠结，体谅一下老师吧。","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1590550075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1991279,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/62/6f/06d476f7.jpg","nickname":"Geek_Akara","note":"","ucode":"E86A5A9EEC8BFF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286868,"discussion_content":"萨瓦迪卡味的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593313905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274173,"ip_address":""},"score":286868,"extra":""}]},{"author":{"id":2343086,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","nickname":"徐志超-Klaus","note":"","ucode":"CF26B39965F2A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531264,"discussion_content":"如果你喜欢把焦点放到这些细节上的话，那我觉得你对学习这事真的不太专注。我觉得你也别学习了，你要不要申请一下极客时间的发音纠错人，需要你纠错的地方可多了去了，哪有时间再来学习呀","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1637256423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":1,"child_discussions":[{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2343086,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","nickname":"徐志超-Klaus","note":"","ucode":"CF26B39965F2A2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582669,"discussion_content":"人家说的是对的，你这就属于瞎几把扯淡了。有那功夫你还来评论，那我觉得你对学习这事真的不太关注，需要你纠错的地方可多了去了，哪有时间来学习鸭","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659584230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531264,"ip_address":"广东"},"score":582669,"extra":""}]},{"author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350357,"discussion_content":"已经更正了吧， 听着没毛病","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1613822214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326223,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3c/8f/be719404.jpg","nickname":"Del皮耶罗","note":"","ucode":"E90D6311ED875F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320615,"discussion_content":"2020年快过去了，凑个热闹笑一下","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604414660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784558,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3a/ee/5afcf719.jpg","nickname":"Itachi","note":"","ucode":"0F9520652D6D43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308106,"discussion_content":"评论区都哈哈哈笑什么呢？你们听着不难受？？ 正常过了大学英语四级的人都会发现这个错误吧！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1600846971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1784558,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3a/ee/5afcf719.jpg","nickname":"Itachi","note":"","ucode":"0F9520652D6D43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329435,"discussion_content":"我觉得没必要较真","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606383667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":308106,"ip_address":""},"score":329435,"extra":""},{"author":{"id":1122875,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/3b/a79865d3.jpg","nickname":"Alexyz","note":"","ucode":"E9A59CF6D3335B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1784558,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3a/ee/5afcf719.jpg","nickname":"Itachi","note":"","ucode":"0F9520652D6D43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337447,"discussion_content":"的确是个严重问题，我也想提的，平时身边的同事念一些技术词汇也发音不准确，听着难受又不好意思纠正","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1608907148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":308106,"ip_address":""},"score":337447,"extra":""},{"author":{"id":1613425,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9e/71/fb7191ac.jpg","nickname":"Knight","note":"","ucode":"B665B189AF7DA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1122875,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/3b/a79865d3.jpg","nickname":"Alexyz","note":"","ucode":"E9A59CF6D3335B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346286,"discussion_content":"我想问问配置文件yml你们都读什么？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611900606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337447,"ip_address":""},"score":346286,"extra":""}]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255344,"discussion_content":"qqqqq","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588391073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271419,"discussion_content":"其实在有些教程中也能发现读音明显错误的问题。发音不好并不能一定说明技术水平不够，但是时刻注意发音的技术人，技术将来一定会不错","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590134437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046781,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/fd/2c26fc52.jpg","nickname":"😳","note":"","ucode":"E91E08DEDDE3B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32781,"discussion_content":"王争老师很尴尬 haha","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1571060989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1046781,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/fd/2c26fc52.jpg","nickname":"😳","note":"","ucode":"E91E08DEDDE3B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261717,"discussion_content":"朗读者并不是王老师2333","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1588996426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":32781,"ip_address":""},"score":261717,"extra":""}]},{"author":{"id":2203358,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLaoiaerNMy7eoSA5yfibPNhta51jkhPTTL1dD1HGlnjaGnFQ6Uzbbce82Kpnic3g1JlD7rtm41Y83PA/132","nickname":"Geek_3c29c3","note":"","ucode":"3D2E73AB1D08FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386327,"discussion_content":"杠精本精","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627528574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2144624,"avatar":"https://static001.geekbang.org/account/avatar/00/20/b9/70/983f2354.jpg","nickname":"Geek_4acb3b","note":"","ucode":"6FE6971EE47448","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314875,"discussion_content":"我听到了queen😋","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603205357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52788,"discussion_content":"hhh ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574085077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2229244,"avatar":"https://static001.geekbang.org/account/avatar/00/22/03/fc/daa02847.jpg","nickname":"18","note":"","ucode":"4ADE57BEA7C37C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580342,"discussion_content":"kju:","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658112517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555171,"discussion_content":"我都没注意到，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646794364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415676,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/fc/d3cecfb2.jpg","nickname":"Vainycos","note":"","ucode":"57CFC7C9D4F2EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532397,"discussion_content":"读错了更正就是了，没必要上纲上线","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637593125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"user_type\":1}","child_discussion_number":1,"child_discussions":[{"author":{"id":2457254,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/suQ8EerOp4VHR1NCIAnoc2xuUw4V4ticYZMeOZhZG3yDEH0o7Cnsc3IS2m3ES1cvmibekzjQCSZzsq63pjGicPdlg/132","nickname":"Geek_a733e5","note":"","ucode":"A556FCD8643347","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1415676,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/fc/d3cecfb2.jpg","nickname":"Vainycos","note":"","ucode":"57CFC7C9D4F2EC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550098,"discussion_content":"太同意你了。有的决定读者没事找事，不关注技术，有的觉得老师有问题。其实就是一个小错误，同学们发现了，老师改正了，其他同学也都包容了。凡事儿上纲上线真的不至于","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644386139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532397,"ip_address":""},"score":550098,"extra":""}]},{"author":{"id":1589894,"avatar":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","nickname":"Vicent🍀","note":"","ucode":"70AEA72A0B6F0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189430,"discussion_content":"考究","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582881291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1758731,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d6/0b/7afd26c5.jpg","nickname":"Small Wave","note":"","ucode":"48490CC348250C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180142,"discussion_content":"我笑了，hhh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582280092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1119116,"avatar":"https://static001.geekbang.org/account/avatar/00/11/13/8c/c86340ca.jpg","nickname":"巴西","note":"","ucode":"6E68AA02011541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79037,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576048616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50230,"user_name":"The Sword of Damocles","can_delete":false,"product_type":"c1","uid":1188527,"ip_address":"","ucode":"42B462FC572F24","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/af/1a31bc11.jpg","comment_is_top":false,"comment_ctime":1544928881,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"744574271089","product_id":100017301,"comment_content":"看的费劲的同学可以先去网上找找二叉树的深度、广度优先遍历看看。图的搜索和这个类似。<br>深度：借助一个栈<br>广度：借助一个队列<br><br>老师的代码没有注释，变量名称也比较简洁，虽然下文有解释，但是来回上下翻实在是看的费劲。建议能稍微优化一下。<br>","like_count":174,"discussions":[{"author":{"id":1717444,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/34/c4/08d9f349.jpg","nickname":"元","note":"","ucode":"4576E15018EEA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93017,"discussion_content":"二叉树的深度，广度遍历前面课程有讲呀，深度：前序遍历 广度：借助队列按层遍历","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1576899709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237645,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e2/8d/e414c526.jpg","nickname":"高素质流氓","note":"","ucode":"1F5A03D2F2962E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274181,"discussion_content":"兄弟可以试试使用Snipaste贴图功能，用了回不去hh","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1590550831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1244845,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","nickname":"放飞心情","note":"","ucode":"75A2192D91D86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237645,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e2/8d/e414c526.jpg","nickname":"高素质流氓","note":"","ucode":"1F5A03D2F2962E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382187,"discussion_content":"流氓推荐的良心软件，用了好几年","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625467471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274181,"ip_address":""},"score":382187,"extra":""}]},{"author":{"id":1033321,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c4/69/1946f360.jpg","nickname":"行望星烁","note":"","ucode":"A779CE310F0BFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376080,"discussion_content":"没有李威威讲的好 https://liweiwei1419.gitee.io/leetcode-algo/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621950953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268295,"discussion_content":"PC端看视野更广😉","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589760746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2449060,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","nickname":"Geek_sz","note":"","ucode":"72E86D7D6554CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571964,"discussion_content":"着实恶心","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652514938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019725,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","nickname":"学个球","note":"","ucode":"7343F3C0CA981D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57335,"discussion_content":"自己复制到编译器，把注释标上去一起看好像也不错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574598474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45817,"user_name":"P@tricK","can_delete":false,"product_type":"c1","uid":1233716,"ip_address":"","ucode":"293B2B3261A793","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/34/5dee4f70.jpg","comment_is_top":false,"comment_ctime":1543799779,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"422450594787","product_id":100017301,"comment_content":"思考题：<br>1. 可以。DFS递归时传多一个离初始节点的距离值，访问节点时，距离超过3的不再继续递归<br><br>2.  初始化两个顶点为迷宫起点和终点，从起点开始，遇到分叉点，为每个分支都新建一个节点，并和前一节点连接，递归每个分支直到终点","like_count":98,"discussions":[{"author":{"id":2052088,"avatar":"","nickname":"dyh_zero","note":"","ucode":"98029D72597EF2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547125,"discussion_content":"有可能把一度的筛选出来吧 如果有交叉好友","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642552844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1462911,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKf9xWMCV4ic5dsKyroQpGkYGZ32IPicVPVsF1TPENeTcspd6HhhaciaHCCmzeicaiaItZS3DahASFovJQ/132","nickname":"bai","note":"","ucode":"C9673B7F2C896E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308704,"discussion_content":"2的解法不会有问题吗，这样怎么标识是同一个节点，比如从a节点分支出去两个节点b,c,经过x个几点后，两个都能到达d，这样还能识别出来b，c到达的是同一个吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601038562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1616622,"avatar":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","nickname":"ɴɪᴋᴇʀ","note":"","ucode":"DB7D92CBB5FD15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292050,"discussion_content":"不会的吧，递归不是一条线，是一个节点下面一层所有的节点并行递归的，但是不知道他这样会不会有问题，看上面老师画的深度递归的图，就感觉不是并行的，我也很有疑问。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595062940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1329303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/48/97/d13d8802.jpg","nickname":"Dr.J😶","note":"","ucode":"14B5D88CA55162","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1616622,"avatar":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","nickname":"ɴɪᴋᴇʀ","note":"","ucode":"DB7D92CBB5FD15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299300,"discussion_content":"老师画的图没有画出全部情况，而且邻接表中链表部分储存的vertex顺序也未知，就是给出一个大致的图解。万一储存的顺序碰巧，也有可能dfs刚好是最短路径的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597649160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292050,"ip_address":""},"score":299300,"extra":""}]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273820,"discussion_content":"这样的话3度、2度好友是不是只有一个呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590503139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2198755,"avatar":"https://static001.geekbang.org/account/avatar/00/21/8c/e3/b9e926f9.jpg","nickname":"面罩","note":"","ucode":"E85F2550D7C6D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393034,"discussion_content":"我理解他的“不再继续递归”的意思是当前节点不再深入递归，而是向上回溯，处理其他的结点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631234137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273820,"ip_address":""},"score":393034,"extra":""}]}]},{"had_liked":false,"id":51238,"user_name":"李东勇","can_delete":false,"product_type":"c1","uid":1236071,"ip_address":"","ucode":"7D1EA72D326F32","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/67/5149a60b.jpg","comment_is_top":false,"comment_ctime":1545141071,"is_pvip":false,"replies":[{"id":"18550","content":"嗯嗯 👍","user_name":"作者回复","comment_id":51238,"uid":"1190123","ip_address":"","utype":1,"ctime":1545184840,"user_name_real":"gg"}],"discussion_count":6,"race_medal":0,"score":"263538146127","product_id":100017301,"comment_content":"老师， 我觉得深度优先搜索的代码中有一个可以改进的地方， 可以在21行之后加一句： if (found == true) return;  这样， 在一个顶点的for循环之中， 如果已经找到了t, 就可以跳出这个for循环了。目前的逻辑是， 这个for循环中剩下的还会继续执行， 每次都调用一次recurDfs函数， 但recurDfs函数在第一行就return了。","like_count":61,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433358,"discussion_content":"嗯嗯 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545184840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1513948,"avatar":"https://static001.geekbang.org/account/avatar/00/17/19/dc/9d3ed421.jpg","nickname":"monchickey","note":"","ucode":"D7B670444F62B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334581,"discussion_content":"不应该放到for循环里面，因为这样每次都要判断，大部分情况下是搜索不到的，判断次数会特别多，一旦找到目标顶点才会起作用，但是多循环的次数仅仅是和目标顶点同层级的顶点个数，所以感觉这样会带来更大的开销~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607906784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1971269,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oltLEqTrmHm2aJP99BK6tHu5h7hp4aj08wR5Wt6H31iadFduDAVvjYKmhQ2nvGbLV3lkVdiat2GRasgWXoJeTibUg/132","nickname":"杨","note":"","ucode":"7EFEFE285975C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321713,"discussion_content":"不应该 if found嘛  为啥都喜欢加个found==true   a==false(用!a不好吗)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604625647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2449060,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","nickname":"Geek_sz","note":"","ucode":"72E86D7D6554CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562731,"discussion_content":"这个王争真的是前谷歌的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649865838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321711,"discussion_content":"这个改善挺大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604625358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1677759,"avatar":"https://static001.geekbang.org/account/avatar/00/19/99/bf/2be3938c.jpg","nickname":"Treasure","note":"","ucode":"743DB32353D049","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279947,"discussion_content":"如果找到了这个t退出当前调用函数到上一个调用函数，然后进行判断found是否为true，所以就会减掉其他的路径的搜索，之前会进行全搜索，一条路径找到之后返回，所以加上大佬说的这个判断之后针对于找到迷宫出口来说确实就不用再搜索其他的路径了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591453976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183450,"user_name":"Vicent🍀","can_delete":false,"product_type":"c1","uid":1589894,"ip_address":"","ucode":"70AEA72A0B6F0E","user_header":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","comment_is_top":false,"comment_ctime":1583044202,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"229216310890","product_id":100017301,"comment_content":"20200301 续<br>关于第一阶段任务：<br>2020的第一季度已经马上度过，看了看初期定的计划，自己完成情况大概在70%；预计的3月中旬把《数据之美》看完，完成难度有点大。复工之后，明显感觉每天投入到学习中的时间变少。百日计划也暂停了两周。目前《数据之美》完成了70%，还剩余30%，但是如果按照保质保量的完成剩余课程，还是需要很多时间的，因为后面的内容更加高级和复杂，需要用很多时间来思考。<br>关于第一阶段内一些问题：<br>1.应试过程中如果按计划学习？<br>2.如何培养正确的学习习惯？<br>首先是关于工作，开年后就开始着手换工作的事情，现在找到一家薪资合适的工作，但是回头看，觉得自己还是没有一个清晰的规划路线。现在觉得自己纠结点是：没有去尝试头部公司以及自己觉得现在准备不足以冲击头部公司。我觉得自己还是可能属于比较容易妥协的，有一份薪资和工作内容达到自己要求的工作。就会不愿意去再去探索。一方面可能是自己比较急于新的环境（受不了当前的状态）；另一方面也是因为自己的知识还不够成体系。每次在面试中都可以看到自己的不足和短板。自信心总是受到打击，而且有些短板的弥补不是一蹴而就的。在这里换工作之后，对学习的目的有了新的感受。要把学习培养成一个习惯，把学习的态度摆正。浅尝辄止的学习态度不利于持久的发展。<br>还有一件事件就是关于学习的方向，特别是在面试过程中的学习，会发现一些热点知识点的学习对面试的帮助很大，提高面试成功率显著，对于之前第一阶段制定的围绕基础知识学习对面试的提升就限制的比较多。但又不想放弃自己的学习计划，所以只能又开始了看看这个、看看那个的节奏……这个状态想了很多办法来解决，但是收效甚微，还是在状态切换中花费了很多时间。目前还没有想好特别好的办法，庆幸的是目前收到offer，新的岗位也需要新的技术栈，但这些我觉得可以在入职后通过工作时间来补充。<br>关于第一阶段学习总结：<br>评估学习量和强度对计划执行有很大影响，能正确评估出自己掌握一个知识点或者消化知识所用的时间，可以让自己的计划不容易打乱。一开始我按照一课时一天的节奏来计划。后来发现，有的章节一天可以刷3-4课，而有的课程需要3-4天才能消化。我在新的计划制定的时候，会采取先大致浏览一下内容，预估一下消化时间，然后在进行计划的制定，这样误差不会太大。像最开始的“四十天完成四十节课计划”执行成功率太低。<br>稳定军心，再接再厉：<br>在后面的规划中，自己有几点需要注意的<br>1.不能松懈，没有松懈的理由，如果真的热爱学习，就应该养成习惯，当每个周末想到的不是可以放松看看直播了，而是发现又有两天可以集中精力学习了。<br>2.计划要定时定量，更要有完成的可能性。<br>3.不能懒惰的同时也不能急躁；科学的认识到认知的发展规律，认清现状，不要为难自己。<br>战略&amp;战术<br>战略明确了，剩下的就是战术执行。首先应该还是要围绕着基础，不能后面再回头来补基础一次又一次。目前我认为在基础知识中较为重要的为数据结构与算法、设计模式、通信与网络协议、计算机组成。然后基本每项基础学科的掌握基本需要3-5个月的时间。如果这样算，那基本至少需要一年的时间来补基础。","like_count":53,"discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306884,"discussion_content":"我觉得 不要把刷题当做目的，，，，你每天坚持2~3个小时学习，不管是学习新知识还是老知识，然后每半年到1年出去面试相互交流学习，别把面试当负担，当成学习交流的过程，要知道平时都是我们面试别人，有别人面试你，同级或者高level的人给你指点，这是一个非常好的过程。。。。而且慢慢的随着你的级别提升，大家更多的看你这个人的技术观，技术业务观，你的技术的成就是什么","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1600410985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2249227,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","nickname":"橙子橙","note":"","ucode":"CD51367A14D955","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325766,"discussion_content":"这样感觉会压力很大哎..持续的在面试和准备面试的氛围中...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605427576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306884,"ip_address":""},"score":325766,"extra":""}]},{"author":{"id":1194572,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/4c/b6200773.jpg","nickname":"一步","note":"","ucode":"FBFAE23E8E48B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292436,"discussion_content":"我也是。看了《左耳听风》皓书的几篇关于高效学习的文章，收获颇大。我们要把学习当做终身的事来考虑，学习不只是为了积累知识，经验，关键是要改变自己的思维，改善自己的大脑，说不定可以变的更聪明（笑）。而且要深度学习，不然还是学啥忘啥。归纳总结真的是太重要了。。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1595224985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262319,"discussion_content":"总结的很好，又过去了两个月不知道你现在状态如何？\n\n我现在处于找工作的状态，正在刷算法课，以增加后续面试通过的几率；另外还打算看一下《面试现场》。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589074147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1589894,"avatar":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","nickname":"Vicent🍀","note":"","ucode":"70AEA72A0B6F0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":2,"user_type":1,"is_pvip":true},"discussion":{"id":304813,"discussion_content":"换了新工作，疫情期间的闭门学习收获很明显。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1599666110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262319,"ip_address":""},"score":304813,"extra":""}]},{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582670,"discussion_content":"已阅，继续保持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659584304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45816,"user_name":"五岳寻仙","can_delete":false,"product_type":"c1","uid":1247467,"ip_address":"","ucode":"88A46A4E1832CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg","comment_is_top":false,"comment_ctime":1543799766,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"190522360790","product_id":100017301,"comment_content":"课后思考题：<br>1. 深度优先用于寻找3度好友，可以设定搜索的深度，到3就向上回溯。正如文中提到的，可能不是最短路径，所以会涉及到更新结点度的问题。<br><br>2. 关于迷宫存储问题。类似于欧拉七桥问题，需要将迷宫抽象成图，每个分叉路口作为顶点，顶点之间连成边，构成一张无向图，可以存储在邻接矩阵或邻接表中。","like_count":44,"discussions":[{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268556,"discussion_content":"个人觉得迷宫应该是用有向图是不是会接近一点呀？因为有一些路径是不能到终点吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589801676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2282960,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d5/d0/97c8dc32.jpg","nickname":"大西几吃小兔兔","note":"","ucode":"44D75626C6DB57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":347860,"discussion_content":"迷宫无向图就可以了，两个路口可以来回走。除非有设定是单向路","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612343855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":268556,"ip_address":""},"score":347860,"extra":""},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":2282960,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d5/d0/97c8dc32.jpg","nickname":"大西几吃小兔兔","note":"","ucode":"44D75626C6DB57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348592,"discussion_content":"好像是哦，多谢大佬指点！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612660874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":347860,"ip_address":""},"score":348592,"extra":""}]}]},{"had_liked":false,"id":45975,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1543826989,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"134687813165","product_id":100017301,"comment_content":"留言笔记不小心被自己删了（问了客服，也不能找回了），补上：<br><br>1. 可以用深度遍历，每次遍历到三度人脉，再回溯到上层节点，直到所有的三度人脉都找完。<br><br>2. 将迷宫的每个岔口记为&quot;顶点&quot;，岔口之间的路径记为&quot;边&quot;，可以用邻接表存储，也可以用邻接矩阵存储。但是个人感觉，像那种标准的方格迷宫，适合用邻接矩阵存储，因为稠密度比较高。","like_count":31,"discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278932,"discussion_content":"找完所有三度人脉外,还需要剔除部分是一度或二度的人脉","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591260812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1785016,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","nickname":"鱼丸粗面","note":"","ucode":"B2F3F75B0D1422","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257688,"discussion_content":"稠密度不高吧，一个顶点往往只和它上下左右的顶点有边","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588599980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056201,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/60/09/a8e7913b.jpg","nickname":"SandCarving","note":"","ucode":"6B97DB71613A46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320804,"discussion_content":"如果是个环呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604482421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235287,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d9/57/7848fd65.jpg","nickname":"标签","note":"","ucode":"38441CF5571B82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38999,"discussion_content":"有点疑惑深度遍历怎么判断三度人脉呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571877450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1583499,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/8b/3629c0f8.jpg","nickname":"游山行人","note":"","ucode":"E559BD0A3C6484","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1235287,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d9/57/7848fd65.jpg","nickname":"标签","note":"","ucode":"38441CF5571B82","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230134,"discussion_content":"递归到第三度，就是第三层就可以返回了，因为每一层都代表一度","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586707910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":38999,"ip_address":""},"score":230134,"extra":""}]}]},{"had_liked":false,"id":200338,"user_name":"Geek_Heiko","can_delete":false,"product_type":"c1","uid":1469881,"ip_address":"","ucode":"54B0D22008F7EC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/VfE7OiboMc7SKwOiczAJDWo3T4WJn0dVW8yPEpVRUFtk6ib0DUicN1eDfpel1UAgp8ia4kqEjXSVXOVHcoZKXhq7k4w/132","comment_is_top":false,"comment_ctime":1585573548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"108959755948","product_id":100017301,"comment_content":"&quot;学习数据结构最难的不是理解和掌握原理，而是能灵活地将各种场景和问题抽象成对应的数据结构和算法。&quot; 看到这句话，突然觉得信息量很大，但是目前相关的练习和经验还不到位，没到那个量，是一种相对比较空的那种大，上次的这种体验是，看到和这句话相似的一句话：“一旦一个问题得到正确描述，那么就趋近于解决。&quot;","like_count":25},{"had_liked":false,"id":56883,"user_name":"luo","can_delete":false,"product_type":"c1","uid":1148742,"ip_address":"","ucode":"00FBDC12101419","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/46/2850b4a9.jpg","comment_is_top":false,"comment_ctime":1546572417,"is_pvip":false,"replies":[{"id":"21322","content":"你说的没错，但是做工程就是trade-off，只能权衡来选择方案。如果实在存不下，可以降低些执行效率。不过，现在有很多图数据库，也可以解决你说的问题，把图直接存在硬盘中。","user_name":"作者回复","comment_id":56883,"uid":"1190123","ip_address":"","utype":1,"ctime":1547262381,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"74561016449","product_id":100017301,"comment_content":"老师针对图这个数据结构的应用 我有点疑惑，从结构来看无论是临近矩阵还是临近表 其实都需要有一个唯一下标作为这个顶点，那么问题来了 在实际数据量庞大的时候，这种数据结构是不是就没法用了（临近矩阵就不说了，临近表的话也是需要一个大的数组存储每个顶点 ），或者只能拆成以hash先分id，之后映射到对应的机器上存储各自的临近表部分，但这样进行深度广度搜索就有网络io了。","like_count":17,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435295,"discussion_content":"你说的没错，但是做工程就是trade-off，只能权衡来选择方案。如果实在存不下，可以降低些执行效率。不过，现在有很多图数据库，也可以解决你说的问题，把图直接存在硬盘中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547262381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66778,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1550019680,"is_pvip":false,"replies":[{"id":"24605","content":"不是最短路径的。广度优先可以取到最短路径。","user_name":"作者回复","comment_id":66778,"uid":"1190123","ip_address":"","utype":1,"ctime":1550716723,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"53089627232","product_id":100017301,"comment_content":"对于今天的问题，无权图，如果采用深度优先。拿到的路径不一定是最短路径吧","like_count":12,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438905,"discussion_content":"不是最短路径的。广度优先可以取到最短路径。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550716723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2449748,"avatar":"https://static001.geekbang.org/account/avatar/00/25/61/54/5bf767e7.jpg","nickname":"没有心的人","note":"","ucode":"F27D5894087B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554429,"discussion_content":"解答我的疑惑了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646376942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52335,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1545363745,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"44495036705","product_id":100017301,"comment_content":"老师，你好，我怎么觉得，递归完成之后，回溯到上一步，需要执行visited[w] = false呢，，因为路径不通，所以要回溯，但是应该重置为false，以便下次搜索 ","like_count":10,"discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164718,"discussion_content":"回溯不是说代码显示的回溯，而是执行到那里代码会回来执行另外一条路径","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1581215846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574614,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654177532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":164718,"ip_address":""},"score":574614,"extra":""}]},{"author":{"id":2037714,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/17/d2/68cdbd75.jpg","nickname":"海狮","note":"","ucode":"18FDDF5841F282","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304019,"discussion_content":"不需要，因为回溯时，是不用去判断visited，visited是在前进时判断的；\n如果难以理解的话，你可以假设当前处于正确路径上的一点A, A的前进方向有两个点分别为B和C（多个点也是一样）；\n假设往B点方向走，怎么走都是死路，那么显然C是正确的，并且刚才B方向所走的路上，肯定不会经过C（要是经过C那就不可能走到目标点了）；\n所以回溯到 A，然后此时C的visited还是false，就可以向C前进···；\n最坏的情况，也总能回溯到一个正确的点，那就是起点了；","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599451749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2037714,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/17/d2/68cdbd75.jpg","nickname":"海狮","note":"","ucode":"18FDDF5841F282","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321730,"discussion_content":"用迷宫来看，特别好理解。尝试当前节点的所有路径，发现不行，则回溯。在找所有路径时，就必须 依据这个visited=true来判断这个子路径是否已经尝试过了。如果尝试了，就尝试下一个子路径。所有子路径都尝试了，仍没有找到，则弹栈，回溯到上一个节点。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604627483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304019,"ip_address":""},"score":321730,"extra":""}]},{"author":{"id":1439568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","nickname":",","note":"","ucode":"191431A878D7B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297159,"discussion_content":"如果只是单纯的找一条路径，那就不需要写回visit[w] = false；但如果是一条“规定”的路径，比如剑指offer第12题，那就需要写回visit[w] = false。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596789266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1439568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","nickname":",","note":"","ucode":"191431A878D7B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297149,"discussion_content":"不需要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596787855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77100,"discussion_content":"em，回溯和这个visited[w] 已赋值没有关系，这个值 不影响它的几个后继顶点的搜索","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575888938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45795,"user_name":"韩","can_delete":false,"product_type":"c1","uid":1218674,"ip_address":"","ucode":"75BB3E48AE7E45","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/72/0dccb3e7.jpg","comment_is_top":false,"comment_ctime":1543797334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44493470294","product_id":100017301,"comment_content":"我的想法:迷宫可以用带权无向图存储，每个多岔路口是一个顶点，相邻的多岔路口是一条边。带权是为了记录两个顶点间的距离。<br><br>但用上面这种方式，会丢失一些拐点信息。可以结合业务场景，如果需要这些信息，就把拐点也作为一个顶点存储。","like_count":10},{"had_liked":false,"id":46756,"user_name":"马球先生","can_delete":false,"product_type":"c1","uid":1119609,"ip_address":"","ucode":"858C2CE0E494C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/79/efde2a69.jpg","comment_is_top":false,"comment_ctime":1543977891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40198683555","product_id":100017301,"comment_content":"广度优先 有点像树中的层序遍历啊 也是借助一个队列来实现的","like_count":9},{"had_liked":false,"id":49260,"user_name":"Laughing_Lz","can_delete":false,"product_type":"c1","uid":1251342,"ip_address":"","ucode":"7A7445E96F2978","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg","comment_is_top":false,"comment_ctime":1544637126,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"35904375494","product_id":100017301,"comment_content":"我基础非常差，写了老半天的非递归深度优先遍历，还请各位看看写的对不对<br><br>&#47;**<br>\t * 深度优先遍历<br>\t * <br>\t * @param start 路径查找起始点<br>\t * @param end   路径查找终点<br>\t *&#47;<br>\tpublic void depthFirstSearch(int start, int end) {<br>\t\tif (start == end) {<br>\t\t\treturn;<br>\t\t}<br>\t\t&#47;&#47; 定义一个visited数组，保存是否访问过<br>\t\tboolean[] visited = new boolean[v];<br>\t\t&#47;&#47; 定义一个栈，作为一个后进先出栈，保存已访问，但相连节点未访问的节点<br>\t\tStack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();<br>\t\t&#47;&#47; 先将start压入栈中<br>\t\tvisited[start] = true;<br>\t\tstack.push(start);<br>\t\twhile (!stack.isEmpty()) {<br>\t\t\t&#47;&#47; 取出，但不出栈<br>\t\t\tint step = stack.peek();<br>\t\t\t&#47;&#47; 标识位，标识step节点下的邻接节点中是否有未走过的节点<br>\t\t\tboolean hasNoVisited = false;<br>\t\t\tfor (int i = 0; i &lt; adj[step].size(); i++) {<br>\t\t\t\tint nextStep = adj[step].get(i);<br>\t\t\t\t&#47;&#47; 存在未走过节点，则flag = true,将nextStep压入栈中，继续前行<br>\t\t\t\tif (visited[nextStep] == false) {<br>\t\t\t\t\thasNoVisited = true;<br>\t\t\t\t\tvisited[nextStep] = true;<br>\t\t\t\t\tstack.push(nextStep);<br>\t\t\t\t\tif (nextStep == end) {<br>\t\t\t\t\t\treturn;<br>\t\t\t\t\t}<br>\t\t\t\t\tbreak;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\t&#47;&#47; 邻接的节点都是已走过的，则出栈<br>\t\t\tif (hasNoVisited == false) {<br>\t\t\t\tstack.pop();<br>\t\t\t}<br>\t\t}<br>\t\t&#47;&#47; 遍历输出栈中存储的节点，即路径<br>\t\tif (!stack.isEmpty()) {<br>\t\t\tIterator&lt;Integer&gt; it = stack.iterator();<br>\t\t\twhile (it.hasNext()) {<br>\t\t\t\tSystem.out.print(it.next() + &quot; &quot;);<br>\t\t\t}<br>\t\t}<br>\t}","like_count":8,"discussions":[{"author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99308,"discussion_content":"这个排版，能有几个人好好看你的代码呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577198522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298513,"discussion_content":"按照楼主已有逻辑改造的一个正确的利用stack实现的非递归迭代式DFS\n*\n\t* 深度优先遍历\n\t*\n\t* @param start 路径查找起始点\n\t* @param end 路径查找终点\n\t*/\npublic void dfsbyIteration(int start, int end) {\n\t\tif (start == end) {\n\t\t\treturn;\n\t\t}\n\t\t// 定义一个visited数组，保存是否访问过\n\t\tboolean[] visited = new boolean[v];\n\t\t// 定义一个栈，作为一个后进先出栈，保存已访问，但相连节点未访问的节点\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t// 先将start压入栈中\n\t\tvisited[start] = true;\n\t\tstack.push(start);\n\t\tretry:\n\t\twhile (!stack.isEmpty()) {\n\t\t\t// 取出，但不出栈\n\t\t\tint step = stack.peek();\n\t\t\tfor (int i = 0; i < adj[step].size(); i++) {\n\t\t\t\tint nextStep = adj[step].get(i);\n\t\t\t\t// 存在未走过节点，则flag = false,将nextStep压入栈中\n\t\t\t\tif (visited[nextStep] == false) {\n\t\t\t\t\tvisited[nextStep] = true;\n\t\t\t\t\tstack.push(nextStep);\n\t\t\t\t\tif (nextStep == end) {\n\t\t\t\t\t\tbreak retry;//找到终点，中断外循环\n\t\t\t\t\t}\n\t\t\t\t\tcontinue retry;//push了一个顶点就以该顶点为始点开始找，继续外循环\n\t\t\t\t}\n\t\t\t}\n\t\t\t//step的最后一个顶点都没有到达终点end，将其弹出\t\n\t\t\tstack.pop();\n\t\t}\n\t\t// 遍历输出栈中存储的节点，即路径\n\t\tif (!stack.isEmpty()) {\n\t\t\tIterator<Integer> it = stack.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tSystem.out.print(it.next() + &#34; &#34;);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}else{\n\t\t\tSystem.out.println(String.format(&#34;顶点[%d]到[%d]没有路径&#34;, new Object[]{start,end}));\n\t\t}\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597315268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298508,"discussion_content":"你的代码是错的，因为你找到终点就直接没打印就return了，即使是对的你的逻辑也是BFS广度优先","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597314347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90177,"user_name":"possible","can_delete":false,"product_type":"c1","uid":1274061,"ip_address":"","ucode":"766CFE8791C625","user_header":"","comment_is_top":false,"comment_ctime":1556440527,"is_pvip":false,"replies":[{"id":"32369","content":"是的","user_name":"作者回复","comment_id":90177,"uid":"1190123","ip_address":"","utype":1,"ctime":1556502542,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"31621211599","product_id":100017301,"comment_content":"广度优先用的queue（先进先出），深度优先把queue换成stack（后进先出）即可吧？也经常会用stack来替代递归","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448414,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556502542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142845,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1571558600,"is_pvip":false,"replies":[{"id":"55217","content":"是的","user_name":"作者回复","comment_id":142845,"uid":"1190123","ip_address":"","utype":1,"ctime":1571618157,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"27341362376","product_id":100017301,"comment_content":"弱弱的问一句，prev和visited用数组存是正好value和下标一致才行的吧?","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471294,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571618157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321733,"discussion_content":"所以，如果工程中，节点value怎么和下标对应起来？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604627573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008534,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/96/abb7bfe3.jpg","nickname":"厚厚","note":"","ucode":"C95341F5E3E776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96671,"discussion_content":"你这个正是我想问的。建议老师加上注释比较好理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577085399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65856,"user_name":"JzyCc","can_delete":false,"product_type":"c1","uid":1333099,"ip_address":"","ucode":"C2E02DF421FC1B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIANNsQtwyubFGMzWibtA0ibuPmwp69wTyu9LmYh3tibb2tfUZMxDVrbpnxGibPjdvJxjacuFibOw7Sb9w/132","comment_is_top":false,"comment_ctime":1549702605,"is_pvip":false,"replies":[{"id":"24285","content":"不，宽搜对于无权图来说，肯定能找到最短路径的。因为整体的逻辑是离起点越近的，越早被访问到。","user_name":"作者回复","comment_id":65856,"uid":"1190123","ip_address":"","utype":1,"ctime":1550542029,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"27319506381","product_id":100017301,"comment_content":"弱弱的问一下，宽搜代码那块，如果给的图中 1 和 3的位置互换，那么得出来的就不是最短路径了吧","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438614,"discussion_content":"不，宽搜对于无权图来说，肯定能找到最短路径的。因为整体的逻辑是离起点越近的，越早被访问到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56293,"user_name":"德尼","can_delete":false,"product_type":"c1","uid":1328081,"ip_address":"","ucode":"04D3836994EDF8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8rNWRmZ2slWlXZNFJiakMBo8zTTXCw1egz8tPia3JTmxCpP9wsPU7ABSG0PiboeEiaIyLQoTnQN3Jd7ibscdpRyEIAg/132","comment_is_top":false,"comment_ctime":1546416944,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27316220720","product_id":100017301,"comment_content":"说几个自己觉得是问题的小问题噢。在无向图代码中 adj声明的每个顶点的类型不是Integer吗？怎么在下面赋值时变成了LinkList？   <br>还有就是语音上在讲述dfs空间复杂度的时候，听到的是dfs的时间（实质上是空间）复杂度为Ov。","like_count":6,"discussions":[{"author":{"id":2052843,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoCZfMvnQdibYUlvcHnCIu3nO5T2EffF3H35zibcI0sne0xic7OyGO9WicBIM1cjd4PCfzFMGcXbPjiaGA/132","nickname":"Geek_24a140","note":"","ucode":"D884D7715D944D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387183,"discussion_content":"adj是一个linkedList数组，然后linkedList里边的元素是integer","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628039716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182650,"user_name":"醉红颜","can_delete":false,"product_type":"c1","uid":1118507,"ip_address":"","ucode":"66C7FA47CC4D7A","user_header":"https://static001.geekbang.org/account/avatar/00/11/11/2b/4053b256.jpg","comment_is_top":false,"comment_ctime":1582824952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23057661432","product_id":100017301,"comment_content":"dfs类似于二叉树的前序遍历，bfs类似于二叉树的层次遍历","like_count":5},{"had_liked":false,"id":57820,"user_name":"轩","can_delete":false,"product_type":"c1","uid":1326352,"ip_address":"","ucode":"A1E38FFFD04BF5","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/10/97f4e2a7.jpg","comment_is_top":false,"comment_ctime":1546917583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23021754063","product_id":100017301,"comment_content":"老师的图如果看不懂，可以看看这个https:&#47;&#47;www.jianshu.com&#47;p&#47;70952b51f0c8","like_count":5},{"had_liked":false,"id":213598,"user_name":"kaiser","can_delete":false,"product_type":"c1","uid":1390375,"ip_address":"","ucode":"F9438786E9A57B","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/27/b023ada7.jpg","comment_is_top":false,"comment_ctime":1588486636,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18768355820","product_id":100017301,"comment_content":"三度好友的代码：<br>  &#47;**<br>   * 广度优先搜索<br>   * @param s 起始顶点<br>   * @return<br>   *&#47;<br>  public List&lt;Integer&gt; threeDegreeRelationBfs(int s) {<br>    boolean[] visited = new boolean[v];<br>    visited[s] = true;<br>    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();<br>    queue.add(s);<br>    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();<br>    &#47;&#47; 记录每个顶点到起始顶点的距离<br>    int[] degree = new int[v];<br>    &#47;&#47; 记录总共遍历的次数<br>    int cycleNum = 0;<br>    &#47;&#47; 广度优先搜索，遍历整张图<br>    while (!queue.isEmpty()) {<br>      Integer w = queue.poll();<br>      &#47;&#47; 顶点离起始顶点距离超过 3 时则退出<br>      if (degree[w] == 3) {<br>        continue;<br>      }<br>      &#47;&#47; 遍历其关注的顶点<br>      for (Integer q : adj[w]) {<br>        &#47;&#47; 没有访问过的顶点进行记录<br>        if (!visited[q]) {<br>          visited[q] = true;<br>          &#47;&#47; 添加到队列<br>          queue.add(q);<br>          &#47;&#47; 记录当前顶点到起始顶点的距离，查找其前驱顶点的距离<br>          degree[q] = degree[w] + 1;<br>          cycleNum++;<br>          &#47;&#47; 记录结果<br>          result.add(q);<br>        }<br>      }<br>    }<br>    System.out.println(&quot;广度优先搜索三度好友关系一共遍历的次数：&quot; + cycleNum);<br>    return result;<br>  }<br><br>  &#47;**<br>   * 深度优先搜索<br>   * &lt;p&gt;<br>   *<br>   * @param s 起始顶点<br>   *&#47;<br>  public List&lt;Integer&gt; threeDegreeRelationDfs(int s) {<br>    &#47;&#47; 采用广度优先搜索算法<br>    boolean[] visited = new boolean[v];<br>    visited[s] = true;<br>    List&lt;Integer&gt; relations = new ArrayList&lt;&gt;();<br>    &#47;&#47; 递归寻找顶点的关系<br>    int cycleNum = findDegreeRelation(visited, relations, s, 0);<br>    System.out.println(&quot;深度优先搜索三度好友关系一共遍历的次数：&quot; + cycleNum);<br>    return relations;<br>  }<br><br>  &#47;**<br>   * 递归寻找顶点关系——深度优先搜索<br>   *<br>   * @param visited<br>   * @param relations<br>   * @param p<br>   * @param level<br>   * @return<br>   *&#47;<br>  private int findDegreeRelation(boolean[] visited, List&lt;Integer&gt; relations, Integer p, int level) {<br>    if (level == 3) {<br>      return 1;<br>    }<br>    int cycleNum = 0;<br>    for (int h = 0; h &lt; adj[p].size(); h++) {<br>      Integer t = adj[p].get(h);<br>      if (!visited[t]) {<br>        relations.add(t);<br>        visited[p] = true;<br>        cycleNum += findDegreeRelation(visited, relations, t, level + 1);<br>      }<br>      cycleNum++;<br>    }<br>    return cycleNum;<br>  }","like_count":4,"discussions":[{"author":{"id":1712219,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/20/5b/05516921.jpg","nickname":"Miki","note":"","ucode":"09C0E4E0641CDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368925,"discussion_content":"为什么深度优先的level是从0开始？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618883140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1247965,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","nickname":"Geek_41d472","note":"","ucode":"DEC2B6329460CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293574,"discussion_content":"优秀,我想破脑袋都没想出来怎么计算这个深度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595584939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390375,"avatar":"https://static001.geekbang.org/account/avatar/00/15/37/27/b023ada7.jpg","nickname":"kaiser","note":"","ucode":"F9438786E9A57B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256494,"discussion_content":"// 采用广度优先搜索算法 这句注释写错了，应该是深度优先搜索算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588487359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46374,"user_name":"他在她城断了弦","can_delete":false,"product_type":"c1","uid":1242521,"ip_address":"","ucode":"3D91CA87B64C8B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/99/454b17c1.jpg","comment_is_top":false,"comment_ctime":1543910085,"is_pvip":false,"replies":[{"id":"16673","content":"不大行   因为深度优先也可以用非递归的方式实现","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543974301,"ip_address":"","comment_id":46374,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18723779269","product_id":100017301,"comment_content":"可不可以这样理解，深度优先用递归思想，广度优先用迭代思想？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431433,"discussion_content":"不大行   因为深度优先也可以用非递归的方式实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543974301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77115,"discussion_content":"递归 都可以搞成循环遍历的，就是迭代。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575889578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59160,"user_name":"Justin","can_delete":false,"product_type":"c1","uid":1244003,"ip_address":"","ucode":"484753EFCB9F4F","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/63/add33f23.jpg","comment_is_top":false,"comment_ctime":1547309560,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14432211448","product_id":100017301,"comment_content":"觉得这一章代码这一段的讲得不详细，代码也没有什么注释，感觉理解很费劲","like_count":3,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86960,"discussion_content":"同感，而且感觉广度优先遍历的代码给我感觉是像再做深度优先遍历，图的初始化也不合理，把下标作为了图中元素的值","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576634262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033321,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c4/69/1946f360.jpg","nickname":"行望星烁","note":"","ucode":"A779CE310F0BFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376021,"discussion_content":"而且命名也很随意，完全不能见名知意，难以想象这是google工程师的代码","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1621929429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376783,"discussion_content":"广度优先搜索的分解图中，为什么我感觉最后一张图的visited[6]=0呀？看代码不是return返回回去了么？求大佬解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622343518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55458,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1546184959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14431086847","product_id":100017301,"comment_content":"<br>思考题 2、图的特点：顶点和边（顶点之间的连接关系）。<br><br>迷宫，选一个入口作为起始顶点，遇到岔路口，将岔路口作为顶点，并建立连接关系（边），终止条件应该是：到出口 或者 到下一个路口之后不能再前进为止。这里仍然用深度优先搜索的方法实现。<br>","like_count":3},{"had_liked":false,"id":47982,"user_name":"gesanri","can_delete":false,"product_type":"c1","uid":1121174,"ip_address":"","ucode":"AE3B97DC3ED668","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELtOO0HKrj5SI5JSlmwiaCvaF6GLiaTmf5NX88OZaO3HymTAGTeIoicBUjqzmMF6sF5raPFjuqLFibrrw/132","comment_is_top":false,"comment_ctime":1544278199,"is_pvip":false,"replies":[{"id":"17172","content":"路径的意思你理解错了 你可以看下prev数组","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544407198,"ip_address":"","comment_id":47982,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14429180087","product_id":100017301,"comment_content":"没明白文中说的广度优先遍历是起始顶点到终止顶点的最短路径是什么意思？就举的这个例子来说，按照广度优先的算法，一直到倒数第二个顶点才扫描到终止节点，总共经历了七个顶点，而肉眼上看明显有更短的路径，比如0346，只经历了四个顶点","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431971,"discussion_content":"路径的意思你理解错了 你可以看下prev数组","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544407198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45906,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1543816366,"is_pvip":false,"replies":[{"id":"16679","content":"可以的。看你用什么信息去查找 以及怎么定义找到。所谓相同节点 这个说法有点笼统了 怎样才算两个节点相同呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543974704,"ip_address":"","comment_id":45906,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14428718254","product_id":100017301,"comment_content":"老师把广度和深度优先搜索讲的真的是通俗易懂。我有个问题是，如果图中存在相同的节点，两种算法是不是就不能工作了？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431263,"discussion_content":"可以的。看你用什么信息去查找 以及怎么定义找到。所谓相同节点 这个说法有点笼统了 怎样才算两个节点相同呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543974704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010922,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6c/ea/ce9854a5.jpg","nickname":"坤","note":"","ucode":"74E6838226A405","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6799,"discussion_content":"比如说value相同，顶点映射到数组的索引就失效了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567126807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144108,"user_name":"标签","can_delete":false,"product_type":"c1","uid":1235287,"ip_address":"","ucode":"38441CF5571B82","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/57/7848fd65.jpg","comment_is_top":false,"comment_ctime":1571843805,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10161778397","product_id":100017301,"comment_content":"看不懂广度优先搜索那个图，1出列的时候queue队列不是应该先入2再入4吗。","like_count":2,"discussions":[{"author":{"id":1985779,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/4c/f3/6d6def2a.jpg","nickname":"张斌辉","note":"","ucode":"D8D2E278F86F15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389893,"discussion_content":"先入2还是先入4，其实不重要，就是把图用链表存的时候，跟在1后面是2还是4，这个不影响广度优先算法的结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629472150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1391065,"avatar":"https://static001.geekbang.org/account/avatar/00/15/39/d9/cab2deab.jpg","nickname":"沃特 折 法克！","note":"","ucode":"11C1E59B951AD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1985779,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/4c/f3/6d6def2a.jpg","nickname":"张斌辉","note":"","ucode":"D8D2E278F86F15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560275,"discussion_content":"我用24推了一下  结果确实依然是6410","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649246694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389893,"ip_address":""},"score":560275,"extra":""}]}]},{"had_liked":false,"id":113710,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1563136033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10153070625","product_id":100017301,"comment_content":"1. 开篇问题可以用 dfs 来解决，可以通过限制递归深度的方式来做到。<br>2. 如何存迷宫？我想到了以下几种方法：<br>1) 开一个二维数组 G[i][j]，0 表示为可走的路，1 表示为墙走不过去。<br>2) 用邻接矩阵的方式, Adj[i][j] = 1 表示 i 到 j 存在可以走的路；注意迷宫可能为一个无向图，所以 Adj[i][j] = Adj[j][i] = 1;<br>3) 用邻接表的方式，把每个点可以走到的下一个点存到这个点的链表中去。","like_count":2},{"had_liked":false,"id":45992,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1543829135,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10133763727","product_id":100017301,"comment_content":"我感觉用深度优先查找人脉的算法可能会把小于这个度数的数据查找出来吧，例如查找度数为3的顶点，用文中广度优先搜索的那个数据，使用深度优先的算法会把0，1，4，3也给查出来。。。","like_count":2},{"had_liked":false,"id":45895,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1543814802,"is_pvip":false,"replies":[{"id":"16541","content":"因为6已经是终止节点了 所以不用再入队列了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543889029,"ip_address":"","comment_id":45895,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10133749394","product_id":100017301,"comment_content":"广度搜索图， 4 出队列的时候 queue 应该是  2 5 6 吧","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431258,"discussion_content":"因为6已经是终止节点了 所以不用再入队列了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543889029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582672,"discussion_content":"我也有同样的问题，但是好像很少人有疑问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659584581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45870,"user_name":"NeverMore","can_delete":false,"product_type":"c1","uid":1228498,"ip_address":"","ucode":"582698D772810D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d2/3d88cb8e.jpg","comment_is_top":false,"comment_ctime":1543807325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10133741917","product_id":100017301,"comment_content":"深度与广度应该都是可以互相实现的，主要复杂度问题。深度主要使用栈，广度主要使用堆。","like_count":2},{"had_liked":false,"id":252681,"user_name":"Edison","can_delete":false,"product_type":"c1","uid":1135701,"ip_address":"","ucode":"734A561F363720","user_header":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","comment_is_top":false,"comment_ctime":1602431586,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5897398882","product_id":100017301,"comment_content":"老师，算法与数据结构这块一直很难掌握，就算有些算法题都刷过了，但是过一阵子又忘了，或者遇到类似的题目依然不会做。如果去大厂，算法与数据结构是绕不开的。","like_count":1,"discussions":[{"author":{"id":2241471,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erqHQZANVl9eaPTx4kVv0BNLGWNKa3ib4HnOrDMwicribfw5J4NW2QibpZj79pjicB2UffJnY2Tp1abmuQ/132","nickname":"LICHENSM","note":"","ucode":"4906C027C59500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351681,"discussion_content":"我也是一样当时都会,思想也知道,过段时间还是会忘,难整","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614395152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216850,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1589354603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884321899","product_id":100017301,"comment_content":"学习笔记:<br>深度优先搜索和广度优先搜索是最暴力的图的搜索算法。算法的目标是，给定一张图，一对初始和终止节点，找到两节点之间的节点路径。<br>算法非常好理解：广度优先搜索是一层一层搜索，广度优先搜索是搜到底，不能走了在回溯。<br>但是算法的实现就不容易了。比起之前的算法，最直观的是，不能原地实现，一定会有空间复杂度消耗。<br>用到的数据结构:<br>1. 广度优先搜索：visited数组，queue表示已访问但未深入的节点(当前边界)，prev数组访问节点的前驱<br>2. 深度优先搜索：visited数组，found表示已经找到、prev表示访问节点的前驱。<br>visited数组，我之前就知道。queue队列和found变量是我之前没记得的。<br>prev对我来说是全新的。该数组解决了搜索到之后，打印的路径问题。<br>更具体的实现:<br>1. 广度优先搜索:<br>    1. 准备部分:visited清零，prev置-1。queue加入s节点，visited s 置true。<br>    2. 开始循环，queue不为空，则取出队头，遍历队头的邻接链表中的节点，如果节点没访问过，将visited中对应位置置true，判断其是否为t，是则打印路径，退出。否则将prev对应位置置为它的前驱。queue中加入它的邻接链表中的节点。<br>2. 深度优先搜索:<br>    1. 准备数据和广度类似只不过不需要队列queue，而是需要一个found（全局变量，因为所有的递归函数都是靠它判断是否停止的，不是全局的话，回溯时这个变量无法更新）变量标识：found变量置为false。<br>    2. 进入递归 深度优先搜索。先判断found变量，true则返回 在判断 s==t，true则found=true，返回。在进入循环遍历s的邻接表，对邻接表内的每一个节点调用深度优先搜索。<br>复杂度:图算法的复杂度都跟 边和节点的数量有关。广度的时间复杂度为O(v+E)但是连通图E一定大于V所以O（E）。空间复杂度主要是节点的消耗O(V)。深度优先搜索的时间复杂度，主要访问的也是边，所以O（E）。空间复杂度为O(V)<br>思考题：<br>1. 三度友好关系:可将visited数组稍加改造，不为0表示已访问，同时数字表示几度友好关系。<br>广度优先搜索中，如果后继节点的好友关系是3，则不把它放入队列中。<br>深度优先搜索时，如果visited数组中是3则不再往下深入递归。<br>2. 岔路口为节点，岔路口之间的路径为边","like_count":1},{"had_liked":false,"id":178918,"user_name":"赵赟","can_delete":false,"product_type":"c1","uid":1164481,"ip_address":"","ucode":"B027E6F3449F9C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/c1/1118e24e.jpg","comment_is_top":false,"comment_ctime":1581855224,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876822520","product_id":100017301,"comment_content":"线程安全的版本。<br><br>&#47;**<br>* dfs 搜索到的路径不一定是最短路径<br>*&#47;<br>public void dfs(int s, int t) {<br>    final AtomicReference&lt;Boolean&gt; found = new AtomicReference&lt;&gt;(false);<br>    <br>    boolean[] visited = new boolean[v];<br>    Arrays.fill(visited, false);<br>    <br>    int[] prev = new int[v];<br>    Arrays.fill(prev, -1);<br>    <br>    recurDfs(found, visited, prev, s, t);<br>    print(prev, t);<br>}<br><br>private void recurDfs(AtomicReference&lt;Boolean&gt; found, boolean[] visited, int[] prev, int s, int t) {<br>    if (visited[s] || found.get()) {<br>        return;<br>    }<br>    if (s == t) {<br>        found.set(true);<br>        return;<br>    }<br>    visited[s] = true;<br>    for (Integer i : adj[s]) {<br>        prev[i] = s;<br>        recurDfs(found, visited, prev, i, t);<br>    }<br>}","like_count":1},{"had_liked":false,"id":170189,"user_name":"拉啦啦","can_delete":false,"product_type":"c1","uid":1389164,"ip_address":"","ucode":"1F36C0FB2AA0CC","user_header":"https://static001.geekbang.org/account/avatar/00/15/32/6c/cc82a2d0.jpg","comment_is_top":false,"comment_ctime":1578545452,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5873512748","product_id":100017301,"comment_content":"广度优先的queue为什么是01342，而不是01324","like_count":1,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273846,"discussion_content":"这个没必要纠结吧，2、4放在值为1下面的链表中，2放在前面就是2先，4放在前面就是4先","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590504396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390375,"avatar":"https://static001.geekbang.org/account/avatar/00/15/37/27/b023ada7.jpg","nickname":"kaiser","note":"","ucode":"F9438786E9A57B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255481,"discussion_content":"我也感觉应该队列入队顺序是 01324","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588404549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159883,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1575817132,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5870784428","product_id":100017301,"comment_content":"三度好友问题可以用广度优先搜索解决，深度优先搜索用的是回溯思想 递归解决。BFS和DFS的时间复杂度是O(E)边，空间复杂度O(V)顶点个数。","like_count":1,"discussions":[{"author":{"id":1350730,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJYEdMwBDUC6lDsNOFlRxdOXkUheMKUTWpYtK1KRuGGicS2dwyrKiasicvk1A1A8dExlRXkx5iaX4Xdjw/132","nickname":"天星之主","note":"","ucode":"7BC9E42B2280F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85729,"discussion_content":"到处都能看到大师兄的影子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576570045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131550,"user_name":"叶致习","can_delete":false,"product_type":"c1","uid":1510429,"ip_address":"","ucode":"38E399769699D9","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/1d/f21977c8.jpg","comment_is_top":false,"comment_ctime":1567790919,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5862758215","product_id":100017301,"comment_content":"private LinkedList&lt;integer&gt; adj[];这句话是什么意思哈","like_count":1,"discussions":[{"author":{"id":1357303,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKg3ia2DDFuGLZRtHw6to43icxKyia1eHbxTUh1CY1dSuTp5WmQN01A1aLAia1lkaR8EAkXD4h76n8Bog/132","nickname":"Hxd","note":"","ucode":"B8B04AA5738CC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26568,"discussion_content":"声明一个存储LinkedList链表类型的数组","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570608679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77121,"discussion_content":"em 单词 Adjacency 邻接 的缩写。。。即 邻接数组，\n因为元素是链表，那这个就是 邻接表了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575889738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40116,"discussion_content":"邻接表的存储方式,可以看前几节的图","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572082100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96138,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1558341427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853308723","product_id":100017301,"comment_content":"##图：邻接表存储<br>graph = {0:[1,3],1:[0,2,4],2:[1,5],3:[0,4],4:[1,3,5,6],5:[2,4,7],6:[4,7],7:[5,6]}<br>##广度优先搜索：用户的3度好友关系<br>def bfs(s,deg):<br>    v = 8 #顶点个数<br>    visited = {}<br>    prev = {}<br>    que = Queue.Queue()<br>    for i in range(v):<br>        visited[i] = False<br>        prev[i] = -1<br>    que.put(s)<br>    visited[s] = True<br>    dist = {} ##记录每个顶点与s的距离<br>    dist[s] = 0<br>    friends = []<br>    while not que.empty():<br>        ele = que.get()<br>        for i in graph.get(ele):<br>            if not visited.get(i):<br>                dist[i] = dist[ele]+1<br>                if dist[i] &gt; deg:<br>                    break<br>                prev[i] = ele<br>                visited[i] = True<br>                que.put(i)<br>                friends.append(i)<br>    return friends,prev<br><br>print(bfs(0,4))","like_count":1},{"had_liked":false,"id":84096,"user_name":"石将从","can_delete":false,"product_type":"c1","uid":1375617,"ip_address":"","ucode":"12F43E643D1D58","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/81/1864f266.jpg","comment_is_top":false,"comment_ctime":1554782497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849749793","product_id":100017301,"comment_content":"代码有注释就好了","like_count":1},{"had_liked":false,"id":78651,"user_name":"石将从","can_delete":false,"product_type":"c1","uid":1375617,"ip_address":"","ucode":"12F43E643D1D58","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/81/1864f266.jpg","comment_is_top":false,"comment_ctime":1553211035,"is_pvip":false,"replies":[{"id":"28614","content":"是的 不只一个","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553217613,"ip_address":"","comment_id":78651,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848178331","product_id":100017301,"comment_content":"有个疑问，广度优先搜索，最短路径不止一个吧，比如 s(0)-&gt;t(5) 路径有三种： 0-&gt;1-&gt;2-&gt;5,  0-&gt;3-&gt;4-&gt;5, 0-&gt;1-&gt;4-&gt;5","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444178,"discussion_content":"是的 不只一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553217613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67691,"user_name":"Bryce","can_delete":false,"product_type":"c1","uid":1286669,"ip_address":"","ucode":"E504AB8F2CA1A1","user_header":"https://static001.geekbang.org/account/avatar/00/13/a2/0d/e72f5e75.jpg","comment_is_top":false,"comment_ctime":1550223384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5845190680","product_id":100017301,"comment_content":"@許敲敲 交流学习，望指正<br>bfs 和 dfs 的 python 实现。现根据课程里的思想自己独立实现一遍，然后再分析老师提供的代码，如果实现的方式有些差距，则将老师提供的代码写成 python 版，dfs 除了递归实现还进一步实现了非递归显式用栈的方式。https:&#47;&#47;github.com&#47;Brycexxx&#47;data-structure-algorithm&#47;blob&#47;master&#47;graph.py","like_count":1},{"had_liked":false,"id":47683,"user_name":"追风者","can_delete":false,"product_type":"c1","uid":1055092,"ip_address":"","ucode":"879BC372A6B605","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","comment_is_top":false,"comment_ctime":1544180136,"is_pvip":false,"replies":[{"id":"17189","content":"1 找到t<br>2 队列空<br><br>都会导致搜索退出","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544407928,"ip_address":"","comment_id":47683,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5839147432","product_id":100017301,"comment_content":"王老师，广度优先搜索代码的递归退出条件可以再解释一下吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431855,"discussion_content":"1 找到t\n2 队列空\n\n都会导致搜索退出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544407928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47246,"user_name":"。。。","can_delete":false,"product_type":"c1","uid":1267092,"ip_address":"","ucode":"F4D90A500B66D3","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/94/cefb8a05.jpg","comment_is_top":false,"comment_ctime":1544088371,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5839055667","product_id":100017301,"comment_content":"谢谢老师 以前从来没有了解过图，老师通俗的讲解过后发现原来是那么的简单。这个专栏买的是真的超值。数据机构和算法入门最佳专栏啊","like_count":1,"discussions":[{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582671,"discussion_content":"红黑树学会了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659584509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46297,"user_name":"meng","can_delete":false,"product_type":"c1","uid":1252478,"ip_address":"","ucode":"0A497CA3B5C67B","user_header":"","comment_is_top":false,"comment_ctime":1543895004,"is_pvip":false,"replies":[{"id":"16675","content":"是不大符合命名规范 但为了代码简洁 故意这么写的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543974494,"ip_address":"","comment_id":46297,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5838862300","product_id":100017301,"comment_content":"提个小建议，代码里有些变量名比如 q, v, t，总是不太清楚它们的意思，能否起个更有意义的名字 ？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431414,"discussion_content":"是不大符合命名规范 但为了代码简洁 故意这么写的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543974494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45923,"user_name":"nothing","can_delete":false,"product_type":"c1","uid":1250912,"ip_address":"","ucode":"49058C9095281D","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/60/d6024ae8.jpg","comment_is_top":false,"comment_ctime":1543819160,"is_pvip":false,"replies":[{"id":"16535","content":"这个没有非得说要不要用adt吧 但是如果场景非常符合adt的特性 建议还是用adt。可以参考 栈那一节的说明","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543888265,"ip_address":"","comment_id":45923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5838786456","product_id":100017301,"comment_content":"老师想问问你，您觉得抽象数据类型重要吗，算法实现采用ADT来实现是否重要呢，因为我看到网上的还是您写的一些代码很多都是直接面向物理存储结构，比如数组链表。 但是我们老师在课上都要求我们一定要用ADT，但是我对这个不是很理解。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431272,"discussion_content":"这个没有非得说要不要用adt吧 但是如果场景非常符合adt的特性 建议还是用adt。可以参考 栈那一节的说明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543888265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45834,"user_name":"Allen Zou","can_delete":false,"product_type":"c1","uid":1121996,"ip_address":"","ucode":"869093D74E5EF3","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/cc/ee358b34.jpg","comment_is_top":false,"comment_ctime":1543801780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838769076","product_id":100017301,"comment_content":"老师，深度优先代码中recurseDfs函数中循环的每次迭代加found 判断可以少一些函数调用","like_count":1},{"had_liked":false,"id":359120,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1665279106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665279106","product_id":100017301,"comment_content":"总结：<br>1. 深度优先 回溯思想<br>2. 广度优先 使用栈<br><br>1. 深度优先通过一个距离值来确定<br>2. 使用邻接表，每个分岔点都作为一个节点存储","like_count":0},{"had_liked":false,"id":352763,"user_name":"焦太郎","can_delete":false,"product_type":"c1","uid":1325464,"ip_address":"","ucode":"72D48AD49C07C3","user_header":"https://static001.geekbang.org/account/avatar/00/14/39/98/4c96c6f4.jpg","comment_is_top":false,"comment_ctime":1658917796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658917796","product_id":100017301,"comment_content":"读广度优先算法的时候，思想一直抛锚到最短路径上去了，忘了这是讲搜索算法而不是讲最短路径算法。然后就一直在想 这 深度优先算法根本不是最短路径啊 ，然后再回头看了下标题 ，恍然大悟，这节讲的原来是搜索，不是最短路径😂","like_count":0},{"had_liked":false,"id":344600,"user_name":"swag~","can_delete":false,"product_type":"c1","uid":2989201,"ip_address":"","ucode":"EFE43DB6401B9C","user_header":"https://static001.geekbang.org/account/avatar/00/2d/9c/91/f9b7c773.jpg","comment_is_top":false,"comment_ctime":1651664017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651664017","product_id":100017301,"comment_content":"为什么代码从三十讲之后就没有了呢，作者能补上吗？","like_count":0},{"had_liked":false,"id":341194,"user_name":"好吃二师兄","can_delete":false,"product_type":"c1","uid":1242173,"ip_address":"","ucode":"A367B52BC79199","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/3d/ec3d6348.jpg","comment_is_top":false,"comment_ctime":1649413134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649413134","product_id":100017301,"comment_content":"    &#47;**<br>     * 查找s的三度优先好友<br>     *<br>     * @param s s<br>     *&#47;<br>    public static void findThreeDegreeFriendship(int s, Graph graph) {<br>        int v = graph.v;<br>        LinkedList&lt;Integer&gt;[] adj = graph.adj;<br><br>        &#47;&#47; 记录已经被访问过的顶点，避免重复访问<br>        boolean[] visited = new boolean[v];<br>        visited[s]=true;<br><br>        &#47;&#47; 队列，用于驱动从顶点往外层一层层的遍历<br>        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();<br>        queue.add(s);<br><br>        int level = 0;<br>        while (queue.size() != 0) {<br>            if (level &gt; 3) {<br>                break;<br>            }<br><br>            &#47;&#47; 队列宽度，依据这个队列宽度来区分层级<br>            int width = queue.size();<br><br>            for (int i = 0; i &lt; width; ++i) {<br>                int w = queue.poll();<br>                if (level &gt; 0) {<br>                    System.out.println(w);<br>                }<br>                for (int j = 0; j &lt; adj[w].size(); ++j) {<br>                    int q = adj[w].get(j);<br>                    if (!visited[q]) {<br>                        visited[q] = true;<br>                        queue.add(q);<br>                    }<br>                }<br>            }<br><br>            level++;<br>        }<br>    }","like_count":0},{"had_liked":false,"id":341181,"user_name":"痕酉","can_delete":false,"product_type":"c1","uid":1379017,"ip_address":"","ucode":"3E9BAF9136E586","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epxa4R9wsGic4zz6vhndhpM4PibiavVbtVZgI7rzfVR23yasTnhcAkz2BqmdTjX53XYgvKv4LVh84HyA/132","comment_is_top":false,"comment_ctime":1649406348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649406348","product_id":100017301,"comment_content":"看到广度优先遍历这里，visited和prev这两个辅助变量的设计真实巧妙。visited应该是保证“最短路径”的关键，体会到了算法之美。","like_count":0},{"had_liked":false,"id":339714,"user_name":"侯恩训","can_delete":false,"product_type":"c1","uid":1162376,"ip_address":"","ucode":"F4DC47EECA0F00","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/88/fbb6022e.jpg","comment_is_top":false,"comment_ctime":1648305644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648305644","product_id":100017301,"comment_content":"图的搜索算法：<br>广度优先搜索算法：借助队列<br>深度优先搜索算法：适合解决迷宫问题","like_count":0},{"had_liked":false,"id":338481,"user_name":"Null","can_delete":false,"product_type":"c1","uid":1382587,"ip_address":"","ucode":"A7D4DF2A43C7D8","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/bb/9299fab1.jpg","comment_is_top":false,"comment_ctime":1647518356,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647518356","product_id":100017301,"comment_content":"感觉深度优先跟回溯并没太大的关系，并没有 “发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法”，这种标准回溯解决问题的方法和策略。","like_count":0},{"had_liked":false,"id":337908,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1647156407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647156407","product_id":100017301,"comment_content":"思考题：<br>1. 深度优先搜索也可以算 3 度，用一个参数记录当前走到了第几度， 第三度的时候进回溯<br>2. 迷宫里有几个要素：入口（一个），出口（一个或多个），墙壁（若干），通道（若干可能交叉）； <br>如果迷宫路线很多，用矩阵来表示是比较直观的，1表示通道，0 表示墙壁，最边上的两个 1 表示入口和出口；<br>如果迷宫路线很少，用邻接表表示，可以设计循环链表表示死路，null指向的链表表示断路，非 target 的链表表示走错路了，但是可玩性感觉没有矩阵高","like_count":0},{"had_liked":false,"id":331139,"user_name":"Hunter_Dark","can_delete":false,"product_type":"c1","uid":1342279,"ip_address":"","ucode":"3A07CCBC250B69","user_header":"https://static001.geekbang.org/account/avatar/00/14/7b/47/96dad3ff.jpg","comment_is_top":false,"comment_ctime":1642446437,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642446437","product_id":100017301,"comment_content":"理解错回溯了。我以为回溯是真的要重新遍历下原先访问过的节点，其实是恢复之前的“被递归中断”的遍历？是这意思吗？","like_count":0},{"had_liked":false,"id":329388,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1641309725,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1641309725","product_id":100017301,"comment_content":"private void print(int[] prev, int s, int t) { &#47;&#47; 递归打印s-&gt;t的路径 if (prev[t] != -1 &amp;&amp; t != s) { print(prev, s, prev[t]); } System.out.print(t + &quot; &quot;);} 这个没有找到结束的路径呀","like_count":0},{"had_liked":false,"id":327313,"user_name":"iPolaris","can_delete":false,"product_type":"c1","uid":1521172,"ip_address":"","ucode":"48ED4FCF00B84F","user_header":"https://static001.geekbang.org/account/avatar/00/17/36/14/ae0d3bf1.jpg","comment_is_top":false,"comment_ctime":1640057214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640057214","product_id":100017301,"comment_content":"老师这篇dfs和bfs讲解例子使用的数据结构是图，图的分层遍历或者递归对于很多新手来说看起来是比较困难的，建议基础入门的同学可以去找二叉树的例子来看，然后再来看老师这篇会比较容易理解","like_count":0},{"had_liked":false,"id":324305,"user_name":"小竹子","can_delete":false,"product_type":"c1","uid":2813766,"ip_address":"","ucode":"D20F56114426EA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erX65FTLyn3JMbqLKdFkkv9okdx7qmVIibl1zKB7pnCIbtElSgibULma5cTsSMyS5KGMBy5MRdXtN8g/132","comment_is_top":false,"comment_ctime":1638365320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638365320","product_id":100017301,"comment_content":"摘录于《漫画算法2》<br>&#47;&#47;深度优先搜索<br>public static void dfs(Graph graph,int start,boolean[] visited){<br>    System.out.printlin(graph.vertexes[start].data);<br>    visited[start]=true;<br>    for(int index : graph.adj[start]){<br>        if(!visited[index]){<br>        dfs(graph,index,visited);<br>        }<br>   }<br>}<br>&#47;&#47;图的顶点<br>private static class Vertex{<br>   int data;<br>   Vertex(int data){<br>   this.data=data;<br>   }<br>}<br>&#47;&#47;图（邻接表）<br>private static class Graph{<br><br>   private int size;<br>   private Vertex[] vertexes;<br>   private LinkedList&lt;Integer&gt;[] adj;<br>   Graph(int size){<br>       this.size=size;<br>       &#47;&#47;初始化顶点和邻接矩阵<br>      vertexes =new Vertex[size];<br>      adj=new LinkedList[size];<br>      for(int i=0;i&lt;size;i++){<br>         vertexes[i] =new Vertex(i);<br>         adj[i]=new LinkedList();<br>      }<br><br>   }<br>}","like_count":0},{"had_liked":false,"id":312496,"user_name":"while (1)等;","can_delete":false,"product_type":"c1","uid":1061991,"ip_address":"","ucode":"BAEC7258D65B69","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/67/06a7f9be.jpg","comment_is_top":false,"comment_ctime":1631843369,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1631843369","product_id":100017301,"comment_content":"老师你好，在广度优先搜索的分解图里，1出队的时候，为什么是4在2前面入队，要是2在4前面入队，就不是最短路径了。这地方有些困惑，希望老师指点一下，谢谢。","like_count":0},{"had_liked":false,"id":308818,"user_name":"Juniper","can_delete":false,"product_type":"c1","uid":1174794,"ip_address":"","ucode":"1BC24554034BD3","user_header":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","comment_is_top":false,"comment_ctime":1629809865,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629809865","product_id":100017301,"comment_content":"本人愚笨，有个问题，请教下大家。BFS中，从上一层到下一层的执行循序，是根据邻接表里的链表存储顺序决定的，如其实值0，链表里顺序是1-&gt;3,所里queue的入队顺序就是1，3.但是到下一层的时候，入队顺序是4，2而不是2，4，这是为什么？","like_count":0,"discussions":[{"author":{"id":1379017,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epxa4R9wsGic4zz6vhndhpM4PibiavVbtVZgI7rzfVR23yasTnhcAkz2BqmdTjX53XYgvKv4LVh84HyA/132","nickname":"痕酉","note":"","ucode":"3E9BAF9136E586","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560621,"discussion_content":"实际顺序应该就是2,4。可能是作者在图中仅做示意，没有太严谨吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649406631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308166,"user_name":"张斌辉","can_delete":false,"product_type":"c1","uid":1985779,"ip_address":"","ucode":"D8D2E278F86F15","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4c/f3/6d6def2a.jpg","comment_is_top":false,"comment_ctime":1629436080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629436080","product_id":100017301,"comment_content":"给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系<br>在争哥的代码上修改，按广度优先算法实现：<br><br>int count = 0;<br>int[] depth_array = new int[v];<br>&#47;&#47;数组下标代替顶点，每个顶点的深度值初始化为0<br>for (int i = 0; i &lt; v; ++i) {<br>    int depth_array[i] = 0;<br>};<br><br>public void bfs(int s, int depth) {<br>  if (count == depth) return;<br>  boolean[] visited = new boolean[v];<br>  visited[s]=true;  <br>  Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();<br>  queue.add(s);<br>  while (queue.size() != 0) {<br>    int w = queue.poll();<br>\tcount = depth[w]+1; &#47;&#47;w作为顶点之后，解下来访问的就是它的深度+一个度的顶点了。<br>\t&#47;&#47;必须要等所有同一度的顶点都遍历完，才能退出循环;<br>\tif(count &gt; depth){<br>\t\treturn;<br>\t\t&#47;&#47;或者将depth_array 中所有值=depth 的下标找到，就是对应的depth度好友顶点；<br>\t}else<br>\t{<br>\t\tfor (int i = 0; i &lt; adj[w].size(); ++i) {<br>\t\t\tint q = adj[w].get(i);<br>\t\t\tif (!visited[q]) {<br>\t\t\t\tvisited[q] = true;<br>\t\t\t\tqueue.add(q);<br>\t\t\t\tdepth(q) = count; &#47;&#47;数组里面q顶点对应的深度就是count<br>\t\t\t}<br>\t\t}<br>\t}<br>   <br>  }<br>}","like_count":0},{"had_liked":false,"id":306884,"user_name":"大明猩","can_delete":false,"product_type":"c1","uid":1494622,"ip_address":"","ucode":"61D330B42AE3C4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/5e/b103d538.jpg","comment_is_top":false,"comment_ctime":1628761915,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628761915","product_id":100017301,"comment_content":"广度优先遍历prev数组没搞懂","like_count":0},{"had_liked":false,"id":305466,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1627983311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627983311","product_id":100017301,"comment_content":"深度优先搜索也可以做，记录搜索的深度，也就是经过边的个数，如果大于2了就不继续往下了，同时用一个数组来存放结果","like_count":0},{"had_liked":false,"id":305465,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1627983244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627983244","product_id":100017301,"comment_content":"迷宫如何用邻接矩阵存储的话就可以每个节点记录该位置是否可以通行","like_count":0},{"had_liked":false,"id":297891,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623833694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623833694","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":289998,"user_name":"幻影","can_delete":false,"product_type":"c1","uid":1740208,"ip_address":"","ucode":"E98DDC420A6E00","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8d/b0/520f65d4.jpg","comment_is_top":false,"comment_ctime":1619315266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619315266","product_id":100017301,"comment_content":"迄今为止，图算最难得吧","like_count":0},{"had_liked":false,"id":287335,"user_name":"徐改","can_delete":false,"product_type":"c1","uid":1298380,"ip_address":"","ucode":"82276A584AC602","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","comment_is_top":false,"comment_ctime":1617887818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617887818","product_id":100017301,"comment_content":"使用Go实现的非递归深度优先搜索算法：<br>type Graph struct {<br>\tv int\t\t&#47;&#47; 顶点数<br>\tadj [][]int\t&#47;&#47;用于存储图的邻接表<br>}<br>func (g *Graph) NonRecurDFS(s, t int, prev []int, visited []bool) {<br>\tif found {<br>\t\treturn<br>\t}<br>\tif s == t {<br>\t\tfound = true<br>\t\treturn<br>\t}<br>\tvisited[s] = true<br>\tfor true {<br>\t\tallVisited := true<br>\t\tk := 0<br>\t\tfor true {<br>\t\t\tif k &lt; len(g.adj[s]) {<br>\t\t\t\tq := g.adj[s][k]<br>\t\t\t\tif !visited[q] {<br>\t\t\t\t\tprev[q] = s<br>\t\t\t\t\tif q == t {<br>\t\t\t\t\t\tfound = true<br>\t\t\t\t\t\treturn<br>\t\t\t\t\t}<br>\t\t\t\t\tvisited[q] = true<br>\t\t\t\t\ts = q<br>\t\t\t\t\tbreak<br>\t\t\t\t}<br>\t\t\t\tk++<br>\t\t\t\tcontinue<br>\t\t\t}<br>\t\t\ts = prev[s]<br>\t\t\tbreak<br>\t\t}<br>\t\tfor i := 0; i &lt; g.v; i++ {<br>\t\t\tif !visited[i] {<br>\t\t\t\tallVisited = false<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t}<br>\t\tif allVisited {<br>\t\t\tfmt.Println(&quot;invaid parameters!&quot;)<br>\t\t\treturn<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":286202,"user_name":"柯尊铖","can_delete":false,"product_type":"c1","uid":1851031,"ip_address":"","ucode":"8C3E35A76EED61","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5GIMGQPRu31calIBicDXTNJQFCgTwgaiaQJniaw8jYrPxwpxNd0nAiapYgD6OK1LrSLuSerOuURG1sQ/132","comment_is_top":false,"comment_ctime":1617188504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617188504","product_id":100017301,"comment_content":"第一个题可以用 dfs 递归，记录层次，到达三层的时候，不再递归，将当前点加入到返回值里。不过需要注意，有些点会被遍历多次，每次遍历层级不一定一样，需要将更小的层级赋予它。当一个点层级由3 变成一个更小的层级的时候，需要从返回值里去掉。","like_count":0},{"had_liked":false,"id":280895,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614448353,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614448353","product_id":100017301,"comment_content":"茶艺师学编程<br><br>思考题：<br>能，但会走不少冤枉路，除非用一个类似map的东西记录“此路已走，赶紧跑!&quot;<br>","like_count":0},{"had_liked":false,"id":279678,"user_name":"Eason","can_delete":false,"product_type":"c1","uid":1032955,"ip_address":"","ucode":"25644E24732D1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c2/fb/3b64b8dd.jpg","comment_is_top":false,"comment_ctime":1613902498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613902498","product_id":100017301,"comment_content":"代码加了一点注释。这里的邻接矩阵并不是二维数组，而是链表数组。<br><br>public void bfs(int s, int t) {<br>    if (s == t) return;<br>    <br>    &#47;&#47;访问过的标记为true<br>    boolean[] visited = new boolean[v];<br>    visited[s]=true;<br>    <br>    &#47;&#47;即将分析的顶点【自己被访问了，与之相关的顶点还没被访问】<br>    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();<br>    queue.add(s);<br>    <br>    &#47;&#47;记录来当前顶点之前的顶点<br>    int[] prev = new int[v];<br>    for (int i = 0; i &lt; v; ++i) {<br>        prev[i] = -1;<br>    }<br>    <br>    while (queue.size() != 0) {<br>        int w = queue.poll();&#47;&#47;取出队列第一项，进行分析！<br>        for (int i = 0; i &lt; adj[w].size(); ++i) {&#47;&#47;遍历所有与当前顶点有关系的顶点<br>            int q = adj[w].get(i);&#47;&#47;找到与当前顶点有关系的顶点之一，并获得该顶点的值<br>            if (!visited[q]) {&#47;&#47;该顶点没被访问过<br>                prev[q] = w;&#47;&#47;记录来到该顶点之前的顶点的值<br>                if (q == t) {<br>                    print(prev, s, t);<br>                    return;<br>                }<br>                visited[q] = true;&#47;&#47;标记：该顶点已经被访问过了<br>                queue.add(q);<br>            }<br>        }<br>    }<br>}<br><br>private void print(int[] prev, int s, int t) { &#47;&#47; 递归打印s-&gt;t的路径<br>    if (prev[t] != -1 &amp;&amp; t != s) {<br>        print(prev, s, prev[t]);<br>    }<br>    System.out.print(t + &quot; &quot;);<br>}","like_count":0},{"had_liked":false,"id":276081,"user_name":"崔崔","can_delete":false,"product_type":"c1","uid":2321812,"ip_address":"","ucode":"1DA93CAA99CBED","user_header":"https://static001.geekbang.org/account/avatar/00/23/6d/94/539c90db.jpg","comment_is_top":false,"comment_ctime":1611782253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611782253","product_id":100017301,"comment_content":"王争老师一直以来讲解的都非常清楚简洁，一直以来受益良多。但这篇文章读完之后，我觉得文章里对dfs&#47;bfs的介绍有些不准确的地方。<br><br>dfs&#47;bfs算法的主要目的是：给定一个node，遍历从该node出发所有可以到达的点（即一个联通域），并且每个点只被访问一次。在这个过程中我们可以找到一个需要的点就返回，或者在遍历过程中构建需要的结果（比如遍历文件夹，把相同的文件放到一个array里）。<br><br>bfs&#47;dfs函数的输入应该只有node（起点），visited信息，和adjacent list（如果node是一个object，有get_parent()这样的方法，连adjacant list也不需要）。但是王争老师的代码的参数里总是给了起点和终点，给人一种错觉bfs&#47;dfs必须有终点这个参数，而且他们只是用来搜索。实际上多数情况不需要终点参数，有时我们也不去找一个特定的点只是想遍历完一个联通域。<br><br>这些是我看网上一些公开课（如mit）讲dfs&#47;bfs，和做题得到的结论，如果我有说得不对的地方还请指正^^","like_count":0},{"had_liked":false,"id":262693,"user_name":"JGOS","can_delete":false,"product_type":"c1","uid":1237592,"ip_address":"","ucode":"46A905A169408F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/58/2468a5e9.jpg","comment_is_top":false,"comment_ctime":1605805542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605805542","product_id":100017301,"comment_content":"老师， 有个疑问，文中dfs的递归结束条件为什么不需要考虑不存在达到目标顶点的情况","like_count":0},{"had_liked":false,"id":253814,"user_name":"Senior6623","can_delete":false,"product_type":"c1","uid":1517590,"ip_address":"","ucode":"D8ADAE5D037FC4","user_header":"https://static001.geekbang.org/account/avatar/00/17/28/16/ca72addc.jpg","comment_is_top":false,"comment_ctime":1602905235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602905235","product_id":100017301,"comment_content":"找到后似乎还会继续遍历，其实可以不需要了，修改了下<br>    boolean found;<br>    public void dfs(int s, int t) {<br>        found = false;<br>        boolean[] visited = new boolean[v];<br>        int[] prev = new int[v];<br>        for (int i = 0; i &lt; v; i++) {<br>            prev[i] = -1;<br>        }<br>        dfsRecursive(s, t, visited, prev);<br>        print(prev, s, t);<br>    }<br><br>    private void dfsRecursive(int c, int t, boolean[] visited, int[] prev) {<br>        if (found) return;<br>        visited[c] = true;<br>        for (int i = 0; i &lt; adj[c].size(); i++) {<br>            int next = adj[c].get(i);<br>            if ( !visited[next] ) {<br>                prev[next] = c;<br>                if (next == t) { &#47;&#47; 找到则提前返回<br>                    found = true;<br>                    return;<br>                }<br>                dfsRecursive(next, t, visited, prev);<br>                if (found) {<br>                    return; &#47;&#47; 已找到，终止剩余的遍历，减少已找到后的无效遍历<br>                }<br>            }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":249161,"user_name":"王世林","can_delete":false,"product_type":"c1","uid":1076155,"ip_address":"","ucode":"2BB56D0FD71417","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/bb/10aaf123.jpg","comment_is_top":false,"comment_ctime":1600486590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600486590","product_id":100017301,"comment_content":"迷宫的话每个拐弯处可以看作一个顶点，每个顶点之间距离可以看作权重，针对具体的出口可以用广度优先算法找出最短路径","like_count":0},{"had_liked":false,"id":247882,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1599901486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599901486","product_id":100017301,"comment_content":"<br>1.答：不能，因为深度优先搜索会扰乱好友度，比如一开始深度优先搜索到3度好友，由于该顶点设置为了已访问，后续就不再访问，但是有可能这个好友只是1度好友，同时由于这个好友定为3度好友，那么本该从这个好友出发定为的3度好友就丢失了<br>2.答：将迷宫的每个门当做一个顶点，然后门和门之间的路当做边，既可以组成一个无向图","like_count":0},{"had_liked":false,"id":247881,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1599901476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599901476","product_id":100017301,"comment_content":"<br>1.答：不能，因为深度优先搜索会扰乱好友度，比如一开始深度优先搜索到3度好友，由于该顶点设置为了已访问，后续就不再访问，但是有可能这个好友只是1度好友，同时由于这个好友定为3度好友，那么本该从这个好友出发定为的3度好友就丢失了<br>2.答：将迷宫的每个门当做一个顶点，然后门和门之间的路当做边，既可以组成一个无向图","like_count":0},{"had_liked":false,"id":246505,"user_name":"小时候可鲜啦","can_delete":false,"product_type":"c1","uid":1050777,"ip_address":"","ucode":"C88B3EDF758230","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","comment_is_top":false,"comment_ctime":1599381037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599381037","product_id":100017301,"comment_content":"课后思考第二题：迷宫可以用一个二维矩阵存储，矩阵元素是一个长度为4的数组，分别对应该位置的上下左右是否连通，是为1否为0，空间复杂度为m*n*4，但是可以做到随机访问，很适合用于BFS遍历图。","like_count":0},{"had_liked":false,"id":245871,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1599099595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599099595","product_id":100017301,"comment_content":"习题，1：可以，但注意不能使用visited来规避重复入栈，因为入栈的顶点只是表明它到起始点的距离（即边的数目），但并不一定是最短距离，规避重复入栈的做法可能导致实际满足度数的节点无法被访问到。比如图（0-1；0-2；2-3；1-4；3-4；4-5），6个顶点，6条边，4到0的最短距离是2（0-1-4），但采用深度优先算法，4入栈后，就会规避从1到4的深度探索，从而影响结果的正确性。","like_count":0},{"had_liked":false,"id":245820,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1599061060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599061060","product_id":100017301,"comment_content":"习题：2，将整个迷宫抽象成含有n*m个顶点的图。任意一条路（不论是分叉的，还是直行的）均可表示为一个可连通的顶点集合。迷宫的入口为路的一个顶点，出口为路的另一个顶点，解答即搜索找到一个连通入口顶点和出口顶点的路径。<br><br>每个路的终点（断路）必然是一个顶点，每条连通的路上可能有多个顶点。如果两个顶点不同（有断路）则他们之间没有边。<br>迷宫能抽象成一个不完全连通的图","like_count":0},{"had_liked":false,"id":244295,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1598452281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598452281","product_id":100017301,"comment_content":"1 可以。递归终止条件设置为亲密度大于3。即按某个路径递归时，若节点到初始节点的距离为3，则中止该路径递归。然后记录所有节点距离，并且当某条递归路径获取的距离小于当前记录的距离时，则更新该距离。最后扫描记录中距离为3的节点，即为所求节点<br>2 将迷宫中入口，出口，分叉点记为图的顶点，顶点之间路径记为边","like_count":0},{"had_liked":false,"id":243163,"user_name":"୯yu","can_delete":false,"product_type":"c1","uid":2091963,"ip_address":"","ucode":"729DA78B8E833D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/eb/bb/517a3e9b.jpg","comment_is_top":false,"comment_ctime":1597979161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597979161","product_id":100017301,"comment_content":"王争老师， 广度优先搜索算法的分解图里面，有关prev数组是不是画错了，当3出队时，prev下标为4的位置应该是3，不是1，不知道我说得对不对，请老师指正。","like_count":0},{"had_liked":false,"id":240109,"user_name":"醉梦了红尘","can_delete":false,"product_type":"c1","uid":1889141,"ip_address":"","ucode":"DB742865BAD6B6","user_header":"","comment_is_top":false,"comment_ctime":1596763425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596763425","product_id":100017301,"comment_content":"广度优先的例子，强行把数据和索引耦合在了一起，但是现实开发中这种场景太少了，有没有大佬教一下，怎么扩展呢","like_count":0},{"had_liked":false,"id":239441,"user_name":"AlexQi","can_delete":false,"product_type":"c1","uid":1626884,"ip_address":"","ucode":"0CD77FA26BC484","user_header":"https://static001.geekbang.org/account/avatar/00/18/d3/04/7954f03a.jpg","comment_is_top":false,"comment_ctime":1596532517,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596532517","product_id":100017301,"comment_content":"用递归来实现的dfs算法，总感觉比用栈实现要多走很多步，不知对吗请各位指正<br>&#47;&#47; 用递归实现<br>private void search(E start, E end, List&lt;E&gt; visitedArr, List&lt;Node&lt;E&gt;&gt; pathList) {<br>        if (found) return;<br>        visitedArr.add(start);<br>        if (Objects.equals(start, end)) {<br>            found = true;<br>            return;<br>        }<br>        int j = getIndexFromEle(start);<br>        Set&lt;E&gt; nodes = arr.get(j).keySet();<br>        if (nodes.size() &gt; 0) {<br>            for (E node : nodes) {<br>                if (!visitedArr.contains(node)) {<br>                    pathList.add(new Node&lt;&gt;(start, node));<br>                    search(node, end, visitedArr, pathList);<br>                    if (found) break;<br>                }<br>            }<br>        }<br>    }<br>用栈实现<br>private void searchInStack(E start, E end, List&lt;E&gt; visitedArr, List&lt;Node&lt;E&gt;&gt; pathList, Stack&lt;E&gt; stack) {<br>        if (found) return;<br>        stack.push(start);<br>        E prev = start;<br>        while (!stack.isEmpty()) {<br>            E top = stack.pop();<br>            visitedArr.add(top);<br>            if (!Objects.equals(prev, top)) pathList.add(new Node&lt;&gt;(prev, top));<br>            if (Objects.equals(top, end)) {<br>                found = true;<br>                return;<br>            }<br>            int j = getIndexFromEle(top);<br>            Set&lt;E&gt; nodes = arr.get(j).keySet();<br>            if (nodes.size() &gt; 0) {<br>                for (E node : nodes) {<br>                    if (!visitedArr.contains(node)) {<br>                        stack.push(node);<br>                        prev = top;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    @Data<br>    @AllArgsConstructor<br>    @NoArgsConstructor<br>    public static class Node&lt;E&gt; {<br>        private E start;<br>        private E end;<br>    }<br>我这个图的结构也是邻接表存储，只不过是ArrayList&lt;LinkedHashMap&lt;E, Integer&gt;&gt;,Map的value代表数组下标，Map的第一个元素代表顶点，Node是定义的内部类存储路径的。","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298777,"discussion_content":"完整版的代码有吗？方法和类不全看不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597397019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236473,"user_name":"李欣洋","can_delete":false,"product_type":"c1","uid":1397084,"ip_address":"","ucode":"C467DB0FC30B13","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/5c/cb1da952.jpg","comment_is_top":false,"comment_ctime":1595423501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595423501","product_id":100017301,"comment_content":"广度遍历过程中，visited数组和prev数组的功能是不是有些重复，是否用prev[i] != -1 就可以取代visited数组的判断是否已经访问功能，设计visited数组是因为考虑 Boolean类型判断效率更高吗？","like_count":0},{"had_liked":false,"id":232107,"user_name":"軟件賺硬幣","can_delete":false,"product_type":"c1","uid":1736543,"ip_address":"","ucode":"0BB619B53A3046","user_header":"https://static001.geekbang.org/account/avatar/00/1a/7f/5f/1d82812f.jpg","comment_is_top":false,"comment_ctime":1593856326,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593856326","product_id":100017301,"comment_content":"要是字符串系列，queue和visited（顶点和下一个顶点用散列表）的记录都没问题，prev怎么记录（根本没有下标可用）","like_count":0},{"had_liked":false,"id":230648,"user_name":"Geek_dd8b2b","can_delete":false,"product_type":"c1","uid":1988075,"ip_address":"","ucode":"CBEF7C39075A96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","comment_is_top":false,"comment_ctime":1593440257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593440257","product_id":100017301,"comment_content":"老师广度优先搜索 最后一张图是不是错了，4出队列时候，不应该把他的相邻顶点，5和6加到队列，形成2，5，6这样的队列吗？","like_count":0},{"had_liked":false,"id":229023,"user_name":"豆豆","can_delete":false,"product_type":"c1","uid":1275407,"ip_address":"","ucode":"97788B134C3212","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","comment_is_top":false,"comment_ctime":1592881500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592881500","product_id":100017301,"comment_content":"以前一提到图，就颤抖，没想到还可以这样理解，大学的教材真不是给人看的","like_count":0},{"had_liked":false,"id":228220,"user_name":"慌张而黑糖","can_delete":false,"product_type":"c1","uid":1638878,"ip_address":"","ucode":"B4416885A301C8","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","comment_is_top":false,"comment_ctime":1592617083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592617083","product_id":100017301,"comment_content":"想问一下老师，这里的邻接表是不是不能有重复的数啊，我看visited那好像有重复的数据就不能用了","like_count":0},{"had_liked":false,"id":224489,"user_name":"TheStarBoys","can_delete":false,"product_type":"c1","uid":2009311,"ip_address":"","ucode":"9A6D70482F9212","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SiciaNKibn60SjA50TsTEtO09DoRA57UozylHmKckZXkJmNiaShSC0BIP6TdZC6cAphuEzmuxMHWwvpYN8P7kKb8eA/132","comment_is_top":false,"comment_ctime":1591417176,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591417176","product_id":100017301,"comment_content":"课后思考：<br>1. 可以用DFS来做，限制栈的最大深度就可以了，也就是限制dfs递归调用的深度，比如深度为最大深度为h，每次递归的时候先让 h-- , 然后在 dfs(h)，并在dfs函数中对深度当前深度h进行校验就可以了。<br>2. 迷宫可以看作是一个二维平面，直接用二维数组来存就好了。0表示可以通行，1表示路障（或者说墙），无法通行。在搜索的时候，判断下一步是0还是1就知道是否可以继续搜索了。","like_count":0},{"had_liked":false,"id":222835,"user_name":"www","can_delete":false,"product_type":"c1","uid":1898338,"ip_address":"","ucode":"ADC9BC655EA16C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f7/62/947004d0.jpg","comment_is_top":false,"comment_ctime":1590924451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590924451","product_id":100017301,"comment_content":"之前用邻接矩阵写过，今天再用邻接表写一遍，代码简洁了不少，Golang代码还是调了不少时间，编程是技能，实现出来才对","like_count":0},{"had_liked":false,"id":222320,"user_name":"你在不远的未来","can_delete":false,"product_type":"c1","uid":1318404,"ip_address":"","ucode":"5B34C8BD03B71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/04/f902047e.jpg","comment_is_top":false,"comment_ctime":1590746647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590746647","product_id":100017301,"comment_content":"&#47;&#47;优化了下 深度代码， 感觉效率和广度一样了<br>class Graph {<br>    private int v; <br>    private LinkedList&lt;Integer&gt;[] adj;<br><br>    Graph(int v) {<br>        this.v = v;<br>        this.adj = new LinkedList[v];<br><br>        for (int i = 0; i &lt; v; i++) {<br>            adj[i] = new LinkedList&lt;&gt;();<br>        }<br>    }<br><br><br>    void addEdge(int s, int t) {<br>        adj[s].add(t);<br>        adj[t].add(s);<br>    }<br><br><br>    void bfs(int s, int t) {<br>        if (s == t) return;<br><br>        &#47;&#47;已经访问定点<br>        boolean[] visited = new boolean[v];<br><br>        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();<br>        queue.add(s);<br><br>        int[] prev = new int[v];<br>        for (int i = 0; i &lt; prev.length; i++) {<br>            prev[i] = -1;<br>        }<br><br>        while (queue.size() != 0) {<br>            int q = queue.poll();<br>            LinkedList&lt;Integer&gt; qqs = adj[q];<br><br>            for (int qq : qqs) {<br>                if (!visited[qq]) {<br>                    visited[qq] = true;<br>                    prev[qq] = q;<br><br>                    if (qq == t) {<br>                        printR(prev, s, t);<br>                        return;<br>                    }<br><br>                    queue.add(qq);<br>                }<br>            }<br>        }<br>    }<br><br><br>  <br><br>    private boolean found = false;<br><br><br>    void dfs(int s, int t) {<br>        found = false;<br><br>        boolean[] visited = new boolean[v];<br><br>        int[] prev = new int[v];<br><br>        reduceDfs(s, t, visited, prev);<br>        printR(prev, s, t);<br>    }<br><br>    private void reduceDfs(int s, int t, boolean[] visited, int[] prev) {<br>        if (s == t) {<br>            found = true;<br>            return;<br>        }<br><br>        for (Integer q : adj[s]) {<br>            if (found) break;<br>            if (visited[q]) continue;<br><br>            visited[q] = true;<br>            prev[q] = s;<br>            reduceDfs(q, t, visited, prev);<br>        }<br>    }<br><br><br><br>    private void printR(int[] prev, int s, int t) {<br>        if (prev[t] != -1 &amp;&amp; t != s) {<br>            printR(prev, s, prev[t]);<br>        }<br><br>        System.out.format(&quot;%d\\t&quot;, t);<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":221851,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1590622869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590622869","product_id":100017301,"comment_content":"pipeline 的 worker 之间的连接关系就是一张图，在构建实例时，可以采用广度优先，一层层构建。","like_count":0},{"had_liked":false,"id":220396,"user_name":"社会你强哥","can_delete":false,"product_type":"c1","uid":1243570,"ip_address":"","ucode":"325B9005588D9B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","comment_is_top":false,"comment_ctime":1590234213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590234213","product_id":100017301,"comment_content":"最好把深度搜索优先把所有的路径都求出来吧","like_count":0},{"had_liked":false,"id":219420,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1590024149,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1590024149","product_id":100017301,"comment_content":"之前一直以为深度优先和广度优先是和树联系在一起的，放在图这边也完全没有违和感。<br><br>对于思考题，如果使用深度优先来搜索当然也没问题，增加一个变量记录深度，每次到 3 就结束（ &lt;4 ），应该就可以。<br><br>将迷宫换抽象成图，那么我能想到的就是将每一个路口当做顶点，然后路口（顶点）之间的每一条通路当做边。<br><br>跟随 @Jerry银银 学习了一下 queue 的发音，我之前也是错的。<br><br>看到了 @vicent 同学的留言，不知道现在的状态如何。<br><br>学习了 @kaiser 的三度好友代码，感觉上还是广度优先比 BFS 较合适，深度优先似乎效率不高。","like_count":0},{"had_liked":false,"id":217204,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1589439557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589439557","product_id":100017301,"comment_content":"代码有少许格式不太规范的地方 ，比如 = 左边没有空格，我觉得作为一个示范性的代码 标准还是要提高一点","like_count":0},{"had_liked":false,"id":215889,"user_name":"russellyue","can_delete":false,"product_type":"c1","uid":1541894,"ip_address":"","ucode":"0758ACF772F9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIMwPE6FwsicZ6bjhu7ZpWLnoib8G76sA1XL8y5W8GxqfQEjBub6g57E60mzjWzrA6icMRw1QT5CpyA/132","comment_is_top":false,"comment_ctime":1589125965,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589125965","product_id":100017301,"comment_content":"总结：广度优先算法，一层一层递进；深度优先算法先走到底，再往回，再去走其它方向。两者都是暴力搜索法。","like_count":0},{"had_liked":false,"id":215781,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1589102125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589102125","product_id":100017301,"comment_content":"60天攻克算法打卡行动第28天<br><br>学习内容 :深度和广度优先搜索：如何找出社交网络中的三度好友关系？<br><br>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法。了解它们的不同实现方式和适用场景，就能实现推荐“可能认识的人”这么一个功能。<br><br>1.什么是“搜索”算法？<br>图中的一个顶点到另一个顶点的路径。<br>2.什么是广度优先搜索（BFS）？<br>从根节点开始，相当于一层一层的节点遍历，时间复杂度 也就是所有顶点 + 边 因为E边肯定要大于 顶点数 V-1 ，所以时间复杂度是O(E),那么存储空间复杂度呢？主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。<br><br>3.什么是深度优先搜索（DFS）？<br>深度优先就是要一条路径遍历完，从根节点一直到一个叶子结点的一条完整路线，这样一条一条的遍历完所有树的节点。<br>时间O(E),空间O(V).<br><br>课后思考：<br>1、三度好友，深度搜索也可以邻接表方式。<br>迷宫可以用深度遍历的思想来做","like_count":0},{"had_liked":false,"id":214991,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1588864044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588864044","product_id":100017301,"comment_content":"将迷宫中有门的地方作为边，将连续的区域（通路）作为顶点，构建无向无权图。","like_count":0},{"had_liked":false,"id":213350,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1588391229,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588391229","product_id":100017301,"comment_content":"DFS搜索得到的不一定是最短路径，但也可能是最短路径呢","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298780,"discussion_content":"恩，取决于你邻接链表是怎么存的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597397827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210726,"user_name":"Simon","can_delete":false,"product_type":"c1","uid":1633562,"ip_address":"","ucode":"ECB05EFD735115","user_header":"https://static001.geekbang.org/account/avatar/00/18/ed/1a/59b41eb2.jpg","comment_is_top":false,"comment_ctime":1587815874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587815874","product_id":100017301,"comment_content":"找三度好友的题目，如果使用DFS可能会有点问题，就是有部分计算出来的三度好友，可能是一度或者二度。因为网状结构的连接方式不确定，在用另外节点搜索时会度数更低。还是用BFS更加靠谱一点。<br>或者加上去重机制，如果发现有人在一度二度就被搜到，就从列表里删掉。","like_count":0},{"had_liked":false,"id":200632,"user_name":"KingKong","can_delete":false,"product_type":"c1","uid":1482366,"ip_address":"","ucode":"9E31B0F8FFC4DE","user_header":"https://static001.geekbang.org/account/avatar/00/16/9e/7e/0f658ea8.jpg","comment_is_top":false,"comment_ctime":1585626570,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585626570","product_id":100017301,"comment_content":"老师，深度优先算法中我有两点不太明白。<br>1、在您举的走迷宫的例子中，画的搜索路径图，我没太明白跟DFS算法间的关系。回溯思想我没想明白在DFS算法中是如何实现的。<br>2、DFS算法我在测试的时候发现，搜索路径取决与它邻接表中节点存储的先后，比如说顶点1连通的是顶点2和4，使用addEdge方法，先addEdge(1,2)，再addEdge(1,3)的搜索路径(1-2-3-6-5-7)；和先addEdge(1,3)，再addEdge(1,2)的路径(1-4-5-2-3-6-8-7)完全不同，有些顶点没有被搜索到。有了BFS，那DFS的使用意义是什么呢？<br>如果其他各位大牛，能解答我的问题，也欢迎留言回复我。不胜感激。","like_count":0,"discussions":[{"author":{"id":2241471,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erqHQZANVl9eaPTx4kVv0BNLGWNKa3ib4HnOrDMwicribfw5J4NW2QibpZj79pjicB2UffJnY2Tp1abmuQ/132","nickname":"LICHENSM","note":"","ucode":"4906C027C59500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324263,"discussion_content":"我也发现了,我刚开始1->0,2,4和1->0,4.2得到完全不同的结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605081755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191464,"user_name":"小谢","can_delete":false,"product_type":"c1","uid":1879476,"ip_address":"","ucode":"82D54A61D2FDB9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ad/b4/e4dcd4d7.jpg","comment_is_top":false,"comment_ctime":1584775765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584775765","product_id":100017301,"comment_content":"BFS:广度优先搜索——&gt;队列这种特殊结构<br>DFS:深度优先搜索——&gt;递归回溯(能用递归就应该可以考虑栈)","like_count":0},{"had_liked":false,"id":190389,"user_name":"獨自去遠方","can_delete":false,"product_type":"c1","uid":1503941,"ip_address":"","ucode":"E246B33F397441","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/c5/2a441c27.jpg","comment_is_top":false,"comment_ctime":1584635200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584635200","product_id":100017301,"comment_content":"深度和广度优先搜索：最基本最常用-暴力搜索算法<br>\t给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？<br>\t\t使用广度优先算法<br>\t\t\t改造一下广度优先搜索代码，用一个数组来记录每个顶点与起始顶点的距离<br><br><br>\t“搜索”算法<br>\t\t在图上，从一个点到另一个点<br><br>\t广度优先搜索（BFS）<br>\t\t地毯式 层层推进<br>\t\t先记录所有的第一层，然后通过第一层推出第二层，依次向后<br>\t\t\t记录扫过的点，防止重复<br><br>\t深度优先搜索（DFS）<br>\t\t一条路走到底，如果走不通，退回上一步，选择另外的路径去走，直到退回起点的节点<br>\t\t再从起点换条路，重复上述步骤<br>\t\t直到从起点开始无路可走","like_count":0},{"had_liked":false,"id":189900,"user_name":"问心","can_delete":false,"product_type":"c1","uid":1250775,"ip_address":"","ucode":"6808568D61CE36","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/d7/96e77edd.jpg","comment_is_top":false,"comment_ctime":1584580814,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584580814","product_id":100017301,"comment_content":"深度搜索三度人脉时，需要考虑三度人脉是否已在一度和二度人脉之中。这样的话相当于先把一、二、三度人脉全查出来，然后再把一、二度人脉从三度人脉中踢出。","like_count":0},{"had_liked":false,"id":186940,"user_name":"起而行","can_delete":false,"product_type":"c1","uid":1131399,"ip_address":"","ucode":"4F116B0B740776","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/87/7604d7a4.jpg","comment_is_top":false,"comment_ctime":1583977042,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583977042","product_id":100017301,"comment_content":"树，图算法需要辅助数据结构和辅助函数。比如辅助函数，遍历并打印一颗树或一副图，打印一条路径，等等。辅助数据结构，在bfs中需要已访问节点的数组，队列，记录搜索路径，也就是每个节点在路径上的前一个节点。在dfs中同样需要已访问节点的数组和访问路径数组和栈。时空复杂度均为On","like_count":0},{"had_liked":false,"id":184074,"user_name":"jackhance","can_delete":false,"product_type":"c1","uid":1261634,"ip_address":"","ucode":"934B0D20CCD06C","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/42/d5c23178.jpg","comment_is_top":false,"comment_ctime":1583218388,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583218388","product_id":100017301,"comment_content":"BFS &amp; DFS 虽然能定位到s到t的路径，但是满足不了最短路径的要求","like_count":0},{"had_liked":false,"id":183724,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583120351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583120351","product_id":100017301,"comment_content":"思考题 <br>1.  我觉得没得问题还可以用深度优先的 因为最终都会遍历完所有的结点<br>2. 我觉得用图来存储迷宫 图中每个结点表示迷宫中的房间 而和他直接相连的房间就用邻接表来表示","like_count":0},{"had_liked":false,"id":178253,"user_name":"谢艺华","can_delete":false,"product_type":"c1","uid":1711975,"ip_address":"","ucode":"08A50F4D66ECCA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1f/67/d8c69191.jpg","comment_is_top":false,"comment_ctime":1581643690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581643690","product_id":100017301,"comment_content":"bfs算法中的21，22行，放到if条件中，是不是比较优化呢？有人能指导一下吗","like_count":0},{"had_liked":false,"id":175835,"user_name":"Geek_94adb8","can_delete":false,"product_type":"c1","uid":1638187,"ip_address":"","ucode":"B142F473E1A0B3","user_header":"","comment_is_top":false,"comment_ctime":1580867227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580867227","product_id":100017301,"comment_content":"深度优先遍历的代码中“if (found == true) return;” 这一行可以去掉吧，递归代码里有一个终止条件就够了吧。","like_count":0},{"had_liked":false,"id":174216,"user_name":"想象你的身影","can_delete":false,"product_type":"c1","uid":1785382,"ip_address":"","ucode":"F9301E3A1E76D5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTINv9F0mcuXvfOM6k7GWvrlTMjYkTpHH1XD6QtJia9R9nsCkjIrCz6AbgxS6UhSjcW6ojULv6iax8BA/132","comment_is_top":false,"comment_ctime":1580092893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580092893","product_id":100017301,"comment_content":"有没有大佬能分享下更浅显的资源读一读，然后再回过头来再看一遍老师的","like_count":0},{"had_liked":false,"id":173273,"user_name":"飘到站","can_delete":false,"product_type":"c1","uid":1796339,"ip_address":"","ucode":"0C9A9521061127","user_header":"https://static001.geekbang.org/account/avatar/00/1b/68/f3/57456c44.jpg","comment_is_top":false,"comment_ctime":1579491477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579491477","product_id":100017301,"comment_content":"1. 可以使用深度优先，限制栈的深度。<br>2. 保准迷宫 都是 X*X的，适合用无向邻接矩阵。<br>          可提供动态生成迷宫方法，入参  X，起点S，终点T;  校验 S 是否是外边， 方法暴力实现 随机删除适量的几条边，校验是否可以  S到T，可以即生成，不可以重新回复再随机删除。","like_count":0},{"had_liked":false,"id":171245,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1578885909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578885909","product_id":100017301,"comment_content":"测试代码时，print()打印可以简化为if (t != s) ，而这个prev[t] != -1 需要访问数组元素，且只有未访问和起始数据为-1，所以简化成if (t != s)作为递归终止条件就够了；recurDfs()的if (found == true) return;和if (w == t) {found = true;return;} 可读性更强，下面for的if (!visited[q])可以作为递归终止条件，但需要多付出数据访问","like_count":0},{"had_liked":false,"id":169095,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1578272992,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578272992","product_id":100017301,"comment_content":"1，什么是“搜索”算法<br>①：算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜素算法都是基于“图”这种数据结构的。因为图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。<br><br>\t2，广度优先搜索（BFS）<br>\t\t①：广度优先搜索（Breadth-First-Search）简称BFS，其实是一种“地毯式”层层推进的搜索策略，（先查找离起始顶点最近的，然后是次近的，依次往外搜索）<br><br><br>public void bfs(int s, int t) {<br>  if (s == t) return;<br>  boolean[] visited = new boolean[v];<br>  visited[s]=true;<br>  Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();<br>  queue.add(s);<br>  int[] prev = new int[v];<br>  for (int i = 0; i &lt; v; ++i) {<br>    prev[i] = -1;<br>  }<br>  while (queue.size() != 0) {<br>    int w = queue.poll();<br>   for (int i = 0; i &lt; adj[w].size(); ++i) {<br>      int q = adj[w].get(i);<br>      if (!visited[q]) {<br>        prev[q] = w;<br>        if (q == t) {<br>          print(prev, s, t);<br>          return;<br>        }<br>        visited[q] = true;<br>        queue.add(q);<br>      }<br>    }<br>  }<br>}<br><br>private void print(int[] prev, int s, int t) { &#47;&#47; 递归打印 s-&gt;t 的路径<br>  if (prev[t] != -1 &amp;&amp; t != s) {<br>    print(prev, s, prev[t]);<br>  }<br>  System.out.print(t + &quot; &quot;);<br>}<br><br>有三个重要辅助变量visited，queue，prev<br>\tvisited是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点q被访问，那相应的visited[q]会被设被设置为true。<br>\tqueue是一个队列，用来存储已经被访问，但相连的顶点还没被访问的顶点。因为广度优先搜索是逐层访问的，只有把第k层的顶点都访问完成之后，才能访问第k+1层的顶点。当我们访问到第k层的时，要把第k层的顶点记录下来，稍后才能通过第k层来找第k+1层的顶点。<br>\tprev用来记录搜索路径。当我们从顶点s开始，广度优先搜索到顶点t后，prev数组中存储的就是搜索的路径。不过这个路径是反向存储的，prev[w]存储的是，顶点w是从哪个前驱顶点遍历过来的。<br><br>②：广度优先搜索的时间，空间复杂度<br>\t时间复杂度：终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。此时每个顶点都要进出一遍队列，每个边也都会被访问一次。<br>所以广度优先搜索的时间复杂度是O(V+E)，V表示顶点的个数，E表示边的个数。<br>因为，对于一个连通图来讲，一个图中的所有顶点都是连通的，E肯定要大于等于V-1，所以广度优先搜索复杂度也可简写为O(E)。<br>\t空间复杂度：广度优先搜素的空间消耗主要在几个辅助变量visited数组，queue队列，prev数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是O(V)。<br><br>2：深度优先搜索（DFS）<br>\t①：深度优先搜索（Depth-First-Search）简称。最直观的例子就是走迷宫。<br>\t深度优先搜素用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。<br><br>\t②：深度优先搜索代码实现也用到了prev，visited变量以及print()函数，作用于广度优先搜索代码实现里相同。但深度优先搜索代码实现里。有个比较特殊的变量found，他的作用是，当我们已经找到终止顶点t之后，我们就不再递归继续查找了。<br>\t<br>时间复杂度：每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法是O(E)，E表示边的个数。<br><br>空间复杂度：深度优先搜素算法的消耗内存主要是visited，prev数组和递归调用栈。Visited，prev数组的大小跟顶点的个数V成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是O(V)。<br>","like_count":0},{"had_liked":false,"id":167105,"user_name":"Allen_","can_delete":false,"product_type":"c1","uid":1677187,"ip_address":"","ucode":"CA5E00E4644CD5","user_header":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","comment_is_top":false,"comment_ctime":1577692516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577692516","product_id":100017301,"comment_content":"怎么存迷宫？<br>首先想一想我们需要迷宫的功能，1.有“路”可以让玩家走，2.有墙可以阻止玩家走，3.再加一个我们需要迷宫标注一个最终答案。<br>然后具体实现，1.可以把一个格子的四个点当作四个坐标，2.可以把一个格子直接当成一个坐标。<br>我就选2了，具体大家可以想一想，第2会简洁很多。<br>然后怎么标识墙呢？1，存储墙的位置。2，直接存储出路的位置，墙在这是“隐形的”。<br>我选2了，2感觉要聪明一点。这时候每一个坐标有四个方向，我们可以构建(x , y)来代表一个顶点，代表的是横坐标和纵坐标。这样如果a1,b1和a2, b2之间有路的话，那我们就要存储 (a1, b1) &lt;--&gt;(a2,b2).<br>然后我们假设初始化了这么一个迷宫，接下来就是找出路了。这里用dfs，从a1 b1开始，从存储里面便利记录的出路一直找知道有出口坐标位置然后返回。 ","like_count":0},{"had_liked":false,"id":166228,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1577418666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577418666","product_id":100017301,"comment_content":"深度优先可以用于寻找3度好友，设定搜索的深度为3，通过回溯。迷宫存储可以用无向图，每个路口作为顶点，可以用邻接矩阵或者邻接表存储。","like_count":0},{"had_liked":false,"id":164687,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1577072257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577072257","product_id":100017301,"comment_content":"1. 使用一个距离数组记录每个点到起始点之间的具体距离，深度优先搜索时记录并更新最小距离。搜索完成整张图之后，遍历距离数组找到三度好友<br>2. 将迷宫的每个路口抽象为顶点，存储顶点的坐标值，使用邻接表来存储。","like_count":0},{"had_liked":false,"id":164396,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576978445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576978445","product_id":100017301,"comment_content":"广度优先是按照离起始点的距离先后遍历，这个顺序可以处理最简单的方法最短路径问题。深度优先包含两个顺序，一个是发现的顺序，这个顺序有点随机，意义不大，还有一个是完成的顺序，这个顺序反映了有向图连接关系，也就是如果一个点到另外一个点有边，但是反之则没有，那么前者一定比后者后完成遍历。这个顺序可用来做拓扑排序以及发现双联通结构。","like_count":0},{"had_liked":false,"id":164234,"user_name":"元","can_delete":false,"product_type":"c1","uid":1717444,"ip_address":"","ucode":"4576E15018EEA3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/34/c4/08d9f349.jpg","comment_is_top":false,"comment_ctime":1576912149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576912149","product_id":100017301,"comment_content":"上一节是“度”指顶点的边数，容易和节讲的三度好友关系的“度”会混淆，说成三级好友关系（真的没开车）是不是更好呢","like_count":0},{"had_liked":false,"id":163403,"user_name":"分清云淡","can_delete":false,"product_type":"c1","uid":1269873,"ip_address":"","ucode":"7045AE6BF72D31","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","comment_is_top":false,"comment_ctime":1576717499,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576717499","product_id":100017301,"comment_content":"深度优先的算法 visit 和 prev 不需要 回退操作么？ 走查了一下 我再仔细看看","like_count":0,"discussions":[{"author":{"id":1269873,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","nickname":"分清云淡","note":"","ucode":"7045AE6BF72D31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88533,"discussion_content":"恩 没问题 在prev里面做的回溯 回溯时候跳过了 不满足条件的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576718172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162955,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1576634513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576634513","product_id":100017301,"comment_content":"感觉老师对于Graph的构造不合理，构建出Graph后，图中元素的值成为了和邻接表中下标相关的值；广度优先算法感觉是在做深度优先，看得比较费劲，代码有注释就好了","like_count":0},{"had_liked":false,"id":159304,"user_name":"百里","can_delete":false,"product_type":"c1","uid":1212873,"ip_address":"","ucode":"2CE96129AA7F78","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/c9/9194612b.jpg","comment_is_top":false,"comment_ctime":1575597108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575597108","product_id":100017301,"comment_content":"1. 可以使用深度优先搜索, 递归时使用一个depth_count变量记录递归深度, 然后再回溯<br>2. 使用有向图抽象出迷宫, 使用邻接矩阵和逆邻接矩阵存储","like_count":0},{"had_liked":false,"id":159073,"user_name":"black","can_delete":false,"product_type":"c1","uid":1681512,"ip_address":"","ucode":"9B5E0909926674","user_header":"https://static001.geekbang.org/account/avatar/00/19/a8/68/70392fdd.jpg","comment_is_top":false,"comment_ctime":1575532821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575532821","product_id":100017301,"comment_content":"广度优先遍历实现中，在无向图中，有很多节点都会重复遍，可以在上面判断一下，若是遍历过的节点直接跳过，防止重复赋值的情况出现","like_count":0},{"had_liked":false,"id":157688,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1575247327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575247327","product_id":100017301,"comment_content":"深度优先搜索，初始化数据的顺序不同，找到的路径不一样？ ","like_count":0},{"had_liked":false,"id":156750,"user_name":"莺时无念","can_delete":false,"product_type":"c1","uid":1748695,"ip_address":"","ucode":"036B1C25C146BE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/d7/71da1b4a.jpg","comment_is_top":false,"comment_ctime":1574947257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574947257","product_id":100017301,"comment_content":"想看看C++的代码","like_count":0},{"had_liked":false,"id":153022,"user_name":"Z-ll","can_delete":false,"product_type":"c1","uid":1266233,"ip_address":"","ucode":"68A75A53D1455E","user_header":"https://static001.geekbang.org/account/avatar/00/13/52/39/2211b1a2.jpg","comment_is_top":false,"comment_ctime":1574142224,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574142224","product_id":100017301,"comment_content":"DFS中found变量不是必须的吧， `if (s==t) return;` 就可以了吧。","like_count":0},{"had_liked":false,"id":151547,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1573738748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573738748","product_id":100017301,"comment_content":"存储一个迷宫用邻接矩阵，矩阵中0表示可以走，1表示有障碍物","like_count":0},{"had_liked":false,"id":150671,"user_name":"_tom","can_delete":false,"product_type":"c1","uid":1437212,"ip_address":"","ucode":"B80F244B966F76","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/1c/739f7b4e.jpg","comment_is_top":false,"comment_ctime":1573580010,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573580010","product_id":100017301,"comment_content":"老师，广度优先搜索的分解图 1出队列以后，后面的队列顺序是不是应该是3，2，4","like_count":0},{"had_liked":false,"id":150640,"user_name":"Mr.Fu","can_delete":false,"product_type":"c1","uid":1613254,"ip_address":"","ucode":"F1E4304C5CDE52","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/c6/a72db706.jpg","comment_is_top":false,"comment_ctime":1573572209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573572209","product_id":100017301,"comment_content":"一.图的搜索算法：在图中找出从一个顶点出发，到另一个顶点的路径<br>二.广度优先搜索（BFS）<br>原理和特点：“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。<br><br>时间复杂度：<br>①时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数<br>②对于一个连通图来说(一个图中的所有顶点都是连通的)，E 肯定要大于等于 V-1，所以时间复杂度可以简写为 O(E)<br>是否原地：非原地，空间复杂度O(V)<br>代码实现：<br>①visited 是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点 q 被访问，那相应的 visited[q] 会被设置为 true。<br>②queue 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当访问到第 k 层的顶点的时候，需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。所以用这个队列来实现记录的功能。<br>③prev 用来记录搜索路径。当从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w] 存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如通过顶点 2 的邻接表访问到顶点 3，那 prev[3] 就等于 2。为了正向打印出路径需要递归地来打印<br><br>二.深度优先搜索（DFS）<br>原理和特点：<br>①原理：类似“走迷宫”，假设你站在迷宫的某个岔路口，然后想找到出口；随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口，利用了回溯思想。<br>②特点：深度优先搜索找出来的路径，并不是顶点 s 到顶点 t 的最短路径<br><br>时间复杂度：时间复杂度是 O(E)，E 表示边的个数(每条边最多会被访问两次，一次是遍历，一次是回退)<br>是否原地：非原地，空间复杂度 O(V)，visited、prev 消耗内存大小和顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数","like_count":0},{"had_liked":false,"id":149415,"user_name":"会飞的鱼","can_delete":false,"product_type":"c1","uid":1257205,"ip_address":"","ucode":"BA3FC4E0BF7B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erloYzyia2hRy19E3aCtc0pf10MiaGmzEcXw8UZ3jC3LAibD8icWAFVCXGAlAic3mpjBUrHvyreyhAjIFw/132","comment_is_top":false,"comment_ctime":1573213957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573213957","product_id":100017301,"comment_content":"建议变量名规范一些，否则总是摸不着头脑，总是需要回头看看是什么意思","like_count":0},{"had_liked":false,"id":148583,"user_name":"技术小生","can_delete":false,"product_type":"c1","uid":1692743,"ip_address":"","ucode":"18B7751498029F","user_header":"https://static001.geekbang.org/account/avatar/00/19/d4/47/0deb44d6.jpg","comment_is_top":false,"comment_ctime":1573033602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573033602","product_id":100017301,"comment_content":"dfs和bfs都是基于连通图实现的，非连通图需要遍历节点","like_count":0},{"had_liked":false,"id":146494,"user_name":"三打哈","can_delete":false,"product_type":"c1","uid":1274878,"ip_address":"","ucode":"54D96B4DA36125","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/fe/425523cd.jpg","comment_is_top":false,"comment_ctime":1572538895,"is_pvip":true,"replies":[{"id":"57070","content":"也可以的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572949111,"ip_address":"","comment_id":146494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572538895","product_id":100017301,"comment_content":"老师，请问下广度优先算法中的打印函数的判断语句中有个t!=s，不要这个应该也吧？我认为直接用pre[s]！=-1做判断就可以完成打印正确的路径了。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472884,"discussion_content":"也可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572949111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145511,"user_name":"Bufan","can_delete":false,"product_type":"c1","uid":1387704,"ip_address":"","ucode":"A5EC0391C412DE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriaIgoPa8abNTaUm7o6oa6mvL9iagRTdD1vhovWPyfiaS82f409Sz3kMFzYLNa4ibnHagA7M33l8XnIQ/132","comment_is_top":false,"comment_ctime":1572308710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572308710","product_id":100017301,"comment_content":"看了第四遍，现在终于懂了","like_count":0},{"had_liked":false,"id":143923,"user_name":"Joiner","can_delete":false,"product_type":"c1","uid":1071941,"ip_address":"","ucode":"7F67D4C325E71F","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/45/5dc5437e.jpg","comment_is_top":false,"comment_ctime":1571807586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571807586","product_id":100017301,"comment_content":"上条留言不知道成功没，再来一次吧。<br>老师，对于广度优先例子，prev[4]为1，其实prev[4]也可以为3吧？取决于顶点0的链表中，1和3谁排在前面，但不管prev[4]为1还是为3，都对最终的结果有影响吧？<br>老师我理解的对吗？","like_count":0},{"had_liked":false,"id":142684,"user_name":"AllenGFLiu","can_delete":false,"product_type":"c1","uid":1221991,"ip_address":"","ucode":"90FA8A619A2629","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","comment_is_top":false,"comment_ctime":1571456232,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571456232","product_id":100017301,"comment_content":"dfs代码recurDfs中不是有判定if(!visited[q])吗？应该就不会出现回退这种动作，应该解释为穷举所有可能的路径，当发现之前的节点已经被访问过了，就不会再次去访问了，所以，prev中是不会出现prev[3]=4 prev[4]=3这种数据的。","like_count":0,"discussions":[{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262390,"discussion_content":"是的，我也觉得代码里并没有回退这一操作，和图上画的虚线不符合，时间复杂度分析那里也有问题了...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589085296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139276,"user_name":"ITACHI","can_delete":false,"product_type":"c1","uid":1260500,"ip_address":"","ucode":"4EE419128ED9E8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/d4/e4bfb25f.jpg","comment_is_top":false,"comment_ctime":1570599829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570599829","product_id":100017301,"comment_content":"最初没弄明白为什么广度优先最后输出的是最短路径，毕竟可以认为是按层一层一层搜索并向 prev存值的。后来仔细看才弄明白，递归打印print函数，每次输出的都是 prev数组中对应从t点往前推的前一个来源（就是路径上的前一个点），连起来就是一条最短路径了。","like_count":0},{"had_liked":false,"id":138926,"user_name":"余晓飞","can_delete":false,"product_type":"c1","uid":1007370,"ip_address":"","ucode":"EEC632FF776327","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/0a/7f9c476b.jpg","comment_is_top":false,"comment_ctime":1570509412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570509412","product_id":100017301,"comment_content":"示例给出的bfs dfs算法仅适用于连通图，对于非连通图需要对所有顶点循环调用文中的相关代码。","like_count":0},{"had_liked":false,"id":135981,"user_name":"Hwan","can_delete":false,"product_type":"c1","uid":1205627,"ip_address":"","ucode":"A728C6790511BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","comment_is_top":false,"comment_ctime":1569319702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569319702","product_id":100017301,"comment_content":"也可以使用深度优先算法来实现查找三度好友，对于迷宫的话，可以理解为分叉点为图中的顶点，然后每两个分叉点之间的路线为图中的边，起点终点也为顶点，其他的和图的就一样了","like_count":0},{"had_liked":false,"id":135896,"user_name":"junjun","can_delete":false,"product_type":"c1","uid":1547322,"ip_address":"","ucode":"1F7EE146B9BE04","user_header":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","comment_is_top":false,"comment_ctime":1569294183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569294183","product_id":100017301,"comment_content":"广度搜索画的图中，第一次把1和3加入的queue里边，第二次应该是3，2，4吧","like_count":0},{"had_liked":false,"id":135156,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1569046726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569046726","product_id":100017301,"comment_content":"1 用深度优先没法做吧，假设递归访问顺序是a-&gt;b-&gt;c，这时返回c，但是如果a，c之间也有边，那么这个解就是错误的了<br>2 有无向图存储迷宫，迷宫中的岔路口对应顶点，岔路口之间的密道对应边","like_count":0},{"had_liked":false,"id":133345,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1568522981,"is_pvip":false,"replies":[{"id":"51217","content":"https:&#47;&#47;github.com&#47;wangzheng0822","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568588256,"ip_address":"","comment_id":133345,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568522981","product_id":100017301,"comment_content":"老师，发现代码只是一部分吧，有完整的代码地址么","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467358,"discussion_content":"https://github.com/wangzheng0822","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568588256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131834,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1567930086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567930086","product_id":100017301,"comment_content":"思考题1：也可以用深度优先算法，设置一个递归计数器，每进入一层递归，计数器加1，递归的层数大于3或没有可递归的层次时则返回到上一层，返回时，计数器减1，然后访问上一层的下个邻接点，再进行下轮深搜，直到所有邻接点都被访问。<br>思考题2：可以把迷宫看做是一个无向图，迷宫中设置几个点，两点之间有路连通则用一条无向边相连，这样就把迷宫转换成无向图，而无向图则可以用邻接矩阵或邻接表来存储。","like_count":0},{"had_liked":false,"id":130933,"user_name":"走马","can_delete":false,"product_type":"c1","uid":1251016,"ip_address":"","ucode":"EEFE8F7590FFA4","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/c8/980776fc.jpg","comment_is_top":false,"comment_ctime":1567579479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567579479","product_id":100017301,"comment_content":"迷宫问题：<br>转折点看作图的点，通道看作是图的连接线","like_count":0},{"had_liked":false,"id":129636,"user_name":"老白","can_delete":false,"product_type":"c1","uid":1397031,"ip_address":"","ucode":"39881175152D49","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","comment_is_top":false,"comment_ctime":1567177535,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1567177535","product_id":100017301,"comment_content":"BFS算法每条边感觉是走了两次，虽然对于访问过的顶点不会执行复杂逻辑，但也有简单逻辑。","like_count":0},{"had_liked":false,"id":128896,"user_name":"saber","can_delete":false,"product_type":"c1","uid":1193468,"ip_address":"","ucode":"D02F8D129DB41C","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","comment_is_top":false,"comment_ctime":1566981019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566981019","product_id":100017301,"comment_content":"我实现了一个深度优先搜索的 c++ 版本，自己测试没有错误（也可能测试样本太少），按照递归的执行方式，利用了一个栈来模拟，各位大佬可以帮忙看看有没有错误，可能也有一定的参考价值，链接如下：<br>https:&#47;&#47;github.com&#47;saber&#47;algorithm&#47;blob&#47;master&#47;src&#47;graph&#47;graph.hpp","like_count":0},{"had_liked":false,"id":128503,"user_name":"Chris","can_delete":false,"product_type":"c1","uid":1485515,"ip_address":"","ucode":"712CD86AE8EB81","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/KB4590biaILdggH6ibRibQtlr7p2yONZCfeRK3QM9OSHrwyZrV8oSl5HuOHICl4lQtVoKgpHVydmxQ4peeYPmoIGA/132","comment_is_top":false,"comment_ctime":1566891239,"is_pvip":false,"replies":[{"id":"48486","content":"那只是初始化成-1，之后会重新计算的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567378176,"ip_address":"","comment_id":128503,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566891239","product_id":100017301,"comment_content":"广度优先遍历代码prev是i=1开始赋值，第一个默认为0吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464975,"discussion_content":"那只是初始化成-1，之后会重新计算的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567378176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128499,"user_name":"Chris","can_delete":false,"product_type":"c1","uid":1485515,"ip_address":"","ucode":"712CD86AE8EB81","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/KB4590biaILdggH6ibRibQtlr7p2yONZCfeRK3QM9OSHrwyZrV8oSl5HuOHICl4lQtVoKgpHVydmxQ4peeYPmoIGA/132","comment_is_top":false,"comment_ctime":1566890204,"is_pvip":false,"replies":[{"id":"48487","content":"为啥是0呢？0结点的前驱没有啊 所以是-1啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567378213,"ip_address":"","comment_id":128499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566890204","product_id":100017301,"comment_content":"图中，创建存储路径的数组prev的prev[0]=0吧，不应该为-1吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464973,"discussion_content":"为啥是0呢？0结点的前驱没有啊 所以是-1啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567378213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121916,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1565248903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565248903","product_id":100017301,"comment_content":"问题回答<br>1.可以使用深度优先搜索替代广度优先搜索。但是性能没有广度优先搜索好。因为深度优先搜索会一直递归，无法控制在三层范围，不像广度有类似辐射范围的概念。<br>2.迷宫可以使用邻接矩阵来表示","like_count":0},{"had_liked":false,"id":121524,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1565152013,"is_pvip":false,"replies":[{"id":"44739","content":"不是啊，我的意思就是起点是s，要搜索的结点是t，怎么通过广度优先，搜到结点t","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565220171,"ip_address":"","comment_id":121524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565152013","product_id":100017301,"comment_content":"老师，关于广度优先搜索的，你图上定义的是s对应的是0，t对应的是6，你说起始点是从s开始到t结束，这边的前提是不是文章的开篇前提，查找3度好友。也就是向外扩张3次，就是这个结果？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461836,"discussion_content":"不是啊，我的意思就是起点是s，要搜索的结点是t，怎么通过广度优先，搜到结点t","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565220171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116725,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1563896206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563896206","product_id":100017301,"comment_content":"老师讲的很清楚，打卡跟进！","like_count":0},{"had_liked":false,"id":115476,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1563597344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563597344","product_id":100017301,"comment_content":"思考题1 深度优先搜索距离小于三的节点，距离的计算会有问题，会导致某些距离为三的节点遍历不到。<br>思考题2 迷宫的过道为边，起点，终点和转折点为顶点构建图。","like_count":0},{"had_liked":false,"id":113676,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1563114147,"is_pvip":false,"replies":[{"id":"41399","content":"树也算是一种特殊的图","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563140989,"ip_address":"","comment_id":113676,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563114147","product_id":100017301,"comment_content":"为什么二叉树也会采用深度和广度优先搜索算法","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458344,"discussion_content":"树也算是一种特殊的图","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563140989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110514,"user_name":"ILoveKindness","can_delete":false,"product_type":"c1","uid":1559444,"ip_address":"","ucode":"A6210B034AAC62","user_header":"https://static001.geekbang.org/account/avatar/00/17/cb/94/eedbace3.jpg","comment_is_top":false,"comment_ctime":1562288926,"is_pvip":false,"replies":[{"id":"40492","content":"你留言发错了地方了吧，这节课是dfs","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562543387,"ip_address":"","comment_id":110514,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562288926","product_id":100017301,"comment_content":"老师您好，对于课后ZX的留言，“在构建主串时就比是不是一样的，一样的就不计算后面的hash值”我不是很理解，请求解答，谢谢老师","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456918,"discussion_content":"你留言发错了地方了吧，这节课是dfs","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562543387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107868,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1561626313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561626313","product_id":100017301,"comment_content":"对于思考题1⃣️，深度遍历可以解决问题，只需要添加遍历深度值为2返回条件，","like_count":0},{"had_liked":false,"id":105908,"user_name":"伍二娃","can_delete":false,"product_type":"c1","uid":1108888,"ip_address":"","ucode":"4F19273DE4186D","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/98/a0269f25.jpg","comment_is_top":false,"comment_ctime":1561102970,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561102970","product_id":100017301,"comment_content":"什么时候用BFS，什么时候用DFS都不讲？","like_count":0},{"had_liked":false,"id":105156,"user_name":"菜小轩","can_delete":false,"product_type":"c1","uid":1246433,"ip_address":"","ucode":"DE30E77DD0D83F","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/e1/2f382024.jpg","comment_is_top":false,"comment_ctime":1560931211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560931211","product_id":100017301,"comment_content":"深度优先的代码里if(found)就可以啦老师~~","like_count":0},{"had_liked":false,"id":99254,"user_name":"宋蛋","can_delete":false,"product_type":"c1","uid":1206055,"ip_address":"","ucode":"87CEDC7BB66ABC","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/27/202fde3b.jpg","comment_is_top":false,"comment_ctime":1559182616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559182616","product_id":100017301,"comment_content":"图的邻接表为什么用链表呢？随机查询的效率没有数组高","like_count":0},{"had_liked":false,"id":98065,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1558886535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558886535","product_id":100017301,"comment_content":"多亏其它大牛的python代码, 看懂了代码, 哈哈哈, 开心。应用有点难, 但是不容易了, 继续加油","like_count":0},{"had_liked":false,"id":96179,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1558350792,"is_pvip":false,"replies":[{"id":"34475","content":"结果肯定要一样的  dfs实现起来比较难，要记录用户与你的最小度，有点类似dijkstra算法。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558395421,"ip_address":"","comment_id":96179,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558350792","product_id":100017301,"comment_content":"老师，请教个问题，在求三度好友关系的时候，用bfs和dfs两种方法得到的结果，是不是有可能不一样？？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450754,"discussion_content":"结果肯定要一样的  dfs实现起来比较难，要记录用户与你的最小度，有点类似dijkstra算法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558395421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92363,"user_name":"咸鱼浪子心","can_delete":false,"product_type":"c1","uid":1239309,"ip_address":"","ucode":"344A0104956535","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/0d/605b409e.jpg","comment_is_top":false,"comment_ctime":1557239898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557239898","product_id":100017301,"comment_content":"迷宫可以使用矩阵存储","like_count":0},{"had_liked":false,"id":90045,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1556378231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556378231","product_id":100017301,"comment_content":"1. 递归的退出条件 = 三度. 并增加一个数组记录深度<br>2. 迷宫的起点、终点、岔路都可以认为是图的顶点，顶点间的路就是边.","like_count":0},{"had_liked":false,"id":88294,"user_name":"立冬","can_delete":false,"product_type":"c1","uid":1467313,"ip_address":"","ucode":"287FA88D933FD5","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/b1/a6103703.jpg","comment_is_top":false,"comment_ctime":1555902200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555902200","product_id":100017301,"comment_content":"1 深度的化 需要判断是否终止  不需要found 没被访问的顶点 度是父点+1 据此判断递归结束<br>2每一个叉路看作顶点","like_count":0},{"had_liked":false,"id":84650,"user_name":"Vicky","can_delete":false,"product_type":"c1","uid":1470314,"ip_address":"","ucode":"84610E23A73528","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL3OaibxsOia5ZMiaK5B1AIBW2KwibMhuInSD0xORaSbS2jKUTkLpWfz7ueySJhZfD72HjiamqeW8Hc2HA/132","comment_is_top":false,"comment_ctime":1554889615,"is_pvip":false,"replies":[{"id":"30472","content":"是的 要记录映射关系","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554939152,"ip_address":"","comment_id":84650,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1554889615","product_id":100017301,"comment_content":"工程上怎么使用呢？不可能图上的点都能用下标表示，社交网络为例，用户名到下标如何映射，java中用一个hashmap来保存二者对应关系吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446414,"discussion_content":"是的 要记录映射关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554939152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8515,"discussion_content":"如果是映射过程中 产生hash冲突，那该如何解决，不可能保证百分百不冲突的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568013922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75783,"user_name":"daniel","can_delete":false,"product_type":"c1","uid":1370456,"ip_address":"","ucode":"3516AF7F9A4DEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/e9/58/397a4ab2.jpg","comment_is_top":false,"comment_ctime":1552468507,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1552468507","product_id":100017301,"comment_content":"&#47;&#47;广度优先遍历<br>        public void LevelOrder(){<br>            LinkedList&lt;Node&gt; linkedList=new LinkedList&lt;&gt;();<br>            linkedList.add(root);<br>            while (!linkedList.isEmpty()){<br>                Node cur=linkedList.remove();<br>                System.out.println(cur.e);<br>                if(cur.left!=null)<br>                    linkedList.add(cur.left);<br>                if (cur.right!=null)<br>                    linkedList.add(cur.right);<br>            }<br>        }<br>这是我用链表写的一个广度优先，是有关二叉树的，我从其他章节跳到图有点蒙蔽，会树的可以看看这个，比较好理解的代码！","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298854,"discussion_content":"LinkedList实现了queue接口，最好用queue声明便于理解，remove方法相当于dequeue","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597428097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72950,"user_name":"刘涛涛","can_delete":false,"product_type":"c1","uid":1396130,"ip_address":"","ucode":"D2EE76FA0BB1C5","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/a2/9450ef89.jpg","comment_is_top":false,"comment_ctime":1551758496,"is_pvip":false,"replies":[{"id":"26600","content":"adj保存到是每个顶点的链表，比如adj[0]表示顶点0的邻接链表","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551837384,"ip_address":"","comment_id":72950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551758496","product_id":100017301,"comment_content":"请问老师，private LinkedList adj[] ，为什么不是private LinkedList adj<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441842,"discussion_content":"adj保存到是每个顶点的链表，比如adj[0]表示顶点0的邻接链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551837384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71297,"user_name":"晓龙","can_delete":false,"product_type":"c1","uid":1004576,"ip_address":"","ucode":"78CDCEBD183D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/20/93c79f7c.jpg","comment_is_top":false,"comment_ctime":1551317213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551317213","product_id":100017301,"comment_content":"计算机中存储迷宫，可以用邻接矩阵，1表示通，0表示不通。<br>","like_count":0},{"had_liked":false,"id":64546,"user_name":"许路路","can_delete":false,"product_type":"c1","uid":1114824,"ip_address":"","ucode":"E869F5D2AA76FF","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/c8/a6a2a182.jpg","comment_is_top":false,"comment_ctime":1548818357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548818357","product_id":100017301,"comment_content":"迷宫我可不可以这样抽象，每个没有分叉的区域是一个顶点，然后区域间可以连通的有一条边，走迷宫不就是一个区域到另一个区域，然后用深度优先搜索，😂😂😂","like_count":0},{"had_liked":false,"id":62495,"user_name":"syz","can_delete":false,"product_type":"c1","uid":1174704,"ip_address":"","ucode":"54AF17ACD72645","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","comment_is_top":false,"comment_ctime":1548072206,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1548072206","product_id":100017301,"comment_content":"无向图对应微信的好友关系，当两个人建立好友时在各自的好友列表中新增这个好友","like_count":0},{"had_liked":false,"id":62366,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1548039000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548039000","product_id":100017301,"comment_content":"按照两种情况，一个是拐点。另一个是终点。也就是前面没有路的点。这两种情况来创建节点。每一条通路，设置为一条边。最后用无向图的方式来存储。","like_count":0},{"had_liked":false,"id":62362,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1548038751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548038751","product_id":100017301,"comment_content":"设定一个全局的深度属性。如果在遍历子节点之前对其加一。遍历完成之后对其进行减一。设定三个数组，用来存储相应的好友。依次判断深度是否为1.2.3，插入到相应的数组即可。","like_count":0},{"had_liked":false,"id":57924,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1546942166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546942166","product_id":100017301,"comment_content":"问题1:当度&gt;3时回溯<br>问题2：就是邻接表吧","like_count":0},{"had_liked":false,"id":57184,"user_name":"keshawn","can_delete":false,"product_type":"c1","uid":1319270,"ip_address":"","ucode":"CFCC24F58D1651","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/66/f9125286.jpg","comment_is_top":false,"comment_ctime":1546674505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546674505","product_id":100017301,"comment_content":"深度优先查找那个可以创建一个静态内部类 <br> static class result {<br>        boolean isFound;<br>    }<br>递归的时候带着，这样的话就可以不用isFound作为共享变量<br><br>遍历的方法如下：<br>    private static void recursionDfs(int w, int t, boolean[] visited, int[] prev, result result, LinkedList&lt;Integer&gt;[] adj) {<br>        if (result.isFound) return;<br><br>        for (int i = 0; i &lt; adj[w].size(); i++) {<br>            Integer q = adj[w].get(i);<br>            if (!visited[q]) {<br>                prev[q] = w;<br>                visited[q] = true;<br>                if (w == t) result.isFound = true;<br>                recursionDfs(q, t, visited, prev, result, adj);<br>            }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":56790,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1546562139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546562139","product_id":100017301,"comment_content":"深度优先可以做，给递归方法加个参数depth","like_count":0},{"had_liked":false,"id":54705,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1545955569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545955569","product_id":100017301,"comment_content":"1 可以，增加一个属性，距离 距离大于3便不递归。<br>2。在邻接表中递归，不过标注这两个点，入点与出点","like_count":0},{"had_liked":false,"id":52557,"user_name":"Mr.M","can_delete":false,"product_type":"c1","uid":1243730,"ip_address":"","ucode":"C32AE0A9CD6EEF","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/52/4781da3f.jpg","comment_is_top":false,"comment_ctime":1545434039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545434039","product_id":100017301,"comment_content":"为什么无向图一条边要存两次啊？","like_count":0},{"had_liked":false,"id":51656,"user_name":"程序员联盟","can_delete":false,"product_type":"c1","uid":1018781,"ip_address":"","ucode":"5BB1E4050BBFF2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/9d/30c79c4b.jpg","comment_is_top":false,"comment_ctime":1545218542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545218542","product_id":100017301,"comment_content":"使用邻接列表的深度优先搜索（DFS）的时间复杂度也是 O(V+E) 吧？","like_count":0},{"had_liked":false,"id":49847,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544779280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544779280","product_id":100017301,"comment_content":"广度优先遍历，深度优先遍历","like_count":0},{"had_liked":false,"id":47979,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1544277099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544277099","product_id":100017301,"comment_content":"迷宫转换成图：每个岔路口都是一个顶点，岔路口和岔路口之间可以连通，说明顶点与顶点之间有连线，从而转化为无向图存储。","like_count":0},{"had_liked":false,"id":46958,"user_name":"梅坊帝卿","can_delete":false,"product_type":"c1","uid":1240270,"ip_address":"","ucode":"702F019BA3356C","user_header":"","comment_is_top":false,"comment_ctime":1544009153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544009153","product_id":100017301,"comment_content":"从我前面画的图可以看出，每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数。<br><br>这里不太理解，从代码中看来 假设当前处理N 那么遍历它的孩子 递归调用之 这里递归调用后返回算是回退？从N的视角 它只是依次处理这些孩子<br>如果用栈来实现非递归 那么会先压栈所有孩子 再去最顶的孩子继续处理 有一个压栈和出栈 这就匹配了<br>所以在递归调用中 函数返回了 也可以等同于回退一条边","like_count":0},{"had_liked":false,"id":46719,"user_name":"马球先生","can_delete":false,"product_type":"c1","uid":1119609,"ip_address":"","ucode":"858C2CE0E494C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/79/efde2a69.jpg","comment_is_top":false,"comment_ctime":1543973682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543973682","product_id":100017301,"comment_content":"4出队时 当找到t顶点时<br><br>Queue: 2, 5<br>Visited: 1,1,1,1,1,1,1,0<br>Prev: -1,0,1,0,1,4,4,-1<br><br>感觉下标为6时 visited应该是0 即没有访问过<br>因为已经return了<br>所以visited[q] = true; 这句代码没有被执行<br>","like_count":0},{"had_liked":false,"id":46678,"user_name":"jon","can_delete":false,"product_type":"c1","uid":1253287,"ip_address":"","ucode":"5768A34E292CAA","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/a7/d379ca4f.jpg","comment_is_top":false,"comment_ctime":1543970875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543970875","product_id":100017301,"comment_content":"广度搜索用的是一个队列存储已经比较过的一层点点，深度搜索用的是递归也就是栈来存储搜索过的顶点","like_count":0},{"had_liked":false,"id":46352,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1543905695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543905695","product_id":100017301,"comment_content":"1. 设置搜索的深度为 3 , 超过了 3 则强行回溯<br>2. 将迷宫的分叉路口映射成为图中的顶点","like_count":0},{"had_liked":false,"id":46175,"user_name":"許敲敲","can_delete":false,"product_type":"c1","uid":1046681,"ip_address":"","ucode":"6486466820E7BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/99/8e760987.jpg","comment_is_top":false,"comment_ctime":1543881073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543881073","product_id":100017301,"comment_content":"想看看python的代码实现","like_count":0},{"had_liked":false,"id":46052,"user_name":"MIAN-勉","can_delete":false,"product_type":"c1","uid":1123554,"ip_address":"","ucode":"AE938038C2E7D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/24/e2/e5110db5.jpg","comment_is_top":false,"comment_ctime":1543839568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543839568","product_id":100017301,"comment_content":"思考題2 本質上是構建圖的過程。而且衹知道一個起點節點，如何將遇到的分叉口抽象為一個節點是難點，看了所有的留言答案，感覺大家都避重就輕，沒答到點上。希望老師釋惑。","like_count":0},{"had_liked":false,"id":45876,"user_name":"🐱您的好友William🐱","can_delete":false,"product_type":"c1","uid":1215456,"ip_address":"","ucode":"427786DB178965","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg","comment_is_top":false,"comment_ctime":1543808938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543808938","product_id":100017301,"comment_content":"走迷宫就是现在地图类APP干的事情吧，我知道他们用A*和A*优化版。我自己想的是把每个路口设置成vertex然后按vertex间的路程时间长短构建有向带权图，然后在这个图里面找最短路径，可以使用狄克斯特拉求解，但是缺点是图中不能是无向的，也不能有环。最正规的解法应该是A*，我之前专门学了一下，没学明白。。。。<br><br>用深度优先搜索好友我们只要控制好每次深度不超过3，达到3就回溯应该就可以了。","like_count":0}]}