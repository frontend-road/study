{"id":97764,"title":"09 | 不可或缺的自定义函数","content":"<p>你好，我是景霄。</p><p>实际工作生活中，我曾见到不少初学者编写的Python程序，他们长达几百行的代码中，却没有一个函数，通通按顺序堆到一块儿，不仅让人读起来费时费力，往往也是错误连连。</p><p>一个规范的值得借鉴的Python程序，除非代码量很少（比如10行、20行以下），基本都应该由多个函数组成，这样的代码才更加模块化、规范化。</p><p>函数是Python程序中不可或缺的一部分。事实上，在前面的学习中，我们已经用到了很多Python的内置函数，比如sorted()表示对一个集合序列排序，len()表示返回一个集合序列的长度大小等等。这节课，我们主要来学习Python的自定义函数。</p><h2>函数基础</h2><p>那么，到底什么是函数，如何在Python程序中定义函数呢？</p><p>说白了，函数就是为了实现某一功能的代码段，只要写好以后，就可以重复利用。我们先来看下面一个简单的例子:</p><pre><code>def my_func(message):\n    print('Got a message: {}'.format(message))\n\n# 调用函数 my_func()\nmy_func('Hello World')\n# 输出\nGot a message: Hello World\n</code></pre><p>其中：</p><ul>\n<li>\n<p>def是函数的声明；</p>\n</li>\n<li>\n<p>my_func是函数的名称；</p>\n</li>\n<li>\n<p>括号里面的message则是函数的参数；</p>\n</li>\n<li>\n<p>而print那行则是函数的主体部分，可以执行相应的语句；</p>\n</li>\n<li>\n<p>在函数最后，你可以返回调用结果（return或yield），也可以不返回。</p>\n</li>\n</ul><p>总结一下，大概是下面的这种形式：</p><!-- [[[read_end]]] --><pre><code>def name(param1, param2, ..., paramN):\n    statements\n    return/yield value # optional\n</code></pre><p>和其他需要编译的语言（比如C语言）不一样的是，def是可执行语句，这意味着函数直到被调用前，都是不存在的。当程序调用函数时，def语句才会创建一个新的函数对象，并赋予其名字。</p><p>我们一起来看几个例子，加深你对函数的印象：</p><pre><code>def my_sum(a, b):\n    return a + b\n\nresult = my_sum(3, 5)\nprint(result)\n\n# 输出\n8\n</code></pre><p>这里，我们定义了my_sum()这个函数，它有两个参数a和b，作用是相加；随后，调用my_sum()函数，分别把3和5赋于a和b；最后，返回其相加的值，赋于变量result，并输出得到8。</p><p>再来看一个例子：</p><pre><code>def find_largest_element(l):\n    if not isinstance(l, list):\n        print('input is not type of list')\n        return\n    if len(l) == 0:\n        print('empty input')\n        return\n    largest_element = l[0]\n    for item in l:\n        if item &gt; largest_element:\n            largest_element = item\n    print('largest element is: {}'.format(largest_element)) \n      \nfind_largest_element([8, 1,-3, 2, 0])\n\n# 输出\nlargest element is: 8\n</code></pre><p>这个例子中，我们定义了函数find_largest_element，作用是遍历输入的列表，找出最大的值并打印。因此，当我们调用它，并传递列表  [8, 1, -3, 2, 0]  作为参数时，程序就会输出 <code>largest element is: 8</code>。</p><p>需要注意，主程序调用函数时，必须保证这个函数此前已经定义过，不然就会报错，比如：</p><pre><code>my_func('hello world')\ndef my_func(message):\n    print('Got a message: {}'.format(message))\n    \n# 输出\nNameError: name 'my_func' is not defined\n</code></pre><p>但是，如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为def是可执行语句，函数在调用之前都不存在，我们只需保证调用时，所需的函数都已经声明定义：</p><pre><code>def my_func(message):\n    my_sub_func(message) # 调用my_sub_func()在其声明之前不影响程序执行\n    \ndef my_sub_func(message):\n    print('Got a message: {}'.format(message))\n\nmy_func('hello world')\n\n# 输出\nGot a message: hello world\n</code></pre><p>另外，Python函数的参数可以设定默认值，比如下面这样的写法：</p><pre><code>def func(param = 0):\n    ...\n</code></pre><p>这样，在调用函数func()时，如果参数param没有传入，则参数默认为0；而如果传入了参数param，其就会覆盖默认值。</p><p>前面说过，Python和其他语言相比的一大特点是，Python是dynamically typed的，可以接受任何数据类型（整型，浮点，字符串等等）。对函数参数来说，这一点同样适用。比如还是刚刚的my_sum函数，我们也可以把列表作为参数来传递，表示将两个列表相连接：</p><pre><code>print(my_sum([1, 2], [3, 4]))\n\n# 输出\n[1, 2, 3, 4]\n</code></pre><p>同样，也可以把字符串作为参数传递，表示字符串的合并拼接：</p><pre><code>print(my_sum('hello ', 'world'))\n\n# 输出\nhello world\n</code></pre><p>当然，如果两个参数的数据类型不同，比如一个是列表、一个是字符串，两者无法相加，那就会报错：</p><pre><code>print(my_sum([1, 2], 'hello'))\nTypeError: can only concatenate list (not &quot;str&quot;) to list\n</code></pre><p>我们可以看到，Python不用考虑输入的数据类型，而是将其交给具体的代码去判断执行，同样的一个函数（比如这边的相加函数my_sum()），可以同时应用在整型、列表、字符串等等的操作中。</p><p>在编程语言中，我们把这种行为称为<strong>多态</strong>。这也是Python和其他语言，比如Java、C等很大的一个不同点。当然，Python这种方便的特性，在实际使用中也会带来诸多问题。因此，必要时请你在开头加上数据的类型检查。</p><p>Python函数的另一大特性，是Python支持函数的嵌套。所谓的函数嵌套，就是指函数里面又有函数，比如：</p><pre><code>def f1():\n    print('hello')\n    def f2():\n        print('world')\n    f2()\nf1()\n\n# 输出\nhello\nworld\n</code></pre><p>这里函数f1()的内部，又定义了函数f2()。在调用函数f1()时，会先打印字符串<code>'hello'</code>，然后f1()内部再调用f2()，打印字符串<code>'world'</code>。你也许会问，为什么需要函数嵌套？这样做有什么好处呢？</p><p>其实，函数的嵌套，主要有下面两个方面的作用。</p><p>第一，函数的嵌套能够保证内部函数的隐私。内部函数只能被外部函数所调用和访问，不会暴露在全局作用域，因此，如果你的函数内部有一些隐私数据（比如数据库的用户、密码等），不想暴露在外，那你就可以使用函数的的嵌套，将其封装在内部函数中，只通过外部函数来访问。比如：</p><pre><code>def connect_DB():\n    def get_DB_configuration():\n        ...\n        return host, username, password\n    conn = connector.connect(get_DB_configuration())\n    return conn\n</code></pre><p>这里的函数get_DB_configuration，便是内部函数，它无法在connect_DB()函数以外被单独调用。也就是说，下面这样的外部直接调用是错误的：</p><pre><code>get_DB_configuration()\n\n# 输出\nNameError: name 'get_DB_configuration' is not defined\n</code></pre><p>我们只能通过调用外部函数connect_DB()来访问它，这样一来，程序的安全性便有了很大的提高。</p><p>第二，合理的使用函数嵌套，能够提高程序的运行效率。我们来看下面这个例子：</p><pre><code>def factorial(input):\n    # validation check\n    if not isinstance(input, int):\n        raise Exception('input must be an integer.')\n    if input &lt; 0:\n        raise Exception('input must be greater or equal to 0' )\n    ...\n\n    def inner_factorial(input):\n        if input &lt;= 1:\n            return 1\n        return input * inner_factorial(input-1)\n    return inner_factorial(input)\n\n\nprint(factorial(5))\n</code></pre><p>这里，我们使用递归的方式计算一个数的阶乘。因为在计算之前，需要检查输入是否合法，所以我写成了函数嵌套的形式，这样一来，输入是否合法就只用检查一次。而如果我们不使用函数嵌套，那么每调用一次递归便会检查一次，这是没有必要的，也会降低程序的运行效率。</p><p>实际工作中，如果你遇到相似的情况，输入检查不是很快，还会耗费一定的资源，那么运用函数的嵌套就十分必要了。</p><h2>函数变量作用域</h2><p>Python函数中变量的作用域和其他语言类似。如果变量是在函数内部定义的，就称为局部变量，只在函数内部有效。一旦函数执行完毕，局部变量就会被回收，无法访问，比如下面的例子：</p><pre><code>def read_text_from_file(file_path):\n    with open(file_path) as file:\n        ...\n</code></pre><p>我们在函数内部定义了file这个变量，这个变量只在read_text_from_file这个函数里有效，在函数外部则无法访问。</p><p>相对应的，全局变量则是定义在整个文件层次上的，比如下面这段代码：</p><pre><code>MIN_VALUE = 1\nMAX_VALUE = 10\ndef validation_check(value):\n    if value &lt; MIN_VALUE or value &gt; MAX_VALUE:\n        raise Exception('validation check fails')\n</code></pre><p>这里的MIN_VALUE和MAX_VALUE就是全局变量，可以在文件内的任何地方被访问，当然在函数内部也是可以的。不过，我们<strong>不能在函数内部随意改变全局变量的值</strong>。比如，下面的写法就是错误的：</p><pre><code>MIN_VALUE = 1\nMAX_VALUE = 10\ndef validation_check(value):\n    ...\n    MIN_VALUE += 1\n    ...\nvalidation_check(5)\n</code></pre><p>如果运行这段代码，程序便会报错：</p><pre><code>UnboundLocalError: local variable 'MIN_VALUE' referenced before assignment\n</code></pre><p>这是因为，Python的解释器会默认函数内部的变量为局部变量，但是又发现局部变量MIN_VALUE并没有声明，因此就无法执行相关操作。所以，如果我们一定要在函数内部改变全局变量的值，就必须加上global这个声明：</p><pre><code>MIN_VALUE = 1\nMAX_VALUE = 10\ndef validation_check(value):\n    global MIN_VALUE\n    ...\n    MIN_VALUE += 1\n    ...\nvalidation_check(5)\n</code></pre><p>这里的global关键字，并不表示重新创建了一个全局变量MIN_VALUE，而是告诉Python解释器，函数内部的变量MIN_VALUE，就是之前定义的全局变量，并不是新的全局变量，也不是局部变量。这样，程序就可以在函数内部访问全局变量，并修改它的值了。</p><p>另外，如果遇到函数内部局部变量和全局变量同名的情况，那么在函数内部，局部变量会覆盖全局变量，比如下面这种：</p><pre><code>MIN_VALUE = 1\nMAX_VALUE = 10\ndef validation_check(value):\n    MIN_VALUE = 3\n    ...\n</code></pre><p>在函数validation_check()内部，我们定义了和全局变量同名的局部变量MIN_VALUE，那么，MIN_VALUE在函数内部的值，就应该是3而不是1了。</p><p>类似的，对于嵌套函数来说，内部函数可以访问外部函数定义的变量，但是无法修改，若要修改，必须加上nonlocal这个关键字：</p><pre><code>def outer():\n    x = &quot;local&quot;\n    def inner():\n        nonlocal x # nonlocal关键字表示这里的x就是外部函数outer定义的变量x\n        x = 'nonlocal'\n        print(&quot;inner:&quot;, x)\n    inner()\n    print(&quot;outer:&quot;, x)\nouter()\n# 输出\ninner: nonlocal\nouter: nonlocal\n</code></pre><p>如果不加上nonlocal这个关键字，而内部函数的变量又和外部函数变量同名，那么同样的，内部函数变量会覆盖外部函数的变量。</p><pre><code>def outer():\n    x = &quot;local&quot;\n    def inner():\n        x = 'nonlocal' # 这里的x是inner这个函数的局部变量\n        print(&quot;inner:&quot;, x)\n    inner()\n    print(&quot;outer:&quot;, x)\nouter()\n# 输出\ninner: nonlocal\nouter: local\n</code></pre><h2>闭包</h2><p>这节课的第三个重点，我想再来介绍一下闭包（closure）。闭包其实和刚刚讲的嵌套函数类似，不同的是，这里外部函数返回的是一个函数，而不是一个具体的值。返回的函数通常赋于一个变量，这个变量可以在后面被继续执行调用。</p><p>举个例子你就更容易理解了。比如，我们想计算一个数的n次幂，用闭包可以写成下面的代码：</p><pre><code>def nth_power(exponent):\n    def exponent_of(base):\n        return base ** exponent\n    return exponent_of # 返回值是exponent_of函数\n\nsquare = nth_power(2) # 计算一个数的平方\ncube = nth_power(3) # 计算一个数的立方 \nsquare\n# 输出\n&lt;function __main__.nth_power.&lt;locals&gt;.exponent(base)&gt;\n\ncube\n# 输出\n&lt;function __main__.nth_power.&lt;locals&gt;.exponent(base)&gt;\n\nprint(square(2))  # 计算2的平方\nprint(cube(2)) # 计算2的立方\n# 输出\n4 # 2^2\n8 # 2^3\n</code></pre><p>这里外部函数nth_power()返回值，是函数exponent_of()，而不是一个具体的数值。需要注意的是，在执行完<code>square = nth_power(2)</code>和<code>cube = nth_power(3)</code>后，外部函数nth_power()的参数exponent，仍然会被内部函数exponent_of()记住。这样，之后我们调用square(2)或者cube(2)时，程序就能顺利地输出结果，而不会报错说参数exponent没有定义了。</p><p>看到这里，你也许会思考，为什么要闭包呢？上面的程序，我也可以写成下面的形式啊！</p><pre><code>def nth_power_rewrite(base, exponent):\n    return base ** exponent\n\n</code></pre><p>确实可以，不过，要知道，使用闭包的一个原因，是让程序变得更简洁易读。设想一下，比如你需要计算很多个数的平方，那么你觉得写成下面哪一种形式更好呢？</p><pre><code># 不适用闭包\nres1 = nth_power_rewrite(base1, 2)\nres2 = nth_power_rewrite(base2, 2)\nres3 = nth_power_rewrite(base3, 2)\n...\n\n# 使用闭包\nsquare = nth_power(2)\nres1 = square(base1)\nres2 = square(base2)\nres3 = square(base3)\n...\n</code></pre><p>显然是第二种，是不是？首先直观来看，第二种形式，让你每次调用函数都可以少输入一个参数，表达更为简洁。</p><p>其次，和上面讲到的嵌套函数优点类似，函数开头需要做一些额外工作，而你又需要多次调用这个函数时，将那些额外工作的代码放在外部函数，就可以减少多次调用导致的不必要的开销，提高程序的运行效率。</p><p>另外还有一点，我们后面会讲到，闭包常常和装饰器（decorator）一起使用。</p><h2>总结</h2><p>这节课，我们一起学习了Python函数的概念及其应用，有这么几点你需要注意:</p><ol>\n<li>\n<p>Python中函数的参数可以接受任意的数据类型，使用起来需要注意，必要时请在函数开头加入数据类型的检查；</p>\n</li>\n<li>\n<p>和其他语言不同，Python中函数的参数可以设定默认值；</p>\n</li>\n<li>\n<p>嵌套函数的使用，能保证数据的隐私性，提高程序运行效率；</p>\n</li>\n<li>\n<p>合理地使用闭包，则可以简化程序的复杂度，提高可读性。</p>\n</li>\n</ol><h2>思考题</h2><p>最后给你留一道思考题。在实际的学习工作中，你遇到过哪些使用嵌套函数或者是闭包的例子呢？欢迎在下方留言，与我讨论，也欢迎你把这篇文章分享给你的同事、朋友。</p><p></p>","comments":[{"had_liked":false,"id":98827,"user_name":"不瘦到140不改名","can_delete":false,"product_type":"c1","uid":1528298,"ip_address":"","ucode":"31DA063A17FC27","user_header":"https://static001.geekbang.org/account/avatar/00/17/51/ea/2ce84d5a.jpg","comment_is_top":false,"comment_ctime":1559101289,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"499775307625","product_id":100026901,"comment_content":"其实函数也可以看做成是一个变量，函数名就是变量名，函数体就是值。函数虽然在不被调用的情况下不会执行，但是python解释器会做一些变量检测、或者类型检测，比如是不是有yield，如果有那么就会被标记为生成器，这个在编译成字节码的时候就已经确定了。而有些东西则是只有在解释执行的时候才会被发现。<br>比如说：<br>x = 1<br><br><br>def foo():<br>    print(x)<br>    x = 10<br>foo()  # UnboundLocalError: local variable &#39;x&#39; referenced before assignment<br>为什么会有这种结果，因为python寻找变量的时候，会按照本地作用域、闭包、全局、内置这种顺序去查找，当看到x=1的时候，python解释器就知道函数体内部创建了变量x，这是在编译的时候就已经确定了，于是在print的时候也会从本地查找，但是print(x)语句在x=10的上面，这是在执行的时候才发现的，于是报了个错：提示局部变量x在赋值之前就已经被引用了。<br><br>x = 1<br><br><br>def foo():<br>    x += 1<br><br>foo()  #   UnboundLocalError: local variable &#39;x&#39; referenced before assignment<br>这也是同样的道理，x += 1,相当于x = x+1，相当于将x的值和1进行相加然后再让x重新指向它，同样在编译的时候就知道函数内部创建了x这个变量，因此在执行x+1的时候，会从本地查找，但是发现本地此时还没有x，于是引发了同样的错误。<br>因此如果想在函数体内部修改全局变量，对于immutable类型，一定要使用global关键字，表示外部的变量和函数内部的变量是同一个变量，如果是mutable类型，比如list、dict，支持本地修改的话，那么可以不用使用global关键字，因为它们支持本地修改<br><br>关于python的传参，python和golang不一样，golang只有值传递，而python只有引用传递，无论是什么类型，python传的永远都是引用。<br>x = 1<br>def foo(x):<br>    x = 2<br>foo(x)<br>print(x)  # 1<br>传递x的时候，相当于传递了引用，函数的x通过外部的x找到了值为1的内存地址，相当于值为1的这片内存被贴了两个标签，当x=2的时候，那么会重新开辟一块内存，存储的值为2，然后让函数内部的x重新指向，但是外部的x该指向谁还是指向谁，所以外部的x是不会受影响的。但如果是列表，支持本地操作，外部和内部的变量指向同一个列表的话，那么内部变量进行append等本地操作是会影响外部的，因为它们指向同一片内存区域，并且是本地修改，而不是重新赋值<br><br><br>思考题：<br>from functools import wraps<br><br><br>def login_required(func):<br>    @wraps(func)<br>    def inner(*args, **kwargs):<br>        user = input(&quot;请输入账号: &quot;)<br>        passwd = input(&quot;请输入密码: &quot;)<br>        if user == &quot;bilibili&quot; and passwd == &quot;bilibili&quot;:<br>            return func(*args, **kwargs)<br>        return &quot;页面去火星了&quot;<br>    return inner<br><br><br>@login_required<br>def login():<br>    return &quot;欢迎来到bilibili&quot;<br><br><br>print(login())","like_count":117,"discussions":[{"author":{"id":1221991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","nickname":"AllenGFLiu","note":"","ucode":"90FA8A619A2629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18300,"discussion_content":" 你把decorator的知识都先讲了，陈独秀同志","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1569041229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202047,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oib0a89lqtOhJL1UvfUp4uTsRLrDbhoGk9jLiciazxMu0COibJsFCZDypK1ZFcHEJc9d9qgbjvgR41ImL6FNPoVlWA/132","nickname":"stefen","note":"","ucode":"7C9AAE829E7802","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310529,"discussion_content":"陈独秀同志能不打广告么  还有你对go语言的说法不准确  可以再多去学习一个go语言","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601892276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1202047,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oib0a89lqtOhJL1UvfUp4uTsRLrDbhoGk9jLiciazxMu0COibJsFCZDypK1ZFcHEJc9d9qgbjvgR41ImL6FNPoVlWA/132","nickname":"stefen","note":"","ucode":"7C9AAE829E7802","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":392101,"discussion_content":"人家说的非常准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630831952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310529,"ip_address":""},"score":392101,"extra":""},{"author":{"id":1227366,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ba/66/7d9f45e7.jpg","nickname":"太空牛仔","note":"","ucode":"0205635C3854AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":564204,"discussion_content":"go的引用类型知道吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650188814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":392101,"ip_address":""},"score":564204,"extra":""}]},{"author":{"id":1581705,"avatar":"https://static001.geekbang.org/account/avatar/00/18/22/89/73397ccb.jpg","nickname":"响雨","note":"","ucode":"C5FB3A3BC68F92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221,"discussion_content":"感谢分享经验","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561299544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529249,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/a1/e77b9612.jpg","nickname":"峪五","note":"","ucode":"DCF2DC959D0CD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550183,"discussion_content":"要是半吊子可以不说，你这样很误人子弟艾。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644409350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363634,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ce/b2/1f914527.jpg","nickname":"海盗船长","note":"","ucode":"ECB28BA21A4113","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413425,"discussion_content":"关于“python传参是引用传递”说法是错误的，可以看下官网","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636469674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2627424,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zHgpyelqWyHLwzuaj1WujbrvtdSVTZDbbROlEEgYjIe8fQiatRZAmsxk5ibGeAq8Piaib7YqF937scRpibs34ibLphHA/132","nickname":"Geek_180e51","note":"","ucode":"69454B72D8F4C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375785,"discussion_content":"不是变量，而是对象，python一切皆对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621849166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165084,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c7/1c/e59a699b.jpg","nickname":"海朋森","note":"","ucode":"212BADF1F9E962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343830,"discussion_content":"陈独秀你妹妹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611192872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1995257,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/71/f9/85329b42.jpg","nickname":"做一个可靠的UDP","note":"","ucode":"2428ED20AD3398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263136,"discussion_content":"6","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589178635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1524832,"avatar":"https://static001.geekbang.org/account/avatar/00/17/44/60/330fd735.jpg","nickname":"马马马马马马马","note":"","ucode":"F6A6288C4E1B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1032,"discussion_content":"你好，我想请教一下，第一个例子中，执行到 print(x) 时，开始在本地作用域查找变量，但是解释器发现后面还有 x = 10，被赋值前已经被引用了，所以此时报错。\n但是第二个例子，执行 x + 1 时，开始查找变量，本地没有，但是全局有啊，此时为什么会报相同的错呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562254402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1524832,"avatar":"https://static001.geekbang.org/account/avatar/00/17/44/60/330fd735.jpg","nickname":"马马马马马马马","note":"","ucode":"F6A6288C4E1B99","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2588,"discussion_content":"因为x是int类型，属于immutable类型，即不可变，在函数内部试图改变，python就以为你用的这个x是局部变量，但是局部并未定义，所以出现error。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1563779409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1032,"ip_address":""},"score":2588,"extra":""}]}]},{"had_liked":false,"id":98716,"user_name":"pyhhou","can_delete":false,"product_type":"c1","uid":1256496,"ip_address":"","ucode":"31EF8D50CF91A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","comment_is_top":false,"comment_ctime":1559070429,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"190537631453","product_id":100026901,"comment_content":"闭包必须使用嵌套函数，一看到闭包我首先想到的是 JavaScript 里面的回调函数。闭包这里看似仅仅返回了一个嵌套函数，但是需要注意的是，它其实连同嵌套函数的外部环境变量也一同保存返回回来了（例子中的 exponent 变量），这个环境变量是在调用其外部函数时设定的，这样一来，对于一些参数性，不常改变的设定变量，我们可以通过这个形式来设定，这样返回的闭包函数仅需要关注那些核心输入变量，节省了效率，这样做也大大减少了全局变量的使用，增加代码可读性的同时，也会让代码变得更加的安全","like_count":45,"discussions":[{"author":{"id":2628251,"avatar":"https://static001.geekbang.org/account/avatar/00/28/1a/9b/aa3b16f5.jpg","nickname":"海棠","note":"","ucode":"9416069D151314","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540489,"discussion_content":"1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640068210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1995257,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/71/f9/85329b42.jpg","nickname":"做一个可靠的UDP","note":"","ucode":"2428ED20AD3398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263137,"discussion_content":"太棒了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589178740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99285,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1559186298,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"113228335994","product_id":100026901,"comment_content":"一开始看完，对闭包的概念有了，但比较糙，不知道闭包究竟指的是哪个变量。<br>这篇文章对大家理解闭包有一定帮助：https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;26934085","like_count":26},{"had_liked":false,"id":98941,"user_name":"Aspirin","can_delete":false,"product_type":"c1","uid":1141751,"ip_address":"","ucode":"858B551CF0C2F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/6b/f7/3a3b82c2.jpg","comment_is_top":false,"comment_ctime":1559117412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"78868528740","product_id":100026901,"comment_content":"关于闭包，我想到一个案例，就是卷积神经网络模型的实现。我们知道，在CNN模型推理时，所有卷积层或全连接层的权重weights都是已知的、确定的，也就是说我们实例化一个模型之后，所有layer的weights都是确定好的，只需要处理不同的输入就可以了。所以，我们可以写一个闭包函数，输入不同的权重，返回使用该权重进行卷积运算的函数即可。伪代码如下：<br>不使用闭包：<br>```<br>for img in imgs:<br>    x = conv2d(img, weights1)<br>    x = conv2d(x, weights2)<br>...<br>```<br>使用闭包：<br>```<br>conv_layer1 = conv_layer(weights1)<br>conv_layer2 = conv_layer(weights2)<br>for img in imgs:<br>    x = conv_layer1(img)<br>    x = conv_layer2(x)<br>...<br>```","like_count":18},{"had_liked":false,"id":98713,"user_name":"farFlight","can_delete":false,"product_type":"c1","uid":1245211,"ip_address":"","ucode":"B0872D3ECBEC38","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbRibsic15KXfGEN3SSjnLhXGyhK2Uyrj5ibBJsKAjicNqtafDaQOLH4xpSJRZD1vmibFPJER1ySmwP9A/132","comment_is_top":false,"comment_ctime":1559065519,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"53098673071","product_id":100026901,"comment_content":"谢谢老师，这节课的内容非常有意思！<br>有两个问题：<br>1. python自己判断类型的多态和子类继承的多态Polymorphism应该不是一个意思吧？<br>2. 函数内部不能直接用+=等修改全局变量，但是对于list全局变量，可以使用append, extend之类修改，这是为什么呢?","like_count":12,"discussions":[{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2589,"discussion_content":"我来说说自己的看法：\n1. \n本文中老师提到的是一个函数在接受参数时，不判断参数的态，即类型。Polymorphism是指在继承中，一个父类可以被多个不同的子类继承，并针对同一接口（即函数），表现出不同的形式（即返回不同的值）。\n2. \nint类型和tuple类型是immutable的，比如 x = 1，在内存中，有一块内存上记录了’1‘，而变量x直接指向了这个地址；而对于list，比如y = [1,2,3]，在内存中，有一块内存上标记了list对象，而这个对象又指向了另一个内存地址，这个新的内存地址里，才是真正的’1，2，3‘。两者就是x => 1 和 y => <list object> => [1,2,3]的关系。\n可以参考这个网站：http://www.pythontutor.com/visualize.html#mode=edit","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1563780468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99062,"user_name":"William","can_delete":false,"product_type":"c1","uid":1241365,"ip_address":"","ucode":"4499F99B180102","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/15/8fcf8038.jpg","comment_is_top":false,"comment_ctime":1559137428,"is_pvip":true,"replies":[{"id":"35593","content":"嗯嗯，学习很细心","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559150924,"ip_address":"","comment_id":99062,"utype":1}],"discussion_count":1,"race_medal":2,"score":"40213843092","product_id":100026901,"comment_content":"快排封装，增加index参数会用到嵌套。<br>```python<br>def quickSort(arr):<br>    def partition(arr, left, right):<br>        pivot = arr[left]<br>        while left &lt; right:<br>            while left &lt; right and arr[right] &gt; pivot:<br>                right -= 1<br>            if left &lt; right:<br>                arr[left] = arr[right]<br>            while left &lt; right and arr[left] &lt; pivot:<br>                left += 1<br>            if left &lt; right:<br>                arr[right] = arr[left]<br>        arr[left] = pivot<br>        return left<br>    def innerQuickSort(arr, left, right):<br>        stack = []<br>        stack.append(left)<br>        stack.append(right)<br>        while len(stack) &gt; 0:<br>            right = stack.pop()<br>            left = stack.pop()<br>            pivotIndex = partition(arr, left, right)<br>            if pivotIndex + 1 &lt; right:<br>                stack.append(pivotIndex+1)<br>                stack.append(right)<br>            if left + 1 &lt; pivotIndex:<br>                stack.append(left)<br>                stack.append(pivotIndex - 1)<br>    innerQuickSort(arr, 0, len(arr)-1)<br><br>arr = [394, 129, 11, 39, 28]<br>quickSort(arr)<br>print(arr)<br>```","like_count":9,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451956,"discussion_content":"嗯嗯，学习很细心","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559150924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178957,"user_name":"Geek_7777","can_delete":false,"product_type":"c1","uid":1578271,"ip_address":"","ucode":"FC5FFB3DE50BB4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTOaSibFSEnoB5c0qdG7g9Eia5f2xONMbWYmnpQZTYrSqUUMnG984jFVGyVG8px3oSDVUIXj185VEA/132","comment_is_top":false,"comment_ctime":1581863493,"is_pvip":false,"replies":[{"id":"69472","content":"因为这里square=nth_power(2)已经是一个函数了，这个函数有两个参数，已经接受了exponent，因此如果你调用了square(2)，这个参数会再传给base，这样就能输出结果了","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1581883594,"ip_address":"","comment_id":178957,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23056699973","product_id":100026901,"comment_content":"闭包，调用square(2)，这个参数2为啥能传给base，不太懂请教下","like_count":5,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484038,"discussion_content":"因为这里square=nth_power(2)已经是一个函数了，这个函数有两个参数，已经接受了exponent，因此如果你调用了square(2)，这个参数会再传给base，这样就能输出结果了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581883594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1384819,"avatar":"https://static001.geekbang.org/account/avatar/00/15/21/73/06492fb7.jpg","nickname":"～","note":"","ucode":"E5E17131535239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":569013,"discussion_content":"还是没太懂，是第二次默认传给嵌套的那个函数吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651289446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":484038,"ip_address":""},"score":569013,"extra":""}]},{"author":{"id":1891041,"avatar":"","nickname":"abczdefg","note":"","ucode":"018C8ABBCE3810","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573842,"discussion_content":"1.square=nth_power(2)-&gt;调用nth_power，设置exponent=2；此时square=exponent_of；\n2.后面print调用square（2）其实运行的是exponent_of（2）-&gt;base=2，然后闭包会保留外部变量，因此最终结果是2**2；\n可以自己打断点，运行一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653671758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98859,"user_name":"路伴友行","can_delete":false,"product_type":"c1","uid":1506974,"ip_address":"","ucode":"96B54B7EEAEDAD","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/9e/8165b0a0.jpg","comment_is_top":false,"comment_ctime":1559107556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23033944036","product_id":100026901,"comment_content":"我有个项目需要将很多不规则的列表展平<br>但没有找到推荐的方式，就自己写了个<br>希望大佬们多多指出缺点，谢谢<br><br>def getSmoothList(lst):<br>    def gen_expand(_list):<br>        for item in _list:<br>            if isinstance(item, (list, tuple)):<br>                yield from gen_expand(item)<br>            else:<br>                yield item<br>    return list(gen_expand(lst))","like_count":5},{"had_liked":false,"id":98786,"user_name":"潇洒哥er","can_delete":false,"product_type":"c1","uid":1227101,"ip_address":"","ucode":"6ECF035120B350","user_header":"https://static001.geekbang.org/account/avatar/00/12/b9/5d/9e6e7a67.jpg","comment_is_top":false,"comment_ctime":1559094675,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23033931155","product_id":100026901,"comment_content":"看到评论区经常有同学在问手机用什么软件写代码，推荐一下：<br>苹果系统的：Pythonista 3<br>安卓系统的：PyDroid3 <br>两个都有用，但感觉苹果的pythonista 特别的好用，打一半提示一半，半智能，自动格式化。","like_count":5,"discussions":[{"author":{"id":1519200,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2e/60/4fa1f3bd.jpg","nickname":"rs勿忘初心","note":"","ucode":"557D1ECD757195","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398431,"discussion_content":"啊，还有用手机写代码的强需求啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632792845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021004,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/94/4c/abb7bfe3.jpg","nickname":"马庆","note":"","ucode":"7F8484548FCD0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56837,"discussion_content":"好贵","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574518710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98727,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1221267,"ip_address":"","ucode":"FF679EAE2B683D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/93/cfed7c6c.jpg","comment_is_top":false,"comment_ctime":1559084640,"is_pvip":false,"replies":[{"id":"35602","content":"数据库的用户名密码等一些信息不会暴露在外部的API中","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559156480,"ip_address":"","comment_id":98727,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23033921120","product_id":100026901,"comment_content":"关于嵌套函数：“我们只能通过调用外部函数 connect_DB() 来访问它，这样一来，程序的安全性便有了很大的提高。”    这个怎么就安全了呢？这个安全指的是什么安全呢？","like_count":5,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451810,"discussion_content":"数据库的用户名密码等一些信息不会暴露在外部的API中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559156480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137731,"user_name":"Gfcn","can_delete":false,"product_type":"c1","uid":1545958,"ip_address":"","ucode":"B0130F13DAF5B8","user_header":"https://static001.geekbang.org/account/avatar/00/17/96/e6/e7e6f578.jpg","comment_is_top":false,"comment_ctime":1569832688,"is_pvip":false,"replies":[{"id":"53023","content":"谢谢支持","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1569936479,"ip_address":"","comment_id":137731,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18749701872","product_id":100026901,"comment_content":"没想到连闭包都讲，真的是干货满满，32个赞","like_count":4,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469235,"discussion_content":"谢谢支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569936479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99375,"user_name":"michel","can_delete":false,"product_type":"c1","uid":1041031,"ip_address":"","ucode":"9BF44FA89F3B62","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hcuW3Hibz2Yl68OjRUQ2AIEnTjI0ylGOSAdmgOEpTYgel3hdJiaq1QJ2cFIjRO6Jv8xyTwBjR9SyQ17HMr77eZPQ/132","comment_is_top":false,"comment_ctime":1559201902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18739071086","product_id":100026901,"comment_content":"关于函数申明及调用关系，以及变量范围，做了几个测试，终于理解的比较透彻了。<br><br>def本身就是一个申明，如果不执行，不涉及对对象的引用，则不会报错，即使在函数内部引用了一个不存在的变量。关键在于执行的时候，被引用的变量或者函数是否被加载。<br><br>更详细的测试过程及分析，记录在博客中:https:&#47;&#47;www.jianshu.com&#47;p&#47;3c7f13cc6f8d","like_count":4},{"had_liked":false,"id":98860,"user_name":"路伴友行","can_delete":false,"product_type":"c1","uid":1506974,"ip_address":"","ucode":"96B54B7EEAEDAD","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/9e/8165b0a0.jpg","comment_is_top":false,"comment_ctime":1559108051,"is_pvip":false,"replies":[{"id":"35597","content":"你说的没错","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559155906,"ip_address":"","comment_id":98860,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18738977235","product_id":100026901,"comment_content":"顺便我想多问一句，在Python里是不推荐使用递归的，是因为Python没有对递归做优化，那使用 yield from 来代替递归会不会好些呢？<br>其实我上一个例子就是一个尝试，我之前只尝试过打印栈信息，只看到有2层，就是不清楚有些其他什么弊端。","like_count":4,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451868,"discussion_content":"你说的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559155906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98779,"user_name":"乔克","can_delete":false,"product_type":"c1","uid":1315273,"ip_address":"","ucode":"28A797A4235B78","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/c9/c3eae895.jpg","comment_is_top":false,"comment_ctime":1559094112,"is_pvip":false,"replies":[{"id":"35601","content":"文中已经更新了。可能之前表达的不准确，意思是主程序调用函数时，必须保证这个函数此前已经定义过，但是，如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为def是可执行语句，函数调用前都不存在，我们只需保证调用时，所需的函数都已经声明定义","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559156427,"ip_address":"","comment_id":98779,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18738963296","product_id":100026901,"comment_content":"老师，您说的“函数的调用和声明哪个在前哪个在后是无所谓的。”请问这句话怎么理解呢？<br>如下是会报异常NameError: name &#39;f&#39; is not defined：<br>f()<br>def f():<br>    print(&quot;test&quot;)","like_count":4,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451834,"discussion_content":"文中已经更新了。可能之前表达的不准确，意思是主程序调用函数时，必须保证这个函数此前已经定义过，但是，如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为def是可执行语句，函数调用前都不存在，我们只需保证调用时，所需的函数都已经声明定义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559156427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2591,"discussion_content":"python文档从上到下，按顺序执行，遇到函数定义时，不进入检查，只记录函数名称和位置。真正调用时，再返回到函数被定义处进入主体开始执行。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1563780735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1044785,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f1/31/5001390b.jpg","nickname":"Lonely绿豆蛙","note":"","ucode":"0862179B614974","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":153073,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580020876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2591,"ip_address":""},"score":153073,"extra":""},{"author":{"id":2146401,"avatar":"","nickname":"马学武","note":"","ucode":"23FA4EFD890850","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340384,"discussion_content":"谢谢，你的解释比文中的解释更易于理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609991426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2591,"ip_address":""},"score":340384,"extra":""}]}]},{"had_liked":false,"id":128407,"user_name":"_stuView","can_delete":false,"product_type":"c1","uid":1244561,"ip_address":"","ucode":"C2D4AAB08515F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/91/65ff3154.jpg","comment_is_top":false,"comment_ctime":1566877447,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10156812039","product_id":100026901,"comment_content":"老师可以讲一讲yield和return的用法和区别吗？还有yield from是什么呀？","like_count":2,"discussions":[{"author":{"id":1611663,"avatar":"https://static001.geekbang.org/account/avatar/00/18/97/8f/ccce7df1.jpg","nickname":"小匚","note":"","ucode":"78E800B23C457A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388576,"discussion_content":"yield 是想通过批量的接收出来，或者一次一次 next，来看、处理函数的返回值。\n\n爬虫时候经常会用到 yield。\n\nyield from 通常接一个列表或可以迭代的对象，然后从里面挨个 yield。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628839530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308541,"discussion_content":"https://www.mscto.com/python/617297.html\n可以看下这个解释，我觉得解释得很好了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600994712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98722,"user_name":"KaitoShy","can_delete":false,"product_type":"c1","uid":1038415,"ip_address":"","ucode":"E2E2E9BD3F5048","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","comment_is_top":false,"comment_ctime":1559082315,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10149016907","product_id":100026901,"comment_content":"a = {&#39;shanghai&#39;:50000, &#39;hangzhou&#39;:300000}<br><br>def func():<br>    a[&#39;beijing&#39;] = 17500<br>    <br>func()<br>print(a)<br><br>b = &#39;dfff&#39;<br>def func_a():<br>    b += &#39;ddd&#39;;<br>func_a()<br>print(b)<br>第一个改变了他的值，第二个确没有。是因为字典和列表是直接操作内存的？而变量的操作是重新生产一块内存？","like_count":2,"discussions":[{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2593,"discussion_content":"a是变量，b也是变量。python中的变量分为值类型和引用类型，int, string, bool, tuple属于值类型，不可变，任何试图改变它们的操作，将被视为重新创建；list, dict, set属于引用类型，可以随意修改。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1563781032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1764320,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/SKPfibfoMmlNicmhj6e84Pt7Z5eZ4iaKXqqkKbQpIx2qZ0BYQkXs0H3fOw7e8AGXEg27uic6hxt0MLenutViaaWblNA/132","nickname":"geek","note":"","ucode":"431C838A6491B0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577382,"discussion_content":"函数中的变量b就没有指向外部的变量b。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656059749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1315843,"avatar":"https://static001.geekbang.org/account/avatar/00/14/14/03/3712e70c.jpg","nickname":"yuehui","note":"","ucode":"159595CAB65E4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313941,"discussion_content":"int, string, bool, tuple类型的变量在函数中不能与全局变量重名？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603106536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98853,"user_name":"third","can_delete":false,"product_type":"c1","uid":1025114,"ip_address":"","ucode":"9A37408A834F0B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/5a/e708e423.jpg","comment_is_top":false,"comment_ctime":1559106435,"is_pvip":false,"replies":[{"id":"35598","content":"1. 我只是用‘...’表示省略<br>2. 全局变量在任何地方都可以访问，但是访问之前你必须得定义赋值他啊","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559156031,"ip_address":"","comment_id":98853,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5854073731","product_id":100026901,"comment_content":"1.Python中...是啥意思？发现在代码中运行没有错误。也没有百度到<br><br>2.#不是说全局变量可以在文件的任意地方都可以被访问吗？,我试了下，去掉x的赋值，就可以访问了。这是什么原因呢？<br>#x=10<br>def outer():<br>    print(x)<br>    x = &quot;local&quot;<br>    def inner():<br>        nonlocal x # nonlocal 关键字表示这里的 x 就是外部函数 outer 定义的变量 x<br>        x = &#39;nonlocal&#39;<br>        print(&quot;inner:&quot;, x)<br>    inner()<br>    print(&quot;outer:&quot;, x)<br>x=10<br>outer()<br><br>#报错Traceback (most recent call last):<br>#  File &quot;D:&#47;软件&#47;Python&#47;Lib&#47;idlelib&#47;新p&#47;学习分析&#47;写着玩.py&quot;, line 11, in &lt;module&gt;<br>#    outer()<br>#  File &quot;D:&#47;软件&#47;Python&#47;Lib&#47;idlelib&#47;新p&#47;学习分析&#47;写着玩.py&quot;, line 2, in outer<br>#    print(x)<br># UnboundLocalError: local variable &#39;x&#39; referenced before assignment<br><br>","like_count":1,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451863,"discussion_content":"1. 我只是用‘...’表示省略\n2. 全局变量在任何地方都可以访问，但是访问之前你必须得定义赋值他啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559156031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98826,"user_name":"SCAR","can_delete":false,"product_type":"c1","uid":1031209,"ip_address":"","ucode":"38C0927FA3C5FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/29/022905e6.jpg","comment_is_top":false,"comment_ctime":1559101288,"is_pvip":false,"replies":[{"id":"35599","content":"这个case by case，需要注意的是有些时候一些validation check的cost很高，比如机器学习里面我们会对训练数据（&gt;= 1000 million的样本）做一些统计等等","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559156182,"ip_address":"","comment_id":98826,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5854068584","product_id":100026901,"comment_content":"老师函数嵌套的作用二的例子，如果是在大量的调用函数时，可能还是分开检查和递归比较好，因为嵌套内函数是函数的一个local变量，在大量调用函数的时候，local变量是不断产生和销毁的，这会非常费时间，它可能会反噬掉一次类型检查节省下来的时间。看下面我贴出的计算1百万次100阶乘的时间，所以还是要根据具体情况来定，当然大部分时候函数不会这么大量调用。<br><br>def factorial(input):<br>    # validation check <br>    if not isinstance(input, int):<br>        raise Exception(&#39;input must be an integer.&#39;)<br>    if input &lt; 0:<br>        raise Exception(&#39;input must be greater or equal to 0&#39; )<br>    ...<br><br>    def inner_factorial(input):<br>        if input &lt;= 1:<br>            return 1<br>        return input * inner_factorial(input-1)<br>    return inner_factorial(input)<br><br>def factorial_1(input):<br>    # validation check<br>    if not isinstance(input, int):<br>        raise Exception(&#39;input must be an integer.&#39;)<br>    if input &lt; 0:<br>        raise Exception(&#39;input must be greater or equal to 0&#39; )<br><br>def inner_factorial_1(input):<br>    if input &lt;= 1:<br>        return 1<br>    return input*inner_factorial_1(input-1)<br><br>%%time<br>for i in range(1000000):<br>    factorial(100)<br>CPU times: user 21.6 s, sys: 11.6 ms, total: 21.6 s<br>Wall time: 21.7 s<br><br><br>%%time<br>for i in range(1000000):<br>    factorial_1(100)<br>    inner_factorial_1(100)<br>CPU times: user 19.7 s, sys: 12 ms, total: 19.7 s<br>Wall time: 19.7 s","like_count":1,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451854,"discussion_content":"这个case by case，需要注意的是有些时候一些validation check的cost很高，比如机器学习里面我们会对训练数据（&amp;gt;= 1000 million的样本）做一些统计等等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559156182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98789,"user_name":"乔克","can_delete":false,"product_type":"c1","uid":1315273,"ip_address":"","ucode":"28A797A4235B78","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/c9/c3eae895.jpg","comment_is_top":false,"comment_ctime":1559095089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5854062385","product_id":100026901,"comment_content":"老师，还有一个问题：您说“函数直到被调用前，都是不存在的，直到调用的时候才会创建一个新的函数对象，并赋予其名字”，难道不是在程序运行，函数就会被加载到内存中嘛？忘老师解惑，谢谢","like_count":1},{"had_liked":false,"id":347129,"user_name":"奔放还暖男","can_delete":false,"product_type":"c1","uid":2314639,"ip_address":"","ucode":"3AB00E32E76D36","user_header":"https://static001.geekbang.org/account/avatar/00/23/51/8f/770704c2.jpg","comment_is_top":false,"comment_ctime":1653730495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653730495","product_id":100026901,"comment_content":"工作两年了一直都没有使用过嵌套函数和闭包，一般都是一个函数写几百行的那种","like_count":0},{"had_liked":false,"id":345467,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1652313083,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652313083","product_id":100026901,"comment_content":"python函数相较其他语言最大的区别在于它不对参数做类型检查，def被调用时才创建函数，并将输入参数填入函数参数中，它不会对参数类型做检查，因此这需要函数的入口代码对参数做检查。由于可以嵌套函数，因此，函数入口做类型检查，接着再定义一个子函数来做实际计算，这样如果有递归调用的话，检查code只会执行一次。支持闭包也是python函数的重要特性，好处是可以减少输入参数，提高代码可读性。","like_count":1},{"had_liked":false,"id":332836,"user_name":"Geek_fightingDC","can_delete":false,"product_type":"c1","uid":1843027,"ip_address":"","ucode":"EF7F7316ADFF49","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83equSjO9AVmwhvyhTZzk6icNTSED9s1sUdFZSfqTHq2PmZ4MibMFX58C8qDW2a4cjiaFvAdiaRchsLz54g/132","comment_is_top":false,"comment_ctime":1643715260,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1643715260","product_id":100026901,"comment_content":"python闭包就是函数返回函数","like_count":1},{"had_liked":false,"id":332048,"user_name":"砖用冰西瓜","can_delete":false,"product_type":"c1","uid":1057075,"ip_address":"","ucode":"9FB3FAFC958A10","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/33/acacb6ac.jpg","comment_is_top":false,"comment_ctime":1642995470,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642995470","product_id":100026901,"comment_content":"使用闭包的话会影响 gc 么。","like_count":0},{"had_liked":false,"id":327835,"user_name":"Geek_44798f","can_delete":false,"product_type":"c1","uid":2851448,"ip_address":"","ucode":"4EB2BD9FBDDE7F","user_header":"","comment_is_top":false,"comment_ctime":1640321329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640321329","product_id":100026901,"comment_content":"一个函数中需要经常被处理的部分，而其他函数不需要的，就会被放到函数内部作为嵌套函数来写。","like_count":1},{"had_liked":false,"id":325242,"user_name":"二师兄","can_delete":false,"product_type":"c1","uid":1396137,"ip_address":"","ucode":"292931329F2150","user_header":"","comment_is_top":false,"comment_ctime":1638874349,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638874349","product_id":100026901,"comment_content":"请问把找出最大数里的条件判断，写成一行代码，为什么会报错？是因为赋值符号 = 的优先级导致的吗？<br>[largest_element = item  for item in l if item &gt; largest_element]","like_count":0},{"had_liked":false,"id":320151,"user_name":"浮石沉木","can_delete":false,"product_type":"c1","uid":2223167,"ip_address":"","ucode":"D585768321B84A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mQddXC7nRiaKHTwdficicTB3bH0q5ic5UoSab51Omic7eyLBz0SNcvbLpQnNib7zP1yJFm7xxx4ia81iahfibRVnbTwHmhw/132","comment_is_top":false,"comment_ctime":1636100575,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636100575","product_id":100026901,"comment_content":"老师，请教一个问题，如何在两个脚本中共享变量，我之前尝试了threadlocal来做还是不行，因为网上的例子基本都是在同一个脚本定义了localthread，我在实际中用两个脚本的方式来做，获取不到存入的变量。现在是存到环境变量中去，另一个脚本再去环境变量中拿然后删除。感觉这种操作很危险，但如果通过添加函数形参的方式来做，入侵性又太强了。<br>1 #!&#47;usr&#47;bin&#47;env python<br> 2 # -*- coding:utf-8 -*-<br> 3 # ThreadLocal code<br> 4 <br> 5 import threading<br> 6 <br> 7 NUM = 0<br> 8 local = threading.loacl()<br> 9 <br>10 <br>11 def run(x, n):<br>12     x = x + n<br>13     x = x - n<br>14 <br>15 <br>16 def func(n):<br>17     local.x = NUM  # 将全局变量赋值给一个线程要执行的函数的局部变量。<br>18     for i in range(1000000):<br>19         run(local.x, n)<br>20     print(&#39;%s-%d&#39; % (threading.current_thread().name, local.x))<br>21 <br>22 <br>23 if __name__ == &#39;__main__&#39;:<br>24     t1 = threading.Thread(target=func, args=(6,))<br>25     t2 = threading.Thread(target=func, args=(9,))<br>26     t1.start()<br>27     t2.start()<br>28     t1.join()<br>29     t2.join()<br>30     print(&#39;NUM = &#39;, NUM)<br><br>view_ThreadLocal_code","like_count":0},{"had_liked":false,"id":318125,"user_name":"Roway","can_delete":false,"product_type":"c1","uid":1060967,"ip_address":"","ucode":"65AF589142AB6C","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/67/a1e9aaba.jpg","comment_is_top":false,"comment_ctime":1635156353,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1635156353","product_id":100026901,"comment_content":"def exponent_of(base)  请问这里的base是什么意思？","like_count":0},{"had_liked":false,"id":295780,"user_name":"Geek_ab5b58","can_delete":false,"product_type":"c1","uid":2639740,"ip_address":"","ucode":"9192E195F5C63A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/f2LLuXLDVUliaDMxsiaB04ia46hkZyMljwiadxJ6ibPspmBrp5qwEjI0ZLkDSibNg0ez895WwTY91icPVgqKoEphSdKEA/132","comment_is_top":false,"comment_ctime":1622598102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622598102","product_id":100026901,"comment_content":"我的理解，闭包返回的就是一个匿名函数，square = nth_power(2) 中的 返回的匿名函数给了一个名字，名字叫square,","like_count":0},{"had_liked":false,"id":290662,"user_name":"lcqbug","can_delete":false,"product_type":"c1","uid":1268609,"ip_address":"","ucode":"08FA17F21BCEC5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbyHPGNLu9sDQOs1V6brMcDwia55pyIlP9n62oO6IYS6kIFDnOSON4ugSeBSy6WhDUnYyJC6vtnHQ/132","comment_is_top":false,"comment_ctime":1619680366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619680366","product_id":100026901,"comment_content":"<br>def factorial(input):<br>    # validation check<br>    if not isinstance(input, int):<br>        raise Exception(&#39;input must be an integer.&#39;)<br>    if input &lt; 0:<br>        raise Exception(&#39;input must be greater or equal to 0&#39; )<br>    ...<br><br>    def inner_factorial(input):<br>        if input &lt;= 1:<br>            return 1<br>        return input * inner_factorial(input-1)<br>    return inner_factorial(input)<br><br><br>print(factorial(5))<br>这个例子还是没看出来,inner function如果写到外边,相比之下,怎么效率低了","like_count":0},{"had_liked":false,"id":281680,"user_name":"Boom clap!!!","can_delete":false,"product_type":"c1","uid":2443427,"ip_address":"","ucode":"E9AF8ECB963239","user_header":"https://static001.geekbang.org/account/avatar/00/25/48/a3/2df11999.jpg","comment_is_top":false,"comment_ctime":1614846571,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614846571","product_id":100026901,"comment_content":"文章里说不能在函数内部随意改变全局变量的值，那同名的情况下又可以修改其值，这听起来有点矛盾，老师同学们能解释一下吗？","like_count":0},{"had_liked":false,"id":272236,"user_name":"马学武","can_delete":false,"product_type":"c1","uid":2146401,"ip_address":"","ucode":"23FA4EFD890850","user_header":"","comment_is_top":false,"comment_ctime":1610001133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610001133","product_id":100026901,"comment_content":"&quot;如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为 def 是可执行语句，函数在调用之前都不存在，我们只需保证调用时，所需的函数都已经声明定义&quot;<br>函数内部调用其他函数，函数间哪个声明在前，哪个在后无所谓。但是所有函数的声明必须全部在最外部函数调用语句之前。否则依然会报NameError","like_count":1},{"had_liked":false,"id":260660,"user_name":"迈克尔枪王岁月","can_delete":false,"product_type":"c1","uid":2228744,"ip_address":"","ucode":"7EA40C889614E2","user_header":"https://static001.geekbang.org/account/avatar/00/22/02/08/0aba59b0.jpg","comment_is_top":false,"comment_ctime":1605079739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605079739","product_id":100026901,"comment_content":"闭包相当于把参数分层了，常用参数分到一层，提前传进去。<br>print(cube(2)) 和 print(nth_power(3)(2)) 结果一样，但明显闭包更好看。","like_count":0},{"had_liked":false,"id":257942,"user_name":"顽石少年","can_delete":false,"product_type":"c1","uid":1371229,"ip_address":"","ucode":"397B01176626C3","user_header":"https://static001.geekbang.org/account/avatar/00/14/ec/5d/45227d75.jpg","comment_is_top":false,"comment_ctime":1604219438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604219438","product_id":100026901,"comment_content":"作者举的闭包的例子，就是偏函数吧。<br>闭包我看到比较白话的解释就是：函数 A 返回函数 B、同时函数 B 引用了函数 A 的变量。<br>感觉闭包和装饰器是python里面比较有趣的东西。","like_count":0},{"had_liked":false,"id":199341,"user_name":"Geek_David","can_delete":false,"product_type":"c1","uid":1897719,"ip_address":"","ucode":"9B9F30BB2F2C68","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/f7/871ff71d.jpg","comment_is_top":false,"comment_ctime":1585487238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585487238","product_id":100026901,"comment_content":"需要练习练习","like_count":0},{"had_liked":false,"id":197373,"user_name":"Geek_David","can_delete":false,"product_type":"c1","uid":1897719,"ip_address":"","ucode":"9B9F30BB2F2C68","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/f7/871ff71d.jpg","comment_is_top":false,"comment_ctime":1585372281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585372281","product_id":100026901,"comment_content":"global  nonlocal 好理解<br>闭包需要好好理解并实践一下<br>","like_count":0},{"had_liked":false,"id":187238,"user_name":"蚊子为什么不咬猫","can_delete":false,"product_type":"c1","uid":1433095,"ip_address":"","ucode":"7C2D2461D6494A","user_header":"https://static001.geekbang.org/account/avatar/00/15/de/07/9525a99b.jpg","comment_is_top":false,"comment_ctime":1584067427,"is_pvip":false,"replies":[{"id":"72343","content":"当然是函数，但是这里主要讲自定义哈","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1584135520,"ip_address":"","comment_id":187238,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584067427","product_id":100026901,"comment_content":"正则表达式算吗？<br>r = re.compile(&#39;[^\\w]&#39;)<br>r.match()","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487039,"discussion_content":"当然是函数，但是这里主要讲自定义哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584135520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177954,"user_name":"拾掇拾掇","can_delete":false,"product_type":"c1","uid":1051873,"ip_address":"","ucode":"D775F374C2A1D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","comment_is_top":false,"comment_ctime":1581561322,"is_pvip":true,"replies":[{"id":"69474","content":"没明白你的意思，能说的清除一些么？","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1581883705,"ip_address":"","comment_id":177954,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581561322","product_id":100026901,"comment_content":"全局声明不可能类型，那么在函数内部只要想全局修改都要加global，所以得出global适合用于不可变类型，因为可变类型不需要也不会报错?","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483609,"discussion_content":"没明白你的意思，能说的清除一些么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581883705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174174,"user_name":"bbbi","can_delete":false,"product_type":"c1","uid":1682175,"ip_address":"","ucode":"9A539AEF791428","user_header":"https://static001.geekbang.org/account/avatar/00/19/aa/ff/e2c331e0.jpg","comment_is_top":false,"comment_ctime":1580044009,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580044009","product_id":100026901,"comment_content":"Python 不用考虑输入的数据类型，而是将其交给具体的代码去判断执行，这个应该是函数的重载吧，不是多态，个人理解","like_count":0,"discussions":[{"author":{"id":1764941,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ee/4d/5d021e4c.jpg","nickname":"向左看齐","note":"","ucode":"2E0AC7D59AF85C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230678,"discussion_content":"重载：同名不同参数（参数必须不同）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586761391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166946,"user_name":"Nemo","can_delete":false,"product_type":"c1","uid":1657039,"ip_address":"","ucode":"2B11D18D6FA2AE","user_header":"https://static001.geekbang.org/account/avatar/00/19/48/cf/8c88e6c0.jpg","comment_is_top":false,"comment_ctime":1577635447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577635447","product_id":100026901,"comment_content":"flask中路由使用装饰器","like_count":0},{"had_liked":false,"id":166661,"user_name":"MickeyW","can_delete":false,"product_type":"c1","uid":1376714,"ip_address":"","ucode":"4D2AEB20A34E1C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEK4rOhXRjMHbgRVtogiaEt93ia2lQDwtgxic5YBicHNIJFK9k0LibxTwLjSH1NzjEsUTiciawsCvaASZB7Ag/132","comment_is_top":false,"comment_ctime":1577538922,"is_pvip":false,"replies":[{"id":"66790","content":"有可能，stackoverflow上有相关的讨论：https:&#47;&#47;stackoverflow.com&#47;questions&#47;2017381&#47;is-it-possible-to-have-an-actual-memory-leak-in-python-because-of-your-code","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1579135800,"ip_address":"","comment_id":166661,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577538922","product_id":100026901,"comment_content":"python里的闭包也会跟javaScript里的闭包一样，有内存得不到释放的问题么？","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479575,"discussion_content":"有可能，stackoverflow上有相关的讨论：https://stackoverflow.com/questions/2017381/is-it-possible-to-have-an-actual-memory-leak-in-python-because-of-your-code","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579135800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151214,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573679396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573679396","product_id":100026901,"comment_content":"在面向对象出来之前，函数都是主要的组织代码的工具与。函数的嵌套赋予函数内组织代码的方便，可以隐藏内部实现，可以处理紧密关联的功能，避免多重检查的作用。<br><br>函数内部对全局变量是只读的，要写全局变量需要额外的声明。嵌套域也类似。<br><br>闭包起到了的分步组装函数的作用。个人以为文中的平方函数不适合闭包，定义两个函数即可，一个是通用指数函数，一个是求平方函数，让求平方的函数调用通用指数函数。<br><br>","like_count":0},{"had_liked":false,"id":136017,"user_name":"自由民","can_delete":false,"product_type":"c1","uid":1346236,"ip_address":"","ucode":"435C67531697F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/bc/cb39ed38.jpg","comment_is_top":false,"comment_ctime":1569330645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569330645","product_id":100026901,"comment_content":"总结:函数参数可以接受任意类型，但要注意可能出错。函数参数可以设置默认值。函数可以嵌套，好处是安全，一些每次需要执行的操作只用执行一次，比较高效。在函数内部修改外部变量需要进行global或nonlocal声明，否则修改只在函数内部有效。闭包是嵌套函数的外层函数返回函数而不是值，返回的函数可以在后期执行。使用闭包的好处是使程序简洁高效。<br>思考题:在有一些共同的步骤要执行且只需执行一次是使用，共同部分放在外层。至于闭包，以前当然听过，从来没具体了解过。使用场合没想到有啥，看看其它同学的留言？<br>课程的练习代码: https:&#47;&#47;github.com&#47;zwdnet&#47;PythonPractice","like_count":0},{"had_liked":false,"id":134482,"user_name":"夜雨声烦","can_delete":false,"product_type":"c1","uid":1349749,"ip_address":"","ucode":"87D8DB1E32522A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6mh3xlaMoGtWjmVJh2LutdLcQcPbKNjRlVru3bx8ynPhgwuGhhdzTkwEMoXbvBtgkcDSfom1kZg/132","comment_is_top":false,"comment_ctime":1568854379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568854379","product_id":100026901,"comment_content":"使用了闭包就可以将某个函数中的变量与外部链接起来，跟封装有些像，这样可以将数据与多个方法联系在一起。","like_count":0},{"had_liked":false,"id":126291,"user_name":"王帅帅","can_delete":false,"product_type":"c1","uid":1526719,"ip_address":"","ucode":"84424192B61D47","user_header":"https://static001.geekbang.org/account/avatar/00/17/4b/bf/d714f592.jpg","comment_is_top":false,"comment_ctime":1566357422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566357422","product_id":100026901,"comment_content":"github地址多少","like_count":0},{"had_liked":false,"id":109520,"user_name":"Goal","can_delete":false,"product_type":"c1","uid":1307012,"ip_address":"","ucode":"C337CD4C7E07B0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/84/7d21bd9e.jpg","comment_is_top":false,"comment_ctime":1562049716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562049716","product_id":100026901,"comment_content":"加油，肯一门编程语言。","like_count":0},{"had_liked":false,"id":107468,"user_name":"magician","can_delete":false,"product_type":"c1","uid":1483968,"ip_address":"","ucode":"1BD1125C7C907A","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/c0/c6880c07.jpg","comment_is_top":false,"comment_ctime":1561541005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561541005","product_id":100026901,"comment_content":"递归，接口用户身份权限认证","like_count":0},{"had_liked":false,"id":103026,"user_name":"enjoylearning","can_delete":false,"product_type":"c1","uid":1000237,"ip_address":"","ucode":"DCAF8538DEA277","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","comment_is_top":false,"comment_ctime":1560350599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560350599","product_id":100026901,"comment_content":"另外我觉得检验函数参数也可以用断言assert ，但不知道和此处作者提到的哪个更好些。","like_count":0},{"had_liked":false,"id":102463,"user_name":"青木如夏","can_delete":false,"product_type":"c1","uid":1066061,"ip_address":"","ucode":"D6FF4092890A96","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/4d/f1497d7e.jpg","comment_is_top":false,"comment_ctime":1560226576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560226576","product_id":100026901,"comment_content":"建议贴:先给出普通案例,再给出优化后的知识点案例,这样一目了然.","like_count":0},{"had_liked":false,"id":101419,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1559803955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559803955","product_id":100026901,"comment_content":"闭包是不是可以理解为C语言里面的一个函数，返回的就是一个函数指针？<br>可以用一个指针接受函数指针。","like_count":0},{"had_liked":false,"id":101364,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1559788975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559788975","product_id":100026901,"comment_content":"1.Python 中函数的参数可以接受任意的数据类型，使用起来需要注意，必要时请在函数开头加入数据类型的检查；<br>2.和其他语言不同，Python 中函数的参数可以设定默认值；<br>3.嵌套函数的使用，能保证数据的隐私性，提高程序运行效率；<br>4.合理地使用闭包，则可以简化程序的复杂度，提高可读性。<br><br>另外，在Python中函数是一等公民","like_count":0},{"had_liked":false,"id":101166,"user_name":"蚂蚁","can_delete":false,"product_type":"c1","uid":1210950,"ip_address":"","ucode":"966A24FA95B83B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7a/46/c296dea8.jpg","comment_is_top":false,"comment_ctime":1559732256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559732256","product_id":100026901,"comment_content":"&quot;其实函数也可以看做成是一个变量，函数名就是变量名，函数体就是值。函数虽然在不被调用的情况下不会执行，但是python解释器会做一些变量检测、或者类型检测，比如是不是有yield，如果有那么就会被标记为生成器，这个在编译成字节码的时候就已经确定了。而有些东西则是只有在解释执行的时候才会被发现。<br>比如说：<br>x = 1<br><br><br>def foo():<br>    print(x)<br>    x = 10<br>foo() # UnboundLocalError: local variable &#39;x&#39; referenced before assignment<br>为什么会有这种结果，因为python寻找变量的时候，会按照本地作用域、闭包、全局、内置这种顺序去查找，当看到x=1的时候，python解释器就知道函数体内部创建了变量x，这是在编译的时候就已经确定了，于是在print的时候也会从本地查找，但是print(x)语句在x=10的上面，这是在执行的时候才发现的，于是报了个错：提示局部变量x在赋值之前就已经被引用了。&quot;<br>这里为什么当看到x=1的时候 python解释器就知道函数体内部创建了变量x","like_count":0},{"had_liked":false,"id":101134,"user_name":"while (1)等;","can_delete":false,"product_type":"c1","uid":1061991,"ip_address":"","ucode":"BAEC7258D65B69","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/67/06a7f9be.jpg","comment_is_top":false,"comment_ctime":1559724298,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1559724298","product_id":100026901,"comment_content":"“如果不加上 nonlocal 这个关键字，而内部函数的变量又和外部函数变量同名，那么同样的，内部函数变量会覆盖外部函数的变量。“     这个是不覆盖吧","like_count":0,"discussions":[{"author":{"id":1448974,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/0e/42b357cd.jpg","nickname":"Xiky","note":"","ucode":"C9E8D8C7024CA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91405,"discussion_content":"所谓的覆盖，是指在内部函数中会以内部定义的值为准，不是指修改了外部的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576832255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475340,"avatar":"https://static001.geekbang.org/account/avatar/00/16/83/0c/b9e39db4.jpg","nickname":"韩俊臣","note":"","ucode":"D6A15C025570D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25332,"discussion_content":"同问，老师贴出来的运行结果与语言描述是相反的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570504425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99864,"user_name":"wanj","can_delete":false,"product_type":"c1","uid":1259549,"ip_address":"","ucode":"BE9ECC67ABC004","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLnYfSUc8hJ3oLfa39qkNiaXNibs3VyAbgT7ZXasZXp89fRL7YBakIZdNNEE7kClOjN2KpBUuGpacfQ/132","comment_is_top":false,"comment_ctime":1559345709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559345709","product_id":100026901,"comment_content":"默认值参数再有新的参数也必须是带有默认值的，另外*args **kargs也比较常用，希望能够补充讲解","like_count":0},{"had_liked":false,"id":99508,"user_name":"大斌","can_delete":false,"product_type":"c1","uid":1002183,"ip_address":"","ucode":"1434C2B0A29135","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/c7/ec18673b.jpg","comment_is_top":false,"comment_ctime":1559232894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559232894","product_id":100026901,"comment_content":"闭包就是函数中的函数，输出结果是内部函数并且复制给变量再操作，并且会记住外部函数已经输入的值，内部函数赋予的变量可以被调用并添加参数。可以简化函数复杂度。","like_count":0},{"had_liked":false,"id":99309,"user_name":"lllong33","can_delete":false,"product_type":"c1","uid":1528751,"ip_address":"","ucode":"5D012385994C3D","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/af/e5bf5d08.jpg","comment_is_top":false,"comment_ctime":1559189745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559189745","product_id":100026901,"comment_content":"构造多条线性方程<br>def line_conf(a, b):<br>    def line(x):<br>        return a*x + b<br>    return line<br>line1 = line_conf(1,1)<br>line2 = line_conf(4,5)<br>print(line1(5), line2(5))<br>--------------------- <br>原文：https:&#47;&#47;blog.csdn.net&#47;lllong33&#47;article&#47;details&#47;85124086 ","like_count":0},{"had_liked":false,"id":99304,"user_name":"lllong33","can_delete":false,"product_type":"c1","uid":1528751,"ip_address":"","ucode":"5D012385994C3D","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/af/e5bf5d08.jpg","comment_is_top":false,"comment_ctime":1559189112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559189112","product_id":100026901,"comment_content":"闭包相对于<br><br>全局变量：不能很好的封装<br><br>缺省参数：适应场景有限<br><br>类对象：默认参数和方法过多，消耗内存。<br>引用：https:&#47;&#47;blog.csdn.net&#47;lllong33&#47;article&#47;details&#47;85124086","like_count":0},{"had_liked":false,"id":99193,"user_name":"Fergus","can_delete":false,"product_type":"c1","uid":1277066,"ip_address":"","ucode":"3A8AC741C49CEB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","comment_is_top":false,"comment_ctime":1559176723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559176723","product_id":100026901,"comment_content":"遇到老师文中提到的隐藏“数据库密码”的问题，一直没有解决。读完可操作：1.虽不能完全解决，但作为内部函数封装可能更好一点；2.从答案获取到一般使用hash，或token，这点老师可以提示多一点么？谢谢🙏🙏<br>","like_count":0},{"had_liked":false,"id":99084,"user_name":"enjoylearning","can_delete":false,"product_type":"c1","uid":1000237,"ip_address":"","ucode":"DCAF8538DEA277","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","comment_is_top":false,"comment_ctime":1559140708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559140708","product_id":100026901,"comment_content":"def是可执行语句，是说它跟条件或循环语句具有相同的优先级吗？","like_count":0},{"had_liked":false,"id":99083,"user_name":"Geek_5c241c","can_delete":false,"product_type":"c1","uid":1525895,"ip_address":"","ucode":"78129ACF50D3D9","user_header":"","comment_is_top":false,"comment_ctime":1559140537,"is_pvip":false,"replies":[{"id":"35622","content":"你仔细看文章，文章里说的是函数内部的MIN_VALUE是3，因为函数内部局部变量覆盖了全局变量。<br><br>你如果如果在函数外部打印当然是1。","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559173048,"ip_address":"","comment_id":99083,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559140537","product_id":100026901,"comment_content":"MIN_VALUE = 1<br>MAX_VALUE = 10<br>def validation_check(value):<br>    MIN_VALUE = 3<br><br><br>validation_check(1)<br><br>print(MIN_VALUE)<br><br>仍然是1而不是文章里面说的3，是不是弄错了？","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451966,"discussion_content":"你仔细看文章，文章里说的是函数内部的MIN_VALUE是3，因为函数内部局部变量覆盖了全局变量。\n\n你如果如果在函数外部打印当然是1。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559173048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99078,"user_name":"carpe_diem","can_delete":false,"product_type":"c1","uid":1085804,"ip_address":"","ucode":"25A77D8D146A4F","user_header":"https://static001.geekbang.org/account/avatar/00/10/91/6c/054a0745.jpg","comment_is_top":false,"comment_ctime":1559139844,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559139844","product_id":100026901,"comment_content":"<br>\t1. 函数内部修改全局变量，需要在全局标量之前加global标识，否则python会默认变量为局部变量，导致逻辑错误，甚至报错<br>\t2. 函数嵌套中，内部函数不能直接修改外部函数的变量，如需修改，必须使用nonlocal关键字在内部函数中表明变量在外部函数中定义<br>\t3. 合理使用函数嵌套，可以提高函数执行的效率。比如求阶乘时，需要检查输入是否合法，使用递归的方式，如果在需要递归的函数中检查输入，则每次递归都要执行这些检查，降低了效率。可以使用函数嵌套，在外层函数检查输入，内层函数来递归，最后返回结果。<br>\t4. 闭包。一个函数返回一个内部函数，外层函数返回后，被返回的函数依然可以访问外层变量<br><br>","like_count":0},{"had_liked":false,"id":99072,"user_name":"Hoo-Ah","can_delete":false,"product_type":"c1","uid":1306913,"ip_address":"","ucode":"823093A6C7DEE7","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/21/52e8267b.jpg","comment_is_top":false,"comment_ctime":1559139365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559139365","product_id":100026901,"comment_content":"回答farFlight的第二个问题，函数传参的时候有两种形式，一种是值传递，另一种是引用传递。值传递是针对于那些不可变数据类型像字符串，整型；引用传递是针对于可变数据类型，像列表和字典。所以在函数内部对可变数据类型是可以直接进行操作的。而不可变数据类型操作的话就是对变量重新赋值。","like_count":0},{"had_liked":false,"id":99056,"user_name":"pysn","can_delete":false,"product_type":"c1","uid":1545732,"ip_address":"","ucode":"0C28215188C5D4","user_header":"","comment_is_top":false,"comment_ctime":1559136796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559136796","product_id":100026901,"comment_content":"函数嵌套的第二个例子很赞","like_count":0},{"had_liked":false,"id":98965,"user_name":"她の他","can_delete":false,"product_type":"c1","uid":1312694,"ip_address":"","ucode":"A61CEC365D782F","user_header":"https://static001.geekbang.org/account/avatar/00/14/07/b6/e213fc11.jpg","comment_is_top":false,"comment_ctime":1559121028,"is_pvip":true,"replies":[{"id":"35595","content":"装饰物后面会讲到","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559150967,"ip_address":"","comment_id":98965,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559121028","product_id":100026901,"comment_content":"使用装饰器计算某个函数的执行时间，可以做简单的权限校验","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451912,"discussion_content":"装饰物后面会讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559150967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98953,"user_name":"rogerr","can_delete":false,"product_type":"c1","uid":1538280,"ip_address":"","ucode":"735EE845D4560F","user_header":"https://static001.geekbang.org/account/avatar/00/17/78/e8/b79240e8.jpg","comment_is_top":false,"comment_ctime":1559119398,"is_pvip":false,"replies":[{"id":"35596","content":"我这里只是举例说明。实际会做hash，或者通过token之类的其他方式访问","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559151034,"ip_address":"","comment_id":98953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559119398","product_id":100026901,"comment_content":"连接数据库的密码信息虽然在嵌套的函数里，但对于脚本来说还是明文的","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451907,"discussion_content":"我这里只是举例说明。实际会做hash，或者通过token之类的其他方式访问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559151034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98839,"user_name":"voc","can_delete":false,"product_type":"c1","uid":1526888,"ip_address":"","ucode":"EDAFFBA02550FF","user_header":"https://static001.geekbang.org/account/avatar/00/17/4c/68/77a0ac2d.jpg","comment_is_top":false,"comment_ctime":1559103028,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1559103028","product_id":100026901,"comment_content":"在函数内部，改变外部变量内存地址的操作需要使用global声明，对于list,dict内容的扩充没有改变原变量内存地址，所以不需要声明。","like_count":0,"discussions":[{"author":{"id":2146401,"avatar":"","nickname":"马学武","note":"","ucode":"23FA4EFD890850","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340389,"discussion_content":"list，dict不需要声明，直接使用的是外部定义的；\n如果内部重新声明了，会覆盖外部声明的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609992014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98825,"user_name":"鱼_XueTr","can_delete":false,"product_type":"c1","uid":1506691,"ip_address":"","ucode":"A164D2540F251D","user_header":"https://static001.geekbang.org/account/avatar/00/16/fd/83/b432b125.jpg","comment_is_top":false,"comment_ctime":1559100738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559100738","product_id":100026901,"comment_content":"前面对函数嵌套，闭包，生成器的概念比较模糊，现在可以比较清楚区分了","like_count":0},{"had_liked":false,"id":98823,"user_name":"从来不摸鱼","can_delete":false,"product_type":"c1","uid":1526578,"ip_address":"","ucode":"6758D7F2403C4E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ernIGVtCQTwc9BYKrmPVOEt0WSMiaUwkiciaYEdT2vfpY0uViaEvaDPOUGBpwwiaOYyrNfTqeHurYT7vmg/132","comment_is_top":false,"comment_ctime":1559100539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559100539","product_id":100026901,"comment_content":"请问老师，通过global声明和通过nonlocal关键字在函数内部修改全局变量的值，两者的效果是一样的吗？","like_count":0},{"had_liked":false,"id":98821,"user_name":"........","can_delete":false,"product_type":"c1","uid":1236198,"ip_address":"","ucode":"D54E7F428E7F49","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/e6/ea4b2c10.jpg","comment_is_top":false,"comment_ctime":1559100290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559100290","product_id":100026901,"comment_content":"在函数式编程中，会大量运用函数嵌套和闭包，来达到高度抽象的目的。","like_count":0},{"had_liked":false,"id":98819,"user_name":"Iris","can_delete":false,"product_type":"c1","uid":1352522,"ip_address":"","ucode":"8096A5BAB52B8A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLMdia9R0bMfaA9jbcVOyQFlrr3N4EEDeQYibNFQm2WzYPvoSWERh7jNcSSeqTZIXcjTVua3tetNW4w/132","comment_is_top":false,"comment_ctime":1559100160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559100160","product_id":100026901,"comment_content":"想请教一下老师：如果不加上 nonlocal 这个关键字，而内部函数的变量又和外部函数变量同名。那么同样的，内部函数变量会覆盖外部函数的变量<br>这句话怎么理解？加上这个关键字不是内外部函数都输出nonlocal吗？不加这个关键字不是内部输出nonlocal,而外部输出local，不是应该理解为：加上这个关键字，内部函数才会覆盖外部函数的同名变量，而不加这个关键字内部函数的同名变量只是局部变量，而不会覆盖外部函数的同名变量吗？","like_count":0},{"had_liked":false,"id":98813,"user_name":"Wing·三金","can_delete":false,"product_type":"c1","uid":1341402,"ip_address":"","ucode":"6B9F5822C3717F","user_header":"https://static001.geekbang.org/account/avatar/00/14/77/da/54c663f3.jpg","comment_is_top":false,"comment_ctime":1559099395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559099395","product_id":100026901,"comment_content":"今日所得：<br>函数内部使用全局变量须加 global，嵌套&#47;闭包中使用外层函数的变量须加 nonlocal；<br>旧的 range 生成 list，新的 range == xrange 即生成的是 generator，目的是减小内存开销；<br>yield 近似于 return，但后者是“一次性”的，前者每一次调用都会基于上一次的调用；<br>嵌套的使用场景之一是隐私保护 + 排除不必要的重复调用以提高代码效率；<br>闭包的使用场景之一是预定义好共通的工作以提高代码效率 + 简洁；<br><br>思考题：<br>当函数 A 需要用到函数 B 中的变量时，一个选择是不使用嵌套，将需要用到的变量作为参数传递，另一个选择就是将 A 定义为 B 中的嵌套函数。后者适用于传参代价比较大的情况，比如传递一个很大的且需要作出改动的 list。<br>闭包方面个人之前都只是配合 decorator 来使用，暂未遇到其他案例。过几天再来回顾下大家的留言~<br><br>（另外，之前 06 讲的思考题—— 5 GB 大文件的传输，请问老师的代码已经发出来了吗？在哪里找呢？感谢~！）","like_count":0},{"had_liked":false,"id":98806,"user_name":"Steven","can_delete":false,"product_type":"c1","uid":1495454,"ip_address":"","ucode":"BC5B33911FEC46","user_header":"https://static001.geekbang.org/account/avatar/00/16/d1/9e/fe7bc8df.jpg","comment_is_top":false,"comment_ctime":1559098449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559098449","product_id":100026901,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":98793,"user_name":"对方正在输入中…","can_delete":false,"product_type":"c1","uid":1210596,"ip_address":"","ucode":"D40224951C57E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/78/e4/7978869e.jpg","comment_is_top":false,"comment_ctime":1559095635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559095635","product_id":100026901,"comment_content":"景大大，能把关于嵌套函数的安全例子举两个不？有例子要好理解一些。","like_count":0},{"had_liked":false,"id":98781,"user_name":"马星","can_delete":false,"product_type":"c1","uid":1247867,"ip_address":"","ucode":"83D9460D21CEF3","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/7b/eb3323eb.jpg","comment_is_top":false,"comment_ctime":1559094452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559094452","product_id":100026901,"comment_content":"with open(file_path) as file:这句中的with是什么意思？老师还没讲过呢","like_count":0},{"had_liked":false,"id":98778,"user_name":"徐辰伟","can_delete":false,"product_type":"c1","uid":1252251,"ip_address":"","ucode":"42F05490BA8DBE","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/9b/89c1929e.jpg","comment_is_top":false,"comment_ctime":1559094013,"is_pvip":false,"replies":[{"id":"35600","content":"文中已经更新了。可能之前表达的不准确，意思是主程序调用函数时，必须保证这个函数此前已经定义过，但是，如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为def是可执行语句，函数调用前都不存在，我们只需保证调用时，所需的函数都已经声明定义","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559156419,"ip_address":"","comment_id":98778,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559094013","product_id":100026901,"comment_content":"文章中说函数的声明和调用哪个在前，哪个在后都无所谓。可是实际试了下先调用再声明会报错？","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451833,"discussion_content":"文中已经更新了。可能之前表达的不准确，意思是主程序调用函数时，必须保证这个函数此前已经定义过，但是，如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为def是可执行语句，函数调用前都不存在，我们只需保证调用时，所需的函数都已经声明定义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559156419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98718,"user_name":"栾~龟虽寿！","can_delete":false,"product_type":"c1","uid":1504671,"ip_address":"","ucode":"219B38C08979FE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","comment_is_top":false,"comment_ctime":1559077383,"is_pvip":false,"replies":[{"id":"35603","content":"是在web上写的。谢谢你的支持，也欢迎你把专栏分享给更多的朋友！","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1559156513,"ip_address":"","comment_id":98718,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559077383","product_id":100026901,"comment_content":"这节课，轻轻的，把函数讲明白了，老师厉害，我收获，嵌套函数，可以保护隐私；只检查一次，提高了效率。老师，大家是怎么用手机写代码的？求答案","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451805,"discussion_content":"是在web上写的。谢谢你的支持，也欢迎你把专栏分享给更多的朋友！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559156513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98709,"user_name":"yshan","can_delete":false,"product_type":"c1","uid":1136788,"ip_address":"","ucode":"A2ECDCDA52B8EE","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/94/c8bc2b59.jpg","comment_is_top":false,"comment_ctime":1559063064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559063064","product_id":100026901,"comment_content":"函数，实现某一功能的代码块<br><br>def是可执行语句<br>python特性，多态，支持嵌套<br><br>嵌套优势：<br>保护内部函数隐私<br>提高运行效率<br><br>函数变量作用域：<br>局部变量 <br>全局变量<br>关键字：global  nonlocal<br><br>闭包：返回一个函数，<br>优势：简洁易读，执行效率高<br>常与装饰器一起使用<br><br>疑问：怎么理解“def是可执行语句，函数直到被调用前，都是不存在的”","like_count":0}]}