{"id":154378,"title":"26 | Facebook怎样实现代码提交的原子性？","content":"<p>你好，我是葛俊。今天，我们继续来聊聊如何通过Git提高代码提交的原子性吧。</p><p>在上一篇文章中，我给你详细介绍了Git助力提高代码提交原子性的五条基础操作，今天我们再来看看Facebook的开发人员具体是如何使用这些操作来实现提交的原子性的。</p><p>为了帮助你更直观地理解、学习，在这篇文章里，我会与你详细描述工作场景，并列出具体命令。同时，我还把这些命令的输出也都放到了文章里，供你参考。所以，这篇文章会比较长、比较细。不过不要担心，这些内容都是日常工作中的自然流程，阅读起来也会比较顺畅。</p><p>在Facebook，开发人员最常使用两种Git工作流：</p><ul>\n<li>使用一个分支，完成所有需求的开发；</li>\n<li>使用多个分支，每个分支支持一个需求的开发。</li>\n</ul><p>两种工作流都利用Git的超强功能来提高代码原子性。这里的“需求”包括功能开发和缺陷修复，用大写字母A、B、C等表示；每个需求都可能包含有多个提交，每个提交用需求名+序号表示。比如，A可能包含A1、A2两个提交，B只包含B1这一个提交，而C包含C1、C2、C3三个提交。</p><p>需要强调的是，这两种工作流中的一个分支和多个分支，都是在开发者本地机器上的分支，不是远程代码仓中的功能分支。我在前面<a href=\"https://time.geekbang.org/column/article/132499\">第7篇文章</a>中提到过，Facebook的主代码仓是不使用功能分支的。</p><!-- [[[read_end]]] --><p>另外，这两种Git工作流对代码提交原子性的助力作用，跟主代码仓是否使用单分支开发没有关系。也就是说，即使你所在团队的主仓没有使用Facebook那样的单分支开发模式，仍然可以使用这两种工作流来提高代码提交的原子性。</p><p>接下来，我们就先看看第一种工作流，也就是使用一个分支完成所有需求的开发。</p><h2>工作流一：使用一个分支完成所有需求的开发</h2><p>这种工作流程的最大特点是，<strong>使用一个分支上的提交链，大量使用git rebase -i来修改提交链上的提交</strong>。这里的提交链，指的是当前分支上，还没有推送到远端主仓共享分支的所有提交。</p><p>首先，我们需要设置一个本地分支来开发需求，通过这个分支和远端主仓的共享分支进行交互。本地分支通常直接使用master分支，而远端主仓的共享分支一般是origin/master，也叫作上游分支（upstream）。</p><p>一般来说，在git clone的时候，master是默认已经产生，并且是已经跟踪origin/master了的，你不需要做任何设置，可以查看.git/config文件做确认：</p><pre><code>&gt; cat .git/config\n...\n[remote &quot;origin&quot;]\n\turl = git@github.com:jungejason/git-atomic-demo.git\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n[branch &quot;master&quot;]\n\tremote = origin\n\tmerge = refs/heads/master\n</code></pre><p>可以看到，branch \"master\"里有一个remote = origin选项，表明master分支在跟踪origin这个上游仓库；另外，config文件里还有一个remote \"origin\"选项，列举了origin这个上游仓库的地址。</p><p>当然，除了直接查看config文件外，Git还提供了命令行工具。你可以使用git branch -vv查看某个分支是否在跟踪某个远程分支，然后再使用git remote show <upstream-repo-name>去查看远程代码仓的细节。</upstream-repo-name></p><pre><code>## 查看远程分支细节\n&gt; git branch -vv\n  master      5055c14 [origin/master: behind 1] Add documentation for getRandom endpoint\n\n\n## 查看分支跟踪的远程代码仓细节\n&gt; git remote show origin\n* remote origin\n  Fetch URL: git@github.com:jungejason/git-atomic-demo.git\n  Push  URL: git@github.com:jungejason/git-atomic-demo.git\n  HEAD branch: master\n  Remote branch:\n    master tracked\n  Local branches configured for 'git pull':\n    master  merges with remote master\n  Local ref configured for 'git push':\n    master pushes to master (fast-forwardable)\n11:07:36 (master2) jasonge@Juns-MacBook-Pro-2.local:~/jksj-repo/git-atomic-demo\n</code></pre><p>因为config文件简单直观，所以我常常直接到config文件里面查看和修改来完成这些操作。关于远程跟踪上游代码仓分支的更多细节，比如产生新分支、设置上游分支等，你可以参考<a href=\"https://mincong-h.github.io/2018/05/02/git-upstream-tracking/\">Git: Upstream Tracking Understanding</a>这篇文章。</p><p>设置好分支之后，我们来看看<strong>这个工作流中的具体步骤</strong>。</p><h3>单分支工作流具体步骤</h3><p>单分支工作流的步骤，大致包括以下4步：</p><ol>\n<li>一个原子性的功能完成后，使用<a href=\"https://time.geekbang.org/column/article/152715\">第25篇文章</a>中提到的改变提交顺序的方法，把它放到距离origin/master最近的地方。</li>\n<li>把这个提交发到代码审查系统Phabricator上进行质量检查，包括代码审查和机器检查。在等待质量检查结果的同时，继续其他提交的开发。</li>\n<li>如果没有通过质量检查，则需要对提交进行修改，修改之后返回第2步。</li>\n<li>如果通过质量检查， 就把这个提交推送到主代码仓的共享分支上，然后继续其他分支的开发，回到第1步。</li>\n</ol><p>请注意第二步的目的是，确保入库代码的质量，你可以根据实际情况进行检查。比如，你可以通过提交PR触发机器检查的工作流，也可以运行单元测试自行检查。如果没有任何质量检查的话，至少也要进行简单手工验证，让进入到远程代码仓的代码有起码的质量保障。</p><p>接下来，我设计了一个案例，尽量模拟我在Facebook的真实开发场景，与你讲述这个工作流的操作步骤。大致场景是这样的：我本来在开发需求A，这时来了更紧急的需求B。于是，我开始开发B，把B分成两个原子性提交B1和B2，并在B1完成之后最先推送到远程代码仓共享分支。</p><p>这个案例中，提交的改动很简单，但里面涉及了很多开发技巧，可供你借鉴。</p><h3>阶段1：开始开发需求A</h3><p>某天，我接到开发需求A的任务，要求在项目中添加一个README文件，对项目进行描述。</p><p>我先添加一个简单的README.md文件，然后用git commit -am ‘readme’ 快速生成一个提交A1，确保代码不会丢失。</p><pre><code>## 文件内容\n&gt; cat README.md\n## This project is for demoing git\n\n\n## 产生提交\n&gt; git commit -am 'readme'\n[master 0825c0b] readme\n 1 file changed, 1 insertion(+)\n create mode 100644 README.md\n\n\n## 查看提交历史\n&gt; git log --oneline --graph\n* 0825c0b (HEAD -&gt; master) readme\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n...\n\n\n## 查看提交细节\n&gt; git show\ncommit 0825c0b6cd98af11b171b52367209ad6e29e38d1 (HEAD -&gt; master)\nAuthor: Jason Ge &lt;gejun_1978@yahoo.com&gt;\nDate:   Tue Oct 15 12:45:08 2019\n\n    readme\n\ndiff --git a/README.md b/README.md\nnew file mode 100644\nindex 0000000..789cfa9\n--- /dev/null\n+++ b/README.md\n@@ -0,0 +1 @@\n+## This project is for demoing git\n</code></pre><p>这时，A1是master上没有推送到origin/master的唯一提交，也就是说，是提交链上的唯一提交。</p><p>请注意，A1的Commit Message很简单，就是“readme”这6个字符。在把A1发出去做代码质量检查之前，我需要添加Commit Message的细节。</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/0a/d14b3b23385fcb20d9a0013544a7cc0a.png?wh=542*197\" alt=\"\"></p><center><span class=\"reference\">图1 提交链状态第1步</span></center><h3>阶段2：开始开发需求B</h3><p>这时，来了另外一个紧急需求B，要求是添加一个endpoint getRandom。开发时，我不切换分支，直接在master上继续开发。</p><p>首先，我写一个getRandom的实现，并进行简单验证。</p><pre><code>## 用VIM修改\n&gt; vim index.js\n\n\n## 查看工作区中的改动\n&gt; git diff\ndiff --git a/index.js b/index.js\nindex 986fcd8..06695f6 100644\n--- a/index.js\n+++ b/index.js\n@@ -6,6 +6,10 @@ app.get('/timestamp', function (req, res) {\n   res.send('' + Date.now())\n })\n\n+app.get('/getRandom', function (req, res) {\n+  res.send('' + Math.random())\n+})\n+\n app.get('/', function (req, res) {\n   res.send('hello world')\n })\n\n\n## 用命令行工具httpie验证结果\n&gt; http localhost:3000/getRandom\nHTTP/1.1 200 OK\nConnection: keep-alive\nContent-Length: 19\nContent-Type: text/html; charset=utf-8\nDate: Tue, 15 Oct 2019 03:49:15 GMT\nETag: W/&quot;13-U1KCE8QRuz+dioGnmVwMkEWypYI&quot;\nX-Powered-By: Express\n\n0.25407324324864167\n</code></pre><p>为确保代码不丢失，我用git commit -am ‘random’ 命令生成了一个提交B1：</p><pre><code>## 产生提交\n&gt; git commit -am 'random'\n[master 7752df4] random\n 1 file changed, 4 insertions(+)\n\n\n## 查看提交历史\n&gt; git log --oneline --graph\n* 7752df4 (HEAD -&gt; master) random\n* 0825c0b readme\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n...\n\n\n## 查看提交细节\n&gt; git show\ncommit f59a4084e3a2c620bdec49960371f8cc93b86825 (HEAD -&gt; master)\nAuthor: Jason Ge &lt;gejun_1978@yahoo.com&gt;\nDate:   Tue Oct 15 11:55:06 2019\n\n    random\n\ndiff --git a/index.js b/index.js\nindex 986fcd8..06695f6 100644\n--- a/index.js\n+++ b/index.js\n@@ -6,6 +6,10 @@ app.get('/timestamp', function (req, res) {\n   res.send('' + Date.now())\n })\n\n+app.get('/getRandom', function (req, res) {\n+  res.send('' + Math.random())\n+})\n+\n app.get('/', function (req, res) {\n   res.send('hello world')\n })\n</code></pre><p>B1的Commit Message也很简陋，因为当前的关键任务是先把功能运行起来。</p><p>现在，我的提交链上有A1和B1两个提交了。</p><p><img src=\"https://static001.geekbang.org/resource/image/74/94/747ab78ca16aefc1f4a74a904014ae94.png?wh=773*196\" alt=\"\"></p><center><span class=\"reference\">图2 提交链状态第2步</span></center><p>接下来，我需要进行需求B的进一步开发：在README文件中给这个新的endpoint添加说明。</p><pre><code>&gt; git diff\ndiff --git a/README.md b/README.md\nindex 789cfa9..7b2b6af 100644\n--- a/README.md\n+++ b/README.md\n@@ -1 +1,3 @@\n ## This project is for demoing git\n+\n+You can visit endpoint getRandom to get a random real number.\n</code></pre><p>我认为这个改动是B1的一部分，所以我用git commit --amend把它添加到B1中。</p><pre><code>## 添加改动到B1\n&gt; git add README.md\n&gt; git commit --amend\n[master 27c4d40] random\n Date: Tue Oct 15 11:55:06 2019 +0800\n 2 files changed, 6 insertions(+)\n\n\n## 查看提交历史\n&gt; git log --oneline --graph\n* 27c4d40 (HEAD -&gt; master) random\n* 0825c0b readme\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n</code></pre><p>现在，我的提交链上还是A1和B1’两个提交。这里的B1’是为了区别之前的B1，B1仍然存在代码仓中，不过是不再使用了而已。</p><p><img src=\"https://static001.geekbang.org/resource/image/25/37/2581e07273218b464b463cf3243a3c37.png?wh=773*197\" alt=\"\"></p><center><span class=\"reference\">图3 提交链状态第3步</span></center><h3>阶段3：拆分需求B的代码，把B1’提交检查系统</h3><p>这时，我觉得B1’的功能实现部分，也就是index.js的改动部分，可以推送到origin/master了。</p><p>不过，文档部分也就是README.md文件的改动，还不够好，而且功能实现和文档应该分成两个原子性提交。于是，我将B1’拆分为B1’’ 和B2两部分。</p><pre><code>## 将B1'拆分\n&gt; git reset HEAD^\nUnstaged changes after reset:\nM\tREADME.md   ## 这个将是B2的内容\nM\tindex.js    ## 这个将是B1''的内容\n\n&gt; git status\nOn branch master\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use &quot;git push&quot; to publish your local commits)\nChanges not staged for commit:\n  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)\n  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\n\tmodified:   README.md\n\tmodified:   index.js\nno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\n&gt; git add index.js\n&gt; git commit   ## 这里我认真填写B1''的Commit Message\n\n&gt; git add README.md\n&gt; git commit   ## 这里我认真填写B2的Commit Message\n\n\n## 查看提交历史\n* 68d813f (HEAD -&gt; master) [DO NOT PUSH] Add documentation for getRandom endpoint\n* 7d43442 Add getRandom endpoint\n* 0825c0b readme\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n</code></pre><p>现在，提交链上有A1、B1’’、B2三个提交。</p><p>请注意，在这里我把功能实现和文档分为两个原子性提交，只是为了帮助说明我需要把B1’进行原子性拆分而已，在实际工作中，很可能功能实现和文档就应该放在一个提交当中。</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/9d/1abf304f8b1de6fcd4a1487243e4409d.png?wh=994*203\" alt=\"\"></p><center><span class=\"reference\">图4 提交链状态第4步</span></center><p>提交B1’拆开之后，为了把B1’’ 推送到origin/master上去，我需要要把B1’’ 挪到A1的前面。首先，运行git rebase -i origin/master。</p><pre><code>&gt; git rebase -i origin/master\n\n## 下面是弹出的编辑器\npick 0825c0b readme                   ## 这个是A1\npick 7d43442 Add getRandom endpoint   ## 这个是B1''\npick 68d813f [DO NOT PUSH] Add documentation for getRandom endpoint\n\n# Rebase 7b6ea30..68d813f onto 7b6ea30 (3 commands)\n...\n</code></pre><p>然后，我把针对B1’’ 的那一行挪到第一行，保存退出。</p><pre><code>pick 7d43442 Add getRandom endpoint  ## 这个是B1''\npick 0825c0b readme                  ## 这个是A1   \npick 68d813f [DO NOT PUSH] Add documentation for getRandom endpoint\n\n# Rebase 7b6ea30..68d813f onto 7b6ea30 (3 commands)\n...\n</code></pre><p>git rebase -i 命令会显示运行成功，使用git log命令可以看到我成功改变了提交的顺序。</p><pre><code>&gt; git rebase -i origin/master\nSuccessfully rebased and updated refs/heads/master.\n\n&gt; git log --oneline --graph\n* 86126f7 (HEAD -&gt; master) [DO NOT PUSH] Add documentation for getRandom endpoint\n* 7113c16 readme\n* 4d37768 Add getRandom endpoint\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n</code></pre><p>现在，提交链上有B1’’’、A1’、B2’三个提交了。请注意，B2’也是一个新的提交。虽然我只是交换了B1’’ 和A的顺序，但git rebase的操作是重新应用，产生出了三个新提交。</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/a8/2af308dacc801197e5248b49f8cc83a8.png?wh=994*204\" alt=\"\"></p><center><span class=\"reference\">图5 提交链状态第5步</span></center><p>现在，我可以把B1’’’ 发送给质量检查系统了。</p><p>首先，产生一个临时分支temp指向B2’，确保能回到原来的代码；然后，用git reset --hard命令把master和HEAD指向B1’’’。</p><pre><code>&gt; git branch temp\n&gt; git reset --hard 4d37768\nHEAD is now at 4d37768 Add getRandom endpoint\n\n## 检查提交链\n&gt; git log --oneline --graph\n* 4d37768 (HEAD -&gt; master) Add getRandom endpoint\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n...\n</code></pre><p>这时，提交链中只有B1’’’。当然，A1’和B2’仍然存在，只是不在提交链里了而已。</p><p><img src=\"https://static001.geekbang.org/resource/image/71/91/71b4dba396681ffcec08e912edb7b691.png?wh=541*197\" alt=\"\"></p><center><span class=\"reference\">图6 提交链状态第6步</span></center><p>最后，运行命令把B1’’’ 提交到Phabricator上，结束后使用git reset --hard temp命令重新把HEAD指向B2’。</p><pre><code>## 运行arc命令把B'''提交到Phabricator上\n&gt; arc diff\n\n\n## 重新把HEAD指向B2'\n&gt; git reset --hard temp\nHEAD is now at 86126f7 [DO NOT PUSH] Add documentation for getRandom endpoint\n\n\n## 检查提交链\n&gt; git log --oneline --graph\n* 86126f7 (HEAD -&gt; master, temp, single-branch-step-5) [DO NOT PUSH] Add documentation for getRandom endpoint\n* 7113c16 readme\n* 4d37768 Add getRandom endpoint\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n</code></pre><p>这时，提交链又恢复成为B1’’’、A1’、B2’三个提交了。</p><p><img src=\"https://static001.geekbang.org/resource/image/91/c2/912e4a00c2d08b9d82fee818d780c0c2.png?wh=994*203\" alt=\"\"></p><center><span class=\"reference\">图7 提交链状态第7步</span></center><h3>阶段4：继续开发B2，同时得到B1的反馈，修改B1</h3><p>把B1’’’ 发送到质量检查中心之后，我回到B2’ 继续工作，也就是在README文件中继续添加关于getRandom的文档。我正在开发的过程中，得到B1’’’ 的反馈，要求我对其进行修改。于是，我首先保存当前对B2’的修改，用git commit --amend把它添加到B2’中。</p><pre><code>## 查看工作区中的修改\n&gt; git diff\ndiff --git a/README.md b/README.md\nindex 8a60943..1f06f52 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,3 +1,4 @@\n ## This project is for demoing git\n\n You can visit endpoint getRandom to get a random real number.\n+The end endpoint is `/getRandom`.\n\n\n## 把工作区中的修改添加到B2'中\n&gt; git add README.md\n&gt; git commit --amend\n[master 7b4269c] [DO NOT PUSH] Add documentation for getRandom endpoint\n Date: Tue Oct 15 17:17:18 2019 +0800\n 1 file changed, 3 insertions(+)\n* 7b4269c (HEAD -&gt; master) [DO NOT PUSH] Add documentation for getRandom endpoint\n* 7113c16 readme\n* 4d37768 Add getRandom endpoint\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n...\n</code></pre><p>这时，提交链成为B1’’’、A1’、B2’’ 三个提交了。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/c0/de37ce76ba36c0c8ec3075a67e3a8ac0.png?wh=993*204\" alt=\"\"></p><center><span class=\"reference\">图8 提交链状态第8步</span></center><p>接下来，我使用<a href=\"https://time.geekbang.org/column/article/152715\">第25篇文章</a>中介绍的基础操作对B1’’’ 进行修改。</p><p>首先，在git rebase -i origin/master的文本输入框中，将pick B1’’’ 那一行修改为edit B1’’’，然后保存退出，git rebase 暂停在B1’’’ 处：</p><pre><code>&gt; git rebase -i origin/master\n\n\n## 以下是弹出编辑器中的文本内容\nedit 4d37768 Add getRandom endpoint   ## &lt;-- 这一行开头原本是pick\npick 7113c16 readme\npick 7b4269c [DO NOT PUSH] Add documentation for getRandom endpoint\n\n\n## 以下是保存退出后 git rebase -i origin/master 的输出\nStopped at 4d37768...  Add getRandom endpoint\nYou can amend the commit now, with\n  git commit --amend\nOnce you are satisfied with your changes, run\n  git rebase --continue\n\n\n## 查看提交历史\n&gt; git log --oneline --graph\n* 4d37768 (HEAD) Add getRandom endpoint\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n</code></pre><p>这时，提交链上只有B1’’’ 一个提交。</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/66/6f62dbf5e85b3f1705d4a6475ebac966.png?wh=542*146\" alt=\"\"></p><center><span class=\"reference\">图9 提交链状态第9步</span></center><p>然后，我对index.js进行修改，并添加到B1’’’ 中，成为B1’’’’。完成之后，再次把B1’’’’ 发送到代码质量检查系统。</p><pre><code>## 根据同事反馈，修改index.js\n&gt; vim index.js\n&gt; git add index.js\n\n\n## 查看修改\n&gt; git diff --cached\ndiff --git a/index.js b/index.js\nindex 06695f6..cc92a42 100644\n--- a/index.js\n+++ b/index.js\n@@ -7,7 +7,7 @@ app.get('/timestamp', function (req, res) {\n })\n\n app.get('/getRandom', function (req, res) {\n-  res.send('' + Math.random())\n+  res.send('The random number is:' + Math.random())\n })\n\n app.get('/', function (req, res) {\n\n\n## 把改动添加到B1'''中。\n&gt; git commit --amend\n[detached HEAD 29c8249] Add getRandom endpoint\n Date: Tue Oct 15 17:16:12 2019 +0800\n 1 file changed, 4 insertions(+)\n19:17:28 (master|REBASE-i) jasonge@Juns-MacBook-Pro-2.local:~/jksj-repo/git-atomic-demo\n&gt; git show\ncommit 29c82490256459539c4a1f79f04823044f382d2b (HEAD)\nAuthor: Jason Ge &lt;gejun_1978@yahoo.com&gt;\nDate:   Tue Oct 15 17:16:12 2019\n    Add getRandom endpoint\n\n    Summary:\n    As title.\n\n    Test:\n    Verified it on localhost:3000/getRandom\n\ndiff --git a/index.js b/index.js\nindex 986fcd8..cc92a42 100644\n--- a/index.js\n+++ b/index.js\n@@ -6,6 +6,10 @@ app.get('/timestamp', function (req, res) {\n   res.send('' + Date.now())\n })\n\n+app.get('/getRandom', function (req, res) {\n+  res.send('The random number is:' + Math.random())\n+})\n+\n app.get('/', function (req, res) {\n   res.send('hello world')\n })\n\n\n## 查看提交链\n&gt; git log --oneline --graph\n* 29c8249 (HEAD) Add getRandom endpoint\n* 7b6ea30 (origin/master, git-add-p) Add a new endpoint to return timestamp\n\n\n## 将B1''''发送到代码审查系统\n&gt; arc diff\n</code></pre><p>这时，提交链只有B1’’’’ 一个提交。<br>\n<img src=\"https://static001.geekbang.org/resource/image/a1/0e/a16c37876defb48c59977c23bb86960e.png?wh=542*145\" alt=\"\"></p><center><span class=\"reference\">图10 提交链状态第10步</span></center><p>最后，运行git rebase --continue完成整个git rebase -i操作。</p><pre><code>&gt; git rebase --continue\nSuccessfully rebased and updated refs/heads/master.\n\n\n## 查看提交历史\n&gt; git log --oneline --graph\n* bc0900d (HEAD -&gt; master) [DO NOT PUSH] Add documentation for getRandom endpoint\n* 1562cc7 readme\n* 29c8249 Add getRandom endpoint\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n...\n</code></pre><p>这时，提交链包含B1’’’’、A1’’、B2’’’ 三个提交。<br>\n<img src=\"https://static001.geekbang.org/resource/image/a7/fc/a72eba2775d8ebbbe0f9808cc17917fc.png?wh=993*203\" alt=\"\"></p><center><span class=\"reference\">图11 提交链状态第11步</span></center><h3>阶段5：继续开发A1，并发出代码审查</h3><p>这时，我认为A1’’ 比B2’’’ 更为紧急重要，于是决定先完成A1’’ 的工作并发送审查，同样也是使用git rebase -i。</p><pre><code>&gt; git rebase -i HEAD^^  ## 两个^^表示从当前HEAD前面两个提交的地方rebase\n\n\n## git rebase 弹出编辑窗口\nedit 1562cc7 readme  &lt;-- 这一行开头原来是pick。这个是A1''\npick bc0900d [DO NOT PUSH] Add documentation for getRandom endpoint\n\n\n## 保存退出后git rebase -i HEAD^^ 的结果\nStopped at 1562cc7...  readme\nYou can amend the commit now, with\n  git commit --amend\nOnce you are satisfied with your changes, run\n  git rebase --continue\n\n\n## 对A1''修改\n&gt; vim README.md\n&gt; git diff\ndiff --git a/README.md b/README.md\nindex 789cfa9..09bcc7d 100644\n--- a/README.md\n+++ b/README.md\n@@ -1 +1 @@\n-## This project is for demoing git\n+# This project is for demoing atomic commit in git\n\n&gt; git add README.md\n&gt; git commit --amend\n\n\n## 下面是git commit弹出编辑器，在里面完善A1''的Commit Message\nAdd README.md file\n\nSummary: we need a README file for the project.\n\nTest: none.\n\n# Please enter the Commit Message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# Date:      Tue Oct 15 12:45:08 2019 +0800\n#\n# interactive rebase in progress; onto 29c8249\n# Last command done (1 command done):\n#    edit 1562cc7 readme\n# Next command to do (1 remaining command):\n#    pick bc0900d [DO NOT PUSH] Add documentation for getRandom endpoint\n# You are currently splitting a commit while rebasing branch 'master' on '29c8249'.\n#\n# Changes to be committed:\n#       new file:   README.md\n#\n\n\n## 保存退出后git commit 输出结果\n[detached HEAD 2c66fe9] Add README.md file\n Date: Tue Oct 15 12:45:08 2019 +0800\n 1 file changed, 1 insertion(+)\n create mode 100644 README.md\n\n\n## 继续执行git rebase -i\n&gt; git rebase --continue\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nerror: could not apply bc0900d... [DO NOT PUSH] Add documentation for getRandom endpoint\nResolve all conflicts manually, mark them as resolved with\n&quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.\nYou can instead skip this commit: run &quot;git rebase --skip&quot;.\nTo abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.\nCould not apply bc0900d... [DO NOT PUSH] Add documentation for getRandom endpoint\n</code></pre><p>这个过程可能会出现冲突，比如在A1’’’ 之上应用B2’’’ 时可能会出现冲突。冲突出现时，你可以使用git log和git status命令查看细节。</p><pre><code>## 查看当前提交链\n&gt; git log --oneline --graph\n* 2c66fe9 (HEAD) Add README.md file\n* 29c8249 Add getRandom endpoint\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n...\n\n\n## 查看冲突细节\n&gt; git status\ninteractive rebase in progress; onto 29c8249\nLast commands done (2 commands done):\n   edit 1562cc7 readme\n   pick bc0900d [DO NOT PUSH] Add documentation for getRandom endpoint\nNo commands remaining.\nYou are currently rebasing branch 'master' on '29c8249'.\n  (fix conflicts and then run &quot;git rebase --continue&quot;)\n  (use &quot;git rebase --skip&quot; to skip this patch)\n  (use &quot;git rebase --abort&quot; to check out the original branch)\n\nUnmerged paths:\n  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\n  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)\n\n\tboth modified:   README.md\n\nno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)  \n\n\n## 用git diff 和git diff --cached查看更多细节\n&gt; git diff\ndiff --cc README.md\nindex 09bcc7d,1f06f52..0000000\n--- a/README.md\n+++ b/README.md\n@@@ -1,1 -1,4 +1,8 @@@\n++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n +# This project is for demoing atomic commit in git\n++=======\n+ ## This project is for demoing git\n+\n+ You can visit endpoint getRandom to get a random real number.\n+ The end endpoint is `/getRandom`.\n++&gt;&gt;&gt;&gt;&gt;&gt;&gt; bc0900d... [DO NOT PUSH] Add documentation for getRandom endpoint\n\n&gt; git diff --cached\n* Unmerged path README.md\n</code></pre><p>解决冲突的具体步骤是：</p><ol>\n<li>手动修改冲突文件；</li>\n<li>使用git add或者git rm把修改添加到暂存区；</li>\n<li>运行git rebase --continue。于是，git rebase会把暂存区的内容生成提交，并继续git-rebase后续步骤。</li>\n</ol><pre><code>&gt; vim README.md\n\n## 这个是初始内容\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n# This project is for demoing atomic commit in git\n=======\n## This project is for demoing git\n\nYou can visit endpoint getRandom to get a random real number.\nThe end endpoint is `/getRandom`.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; bc0900d... [DO NOT PUSH] Add documentation for getRandom endpoint\n\n\n## 这个是修改后内容，并保存退出\n# This project is for demoing atomic commit in git\n\nYou can visit endpoint getRandom to get a random real number.\nThe end endpoint is `/getRandom`.\n\n\n## 添加README.md到暂存区，并使用git status查看状态\n&gt; git add README.md\n19:51:16 (master|REBASE-i) jasonge@Juns-MacBook-Pro-2.local:~/jksj-repo/git-atomic-demo\n\n\n## 使用git status查看状态\n&gt; git status\ninteractive rebase in progress; onto 29c8249\nLast commands done (2 commands done):\n   edit 1562cc7 readme\n   pick bc0900d [DO NOT PUSH] Add documentation for getRandom endpoint\nNo commands remaining.\nYou are currently rebasing branch 'master' on '29c8249'.\n  (all conflicts fixed: run &quot;git rebase --continue&quot;)\n\nChanges to be committed:\n  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\n\n\tmodified:   README.md\n\n\n## 冲突成功解决，继续git rebase -i后续步骤\n&gt; git rebase --continue\n\n\n## git rebase 提示编辑B2''''的Commit Message\n[DO NOT PUSH] Add documentation for getRandom endpoint\n\nSummary:\nAT.\n\nTest:\nNone.\n\n\n## 保存退出之后git rebase --continue的输出\n[detached HEAD ae38d9e] [DO NOT PUSH] Add documentation for getRandom endpoint\n 1 file changed, 3 insertions(+)\nSuccessfully rebased and updated refs/heads/master.\n\n\n## 检查提交链\n* ae38d9e (HEAD -&gt; master) [DO NOT PUSH] Add documentation for getRandom endpoint\n* 2c66fe9 Add README.md file\n* 29c8249 Add getRandom endpoint\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n</code></pre><p>这时，提交链上有B1’’’’、A1’’’、B2’’’’ 三个提交。</p><p><img src=\"https://static001.geekbang.org/resource/image/03/bb/034757450750df327f5a5d4f94b728bb.png?wh=993*204\" alt=\"\"></p><center><span class=\"reference\">图12 提交链状态第12步</span></center><h3>阶段6：B1检查通过，推送到远程代码仓共享分支</h3><p>这时，我从Phabricator得到通知，B1’’’’ 检查通过了，可以将其推送到oringin/master去了！</p><p>首先，使用git fetch和git rebase origin/master命令，确保本地有远端主代码仓的最新代码。</p><pre><code>&gt; git fetch\n&gt; git rebase origin/master\nCurrent branch master is up to date.\n</code></pre><p>然后，使用git rebase -i，在B1’’’’ 处暂停：</p><pre><code>&gt; git rebase -i origin/master\n\n## 修改第一行开头：pick -&gt; edit\nedit 29c8249 Add getRandom endpoint\npick 2c66fe9 Add README.md file\npick ae38d9e [DO NOT PUSH] Add documentation for getRandom endpoint\n\n\n## 保存退出结果\nStopped at 29c8249...  Add getRandom endpoint\nYou can amend the commit now, with\n  git commit --amend\nOnce you are satisfied with your changes, run\n  git rebase --continue\n\n\n## 查看提交链\n* 29c8249 (HEAD) Add getRandom endpoint\n* 7b6ea30 (origin/master) Add a new endpoint to return timestamp\n...\n</code></pre><p>这时，origin/master和HEAD之间只有B1’’’’ 一个提交。<br>\n<img src=\"https://static001.geekbang.org/resource/image/0d/66/0db95ca7cd433baaffe5771636cf7166.png?wh=541*145\" alt=\"\"></p><center><span class=\"reference\">图13 提交链状态第13步</span></center><p>我终于可以运行git push origin HEAD:master，去推送B1’’’’ 了。</p><p>注意，当前HEAD不在任何分支上，master分支仍然指向B2’’’’，所以push命令需要明确指向远端代码仓origin和远端分支maser，以及本地要推送的分支HEAD。推送完成之后，再运行git rebase --continue完成rebase操作，把master分支重新指向B2’’’’。</p><pre><code>## 直接推送。因为当前HEAD不在任何分支上，推送失败。\n&gt; git push\nfatal: You are not currently on a branch.\nTo push the history leading to the current (detached HEAD)\nstate now, use\n    git push origin HEAD:&lt;name-of-remote-branch&gt;\n\n\n## 再次推送，指定远端代码仓origin和远端分支maser，以及本地要推送的分支HEAD。推送成功\n&gt; git push origin HEAD:master\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 392 bytes | 392.00 KiB/s, done.\nTotal 3 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), completed with 2 local objects.\nTo github.com:jungejason/git-atomic-demo.git\n   7b6ea30..29c8249  HEAD -&gt; master\n\n&gt; git rebase --continue\nSuccessfully rebased and updated refs/heads/master.\n\n## 查看提交链\n&gt; git log --oneline --graph\n* ae38d9e (HEAD -&gt; master) [DO NOT PUSH] Add documentation for getRandom endpoint\n* 2c66fe9 Add README.md file\n* 29c8249 (origin/master) Add getRandom endpoint\n* 7b6ea30 Add a new endpoint to return timestamp\n</code></pre><p>这时，origin/master已经指向了B1’’’’，提交链现在只剩下了A1’’’ 和B2’’’’。<br>\n<img src=\"https://static001.geekbang.org/resource/image/5a/b3/5a1a47e2750cdcecfc764bf2d6deeab3.png?wh=772*197\" alt=\"\"></p><center><span class=\"reference\">图14 提交链状态第14步</span></center><p>至此，我们完成了在一个分支上同时开发两个需求A和B、把提交拆分为原子性提交，并尽早把完成的提交推送到远端代码仓共享分支的全过程！</p><p>这个过程看起来比较复杂，但实际上就是根据上面列举的“单分支工作流”的4个步骤执行而已。</p><p>接下来，我们再看看使用多个分支，每个分支支持一个需求的开发方式。</p><h2>用本地多分支实现多个需求的提交的原子性</h2><p>在这种开发工作流下，每个需求都拥有独享的分支。同样的，跟单分支实现提交原子性的方式一样，这些分支都是本地分支，并不是主代码仓上的功能分支。</p><p>需要注意的是，在下面的分析中，我只描述每个分支上只有一个提交的简单形式，而至于每个分支上使用多个提交的形式，操作流程与单分支提交链中的描述一样，就不再重复表述了。</p><h3>多分支工作流具体步骤</h3><p>分支工作流的具体步骤，大致包括以下4步：</p><ol>\n<li>切换到某一个分支对某需求进行开发，产生提交。</li>\n<li>提交完成后，将其发送到代码审查系统Phabricator上进行质量检查。在等待质量检查结果的同时，切换到其他分支，继续其他需求的开发。</li>\n<li>如果第2步的提交没有通过质量检查，则切换回这个提交所在分支，对提交进行修改，修改之后返回第2步。</li>\n<li>如果第2步的提交通过了质量检查，则切换回这个提交所在分支，把这个提交推送到远端代码仓中，然回到第1步进行其他需求的开发。</li>\n</ol><p>接下来，我们看一个开发两个需求C和D的场景吧。</p><p>在这个场景中，我首先开发需求C，并把它的提交C1发送到质量检查中心；然后开始开发需求D，等到C1通过质量检查之后，我立即将其推送到远程共享代码仓中去。</p><h3>阶段1：开发需求C</h3><p>需求C是一个简单的重构，把index.js中所有的var都改成const。</p><p>首先，使用git checkout -b feature-c origin/master产生本地分支feature-c，并跟踪origin/master。</p><pre><code>&gt; git checkout -b feature-c origin/master\nBranch 'feature-c' set up to track remote branch 'master' from 'origin'.\nSwitched to a new branch 'feature-c'\n</code></pre><p>然后，进行C的开发，产生提交C1，并把提交发送到Phabricator进行检查。</p><pre><code>## 修改代码，产生提交\n&gt; vim index.js\n&gt; git diff\ndiff --git a/index.js b/index.js\nindex cc92a42..e5908f0 100644\n--- a/index.js\n+++ b/index.js\n@@ -1,6 +1,6 @@\n-var port = 3000\n-var express = require('express')\n-var app = express()\n+const port = 3000\n+const express = require('express')\n+const app = express()\n\n app.get('/timestamp', function (req, res) {\n   res.send('' + Date.now())\n20:54:10 (feature-c) jasonge@Juns-MacBook-Pro-2.local:~/jksj-repo/git-atomic-demo\n\n&gt; git add .\n20:54:16 (feature-c) jasonge@Juns-MacBook-Pro-2.local:~/jksj-repo/git-atomic-demo\n\n&gt; git commit\n\n\n## 填写详细Commit Message\nRefactor to use const instead of var\n\nSummary: const provides more info about a variable. Use it when possible.\n\nTest: ran `node index.js` and verifeid it by visiting localhost:3000.\nEndpoints still work.\n\n\n## 以下是Commit Message保存后退出，git commit的输出结果\n[feature-c 2122faa] Refactor to use const instead of var\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n\n## 使用Phabricator的客户端，arc，把当前提交发送给Phabricator进行检查\n&gt; arc diff\n\n\n## 查看提交链\n* 2122faa (HEAD -&gt; feature-c, multi-branch-step-1) Refactor to use const instead of var\n* 5055c14 (origin/master) Add documentation for getRandom endpoint\n...\n</code></pre><p>这时，origin/master之上只有feature-c一个分支，上面有C1一个提交。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/b3/6953532b8a3600bbc1753dd274faafb3.png?wh=542*197\" alt=\"\"></p><center><span class=\"reference\">图15 多分支提交状态第1步</span></center><h3>阶段2：开发需求D</h3><p>C1发出去进行质量检查后，我开始开发需求D。需求D是在README.md中，添加所有endpoint的文档。</p><p>首先，也是使用git checkout -b feature-d origin/master产生一个分支feature-d并跟踪origin/master。</p><pre><code>&gt; git checkout -b feature-d origin/master\nBranch 'feature-d' set up to track remote branch 'master' from 'origin'.\nSwitched to a new branch 'feature-d'\nYour branch is up to date with 'origin/master'.\n</code></pre><p>然后，开始开发D，产生提交D1，并把提交发送到Phabricator进行检查。</p><pre><code>## 进行修改\n&gt; vim README.md\n\n\n## 添加，产生修改，过程中有输入Commit Message\n&gt; git add README.md\n&gt; git commit\n\n\n## 查看修改\n&gt; git show\ncommit 97047a33071420dce3b95b89f6d516e5c5b59ec9 (HEAD -&gt; feature-d, multi-branch-step-2)\nAuthor: Jason Ge &lt;gejun_1978@yahoo.com&gt;\nDate:   Tue Oct 15 21:12:54 2019\n\n    Add spec for all endpoints\n\n    Summary: We are missing the spec for the endpoints. Adding them.\n\n    Test: none\n\ndiff --git a/README.md b/README.md\nindex 983cb1e..cbefdc3 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,4 +1,8 @@\n # This project is for demoing atomic commit in git\n\n-You can visit endpoint getRandom to get a random real number.\n-The end endpoint is `/getRandom`.\n+## endpoints\n+\n+* /getRandom: get a random real number.\n+* /timestamp: get the current timestamp.\n+* /: get a &quot;hello world&quot; message.\n\n\n## 将提交发送到Phabricator进行审查\n&gt; arc diff\n\n\n## 查看提交历史\n&gt; git log --oneline --graph feature-c feature-d\n* 97047a3 (HEAD -&gt; feature-d Add spec for all endpoints\n| * 2122faa (feature-c) Refactor to use const instead of var\n|/\n* 5055c14 (origin/master) Add documentation for getRandom endpoint\n</code></pre><p>这时，origin/master之上有feature-c和feature-d两个分支，分别有C1和D1两个提交。</p><p><img src=\"https://static001.geekbang.org/resource/image/07/cc/072e1088fd35c6afa757e01ee8819acc.png?wh=563*394\" alt=\"\"></p><center><span class=\"reference\">图16 多分支提交状态第2步</span></center><h3>阶段3：推送提交C1到远端代码仓共享分支</h3><p>这时，我收到Phabricator的通知，C1通过了检查，可以推送了！首先，我使用git checkout把分支切换回分支feature-c：</p><pre><code>&gt; git checkout feature-c\nSwitched to branch 'feature-c'\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use &quot;git push&quot; to publish your local commits)\n</code></pre><p>然后，运行git fetch; git rebase origin/master，确保我的分支上有最新的远程共享分支代码：</p><pre><code>&gt; git fetch\n&gt; git rebase origin/master\nCurrent branch feature-c is up to date.\n</code></pre><p>接下来，运行git push推送C1：</p><pre><code>&gt; git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 460 bytes | 460.00 KiB/s, done.\nTotal 3 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), completed with 2 local objects.\nTo github.com:jungejason/git-atomic-demo.git\n   5055c14..2122faa  feature-c -&gt; master\n\n\n## 查看提交状态\n* 97047a3 (feature-d) Add spec for all endpoints\n| * 2122faa (HEAD -&gt; feature-c, origin/master, multi-branch-step-1) Refactor to use const instead of var\n|/\n* 5055c14 Add documentation for getRandom endpoint\n...\n</code></pre><p>这时，origin/master指向C1。分支feature-d从origin/master的父提交上分叉，上面只有D1一个提交。</p><p><img src=\"https://static001.geekbang.org/resource/image/07/24/0794c35efb4d17fc4a2bff67d9e83524.png?wh=563*446\" alt=\"\"></p><center><span class=\"reference\">图17 多分支提交状态第3步</span></center><h3>阶段4：继续开发D1</h3><p>完成C1的推送后，我继续开发D1。首先，用git checkout命令切换回分支feature-d；然后，运行git fetch和git rebase，确保当前代码D1是包含了远程代码仓最新的代码，以减少将来合并代码产生冲突的可能性。</p><pre><code>&gt; git checkout feature-d\nSwitched to branch 'feature-d'\nYour branch and 'origin/master' have diverged,\nand have 1 and 1 different commits each, respectively.\n  (use &quot;git pull&quot; to merge the remote branch into yours)\n21:38:22 (feature-d) jasonge@Juns-MacBook-Pro-2.local:~/jksj-repo/git-atomic-demo\n\n&gt; git fetch\n&gt; git rebase origin/master\nFirst, rewinding head to replay your work on top of it...\nApplying: Add spec for all endpoints\n\n\n## 查看提交状态\n&gt; git log --oneline --graph feature-c feature-d\n* a8f92f5 (HEAD -&gt; feature-d) Add spec for all endpoints\n* 2122faa (origin/master,) Refactor to use const instead of var\n...\n</code></pre><p>这时，当前分支为feature-d，上面有唯一一个提交D1’，而且D1’已经变基到了origin/master上。</p><p>需要注意的是，因为使用的是git rebase，没有使用git merge产生和并提交，所以提交历史是线性的。我在<a href=\"https://time.geekbang.org/column/article/132499\">第7篇文章</a>中提到过，线性的提交历史对Facebook的CI自动化意义重大。</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/5b/6af5e952f4846983e05a04b44a0db65b.png?wh=890*230\" alt=\"\"></p><center><span class=\"reference\">图18 多分支提交状态第4步</span></center><p>至此，我们完成了在两个分支上同时开发C和D两个需求，并尽早把完成了的提交推送到远端代码仓中的全过程。</p><p>虽然在这个例子中，我简化了这两个需求开发的情况，每个需求只有一个提交并且一次就通过了质量检查，但结合在一个分支上完成所有开发需求的流程，相信你也可以推导出每个需求有多个提交，以及质量检查没有通过时的处理方法了。如果这中间还有什么问题的话，那就直接留言给我吧。</p><p>接下来，我与你对比下这两种工作流。</p><h2>两种工作流的对比</h2><p>如果我们要对比这两工作流的话，那就是各有利弊。</p><p>单分支开发方式的好处是，不需要切换分支，可以顺手解决一些缺陷修复，但缺点是rebase操作多，产生冲突的可能性大。</p><p>而多分支方式的好处是，一个分支只对应一个需求，相对比较简单、清晰，rebase操作较少，产生冲突的可能性小，但缺点是不如单分支开发方式灵活。</p><p>无论是采用哪一种工作流，都有几个需要注意的地方：</p><ul>\n<li>不要同时开发太多的需求，否则分支管理花销太大；</li>\n<li>有了可以推送的提交就尽快推送到远端代码仓，从而减少在本地的管理成本，以及推送时产生冲突的可能性；</li>\n<li>经常使用git fetch和git rebase，确保自己的代码在本地持续与远程共享分支的代码在做集成，降低推送时冲突的可能性</li>\n</ul><p>最后，我想说的是，如果你对Git不是特别熟悉，我推荐你先尝试第二种工作流。这种情况rebase操作较少，相对容易上手一些。</p><h2>小结</h2><p>今天，我与你详细讲述了，在Facebook开发人员借助Git的强大功能，实现代码提交的原子性的两种工作流。</p><p>第一种工作流是，在一个单独的分支上进行多个需求的开发。总结来讲，具体的工作方法是：把每一个需求的提交都拆分为比较小的原子提交，并使用git rebase -i的功能，把可以进行质量检查的提交，放到提交链的最底部，也就是最接近origin/master的地方，然后发送到代码检查系统进行检查，之后继续在提交链的其他提交处工作。如果提交没有通过检查，就对它进行修改再提交检查；如果检查通过，就马上把它推送到远端代码仓的共享分支去。在等待代码检察时，继续在提交链的其他提交处工作。</p><p>第二种工作流是，使用多个分支来开发多个需求，每个分支对应一个需求。与单分支开发流程类似，我们尽快把当前可以进行代码检查的提交，放到离origin/master最近的地方；然后在代码审查时，继续开发其他提交。与单分支开发流程不同的是，切换工作任务时，需要切换分支。</p><p>这两种工作流，无论哪一种都能大大促进代码提交的原子性，从而同时提高个人及团队的研发效能。</p><p>我把今天的案例放到了GitHub上的<a href=\"https://github.com/jungejason/git-atomic-demo\">git-atomic-demo</a>代码仓里，并标注出了各个提交状态产生的分支。比如，single-branch-step-14就是单分支流程中的第14个状态，multi-branch-step-4就是多分支流程中的第4个状态。</p><h2>思考题</h2><ol>\n<li>在对提交链的非当前提交，比如HEAD^，进行修改时，除了使用git rebase -i，在它暂停的时候进行修改，你还其他办法吗？你觉得这种方法的利弊是什么？</li>\n<li>Git和文字编排系统LaTex有一个有趣的共同点，你知道是什么吗？</li>\n</ol><p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎你把这篇文章分享给更多的朋友一起阅读。我们下期再见！</p><p></p>","neighbors":{"left":{"article_title":"25 | 玩转Git：五种提高代码提交原子性的基本操作","id":152715},"right":{"article_title":"27 | 命令行：不只是酷，更重要的是能提高个人效能","id":155538}},"comments":[{"had_liked":false,"id":143842,"user_name":"Johnson","can_delete":false,"product_type":"c1","uid":1225037,"ip_address":"","ucode":"55B582953E49F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/b1/4d/10c75b34.jpg","comment_is_top":false,"comment_ctime":1571798481,"is_pvip":false,"replies":[{"id":"55666","content":"&gt;第二种为主，然后在某个branch内部结合第一种的情况比较容易驾驭<br><br>的确是这样。第1种操作的确是要求比较高。而且如果有比较多的提交的话，rebase的overhead会比较大。所以单独的分支上不推荐，产生太多的提交。<br><br>&gt; 很头疼的问题是很多老同事没有深入学习git的主动性和激情<br>如果他们能够意识到git的强大能够帮助自己提高研发效率的话，可能就会更愿意投入一些。能不能给他们搞点集体培训什么的？对团队效能提升帮助应该不错<br><br>","user_name":"作者回复","comment_id":143842,"uid":"1030244","ip_address":"","utype":1,"ctime":1571909733,"user_name_real":"葛俊 Jason"}],"discussion_count":3,"race_medal":0,"score":"18751667665","product_id":100034501,"comment_content":"第一种太烧脑了，对开发人员的git技能要求太高了，大部分的开发人员都不能正确驾驭，感觉工作中更多的是以第二种为主，然后在某个branch内部结合第一种的情况比较容易驾驭。很头疼的问题是很多老同事没有深入学习git的主动性和激情，稍微复杂点儿的操作就让别人帮忙操作。","like_count":4,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471722,"discussion_content":"&amp;gt;第二种为主，然后在某个branch内部结合第一种的情况比较容易驾驭\n\n的确是这样。第1种操作的确是要求比较高。而且如果有比较多的提交的话，rebase的overhead会比较大。所以单独的分支上不推荐，产生太多的提交。\n\n&amp;gt; 很头疼的问题是很多老同事没有深入学习git的主动性和激情\n如果他们能够意识到git的强大能够帮助自己提高研发效率的话，可能就会更愿意投入一些。能不能给他们搞点集体培训什么的？对团队效能提升帮助应该不错\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571909733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2578516,"avatar":"https://static001.geekbang.org/account/avatar/00/27/58/54/d3344e90.jpg","nickname":"浇了汁鸡","note":"","ucode":"22F58ACB44CB36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534387,"discussion_content":"内部培训是一定要的，不要指望所有人都有深入学习git的主动性和激情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638177816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225037,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b1/4d/10c75b34.jpg","nickname":"Johnson","note":"","ucode":"55B582953E49F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39857,"discussion_content":"多谢详细的回答，赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572003328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146971,"user_name":"于小咸","can_delete":false,"product_type":"c1","uid":1640946,"ip_address":"","ucode":"833D5E92016430","user_header":"https://static001.geekbang.org/account/avatar/00/19/09/f2/6ed195f4.jpg","comment_is_top":false,"comment_ctime":1572747445,"is_pvip":false,"replies":[{"id":"57063","content":"工程上，主要是解耦和增量开发。解耦好理解，把功能进行拆分。而增量开发这个一般大家提的不多。主要是在实现功能的时候，考虑怎么样实现最小子功能，即时这个子功能不能暴露给用户。我以后抽空详细写一下，通过代码的实际例子来解释应该更清楚。","user_name":"作者回复","comment_id":146971,"uid":"1030244","ip_address":"","utype":1,"ctime":1572947933,"user_name_real":"葛俊 Jason"}],"discussion_count":1,"race_medal":0,"score":"10162682037","product_id":100034501,"comment_content":"葛老师，请问提交代码的原子性，除了提高git技巧外，在工程上有什么需要注意的点吗？比如软件架构，设计模式。这方面应该随着语言和项目的不同会有较大的差异，有没有什么通用的原则？","like_count":2,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473079,"discussion_content":"工程上，主要是解耦和增量开发。解耦好理解，把功能进行拆分。而增量开发这个一般大家提的不多。主要是在实现功能的时候，考虑怎么样实现最小子功能，即时这个子功能不能暴露给用户。我以后抽空详细写一下，通过代码的实际例子来解释应该更清楚。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572947933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144116,"user_name":"Weining Cao","can_delete":false,"product_type":"c1","uid":1026955,"ip_address":"","ucode":"6E3DB699A41518","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/8b/fdb853c4.jpg","comment_is_top":false,"comment_ctime":1571844634,"is_pvip":false,"replies":[{"id":"55664","content":"http:&#47;&#47;onlywei.github.io&#47;explain-git-with-d3&#47;#rebase<br><br>交互式的界面学rebase。推荐看看 ：）","user_name":"作者回复","comment_id":144116,"uid":"1030244","ip_address":"","utype":1,"ctime":1571908506,"user_name_real":"葛俊 Jason"}],"discussion_count":1,"race_medal":0,"score":"10161779226","product_id":100034501,"comment_content":"从来不用rebase, 一直用merge，看来要好好学习下rebase了","like_count":2,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471818,"discussion_content":"http://onlywei.github.io/explain-git-with-d3/#rebase\n\n交互式的界面学rebase。推荐看看 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571908506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144092,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1571842530,"is_pvip":false,"replies":[{"id":"55665","content":"1-----<br>&gt; 但有个比较纠结的是...<br>我一般是使用为rebase或者cherry-pick，把这些分支上的都放到合并到一个分支上，不使用merge --no-ff命令。<br><br>至于提交的粒度，就要考虑原子性了。尽量是单个提交只完成单个需求。当然，有些时候如果bug fix很小，也可以选择把多个bug fix合并成一个提交。<br><br>2-----<br>&gt; 1。先备份当前分支，比如git branch temp<br>&gt; 2。git reset —hard HEAD^<br>&gt; 3。修改并git commit —amend —no-edit<br>&gt; 4。git cherry-pick 后面的commit 😄<br>&gt; 或者git checkout temp ；git rebase xxx 刚才修改后的commit （不知道可不可行）<br><br>这两种办法都可以，都很好！<br><br>还有第三个办法，我一般是把提交交换顺序，把要修改的提交放到HEAD处修改。<br><br>另外，我还第一次见到--no-edit。我以前都是用 commit --amend -a -C HEAD来完成类似功能 ：）","user_name":"作者回复","comment_id":144092,"uid":"1030244","ip_address":"","utype":1,"ctime":1571909469,"user_name_real":"葛俊 Jason"}],"discussion_count":2,"race_medal":0,"score":"10161777122","product_id":100034501,"comment_content":"学习了，这两种方式我都会，也经常用。<br>我比较喜欢线性的提交历史，不喜欢merge。<br><br>但有个比较纠结的是。<br>比如采用第二种方式：<br>单独开发某个功能，也是采用小步走的方式，这样一个功能分支开发完后，可能有很多小的commit。<br>如果这些commit都线性的推到远程，感觉也不好。<br>目前只能先自己用rebase合并一些分支，然后再推。<br><br>如果是使用git merge —no-ff的方式，这些小commit就可以保留，在历史中可以看到完整的开发过程。<br>但是这样分支看上去就临时分叉了。<br>不知道老师推荐用哪种方法。<br><br>课后思考题一<br>我能想到的笨办法：<br>1。先备份当前分支，比如git branch temp<br>2。git reset —hard HEAD^<br>3。修改并git commit —amend —no-edit<br>4。git cherry-pick 后面的commit 😄<br>或者git checkout temp ；git rebase xxx 刚才修改后的commit （不知道可不可行）","like_count":2,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471810,"discussion_content":"1-----\n&amp;gt; 但有个比较纠结的是...\n我一般是使用为rebase或者cherry-pick，把这些分支上的都放到合并到一个分支上，不使用merge --no-ff命令。\n\n至于提交的粒度，就要考虑原子性了。尽量是单个提交只完成单个需求。当然，有些时候如果bug fix很小，也可以选择把多个bug fix合并成一个提交。\n\n2-----\n&amp;gt; 1。先备份当前分支，比如git branch temp\n&amp;gt; 2。git reset —hard HEAD^\n&amp;gt; 3。修改并git commit —amend —no-edit\n&amp;gt; 4。git cherry-pick 后面的commit 😄\n&amp;gt; 或者git checkout temp ；git rebase xxx 刚才修改后的commit （不知道可不可行）\n\n这两种办法都可以，都很好！\n\n还有第三个办法，我一般是把提交交换顺序，把要修改的提交放到HEAD处修改。\n\n另外，我还第一次见到--no-edit。我以前都是用 commit --amend -a -C HEAD来完成类似功能 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571909469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980442,"avatar":"","nickname":"nate_luo","note":"","ucode":"2A2E880126E9E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282552,"discussion_content":"在学习葛老师的这门课之前，我一直只会有新建分支加cherry-pick 的方式来处理思考题一。另外我也不喜欢一个功拆成多个提交，除非一个功能涉及多人开发，不得不这么做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592014784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323840,"user_name":"浇了汁鸡","can_delete":false,"product_type":"c1","uid":2578516,"ip_address":"","ucode":"22F58ACB44CB36","user_header":"https://static001.geekbang.org/account/avatar/00/27/58/54/d3344e90.jpg","comment_is_top":false,"comment_ctime":1638178225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638178225","product_id":100034501,"comment_content":"还有一种合并方式叫做&#39;半线性历史记录&#39;，(https:&#47;&#47;stackoverflow.com&#47;questions&#47;59714347&#47;semi-linear-merge)，先把特性分支基于master做rebase，再merge --no-ff，既可以看到每次合并引入点，又能近似拥有线性历史的定位问题的便捷性","like_count":0},{"had_liked":false,"id":288906,"user_name":"巫山老妖","can_delete":false,"product_type":"c1","uid":1056037,"ip_address":"","ucode":"B35E2CF1B3B04E","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/25/c4cc1e9f.jpg","comment_is_top":false,"comment_ctime":1618757019,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1618757019","product_id":100034501,"comment_content":"第一种虽然能够不切换分支完成原子性提交，但感觉复杂性也变高了，要求所有人都能掌握还是比较困难，目前我们团队还是以第二种为主，不过有些同学还是习惯用merge来合并分支","like_count":0}]}