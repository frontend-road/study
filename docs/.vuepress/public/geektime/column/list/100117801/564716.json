{"id":564716,"title":"19｜RISC-V指令精讲（四）：跳转指令实现与调试","content":"<p>你好，我是LMOS。</p><p>前面我们学习了无条件跳转指令，但是在一些代码实现里，我们必须根据条件的判断状态进行跳转。比如高级语言中的if-else 语句，这是一个典型程序流程控制语句，它能根据条件状态执行不同的代码。这种语句落到指令集层，就需要有根据条件状态进行跳转的指令来支持，这类指令我们称为有条件跳转指令。</p><p>这节课，我们就来学习这些有条件跳转指令。在RISC-V指令集中，一共有6条有条件跳转指令，分别是beq、bne、blt、bltu、bge、bgeu。</p><p>这节课的配套代码，你可以从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson18~19\">这里</a>下载。</p><h2>比较数据是否相等：beq和bne指令</h2><p>我们首先来看看条件相等跳转和条件不等跳转指令，即beq指令和bne指令，它们的汇编代码书写形式如下所示：</p><pre><code class=\"language-plain\">beq rs1，rs2，imm\n#beq 条件相等跳转指令\n#rs1 源寄存器1\n#rs2 源寄存器2\n#imm 立即数\nbne rs1，rs2，imm\n#bne 条件不等跳转指令\n#rs1 源寄存器1\n#rs2 源寄存器2\n#imm 立即数\n</code></pre><p>上述代码中，rs1、rs2可以是任何通用寄存器，imm是立即数（也可称为偏移量），占用13位二进制编码。请注意，<strong>beq指令和bne指令没有目标寄存器，就不会回写结果。</strong></p><p>我们用伪代码描述一下beq指令和bne指令完成的操作。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">//beq\nif(rs1 == rs2) pc = pc + 符号扩展（imm &lt;&lt; 1）\n//bne\nif(rs1 != rs2) pc = pc + 符号扩展（imm &lt;&lt; 1）\n</code></pre><p>你可以这样理解这两个指令。在rs1、rs2寄存器的数据相等时，beq指令就会跳转到标号为imm的地方运行。而rs1、rs2寄存器的数据不相等时，bne指令就会跳转到imm标号处运行。</p><p>下面我们一起写代码来验证。在工程目录下，我们需要建立一个beq.S文件，在文件里用汇编写上beq_ins、bne_ins函数，代码如下所示：</p><pre><code class=\"language-plain\">.global beq_ins\nbeq_ins:\n    beq a0，a1，imm_l1          #a0==a1，跳转到imm_l1地址处开始运行\n    mv a0，zero                 #a0=0\n    jr ra                       #函数返回    \nimm_l1:\n    addi a0，zero，1            #a0=1\n    jr ra                       #函数返回\n\n.global bne_ins\nbne_ins:\n    bne a0，a1，imm_l2          #a0!=a1，跳转到imm_l2地址处开始运行\n    mv a0，zero                 #a0=0\n    jr ra                       #函数返回    \nimm_l2:\n    addi a0，zero，1            #a0=1\n    jr ra                       #函数返回    \n</code></pre><p>我们先看代码里的 <strong>beq_ins函数</strong>完成了什么操作，如果a0和a1相等，则跳转到imm_l1处，将a0置1并返回，否则继续顺序执行，将a0置0并返回。然后，我们再看下 <strong>bne_ins函数</strong>的操作，如果a0和a1不相等则跳转到imm_l2处，将a0置1并返回，否则继续顺序执行将a0置0并返回。</p><p>我们在main.c文件中声明一下这两个函数并调用它们，然后用VSCode打开工程目录，按下“F5”键来调试，情况如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/49/93/49f58deaf397223dc8beac03db98ae93.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图是执行“beq a0，a1，imm_l1”指令后的状态。由于a0、a1寄存器内容不相等，所以没有跳转到imm_l1处运行，而是继续顺序执行beq后面的下一条指令，最后返回到main函数中。</p><p>函数返回结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/0f/9de3e01df935093db045340ef3b72d0f.jpg?wh=1920x1018\" alt=\"图片\"></p><p>从图里我们能看到，首先会由main函数调用beq_ins函数，然后调用printf输出返回的结果，在终端中的输出为0。这个结果在我们的预料之中，也验证了beq指令的效果和我们之前描述的一致。</p><p>下面我们继续调试，就会进入bne_ins函数中，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/59/e25ea97a9e52f1af1e524ca700a98259.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是执行“bne a0，a1，imm_l2”指令之后的状态。同样因为a0、a1寄存器内容不相等，而bne指令是不相等就跳转。这时程序会直接跳转到imm_l2处运行，执行addi a0，zero，1指令，将a0寄存器置为1后，返回到main函数中，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/cb/43/cb69e671438f856f16f7edb3fd038d43.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中第二个printf函数打印出bne_ins函数返回的结果，输出为1。bne指令会因为数据相等而跳转，将a0寄存器置为1，导致返回值为1，这个结果是正确的。</p><p>经过上面的调试验证，我们不难发现：<strong>其实bne是beq的相反操作，作为一对指令搭配使用，完成相等和不相等的流程控制。</strong></p><h2>小于则跳转：blt和bltu指令</h2><p>有了bqe、bne有条件跳转指令后，就能实现C语言 ==和 != 的比较运算符的功能。但这还不够，除了比较数据的相等和不等，我们还希望实现比较数据的大小这个功能。</p><p>这就要说到小于则跳转的指令，即blt指令与bltu指令，bltu指令是blt的无符号数版本。它们的汇编代码书写形式如下：</p><pre><code class=\"language-plain\">blt rs1，rs2，imm\n#blt 条件小于跳转指令\n#rs1 源寄存器1\n#rs2 源寄存器2\n#imm 立即数\nbltu rs1，rs2，imm\n#bltu 无符号数条件小于跳转指令\n#rs1 源寄存器1\n#rs2 源寄存器2\n#imm 立即数\n</code></pre><p>和bqe、bne指令一样，上述代码中rs1、rs2可以是任何通用寄存器，imm是立即数（也可称为偏移量），占用13位二进制编码，它们同样没有目标寄存器，不会回写结果。</p><p>blt指令和bltu指令所完成的操作，可以用后面的伪代码描述：</p><pre><code class=\"language-plain\">//blt\nif(rs1 &lt; rs2) pc = pc + 符号扩展（imm &lt;&lt; 1）\n//bltu\nif((无符号)rs1 &lt; (无符号)rs2) pc = pc + 符号扩展（imm &lt;&lt; 1）\n</code></pre><p>你可以这样理解这两个指令。当rs1小于rs2时且rs1、rs2中为有符号数据，blt指令就会跳转到imm标号处运行。而当rs1小于rs2时且rs1、rs2中为无符号数据，bltu指令就会跳转到imm标号处运行。</p><p>我们同样通过写代码验证一下，加深理解。在beq.S文件中，我们用汇编写上blt_ins、bltu_ins函数，代码如下所示：</p><pre><code class=\"language-plain\">.global blt_ins\nblt_ins:\n    blt a0，a1，imm_l3          #a0&lt;a1，跳转到imm_l3地址处开始运行\n    mv a0，zero                 #a0=0\n    jr ra                       #函数返回    \nimm_l3:\n    addi a0，zero，1            #a0=1\n    jr ra                       #函数返回\n\n.global bltu_ins\nbltu_ins:\n    bltu a0，a1，imm_l4         #a0&lt;a1，跳转到imm_l4地址处开始运行\n    mv a0，zero                 #a0=0\n    jr ra                       #函数返回    \nimm_l4:\n    addi a0，zero，1            #a0=1\n    jr ra                       #函数返回    \n</code></pre><p>blt_ins函数都做了什么呢？如果a0小于a1，则跳转到imm_l3处，将a0置1并返回，否则继续顺序执行将a0置0并返回。</p><p>接着我们来看bltu_ins函数的操作，如果a0中的无符号数小于a1中的无符号数，程序就会跳转到imm_l4处，将a0置1并返回，否则继续顺序执行，将a0置0并返回。</p><p>我们还是用VSCode打开工程目录，按下“F5”键来调试验证。下图是执行“blt a0,a1,imm_l3”指令之后的状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/2b/de83yyfa2b78a2befbc8c147e6007d2b.jpg?wh=1920x1018\" alt=\"图片\"></p><p>由于a0中的有符号数小于a1中的有符号数，而blt指令是小于就跳转，这时程序会直接跳转到imm_l3处运行，执行addi a0，zero，1指令，将a0寄存器置为1后，返回到main函数中。返回结果如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/52/de/52a76a672d7439067fb89f47888409de.jpg?wh=1920x1018\" alt=\"图片\"></p><p>对照上图可以发现，main函数先调用了blt_ins函数，然后调用printf在终端上打印返回的结果，输出为1。这个结果同样跟我们预期的一样，也验证了blt指令的功能确实是小于则跳转。</p><p>我们再接再厉，继续调试，进入bltu_ins函数中，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/08/43/084212450c4ba63965e7e2a041d82c43.jpg?wh=1920x1018\" alt=\"图片\"></p><p>图里的代码表示执行“bltu a0，a1，imm_l4”指令之后的状态。</p><p>由于bltu把a0、a1中的数据当成无符号数，所以a0的数据小于a1的数据，而bltu指令是小于就跳转，这时程序就会跳转到imm_l4处运行，执行addi a0，zero，1指令，将a0寄存器置为1后，就会返回到main函数中。</p><p>对应的跳转情况，你可以对照一下后面的截图：</p><p><img src=\"https://static001.geekbang.org/resource/image/57/2e/577245249a17da3579a7b7af1a024a2e.jpg?wh=1920x1018\" alt=\"图片\"></p><p>我们看到上图中调用bltu_ins函数传递的参数是3和-1，应该返回0才对。然而printf在终端上输出为1，这个结果是不是出乎你的意料呢？</p><p>我们来分析一下原因，没错，这是因为bltu_ins函数<strong>会把两个参数都当成无符号数据</strong>，把-1当成无符号数是0xffffffff，远大于3。所以这里返回1，反而是bltu指令正确的运算结果。</p><h2>大于等于则跳转：bge和bgeu指令</h2><p>有了小于则跳转的指令，我们还是需要大于等于则跳转的指令，这样才可以在C语言中写出类似\"a &gt;= b\"这种表达式。在RISC-V指令中，为我们提供了bge、bgeu指令，它们分别是有符号数大于等于则跳转的指令和无符号数大于等于则跳转的指令。</p><p>这是最后两条有条件跳转指令，它们的汇编代码形式如下：</p><pre><code class=\"language-plain\">bge rs1，rs2，imm\n#bge 条件大于等于跳转指令\n#rs1 源寄存器1\n#rs2 源寄存器2\n#imm 立即数\nbgeu rs1，rs2，imm\n#bgeu 无符号数条件大于等于跳转指令\n#rs1 源寄存器1\n#rs2 源寄存器2\n#imm 立即数\n</code></pre><p>代码规范和前面四条指令都相同，这里不再重复。</p><p>下面我们用伪代码描述一下bge、bgeu指令，如下所示：</p><pre><code class=\"language-plain\">//bge\nif(rs1 &gt;= rs2) pc = pc + 符号扩展（imm &lt;&lt; 1）\n//bgeu\nif((无符号)rs1 &gt;= (无符号)rs2) pc = pc + 符号扩展（imm &lt;&lt; 1）\n</code></pre><p>我们看完伪代码就能大致理解这两个指令的操作了。当rs1大于等于rs2，且rs1、rs2中为有符号数据时，bge指令就会跳转到imm标号处运行。而当rs1大于等于rs2时且rs1、rs2中为无符号数据，bgeu指令就会跳转到imm标号处运行。</p><p>我们继续在beq.S文件中用汇编写上bge_ins、bgeu_ins函数，进行调试验证，代码如下所示：</p><pre><code class=\"language-plain\">.global bge_ins\nbge_ins:\n    bge a0，a1，imm_l5          #a0&gt;=a1，跳转到imm_l5地址处开始运行\n    mv a0，zero                 #a0=0\n    jr ra                       #函数返回    \nimm_l5:\n    addi a0，zero，1            #a0=1\n    jr ra                       #函数返回\n    \n.global bgeu_ins\nbgeu_ins:\n    bgeu a0，a1，imm_l6         #a0&gt;=a1，跳转到imm_l6地址处开始运行\n    mv a0，zero                 #a0=0\n    jr ra                       #函数返回    \nimm_l6:\n    addi a0，zero，1            #a0=1\n    jr ra                       #函数返回        \n</code></pre><p>结合上面的代码，我们依次来看看bge_ins函数和bgeu_ins函数都做了什么。先看bge_ins函数，如果a0大于等于a1，则跳转到imm_l5处将a0置1并返回，否则就会继续顺序执行，将a0置0并返回。</p><p>而bgeu_ins函数也类似，如果a0中无符号数大于等于a1中的无符号数，则跳转到imm_l6处将a0置1并返回，否则继续顺序执行，将a0置0并返回。</p><p>我们用VSCode打开工程目录，按“F5”键调试，情况如下：<img src=\"https://static001.geekbang.org/resource/image/36/f6/364a03d76569d5b60d121a54ddcb41f6.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是执行“bge a0，a1，imm_l5”指令之后的状态，由于a0中的有符号数，大于等于a1中的有符号数。而bge指令是大于等于就跳转，所以这时程序将会直接跳转到imm_l5处运行。执行addi a0，zero，1指令，将a0寄存器置为1后，就会返回到main函数中。</p><p>对照下图，可以看到调用bge_ins(4,4)函数后，之后就是调用printf，在终端上打印其返回结果，输出为1。</p><p><img src=\"https://static001.geekbang.org/resource/image/42/07/42711ec540d4a45b856692bc0fec7307.jpg?wh=1920x1018\" alt=\"图片\"></p><p>因为两个数相等，所以返回1，这个结果正确，也验证了bge指令的功能确实是大于等于则跳转。</p><p>下面我们继续调试，就会进入bgeu_ins函数之中，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/71/f8/711eeea5c7d9b26988649c80d01128f8.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是执行“bgeu a0，a1，imm_l6”指令之后的状态。</p><p>由于bgeu把a0、a1中的数据当成无符号数，所以a0的数据小于a1的数据。而bgeu指令是大于等于就跳转，这时程序就会就会顺序运行bgeu后面的指令“mv a0，zero”，将a0寄存器置为0后，返回到main函数中。</p><p>可以看到，意料外的结果再次出现了。你可能疑惑，下图里调用bgeu_ins函数传递的参数是3和-1，应该返回1才对，然而printf在终端上的输出却是0。</p><p><img src=\"https://static001.geekbang.org/resource/image/31/fd/31c1bfab78d9e582ecd749da5e8942fd.jpg?wh=1920x1018\" alt=\"图片\"></p><p>出现这样的情况，跟前面bltu_ins函数情况类似，bgeu_ins函数会把两个参数都当成无符号数据，把-1当成无符号数是0xffffffff，3远小于0xffffffff，所以才会返回0。也就是说，图里的结果恰好验证了bgeu指令是正确的。</p><p>到这里，我们已经完成了对beq、bne、blt、bltu、bge、bgeu指令的调试，熟悉了它们的功能细节，现在我们继续一起看看beq_ins、bne_ins、blt_ins、bltu_ins、bge_ins、bgeu_ins函数的二进制数据。</p><p>沿用之前查看jal_ins、jalr_ins函数的方法，我们将main.elf文件反汇编成main.ins文件，然后打开这个文件，就会看到这些函数的二进制数据，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/65/c30f9ebfba9e4aa3ed983dd9f38d1465.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图里的反汇编代码中使用了一些伪指令，它们的机器码以及对应的汇编语句、指令类型，我画了张表格来梳理。</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/14/d19b398473be5f8441b3e9d27c55f914.jpg?wh=1920x955\" alt=\"图片\"><br>\n有了这些机器码数据，我们同样来拆分一下这些指令各位段的数据，在内存里它们是这样编码的：</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/eb/fdf6e7e41b0cd3ef02712890815506eb.jpg?wh=1920x2178\" alt=\"图片\"></p><p>看完图片我们可以发现，bqe、bne、blt、bltu、bge、bgeu指令的操作码是相同的，区分指令的是<strong>功能码</strong>。</p><p>这些指令的立即数都是相同的，这和我们编写的代码有关，其数据正常组合起来是0b00000000110，这个二进制数据左移1位等于十六进制数据0xc。看看那些bxxx_ins函数代码，你就明白了，bxxx指令和imm_lxxx标号之间（包含标号）正好间隔3条，一条指令4字节，其<strong>偏移量正好是12</strong>，pc+12正好落在imm_lxxx标号处的指令上。</p><h2>重点回顾</h2><p>这节课就要结束了，我们做个总结。</p><p>RISC-V指令集中的有条件跳转指令一共六条，它们分别是beq、bne、blt、bltu、bge、bgeu。</p><p>bne和beq指令，用于比较数据是否相等，它们是一对相反的指令操作，搭配使用就能完成相等和不相等的流程控制。blt、bltu是小于则跳转的指令，bge、bgeu是大于等于则跳转的指令，区别在于有无符号数。这六条跳转指令的共性是，<strong>都会先比较两个源操作数，然后根据比较结果跳转到具体的偏移地址去运行。</strong></p><p>这节课的要点我给你准备了导图，供你参考复习。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/09/bce0a544b0c7a1d518ab2bd1ca600a09.jpg?wh=1920x1125\" alt=\"图片\"></p><p>到这里，我们用两节课的时间掌握了RISC-V指令集的八条跳转指令。正是这些“辛勤劳作”的指令，CPU才获得了顺序执行之外的新技能，进而让工程师在高级语言中，顺利实现了函数调用和流程控制与比较表达式。</p><p>下节课我们继续挑战访存指令，敬请期待。</p><h2>思考题</h2><p>我们发现在RISC-V指令集中，没有大于指令和小于等于指令，这是为什么呢？</p><p>别忘了在留言区记录收获，或者向我提问。如果觉得课程还不错，别忘了推荐给身边的朋友，跟他一起学习进步。</p>","neighbors":{"left":{"article_title":"18｜RISC-V指令精讲（三）：跳转指令实现与调试","id":562786},"right":{"article_title":"20｜RISC-V指令精讲（五）：原子指令实现与调试","id":565782}},"comments":[{"had_liked":false,"id":356991,"user_name":"极客酱酱","can_delete":false,"product_type":"c1","uid":2934665,"ip_address":"湖北","ucode":"18CDC1DB754D58","user_header":"https://static001.geekbang.org/account/avatar/00/2c/c7/89/16437396.jpg","comment_is_top":false,"comment_ctime":1662802668,"is_pvip":true,"replies":[{"id":"130141","content":"哈哈  加油","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1663396303,"ip_address":"湖北","comment_id":356991,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5957769964","product_id":100117801,"comment_content":"终于了解了高级语言是怎么实现函数返回和调用的了","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587941,"discussion_content":"哈哈  加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663396303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356703,"user_name":"苏流郁宓","can_delete":false,"product_type":"c1","uid":2729645,"ip_address":"湖北","ucode":"AD07BD9CE03047","user_header":"https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg","comment_is_top":false,"comment_ctime":1662518185,"is_pvip":false,"replies":[{"id":"129929","content":"那是硬件 内部 的实现 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1662885167,"ip_address":"湖北","comment_id":356703,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1662518185","product_id":100117801,"comment_content":"俺更好奇，RIScv基本指令中怎么实现接口的功能（比如不同厂家在基本指令上扩展，为了实现不同riscv+指令，能够实现互联互通，需要基本指令怎么实现接口功能，避免碎片化（不同指令集互通不了））","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587212,"discussion_content":"那是硬件 内部 的实现 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662885168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356700,"user_name":"苏流郁宓","can_delete":false,"product_type":"c1","uid":2729645,"ip_address":"湖北","ucode":"AD07BD9CE03047","user_header":"https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg","comment_is_top":false,"comment_ctime":1662517834,"is_pvip":false,"replies":[{"id":"129928","content":"是的 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1662885122,"ip_address":"湖北","comment_id":356700,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1662517834","product_id":100117801,"comment_content":"答：不需要再增加多余比较指令，上面的跳转指令混合使用就能实现相同的功能的，riscv类似软件功能的模块化设计，不需要搞那么多比较指令的，只要无符号比较和有符号比较上基本扩展就行的 啊","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587211,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662885122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}