{"id":688563,"title":"01｜重识JVM：JVM的起源、特性与系统构成","content":"<p>你好，我是康杨。欢迎你加入学习，和我一起开启JVM的探索之旅。</p><p>作为这门课程的第一讲，我希望通过我的介绍，能让你对JVM有一个整体的认知。我将从JVM的起源、它的基本特性、内部构成，以及它与我们常说的JDK、JRE的关系等多个维度展开，让你知其然并知其所以然。</p><h2>JVM的起源</h2><p>区别于很多课程以“hello world”&nbsp;开篇，我们今天从一个实际的需求开始。假设你是一家餐厅的老板，需要计算过去一周的营收总和，过去一周每天的营收分别是 102、230、320、431、130。假如你生活在公元前，这时候你可能就需要用结绳记事的方式来进行计算。</p><p>而如果你生活在19世纪50年代，那么恭喜你，你可以用计算机帮你计算了。幸亏有了计算机，不然，如果要算一年的营收，不知道要用掉多少根绳子，算多长时间呢。</p><p>当然，现在的你，显然会用更简单的方式得到结果，通过下面这段代码，JVM就会帮你完成运算，你甚至不用考虑是在Windows上运行，还是在苹果电脑上运行，因为JVM会帮你搞定。</p><pre><code class=\"language-java\">int[] arr = {&nbsp;102，230，320，431，130};\nint sum = 0;   \nfor(int i: arr){   \n   sum += i;\n}\nSystem.out.println(\"Sum is: \" + sum);\n</code></pre><!-- [[[read_end]]] --><p>我们要解决的问题本身，其实从未发生变化，但是解决问题的工具从结绳记事，到计算机再到虚拟机一直在演进。</p><p><img src=\"https://static001.geekbang.org/resource/image/31/03/31bdac0e85275e0a09527b2b6be88303.jpg?wh=1920x572\" alt=\"图片\"></p><p>其实结绳记事也可以看作是最早的“计算机”，虽然它看上去与我们现在所使用的计算机大不相同，但其背后的原理，也就是信息的储存、处理与传递，却与我们现在所使用的计算机如出一辙。</p><p>人类的智慧从这里开始，也由此引领我们走向了计算机的时代。然后，人类发明了算盘、电子管计算机，再到晶体管计算机。在这个过程中，人们逐渐发现，用硬件实现不同的计算机系统既昂贵又低效。于是，软件的概念应运而生，随着时间的推移，软件的领域不断拓展和加深，计算机的能力也相应地提高了。<strong>整个计算机系统由层层抽象构建而成，硬件是基础，应用是表层，中间则是操作系统和各种各样的编程语言。</strong></p><h3>计算机的机器本质</h3><p>现代的计算机基本是以图灵机为理论基础的，采用了冯·诺依曼体系架构。</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/c6/9cdb7c0247ae7c5799898f4d43eb5ec6.png?wh=1920x1125\" alt=\"图片\"></p><p>如图所示，冯·诺依曼体系是计算机体系结构的基本框架，它由存储器、运算器、控制器和I/O设备组成。存储器用来存放指令和数据，运算器负责执行算术和逻辑运算，控制器指导指令的执行流程，而I/O设备用于与外部世界进行数据交互。</p><p>0/1机器码是计算机能够直接执行的最底层的指令形式，它由0和1构成，对应着不同的操作和数据传输。计算机通过将0/1机器码加载到存储器中，并由控制器解析、执行这些指令，实现了复杂的计算和数据处理任务。</p><p>这种基于冯·诺依曼体系和0/1机器码的计算机运行方式不仅具有普适性和可编程性，还为计算机科学和技术的发展提供了强大的基石。深入理解和掌握这些机器本质的概念，能够更好地解析和控制计算机系统。而冯·诺依曼也可以看作是Java虚拟机（JVM）的本源和雏形。</p><h3>Java 虚拟机的本质</h3><p>JVM是一种虚拟计算机，它接收字节码，并把它转化为机器可以读取和执行的代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/yy/c5def0b8811755a27cbc917dcffe4dyy.png?wh=2302x666\" alt=\"\"></p><p>这样Java程序就能在JVM中运行，不用考虑底层的硬件和操作系统，这就是<strong>JVM的平台无关性</strong>。简单来说，JVM可以看作是一个抽象的计算机，它有自己的指令系统、内存、注册器等。编译器把源程序翻译成字节码，这些字节码随后在JVM中执行。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/9e/4dc0517dd71130cd14552c208540d09e.jpg?wh=1920x619\" alt=\"图片\"></p><p>总的来说就是Java虚拟机在计算机硬件和Java程序之间建立了一个抽象层，使Java程序不必关心底层的硬件和操作系统的情况，从而实现了Java“<strong>一次编写，到处运行</strong>”的效果。这也是Java语言相比其他语言的一大优势。</p><h3><strong>机器与语言</strong></h3><p><img src=\"https://static001.geekbang.org/resource/image/fb/4f/fbac890fbdd8407441df8243f6a8854f.jpg?wh=2732x1192\" alt=\"\"></p><p>通过刚刚的介绍，也许你会发现，其实问题本身从来没有变化过，只是随着每一个新的机器的诞生，我们使用机器的成本快速降低了。每种机器都提供了一种语言作为我们和它们交互的方式，在最早的计算机时代，我们是通过0/1来和计算机交互，而JVM采用字节码作为交互的语言。但是现在我们可以用更接近人类语言的Java或者Groovy语言和机器交互，让它们完成我们期望的目标。</p><p>这就像一个无限的递归，通过封装原有的机器，我们借助原有的机器的能力，打造一个新的机器，并提供一门新的更简化的语言。这也是云时代当机器的概念越来越弱化FaaS逐步成为主流的原因。所以深刻地理解JVM的本质，不光能帮我们写出优秀的Java代码，也能帮助我们看清楚技术演进的趋势。</p><h2>JVM基本特性</h2><p>说了这么多，让我们一起来看看JVM有哪些特性。作为一种计算机抽象设备，JVM用于管理和优化执行Java程序。区别于CPU采用的寄存器架构，JVM是基于栈技术实现的。因为寄存器和硬件息息相关，程序如果采用寄存器就会失去移植性，而基于栈最主要的优点就是与机器无关。</p><p>这也使得JVM具备如下特性：</p><ol>\n<li>平台独立性：Java代码可以在任何安装了JVM的机器上运行，不用为每种平台编写不同的版本。</li>\n<li>自动内存管理 ：JVM提供了垃圾收集机制，自动回收不再使用的内存，降低内存泄漏的风险。</li>\n<li>高效的即时编译：JVM运行时即时编译对热点代码进行优化，提升程序执行效率。</li>\n<li>强大的监控和调试工具：JVM为开发者提供了详细的性能数据和调试工具，帮助开发者提升程序性能，解决问题。</li>\n</ol><p>所以JVM不仅能降低开发成本，使开发者不用再去解决一套代码在多平台运行和维护的问题。同时也能通过即时编译和内存管理使Java应用可以运行得更快、更稳定。各种调试和监控工具也会帮助我们更快地发现和解决问题，从而提升开发效率。</p><p>JVM固然很强大，但是这并不意味着我们可以随心所欲地开发程序。只有深入地了解JVM，才能真正用好JVM。否则你会发现程序运行的结果和你设想的并不一样。比如不了解GC机制，随意创建对象，不考虑对象的大小和生命周期，不考虑GC和应用程序之间关系，从而导致FULL GC和OOM的问题。</p><p>比如下面这段代码，如果没有认识到一段代码从我们开发到真正执行可能经过的编译器重排、内存重排、指令重排等诸多过程，很可能导致代码的执行结果不稳定，甚至是出错。</p><pre><code class=\"language-java\">public class Demo {\n    private int a = 0;\n    private  boolean flag = false;\n    public void writer() {\n        a = 1;                  \n        flag = true;            \n    }\n\n    public void reader() {\n        if (flag) {             \n            int i = a * a;      \n            System.out.println(i);\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        final   Demo example = new  Demo();\n        Thread thread1 = new Thread(() -&gt; example.writer());\n        Thread thread2 = new Thread(() -&gt; example.reader());\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n    }\n }\n</code></pre><p>那怎么优化这段代码呢？你可以先自己尝试优化一下。</p><h2>JVM内部构成</h2><p>了解了这么多JVM的特性，下面就让我们深入到JVM的内部一探究竟。如图所示，JVM由三大子系统构成，分别是类加载子系统、字节码执行引擎以及运行时数据区。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/f4/d280d8637642253797815bfb6738d8f4.jpg?wh=7069x5669\" alt=\"图片\"></p><h3>类加载子系统</h3><p>类加载子系统（&nbsp;Class Loader Subsystem）负责把字节码文件加载到内存里，并在运行时解析和验证类文件的正确性，以此实现Java的动态性和可扩展性。</p><h3>字节码执行引擎</h3><p>字节码执行引擎（Execution Engine）是JVM的核心，类似于冯.诺依曼机的中央处理器，负责执行字节码指令，把字节码翻译成机器代码，实现程序的实际运行以及跨平台性和高性能的特性。</p><p>JVM 同时支持<strong>解释执行和编译执行</strong>两种方式，JVM的优化重点放到了这个部分，它会自动监视代码的执行情况，对于一般的代码采用解释执行的方式，而对于经常调用的方法启动一个后台线程，把它们编译成本地代码并进行优化，这也是JVM能实现高性能一个非常重要的因素。</p><h3>运行时数据区</h3><p>运行时数据区（Runtime Data Area）用来存储程序执行期间的数据。提供程序运行时的内存空间，为程序的执行提供基础支持。</p><p>这个区域可以从线程的视角分成线程共享区域和线程独享区域。线程独享区域主要有程序计数器、虚拟机栈、本地方法栈三个部分，这三个部分与线程的生命周期相同，所以和线程同生灭，不用考虑垃圾回收的问题。线程共享区域包括堆和方法区，方法区用来存储类的结构信息、堆用来存储对象实例等。</p><h2>JVM、JDK与JRE</h2><p>我们可以把JVM比作汽车的发动机，虽然它是整个汽车中非常核心的部件，但是显然我们不能只是把一台发动机交付给客户，用户不光关心发动机的性能、百公里加速的时间，也关注你的座椅是否是真皮的、是否有全景天窗等，所以接下来我们就来介绍一下JVM最终交付给用户的三个概念JDK、JRE、JVM。</p><p>JVM我们前面已经说过了，这里我们重点看一下JDK和JRE。</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/5c/ebf3432f388fc20d6d1eab56c571385c.png?wh=1920x1023\" alt=\"图片\"></p><h3>JRE</h3><p>JRE 是 Java Runtime Environment 的缩写， 从名字就能看出来，JRE 关注Java的运行时环境，它主要由三个部分构成，分别是核心类库、支持文件以及&nbsp;JVM。JRE由Java API和JVM组成，JVM通过类加载器加载Java应用，并通过Java API来执行。</p><h3>JDK</h3><p>JDK是 Java Development Kit（ Java开发工具套件 ）的缩写，看名字估计你就猜到了，它才是我们交付给用户的那台汽车。事实上JDK 是一个完整的软件开发环境，能够帮助用户更好地开发Java Applet 以及 Java 服务器端程序。</p><p>JDK 整体上包括JRE（Java 运行时环境）、Javac（编译器）、Javadoc（文档生成器）、各种工具等，提供了从加载代码到验证代码再到执行代码的全生命周期管理。</p><h2>重点回顾</h2><p>这节课我通过介绍支撑着Java语言的JVM为你揭示了Java编程背后的秘密。</p><p>我们从底层实现开始了解了JVM的起源，它其实就是一台冯.诺依曼机器，和所有的计算机一样能协助你完成计算的任务。但是相对于普通计算机基于寄存器的架构，JVM是基于栈的虚拟机，正是因为基于栈的特性，使JVM具备了平台无关性。和所有的语言一样，JVM提供了自己的语言字节码以及字节码的运行时环境。</p><p>虽然JVM是一台机器，但是它也是虚拟的，它的能力来源于底层真实的物理机，所以了解底层CPU和操作系统对你用好JVM大有裨益，因为它们是JVM的能力之源。当然面试的必考点JVM的内部构造我也着重介绍了下，这些都是需要你牢记于心的。</p><h2>思考题</h2><pre><code>public class Demo {\n    private int a = 0;\n    private  boolean flag = false;\n    public void writer() {\n        a = 1;                  \n        flag = true;            \n    }\n\n    public void reader() {\n        if (flag) {             \n            int i = a * a;      \n            System.out.println(i);\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        final   Demo example = new  Demo();\n        Thread thread1 = new Thread(() -&gt; example.writer());\n        Thread thread2 = new Thread(() -&gt; example.reader());\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n    }\n }\n</code></pre><ol>\n<li>对于我给出的这段代码，你会如何优化呢？请你把你优化后的代码分享到评论区。</li>\n<li>JVM和普通计算机的关系是什么？请说一说你的理解。</li>\n</ol><p>欢迎你把你的答案分享到评论区，和我一起讨论，也欢迎你把这节课分享给需要的朋友，我们下节课再见！</p><h2>💡点亮你的知识框架图</h2><p><img src=\"https://static001.geekbang.org/resource/image/46/c5/462b4c3e2b1033bca75fb62d56fc8bc5.jpg?wh=6666x4923\" alt=\"图片\"></p>","neighbors":{"left":{"article_title":"开篇词｜云时代来临，如何学好JVM应对未来的挑战？","id":688761},"right":{"article_title":"02｜挑战与趋势：云原生时代JVM的演进之路","id":688784}},"comments":[{"had_liked":false,"id":379945,"user_name":"喆","can_delete":false,"product_type":"c1","uid":1021657,"ip_address":"辽宁","ucode":"542E4D8FF40EEF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/d9/a252585b.jpg","comment_is_top":false,"comment_ctime":1692751064,"is_pvip":false,"replies":[{"id":138438,"content":" 基于栈的特性指的是JVM使用栈来进行计算和内存管理。在JVM中，每个线程都有一个私有的栈，用来存储方法的局部变量、方法的参数、返回值以及方法调用时的临时数据。每当线程调用一个方法时，JVM会为该方法分配一个栈帧，栈帧包含了方法的局部变量表、操作数栈等信息。与之相对，基于寄存器的架构（如普通计算机）使用寄存器来存储数据。寄存器是位于处理器内部的高速存储器，用于存放指令操作数和中间结果。基于寄存器的架构直接利用处理器的寄存器进行计算，速度较快。\n基于栈的特性使JVM具备了平台无关性，主要有以下几点原因：\n1. 栈的操作是在内存中进行的，并不依赖于特定的硬件架构。JVM通过使用栈来进行计算，抽象了底层的硬件细节，使得Java程序可以在不同的硬件平台上运行，而不需要修改源代码。\n2. Java的字节码是面向栈的指令集。Java源码在经过编译后会生成字节码，字节码是一种中间代码，使用栈来进行操作。这些字节码可以被JVM解释执行或者编译成特定硬件架构的机器码，实现了平台无关性。\n3. JVM的内存管理也是基于栈的。JVM使用栈来进行方法调用和局部变量的管理，同时也使用栈来进行内存的分配和销毁。这种基于栈的内存管理方式，简化了开发者的内存管理工作，提供了跨平台的内存管理机制。","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1693116479,"ip_address":"北京","comment_id":379945,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"“相对于普通计算机基于寄存器的架构，JVM 是基于栈的虚拟机，正是因为基于栈的特性，使 JVM 具备了平台无关性”，基于栈的特性是什么意思，什么叫基于栈？可以展开说一下吗？为什么基于栈的特性就能平台无关了？","like_count":10,"discussions":[{"author":{"id":1020644,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/e4/abb7bfe3.jpg","nickname":"TerryGoForIt","note":"","ucode":"701B0E72F15AB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626536,"discussion_content":"JVM不用寄存器？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1693097921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626552,"discussion_content":" 基于栈的特性指的是JVM使用栈来进行计算和内存管理。在JVM中，每个线程都有一个私有的栈，用来存储方法的局部变量、方法的参数、返回值以及方法调用时的临时数据。每当线程调用一个方法时，JVM会为该方法分配一个栈帧，栈帧包含了方法的局部变量表、操作数栈等信息。与之相对，基于寄存器的架构（如普通计算机）使用寄存器来存储数据。寄存器是位于处理器内部的高速存储器，用于存放指令操作数和中间结果。基于寄存器的架构直接利用处理器的寄存器进行计算，速度较快。\n基于栈的特性使JVM具备了平台无关性，主要有以下几点原因：\n1. 栈的操作是在内存中进行的，并不依赖于特定的硬件架构。JVM通过使用栈来进行计算，抽象了底层的硬件细节，使得Java程序可以在不同的硬件平台上运行，而不需要修改源代码。\n2. Java的字节码是面向栈的指令集。Java源码在经过编译后会生成字节码，字节码是一种中间代码，使用栈来进行操作。这些字节码可以被JVM解释执行或者编译成特定硬件架构的机器码，实现了平台无关性。\n3. JVM的内存管理也是基于栈的。JVM使用栈来进行方法调用和局部变量的管理，同时也使用栈来进行内存的分配和销毁。这种基于栈的内存管理方式，简化了开发者的内存管理工作，提供了跨平台的内存管理机制。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1693116479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220497,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgObalcm8lIIX69bTo2uYq8erQ9l5wyBibqgorgSsA3QdfOibzeM2V2LbfolwNsLJPMmrdhbHYNsSQ/132","nickname":"Volatile","note":"","ucode":"020769E374988C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635751,"discussion_content":"这里作者的观点，我不敢苟同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705123083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1174199,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","nickname":"5-刘新波(Arvin)","note":"","ucode":"DBD135D2587A93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627324,"discussion_content":"相当于用内存代替物理寄存器进行计算，存储。至于其他能力如创建线程等还是得借助物理机","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693988469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379860,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"重庆","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1692624078,"is_pvip":false,"replies":[{"id":138441,"content":" 在Java中，class文件的卸载是由Java虚拟机的垃圾回收机制决定的。一般来说，当一个类不再被任何活动的线程所引用时，它就变得可被卸载的。\n具体而言，下面是导致class文件卸载的一些常见情况：\n1. 类的实例被垃圾回收：当一个类的所有实例都被垃圾回收器回收时，该类就变得没有被引用，可以被卸载。\n2. 类的ClassLoader被回收：当一个类的ClassLoader被垃圾回收器回收时，该类及其相关的类也会被卸载。\n3. 类的引用被解除：当一个类的所有引用被解除，例如通过反射调用`Class.forName()`加载的类，在不再需要时可以手动调用`Class.forName(&quot;className&quot;).getClassLoader().clearAssertionStatus()`来解除对类的引用，从而使得该类可以被卸载。\n但是并不是所有的class文件都可以被卸载。因为在Java虚拟机规范中，并没有明确要求虚拟机必须卸载类，类的卸载是可选的。一些Java虚拟机实现可能会选择不进行类的卸载，或者仅在特定条件下才进行卸载。因此，class文件的卸载行为可能会因不同的Java虚拟机实现而有所不同。","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1693116844,"ip_address":"北京","comment_id":379860,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"请教一下加载的class文件什么时候会卸载？","like_count":2,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626555,"discussion_content":" 在Java中，class文件的卸载是由Java虚拟机的垃圾回收机制决定的。一般来说，当一个类不再被任何活动的线程所引用时，它就变得可被卸载的。\n具体而言，下面是导致class文件卸载的一些常见情况：\n1. 类的实例被垃圾回收：当一个类的所有实例都被垃圾回收器回收时，该类就变得没有被引用，可以被卸载。\n2. 类的ClassLoader被回收：当一个类的ClassLoader被垃圾回收器回收时，该类及其相关的类也会被卸载。\n3. 类的引用被解除：当一个类的所有引用被解除，例如通过反射调用`Class.forName()`加载的类，在不再需要时可以手动调用`Class.forName(&#34;className&#34;).getClassLoader().clearAssertionStatus()`来解除对类的引用，从而使得该类可以被卸载。\n但是并不是所有的class文件都可以被卸载。因为在Java虚拟机规范中，并没有明确要求虚拟机必须卸载类，类的卸载是可选的。一些Java虚拟机实现可能会选择不进行类的卸载，或者仅在特定条件下才进行卸载。因此，class文件的卸载行为可能会因不同的Java虚拟机实现而有所不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693116844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380102,"user_name":"seker","can_delete":false,"product_type":"c1","uid":1122034,"ip_address":"广东","ucode":"9B705F91355873","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","comment_is_top":false,"comment_ctime":1692964111,"is_pvip":false,"replies":[{"id":138447,"content":"很好的问题，通过这个问题，我并不是希望你能马上得到一个答案，而是希望引导大家去思考，一段代码从我们写出来，到真正执行环节，还有谁来谁来参与，并带来了那些影响，比如编译器重排、内存重排、指令重排这些，答案本身并不重要，引导大家去思考背后的原因，我理解才是更重要的","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1693119206,"ip_address":"北京","comment_id":380102,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"文稿中的代码，如果thread1先执行完，那么程序会正常输出1。如果是thread2先执行完，那么程序没有任何输出。由于引入多线程，导致线程执行先后顺序不确定出现上述问题。\n\n从程序的意图看是想thread1先写，thread2再读，那么修改start()、join()顺序就可以避免问题。即修改为：\nthread1.start(); \nthread1.join();\nthread2.start();\nthread2.join();\n\n但如果是writer()和reader()都有多个线程进入，那就是另外的解决方案了。\n\n所以还是想问老师那段代码的意图是什么？","like_count":1,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626563,"discussion_content":"很好的问题，通过这个问题，我并不是希望你能马上得到一个答案，而是希望引导大家去思考，一段代码从我们写出来，到真正执行环节，还有谁来谁来参与，并带来了那些影响，比如编译器重排、内存重排、指令重排这些，答案本身并不重要，引导大家去思考背后的原因，我理解才是更重要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693119206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380104,"user_name":"seker","can_delete":false,"product_type":"c1","uid":1122034,"ip_address":"广东","ucode":"9B705F91355873","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","comment_is_top":false,"comment_ctime":1692965536,"is_pvip":false,"replies":[{"id":138436,"content":"这样理解没有问题，但是整篇教程我想表达的是另外一种思考。建议再仔细品味下第一篇，去思考下计算机又是什么，他的图灵机本质，换个视角来看待这个问题，有个小提示，一切的本源是为了解决计算的问题，而解决这个问题有两个方向，一个偏重于是什么，就是阿隆佐.邱奇的lambda（λ），一个是图灵的图灵机，推荐读一下http:&#47;&#47;www.yinwang.org&#47;blog-cn&#47;2013&#47;07&#47;13&#47;church-turing，深刻理解这个问题，会对你理解函数式编程，并发的本质，java和go的区别都很有助益的，我也会在后面第四篇重点介绍下这部分","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1693116225,"ip_address":"北京","comment_id":380104,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"JVM 和普通计算机的关系是什么？\n\n这里的普通计算机我理解就是物理机，是一种硬件。JVM终究是一个软件，不过可以进行内存管理、线程管理。在JVM之上可以运行Java应用程序，以及其它可以编译为字节码的编程语言。因此我觉得JVM更像是一个虚拟的操作系统，而Java应用程序则运行在这个虚拟的操作系统之上。\n\n没有硬件作为支撑，那么软件将无法运行。因此软件对硬件是有依赖关系的。","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626550,"discussion_content":"这样理解没有问题，但是整篇教程我想表达的是另外一种思考。建议再仔细品味下第一篇，去思考下计算机又是什么，他的图灵机本质，换个视角来看待这个问题，有个小提示，一切的本源是为了解决计算的问题，而解决这个问题有两个方向，一个偏重于是什么，就是阿隆佐.邱奇的lambda（λ），一个是图灵的图灵机，推荐读一下http://www.yinwang.org/blog-cn/2013/07/13/church-turing，深刻理解这个问题，会对你理解函数式编程，并发的本质，java和go的区别都很有助益的，我也会在后面第四篇重点介绍下这部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693116226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379926,"user_name":"临风","can_delete":false,"product_type":"c1","uid":1145430,"ip_address":"广东","ucode":"59A7F3DDD94D76","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/56/29877cb9.jpg","comment_is_top":false,"comment_ctime":1692721175,"is_pvip":true,"replies":[{"id":138448,"content":"你的思考很赞，其实通过这个例子我是想让大家去思考我们写的代码，在真正执行的时候还有谁参与，如何参与，背后原理是什么，去有整体化的思考，这样才能更好地看清楚未来的变化","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1693119522,"ip_address":"北京","comment_id":379926,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"问题1：对于这段代码，存在两个问题。\n1.join的作用是等待线程执行结束，再继续往后执行，但thread2已经start了，所以我们没办法保证thread1和thread2谁先执行，flag显然是不能保证代码执行的先后顺序的，可以通过信号量或者CountDownLatch来解决（暂时只想到了这两个，不知道还有没用别的更好的方式）。\n2.变量a缺乏volatile修饰，两个可能线程会读取各自线程中的值，导致reader执行的时候取的还是0。\n\n问题2：\njvm就是对操作系统和硬件资源的抽象封装，让你无需考虑是x86还是arm的CPU，也不用管是window是还是Linux的操作系统，实现了一次编译到处运行。本质就是让你只关注自己的代码逻辑，而不用考虑底层硬件和操作系统的区别，但实际上这些事情还是得有人做的，只不过是jvm替你做了，这也就导致了一定程度上的性能损耗。但云原生时代的到了，docker的普及，因为已经对运行环境做了一层封装，大家都是执行镜像，导致Java的优势也就荡然无存了，反而因为其需要支持运行时的问题，启动服务缓慢，无法实现秒级的扩缩容而举步维艰。这些就是我的一些浅薄的认识，希望之后跟着老师能加深对云原生时代Java的理解。\n\n附问题1的代码：\npublic class Demo {\n    private volatile int a = 0;\n    private final Semaphore semaphore = new Semaphore(1);\n\n    public void writer() {\n        a = 1;\n        semaphore.release();\n    }\n\n    public void reader() {\n        try {\n            semaphore.acquire();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        int i = a * a;\n        System.out.println(i);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final Demo example = new Demo();\n        Thread thread1 = new Thread(() -&gt; example.writer());\n        Thread thread2 = new Thread(() -&gt; example.reader());\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n    }\n}","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626564,"discussion_content":"你的思考很赞，其实通过这个例子我是想让大家去思考我们写的代码，在真正执行的时候还有谁参与，如何参与，背后原理是什么，去有整体化的思考，这样才能更好地看清楚未来的变化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693119523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379880,"user_name":"edward","can_delete":false,"product_type":"c1","uid":1604798,"ip_address":"湖南","ucode":"09F7A5B8D2E7BD","user_header":"","comment_is_top":false,"comment_ctime":1692662600,"is_pvip":false,"replies":[{"id":138423,"content":"谢谢夸奖，希望最后你也可以绘制出自己的知识地图\n","user_name":"编辑回复","user_name_real":"编辑","uid":2843479,"ctime":1692929198,"ip_address":"北京","comment_id":379880,"utype":2}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"最后这张图很赞👍","like_count":0,"discussions":[{"author":{"id":2843479,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","nickname":"小虎子🐯","note":"","ucode":"4C9530B3FB407B","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626450,"discussion_content":"谢谢夸奖，希望最后你也可以绘制出自己的知识地图\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692929198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379873,"user_name":"码小呆","can_delete":false,"product_type":"c1","uid":2055809,"ip_address":"广东","ucode":"44532D6ABF9340","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg","comment_is_top":false,"comment_ctime":1692631113,"is_pvip":false,"replies":[{"id":138424,"content":"是的，它的本质就是工具，不过如何用好这个工具可是有大学问哦～欢迎交流！","user_name":"编辑回复","user_name_real":"编辑","uid":2843479,"ctime":1692929274,"ip_address":"北京","comment_id":379873,"utype":2}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"jvm 对于计算机来说,只能算是一个中间件工具,用于把字节码翻译成计算机能识别的机器码而已!","like_count":0,"discussions":[{"author":{"id":2843479,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","nickname":"小虎子🐯","note":"","ucode":"4C9530B3FB407B","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626451,"discussion_content":"是的，它的本质就是工具，不过如何用好这个工具可是有大学问哦～欢迎交流！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692929274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379859,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"广东","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1692623184,"is_pvip":false,"replies":[{"id":138442,"content":"没问题，想了解什么，都可以群里提出来，希望能让你有真正的收获","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1693116936,"ip_address":"北京","comment_id":379859,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"给大佬点赞666，期待半桶水的自己学习这个课程后能查漏补缺底层知识更精进一些，PS：JVM 虚拟机类比真实的计算机之前我怎么没想到呢？😂\n\n另外我看思考题有提到Thread线程，而 JDK 21 下个月就要 GA 了，到时“虚拟线程”（协程）就正式可用了，不知道利用其结构化编程能力能否实现优化它的目的？\n\n以及大佬会否考虑在后面的章节中添加相关的知识点或者加餐介绍一下这个新特性呢？","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626556,"discussion_content":"没问题，想了解什么，都可以群里提出来，希望能让你有真正的收获","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693116936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379855,"user_name":"轻风悠扬","can_delete":false,"product_type":"c1","uid":1319215,"ip_address":"澳大利亚","ucode":"F2276CE113BED1","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/2f/b29e8af8.jpg","comment_is_top":false,"comment_ctime":1692619508,"is_pvip":false,"replies":[{"id":138444,"content":"没问题的，但是volatile的本质是什么，他是如何做到的，volatile和raft协议有什么关系，其实也是可以去思考一下的","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1693117062,"ip_address":"北京","comment_id":379855,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"flag应该用volatile来修饰以确保对其他线程可见。","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626558,"discussion_content":"没问题的，但是volatile的本质是什么，他是如何做到的，volatile和raft协议有什么关系，其实也是可以去思考一下的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693117063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379864,"user_name":"老衲","can_delete":false,"product_type":"c1","uid":1433290,"ip_address":"广东","ucode":"B02BB107DB51BE","user_header":"https://static001.geekbang.org/account/avatar/00/15/de/ca/73f15fe7.jpg","comment_is_top":false,"comment_ctime":1692626990,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"public class Demo {\n    private AtomicInteger a = new AtomicInteger(0);\n    private volatile boolean flag = false;\n\n    public void writer() {\n        a = new AtomicInteger(1);\n        flag = true;\n    }\n\n    public void reader() {\n        if (flag) {\n            int i = a.get() * a.get();\n            System.out.println(i);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final Demo example = new Demo();\n        Thread thread1 = new Thread(example::writer);\n        Thread thread2 = new Thread(example::reader);\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n    }\n}","like_count":1,"discussions":[{"author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626481,"discussion_content":"感谢分享，不过验证了下你的代码，多执行几次的情况下还是会出现问题。\n\n启动thread1和thread2，但执行先后顺序是没有办法保障的，一旦thread2先执行，虽然flag有volatile修饰，但是由于thread1还没开始写，此时thread2读到的flag值依然是false，会导致没有任何输出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692964277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381534,"user_name":"ZYJ","can_delete":false,"product_type":"c1","uid":2130546,"ip_address":"湖北","ucode":"9B4F2A03754D0A","user_header":"https://static001.geekbang.org/account/avatar/00/20/82/72/e6a56c30.jpg","comment_is_top":false,"comment_ctime":1695352587,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100613601,"comment_content":"思考题:\n1,如果想让程序输出1,只需要调整thread1.join()的顺序,让主线程等待thread1执行完再start t2线程\n2,join的原理是,主线程调用thread1.join()时,join里会调用wait方法使主线程等待, 等thread1执行完后才会唤醒主线程(run方法里,最终会notifyAll唤醒主线程)\n3,此时两个线程其实是串联执行,没有并发问题, 但是如果是多个线程的话, 需要给共享变量加上volatile保证可见性(原理:变量读取和写入前后加入内存屏障,保证刷新到主内存)\n疑问:\n老师在下面评论里提到的volatile和Raft协议的关系具体指的是什么?\n\nfinal Demo example = new Demo();\n Thread thread1 = new Thread(() -&gt; example.writer()); \nThread thread2 = new Thread(() -&gt; example.reader()); \nthread1.start(); \nthread1.join(); \nthread2.start(); \nthread2.join();","like_count":0},{"had_liked":false,"id":380712,"user_name":"on","can_delete":false,"product_type":"c1","uid":2869085,"ip_address":"上海","ucode":"D0B59D9F0FC209","user_header":"https://static001.geekbang.org/account/avatar/00/2b/c7/5d/40bdba38.jpg","comment_is_top":false,"comment_ctime":1694045438,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100613601,"comment_content":"文中指出的重排的例子不是很好吧。他实际和cpu线程调度关系更大点，指令重排体现不出来","like_count":0},{"had_liked":false,"id":380039,"user_name":"雷小鸿","can_delete":false,"product_type":"c1","uid":1368897,"ip_address":"陕西","ucode":"424DC9A532FFD7","user_header":"https://static001.geekbang.org/account/avatar/00/14/e3/41/bd0e3a04.jpg","comment_is_top":false,"comment_ctime":1692872568,"is_pvip":true,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100613601,"comment_content":"其实 我看到这段代码，没想要怎么去改，我再想什么情况下，什么业务场景下，会这样写代码，我自己在什么场景下会这样写，对于我们这种业务小的公司很难再实际开发中这样去写。","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626562,"discussion_content":"其实我理解现实业务场景是否有这种需要并不重要，因为我们本身就是不断成长不断去挑战更高的难度，去更大的平台的过程，就像先有鸡还是先有蛋一样，借助这个问题去思考他背后的本质形成自己的知识体系才是最重要的，而不是一段代码是否写的优雅，有点借假修真的味道","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1693117891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}