{"id":627936,"title":"13｜Ranges实战：数据序列函数式编程","content":"<p>你好，我是卢誉声。</p><p>通过前面的学习，我们已经了解到，C++ Ranges作为基础编程工具，可以大幅加强函数式编程的代码可读性和可维护性，解决了C++传统函数式编程的困境。在C++20的加持下，我们终于可以优雅地处理大规模数据了。</p><p>在讲解完Ranges的概念和用法后，我们还是有必要通过实战来融会贯通C++ Ranges。它的用法比较灵活，在熟练使用后，我相信你会在今后的代码实现中对它爱不释手。</p><p>在处理规模型数据时，函数式编程特别有用。为了让你建立更直观的感受，今天我为你准备了一个实战案例，设计一个简单的统计分析程序，用来分析三维视图中的对象。</p><p>好，话不多说，让我们从工程的基本介绍开始吧（课程完整代码，你可以从<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>获取）。</p><h2>模块设计</h2><p>在这个实战案例里，我们主要是展示Ranges的强大功能，而非数据本身的严谨性和正确性。因此，你可以重点关注处理数据的部分。</p><p>那么，<strong>要分析统计的数据长什么样子呢？</strong>我们假设一个三维模型包含多个视图，每个视图包含一定量的三维对象。某个三维对象中的三角面片就组成了逻辑上的三维对象。同时，三维模型会将视图分成高精度视图和低精度视图。</p><p>我造了一份简单的数据，一个三维模型的统计分析表是后面这样。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/by/9a/byy7f09aff681616b49cb377f508eb9a.jpg?wh=3188x2687\" alt=\"\"></p><p>在这个案例中，我们先从系统接口获取数据，再基于这些数据生成表中的统计数据。系统接口的数据格式，都定义在了关键数据类型这个头文件（include/Types.h）中。代码是后面这样。</p><pre><code class=\"language-c++\">#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;string&gt;\n#include &lt;chrono&gt;\n#include &lt;vector&gt;\n\nnamespace ca::types {\n&nbsp;&nbsp;&nbsp; namespace chrono = std::chrono;\n\n&nbsp;&nbsp;&nbsp; using Id = int32_t;\n&nbsp;&nbsp;&nbsp; using ZonedTime = chrono::zoned_time&lt;std::chrono::system_clock::duration, const chrono::time_zone*&gt;;\n\n&nbsp;&nbsp;&nbsp; // 从API接口获取到的视图数据\n&nbsp;&nbsp;&nbsp; struct ModelView {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // API接口中的三维对象数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Object {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对象精度类型\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum class ResolutionType {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; High,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Low\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对象类型ID\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Id objectTypeID;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对象名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string name;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对象中各部件的面片数量（数组）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;int32_t&gt; meshCounts;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图ID\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Id viewId = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图类型名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string viewTypeName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string viewName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 创建时间\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string createdAt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三维对象列表\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;Object&gt; viewObjectList;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 操作符重载，需要供算法使用\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool operator&lt;(const ModelView&amp; rhs) const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (createdAt &lt; rhs.createdAt) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (viewName &gt; rhs.viewName) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool operator&gt;(const ModelView&amp; rhs) const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (createdAt &gt; rhs.createdAt) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (viewName &lt; rhs.viewName) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool operator&gt;=(const ModelView&amp; rhs) const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this == rhs || *this &gt; rhs;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool operator&lt;=(const ModelView&amp; rhs) const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *this == rhs || *this &lt; rhs;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool operator==(const ModelView&amp; rhs) const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return createdAt == rhs.createdAt &amp;&amp; viewName == rhs.viewName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; // 统计后存储的对象数据\n&nbsp;&nbsp;&nbsp; struct ModelObject {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图序号\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t viewOrder = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图ID\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Id viewId = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图类型名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string viewTypeName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string viewName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图创建时间\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZonedTime createdAt;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对象类型ID\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Id objectTypeID = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对象名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string objectName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对象包含的三角面片数量\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对象在视图中的序号\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t viewObjectIndex = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图中剩余已用三角面片数量\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t viewUsedMeshCount = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图中可用三角面片数量上限\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t viewTotalMeshCount = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图中剩余可用三角面片数量\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t viewFreeMeshCount = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图中对象数量\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t viewObjectCount = 0;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取完整视图名称\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string getCompleteViewName() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return viewTypeName + \"/\" + viewName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取对象Key\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string getObjectKey() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return getObjectKey(objectTypeID, viewId);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 根据objectTypeID和viewId获取对象Key\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static std::string getObjectKey(Id objectTypeID, Id viewId) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return std::to_string(objectTypeID) + \"-\" + std::to_string(viewId);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; // 所有统计后的对象数据\n&nbsp;&nbsp;&nbsp; struct ModelObjectTableData {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 高精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelObject&gt; highResolutionObjects;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 低精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelObject&gt; lowResolutionObjects;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角面片数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount;\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; // 被选择的某种精度的数据\n&nbsp;&nbsp;&nbsp; struct ChoseModelObjectTableData {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 当前对象数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ModelObjectTableData* objectTableData;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 选择精度类型\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ModelView::Object::ResolutionType resolutionType;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取当前对象数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::vector&lt;ModelObject&gt;&amp; getCurrentModelObjects() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resolutionType == ModelView::Object::ResolutionType::Low ?\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objectTableData-&gt;lowResolutionObjects : objectTableData-&gt;highResolutionObjects;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; // 从统计后的对象数据中选择某种精度的数据\n&nbsp;&nbsp;&nbsp; inline ChoseModelObjectTableData chooseModelObjectTable(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ModelObjectTableData&amp; objectTableData,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ModelView::Object::ResolutionType resolutionType\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTableData = &amp;objectTableData,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resolutionType = resolutionType,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>在这段代码中，定义了几个类，具体说明我用表格的形式做了整理。</p><p><img src=\"https://static001.geekbang.org/resource/image/19/78/191c04528822cfd010fa9a1f838a7878.jpg?wh=3500x1886\" alt=\"\"></p><p>至于类的数据成员，你可以对照文稿中的代码来具体了解。现在，我们有了关键数据类型定义，在这个基础上，我们就可以开始考虑如何设计程序的模块了。</p><p>这次，我们采用传统C++模块划分来实现整个工程。在学习的过程中，你可以思考一下，如何使用C++ Modules来改造代码的组织方式。</p><p>后面我画了示意图，方便你了解模块的结构和划分。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ae/3b/aed11ef1c47c01e75b09420b5bfc0c3b.jpg?wh=4077x3032\" alt=\"\"></p><p>从图里可以看到，除了main.cpp作为程序入口以外，所有代码都放在ca（ca指的是correlations algorithm，即统计算法）模块下。该模块包含了三个子模块。</p><ul>\n<li>types：基础类型定义。</li>\n<li>utils：工具模块，包括时间工具库、输入输出工具库和Ranges工具库。</li>\n<li>algorithms：算法模块，包括procedure、functional、ranges单个子模块，分别对应过程化算法实现、函数式算法实现和基于Ranges的函数式算法实现。</li>\n</ul><p>因为我们关注的重点是<strong>跟Ranges库相关的逻辑</strong>，所以我们就沿着主模块（main函数）和算法模块（algorithms）这条路线，利用Ranges来实现相关的统计分析功能。至于工具模块，只是提供了一些基本工具函数，不是我们学习的重点，你可以参考完整的<a href=\"https://github.com/samblg/cpp20-plus-indepth/tree/main/13\">工程代码</a>，了解其具体实现。</p><h2>主模块</h2><p>在主模块中，我定义了统计分析的接口，代码实现在src/main.cpp中。</p><pre><code class=\"language-c++\">#include \"data.h\"\n\n#include \"ca/IoUtils.h\"\n#include \"ca/algorithms/ProcedureAlgorithm.h\"\n#include \"ca/algorithms/FunctionalAlgorithm.h\"\n#include \"ca/algorithms/RangesAlgorithm.h\"\n\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nint main() {\n&nbsp;&nbsp;&nbsp; using ca::types::ModelObjectTableData;\n&nbsp;&nbsp;&nbsp; using ResolutionType = ca::types::ModelView::Object::ResolutionType;\n\n&nbsp;&nbsp;&nbsp; // 获取对象信息\n&nbsp;&nbsp;&nbsp; auto modelObjectsInfo = getModelObjectsInfo();\n\n&nbsp;&nbsp;&nbsp; auto&amp; highResolutionObjectSet = modelObjectsInfo.highResolutionObjectSet;\n&nbsp;&nbsp;&nbsp; int32_t meshCount = modelObjectsInfo.meshCount;\n&nbsp;&nbsp;&nbsp; auto&amp; modelViews = modelObjectsInfo.modelViews;\n\n&nbsp;&nbsp;&nbsp; // 过程化算法实现\n&nbsp;&nbsp;&nbsp; auto procedureObjectTable = ca::algorithms::procedure::parseModelObjectTableData(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meshCount\n&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; ca::types::chooseModelObjectTable(procedureObjectTable, ResolutionType::High) &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; ca::types::chooseModelObjectTable(procedureObjectTable, ResolutionType::Low) &lt;&lt; std::endl;\n\n&nbsp;&nbsp;&nbsp; // 函数式算法实现（传统STL）\n&nbsp;&nbsp;&nbsp; ModelObjectTableData functionalObjectTable = {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCount = meshCount\n&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp; ca::algorithms::functional::parseModelObjectTableData(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelViews.begin(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelViews.end(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::back_inserter(functionalObjectTable.lowResolutionObjects),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::back_inserter(functionalObjectTable.highResolutionObjects)\n&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; ca::types::chooseModelObjectTable(functionalObjectTable, ResolutionType::High) &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; ca::types::chooseModelObjectTable(functionalObjectTable, ResolutionType::Low) &lt;&lt; std::endl;\n\n&nbsp;&nbsp;&nbsp; // 函数式算法实现（Ranges）\n&nbsp;&nbsp;&nbsp; auto rangesObjectTable = ca::algorithms::ranges::parseModelObjectTableData(modelViews, highResolutionObjectSet, meshCount);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; ca::types::chooseModelObjectTable(rangesObjectTable, ResolutionType::High) &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; ca::types::chooseModelObjectTable(rangesObjectTable, ResolutionType::Low) &lt;&lt; std::endl;\n\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>从实现代码可以看到，我们首先调用了getModelObjectsInfo函数，通过系统接口获取视图数据。视图数据是一个结构体，包括后面这些数据。</p><ul>\n<li>modelViews：视图数据列表。</li>\n<li>highResolutionObjectSet：高精度的对象集合。</li>\n<li>meshCount：每个视图可以使用的三角面片的数量上限。</li>\n</ul><p>接着，分别调用了以下3个不同的算法接口，使用不同范式实现了对相同数据的处理。</p><p>1.过程式接口：ca::algorithms::<strong>procedure</strong>::parseModelObjectTableData。</p><p>2.传统函数式接口：ca::algorithms::<strong>functional</strong>::parseModelObjectTableData。</p><p>3.基于Ranges的函数式接口：ca::algorithms::<strong>ranges</strong>::parseModelObjectTableData。</p><p>传统函数式算法接口的输入参数比较特殊，由于传统的STL算法在数据的输入输出上，都使用迭代器而非容器，因此我们也模仿这种风格。最后，我们还需要调用chooseModelObjectTable来选择高精度或低精度对象，并将对象通过cout输出到标准输出中。</p><p>现在，我们来看一下刚才提到的getModelObjectsInfo函数，通过系统接口获取视图数据。该函数声明在include/data.h中。</p><pre><code class=\"language-c++\">#pragma once\n\n#include \"ca/Types.h\"\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;cstdint&gt;\n\nstruct ModelObjectsInfo {\n&nbsp;&nbsp;&nbsp; // 视图数据列表\n&nbsp;&nbsp;&nbsp; std::vector&lt;ca::types::ModelView&gt; modelViews;\n&nbsp;&nbsp;&nbsp; // 高精度对象集合\n&nbsp;&nbsp;&nbsp; std::set&lt;std::string&gt; highResolutionObjectSet;\n&nbsp;&nbsp;&nbsp; // 3D模型可用三角面片总数\n&nbsp;&nbsp;&nbsp; int32_t meshCount;\n};\n\nModelObjectsInfo getModelObjectsInfo();\n</code></pre><p>函数的实现代码在src/data.cpp中。</p><pre><code class=\"language-c++\">#include \"data.h\"\n\nModelObjectsInfo getModelObjectsInfo() {\n&nbsp;&nbsp;&nbsp; return {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .modelViews = {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewId = 1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewTypeName = \"Building\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewName = \"Terminal\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .createdAt = \"2020-09-01T08:00:00+0800\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewObjectList = {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 1,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"stair\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 2000, 3000, 3000 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 2,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"window\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 3000, 4000, 4000 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 3,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"pool\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 100, 101 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 4,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"pinball arcade\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 1000, 999 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewId = 2,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewTypeName = \"Building\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewName = \"Side Road\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .createdAt = \"2020-09-01T08:00:00+0800\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewObjectList = {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 5,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"curb\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 1000, 1000, 1000, 65 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 6,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"arterial\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 1000, 2000, 2700 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 7,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"door\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 60, 40, 200 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 8,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"wall\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 200, 500, 302 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewId = 3,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewTypeName = \"Building\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewName = \"Architecture\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .createdAt = \"2020-09-01T08:00:00+0800\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewObjectList = {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 9,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"skeleton\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 1000, 1000, 1000, 320 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 10,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"roof\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 500, 501 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 11,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"table\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 50, 50, 100, 100 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = 12,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = \"carpet\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCounts = { 2, 2, 2, 1, 3 },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .highResolutionObjectSet = {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"1-1\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"2-1\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"5-2\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"6-2\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"9-3\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"10-3\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCount = 50000,\n&nbsp;&nbsp;&nbsp; };\n}\n</code></pre><p>在这里，我选择直接返回了硬编码的数据，这种方式充分利用了C++20的初始化表达式扩展，让初始化代码变得和直接编写JSON一样简单。数据本身就是需求中表格的详细数据。</p><p>我在这里简化了数据初始化的过程，你也可以考虑使用外部数据作为程序的输入。</p><p>接下来，我们重点看看算法模块，其中包含了关键的Ranges用法，所以该模块是整个工程实战的重头戏。</p><h2>算法模块</h2><p>算法模块分别包含传统过程式实现，函数式实现（基于传统STL）和采用Ranges的函数式实现的分析算法。</p><p>为什么要展示不同方案呢？这是为了让你有个对比，也能突出使用Ranges版本的优势。</p><h3>过程化实现</h3><p>先来看过程化算法，我们先编写头文件include/ca/algorithms/ProcedureAlgorithm.h。</p><pre><code class=\"language-c++\">#pragma once\n#include \"ca/Types.h\"\n#include &lt;set&gt;\n\nnamespace ca::algorithms::procedure {\n&nbsp;&nbsp;&nbsp; ca::types::ModelObjectTableData parseModelObjectTableData(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ca::types::ModelView&gt; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 高精度对象集合\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::set&lt;std::string&gt;&amp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角面片数上限\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount\n&nbsp;&nbsp;&nbsp; );\n}\n</code></pre><p>这里声明了几个简单的数据成员变量，对照代码和注释，你就能知道它们的用途。</p><p>接下来，我们来看具体的算法实现。</p><pre><code class=\"language-c++\">#include \"ca/algorithms/ProcedureAlgorithm.h\"\n#include \"ca/TimeUtils.h\"\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nnamespace ca::algorithms::procedure {\n&nbsp;&nbsp;&nbsp; using ca::types::ModelObjectTableData;\n&nbsp;&nbsp;&nbsp; using ca::types::ModelView;\n&nbsp;&nbsp;&nbsp; using ca::types::ModelObject;\n&nbsp;&nbsp;&nbsp; using ca::utils::timePointFromString;\n\n&nbsp;&nbsp;&nbsp; ModelObjectTableData parseModelObjectTableData(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelView&gt; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::set&lt;std::string&gt;&amp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[PROCEDURE] Parse model objects table data\" &lt;&lt; std::endl;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对视图数组进行排序\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::sort(modelViews.begin(), modelViews.end());\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 低精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelObject&gt; highResolutionObjects;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 高精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelObject&gt; lowResolutionObjects;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t viewOrder = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 遍历视图\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; modelView : modelViews) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto viewId = modelView.viewId;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; viewTypeName = modelView.viewTypeName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; viewName = modelView.viewName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; viewObjectList = modelView.viewObjectList;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; createdAt = modelView.createdAt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; viewOrder++;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 本视图的低精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelObject&gt; lowResolutionModelObjects;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 本视图的低精度对象面片数总和\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t lowResolutionMeshCounts = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 本视图的高精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelObject&gt; highResolutionModelObjects;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 本视图的高精度对象面片数总和\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t doubleResolutionMeshCounts = 0;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 遍历视图的对象信息，将对象的数据按高低精度添加到各自的数组并更改统计数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (const auto&amp; viewObject : modelView.viewObjectList) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 遍历meshCounts计算对象的总面片数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t objectMeshCount = 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int meshCount : viewObject.meshCounts) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objectMeshCount += meshCount;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ModelObject modelObject = {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewOrder = viewOrder,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewId = viewId,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewTypeName = viewTypeName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewName = viewName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .createdAt = timePointFromString(createdAt),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = viewObject.objectTypeID,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectName = viewObject.name,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCount = objectMeshCount\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 确定对象是否是高精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (highResolutionObjectSet.find(modelObject.getObjectKey()) == highResolutionObjectSet.end()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 低精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lowResolutionMeshCounts += objectMeshCount;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lowResolutionModelObjects.push_back(modelObject);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 高精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doubleResolutionMeshCounts += objectMeshCount;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionModelObjects.push_back(modelObject);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 计算低精度视图统计信息，原地修改低精度对象信息\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; modelObject : lowResolutionModelObjects) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelObject.viewUsedMeshCount = lowResolutionMeshCounts;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelObject.viewTotalMeshCount = meshCount;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelObject.viewFreeMeshCount = meshCount - lowResolutionMeshCounts;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelObject.viewObjectCount = lowResolutionModelObjects.size();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lowResolutionObjects.push_back(modelObject);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 计算高精度视图统计信息，原地修改高精度对象信息\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (auto&amp; modelObject : highResolutionModelObjects) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelObject.viewUsedMeshCount = doubleResolutionMeshCounts;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelObject.viewTotalMeshCount = meshCount;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelObject.viewFreeMeshCount = meshCount - doubleResolutionMeshCounts;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelObject.viewObjectCount = highResolutionModelObjects.size();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionObjects.push_back(modelObject);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 返回数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ModelObjectTableData{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .highResolutionObjects = highResolutionObjects,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .lowResolutionObjects = lowResolutionObjects,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCount = meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>这里，我们按照标准的过程化编程思路进行编程，这是一种非常平凡的方法——按部就班地处理数据。但是，有必要提一下这段代码的两个特性。</p><p>1.除了sort函数以外，统计分析基本都通过for循环完成。</p><p>2.在数据处理时，存在大量的原地修改。</p><p>这几点特性在过程化编程中很常见。不过，这种原地修改数据的行为，不利于数据的处理和计算。</p><p>虽然原地修改数据可能在简单的程序中很实用，但在复杂的程序中，理论上每个变量应该都只有唯一用途，这么做会让一个变量在程序的不同位置上具备不同的用途。在并行程序中，这种行为会引发数据竞争，反而可能降低并行程序处理性能。所以，在很多时候，对于一个复杂数据处理程序，我们应该避免原地修改数据。</p><h3>传统STL函数式实现</h3><p>那么，如果用函数式编程的方法实现，会有什么变化呢？接下来，我们就看看基于传统STL的、函数式算法的实现版本。</p><p>先看头文件的定义，具体代码放在了include/ca/algorithms/FunctionalAlgorithm.h下面。</p><pre><code class=\"language-c++\">#pragma once\n#include \"ca/Types.h\"\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nnamespace ca::algorithms::functional {\n&nbsp;&nbsp;&nbsp; using ModelObjectOutputIterator = std::back_insert_iterator&lt;std::vector&lt;ca::types::ModelObject&gt;&gt;;\n&nbsp;&nbsp;&nbsp; void parseModelObjectTableData(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图begin迭代器\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ca::types::ModelView&gt;::const_iterator modelViewsBegin,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图end迭代器\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ca::types::ModelView&gt;::const_iterator modelViewsEnd,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 高精度对象集合\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::set&lt;std::string&gt;&amp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角面片数上限\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 低精度对象输出迭代器，用于输出插入低精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ModelObjectOutputIterator lowResolutionObjectOutputIterator,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 高精度对象输出迭代器，用于输出插入高精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ModelObjectOutputIterator highResolutionObjectOutputIterator\n&nbsp;&nbsp;&nbsp; );\n}\n</code></pre><p>接下来，是这种方法的具体实现，代码在src/ca/algorithms/FunctionalAlgorithm.cpp中。建议你大致浏览一下代码，想想和前面过程化实现有什么不同，然后我们再进一步探讨。</p><pre><code class=\"language-c++\">#include \"ca/algorithms/FunctionalAlgorithm.h\"\n#include \"ca/TimeUtils.h\"\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;tuple&gt;\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing ca::types::ModelObjectTableData;\nusing ca::types::ModelView;\nusing ca::types::ModelObject;\nusing ca::utils::timePointFromString;\n\nnamespace ca::algorithms::functional {\n&nbsp;&nbsp;&nbsp; static void extractHighOrLowResolutionObjects(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 排序后的视图数组\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::vector&lt;ca::types::ModelView&gt;&amp; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 高精度对象集合\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::set&lt;std::string&gt;&amp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角面片数上限\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 是否要提取高精度数据，参数为true时提取高精度数据，参数为false时提取低精度数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isHigh,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对象输出迭代器，用于输出插入对象数据（高精度或双精度）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ModelObjectOutputIterator outputIterator\n&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp; void parseModelObjectTableData(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelView&gt;::const_iterator modelViewsBegin,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelView&gt;::const_iterator modelViewsEnd,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::set&lt;std::string&gt;&amp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ModelObjectOutputIterator lowResolutionObjectOutputIterator,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ModelObjectOutputIterator highResolutionObjectOutputIterator\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[FUNCTIONAL] Parse model object data\" &lt;&lt; std::endl;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对视图数组进行排序\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelView&gt; sortedModelViews;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::copy(modelViewsBegin, modelViewsEnd, std::back_inserter(sortedModelViews));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::sort(sortedModelViews.begin(), sortedModelViews.end());\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提取低精度对象数据，通过lowResolutionObjectOutputIterator输出数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extractHighOrLowResolutionObjects(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sortedModelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lowResolutionObjectOutputIterator\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提取高精度对象数据，通过highResolutionObjectOutputIterator输出数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extractHighOrLowResolutionObjects(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sortedModelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionObjectOutputIterator\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; static void extractHighOrLowResolutionObjects(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::vector&lt;ca::types::ModelView&gt;&amp; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::set&lt;std::string&gt;&amp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isHigh,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ModelObjectOutputIterator outputIterator\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 生成对象数据（高精度或双精度）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将模型三维对象数组转换成一个新数组，数组元素是每个视图的对象数组（返回的是二维数组）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;std::vector&lt;ModelObject&gt;&gt; objectsOfViews;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto modelViewsData = modelViews.data();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::transform(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelViews.begin(), modelViews.end(), std::back_inserter(objectsOfViews),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [modelViewsData, &amp;highResolutionObjectSet, meshCount, isHigh](const auto&amp; modelView) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 通过视图指针地址计算视图序号\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t viewOrder = static_cast&lt;int32_t&gt;(&amp;modelView - modelViewsData + 1);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 筛选满足要求的对象（高精度或低精度）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::vector&lt;ModelView::Object&gt;&amp; viewObjectList = modelView.viewObjectList;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelView::Object&gt; filteredViewObjectList;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::copy_if(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; viewObjectList.begin(), viewObjectList.end(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::back_inserter(filteredViewObjectList),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&amp;modelView, &amp;highResolutionObjectSet, isHigh](const ModelView::Object&amp; viewObject) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto viewId = modelView.viewId;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto objectTypeID = viewObject.objectTypeID;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 通过ModelObject::getObjectKey获取对象的key（格式为objectTypeID-viewId）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto objectKey = ModelObject::getObjectKey(objectTypeID, viewId);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 如果高精度对象集合中存在该对象返回true，可以筛选出高精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 如果不存在则返回false，可以筛选出低精度对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return highResolutionObjectSet.contains(objectKey) == isHigh;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 计算各对象总面片数，生成对象数组\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelObject&gt; highResolutionObjects;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::transform(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filteredViewObjectList.begin(), filteredViewObjectList.end(), std::back_inserter(highResolutionObjects),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&amp;modelView, &amp;highResolutionObjectSet, &amp;filteredViewObjectList, viewOrder](const auto&amp; viewObject) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto viewId = modelView.viewId;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; viewTypeName = modelView.viewTypeName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; viewName = modelView.viewName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; viewObjectList = modelView.viewObjectList;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; createdAt = modelView.createdAt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto objectTypeID = viewObject.objectTypeID;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 求对象总面片数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; meshCounts = viewObject.meshCounts;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto objectMeshCount = std::accumulate(meshCounts.begin(), meshCounts.end(), 0);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ModelObject{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewOrder = viewOrder,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewId = viewId,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewTypeName = viewTypeName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewName = viewName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .createdAt = timePointFromString(createdAt),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = viewObject.objectTypeID,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectName = viewObject.name,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCount = objectMeshCount\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 求视图已占用面片数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto viewUsedMeshCount = std::accumulate(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionObjects.begin(), highResolutionObjects.end(), 0,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int32_t prev, const auto&amp; modelObject) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return prev + modelObject.meshCount;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 生成完整的对象数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ModelObject&gt; resultModelObjects;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto viewObjectCount = highResolutionObjects.size();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::transform(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionObjects.begin(), highResolutionObjects.end(), std::back_inserter(resultModelObjects),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [viewUsedMeshCount, meshCount, viewObjectCount](const auto&amp; incomingModelObject) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 返回全新的ModelObject对象，不原地修改数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ModelObject{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewOrder = incomingModelObject.viewOrder,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewId = incomingModelObject.viewId,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewTypeName = incomingModelObject.viewTypeName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewName = incomingModelObject.viewName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .createdAt = incomingModelObject.createdAt,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = incomingModelObject.objectTypeID,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectName = incomingModelObject.objectName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCount = incomingModelObject.meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewUsedMeshCount = viewUsedMeshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewTotalMeshCount = meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewFreeMeshCount = meshCount - viewUsedMeshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewObjectCount = viewObjectCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 返回完整的对象数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resultModelObjects;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 展平二维数组\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::for_each(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objectsOfViews.begin(), objectsOfViews.end(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&amp;outputIterator](const auto&amp; modelObjects) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputIterator = std::copy(modelObjects.begin(), modelObjects.end(), outputIterator);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>看完这段代码实现，有没有什么感想或发现？</p><p><strong>没错，代码更复杂了？！</strong></p><p>这比纯粹的过程式代码还要长，函数parseModelObjectTableData的计算过程，总共分为三步。</p><p>第一步，采用sort算法函数排序视图数组。第二步，调用extractHighOrLowResolutionObjects提取低精度对象数据，通过lowResolutionObjectOutputIterator输出数据。第三步，还是调用上一步的函数，通过highResolutionObjectOutputIterator输出数据。</p><p>在这个函数中，我们调用了transform算法，将对象的数组转换成一个新数组。同时，为了把二维数组展平成一维数组，我们通过for_each将二维数组中的子数组的数据，都拷贝到了最终的输出迭代器中。</p><p>现在，我们分析一下这种传统函数式编程方案有哪些特点。</p><p><strong>首先，它基于STL实现，所有的任务都转换成了函数。</strong></p><p>包括将循环都转换成了transform（映射）、copy_if（筛选）和accumulate（聚合计算）。其中，transform算法将一个数组中的元素映射到另一个数组中，类似于Python和JavaScript中的map函数。</p><p>在代码的第85行，copy_if算法遍历了迭代器中的数据，将符合copy_if中条件函数的元素写入到输出迭代器中，本质类似于Python和JavaScript中filter的效果。</p><p><strong>其次，数据处理过程中尽量避免出现副作用。</strong></p><p>比如说，在原地排序前，我们先复制数据。在transform和copy_if时，都创建了一个新的空数组，然后通过back_inserter获取插入迭代器，然后将输入插入到新数组中。同时，避免在transform的过程中修改输入参数（输入数组的元素）。</p><p><strong>最后，在复杂的计算过程中，将类似的任务提取出来，然后分段处理数组。</strong></p><p>比如说，在第46行和55行，调用了两次extractHighOrLowResolutionObjects函数，也就是需要遍历两次视图，所以相对于过程化版本需要多一次循环。但是，从时间复杂度上看，没有本质区别。</p><p>接下来，我们思考这样一个问题——<strong>如果比较传统STL函数式编程和过程实现的方案，哪种方案编程效率更高？</strong></p><p>从表面上看，这种编码方案比过程式方案复杂。</p><p>但是，考虑到并行化处理问题，比如将高精度、低精度的计算任务分别放在两个线程上执行。那么，由于这种函数式处理方式不会产生对数据的副作用，在处理大规模数据时，无需担心数据竞争和加锁的问题。因此，这种编程方案，执行效率反而更高。</p><p>不过，这段代码看起来还是过于冗长了，而且编码效率低下。所以，我们还是得靠Ranges库来改善函数式编程的开发效率。</p><h3>基于Ranges的函数式实现</h3><p>现在，让我们聚焦在Ranges库上，看看基于Ranges的函数式算法是怎么实现的。</p><p>头文件定义在include/ca/algorithms/RangesAlgorithm.h中。</p><pre><code class=\"language-c++\">#pragma once\n#include \"ca/Types.h\"\n#include &lt;set&gt;\nnamespace ca::algorithms::ranges {\n&nbsp;&nbsp;&nbsp; ca::types::ModelObjectTableData parseModelObjectTableData(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 视图数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ca::types::ModelView&gt; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 高精度对象集合\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::set&lt;std::string&gt;&amp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角面片数上限\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount\n&nbsp;&nbsp;&nbsp; );\n}\n</code></pre><p>对头文件对应的具体实现是这样。</p><pre><code class=\"language-c++\">#include \"ca/algorithms/RangesAlgorithm.h\"\n#include \"ca/TimeUtils.h\"\n#include \"ca/RangeUtils.h\"\n#include &lt;iostream&gt;\n#include &lt;ranges&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing ca::types::ModelObjectTableData;\nusing ca::types::ModelView;\nusing ca::types::ModelObject;\nusing ca::utils::timePointFromString;\n\nnamespace ca::algorithms::ranges {\n&nbsp;&nbsp;&nbsp; namespace ranges = std::ranges;\n&nbsp;&nbsp;&nbsp; namespace views = std::views;\n\n&nbsp;&nbsp;&nbsp; using ca::utils::sizeOfRange;\n&nbsp;&nbsp;&nbsp; using ca::utils::views::to;\n\n&nbsp;&nbsp;&nbsp; // 提取对象\n&nbsp;&nbsp;&nbsp; static std::vector&lt;ModelObject&gt; extractHighOrLowResolutionObjects(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 排序后的视图数组\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::vector&lt;ca::types::ModelView&gt;&amp; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 高精度对象集合\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::set&lt;std::string&gt;&amp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 三角面片数上限\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 是否要提取高精度数据，参数为true时提取高精度数据，参数为false时提取低精度数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isDouble\n&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp; ca::types::ModelObjectTableData parseModelObjectTableData(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::vector&lt;ca::types::ModelView&gt; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::set&lt;std::string&gt;&amp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[RANGES] Parse model objects table data\" &lt;&lt; std::endl;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 对视图数组进行排序\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ranges::sort(modelViews);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ca::types::ModelObjectTableData{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提取低精度对象数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .highResolutionObjects = extractHighOrLowResolutionObjects(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 提取高精度对象数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .lowResolutionObjects = extractHighOrLowResolutionObjects(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCount = meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; static std::vector&lt;ModelObject&gt; extractHighOrLowResolutionObjects(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::vector&lt;ca::types::ModelView&gt;&amp; modelViews,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::set&lt;std::string&gt;&amp; highResolutionObjectSet,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isHigh\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto modelViewsData = modelViews.data();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 生成对象数据（高精度或双精度）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将模型三维对象数组转换成一个新数组，数组元素是每个视图的对象数组（返回的是二维数组）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return modelViews |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::transform([modelViewsData, &amp;highResolutionObjectSet, meshCount, isHigh](const auto&amp; modelView) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 通过视图指针地址计算视图序号\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t viewOrder = static_cast&lt;int32_t&gt;(&amp;modelView - modelViewsData + 1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const std::vector&lt;ModelView::Object&gt;&amp; viewObjectList = modelView.viewObjectList;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto filteredModelObjects = viewObjectList |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 筛选满足要求的对象（高精度或低精度）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::filter([&amp;modelView, &amp;highResolutionObjectSet, isHigh](const ModelView::Object&amp; viewObject) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto viewId = modelView.viewId;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto objectTypeID = viewObject.objectTypeID;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto objectKey = ModelObject::getObjectKey(objectTypeID, viewId);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return highResolutionObjectSet.contains(objectKey) == isHigh;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }) |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 计算各对象总面片数，生成对象数组\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::transform([&amp;modelView, &amp;highResolutionObjectSet, viewOrder](const auto&amp; viewObject) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto viewId = modelView.viewId;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; viewTypeName = modelView.viewTypeName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; viewName = modelView.viewName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; viewObjectList = modelView.viewObjectList;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto&amp; createdAt = modelView.createdAt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto objectTypeID = viewObject.objectTypeID;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const auto&amp; meshCounts = viewObject.meshCounts;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto objectMeshCount = std::accumulate(meshCounts.begin(), meshCounts.end(), 0);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ModelObject{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewOrder = viewOrder,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewId = viewId,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewTypeName = viewTypeName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewName = viewName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .createdAt = timePointFromString(createdAt),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = viewObject.objectTypeID,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectName = viewObject.name,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCount = objectMeshCount\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 计算视图已占用面片数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto viewUsedMeshCount = std::accumulate(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filteredModelObjects.begin(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filteredModelObjects.end(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int32_t prev, const auto&amp; modelObject) { return prev + modelObject.meshCount; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 计算视图中的对象数量\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t viewObjectCount = sizeOfRange(filteredModelObjects);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 生成包含统计信息的对象数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return filteredModelObjects |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::transform(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [viewUsedMeshCount, meshCount, viewObjectCount](const auto&amp; incomingModelObject) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ModelObject{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewOrder = incomingModelObject.viewOrder,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewId = incomingModelObject.viewId,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewTypeName = incomingModelObject.viewTypeName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewName = incomingModelObject.viewName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .createdAt = incomingModelObject.createdAt,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectTypeID = incomingModelObject.objectTypeID,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .objectName = incomingModelObject.objectName,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .meshCount = incomingModelObject.meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewUsedMeshCount = viewUsedMeshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewTotalMeshCount = meshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewFreeMeshCount = meshCount - viewUsedMeshCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .viewObjectCount = viewObjectCount,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to&lt;std::vector&lt;ModelObject&gt;&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }) |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to&lt;std::vector&lt;std::vector&lt;ModelObject&gt;&gt;&gt;() |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::join |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to&lt;std::vector&lt;ModelObject&gt;&gt;();\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>你应该感觉到了，这段代码的基本结构和传统的STL版本一样，但是明显简洁不少——最后的代码形式更像函数式编程语言。</p><p>这都得益于Ranges带来的以下两个关键变化。</p><p><strong>第一，采用视图替换原本的算法。</strong>比如说，用views::transform替换std::transform、views::filter替换std::copy_if，并使用views::join替代std::for_each，让二维数组展平为一维数组。这样一来，我们就可以直接通过range对象作为输入参数，而不再需要手动获取迭代器，代码更加清晰明了。</p><p><strong>第二，采用视图管道替换原本的过程化衔接。</strong>比如说，筛选视图中的高精度/低精度对象（ModelView::Object）以及生成对象（ModelObject）的过程，被改写成了视图管道的连接。二维数组的生成与展平过程也通过views::join和视图管道实现。</p><p>我们通过Ranges大幅减少了临时变量的定义。否则，在复杂的函数式编码过程中，给这么多临时变量起名，几乎是一个不可能完成的任务。</p><p>不过受限于C++20（不考虑C++20的后续演进标准）提供的支持，现在的代码还有几点不足。</p><p>第一，算法函数accumulate其实是在头文件&lt;numeric&gt;中，因此并没有提供针对视图的实现，这里我们还是用了迭代器作为输入，希望C++之后能提供其range版本。</p><p>第二，视图views::join可以将诸如T&lt;T&lt;E&gt;&gt;这种类型转换为T&lt;E&gt;，也就是将子数组的元素都 “join” 到一起。但是，这个函数无法直接连接嵌套视图，因此，我们需要一个视图适配器，将视图转换为具体容器类型，然后通过join进行转换。</p><p>第三，将视图转换为容器需要通过模板函数to&lt;&gt;实现。但这个视图是C++23标准中的，C++20中并没有提供该视图，也就意味着正常情况这段代码无法在C++20中通过编译！</p><p>标准不支持，那我们自己实现不就可以了，为此我们在Ranges工具库中实现了模板函数to&lt;&gt;，具体定义在Ranges工具库头文件include/ca/RangeUtils.h中。</p><pre><code class=\"language-c++\">#pragma once\n\n#include &lt;ranges&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nnamespace ca::utils {\n&nbsp;&nbsp;&nbsp; template &lt;std::ranges::range T&gt;\n&nbsp;&nbsp;&nbsp; size_t sizeOfRange(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T&amp; range\n&nbsp;&nbsp;&nbsp; ) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return static_cast&lt;size_t&gt;(std::accumulate(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range.begin(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range.end(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int32_t prev, const auto&amp; value) { return prev + 1; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ));\n&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp; namespace views {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class Container&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct ToFn {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class Container&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ToFn&lt;Container&gt; to() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ToFn&lt;Container&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template &lt;class Container, std::ranges::viewable_range Range&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Container operator | (Range range, const ToFn&lt;Container&gt;&amp; fn) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Container container{};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::ranges::copy(range, std::back_inserter(container));\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return container;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>由于C++20并不支持自定义视图类型的range适配器闭包对象，这里我们再了解一下实现视图管道的变通方案。</p><p>首先回顾一下视图管道。视图管道是一种语法糖：假定C是一个视图适配器闭包对象，R是一个Range对象，编译器可以自动将以下代码中的第1行，转换成第2行的形式。</p><pre><code class=\"language-c++\">R | C\nC(R)\n</code></pre><p>这里的 | 就是视图管道的操作符。只不过这种语法糖要求视图适配器闭包对象，要按照特定要求实现operator()操作符重载。但在C++20中，自定义的视图类型是无法通过operator()操作符重载获得视图管道支持的。</p><p>虽然编译器无法给予语法糖支持，但开发者可以通过C++标准的操作符重载实现相同的效果。假设R是Range对象的类型，P是自定义适配器闭包对象的类型，如果我们实现下列代码中的函数，就可以实现与视图管道相同的效果了。</p><pre><code class=\"language-c++\">auto operator | (R r, P p) {\n  return p(r);\n}\n</code></pre><p>其实，这么做就是实现了operator | 的操作符重载，可以针对特定类型的R与P，将R | P这种表达式转换为P(R）。</p><p>如果你希望支持所有的Range视图，那么可以使用concept将该函数定义成后面的形式。</p><pre><code class=\"language-c++\">template &lt;std::ranges::viewable_range R&gt;\nauto operator | (R r, P p) {\n  return p(r);\n}\n</code></pre><p>看，这不就实现了跟range适配器闭包对象一样的效果了嘛。</p><p>只不过，这种方式要求我们定义一个类型P，作为操作符重载的“占位符”。因此，在这里我们又总结出一个新的概念——将这种不是视图，但为了模拟range适配器闭包对象，而创建的类似于range适配器闭包的类型，称之为“仿range适配器闭包”。</p><p>这是受到了C++的仿函数的启发，也是通过()操作符重载来模仿函数行为。虽然需要一些技巧，不过在编译器支持C++23之前，在现阶段我们还需要这种变通方式，希望你能掌握这种编程技巧。</p><h2>总结</h2><p>这一讲，我们结合一个简单的统计分析程序案例。为了方便你对比，在算法模块我还给出了过程化实现方案和传统STL函数式的实现方案。</p><p>通过这一讲的学习，相信你已经直观地感受到了Ranges的强大功能。Ranges可以大幅提高C++中函数式编程的代码可读性，降低代码复杂度，提高函数式编程效率。我们可以通过Ranges库中的视图来简化数据处理过程，并利用管道来替换原有的过程化衔接。</p><p>在处理大规模数据的时候，利用Ranges库我们几乎可以避免声明临时变量。现在，C++中的函数式编程变得更加现代，也跟其他支持函数式编程语言一样，实现了类似的编程范式。其实Ranges还有更多使用场景，期待你在日常开发中多多探索。</p><h2>课后思考</h2><p>我们在一讲中使用Ranges库实现了对数据集合的处理。那么，你能否结合Ranges库实现以下功能？</p><p>1.输入一组数据，数据由一系列的字符串组成，每个字符串是一个句子。比如：</p><ul>\n<li>“ C++ 20 is much more powerful than ever before ”</li>\n<li>“ I am learning C++ 20, C++ 23 and C++ 26 ”</li>\n</ul><p>2.剔除每个字符串中的数字，返回新的数组。</p><p>3.处理的过程中，结合C++ Coroutines来实现异步处理（你可以尝试复用前面课程的代码）。</p><p>欢迎把你的代码贴出来，与大家一起分享。我们一同交流。下一讲见！</p>","comments":[{"had_liked":false,"id":387066,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1706348285,"is_pvip":false,"replies":[{"id":141128,"content":"点赞","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1706891133,"ip_address":"上海","comment_id":387066,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"按照老师上次留言给出的指导意见，已修改代码，这里给出关键代码：\n协程类修改成下面的代码，注意 final_suspend 的返回值需要修改成suspend_always，否则在我的这个使用场景中，协程退出时会抛异常：\nexport struct Coroutine {\n    struct promise_type {\n        std::string _value;\n        \n        Coroutine get_return_object() {\n            return {\n                ._handle = std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)\n            };\n        }\n\n        std::suspend_never initial_suspend() { return {}; }\n        std::suspend_always final_suspend() noexcept { return {}; }\n\n        std::suspend_always yield_value(std::string value) {\n            _value = RemoveNumber(value);\n            return {};\n        }\n\n        void return_void() {}\n        void unhandled_exception() {}\n    };\n\n    std::coroutine_handle&lt;promise_type&gt; _handle;\n};\n\n字符串的处理：\nexport string RemoveNumber(string&amp; input)\n{\n    return input | views::filter([](char ch) {\n        return !isdigit(ch);\n        }) | to&lt;string&gt;();\n}\n\nmain.cpp中的调用：\nCoroutine asyncStr()\n{\n    string input;\n    while (getline(cin, input))\n    {\n        if (input == &quot;End&quot;)\n        {\n            break;\n        }\n        co_yield input;\n    }\n}\n\n\nint main()\n{\n    auto h = asyncStr()._handle;\n    auto&amp; promise = h.promise();\n    while (!h.done())\n    {\n        cout &lt;&lt; &quot;处理结果：&quot; &lt;&lt; promise._value &lt;&lt; endl;\n        h();\n    }\n\n    h.destroy();\n\n    return 0;\n}","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636764,"discussion_content":"点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706891133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386635,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1705242673,"is_pvip":false,"replies":[{"id":140982,"content":"这个基本代码思路没有问题 。\n但是有两个细节需要注意：\n1.过滤数字后没必要先转换成字符串再合并，应该直接合并，否则效率比较低，而且字符之间拼接不应该包含空格\n2.Coroutines的使用有点生硬，其实可以有两个地方采用：\n(1)如果输入字符串是来自于用户输入，那么可以在用户输入这里做I&#47;O异步。\n(2)如果输入字符串是函数的参数并且数量极大，可以借助高性能异步队列在处理计算任务。\n核心是不必要时让出CPU，避免主线程一直阻塞。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1705416481,"ip_address":"上海","comment_id":386635,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"分享一下我的思考题的答案，我这里只给出关键代码：\nexport module asyncString.stringHandle:handler;\n\nimport asyncString.utils;\nimport asyncString.task;\nimport &lt;ctype.h&gt;;\nimport &lt;ranges&gt;;\nimport &lt;algorithm&gt;;\nimport &lt;string&gt;;\nimport &lt;sstream&gt;;\nimport &lt;vector&gt;;\nimport &lt;numeric&gt;;\n\nusing std::vector;\nusing std::string;\nusing std::istringstream;\n\nnamespace asyncString::stringHandle {\n    namespace views = std::ranges::views;\n    namespace ranges = std::ranges;\n\n    using asyncString::utils::views::to;\n    using asyncString::task::asyncify;\n\n    export vector&lt;string&gt; RemoveNumber(vector&lt;string&gt;&amp; vecInput)\n    {\n        return vecInput | views::transform(\n                [](string&amp; str) {\n                    istringstream iss{ str };\n                    ranges::istream_view&lt;string&gt; isView{ iss };\n\n                    auto resultStr = isView | views::transform([](string word) {\n                        return word | views::filter([](char ch) {\n                            return !isdigit(ch);\n                            }) | to&lt;string&gt;();\n                        }) | to&lt;vector&lt;string&gt;&gt;();\n\n                    string iniStr;\n                    string joinStr = std::accumulate(resultStr.begin(), resultStr.end(), iniStr, [](string prev, string&amp; val) {\n                        return prev + &quot; &quot; + val;\n                        });\n\n                    return joinStr;\n                }\n        ) | to&lt;vector&lt;string&gt;&gt;();\n    }\n\n    export auto RemoveNumberAwaiter(vector&lt;string&gt;&amp; inputVec) {\n        return asyncify([&amp;inputVec]() {\n            return RemoveNumber(inputVec);\n            });\n    }\n}\n完整代码，请参阅gitee仓库：https:&#47;&#47;gitee.com&#47;devin21&#47;rangeAssignment&#47;tree&#47;master","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635976,"discussion_content":"这个基本代码思路没有问题 。\n但是有两个细节需要注意：\n1.过滤数字后没必要先转换成字符串再合并，应该直接合并，否则效率比较低，而且字符之间拼接不应该包含空格\n2.Coroutines的使用有点生硬，其实可以有两个地方采用：\n(1)如果输入字符串是来自于用户输入，那么可以在用户输入这里做I/O异步。\n(2)如果输入字符串是函数的参数并且数量极大，可以借助高性能异步队列在处理计算任务。\n核心是不必要时让出CPU，避免主线程一直阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705416481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3201926,"avatar":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","nickname":"李云龙","note":"","ucode":"785924B16BE788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636169,"discussion_content":"我精简了一下代码，提出了下面的这种写法，但是还是要先to&lt;string&gt;(), 因为下面代码的filter返回的不是string，而是视图，不加to&lt;string&gt;, 编译不通过。以下是在Handle.ixx文件中：\nnamespace asyncString::stringHandle {\n    namespace views = std::ranges::views;\n    namespace ranges = std::ranges;\n\n    using asyncString::utils::views::to;\n    using asyncString::task::asyncify;\n\n    export vector&lt;string&gt; RemoveNumber(vector&lt;string&gt;&amp; vecInput)\n    {\n       return vecInput | views::transform(\n           [](string&amp; str) {\n               return str | views::filter([](char ch) {\n                   return !isdigit(ch);\n                   }) | to&lt;string&gt;();\n           }) | to&lt;vector&lt;string&gt;&gt;();\n   }\n通过异步队列的方式使用协程，在main.cpp中：\nCoroutine asyncStr()\n{\n    vector&lt;string&gt; vecInput{ &#34;C++ 20 is much more powerful than ever before &#34;, &#34;I am learning C++ 20, C++ 23 and C++ 26&#34; };\n\n    std::cout &lt;&lt; &#34;[AWAIT] Before: &#34; &lt;&lt; std::endl;\n    auto result = co_await RemoveNumberAwaiter(vecInput);\n    std::cout &lt;&lt; &#34;[AWAIT] After: &#34; &lt;&lt; std::endl;\n\n    for_each(result, [](auto&amp; str) {\n        std::cout &lt;&lt; str &lt;&lt; std::endl;\n        });\n}\n\nint main()\n{\n    asyncStr();\n    AsyncTaskLoop::start();\n\n    return 0;\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705733643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382614,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"广东","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1697678944,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"还是更喜欢传统的方式，可以用不修改原来变量的方式去实现多线程处理","like_count":0}]}