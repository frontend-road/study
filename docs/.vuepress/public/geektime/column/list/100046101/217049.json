{"id":217049,"title":"19 | 基于Raft的分布式KV系统开发实战（一）：如何设计架构？","content":"<p>你好，我是韩健。</p><p>学完前面2讲之后，相信你已经大致了解了Raft算法的代码实现（Hashcorp Raft），也掌握了常用API接口的用法，对Raft算法的理解也更深刻了。那么，是不是掌握这些，就能得心应手的处理实际场景的问题了呢？</p><p>在我看来，掌握的还不够，因为Raft算法的实现只是工具。而掌握了工具的用法，和能使用工具得心应手地处理实际场景的问题，是两回事。也就是说，我们还需要掌握使用Raft算法开发分布式系统的实战能力，然后才能游刃有余的处理实际场景的问题。</p><p>我从这个角度出发，在接下来的2节课中，我会分别从架构和代码实现的角度，以一个基本的分布式KV系统为例，具体说一说，如何基于Raft算法构建一个分布式KV系统。<strong>那么我希望你能课下多动手，自己写一遍，不给自己留下盲区。</strong>如果条件允许的话，你还可以按需开发实现需要的功能，并将这套系统作为自己的“配置中心”“名字路由”维护下去，不断在实战中加深自己对技术的理解。</p><p>可能有同学会问：“老韩，为什么不以Etcd为例呢？它不是已经在生产环境中落地了吗？”</p><p>我是这么考虑的，这个基本的分布式KV系统的代码比较少，相对纯粹聚焦在技术本身，涉及的KV业务层面的逻辑少，适合入门学习（比如你可以从零开始，动手编程实现），是一个很好的学习案例。</p><!-- [[[read_end]]] --><p>另外，对一些有经验的开发者来说，这部分知识能够帮助你掌握Raft算法中，一些深层次的技术实现，比如如何实现多种读一致性模型，让你更加深刻地理解Raft算法。</p><p>今天这节课，我会具体说一说如何设计一个基本的分布式KV系统，也就是需要实现哪些功能，以及在架构设计的时候，你需要考虑哪些点（比如跟随者是否要转发写请求给领导者？或者如何设计接入访问的API？）</p><p>好了，话不多说，一起进入今天的课程吧！</p><p>在我看来，基于技术深度、开发工作量、学习复杂度等综合考虑，一个基本的分布式KV系统，至少需要具备这样几块功能，就像下图的样子。</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/6d/1e8e7cac5c9159aa1dbf9a72cd90416d.jpg?wh=1142*483\" alt=\"\"></p><ul>\n<li>接入协议：供客户端访问系统的接入层API，以及与客户端交互的通讯协议。</li>\n<li>KV操作：我们需要支持的KV操作（比如赋值操作）。</li>\n<li>分布式集群：也就是说，我们要基于Raft算法实现一个分布式存储集群，用于存放KV数据。</li>\n</ul><p>需要你注意的是，这3点就是分布式KV系统的核心功能，也就是我们需要编程实现的需求。</p><p>在我看来，要实现一个基本的分布式KV系统，首先要做的第一件事，就是实现访问接入的通讯协议。因为如果用户想使用这套系统，对他而言的第一件事，就是如何访问这套系统。那么，如何实现访问接入的通讯协议呢？</p><h2>如何设计接入协议？</h2><p>我想说的是，在早些时候，硬件性能低，服务也不是很多，开发系统的时候，主要矛盾是性能瓶颈，所以，更多的是基于性能的考虑，采用UDP协议和实现私有的二进制协议，比如，早期的QQ后台组件，就是这么做的。</p><p>现在呢，硬件性能有了很大幅度的提升，后台服务器的CPU核数都近百了，开发系统的时候，主要的矛盾已经不是性能瓶颈了，而是快速增长的海量服务和开发效率，所以这时，基于开发效率和可维护性的考虑，我们就需要优先考虑标准的协议了（比如HTTP）。</p><p>如果使用HTTP协议，那么就需要设计HTTP RESTful API，作为访问接口。具体怎么设计呢？</p><p>我想说的是，因为我们设计实现的是KV系统，肯定要涉及到KV操作，那么我们就一定需要设计个API（比如\"/key\"）来支持KV操作。也就是说，通过访问这个API，我们能执行相关的KV操作了，就像下面的样子（查询指定key（就是foo）对应的值）。</p><pre><code>curl -XGET http://raft-cluster-host01:8091/key/foo\n</code></pre><p>另外，需要你注意的是，因为这是一个Raft集群系统，除了业务层面（KV操作），我们还需要实现平台本身的一些操作的API接口，比如增加、移除集群节点等。我们现在只考虑增加节点操作的API（比如\"/join\"），就像下面的样子。</p><pre><code>http://raft-cluster-host01:8091/join\n</code></pre><p>另外，在故障或缩容情况下，如何替换节点、移除节点，我建议你在线下对比着增加节点的操作，自主实现。</p><p>除此之外，在我看来，实现HTTP RESTful API，还有非常重要的一件事情要做，那就是在设计API时，考虑如何实现路由，为什么这么说呢？你这么想象一下，如果我们实现了多个API，比如\"/key\"和\"/join\"，那么就需要将API对应的请求和它对应的处理函数一一映射起来。</p><p>我想说的是，我们可以在serveHTTP()函数（Golang）中，通过检测URL路径，来设置请求对应处理函数，实现路由。大概的原理，就像下面的样子。</p><pre><code>func (s *Service) ServeHTTP(w http.ResponseWriter, r *http.Request) {    // 设置HTTP请求对应的路由信息\n        if strings.HasPrefix(r.URL.Path, &quot;/key&quot;) {\n                s.handleKeyRequest(w, r)\n        } else if r.URL.Path == &quot;/join&quot; {\n                s.handleJoin(w, r)\n        } else {\n                w.WriteHeader(http.StatusNotFound)\n        }\n}\n</code></pre><p>从上面代码中，我们可以看到，当检测到URL路径为“/key”时，会调用handleKeyRequest()函数，来处理KV操作请求；当检测到URL路径为\"/join\"时，会调用handleJoin()函数，将指定节点加入到集群中。</p><p>你看，通过\"/key\"和\"/join\"2个API，我们就能满足这个基本的分布式KV系统的运行要求了，既能支持来自客户端的KV操作，也能新增节点并将集群运行起来。</p><p>当客户端通过通讯协议访问到系统后，它最终的目标，还是执行KV操作。那么，我们该如何设计KV操作呢？</p><h2>如何设计KV操作？</h2><p>我想说的是，常见的KV操作是赋值、查询、删除，也就是说，我们实现这三个操作就可以了，其他的操作可以先不考虑。具体可以这么实现。</p><ul>\n<li><strong>赋值操作：</strong>我们可以通过HTTP POST请求，来对指定key进行赋值，就像下面的样子。</li>\n</ul><pre><code>curl -XPOST http://raft-cluster-host01:8091/key -d '{&quot;foo&quot;: &quot;bar&quot;}'\n</code></pre><ul>\n<li><strong>查询操作：</strong>我们可以通过HTTP GET请求，来查询指定key的值，就像下面的样子。</li>\n</ul><pre><code>curl -XGET http://raft-cluster-host01:8091/key/foo\n\n</code></pre><ul>\n<li><strong>删除操作：</strong>我们可以通过HTTP DELETE请求，来删除指定key和key对应的值，就像下面的样子。</li>\n</ul><pre><code>curl -XDELETE http://raft-cluster-host01:8091/key/foo\n</code></pre><p>在这里，尤其需要你注意的是，操作需要具有幂等性。幂等性这个词儿你估计不会陌生，你可以这样理解它：同一个操作，不管执行多少次，最终的结果都是一样的，也就是，这个操作是可以重复执行的，而是重复执行不会对系统产生预期外的影响。</p><p>为什么操作要具有幂等性呢？</p><p>因为共识算法能保证达成共识后的值（也就是指令）就不再改变了，但不能保证值只被提交一次，也就是说，共识算法是一个“at least once”的指令执行模型，是可能会出现同一个指令被重复提交的情况，为什么呢？我以Raft算法为例，具体说一说。</p><p>比如，如果客户端接收到Raft的超时响应后，也就是这时日志项还没有提交成功，如果此时它重试，发送一个新的请求，那么这个时候Raft会创建一个新的日志项，并最终将新旧2个日志项都提交了，出现了指令重复执行的情况。</p><p>在这里我想强调的是，你一定要注意到这样的情况，在使用Raft等共识算法时，要充分评估操作是否具有幂等性，避免对系统造成预期外的影响，比如，直接使用“Add”操作，就会因重复提交，导致最终的执行结果不准了，影响到业务。这就可能会出现，用户购买了100Q币，系统却给他充值了500Q币，肯定不行了。</p><p>说完如何设计KV操作后，因为我们的最终目标是实现分布式KV系统，那么，就让我们回到分布式系统最本源的一个问题上，如何实现分布式集群？</p><h2>如何实现分布式集群？</h2><p>我想说的是，正如在09讲中提到的，我推荐使用Raft算法实现分布式集群。而实现一个Raft集群，我们首先要考虑的是如何创建集群，为了简单起见，我们暂时不考虑节点的移除和替换等。</p><p><strong>创建集群</strong></p><p>在Raft算法中，我们可以这样创建集群。</p><ul>\n<li>先将第一个节点，通过Bootstrap的方式启动，并作为领导者节点。</li>\n<li>其他节点与领导者节点通讯，将自己的配置信息发送给领导者节点，然后领导者节点调用AddVoter()函数，将新节点加入到集群中。</li>\n</ul><p>创建了集群后，在集群运行中，因为Raft集群的领导者不是固定不变的，而写请求是必须要在领导者节点上处理的，那么如何实现写操作，来保证写请求都会发给领导者呢？</p><p><strong>写操作</strong><br>\n一般而言，有2种方法来实现写操作。我来具体说说。</p><p><strong>方法1：</strong>跟随者接收到客户端的写请求后，拒绝处理这个请求，并将领导者的地址信息返回给客户端，然后客户端直接访问领导者节点，直到该领导者退位，就像下图的样子。</p><p><img src=\"https://static001.geekbang.org/resource/image/59/c8/591314be65729ae2ca242e5e016e84c8.jpg?wh=1142*515\" alt=\"\"></p><p><strong>方法2：</strong>跟随者接收到客户端的写请求后，将写请求转发给领导者，并将领导者处理后的结果返回给客户端，也就是说，这时跟随者在扮演“代理”的角色，就像下图的样子。</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/96/ac7f6e9226c0dc3f323abb70b9a3b596.jpg?wh=1142*398\" alt=\"\"></p><p>在我看来，虽然第一种方法需要客户端的配合，但实现起来复杂度不高；另外，第二种方法，虽然能降低客户端的复杂度，客户端像访问一个黑盒一样，访问系统，对领导者变更完全无感知。</p><p>但是这个方法会引入一个中间节点（跟随者），增加了问题分析排查的复杂度。而且，一般情况下，在绝大部分的时间内（比如Google Chubby团队观察到的值是数天），领导者是处于稳定状态的，某个节点一直是领导者，那么引入中间节点，就会增加大量的不必要的消息和性能消耗。所以，综合考虑，我推荐方法1。</p><p>学习了Raft算法后，我们知道，相比写操作（只要在领导者节点执行就可以了）而言，读操作要复杂些，因为如何实现读操作，关乎着一致性的实现，也就是说，怎么实现读操作，决定了客户端是否会读取到旧数据。那么如何实现读操作呢？</p><p><strong>读操作</strong><br>\n其实，在实际系统中，并不是实现了强一致性就是最好的，因为实现了强一致性，必然会限制集群的整体性能。也就是说，我们需要根据实际场景特点进行权衡折中，这样，才能设计出最适合该场景特点的读操作。比如，我们可以实现类似Consul的3种读一致性模型。</p><ul>\n<li>default：偶尔读到旧数据。</li>\n<li>consistent：一定不会读到旧数据。</li>\n<li>stale：会读到旧数据。</li>\n</ul><p>如果你不记得这3种模型的含义了，你可以去09讲回顾下，在这里，我就不啰嗦了。</p><p>也就是说，我们可以实现多种读一致性模型，将最终的一致性选择权交给用户，让用户去选择，就像下面的样子。</p><pre><code>curl -XGET http://raft-cluster-host02:8091/key/foo?level=consistent  -L\n</code></pre><h2>内容小结</h2><p>本节课我主要带你了解了一个基本的分布式KV系统的架构，和需要权衡折中的技术细节，我希望你明确的重点如下。</p><p>1.在设计KV操作时，更确切的说，在实现Raft指令时，一定要考虑幂等性，因为Raf指令是可能会被重复提交和执行。</p><p>2.推荐你采用这种方式来实现写操作：跟随者接收到客户端的写请求时，拒绝该请求并返回领导者的地址信息给客户端，然后客户端直接访问领导者。</p><p>3.在Raft集群中，如何实现读操作，关乎一致性的实现，推荐实现default、consistent、stale三种一致性模型，将一致性的选择权交给用户，让用户根据实际业务特点，按需选择，灵活使用。</p><p>最后，我想说的是，这个基本的分布式KV系统，除了适合入门学习外，也比较适合配置中心、名字服务等小数据量的系统。另外我想补充一下，对于数据层组件，不仅性能重要，成本也很重要，而决定数据层组件的成本的最关键的一个理念是冷热分离，一般而言，可以这么设计三级缓存：</p><ul>\n<li>热数据：经常被访问到的数据，我们可以将它们放在内存中，提升访问效率。</li>\n<li>冷数据：有时会被访问到的数据，我们可以将它们放在SSD硬盘上，访问起来也比较快。</li>\n<li>陈旧数据：偶尔会被访问到的数据，我们可以将它们放在普通磁盘上，节省存储成本。</li>\n</ul><p>在实际系统中，你可以统计热数据的命中率，并根据命中率来动态调整冷热模型。在这里，我想强调的是，冷热分离理念在设计海量数据存储系统时尤为重要，比如，自研KV存储的成本仅为Redis数十分之一，其中系统设计时非常重要的一个理念就是冷热分离。希望你能重视这个理念，在实际场景中活学活用。</p><h2>课堂思考</h2><p>我提到了其他节点与领导者节点通讯，将自己的配置信息发送给领导者节点，然后领导者节点调用addVoter()函数，将新节点加入到集群中，那么，你不妨思考一下，当节点故障时，如何替换一个节点呢？欢迎在留言区分享你的看法，与我一同讨论。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"18 | Hashicorp Raft（二）：如何以“集群节点”为中心使用API？","id":215116},"right":{"article_title":"20 | 基于Raft的分布式KV系统开发实战（二）：如何实现代码？","id":218093}},"comments":[{"had_liked":false,"id":206942,"user_name":"zzl","can_delete":false,"product_type":"c1","uid":1814781,"ip_address":"","ucode":"B2F2252973E556","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b0/fd/740245c7.jpg","comment_is_top":false,"comment_ctime":1586960654,"is_pvip":false,"replies":[{"id":"77288","content":"加一颗星:)，问题1，此时访问的领导者可能不是真正的领导者，比如3节点集群（A、B、C），A是领导者，发生了网络分区，B、C选举出了新领导者C，当我们继续加一颗星:)，访问节点A时，A可能仍处于稳定状态（在 leader leasing 时间内），认为自己领导者（其实它已经不是了），这时它返回数据给客户端，这份数据可能不是最新的。问题2：这个说法不严谨，必须确认主节点仍是领导者，但因为zab不支持该功能，所以，这个做法落地性差，已修正。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1586988200,"ip_address":"","comment_id":206942,"utype":1}],"discussion_count":3,"race_medal":0,"score":"61716502798","product_id":100046101,"comment_content":"consul的读一致性default模式，是从leader节点读的，为啥不一定是最新数据呢？zookeeper的leader节点，读取的数据一定是最新的吗？","like_count":15,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491960,"discussion_content":"加一颗星:)，问题1，此时访问的领导者可能不是真正的领导者，比如3节点集群（A、B、C），A是领导者，发生了网络分区，B、C选举出了新领导者C，当我们继续加一颗星:)，访问节点A时，A可能仍处于稳定状态（在 leader leasing 时间内），认为自己领导者（其实它已经不是了），这时它返回数据给客户端，这份数据可能不是最新的。问题2：这个说法不严谨，必须确认主节点仍是领导者，但因为zab不支持该功能，所以，这个做法落地性差，已修正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586988200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2733281,"avatar":"","nickname":"Geek_f4512f","note":"","ucode":"3CB387D2943590","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388991,"discussion_content":"我擦 还有这种情况，那么这种情况该如何检测出来呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629085126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/83/39/f9623363.jpg","nickname":"竹马彦四郎的好朋友影法師","note":"","ucode":"A9555AEFF90CDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259070,"discussion_content":"还在租约内，所以以为自己还是leader，尚未退位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588757538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293453,"user_name":"roseduan","can_delete":false,"product_type":"c1","uid":1246451,"ip_address":"","ucode":"5BB69BB9D329EC","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/f3/a3ff8a58.jpg","comment_is_top":false,"comment_ctime":1621392359,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"35981130727","product_id":100046101,"comment_content":"我使用 Go 语言实现了一个单机版的kv数据库：https:&#47;&#47;github.com&#47;roseduan&#47;rosedb，后续改造为分布式的，多谢老师的指点。也希望大家一起来学习！","like_count":9,"discussions":[{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375958,"discussion_content":"在B站看到你视频了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621906365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2733281,"avatar":"","nickname":"Geek_f4512f","note":"","ucode":"3CB387D2943590","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388995,"discussion_content":"给个链接？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629085489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375958,"ip_address":""},"score":388995,"extra":""}]},{"author":{"id":1363671,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ce/d7/5315f6ce.jpg","nickname":"不负青春不负己🤘","note":"","ucode":"A6DD8E8B20EA6E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551521,"discussion_content":"大佬都工程实践了啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645033580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219856,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1590110974,"is_pvip":true,"replies":[{"id":"86973","content":"加一颗星:)，可以这么理解，更准确的说，Raft实现的是算法逻辑，领导者选举、日志复制、成员变更等。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1595042659,"ip_address":"","comment_id":219856,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10180045566","product_id":100046101,"comment_content":"按照老师的表述以及对源码的理解，是否可以认为 应用层组件与 raft 库的分工<br>1. 应用层负责 设计协议接入层以及FSM 的实现（接入和底层存储）<br>2. raft 负责接入层和持久化之间（raft 也有log存储的部分）","like_count":2,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495966,"discussion_content":"加一颗星:)，可以这么理解，更准确的说，Raft实现的是算法逻辑，领导者选举、日志复制、成员变更等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595042659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203463,"user_name":"lingjiango","can_delete":false,"product_type":"c1","uid":1876016,"ip_address":"","ucode":"202B67F1AACDAB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoz2e0Ka1CFfMIgZ8XHaVukpJm0Upibh68Wplru5a6zv0SkibM668tVaIGdMjpUHN8wEmiaTVtWgiahKQ/132","comment_is_top":false,"comment_ctime":1586215814,"is_pvip":false,"replies":[{"id":"76170","content":"加一颗星:)。问题1：可以容忍少数节点故障，也就是说，当少数节点故障时，系统能稳定运行。问题2：节点故障，需要我们做监控来发现，然后修复的。另外，其实你可以通过20讲的raftdb程序，来测试下Raft的节点故障容错能力，感性体验下。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1586279260,"ip_address":"","comment_id":203463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881183110","product_id":100046101,"comment_content":"节点故障后是不是可以先容忍一部分，在容忍的过程中是不是部分节点又恢复正常了？","like_count":2,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490868,"discussion_content":"加一颗星:)。问题1：可以容忍少数节点故障，也就是说，当少数节点故障时，系统能稳定运行。问题2：节点故障，需要我们做监控来发现，然后修复的。另外，其实你可以通过20讲的raftdb程序，来测试下Raft的节点故障容错能力，感性体验下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586279260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196366,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1464199,"ip_address":"","ucode":"854500026E2187","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhuGLVRYZibOTfMumk53Wn8Q0Rkg0o6DzTicbibCq42lWQoZ8lFeQvicaXuZa7dYsr9URMrtpXMVDDww/132","comment_is_top":false,"comment_ctime":1585275815,"is_pvip":false,"replies":[{"id":"77781","content":"加一颗星:)，冷热的本质区别是访问速度，根据实际场景妥协权衡，比如，可以考虑数据类型，对访问效率要求高的业务数据，全部是热数据，要求不高的，冷数据；另外实现时间局部性，访问到的冷数据，在热数据中停留些时间，再老化，下沉为冷数据。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1587324574,"ip_address":"","comment_id":196366,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880243111","product_id":100046101,"comment_content":"老师，请教您一个问题呀，数据的冷热分离，比如基于时间的日志数据可以比较好区分，如果没有明显时间跨度的数据有什么好办法实现冷热分离吗？或者都有哪些冷热分离的策略可供参考？多谢！","like_count":2,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489276,"discussion_content":"加一颗星:)，冷热的本质区别是访问速度，根据实际场景妥协权衡，比如，可以考虑数据类型，对访问效率要求高的业务数据，全部是热数据，要求不高的，冷数据；另外实现时间局部性，访问到的冷数据，在热数据中停留些时间，再老化，下沉为冷数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587324574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196258,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1585267767,"is_pvip":false,"replies":[{"id":"75557","content":"比如redis、memcached、etcd、zookeeper等。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1585934932,"ip_address":"","comment_id":196258,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5880235063","product_id":100046101,"comment_content":"目前市面上有哪些成熟开源的分布式KV框架可直接用","like_count":2,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489252,"discussion_content":"比如redis、memcached、etcd、zookeeper等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585934932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268264,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","nickname":"GEEKBANG_6638780","note":"","ucode":"952194E56FD8C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215212,"discussion_content":"redis不香么","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585302199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2733281,"avatar":"","nickname":"Geek_f4512f","note":"","ucode":"3CB387D2943590","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389003,"discussion_content":"这都是 分布式产品了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629086657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244014,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1598351931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598351931","product_id":100046101,"comment_content":"可以在多次发出同步日志的时候,都获得超时的恢复,考虑进行节点的替换,在RemoveServer函数中,可以通过传入失效这个节点的集群的ID来进行删除","like_count":0},{"had_liked":false,"id":215883,"user_name":"钟友兵","can_delete":false,"product_type":"c1","uid":1866454,"ip_address":"","ucode":"BFD61236BF448E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/4uiaFspOvPSF8tzalkP0DvCDme7v53eDGkDMsZsibcm31W99Sib2thFe9m3714d4t7qtIcSeyuR1HiaTXZs4TG8enQ/132","comment_is_top":false,"comment_ctime":1589124345,"is_pvip":false,"replies":[{"id":"80032","content":"加一颗星:)，创建集群时，才需要以bootstrap的形式启动，第一个节点是领导者，这是Hashicorp Raft实现的一个功能，方便添加节点创建集群。正常启动，是不需要bootstrap的，领导者由选举产生。具体可以参考下raftdb的Store.Open()的实现。使用Raft，是不需要指定领导者（也就是master的）。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1589234213,"ip_address":"","comment_id":215883,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589124345","product_id":100046101,"comment_content":"韩老师，有点不太明白使用boostrap启动，称为领导者。一般分布式系统，系统安装配置指定master 。这里的话麻烦解释一下","like_count":0,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494594,"discussion_content":"加一颗星:)，创建集群时，才需要以bootstrap的形式启动，第一个节点是领导者，这是Hashicorp Raft实现的一个功能，方便添加节点创建集群。正常启动，是不需要bootstrap的，领导者由选举产生。具体可以参考下raftdb的Store.Open()的实现。使用Raft，是不需要指定领导者（也就是master的）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589232123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207694,"user_name":"华子","can_delete":false,"product_type":"c1","uid":1246520,"ip_address":"","ucode":"91DFE5F9BB8D32","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erY7671v8F2joiaBbnCPsbJ6ExFruIMDsd9HRSORsOZgbzBrKibDibU9CRCGghI56hUiampklDWzMFc4A/132","comment_is_top":false,"comment_ctime":1587139011,"is_pvip":false,"replies":[{"id":"77595","content":"加一颗星:)，我后面做个补充吧。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1587219715,"ip_address":"","comment_id":207694,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587139011","product_id":100046101,"comment_content":"请问老师以后会不会介绍multiple raft group相关内容？","like_count":1,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492210,"discussion_content":"加一颗星:)，我后面做个补充吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587219715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196273,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1585268828,"is_pvip":false,"replies":[{"id":"77633","content":"加一颗星:)，SET操作（比如SET X = 1）具有冥等性的，执行多次，和执行一次，效果是一样的，即使有多个日志项，后面也会去重压缩处理的，不会有影响的。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1587239107,"ip_address":"","comment_id":196273,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1585268828","product_id":100046101,"comment_content":"问老师一个问题，如果POST请求新增一个kv键值对，第一个请求新增成功后，应该会给出成功的响应，但若是重复POST请求，第二次应该会失败，这样怎么保证幂等性呢？","like_count":0,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489255,"discussion_content":"加一颗星:)，SET操作（比如SET X = 1）具有冥等性的，执行多次，和执行一次，效果是一样的，即使有多个日志项，后面也会去重压缩处理的，不会有影响的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587239107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215052,"discussion_content":"个人看法：这个要明确一点，kv 存储，实际的存储不是 Raft 来负责的，是由 service 来负责的，Raft 在 commit 一条日志的时候，会回调 service 层的 Apply 方法（可以说是 Raft 提供的一个 hook，启动 Raft 的时候注入），在 Apply 中，可以得到 log 的内容，然后处理相应的逻辑。\n\n这样处理幂等就容易多了。这个可以在 log 中添加一个请求 ID 之类的东西，然后在 Apply 中实现幂等逻辑。即在 Raft 中，日志是有可能重复的，需要在 service 层来处理幂等。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1585277164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219329,"discussion_content":"post  请求幂等性 一般都会生成一个唯一的ID 标示该请求","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585751309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}