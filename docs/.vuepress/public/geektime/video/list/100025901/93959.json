{"id":93959,"title":"27 | 使用UIGestureRecognizer实现自定义点击与手势","content":"<p><strong>PDF 课件和源代码下载地址：</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/geektime-ios-course\">https://gitee.com/geektime-geekbang/geektime-ios-course</a></p>","comments":[{"had_liked":false,"id":190107,"user_name":"Shnerd","can_delete":false,"product_type":"c3","uid":1440263,"ip_address":"","ucode":"3630276571AF66","user_header":"https://static001.geekbang.org/account/avatar/00/15/fa/07/1d50f530.jpg","comment_is_top":false,"comment_ctime":1584603384,"is_pvip":false,"replies":[{"id":74557,"content":"整体的原因就是因为UIScrollViewContentInsetAdjustmentBehavior这个属性，在项目中我们为了简单演示UIScrollView的滚动属性，没有引入其他的复杂概念，所以没有讲解到这个具体的属性设置。\n\n具体的原因：默认系统会在addsubview之后，就是scrollView展示之前自动的调整Inset，导致了offset的变化，所以初始化的时候，其实整体的页面是下移的。设置了pagingEnabled，系统会自动的处理offset来实现分页的效果.所以对于垂直方向，所以这种自动处理在滑动时会导致之前变化的offset回滚到0。所以就有了上移，而不设置pagingEnabled时系统不会自动调整offset，完全由用户操作，所以就不会出现这种现象。\n\n解决的办法：设置scrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever。在开发过程中的frame布局的项目中，所有的scrollView也都建议设置这个属性。","user_name":"作者回复","user_name_real":"zzz","uid":1041455,"ctime":1585369479,"ip_address":"","comment_id":190107,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"为什么我点击黄色的UIView时view会向上动","like_count":3,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487886,"discussion_content":"整体的原因就是因为UIScrollViewContentInsetAdjustmentBehavior这个属性，在项目中我们为了简单演示UIScrollView的滚动属性，没有引入其他的复杂概念，所以没有讲解到这个具体的属性设置。\n\n具体的原因：默认系统会在addsubview之后，就是scrollView展示之前自动的调整Inset，导致了offset的变化，所以初始化的时候，其实整体的页面是下移的。设置了pagingEnabled，系统会自动的处理offset来实现分页的效果.所以对于垂直方向，所以这种自动处理在滑动时会导致之前变化的offset回滚到0。所以就有了上移，而不设置pagingEnabled时系统不会自动调整offset，完全由用户操作，所以就不会出现这种现象。\n\n解决的办法：设置scrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever。在开发过程中的frame布局的项目中，所有的scrollView也都建议设置这个属性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585369479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159576,"user_name":"VHJM","can_delete":false,"product_type":"c3","uid":1040549,"ip_address":"","ucode":"B8319C44989612","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/a5/da168c0d.jpg","comment_is_top":false,"comment_ctime":1575691011,"is_pvip":false,"replies":[{"id":62015,"content":"target中的self，以及delegate的self 都是指当前这个类，也就是UIViewController。UITapGestureRecognizer简单的理解，就是一个手势，当这个手势被系统检测到的时候，调用Target的action。所以你可以看到代码后面的@selector其实是在当前这个类中的，简单的说就是调用self的某一个selector，当然target可以是任何Object，只要能响应后面的selector就好。至于黄色的View，我们是将UITapGestureRecognizer加到它上面，所以它调用addGestureRecognizer方法，来增加手势。","user_name":"作者回复","user_name_real":"zzz","uid":1041455,"ctime":1576676529,"ip_address":"","comment_id":159576,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"TapGesture 的 target 设置的是 self, 这个 self 指代的不是黄色的 view 吗？\nTapGesture 的 delegate 设置的也是 self，这个 self 指代的是整个 UIViewController 吗？\n怎么两个 self 指代的不一样啊？还是我理解错了","like_count":1,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477103,"discussion_content":"target中的self，以及delegate的self 都是指当前这个类，也就是UIViewController。UITapGestureRecognizer简单的理解，就是一个手势，当这个手势被系统检测到的时候，调用Target的action。所以你可以看到代码后面的@selector其实是在当前这个类中的，简单的说就是调用self的某一个selector，当然target可以是任何Object，只要能响应后面的selector就好。至于黄色的View，我们是将UITapGestureRecognizer加到它上面，所以它调用addGestureRecognizer方法，来增加手势。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576676529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95350,"user_name":"Geek_jg3r26","can_delete":false,"product_type":"c3","uid":1454691,"ip_address":"","ucode":"7D093ED7273CBE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEK5icO2A4K7HYTYfQoagTz7VbtgxfS2ibBqLnKVWwQZgsePibZWFvFJEhPT8BtpQSaFx9IEodyp6c0dw/132","comment_is_top":false,"comment_ctime":1558025893,"is_pvip":false,"replies":[{"id":34414,"content":"最早六月末 最晚七月中旬吧","user_name":"作者回复","user_name_real":"dequanzhu","uid":1041455,"ctime":1558352162,"ip_address":"","comment_id":95350,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"老师 预计什么时候全部就更新完了","like_count":1,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450420,"discussion_content":"最早六月末 最晚七月中旬吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558352162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190105,"user_name":"Shnerd","can_delete":false,"product_type":"c3","uid":1440263,"ip_address":"","ucode":"3630276571AF66","user_header":"https://static001.geekbang.org/account/avatar/00/15/fa/07/1d50f530.jpg","comment_is_top":false,"comment_ctime":1584603246,"is_pvip":false,"replies":[{"id":74558,"content":"加油！","user_name":"作者回复","user_name_real":"zzz","uid":1041455,"ctime":1585369487,"ip_address":"","comment_id":190105,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"最近在学网络知识, 想一次性把新更新的视频看完","like_count":0,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487885,"discussion_content":"加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585369487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185714,"user_name":"Geek_Maggie","can_delete":false,"product_type":"c3","uid":1609708,"ip_address":"","ucode":"3B74088B2C7B93","user_header":"https://static001.geekbang.org/account/avatar/00/18/8f/ec/c30b45d4.jpg","comment_is_top":false,"comment_ctime":1583669436,"is_pvip":false,"replies":[{"id":71755,"content":"这个是gcc的一种扩展，具体可见https:&#47;&#47;gcc.gnu.org&#47;onlinedocs&#47;gcc&#47;Statement-Exprs.html  主要的作用就是优化代码结构，当在代码较多的时候，非常方便阅读。","user_name":"作者回复","user_name_real":"zzz","uid":1041455,"ctime":1583671300,"ip_address":"","comment_id":185714,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"不懂就问：为啥可以这么写——\nview addSubView:({\n      UIView *view = ......;\n      view;\n})","like_count":0,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486473,"discussion_content":"这个是gcc的一种扩展，具体可见https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html  主要的作用就是优化代码结构，当在代码较多的时候，非常方便阅读。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583671300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609708,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/ec/c30b45d4.jpg","nickname":"Geek_Maggie","note":"","ucode":"3B74088B2C7B93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200247,"discussion_content":"好的 谢谢老师 还有个问题是WKWebView的，在网上查了很久不知能否私聊问您一下，QQ：295004646","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583671883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164476,"user_name":"miss","can_delete":false,"product_type":"c3","uid":1256839,"ip_address":"","ucode":"07831674314ECF","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/87/aadb394b.jpg","comment_is_top":false,"comment_ctime":1577003026,"is_pvip":false,"replies":[{"id":67090,"content":"说下我简单的理解哈，视图组件我个人认为就是一些UI视图组成的，可以复用的常用视图单元。我们把这些视图封装成组件的原因，就是为了划分功能边界，方便复用，提升开发效率。当然组件也可以脱离视图，比如iOS中说的组件化，都是业务逻辑维度的，但是也都是为了合理的区分功能进行解耦，方便复用，背后也是为了提升开发效率。所以组件更加想表达的是解耦和边界。而控件我感觉更想表达的是可以进行交互的视图组件，比如按钮、输入框、复选框等等。当然这些‘术语’并不是标准和规范的，我们也大可不必过分的纠结其意义和使用场景，比如你想实现一个类似的输入框的小功能，然后说封装成了组件，或者封装成了控件，应该都是可以接受的。","user_name":"作者回复","user_name_real":"zzz","uid":1041455,"ctime":1579403638,"ip_address":"","comment_id":164476,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"老师，我想问问，iOS中的控件是啥?是不是我们常见的组件呐？","like_count":0,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478783,"discussion_content":"说下我简单的理解哈，视图组件我个人认为就是一些UI视图组成的，可以复用的常用视图单元。我们把这些视图封装成组件的原因，就是为了划分功能边界，方便复用，提升开发效率。当然组件也可以脱离视图，比如iOS中说的组件化，都是业务逻辑维度的，但是也都是为了合理的区分功能进行解耦，方便复用，背后也是为了提升开发效率。所以组件更加想表达的是解耦和边界。而控件我感觉更想表达的是可以进行交互的视图组件，比如按钮、输入框、复选框等等。当然这些‘术语’并不是标准和规范的，我们也大可不必过分的纠结其意义和使用场景，比如你想实现一个类似的输入框的小功能，然后说封装成了组件，或者封装成了控件，应该都是可以接受的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579403638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125237,"user_name":"Rilakkuma","can_delete":false,"product_type":"c3","uid":1241274,"ip_address":"","ucode":"CEF56175ECF174","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/ba/55d67ed2.jpg","comment_is_top":false,"comment_ctime":1566128886,"is_pvip":false,"replies":[{"id":46024,"content":"整体的原因就是因为UIScrollViewContentInsetAdjustmentBehavior这个属性，在项目中我们为了简单演示UIScrollView的滚动属性，没有引入其他的复杂概念，所以没有设置。\n\n具体的原因：默认系统会在addsubview之后，就是scrollView展示之前自动的调整Inset，导致了offset的变化，所以初始化的时候，其实整体的页面是下移的。设置了pagingEnabled，系统会自动的处理offset来实现分页的效果.所以对于垂直方向，所以这种自动处理在滑动时会导致之前变化的offset回滚到0。所以就有了上移，而不设置pagingEnabled时系统不会自动调整offset，完全由用户操作，所以就不会出现这种现象。\n\n解决的办法：设置scrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever。在开发过程中的frame布局的项目中，所有的scrollView也都建议设置这个属性。","user_name":"作者回复","user_name_real":"朱德权","uid":1041455,"ctime":1566177426,"ip_address":"","comment_id":125237,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"为什么我点击黄色的UIView 这个view会向上挪动","like_count":0,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463490,"discussion_content":"整体的原因就是因为UIScrollViewContentInsetAdjustmentBehavior这个属性，在项目中我们为了简单演示UIScrollView的滚动属性，没有引入其他的复杂概念，所以没有设置。\n\n具体的原因：默认系统会在addsubview之后，就是scrollView展示之前自动的调整Inset，导致了offset的变化，所以初始化的时候，其实整体的页面是下移的。设置了pagingEnabled，系统会自动的处理offset来实现分页的效果.所以对于垂直方向，所以这种自动处理在滑动时会导致之前变化的offset回滚到0。所以就有了上移，而不设置pagingEnabled时系统不会自动调整offset，完全由用户操作，所以就不会出现这种现象。\n\n解决的办法：设置scrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever。在开发过程中的frame布局的项目中，所有的scrollView也都建议设置这个属性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566177426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114433,"user_name":"Realtime","can_delete":false,"product_type":"c3","uid":1107989,"ip_address":"","ucode":"CCE761CF2CD804","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/15/c60311ab.jpg","comment_is_top":false,"comment_ctime":1563300921,"is_pvip":false,"replies":[{"id":42532,"content":"整个点击的响应，是根据响应链传递的。在runloop中系统会默认接收事件，然后通过响应链传递给子View，选择合适的View来处理这个事件。而selector以及你说的runtime，则是View在接收到这个事件之后到处理，执行了这个selector的调用。我们传递的selector只是响应之后的业务逻辑，是不会影响响应手势的。","user_name":"作者回复","user_name_real":"dequanzhu","uid":1041455,"ctime":1563845306,"ip_address":"","comment_id":114433,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"老师，您讲的很清楚， 我有一个更深入点儿的问题。那就是既然是selector，那么系统应该是在runtime的时候来响应手势的方法吧。 系统是如何监听到点击方法的呢？","like_count":0,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458661,"discussion_content":"整个点击的响应，是根据响应链传递的。在runloop中系统会默认接收事件，然后通过响应链传递给子View，选择合适的View来处理这个事件。而selector以及你说的runtime，则是View在接收到这个事件之后到处理，执行了这个selector的调用。我们传递的selector只是响应之后的业务逻辑，是不会影响响应手势的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563845306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246710,"user_name":"Geek_3ef812","can_delete":false,"product_type":"c3","uid":2132638,"ip_address":"","ucode":"00339A90F9C117","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ergjleMbtpL8qcTqBxShJ8oD6ibfdSuvu0XZtadpj9AB8JicAIkiaQC837NRmwXPQ689wxqPAHwcAMqw/132","comment_is_top":false,"comment_ctime":1599459574,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"老师，我想设置导航条的标题，给四个tabbar里面的Controller分别单独设置，我只能使用self.tabBarController.navigationItem.title方式设置 设置一个其他四个也被设置了，包括self.navigationItem.rightBarButtonItem单独的设置 有什么好的方式吗？","like_count":1},{"had_liked":false,"id":375733,"user_name":"Geek_b7eb88","can_delete":false,"product_type":"c3","uid":1573715,"ip_address":"北京","ucode":"0EB46381D9B1CB","user_header":"","comment_is_top":false,"comment_ctime":1685933095,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"朱老师，之前学习完课程后，收获很大。目前在手势这方面遇到个疑问。比如我在同一个View上面添加了两个PanGesture，当我在View上滑动时，只有最上层的手势响应了滑动的方法。我想知道这是为什么？手势之间的竞争以及手势失败的原因，好像没有文档写的很明白。并且手势也不像事件响应一样有明确的流程逻辑，所以对于这方面比较疑惑。","like_count":0},{"had_liked":false,"id":304647,"user_name":"Bo","can_delete":false,"product_type":"c3","uid":2076600,"ip_address":"","ucode":"D5DD3300310C02","user_header":"https://static001.geekbang.org/account/avatar/00/1f/af/b8/458866d3.jpg","comment_is_top":false,"comment_ctime":1627530914,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":3,"product_id":100025901,"comment_content":"老师您好，我在使用UIGestureRecognizerDelegate将手势设置为不被响应，但结果为什么还是响应了点击呢？\n我的这部分代码是这样的，\n声明delegate：\n@interface GTRecommendViewController () &lt;UIScrollViewDelegate, UIGestureRecognizerDelegate&gt;\n增加Subsiew：\n            [view addSubview:({\n                UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 100, 100)];\n                view.backgroundColor = [UIColor yellowColor];\n                UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(viewClick)];  &#47;&#47; Target-Action方式；识别Tap手势\n                [view addGestureRecognizer:tapGesture];\n                view;\n            })];\n点击事件：\n- (void)viewClick {\n    NSLog(@&quot;viewClick&quot;);\n}\n不响应手势：\n- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer {\n    return NO;\n}\n","like_count":0,"discussions":[{"author":{"id":2076600,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/af/b8/458866d3.jpg","nickname":"Bo","note":"","ucode":"D5DD3300310C02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386377,"discussion_content":"抱歉，我忘记在Subsiew里声明tapGesture.delegate = self;了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627555716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2076600,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/af/b8/458866d3.jpg","nickname":"Bo","note":"","ucode":"D5DD3300310C02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386376,"discussion_content":"debug发现不会到达return NO;这是为什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627555537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280362,"user_name":"Geek_3e3612","can_delete":false,"product_type":"c3","uid":1563348,"ip_address":"","ucode":"8A6784D31108DA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLYoMZtO0dIsxA7LV3uW9pnvtF9ovb7McUpoI5dR7T1ibel1Yh09xkZykuyzNCeyrpy7TRyPnGRwqw/132","comment_is_top":false,"comment_ctime":1614168380,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100025901,"comment_content":"老师我有个问题想问您，我的net扩展为什么写出来其他的app服务器都不能连接网络了\n","like_count":0}]}