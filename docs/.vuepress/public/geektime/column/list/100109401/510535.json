{"id":510535,"title":"24｜DI Container（12）：如何增补功能？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code>InjectProvider.java:\n\npackage geektime.tdd.di;\n\nimport jakarta.inject.Inject;\nimport java.lang.reflect.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.function.BiFunction;\nimport java.util.stream.Stream;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Stream.concat;\n\nclass InjectionProvider&lt;T&gt; implements ContextConfig.ComponentProvider&lt;T&gt; {\n\n    private Constructor&lt;T&gt; injectConstructor;\n    private List&lt;Field&gt; injectFields;\n    private List&lt;Method&gt; injectMethods;\n    \n    public InjectionProvider(Class&lt;T&gt; component) {\n        if (Modifier.isAbstract(component.getModifiers())) throw new IllegalComponentException();\n        this.injectConstructor = getInjectConstructor(component);\n        this.injectFields = getInjectFields(component);\n        this.injectMethods = getInjectMethods(component);\n        if (injectFields.stream().anyMatch(f -&gt; Modifier.isFinal(f.getModifiers())))  throw new IllegalComponentException();\n        if (injectMethods.stream().anyMatch(m -&gt; m.getTypeParameters().length != 0))  throw new IllegalComponentException();\n    }\n    \n    @Override\n    public T get(Context context) {\n        try {\n            T instance = injectConstructor.newInstance(toDependencies(context, injectConstructor));\n            for (Field field : injectFields)  field.set(instance, toDependency(context, field));\n            for (Method method : injectMethods) method.invoke(instance, toDependencies(context, method));\n            return instance;\n        } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    \n    @Override\n    public List&lt;Class&lt;?&gt;&gt; getDependencies() {\n        return concat(concat(stream(injectConstructor.getParameterTypes()),\n                        injectFields.stream().map(Field::getType)),\n                injectMethods.stream().flatMap(m -&gt; stream(m.getParameterTypes()))).toList();\n    }\n    \n    private static &lt;T&gt; List&lt;Method&gt; getInjectMethods(Class&lt;T&gt; component) {\n        List&lt;Method&gt; injectMethods = traverse(component, (methods, current) -&gt; injectable(current.getDeclaredMethods())\n                        .filter(m -&gt; isOverrideByInjectMethod(methods, m))\n                        .filter(m -&gt; isOverrideByNoInjectMethod(component, m)).toList());\n        Collections.reverse(injectMethods);\n        return injectMethods;\n    }\n    \n    private static &lt;T&gt; List&lt;Field&gt; getInjectFields(Class&lt;T&gt; component) {\n        return traverse(component, (fields, current) -&gt; injectable(current.getDeclaredFields()).toList());\n    }\n    \n    private static &lt;Type&gt; Constructor&lt;Type&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n        List&lt;Constructor&lt;?&gt;&gt; injectConstructors = injectable(implementation.getConstructors()).toList();\n        if (injectConstructors.size() &gt; 1) throw new IllegalComponentException();\n        return (Constructor&lt;Type&gt;) injectConstructors.stream().findFirst().orElseGet(() -&gt; defaultConstructor(implementation));\n    }\n    \n    private static &lt;Type&gt; Constructor&lt;Type&gt; defaultConstructor(Class&lt;Type&gt; implementation) {\n        try {\n            return implementation.getDeclaredConstructor();\n        } catch (NoSuchMethodException e) {\n            throw new IllegalComponentException();\n        }\n    }\n    \n    private static &lt;T&gt; List&lt;T&gt; traverse(Class&lt;?&gt; component, BiFunction&lt;List&lt;T&gt;, Class&lt;?&gt;, List&lt;T&gt;&gt; finder) {\n        List&lt;T&gt; members = new ArrayList&lt;&gt;();\n        Class&lt;?&gt; current = component;\n        while (current != Object.class) {\n            members.addAll(finder.apply(members, current));\n            current = current.getSuperclass();\n        }\n        return members;\n    }\n    \n    private static &lt;T extends AnnotatedElement&gt; Stream&lt;T&gt; injectable(T[] declaredFields) {\n        return stream(declaredFields).filter(f -&gt; f.isAnnotationPresent(Inject.class));\n    }\n    \n    private static boolean isOverride(Method m, Method o) {\n        return o.getName().equals(m.getName()) &amp;&amp; Arrays.equals(o.getParameterTypes(), m.getParameterTypes());\n    }\n    \n    private static &lt;T&gt; boolean isOverrideByNoInjectMethod(Class&lt;T&gt; component, Method m) {\n        return stream(component.getDeclaredMethods()).filter(m1 -&gt; !m1.isAnnotationPresent(Inject.class)).noneMatch(o -&gt; isOverride(m, o));\n    }\n    \n    private static boolean isOverrideByInjectMethod(List&lt;Method&gt; injectMethods, Method m) {\n        return injectMethods.stream().noneMatch(o -&gt; isOverride(m, o));\n    }\n    \n    private static Object[] toDependencies(Context context, Executable executable) {\n        return stream(executable.getParameterTypes()).map(t -&gt; context.get(t).get()).toArray(Object[]::new);\n    }\n    \n    private static Object toDependency(Context context, Field field) {\n        return context.get(field.getType()).get();\n    }\n}\n\nContext.java: \n\npackage geektime.tdd.di;\n\nimport java.util.Optional;\n\npublic interface Context {\n    &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type);\n}\n\nContextConfig.java:\npackage geektime.tdd.di;\n\nimport java.util.*;\nimport static java.util.List.of;\n\npublic class ContextConfig {\n    private Map&lt;Class&lt;?&gt;, ComponentProvider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n    public &lt;Type&gt; void bind(Class&lt;Type&gt; type, Type instance) {\n        providers.put(type, (ComponentProvider&lt;Type&gt;) context -&gt; instance);\n    }\n    public &lt;Type, Implementation extends Type&gt;\n    void bind(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation) {\n        providers.put(type, new InjectionProvider&lt;&gt;(implementation));\n    }\n    public Context getContext() {\n        providers.keySet().forEach(component -&gt; checkDependencies(component, new Stack&lt;&gt;()));\n        return new Context() {\n            @Override\n            public &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type) {\n                return Optional.ofNullable(providers.get(type)).map(provider -&gt; (Type) provider.get(this));\n            }\n        };\n    }\n    private void checkDependencies(Class&lt;?&gt; component, Stack&lt;Class&lt;?&gt;&gt; visiting) {\n        for (Class&lt;?&gt; dependency: providers.get(component).getDependencies()) {\n            if (!providers.containsKey(dependency)) throw new DependencyNotFoundException(component, dependency);\n            if (visiting.contains(dependency)) throw new CyclicDependenciesFoundException(visiting);\n            visiting.push(dependency);\n            checkDependencies(dependency, visiting);\n            visiting.pop();\n        }\n    }\n    interface ComponentProvider&lt;T&gt; {\n        T get(Context context);\n        default List&lt;Class&lt;?&gt;&gt; getDependencies() {\n            return of();\n        }\n    }\n}\n</code></pre><p>任务列表的状态为：</p><ul>\n<li>\n<p><s>无需构造的组件——组件实例</s></p>\n</li>\n<li>\n<p><s>如果注册的组件不可实例化，则抛出异常</s></p>\n<ul>\n<li><s>抽象类</s></li>\n<li><s>接口</s></li>\n</ul>\n</li>\n<li>\n<p><s>构造函数注入</s></p>\n<ul>\n<li><s>无依赖的组件应该通过默认构造函数生成组件实例</s></li>\n<li><s>有依赖的组件，通过Inject标注的构造函数生成组件实例</s></li>\n<li><s>如果所依赖的组件也存在依赖，那么需要对所依赖的组件也完成依赖注入</s></li>\n<li><s>如果组件有多于一个Inject标注的构造函数，则抛出异常</s></li>\n<li><s>如果组件没有Inject标注的构造函数，也没有默认构造函数（新增任务）</s></li>\n<li><s>如果组件需要的依赖不存在，则抛出异常</s></li>\n<li><s>如果组件间存在循环依赖，则抛出异常</s></li>\n</ul>\n</li>\n<li>\n<p><s>字段注入</s></p>\n<ul>\n<li><s>通过Inject标注将字段声明为依赖组件</s></li>\n<li><s>如果字段为final则抛出异常</s></li>\n<li><s>依赖中应包含Inject Field声明的依赖</s></li>\n</ul>\n</li>\n<li>\n<p><s>方法注入</s></p>\n<ul>\n<li><s>通过Inject标注的方法，其参数为依赖组件</s></li>\n<li><s>通过Inject标注的无参数方法，会被调用</s></li>\n<li><s>按照子类中的规则，覆盖父类中的Inject方法</s></li>\n<li><s>如果方法定义类型参数，则抛出异常</s></li>\n<li><s>依赖中应包含Inject Method声明的依赖</s></li>\n</ul>\n</li>\n<li>\n<p>对Provider类型的依赖</p>\n<ul>\n<li>从容器中取得组件的Provider（新增任务）</li>\n<li>注入构造函数中可以声明对于Provider的依赖</li>\n<li>注入字段中可以声明对于Provider的依赖</li>\n</ul>\n</li>\n<li>\n<p>注入方法中可声明对于Provider的依赖对Provider类型的依赖</p>\n<ul>\n<li>可从容器中获取依赖的Provider（新增任务）</li>\n<li>注入构造函数中可以声明对于Provider的依赖</li>\n<li>注入字段中可以声明对于Provider的依赖</li>\n<li>注入方法中可声明对于Provider的依赖</li>\n</ul>\n</li>\n<li>\n<p>自定义Qualifier的依赖</p>\n<ul>\n<li>注册组件时，可额外指定Qualifier</li>\n<li>注册组件时，可从类对象上提取Qualifier</li>\n<li>寻找依赖时，需同时满足类型与自定义Qualifier标注</li>\n<li>支持默认Qualifier——Named</li>\n</ul>\n</li>\n<li>\n<p>Singleton生命周期</p>\n<ul>\n<li>注册组件时，可额外指定是否为Singleton</li>\n<li>注册组件时，可从类对象上提取Singleton标注</li>\n<li>对于包含Singleton标注的组件，在容器范围内提供唯一实例</li>\n<li>容器组件默认不是Single生命周期</li>\n</ul>\n</li>\n<li>\n<p>自定义Scope标注</p>\n<ul>\n<li>可向容器注册自定义Scope标注的回调</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><h2>视频演示</h2><p>让我们进入今天的部分：</p><p><video poster=\"https://media001.geekbang.org/c6a2696c59974d878fba18873c7ae6ed/snapshots/14248d3978e742bc87fae524388f4f14-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/60e9ef0b-18083bc1e68-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/79adeaea9bdf4e028b64fc54b5a22196/9cfdfcf4524e42a5bb74024a21e3bd93-0ebfdcafe32f54b9726a647d10cf22b0-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>从任务上看，我们是否存在什么遗漏？</p><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码的链接分享出来。相信经过你的思考与实操，学习效果会更好！</p>","neighbors":{"left":{"article_title":"23｜DI Container（11）：如何对ContainerTest进行文档化改造？","id":510518},"right":{"article_title":"25｜DI Container（13）：任务上的遗漏该怎么处理？","id":510556}},"comments":[{"had_liked":false,"id":344909,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1651849456,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"神奇的方法\n\nstatic abstract class TypeLiteral&lt;T&gt; {\n    public ParameterizedType getType() {\n        return (ParameterizedType)((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n    }\n}\n\nParameterizedType type = (ParameterizedType) new TypeLiteral&lt;Provider&lt;Component&gt;&gt;() {}.getType();\n\nassertEquals(Provider.class, type.getRawType());\nassertEquals(Component.class, type.getActualTypeArguments()[0]);","like_count":2},{"had_liked":false,"id":344546,"user_name":"张铁林","can_delete":false,"product_type":"c1","uid":1108258,"ip_address":"","ucode":"4AB8BC6CDAC0A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/22/7606c6ba.jpg","comment_is_top":false,"comment_ctime":1651640707,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"跟着敲完，都不知道在干啥了，必须要回来多练才清楚","like_count":1},{"had_liked":false,"id":355850,"user_name":"蝴蝶","can_delete":false,"product_type":"c1","uid":1193167,"ip_address":"广东","ucode":"8019924D99182F","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","comment_is_top":false,"comment_ctime":1661785095,"is_pvip":true,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"15分钟左右，我不明白为啥provider.get(this)能强转成(Provider&lt;Object&gt;)。一个是 ComponentProvider，一个是 Provider，没有继承，没有同名方法，又不是 python 的 ducktype。困惑啊","like_count":0,"discussions":[{"author":{"id":1113827,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/e3/7da333ae.jpg","nickname":"邱柏森","note":"","ucode":"ED91FEEC083F3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591898,"discussion_content":"是 ()-&gt;provider.get(this) 这个lambda 强转了 Provider&lt;Object&gt;, 完整代码是 \n\n       public &lt;Type&gt; Optional&lt;Provider&lt;Type&gt;&gt; get(ParameterizedType type) {\n                if(type.getRawType() != Provider.class) return Optional.empty();\n                Class&lt;?&gt; componentType = (Class&lt;?&gt;) type.getActualTypeArguments()[0];\n                return Optional.ofNullable(providers.get(componentType)).map(it -&gt; (Provider&lt;Type&gt;) () -&gt; (Type) it.get(this));\n            }\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666923618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355848,"user_name":"蝴蝶","can_delete":false,"product_type":"c1","uid":1193167,"ip_address":"广东","ucode":"8019924D99182F","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","comment_is_top":false,"comment_ctime":1661784285,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"        @Test\n        public void should_retrieve_bind_as_provider() {\n            Component instance = new Component() {\n            };\n            config.bind(Component.class, instance);\n            Context context = config.getContext();\n\n            ParameterizedType type = new TypeLiteral&lt;Provider&lt;Component&gt;&gt;() {}.getType();\n\n            Provider&lt;Component&gt; provider = (Provider&lt;Component&gt;) context.get(type).get();\n            assertSame(provider.get(), instance);\n\n        }\n\n        static abstract class TypeLiteral&lt;T&gt; {\n\n            public ParameterizedType getType() {\n                return (ParameterizedType) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n            }\n        }\n       public Optional get(ParameterizedType type) {\n                Class&lt;?&gt; componentClass = (Class&lt;?&gt;) type.getActualTypeArguments()[0];\n                return Optional.ofNullable(providers.get(componentClass))\n                        .map(provider -&gt; provider.get(this));\n            }\n抛出了异常信息：\njava.lang.ClassCastException: class xxx.ContainerTest$DependencyInject$2 cannot be cast to class jakarta.inject.Provider (com.coolme.di.ContainerTest$DependencyInject$2 and jakarta.inject.Provider are in unnamed module of loader &#39;app&#39;)\n\n有踩过坑的小伙伴吗？","like_count":0}]}