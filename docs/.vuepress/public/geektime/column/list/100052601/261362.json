{"id":261362,"title":"22 | Liskov替换原则：用了继承，子类就设计对了吗？","content":"<p>你好！我是郑晔。</p><p>上一讲，我们讲了开放封闭原则，想要让系统符合开放封闭原则，最重要的就是我们要构建起相应的扩展模型，所以，我们要面向接口编程。</p><p>而大部分的面向接口编程要依赖于继承实现，虽然我们在前面的课程中说过，继承的重要性不如封装和多态，但在大部分面向对象程序设计语言中，继承却是构建一个对象体系的重要组成部分。</p><p>理论上，在定义了接口之后，我们就可以把继承这个接口的类完美地嵌入到我们设计好的体系之中。然而，用了继承，子类就一定设计对了吗？事情可能并没有这么简单。</p><p>新的类虽然在语法上声明了一个接口，形成了一个继承关系，但我们要想让这个子类真正地扮演起这个接口的角色，还需要有一个好的继承指导原则。</p><p>所以，这一讲，我们就来看看可以把继承体系设计好的设计原则：Liskov替换法则。</p><h2>Liskov替换原则</h2><p>2008年，图灵奖授予Barbara Liskov，表彰她在程序设计语言和系统设计方法方面的卓越工作。她在设计领域影响最深远的就是以她名字命名的Liskov替换原则（Liskov substitution principle，简称LSP）。</p><p>1988 年，Barbara Liskov在描述如何定义子类型时写下这样一段话：</p><!-- [[[read_end]]] --><blockquote>\n<p>这里需要如下替换性质：若每个类型S的对象o1，都存在一个类型T的对象o2，使得在所有针对T编程的程序P中，用o1替换o2后，程序P行为保持不变，则S是T的子类型。</p>\n</blockquote><p>用通俗的讲法来说，意思就是，子类型（subtype）必须能够替换其父类型（base type）。</p><p>这句话看似简单，但是违反这个原则，后果是很严重的，比如，父类型规定接口不能抛出异常，而子类型抛出了异常，就会导致程序运行的失败。</p><p>虽然很好理解，但你可能会有个疑问，我的子类型不都是继承自父类型，咋就能违反LSP呢？这个LSP是不是有点多此一举呢？</p><p>我们来看个例子，有不少的人经常写出类似下面这样的代码：</p><pre><code>void handle(final Handler handler) {\n  if (handler instanceof ReportHandler) {\n    // 生成报告\n    ((ReportHandler)handler).report();\n    return;\n  }\n  \n  if (handler instanceof NotificationHandler) {\n    // 发送通知\n    ((NotificationHandler)handler).sendNotification();\n  }\n  ...\n}\n</code></pre><p>根据上一讲的内容，这段代码显然是违反了OCP的。另外，在这个例子里面，虽然我们定义了一个父类型Handler，但在这段代码的处理中，是通过运行时类型识别（Run-Time Type Identification，简称 RTTI），也就是这里的instanceof，知道子类型是什么的，然后去做相应的业务处理。</p><p>但是，ReportHandler和NotificationHandler虽然都是Handler的子类，但<strong>它们没有统一的处理接口</strong>，所以，它们之间并不存在一个可以替换的关系，这段代码也是违反LSP的。这里我们就得到了一个经验法则，<strong>如果你发现了任何做运行时类型识别的代码，很有可能已经破坏了LSP</strong>。</p><h2>基于行为的IS-A</h2><p>如果你去阅读关于LSP的资料，很有可能会遇到一个有趣的问题，也就是长方形正方形问题。在我们对于几何通常的理解中，正方形是一种特殊的长方形。所以，我们可能会写出这样的代码：</p><pre><code>class Rectangle {\n  private int height;\n  private int width;\n  \n  // 设置长度\n  public void setHeight(int height) {\n    this.height = height;\n  }\n  \n  // 设置宽度\n  public void setWidth(int width) {\n    this.width = width;\n  }\n  \n  //\n  public int area() {\n    return this.height * this.width;\n  }\n}\n\nclass Square extends Rectangle {\n  // 设置边长\n  public void setSide(int side) {\n    this.setHeight(side);\n    this.setWidth(side);\nt\n  }\n  \n  @Override\n  public void setHeight(int height) {\n    this.setSide(height);\n  }\n\n  @Override\n  public void setWidth(int width) {\n    this.setSide(width);\n  }\n}\n</code></pre><p>这段代码看上去一切都很好，然而，它却是有问题的，因为它在下面这个测试里会失败：</p><pre><code>Rectangle rect = new Square();\nrect.setHeight(4); // 设置长度\nrect.setWidth(5);  // 设置宽度\nassertThat(rect.area(), is(20)); // 对结果进行断言\n</code></pre><p>如果想保证断言（assert）的正确性，Rectangle和Square二者在这里是不能互相替换的。使用Rectangle的代码必须知道自己使用的到底是Rectangle还是Square。</p><p>出现这个问题的原因就在于，我们构建模型时，会理所当然地把我们直觉中的模型直接映射到代码模型上。在我们直觉中，正方形确实是一种长方形。</p><p>在我们设计的这个对象体系中，边长是可以调整的。然而，在几何的体系里面，长方形的边长是不能随意改变的，设置好了就是设置好了。换句话说，两个体系内，“长方形”的行为是不一致的。所以，在这个对象体系中，正方形边长即使可以调整，但正方形也并不是一个长方形，也就是说，它们之间不满足IS-A关系。</p><p>你可能听说过继承要符合IS-A的关系，也就是说，<strong>如果A是B的子类，就需要满足A是一个B（A is a B）</strong>。但你有没有想过，凭什么A是一个B呢？判断依据从何而来呢？</p><p>你应该知道，这种判定显然不能依靠直觉。其实，从前面的分析中，你也能看出一些端倪来，<strong>IS-A的判定是基于行为的</strong>，只有行为相同，才能说是满足IS-A的关系。</p><p>这个道理说起来很简单，但在实际的工作中，我们时常就会走上歧途。我给你举个例子，我要做一个图片制作的网站，创作者可以在上面创作自己的内容，还可以发布自己创作的一些素材在网站上销售。显然，这个网站要提供一个销售的能力，那这个可以销售的素材算不算商品呢？</p><p>如果站在销售的角度看，它确实是一个商品，我们需要给它定价，需要让它支持后续的购买行为等等。从行为上看，素材也确实是商品，但它又与创作相关，我们需要知道它的作者是谁，需要知道它所应用的不同创作阶段等等，这些行为又与商品完全无关。</p><p>其实，在我们分析问题的时候，答案就已经呼之欲出了。这里的“素材”就不是一个“素材”，前面讲SRP的时候，我们已经做过类似的分析了，虽然我们在讨论的时候，用的是一个词“素材”，但创作者和销售却是两个不同的领域。</p><p>所以，如果我们把“素材”做一个拆分，这个问题就迎刃而解了。一个是“创作者素材”，一个是“可销售素材”，显然，“可销售素材”是一种商品，而“创作者素材”不是。</p><p>这是一种常见的概念混淆。产品经理在描述一个需求时，可能并不会注意到这是两个不同领域的概念，而程序员如果不好好分析一下，在概念上就会走偏，后续的问题将无穷无尽。</p><p>所以，IS-A这个关系理解起来并不难，但在实际工作中，当它和其他一些问题混在一起的时候，它就不像看起来那么简单了。</p><p>到这里，你应该对LSP原则有了一些理解，<strong>要满足LSP，首先这个对象体系要有一个统一的接口，而不能各行其是，其次，子类要满足IS-A的关系</strong>。</p><p>有了对LSP的理解，你再用它去衡量一些设计，就会发现一些问题。比如，程序员们最常用的数据结构List，很多人都习惯地把它当做接口传来传去。在绝大多数场景下，使用它的目的只是为了传递一些数据，也就是为了从中读取数据，但List接口本身一般都有写的方法。</p><p>所以，尽管你的目的是读，但还是有人不小心写了，就会导致一些奇怪的问题。Google的Guava库提供了一个ImmutableList，在概念上做了改进。但为了配合现有的各种程序，它不得不继承自List接口，实际上，根本的问题并没有得到完全的解决。</p><p>还有一类常见的违反LSP的问题，就是继承数据结构。比如，我要实现包含多个学生的类，结果声明成：</p><pre><code>class Students extends ArrayList&lt;Student&gt; {\n  ...\n}\n</code></pre><p>这是一种非常直觉的设计，只要一继承ArrayList，添加、获取的方法就都有了。但从我们前面讲的内容上来看，这显然是不好的，因为Students不是一个ArrayList，不能满足IS-A关系。这种做法想做的就是实现继承，而我们在前面讲继承的时候，就说过这种做法的问题。</p><p>你会发现，LSP的关注点让人把注意力放到父类上，而一旦子类成了重点，我们必须小心谨慎。在前面讲继承的时候，我们说过，关心子类是一种实现继承的表现，而实现继承是我们要努力摒弃的，接口继承才是我们的努力方向，而做好接口继承，显然会更符合LSP。</p><h2>更广泛的LSP</h2><p>如果理解了LSP，你会发现，它不仅适用于类级别的设计，还适用于更广泛的接口设计。比如，我们在开发中经常会遇到系统集成的问题，有不同的厂商都要通过REST接口把他们的统计信息上报到你的系统中，但是，有一个大厂上报的消息格式没法遵循你定义的格式，因为他的系统改动起来难度比较大。你该怎么办呢？</p><p>也许，专门为大厂设计一个特定接口是最简单的想法，但是，一旦开了这个口子，后面的各种集成接口都要为这个大厂开发一份特殊的，而且，如果未来再有其他大厂也提出要求，你要不要为它们也设计特殊接口呢？事实上，很多项目功能不多，但接口特别多，就是因为在这种决策的时候开了口子。<strong>请记住，公开接口是最宝贵的资源，千万不能随意添加</strong>。</p><p>如果我们用LSP的角度看这个问题，通用接口就是一个父类接口，而不同厂商的内容就相当于一个个子类。让厂商面对特定接口，系统将变得无法维护。后期随着人员变动，接口只会更加膨胀，到最后，没有人说清楚每个接口到底是做什么的。</p><p>好，那我们决定采用统一的接口，可是不同的消息格式该怎么处理呢？首先，我们需要区分出不同的厂商，办法有很多，无论是通过REST的路径，还是HTTP头的方式，我们可以得到一个标识符。然后呢？</p><p>很容易想到的做法就是写出一个if语句来，像下面这样：</p><pre><code>if (identfier.equals(&quot;SUPER_VENDOR&quot;)) {\n  ...\n}\n</code></pre><p>但是，千万要遏制自己写if的念头，一旦开了这个头，后续的代码也将变得难以维护。我们可以做的是，提供一个解析器的接口，根据标识符找到一个对应的解析器，像下面这样：</p><pre><code>RequestParser parser = parsers.get(identifier);\nif (parser != null) {\n  return parser.parse(request);\n}\n</code></pre><p>这样一来，即便有其他厂商再因为某些奇怪的原因要求有特定的格式，我们要做的只是提供一个新的接口实现。这样一来，所有代码的行为就保持了一致性，核心的代码结构也保持了稳定。</p><p><strong>总结时刻</strong></p><p>今天，我们讲了Liskov替换原则，其主要意思是说子类型必须能够替换其父类型。</p><p>理解LSP，我们需要站在父类的角度去看，而站在子类的角度，常常是破坏LSP的做法，一个值得警惕的现象是，代码中出现RTTI相关的代码。</p><p>继承需要满足IS-A的关系，但IS-A的关键在于行为上的一致性，而不能单纯凭日常的概念或直觉去理解。</p><p>LSP不仅仅可以用在类关系的设计上，我们还可以把它用在更广泛的接口设计中。任何接口都是宝贵的，在设计时，都要精心考量。</p><p>这一讲，你可以看到LSP的根基在于继承，但显然接口继承才是重点。那我们该如何设计接口呢？我们下一讲来讨论。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>用父类的角度去思考，设计行为一致的子类</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/00/bcfbb2358f37ae40383fe89bccedb400.jpg?wh=2284*1517\" alt=\"\"></p><h2>思考题</h2><p>在今天的内容中，我们提到了长方形正方形问题，我只分析了这个做法有问题的地方，现在我把解决这个问题的机会留给你，请你来动动脑，欢迎在留言区写下你的解决方案。</p><p>感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"21 | 开放封闭原则：不改代码怎么写新功能？","id":261238},"right":{"article_title":"23 | 接口隔离原则：接口里的方法，你都用得到吗？","id":263444}},"comments":[{"had_liked":false,"id":235202,"user_name":"zcc","can_delete":false,"product_type":"c1","uid":1046664,"ip_address":"","ucode":"58FB42400517A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/88/96b870fd.jpg","comment_is_top":false,"comment_ctime":1594943917,"is_pvip":false,"replies":[{"id":"87012","content":"嗯，这个解决方案的味道不错。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595116468,"ip_address":"","comment_id":235202,"utype":1}],"discussion_count":1,"race_medal":0,"score":"87494289837","product_id":100052601,"comment_content":"那从父类的角度来考虑的话，应该是定义一个几何图形的接口，接口有计算面积的方法。然后长方形、正方形、圆形、三角形……都实现这个接口，然后各自实现计算面积的方法。各自有自己特别的关键属性，根据属性计算各自面积:长*宽、边长²、πr²、(底长*高)&#47;2、……","like_count":20,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501638,"discussion_content":"嗯，这个解决方案的味道不错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595116468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255874,"user_name":"Janenesome","can_delete":false,"product_type":"c1","uid":1276572,"ip_address":"","ucode":"15D2673CC31D9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/9c/a4bc748d.jpg","comment_is_top":false,"comment_ctime":1603448386,"is_pvip":false,"replies":[{"id":"100112","content":"这个观点真好！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611719376,"ip_address":"","comment_id":255874,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53143055938","product_id":100052601,"comment_content":"千万要遏制自己写 if 的念头，一旦开了这个头，后续的代码也将变得难以维护。刚好前段时间看到过一种说法：以多态应用为荣，以分支判断为耻。哈哈","like_count":13,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507859,"discussion_content":"这个观点真好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611719376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240436,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1596925526,"is_pvip":false,"replies":[{"id":"88754","content":"非常好的经验总结！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1596936613,"ip_address":"","comment_id":240436,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44546598486","product_id":100052601,"comment_content":"时刻提醒自己: 千万要遏制写if的念头","like_count":11,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503445,"discussion_content":"非常好的经验总结！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596936613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250573,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1601134810,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"31665905882","product_id":100052601,"comment_content":"刚知道 Liskov 是位女士，我原来记的是“里氏科夫”，所以就想当然的以为是男的了。<br><br>以前在考虑继承或者子类的时候，其实没有想到要“行为相同”，更多的是把相同的方法提取到父类，自以为 DRY，洋洋自得。<br><br>“创作者素材”和“可销售素材”这个例子有点晦涩了，经过文中的分析，能看明白是两个领域，但是还是有一点疑惑，这两种素材之间不可以转换么？比如从创作者素材转为可销售素材？<br><br>可能比较简单直接的做法是在素材类里面设置一个状态——是否可销售，不过这样一来的确会给编码带来很多麻烦。<br><br>用解析器代替 if 语句，代码顿时就“高大上”起来了。<br><br>LSP 的重点在于接口继承。<br><br>在专栏后续的依赖倒置原则里面，有一条编码规则：任何类都不应继承自具体类。","like_count":8},{"had_liked":false,"id":247525,"user_name":"段启超","can_delete":false,"product_type":"c1","uid":1258209,"ip_address":"","ucode":"164CF3018071B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","comment_is_top":false,"comment_ctime":1599731625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27369535401","product_id":100052601,"comment_content":"发表一下我的想法：长方形正方形问题反应出的是大多人认为的正方形是一种特殊的长方形，在面向对象的世界中不成立的。面向对象的出发点是对象的行为，只要行为一致，他们就可以是一类东西，这个和《head first 设计模式》一文中开篇的那个各种不同类型的鸭子是一个道理，虽然有的是玩具鸭，有的是实实在在的鸭子， 只要有叫的行为，飞的行为，游泳的行为，那么他们就可以成为“鸭子”。 <br>最近在写代码的过程中发现一个有趣的问题，我们总在对象中依赖各种对象，但是实际上只是依赖了那个对象中的某个行为（方法，或者是能力），依赖的具体类多了，免不了就会把那些不需要的能力引进来；而且具体的类依赖的多了，循环依赖不可避免的就会出现。 所以我想，以后引入某个依赖的时候不妨先考虑一下，我这里需要的真的是这个对象么？ 如果不是，能否把自己需要的那个能力单独放到一个接口或者是一个单独的对象中呢?","like_count":7},{"had_liked":false,"id":237801,"user_name":"桃子-夏勇杰","can_delete":false,"product_type":"c1","uid":1158436,"ip_address":"","ucode":"5D5F38AABA980F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/24/c6b763b4.jpg","comment_is_top":false,"comment_ctime":1595976562,"is_pvip":true,"replies":[{"id":"87916","content":"LSP告诉我们什么样的继承是对的，而继承使用范围太广了。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1596019512,"ip_address":"","comment_id":237801,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18775845746","product_id":100052601,"comment_content":"这个设计原则看着非常简单，提出者居然能获得图灵奖，可见这个设计原则的价值非常大。郑老师，这个设计原则的价值到底有多大呢？","like_count":5,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502544,"discussion_content":"LSP告诉我们什么样的继承是对的，而继承使用范围太广了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596019512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235423,"user_name":"Being","can_delete":false,"product_type":"c1","uid":1152227,"ip_address":"","ucode":"80A8783927B650","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg","comment_is_top":false,"comment_ctime":1595030553,"is_pvip":false,"replies":[{"id":"87006","content":"“把求面积的行为放在Rectangle下，子类分别去实现面积的方法”，可以解决这个问题吗？","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595116238,"ip_address":"","comment_id":235423,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18774899737","product_id":100052601,"comment_content":"全篇一直在强调行为，我想这也是思考题的突破口。长宽是数据，而Rectangle并没有将行为抽象出来，导致Rectangle和Square不能成为IS-A的关系，我们只要把求面积的行为放在Rectangle下，子类分别去实现面积的方法就好了。","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501713,"discussion_content":"“把求面积的行为放在Rectangle下，子类分别去实现面积的方法”，可以解决这个问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595116238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1152227,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg","nickname":"Being","note":"","ucode":"80A8783927B650","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292148,"discussion_content":"是否需要抽象一个shape类，提供计算面积的接口，然后rectangle和square分别作为它的子类实现计算面积接口。同时对于rectangle应该是提供宽高的setter，对于square应该是提供side的setter。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595118366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255872,"user_name":"Janenesome","can_delete":false,"product_type":"c1","uid":1276572,"ip_address":"","ucode":"15D2673CC31D9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/9c/a4bc748d.jpg","comment_is_top":false,"comment_ctime":1603448216,"is_pvip":false,"replies":[{"id":"100113","content":"今天“偷懒”，明天要付出更多。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611719457,"ip_address":"","comment_id":255872,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14488350104","product_id":100052601,"comment_content":"郑老师给出的业务开发的案例真的挺接地气。<br><br>运行时类型识别我以前写过，后面回去维护的时候想打死自己，怎么写出这样的烂代码。<br><br>还有业务分析里的素材分类，太真实了，平时做需求时很多概念有点相似，放在一起好像也可以而且看起来还能省点力气，没有太深入思考的话就会放在一起了，一些差异化的部分就单独存或者用条件判断。","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507858,"discussion_content":"今天“偷懒”，明天要付出更多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611719457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2404924,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b2/3c/22028324.jpg","nickname":"呆呆狗的兽","note":"","ucode":"B7D445F3BE2E4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384568,"discussion_content":"文中展示的是运行时类型识别的不恰当用法，要用这个运行时类型识别，最好是在这个对象符合自己的预期想法时，需要执行的某些操作得以执行，而不是类型强转在执行里面的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626665613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236220,"user_name":"三生","can_delete":false,"product_type":"c1","uid":1606669,"ip_address":"","ucode":"1DE1A2693A5E33","user_header":"https://static001.geekbang.org/account/avatar/00/18/84/0d/4e289b94.jpg","comment_is_top":false,"comment_ctime":1595349787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10185284379","product_id":100052601,"comment_content":"所有的形状都有求面积的方式，但是计算方式都不同，这行为应该是“正常的”，但是设置长和宽的行为不正确，因为长方体有宽和高，正方形只有宽或高，这里只能抽象出计算面积这个方法。<br><br>比如企鹅和麻雀，我们认为所有的鸟都会飞，但企鹅不会飞，而他却具有了飞的行为，这是“不正常”的","like_count":3},{"had_liked":false,"id":235899,"user_name":"monalisali","can_delete":false,"product_type":"c1","uid":1299521,"ip_address":"","ucode":"1FDEC87C133E28","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJbh5FQajwKhNlMrkoSklPpOXBtEYXCLvuWibhfWIS9QxHWDqzhEHJzEdmtUiaiaqFjfpsr2LwgNGpbQ/132","comment_is_top":false,"comment_ctime":1595238752,"is_pvip":false,"replies":[{"id":"87142","content":"不一定，可以通过一个Map实现。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595249835,"ip_address":"","comment_id":235899,"utype":1}],"discussion_count":5,"race_medal":0,"score":"10185173344","product_id":100052601,"comment_content":"RequestParser 中还是免不了用多个 if 来判断 identifier，从而返回特定的子类吧","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501872,"discussion_content":"不一定，可以通过一个Map实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595249835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2404924,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b2/3c/22028324.jpg","nickname":"呆呆狗的兽","note":"","ucode":"B7D445F3BE2E4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384564,"discussion_content":"还可以用枚举，用配置文件，或者用Map<String,Function>提前初始化identifier与Function（子类在这里可以看成是一个function）的关系，总而言之通过代码或配置提前告诉identifier需要的子类，在用的时候直接取","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626665322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1637632,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fd/00/6cff1d24.jpg","nickname":"Y","note":"","ucode":"F57929C11BD34C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294170,"discussion_content":"还可以用list","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595817336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1637632,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fd/00/6cff1d24.jpg","nickname":"Y","note":"","ucode":"F57929C11BD34C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308969,"discussion_content":"list 怎么用？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601134005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294170,"ip_address":""},"score":308969,"extra":""},{"author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":343562,"discussion_content":"RequestParser提供一个方法来告诉外界是否可以处理某个identifier，然后parsers遍历list找到第一个可以处理特定identifier的RequestParser，当然这种方法一般情况下只是实现了功能，并不能算是一个好的设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611073997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":308969,"ip_address":""},"score":343562,"extra":""}]}]},{"had_liked":false,"id":235254,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1594952523,"is_pvip":false,"replies":[{"id":"87010","content":"setter 确实是一个有杀伤力的东西，但回避 setter并不是在解决我们提出的问题。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595116411,"ip_address":"","comment_id":235254,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10184887115","product_id":100052601,"comment_content":"如果业务场景合适，约束功能也不失为一个解决办法。让宽高不可变，初始化时就必须赋值。这样就能符合现实中的特性。自然也没有长宽赋不同值的麻烦。","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501658,"discussion_content":"setter 确实是一个有杀伤力的东西，但回避 setter并不是在解决我们提出的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595116411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346130,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1652851080,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5947818376","product_id":100052601,"comment_content":"用父类的角度去思考，设计行为一致的子类--记下来<br>课后问题: 是否设计一个矩形父类，长方形和正方形都继承矩形呢？","like_count":1,"discussions":[{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579964,"discussion_content":"IShape{length(); area();}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657785319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303207,"user_name":"呆呆狗的兽","can_delete":false,"product_type":"c1","uid":2404924,"ip_address":"","ucode":"B7D445F3BE2E4C","user_header":"https://static001.geekbang.org/account/avatar/00/24/b2/3c/22028324.jpg","comment_is_top":false,"comment_ctime":1626664991,"is_pvip":false,"replies":[{"id":"110014","content":"嗯，这个是关键的。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1627119164,"ip_address":"","comment_id":303207,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5921632287","product_id":100052601,"comment_content":"lsp这一分享，很精髓也很精彩，is-a这个太重要了，遵循is-a会让系统越来越稳定且易拓展","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523588,"discussion_content":"嗯，这个是关键的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627119164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300748,"user_name":"BBQ","can_delete":false,"product_type":"c1","uid":1656804,"ip_address":"","ucode":"683BBF7F7AE370","user_header":"https://static001.geekbang.org/account/avatar/00/19/47/e4/17cb3df1.jpg","comment_is_top":false,"comment_ctime":1625370254,"is_pvip":false,"replies":[{"id":"109369","content":"如果有特定的需求，这么做是没有问题的","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1626186521,"ip_address":"","comment_id":300748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5920337550","product_id":100052601,"comment_content":"关于不同客户的不同格式问题，我们单独开发了一套系统，在这个系统里面做接口格式映射，然后再调用标准接口。<br>由于这个系统的受众是实施人员，所以界面做到可以通过拖拽来实现映射。<br>当然实际功能更多，包括聚合，转换，以及enrich 功能<br>总之，把这个映射的关注点单独独立成了一个系统。","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522806,"discussion_content":"如果有特定的需求，这么做是没有问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626186521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244837,"user_name":"CPP","can_delete":false,"product_type":"c1","uid":1074165,"ip_address":"","ucode":"2313F6BD693F48","user_header":"https://static001.geekbang.org/account/avatar/00/10/63/f5/9c7ef5ce.jpg","comment_is_top":false,"comment_ctime":1598695743,"is_pvip":false,"replies":[{"id":"100665","content":"即便两个函数合成一个，也是有问题的。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1612432253,"ip_address":"","comment_id":244837,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5893663039","product_id":100052601,"comment_content":"两个set函数改成一个，setparam(int height,int width);","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504715,"discussion_content":"即便两个函数合成一个，也是有问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612432253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343558,"discussion_content":"如果调用正方形的setparam，传入的宽高不一样怎么搞2333","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611073540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235230,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1594948257,"is_pvip":false,"replies":[{"id":"87011","content":"长方形和正方形接口不一样，这是一个点。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595116445,"ip_address":"","comment_id":235230,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5889915553","product_id":100052601,"comment_content":"Liskov替换的意思是子类型能够替换父类型，且在继承体系中保持接口的一致<br>长方形与正方形计算面积的行为接口是一样的，但是定义长方形和正方形的接口是不一样的，所以这两个行为可以分别抽离出来","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501648,"discussion_content":"长方形和正方形接口不一样，这是一个点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595116445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357019,"user_name":"三三","can_delete":false,"product_type":"c1","uid":1054201,"ip_address":"北京","ucode":"4A76933C29BDA1","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/f9/0b14785a.jpg","comment_is_top":false,"comment_ctime":1662864622,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662864622","product_id":100052601,"comment_content":"关注父类的行为","like_count":0},{"had_liked":false,"id":344645,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1582420,"ip_address":"","ucode":"349FD35822DC8A","user_header":"https://static001.geekbang.org/account/avatar/00/18/25/54/ef2ca14f.jpg","comment_is_top":false,"comment_ctime":1651702174,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651702174","product_id":100052601,"comment_content":"关于长方形正方形问题的解决思路: <br>- 接口不应该共享; <br>- 如果square要复用rectangle的功能, 通过组合来实现即可;","like_count":0},{"had_liked":false,"id":342008,"user_name":"Nio","can_delete":false,"product_type":"c1","uid":1529642,"ip_address":"","ucode":"A1B8D3C01FB937","user_header":"https://static001.geekbang.org/account/avatar/00/17/57/2a/c6c95f37.jpg","comment_is_top":false,"comment_ctime":1649952127,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1649952127","product_id":100052601,"comment_content":"关注公共的行为<br>这个应该是本文的重点","like_count":0},{"had_liked":false,"id":333681,"user_name":"RainJeyin","can_delete":false,"product_type":"c1","uid":2081744,"ip_address":"","ucode":"91ADCBE48B8848","user_header":"https://static001.geekbang.org/account/avatar/00/1f/c3/d0/10fe80f1.jpg","comment_is_top":false,"comment_ctime":1644472971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644472971","product_id":100052601,"comment_content":"今天这一讲没有看明白，自己还要多学习。","like_count":0},{"had_liked":false,"id":327428,"user_name":"托马斯赵四","can_delete":false,"product_type":"c1","uid":2712653,"ip_address":"","ucode":"F9FA980A9F8A1C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/kBKTRyV4wnhV4YN9iaFgKYIJ4451n0zIiazFumcSpCXdEDhdexgc8PQdrDEmy4BCOUgsUlibicEwQlGo6K5Nibv7SEg/132","comment_is_top":false,"comment_ctime":1640133939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640133939","product_id":100052601,"comment_content":"听到这，使用javascript语言的我还是有些似懂非懂，看来还是得多学多思考","like_count":0},{"had_liked":false,"id":291931,"user_name":"tdd学徒","can_delete":false,"product_type":"c1","uid":1724083,"ip_address":"","ucode":"CC9C3EAD1B29B4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUCiacuh59wMbq1icuB8U1T7Vpic8FjKFdanvdt9bzClBmYqFUXmtKmh2Zibn9Dic6A8pjdoBiaia1LCrnA/132","comment_is_top":false,"comment_ctime":1620614620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620614620","product_id":100052601,"comment_content":" public void setSide(int side) {    this.setHeight(side);    this.setWidth(side); }<br>这里setSide是super.setHeight(side)吧 ","like_count":0},{"had_liked":false,"id":291191,"user_name":"春之绿野","can_delete":false,"product_type":"c1","uid":1057216,"ip_address":"","ucode":"296003F7D2B086","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/c0/38816c31.jpg","comment_is_top":false,"comment_ctime":1620108576,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1620108576","product_id":100052601,"comment_content":"我想问下老师，我写的都是pipeline 和里面嵌套的shell 脚本，不能用接口多态这些技术，里面for if else嵌套好多层，太头大了，这种怎么改进啊？","like_count":0,"discussions":[{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579967,"discussion_content":"Shell的语法表达的局限，建议通过Python或者其它支持面向对象的编程语言来改写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657785479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281854,"user_name":"可笑的霸王","can_delete":false,"product_type":"c1","uid":1379465,"ip_address":"","ucode":"CDCE2AA7119E2C","user_header":"https://static001.geekbang.org/account/avatar/00/15/0c/89/d5077e61.jpg","comment_is_top":false,"comment_ctime":1614927816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614927816","product_id":100052601,"comment_content":"看起来组合才适合正长方形","like_count":0},{"had_liked":false,"id":269882,"user_name":"vplus","can_delete":false,"product_type":"c1","uid":1474072,"ip_address":"","ucode":"19A014336C1E40","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/18/9b9c373b.jpg","comment_is_top":false,"comment_ctime":1608824682,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1608824682","product_id":100052601,"comment_content":"作者形状的那个例子的解释，感觉很难理解~~~<br><br>我说说自己的理解：<br>正方形的行为虽然表面看起来和父类矩形保持一致，但其内部实现却暗度陈仓。<br>setWidth方法，父类就是单纯设置宽度；<br>而子类setWidth的内部实现，变成了调用setWidth和setHeight；<br>这样写在外面是显式违反规则，写在类里面是隐晦地违反规则，后者找错误都难找，比前者更恶劣。","like_count":0,"discussions":[{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579970,"discussion_content":"构建模型的思维方式不同，重点关注行为（计算周长、面积等）而不是属性（长、宽）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657785608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238601,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1596210043,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1596210043","product_id":100052601,"comment_content":"我想请教一下老师 当我们可以抽象出统一的接口之后应该怎么处理参数的不同？举个例子：我现在又两种不同的上传文件的策略：1.上传S3; 2.上传到自己的document-service。这两种上传的策略在参数方面略有不同， 比如上传到S3的实现可能需要指定fileName, 上传到自己的document-service可能需要加上一些业务的字段，但是也有相同的参数， 比如最基本的二进制文件。所以按照我的理解我们应该有一个BaseUploadDocumentRequest作为父类，S3UploadDocumentRequest extends BaseUploadDocumentRequest, DocumentServiceUploadDocumentRequest extends BaseUploadDocumentRequest,同样的对于返回值也应该有同样的继承体系: S3UploadDocumentResponse extends BaseUploadDocumentResponse, DocumentServiceUploadDocumentResponse extends BaseUploadDocumentResponse。<br>接口应该长这样：<br>public interface DocumentUploadStrategy&lt;RequestType extends BaseUploadDocumentRequest, ResponseType extends BaseUploadDocumentResponse&gt; {<br>        public ResponseType uploadDocument(RequestType request);<br>}<br><br>请问老师我这样设计合理么？<br>","like_count":0,"discussions":[{"author":{"id":2404924,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b2/3c/22028324.jpg","nickname":"呆呆狗的兽","note":"","ucode":"B7D445F3BE2E4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384571,"discussion_content":"不需要强行继承啊，相同参数可以抽出来作为单独的类，组合的放在没有关系的request中，而只有一个基础数据字段的类型相同就行，比如二进制文件private MyFileInfo myFileInfo这样 这样参数既达到了公用重用，又不需要有什么关联，因为本质他们属于不同系统不需要有关联，假设是同一个系统中，那么采取继承比较合适，可以创建抽象类，方法入参为父类，来处理高层次同等逻辑，不同逻辑与参数处理分化到各子类中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626666391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308973,"discussion_content":"有一点好奇，返回值为什么也有不同的继承体系。\n\n另外，BaseUploadDocumentRequest 不应该是一个接口么？\n\n上传的参数和返回值如果采用 JSON 的方式，会不会简单一点？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601134568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235976,"user_name":"张chuang","can_delete":false,"product_type":"c1","uid":1185757,"ip_address":"","ucode":"17A49A30FF7AD8","user_header":"https://static001.geekbang.org/account/avatar/00/12/17/dd/7d88bc91.jpg","comment_is_top":false,"comment_ctime":1595259488,"is_pvip":false,"replies":[{"id":"87199","content":"但测试依然无法通过。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595294930,"ip_address":"","comment_id":235976,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595259488","product_id":100052601,"comment_content":"在正方形类中重写长方形的计算面积接口","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501906,"discussion_content":"但测试依然无法通过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595294930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235861,"user_name":"zchq88","can_delete":false,"product_type":"c1","uid":1105444,"ip_address":"","ucode":"DDD6B4F92E3692","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/24/1d3d026f.jpg","comment_is_top":false,"comment_ctime":1595227309,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595227309","product_id":100052601,"comment_content":"是不是可以吧Square做父类，然后Rectangle作为子类来设计，父类只有一个设置边长，子类增加设置长宽的接口，如果没有设置长宽默认使用边长的值。这样是不是符合替换原则？","like_count":0,"discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308971,"discussion_content":"感觉好像不太行，父类 Square 有一个设置边长，子类 Rectangle 除了设置长宽，还会有设置边长（继承来的），违反了接口隔离原则吧，另外感觉代码会比较奇怪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601134292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}