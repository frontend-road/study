{"id":140196,"title":"07 | 解耦是永恒的主题：MVC框架的发展","content":"<p>你好，我是四火。</p><p>欢迎进入第二章，本章我们将围绕 MVC 这个老而弥坚的架构模式展开方方面面的介绍，对于基于 Web 的全栈工程师来说，它是我们知识森林中心最茂密的一片区域，请继续打起精神，积极学习和思考。</p><p>无论是在  Web  全栈还是整个软件工程领域，有很多东西在本质上是相通的。比如我们在前一章提到的“权衡”（trade-off），我们后面还会反复提到。MVC 作为贯穿本章的主题，今天我们就通过它来引出另一个关键词——解耦。</p><h2>JSP 和 Servlet</h2><p>在我们谈 MVC 之前，先来讲一对好朋友，JSP 和 Servlet。说它们是好朋友，是因为它们经常一起出现，而事实上，它们还有更为紧密的联系。</p><h3>1. 概念介绍</h3><p>如果你有使用 Java 作为主要语言开发网站的经历，那么你一定听过别人谈论JSP和Servlet。其中，Servlet 指的是服务端的一种 Java 写的组件，它可以接收和处理来自浏览器的请求，并生成结果数据，通常它会是 HTML、JSON 等常见格式，写入 HTTP 响应，返回给用户。</p><p>至于 JSP，它的全称叫做 Java Server Pages，它允许静态的 HTML 页面插入一些类似于“&lt;% %&gt;”这样的标记（scriptlet），而在这样的标记中，还能以表达式或代码片段的方式，嵌入一些 Java 代码，在 Web 容器响应 HTTP 请求时，这些标记里的 Java 代码会得到执行，这些标记也会被替换成代码实际执行的结果，嵌入页面中一并返回。这样一来，原本静态的页面，就能动态执行代码，并将执行结果写入页面了。</p><!-- [[[read_end]]] --><ul>\n<li>第一次运行时，系统会执行编译过程，并且这个过程只会执行一次：JSP 会处理而生成 Servlet 的 Java 代码，接着代码会被编译成字节码（class文件），在 Java 虚拟机上运行。</li>\n<li>之后每次就只需要执行运行过程了，Servlet能够接受 HTTP 请求，并返回 HTML 文本，最终以 HTTP 响应的方式返回浏览器。</li>\n</ul><p>这个过程大致可以这样描述：</p><blockquote>\n<p>编译过程：JSP页面 → Java文件（Servlet）→ class文件（Servlet）<br>\n运行过程：HTTP请求 + class文件（Servlet）→ HTML文本</p>\n</blockquote><h3>2. 动手验证</h3><p>为了更好地理解这个过程，让我们来实际动手操作一遍。</p><p>首先，你需要安装两样东西，一样是 <a href=\"https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\">JDK（Java Development Kit）8</a>，是Java的软件开发包；另一样是 <a href=\"https://tomcat.apache.org/download-90.cgi\">Apache Tomcat 9</a>，它是一款Web容器，也是一款Servlet容器，因此无论是静态的 HTML 页面，还是动态的 Servlet、JSP，都可以部署在上面运行。</p><p>你可以使用安装包安装，也可以使用包管理工具安装（比如 Mac 下使用 Homebrew 安装）。如果你的电脑上已经安装了，只是版本号不同，也是没有问题的。</p><p>安装完成以后，打开一个新的命令行窗口，执行一下 java --version 命令，你应该能看到类似以下信息：</p><pre><code>java -version\njava version &quot;1.8.0_162&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_162-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)\n</code></pre><p>这里显示了JRE（Java Runtime Environment，Java 运行时环境）的版本号，以及虚拟机的类型和版本号。</p><p>同样地，执行catalina version，你也能看到Tomcat重要的环境信息：</p><pre><code>catalina version\nUsing CATALINA_BASE: ...\nUsing CATALINA_HOME: ...\nUsing CATALINA_TMPDIR: ...\n（以下省略其它的环境变量，以及服务器、操作系统和 Java 虚拟机的版本信息）\n</code></pre><p>其中，CATALINA_HOME 是 Tomcat 的“家”目录，就是它安装的位置，我们在下面要使用到它。</p><p>好，现在启动Tomcat：</p><pre><code>catalina run\n</code></pre><p>在浏览器中访问 <a href=\"http://localhost:8080/\">http://localhost:8080/</a>，你应该能看到Tomcat的主页面：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/22/2d4916452a0970d27d8bcb4cfe7b4422.jpg?wh=2376*666\" alt=\"\"></p><p>接着，我们在 ${CATALINA_HOME}/webapps/ROOT 下建立文件 hello_world.jsp，写入：</p><pre><code>Hello world! Time: &lt;%= new java.util.Date() %&gt;\n</code></pre><p>接着，访问 <a href=\"http://localhost:8080/hello_world.jsp\">http://localhost:8080/hello_world.jsp</a>，你将看到类似下面这样的文本：</p><pre><code>Hello world! Time: Sat Jul 27 20:39:19 PDT 2019\n</code></pre><p>嗯，代码被顺利执行了。可是根据我们学到的原理，我们应该能找到这个JSP文件生成的Java和class文件，它们应该藏在某处。没错，现在进入如下目录${CATALINA_HOME}/work/Catalina/localhost/ROOT/org/apache/jsp，你可以看到这样几个文件：</p><pre><code>index_jsp.java\nhello_005fworld_jsp.java\nindex_jsp.class\nhello_005fworld_jsp.class\n</code></pre><p>你看，前两个Java文件就是根据JSP生成的Servlet的源代码，后两个就是这个Servlet编译后的字节码。以index开头的文件就是Tomcat启动时你最初看到的主页面，而以hello开头的这两个文件则完全来自于我们创建的hello_world.jsp。</p><p>现在你可以打开 hello_005fworld_jsp.java，如果你有Java基础，那么你应该可以看得懂其中的代码。代码中公有类 hello_005fworld_jsp 继承自 HttpJspBase 类，而如果你查看 <a href=\"https://tomcat.apache.org/tomcat-9.0-doc/api/org/apache/jasper/runtime/HttpJspBase.html\">Tomcat的API文档</a>，你就会知道，原来它进一步继承自HttpServlet类，也就是说，这个自动生成的 Java 文件，就是 Servlet。</p><p>在117行附近，你可以找到我们写在 JSP 页面中的内容，它们以流的方式被写入了 HTTP 响应：</p><pre><code>out.write(&quot;Hello world! Time: &quot;);\nout.print( new java.util.Date() );\nout.write('\\n');\n</code></pre><p>通过自己动手，我想你现在应该更加理解  JSP  的工作原理了。你看，JSP和Servlet并不是完全独立的“两个人”，<strong>JSP实际工作的时候，是以Servlet的形式存在的</strong>，也就是说，前者其实是可以转化成后者的。</p><h3>3. 深入理解</h3><p>好，那么问题来了，我们为什么不直接使用Servlet，而要设计出JSP这样的技术，让其在实际运行中转化成Servlet来执行呢？</p><p>最重要的原因，<strong>从编程范型的角度来看，JSP页面的代码多是基于声明式（Declarative），而Servlet的代码则多是基于命令式（Imperative）</strong>，这两种技术适合不同的场景。这两个概念，最初来源于编程范型的分类，声明式编程，是去描述物件的性质，而非给出指令，而命令式编程则恰恰相反。</p><p>比方说，典型的JSP页面代码中，只有少数一些scriptlet，大部分还是HTML等格式的文本，而HTML文本会告诉浏览器，这里显示一个按钮，那里显示一个文本输入框，随着程序员对代码的阅读，可以形象地在脑海里勾勒出这个页面的样子，这也是声明式代码的一大特点。全栈工程师经常接触到的HTML、XML、JSON和CSS等，都是声明式代码。你可能注意到了，这些代码都不是使用编程语言写的，而是使用标记语言写的，但是，编程语言其实也有声明式的，比如Prolog。</p><p>再来说命令式代码，在Servlet中，它会一条一条语句告诉计算机下一步该做什么，这个过程就是命令式的。我们绝大多数的代码都是命令式的。声明式代码是告诉计算机“什么样”，而不关注“怎么做”；命令式代码则是告诉计算机“怎么做”，而不关注“什么样”。</p><p>为什么需要两种方式？因为人的思维是很奇特的，<strong>对于某些问题，使用声明式会更符合直觉，更形象，因而更接近于人类的语言；而另一些问题，则使用命令式，更符合行为步骤的思考模式，更严谨，也更能够预知机器会怎样执行</strong>。</p><p>计算机生来就是遵循命令执行的，因此声明式的JSP页面会被转化成一行行命令式的Servlet代码，交给计算机执行。可是，你可以想象一下，如果HTML那样适合声明式表述的代码，程序员使用命令式来手写会是怎样的一场噩梦——代码将会变成无趣且易错的一行行字符串拼接。</p><h2>MVC 的演进</h2><p>我想你一定听过MVC这种经典的架构模式，它早在20世纪70年代就被发明出来了，直到现在，互联网上的大多数网站，都是遵从MVC实现的，这足以见其旺盛的生命力。MVC模式包含这样三层：</p><ul>\n<li>控制器（Controller），恰如其名，主要负责请求的处理、校验和转发。</li>\n<li>视图（View），将内容数据以界面的方式呈现给用户，也捕获和响应用户的操作。</li>\n<li>模型（Model），数据和业务逻辑真正的集散地。</li>\n</ul><p>你可能会想，这不够全面啊，这三层之间的交互和数据流动在哪里？别急，MVC在历史上经历了多次演进，这三层，再加上用户，它们之间的交互模型，是逐渐变化的。哪怕在今天，不同的MVC框架的实现在这一点上也是有区别的。</p><h3>1. JSP Model 1</h3><p>JSP Model 1  是整个演化过程中最古老的一种，请求处理的整个过程，包括参数验证、数据访问、业务处理，到页面渲染（或者响应构造），全部都放在JSP页面里面完成。JSP页面既当爹又当妈，静态页面和嵌入动态表达式的特性，使得它可以很好地容纳声明式代码；而JSP的scriptlet，又完全支持多行Java代码的写入，因此它又可以很好地容纳命令式代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/66/eaaca09b4681bfaa9d36ee1e5998d966.png?wh=748*368\" alt=\"\"></p><h3>2. JSP Model 2</h3><p>在 Model 1 中，你可以对 JSP页面上的内容进行模块和职责的划分，但是由于它们都在一个页面上，物理层面上可以说是完全耦合在一起，因此模块化和单一职责无从谈起。和  Model 1  相比，Model 2  做了明显的改进。</p><ul>\n<li>JSP只用来做一件事，那就是页面渲染，换言之，JSP从全能先生转变成了单一职责的页面模板；</li>\n<li>引入JavaBean的概念，它将数据库访问等获取数据对象的行为封装了起来，成为业务数据的唯一来源；</li>\n<li>请求处理和派发的活交到纯Servlet手里，它成为了MVC的“大脑”，它知道创建哪个JavaBean准备好业务数据，也知道将请求引导到哪个JSP页面去做渲染。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/a0/f8/a0d15b2dc1e87ebac4aea3526edf38f8.png?wh=896*407\" alt=\"\"></p><p>通过这种方式，你可以看到，原本全能的JSP被解耦开了，分成了三层，这三层其实就是MVC的View、Model和Controller。于是殊途同归，MVC又一次进入了人们的视野，今天的MVC框架千差万别，原理上却和这个版本基本一致。</p><p>上面提到了一个概念JavaBean，随之还有一个常见的概念POJO，这是在Java领域中经常听到的两个名词，但有时它们被混用。在此，我想对这两个概念做一个简短的说明。</p><ul>\n<li>JavaBean其实指的是一类特殊的封装对象，这里的“Bean”其实指的就是可重用的封装对象。它的特点是可序列化，包含一个无参构造器，以及遵循统一的getter和setter这样的简单命名规则的存取方法。</li>\n<li>POJO，即Plain  Old Java Object，还是最擅长创建软件概念的Martin Fowler的杰作。它指的就是一个普通和简单的Java对象，没有特殊限制，也不和其它类有关联（它不能继承自其它类，不能实现任何接口，也不能被任何注解修饰）。</li>\n</ul><p>所以，二者是两个类似的概念，通常认为它们之间具备包含关系，即JavaBean可以视作POJO的一种。但它们二者也有一些共性，比如，它们都是可以承载实际数据状态，都定义了较为简单的方法，概念上对它们的限制只停留在外在表现（即内部实现可以不“plain”，可以很复杂，比如JavaBean经常在内部实现中读写数据库）。</p><h3>3. MVC的一般化</h3><p>JSP  Model 2  已经具备了MVC的基本形态，但是，它却对技术栈有着明确限制——Servlet、JSP和JavaBean。今天我们见到的MVC，已经和实现技术无关了，并且，在MVC三层大体职责确定的基础上，其中的交互和数据流动却是有许多不同的实现方式的。</p><p>不同的MVC框架下实现的MVC架构不同，有时即便是同一个框架，不同的版本之间其MVC架构都有差异（比如ASP.NET MVC），在这里我只介绍最典型的两种情况，如果你在学习的过程中见到其它类型，请不要惊讶，重要的是理解其中的原理。</p><p><strong>第一种：</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/93/0f/93c35efa9a76e0bd940d30563188c20f.png?wh=928*394\" alt=\"\"></p><p>上图是第一种典型情况，这种情况下，用户请求发送给Controller，而Controller是大总管，需要主动调用Model层的接口去取得实际需要的数据对象，之后将数据对象发送给需要渲染的View，View渲染之后返回页面给用户。</p><p>在这种情况下，Controller往往会比较大，因为它要知道需要调用哪个Model的接口获取数据对象，还需要知道要把数据对象发送给哪个View去渲染；View和Model都比较简单纯粹，它们都只需要被动地根据Controller的要求完成它们自己的任务就好了。</p><p><strong>第二种：</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/73/bb/73950914ac1904faf5c40602f8f9e0bb.png?wh=920*404\" alt=\"\"></p><p>上图是第二种典型情况，请和第一种比较，注意到了区别没有？这种情况在更新操作中比较常见，Controller调用Model的接口发起数据更新操作，接着就直接转向最终的View去了；View会调用Model去取得经过Controller更新操作以后的最新对象，渲染并返回给用户。</p><p>在这种情况下，Controller相对就会比较简单，而这里写操作是由Controller发起的，读操作是由View发起的，二者的业务对象模型可以不相同，非常适合需要CQRS（Command Query Responsibility Segregation，命令查询职责分离）的场景，我在 <a href=\"https://time.geekbang.org/column/article/141679\">[第 08 讲]</a> 中会进一步介绍 CQRS。</p><h3>4. MVC的变体</h3><p>MVC的故事还没完，当它的核心三层和它们的基本职责发生变化，这样的架构模式就不再是严格意义上的MVC了。这里我介绍两种MVC的变体：MVP和MVVM。</p><p>MVP包含的三层为Model、View和Presenter，它往往被用在用户的界面设计当中，和MVC比起来，Controller被Presenter替代了。</p><ul>\n<li>Model的职责没有太大的变化，依然是业务数据的唯一来源。</li>\n<li>View变成了纯粹的被动视图，它被动地响应用户的操作来触发事件，并将其转交给Presenter；反过来，它的视图界面被动地由Presenter来发起更新。</li>\n<li>Presenter变成了View和Model之间的协调者（Middle-man），它是真正调度逻辑的持有者，会根据事件对Model进行状态更新，又在Model层发生改变时，相应地更新View。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/b7/f2/b7e11bd5f911392cd2f1d51018b043f2.png?wh=1378*248\" alt=\"\"></p><p>MVVM是在MVP的基础上，将职责最多的Presenter替换成了ViewModel，它实际是一个数据对象的转换器，将从Model中取得的数据简化，转换为View可以识别的形式返回给View。View和ViewModel实行双向绑定，成为命运共同体，即View的变化会自动反馈到ViewModel中，反之亦然。关于数据双向绑定的知识我还会在 <a href=\"https://time.geekbang.org/column/article/143834\">[第 10 讲]</a> 中详解。</p><p><img src=\"https://static001.geekbang.org/resource/image/10/a8/1058b10f1bd38f518b483f7046c294a8.png?wh=1400*260\" alt=\"\"></p><h2>总结思考</h2><p>今天我们学习了 JSP 和 Servlet 这两个同源技术的本质，它们是分别通过声明式和命令式两种编程范型来解决同一问题的体现，接着围绕解耦这一核心，了解了 MVC 的几种形式和变体。</p><ul>\n<li>JSP Model 1：请求处理的整个过程，全部都耦合在JSP页面里面完成；</li>\n<li>JSP Model 2：MVC 分别通过 JavaBean、JSP 和 Servlet 解耦成三层；</li>\n<li>MVC 的常见形式一：数据由 Controller 调用 Model 来准备，并传递给 View 层；</li>\n<li>MVC 的常见形式二：Controller 发起对数据的修改，在 View 中查询修改后的数据并展示，二者分别调用 Model；</li>\n<li>MVP：Presenter 扮演协调者，对 Model 和 View 实施状态的更新；</li>\n<li>MVVM：View 和 ViewModel 实行数据的双向绑定，以自动同步状态。</li>\n</ul><p>好，现在提两个问题，检验一下今天的学习成果：</p><ul>\n<li>我们介绍了JSP页面和Servlet在编程范型上的不同，这两个技术有着不同的使用场景，你能举出例子来说明吗？</li>\n<li>在介绍MVC的一般化时，我介绍了两种典型的MVC各层调用和数据流向的实现，你工作或学习中使用过哪一种，还是都没使用过，而是第三种？</li>\n</ul><p>MVC是本章的核心内容，在这之后的几讲中我会对MVC逐层分解，今天的内容先打个基础，希望你能真正地理解和消化，这将有助于之后的学习。欢迎你在留言区和我讨论！</p><h2>扩展阅读</h2><ul>\n<li>【基础】专栏文章中的例子有时会涉及到 Java 代码，如果你对 Java 很不熟悉，可以参考廖雪峰 Java 教程中“<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255883772263712\">快速入门</a>”的部分，它很短小，但是覆盖了专栏需要的 Java 基础知识。</li>\n<li>【基础】W3Cschool上的 <a href=\"https://www.w3cschool.cn/servlet/\">Servlet教程</a>和 <a href=\"https://www.w3cschool.cn/jsp/\">JSP教程</a>，如果你对这二者完全不了解，那我推荐你阅读。在较为系统的教程中，这两个算较为简洁的，如果觉得内容较多，可以挑选其中的几个核心章节阅读。</li>\n<li>如果你顺利地将文中介绍的Tomcat启动起来了，并且用的也是9.x版本，那么你可以直接访问 <a href=\"http://localhost:8080/examples/\">http://localhost:8080/examples/</a>，里面有Tomcat自带的很多典型和带有源码的例子，有JSP的例子，也有Servlet的例子，还有WebSocket的例子（由于我们前一章已经学过了WebSocket，这里你应该可以较为顺利地学习）。</li>\n</ul><p></p>","comments":[{"had_liked":false,"id":137454,"user_name":"Luciano李鑫","can_delete":false,"product_type":"c1","uid":1329995,"ip_address":"","ucode":"5FBE5F86FD5B2C","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","comment_is_top":false,"comment_ctime":1569745072,"is_pvip":false,"replies":[{"id":"52897","content":"MVP 是 MVC 的变体，功能、层次和应用场景有所区别，下面是我的归纳，供参考。<br><br>简单说，对于 MVC 来说，Controller 层次上完全独立于 View，它可以跨多个视图、可以决定视图路由，更多存放的是控制逻辑，应用较为广泛，但多数在服务端代码中；<br><br>而对于 MVP 来说，Presenter 则其实是和 View 在相似的层次上，协调并把 Model 的数据绑定到指定 View 上去，主要用在纯粹 UI 的实现中。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569817480,"ip_address":"","comment_id":137454,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35929483440","product_id":100035501,"comment_content":"请问MVP和MVC的主要区别体现在什么地方","like_count":8,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469103,"discussion_content":"MVP 是 MVC 的变体，功能、层次和应用场景有所区别，下面是我的归纳，供参考。\n\n简单说，对于 MVC 来说，Controller 层次上完全独立于 View，它可以跨多个视图、可以决定视图路由，更多存放的是控制逻辑，应用较为广泛，但多数在服务端代码中；\n\n而对于 MVP 来说，Presenter 则其实是和 View 在相似的层次上，协调并把 Model 的数据绑定到指定 View 上去，主要用在纯粹 UI 的实现中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569817480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1518250,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2a/aa/e0ae9b76.jpg","nickname":"浅浅悠","note":"","ucode":"82F005FD97E73F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395591,"discussion_content":"有什么实际的运用场景吗，怎么区别这俩","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632317878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137696,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1569825243,"is_pvip":false,"replies":[{"id":"52987","content":"👍，补充说明一下，使用 Spring MVC 也是可以应用第二种的","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569905591,"ip_address":"","comment_id":137696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159759835","product_id":100035501,"comment_content":"SpringMVC应该属于第一种，但是我们在编写控制器代码时，并没有显式的调用View,而是生成一个ViewModel.由前置控制器去做剩下的事情~","like_count":2,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469216,"discussion_content":"👍，补充说明一下，使用 Spring MVC 也是可以应用第二种的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569905591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137775,"user_name":"易儿易","can_delete":false,"product_type":"c1","uid":1242864,"ip_address":"","ucode":"B15D1031CA841E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLcWH3mSPmhjrs1aGL4b3TqI7xDqWWibM4nYFrRlp0z7FNSWaJz0mqovrgIA7ibmrPt8zRScSfRaqQ/132","comment_is_top":false,"comment_ctime":1569842227,"is_pvip":false,"replies":[{"id":"53134","content":"你提到的 ② 和 ③，都属于 Model 层的一部分。我认为bean 简单来说指的就是可重用的封装对象，文中也有解释。从这个角度来说的话，满足这个条件都可以算，所以你说这两个的是算的。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1570076644,"ip_address":"","comment_id":137775,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864809523","product_id":100035501,"comment_content":"老师，我一直有一个疑惑，希望老师能够解答：平时开发用的是第一种MVC，CRUD的代码基本上都是①xxxAction-②(Ixxx接口类-xxxServiceImpl实现类)-③xxxDao这“三层”结构，xxxAction属于Controller，那么(Ixxx接口类-xxxServiceImpl实现类)-xxxDao应该都属于Model层对吗？很多资料包括老师今天讲的都提到Model是由javabean的构成的，是不是我理解的javabean太狭隘了？(Ixxx接口类-xxxServiceImpl实现类)-xxxDao这些都可以称为javabean吗？","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469255,"discussion_content":"你提到的 ② 和 ③，都属于 Model 层的一部分。我认为bean 简单来说指的就是可重用的封装对象，文中也有解释。从这个角度来说的话，满足这个条件都可以算，所以你说这两个的是算的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570076644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136807,"user_name":"四喜","can_delete":false,"product_type":"c1","uid":1071389,"ip_address":"","ucode":"C5EBED19C0F332","user_header":"https://static001.geekbang.org/account/avatar/00/10/59/1d/c89abcd8.jpg","comment_is_top":false,"comment_ctime":1569513403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5864480699","product_id":100035501,"comment_content":"Vue: MVVM   -&gt; model view viewmodel<br>React: MVC   -&gt; model view controller<br>Angular: MVW   -&gt; model view whatever","like_count":2},{"had_liked":false,"id":136130,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1569371505,"is_pvip":false,"replies":[{"id":"52463","content":"第一条大致可以按你说的理解，但是第二条做个说明：VVM 和 MVVM 的区别在于实际的数据源头 M 消失了，因为有时候我们不需要它，比如设计一个可重用的组件。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569510525,"ip_address":"","comment_id":136130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864338801","product_id":100035501,"comment_content":"M-VVM就是M-automated-VP么？因为view和viewModel成为了命运共同体。<br><br>或者说VVM是“别人实现了，我直接用”的VP？比如Vue或React","like_count":1,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468472,"discussion_content":"第一条大致可以按你说的理解，但是第二条做个说明：VVM 和 MVVM 的区别在于实际的数据源头 M 消失了，因为有时候我们不需要它，比如设计一个可重用的组件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569510525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313228,"user_name":"浅浅悠","can_delete":false,"product_type":"c1","uid":1518250,"ip_address":"","ucode":"82F005FD97E73F","user_header":"https://static001.geekbang.org/account/avatar/00/17/2a/aa/e0ae9b76.jpg","comment_is_top":false,"comment_ctime":1632317993,"is_pvip":false,"replies":[{"id":"114158","content":"Servlet 这个词应当就是指同一个概念","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1633792699,"ip_address":"","comment_id":313228,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632317993","product_id":100035501,"comment_content":"有个问题哈，这里的servlet和现在的servlet前端框架是一个东西吗","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527285,"discussion_content":"Servlet 这个词应当就是指同一个概念","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633792699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277880,"user_name":"程同学","can_delete":false,"product_type":"c1","uid":2418763,"ip_address":"","ucode":"622B71D5A2DA5E","user_header":"https://static001.geekbang.org/account/avatar/00/24/e8/4b/8ddf36b0.jpg","comment_is_top":false,"comment_ctime":1612654239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612654239","product_id":100035501,"comment_content":"大师视角，让我对知识有了不一样的理解","like_count":0},{"had_liked":false,"id":273055,"user_name":"叶子","can_delete":false,"product_type":"c1","uid":1263982,"ip_address":"","ucode":"55E4D9534594BB","user_header":"","comment_is_top":false,"comment_ctime":1610421923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610421923","product_id":100035501,"comment_content":"老师，我想问下，百科上说MVP与MVC有着一个重大的区别MVP是View与Model完全隔离,MVC里，View是可以直接访问Model的。<br>为什么上文中第一种MVC怎么看都觉得是一种MVP？","like_count":1},{"had_liked":false,"id":258018,"user_name":"唯心主义蠢货🍁","can_delete":false,"product_type":"c1","uid":1941034,"ip_address":"","ucode":"836B09E0459953","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9e/2a/f1d8913f.jpg","comment_is_top":false,"comment_ctime":1604244388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604244388","product_id":100035501,"comment_content":"是不是因为后端Model层和view建立联系是需要通过一层control层的，持久层的数据无法对应到一个view<br>但是前端的话数据和UI是可以完全对应的，control就不需要了，只需要一层p或者vm层建立数据和view的连接即可","like_count":0},{"had_liked":false,"id":142125,"user_name":"加利率的钟摆","can_delete":false,"product_type":"c1","uid":1005958,"ip_address":"","ucode":"0E802A99455E71","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/86/0f9f81d5.jpg","comment_is_top":false,"comment_ctime":1571297481,"is_pvip":false,"replies":[{"id":"55065","content":"这个取决于一致性的设计了。如果采用的是强一致性，比如关系数据库，那就可以保证在 View 调用的时候，前面 Controller 调用的更新能够被查询出来。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1571436851,"ip_address":"","comment_id":142125,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571297481","product_id":100035501,"comment_content":"老师好，有个问题想请教一下：<br>第二种MVC，“Controller 调用 Model 的接口发起数据更新操作，接着就直接转向最终的 View 去了；View 会调用 Model 去取得经过 Controller 更新操作以后的最新对象，渲染并返回给用户。”<br><br>如何保证View调用的Model已经更新完毕了？","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470993,"discussion_content":"这个取决于一致性的设计了。如果采用的是强一致性，比如关系数据库，那就可以保证在 View 调用的时候，前面 Controller 调用的更新能够被查询出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571436851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137888,"user_name":"pyhhou","can_delete":false,"product_type":"c1","uid":1256496,"ip_address":"","ucode":"31EF8D50CF91A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","comment_is_top":false,"comment_ctime":1569905535,"is_pvip":false,"replies":[{"id":"53138","content":"不清楚你说的“MVC 和一般设计相比”，这里的“一般设计”指的是什么。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1570077012,"ip_address":"","comment_id":137888,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1569905535","product_id":100035501,"comment_content":"1. 解耦后，JSP 更偏向于声明式编程，也就是描述一个页面上的属性，UI 呈现等等，可以把它看作是加强版的 HTML。servlet 更偏向于命令式编程，用于后台的数据交互，发出指令，接收 request，做的都是逻辑性较强的工作。但回过头来看 JSP 其实也是 servlet，只是为了让编写代码更加直观，易懂，这中间做了个转换<br><br>2. 工作中做的项目没有特别强的 MVC 的概念，之前设计的时候只考虑了 “前端” 和 “后端” 这两个概念，前端和后端分离，前端负责接收并响应界面用户的操作，然后通过 RESTful API 的方式和后端进行交互，后端根据请求进行 CRUD，然后响应请求。不是特别清楚 MVC 和一般设计相比的优势有哪些，还是说 MVC 架构下分工比较明确，代码比较容易区分开来？还望老师指点","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469295,"discussion_content":"不清楚你说的“MVC 和一般设计相比”，这里的“一般设计”指的是什么。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570077012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24524,"discussion_content":"当然 ，你可以阅读一下 09 篇，特别是客户端聚合部分，视图层的大部分工作，都被拆解到前端来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570167821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256496,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","nickname":"pyhhou","note":"","ucode":"31EF8D50CF91A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24445,"discussion_content":"不好意思，可能是我这里说的比较模糊，controller、model 和 view 在 MVC 里面是分开来讨论的，但是如果把这几块合在一起是否可行呢？这里的 “一般设计” 就是想说我们是不是可以不局限于 MVC 或者其他的一些框架概念，自由地组合出我们想要的框架结构，比如把 view 单独拉出来作为 “前端”，把 controller 和 model 合在一起作为 “后端”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570122568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137760,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1569838123,"is_pvip":true,"replies":[{"id":"53133","content":"模式本身来说，是没有前后端的限制的。不过，在实际使用中，因为解决的问题所在的层次特点，是带有明显的偏向的。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1570076170,"ip_address":"","comment_id":137760,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569838123","product_id":100035501,"comment_content":"一直不明白，mvc，mvp，mvvm等变体模式，跟前后端有关系吗，个人的理解是，后端框架多是mvc，「开发语言php」，前端似乎是mvp，mvvm之类的，难道就不存在反过来的，还是实践表明，目前的架构模式是较好的实践结果。望老师看到解答，谢谢。","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469251,"discussion_content":"模式本身来说，是没有前后端的限制的。不过，在实际使用中，因为解决的问题所在的层次特点，是带有明显的偏向的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570076170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137747,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1569835581,"is_pvip":true,"replies":[{"id":"52985","content":"在 Windows 下你看看 Tomcat 的 bin 目录下有没有 version.bat，启动则是 startup.bat。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569905208,"ip_address":"","comment_id":137747,"utype":1}],"discussion_count":6,"race_medal":0,"score":"1569835581","product_id":100035501,"comment_content":"试了下「同样地，执行 catalina version，你也能看到 Tomcat 重要的环境信息：」提示没有该命令……，其他都正常，浏览器上能访问到的，系统变量配置了「CATALINA_HOME   C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0」，也重启过电脑，一样的结果，原因是什么呢。","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469242,"discussion_content":"在 Windows 下你看看 Tomcat 的 bin 目录下有没有 version.bat，启动则是 startup.bat。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569905208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23837,"discussion_content":"有的，还有catalina.bat，新电脑上试了也是不行「win10 64位 专业版」","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569911362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":24279,"discussion_content":"JDK 安装了吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570078474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":23837,"ip_address":""},"score":24279,"extra":""},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":24513,"discussion_content":"en 安装了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570163308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24279,"ip_address":""},"score":24513,"extra":""},{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":24523,"discussion_content":"也许是我没说清楚，Windows 下如果是查看版本号执行 version.bat；如果是启动 Tomcat 执行 startup.bat。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570167062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24513,"ip_address":""},"score":24523,"extra":""}]}]},{"had_liked":false,"id":137559,"user_name":"易儿易","can_delete":false,"product_type":"c1","uid":1242864,"ip_address":"","ucode":"B15D1031CA841E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLcWH3mSPmhjrs1aGL4b3TqI7xDqWWibM4nYFrRlp0z7FNSWaJz0mqovrgIA7ibmrPt8zRScSfRaqQ/132","comment_is_top":false,"comment_ctime":1569778727,"is_pvip":false,"replies":[{"id":"52896","content":"从你描述来看，能运行 *.bat，是 Windows 系统吧，那就通过 startup.bat 启动吧。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569816715,"ip_address":"","comment_id":137559,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569778727","product_id":100035501,"comment_content":"很奇怪，我输入catalina run命令后是这个样子的jdk1.8,tomcat9,catalina run 多次重复输入都是一样，不知道是哪里出的问题，只能通过startup.bat启动<br>Usage:  catalina ( commands ... )<br>commands:<br>  debug             Start Catalina in a debugger<br>  debug -security   Debug Catalina with a security manager<br>  jpda start        Start Catalina under JPDA debugger<br>  run               Start Catalina in the current window<br>  run -security     Start in the current window with security manager<br>  start             Start Catalina in a separate window<br>  start -security   Start in a separate window with security manager<br>  stop              Stop Catalina<br>  configtest        Run a basic syntax check on server.xml<br>  version           What version of tomcat are you running?","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469149,"discussion_content":"从你描述来看，能运行 *.bat，是 Windows 系统吧，那就通过 startup.bat 启动吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569816715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137023,"user_name":"Paradise丶朽木","can_delete":false,"product_type":"c1","uid":1242819,"ip_address":"","ucode":"4E4B8DCC216FAA","user_header":"https://static001.geekbang.org/account/avatar/00/12/f6/c3/926f2da9.jpg","comment_is_top":false,"comment_ctime":1569577737,"is_pvip":false,"replies":[{"id":"52757","content":"👍","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569690192,"ip_address":"","comment_id":137023,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569577737","product_id":100035501,"comment_content":"刚入职时写过一点jsp，后来是freemaker模板引擎，现在是前后端分离~回答下第二个问题，我觉得fremaker那种方式应该是典型的第一种，controller负责接收请求，处理参数，调用service查询数据，封装成ModelAndView，再由freemaker渲染页面返回。","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468910,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569690192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136773,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1569505947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569505947","product_id":100035501,"comment_content":"   先打卡吧：这块确实是我的弱项，趁着马上到来的长假好好把MVC这块补了、、、","like_count":0},{"had_liked":false,"id":136236,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1569392683,"is_pvip":false,"replies":[{"id":"52466","content":"嗯，最重要的是理解原理。不严格地讲，这些说法都没问题。","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569510875,"ip_address":"","comment_id":136236,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569392683","product_id":100035501,"comment_content":"之前就曾听人说过JSP是一种特殊的Servlet，现在看说的不完全正确，JSP会转化成一种特殊的servlet返回请求结果。","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468521,"discussion_content":"嗯，最重要的是理解原理。不严格地讲，这些说法都没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569510875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136163,"user_name":"桃源小盼","can_delete":false,"product_type":"c1","uid":1039664,"ip_address":"","ucode":"3FA0819FD69FF8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/30/9d36ccaf.jpg","comment_is_top":false,"comment_ctime":1569375378,"is_pvip":true,"replies":[{"id":"52462","content":"你的描述有一些简单，什么是“接口服务里有service”？","user_name":"作者回复","user_name_real":"四火","uid":"1580075","ctime":1569510279,"ip_address":"","comment_id":136163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569375378","product_id":100035501,"comment_content":"接口服务里有service，它属于view层还是model层？","like_count":0,"discussions":[{"author":{"id":1580075,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/2b/2069abe6.jpg","nickname":"四火","note":"","ucode":"E4BED7DCAADD99","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468488,"discussion_content":"你的描述有一些简单，什么是“接口服务里有service”？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569510279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}