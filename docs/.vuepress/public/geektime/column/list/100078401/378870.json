{"id":378870,"title":"09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？","content":"<p>你好，我是LMOS。</p><p>上节课，我们学习了解决数据同步问题的思路与方法。Linux作为成熟的操作系统内核，当然也有很多数据同步的机制，它也有原子变量、开启和关闭中断、自旋锁、信号量。</p><p>那今天我们就来探讨一下这些机制在Linux中的实现。看看Linux的实现和前面我们自己的实现有什么区别，以及Linux为什么要这么实现，这么实现背后的机理是什么。</p><h2>Linux的原子变量</h2><p>首先，我们一起来看看Linux下的原子变量的实现，在Linux中，有许多共享的资源可能只是一个简单的整型数值。</p><p>例如在文件描述符中，需要包含一个简单的计数器。这个计数器表示有多少个应用程序打开了文件。在文件系统的open函数中，将这个计数器变量加1；在close函数中，将这个计数器变量减1。</p><p>如果单个进程执行打开和关闭操作，那么这个计数器变量不会出现问题，但是Linux是支持多进程的系统，如果有多个进程同时打开或者关闭文件，那么就可能导致这个计数器变量多加或者少加，出现错误。</p><p>为了避免这个问题，Linux提供了<strong>一个原子类型变量atomic_t</strong>。该变量的定义如下。</p><pre><code>typedef struct {\n    int counter;\n} atomic_t;//常用的32位的原子变量类型\n#ifdef CONFIG_64BIT\ntypedef struct {\n    s64 counter;\n} atomic64_t;//64位的原子变量类型\n#endif\n</code></pre><p>上述代码自然不能用普通的代码去读写加减，而是要用Linux专门提供的接口函数去操作，否则就不能保证原子性了，代码如下。</p><!-- [[[read_end]]] --><pre><code>//原子读取变量中的值\nstatic __always_inline int arch_atomic_read(const atomic_t *v)\n{\n    return __READ_ONCE((v)-&gt;counter);\n}\n//原子写入一个具体的值\nstatic __always_inline void arch_atomic_set(atomic_t *v, int i)\n{\n    __WRITE_ONCE(v-&gt;counter, i);\n}\n//原子加上一个具体的值\nstatic __always_inline void arch_atomic_add(int i, atomic_t *v)\n{\n    asm volatile(LOCK_PREFIX &quot;addl %1,%0&quot;\n             : &quot;+m&quot; (v-&gt;counter)\n             : &quot;ir&quot; (i) : &quot;memory&quot;);\n}\n//原子减去一个具体的值\nstatic __always_inline void arch_atomic_sub(int i, atomic_t *v)\n{\n    asm volatile(LOCK_PREFIX &quot;subl %1,%0&quot;\n             : &quot;+m&quot; (v-&gt;counter)\n             : &quot;ir&quot; (i) : &quot;memory&quot;);\n}\n//原子加1\nstatic __always_inline void arch_atomic_inc(atomic_t *v)\n{\n    asm volatile(LOCK_PREFIX &quot;incl %0&quot;\n             : &quot;+m&quot; (v-&gt;counter) :: &quot;memory&quot;);\n}\n//原子减1\nstatic __always_inline void arch_atomic_dec(atomic_t *v)\n{\n    asm volatile(LOCK_PREFIX &quot;decl %0&quot;\n             : &quot;+m&quot; (v-&gt;counter) :: &quot;memory&quot;);\n}\n</code></pre><p>Linux原子类型变量的操作函数有很多，这里我只是介绍了最基础的几个函数，<a href=\"https://elixir.bootlin.com/linux/v5.10.13/source/arch/x86/include/asm/atomic.h#L23\">其它的原子类型变量操作</a>也依赖于上述几个基础的函数。</p><p>你会发现，Linux的实现也同样采用了x86 CPU的原子指令，LOCK_PREFIX是一个宏，根据需要展开成“lock;”或者空串。<strong>单核心CPU是不需要lock前缀的，只要在多核心CPU下才需要加上lock前缀。</strong></p><p>剩下__READ_ONCE，__WRITE_ONCE两个宏，我们来看看它们分别做了什么，如下所示。</p><pre><code>#define __READ_ONCE(x)\t\\\n(*(const volatile __unqual_scalar_typeof(x) *)&amp;(x))\n#define __WRITE_ONCE(x, val) \\\ndo {*(volatile typeof(x) *)&amp;(x) = (val);} while (0)\n//__unqual_scalar_typeof表示声明一个非限定的标量类型，非标量类型保持不变。说人话就是返回x变量的类型，这是GCC的功能，typeof只是纯粹返回x的类型。\n//如果 x 是int类型则返回“int” \n#define __READ_ONCE(x)\t\\\n(*(const volatile int *)&amp;(x))\n#define __WRITE_ONCE(x, val) \\\ndo {*(volatile int *)&amp;(x) = (val);} while (0) \n</code></pre><p>结合刚才的代码，我给你做个解读。Linux定义了__READ_ONCE，__WRITE_ONCE这两个宏，是对代码封装并利用GCC的特性对代码进行检查，把让错误显现在编译阶段。其中的“volatile int *”是为了提醒编译器：<strong>这是对内存地址读写，不要有优化动作，每次都必须强制写入内存或从内存读取。</strong></p><h2>Linux控制中断</h2><p>Linux中有很多场景，需要在关中断下才可以安全执行一些操作。</p><p>比如，多个中断处理程序需要访问一些共享数据，一个中断程序在访问数据时必须保证自身（中断嵌套）和其它中断处理程序互斥，否则就会出错。再比如，设备驱动程序在设置设备寄存器时，也必须让CPU停止响应中断。</p><p>Linux控制CPU响应中断的函数如下。</p><pre><code>//实际保存eflags寄存器\nextern __always_inline unsigned long native_save_fl(void){\n    unsigned long flags;\n    asm volatile(&quot;# __raw_save_flags\\n\\t&quot;\n                 &quot;pushf ; pop %0&quot;:&quot;=rm&quot;(flags)::&quot;memory&quot;);\n    return flags;\n}\n//实际恢复eflags寄存器\nextern inline void native_restore_fl(unsigned long flags){\n    asm volatile(&quot;push %0 ; popf&quot;::&quot;g&quot;(flags):&quot;memory&quot;,&quot;cc&quot;);\n}\n//实际关中断\nstatic __always_inline void native_irq_disable(void){\n    asm volatile(&quot;cli&quot;:::&quot;memory&quot;);\n}\n//实际开启中断\nstatic __always_inline void native_irq_enable(void){\n    asm volatile(&quot;sti&quot;:::&quot;memory&quot;);\n}\n//arch层关中断\nstatic __always_inline void arch_local_irq_disable(void){\n    native_irq_disable();\n}\n//arch层开启中断\nstatic __always_inline void arch_local_irq_enable(void){ \n    native_irq_enable();\n}\n//arch层保存eflags寄存器\nstatic __always_inline unsigned long           arch_local_save_flags(void){\n    return native_save_fl();\n}\n//arch层恢复eflags寄存器\nstatic  __always_inline void arch_local_irq_restore(unsigned long flags){\n    native_restore_fl(flags);\n}\n//实际保存eflags寄存器并关中断\nstatic __always_inline unsigned long arch_local_irq_save(void){\n    unsigned long flags = arch_local_save_flags();\n    arch_local_irq_disable();\n    return flags;\n}\n//raw层关闭开启中断宏\n#define raw_local_irq_disable()     arch_local_irq_disable()\n#define raw_local_irq_enable()      arch_local_irq_enable()\n//raw层保存恢复eflags寄存器宏\n#define raw_local_irq_save(flags)           \\\n    do {                        \\\n        typecheck(unsigned long, flags);    \\\n        flags = arch_local_irq_save();      \\\n    } while (0)\n    \n#define raw_local_irq_restore(flags)            \\\n    do {                        \\\n        typecheck(unsigned long, flags);    \\\n        arch_local_irq_restore(flags);      \\\n    } while (0)\n    \n#define raw_local_save_flags(flags)         \\\n    do {                        \\\n        typecheck(unsigned long, flags);    \\\n        flags = arch_local_save_flags();    \\\n    } while (0)\n//通用层接口宏 \n#define local_irq_enable()              \\\n    do { \\\n        raw_local_irq_enable();         \\\n    } while (0)\n\n#define local_irq_disable()             \\\n    do {                        \\\n        raw_local_irq_disable();        \\\n    } while (0)\n\n#define local_irq_save(flags)               \\\n    do {                        \\\n        raw_local_irq_save(flags);      \\\n    } while (0)\n\n#define local_irq_restore(flags)            \\\n    do {                        \\\n        raw_local_irq_restore(flags);       \\\n    } while (0)\n</code></pre><p>可以发现，Linux中通过定义的方式对一些底层函数进行了一些包装，为了让你抓住重点，前面这些宏我去掉了和中断控制无关的额外操作，详细信息你可以参阅<a href=\"https://elixir.bootlin.com/linux/v5.10.13/source/include/linux/irqflags.h#L186\">相关代码</a>。</p><p>编译Linux代码时，编译器自动对宏进行展开。其中，<span class=\"orange\">do{}while(0)</span>是Linux代码中一种常用的技巧，do{}while(0)表达式会保证{}中的代码片段执行一次，保证宏展开时这个代码片段是一个整体。</p><p>带native_前缀之类的函数则跟我们之前实现的hal_前缀对应，而Linux为了支持不同的硬件平台，做了多层封装。</p><h2>Linux自旋锁</h2><p>Linux也是支持多核心CPU的操作系统内核，因此Linux也需要自旋锁来对系统中的共享资源进行保护。同一时刻，只有获取了锁的进程才能使用共享资源。</p><p>根据上节课对自旋锁算法的理解，自旋锁不会引起加锁进程睡眠，如果自旋锁已经被别的进程持有，加锁进程就需要一直循环在那里，查看是否该自旋锁的持有者已经释放了锁，\"自旋\"一词就是因此而得名。</p><p>Linux有多种自旋锁，我们这里只介绍两种，<strong>原始自旋锁和排队自旋锁</strong>，它们底层原理和我们之前实现的没什么不同，但多了一些优化和改进，下面我们一起去看看。</p><h3>Linux原始自旋锁</h3><p>我们先看看Linux原始的自旋锁，Linux的原始自旋锁本质上用一个整数来表示，值为1代表锁未被占用，为0或者负数则表示被占用。</p><p>你可以结合上节课的这张图，理解后面的内容。当某个CPU核心执行进程请求加锁时，如果锁是未加锁状态，则加锁，然后操作共享资源，最后释放锁；如果锁已被加锁，则进程并不会转入睡眠状态，而是循环等待该锁，一旦锁被释放，则第一个感知此信息的进程将获得锁。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/24/a2968832f3f1055cc7ba68628a25d924.jpg?wh=2195*2405\" alt=\"\" title=\"自旋锁原理示意图\"></p><p>我们先来看看Linux原始自旋锁的数据结构，为方便你阅读，我删除了用于调试的数据字段，代码如下。</p><pre><code>//最底层的自旋锁数据结构\ntypedef struct{\nvolatile unsigned long lock;//真正的锁值变量，用volatile标识\n}spinlock_t;\n</code></pre><p>Linux原始自旋锁数据结构封装了一个unsigned long类型的变量。有了数据结构，我们再来看看操作这个数据结构的函数，即自旋锁接口，代码如下。</p><pre><code>#define spin_unlock_string \\\t\n    &quot;movb $1,%0&quot; \\ //写入1表示解锁\n    :&quot;=m&quot; (lock-&gt;lock) : : &quot;memory&quot;\n\n#define spin_lock_string \\\n\t&quot;\\n1:\\t&quot; \\\t\n    &quot;lock ; decb %0\\n\\t&quot; \\ //原子减1\n\t&quot;js 2f\\n&quot; \\\t  //当结果小于0则跳转到标号2处，表示加锁失败\n    &quot;.section .text.lock,\\&quot;ax\\&quot;\\n&quot; \\ //重新定义一个代码段，这是优化技术，避免后面的代码填充cache，因为大部分情况会加锁成功，链接器会处理好这个代码段的\n\t&quot;2:\\t&quot; \\\t\n    &quot;cmpb $0,%0\\n\\t&quot; \\\t//和0比较\n    &quot;rep;nop\\n\\t&quot; \\\t//空指令\n    &quot;jle 2b\\n\\t&quot; \\\t //小于或等于0跳转到标号2\n    &quot;jmp 1b\\n&quot; \\   //跳转到标号1\t\n    &quot;.previous&quot;\n//获取自旋锁\nstatic inline void spin_lock(spinlock_t*lock){\n    __asm__ __volatile__(\n    spin_lock_string\n    :&quot;=m&quot;(lock-&gt;lock)::&quot;memory&quot;\n    );\n}\n//释放自旋锁\nstatic inline void spin_unlock(spinlock_t*lock){\n__asm__ __volatile__(\n    spin_unlock_string\n    );\n}\n</code></pre><p>上述代码中用spin_lock_string、spin_unlock_string两个宏，定义了获取、释放自旋锁的汇编指令。spin_unlock_string只是简单将锁值变量设置成1，表示释放自旋锁，spin_lock_string中并没有像我们Cosmos一样使用xchg指令，而是使用了decb指令，这条指令也能原子地执行减1操作。</p><p>开始锁值变量为1时，执行decb指令就变成了0，0就表示加锁成功。如果小于0，则表示有其它进程已经加锁了，就会导致循环比较。</p><h3>Linux排队自旋锁</h3><p>现在我们再来看看100个进程获取同一个自旋锁的情况，开始1个进程获取了自旋锁L，后面继续来了99个进程，它们都要获取自旋锁L，但是它们必须等待，这时第1进程释放了自旋锁L。请问，这99个进程中谁能先获取自旋锁L呢？</p><p>答案是不确定，因为这个次序依赖于哪个CPU核心能最先访问内存，而哪个CPU核心可以访问内存是由<strong>总线仲裁协议</strong>决定的。</p><p>很有可能最后来的进程最先获取自旋锁L，这对其它等待的进程极其不公平，为了解决获取自旋锁的<strong>公平性</strong>，Linux开发出了排队自旋锁。</p><p>你可以这样理解，想要给进程排好队，就需要确定顺序，也就是进程申请获取锁的先后次序，Linux的排队自旋锁通过保存这个信息，就能更公平地调度进程了。</p><p>为了保存顺序信息，排队自旋锁重新定义了数据结构。</p><pre><code>//RAW层的自旋锁数据结构\ntypedef struct raw_spinlock{\n    unsigned int slock;//真正的锁值变量\n}raw_spinlock_t;\n//最上层的自旋锁数据结构\ntypedef struct spinlock{\n    struct raw_spinlock rlock;\n}spinlock_t;\n//Linux没有这样的结构，这只是为了描述方便\ntypedef struct raw_spinlock{\n    union {\n        unsigned int slock;//真正的锁值变量\n        struct {\n        u16 owner;\n        u16 next;\n        }\n    }\n}raw_spinlock_t;\n</code></pre><p>slock域被分成两部分，分别保存<strong>锁持有者</strong>和<strong>未来锁申请者</strong>的序号，如上述代码10～16行所示。</p><p>只有next域与owner域相等时，才表示自旋锁处于未使用的状态（此时也没有进程申请该锁）。在排队自旋锁初始化时，slock被置为0，即next和owner被置为0，Linux进程执行申请自旋锁时，原子地将next域加1，并将原值返回作为自己的序号。</p><p>如果返回的序号等于申请时的owner值，说明自旋锁处于未使用的状态，则进程直接获得锁；否则，该进程循环检查owner域是否等于自己持有的序号，一旦相等，则表明锁轮到自己获取。</p><p>进程释放自旋锁时，原子地将owner域加1即可，下一个进程将会发现这一变化，从循环状态中退出。进程将严格地按照申请顺序依次获取排队自旋锁。这样一来，原先进程无序竞争的乱象就迎刃而解了。</p><pre><code>static inline void __raw_spin_lock(raw_spinlock_t*lock){\nint inc = 0x00010000;\nint tmp;\n__asm__ __volatile__(\n&quot;lock ; xaddl %0, %1\\n&quot; //将inc和slock交换，然后 inc=inc+slock\n                        //相当于原子读取next和owner并对next+1\n&quot;movzwl %w0, %2\\n\\t&quot;//将inc的低16位做0扩展后送tmp tmp=(u16)inc\n&quot;shrl $16, %0\\n\\t&quot; //将inc右移16位 inc=inc&gt;&gt;16\n&quot;1:\\t&quot;\n&quot;cmpl %0, %2\\n\\t&quot; //比较inc和tmp，即比较next和owner \n&quot;je 2f\\n\\t&quot; //相等则跳转到标号2处返回\n&quot;rep ; nop\\n\\t&quot; //空指令\n&quot;movzwl %1, %2\\n\\t&quot; //将slock的低16位做0扩展后送tmp 即tmp=owner\n&quot;jmp 1b\\n&quot; //跳转到标号1处继续比较\n&quot;2:&quot;\n:&quot;+Q&quot;(inc),&quot;+m&quot;(lock-&gt;slock),&quot;=r&quot;(tmp)\n::&quot;memory&quot;,&quot;cc&quot;\n);\n}\n#define UNLOCK_LOCK_PREFIX LOCK_PREFIX\nstatic inline void __raw_spin_unlock(raw_spinlock_t*lock){\n__asm__ __volatile__(\nUNLOCK_LOCK_PREFIX&quot;incw %0&quot;//将slock的低16位加1 即owner+1\n:&quot;+m&quot;(lock-&gt;slock)\n::&quot;memory&quot;,&quot;cc&quot;);\n}\n</code></pre><p>上述代码中的注释已经描述得很清楚了，每条指令都有注解，供你参考。这里需要注意的是Linux为了避免差异性，在spinlock_t结构体中包含了raw_spinlock_t，而在raw_spinlock_t结构体中并没使用next和owner字段，而是在代码中直接操作slock的高16位和低16位来实现的。</p><p>不知道你有没有过这样的经历？当你去银行办事，又发现人很多时，你很可能会选择先去处理一些别的事情，等过一会人比较少了，再来办理我们自己的业务。</p><p>其实，在使用自旋锁时也有同样的情况，当一个进程发现另一个进程已经拥有自己所请求的自旋锁时，就自愿放弃，转而做其它别的工作，并不想在这里循环等待，浪费自己的时间。</p><p>对于这种情况，Linux同样提供了相应的自旋锁接口，如下所示。</p><pre><code>static inline int __raw_spin_trylock(raw_spinlock_t*lock){\n    int tmp;\n    int new;\n    asm volatile(\n    &quot;movl %2,%0\\n\\t&quot;//tmp=slock\n    &quot;movl %0,%1\\n\\t&quot;//new=tmp\n    &quot;roll $16, %0\\n\\t&quot;//tmp循环左移16位，即next和owner交换了\n    &quot;cmpl %0,%1\\n\\t&quot;//比较tmp和new即（owner、next）？=（next、owner）\n    &quot;jne 1f\\n\\t&quot; //不等则跳转到标号1处 \n    &quot;addl $0x00010000, %1\\n\\t&quot;//相当于next+1\n    &quot;lock ; cmpxchgl %1,%2\\n\\t&quot;//new和slock交换比较    \n    &quot;1:&quot;\n    &quot;sete %b1\\n\\t&quot; //new = eflags.ZF位，ZF取决于前面的判断是否相等\n    &quot;movzbl %b1,%0\\n\\t&quot; //tmp = new\n    :&quot;=&amp;a&quot;(tmp),&quot;=Q&quot;(new),&quot;+m&quot;(lock-&gt;slock)\n    ::&quot;memory&quot;,&quot;cc&quot;);\n    return tmp;\n}\nint __lockfunc _spin_trylock(spinlock_t*lock){ \n    preempt_disable();\n    if(_raw_spin_trylock(lock)){\n        spin_acquire(&amp;lock-&gt;dep_map,0,1,_RET_IP_);\n        return 1;\n    }\n    preempt_enable();\n    return 0;\n}\n#define spin_trylock(lock) __cond_lock(lock, _spin_trylock(lock))\n</code></pre><p>_cond_lock只用代码静态检查工作，一定要明白_spin_trylock返回1表示尝试加锁成功，可以安全的地问共享资源了；返回值为0则表示尝试加锁失败，不能操作共享资源，应该等一段时间，再次尝试加锁。</p><h2>Linux信号量</h2><p>Linux中的信号量同样是用来保护共享资源，能保证资源在一个时刻只有一个进程使用，这是单值信号量。也可以作为资源计数器，比如一种资源有五份，同时最多可以有五个进程，这是多值信号量。</p><p>单值信号量，类比于私人空间一次只进去一个人，其信号量的值初始值为1，而多值信号量，相当于是客厅，可同时容纳多个人。其信号量的值初始值为5，就可容纳5个人。</p><p>信号量的值为正的时候。所申请的进程可以锁定使用它。若为0，说明它被其它进程占用，申请的进程要进入睡眠队列中，等待被唤醒。所以信号量最大的优势是既<strong>可以使申请失败的进程睡眠，还可以作为资源计数器使用。</strong></p><p>我们先来看看Linux实现信号量所使用的数据结构，如下所示：</p><pre><code>struct semaphore{\n    raw_spinlock_t lock;//保护信号量自身的自旋锁\n    unsigned int count;//信号量值\n    struct list_head wait_list;//挂载睡眠等待进程的链表\n};\n</code></pre><p>下面我们就跟着Linux信号量接口函数，一步步探索Linux信号量工作原理，和它对进程状态的影响，先来看看Linux信号量的使用案例，如下所示。</p><pre><code>#define down_console_sem() do { \\\n    down(&amp;console_sem);\\\n} while (0)\nstatic void __up_console_sem(unsigned long ip) {\n    up(&amp;console_sem);\n}\n#define up_console_sem() __up_console_sem(_RET_IP_)\n//加锁console\nvoid console_lock(void)\n{\n    might_sleep();\n    down_console_sem();//获取信号量console_sem\n    if (console_suspended)\n        return;\n    console_locked = 1;\n    console_may_schedule = 1;\n}\n//解锁console\nvoid console_unlock(void)\n{\n    static char ext_text[CONSOLE_EXT_LOG_MAX];\n    static char text[LOG_LINE_MAX + PREFIX_MAX];\n    //……删除了很多代码\n    up_console_sem();//释放信号量console_sem\n    raw_spin_lock(&amp;logbuf_lock);\n    //……删除了很多代码   \n}\n</code></pre><p>为了简单说明问题，我删除了很多代码，上面代码中以console驱动为例说明了信号量的使用。</p><p>在Linux源代码的kernel/printk.c中，使用宏DEFINE_SEMAPHORE声明了一个单值信号量console_sem，也可以说是<strong>互斥锁</strong>，它用于保护console驱动列表console_drivers以及同步对整个console驱动的访问。</p><p>其中定义了宏down_console_sem()来获得信号量console_sem，定义了宏up_console_sem()来释放信号量console_sem，console_lock和console_unlock函数是用于互斥访问console驱动的，核心操作就是调用前面定义两个宏。</p><p>上面的情景中，down_console_sem()和up_console_sem()宏的核心主要是调用了信号量的接口函数down、up函数，完成获取、释放信号量的核心操作，代码如下。</p><pre><code>static inline int __sched __down_common(struct semaphore *sem, long state,long timeout)\n{\n    struct semaphore_waiter waiter;\n    //把waiter加入sem-&gt;wait_list的头部\n    list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list);\n    waiter.task = current;//current表示当前进程，即调用该函数的进程\n    waiter.up = false;\n    for (;;) {\n        if (signal_pending_state(state, current))\n            goto interrupted;\n        if (unlikely(timeout &lt;= 0))\n            goto timed_out;\n        __set_current_state(state);//设置当前进程的状态，进程睡眠，即先前__down函数中传入的TASK_UNINTERRUPTIBLE：该状态是等待资源有效时唤醒（比如等待键盘输入、socket连接、信号（signal）等等），但不可以被中断唤醒\n        raw_spin_unlock_irq(&amp;sem-&gt;lock);//释放在down函数中加的锁\n        timeout = schedule_timeout(timeout);//真正进入睡眠\n        raw_spin_lock_irq(&amp;sem-&gt;lock);//进程下次运行会回到这里，所以要加锁\n        if (waiter.up)\n            return 0;\n    }\n timed_out:\n    list_del(&amp;waiter.list);\n    return -ETIME;\n interrupted:\n    list_del(&amp;waiter.list);\n    return -EINTR;\n\n    //为了简单起见处理进程信号（signal）和超时的逻辑代码我已经删除\n}\n//进入睡眠等待\nstatic noinline void __sched __down(struct semaphore *sem)\n{\n    __down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n}\n//获取信号量\nvoid down(struct semaphore *sem)\n{\n    unsigned long flags;\n    //对信号量本身加锁并关中断，也许另一段代码也在操作该信号量\n    raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);\n    if (likely(sem-&gt;count &gt; 0))\n        sem-&gt;count--;//如果信号量值大于0,则对其减1\n    else\n        __down(sem);//否则让当前进程进入睡眠\n    raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);\n}\n//实际唤醒进程 \nstatic noinline void __sched __up(struct semaphore *sem)\n{\n    struct semaphore_waiter *waiter = list_first_entry(&amp;sem-&gt;wait_list, struct semaphore_waiter, list);\n    //获取信号量等待链表中的第一个数据结构semaphore_waiter，它里面保存着睡眠进程的指针\n    list_del(&amp;waiter-&gt;list);\n    waiter-&gt;up = true;\n    wake_up_process(waiter-&gt;task);//唤醒进程重新加入调度队列\n}\n//释放信号量\nvoid up(struct semaphore *sem)\n{\n    unsigned long flags;\n    //对信号量本身加锁并关中断，必须另一段代码也在操作该信号量\n    raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);\n    if (likely(list_empty(&amp;sem-&gt;wait_list)))\n        sem-&gt;count++;//如果信号量等待链表中为空，则对信号量值加1\n    else\n        __up(sem);//否则执行唤醒进程相关的操作\n    raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);\n}\n</code></pre><p>上述代码中的逻辑，已经描述了信号量的工作原理。需要注意的是，一个进程进入了__down函数中，设置了一个不可中断的等待状态，然后执行了schedule_timeout函数。这个执行了进程的调度器，就直接调度到别的进程运行了。</p><p>这时，这个进程就不会返回了，直到下一次它被up函数唤醒。执行了wake_up_process函数以后，重新调度它就会回到schedule_timeout函数下一行代码，沿着调用路经返回，最后从__down函数中出来，即进程睡醒了。</p><h2>Linux读写锁</h2><p>在操作系统中，有很多共享数据，进程对这些共享数据要进行修改的情况很少，而读取的情况却是非常多的，这些共享数据的操作基本都是在读取。</p><p>如果每次读取这些共享数据都加锁的话，那就太浪费时间了，会降低进程的运行效率。因为读操作不会导致修改数据，所以在读取数据的时候不用加锁了，而是可以共享的访问，只有涉及到对共享数据修改的时候，才需要加锁互斥访问。</p><p>想像一下100个进程同时读取一个共享数据，而每个进程都要加锁解锁，剩下的进程只能等待，这会大大降低整个系统性能，这时候就需要使用一种新的锁了——读写锁。</p><p>读写锁也称为共享-独占（shared-exclusive）锁，当读写锁用读取模式加锁时，它是以共享模式上锁的，当以写入修改模式加锁时，它是以独占模式上锁的（互斥）。</p><p>读写锁非常适合<strong>读取数据的频率远大于修改数据的频率</strong>的场景中。这样可以在任何时刻，保证多个进程的读取操作并发地执行，给系统带来了更高的并发度。</p><p>那读写锁是怎么工作的呢？读写之间是互斥的，读取的时候不能写入，写入的时候不能读取，而且读取和写入操作在竞争锁的时候，写会优先得到锁，步骤如下。</p><p>1.当共享数据没有锁的时候，读取的加锁操作和写入的加锁操作都可以满足。<br>\n2.当共享数据有读锁的时候，所有的读取加锁操作都可以满足，写入的加锁操作不能满足，读写是互斥的。<br>\n3.当共享数据有写锁的时候，所有的读取的加锁操作都不能满足，所有的写入的加锁操作也不能满足，读与写之间是互斥的，写与写之间也是互斥的。</p><p>如果你感觉刚才说的步骤还是太复杂，那我再给你画一个表，你就清楚了，如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/70/08/70c2d2580e8ec4b138db2f2807ba9f08.jpg?wh=1625*848\" alt=\"\"></p><p>好了，我们明白了读写锁的加锁规则，现在就去看看Linux中的读写锁的实现，<strong>Linux中的读写锁本质上是自旋锁的变种。</strong></p><p>后面这段代码是Linux中读写锁的核心代码，请你注意，<strong>实际操作的时候，我们不是直接使用上面的函数和数据结构，而是应该使用Linux提供的标准接口，如read_lock、write_lock等。</strong></p><pre><code>//读写锁初始化锁值\n#define RW_LOCK_BIAS\t\t 0x01000000\n//读写锁的底层数据结构\ntypedef struct{\n    unsigned int lock;\n}arch_rwlock_t;\n//释放读锁 \nstatic inline void arch_read_unlock(arch_rwlock_t*rw){ \n    asm volatile(\n        LOCK_PREFIX&quot;incl %0&quot; //原子对lock加1\n        :&quot;+m&quot;(rw-&gt;lock)::&quot;memory&quot;);\n}\n//释放写锁\nstatic inline void arch_write_unlock(arch_rwlock_t*rw){\n    asm volatile(\n        LOCK_PREFIX&quot;addl %1, %0&quot;//原子对lock加上RW_LOCK_BIAS\n        :&quot;+m&quot;(rw-&gt;lock):&quot;i&quot;(RW_LOCK_BIAS):&quot;memory&quot;);\n}\n//获取写锁失败时调用\nENTRY(__write_lock_failed)\n    //(%eax)表示由eax指向的内存空间是调用者传进来的 \n    2:LOCK_PREFIX addl\t$ RW_LOCK_BIAS,(%eax)\n    1:rep;nop//空指令\n    cmpl $RW_LOCK_BIAS,(%eax)\n    //不等于初始值则循环比较，相等则表示有进程释放了写锁\n    jne\t 1b\n    //执行加写锁\n    LOCK_PREFIX subl\t$ RW_LOCK_BIAS,(%eax)\n    jnz 2b //不为0则继续测试，为0则表示加写锁成功\n    ret //返回\nENDPROC(__write_lock_failed)\n//获取读锁失败时调用\nENTRY(__read_lock_failed)\n    //(%eax)表示由eax指向的内存空间是调用者传进来的 \n    2:LOCK_PREFIX incl(%eax)//原子加1\n    1:\trep; nop//空指令\n    cmpl\t$1,(%eax) //和1比较 小于0则\n    js 1b //为负则继续循环比较\n    LOCK_PREFIX decl(%eax) //加读锁\n    js\t2b\t//为负则继续加1并比较，否则返回\n    ret //返回\nENDPROC(__read_lock_failed)\n//获取读锁\nstatic inline void arch_read_lock(arch_rwlock_t*rw){\n    asm volatile(\n        LOCK_PREFIX&quot; subl $1,(%0)\\n\\t&quot;//原子对lock减1\n        &quot;jns 1f\\n&quot;//不为小于0则跳转标号1处，表示获取读锁成功\n        &quot;call __read_lock_failed\\n\\t&quot;//调用__read_lock_failed\n        &quot;1:\\n&quot;\n        ::LOCK_PTR_REG(rw):&quot;memory&quot;);\n}\n//获取写锁\nstatic inline void arch_write_lock(arch_rwlock_t*rw){\n    asm volatile(\n        LOCK_PREFIX&quot;subl %1,(%0)\\n\\t&quot;//原子对lock减去RW_LOCK_BIAS\n        &quot;jz 1f\\n&quot;//为0则跳转标号1处\n        &quot;call __write_lock_failed\\n\\t&quot;//调用__write_lock_failed\n        &quot;1:\\n&quot;\n        ::LOCK_PTR_REG(rw),&quot;i&quot;(RW_LOCK_BIAS):&quot;memory&quot;);\n}\n</code></pre><p>Linux读写锁的原理本质是基于计数器，初始值为0x01000000，获取读锁时对其减1，结果不小于0则表示获取读锁成功，获取写锁时直接减去0x01000000。</p><p>说到这里你可能要问了，为何要减去初始值呢？这是因为只有当锁值为初始值时，减去初始值结果才可以是0，这是唯一没有进程持有任何锁的情况，这样才能保证获取写锁时是互斥的。</p><p>__read_lock_failed、__write_lock_failed是两个汇编函数，注释写得很详细了，和前面自旋锁的套路是一样的。我们可以看出，读写锁其实是带计数的特殊自旋锁，能同时被多个读取数据的进程占有或一个修改数据的进程占有，但不能同时被读取数据的进程和修改数据的进程占有。</p><p>我们再次梳理一下获取、释放读写锁的流程，如下所示。</p><p>1.获取读锁时，锁值变量lock计数减去1，判断结果的符号位是否为1。若结果符号位为0时，获取读锁成功，即表示lock大于0。<br>\n2.获取读锁时，锁值变量lock计数减去1，判断结果的符号位是否为1。若结果符号位为1时，获取读锁失败，表示此时读写锁被修改数据的进程占有，此时调用__read_lock_failed失败处理函数，循环测试lock+1的值，直到结果的值大于等于1。<br>\n3.获取写锁时，锁值变量lock计数减去RW_LOCK_BIAS_STR，即lock-0x01000000，判断结果是否为0。若结果为0时，表示获取写锁成功。<br>\n4.获取写锁时，锁值变量lock计数减去RW_LOCK_BIAS_STR，即lock-0x01000000，判断结果是否为0。若结果不为0时，获取写锁失败，表示此时有读取数据的进程占有读锁或有修改数据的进程占有写锁，此时调用__write_lock_failed失败处理函数，循环测试lock+0x01000000，直到结果的值等于0x01000000。</p><h2>重点回顾</h2><p>好了，这节课的内容讲完了。我们一起学习了Linux上实现数据同步的五大利器，分别是Linux原子变量、Linux中断控制、Linux自旋锁、Linux信号量、Linux读写锁。我把重点给你梳理一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/a9/7fd3abc144bb40331ca2aeb05ab5b7a9.jpg?wh=3145*2137\" alt=\"\"></p><p>锁，保证了数据的安全访问，但是它给程序的并行性能造成了巨大损害，所以在设计一个算法时应尽量避免使用锁。若无法避免，则应根据实际情况使用相应类型的锁，以降低锁的不当使用带来的性能损失。</p><h2>思考题</h2><p>请试着回答：上述Linux的读写锁，支持多少个进程并发读取共享数据？这样的读写锁有什么不足？</p><p>欢迎你在留言区和我交流，相信通过积极参与，你将更好地理解这节课的内容。</p><p>我是 LMOS，我们下节课见！</p>","comments":[{"had_liked":false,"id":295045,"user_name":"老男孩","can_delete":false,"product_type":"c1","uid":1134514,"ip_address":"","ucode":"CEC6D47412F620","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/b2/1e8b5616.jpg","comment_is_top":true,"comment_ctime":1622193582,"is_pvip":false,"replies":[{"id":"107295","content":"嗯嗯见解独到","user_name":"作者回复","comment_id":295045,"uid":"1345199","ip_address":"","utype":1,"ctime":1622472904,"user_name_real":"LMOS"}],"discussion_count":4,"race_medal":0,"score":"9.2233721759159009e+18","product_id":100078401,"comment_content":"这个排队自旋锁的实现方式感觉很风骚啊。关于读锁最大支持进程数是0x01000000（学友们都已经解答了）关于写饥饿的问题，既然写锁和读锁在同时获取锁状态时候写锁优先，那么就应该对读锁做一个限制，不能让读锁朝着最大数奔去。比如，系统检测到有写锁在等待，那么就限制新的读锁加入，等已经存在的读锁都释放了，写锁马上加锁更新资源。然后等待的读锁再开始加锁读取。这个等待的队列要分为读锁队列和写锁队列。优先处理写锁队列，在没有写锁的时候才能继续加读锁，如果有写锁等待，那么新的读锁不管超没超出那个最大数，都要进入读锁队列等待写锁完成后再开始自己的表演。","like_count":33,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520925,"discussion_content":"嗯嗯见解独到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622472904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364645,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/a5/7acbd63a.jpg","nickname":"eddy","note":"","ucode":"E71EE2FAD96000","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582488,"discussion_content":"我怎么就没理解这个优先么？\n明明是写锁优先，还限制读锁，这难道是要读锁被饿死后还鞭尸？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659452252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129610,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3c/8a/900ca88a.jpg","nickname":"test","note":"","ucode":"C57A175CBC6547","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568381,"discussion_content":"限制读，那等写完了，数据不是变了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651121976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134694,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/66/047ee060.jpg","nickname":"Return12321","note":"","ucode":"F7A3C5ED02E1D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413377,"discussion_content":"的确，加入队列和优先级就可解决锁饥饿的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636460228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295378,"user_name":"springXu","can_delete":false,"product_type":"c1","uid":2064750,"ip_address":"","ucode":"F5DB0B963C894F","user_header":"","comment_is_top":true,"comment_ctime":1622387215,"is_pvip":true,"replies":[{"id":"107267","content":"你好，铁子总结 到位","user_name":"作者回复","comment_id":295378,"uid":"1345199","ip_address":"","utype":1,"ctime":1622469798,"user_name_real":"LMOS"}],"discussion_count":3,"race_medal":0,"score":"9.2233721114916004e+18","product_id":100078401,"comment_content":"同步与锁<br>操作系统是让应用程序认为当前有超大的内存空间和强大的cpu来工作的硬件环境，但其实硬件没有这么强大。那如何解决呢？比如在单核cpu上可以用分时技术，让进程交替执行。对于一个进程来说，我们可以把一个进程变成了多个线程来执行。但这样就产生了同一个资源可以是内存的某一具体地址，可以是鼠标可以是磁盘上的某一文件被多个线程访问和修改的问题。这两节课提供了解决思路，一个是cosmos操作系统的方案，一个是linux的方案。<br>1.原子性。就是硬件执行指令时不被打断。对于x86是复杂指令集。一条指令可以做读修改内存值的操作，指令集中直接支持锁定操作。对于精简指令集，就相对麻烦些，硬件会提供bitband的操作。<br>2.中断控制是在执行时，防止中断信号突然来了把当前执行的过程打断了。 解决方法就是关闭中断。让中断信号等到可以通知时，才发起通知。<br>3.自旋锁。在多核的cpu环境下，当前核心的cpu要访问的资源是有可能被其他核的cpu来访问的。如果产生这种情况，那就让其他核的cpu自己执行空转。一直到当前核心的cpu把访问资源让出后，其他核的cpu通过检测到了可以访问资源，不在空转执行相关操作恢复正常运行。而这个过程就是自旋锁。这里会有一点浪费cpu的运行效率。毕竟有个cpu在空转。当空转时间过长时，浪费的效能更大。我们需要更好的利用cpu核的方式来解决这个问题。那就是互斥。<br>4.信号量<br>对于单一资源的信号量也可以说是互斥锁。  互斥锁和自旋锁的区别就是原来那个空转的核不再空转，而是把当前运行的线程或者进程睡眠去执行其他的线程或者进程了。  当资源被适当后，去通知睡眠线程或者进程。这就是信号量。linux下新版本的信号量在被移除。","like_count":18,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521054,"discussion_content":"你好，铁子总结 到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622469798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147795,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBV8Deuz0Ys4omVlErUvTeRLt7xYRPd8nxhSZ1C2Q9Nice7icHnndsHmyT3KBenxLGw7xghlDzfIuA/132","nickname":"LT","note":"","ucode":"4E902E1EFBB9C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377938,"discussion_content":"这章的代码和当前的linux代码有点对不上（rwlock, spin_trylock），是linux在做改进吗？这些改进能说明一下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622972886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2064750,"avatar":"","nickname":"springXu","note":"","ucode":"F5DB0B963C894F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377168,"discussion_content":"谢谢东哥的鼓励。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622535568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339965,"user_name":"Qfeng","can_delete":false,"product_type":"c1","uid":1466121,"ip_address":"","ucode":"1248E70012BBA2","user_header":"https://static001.geekbang.org/account/avatar/00/16/5f/09/2ec44412.jpg","comment_is_top":true,"comment_ctime":1648515410,"is_pvip":false,"replies":[{"id":"124365","content":"是的 ","user_name":"作者回复","comment_id":339965,"uid":"1345199","ip_address":"","utype":1,"ctime":1648605951,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"9.223372055683199e+18","product_id":100078401,"comment_content":"回答思考题：Linux 的读写锁，因为每次读锁加锁计数-1，所以最多支持0x01000000个进程并发读取共享数据。<br>这样的读写锁的不足：读或者写锁拿不到时忙等，可以优化成trylock，拿不到可以先干其他的，等一段时间再尝试拿锁。（不知道回答的对不对）<br><br>感悟：不论是单值信号量还是多值信号量，亦或是原始自旋锁、trylock版本自旋锁还是读写锁，各种机制的设计和优化都是为了资源（CPU等）的更合理更高效的使用而优化。互斥机制有很多，理解每种锁机制重要，但是理解我们的业务更重要，这样才能因地制宜选择合适的锁。<br><br>老师简明扼要，点到即止的文风太赞了，谢谢。","like_count":5,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559083,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648605951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294934,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1622160439,"is_pvip":false,"replies":[{"id":"107308","content":"哈哈 欢迎","user_name":"作者回复","comment_id":294934,"uid":"1345199","ip_address":"","utype":1,"ctime":1622473557,"user_name_real":"LMOS"}],"discussion_count":2,"race_medal":0,"score":"117586277431","product_id":100078401,"comment_content":"以后我就是第一东吹了😁！<br>像这样的清晰明了，言简意赅的Linux内核源码解读实在是太少了，这样的文章读起来实在是太爽了，强烈小编安排一下东哥的下一个专栏叫做 《纵览Linux源码，小白也能学透》。<br><br>对于思考题答案，读并发进程的最大个数就是0x01000000，只要lock大于0都是可以共享数据的。<br>至于读写锁的不足，我个人觉得最不友好的点在于读写互斥上，由于读锁对写锁是互斥的，如果一直有人读，那么计数器一直小于0x01000000，加写锁时也一直小于0，写锁一直也不会成功，会陷入长时间的写饥饿状态，并且一直自旋，浪费CPU资源。<br>所以改进点就在于，给写进程配上一个休眠队列，待加锁失败进入队列休眠等待，待解读锁时判断计数器，决定是否唤醒队列中的写进程。<br>当然还有很多其它的优化点，欢迎大家集思广益~","like_count":28,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520878,"discussion_content":"哈哈 欢迎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2950704,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/06/30/c26ea06a.jpg","nickname":"艾恩凝","note":"","ucode":"F2B81BF4F0106A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558954,"discussion_content":"锁就是锁，优化啥，应用场景不同，个人认为不是不能优化，每个锁都有它存在的道理，像这种长时间有写操作的场景，用读写锁就不适用了，明明知道要长时间等待，还要用这种短时间才用的锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648527689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294945,"user_name":"blentle","can_delete":false,"product_type":"c1","uid":1064679,"ip_address":"","ucode":"AC092609A4942A","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/e7/261711a5.jpg","comment_is_top":false,"comment_ctime":1622163542,"is_pvip":false,"replies":[{"id":"107306","content":"嗯嗯","user_name":"作者回复","comment_id":294945,"uid":"1345199","ip_address":"","utype":1,"ctime":1622473489,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"61751705686","product_id":100078401,"comment_content":"回答一下思考题<br>1.理论上可以支持x01000000这么多进程，但实际上受限于文件句炳也就是文件描述符的限制，还有考虑多个线程的问题等等，注定最终远远小于这个值<br>2.读写锁造成写饥饿的情况是不是可以参考jdk的读写锁的实现，在条件等待队列中判断队列第一个元素是不是一个写进程，如果是写进程，让其直接优先获取锁.","like_count":15,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520887,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296899,"user_name":"Geek_8c4220","can_delete":false,"product_type":"c1","uid":2028446,"ip_address":"","ucode":"5370E7C39AD1E3","user_header":"","comment_is_top":false,"comment_ctime":1623218891,"is_pvip":false,"replies":[{"id":"107853","content":"因为我没有讲","user_name":"作者回复","comment_id":296899,"uid":"1345199","ip_address":"","utype":1,"ctime":1623245032,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"18803088075","product_id":100078401,"comment_content":"为什么这节里实现自旋锁的时候都没有关中断了呢？","like_count":4,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521633,"discussion_content":"因为我没有讲","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623245032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313284,"user_name":"子青","can_delete":false,"product_type":"c1","uid":1200029,"ip_address":"","ucode":"F6D22EB15325FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/9d/72461b25.jpg","comment_is_top":false,"comment_ctime":1632363959,"is_pvip":true,"replies":[{"id":"113517","content":"1.进程调用自旋锁，是在内核态运行的内核代码，如果在这个代码路径上挂了，那就说明内核有BUG 需要修正<br>2. up之后会对进程的优先级进行处理的，不会后面的进程没机会的","user_name":"作者回复","comment_id":313284,"uid":"1345199","ip_address":"","utype":1,"ctime":1632445425,"user_name_real":"LMOS"}],"discussion_count":2,"race_medal":0,"score":"14517265847","product_id":100078401,"comment_content":"老师，我有两个问题想请教<br>1 。Linux自旋锁，如果一个进程在获取锁之后挂了怎么办，没人给owner +1了，后面排队的进程岂不是永远等不到锁释放？<br>2。信号量那里，down是在链表的头部插入，up是唤醒链表的头部，这样不会有饥饿问题吗，链表后面的可能永远拿不到资源？","like_count":4,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527302,"discussion_content":"1.进程调用自旋锁，是在内核态运行的内核代码，如果在这个代码路径上挂了，那就说明内核有BUG 需要修正\n2. up之后会对进程的优先级进行处理的，不会后面的进程没机会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632445425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2834444,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/40/0c/19b4224a.jpg","nickname":"不写出操作系统不改名","note":"","ucode":"DD40D98250B688","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412558,"discussion_content":"你的第2问，看代码里是把它加入到了sem->wait_list的尾部了，没有插入到头部。up唤醒的时候是从头部唤醒的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636208367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331157,"user_name":"疯码","can_delete":false,"product_type":"c1","uid":1228313,"ip_address":"","ucode":"7FF11EC80439EA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vQiadbkZYR239J80hjekw7jzY9vy6otLKPNDSuz2lruDiaXlKGkcsX5wwiaFevicgqV8odlRG4UITiadDF3fgicrHPcw/132","comment_is_top":false,"comment_ctime":1642469278,"is_pvip":false,"replies":[{"id":"121015","content":"eflags寄存器不能使用mov指令访问","user_name":"作者回复","comment_id":331157,"uid":"1345199","ip_address":"","utype":1,"ctime":1642495790,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10232403870","product_id":100078401,"comment_content":"请问下为什么保存和恢复eflags那段代码用push pop而不是mov呢","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547015,"discussion_content":"eflags寄存器不能使用mov指令访问","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642495790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326120,"user_name":"GeekYanger","can_delete":false,"product_type":"c1","uid":2046036,"ip_address":"","ucode":"E674B7D25261CC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sOuSC65kXWdWBAIIs6uXAD41Ed8Wo8tib81LLVOQJ2oK23TgPDy6x0PGmp7rXwLR3BHOicaKx1zib1DyfpCITK3dw/132","comment_is_top":false,"comment_ctime":1639386760,"is_pvip":false,"replies":[{"id":"118725","content":"对 对 对 我大意了","user_name":"作者回复","comment_id":326120,"uid":"1345199","ip_address":"","utype":1,"ctime":1639703029,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"10229321352","product_id":100078401,"comment_content":"文中：<br>“&#47;&#47;Linux没有这样的结构，这只是为了描述方便<br>typedef struct raw_spinlock<br>{ <br>        union <br>                { <br>                        unsigned int slock;&#47;&#47;真正的锁值变量 <br>                        u16 owner; <br>                        u16 next; <br>                }<br>}raw_spinlock_t;”<br>这里老师为了帮助我们理解汇编代码构造了一个这样的结构体，我觉得，这个owner和next要被包在一个struct中才是老师想要表述的意思，不然owner和next的取值是一样的，都是低16位。","like_count":3,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539383,"discussion_content":"对 对 对 我大意了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639703029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539412,"discussion_content":"更正后的代码是\n//RAW层的自旋锁数据结构\ntypedef struct raw_spinlock{\n    unsigned int slock;//真正的锁值变量\n}raw_spinlock_t;\n//最上层的自旋锁数据结构\ntypedef struct spinlock{\n    struct raw_spinlock rlock;\n}spinlock_t;\n//Linux没有这样的结构，这只是为了描述方便\ntypedef struct raw_spinlock{\n    union {\n        unsigned int slock;//真正的锁值变量\n        struct {\n        u16 owner;\n        u16 next;\n        }\n    }\n}raw_spinlock_t;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639710277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539411,"discussion_content":"感谢反馈，我们已经改正啦，刷新可见。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639710266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301229,"user_name":"Geek_4b6813","can_delete":false,"product_type":"c1","uid":1721895,"ip_address":"","ucode":"ED10C17BE368B4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/46/27/eb318d12.jpg","comment_is_top":false,"comment_ctime":1625582250,"is_pvip":false,"replies":[{"id":"109107","content":"是的 ","user_name":"作者回复","comment_id":301229,"uid":"1345199","ip_address":"","utype":1,"ctime":1625625672,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"10215516842","product_id":100078401,"comment_content":"最多支持同时有2^24个进程共享读锁(计算机常驻的进程基本上是不可能达到这个数的)<br>存在的问题，写饥饿，只要有读进程存在，写进程就永远没机会获得锁。","like_count":3,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522935,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625625672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297515,"user_name":"K菌无惨","can_delete":false,"product_type":"c1","uid":2194764,"ip_address":"","ucode":"97A532D588FD49","user_header":"","comment_is_top":false,"comment_ctime":1623592688,"is_pvip":false,"replies":[{"id":"108063","content":"这是Linux那一套，它有一个检查工具，对代码进行静态检查，能及早发现问题","user_name":"作者回复","comment_id":297515,"uid":"1345199","ip_address":"","utype":1,"ctime":1623723285,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"10213527280","product_id":100078401,"comment_content":"请问“_cond_lock 只用代码静态检查工作”这句话时什么意思？","like_count":3,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521843,"discussion_content":"这是Linux那一套，它有一个检查工具，对代码进行静态检查，能及早发现问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623723285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295252,"user_name":"fhs","can_delete":false,"product_type":"c1","uid":1640934,"ip_address":"","ucode":"941734CC64A296","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJWFdKjyLOXtCzowmdCUFHezNlnux4NPWmYsqETjiaHNbnmb7xdzibDncZqP06nNbpN4AhmD76cpicfw/132","comment_is_top":false,"comment_ctime":1622334269,"is_pvip":false,"replies":[{"id":"107275","content":"不是这样的哦 多看看课程","user_name":"作者回复","comment_id":295252,"uid":"1345199","ip_address":"","utype":1,"ctime":1622470498,"user_name_real":"LMOS"}],"discussion_count":2,"race_medal":0,"score":"10212268861","product_id":100078401,"comment_content":"读写锁部分中。假设t1时候1号写线程获取到了锁且不释放：lock=0，t2时刻2号写线程尝试获取：lock=-(0x0100 0000)，t3时刻1号读尝试获取：lock=-(0x0100 0001)。<br>之后1号写即便释放了锁，此时lock = -1。但是2号写的比较成功的条件是：&quot;lock+0x01000000，直到结果的值等于 0x01000000&quot;。1号读的比较条件是&quot;循环测试 lock+1 的值，直到结果的值大于等于 1&quot;。<br>即在1号写释放之后，2号写和1号读因为lock是-1永远达不到各自退出循环的条件，一直在自旋？","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521010,"discussion_content":"不是这样的哦 多看看课程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622470498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214582,"avatar":"https://static001.geekbang.org/account/avatar/00/12/88/76/c69b7fe5.jpg","nickname":"youngitachi","note":"","ucode":"88717CA8B8ED64","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542286,"discussion_content":"没加锁成功的是不会更新lock值的，因此你这里的情况，lock就是0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640701907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342957,"user_name":"doos","can_delete":false,"product_type":"c1","uid":1069269,"ip_address":"","ucode":"7C9AF67F90E65C","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/d5/73334a95.jpg","comment_is_top":false,"comment_ctime":1650549199,"is_pvip":false,"replies":[{"id":"125286","content":"看你的目的，为了理解这门课，很多内容可以现搜的。汇编到初始化那里，后面都是C。具体有啥不懂之处，你可以再留言提问。","user_name":"编辑回复","comment_id":342957,"uid":"1501385","ip_address":"","utype":2,"ctime":1650593717,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5945516495","product_id":100078401,"comment_content":"感觉不学习汇编和c很多都看不懂","like_count":2,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566061,"discussion_content":"看你的目的，为了理解这门课，很多内容可以现搜的。汇编到初始化那里，后面都是C。具体有啥不懂之处，你可以再留言提问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650593717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323636,"user_name":"kocgockohgoh王裒","can_delete":false,"product_type":"c1","uid":2617112,"ip_address":"","ucode":"35EFABDE0D713D","user_header":"https://static001.geekbang.org/account/avatar/00/27/ef/18/6a620733.jpg","comment_is_top":false,"comment_ctime":1638040330,"is_pvip":false,"replies":[{"id":"120098","content":"点赞","user_name":"作者回复","comment_id":323636,"uid":"1345199","ip_address":"","utype":1,"ctime":1641522625,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5933007626","product_id":100078401,"comment_content":"关于小弟问的那个关于排队自旋锁的问题，好像是因为gcc汇编的源 目的和intel手册上的顺序是反的。关于 xaddl，intel手册上说源是寄存器，目的是寄存器或内存。而slock是内存，不可能是源。所以小弟觉得源是%0  inc，目的是%1 slock, 所以xaddl相当于 temp = inc + slock,  inc = slock,  slock = slock + inc。 否则的话，每次调用slock都会被设成inc的初值0001000，不合理。不知道彭东大神觉得如何","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544437,"discussion_content":"点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641522625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298104,"user_name":"Feen","can_delete":false,"product_type":"c1","uid":2646145,"ip_address":"","ucode":"E6CDC442B7213F","user_header":"https://static001.geekbang.org/account/avatar/00/28/60/81/38b00111.jpg","comment_is_top":false,"comment_ctime":1623914455,"is_pvip":false,"replies":[{"id":"108209","content":"这只能表明你理解了计算机中的同步机制，但是操作系统需要知道的东西还有很多 ","user_name":"作者回复","comment_id":298104,"uid":"1345199","ip_address":"","utype":1,"ctime":1623981020,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"5918881751","product_id":100078401,"comment_content":"到第9课的时候，发现留言的数量少了很多，感觉操作系统（或者计算机原理）的淘汰率真的很高，能出师的太少了。关于最后的问题，应该说读锁最大支持的进程数是0x01000000，写锁最大的进程数人为的设置为1。写锁也可以设置为0x01000000，因为对于计算机来说，到底有多少进程写对它来说无关，数据对计算机没有意义，数据只对于人能不能正确使用有关。所以才有上写锁的时候直接减去0x01000000这个初始值，目的是控制只有一个进程可以写，而不是为了1而设置1。不管是中断，信号量，各种锁，最后都要靠CPU硬件的集成指令支持才能完成，就是原子操作，计算机上的各种软件，应用，服务都是靠原子操作完成自己的事务，手段就是在操作的时候不受打断，目的是完成一件事。怎么样能玩好原子操作，就能出师了。哈哈","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522017,"discussion_content":"这只能表明你理解了计算机中的同步机制，但是操作系统需要知道的东西还有很多 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623981020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296421,"user_name":"LT","can_delete":false,"product_type":"c1","uid":1147795,"ip_address":"","ucode":"4E902E1EFBB9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBV8Deuz0Ys4omVlErUvTeRLt7xYRPd8nxhSZ1C2Q9Nice7icHnndsHmyT3KBenxLGw7xghlDzfIuA/132","comment_is_top":false,"comment_ctime":1622968103,"is_pvip":false,"replies":[{"id":"107569","content":"这是旧版 linux的 新版本中没有了 ","user_name":"作者回复","comment_id":296421,"uid":"1345199","ip_address":"","utype":1,"ctime":1622986436,"user_name_real":"LMOS"}],"discussion_count":2,"race_medal":0,"score":"5917935399","product_id":100078401,"comment_content":"static inline int __raw_spin_trylock(raw_spinlock_t*lock){    int tmp;    int new;    asm volatile(    &quot;movl %2,%0\\n\\t&quot;&#47;&#47;tmp=slock    &quot;movl %0,%1\\n\\t&quot;&#47;&#47;new=tmp    &quot;roll $16, %0\\n\\t&quot;&#47;&#47;tmp循环左移16位，即next和owner交换了    &quot;cmpl %0,%1\\n\\t&quot;&#47;&#47;比较tmp和new即（owner、next）？=（next、owner）    &quot;jne 1f\\n\\t&quot; &#47;&#47;不等则跳转到标号1处     &quot;addl $0x00010000, %1\\n\\t&quot;&#47;&#47;相当于next+1    &quot;lock ; cmpxchgl %1,%2\\n\\t&quot;&#47;&#47;new和slock交换比较        &quot;1:&quot;    &quot;sete %b1\\n\\t&quot; &#47;&#47;new = eflags.ZF位，ZF取决于前面的判断是否相等    &quot;movzbl %b1,%0\\n\\t&quot; &#47;&#47;tmp = new    :&quot;=&amp;a&quot;(tmp),&quot;=Q&quot;(new),&quot;+m&quot;(lock-&gt;slock)    ::&quot;memory&quot;,&quot;cc&quot;);    return tmp;}<br><br>这段代码我看懂了，但是在linux代码树中我没有找到，甚至是用grep.<br>我看linux代码经常会有这种情况，找不到相关的ASM代码的实现。LMOS，这段代码在那个文件中？<br><br>建议以后相关代码，标注下linux下的文件路径。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521436,"discussion_content":"这是旧版 linux的 新版本中没有了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622986436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2358828,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ZpAQxicyuOuNQuxcTVk11Gh0UrmLtPyZbFBVBnyC4I7hGmLrYFF8z6xK6USfNV1EDp6BXskjrv7YGHoodH6T6aw/132","nickname":"Geek_3974bd","note":"","ucode":"74E05D25512948","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407903,"discussion_content":"想请教一下，cmpl %0,%1\\n\\t&#34;//比较tmp和new即（owner、next）？=（next、owner）之后，不是已经判断锁未被占用了嘛，为什么将new中的next+1之后，然后将其与slock进行比较，这样的话，&#34;lock ; cmpxchgl %1,%2\\n\\t&#34;//new和slock交换比较，这一步就一定不相等了。不知道理解的对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635147760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295467,"user_name":"宏典","can_delete":false,"product_type":"c1","uid":2616028,"ip_address":"","ucode":"63953F36596C28","user_header":"https://static001.geekbang.org/account/avatar/00/27/ea/dc/aa699264.jpg","comment_is_top":false,"comment_ctime":1622442330,"is_pvip":true,"replies":[{"id":"107259","content":"是的是的 ","user_name":"作者回复","comment_id":295467,"uid":"1345199","ip_address":"","utype":1,"ctime":1622469258,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"5917409626","product_id":100078401,"comment_content":"重新定义一个代码段，避免后面的代码填充cache。因为大部分加锁都是成功的。<br>这个可以理解。<br>但是为何重新重新定义一个代码段，就可以保证后面的代码不填充cache?","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521091,"discussion_content":"是的是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622469258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295248,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1622330746,"is_pvip":false,"replies":[{"id":"107277","content":"是的 是的 ","user_name":"作者回复","comment_id":295248,"uid":"1345199","ip_address":"","utype":1,"ctime":1622470549,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"5917298042","product_id":100078401,"comment_content":"请问老师，四种解决并发的方法中里是不是只有关中断是只和CPU的状态有关，也就是关闭了CPU接受中断调用的服务，其他的原子操作，自旋锁，信号量都需要内存和CPU各自的原子操作来配合？","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521007,"discussion_content":"是的 是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622470549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295188,"user_name":"fhs","can_delete":false,"product_type":"c1","uid":1640934,"ip_address":"","ucode":"941734CC64A296","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJWFdKjyLOXtCzowmdCUFHezNlnux4NPWmYsqETjiaHNbnmb7xdzibDncZqP06nNbpN4AhmD76cpicfw/132","comment_is_top":false,"comment_ctime":1622291771,"is_pvip":false,"replies":[{"id":"107284","content":"为什么 只有128 ","user_name":"作者回复","comment_id":295188,"uid":"1345199","ip_address":"","utype":1,"ctime":1622472312,"user_name_real":"LMOS"}],"discussion_count":7,"race_medal":0,"score":"5917259067","product_id":100078401,"comment_content":"请问下，Linux的读写锁实现中，写锁每次获取的时候都减0x0100 0000，那么如果有超过128个线程同时写，不是就可能会溢出么？即这个实现中最多只能支持128个写线程？","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520978,"discussion_content":"为什么 只有128 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622472312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2495621,"avatar":"https://static001.geekbang.org/account/avatar/00/26/14/85/73e55be5.jpg","nickname":"~","note":"","ucode":"BE5E3BD6EE3665","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545487,"discussion_content":"朋友 0x01000000 是 16 进制，不是二进制，所以不是 128 而是 2^24。这样的话我想也就不会溢出了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641975816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475134,"avatar":"https://static001.geekbang.org/account/avatar/00/16/82/3e/1fc6e36a.jpg","nickname":"zlig","note":"","ucode":"DD5850FA4235E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376779,"discussion_content":"同一时间只有一个进程能得到写锁。128个都需要排队，每个进程进来都需要先获取写锁，完成写任务后，必需释放锁，后面的进程才能开始尝试获取写锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622341351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1640934,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJWFdKjyLOXtCzowmdCUFHezNlnux4NPWmYsqETjiaHNbnmb7xdzibDncZqP06nNbpN4AhmD76cpicfw/132","nickname":"fhs","note":"","ucode":"941734CC64A296","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1475134,"avatar":"https://static001.geekbang.org/account/avatar/00/16/82/3e/1fc6e36a.jpg","nickname":"zlig","note":"","ucode":"DD5850FA4235E5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376866,"discussion_content":"你说的当然没错。我更想表达的是这128个写操作如果在很短时间内同时到来，那么因为每次都是先减去0x0100 0000，会导致超过int最小值导致数据溢出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622386408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376779,"ip_address":""},"score":376866,"extra":""},{"author":{"id":1475134,"avatar":"https://static001.geekbang.org/account/avatar/00/16/82/3e/1fc6e36a.jpg","nickname":"zlig","note":"","ucode":"DD5850FA4235E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1640934,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJWFdKjyLOXtCzowmdCUFHezNlnux4NPWmYsqETjiaHNbnmb7xdzibDncZqP06nNbpN4AhmD76cpicfw/132","nickname":"fhs","note":"","ucode":"941734CC64A296","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376905,"discussion_content":"这个数字本身就是原子操作的，只要有一个进程操作它了，它的值减过之后，后面的进程就直接进入自旋状态。只能等前一个解锁的时候把它加回来，其它的进程才能来竞争。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622420718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376866,"ip_address":""},"score":376905,"extra":""},{"author":{"id":1640934,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJWFdKjyLOXtCzowmdCUFHezNlnux4NPWmYsqETjiaHNbnmb7xdzibDncZqP06nNbpN4AhmD76cpicfw/132","nickname":"fhs","note":"","ucode":"941734CC64A296","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1475134,"avatar":"https://static001.geekbang.org/account/avatar/00/16/82/3e/1fc6e36a.jpg","nickname":"zlig","note":"","ucode":"DD5850FA4235E5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376942,"discussion_content":"LOCK_PREFIX&#34;subl %1,(%0)\\n\\t&#34;//原子对lock减去RW_LOCK_BIAS\n\n每个写进程尝试获取写锁时候是先去减，不为0了再去自旋。不是先判断","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622431478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376905,"ip_address":""},"score":376942,"extra":""}]}]},{"had_liked":false,"id":295102,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1622245205,"is_pvip":false,"replies":[{"id":"107289","content":"不是哦  是由硬件控制的 ","user_name":"作者回复","comment_id":295102,"uid":"1345199","ip_address":"","utype":1,"ctime":1622472562,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"5917212501","product_id":100078401,"comment_content":"请问老师，原子变量的本质是不是只是对寄存器和内存操作，跳过了其他所有中间缓存，是一种用速度换一致性的方法？","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520949,"discussion_content":"不是哦  是由硬件控制的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622472562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295087,"user_name":"陈超","can_delete":false,"product_type":"c1","uid":2610622,"ip_address":"","ucode":"A28CA3E9B5A5C7","user_header":"https://static001.geekbang.org/account/avatar/00/27/d5/be/183c222b.jpg","comment_is_top":false,"comment_ctime":1622212878,"is_pvip":false,"replies":[{"id":"107292","content":"66666，对的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622472677,"ip_address":"","comment_id":295087,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5917180174","product_id":100078401,"comment_content":"我认为，支持并发读的数量是0x01000000,支持并行读的数量是cpu核心的数量；而不足之处就在于忙等浪费cpu时间了。读的时候可以让写的进程让出cpu休眠吗？期望老师高见！","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520944,"discussion_content":"66666，对的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622472677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295031,"user_name":"送过快递的码农","can_delete":false,"product_type":"c1","uid":1587666,"ip_address":"","ucode":"66EA81B3BADC73","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","comment_is_top":false,"comment_ctime":1622189848,"is_pvip":false,"replies":[{"id":"107297","content":"对的 ，原子操作是硬件必须 提供的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622473029,"ip_address":"","comment_id":295031,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5917157144","product_id":100078401,"comment_content":"说下自己对锁底层的理机，锁是依赖硬件提供的原子指令来执行的。普通互斥锁是lock值1 获取锁则对该值进行原子减，如果这个值本身就小于1，那说明被锁住了。。。独写锁的区别是他是0x01000000的值，读锁减1，写锁减0x01000000，读锁可以被0x01000000共享，写锁是互斥的只能被减一次。。。 突然感觉原子操作是计算机最底层的功能，以前在Java碰到这个问题就范懵，就是自己对底层理解太少导致的，无论是应用层的并发包，还是操作系统内核层，对原子操作都是非常依赖。。。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520920,"discussion_content":"对的 ，原子操作是硬件必须 提供的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1927222,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/68/36/478194f3.jpg","nickname":"Shawn Duan","note":"","ucode":"628BAD6473FBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400738,"discussion_content":"到底硬件是怎么提供的？能够简略的讲讲吗？也可以推荐一遍文章。谢谢老师了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633402806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294976,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1622169232,"is_pvip":false,"replies":[{"id":"107301","content":"你好，说说原因 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622473305,"ip_address":"","comment_id":294976,"utype":1}],"discussion_count":6,"race_medal":0,"score":"5917136528","product_id":100078401,"comment_content":" Linux的读写锁，我的看法正好相反，写会造成读饥饿，一直有写入时读进程将会饥饿","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520902,"discussion_content":"你好，说说原因 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2616002,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ea/c2/8da904a3.jpg","nickname":"Aries","note":"","ucode":"04868496F025A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563475,"discussion_content":"文中已经说了读写锁适合读的频率远大于写的频率的场景，如果是写的频率更大，那不论读、写，都上锁就行了，就变成普通的锁了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650004368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1927222,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/68/36/478194f3.jpg","nickname":"Shawn Duan","note":"","ucode":"628BAD6473FBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400734,"discussion_content":"一般就一个写，多个读的场景吧。如果多个写，多个读那就复杂了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633402224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188222,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","nickname":"罗 乾 林","note":"","ucode":"D0406F95176ABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376568,"discussion_content":"表达有误，其实我想说的是，一直有读并不会造成写进程拿不到锁，因为写与读竞争一定是写抢到锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622195465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2314187,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4f/cb/ad3526bc.jpg","nickname":"laah","note":"","ucode":"C3886AA1CC556D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1188222,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","nickname":"罗 乾 林","note":"","ucode":"D0406F95176ABA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408488,"discussion_content":"写锁每次要减 0x01000000 后不为负数才能拿到锁，而读锁每次减 1 后不为负就能拿到锁，所以肯定是读比写成功抢到锁的概率大很多。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635255100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376568,"ip_address":""},"score":408488,"extra":""},{"author":{"id":1466121,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5f/09/2ec44412.jpg","nickname":"Qfeng","note":"","ucode":"1248E70012BBA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2314187,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4f/cb/ad3526bc.jpg","nickname":"laah","note":"","ucode":"C3886AA1CC556D","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":558865,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648515991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":408488,"ip_address":""},"score":558865,"extra":""}]}]},{"had_liked":false,"id":354664,"user_name":"Geek_ba3598","can_delete":false,"product_type":"c1","uid":3139074,"ip_address":"湖北","ucode":"9D83A36A34189B","user_header":"","comment_is_top":false,"comment_ctime":1660653233,"is_pvip":false,"replies":[{"id":"129180","content":"是不是 版本 不对","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1661052559,"ip_address":"湖北","comment_id":354664,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1660653233","product_id":100078401,"comment_content":"自旋锁在哪个头文件中啊？linux&#47;spin_lock.h里吗？但是include根本找不到这个头文件。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584700,"discussion_content":"是不是 版本 不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661052560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2016221,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c3/dd/33648195.jpg","nickname":"金刚","note":"","ucode":"9657132D6E5D9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585335,"discussion_content":"include/linux/spinlock_types.h","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661487696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"安徽"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350678,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1657091778,"is_pvip":false,"replies":[{"id":"128046","content":"是的 你太牛了","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1658388630,"ip_address":"","comment_id":350678,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1657091778","product_id":100078401,"comment_content":"Java 中的 aqs 和 linux 的排队自旋锁，异曲同工。aqs 用队列的数据结构维护了公平性，而 linux 只用 next 和 owner 维护了抢占的顺序性。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580838,"discussion_content":"是的 你太牛了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658388630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347127,"user_name":"花树","can_delete":false,"product_type":"c1","uid":1542107,"ip_address":"","ucode":"810A5B42EEE264","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/db/c132ef37.jpg","comment_is_top":false,"comment_ctime":1653730160,"is_pvip":false,"replies":[{"id":"126882","content":"你要弄懂那个数据结构和加锁代码 就知道了 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1654912313,"ip_address":"","comment_id":347127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653730160","product_id":100078401,"comment_content":"读写锁那里提到写会优先得到锁，代码里没看到，是怎么实现的呀","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575521,"discussion_content":"你要弄懂那个数据结构和加锁代码 就知道了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654912314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346174,"user_name":"花树","can_delete":false,"product_type":"c1","uid":1542107,"ip_address":"","ucode":"810A5B42EEE264","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/db/c132ef37.jpg","comment_is_top":false,"comment_ctime":1652869177,"is_pvip":false,"replies":[{"id":"126505","content":"其它进程同样要执行 decb 指令的 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1653618068,"ip_address":"","comment_id":346174,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652869177","product_id":100078401,"comment_content":"开始锁值变量为 1 时，执行 decb 指令就变成了 0，0 就表示加锁成功。如果小于 0，则表示有其它进程已经加锁了，就会导致循环比较。<br><br>这里加锁成功值就为0了，其他进程获取值不应该是0吗？为什么是小于零","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573716,"discussion_content":"其它进程同样要执行 decb 指令的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653618068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343129,"user_name":"ljx","can_delete":false,"product_type":"c1","uid":2446982,"ip_address":"","ucode":"6133FC98C44498","user_header":"https://static001.geekbang.org/account/avatar/00/25/56/86/db4c0d1c.jpg","comment_is_top":false,"comment_ctime":1650643538,"is_pvip":true,"replies":[{"id":"125979","content":"减去的锁值不同","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1652066514,"ip_address":"","comment_id":343129,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650643538","product_id":100078401,"comment_content":"老师，读写锁的代码没看出来为什么竞争时写锁会优先获得。能解释一下吗？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571086,"discussion_content":"减去的锁值不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652066514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337552,"user_name":"xy","can_delete":false,"product_type":"c1","uid":2031661,"ip_address":"","ucode":"4D7DB0AC984170","user_header":"https://static001.geekbang.org/account/avatar/00/1f/00/2d/abff5821.jpg","comment_is_top":false,"comment_ctime":1646889705,"is_pvip":false,"replies":[{"id":"123373","content":"优先级","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1646973295,"ip_address":"","comment_id":337552,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646889705","product_id":100078401,"comment_content":"你好读写锁在读锁很多的时候如何做使得写锁能拿到锁呢。感觉这个挺难实现的。看评论这个问题好像没有解释的很清楚哦。非常感谢老师","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555547,"discussion_content":"优先级","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646973295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328050,"user_name":"凉凉","can_delete":false,"product_type":"c1","uid":1325256,"ip_address":"","ucode":"FCCF976E41EF71","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/c8/972a5024.jpg","comment_is_top":false,"comment_ctime":1640503594,"is_pvip":false,"replies":[{"id":"119662","content":"仔细看代码逻辑","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1640768542,"ip_address":"","comment_id":328050,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1640503594","product_id":100078401,"comment_content":"&quot;读锁最大支持进程数是0x01000000&quot;不太理解，这个值怎么得出来的","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542500,"discussion_content":"仔细看代码逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640768542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2616002,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ea/c2/8da904a3.jpg","nickname":"Aries","note":"","ucode":"04868496F025A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563476,"discussion_content":"换成0x10000000也行，懂了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650004474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324564,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1638501770,"is_pvip":true,"replies":[{"id":"117883","content":"受用就好 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1638753529,"ip_address":"","comment_id":324564,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1638501770","product_id":100078401,"comment_content":"小结<br>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？<br>Linux 的原子变量<br>Linux 控制中断<br>Linux 自旋锁<br>1. Linux 原始自旋锁<br>2. Linux 排队自旋锁<br>Linux 信号量<br>Linux 读写锁<br><br>依然觉得老师的思路脉络很清晰，读完结合文末的导图食用更佳","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536293,"discussion_content":"受用就好 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638753529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323634,"user_name":"kocgockohgoh王裒","can_delete":false,"product_type":"c1","uid":2617112,"ip_address":"","ucode":"35EFABDE0D713D","user_header":"https://static001.geekbang.org/account/avatar/00/27/ef/18/6a620733.jpg","comment_is_top":false,"comment_ctime":1638036858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638036858","product_id":100078401,"comment_content":"请问排队自旋锁15 16 行之间 也就是标号2:之后是不是应该加上movl %0，%1啊  不然slock不就变成00010000了么","like_count":0},{"had_liked":false,"id":323631,"user_name":"kocgockohgoh王裒","can_delete":false,"product_type":"c1","uid":2617112,"ip_address":"","ucode":"35EFABDE0D713D","user_header":"https://static001.geekbang.org/account/avatar/00/27/ef/18/6a620733.jpg","comment_is_top":false,"comment_ctime":1638034098,"is_pvip":false,"replies":[{"id":"117626","content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1638323322,"ip_address":"","comment_id":323631,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638034098","product_id":100078401,"comment_content":"请问排队自旋锁  xaddl之后  slock是不是换成inc=00010000啊  这样的话只要一有进程调用，是不是slock就会设成00010000啊","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534952,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638323322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323493,"user_name":"Geek__JASON","can_delete":false,"product_type":"c1","uid":1457801,"ip_address":"","ucode":"B1B4BD97BE3A55","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEK7j6kFBH6Wy9KYcRGjbH7c7zqvjJW6yfu5lFMQEf5qDgJzJbGA1CwMbJwxCedJUTE2Hoj2AfQajQ/132","comment_is_top":false,"comment_ctime":1637932472,"is_pvip":false,"replies":[{"id":"117629","content":"GAS 汇编 是 反的","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1638323421,"ip_address":"","comment_id":323493,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637932472","product_id":100078401,"comment_content":"&quot;lock ; xaddl %0, %1\\n&quot; &#47;&#47;将inc和slock交换，然后 inc=inc+slock<br>感觉应该是 <br>&quot;lock ; xaddl %1, %0\\n&quot; &#47;&#47;将inc和slock交换，然后 inc=inc+slock<br><br>XADD r&#47;m8, r8\tExchange r8 and r&#47;m8; load sum into r&#47;m8. xadd 命令的dest 才能是内存地址；<br>","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534955,"discussion_content":"GAS 汇编 是 反的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638323421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320701,"user_name":"Return12321","can_delete":false,"product_type":"c1","uid":1134694,"ip_address":"","ucode":"F7A3C5ED02E1D9","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/66/047ee060.jpg","comment_is_top":false,"comment_ctime":1636459987,"is_pvip":false,"replies":[{"id":"116316","content":"我们还要考虑读写优先级的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1636506093,"ip_address":"","comment_id":320701,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636459987","product_id":100078401,"comment_content":"读写锁中，如果有1000个线程有999个线程循环读取share数据、1个线程需要写数据，那是否写线程一直获取不到锁，导致无法修改数据？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530085,"discussion_content":"我们还要考虑读写优先级的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636506093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314765,"user_name":"Shawn Duan","can_delete":false,"product_type":"c1","uid":1927222,"ip_address":"","ucode":"628BAD6473FBCE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/68/36/478194f3.jpg","comment_is_top":false,"comment_ctime":1633410927,"is_pvip":false,"replies":[{"id":"114267","content":"你没有读懂xaddl指令","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1633937970,"ip_address":"","comment_id":314765,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633410927","product_id":100078401,"comment_content":"static inline void __raw_spin_lock(raw_spinlock_t*lock){int inc = 0x00010000;int tmp;__asm__ __volatile__(&quot;lock ; xaddl %0, %1\\n&quot; &#47;&#47;将inc和slock交换，然后 inc=inc+slock                        &#47;&#47;相当于原子读取next和owner并对next+1<br><br>这里xaddl 字面意思我懂（将inc和slock交换，然后 inc=inc+slock )。但是如何“相当于原子读取next和owner并对next+1“，我就不懂了，请老师指点。好像是slock的高16位是next, 低16位是owner, 然后和inc相加，怎么就是对next+1了？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527788,"discussion_content":"你没有读懂xaddl指令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633937970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314742,"user_name":"Shawn Duan","can_delete":false,"product_type":"c1","uid":1927222,"ip_address":"","ucode":"628BAD6473FBCE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/68/36/478194f3.jpg","comment_is_top":false,"comment_ctime":1633387327,"is_pvip":false,"replies":[{"id":"114269","content":"是和CPU体系相关的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1633938012,"ip_address":"","comment_id":314742,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633387327","product_id":100078401,"comment_content":"老师，我看了__READ_ONCE和__WRITE_ONCE的实现，还是弄不清是如何实现原子读写的，能解释以下吗？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527779,"discussion_content":"是和CPU体系相关的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633938012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312810,"user_name":"花好月圆","can_delete":false,"product_type":"c1","uid":2425595,"ip_address":"","ucode":"424AC405DE626E","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/fb/30ed9541.jpg","comment_is_top":false,"comment_ctime":1632035724,"is_pvip":true,"replies":[{"id":"113388","content":"可以学的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1632215430,"ip_address":"","comment_id":312810,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632035724","product_id":100078401,"comment_content":"你好，我想问一下对于文中那些代码，是汇编语言吗，没学过汇编语言是不是不可能学下去","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527120,"discussion_content":"可以学的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632215430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311868,"user_name":"IDo","can_delete":false,"product_type":"c1","uid":1026204,"ip_address":"","ucode":"BCF7BFBE35E390","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/9c/91dc7fc4.jpg","comment_is_top":false,"comment_ctime":1631516331,"is_pvip":false,"replies":[{"id":"113154","content":"是的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1631753202,"ip_address":"","comment_id":311868,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631516331","product_id":100078401,"comment_content":"qspinlock没讲呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526777,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631753202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309067,"user_name":"anTalk","can_delete":false,"product_type":"c1","uid":2730532,"ip_address":"","ucode":"5079037241F8AA","user_header":"https://static001.geekbang.org/account/avatar/00/29/aa/24/b46439e8.jpg","comment_is_top":false,"comment_ctime":1629914462,"is_pvip":false,"replies":[{"id":"111869","content":"哈哈 这没有问题先从注释开始看起","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1629939625,"ip_address":"","comment_id":309067,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629914462","product_id":100078401,"comment_content":"看不懂代码，只能看代码注释了！","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525731,"discussion_content":"哈哈 这没有问题先从注释开始看起","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629939625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308974,"user_name":"四喜","can_delete":false,"product_type":"c1","uid":1071389,"ip_address":"","ucode":"C5EBED19C0F332","user_header":"https://static001.geekbang.org/account/avatar/00/10/59/1d/c89abcd8.jpg","comment_is_top":false,"comment_ctime":1629877207,"is_pvip":false,"replies":[{"id":"111874","content":"有些是，有些不是","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1629939894,"ip_address":"","comment_id":308974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629877207","product_id":100078401,"comment_content":"高级编程语言的锁和信号量等接口，是调用系统底层提供的这些接口吗？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525698,"discussion_content":"有些是，有些不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629939894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301734,"user_name":"吴国豪","can_delete":false,"product_type":"c1","uid":2635606,"ip_address":"","ucode":"0899104FDC2C97","user_header":"https://static001.geekbang.org/account/avatar/00/28/37/56/3a527963.jpg","comment_is_top":false,"comment_ctime":1625824550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625824550","product_id":100078401,"comment_content":"&quot;2:\\t&quot; \\ &quot;cmpb $0,%0\\n\\t&quot; \\ &#47;&#47;和0比较 <br>&quot;rep;nop\\n\\t&quot; \\ &#47;&#47;空指令 <br>&quot;jle 2b\\n\\t&quot; \\ &#47;&#47;小于或等于0跳转到标号2<br>这里最开始原子减1，如果小于0，也就是别的进程拿到锁的情况，那别的进程还锁后，应该是0吧。所以这里应该是判断是否小于0，而不是小于等于0？","like_count":0},{"had_liked":false,"id":301730,"user_name":"吴国豪","can_delete":false,"product_type":"c1","uid":2635606,"ip_address":"","ucode":"0899104FDC2C97","user_header":"https://static001.geekbang.org/account/avatar/00/28/37/56/3a527963.jpg","comment_is_top":false,"comment_ctime":1625824202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625824202","product_id":100078401,"comment_content":"&quot;js 2f\\n&quot; \\ &#47;&#47;当结果小于0则跳转到标号2处，表示加锁失败 <br>&quot;.section .text.lock,\\&quot;ax\\&quot;\\n&quot;<br><br>这里如果结果大于0，是不是执行完第二行就结束了，不会再进标号2了呢？","like_count":0},{"had_liked":false,"id":301245,"user_name":"吴国豪","can_delete":false,"product_type":"c1","uid":2635606,"ip_address":"","ucode":"0899104FDC2C97","user_header":"https://static001.geekbang.org/account/avatar/00/28/37/56/3a527963.jpg","comment_is_top":false,"comment_ctime":1625587809,"is_pvip":false,"replies":[{"id":"109106","content":"不会的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1625625655,"ip_address":"","comment_id":301245,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625587809","product_id":100078401,"comment_content":"Linux 排队自旋锁的部分，是怎么保证从读slock，判断，写slock的过程是原子的呢？我看好像分了很多行汇编。有没有可能两个进程同时读，然后判断成功，再写呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522940,"discussion_content":"不会的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625625655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300432,"user_name":"青玉白露","can_delete":false,"product_type":"c1","uid":2619436,"ip_address":"","ucode":"96FE2D4D2B94A0","user_header":"https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg","comment_is_top":false,"comment_ctime":1625152344,"is_pvip":false,"replies":[{"id":"108888","content":"队列是有代价的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1625190386,"ip_address":"","comment_id":300432,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1625152344","product_id":100078401,"comment_content":"从流程上来看，读锁最大为0x01000000；<br>由于读写锁互斥，如果有一个读，其他写都无法，只能自旋，浪费资源，可以考虑给写锁加队列，避免自旋。<br>","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522731,"discussion_content":"队列是有代价的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625190386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1466121,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5f/09/2ec44412.jpg","nickname":"Qfeng","note":"","ucode":"1248E70012BBA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":558866,"discussion_content":"老师，队列的代价是什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648516209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":522731,"ip_address":""},"score":558866,"extra":""}]}]},{"had_liked":false,"id":299672,"user_name":"PawN","can_delete":false,"product_type":"c1","uid":1234005,"ip_address":"","ucode":"D0678E699327DE","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/55/a5ec04f4.jpg","comment_is_top":false,"comment_ctime":1624788785,"is_pvip":false,"replies":[{"id":"108697","content":"單核下 同一時刻 只有一個進程运行","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1624844404,"ip_address":"","comment_id":299672,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1624788785","product_id":100078401,"comment_content":"有一点没太理解， 是在多核 的时候需要锁总线并且关中断吗， 单核只需要关中断就好了 。 关中断时关当前进程的中断，还是所有进程的中断都关呢","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522503,"discussion_content":"單核下 同一時刻 只有一個進程运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624844404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1466121,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5f/09/2ec44412.jpg","nickname":"Qfeng","note":"","ucode":"1248E70012BBA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558869,"discussion_content":"关中断我理解只能关当前CPU的中断。一个核上跑的进程不能关另一个核的中断的。目前Linux上的关中断是这么实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648516358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1927222,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/68/36/478194f3.jpg","nickname":"Shawn Duan","note":"","ucode":"628BAD6473FBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400737,"discussion_content":"在多核情况下，所有的CPU都需要关中断吗？还是只有本进程的CPU关中断？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633402664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1927222,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/68/36/478194f3.jpg","nickname":"Shawn Duan","note":"","ucode":"628BAD6473FBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400736,"discussion_content":"单核情况下，如果关中断，抢占式调度情况下，还是可能有高优先级的进程去抢占CPU，然后造成多进程访问这个保护段的情况吗？如果不能抢占，是如何保证的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633402599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295640,"user_name":"Freddy","can_delete":false,"product_type":"c1","uid":1708412,"ip_address":"","ucode":"5822B746265DB4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/11/7c/bf5049b3.jpg","comment_is_top":false,"comment_ctime":1622526609,"is_pvip":false,"replies":[{"id":"107614","content":"嘿嘿 是的呢","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622990015,"ip_address":"","comment_id":295640,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622526609","product_id":100078401,"comment_content":"Linux的读写锁支持0x01000000 = 16777216个进程并发读取共享数据；<br>Linux的读写锁本质上是自旋锁，进程没有成功获取到读锁或者写锁时，会进行自旋，浪费了CPU资源；","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521166,"discussion_content":"嘿嘿 是的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622990015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295517,"user_name":"二三子也","can_delete":false,"product_type":"c1","uid":1245787,"ip_address":"","ucode":"69C7D86583277D","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/5b/ce326cfc.jpg","comment_is_top":false,"comment_ctime":1622458673,"is_pvip":false,"replies":[{"id":"107256","content":"是先交换","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622469106,"ip_address":"","comment_id":295517,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1622458673","product_id":100078401,"comment_content":"&quot;lock ; xaddl %0, %1\\n&quot; &#47;&#47;将inc和slock交换，然后 inc=inc+slock<br>老师，这个是不是应该是slock=slock+inc？<br>不然第一个申请的线程加不上锁啊？<br>","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521113,"discussion_content":"是先交换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622469106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/02/5b/ce326cfc.jpg","nickname":"二三子也","note":"","ucode":"69C7D86583277D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377057,"discussion_content":"是先交换然后相加。但是相加的结果应该是赋值给slock而不是inc吧。\n假设第一个线程申请锁\n如果是inc=inc+slock的话\nxaddl执行之前\ninc是0x00010000 slock是0x00000000\nxaddl执行之后\ninc=0x00010000 slock是0x00010000\ninc的高位和低位不相等啊。第一次锁不上啊","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1622472913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1478242,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8e/62/435148c1.jpg","nickname":"SinKitwah","note":"","ucode":"BC39A39E17C95E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393669,"discussion_content":"这个我也看了很久，我在想是不是写反了。应该是交换后，slock＝slock + inc吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631540934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323341,"avatar":"https://static001.geekbang.org/account/avatar/00/14/31/4d/ea8ac77c.jpg","nickname":"伟仔_Hoo","note":"","ucode":"74945AEE48DD62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387428,"discussion_content":"是啊，我也看了很久，第一次会加不上锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628163373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2718584,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9YwnzDGnOqlriaMaNXtY8R9b8QpgmnYP9xEBWWy1iaUwdTkiaNHPiajNlB7UKbXHovxkad0oRDEsCDg/132","nickname":"Geek_237cef","note":"","ucode":"06D84FC4A4FF2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537555,"discussion_content":"应该是笔误了，应该是slock=slock+inc,这样程序就符合逻辑了，确保每次加锁后slock的next部分增1，同时加锁前的next值正常给到inc，老师能确认下否？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639102187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295421,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1622426512,"is_pvip":false,"replies":[{"id":"107262","content":"嗯嗯 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622469442,"ip_address":"","comment_id":295421,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1622426512","product_id":100078401,"comment_content":"&quot;addl $0x00010000, %1\\n\\t&quot;&#47;&#47;相当于next+1<br>    &quot;lock ; cmpxchgl %1,%2\\n\\t&quot;&#47;&#47;new和slock交换比较    <br>老师，这两句可以细讲一下吗？<br>是slock和谁比较，如果成功是把new给slock吗","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521073,"discussion_content":"嗯嗯 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622469442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2635606,"avatar":"https://static001.geekbang.org/account/avatar/00/28/37/56/3a527963.jpg","nickname":"吴国豪","note":"","ucode":"0899104FDC2C97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382482,"discussion_content":"slock和谁比较呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625589425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295095,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1622221930,"is_pvip":false,"replies":[{"id":"107290","content":"得看操作系统 是 怎么 处理的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622472627,"ip_address":"","comment_id":295095,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1622221930","product_id":100078401,"comment_content":"老师，说说我这节课的理解和问题。<br>第一个问题，自旋锁在获取不到锁的时候，该进程所在的CPU一直在空转。那如果是8核的CPU，如果是99个进程竞争这把自旋锁，理论上是只有8个进程处于自旋等待，其他的进程等待被调度。那是不是说处于自旋等待的进程，时间片用完也会被挂起的？<br><br><br>","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520948,"discussion_content":"得看操作系统 是 怎么 处理的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622472627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2834444,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/40/0c/19b4224a.jpg","nickname":"不写出操作系统不改名","note":"","ucode":"DD40D98250B688","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412570,"discussion_content":"第1个核获取自旋锁进入临界区，然后后面的2，3，4，5，6，7，8号core都会原地自旋等待有可用的自旋锁，是不会进入挂起状态的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636210289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295094,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1622220047,"is_pvip":false,"replies":[{"id":"107291","content":"嗯嗯","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622472649,"ip_address":"","comment_id":295094,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622220047","product_id":100078401,"comment_content":"老师，关于读写锁的疑问，如果获取不到写锁时，此时该进程一直在等待，也就意味着CPU一直在空转吗？还是该进程被挂起了，等着CPU的调度呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520947,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622472649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295085,"user_name":"静由心然","can_delete":false,"product_type":"c1","uid":2631261,"ip_address":"","ucode":"E48AD41CD96F09","user_header":"https://static001.geekbang.org/account/avatar/00/28/26/5d/eeaa7df0.jpg","comment_is_top":false,"comment_ctime":1622212726,"is_pvip":false,"replies":[{"id":"107293","content":"这是说明获取读写锁的先后次序问题","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622472769,"ip_address":"","comment_id":295085,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622212726","product_id":100078401,"comment_content":"如果多个进程获得共享读取锁的话，那么进行写的操作进程将要等待所有读取共享完成。延迟数据更新，即使是写操作拥有很高的优先级的话，也可能等待所有读共享完成，优先级反转？另外当读和写加锁出现竞态的时候，内核如何实现写锁优先加锁？不是看的很明白。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520943,"discussion_content":"这是说明获取读写锁的先后次序问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622472769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295081,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1622211458,"is_pvip":false,"replies":[{"id":"107294","content":"你了解一下 银行家算法 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622472799,"ip_address":"","comment_id":295081,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622211458","product_id":100078401,"comment_content":"老师，能不能讲下死锁是怎么回事？在实际开发中会遇到这个问题吗？如果遇到了该怎么定位问题是出在哪？如何避免死锁？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520941,"discussion_content":"你了解一下 银行家算法 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622472799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294948,"user_name":"Rush Hour","can_delete":false,"product_type":"c1","uid":1687584,"ip_address":"","ucode":"73ED20FABF63E6","user_header":"https://static001.geekbang.org/account/avatar/00/19/c0/20/db1e7f5b.jpg","comment_is_top":false,"comment_ctime":1622163899,"is_pvip":false,"replies":[{"id":"107304","content":"是的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622473425,"ip_address":"","comment_id":294948,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622163899","product_id":100078401,"comment_content":"初始值是 0x01000000，代表可以接受的共享数据的进程个数。不足之处在于会导致读锁不断有进程获取，写锁会被饿死。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520890,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294947,"user_name":"blentle","can_delete":false,"product_type":"c1","uid":1064679,"ip_address":"","ucode":"AC092609A4942A","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/e7/261711a5.jpg","comment_is_top":false,"comment_ctime":1622163761,"is_pvip":false,"replies":[{"id":"107305","content":"不用，了解一下就行了 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1622473462,"ip_address":"","comment_id":294947,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1622163761","product_id":100078401,"comment_content":"还请教老师和各位童鞋一个问题，看着内核里各种锁实现函数里的汇编代码头大，这个是看到什么指令去查一遍还是先系统的学习遍，本人学习过一遍王爽的x86汇编，这里看着陌生的指令还是头大","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520889,"discussion_content":"不用，了解一下就行了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622473462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376535,"discussion_content":"先看完，再按需补细节吧。不然没啃完汇编，又想放弃了哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622180989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294937,"user_name":"尼欧","can_delete":false,"product_type":"c1","uid":1260883,"ip_address":"","ucode":"39D4D1F5F51764","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/53/9d8a1207.jpg","comment_is_top":false,"comment_ctime":1622160846,"is_pvip":false,"replies":[{"id":"107072","content":"跟着更新步伐同步打卡呀，今天收获如何欢迎分享，还有继续加油。","user_name":"编辑回复","user_name_real":"赵宇新","uid":"1501385","ctime":1622170570,"ip_address":"","comment_id":294937,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1622160846","product_id":100078401,"comment_content":"打卡","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520881,"discussion_content":"跟着更新步伐同步打卡呀，今天收获如何欢迎分享，还有继续加油。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622170570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]}]}