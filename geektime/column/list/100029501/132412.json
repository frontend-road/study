{"id":132412,"title":"41丨初识Redis：Redis为什么会这么快？","content":"<p>之前我们讲解了一些RDBMS的使用，比如MySQL、Oracle、SQL Server和SQLite等，实际上在日常工作中，我们还会接触到一些NoSQL类型的数据库。如果对比RDBMS和NoSQL数据库，你会发现RDBMS建立在关系模型基础上，强调数据的一致性和各种约束条件，而NoSQL的规则是“只提供你想要的”，数据模型灵活，查询效率高，成本低。但同时，相比RDBMS，NoSQL数据库没有统一的架构和标准语言，每种数据库之间差异较大，各有所长。</p><p>今天我们要讲解的Redis属于键值（key-value）数据库，键值数据库会使用哈希表存储键值和数据，其中key作为唯一的标识，而且key和value可以是任何的内容，不论是简单的对象还是复杂的对象都可以存储。键值数据库的查询性能高，易于扩展。</p><p>今天我们就来了解下Redis，具体的内容包括以下几个方面：</p><ol>\n<li>Redis是什么，为什么使用Redis会非常快？</li>\n<li>Redis支持的数据类型都有哪些？</li>\n<li>如何通过Python和Redis进行交互？</li>\n</ol><h2>Redis是什么，为什么这么快</h2><p>Redis全称是REmote DIctionary Server，从名字中你也能看出来它用字典结构存储数据，也就是key-value类型的数据。</p><!-- [[[read_end]]] --><p>Redis的查询效率非常高，根据官方提供的数据，Redis每秒最多处理的请求可以达到10万次。</p><p>为什么这么快呢？</p><p>Redis采用ANSI C语言编写，它和SQLite一样。采用C语言进行编写的好处是底层代码执行效率高，依赖性低，因为使用C语言开发的库没有太多运行时（Runtime）依赖，而且系统的兼容性好，稳定性高。</p><p>此外，Redis是基于内存的数据库，我们之前讲到过，这样可以避免磁盘I/O，因此Redis也被称为缓存工具。</p><p>其次，数据结构结构简单，Redis采用Key-Value方式进行存储，也就是使用Hash结构进行操作，数据的操作复杂度为O(1)。</p><p>但Redis快的原因还不止这些，它采用单进程单线程模型，这样做的好处就是避免了上下文切换和不必要的线程之间引起的资源竞争。</p><p>在技术上Redis还采用了多路I/O复用技术。这里的多路指的是多个socket网络连接，复用指的是复用同一个线程。采用多路I/O复用技术的好处是可以在同一个线程中处理多个I/O请求，尽量减少网络I/O的消耗，提升使用效率。</p><h2>Redis的数据类型</h2><p>相比Memcached，Redis有一个非常大的优势，就是支持多种数据类型。Redis支持的数据类型包括字符串、哈希、列表、集合、有序集合等。</p><p>字符串类型是Redis提供的最基本的数据类型，对应的结构是key-value。</p><p>如果我们想要设置某个键的值，使用方法为<code>set key value</code>，比如我们想要给name这个键设置值为zhangfei，可以写成<code>set name zhangfei</code>。如果想要取某个键的值，可以使用<code>get key</code>，比如想取name的值，写成get name即可。</p><p><img src=\"https://static001.geekbang.org/resource/image/55/30/554243f80e4029e82ffd60c4b0303030.png?wh=866*209\" alt=\"\"><br>\n哈希（hash）提供了字段和字段值的映射，对应的结构是key-field-value。</p><p>如果我们想要设置某个键的哈希值，可以使用<code>hset key field value</code>，如果想要给user1设置username为zhangfei，age为28，可以写成下面这样：</p><pre><code>hset user1 username zhangfei\nhset user1 age 28\n</code></pre><p>如果我们想要同时将多个field-value设置给某个键key的时候，可以使用<code>hmset key field value [field value...]</code>，比如上面这个可以写成：</p><pre><code>Hmset user1 username zhangfei age 28\n\n</code></pre><p>如果想要取某个键的某个field字段值，可以使用<code>hget key field</code>，比如想要取user1的username，那么写成<code>hget user1 username</code>即可。</p><p>如果想要一次获取某个键的多个field字段值，可以使用<code>hmget key field[field...]</code>，比如想要取user1的username和age，可以写成<code>hmget user1 username age</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/4a/3c/4aac95f8536f67f97f1c913a3633aa3c.png?wh=1122*306\" alt=\"\"><br>\n字符串列表（list）的底层是一个双向链表结构，所以我们可以向列表的两端添加元素，时间复杂度都为O(1)，同时我们也可以获取列表中的某个片段。</p><p>如果想要向列表左侧增加元素可以使用：<code>LPUSH key value [...]</code>，比如我们给heroList列表向左侧添加zhangfei、guanyu和liubei这三个元素，可以写成：</p><pre><code>LPUSH heroList zhangfei guanyu liubei\n</code></pre><p>同样，我们也可以使用<code>RPUSH key value [...]</code>向列表右侧添加元素，比如我们给heroList列表向右侧添加dianwei、lvbu这两个元素，可以写成下面这样：</p><pre><code>RPUSH heroList dianwei lvbu\n\n</code></pre><p>如果我们想要获取列表中某一片段的内容，使用<code>LRANGE key start stop</code>即可，比如我们想要获取heroList从0到4位置的数据，写成<code>LRANGE heroList 0 4</code>即可。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/26/d87d2a6b0f858b0a5c88aa4417707a26.png?wh=1366*506\" alt=\"\"><br>\n字符串集合（set）是字符串类型的无序集合，与列表（list）的区别在于集合中的元素是无序的，同时元素不能重复。</p><p>如果想要在集合中添加元素，可以使用<code>SADD key member [...]</code>，比如我们给heroSet集合添加zhangfei、guanyu、liubei、dianwei和lvbu这五个元素，可以写成：</p><pre><code>SADD heroSet zhangfei guanyu liubei dianwei lvbu\n</code></pre><p>如果想要在集合中删除某元素，可以使用<code>SREM key member [...]</code>，比如我们从heroSet集合中删除liubei和lvbu这两个元素，可以写成：</p><pre><code>SREM heroSet liubei lvbu\n</code></pre><p>如果想要获取集合中所有的元素，可以使用<code>SMEMBERS key</code>，比如我们想要获取heroSet集合中的所有元素，写成<code>SMEMBERS heroSet</code>即可。</p><p>如果想要判断集合中是否存在某个元素，可以使用<code>SISMEMBER key member</code>，比如我们想要判断heroSet集合中是否存在zhangfei和liubei，就可以写成下面这样：</p><pre><code>SISMEMBER heroSet zhangfei\nSISMEMBER heroSet liubei\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/e6/0f/e69e7249b48194e0f76a8f351287390f.png?wh=1613*606\" alt=\"\"><br>\n我们可以把有序字符串集合（SortedSet，简称ZSET）理解成集合的升级版。实际上ZSET是在集合的基础上增加了一个分数属性，这个属性在添加修改元素的时候可以被指定。每次指定后，ZSET都会按照分数来进行自动排序，也就是说我们在给集合key添加member的时候，可以指定score。</p><p>有序集合与列表有一定的相似性，比如这两种数据类型都是有序的，都可以获得某一范围的元素。但它俩在数据结构上有很大的不同，首先列表list是通过双向链表实现的，在操作左右两侧的数据时会非常快，而对于中间的数据操作则相对较慢。有序集合采用hash表的结构来实现，读取排序在中间部分的数据也会很快。同时有序集合可以通过score来完成元素位置的调整，但如果我们想要对列表进行元素位置的调整则会比较麻烦。</p><p>如果我们想要在有序集合中添加元素和分数，使用<code>ZADD key score member [...]</code>，比如我们给heroScore集合添加下面5个英雄的hp_max数值，如下表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/54/2b8db8619d37452b4608e8dbe91cba54.png?wh=530*320\" alt=\"\"><br>\n那么我们可以写成下面这样：</p><pre><code>ZADD heroScore 8341 zhangfei 7107 guanyu 6900 liubei 7516 dianwei 7344 lvbu\n</code></pre><p>如果我们想要获取某个元素的分数，可以使用<code>ZSCORE key member</code>，比如我们想要获取guanyu的分数，写成<code>ZSCORE heroScore guanyu</code>即可。</p><p>如果我们想要删除一个或多元素，可以使用ZREM key member [member ...]，比如我们想要删除guanyu这个元素，使用<code>ZREM heroScore guanyu</code>即可。</p><p>我们也可以获取某个范围的元素列表。如果想要分数从小到大进行排序，使用<code>ZRANGE key start stop [WITHSCORES]</code>，如果分数从大到小进行排序，使用<code>ZREVRANGE key start stop [WITHSCORES]</code>。需要注意的是，WITHSCORES是个可选项，如果使用WITHSCORES会将分数一同显示出来，比如我们想要查询heroScore这个有序集合中分数排名前3的英雄及数值，写成<code>ZREVRANGE heroScore 0 2 WITHSCORES</code>即可。</p><p><img src=\"https://static001.geekbang.org/resource/image/10/85/106083c4b4872fadb6b91f46b3e74485.png?wh=1729*617\" alt=\"\"><br>\n除了这5种数据类型以外，Redis还支持位图（Bitmaps）数据结构，在2.8版本之后，增加了基数统计（HyperLogLog），3.2版本之后加入了地理空间（Geospatial）以及索引半径查询的功能，在5.0版本引用了数据流（Streams）数据类型。</p><h2>如何使用Redis</h2><p>我们可以在Python中直接操作Redis，在使用前需要使用<code>pip install redis</code>安装工具包，安装好之后，在使用前我们需要使用import redis进行引用。</p><p>在Python中提供了两种连接Redis的方式，第一种是直接连接，使用下面这行命令即可。</p><pre><code>r = redis.Redis(host='localhost', port= 6379)\n</code></pre><p>第二种是连接池方式。</p><pre><code>pool = redis.ConnectionPool(host='localhost', port=6379)\nr = redis.Redis(connection_pool=pool)\n</code></pre><p>你可能会有疑问，这两种连接方式有什么不同？直接连接可能会耗费掉很多资源。通常情况下，我们在连接Redis的时候，可以创建一个Redis连接，通过它来完成Redis操作，完成之后再释放掉。但是在高并发的情况下，这样做非常不经济，因为每次连接和释放都需要消耗非常多的资源。</p><h3>为什么采用连接池机制</h3><p>基于直接连接的弊端，Redis提供了连接池的机制，这个机制可以让我们事先创建好多个连接，将其放到连接池中，当我们需要进行Redis操作的时候就直接从连接池中获取，完成之后也不会直接释放掉连接，而是将它返回到连接池中。</p><p>连接池机制可以避免频繁创建和释放连接，提升整体的性能。</p><h3>连接池机制的原理</h3><p>在连接池的实例中会有两个list，保存的是<code>_available_connections</code>和<code>_in_use_connections</code>，它们分别代表连接池中可以使用的连接集合和正在使用的连接集合。当我们想要创建连接的时候，可以从<code>_available_connections</code>中获取一个连接进行使用，并将其放到<code>_in_use_connections</code>中。如果没有可用的连接，才会创建一个新连接，再将其放到<code>_in_use_connections</code>中。如果连接使用完毕，会从<code>_in_use_connections</code>中删除，添加到<code>_available_connections</code>中，供后续使用。</p><p>Redis库提供了Redis和StrictRedis类，它们都可以实现Redis命令，不同之处在于Redis是StrictRedis的子类，可以对旧版本进行兼容。如果我们想要使用连接池机制，然后用StrictRedis进行实例化，可以写成下面这样：</p><pre><code>import redis \npool = redis.ConnectionPool(host='localhost', port=6379)\nr = redis.StrictRedis(connection_pool=pool)\n</code></pre><h3>实验：使用Python统计Redis进行1万次写请求和1万次读请求的时间</h3><p>了解了如何使用Python创建Redis连接之后，我们再来看下怎样使用Python对Redis进行数据的写入和读取。这里我们使用HMSET函数同时将多个<code>field-value</code>值存入到键中。模拟1万次的写请求里，设置了不同的key，和相同的<code>field-value</code>值，然后在1万次读请求中，将这些不同的key中保存的<code>field-value</code>值读取出来。具体代码如下：</p><pre><code>import redis\nimport time\n# 创建redis连接\npool = redis.ConnectionPool(host='localhost', port=6379)\nr = redis.StrictRedis(connection_pool=pool)\n# 记录当前时间\ntime1 = time.time()\n# 1万次写\nfor i in range(10000):\n    data = {'username': 'zhangfei', 'age':28}\n    r.hmset(&quot;users&quot;+str(i), data)\n# 统计写时间\ndelta_time = time.time()-time1\nprint(delta_time)\n# 统计当前时间\ntime1 = time.time()\n# 1万次读\nfor i in range(10000):\n    result = r.hmget(&quot;users&quot;+str(i), ['username', 'age'])\n# 统计读时间\ndelta_time = time.time()-time1\nprint(delta_time)\n</code></pre><p>运行结果：</p><pre><code>2.0041146278381348\n0.9920568466186523\n</code></pre><p>你能看到1万次写请求差不多用时2秒钟，而1万次读请求用时不到1秒钟，读写效率还是很高的。</p><h2>总结</h2><p>NoSQL数据库种类非常多，了解Redis是非常有必要的，在实际工作中，我们也经常将RDBMS和Redis一起使用，优势互补。</p><p>作为常见的NoSQL数据库，Redis支持的数据类型比Memcached丰富得多，在I/O性能上，Redis采用的是单线程I/O复用模型，而Memcached是多线程，可以利用多核优势。而且在持久化上，Redis提供了两种持久化的模式，可以让数据永久保存，这是Memcached不具备的。</p><p><img src=\"\" alt=\"\"></p><p>你不妨思考一下，为什么Redis采用了单线程工作模式？有哪些机制可以保证Redis即使采用单线程模式效率也很高呢？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","comments":[{"had_liked":false,"id":132501,"user_name":"墨禾","can_delete":false,"product_type":"c1","uid":1216590,"ip_address":"","ucode":"81BA44231AABE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/90/4e/efaea936.jpg","comment_is_top":false,"comment_ctime":1568153730,"is_pvip":false,"replies":[{"id":"51479","content":"解释的很好，大家都可以看下","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1568791217,"ip_address":"","comment_id":132501,"utype":1}],"discussion_count":6,"race_medal":0,"score":"181956780162","product_id":100029501,"comment_content":"为什么要设计成单线程？<br>1.单线程减少了cpu资源的争用，避免了上下文的切换。<br>2.基于内存读写，单线程读写耗时更少。<br><br>为啥redis单线程模型也能效率这么高？<br><br>1）纯内存操作<br>2）核心是基于非阻塞的IO多路复用机制<br>3）单线程反而避免了多线程的频繁上下文切换问题","like_count":43,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466974,"discussion_content":"解释的很好，大家都可以看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568791217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1425456,"avatar":"https://static001.geekbang.org/account/avatar/00/15/c0/30/53965ee0.jpg","nickname":"刘伟","note":"","ucode":"26A77D2F6429F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248411,"discussion_content":"等于没讲","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587868483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1425456,"avatar":"https://static001.geekbang.org/account/avatar/00/15/c0/30/53965ee0.jpg","nickname":"刘伟","note":"","ucode":"26A77D2F6429F0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378152,"discussion_content":"我也看不太懂，感觉应该是自己缺了一些计算机组成原理的知识","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623071510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":248411,"ip_address":""},"score":378152,"extra":""}]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378153,"discussion_content":"在技术上 Redis 还采用了多路 I/O 复用技术。这里的多路指的是多个 socket 网络连接，复用指的是复用同一个线程。采用多路 I/O 复用技术的好处是可以在同一个线程中处理多个 I/O 请求，尽量减少网络 I/O 的消耗，提升使用效率。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623071609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1394726,"avatar":"https://static001.geekbang.org/account/avatar/00/15/48/26/93fd21d5.jpg","nickname":"书痕","note":"","ucode":"8367371EF89D61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45993,"discussion_content":"如果将Redis线程固定到CPU某个内核上，性能可能会更高吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573107547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1365206,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d4/d6/1d4543ac.jpg","nickname":"云海","note":"","ucode":"0C6CA0BE58EA21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1394726,"avatar":"https://static001.geekbang.org/account/avatar/00/15/48/26/93fd21d5.jpg","nickname":"书痕","note":"","ucode":"8367371EF89D61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396603,"discussion_content":"是的，性能会更高，不存在CPU信息重新切换加载，但也要注意风险。\nredis支持绑核执行下面的命令，就把 Redis 实例绑在了 0 号核上，其中，“-c”选项用于设置要绑定的核编号。\ntaskset -c 0 ./redis-server\n\n当我们把 Redis 实例绑到一个 CPU 逻辑核上时，就会导致子进程、后台线程和 Redis 主线程竞争 CPU 资源，一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致 Redis 请求延迟增加。\n\n方案一：一个 Redis 实例对应绑一个物理核，\n方案二：优化 Redis 源码，通过修改 Redis 源码，把子进程和后台线程绑到不同的 CPU 核上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632460063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45993,"ip_address":""},"score":396603,"extra":""}]}]},{"had_liked":false,"id":131827,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1567925031,"is_pvip":false,"replies":[{"id":"53378","content":"Redis是Key-Value数据库，数据存放在内存中，查询和写入都是在内存中进行操作。当然Redis也支持持久化，只是持久化只是Redis的功能之一，并不是Redis的强项。通常，你可以把Redis称之为缓存。支持的数据类型丰富，包括字符串、哈希、列表、集合、有序集合，同时还支持基数统计，地理空间以及索引半径查询，数据流等。<br>MongoDB是面向文档数据库，功能强大，是非关系型数据库中最像关系型数据库的，处理增删改查也可以增加条件，类似于RDBMS一样灵活。<br>在存储方式上，Redis将数据放在内存中的，通过RDB或者AOF方式进行持久化。<br>而MongoDB实际上数据是存放在磁盘上的，只是通过mmap调用将数据映射到内存中，所以你可以将mmap理解成为加速的方式。mmap调用可以使得对普通文件的操作像是在内存中进行读写一样，这是因为它将文件映射到调用进程的地址空间中，实现了文件所在的磁盘物理地址与进程空间的虚拟地址一一映射的关系，这样就可以直接在内存中进行操作，然后写完成之后同步一下就可以存放到文件中，效率非常高。<br>不过在使用选择的时候，我们还是将 MongoDB 归为数据库，而Redis归为缓存。<br>总的来说，Redis就像是一架飞机一样，查询及写入性能极佳，但是存储的数据规模有限。<br>MongoDB就像是高铁一样，在处理货物（数据）的功能上强于Redis，同时能承载的数据量也很大，远高于Redis，但是查询及写入的效率不及Redis。","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1570431016,"ip_address":"","comment_id":131827,"utype":1}],"discussion_count":2,"race_medal":0,"score":"143301845799","product_id":100029501,"comment_content":"老师能否讲下mongodb，以及redis和mongodb的差别，实际使用时选择应该做哪些方面的考虑","like_count":33,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466635,"discussion_content":"Redis是Key-Value数据库，数据存放在内存中，查询和写入都是在内存中进行操作。当然Redis也支持持久化，只是持久化只是Redis的功能之一，并不是Redis的强项。通常，你可以把Redis称之为缓存。支持的数据类型丰富，包括字符串、哈希、列表、集合、有序集合，同时还支持基数统计，地理空间以及索引半径查询，数据流等。\nMongoDB是面向文档数据库，功能强大，是非关系型数据库中最像关系型数据库的，处理增删改查也可以增加条件，类似于RDBMS一样灵活。\n在存储方式上，Redis将数据放在内存中的，通过RDB或者AOF方式进行持久化。\n而MongoDB实际上数据是存放在磁盘上的，只是通过mmap调用将数据映射到内存中，所以你可以将mmap理解成为加速的方式。mmap调用可以使得对普通文件的操作像是在内存中进行读写一样，这是因为它将文件映射到调用进程的地址空间中，实现了文件所在的磁盘物理地址与进程空间的虚拟地址一一映射的关系，这样就可以直接在内存中进行操作，然后写完成之后同步一下就可以存放到文件中，效率非常高。\n不过在使用选择的时候，我们还是将 MongoDB 归为数据库，而Redis归为缓存。\n总的来说，Redis就像是一架飞机一样，查询及写入性能极佳，但是存储的数据规模有限。\nMongoDB就像是高铁一样，在处理货物（数据）的功能上强于Redis，同时能承载的数据量也很大，远高于Redis，但是查询及写入的效率不及Redis。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570431016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378155,"discussion_content":"老师真厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623071816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145200,"user_name":"Coool","can_delete":false,"product_type":"c1","uid":1701702,"ip_address":"","ucode":"1D1AB3270B02B9","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/46/209ca424.jpg","comment_is_top":false,"comment_ctime":1572229067,"is_pvip":false,"replies":[{"id":"62688","content":"对 总结的不错","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1577084532,"ip_address":"","comment_id":145200,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27342032843","product_id":100029501,"comment_content":"为什么使用单线程？<br>1、代码更清晰，处理逻辑更简单<br>2、不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗<br>3、不存在多进程或者多线程导致的切换而消耗CPU","like_count":6,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472285,"discussion_content":"对 总结的不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577084532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134975,"user_name":"xcoder","can_delete":false,"product_type":"c1","uid":1207135,"ip_address":"","ucode":"2C70ED36B4AC8E","user_header":"https://static001.geekbang.org/account/avatar/00/12/6b/5f/cec1e980.jpg","comment_is_top":false,"comment_ctime":1568966813,"is_pvip":false,"replies":[{"id":"53357","content":"Python在专栏里确实没有讲解，如果之前有编程语言基础，掌握起来不难。专栏里使用到的也是基础的语法。Redis如果之前没有接触过，到是不影响，因为这节主要是Redis初识，可以跟着做遍练习，对Redis多一些了解","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1570426887,"ip_address":"","comment_id":134975,"utype":1}],"discussion_count":6,"race_medal":0,"score":"14453868701","product_id":100029501,"comment_content":"不好意思，我觉得这个课程对初学者，或者完全没接触过python和redis的同学来说不太友好吧。还得补充很多知识，安装python和redis，如何操作等等。。。这些都还需要网上找下教程，虽然最近都有在看起来，但觉得学起来还是有点力不从心，越到后面感觉评论的人也越来越少了，不知道后面的课时学的人也是不是越来越少了","like_count":3,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467986,"discussion_content":"Python在专栏里确实没有讲解，如果之前有编程语言基础，掌握起来不难。专栏里使用到的也是基础的语法。Redis如果之前没有接触过，到是不影响，因为这节主要是Redis初识，可以跟着做遍练习，对Redis多一些了解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570426887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125885,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2d/fd/cfc952f5.jpg","nickname":"大科爱吃肉","note":"","ucode":"4C243A5729A848","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21226,"discussion_content":"不就是因为没接触才看的吗...","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1569455771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1207135,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6b/5f/cec1e980.jpg","nickname":"xcoder","note":"","ucode":"2C70ED36B4AC8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1125885,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2d/fd/cfc952f5.jpg","nickname":"大科爱吃肉","note":"","ucode":"4C243A5729A848","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22883,"discussion_content":"我的想法是希望作者能加入更多细节知识引用的链接等，对于一些初学者去找细节上的资料会很辛苦，有时会像无头苍蝇，花了大把时间，效率也不高，可能还是一直搞不定问题，渐渐就会失去学习的动力，当然能不能坚持下去还是看个人的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1569722969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21226,"ip_address":""},"score":22883,"extra":""},{"author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1207135,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6b/5f/cec1e980.jpg","nickname":"xcoder","note":"","ucode":"2C70ED36B4AC8E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274193,"discussion_content":"所以我觉得你可以看看我的博客（https://blog.csdn.net/weixin_41013322）\n一半内容都是对陈老师的专栏进行的细节补充 😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590552203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":22883,"ip_address":""},"score":274193,"extra":""},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378157,"discussion_content":"在你的博客里不太好找陈老师专栏相关的内容（我知道肯定有，但是我半天翻不到）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623072031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274193,"ip_address":""},"score":378157,"extra":""}]}]},{"had_liked":false,"id":221749,"user_name":"骑行的掌柜J","can_delete":false,"product_type":"c1","uid":1474214,"ip_address":"","ucode":"3163102651C653","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","comment_is_top":false,"comment_ctime":1590582172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10180516764","product_id":100029501,"comment_content":"用Python连接Redis报错“ConnectionRefusedError: [WinError 10061]由于目标计算机积极拒绝，无法连接。”的解决办法 ：<br>https:&#47;&#47;blog.csdn.net&#47;weixin_41013322&#47;article&#47;details&#47;106387319<br>希望对各位有帮助","like_count":2},{"had_liked":false,"id":183875,"user_name":"四喜","can_delete":false,"product_type":"c1","uid":1071389,"ip_address":"","ucode":"C5EBED19C0F332","user_header":"https://static001.geekbang.org/account/avatar/00/10/59/1d/c89abcd8.jpg","comment_is_top":false,"comment_ctime":1583152425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173087017","product_id":100029501,"comment_content":"我的速度是老师的1&#47;10","like_count":2},{"had_liked":false,"id":131349,"user_name":"有所思","can_delete":false,"product_type":"c1","uid":1045956,"ip_address":"","ucode":"FA3FF98D3DC69B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/c4/f2d7ce76.jpg","comment_is_top":false,"comment_ctime":1567728873,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"10157663465","product_id":100029501,"comment_content":"老师，为什么你讲的Redis底层数据结构和王争讲的数据结构与算法课里面的有些不一样，他说的里面redis会根据数据大小和数量选择不同的数据结构，而且有序集合用的是跳表实现，有点蒙","like_count":2,"discussions":[{"author":{"id":1190150,"avatar":"https://static001.geekbang.org/account/avatar/00/12/29/06/0b327738.jpg","nickname":"Gankki","note":"","ucode":"399C6F74286590","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":11244,"discussion_content":"Implementation note: Sorted sets are implemented via a dual-ported data structure containing both a skip list and a hash table, so every time we add an element Redis performs an O(log(N)) operation   ","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1568371558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437425,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/f1/16545faf.jpg","nickname":"学习","note":"","ucode":"CDFB71E0D1508B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7931,"discussion_content":"数据结构说的是Redis的数据结构是怎样的，简单来说，一个是教你如何造一个Redis，一个是教你如何使用Redis","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567732679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1229516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c2/cc/ca22bb7c.jpg","nickname":"蓝士钦","note":"","ucode":"726EB5C8EF1249","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327821,"discussion_content":"老师这里讲的是Redis的5种值类型，不同值类型低层都有对应的数据存储结构，比如跳表等。建议你阅读极客时间的Redis专栏会有所收获。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605961854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305720,"discussion_content":"zset是由 skiplist+dict 共同实现的。dict 负责保存数据到 score 的对应关系，键是数据的值，值是score；skiplist 保存数据。dict 实现了快速判断元素是否存在和返回元素的 score。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600069149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":112426,"discussion_content":"你懂什么叫底层吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577862011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1582134,"avatar":"https://static001.geekbang.org/account/avatar/00/18/24/36/1c4af368.jpg","nickname":"TheOne","note":"","ucode":"2A359780156A8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392572,"discussion_content":"我是你爹","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1631063393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":112426,"ip_address":""},"score":392572,"extra":""},{"author":{"id":2815900,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/f7/9c/69c5c5dc.jpg","nickname":"越锋利","note":"","ucode":"63E9E3F3C7D53D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533059,"discussion_content":"友善的评论是交流的起点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637764400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":112426,"ip_address":""},"score":533059,"extra":"{\"user_type\":1}"}]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8367,"discussion_content":"有序集合底层是跳跃表实现的，但是跳跃表的实现基础是链表的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567950077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223858,"user_name":"一路前行","can_delete":false,"product_type":"c1","uid":1288985,"ip_address":"","ucode":"32D3C715690783","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcFhGY0NV4kFzOSXWDHR2lrI2UbUP4Y016GOnpTH7dqSbicqJarX0pHxMsfLopRiacKEPXLx7IHHqg/132","comment_is_top":false,"comment_ctime":1591197514,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5886164810","product_id":100029501,"comment_content":"redis6.0，采用了多线程模式，老师怎么看？？？","like_count":1},{"had_liked":false,"id":131512,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1567775177,"is_pvip":false,"replies":[{"id":"50429","content":"加油！","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1568004375,"ip_address":"","comment_id":131512,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862742473","product_id":100029501,"comment_content":"跟着老师一起精进。加油。","like_count":1,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466494,"discussion_content":"加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568004375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131364,"user_name":"学习","can_delete":false,"product_type":"c1","uid":1437425,"ip_address":"","ucode":"CDFB71E0D1508B","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/f1/16545faf.jpg","comment_is_top":false,"comment_ctime":1567730979,"is_pvip":false,"replies":[{"id":"50434","content":"是field，代表字段的含义","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1568005268,"ip_address":"","comment_id":131364,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862698275","product_id":100029501,"comment_content":"文中多次提到key-filed-value，是field还是filed啊！！！！<br><br>Redis采用单进程单线程模型，这样做的好处就是避免了上下文切换和不必要的线程之间引起的资源竞争。这样就会很快。<br><br>Redis采用多路I&#47;O复用技术，这样就会解决单线程慢效率弊端，其中有个集群模式，能支持多客户端使用","like_count":1,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466412,"discussion_content":"是field，代表字段的含义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568005268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360282,"user_name":"明月","can_delete":false,"product_type":"c1","uid":1070166,"ip_address":"陕西","ucode":"E180B0EC24EFE8","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/56/5a5098d1.jpg","comment_is_top":false,"comment_ctime":1666397381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666397381","product_id":100029501,"comment_content":"使用单线程，是不是原理就是类似JavaScript的线程模型，采用轮询一个队列的方式","like_count":0},{"had_liked":false,"id":358105,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"陕西","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1663912743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663912743","product_id":100029501,"comment_content":"1. Redis用作缓存数据库<br>2.单线程IO复用模型<br>3.持久化方式有RDB,AOF , 一般开启aof ","like_count":0},{"had_liked":false,"id":260345,"user_name":"小虾米","can_delete":false,"product_type":"c1","uid":1619943,"ip_address":"","ucode":"7F0AAF55F602DC","user_header":"","comment_is_top":false,"comment_ctime":1604988360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604988360","product_id":100029501,"comment_content":"1.0412158966064453<br>1.049706220626831<br><br><br>感谢老师，初识redis","like_count":0},{"had_liked":false,"id":206272,"user_name":"凌空飞起的剪刀腿","can_delete":false,"product_type":"c1","uid":1243680,"ip_address":"","ucode":"16FBBF4A3B54C6","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/20/0f06b080.jpg","comment_is_top":false,"comment_ctime":1586832010,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586832010","product_id":100029501,"comment_content":"老师您好：<br>      Redis用跳表来实现有序集合的，不是使用hash表来实现有序集合吧？","like_count":0,"discussions":[{"author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305721,"discussion_content":"zset是由 skiplist+dict 共同实现的。dict 负责保存数据到 score 的对应关系，键是数据的值，值是score；skiplist 保存数据。dict 实现了快速判断元素是否存在和返回元素的 score。源码：\ntypedef struct zset {\n    dict *dict;\n    zskiplist *zsl;\n} zset;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600069227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148295,"user_name":"暮雨","can_delete":false,"product_type":"c1","uid":1176426,"ip_address":"","ucode":"4B7F4932446EF7","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/6a/6d82e7a3.jpg","comment_is_top":false,"comment_ctime":1572969111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572969111","product_id":100029501,"comment_content":"redis的单线程怎么理解？查看redis服务不至一个线程","like_count":0}]}