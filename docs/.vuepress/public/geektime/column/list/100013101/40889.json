{"id":40889,"title":"22 | panic函数、recover函数以及defer语句（下）","content":"<p>你好，我是郝林，今天我们继续来聊聊panic函数、recover函数以及defer语句的内容。</p><p>我在前一篇文章提到过这样一个说法，panic之中可以包含一个值，用于简要解释引发此panic的原因。</p><p>如果一个panic是我们在无意间引发的，那么其中的值只能由Go语言运行时系统给定。但是，当我们使用<code>panic</code>函数有意地引发一个panic的时候，却可以自行指定其包含的值。我们今天的第一个问题就是针对后一种情况提出的。</p><h2>知识扩展</h2><h3>问题 1：怎样让panic包含一个值，以及应该让它包含什么样的值？</h3><p>这其实很简单，在调用<code>panic</code>函数时，把某个值作为参数传给该函数就可以了。由于<code>panic</code>函数的唯一一个参数是空接口（也就是<code>interface{}</code>）类型的，所以从语法上讲，它可以接受任何类型的值。</p><p>但是，我们最好传入<code>error</code>类型的错误值，或者其他的可以被有效序列化的值。这里的“有效序列化”指的是，可以更易读地去表示形式转换。</p><p>还记得吗？对于<code>fmt</code>包下的各种打印函数来说，<code>error</code>类型值的<code>Error</code>方法与其他类型值的<code>String</code>方法是等价的，它们的唯一结果都是<code>string</code>类型的。</p><p>我们在通过占位符<code>%s</code>打印这些值的时候，它们的字符串表示形式分别都是这两种方法产出的。</p><!-- [[[read_end]]] --><p>一旦程序异常了，我们就一定要把异常的相关信息记录下来，这通常都是记到程序日志里。</p><p>我们在为程序排查错误的时候，首先要做的就是查看和解读程序日志；而最常用也是最方便的日志记录方式，就是记下相关值的字符串表示形式。</p><p>所以，如果你觉得某个值有可能会被记到日志里，那么就应该为它关联<code>String</code>方法。如果这个值是<code>error</code>类型的，那么让它的<code>Error</code>方法返回你为它定制的字符串表示形式就可以了。</p><p>对于此，你可能会想到<code>fmt.Sprintf</code>，以及<code>fmt.Fprintf</code>这类可以格式化并输出参数的函数。</p><p>是的，它们本身就可以被用来输出值的某种表示形式。不过，它们在功能上，肯定远不如我们自己定义的<code>Error</code>方法或者<code>String</code>方法。因此，为不同的数据类型分别编写这两种方法总是首选。</p><p>可是，这与传给<code>panic</code>函数的参数值又有什么关系呢？其实道理是相同的。至少在程序崩溃的时候，panic包含的那个值字符串表示形式会被打印出来。</p><p>另外，我们还可以施加某种保护措施，避免程序的崩溃。这个时候，panic包含的值会被取出，而在取出之后，它一般都会被打印出来或者记录到日志里。</p><p>既然说到了应对panic的保护措施，我们再来看下面一个问题。</p><h3>问题 2：怎样施加应对panic的保护措施，从而避免程序崩溃？</h3><p>Go语言的内建函数<code>recover</code>专用于恢复panic，或者说平息运行时恐慌。<code>recover</code>函数无需任何参数，并且会返回一个空接口类型的值。</p><p>如果用法正确，这个值实际上就是即将恢复的panic包含的值。并且，如果这个panic是因我们调用<code>panic</code>函数而引发的，那么该值同时也会是我们此次调用<code>panic</code>函数时，传入的参数值副本。请注意，这里强调用法的正确。我们先来看看什么是不正确的用法。</p><pre><code>package main\n\nimport (\n &quot;fmt&quot;\n &quot;errors&quot;\n)\n\nfunc main() {\n fmt.Println(&quot;Enter function main.&quot;)\n // 引发panic。\n panic(errors.New(&quot;something wrong&quot;))\n p := recover()\n fmt.Printf(&quot;panic: %s\\n&quot;, p)\n fmt.Println(&quot;Exit function main.&quot;)\n}\n</code></pre><p>在上面这个<code>main</code>函数中，我先通过调用<code>panic</code>函数引发了一个panic，紧接着想通过调用<code>recover</code>函数恢复这个panic。可结果呢？你一试便知，程序依然会崩溃，这个<code>recover</code>函数调用并不会起到任何作用，甚至都没有机会执行。</p><p>还记得吗？我提到过panic一旦发生，控制权就会讯速地沿着调用栈的反方向传播。所以，在<code>panic</code>函数调用之后的代码，根本就没有执行的机会。</p><p>那如果我把调用<code>recover</code>函数的代码提前呢？也就是说，先调用<code>recover</code>函数，再调用<code>panic</code>函数会怎么样呢？</p><p>这显然也是不行的，因为，如果在我们调用<code>recover</code>函数时未发生panic，那么该函数就不会做任何事情，并且只会返回一个<code>nil</code>。</p><p>换句话说，这样做毫无意义。那么，到底什么才是正确的<code>recover</code>函数用法呢？这就不得不提到<code>defer</code>语句了。</p><p>顾名思义，<code>defer</code>语句就是被用来延迟执行代码的。延迟到什么时候呢？这要延迟到该语句所在的函数即将执行结束的那一刻，无论结束执行的原因是什么。</p><p>这与<code>go</code>语句有些类似，一个<code>defer</code>语句总是由一个<code>defer</code>关键字和一个调用表达式组成。</p><p>这里存在一些限制，有一些调用表达式是不能出现在这里的，包括：针对Go语言内建函数的调用表达式，以及针对<code>unsafe</code>包中的函数的调用表达式。</p><p>顺便说一下，对于<code>go</code>语句中的调用表达式，限制也是一样的。另外，在这里被调用的函数可以是有名称的，也可以是匿名的。我们可以把这里的函数叫做<code>defer</code>函数或者延迟函数。注意，被延迟执行的是<code>defer</code>函数，而不是<code>defer</code>语句。</p><p>我刚才说了，无论函数结束执行的原因是什么，其中的<code>defer</code>函数调用都会在它即将结束执行的那一刻执行。即使导致它执行结束的原因是一个panic也会是这样。正因为如此，我们需要联用<code>defer</code>语句和<code>recover</code>函数调用，才能够恢复一个已经发生的panic。</p><p>我们来看一下经过修正的代码。</p><pre><code>package main\n\nimport (\n &quot;fmt&quot;\n &quot;errors&quot;\n)\n\nfunc main() {\n fmt.Println(&quot;Enter function main.&quot;)\n defer func(){\n  fmt.Println(&quot;Enter defer function.&quot;)\n  if p := recover(); p != nil {\n   fmt.Printf(&quot;panic: %s\\n&quot;, p)\n  }\n  fmt.Println(&quot;Exit defer function.&quot;)\n }()\n // 引发panic。\n panic(errors.New(&quot;something wrong&quot;))\n fmt.Println(&quot;Exit function main.&quot;)\n}\n</code></pre><p>在这个<code>main</code>函数中，我先编写了一条<code>defer</code>语句，并在<code>defer</code>函数中调用了<code>recover</code>函数。仅当调用的结果值不为<code>nil</code>时，也就是说只有panic确实已发生时，我才会打印一行以“panic:”为前缀的内容。</p><p>紧接着，我调用了<code>panic</code>函数，并传入了一个<code>error</code>类型值。这里一定要注意，我们要尽量把<code>defer</code>语句写在函数体的开始处，因为在引发panic的语句之后的所有语句，都不会有任何执行机会。</p><p>也只有这样，<code>defer</code>函数中的<code>recover</code>函数调用才会拦截，并恢复<code>defer</code>语句所属的函数，及其调用的代码中发生的所有panic。</p><p>至此，我向你展示了两个很典型的<code>recover</code>函数的错误用法，以及一个基本的正确用法。</p><p>我希望你能够记住错误用法背后的缘由，同时也希望你能真正地理解联用<code>defer</code>语句和<code>recover</code>函数调用的真谛。</p><p>在命令源码文件demo50.go中，我把上述三种用法合并在了一段代码中。你可以运行该文件，并体会各种用法所产生的不同效果。</p><p>下面我再来多说一点关于<code>defer</code>语句的事情。</p><h3>问题 3：如果一个函数中有多条<code>defer</code>语句，那么那几个<code>defer</code>函数调用的执行顺序是怎样的？</h3><p>如果只用一句话回答的话，那就是：在同一个函数中，<code>defer</code>函数调用的执行顺序与它们分别所属的<code>defer</code>语句的出现顺序（更严谨地说，是执行顺序）完全相反。</p><p>当一个函数即将结束执行时，其中的写在最下边的<code>defer</code>函数调用会最先执行，其次是写在它上边、与它的距离最近的那个<code>defer</code>函数调用，以此类推，最上边的<code>defer</code>函数调用会最后一个执行。</p><p>如果函数中有一条<code>for</code>语句，并且这条<code>for</code>语句中包含了一条<code>defer</code>语句，那么，显然这条<code>defer</code>语句的执行次数，就取决于<code>for</code>语句的迭代次数。</p><p>并且，同一条<code>defer</code>语句每被执行一次，其中的<code>defer</code>函数调用就会产生一次，而且，这些函数调用同样不会被立即执行。</p><p>那么问题来了，这条<code>for</code>语句中产生的多个<code>defer</code>函数调用，会以怎样的顺序执行呢？</p><p>为了彻底搞清楚，我们需要弄明白<code>defer</code>语句执行时发生的事情。</p><p>其实也并不复杂，在<code>defer</code>语句每次执行的时候，Go语言会把它携带的<code>defer</code>函数及其参数值另行存储到一个链表中。</p><p>这个链表与该<code>defer</code>语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。</p><p>在需要执行某个函数中的<code>defer</code>函数调用的时候，Go语言会先拿到对应的链表，然后从该链表中一个一个地取出<code>defer</code>函数及其参数值，并逐个执行调用。</p><p>这正是我说“<code>defer</code>函数调用与其所属的<code>defer</code>语句的执行顺序完全相反”的原因了。</p><p>下面该你出场了，我在demo51.go文件中编写了一个与本问题有关的示例，其中的核心代码很简单，只有几行而已。</p><p>我希望你先查看代码，然后思考并写下该示例被运行时，会打印出哪些内容。</p><p>如果你实在想不出来，那么也可以先运行示例，再试着解释打印出的内容。总之，你需要完全搞明白那几行内容为什么会以那样的顺序出现的确切原因。</p><h2>总结</h2><p>我们这两期的内容主要讲了两个函数和一条语句。<code>recover</code>函数专用于恢复panic，并且调用即恢复。</p><p>它在被调用时会返回一个空接口类型的结果值。如果在调用它时并没有panic发生，那么这个结果值就会是<code>nil</code>。</p><p>而如果被恢复的panic是我们通过调用<code>panic</code>函数引发的，那么它返回的结果值就会是我们传给<code>panic</code>函数参数值的副本。</p><p>对<code>recover</code>函数的调用只有在<code>defer</code>语句中才能真正起作用。<code>defer</code>语句是被用来延迟执行代码的。</p><p>更确切地说，它会让其携带的<code>defer</code>函数的调用延迟执行，并且会延迟到该<code>defer</code>语句所属的函数即将结束执行的那一刻。</p><p>在同一个函数中，延迟执行的<code>defer</code>函数调用，会与它们分别所属的<code>defer</code>语句的执行顺序完全相反。还要注意，同一条<code>defer</code>语句每被执行一次，就会产生一个延迟执行的<code>defer</code>函数调用。</p><p>这种情况在<code>defer</code>语句与<code>for</code>语句联用时经常出现。这时更要关注<code>for</code>语句中，同一条<code>defer</code>语句产生的多个<code>defer</code>函数调用的实际执行顺序。</p><p>以上这些，就是关于Go语言中特殊的程序异常，及其处理方式的核心知识。这里边可以衍生出很多面试题目。</p><h2>思考题</h2><p>我们可以在<code>defer</code>函数中恢复panic，那么可以在其中引发panic吗？</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p>","comments":[{"had_liked":false,"id":84012,"user_name":"wesleydeng","can_delete":false,"product_type":"c1","uid":1061385,"ip_address":"","ucode":"EC9204CEDDAF8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/09/669e21db.jpg","comment_is_top":false,"comment_ctime":1554769429,"is_pvip":false,"replies":[{"id":"30330","content":"这是两种完全不同的异常处理机制。Go语言的异常处理机制是两层的，defer和recover可以处理意外的的异常，而error接口及相关体系处理可预期的异常。Go语言把不同种类的异常完全区别对待，我觉得这是一个进步。<br><br>另外，defer机制能够处理的远不止异常，还有很多资源回收的任务可以用到它。defer机制和goroutine机制一样，是一种很有效果的创新。<br><br>我认为defer机制正是建立在goroutine机制之上的。因为每个函数都有可能成为go函数，所以必须要把异常处理做到函数级别。可以看到，defer机制和error机制都是以函数为边界的。前者在函数级别上阻止会导致非正常控制流的意外异常外溢，而后者在函数级别上用正常的控制流向外传递可预期异常。<br><br>不要说什么先驱，什么旧例，世界在进步，技术更是在猛进。不要把思维固化在某门或某些编程语言上。每种能够流行起来的语言都会有自己独有的、已经验证的语法、风格和哲学。<br><br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1554781413,"ip_address":"","comment_id":84012,"utype":1}],"discussion_count":9,"race_medal":0,"score":"366626989589","product_id":100013101,"comment_content":"从语言设计上，不使用try-catch而是用defer-recover有什么优势？c++和java作为先驱都使用try-catch，也比较清晰，为什么go作为新语言却要发明一个这样的新语法？有何设计上的考量？","like_count":85,"discussions":[{"author":{"id":1026448,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","nickname":"颇忒妥","note":"","ucode":"AA86AD1049BC2E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161276,"discussion_content":"如果就try-catch 和关闭资源的角度来说，目前defer 的设计实在算不上优雅，如果把defer做成函数级代码块会更好一些，比如这样：\nfunc() {\n} defer {\n} defer {\n}\n不过defer 的优势在于可以运行时插入，而不是编译时。比如你可以用if 来决定是否要插入一个defer 。\n所以我觉得defer 用来处理panic 应该算是一个兼职，是go 的设计者偷懒的结果。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1580883183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446217,"discussion_content":"这是两种完全不同的异常处理机制。Go语言的异常处理机制是两层的，defer和recover可以处理意外的的异常，而error接口及相关体系处理可预期的异常。Go语言把不同种类的异常完全区别对待，我觉得这是一个进步。\n\n另外，defer机制能够处理的远不止异常，还有很多资源回收的任务可以用到它。defer机制和goroutine机制一样，是一种很有效果的创新。\n\n我认为defer机制正是建立在goroutine机制之上的。因为每个函数都有可能成为go函数，所以必须要把异常处理做到函数级别。可以看到，defer机制和error机制都是以函数为边界的。前者在函数级别上阻止会导致非正常控制流的意外异常外溢，而后者在函数级别上用正常的控制流向外传递可预期异常。\n\n不要说什么先驱，什么旧例，世界在进步，技术更是在猛进。不要把思维固化在某门或某些编程语言上。每种能够流行起来的语言都会有自己独有的、已经验证的语法、风格和哲学。\n\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1554781413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114356,"avatar":"https://static001.geekbang.org/account/avatar/00/11/00/f4/cc5f0896.jpg","nickname":"Jowin","note":"","ucode":"19017F7D06C22A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273328,"discussion_content":"可预期的错误和异常分开，的确要好一些，可以避免异常被滥用。在很多时候为了省事儿，有人会用try/cache代替防卫代码，不做错误检查。我赞同下面这个哥们的说法，defer是用来做函数级别的资源清理工作的，处理panic是兼职。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1590447530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/21/0e/b2c7469c.jpg","nickname":"翼江亭赋","note":"","ucode":"B41C208B19C76C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41696,"discussion_content":"我认为try更简单明了，功能上是一样的。\n\n一条条争论：\n\n1. 可预期的异常在java里对应的是checked exception，意外的异常对应的是runtime exception。也是和go一样的不同情况区别对待。当然，实际情况下，早期java世界里，包括jdk自己，对两个的区别阐述指导得不清晰，导致checked exception被滥用。不过c++没这个区别。\n\n2. try finally同样可以用来释放资源。另外，java还有closeable单方法接口，同样作用。\n\n3. try是block层级的机制，比函数范围更小更灵活","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572488232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1351215,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AyccJq7eg6w3aCn7AxpicdplGhhY2xYOJLd9q2Xcjqxdbb6HO7rU4p37oxCjUnrcydpQVjNgcIhxOLKsI4w2KWQ/132","nickname":"Iflei","note":"","ucode":"812264ADE9CB33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1122574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/21/0e/b2c7469c.jpg","nickname":"翼江亭赋","note":"","ucode":"B41C208B19C76C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117978,"discussion_content":"try里写一坨代码是非常恶心的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578146173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41696,"ip_address":""},"score":117978,"extra":""},{"author":{"id":1296063,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c6/bf/52b3f71d.jpg","nickname":"dawn","note":"","ucode":"1757B28F1EF5C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1351215,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AyccJq7eg6w3aCn7AxpicdplGhhY2xYOJLd9q2Xcjqxdbb6HO7rU4p37oxCjUnrcydpQVjNgcIhxOLKsI4w2KWQ/132","nickname":"Iflei","note":"","ucode":"812264ADE9CB33","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287854,"discussion_content":"封闭原则，一个函数不应当抛错误的，即便自己内部出现异常，也应当对调用方屏蔽，比如一个insert函数，你能告诉调用方的只是是否插入成功以及插入成功后的id，而内部如数据库挂了，网络连接超时等，这些异常情况都应当视为插入失败，java在这一层抛异常，是因为系统有统一的异常处理，那么go呢，error满天飞，难道没调用一个函数都应该去判断是否有error嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593569686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":117978,"ip_address":""},"score":287854,"extra":""},{"author":{"id":1351215,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AyccJq7eg6w3aCn7AxpicdplGhhY2xYOJLd9q2Xcjqxdbb6HO7rU4p37oxCjUnrcydpQVjNgcIhxOLKsI4w2KWQ/132","nickname":"Iflei","note":"","ucode":"812264ADE9CB33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1296063,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c6/bf/52b3f71d.jpg","nickname":"dawn","note":"","ucode":"1757B28F1EF5C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290611,"discussion_content":"你可以返回值不加error啊，通过返回是否为空就知道是否处理成功，另外在一个新协程开始通过defer  处理recover，panic自底向上传递总会被捕获，比到处try catch美观多了吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594549128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287854,"ip_address":""},"score":290611,"extra":""}]},{"author":{"id":1188863,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/ff/701c6f4d.jpg","nickname":"小韩","note":"","ucode":"6CDE03F432607E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6511,"discussion_content":"拥抱变化，拥抱未来٩(๑^o^๑)۶","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566953160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31240,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1539135121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"177632794257","product_id":100013101,"comment_content":"defer其实是预调用，产生一个函数对象，压栈保存，函数退出时依次取出执行","like_count":41},{"had_liked":false,"id":88575,"user_name":"凌惜沫","can_delete":false,"product_type":"c1","uid":1008524,"ip_address":"","ucode":"9069731E14F8DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/8c/8e803651.jpg","comment_is_top":false,"comment_ctime":1555944835,"is_pvip":false,"replies":[{"id":"31780","content":"嗯，是的，由于之前发生的 panic 已经被 recover 了，所以最终被抛出去的就应该是外层 defer 语句中的那个 panic。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1555984317,"ip_address":"","comment_id":88575,"utype":1}],"discussion_count":2,"race_medal":0,"score":"78865356163","product_id":100013101,"comment_content":"如果defer中引发panic，那么在该段defer函数之前，需要另外一个defer来捕获该panic，并且代码中最后一个panic会被抛弃，由defer中的panic来成为最后的异常返回。","like_count":18,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447833,"discussion_content":"嗯，是的，由于之前发生的 panic 已经被 recover 了，所以最终被抛出去的就应该是外层 defer 语句中的那个 panic。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555984317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134774,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/b6/a60efa42.jpg","nickname":"孟凡浩","note":"","ucode":"77522A196C31D5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320020,"discussion_content":"1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604225799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88673,"user_name":"小龙虾","can_delete":false,"product_type":"c1","uid":1141385,"ip_address":"","ucode":"A6DFC7DD17E297","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/89/3cac9f83.jpg","comment_is_top":false,"comment_ctime":1555981407,"is_pvip":false,"replies":[{"id":"31778","content":"是的，这是最主要好处。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1555983878,"ip_address":"","comment_id":88673,"utype":1}],"discussion_count":2,"race_medal":0,"score":"70275458143","product_id":100013101,"comment_content":"我感觉还是go的这种设计好用，它会强迫开发者区别对待错误和异常，并做出不同的处理。相比try{}catch，我在开发中经常看到开发者把大段大段的代码或者整个处理写到try{}中，这本身就是对try{}catch的乱用","like_count":16,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447861,"discussion_content":"是的，这是最主要好处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555983878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1989926,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/5d/26/972b2b8f.jpg","nickname":"越泽","note":"","ucode":"973DAB48E413BF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390552,"discussion_content":"新手怎样区别错误和异常呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629887736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54484,"user_name":"sket","can_delete":false,"product_type":"c1","uid":1197729,"ip_address":"","ucode":"C7E24300D794F7","user_header":"http://thirdwx.qlogo.cn/mmopen/KFgDEHIEpnSjjGClCeqmKYJsSOQo40BMHRTtNYrWyQP9WypAjTToplVND944one2pkEyH5Oib4m4wUOJ9xBEIZQ/132","comment_is_top":false,"comment_ctime":1545880079,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35905618447","product_id":100013101,"comment_content":"感觉还是try{}catch这种异常处理好用","like_count":8,"discussions":[{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541053,"discussion_content":"感觉各有各的优势吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640243189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175901,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1580882683,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"31645653755","product_id":100013101,"comment_content":"作者想把概念给我们讲清楚，但是我总觉着看着费劲。为啥？因为作者太啰嗦了。比如：<br>defer函数调用的执行顺序与它们分别所属的defer语句的出现顺序（更严谨地说，是执行顺序）完全相反。<br>改成这样就简单多了：defer函数的调用顺序与其defer语句执行顺序相反。<br>还有：当一个函数即将结束执行时，其中的写在最下边的defer函数调用会最先执行，其次是写在它上边、与它的距离最近的那个defer函数调用，以此类推，最上边的defer函数调用会最后一个执行。<br>改成：当一个函数即将执行结束时，最下面的defer函数先执行，然后是倒数第二个，以此类推。","like_count":7,"discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387860,"discussion_content":"我认为作者的表述更加严谨，不信你日后再来品读。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1628475948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2725689,"avatar":"https://static001.geekbang.org/account/avatar/00/29/97/39/1f5c6350.jpg","nickname":"朱元彬🗿","note":"","ucode":"9CBD43225EE65B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537231,"discussion_content":"作者的表述是多点，但是好理解啊……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639008349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2933322,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/c2/4a/22930340.jpg","nickname":"Biff","note":"","ucode":"0F89DF226EEB9F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574080,"discussion_content":"或者讲:当代码遇到defer会将defer依次入栈，函数执行完再依次出栈，虽然坐着说defer的底层是 链表，但是当栈理解没毛病","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653823942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70405,"user_name":"liangjf","can_delete":false,"product_type":"c1","uid":1058812,"ip_address":"","ucode":"681A6CCF098F55","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg","comment_is_top":false,"comment_ctime":1551092478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27320896254","product_id":100013101,"comment_content":"Go 语言会把它携带的defer函数及其参数值另行存储到一个队列中。<br><br>这个队列与该defer语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈<br><br><br>直接表达为  创建defer时“函数对象“压栈，panic触发时出栈调用   更容易理解吧","like_count":6},{"had_liked":false,"id":232961,"user_name":"名:海东","can_delete":false,"product_type":"c1","uid":1269996,"ip_address":"","ucode":"0BBF4402F75D07","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/ec/11cf22de.jpg","comment_is_top":false,"comment_ctime":1594178042,"is_pvip":false,"replies":[{"id":"85984","content":"很简单，在场景一中，test01 函数不是一个 defer 函数（它只是被 defer 函数调用了而已）；而在场景二中，test01 函数却是一个不折不扣的 defer 函数。只有直接在 defer 函数中调用 recover() 函数才能起到恢复 panic 的作用。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1594196262,"ip_address":"","comment_id":232961,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18774047226","product_id":100013101,"comment_content":"&#47;&#47;测试场景1<br>func Test()  {<br>\tdefer func() {<br>\t\tif errRecover := recover(); errRecover != nil {<br>\t\t\tfmt.Println(&quot;recover2...&quot;)<br>\t\t}<br>\t\tfmt.Println(&quot;no recover2...&quot;)<br>\t}()<br>\tdefer func() {<br>\t\ttest01()  &#47;&#47; test01()方法在defer func(){}中执行<br>\t}()<br>\tb := 0<br>\ta := 1 &#47; b<br>\tfmt.Println(a)<br>\treturn<br>}<br><br>func test01() {<br>\tif e := recover(); e != nil {<br>\t\tfmt.Println(&quot;recover...&quot;)<br>\t} else {<br>\t\tfmt.Println(&quot;no recover...&quot;)<br>\t}<br>\tfmt.Println(&quot;defer exe...&quot;)<br>}<br><br>func main() {<br>\tTest()<br>}<br>&#47;&#47;输出：<br>no recover...<br>defer exe...<br>recover2...<br>no recover2...<br><br>&#47;&#47;测试场景2<br>func Test()  {<br>\tdefer func() {<br>\t\tif errRecover := recover(); errRecover != nil {<br>\t\t\tfmt.Println(&quot;recover2...&quot;)<br>\t\t}<br>\t\tfmt.Println(&quot;no recover2...&quot;)<br>\t}()<br>\tdefer test01()  &#47;&#47;test01()直接放到defer后面 <br>\tb := 0<br>\ta := 1 &#47; b<br>\tfmt.Println(a)<br>\treturn<br>}<br><br>func test01() {<br>\tif e := recover(); e != nil {<br>\t\tfmt.Println(&quot;recover...&quot;)<br>\t} else {<br>\t\tfmt.Println(&quot;no recover...&quot;)<br>\t}<br>\tfmt.Println(&quot;defer exe...&quot;)<br>}<br><br>func main() {<br>\tTest()<br>}<br>&#47;&#47;输出：<br>recover...<br>defer exe...<br>no recover2...<br><br>我的问题是：为什么场景1中出现panic没有在defer func() {<br>\t\ttest01()<br>\t}()中被recover，而在defer func() {<br>\t\tif errRecover := recover(); errRecover != nil {<br>\t\t\tfmt.Println(&quot;recover2...&quot;)<br>\t\t}<br>\t\tfmt.Println(&quot;no recover2...&quot;)<br>\t}()中被recover。<br>场景2使用defer test01 的写法后就可以被recover。","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500828,"discussion_content":"很简单，在场景一中，test01 函数不是一个 defer 函数（它只是被 defer 函数调用了而已）；而在场景二中，test01 函数却是一个不折不扣的 defer 函数。只有直接在 defer 函数中调用 recover() 函数才能起到恢复 panic 的作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594196262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269996,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/ec/11cf22de.jpg","nickname":"名:海东","note":"","ucode":"0BBF4402F75D07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290127,"discussion_content":"谢谢老师，看了下官网文档，都是使用场景二实现的recover,不知道是不是go官方defer中就是这么规定的:只有直接在 defer 函数中调用 recover() 函数才能恢复 panic 。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594351094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1151796,"avatar":"https://static001.geekbang.org/account/avatar/00/11/93/34/5e5b958e.jpg","nickname":"How2Go","note":"","ucode":"A2242F1C832D36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380242,"discussion_content":"郝老师，为什么test01在被defer 函数调用的情况下，不能recover呢？ recover的是只能恢复当前函数调用吗？一旦离开当前栈帧就会失效吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624411622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159541,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1575677827,"is_pvip":false,"replies":[{"id":"60978","content":"当然。因为它们之间不是串行的关系，所以 panic 传播不到其他的 goroutine 那里。所以，每个 goroutine 都应该有自己的异常处理代码。我们可以设计一个整体的异常处理规则或体系，并在每个 goroutine 里都遵循它。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1575699583,"ip_address":"","comment_id":159541,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18755547011","product_id":100013101,"comment_content":"试验了一下在 goroutine 里面 panic，其他的 goroutine（比如main）是 recover()不到的：<br><br>func main() {<br>\tfmt.Println(&quot;start&quot;)<br>\tdefer func() {<br>\t\tif p := recover(); p != nil {<br>\t\t\tfmt.Println(p)<br>\t\t}<br>\t}()<br>\tvar wg sync.WaitGroup<br>\twg.Add(1)<br>\tgo func() {<br>\t\tdefer func() {<br>\t\t    wg.Done()<br>\t\t}()<br>\t\tpanic(errors.New(&quot;panic in goroutine&quot;))<br><br>\t}()<br>\twg.Wait()<br>}","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477091,"discussion_content":"当然。因为它们之间不是串行的关系，所以 panic 传播不到其他的 goroutine 那里。所以，每个 goroutine 都应该有自己的异常处理代码。我们可以设计一个整体的异常处理规则或体系，并在每个 goroutine 里都遵循它。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575699583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146280,"user_name":"翼江亭赋","can_delete":false,"product_type":"c1","uid":1122574,"ip_address":"","ucode":"B41C208B19C76C","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/0e/b2c7469c.jpg","comment_is_top":false,"comment_ctime":1572489017,"is_pvip":false,"replies":[{"id":"56475","content":"Go 的 error 其实就是在用普通的控制流来处理异常。但是性能却可以有非常明显的提高。其实不管怎么弄都做不到“羊毛出在猪身上”。不管是让开发者自行处理，还是运行时系统自己控制，都会对程序的流畅度产生影响。这就是程序稳定性和程序流畅度（包括可读性、控制流和性能等）之间的trade off。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1572494191,"ip_address":"","comment_id":146280,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14457390905","product_id":100013101,"comment_content":"iava世界里曾经try catch满天飞，现在还能看到不少这种代码，但逐渐大家认同了在去掉这种代码。<br><br>因为大部分catch住异常以后只是打个log再重新throw，这个交给框架代码在最外层catch住以后统一处理即可。非框架代码极少需要处理异常。<br><br>go世界里，err guard满天飞，但大部分的处理也是层层上传。但做不到不用，因为不像try那样去掉catch后会自动往上传递，不检查err的话就丢失了，所以这种代码去不掉。只能继续满天飞。<br><br>底层实现其实都是setjmp，主要的区别之一我认为是go设计者认为java异常的性能代价大。","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472779,"discussion_content":"Go 的 error 其实就是在用普通的控制流来处理异常。但是性能却可以有非常明显的提高。其实不管怎么弄都做不到“羊毛出在猪身上”。不管是让开发者自行处理，还是运行时系统自己控制，都会对程序的流畅度产生影响。这就是程序稳定性和程序流畅度（包括可读性、控制流和性能等）之间的trade off。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572494191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/21/0e/b2c7469c.jpg","nickname":"翼江亭赋","note":"","ucode":"B41C208B19C76C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42197,"discussion_content":"从错误处理的性能上来说，我自己不认同go的这个做法，异常路径的性能占总体是20：80之类的占很小一部分的比例，代价是三四分之一的代码在检查和传递error。代码越多通常bug越多。我看见些有的代码里不小心把if err ！=nil写反。相应的，测试代码量也增加了不少。弊端不少...\n\n如果统一用类似java异常的方式去处理err，即拿到err后转换成panic，然后在统一的地方拦截住，这样是否合适？\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572609407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1272825,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","nickname":"Onyanga","note":"","ucode":"DF4D22F0D51881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1122574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/21/0e/b2c7469c.jpg","nickname":"翼江亭赋","note":"","ucode":"B41C208B19C76C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300067,"discussion_content":"你说的方式针对的是panic这一套，而不是err这一套，这就是go的两套错误机制。\n如果内层全部用panic，在最上层加一个defer-recover捕获，和java的框架统一处理是类似的。\n且，如果中途有某一层调用关心下面的panic上抛，也可以再补充一个defer，然后defer内在继续panic，效果和try-catch一样。\n\n不同在于，go提供了这两套泾渭分明的机制，也逼迫开发者和框架设计者去思考到底错误是什么。\n\n只是如果不用panic，纯用err，这就将决定权大幅度给了开发者，也逼迫开发者去思考要不要处理err，也就逼迫去思考如果err了，要怎么做。虽然丑了点，但是约束性更好，这是一种取舍。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1597927042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":42197,"ip_address":""},"score":300067,"extra":""}]}]},{"had_liked":false,"id":50477,"user_name":"風華","can_delete":false,"product_type":"c1","uid":1164612,"ip_address":"","ucode":"B35962E0CD6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/11/c5/44/8ff59fc4.jpg","comment_is_top":false,"comment_ctime":1544977436,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14429879324","product_id":100013101,"comment_content":"如果defer中引发panic，那么在该段defer函数之前，需要另外一个defer来捕获该panic，并且代码中最后一个panic会被抛弃，由defer中的panic来成为最后的异常返回。","like_count":3},{"had_liked":false,"id":29449,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1538377238,"is_pvip":false,"replies":[{"id":"10643","content":"对的。不过还是有不少不一样的地方的，可以体会一下。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1538451577,"ip_address":"","comment_id":29449,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14423279126","product_id":100013101,"comment_content":"可以 defer 有点类似java中的final语句，里面还可以抛出异常。这样的好处是，我们捕获panic之后，可以对起内容进行查看，如果不是我们关注的panic那么可以继续抛出去","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425612,"discussion_content":"对的。不过还是有不少不一样的地方的，可以体会一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538451577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271334,"user_name":"Zz~","can_delete":false,"product_type":"c1","uid":1219199,"ip_address":"","ucode":"7E530804E6C144","user_header":"https://static001.geekbang.org/account/avatar/00/12/9a/7f/781f89ab.jpg","comment_is_top":false,"comment_ctime":1609565936,"is_pvip":true,"replies":[{"id":"98367","content":"某个goroutine中的panic是不可能由别的goroutine中的recover恢复的。或者说，一个goroutine中的panic只能由自己例程中的recover恢复。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1609581763,"ip_address":"","comment_id":271334,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10199500528","product_id":100013101,"comment_content":"老师，您好，我想问一下，如果在main函数里调用一个我自定义的panic方法，recover可以恢复；但是如果我将自定义的panic方法改为go mypanic这样，recover就不能恢复。这是什么原因呢？下面是我实验的代码<br><br><br>==============可以恢复的==============<br>package main<br><br>import (<br>\t&quot;errors&quot;<br>\t&quot;fmt&quot;<br>)<br><br>func myRecover() {<br>\tif err := recover(); err != nil {<br>\t\tfmt.Printf(&quot;panic is %s&quot;, err)<br>\t}<br>}<br><br>func myPanic() {<br>\tpanic(errors.New(&quot;自定义异常&quot;))<br>}<br><br>func main() {<br>\tdefer myRecover()<br>\tmyPanic()<br>}<br><br><br>=================不可以恢复的==============<br>package main<br><br>import (<br>\t&quot;errors&quot;<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br><br>func myRecover() {<br>\tif err := recover(); err != nil {<br>\t\tfmt.Printf(&quot;panic is %s&quot;, err)<br>\t}<br>}<br><br>func myPanic() {<br>\tpanic(errors.New(&quot;自定义异常&quot;))<br>}<br><br>func main() {<br>\tdefer myRecover()<br>\tgo myPanic()<br>\ttime.Sleep(time.Second * 5)<br>}<br>","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512904,"discussion_content":"某个goroutine中的panic是不可能由别的goroutine中的recover恢复的。或者说，一个goroutine中的panic只能由自己例程中的recover恢复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609581763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219199,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9a/7f/781f89ab.jpg","nickname":"Zz~","note":"","ucode":"7E530804E6C144","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339302,"discussion_content":"好的，谢谢老师回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609596567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94314,"user_name":"honnkyou","can_delete":false,"product_type":"c1","uid":1026608,"ip_address":"","ucode":"FD5EC4120EE803","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/30/acc91f01.jpg","comment_is_top":false,"comment_ctime":1557765259,"is_pvip":false,"replies":[{"id":"33728","content":"defer 函数的执行时刻是在直接包含它的那个函数即将执行完毕的时候，也可以理解为下一刻就要返回结果值（如果有的话）的时候。对于 main 函数直接包含的 defer 函数来说，也是如此。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1557802426,"ip_address":"","comment_id":94314,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10147699851","product_id":100013101,"comment_content":"「延迟到什么时候呢？这要延迟到该语句所在的函数即将执行结束的那一刻，无论结束执行的原因是什么。」<br>以该节课中代码为例的话是要吃到main函数快结束时执行是吗？执行defer函数。","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450014,"discussion_content":"defer 函数的执行时刻是在直接包含它的那个函数即将执行完毕的时候，也可以理解为下一刻就要返回结果值（如果有的话）的时候。对于 main 函数直接包含的 defer 函数来说，也是如此。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557802426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1489177,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b9/19/f4ef2c9a.jpg","nickname":"秦穆之","note":"","ucode":"709C49BFCBB776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327263,"discussion_content":"具体可以在一个函数中 写一个匿名函数实现下，很容易就理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605778067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42025,"user_name":"Bang","can_delete":false,"product_type":"c1","uid":1160079,"ip_address":"","ucode":"0CB8A52B177868","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8f/4caf7f03.jpg","comment_is_top":false,"comment_ctime":1542893904,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10132828496","product_id":100013101,"comment_content":"请问下，按您上面说的，一个recover只能恢复所在的那个函数。那如果一个 函数中有一个goroutine函数  而这个goroutine函数触发了panic，那是只有他自己可以recover是吗，他的上级是无法recover内部的goroutine的painc是这样吗？","like_count":2,"discussions":[{"author":{"id":1489177,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b9/19/f4ef2c9a.jpg","nickname":"秦穆之","note":"","ucode":"709C49BFCBB776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327266,"discussion_content":"是的，如果他的上级无论有没有recover 都会panic的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605778475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29395,"user_name":"有匪君子","can_delete":false,"product_type":"c1","uid":1204061,"ip_address":"","ucode":"72B91AFC96E285","user_header":"https://static001.geekbang.org/account/avatar/00/12/5f/5d/63010e32.jpg","comment_is_top":false,"comment_ctime":1538362576,"is_pvip":false,"replies":[{"id":"10650","content":"只要是函数就都可以。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1538452869,"ip_address":"","comment_id":29395,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10128297168","product_id":100013101,"comment_content":"这个问题就引发了另一个问题。defer可以在同一个函数中嵌套使用吗？感觉这两个问题答案应该一致","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425579,"discussion_content":"只要是函数就都可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538452869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195627,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1585206871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880174167","product_id":100013101,"comment_content":"今日总结 <br>本章主要是讲了panic和recover以及defer<br>panic主要是用来抛出恐慌<br>而recover主要用来恢复恐慌，但是recover使用即恢复 如果在此时没有恐慌产生就会返回一个nil<br>也正是因为recover使用即恢复的特性 所以要把recover执行在产生恐慌之后，但是panic之后的代码不会再执行所以引入defer表达式<br>defer表达式 主要是用来代码延迟执行 延迟到函数结束，所以一般把recover跟defer搭配 <br>defer的执行 没执行一次defer语句产生一个defer函数 并且将其放入一个额外的栈中 所以是个先入后出的顺序!所以defer 函数的执行顺序与其声明顺序完全相反<br>关于思考题:<br>我觉得从理论上来说 我们没必要完全人为的引起panic 但是如果是不小心引起的panic那也无法避免,同时通过测试也是可以引发panic的","like_count":1},{"had_liked":false,"id":187029,"user_name":"张sir","can_delete":false,"product_type":"c1","uid":1209431,"ip_address":"","ucode":"52958DF6705208","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/57/7b828263.jpg","comment_is_top":false,"comment_ctime":1583995393,"is_pvip":false,"replies":[{"id":"72157","content":"参数值flag是2，因为Go会在压栈前先求出给予defer函数的那些参数值。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1584006811,"ip_address":"","comment_id":187029,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5878962689","product_id":100013101,"comment_content":"您好，请问defer函数压𣏾的时候，为什么把当时的入参也放入𣏾中呢<br>```<br>func test() {<br>\tvar a, b = 1, 1<br>\tdefer func(flag int) {<br>\t\tfmt.Println(flag)<br>\t}(a + b)<br><br>\ta = 2<br>\tb = 2<br><br>}<br><br>```<br><br>这个输出的２不是４的理论论据是什么呢","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486966,"discussion_content":"参数值flag是2，因为Go会在压栈前先求出给予defer函数的那些参数值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584006811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184637,"user_name":"Pana","can_delete":false,"product_type":"c1","uid":1016571,"ip_address":"","ucode":"6E016D4966B187","user_header":"https://static001.geekbang.org/account/avatar/00/0f/82/fb/9d232a7a.jpg","comment_is_top":false,"comment_ctime":1583375749,"is_pvip":false,"replies":[{"id":"71495","content":"可以，函数需要有一个有名称的error类型的结果，然后在该函数内recover之后为这个结果赋值。这样就可以了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1583471590,"ip_address":"","comment_id":184637,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5878343045","product_id":100013101,"comment_content":"在defer 中 recover 了panic ，是否还能让函数返回错误呢","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486074,"discussion_content":"可以，函数需要有一个有名称的error类型的结果，然后在该函数内recover之后为这个结果赋值。这样就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583471590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42024,"user_name":"Bang","can_delete":false,"product_type":"c1","uid":1160079,"ip_address":"","ucode":"0CB8A52B177868","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8f/4caf7f03.jpg","comment_is_top":false,"comment_ctime":1542893903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5837861199","product_id":100013101,"comment_content":"请问下，按您上面说的，一个recover只能恢复所在的那个函数。那如果一个 函数中有一个goroutine函数  而这个goroutine函数触发了panic，那是只有他自己可以recover是吗，他的上级是无法recover内部的goroutine的painc是这样吗？","like_count":1},{"had_liked":false,"id":34856,"user_name":"独自逛荡","can_delete":false,"product_type":"c1","uid":1184211,"ip_address":"","ucode":"7A3E2840191C3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/d3/dd499428.jpg","comment_is_top":false,"comment_ctime":1540341514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5835308810","product_id":100013101,"comment_content":"defer func(){.....1}()<br>defer func(){.....2}()<br>defer func(){.....3}()<br>panic(&quot;4&quot;)<br>我在goland里面分别选择 gc 和 gccgo编译<br>发现执行的顺序不同  一个是3421一个是 3214","like_count":1},{"had_liked":false,"id":29556,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1538438948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833406244","product_id":100013101,"comment_content":"可以使用panic函数主动触发panic，参数建议传递error（实际上可以是任意类型）<br>可以使用recover捕获panic，如果当前没有发生panic，则返回nil，如果有则返回panic副本<br>defer语句有延后执行调用表达式（推荐是个函数）的作用，这里的延后指的是defer语句的调用函数即将退出的那一刻<br>defer语句的延后调用是先进后出（FILO）的，C++的析构也是这样的","like_count":1},{"had_liked":false,"id":359657,"user_name":"大雄","can_delete":false,"product_type":"c1","uid":2978983,"ip_address":"北京","ucode":"1639C6DAFB5E25","user_header":"https://static001.geekbang.org/account/avatar/00/2d/74/a7/e609ca59.jpg","comment_is_top":false,"comment_ctime":1665732461,"is_pvip":true,"replies":[{"id":"130837","content":"基本正确，panic代表以外错误。其实也可以用于终止程序，比如：当出现某种非常严重的、很难恢复的错误（程序的终止在程序开发或程序运行过程中也算是一种警示⚠️）。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1665747202,"ip_address":"北京","comment_id":359657,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1665732461","product_id":100013101,"comment_content":"是否可以理解，我们一般自己返回的error都是可以预见的业务异常（例如：手机号码格式不正确等），可以灵活判断。<br>panic则是意料外的，但不需要终止进程，所以需要要recover恢复","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590449,"discussion_content":"基本正确，panic代表以外错误。其实也可以用于终止程序，比如：当出现某种非常严重的、很难恢复的错误（程序的终止在程序开发或程序运行过程中也算是一种警示⚠️）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665747202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351453,"user_name":"fire","can_delete":false,"product_type":"c1","uid":2028585,"ip_address":"","ucode":"2B5F571516CD11","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f4/29/20880430.jpg","comment_is_top":false,"comment_ctime":1657802467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657802467","product_id":100013101,"comment_content":"defer函数中可以调动panic函数，但是需要在此defer函数之前再写一个defer recover函数恢复","like_count":0},{"had_liked":false,"id":326469,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1639536406,"is_pvip":false,"replies":[{"id":"118614","content":"try-catch语句要是抛出异常了，try子句里的剩余代码也无法再接着运行了啊，只能通过某种方式再整体重试。Go的panic机制也是这样的。从这个层面讲，两者没有本质区别。只不过，try-catch语句的重试是以try-catch语句为单位的，panic-recover机制是以函数为单位的。","user_name":"作者回复","user_name_real":"作者","uid":"1026643","ctime":1639567956,"ip_address":"","comment_id":326469,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1639536406","product_id":100013101,"comment_content":"如果\ts5 := s1[5]引发panic，可以在函数退出前通过defer语句中recover捕获并处理，哪是否有办法让函数继续执行完引发panic时后面哪些代码，像其他语言用try catch一样，能继续向下执行完整个函数的代码，还是说go的设计并不是如此，一定要在引发异常处立即返回<br>func caller2() (err error) {<br>\tdefer func() {<br>\t\tp := recover()<br>\t\tif p != nil {<br>\t\t\terr = fmt.Errorf(&quot;error: %s\\n&quot;, p)<br>\t\t}<br>\t}()<br>\tfmt.Println(&quot;Enter function caller2.&quot;)<br>\ts1 := []int{1, 2, 3, 4, 5}<br>\ts5 := s1[5]<br>\t_ = s5<br>\tfmt.Println(&quot;Exit function caller2.&quot;)<br>\treturn err<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538974,"discussion_content":"try-catch语句要是抛出异常了，try子句里的剩余代码也无法再接着运行了啊，只能通过某种方式再整体重试。Go的panic机制也是这样的。从这个层面讲，两者没有本质区别。只不过，try-catch语句的重试是以try-catch语句为单位的，panic-recover机制是以函数为单位的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639567956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1101006,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","nickname":"jxs1211","note":"","ucode":"B7F1F2D84389E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":539279,"discussion_content":"也就是说一旦panic后面的代码就肯定不会执行，会立即退出该函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639656458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":538974,"ip_address":""},"score":539279,"extra":""}]}]},{"had_liked":false,"id":320237,"user_name":"爱学习的好孩子","can_delete":false,"product_type":"c1","uid":1331195,"ip_address":"","ucode":"C51EA3E529BE0B","user_header":"https://static001.geekbang.org/account/avatar/00/14/4f/fb/3eb917f1.jpg","comment_is_top":false,"comment_ctime":1636167587,"is_pvip":false,"replies":[{"id":"116139","content":"defer语句是紧接在defer关键字后面（或者说在它右边）的那个函数，这个跟go函数的命名方式是一样的。<br><br>defer语句就是“defer关键字+defer函数”。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1636274084,"ip_address":"","comment_id":320237,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636167587","product_id":100013101,"comment_content":"看不懂，defer函数和defer语句是什么关系？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529924,"discussion_content":"defer语句是紧接在defer关键字后面（或者说在它右边）的那个函数，这个跟go函数的命名方式是一样的。\n\ndefer语句就是“defer关键字+defer函数”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636274084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306839,"user_name":"Harlan","can_delete":false,"product_type":"c1","uid":2134882,"ip_address":"","ucode":"F43595A0A00B19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erpYZalYvFGcBs7zZvYwaQAZwTLiaw0mycJ4PdYpP3VxAYkAtyIRHhjSOrOK0yESaPpgEbVQUwf6LA/132","comment_is_top":false,"comment_ctime":1628740621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628740621","product_id":100013101,"comment_content":"go里 开发者必粗关注异常  稍有不慎 就panic  这种机制感觉带来了大量重复工作  异常处理和程序无法分开","like_count":0},{"had_liked":false,"id":296424,"user_name":"罗峰","can_delete":false,"product_type":"c1","uid":1218501,"ip_address":"","ucode":"5F3D6AF8F28322","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","comment_is_top":false,"comment_ctime":1622968740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622968740","product_id":100013101,"comment_content":"记录下，defer函数像一个闭包，可以捕获自由产量。recover只能捕获所处的goroutine所在函数或者函数里调用的函数传上的异常信息。","like_count":0},{"had_liked":false,"id":284257,"user_name":"tuxknight","can_delete":false,"product_type":"c1","uid":1000882,"ip_address":"","ucode":"B78FE23CB2641B","user_header":"","comment_is_top":false,"comment_ctime":1616142711,"is_pvip":false,"replies":[{"id":"103179","content":"这个做不到，如果出现这种情况就需要考量设计方面的问题了，可以把函数切分的更细一些，从而避免可能出现 panic 的情况过多。<br><br>另外，你可以先 recover，然后在根据具体的 panic 分别对待，比如重新抛出 panic 或者转化为 error。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1616301732,"ip_address":"","comment_id":284257,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616142711","product_id":100013101,"comment_content":"假如一个函数里面会有多个 panic，怎么能够只对某些 panic 进行 recover 呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517287,"discussion_content":"这个做不到，如果出现这种情况就需要考量设计方面的问题了，可以把函数切分的更细一些，从而避免可能出现 panic 的情况过多。\n\n另外，你可以先 recover，然后在根据具体的 panic 分别对待，比如重新抛出 panic 或者转化为 error。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616301732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224643,"user_name":"Tianz","can_delete":false,"product_type":"c1","uid":1248212,"ip_address":"","ucode":"4B6542604B8B6F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/d4/39763233.jpg","comment_is_top":false,"comment_ctime":1591495729,"is_pvip":false,"replies":[{"id":"82772","content":"只要没碰上defer &amp; recover，panic 就会一直传播出去并导致程序终止。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1591589513,"ip_address":"","comment_id":224643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591495729","product_id":100013101,"comment_content":"皮友们，所有在 runtime 时导致程序终止（除了响应外部终止信号），都是 panic 吗？还真是有已经正确添加了 defer &amp; recover 机制但程序还是被终止了，所有像郝大上一篇回答说的有些 panic 是不可恢复的，蛋是都有哪些呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497552,"discussion_content":"只要没碰上defer &amp;amp; recover，panic 就会一直传播出去并导致程序终止。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591589513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221659,"user_name":"LUO JINGYUAN","can_delete":false,"product_type":"c1","uid":1984817,"ip_address":"","ucode":"6403B6D6B6ECB5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/49/31/6d5728ac.jpg","comment_is_top":false,"comment_ctime":1590560597,"is_pvip":false,"replies":[{"id":"81806","content":"这里确实是用词不当，应该叫“链表”。我已经让编辑修正了。你很仔细啊！谢谢！","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1590639318,"ip_address":"","comment_id":221659,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590560597","product_id":100013101,"comment_content":"想问一下老师，队列和栈是不是两个不同的概念。因为之前看别的材料说队列（queue）和栈（stack）是不同的类型的数据结构。主要区分点是队列是FIFO，而栈是FILO。所以在看defer函数那段，感觉有点迷惑。所以希望老师讲解一下。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496528,"discussion_content":"这里确实是用词不当，应该叫“链表”。我已经让编辑修正了。你很仔细啊！谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590639318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1984817,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/49/31/6d5728ac.jpg","nickname":"LUO JINGYUAN","note":"","ucode":"6403B6D6B6ECB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276720,"discussion_content":"谢谢老师，嘿嘿，一起进步，因为我也是在用golang工作，非常喜欢您的这个专栏🥳感觉看完又对golang有了新的认识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590932820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214081,"user_name":"chain","can_delete":false,"product_type":"c1","uid":1209419,"ip_address":"","ucode":"479D8351CE9F63","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/4b/c56452c3.jpg","comment_is_top":false,"comment_ctime":1588651196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588651196","product_id":100013101,"comment_content":"队列一般来讲就是指的先进先出的存储结构，这里术语感觉是可以用得更考究一点","like_count":0},{"had_liked":false,"id":191995,"user_name":"Cyril","can_delete":false,"product_type":"c1","uid":1024693,"ip_address":"","ucode":"29FFFAC32F911B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/b5/4dc0c109.jpg","comment_is_top":false,"comment_ctime":1584808872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584808872","product_id":100013101,"comment_content":"defer 的执行时机是函数返回前","like_count":0},{"had_liked":false,"id":148379,"user_name":"博博","can_delete":false,"product_type":"c1","uid":1490403,"ip_address":"","ucode":"79FF6249DFC047","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/GBU53SA3W8GNRAwZIicc3gTEc0nSvfPJw7iboAMicjicmP6egDcibib28DkUfTYOjMd31DIznmofdRZrpIXvmXvjV1PQ/132","comment_is_top":false,"comment_ctime":1573000492,"is_pvip":false,"replies":[{"id":"57152","content":"切片的话，要看你是怎么变的。比如，由于追加元素等操作导致切片以及底层数组彻底换新，原切片就不变。这需要具体情况具体分析，你最好把代码贴上来。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1573016668,"ip_address":"","comment_id":148379,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573000492","product_id":100013101,"comment_content":"老师，最近遇到一个defer的问题，想请教一下！<br>defer在声明的时候会把函数和它的参数求值后拷贝一份先入栈，如果这个参数是值，那么在真正执行的时候不会改变，如果这个参数是引用，那在真正执行前如果改变了它的话，最终defer执行时的参数应该是改变后的！但是切片这种引用类型的参数，为什么没办法改变呢，而如果是一个指针的话就会被改变？<br>希望能得到您的解答，谢谢了！！！","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473476,"discussion_content":"切片的话，要看你是怎么变的。比如，由于追加元素等操作导致切片以及底层数组彻底换新，原切片就不变。这需要具体情况具体分析，你最好把代码贴上来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573016668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117995,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1564208698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564208698","product_id":100013101,"comment_content":"老师的demo非常经典 每一个看着都很带劲","like_count":0},{"had_liked":false,"id":111960,"user_name":"Sky","can_delete":false,"product_type":"c1","uid":1392585,"ip_address":"","ucode":"4C5A5AB73E8B90","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","comment_is_top":false,"comment_ctime":1562643553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562643553","product_id":100013101,"comment_content":"是否可以这样理解，defer语句就是在析构的时候执行的。","like_count":0},{"had_liked":false,"id":101143,"user_name":"benying","can_delete":false,"product_type":"c1","uid":1247522,"ip_address":"","ucode":"DEBAB485F381CC","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/22/22c0c4fa.jpg","comment_is_top":false,"comment_ctime":1559726444,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559726444","product_id":100013101,"comment_content":"打卡，这篇文章的评论都很赞啊","like_count":0},{"had_liked":false,"id":96240,"user_name":"清静淡泊","can_delete":false,"product_type":"c1","uid":1215670,"ip_address":"","ucode":"8A0DD8BF7405F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/b6/9ff2dfea.jpg","comment_is_top":false,"comment_ctime":1558362479,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558362479","product_id":100013101,"comment_content":"关于思考题，可以的。<br><br>大的控制流是这样的：<br>panic函数那一行执行完后马上结束当前函数；而defer函数被调用就是发生在当前函数结束后的立即。这些规则&#47;顺序是不变的。<br><br>所以说，如果panic函数放在defer函数调用链上（某一个defer函数体中），只要后续defer函数有recover函数并处理了这个panic，那么恐慌就被处理了；同理，如果后续defer函数没有recover函数被放置，那么在依次运行完defer函数链上的函数后，panic会继续向函数栈上一级抛（如果是main就直接终止进程了）。","like_count":0},{"had_liked":false,"id":62555,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1548091322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548091322","product_id":100013101,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":42026,"user_name":"Bang","can_delete":false,"product_type":"c1","uid":1160079,"ip_address":"","ucode":"0CB8A52B177868","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8f/4caf7f03.jpg","comment_is_top":false,"comment_ctime":1542894003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542894003","product_id":100013101,"comment_content":"接着刚刚的提问不好意思了，那我们能不能统一在一个的地方处理panic呢","like_count":0},{"had_liked":false,"id":31350,"user_name":"ugenehan","can_delete":false,"product_type":"c1","uid":1203116,"ip_address":"","ucode":"64CD44A422B63A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/ac/99f1fa52.jpg","comment_is_top":false,"comment_ctime":1539155999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539155999","product_id":100013101,"comment_content":"defer中引发panic，这样吗？<br>func main() {<br>\tfmt.Println(&quot;Enter func main&quot;)<br>\tdefer func() {<br>\t\tfmt.Println(&quot;Enter defer func&quot;)<br>\t\tpanic(errors.New(&quot;again some errors&quot;))<br>\t\tif p := recover(); p != nil {<br>\t\t\tfmt.Printf(&quot;panic:%s\\n&quot;, p)<br>\t\t}<br>\t\tfmt.Println(&quot;Exit defer&quot;)<br><br>\t}()<br>\tfmt.Println(&quot;Begin panic&quot;)<br>\tpanic(errors.New(&quot;some errors&quot;))<br>\tfmt.Println(&quot;Exit main&quot;)<br>}","like_count":0},{"had_liked":false,"id":29676,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1538481050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538481050","product_id":100013101,"comment_content":"可以在defer中引发panic","like_count":0},{"had_liked":false,"id":29558,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1538439401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538439401","product_id":100013101,"comment_content":"defer语句可以用来进行资源清理<br>但是由于捕获panic的defer调用，可以再次抛出panic<br>因此，当panic捕获和资源清理同时存在时，defer的语句顺序就需要仔细考虑了","like_count":0}]}