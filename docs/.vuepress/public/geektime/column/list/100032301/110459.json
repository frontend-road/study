{"id":110459,"title":"03 | 消息模型：主题和队列有什么区别？","content":"<p>你好，我是李玥。这节课我们来学习消息队列中像队列、主题、分区等基础概念。这些基础的概念，就像我们学习一门编程语言中的基础语法一样，你只有搞清楚它们，才能进行后续的学习。</p><p>如果你研究过超过一种消息队列产品，你可能已经发现，每种消息队列都有自己的一套消息模型，像队列（Queue）、主题（Topic）或是分区（Partition）这些名词概念，在每个消息队列模型中都会涉及一些，含义还不太一样。</p><p>为什么出现这种情况呢？因为没有标准。曾经，也是有一些国际组织尝试制定过消息相关的标准，比如早期的JMS和AMQP。但让人无奈的是，标准的进化跟不上消息队列的演进速度，这些标准实际上已经被废弃了。</p><p>那么，到底什么是队列？什么是主题？主题和队列又有什么区别呢？想要彻底理解这些，我们需要从消息队列的演进说起。</p><h2>主题和队列有什么区别？</h2><p>在互联网的架构师圈儿中间，流传着这样一句不知道出处的名言，我非常认同和喜欢：好的架构不是设计出来的，而是演进出来的。 现代的消息队列呈现出的模式，一样是经过之前的十几年逐步演进而来的。</p><p>最初的消息队列，就是一个严格意义上的队列。在计算机领域，“队列（Queue）”是一种数据结构，有完整而严格的定义。在维基百科中，队列的定义是这样的：</p><!-- [[[read_end]]] --><blockquote>\n<p>队列是先进先出（FIFO, First-In-First-Out）的线性表（Linear List）。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</p>\n</blockquote><p>这个定义里面包含几个关键点，第一个是先进先出，这里面隐含着的一个要求是，在消息入队出队过程中，需要保证这些消息<strong>严格有序</strong>，按照什么顺序写进队列，必须按照同样的顺序从队列中读出来。不过，队列是没有“读”这个操作的，“读”就是出队，也就是从队列中“删除”这条消息。</p><p><strong>早期的消息队列，就是按照“队列”的数据结构来设计的。</strong>我们一起看下这个图，生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。</p><p>这就是最初的一种消息模型：队列模型。</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/84/b18f43f67ae1b0d24d88f0ba39708a84.jpg?wh=4266*856\" alt=\"\"></p><p>如果有多个生产者往同一个队列里面发送消息，这个队列中可以消费到的消息，就是这些生产者生产的所有消息的合集。消息的顺序就是这些生产者发送消息的自然顺序。如果有多个消费者接收同一个队列的消息，这些消费者之间实际上是竞争的关系，每个消费者只能收到队列中的一部分消息，也就是说任何一条消息只能被其中的一个消费者收到。</p><p>如果需要将一份消息数据分发给多个消费者，要求每个消费者都能收到全量的消息，例如，对于一份订单数据，风控系统、分析系统、支付系统等都需要接收消息。这个时候，单个队列就满足不了需求，一个可行的解决方式是，为每个消费者创建一个单独的队列，让生产者发送多份。</p><p>显然这是个比较蠢的做法，同样的一份消息数据被复制到多个队列中会浪费资源，更重要的是，生产者必须知道有多少个消费者。为每个消费者单独发送一份消息，这实际上违背了消息队列“解耦”这个设计初衷。</p><p>为了解决这个问题，演化出了另外一种消息模型：“<strong>发布-订阅模型（Publish-Subscribe Pattern）</strong>”。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/54/d5c0742113b2a6f5a419e1ffc3327354.jpg?wh=4062*1448\" alt=\"\"></p><p>在发布-订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。</p><p>在消息领域的历史上很长的一段时间，队列模式和发布-订阅模式是并存的，有些消息队列同时支持这两种消息模型，比如ActiveMQ。我们仔细对比一下这两种模型，生产者就是发布者，消费者就是订阅者，队列就是主题，并没有本质的区别。<strong>它们最大的区别其实就是，一份消息数据能不能被消费多次的问题。</strong></p><p>实际上，在这种发布-订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。也就是说，发布-订阅模型在功能层面上是可以兼容队列模型的。</p><p>现代的消息队列产品使用的消息模型大多是这种发布-订阅模型，当然也有例外。</p><h2>RabbitMQ的消息模型</h2><p>这个例外就是RabbitMQ，它是少数依然坚持使用队列模型的产品之一。那它是怎么解决多个消费者的问题呢？你还记得我在上节课中讲到RabbitMQ的一个特色Exchange模块吗？在RabbitMQ中，Exchange位于生产者和队列之间，生产者并不关心将消息发送给哪个队列，而是将消息发送给Exchange，由Exchange上配置的策略来决定将消息投递到哪些队列中。</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/a5/2df04ce80ff54702240df8598f277ca5.jpg?wh=4266*1284\" alt=\"\"></p><p>同一份消息如果需要被多个消费者来消费，需要配置Exchange将消息发送到多个队列，每个队列中都存放一份完整的消息数据，可以为一个消费者提供消费服务。这也可以变相地实现新发布-订阅模型中，“一份消息数据可以被多个订阅者来多次消费”这样的功能。具体的配置你可以参考RabbitMQ官方教程，其中一个<a href=\"http://www.rabbitmq.com/tutorials/tutorial-three-python.html\">章节</a>专门是讲如何实现发布订阅的。</p><h2>RocketMQ的消息模型</h2><p>讲完了RabbitMQ的消息模型，我们再来看看RocketMQ。RocketMQ使用的消息模型是标准的发布-订阅模型，在RocketMQ的术语表中，生产者、消费者和主题与我在上面讲的发布-订阅模型中的概念是完全一样的。</p><p>但是，在RocketMQ也有队列（Queue）这个概念，并且队列在RocketMQ中是一个非常重要的概念，那队列在RocketMQ中的作用是什么呢？这就要从消息队列的消费机制说起。</p><p>几乎所有的消息队列产品都使用一种非常朴素的“请求-确认”机制，确保消息不会在传递过程中由于网络或服务器故障丢失。具体的做法也非常简单。在生产端，生产者先将消息发送给服务端，也就是Broker，服务端在收到消息并将消息写入主题或者队列中后，会给生产者发送确认的响应。</p><p>如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息；在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认。</p><p>这个确认机制很好地保证了消息传递过程中的可靠性，但是，引入这个机制在消费端带来了一个不小的问题。什么问题呢？为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则。</p><p>也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，RocketMQ在主题下面增加了队列的概念。</p><p><strong>每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。</strong>需要注意的是，RocketMQ只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。</p><p>RocketMQ中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被Consumer Group1消费过，也会再给Consumer Group2消费。</p><p>消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。如果一条消息被消费者Consumer1消费了，那同组的其他消费者就不会再收到这条消息。</p><p>在Topic的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要RocketMQ为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。这个消费位置是非常重要的概念，我们在使用消息队列的时候，丢消息的原因大多是由于消费位置处理不当导致的。</p><p>RocketMQ的消息模型中，比较关键的概念就是这些了。为了便于你理解，我画了下面这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/46/17/465142ab5b5096f283118c307e8cc117.jpg?wh=4266*1743\" alt=\"\"></p><p>你可以对照这张图再把我刚刚讲的这些概念继续消化一下，加深理解。</p><h2>Kafka的消息模型</h2><p>我们再来看看另一种常见的消息队列Kafka，Kafka的消息模型和RocketMQ是完全一样的，我刚刚讲的所有RocketMQ中对应的概念，和生产消费过程中的确认机制，都完全适用于Kafka。唯一的区别是，在Kafka中，队列这个概念的名称不一样，Kafka中对应的名称是“分区（Partition）”，含义和功能是没有任何区别的。</p><h2>小结</h2><p>我们来总结一下本节课学习的内容。首先我们讲了队列和主题的区别，这两个概念的背后实际上对应着两种不同的消息模型：队列模型和发布-订阅模型。然后你需要理解，这两种消息模型其实并没有本质上的区别，都可以通过一些扩展或者变化来互相替代。</p><p>常用的消息队列中，RabbitMQ采用的是队列模型，但是它一样可以实现发布-订阅的功能。RocketMQ和Kafka采用的是发布-订阅模型，并且二者的消息模型是基本一致的。</p><p>最后提醒你一点，我这节课讲的消息模型和相关的概念是业务层面的模型，深刻理解业务模型有助于你用最佳的姿势去使用消息队列。</p><p>但业务模型不等于就是实现层面的模型。比如说MySQL和Hbase同样是支持SQL的数据库，它们的业务模型中，存放数据的单元都是“表”，但是在实现层面，没有哪个数据库是以二维表的方式去存储数据的，MySQL使用B+树来存储数据，而HBase使用的是KV的结构来存储。同样，像Kafka和RocketMQ的业务模型基本是一样的，并不是说他们的实现就是一样的，实际上这两个消息队列的实现是完全不同的。</p><h2>思考题</h2><p>最后给大家留一个思考题。刚刚我在介绍RocketMQ的消息模型时讲过，在消费的时候，为了保证消息的不丢失和严格顺序，每个队列只能串行消费，无法做到并发，否则会出现消费空洞的问题。那如果放宽一下限制，不要求严格顺序，能否做到单个队列的并行消费呢？如果可以，该如何实现？欢迎在留言区与我分享讨论。</p><p>感谢阅读，如果你觉得这篇文章对你有一些启发，也欢迎把它分享给你的朋友。</p><p></p>","neighbors":{"left":{"article_title":"02 | 该如何选择消息队列？","id":109750},"right":{"article_title":"04 | 如何利用事务消息实现分布式事务？","id":111269}},"comments":[{"had_liked":false,"id":118003,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":true,"comment_ctime":1564209816,"is_pvip":false,"replies":[{"id":43256,"content":"A1： 不是，消费者组和队列数没有关系，你这个例子中消费者组的数量是2个。队列数量可以根据数据量和消费速度来合理配置。RocketMQ和Kafka都可以支持水平扩容队列数量，但是都需要手动操作。\n\nA2：producer会往所有队列发消息，但不是“同一条消息每个队列都发一次”，每条消息只会往某个队列里面发送一次。\n\n对于一个消费组，每个队列上只能串行消费，多个队列加一起就是并行消费了，并行度就是队列数量，队列数量越多并行度越大，所以水平扩展可以提升消费性能。\n\nA3：每队列每消费组维护一个消费位置（offset），记录这个消费组在这个队列上消费到哪儿了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564235052,"ip_address":"","comment_id":118003,"utype":1}],"discussion_count":31,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师， 初学者有一些疑问的地方 ，希望老师可以帮忙解答  😁\n\nRocket mq的模型图有些没有看懂 ， 模拟下场景；比如生产者是商品中心发送商品状态的更新（主题）消息（比如下架），那商品中心有多台机器就对应多个producer 。消费者组有两个，分别是导购中心 和 活动中心。\n\n疑问一 ：图中主题的队列是有多少个消费者组就有多少个队列么，是根据我们配置的消费者组数，mq自动增加主题队列个数么\n\n疑问二 ：看到图中每个producer的消息都往所有的队列中添加一条消息，每个消费者组消费自己的队列，但没有看懂这个队列是如何支持 “当水平扩展消费者机器” 可以加快消息的处理 。 每个消费组应该都是按照队列等前一条处理完了，才能去处理下一条（ps：这样来看 ，rb mq也是这个样子，如何通过水平扩展机器来加快消息的处理）\n\n疑问三 ： 图中队列的消费位置有点没看懂，我看是全剧唯一的，这是为什么，每个队列不能都是从0到1么","like_count":134,"discussions":[{"author":{"id":1111400,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","nickname":"王飞2023","note":"","ucode":"C0F3139B836F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3248,"discussion_content":"哥们，你好，我对这个理解不一定正确，我说下我的看法。\n\n一个topic下有多个queue，这个目的是为了负载均衡。比如说，我有一个topicA，然后有queue1-8，你可以理解为把一个topic的消息承载体分为了8段。这个时候，你的消费者，部署了2个实例在2个主机。这个时候，你的消费者在主机a订阅的是这个topic下的queue的queue1,q2,q3,q4，主机b订阅的是这个topic下的queue5,q6,q7,q8。这里的消费者相当于一个组，部署了2台主机。至于说你有多个消费组。他们各是各。    当生产者发送消息的时候，会落在8个queue中的某一个上。  消费位置是另外一个组建，来一个新的消费者组，就在内存和文件中记录他消费到哪里。     如果再来新的，就再新纪录。","likes_number":22,"is_delete":false,"is_hidden":false,"ctime":1564331392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":9,"child_discussions":[{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111400,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","nickname":"王飞2023","note":"","ucode":"C0F3139B836F39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3359,"discussion_content":"多谢 看了老师和你的回复，发现自己之前都理解错了， 多谢指正🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564439445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3248,"ip_address":"","group_id":0},"score":3359,"extra":""},{"author":{"id":1624006,"avatar":"","nickname":"Mr. Z","note":"","ucode":"87E2279F4CD617","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111400,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","nickname":"王飞2023","note":"","ucode":"C0F3139B836F39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4313,"discussion_content":"赞同，所以多个queue只有在同一组里有多个消费者竞争消费时才能发挥作用，如果订阅该主题的消费组里都只有一个消费者，那么单个队列就够了，不知道我这么理解对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565313726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3248,"ip_address":"","group_id":0},"score":4313,"extra":""},{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111400,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","nickname":"王飞2023","note":"","ucode":"C0F3139B836F39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23022,"discussion_content":"可以 解释的 很好~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569741755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3248,"ip_address":"","group_id":0},"score":23022,"extra":""}]},{"author":{"id":1181844,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","nickname":"克里斯","note":"","ucode":"00B755C10AC1C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407253,"discussion_content":"1.一个生产组生产同一个topic类型的消息\n2.一个消费组消费同一个topic类型的消息\n3.一个topic有全量的消息\n4.topic有多个队列,所有队列的消息之和=topic消息\n5.多个队列是为了同一个消费组的多个消费者能并行消费\n6.如果消息需要串行顺序,那只能把消息发送到同一个队列中,此情况不能并行消费","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1634957501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1204496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/61/10/38f22d72.jpg","nickname":"。","note":"","ucode":"B45232071FECB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181844,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","nickname":"克里斯","note":"","ucode":"00B755C10AC1C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589746,"discussion_content":"看完文章和楼上解答，再来看你这个总结，懂了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1665298072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":407253,"ip_address":"北京","group_id":0},"score":589746,"extra":""},{"author":{"id":2682971,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f0/5b/791d0f5e.jpg","nickname":"云从","note":"","ucode":"96442F21D37C0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181844,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","nickname":"克里斯","note":"","ucode":"00B755C10AC1C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607052,"discussion_content":"简单明了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677575575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":407253,"ip_address":"四川","group_id":0},"score":607052,"extra":""},{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181844,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","nickname":"克里斯","note":"","ucode":"00B755C10AC1C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610820,"discussion_content":"最好的评论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679772564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":407253,"ip_address":"英国","group_id":0},"score":610820,"extra":""}]},{"author":{"id":2103021,"avatar":"https://static001.geekbang.org/account/avatar/00/20/16/ed/2db68084.jpg","nickname":"刘瓜瓜","note":"","ucode":"0380FA51CB9950","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363326,"discussion_content":"这里的队列其实就是partion(分区)，一个Topic是包括多个partion的，一个消息只会写入Topic一次，至于进入那个队列（partion），就要看你当时使用的是什么算法了，一般来说都是轮训","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1617168886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180416,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/00/7417d487.jpg","nickname":"🍀","note":"","ucode":"1F47017148E442","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100720,"discussion_content":"所有消费组都在某一条消息设置过offerset后，这条消息才可以被删除吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577276596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180416,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/00/7417d487.jpg","nickname":"🍀","note":"","ucode":"1F47017148E442","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181265,"discussion_content":"一般这类删除是设置保存时间的或者容量的，无法保证消息未被消费一定会被持久化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582352213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100720,"ip_address":"","group_id":0},"score":181265,"extra":""},{"author":{"id":1261493,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/b5/5fe77e16.jpg","nickname":"不经意间","note":"","ucode":"C39D98697ACB8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180416,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/00/7417d487.jpg","nickname":"🍀","note":"","ucode":"1F47017148E442","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198175,"discussion_content":"要实现多次“订阅”，消费者（组）每次消费完一条消息并更新offset后数据是不会被删除的，以支持不同消费者（组）的多从订阅和消费。但是“发布”的数据存储到broker这个实体中，数据是会落盘的，此时就要考虑历史数据的保留时间。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583484527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100720,"ip_address":"","group_id":0},"score":198175,"extra":""}]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460218,"discussion_content":"A1： 不是，消费者组和队列数没有关系，你这个例子中消费者组的数量是2个。队列数量可以根据数据量和消费速度来合理配置。RocketMQ和Kafka都可以支持水平扩容队列数量，但是都需要手动操作。\n\nA2：producer会往所有队列发消息，但不是“同一条消息每个队列都发一次”，每条消息只会往某个队列里面发送一次。\n\n对于一个消费组，每个队列上只能串行消费，多个队列加一起就是并行消费了，并行度就是队列数量，队列数量越多并行度越大，所以水平扩展可以提升消费性能。\n\nA3：每队列每消费组维护一个消费位置（offset），记录这个消费组在这个队列上消费到哪儿了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564235052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1190935,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2c/17/4d548334.jpg","nickname":"Dream Chaser","note":"","ucode":"204F0906E47C1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":572530,"discussion_content":"文章看第一遍的时候有一些地方不是很懂，看了第二遍很多地方也明白了，再加上老师的回答，真的解开了心中的很多疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652839483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":460218,"ip_address":"","group_id":0},"score":572530,"extra":""}]},{"author":{"id":1106238,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e1/3e/a617ae38.jpg","nickname":"每天一点点","note":"","ucode":"B4DFDA3200B452","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261183,"discussion_content":"A2同一条消息只能往一个队列发送一次，对于一个消费组来说其中只能消费一次。\n那为什么会出现消息重复的问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588945166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1638541,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/8d/45c1f62f.jpg","nickname":"🇵  🇦  🇼  🇳 ","note":"","ucode":"1F825BACA9FD99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1106238,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e1/3e/a617ae38.jpg","nickname":"每天一点点","note":"","ucode":"B4DFDA3200B452","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387094,"discussion_content":"消费者消费成功之后，由于网络或宕机等原因没有回复MQ ACK确认消息，后面MQ还会重复发送这个消息给消费者","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1627980569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261183,"ip_address":"","group_id":0},"score":387094,"extra":""}]},{"author":{"id":1117468,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0d/1c/ce44486a.jpg","nickname":"richard","note":"","ucode":"E8A981EFF9F06A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3198,"discussion_content":"A2 这种情况，是不是消费者消费的顺序就没办法保证了，由于消费组并行消费不同的队列，而不同队列里面的消息互相之间是没有顺序的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564296260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1117468,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0d/1c/ce44486a.jpg","nickname":"richard","note":"","ucode":"E8A981EFF9F06A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3360,"discussion_content":"所以我猜测，如果需要保证顺序的消息，应该支持配置该类型消息可以发送在指定的一个队列上面 。看看老师后面会不会提到","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564439556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3198,"ip_address":"","group_id":0},"score":3360,"extra":""},{"author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155449,"discussion_content":"是的 可以通过使用顺序主题（消息中间件支持下）或者通过生产端进行的一个小操作来保证消息统一路由到一个队列或分区上即可保证消费端的顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580228334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3360,"ip_address":"","group_id":0},"score":155449,"extra":""},{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1117468,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0d/1c/ce44486a.jpg","nickname":"richard","note":"","ucode":"E8A981EFF9F06A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181264,"discussion_content":"比如 kafka 只能保证分区有序，我们可以将我们希望有序的设置相同的 Key，这样 kafka 会根据指定 key 进行 hash，从而保证有序","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582352160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3198,"ip_address":"","group_id":0},"score":181264,"extra":""}]}]},{"had_liked":false,"id":118905,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1564464047,"is_pvip":false,"replies":[{"id":43699,"content":"总结的非常到位！\n课后作业也完成的非常好！\n小红花走起！\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564536759,"ip_address":"","comment_id":118905,"utype":1}],"discussion_count":11,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"RocketMQ业务模型的理解，老师有空帮忙看下哦\n1、主题（topic）中有多个队列（队列数量可以水平进行扩容），生产者将其消息发送给主题中的某个队列（根据一定的路由规则，比如取模之类的），主题不保证消息的有序，只有队列中的消息才是有序的。\n2、从主题中的所有队列中取出消息给所有消费组进行消费，消息只能被消费组中的一个线程进行消费，有点类似线程池的形式，工作线程消费来自不同队列的消息，感觉这也是RocketMq,低时延的原因，不同队列中的消息可以同时被消费，并且消费组的线程也可以并发的消费不同的消息。\n3、由于主题中的一个队列都会被多个消费组进行消费，为此需要为每个消费组的消费的不同队列为此一个下标(每个消费组可以一直消费队列中的消息，无需等待其他消费组的确认)，主题中的队列消息是有序的，为此需要等到所有消费组对此条消息进行确认，才能从队列中移除，感觉每个消费组的队列下标，可以一个队列维护一个CurrentHashMap来为此每个消费组的下标，这样的话可以防止锁的竞争。\n课后习题：尝试回答下课后习题，感觉队列可以维护一个全局的下标，消费队列时，使用CAS进行下标的获取，由于不保证消息消费的有序，这样的话可以并发的消费消息，由于有全局下标，不会出现获取队列的空洞消息。","like_count":138,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460654,"discussion_content":"总结的非常到位！\n课后作业也完成的非常好！\n小红花走起！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564536759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596047,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","nickname":"Geek_8c5f9c","note":"","ucode":"70CD441EAF490F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205108,"discussion_content":"这个全局的下标如何实现并发消费呢？假设下标是在消费者成功消费时才被更新，在其他消费者都会拿到同一个下标，消费同一个消息，这显然不对。如果在分发给消费者时就更新，还是会有空洞消息的问题。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1584266918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253597,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/dd/82d8eff2.jpg","nickname":"Mine","note":"","ucode":"85C3A3117FD9CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241402,"discussion_content":"关于最后一点还是不太明白:-(","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587404210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","nickname":"yang","note":"","ucode":"1AA1497C5A293C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15338,"discussion_content":"问一下哈 那要是机器挂了 这个全局下标是不是 就丢了啊？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568816158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1074310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","nickname":"yang","note":"","ucode":"1AA1497C5A293C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155454,"discussion_content":"这个下标我们先管它叫做消费位点 服务器端可以在该消费组中对每个队列实时维护消费位点 并且持久化到磁盘来应对机器宕机后重启的恢复 同时针对磁盘故障也需要提供该消费位点的副本机制来保证","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580228726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":15338,"ip_address":"","group_id":0},"score":155454,"extra":""}]},{"author":{"id":1000475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/1b/fa287ed5.jpg","nickname":"半桶水","note":"","ucode":"AFC053EB627E48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295354,"discussion_content":"通过全局下标，那么是不是又引入了其他问题，还需要不断的询问全局下标","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596173773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1491023,"avatar":"https://static001.geekbang.org/account/avatar/00/16/c0/4f/db7f2ab2.jpg","nickname":"七楼","note":"","ucode":"106856DF5F8F12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102646,"discussion_content":"cas那么是不是要保证消息的全局可见  还有回滚呢  例如 你消费了  但是还有确定机制。你确定的时候其他线程有人消费了  这样也失去了消息队列的意义了  服务器压力大  且在一定情况处理能力极地","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577358430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2851542,"avatar":"","nickname":"我要写代码！","note":"","ucode":"0859B8BFA7834A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564216,"discussion_content":"如何做到所有消费组都对此条消息确认呢，不是只要消费成功一次消费位置就加一了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650191900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437232,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/30/57cac07c.jpg","nickname":"明星shine","note":"","ucode":"AD28165915D583","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334931,"discussion_content":"每个消费组可以一直消费队列中的消息，无需等待其他消费组的确认\n主题中的队列消息是有序的，为此需要等到所有消费组对此条消息进行确认，才能从队列中移除，\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608030969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2296382,"avatar":"https://static001.geekbang.org/account/avatar/00/23/0a/3e/5b1b1b75.jpg","nickname":"流年","note":"","ucode":"8B579C6E466CB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334493,"discussion_content":"单队列并发可以记录每个消费者拉取的位置，比如消费者A拉取10条，记录下拉取的位置，另外一个消费者B拉取时要从11开始拉取10条进行消费。类似于轮询的拉取消息进行消费，然后各自消费完提交偏移量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607866346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80017,"discussion_content":"又是来指导学习的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576138003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118325,"user_name":"Geek_de6f9a","can_delete":false,"product_type":"c1","uid":1444577,"ip_address":"","ucode":"C047D42CFC882A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/V71wNP3XFiaPZuzwVI4AEhCPic5H6YscjWQeUXTfnGY5DEdGxWFf2dticNDyUpxiaQYGH0xboUNB0AicroLbak07xVA/132","comment_is_top":false,"comment_ctime":1564322236,"is_pvip":false,"replies":[{"id":43401,"content":"A1：按照订单ID或者用户ID，用一致性哈希算法，计算出队列ID，指定队列ID发送，这样可以保证相同的订单&#47;用户的消息总被发送到同一个队列上，就可以确保严格顺序了。\n\nA2：会有一个超时，超时之前会阻塞，超时之后就解除锁定，允许其他消费者来拉消息，由于消费位置没变，下次再有消费者来这个队列拉消息，返回的还是上一条消息。\n\nA3：这个问题我在后面的课中会专门来讲。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564366363,"ip_address":"","comment_id":118325,"utype":1}],"discussion_count":15,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师你好，想请问一下消费的顺序问题。\n对于有的消息，需要保证顺序性，比如交易状态和im消息。像im消息还要保证唯一性。\n\nQ1: rocketmq，一个消费组在一个主题下的多个队列并发消费就无法保证消息的顺序性。这种该如何处理?\n\nQ2: 客户端和mq要保持一种重试的机制，如果在网络延迟出现问题的时候，前面的消息一直未收到ack响应，若不做任何处理，后面的就会阻塞，还是重试之后放弃，若是不能发生丢失的信息该如何处理。\n\nQ3: 如何保证消息的唯一性，在重试的过程中，第一条消息已经发送，未收到ack，则进行第二次重试。此时网络故障恢复，则客户端会收到两条消息，客户端如何保证消息的唯一性。","like_count":79},{"had_liked":false,"id":117977,"user_name":"a、","can_delete":false,"product_type":"c1","uid":1532404,"ip_address":"","ucode":"590FE8DB111492","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","comment_is_top":false,"comment_ctime":1564202194,"is_pvip":false,"replies":[{"id":43183,"content":"现代的消息队列大多就是这么实现的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564205540,"ip_address":"","comment_id":117977,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"今天的思考题，我觉得应该是，把消息队列的先进先出，改成数组的随机访问，用offset来控制消息组具体要消费哪条消息，mq不主动删除消息，消息有过期时间，如果到了过期时间，只能确认不能重新该消费，只保留最大可设置天数的消息。超过该天数则删除，还要维护客户端确认信息，如果有客户端没确认，需要有重发机制。不知道这个想法对不对？","like_count":62,"discussions":[{"author":{"id":1111400,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","nickname":"王飞2023","note":"","ucode":"C0F3139B836F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3248,"discussion_content":"哥们，你好，我对这个理解不一定正确，我说下我的看法。\n\n一个topic下有多个queue，这个目的是为了负载均衡。比如说，我有一个topicA，然后有queue1-8，你可以理解为把一个topic的消息承载体分为了8段。这个时候，你的消费者，部署了2个实例在2个主机。这个时候，你的消费者在主机a订阅的是这个topic下的queue的queue1,q2,q3,q4，主机b订阅的是这个topic下的queue5,q6,q7,q8。这里的消费者相当于一个组，部署了2台主机。至于说你有多个消费组。他们各是各。    当生产者发送消息的时候，会落在8个queue中的某一个上。  消费位置是另外一个组建，来一个新的消费者组，就在内存和文件中记录他消费到哪里。     如果再来新的，就再新纪录。","likes_number":22,"is_delete":false,"is_hidden":false,"ctime":1564331392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":9,"child_discussions":[{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111400,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","nickname":"王飞2023","note":"","ucode":"C0F3139B836F39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3359,"discussion_content":"多谢 看了老师和你的回复，发现自己之前都理解错了， 多谢指正🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564439445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3248,"ip_address":"","group_id":0},"score":3359,"extra":""},{"author":{"id":1624006,"avatar":"","nickname":"Mr. Z","note":"","ucode":"87E2279F4CD617","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111400,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","nickname":"王飞2023","note":"","ucode":"C0F3139B836F39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4313,"discussion_content":"赞同，所以多个queue只有在同一组里有多个消费者竞争消费时才能发挥作用，如果订阅该主题的消费组里都只有一个消费者，那么单个队列就够了，不知道我这么理解对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565313726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3248,"ip_address":"","group_id":0},"score":4313,"extra":""},{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111400,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","nickname":"王飞2023","note":"","ucode":"C0F3139B836F39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23022,"discussion_content":"可以 解释的 很好~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569741755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3248,"ip_address":"","group_id":0},"score":23022,"extra":""}]},{"author":{"id":1181844,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","nickname":"克里斯","note":"","ucode":"00B755C10AC1C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407253,"discussion_content":"1.一个生产组生产同一个topic类型的消息\n2.一个消费组消费同一个topic类型的消息\n3.一个topic有全量的消息\n4.topic有多个队列,所有队列的消息之和=topic消息\n5.多个队列是为了同一个消费组的多个消费者能并行消费\n6.如果消息需要串行顺序,那只能把消息发送到同一个队列中,此情况不能并行消费","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1634957501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1204496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/61/10/38f22d72.jpg","nickname":"。","note":"","ucode":"B45232071FECB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181844,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","nickname":"克里斯","note":"","ucode":"00B755C10AC1C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589746,"discussion_content":"看完文章和楼上解答，再来看你这个总结，懂了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1665298072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":407253,"ip_address":"北京","group_id":0},"score":589746,"extra":""},{"author":{"id":2682971,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f0/5b/791d0f5e.jpg","nickname":"云从","note":"","ucode":"96442F21D37C0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181844,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","nickname":"克里斯","note":"","ucode":"00B755C10AC1C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607052,"discussion_content":"简单明了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677575575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":407253,"ip_address":"四川","group_id":0},"score":607052,"extra":""},{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181844,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","nickname":"克里斯","note":"","ucode":"00B755C10AC1C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610820,"discussion_content":"最好的评论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679772564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":407253,"ip_address":"英国","group_id":0},"score":610820,"extra":""}]},{"author":{"id":2103021,"avatar":"https://static001.geekbang.org/account/avatar/00/20/16/ed/2db68084.jpg","nickname":"刘瓜瓜","note":"","ucode":"0380FA51CB9950","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363326,"discussion_content":"这里的队列其实就是partion(分区)，一个Topic是包括多个partion的，一个消息只会写入Topic一次，至于进入那个队列（partion），就要看你当时使用的是什么算法了，一般来说都是轮训","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1617168886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180416,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/00/7417d487.jpg","nickname":"🍀","note":"","ucode":"1F47017148E442","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100720,"discussion_content":"所有消费组都在某一条消息设置过offerset后，这条消息才可以被删除吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577276596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180416,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/00/7417d487.jpg","nickname":"🍀","note":"","ucode":"1F47017148E442","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181265,"discussion_content":"一般这类删除是设置保存时间的或者容量的，无法保证消息未被消费一定会被持久化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582352213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100720,"ip_address":"","group_id":0},"score":181265,"extra":""},{"author":{"id":1261493,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/b5/5fe77e16.jpg","nickname":"不经意间","note":"","ucode":"C39D98697ACB8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180416,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/00/7417d487.jpg","nickname":"🍀","note":"","ucode":"1F47017148E442","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198175,"discussion_content":"要实现多次“订阅”，消费者（组）每次消费完一条消息并更新offset后数据是不会被删除的，以支持不同消费者（组）的多从订阅和消费。但是“发布”的数据存储到broker这个实体中，数据是会落盘的，此时就要考虑历史数据的保留时间。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583484527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100720,"ip_address":"","group_id":0},"score":198175,"extra":""}]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460218,"discussion_content":"A1： 不是，消费者组和队列数没有关系，你这个例子中消费者组的数量是2个。队列数量可以根据数据量和消费速度来合理配置。RocketMQ和Kafka都可以支持水平扩容队列数量，但是都需要手动操作。\n\nA2：producer会往所有队列发消息，但不是“同一条消息每个队列都发一次”，每条消息只会往某个队列里面发送一次。\n\n对于一个消费组，每个队列上只能串行消费，多个队列加一起就是并行消费了，并行度就是队列数量，队列数量越多并行度越大，所以水平扩展可以提升消费性能。\n\nA3：每队列每消费组维护一个消费位置（offset），记录这个消费组在这个队列上消费到哪儿了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564235052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1190935,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2c/17/4d548334.jpg","nickname":"Dream Chaser","note":"","ucode":"204F0906E47C1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":572530,"discussion_content":"文章看第一遍的时候有一些地方不是很懂，看了第二遍很多地方也明白了，再加上老师的回答，真的解开了心中的很多疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652839483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":460218,"ip_address":"","group_id":0},"score":572530,"extra":""}]},{"author":{"id":1106238,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e1/3e/a617ae38.jpg","nickname":"每天一点点","note":"","ucode":"B4DFDA3200B452","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261183,"discussion_content":"A2同一条消息只能往一个队列发送一次，对于一个消费组来说其中只能消费一次。\n那为什么会出现消息重复的问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588945166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1638541,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/8d/45c1f62f.jpg","nickname":"🇵  🇦  🇼  🇳 ","note":"","ucode":"1F825BACA9FD99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1106238,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e1/3e/a617ae38.jpg","nickname":"每天一点点","note":"","ucode":"B4DFDA3200B452","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387094,"discussion_content":"消费者消费成功之后，由于网络或宕机等原因没有回复MQ ACK确认消息，后面MQ还会重复发送这个消息给消费者","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1627980569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261183,"ip_address":"","group_id":0},"score":387094,"extra":""}]},{"author":{"id":1117468,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0d/1c/ce44486a.jpg","nickname":"richard","note":"","ucode":"E8A981EFF9F06A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3198,"discussion_content":"A2 这种情况，是不是消费者消费的顺序就没办法保证了，由于消费组并行消费不同的队列，而不同队列里面的消息互相之间是没有顺序的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564296260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1117468,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0d/1c/ce44486a.jpg","nickname":"richard","note":"","ucode":"E8A981EFF9F06A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3360,"discussion_content":"所以我猜测，如果需要保证顺序的消息，应该支持配置该类型消息可以发送在指定的一个队列上面 。看看老师后面会不会提到","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564439556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3198,"ip_address":"","group_id":0},"score":3360,"extra":""},{"author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155449,"discussion_content":"是的 可以通过使用顺序主题（消息中间件支持下）或者通过生产端进行的一个小操作来保证消息统一路由到一个队列或分区上即可保证消费端的顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580228334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3360,"ip_address":"","group_id":0},"score":155449,"extra":""},{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1117468,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0d/1c/ce44486a.jpg","nickname":"richard","note":"","ucode":"E8A981EFF9F06A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181264,"discussion_content":"比如 kafka 只能保证分区有序，我们可以将我们希望有序的设置相同的 Key，这样 kafka 会根据指定 key 进行 hash，从而保证有序","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582352160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3198,"ip_address":"","group_id":0},"score":181264,"extra":""}]}]},{"had_liked":false,"id":118971,"user_name":"陈泽坛","can_delete":false,"product_type":"c1","uid":1394861,"ip_address":"","ucode":"C81B402868E9E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/ad/8be724da.jpg","comment_is_top":false,"comment_ctime":1564476701,"is_pvip":false,"replies":[{"id":43727,"content":"非常正确！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564539799,"ip_address":"","comment_id":118971,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"可以这样理解吗？请老师解答：\n主要是rocketmq的部分。\n生产者允许多生产者同时生产消息，每条消息只会被主题中的某条队列接收，消费组内的消费者竞相消费所有队列，消费者会根据消费组在队列上的数来记录已消费位置，做到的就是队列上的有序，但是有可能整个topic下，是无序的。有可能图中的4要先被消费，但是另一队列中的3还没被消费。\n所以如果需要有序，就需要发送到同一条队列中去了。","like_count":49,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460694,"discussion_content":"非常正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564539799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1195017,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","nickname":"谁都会变","note":"","ucode":"9965748F7EBB57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587853,"discussion_content":"厉害了，大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663321047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1619882,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b7/aa/6427f4d8.jpg","nickname":"wlarein","note":"","ucode":"81A6B217700403","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22884,"discussion_content":"清晰明了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569723108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117956,"user_name":"flyamonkey","can_delete":false,"product_type":"c1","uid":1045689,"ip_address":"","ucode":"F63B794FC654E4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/b9/c6e91344.jpg","comment_is_top":false,"comment_ctime":1564198741,"is_pvip":false,"replies":[{"id":43187,"content":"没错！具体可以看一下RocketMQ的并行消费的实现。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564206419,"ip_address":"","comment_id":117956,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"不要求严格顺序的话，应该是可以做到单个队列并行的，但这种情况下消息的消费可能就是个出队操作，而非等待消费端的ack后再出队了，这样势必会造成消息的丢失，所以需要有一定的补偿机制，如消息的重传和持久化等。个人见解，不知道是不是准确，还请老师指点~","like_count":36,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460654,"discussion_content":"总结的非常到位！\n课后作业也完成的非常好！\n小红花走起！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564536759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596047,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","nickname":"Geek_8c5f9c","note":"","ucode":"70CD441EAF490F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205108,"discussion_content":"这个全局的下标如何实现并发消费呢？假设下标是在消费者成功消费时才被更新，在其他消费者都会拿到同一个下标，消费同一个消息，这显然不对。如果在分发给消费者时就更新，还是会有空洞消息的问题。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1584266918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253597,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/dd/82d8eff2.jpg","nickname":"Mine","note":"","ucode":"85C3A3117FD9CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241402,"discussion_content":"关于最后一点还是不太明白:-(","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587404210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","nickname":"yang","note":"","ucode":"1AA1497C5A293C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15338,"discussion_content":"问一下哈 那要是机器挂了 这个全局下标是不是 就丢了啊？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568816158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1074310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","nickname":"yang","note":"","ucode":"1AA1497C5A293C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155454,"discussion_content":"这个下标我们先管它叫做消费位点 服务器端可以在该消费组中对每个队列实时维护消费位点 并且持久化到磁盘来应对机器宕机后重启的恢复 同时针对磁盘故障也需要提供该消费位点的副本机制来保证","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580228726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":15338,"ip_address":"","group_id":0},"score":155454,"extra":""}]},{"author":{"id":1000475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/1b/fa287ed5.jpg","nickname":"半桶水","note":"","ucode":"AFC053EB627E48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295354,"discussion_content":"通过全局下标，那么是不是又引入了其他问题，还需要不断的询问全局下标","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596173773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1491023,"avatar":"https://static001.geekbang.org/account/avatar/00/16/c0/4f/db7f2ab2.jpg","nickname":"七楼","note":"","ucode":"106856DF5F8F12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102646,"discussion_content":"cas那么是不是要保证消息的全局可见  还有回滚呢  例如 你消费了  但是还有确定机制。你确定的时候其他线程有人消费了  这样也失去了消息队列的意义了  服务器压力大  且在一定情况处理能力极地","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577358430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2851542,"avatar":"","nickname":"我要写代码！","note":"","ucode":"0859B8BFA7834A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564216,"discussion_content":"如何做到所有消费组都对此条消息确认呢，不是只要消费成功一次消费位置就加一了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650191900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437232,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/30/57cac07c.jpg","nickname":"明星shine","note":"","ucode":"AD28165915D583","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334931,"discussion_content":"每个消费组可以一直消费队列中的消息，无需等待其他消费组的确认\n主题中的队列消息是有序的，为此需要等到所有消费组对此条消息进行确认，才能从队列中移除，\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608030969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2296382,"avatar":"https://static001.geekbang.org/account/avatar/00/23/0a/3e/5b1b1b75.jpg","nickname":"流年","note":"","ucode":"8B579C6E466CB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334493,"discussion_content":"单队列并发可以记录每个消费者拉取的位置，比如消费者A拉取10条，记录下拉取的位置，另外一个消费者B拉取时要从11开始拉取10条进行消费。类似于轮询的拉取消息进行消费，然后各自消费完提交偏移量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607866346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80017,"discussion_content":"又是来指导学习的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576138003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119387,"user_name":"君莫笑","can_delete":false,"product_type":"c1","uid":1252556,"ip_address":"","ucode":"28D804A09E4C64","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/cc/a475e9b0.jpg","comment_is_top":false,"comment_ctime":1564575989,"is_pvip":false,"replies":[{"id":43843,"content":"A1：可以。\nA2：有消费策略的，当然随机也是一种消费策略。\nA3：不是。首先，不同的消费组，消费位置是完全独立的，互不干扰。同一个消费组内：消息队列为每个队列维护一个消费位置（而不是给消费者实例）。因为，我们关心的是整个消费组能消费到全部队列的消息就可以了，不关系组内每个消费者消费多少消息，同一条消息，给A消费消费，还是给B消费者消费，是无所谓的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564627001,"ip_address":"","comment_id":119387,"utype":1}],"discussion_count":9,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，我有几个问题，就是rocket MQ模型图上，1、某一个消费组中的各个消费者可以消费某一个主题中的多个队列吗;2、如果可以，消费者拉取消息的时候是完全随机消费某一个队列还是可以指定策略呢？3、如果可以，那是不是主题下的每个队列都要对应给每一个消费者（注意不是消费组）维护一个offset来记录当前消费者消费位置呢？（或者是每个消费者对应每个队列维护呢），求解答","like_count":23,"discussions":[{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3468,"discussion_content":"A2：针对老师的回答我想再补充些问题：这个超时时间不能太长吧，不然严重影响性能？解除锁定后，比如当前在第二条消息被阻塞了，返回上一条消息意思是一直返回第一条消息，那怎么感觉一直卡在这里了，不会触发消费第三条消息？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564502171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155458,"discussion_content":"返回上一条消息意思是返回ack确认超时的那条消息 因为之前说了单独队列上消息是严格的顺序一致的 所以没有ack的消息会阻塞队列后面的消息消费 直到这条消息真正的被消费后并ack确认才会进行后面的消息消费开始","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580229133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3468,"ip_address":"","group_id":0},"score":155458,"extra":""},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581719,"discussion_content":"所以，还是存在队头阻塞的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658936362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":155458,"ip_address":"","group_id":0},"score":581719,"extra":""}]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460358,"discussion_content":"A1：按照订单ID或者用户ID，用一致性哈希算法，计算出队列ID，指定队列ID发送，这样可以保证相同的订单/用户的消息总被发送到同一个队列上，就可以确保严格顺序了。\n\nA2：会有一个超时，超时之前会阻塞，超时之后就解除锁定，允许其他消费者来拉消息，由于消费位置没变，下次再有消费者来这个队列拉消息，返回的还是上一条消息。\n\nA3：这个问题我在后面的课中会专门来讲。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564366363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2019657,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d1/49/791d0f5e.jpg","nickname":"aake","note":"","ucode":"FEFBF59EF09BFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":591190,"discussion_content":"保证顺序的话，那只有一个消费者能消费吗？有没有并行消费的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666348379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":460358,"ip_address":"浙江","group_id":0},"score":591190,"extra":""}]},{"author":{"id":1111175,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/87/644c0c5d.jpg","nickname":"俊伟","note":"","ucode":"7905B4F25637F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411900,"discussion_content":"消费的逻辑保持幂等应该可以解决重复消费的问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636029437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1573424,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/YDH3ehzpSkBEkl7DavPNrcOzF09icrdTQwUIial966H1LplKiacWtoRicicPfUdCn833ZKiaibCKzrbK7W1BTGmsraFtg/132","nickname":"rookie","note":"","ucode":"9E28FA97C01F24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45198,"discussion_content":"A3:每个消息都有一个唯一id，客户端只需要判断这个id有没有重复就可以","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573012101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1573424,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/YDH3ehzpSkBEkl7DavPNrcOzF09icrdTQwUIial966H1LplKiacWtoRicicPfUdCn833ZKiaibCKzrbK7W1BTGmsraFtg/132","nickname":"rookie","note":"","ucode":"9E28FA97C01F24","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576586,"discussion_content":"消息重试的时候 RocketMQ 的 msgid 应该是新的吧 但是它有一个原始msgId 可以追溯到最初的 msgId","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655687723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45198,"ip_address":"","group_id":0},"score":576586,"extra":""},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581718,"discussion_content":"如果是重试，为什么要用新的消息ID呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658936311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":576586,"ip_address":"","group_id":0},"score":581718,"extra":""}]},{"author":{"id":1588679,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/c7/47f89975.jpg","nickname":"Lotus","note":"","ucode":"FDE1A67C0E6636","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608681,"discussion_content":"对于 Q2 的问题，如果在不需要严格保证消息顺序的情况下，rocketmq 提供了一种死信队列的方案，消费者实例在消费失败并且达到了最大重试次数以后，可以将该消息发送到死信队列，然后继续对死信队列中的消息进行处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678608470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2058455,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/68/d7/29025f1f.jpg","nickname":"前方的灯有点弱","note":"","ucode":"5CEDBCF3DDC991","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304237,"discussion_content":"消息的唯一性kafka可以通过事物或者分布式锁去处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599526766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9933,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568248207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1620997,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/e8OMeib8WILyHEVpNvaETb13Z9wNXmybah7fLrSBDHhu2GQvTf5SsibzFTSNXgibaH7jMibS178y3Ys9ptZ3iaGN4Lw/132","nickname":"zdf---my","note":"","ucode":"BEF943C4804AE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3843,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564859211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3792,"discussion_content":"老师，能帮忙解答下嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564813295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307012,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f1/84/7d21bd9e.jpg","nickname":"Goal","note":"","ucode":"C337CD4C7E07B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3447,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564482866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118726,"user_name":"渔夫","can_delete":false,"product_type":"c1","uid":1019289,"ip_address":"","ucode":"6BF08FD8923E45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/99/f886543d.jpg","comment_is_top":false,"comment_ctime":1564442546,"is_pvip":false,"replies":[{"id":43543,"content":"A1：这个我没有测试过，你可以自己测试一下。\n\nA2：有意义，比如我们通过一个主题来传输一个多库MySQL实例的binlog，这个是必须严格有序的。但是，不用真的全局有序，只要更新同一个库的操作保证有序就行了。一条更新B库和一条更新A库的Binlog，就不需要严格有序。这样我们可以以库名为key进行hash，确保同一个库的消息都路由上同一个队列上就可以了。\n\n3. 正常情况下，多个消费组，他们的消费速度的上限就是生产速度（你消费再快也得等着消息生产出来），下限也是生产速度（否则就会出现消息积压），所以正常情况下，所有消费组的消费速度都应该和生产速度差不多。\n\n异常情况就是有的消费组会出现消息积压，如何解决积压的问题，我们后面会专门讲到。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564451288,"ip_address":"","comment_id":118726,"utype":1}],"discussion_count":7,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师讲得真好！我有几个问题想问下老师：\n 1. rocket mq 和 kafka 同样处理能力的情况下，哪个开销比较小，相差多吗？\n2. 如果要保障消息有序，生产者通过负载hash固化发送到某一个队列，此时一个消费组中多个消费者就没什么意义了吧，因为只能从一个队列取数据\n3. 多个消费组的消费速度不一样，队列又是所有消费组共享的，这似乎有些不妥，实践中什么比较好的解法，请老师教我","like_count":17,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460207,"discussion_content":"现代的消息队列大多就是这么实现的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564205540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3231519,"avatar":"https://static001.geekbang.org/account/avatar/00/31/4f/1f/791d0f5e.jpg","nickname":"Geek_159e2d","note":"","ucode":"8353F32D38C371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653715,"discussion_content":"如果是数组，可以参考 Java 中并行流的设计去做。\n（但根据思考题的限制，是在 ”队列“ 这个数据结构基础上的并行消费，又怎么随机访问呢？！）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731404949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3139074,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/XeGpHsAib2ZBic8PsR7z18plF2AccJ6Op5WmRDnv4Y9Vkmdiba9ibbcQSPGLJ1yuACAhkLQVQZHSz9WUcNj7UKSw6Q/132","nickname":"Geek_ba3598","note":"","ucode":"9D83A36A34189B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653315,"discussion_content":"改成数组的随机访问，用offset来控制消息组具体要消费哪条消息。这句话不太明白，随机访问具体是什么意思？随机的话不会存在随机到同一个消息的情况吗？那怎么保证消息只被消费一次？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730645087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1195017,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","nickname":"谁都会变","note":"","ucode":"9965748F7EBB57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587855,"discussion_content":"为啥是随机访问，没太明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663321762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1195017,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","nickname":"谁都会变","note":"","ucode":"9965748F7EBB57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588047,"discussion_content":"支持随机访问，是因为有消息回溯的需求，可以通过offset消费指定的消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663496232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":587855,"ip_address":"广东","group_id":0},"score":588047,"extra":""},{"author":{"id":1195017,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","nickname":"谁都会变","note":"","ucode":"9965748F7EBB57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588659,"discussion_content":"3Q","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663939174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":588047,"ip_address":"上海","group_id":0},"score":588659,"extra":""}]}]},{"had_liked":false,"id":175928,"user_name":"Geek_6ank0y","can_delete":false,"product_type":"c1","uid":1116340,"ip_address":"","ucode":"54F4AE0579711C","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/b4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1580887019,"is_pvip":false,"replies":[{"id":69501,"content":"这里指的是，在一个队列（分区）中，前面的消息没消费成功，而后面的消息都消费了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1581918321,"ip_address":"","comment_id":175928,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师您好，消费空洞是指消息消费失败之后无法再次消费吗","like_count":15,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460196,"discussion_content":"没错！具体可以看一下RocketMQ的并行消费的实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564206419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293188,"discussion_content":"类似死信队列","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595471785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3026466,"avatar":"","nickname":"Geek_be8a66","note":"","ucode":"192094B01719B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591888,"discussion_content":"出队是单个串行，消费是并行。可以这样理解吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666918375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1315147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","nickname":"xfan","note":"","ucode":"48ED8D498D7F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38466,"discussion_content":"和我理解的差不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571792700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117971,"user_name":"ly","can_delete":false,"product_type":"c1","uid":1221628,"ip_address":"","ucode":"5E2B85252DABF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/fc/379387a4.jpg","comment_is_top":false,"comment_ctime":1564200991,"is_pvip":false,"replies":[{"id":43184,"content":"第一个问题，consumer和queue不是强关联的，但是在任何一个时刻，某个queue在同一个consumer group中最多只能有一个consumer占用。\n\n第二个问题，producer和queue不需要关联，简单点儿说，就是发到哪个queue都可以。RocketMQ的默认策略是轮询选择每个queue。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564206209,"ip_address":"","comment_id":117971,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师您好，关于rocketmq的那张图有几个疑问：\nconsumergourp中的某个consumer是和某个具体的queue一一关联绑定的么？还是说某consumer每次都随机从某queue消费，另外如果是一一关联的话，那某个consumer挂了，那关联的那个queue的消息该由哪个consumer来接替消费呢？\n另外product发给topic的消息是否是被topic随机分配到某个queue中的？还是说product必须指定发到哪个queue中？","like_count":13,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460882,"discussion_content":"A1：可以。\nA2：有消费策略的，当然随机也是一种消费策略。\nA3：不是。首先，不同的消费组，消费位置是完全独立的，互不干扰。同一个消费组内：消息队列为每个队列维护一个消费位置（而不是给消费者实例）。因为，我们关心的是整个消费组能消费到全部队列的消息就可以了，不关系组内每个消费者消费多少消息，同一条消息，给A消费消费，还是给B消费者消费，是无所谓的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564627001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024341,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/55/cff2322c.jpg","nickname":"雪中亮","note":"","ucode":"B294FDFF9F13E8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348730,"discussion_content":"这条评论提的问题很好，把我想问的都提出来了。老师解答的更好！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1612691976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250587,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/1b/448b2775.jpg","nickname":"二货","note":"","ucode":"CF80FB9F35FC3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254303,"discussion_content":"终于明白了，原来同一个消费组里的消费者业务时一致的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588312113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371010,"discussion_content":"可以这样理解，一个消费者组就是一个线程池，取一条消息放入这个线程池中，哪个线程有时间哪个就去处理就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619608352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104487,"discussion_content":"老师，对于“同一条消息，给A消费消费，还是给B消费者消费”我有些疑问。同一组的两个消费者都订阅了这个topic，那也就是说消费者A和B都不能全部消费topic的消息，它们对应的业务逻辑不就会出现消息丢失的情况么？求解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577437722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181276,"discussion_content":"既然消费者 A 和 B 在一个消费者组里，一般来说他们的工作是一样的，消费者组多几个消费者是为了增加消费能力。如果你需要做不一样的事情，你需要再启动一个消费者组。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1582353100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104487,"ip_address":"","group_id":0},"score":181276,"extra":""}]},{"author":{"id":1252556,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/cc/a475e9b0.jpg","nickname":"君莫笑","note":"","ucode":"28D804A09E4C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3604,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564629952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252556,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/cc/a475e9b0.jpg","nickname":"君莫笑","note":"","ucode":"28D804A09E4C64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104489,"discussion_content":"我也有跟你同样的问题，同组的每个消费者只能消费当前topic的部分消息，消费者A和B有着不同的业务逻辑，那不就会出现消息丢失么？还是没想明白这点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577437895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3604,"ip_address":"","group_id":0},"score":104489,"extra":""},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231112,"discussion_content":"所以，如果A B有不同的业务逻辑，那么他们两个就不能在同一个消费者组","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586786997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104489,"ip_address":"","group_id":0},"score":231112,"extra":""}]}]},{"had_liked":false,"id":118003,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":true,"comment_ctime":1564209816,"is_pvip":false,"replies":[{"id":43256,"content":"A1： 不是，消费者组和队列数没有关系，你这个例子中消费者组的数量是2个。队列数量可以根据数据量和消费速度来合理配置。RocketMQ和Kafka都可以支持水平扩容队列数量，但是都需要手动操作。\n\nA2：producer会往所有队列发消息，但不是“同一条消息每个队列都发一次”，每条消息只会往某个队列里面发送一次。\n\n对于一个消费组，每个队列上只能串行消费，多个队列加一起就是并行消费了，并行度就是队列数量，队列数量越多并行度越大，所以水平扩展可以提升消费性能。\n\nA3：每队列每消费组维护一个消费位置（offset），记录这个消费组在这个队列上消费到哪儿了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564235052,"ip_address":"","comment_id":118003,"utype":1}],"discussion_count":31,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师， 初学者有一些疑问的地方 ，希望老师可以帮忙解答  😁\n\nRocket mq的模型图有些没有看懂 ， 模拟下场景；比如生产者是商品中心发送商品状态的更新（主题）消息（比如下架），那商品中心有多台机器就对应多个producer 。消费者组有两个，分别是导购中心 和 活动中心。\n\n疑问一 ：图中主题的队列是有多少个消费者组就有多少个队列么，是根据我们配置的消费者组数，mq自动增加主题队列个数么\n\n疑问二 ：看到图中每个producer的消息都往所有的队列中添加一条消息，每个消费者组消费自己的队列，但没有看懂这个队列是如何支持 “当水平扩展消费者机器” 可以加快消息的处理 。 每个消费组应该都是按照队列等前一条处理完了，才能去处理下一条（ps：这样来看 ，rb mq也是这个样子，如何通过水平扩展机器来加快消息的处理）\n\n疑问三 ： 图中队列的消费位置有点没看懂，我看是全剧唯一的，这是为什么，每个队列不能都是从0到1么","like_count":134,"discussions":[{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3468,"discussion_content":"A2：针对老师的回答我想再补充些问题：这个超时时间不能太长吧，不然严重影响性能？解除锁定后，比如当前在第二条消息被阻塞了，返回上一条消息意思是一直返回第一条消息，那怎么感觉一直卡在这里了，不会触发消费第三条消息？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564502171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155458,"discussion_content":"返回上一条消息意思是返回ack确认超时的那条消息 因为之前说了单独队列上消息是严格的顺序一致的 所以没有ack的消息会阻塞队列后面的消息消费 直到这条消息真正的被消费后并ack确认才会进行后面的消息消费开始","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580229133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3468,"ip_address":"","group_id":0},"score":155458,"extra":""},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581719,"discussion_content":"所以，还是存在队头阻塞的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658936362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":155458,"ip_address":"","group_id":0},"score":581719,"extra":""}]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460358,"discussion_content":"A1：按照订单ID或者用户ID，用一致性哈希算法，计算出队列ID，指定队列ID发送，这样可以保证相同的订单/用户的消息总被发送到同一个队列上，就可以确保严格顺序了。\n\nA2：会有一个超时，超时之前会阻塞，超时之后就解除锁定，允许其他消费者来拉消息，由于消费位置没变，下次再有消费者来这个队列拉消息，返回的还是上一条消息。\n\nA3：这个问题我在后面的课中会专门来讲。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564366363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2019657,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d1/49/791d0f5e.jpg","nickname":"aake","note":"","ucode":"FEFBF59EF09BFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":591190,"discussion_content":"保证顺序的话，那只有一个消费者能消费吗？有没有并行消费的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666348379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":460358,"ip_address":"浙江","group_id":0},"score":591190,"extra":""}]},{"author":{"id":1111175,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/87/644c0c5d.jpg","nickname":"俊伟","note":"","ucode":"7905B4F25637F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411900,"discussion_content":"消费的逻辑保持幂等应该可以解决重复消费的问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636029437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1573424,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/YDH3ehzpSkBEkl7DavPNrcOzF09icrdTQwUIial966H1LplKiacWtoRicicPfUdCn833ZKiaibCKzrbK7W1BTGmsraFtg/132","nickname":"rookie","note":"","ucode":"9E28FA97C01F24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45198,"discussion_content":"A3:每个消息都有一个唯一id，客户端只需要判断这个id有没有重复就可以","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573012101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1573424,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/YDH3ehzpSkBEkl7DavPNrcOzF09icrdTQwUIial966H1LplKiacWtoRicicPfUdCn833ZKiaibCKzrbK7W1BTGmsraFtg/132","nickname":"rookie","note":"","ucode":"9E28FA97C01F24","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576586,"discussion_content":"消息重试的时候 RocketMQ 的 msgid 应该是新的吧 但是它有一个原始msgId 可以追溯到最初的 msgId","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655687723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45198,"ip_address":"","group_id":0},"score":576586,"extra":""},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1139413,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","nickname":"大大大熊myeh","note":"","ucode":"4832C2E7CEB151","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581718,"discussion_content":"如果是重试，为什么要用新的消息ID呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658936311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":576586,"ip_address":"","group_id":0},"score":581718,"extra":""}]},{"author":{"id":1588679,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/c7/47f89975.jpg","nickname":"Lotus","note":"","ucode":"FDE1A67C0E6636","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608681,"discussion_content":"对于 Q2 的问题，如果在不需要严格保证消息顺序的情况下，rocketmq 提供了一种死信队列的方案，消费者实例在消费失败并且达到了最大重试次数以后，可以将该消息发送到死信队列，然后继续对死信队列中的消息进行处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678608470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2058455,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/68/d7/29025f1f.jpg","nickname":"前方的灯有点弱","note":"","ucode":"5CEDBCF3DDC991","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304237,"discussion_content":"消息的唯一性kafka可以通过事物或者分布式锁去处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599526766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9933,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568248207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1620997,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/e8OMeib8WILyHEVpNvaETb13Z9wNXmybah7fLrSBDHhu2GQvTf5SsibzFTSNXgibaH7jMibS178y3Ys9ptZ3iaGN4Lw/132","nickname":"zdf---my","note":"","ucode":"BEF943C4804AE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3843,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564859211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3792,"discussion_content":"老师，能帮忙解答下嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564813295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307012,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f1/84/7d21bd9e.jpg","nickname":"Goal","note":"","ucode":"C337CD4C7E07B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3447,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564482866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118905,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1564464047,"is_pvip":false,"replies":[{"id":43699,"content":"总结的非常到位！\n课后作业也完成的非常好！\n小红花走起！\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564536759,"ip_address":"","comment_id":118905,"utype":1}],"discussion_count":11,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"RocketMQ业务模型的理解，老师有空帮忙看下哦\n1、主题（topic）中有多个队列（队列数量可以水平进行扩容），生产者将其消息发送给主题中的某个队列（根据一定的路由规则，比如取模之类的），主题不保证消息的有序，只有队列中的消息才是有序的。\n2、从主题中的所有队列中取出消息给所有消费组进行消费，消息只能被消费组中的一个线程进行消费，有点类似线程池的形式，工作线程消费来自不同队列的消息，感觉这也是RocketMq,低时延的原因，不同队列中的消息可以同时被消费，并且消费组的线程也可以并发的消费不同的消息。\n3、由于主题中的一个队列都会被多个消费组进行消费，为此需要为每个消费组的消费的不同队列为此一个下标(每个消费组可以一直消费队列中的消息，无需等待其他消费组的确认)，主题中的队列消息是有序的，为此需要等到所有消费组对此条消息进行确认，才能从队列中移除，感觉每个消费组的队列下标，可以一个队列维护一个CurrentHashMap来为此每个消费组的下标，这样的话可以防止锁的竞争。\n课后习题：尝试回答下课后习题，感觉队列可以维护一个全局的下标，消费队列时，使用CAS进行下标的获取，由于不保证消息消费的有序，这样的话可以并发的消费消息，由于有全局下标，不会出现获取队列的空洞消息。","like_count":138,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460207,"discussion_content":"现代的消息队列大多就是这么实现的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564205540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3231519,"avatar":"https://static001.geekbang.org/account/avatar/00/31/4f/1f/791d0f5e.jpg","nickname":"Geek_159e2d","note":"","ucode":"8353F32D38C371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653715,"discussion_content":"如果是数组，可以参考 Java 中并行流的设计去做。\n（但根据思考题的限制，是在 ”队列“ 这个数据结构基础上的并行消费，又怎么随机访问呢？！）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731404949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3139074,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/XeGpHsAib2ZBic8PsR7z18plF2AccJ6Op5WmRDnv4Y9Vkmdiba9ibbcQSPGLJ1yuACAhkLQVQZHSz9WUcNj7UKSw6Q/132","nickname":"Geek_ba3598","note":"","ucode":"9D83A36A34189B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653315,"discussion_content":"改成数组的随机访问，用offset来控制消息组具体要消费哪条消息。这句话不太明白，随机访问具体是什么意思？随机的话不会存在随机到同一个消息的情况吗？那怎么保证消息只被消费一次？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730645087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1195017,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","nickname":"谁都会变","note":"","ucode":"9965748F7EBB57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587855,"discussion_content":"为啥是随机访问，没太明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663321762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1195017,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","nickname":"谁都会变","note":"","ucode":"9965748F7EBB57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588047,"discussion_content":"支持随机访问，是因为有消息回溯的需求，可以通过offset消费指定的消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663496232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":587855,"ip_address":"广东","group_id":0},"score":588047,"extra":""},{"author":{"id":1195017,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","nickname":"谁都会变","note":"","ucode":"9965748F7EBB57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588659,"discussion_content":"3Q","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663939174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":588047,"ip_address":"上海","group_id":0},"score":588659,"extra":""}]}]},{"had_liked":false,"id":118325,"user_name":"Geek_de6f9a","can_delete":false,"product_type":"c1","uid":1444577,"ip_address":"","ucode":"C047D42CFC882A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/V71wNP3XFiaPZuzwVI4AEhCPic5H6YscjWQeUXTfnGY5DEdGxWFf2dticNDyUpxiaQYGH0xboUNB0AicroLbak07xVA/132","comment_is_top":false,"comment_ctime":1564322236,"is_pvip":false,"replies":[{"id":43401,"content":"A1：按照订单ID或者用户ID，用一致性哈希算法，计算出队列ID，指定队列ID发送，这样可以保证相同的订单&#47;用户的消息总被发送到同一个队列上，就可以确保严格顺序了。\n\nA2：会有一个超时，超时之前会阻塞，超时之后就解除锁定，允许其他消费者来拉消息，由于消费位置没变，下次再有消费者来这个队列拉消息，返回的还是上一条消息。\n\nA3：这个问题我在后面的课中会专门来讲。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564366363,"ip_address":"","comment_id":118325,"utype":1}],"discussion_count":15,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师你好，想请问一下消费的顺序问题。\n对于有的消息，需要保证顺序性，比如交易状态和im消息。像im消息还要保证唯一性。\n\nQ1: rocketmq，一个消费组在一个主题下的多个队列并发消费就无法保证消息的顺序性。这种该如何处理?\n\nQ2: 客户端和mq要保持一种重试的机制，如果在网络延迟出现问题的时候，前面的消息一直未收到ack响应，若不做任何处理，后面的就会阻塞，还是重试之后放弃，若是不能发生丢失的信息该如何处理。\n\nQ3: 如何保证消息的唯一性，在重试的过程中，第一条消息已经发送，未收到ack，则进行第二次重试。此时网络故障恢复，则客户端会收到两条消息，客户端如何保证消息的唯一性。","like_count":79,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460196,"discussion_content":"没错！具体可以看一下RocketMQ的并行消费的实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564206419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293188,"discussion_content":"类似死信队列","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595471785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3026466,"avatar":"","nickname":"Geek_be8a66","note":"","ucode":"192094B01719B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591888,"discussion_content":"出队是单个串行，消费是并行。可以这样理解吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666918375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1315147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","nickname":"xfan","note":"","ucode":"48ED8D498D7F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38466,"discussion_content":"和我理解的差不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571792700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117977,"user_name":"a、","can_delete":false,"product_type":"c1","uid":1532404,"ip_address":"","ucode":"590FE8DB111492","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","comment_is_top":false,"comment_ctime":1564202194,"is_pvip":false,"replies":[{"id":43183,"content":"现代的消息队列大多就是这么实现的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564205540,"ip_address":"","comment_id":117977,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"今天的思考题，我觉得应该是，把消息队列的先进先出，改成数组的随机访问，用offset来控制消息组具体要消费哪条消息，mq不主动删除消息，消息有过期时间，如果到了过期时间，只能确认不能重新该消费，只保留最大可设置天数的消息。超过该天数则删除，还要维护客户端确认信息，如果有客户端没确认，需要有重发机制。不知道这个想法对不对？","like_count":62,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460882,"discussion_content":"A1：可以。\nA2：有消费策略的，当然随机也是一种消费策略。\nA3：不是。首先，不同的消费组，消费位置是完全独立的，互不干扰。同一个消费组内：消息队列为每个队列维护一个消费位置（而不是给消费者实例）。因为，我们关心的是整个消费组能消费到全部队列的消息就可以了，不关系组内每个消费者消费多少消息，同一条消息，给A消费消费，还是给B消费者消费，是无所谓的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564627001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024341,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/55/cff2322c.jpg","nickname":"雪中亮","note":"","ucode":"B294FDFF9F13E8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348730,"discussion_content":"这条评论提的问题很好，把我想问的都提出来了。老师解答的更好！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1612691976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250587,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/1b/448b2775.jpg","nickname":"二货","note":"","ucode":"CF80FB9F35FC3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254303,"discussion_content":"终于明白了，原来同一个消费组里的消费者业务时一致的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588312113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371010,"discussion_content":"可以这样理解，一个消费者组就是一个线程池，取一条消息放入这个线程池中，哪个线程有时间哪个就去处理就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619608352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104487,"discussion_content":"老师，对于“同一条消息，给A消费消费，还是给B消费者消费”我有些疑问。同一组的两个消费者都订阅了这个topic，那也就是说消费者A和B都不能全部消费topic的消息，它们对应的业务逻辑不就会出现消息丢失的情况么？求解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577437722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181276,"discussion_content":"既然消费者 A 和 B 在一个消费者组里，一般来说他们的工作是一样的，消费者组多几个消费者是为了增加消费能力。如果你需要做不一样的事情，你需要再启动一个消费者组。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1582353100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104487,"ip_address":"","group_id":0},"score":181276,"extra":""}]},{"author":{"id":1252556,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/cc/a475e9b0.jpg","nickname":"君莫笑","note":"","ucode":"28D804A09E4C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3604,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564629952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252556,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/cc/a475e9b0.jpg","nickname":"君莫笑","note":"","ucode":"28D804A09E4C64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104489,"discussion_content":"我也有跟你同样的问题，同组的每个消费者只能消费当前topic的部分消息，消费者A和B有着不同的业务逻辑，那不就会出现消息丢失么？还是没想明白这点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577437895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3604,"ip_address":"","group_id":0},"score":104489,"extra":""},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231112,"discussion_content":"所以，如果A B有不同的业务逻辑，那么他们两个就不能在同一个消费者组","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586786997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104489,"ip_address":"","group_id":0},"score":231112,"extra":""}]}]},{"had_liked":false,"id":118971,"user_name":"陈泽坛","can_delete":false,"product_type":"c1","uid":1394861,"ip_address":"","ucode":"C81B402868E9E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/ad/8be724da.jpg","comment_is_top":false,"comment_ctime":1564476701,"is_pvip":false,"replies":[{"id":43727,"content":"非常正确！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564539799,"ip_address":"","comment_id":118971,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"可以这样理解吗？请老师解答：\n主要是rocketmq的部分。\n生产者允许多生产者同时生产消息，每条消息只会被主题中的某条队列接收，消费组内的消费者竞相消费所有队列，消费者会根据消费组在队列上的数来记录已消费位置，做到的就是队列上的有序，但是有可能整个topic下，是无序的。有可能图中的4要先被消费，但是另一队列中的3还没被消费。\n所以如果需要有序，就需要发送到同一条队列中去了。","like_count":49,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460694,"discussion_content":"非常正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564539799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1195017,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","nickname":"谁都会变","note":"","ucode":"9965748F7EBB57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587853,"discussion_content":"厉害了，大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663321047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1619882,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b7/aa/6427f4d8.jpg","nickname":"wlarein","note":"","ucode":"81A6B217700403","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22884,"discussion_content":"清晰明了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569723108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117956,"user_name":"flyamonkey","can_delete":false,"product_type":"c1","uid":1045689,"ip_address":"","ucode":"F63B794FC654E4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/b9/c6e91344.jpg","comment_is_top":false,"comment_ctime":1564198741,"is_pvip":false,"replies":[{"id":43187,"content":"没错！具体可以看一下RocketMQ的并行消费的实现。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564206419,"ip_address":"","comment_id":117956,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"不要求严格顺序的话，应该是可以做到单个队列并行的，但这种情况下消息的消费可能就是个出队操作，而非等待消费端的ack后再出队了，这样势必会造成消息的丢失，所以需要有一定的补偿机制，如消息的重传和持久化等。个人见解，不知道是不是准确，还请老师指点~","like_count":36,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460547,"discussion_content":"A1：这个我没有测试过，你可以自己测试一下。\n\nA2：有意义，比如我们通过一个主题来传输一个多库MySQL实例的binlog，这个是必须严格有序的。但是，不用真的全局有序，只要更新同一个库的操作保证有序就行了。一条更新B库和一条更新A库的Binlog，就不需要严格有序。这样我们可以以库名为key进行hash，确保同一个库的消息都路由上同一个队列上就可以了。\n\n3. 正常情况下，多个消费组，他们的消费速度的上限就是生产速度（你消费再快也得等着消息生产出来），下限也是生产速度（否则就会出现消息积压），所以正常情况下，所有消费组的消费速度都应该和生产速度差不多。\n\n异常情况就是有的消费组会出现消息积压，如何解决积压的问题，我们后面会专门讲到。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564451288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531772,"discussion_content":"老师我想请问下，如果这个队列上生产的消息有msg1，msg2，msg3。其中msg1由于代码问题或者网络问题消费失败，进入重试队列。然后消费者成功消费了msg2，msg3.最后才消费msg1，那队列上消费的顺序不是也就无序了吗？ 那像MySQL binlog这种我理解肯定不能接受消费乱序吧？ 可能是我哪里理解错了，欢迎老师指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637412051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":2,"child_discussions":[{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"程序员俊达","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553137,"discussion_content":"Msg1如果没有ack，不应该消费msg2吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645750051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531772,"ip_address":"","group_id":0},"score":553137,"extra":""},{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"程序员俊达","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":553579,"discussion_content":"是的 现在懂这里面的原理了。msg1如果消费失败，会重新进入processQueue继续消费。后面的消息会被阻塞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645970133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553137,"ip_address":"","group_id":0},"score":553579,"extra":""}]},{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371009,"discussion_content":"老师说的A2其实就是mysql主从集群的多线程复制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619608196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","nickname":"饭粒","note":"","ucode":"4C3220B0D43997","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41444,"discussion_content":"正想问 Q3，mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572429117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019289,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/99/f886543d.jpg","nickname":"渔夫","note":"","ucode":"6BF08FD8923E45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3457,"discussion_content":"谢谢老师的答复，期待后续关于消息积压的讲解:-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564494317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119387,"user_name":"君莫笑","can_delete":false,"product_type":"c1","uid":1252556,"ip_address":"","ucode":"28D804A09E4C64","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/cc/a475e9b0.jpg","comment_is_top":false,"comment_ctime":1564575989,"is_pvip":false,"replies":[{"id":43843,"content":"A1：可以。\nA2：有消费策略的，当然随机也是一种消费策略。\nA3：不是。首先，不同的消费组，消费位置是完全独立的，互不干扰。同一个消费组内：消息队列为每个队列维护一个消费位置（而不是给消费者实例）。因为，我们关心的是整个消费组能消费到全部队列的消息就可以了，不关系组内每个消费者消费多少消息，同一条消息，给A消费消费，还是给B消费者消费，是无所谓的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564627001,"ip_address":"","comment_id":119387,"utype":1}],"discussion_count":9,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，我有几个问题，就是rocket MQ模型图上，1、某一个消费组中的各个消费者可以消费某一个主题中的多个队列吗;2、如果可以，消费者拉取消息的时候是完全随机消费某一个队列还是可以指定策略呢？3、如果可以，那是不是主题下的每个队列都要对应给每一个消费者（注意不是消费组）维护一个offset来记录当前消费者消费位置呢？（或者是每个消费者对应每个队列维护呢），求解答","like_count":23,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482958,"discussion_content":"这里指的是，在一个队列（分区）中，前面的消息没消费成功，而后面的消息都消费了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581918321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1895320,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/KiaBJsepm9fHHicfPxiahhR3RqRaR4QH6YFibIHV5o5VspTIXmH72iaiaotb4cRpWtRvLC7mnh5KH1KlSNLGWlI7wUicQ/132","nickname":"Rorchachl","note":"","ucode":"7AABFF65A0033C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405956,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634661616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118726,"user_name":"渔夫","can_delete":false,"product_type":"c1","uid":1019289,"ip_address":"","ucode":"6BF08FD8923E45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/99/f886543d.jpg","comment_is_top":false,"comment_ctime":1564442546,"is_pvip":false,"replies":[{"id":43543,"content":"A1：这个我没有测试过，你可以自己测试一下。\n\nA2：有意义，比如我们通过一个主题来传输一个多库MySQL实例的binlog，这个是必须严格有序的。但是，不用真的全局有序，只要更新同一个库的操作保证有序就行了。一条更新B库和一条更新A库的Binlog，就不需要严格有序。这样我们可以以库名为key进行hash，确保同一个库的消息都路由上同一个队列上就可以了。\n\n3. 正常情况下，多个消费组，他们的消费速度的上限就是生产速度（你消费再快也得等着消息生产出来），下限也是生产速度（否则就会出现消息积压），所以正常情况下，所有消费组的消费速度都应该和生产速度差不多。\n\n异常情况就是有的消费组会出现消息积压，如何解决积压的问题，我们后面会专门讲到。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564451288,"ip_address":"","comment_id":118726,"utype":1}],"discussion_count":7,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师讲得真好！我有几个问题想问下老师：\n 1. rocket mq 和 kafka 同样处理能力的情况下，哪个开销比较小，相差多吗？\n2. 如果要保障消息有序，生产者通过负载hash固化发送到某一个队列，此时一个消费组中多个消费者就没什么意义了吧，因为只能从一个队列取数据\n3. 多个消费组的消费速度不一样，队列又是所有消费组共享的，这似乎有些不妥，实践中什么比较好的解法，请老师教我","like_count":17,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460547,"discussion_content":"A1：这个我没有测试过，你可以自己测试一下。\n\nA2：有意义，比如我们通过一个主题来传输一个多库MySQL实例的binlog，这个是必须严格有序的。但是，不用真的全局有序，只要更新同一个库的操作保证有序就行了。一条更新B库和一条更新A库的Binlog，就不需要严格有序。这样我们可以以库名为key进行hash，确保同一个库的消息都路由上同一个队列上就可以了。\n\n3. 正常情况下，多个消费组，他们的消费速度的上限就是生产速度（你消费再快也得等着消息生产出来），下限也是生产速度（否则就会出现消息积压），所以正常情况下，所有消费组的消费速度都应该和生产速度差不多。\n\n异常情况就是有的消费组会出现消息积压，如何解决积压的问题，我们后面会专门讲到。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564451288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531772,"discussion_content":"老师我想请问下，如果这个队列上生产的消息有msg1，msg2，msg3。其中msg1由于代码问题或者网络问题消费失败，进入重试队列。然后消费者成功消费了msg2，msg3.最后才消费msg1，那队列上消费的顺序不是也就无序了吗？ 那像MySQL binlog这种我理解肯定不能接受消费乱序吧？ 可能是我哪里理解错了，欢迎老师指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637412051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":2,"child_discussions":[{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"程序员俊达","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553137,"discussion_content":"Msg1如果没有ack，不应该消费msg2吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645750051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531772,"ip_address":"","group_id":0},"score":553137,"extra":""},{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"程序员俊达","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":553579,"discussion_content":"是的 现在懂这里面的原理了。msg1如果消费失败，会重新进入processQueue继续消费。后面的消息会被阻塞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645970133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553137,"ip_address":"","group_id":0},"score":553579,"extra":""}]},{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371009,"discussion_content":"老师说的A2其实就是mysql主从集群的多线程复制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619608196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","nickname":"饭粒","note":"","ucode":"4C3220B0D43997","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41444,"discussion_content":"正想问 Q3，mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572429117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019289,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/99/f886543d.jpg","nickname":"渔夫","note":"","ucode":"6BF08FD8923E45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3457,"discussion_content":"谢谢老师的答复，期待后续关于消息积压的讲解:-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564494317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175928,"user_name":"Geek_6ank0y","can_delete":false,"product_type":"c1","uid":1116340,"ip_address":"","ucode":"54F4AE0579711C","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/b4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1580887019,"is_pvip":false,"replies":[{"id":69501,"content":"这里指的是，在一个队列（分区）中，前面的消息没消费成功，而后面的消息都消费了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1581918321,"ip_address":"","comment_id":175928,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师您好，消费空洞是指消息消费失败之后无法再次消费吗","like_count":15,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482958,"discussion_content":"这里指的是，在一个队列（分区）中，前面的消息没消费成功，而后面的消息都消费了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581918321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1895320,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/KiaBJsepm9fHHicfPxiahhR3RqRaR4QH6YFibIHV5o5VspTIXmH72iaiaotb4cRpWtRvLC7mnh5KH1KlSNLGWlI7wUicQ/132","nickname":"Rorchachl","note":"","ucode":"7AABFF65A0033C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405956,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634661616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117971,"user_name":"ly","can_delete":false,"product_type":"c1","uid":1221628,"ip_address":"","ucode":"5E2B85252DABF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/fc/379387a4.jpg","comment_is_top":false,"comment_ctime":1564200991,"is_pvip":false,"replies":[{"id":43184,"content":"第一个问题，consumer和queue不是强关联的，但是在任何一个时刻，某个queue在同一个consumer group中最多只能有一个consumer占用。\n\n第二个问题，producer和queue不需要关联，简单点儿说，就是发到哪个queue都可以。RocketMQ的默认策略是轮询选择每个queue。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564206209,"ip_address":"","comment_id":117971,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师您好，关于rocketmq的那张图有几个疑问：\nconsumergourp中的某个consumer是和某个具体的queue一一关联绑定的么？还是说某consumer每次都随机从某queue消费，另外如果是一一关联的话，那某个consumer挂了，那关联的那个queue的消息该由哪个consumer来接替消费呢？\n另外product发给topic的消息是否是被topic随机分配到某个queue中的？还是说product必须指定发到哪个queue中？","like_count":13,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460204,"discussion_content":"第一个问题，consumer和queue不是强关联的，但是在任何一个时刻，某个queue在同一个consumer group中最多只能有一个consumer占用。\n\n第二个问题，producer和queue不需要关联，简单点儿说，就是发到哪个queue都可以。RocketMQ的默认策略是轮询选择每个queue。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564206209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111400,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","nickname":"王飞2023","note":"","ucode":"C0F3139B836F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3249,"discussion_content":"你好，topic下的queue有多个。一个消费组中的一个消费者启动的时候会绑定到其中1个或多个queue上订阅。这个逻辑会定时更新。也就是说，一旦有一个消费者挂了，会重新分配。这个是我的理解，不一定正确。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564331652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111400,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/68/791d0f5e.jpg","nickname":"王飞2023","note":"","ucode":"C0F3139B836F39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3469,"discussion_content":"绑定之后不会再变动了吧，除非消费者这边主动挂掉会发生解绑操作，消费过程中会指定消费绑定的那些队列，还是可能会消费其他队列？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564502743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3249,"ip_address":"","group_id":0},"score":3469,"extra":""},{"author":{"id":1588679,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/c7/47f89975.jpg","nickname":"Lotus","note":"","ucode":"FDE1A67C0E6636","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608683,"discussion_content":"消费者实例和 queue 之间并不是一经关联就不会再发生改变的。比如说在 rocketmq 中，如果说消费者实例的数量发生变化了，会触发 rebalance 策略，给消费者实例重新分配 queue","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678609786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3469,"ip_address":"浙江","group_id":0},"score":608683,"extra":""}]}]},{"had_liked":false,"id":117916,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1564191431,"is_pvip":false,"replies":[{"id":43206,"content":"谢谢","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208956,"ip_address":"","comment_id":117916,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"没啥问题，就是想点个赞，老师的声音很nice！","like_count":13,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460178,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118233,"user_name":"Geek_87338d","can_delete":false,"product_type":"c1","uid":1617390,"ip_address":"","ucode":"591122E793E9D0","user_header":"","comment_is_top":false,"comment_ctime":1564298747,"is_pvip":false,"replies":[{"id":43395,"content":"A1：队列只有一份，无论有多少订阅，所以不存在你说的问题。\nA2：目前的这种设计也是没办法的办法，还没有什么完美的解决方案既在topic上保证严格顺序，又要保证高性能和数据可靠性。但是目前这种实现也可以解决很多对顺序有要求的场景的问题。\n\nA3：实际上并不是一条一条确认的，而是一批一批确认的。一般consumer取一批消息，然后确认的时候直接提交这批消息中最后一条消息的位置来确认这批消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365900,"ip_address":"","comment_id":118233,"utype":1}],"discussion_count":5,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"有三个问题没太想清楚，希望老师解答一下。\n1. rocket mq的模型，是不是每有一个新的consumer，都需要对mq进行配置新增一个queue？（我预设了一个前提是1queue有且只有1consumer来消费，1consumer只消费1queue不知道对不对）这样下游机器重启或者加机器，运维要累死。但没想明白它是怎么解决新增或者减少consumer的问题的？\n2. rocket mq的那个流程图，不能保证消息在全局顺序处理（比如处理0号消息的consumer1可能比处理1号消息的consumer2要慢，对于整个系统，1号消息被先处理），那么保证单个queue顺序处理的意义或者场景是什么呢？好像是为了消息的ack机制？\n3. 每个消息都确认（tcp是发送方一直发，接收方只确认最后的sequence，这样快得多）效率很低，那是怎么做到打满网卡的？靠大量的queue并发吗？","like_count":12,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460313,"discussion_content":"A1：队列只有一份，无论有多少订阅，所以不存在你说的问题。\nA2：目前的这种设计也是没办法的办法，还没有什么完美的解决方案既在topic上保证严格顺序，又要保证高性能和数据可靠性。但是目前这种实现也可以解决很多对顺序有要求的场景的问题。\n\nA3：实际上并不是一条一条确认的，而是一批一批确认的。一般consumer取一批消息，然后确认的时候直接提交这批消息中最后一条消息的位置来确认这批消息。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564365900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331536,"discussion_content":"我理解同一个组内，并不要求消费者和queue一一对应，也就是一个组内的N个消费者，竞相消费这M个queue。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606895387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018494,"avatar":"","nickname":"whhbbq","note":"","ucode":"4A93F3E375CB44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165777,"discussion_content":"我理解老师的意思是， topic下面有多少个队列是固定的，不会因为多增加了一个消费组就会多一个队列。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581326245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1281460,"avatar":"https://static001.geekbang.org/account/avatar/00/13/8d/b4/ff82483d.jpg","nickname":"邵俊达","note":"","ucode":"4B7DACE6DBCF95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17805,"discussion_content":"没太理解为什么队列只有一份，一个消费组不是可以有多个队列么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568981902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1281460,"avatar":"https://static001.geekbang.org/account/avatar/00/13/8d/b4/ff82483d.jpg","nickname":"邵俊达","note":"","ucode":"4B7DACE6DBCF95","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181271,"discussion_content":"消费组与队列没有直接关系。队列是属于 topic 的，它是固定的，不会因为增加了消费组，而导致队列增加","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582352709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":17805,"ip_address":"","group_id":0},"score":181271,"extra":""}]}]},{"had_liked":false,"id":132156,"user_name":"ForEverLearning","can_delete":false,"product_type":"c1","uid":1622661,"ip_address":"","ucode":"AA32E6126BA954","user_header":"https://static001.geekbang.org/account/avatar/00/18/c2/85/962858f5.jpg","comment_is_top":false,"comment_ctime":1568034253,"is_pvip":false,"replies":[{"id":50565,"content":"不会，这部分只能慢慢消费了。\n\n针对这种情况，RocketMQ支持开启单个队列的并行消费，可以解决你的问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568077799,"ip_address":"","comment_id":132156,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，有一个问题请教下。\n以Kafka为例，目前MQ里已经积压了大量消息，且为了提升消费能力对消费端进行了水平扩展。\n那么对于已经积压的那些消息，Kafka会重新把它们分配到新的队列上去吗？","like_count":10},{"had_liked":false,"id":130505,"user_name":"loCust","can_delete":false,"product_type":"c1","uid":1297583,"ip_address":"","ucode":"A5CFECA44045A1","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/af/25509210.jpg","comment_is_top":false,"comment_ctime":1567474859,"is_pvip":false,"replies":[{"id":48747,"content":"消费组中某个消费者在消费一个队列的时候，其他同组的消费者是不能消费这个队列的，但是他们可以去消费同主题的其它队列，所以并不是空闲的。并且，即使是这些消费者并行消费不同的队列，在每个队列上，还是可以保证严格顺序的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567493511,"ip_address":"","comment_id":130505,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"RocketMQ中一个消费组有多个消费者,一个消费组消费topoic中的一个quene,要在队列上保证消息的有序性,消费组中一个消费者在消费消息的过程中,其余的消费者都是空闲的,是这样吗老师？","like_count":9,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460313,"discussion_content":"A1：队列只有一份，无论有多少订阅，所以不存在你说的问题。\nA2：目前的这种设计也是没办法的办法，还没有什么完美的解决方案既在topic上保证严格顺序，又要保证高性能和数据可靠性。但是目前这种实现也可以解决很多对顺序有要求的场景的问题。\n\nA3：实际上并不是一条一条确认的，而是一批一批确认的。一般consumer取一批消息，然后确认的时候直接提交这批消息中最后一条消息的位置来确认这批消息。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564365900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331536,"discussion_content":"我理解同一个组内，并不要求消费者和queue一一对应，也就是一个组内的N个消费者，竞相消费这M个queue。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606895387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018494,"avatar":"","nickname":"whhbbq","note":"","ucode":"4A93F3E375CB44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165777,"discussion_content":"我理解老师的意思是， topic下面有多少个队列是固定的，不会因为多增加了一个消费组就会多一个队列。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581326245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1281460,"avatar":"https://static001.geekbang.org/account/avatar/00/13/8d/b4/ff82483d.jpg","nickname":"邵俊达","note":"","ucode":"4B7DACE6DBCF95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17805,"discussion_content":"没太理解为什么队列只有一份，一个消费组不是可以有多个队列么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568981902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1130590,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","nickname":"Ryoma","note":"","ucode":"7F692369239692","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1281460,"avatar":"https://static001.geekbang.org/account/avatar/00/13/8d/b4/ff82483d.jpg","nickname":"邵俊达","note":"","ucode":"4B7DACE6DBCF95","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181271,"discussion_content":"消费组与队列没有直接关系。队列是属于 topic 的，它是固定的，不会因为增加了消费组，而导致队列增加","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582352709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":17805,"ip_address":"","group_id":0},"score":181271,"extra":""}]}]},{"had_liked":false,"id":117931,"user_name":"渔村蓝","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1564194733,"is_pvip":false,"replies":[{"id":43208,"content":"consumer在某个时刻对应的是某个queue（图中的实线），consumer group 对应 topic（同样是虚线方框），我理解这张图和你的描述是一致的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564209483,"ip_address":"","comment_id":117931,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"Rocket mq那张图是不是有问题，consumer是不直接对topic的，group才直接对topic，求解答，谢谢。","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466793,"discussion_content":"不会，这部分只能慢慢消费了。\n\n针对这种情况，RocketMQ支持开启单个队列的并行消费，可以解决你的问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568077799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331537,"discussion_content":"因为kafka中一个partition（对应rocket的queue），只能由一个消费者消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606895504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204486,"user_name":"辉马足球","can_delete":false,"product_type":"c1","uid":1125521,"ip_address":"","ucode":"CA9C0AF24AD236","user_header":"https://static001.geekbang.org/account/avatar/00/11/2c/91/cae1fd01.jpg","comment_is_top":false,"comment_ctime":1586405783,"is_pvip":false,"replies":[{"id":76477,"content":"最后这句，我猝不及防啊😓😓😓","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1586426608,"ip_address":"","comment_id":204486,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"当老师好累啊,看您逐个回复学员问题..看着都累\n这么负责任的老师,不好好学,学不好\n也是正常的是吧..","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465983,"discussion_content":"消费组中某个消费者在消费一个队列的时候，其他同组的消费者是不能消费这个队列的，但是他们可以去消费同主题的其它队列，所以并不是空闲的。并且，即使是这些消费者并行消费不同的队列，在每个队列上，还是可以保证严格顺序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567493511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1434066,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","nickname":"今夜秋风和","note":"","ucode":"453C8197FFC81D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577270,"discussion_content":"请问如果多个消费者消费同一个队列，是不是考虑到维护队列消息消费的有序性的成本，才不允许这样处理？ 如果出现实消费者实例1挂掉，那么他消费的队列的消息应该也可以被其他消费者实列来消息吧？ 望老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655996903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117981,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1564203629,"is_pvip":false,"replies":[{"id":43209,"content":"就是记录哪些消息消费了，哪些没消费。由于消费者是不记录消费位置的，它消费的时候只管去找Broker要消息，Broker必须知道消费到哪儿了，好找出下一条或下一批消息给客户端。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564209669,"ip_address":"","comment_id":117981,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师你好，RocketMQ中，消费位置(5)记录了当前消费组GroupA在A队列中的消费位置，(5)之前都被消费过，(5)之后都没有；那么这个(5)最终的作用是什么？\n是当GroupA再取下一个消息时，用来判断在队列A中的消息位置用的吗？除此之外还有其他作用吗？","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460186,"discussion_content":"consumer在某个时刻对应的是某个queue（图中的实线），consumer group 对应 topic（同样是虚线方框），我理解这张图和你的描述是一致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564209483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"渔村蓝","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3139,"discussion_content":"嗯，那就对了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564216328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118636,"user_name":"二星球","can_delete":false,"product_type":"c1","uid":1111552,"ip_address":"","ucode":"89EC5FEB98E7CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/00/2a248fd8.jpg","comment_is_top":false,"comment_ctime":1564403104,"is_pvip":false,"replies":[{"id":43532,"content":"首先，服务端是不回滚的，消费端拉10条数据后，消费位置不变，之后10条全消费成功了，offset才加10。\n\n对于有些“坏消息”始终无法成功的消费的情况，有些消息队列会把这种消息转存到一个特殊的坏消息队列，避免一个坏消息卡主队列。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449999,"ip_address":"","comment_id":118636,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，请教个问题，消费端向服务端拉10条数据，offset偏移10个位置，如果消费端正确处理了其中的9条数据，其中一条数据异常，消息回滚，只能把10条数据都回滚，offset这种机制无法做到回滚某几条吧？如果业务处理一条数据很耗时，这是一种弊端吧，有没有好的解决办法呢","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491198,"discussion_content":"最后这句，我猝不及防啊😓😓😓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586426608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050847,"avatar":"https://static001.geekbang.org/account/avatar/00/10/08/df/866ed645.jpg","nickname":"xuyd","note":"","ucode":"62E1E7D5201E89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390792,"discussion_content":"肯定是正常的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630047908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118110,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1564244235,"is_pvip":true,"replies":[{"id":43387,"content":"不是这样的，无论有多少个消费组，队列只有一份，他们（消费组）都去这个队列上读取消息，由于消费快慢不同，每个消费组都会自己维护在这个队列上的消费位置。\n消费组之间是完全互不影响的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365076,"ip_address":"","comment_id":118110,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师想问下RocketMq模型图中是消费组中每个消费者都对应一个队列以及相应的消费位置么，因为我理解应该是每个消费组都对应着一个具有相同消息的消息队列，只是相应的消费位置不同而已，这样每个消费组都能消费相同的消息","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460209,"discussion_content":"就是记录哪些消息消费了，哪些没消费。由于消费者是不记录消费位置的，它消费的时候只管去找Broker要消息，Broker必须知道消费到哪儿了，好找出下一条或下一批消息给客户端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564209669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013822,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/3e/c39d86f1.jpg","nickname":"Chocolate","note":"","ucode":"242CF0E3C10E97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216240,"discussion_content":"广播消息中，是消费者记录消费位置，不是 broker 记录吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585410323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117909,"user_name":"Penn","can_delete":false,"product_type":"c1","uid":1044701,"ip_address":"","ucode":"C6A4AA2259068F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AkO5s3tJhibth9nelCNdU5qD4J3aEn8OpBhOHluicWgEj1SbcGC6e9rccK8DrfJtRibJT5g6iamfIibt5xX7ketDF6w/132","comment_is_top":false,"comment_ctime":1564190141,"is_pvip":false,"replies":[{"id":43205,"content":"✅","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208940,"ip_address":"","comment_id":117909,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"维护一个offset抽象，offset由单个位置变成一个集合，集合中包含多个单个位置。类似多值信号量的机制","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460266,"discussion_content":"不是这样的，无论有多少个消费组，队列只有一份，他们（消费组）都去这个队列上读取消息，由于消费快慢不同，每个消费组都会自己维护在这个队列上的消费位置。\n消费组之间是完全互不影响的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182167,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","nickname":"Shen","note":"","ucode":"CFF7609A754392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52510,"discussion_content":"我也觉得老师和你说的是一个意思。队列上会记录每一个消费组的消费位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574058140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1182167,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","nickname":"Shen","note":"","ucode":"CFF7609A754392","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52655,"discussion_content":"是的😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574076578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52510,"ip_address":"","group_id":0},"score":52655,"extra":""}]},{"author":{"id":1254582,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/FqZKG3aII9YzXkfSh1Wuc2urQPZX9tZ9AwQKevDlic3mAD9C0ceVpLrSNeCLYfKAY9PtjVjVP2JBLwqRkvMoaQg/132","nickname":"晓μ","note":"","ucode":"4C6A062C43B570","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4649,"discussion_content":"我觉得老师和你说的都是一个意思。\n不同的消费组都对应同样的主题，\n消费者组内消费者存在竞争关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565618779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117916,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1564191431,"is_pvip":false,"replies":[{"id":43206,"content":"谢谢","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208956,"ip_address":"","comment_id":117916,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"没啥问题，就是想点个赞，老师的声音很nice！","like_count":13,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460178,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118233,"user_name":"Geek_87338d","can_delete":false,"product_type":"c1","uid":1617390,"ip_address":"","ucode":"591122E793E9D0","user_header":"","comment_is_top":false,"comment_ctime":1564298747,"is_pvip":false,"replies":[{"id":43395,"content":"A1：队列只有一份，无论有多少订阅，所以不存在你说的问题。\nA2：目前的这种设计也是没办法的办法，还没有什么完美的解决方案既在topic上保证严格顺序，又要保证高性能和数据可靠性。但是目前这种实现也可以解决很多对顺序有要求的场景的问题。\n\nA3：实际上并不是一条一条确认的，而是一批一批确认的。一般consumer取一批消息，然后确认的时候直接提交这批消息中最后一条消息的位置来确认这批消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365900,"ip_address":"","comment_id":118233,"utype":1}],"discussion_count":5,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"有三个问题没太想清楚，希望老师解答一下。\n1. rocket mq的模型，是不是每有一个新的consumer，都需要对mq进行配置新增一个queue？（我预设了一个前提是1queue有且只有1consumer来消费，1consumer只消费1queue不知道对不对）这样下游机器重启或者加机器，运维要累死。但没想明白它是怎么解决新增或者减少consumer的问题的？\n2. rocket mq的那个流程图，不能保证消息在全局顺序处理（比如处理0号消息的consumer1可能比处理1号消息的consumer2要慢，对于整个系统，1号消息被先处理），那么保证单个queue顺序处理的意义或者场景是什么呢？好像是为了消息的ack机制？\n3. 每个消息都确认（tcp是发送方一直发，接收方只确认最后的sequence，这样快得多）效率很低，那是怎么做到打满网卡的？靠大量的queue并发吗？","like_count":12,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466793,"discussion_content":"不会，这部分只能慢慢消费了。\n\n针对这种情况，RocketMQ支持开启单个队列的并行消费，可以解决你的问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568077799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331537,"discussion_content":"因为kafka中一个partition（对应rocket的queue），只能由一个消费者消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606895504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132156,"user_name":"ForEverLearning","can_delete":false,"product_type":"c1","uid":1622661,"ip_address":"","ucode":"AA32E6126BA954","user_header":"https://static001.geekbang.org/account/avatar/00/18/c2/85/962858f5.jpg","comment_is_top":false,"comment_ctime":1568034253,"is_pvip":false,"replies":[{"id":50565,"content":"不会，这部分只能慢慢消费了。\n\n针对这种情况，RocketMQ支持开启单个队列的并行消费，可以解决你的问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568077799,"ip_address":"","comment_id":132156,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，有一个问题请教下。\n以Kafka为例，目前MQ里已经积压了大量消息，且为了提升消费能力对消费端进行了水平扩展。\n那么对于已经积压的那些消息，Kafka会重新把它们分配到新的队列上去吗？","like_count":10,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465983,"discussion_content":"消费组中某个消费者在消费一个队列的时候，其他同组的消费者是不能消费这个队列的，但是他们可以去消费同主题的其它队列，所以并不是空闲的。并且，即使是这些消费者并行消费不同的队列，在每个队列上，还是可以保证严格顺序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567493511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1434066,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","nickname":"今夜秋风和","note":"","ucode":"453C8197FFC81D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577270,"discussion_content":"请问如果多个消费者消费同一个队列，是不是考虑到维护队列消息消费的有序性的成本，才不允许这样处理？ 如果出现实消费者实例1挂掉，那么他消费的队列的消息应该也可以被其他消费者实列来消息吧？ 望老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655996903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130505,"user_name":"loCust","can_delete":false,"product_type":"c1","uid":1297583,"ip_address":"","ucode":"A5CFECA44045A1","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/af/25509210.jpg","comment_is_top":false,"comment_ctime":1567474859,"is_pvip":false,"replies":[{"id":48747,"content":"消费组中某个消费者在消费一个队列的时候，其他同组的消费者是不能消费这个队列的，但是他们可以去消费同主题的其它队列，所以并不是空闲的。并且，即使是这些消费者并行消费不同的队列，在每个队列上，还是可以保证严格顺序的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567493511,"ip_address":"","comment_id":130505,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"RocketMQ中一个消费组有多个消费者,一个消费组消费topoic中的一个quene,要在队列上保证消息的有序性,消费组中一个消费者在消费消息的过程中,其余的消费者都是空闲的,是这样吗老师？","like_count":9,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460186,"discussion_content":"consumer在某个时刻对应的是某个queue（图中的实线），consumer group 对应 topic（同样是虚线方框），我理解这张图和你的描述是一致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564209483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"渔村蓝","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3139,"discussion_content":"嗯，那就对了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564216328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117931,"user_name":"渔村蓝","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1564194733,"is_pvip":false,"replies":[{"id":43208,"content":"consumer在某个时刻对应的是某个queue（图中的实线），consumer group 对应 topic（同样是虚线方框），我理解这张图和你的描述是一致的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564209483,"ip_address":"","comment_id":117931,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"Rocket mq那张图是不是有问题，consumer是不直接对topic的，group才直接对topic，求解答，谢谢。","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491198,"discussion_content":"最后这句，我猝不及防啊😓😓😓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586426608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050847,"avatar":"https://static001.geekbang.org/account/avatar/00/10/08/df/866ed645.jpg","nickname":"xuyd","note":"","ucode":"62E1E7D5201E89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390792,"discussion_content":"肯定是正常的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630047908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204486,"user_name":"辉马足球","can_delete":false,"product_type":"c1","uid":1125521,"ip_address":"","ucode":"CA9C0AF24AD236","user_header":"https://static001.geekbang.org/account/avatar/00/11/2c/91/cae1fd01.jpg","comment_is_top":false,"comment_ctime":1586405783,"is_pvip":false,"replies":[{"id":76477,"content":"最后这句，我猝不及防啊😓😓😓","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1586426608,"ip_address":"","comment_id":204486,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"当老师好累啊,看您逐个回复学员问题..看着都累\n这么负责任的老师,不好好学,学不好\n也是正常的是吧..","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460209,"discussion_content":"就是记录哪些消息消费了，哪些没消费。由于消费者是不记录消费位置的，它消费的时候只管去找Broker要消息，Broker必须知道消费到哪儿了，好找出下一条或下一批消息给客户端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564209669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013822,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/3e/c39d86f1.jpg","nickname":"Chocolate","note":"","ucode":"242CF0E3C10E97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216240,"discussion_content":"广播消息中，是消费者记录消费位置，不是 broker 记录吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585410323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117981,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1564203629,"is_pvip":false,"replies":[{"id":43209,"content":"就是记录哪些消息消费了，哪些没消费。由于消费者是不记录消费位置的，它消费的时候只管去找Broker要消息，Broker必须知道消费到哪儿了，好找出下一条或下一批消息给客户端。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564209669,"ip_address":"","comment_id":117981,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师你好，RocketMQ中，消费位置(5)记录了当前消费组GroupA在A队列中的消费位置，(5)之前都被消费过，(5)之后都没有；那么这个(5)最终的作用是什么？\n是当GroupA再取下一个消息时，用来判断在队列A中的消息位置用的吗？除此之外还有其他作用吗？","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460501,"discussion_content":"首先，服务端是不回滚的，消费端拉10条数据后，消费位置不变，之后10条全消费成功了，offset才加10。\n\n对于有些“坏消息”始终无法成功的消费的情况，有些消息队列会把这种消息转存到一个特殊的坏消息队列，避免一个坏消息卡主队列。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564449999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132","nickname":"尔东橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575293,"discussion_content":"死信队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654733055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118636,"user_name":"二星球","can_delete":false,"product_type":"c1","uid":1111552,"ip_address":"","ucode":"89EC5FEB98E7CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/00/2a248fd8.jpg","comment_is_top":false,"comment_ctime":1564403104,"is_pvip":false,"replies":[{"id":43532,"content":"首先，服务端是不回滚的，消费端拉10条数据后，消费位置不变，之后10条全消费成功了，offset才加10。\n\n对于有些“坏消息”始终无法成功的消费的情况，有些消息队列会把这种消息转存到一个特殊的坏消息队列，避免一个坏消息卡主队列。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449999,"ip_address":"","comment_id":118636,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师好，请教个问题，消费端向服务端拉10条数据，offset偏移10个位置，如果消费端正确处理了其中的9条数据，其中一条数据异常，消息回滚，只能把10条数据都回滚，offset这种机制无法做到回滚某几条吧？如果业务处理一条数据很耗时，这是一种弊端吧，有没有好的解决办法呢","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460501,"discussion_content":"首先，服务端是不回滚的，消费端拉10条数据后，消费位置不变，之后10条全消费成功了，offset才加10。\n\n对于有些“坏消息”始终无法成功的消费的情况，有些消息队列会把这种消息转存到一个特殊的坏消息队列，避免一个坏消息卡主队列。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564449999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6LaITPQ4Lk5fZn8ib1tfsPW8vI9icTuSwAddiajVfibPDiaDvMU2br6ZT7K0LWCKibSQuicT7sIEVmY4K7ibXY0T7UQEiag/132","nickname":"尔东橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575293,"discussion_content":"死信队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654733055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118110,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1564244235,"is_pvip":true,"replies":[{"id":43387,"content":"不是这样的，无论有多少个消费组，队列只有一份，他们（消费组）都去这个队列上读取消息，由于消费快慢不同，每个消费组都会自己维护在这个队列上的消费位置。\n消费组之间是完全互不影响的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365076,"ip_address":"","comment_id":118110,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师想问下RocketMq模型图中是消费组中每个消费者都对应一个队列以及相应的消费位置么，因为我理解应该是每个消费组都对应着一个具有相同消息的消息队列，只是相应的消费位置不同而已，这样每个消费组都能消费相同的消息","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460266,"discussion_content":"不是这样的，无论有多少个消费组，队列只有一份，他们（消费组）都去这个队列上读取消息，由于消费快慢不同，每个消费组都会自己维护在这个队列上的消费位置。\n消费组之间是完全互不影响的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182167,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","nickname":"Shen","note":"","ucode":"CFF7609A754392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52510,"discussion_content":"我也觉得老师和你说的是一个意思。队列上会记录每一个消费组的消费位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574058140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1182167,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","nickname":"Shen","note":"","ucode":"CFF7609A754392","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52655,"discussion_content":"是的😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574076578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52510,"ip_address":"","group_id":0},"score":52655,"extra":""}]},{"author":{"id":1254582,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/FqZKG3aII9YzXkfSh1Wuc2urQPZX9tZ9AwQKevDlic3mAD9C0ceVpLrSNeCLYfKAY9PtjVjVP2JBLwqRkvMoaQg/132","nickname":"晓μ","note":"","ucode":"4C6A062C43B570","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4649,"discussion_content":"我觉得老师和你说的都是一个意思。\n不同的消费组都对应同样的主题，\n消费者组内消费者存在竞争关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565618779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117909,"user_name":"Penn","can_delete":false,"product_type":"c1","uid":1044701,"ip_address":"","ucode":"C6A4AA2259068F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AkO5s3tJhibth9nelCNdU5qD4J3aEn8OpBhOHluicWgEj1SbcGC6e9rccK8DrfJtRibJT5g6iamfIibt5xX7ketDF6w/132","comment_is_top":false,"comment_ctime":1564190141,"is_pvip":false,"replies":[{"id":43205,"content":"✅","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208940,"ip_address":"","comment_id":117909,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"维护一个offset抽象，offset由单个位置变成一个集合，集合中包含多个单个位置。类似多值信号量的机制","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460173,"discussion_content":"✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125747,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566258029,"is_pvip":false,"replies":[{"id":46228,"content":"A1：是的。\nA2：我在08答疑中会详细解释这个问题，你可以看一下。\nA3：这个取决于生产者的业务代码是如何编写的。\nA4：有些消息队列会把这种“坏消息”放到一个特殊死信队列中，避免卡主整个队列消费。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566265494,"ip_address":"","comment_id":125747,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"打卡，这节讲的清晰明了，小结一下\n1：消息模型的分类？\n1-1：队列模型——点对点模式——P2P\nP-&gt;Q-&gt;C\n1-2：发布订阅模型——多对多模式——P&#47;S\n3P-&gt;3Q-&gt;3C\n这两模式的本质是一样的，可以相互转化，最大的区别在于，P&#47;S模式的一条消息可以被多个消费者多次消费。\nP——生产者\nQ——队列，逻辑上就如一个数据结构中的队列，物理上可以有多个队列或分区组成，主题在某种情况下和队列是等价的，一个主题可以对多个分区。\nC——消费者\n\n2：典型的消息模型实现？\n2-1：rabbitMQ是P2P模式的典型应用\n2-2：kafka和rocketMQ是P&#47;S模式的典型应用，注意他们是业务模式完全一样，但物理实现并不相同。\n\n3：P&#47;S简化后就是P2P，那是不是世间只有这一张消息模式？\n\n单队列并行消费我觉得应该没问题，物理单队列可以划分为多个逻辑队列，对每个逻辑队列进行消费应该可以，有点像ConcurrentHashMap。\n其实多队列简化后能成为单队列，那单队列复杂化后应该也能成为多队列。只是做减法相对容易，做加法难一点。\n\n对于下面一段内容，有几个疑问？\n如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息；在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认。\n这个确认机制很好地保证了消息传递过程中的可靠性，但是，引入这个机制在消费端带来了一个不小的问题。什么问题呢？为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则。\n也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，RocketMQ 在主题下面增加了队列的概念。\n1：老师讲的这种情况，应该是一个主题只有一个队列的时候吧？\n2：消息空洞的概念具体指什么？具体怎么形成？怎么解决？\n3：如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息——重复不会一直重复吧？应该有重试次数吧？如果有重设次数，超过重试次数，是否意味着消息就发送失败丢失啦？\n4：在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认——同样这里有重试次数吗？如果有超过重试次数有该如何处理？\n","like_count":4},{"had_liked":false,"id":121613,"user_name":"goingao","can_delete":false,"product_type":"c1","uid":1076132,"ip_address":"","ucode":"1A6A20B98F0DD7","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/a4/6ba9d110.jpg","comment_is_top":false,"comment_ctime":1565167422,"is_pvip":false,"replies":[{"id":44680,"content":"keynote画的噢","user_name":"编辑回复","user_name_real":"孙茹","uid":1336776,"ctime":1565175672,"ip_address":"","comment_id":121613,"utype":2}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"请问老师是用什么工具画的图啊","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463680,"discussion_content":"A1：是的。\nA2：我在08答疑中会详细解释这个问题，你可以看一下。\nA3：这个取决于生产者的业务代码是如何编写的。\nA4：有些消息队列会把这种“坏消息”放到一个特殊死信队列中，避免卡主整个队列消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566265494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119264,"user_name":"victory","can_delete":false,"product_type":"c1","uid":1446010,"ip_address":"","ucode":"CB8A55B4547CA0","user_header":"https://static001.geekbang.org/account/avatar/00/16/10/7a/dc14554e.jpg","comment_is_top":false,"comment_ctime":1564545597,"is_pvip":false,"replies":[{"id":43836,"content":"是的，Kafka和RocketMQ的消费模型是一样的。有一个小的区别是，Kafka把Consumer绑定到Patition上，如果Consumer数量或者分区数量变化，需要reblance，而RocketMQ它不绑定Consumer和Queue，而采用的是分时占用策略，只要Queue没有Consumer在占用，任何一个Consumer都可以来消费。\n\nRocketMQ的offset，如果我没记错的话，应该是保存在Broker的文件里面的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564626417,"ip_address":"","comment_id":119264,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，kafka里一个topic下多个partation的时候，一个partation只能被一个consumer组里的一个consumber消费，RocketMQ是不是同一个topic下多个queue，是不是每个queue同时也只能被消费者组里的一个consumer消费呢，还有就是kafka里是有一个topic用来保存没个partation的offset的，RocketMq是不是同样的呢？","like_count":4,"discussions":[{"author":{"id":1336776,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/c8/fc094eec.jpg","nickname":"大茹","note":"","ucode":"4681A1EDD8D6F7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461879,"discussion_content":"keynote画的噢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565175672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118435,"user_name":"木小柒","can_delete":false,"product_type":"c1","uid":1000802,"ip_address":"","ucode":"947439CDD0B5B1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/45/62/3c6041e7.jpg","comment_is_top":false,"comment_ctime":1564365016,"is_pvip":false,"replies":[{"id":43403,"content":"需要注意的是，消费组不是为了解决并行消费提升性能的，而是为了区分不同的订阅者，保证他们在消费的时候互不影响。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564366572,"ip_address":"","comment_id":118435,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"思考题，如果跟我上次的业务类似，能接受部分数据丢失。我们是用另一个平台解析大量的xml物料，(规则太多，专门的同学负责解析，我们提供xml规则)，那一个消费者组里面多个线程不要消费端ack确认机制，也是一种并发消费。kakfa生产端有120个分区，部署4个机器，其实就是4个消费者群组，一个群组30个线程，让他自己去摊分区，也是一种简单的并发消费。","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460814,"discussion_content":"是的，Kafka和RocketMQ的消费模型是一样的。有一个小的区别是，Kafka把Consumer绑定到Patition上，如果Consumer数量或者分区数量变化，需要reblance，而RocketMQ它不绑定Consumer和Queue，而采用的是分时占用策略，只要Queue没有Consumer在占用，任何一个Consumer都可以来消费。\n\nRocketMQ的offset，如果我没记错的话，应该是保存在Broker的文件里面的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564626417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581390,"avatar":"https://static001.geekbang.org/account/avatar/00/18/21/4e/363b1e65.jpg","nickname":"Andrew胖虎","note":"","ucode":"ED70A22E7DF733","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343842,"discussion_content":"集群模式存储在broker，广播是消费者本地","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611194529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139790,"user_name":"彼岸风铃","can_delete":false,"product_type":"c1","uid":1478229,"ip_address":"","ucode":"F0E647B68DC82B","user_header":"https://static001.geekbang.org/account/avatar/00/16/8e/55/58751406.jpg","comment_is_top":false,"comment_ctime":1570726319,"is_pvip":false,"replies":[{"id":54007,"content":"创建主题的时候可以指定。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1570756894,"ip_address":"","comment_id":139790,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，请问rocketmq中每个主题的队列数量是由什么决定的？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460408,"discussion_content":"需要注意的是，消费组不是为了解决并行消费提升性能的，而是为了区分不同的订阅者，保证他们在消费的时候互不影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564366572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119591,"user_name":"正在减肥的胖籽。","can_delete":false,"product_type":"c1","uid":1033728,"ip_address":"","ucode":"99E2E4DF599236","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c6/00/683bb4f0.jpg","comment_is_top":false,"comment_ctime":1564631566,"is_pvip":false,"replies":[{"id":43958,"content":"一般都是按照业务来建立，主题相对固定，很少变化。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564707727,"ip_address":"","comment_id":119591,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师讲的太棒了。rocketmq的topic，老师在实际的业务中怎么样去建立topic主题？阿里是建议每一种业务建立一个topic。","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460969,"discussion_content":"一般都是按照业务来建立，主题相对固定，很少变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564707727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119306,"user_name":"宋晓明","can_delete":false,"product_type":"c1","uid":1146507,"ip_address":"","ucode":"DC866DCE2FBA9E","user_header":"https://static001.geekbang.org/account/avatar/00/11/7e/8b/3cc461b3.jpg","comment_is_top":false,"comment_ctime":1564556859,"is_pvip":false,"replies":[{"id":43845,"content":"后面还有大量拔拔干的干货呢，哈哈。\n\n你这个需求，本质上是希望进行限流。消息队列是不支持限流功能的。你可以考虑用令牌桶来进行限流。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564627229,"ip_address":"","comment_id":119306,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"哇塞 刚第三节就听见我想听的干货了 老师 太赞了 问个问题 mq也可以用来请求削峰的，比如写sql 一个sql最大支持并发写2000&#47;s ，超过2k可能就宕机了，producer 以6000&#47;s 输送broker，kafka是怎么保证让消费者以最大并发2k&#47;s的速度消费的？有什么配置吗？还是消费者自己实现？望老师解惑 ","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460838,"discussion_content":"后面还有大量拔拔干的干货呢，哈哈。\n\n你这个需求，本质上是希望进行限流。消息队列是不支持限流功能的。你可以考虑用令牌桶来进行限流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564627229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118701,"user_name":"black","can_delete":false,"product_type":"c1","uid":1593345,"ip_address":"","ucode":"9AD756BD5D1C4D","user_header":"https://static001.geekbang.org/account/avatar/00/18/50/01/5bc28ed8.jpg","comment_is_top":false,"comment_ctime":1564416842,"is_pvip":false,"replies":[{"id":43537,"content":"需求简单的话，可以用用，基本功能和可靠性是可以保证的。Redis但和主流的消息队列相比，性能和功能的都有一些差距。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564450486,"ip_address":"","comment_id":118701,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师你好，Redis也有队列和pub&#47;sub模型，能和这些mq一起对比一下嘛","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460838,"discussion_content":"后面还有大量拔拔干的干货呢，哈哈。\n\n你这个需求，本质上是希望进行限流。消息队列是不支持限流功能的。你可以考虑用令牌桶来进行限流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564627229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118263,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1564304401,"is_pvip":false,"replies":[{"id":43398,"content":"没错。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564366051,"ip_address":"","comment_id":118263,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"要保证严格顺序，必须指定这个顺序的消息在同一个队列中，也就是必须保险这些消息路由到的队列是一个值吧？否则同一主题，多个队列的原因没法保证顺序，只是单队列纬度有序","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460536,"discussion_content":"需求简单的话，可以用用，基本功能和可靠性是可以保证的。Redis但和主流的消息队列相比，性能和功能的都有一些差距。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564450486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118086,"user_name":"HSJ,","can_delete":false,"product_type":"c1","uid":1512727,"ip_address":"","ucode":"1C96797846BD6C","user_header":"https://static001.geekbang.org/account/avatar/00/17/15/17/aec71e3f.jpg","comment_is_top":false,"comment_ctime":1564234545,"is_pvip":false,"replies":[{"id":43274,"content":"从逻辑上说，你可以认为是保存在consumer group里的。\n物理实现上，不同的消息队列不一样，有的保存在Broker中，有的保存在一个特殊的队列中。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564239950,"ip_address":"","comment_id":118086,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"请问一下，offset是保存在consumer group 还是保存在topic里","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460332,"discussion_content":"没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564366051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125747,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566258029,"is_pvip":false,"replies":[{"id":46228,"content":"A1：是的。\nA2：我在08答疑中会详细解释这个问题，你可以看一下。\nA3：这个取决于生产者的业务代码是如何编写的。\nA4：有些消息队列会把这种“坏消息”放到一个特殊死信队列中，避免卡主整个队列消费。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566265494,"ip_address":"","comment_id":125747,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"打卡，这节讲的清晰明了，小结一下\n1：消息模型的分类？\n1-1：队列模型——点对点模式——P2P\nP-&gt;Q-&gt;C\n1-2：发布订阅模型——多对多模式——P&#47;S\n3P-&gt;3Q-&gt;3C\n这两模式的本质是一样的，可以相互转化，最大的区别在于，P&#47;S模式的一条消息可以被多个消费者多次消费。\nP——生产者\nQ——队列，逻辑上就如一个数据结构中的队列，物理上可以有多个队列或分区组成，主题在某种情况下和队列是等价的，一个主题可以对多个分区。\nC——消费者\n\n2：典型的消息模型实现？\n2-1：rabbitMQ是P2P模式的典型应用\n2-2：kafka和rocketMQ是P&#47;S模式的典型应用，注意他们是业务模式完全一样，但物理实现并不相同。\n\n3：P&#47;S简化后就是P2P，那是不是世间只有这一张消息模式？\n\n单队列并行消费我觉得应该没问题，物理单队列可以划分为多个逻辑队列，对每个逻辑队列进行消费应该可以，有点像ConcurrentHashMap。\n其实多队列简化后能成为单队列，那单队列复杂化后应该也能成为多队列。只是做减法相对容易，做加法难一点。\n\n对于下面一段内容，有几个疑问？\n如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息；在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认。\n这个确认机制很好地保证了消息传递过程中的可靠性，但是，引入这个机制在消费端带来了一个不小的问题。什么问题呢？为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则。\n也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，RocketMQ 在主题下面增加了队列的概念。\n1：老师讲的这种情况，应该是一个主题只有一个队列的时候吧？\n2：消息空洞的概念具体指什么？具体怎么形成？怎么解决？\n3：如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息——重复不会一直重复吧？应该有重试次数吧？如果有重设次数，超过重试次数，是否意味着消息就发送失败丢失啦？\n4：在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认——同样这里有重试次数吗？如果有超过重试次数有该如何处理？\n","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463680,"discussion_content":"A1：是的。\nA2：我在08答疑中会详细解释这个问题，你可以看一下。\nA3：这个取决于生产者的业务代码是如何编写的。\nA4：有些消息队列会把这种“坏消息”放到一个特殊死信队列中，避免卡主整个队列消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566265494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121613,"user_name":"goingao","can_delete":false,"product_type":"c1","uid":1076132,"ip_address":"","ucode":"1A6A20B98F0DD7","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/a4/6ba9d110.jpg","comment_is_top":false,"comment_ctime":1565167422,"is_pvip":false,"replies":[{"id":44680,"content":"keynote画的噢","user_name":"编辑回复","user_name_real":"孙茹","uid":1336776,"ctime":1565175672,"ip_address":"","comment_id":121613,"utype":2}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"请问老师是用什么工具画的图啊","like_count":4,"discussions":[{"author":{"id":1336776,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/c8/fc094eec.jpg","nickname":"大茹","note":"","ucode":"4681A1EDD8D6F7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461879,"discussion_content":"keynote画的噢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565175672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119264,"user_name":"victory","can_delete":false,"product_type":"c1","uid":1446010,"ip_address":"","ucode":"CB8A55B4547CA0","user_header":"https://static001.geekbang.org/account/avatar/00/16/10/7a/dc14554e.jpg","comment_is_top":false,"comment_ctime":1564545597,"is_pvip":false,"replies":[{"id":43836,"content":"是的，Kafka和RocketMQ的消费模型是一样的。有一个小的区别是，Kafka把Consumer绑定到Patition上，如果Consumer数量或者分区数量变化，需要reblance，而RocketMQ它不绑定Consumer和Queue，而采用的是分时占用策略，只要Queue没有Consumer在占用，任何一个Consumer都可以来消费。\n\nRocketMQ的offset，如果我没记错的话，应该是保存在Broker的文件里面的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564626417,"ip_address":"","comment_id":119264,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，kafka里一个topic下多个partation的时候，一个partation只能被一个consumer组里的一个consumber消费，RocketMQ是不是同一个topic下多个queue，是不是每个queue同时也只能被消费者组里的一个consumer消费呢，还有就是kafka里是有一个topic用来保存没个partation的offset的，RocketMq是不是同样的呢？","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460814,"discussion_content":"是的，Kafka和RocketMQ的消费模型是一样的。有一个小的区别是，Kafka把Consumer绑定到Patition上，如果Consumer数量或者分区数量变化，需要reblance，而RocketMQ它不绑定Consumer和Queue，而采用的是分时占用策略，只要Queue没有Consumer在占用，任何一个Consumer都可以来消费。\n\nRocketMQ的offset，如果我没记错的话，应该是保存在Broker的文件里面的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564626417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581390,"avatar":"https://static001.geekbang.org/account/avatar/00/18/21/4e/363b1e65.jpg","nickname":"Andrew胖虎","note":"","ucode":"ED70A22E7DF733","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343842,"discussion_content":"集群模式存储在broker，广播是消费者本地","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611194529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118435,"user_name":"木小柒","can_delete":false,"product_type":"c1","uid":1000802,"ip_address":"","ucode":"947439CDD0B5B1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/45/62/3c6041e7.jpg","comment_is_top":false,"comment_ctime":1564365016,"is_pvip":false,"replies":[{"id":43403,"content":"需要注意的是，消费组不是为了解决并行消费提升性能的，而是为了区分不同的订阅者，保证他们在消费的时候互不影响。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564366572,"ip_address":"","comment_id":118435,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"思考题，如果跟我上次的业务类似，能接受部分数据丢失。我们是用另一个平台解析大量的xml物料，(规则太多，专门的同学负责解析，我们提供xml规则)，那一个消费者组里面多个线程不要消费端ack确认机制，也是一种并发消费。kakfa生产端有120个分区，部署4个机器，其实就是4个消费者群组，一个群组30个线程，让他自己去摊分区，也是一种简单的并发消费。","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460408,"discussion_content":"需要注意的是，消费组不是为了解决并行消费提升性能的，而是为了区分不同的订阅者，保证他们在消费的时候互不影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564366572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139790,"user_name":"彼岸风铃","can_delete":false,"product_type":"c1","uid":1478229,"ip_address":"","ucode":"F0E647B68DC82B","user_header":"https://static001.geekbang.org/account/avatar/00/16/8e/55/58751406.jpg","comment_is_top":false,"comment_ctime":1570726319,"is_pvip":false,"replies":[{"id":54007,"content":"创建主题的时候可以指定。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1570756894,"ip_address":"","comment_id":139790,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，请问rocketmq中每个主题的队列数量是由什么决定的？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470115,"discussion_content":"创建主题的时候可以指定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570756894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119591,"user_name":"正在减肥的胖籽。","can_delete":false,"product_type":"c1","uid":1033728,"ip_address":"","ucode":"99E2E4DF599236","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c6/00/683bb4f0.jpg","comment_is_top":false,"comment_ctime":1564631566,"is_pvip":false,"replies":[{"id":43958,"content":"一般都是按照业务来建立，主题相对固定，很少变化。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564707727,"ip_address":"","comment_id":119591,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师讲的太棒了。rocketmq的topic，老师在实际的业务中怎么样去建立topic主题？阿里是建议每一种业务建立一个topic。","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470115,"discussion_content":"创建主题的时候可以指定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570756894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119306,"user_name":"宋晓明","can_delete":false,"product_type":"c1","uid":1146507,"ip_address":"","ucode":"DC866DCE2FBA9E","user_header":"https://static001.geekbang.org/account/avatar/00/11/7e/8b/3cc461b3.jpg","comment_is_top":false,"comment_ctime":1564556859,"is_pvip":false,"replies":[{"id":43845,"content":"后面还有大量拔拔干的干货呢，哈哈。\n\n你这个需求，本质上是希望进行限流。消息队列是不支持限流功能的。你可以考虑用令牌桶来进行限流。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564627229,"ip_address":"","comment_id":119306,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"哇塞 刚第三节就听见我想听的干货了 老师 太赞了 问个问题 mq也可以用来请求削峰的，比如写sql 一个sql最大支持并发写2000&#47;s ，超过2k可能就宕机了，producer 以6000&#47;s 输送broker，kafka是怎么保证让消费者以最大并发2k&#47;s的速度消费的？有什么配置吗？还是消费者自己实现？望老师解惑 ","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460969,"discussion_content":"一般都是按照业务来建立，主题相对固定，很少变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564707727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118701,"user_name":"black","can_delete":false,"product_type":"c1","uid":1593345,"ip_address":"","ucode":"9AD756BD5D1C4D","user_header":"https://static001.geekbang.org/account/avatar/00/18/50/01/5bc28ed8.jpg","comment_is_top":false,"comment_ctime":1564416842,"is_pvip":false,"replies":[{"id":43537,"content":"需求简单的话，可以用用，基本功能和可靠性是可以保证的。Redis但和主流的消息队列相比，性能和功能的都有一些差距。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564450486,"ip_address":"","comment_id":118701,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师你好，Redis也有队列和pub&#47;sub模型，能和这些mq一起对比一下嘛","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460536,"discussion_content":"需求简单的话，可以用用，基本功能和可靠性是可以保证的。Redis但和主流的消息队列相比，性能和功能的都有一些差距。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564450486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118263,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1564304401,"is_pvip":false,"replies":[{"id":43398,"content":"没错。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564366051,"ip_address":"","comment_id":118263,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"要保证严格顺序，必须指定这个顺序的消息在同一个队列中，也就是必须保险这些消息路由到的队列是一个值吧？否则同一主题，多个队列的原因没法保证顺序，只是单队列纬度有序","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460332,"discussion_content":"没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564366051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118086,"user_name":"HSJ,","can_delete":false,"product_type":"c1","uid":1512727,"ip_address":"","ucode":"1C96797846BD6C","user_header":"https://static001.geekbang.org/account/avatar/00/17/15/17/aec71e3f.jpg","comment_is_top":false,"comment_ctime":1564234545,"is_pvip":false,"replies":[{"id":43274,"content":"从逻辑上说，你可以认为是保存在consumer group里的。\n物理实现上，不同的消息队列不一样，有的保存在Broker中，有的保存在一个特殊的队列中。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564239950,"ip_address":"","comment_id":118086,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"请问一下，offset是保存在consumer group 还是保存在topic里","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460257,"discussion_content":"从逻辑上说，你可以认为是保存在consumer group里的。\n物理实现上，不同的消息队列不一样，有的保存在Broker中，有的保存在一个特殊的队列中。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564239950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512727,"avatar":"https://static001.geekbang.org/account/avatar/00/17/15/17/aec71e3f.jpg","nickname":"HSJ,","note":"","ucode":"1C96797846BD6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3200,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564299431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117893,"user_name":"IF-Processing","can_delete":false,"product_type":"c1","uid":1205736,"ip_address":"","ucode":"8298C3C9320D94","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/e8/d1e52dbb.jpg","comment_is_top":false,"comment_ctime":1564184535,"is_pvip":true,"replies":[{"id":43201,"content":"第一个问题，据我所知，大部分消息队列都是这样的：在任何一个时刻，某个队列，在一个消费组（Consumer Group ）内，只能有一个消费者占用。\n\n这么设计是为了保证严格顺序。\n\n所以在需要严格顺序的场景下，一般都建议消费者的数量和队列(kafka叫分区）保持一致。\n\n如果不要求严格顺序的话，单个队列上，是可以多个消费者并行消费的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208576,"ip_address":"","comment_id":117893,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，是目前所有的消息队列都是只能接受一个消费者消费完成后才能给下一个消费者吗？这样还有多消费者的意义吗？或者说是通过其他手段，比如获取后直接标记消费成功，如果处理失败，重新放回队列尾部这类的思路来实现并发多消费者呢？","like_count":3},{"had_liked":false,"id":234969,"user_name":"子非鱼","can_delete":false,"product_type":"c1","uid":1621660,"ip_address":"","ucode":"020DA0784E728C","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","comment_is_top":false,"comment_ctime":1594861081,"is_pvip":false,"replies":[{"id":86777,"content":"RocketMQ采用的策略和你的理解是一样的。\n像Kafka就比较粗暴，直接定一个消息保留时长，过期的消息就会被自动删除，它不保证在删除之前是不是还有订阅没有消费这些消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1594900905,"ip_address":"","comment_id":234969,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师讲的挺好的，有个问题想请教下。\n是关于消息什么时候删除的。broker是不是得监控所有的group消费位置，每个offset在这个消息之后，才会去删除队列的消息吗。","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460163,"discussion_content":"第一个问题，据我所知，大部分消息队列都是这样的：在任何一个时刻，某个队列，在一个消费组（Consumer Group ）内，只能有一个消费者占用。\n\n这么设计是为了保证严格顺序。\n\n所以在需要严格顺序的场景下，一般都建议消费者的数量和队列(kafka叫分区）保持一致。\n\n如果不要求严格顺序的话，单个队列上，是可以多个消费者并行消费的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182355,"user_name":"释然","can_delete":false,"product_type":"c1","uid":1264381,"ip_address":"","ucode":"23BE77AB5DCDF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/fd/047518b0.jpg","comment_is_top":false,"comment_ctime":1582772475,"is_pvip":false,"replies":[{"id":70647,"content":"这块大多数MQ设计都是很灵活的，大部分情况下不用关心Queue，哪个queue有消息就取哪个queue，这些都是自动的。\n\n你也可以指定Queue消费，后面我们会讲到，哪些场景下需要指定分区（队列）生产和消费。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582802205,"ip_address":"","comment_id":182355,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"RocketMQ 的模型中 Topic 中的 queue 对 Consumer1 来说是否为透明的？ ","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501563,"discussion_content":"RocketMQ采用的策略和你的理解是一样的。\n像Kafka就比较粗暴，直接定一个消息保留时长，过期的消息就会被自动删除，它不保证在删除之前是不是还有订阅没有消费这些消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594900905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167280,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1577756289,"is_pvip":false,"replies":[{"id":65563,"content":"多个消费者不能“同时”消费一个队列，但是分时消费是可以的，比如RocketMQ就是这么实现的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1578274389,"ip_address":"","comment_id":167280,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，对于一个消费者组，里面的多个消费者消费的是一个主题下的不同的队列吧，允许出现多个消费者消费同一队列的情况吗","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485316,"discussion_content":"这块大多数MQ设计都是很灵活的，大部分情况下不用关心Queue，哪个queue有消息就取哪个queue，这些都是自动的。\n\n你也可以指定Queue消费，后面我们会讲到，哪些场景下需要指定分区（队列）生产和消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582802205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156208,"user_name":"ezekiel","can_delete":false,"product_type":"c1","uid":1158795,"ip_address":"","ucode":"AB4AB6FA8612D8","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/8b/43ce01ca.jpg","comment_is_top":false,"comment_ctime":1574836930,"is_pvip":false,"replies":[{"id":60085,"content":"这个问题我们课程中有专门一节课来讲解：“16 | 缓存策略：如何使用缓存来减少磁盘IO？”","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574903215,"ip_address":"","comment_id":156208,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师您好！\n\n如何保证缓存和数据库的一致性？是否可以使用消息队列？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479807,"discussion_content":"多个消费者不能“同时”消费一个队列，但是分时消费是可以的，比如RocketMQ就是这么实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578274389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152964,"user_name":"Shen","can_delete":false,"product_type":"c1","uid":1182167,"ip_address":"","ucode":"CFF7609A754392","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","comment_is_top":false,"comment_ctime":1574130238,"is_pvip":false,"replies":[{"id":59498,"content":"什么时机删除旧消息，各种MQ的实现也不太一样。一般的策略都是定期删除比较旧的消息，一般的删除策略是消息保留多长时间。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574643383,"ip_address":"","comment_id":152964,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"1、队列模型，就是按照队列的数据结构来设计的，先进先出，消息只能被消费一次。\n2、主题模型中的队列，同样也是先进先出，但是只是针对每一个消费组而言的，整体来看就不一定是先进先出了；另外，主题中的队列也不是只能被消费一次，因为会有多个消费组进行消费。\n那么问题来了，主题中的队列什么时候进行删除被消费完成的消息呢？以及如何判断哪些消息要被删除？\n\n个人理解应该是在最后一个offset之前的消息会被删除，因为所有的消费组都已经成功消费掉最后一个offset之前的消息了。\n\n请老师指点。","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476033,"discussion_content":"这个问题我们课程中有专门一节课来讲解：“16 | 缓存策略：如何使用缓存来减少磁盘IO？”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574903215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151492,"user_name":"Dexter","can_delete":false,"product_type":"c1","uid":1366365,"ip_address":"","ucode":"2A2AAB67B04AC1","user_header":"https://static001.geekbang.org/account/avatar/00/14/d9/5d/46c80054.jpg","comment_is_top":false,"comment_ctime":1573730462,"is_pvip":false,"replies":[{"id":58288,"content":"你的理解总体上是没问题的。\n\n对于消费来说，订阅的就是主题不是队列。\n\n只是有的MQ它没有“主题（Topic）”的概念，它的主题是叫“队列（Queue）”，其实这个队列和主题是一样的概念，这个是容易让人误解的地方。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573779459,"ip_address":"","comment_id":151492,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师您好, 结合文章和评论, 关于 RocketMQ 有几个概念不知道理解的对不对.\n按照文章中订单这个例子:\n0. 生产者: 可以生产订单信息, 可能会是 N 个, 生产者将订单信息会发送到主题的任意一个队列上\n1. 队列: 用于存储订单信息， 一个主题会有 M 个队列\n2. 消费组: 消费组可能是风控系统、分析系统、支付系统等各种需要接受订单信息中的一个\n3. 消费者: 消费组中的一个实例，可以按照消费组定义的逻辑去消费\n已订阅的不同的消费组都会消费  &quot;所有队列上&quot;  的 &quot;所有订单信息&quot;, &quot;一个消费组&quot;  中的  &quot;一个消费者&quot;  一次只能消费  &quot;一个队列&quot;  中的  &quot;一个订单信息&quot;, 所以多个消费者就可以在不同的队列上同时消费多个订单信息了.\n并且由于每个消费组的逻辑和处理时间都是不一样的, 所以需要在队列上维护每个消费组的消费位置.\n\n那么问题是:\n消费组&#47;消费者应该是订阅了一个主题而不是主体中的一个队列吧? 不然新增队列的话, 发送到那个队列中的消息就不会被消费了","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475003,"discussion_content":"什么时机删除旧消息，各种MQ的实现也不太一样。一般的策略都是定期删除比较旧的消息，一般的删除策略是消息保留多长时间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574643383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151403,"user_name":"唯。💍👑🍭","can_delete":false,"product_type":"c1","uid":1201260,"ip_address":"","ucode":"3990B160474F92","user_header":"https://static001.geekbang.org/account/avatar/00/12/54/6c/1fecd912.jpg","comment_is_top":false,"comment_ctime":1573713893,"is_pvip":false,"replies":[{"id":58284,"content":"是的，如果消费者的实例数少于队列数，每个消费者可以消费多个队列。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573778888,"ip_address":"","comment_id":151403,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"如果消费者只有一台机器，但是队列有多个，是不是这个消费者会同时消费多个队列，队列跟消费者实例之间怎么绑定关系的啊","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474498,"discussion_content":"你的理解总体上是没问题的。\n\n对于消费来说，订阅的就是主题不是队列。\n\n只是有的MQ它没有“主题（Topic）”的概念，它的主题是叫“队列（Queue）”，其实这个队列和主题是一样的概念，这个是容易让人误解的地方。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573779459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147035,"user_name":"书中迷梦","can_delete":false,"product_type":"c1","uid":1103010,"ip_address":"","ucode":"1C6B697F41698F","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/a2/fa41c8a8.jpg","comment_is_top":false,"comment_ctime":1572770359,"is_pvip":false,"replies":[{"id":56814,"content":"只需要发送一次，到其中的一个队列中就可以了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572829845,"ip_address":"","comment_id":147035,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"对于RocketMQ有个疑惑点，使用的时候，不应该是生产者只向消息服务端发送一次消息，到某个主题下面吗？如果一个主题有多个队列（因为被多个消费者订阅而产生多个队列），难道生产端要发送多次消息？这好像不符合逻辑吧","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474462,"discussion_content":"是的，如果消费者的实例数少于队列数，每个消费者可以消费多个队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573778888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144458,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":1595382,"ip_address":"","ucode":"A77322C4E07B2D","user_header":"https://static001.geekbang.org/account/avatar/00/18/57/f6/2c7ac1ad.jpg","comment_is_top":false,"comment_ctime":1571927876,"is_pvip":false,"replies":[{"id":55713,"content":"服务端是可以知道有多少个消费组，以及每个消费组的消费位置的，所以可以计算出哪些消息是可以安全删除的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571970962,"ip_address":"","comment_id":144458,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师您好，看到消费位置的概念我有一个问题，就是RocketMQ队列中的消息什么时候删除呢？我的理解是所有消费组都消费了这个消息之后，但是RocketMQ的队列会知道有多少个消费组吗？有点搞不明白","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473107,"discussion_content":"只需要发送一次，到其中的一个队列中就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572829845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117893,"user_name":"IF-Processing","can_delete":false,"product_type":"c1","uid":1205736,"ip_address":"","ucode":"8298C3C9320D94","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/e8/d1e52dbb.jpg","comment_is_top":false,"comment_ctime":1564184535,"is_pvip":true,"replies":[{"id":43201,"content":"第一个问题，据我所知，大部分消息队列都是这样的：在任何一个时刻，某个队列，在一个消费组（Consumer Group ）内，只能有一个消费者占用。\n\n这么设计是为了保证严格顺序。\n\n所以在需要严格顺序的场景下，一般都建议消费者的数量和队列(kafka叫分区）保持一致。\n\n如果不要求严格顺序的话，单个队列上，是可以多个消费者并行消费的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208576,"ip_address":"","comment_id":117893,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，是目前所有的消息队列都是只能接受一个消费者消费完成后才能给下一个消费者吗？这样还有多消费者的意义吗？或者说是通过其他手段，比如获取后直接标记消费成功，如果处理失败，重新放回队列尾部这类的思路来实现并发多消费者呢？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460163,"discussion_content":"第一个问题，据我所知，大部分消息队列都是这样的：在任何一个时刻，某个队列，在一个消费组（Consumer Group ）内，只能有一个消费者占用。\n\n这么设计是为了保证严格顺序。\n\n所以在需要严格顺序的场景下，一般都建议消费者的数量和队列(kafka叫分区）保持一致。\n\n如果不要求严格顺序的话，单个队列上，是可以多个消费者并行消费的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234969,"user_name":"子非鱼","can_delete":false,"product_type":"c1","uid":1621660,"ip_address":"","ucode":"020DA0784E728C","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","comment_is_top":false,"comment_ctime":1594861081,"is_pvip":false,"replies":[{"id":86777,"content":"RocketMQ采用的策略和你的理解是一样的。\n像Kafka就比较粗暴，直接定一个消息保留时长，过期的消息就会被自动删除，它不保证在删除之前是不是还有订阅没有消费这些消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1594900905,"ip_address":"","comment_id":234969,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师讲的挺好的，有个问题想请教下。\n是关于消息什么时候删除的。broker是不是得监控所有的group消费位置，每个offset在这个消息之后，才会去删除队列的消息吗。","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501563,"discussion_content":"RocketMQ采用的策略和你的理解是一样的。\n像Kafka就比较粗暴，直接定一个消息保留时长，过期的消息就会被自动删除，它不保证在删除之前是不是还有订阅没有消费这些消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594900905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182355,"user_name":"释然","can_delete":false,"product_type":"c1","uid":1264381,"ip_address":"","ucode":"23BE77AB5DCDF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/fd/047518b0.jpg","comment_is_top":false,"comment_ctime":1582772475,"is_pvip":false,"replies":[{"id":70647,"content":"这块大多数MQ设计都是很灵活的，大部分情况下不用关心Queue，哪个queue有消息就取哪个queue，这些都是自动的。\n\n你也可以指定Queue消费，后面我们会讲到，哪些场景下需要指定分区（队列）生产和消费。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582802205,"ip_address":"","comment_id":182355,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"RocketMQ 的模型中 Topic 中的 queue 对 Consumer1 来说是否为透明的？ ","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485316,"discussion_content":"这块大多数MQ设计都是很灵活的，大部分情况下不用关心Queue，哪个queue有消息就取哪个queue，这些都是自动的。\n\n你也可以指定Queue消费，后面我们会讲到，哪些场景下需要指定分区（队列）生产和消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582802205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167280,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1577756289,"is_pvip":false,"replies":[{"id":65563,"content":"多个消费者不能“同时”消费一个队列，但是分时消费是可以的，比如RocketMQ就是这么实现的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1578274389,"ip_address":"","comment_id":167280,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，对于一个消费者组，里面的多个消费者消费的是一个主题下的不同的队列吧，允许出现多个消费者消费同一队列的情况吗","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479807,"discussion_content":"多个消费者不能“同时”消费一个队列，但是分时消费是可以的，比如RocketMQ就是这么实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578274389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156208,"user_name":"ezekiel","can_delete":false,"product_type":"c1","uid":1158795,"ip_address":"","ucode":"AB4AB6FA8612D8","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/8b/43ce01ca.jpg","comment_is_top":false,"comment_ctime":1574836930,"is_pvip":false,"replies":[{"id":60085,"content":"这个问题我们课程中有专门一节课来讲解：“16 | 缓存策略：如何使用缓存来减少磁盘IO？”","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574903215,"ip_address":"","comment_id":156208,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师您好！\n\n如何保证缓存和数据库的一致性？是否可以使用消息队列？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476033,"discussion_content":"这个问题我们课程中有专门一节课来讲解：“16 | 缓存策略：如何使用缓存来减少磁盘IO？”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574903215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152964,"user_name":"Shen","can_delete":false,"product_type":"c1","uid":1182167,"ip_address":"","ucode":"CFF7609A754392","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/d7/ffe7b0bf.jpg","comment_is_top":false,"comment_ctime":1574130238,"is_pvip":false,"replies":[{"id":59498,"content":"什么时机删除旧消息，各种MQ的实现也不太一样。一般的策略都是定期删除比较旧的消息，一般的删除策略是消息保留多长时间。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574643383,"ip_address":"","comment_id":152964,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"1、队列模型，就是按照队列的数据结构来设计的，先进先出，消息只能被消费一次。\n2、主题模型中的队列，同样也是先进先出，但是只是针对每一个消费组而言的，整体来看就不一定是先进先出了；另外，主题中的队列也不是只能被消费一次，因为会有多个消费组进行消费。\n那么问题来了，主题中的队列什么时候进行删除被消费完成的消息呢？以及如何判断哪些消息要被删除？\n\n个人理解应该是在最后一个offset之前的消息会被删除，因为所有的消费组都已经成功消费掉最后一个offset之前的消息了。\n\n请老师指点。","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475003,"discussion_content":"什么时机删除旧消息，各种MQ的实现也不太一样。一般的策略都是定期删除比较旧的消息，一般的删除策略是消息保留多长时间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574643383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151492,"user_name":"Dexter","can_delete":false,"product_type":"c1","uid":1366365,"ip_address":"","ucode":"2A2AAB67B04AC1","user_header":"https://static001.geekbang.org/account/avatar/00/14/d9/5d/46c80054.jpg","comment_is_top":false,"comment_ctime":1573730462,"is_pvip":false,"replies":[{"id":58288,"content":"你的理解总体上是没问题的。\n\n对于消费来说，订阅的就是主题不是队列。\n\n只是有的MQ它没有“主题（Topic）”的概念，它的主题是叫“队列（Queue）”，其实这个队列和主题是一样的概念，这个是容易让人误解的地方。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573779459,"ip_address":"","comment_id":151492,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师您好, 结合文章和评论, 关于 RocketMQ 有几个概念不知道理解的对不对.\n按照文章中订单这个例子:\n0. 生产者: 可以生产订单信息, 可能会是 N 个, 生产者将订单信息会发送到主题的任意一个队列上\n1. 队列: 用于存储订单信息， 一个主题会有 M 个队列\n2. 消费组: 消费组可能是风控系统、分析系统、支付系统等各种需要接受订单信息中的一个\n3. 消费者: 消费组中的一个实例，可以按照消费组定义的逻辑去消费\n已订阅的不同的消费组都会消费  &quot;所有队列上&quot;  的 &quot;所有订单信息&quot;, &quot;一个消费组&quot;  中的  &quot;一个消费者&quot;  一次只能消费  &quot;一个队列&quot;  中的  &quot;一个订单信息&quot;, 所以多个消费者就可以在不同的队列上同时消费多个订单信息了.\n并且由于每个消费组的逻辑和处理时间都是不一样的, 所以需要在队列上维护每个消费组的消费位置.\n\n那么问题是:\n消费组&#47;消费者应该是订阅了一个主题而不是主体中的一个队列吧? 不然新增队列的话, 发送到那个队列中的消息就不会被消费了","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474498,"discussion_content":"你的理解总体上是没问题的。\n\n对于消费来说，订阅的就是主题不是队列。\n\n只是有的MQ它没有“主题（Topic）”的概念，它的主题是叫“队列（Queue）”，其实这个队列和主题是一样的概念，这个是容易让人误解的地方。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573779459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151403,"user_name":"唯。💍👑🍭","can_delete":false,"product_type":"c1","uid":1201260,"ip_address":"","ucode":"3990B160474F92","user_header":"https://static001.geekbang.org/account/avatar/00/12/54/6c/1fecd912.jpg","comment_is_top":false,"comment_ctime":1573713893,"is_pvip":false,"replies":[{"id":58284,"content":"是的，如果消费者的实例数少于队列数，每个消费者可以消费多个队列。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573778888,"ip_address":"","comment_id":151403,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"如果消费者只有一台机器，但是队列有多个，是不是这个消费者会同时消费多个队列，队列跟消费者实例之间怎么绑定关系的啊","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474462,"discussion_content":"是的，如果消费者的实例数少于队列数，每个消费者可以消费多个队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573778888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147035,"user_name":"书中迷梦","can_delete":false,"product_type":"c1","uid":1103010,"ip_address":"","ucode":"1C6B697F41698F","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/a2/fa41c8a8.jpg","comment_is_top":false,"comment_ctime":1572770359,"is_pvip":false,"replies":[{"id":56814,"content":"只需要发送一次，到其中的一个队列中就可以了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572829845,"ip_address":"","comment_id":147035,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"对于RocketMQ有个疑惑点，使用的时候，不应该是生产者只向消息服务端发送一次消息，到某个主题下面吗？如果一个主题有多个队列（因为被多个消费者订阅而产生多个队列），难道生产端要发送多次消息？这好像不符合逻辑吧","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473107,"discussion_content":"只需要发送一次，到其中的一个队列中就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572829845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144458,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":1595382,"ip_address":"","ucode":"A77322C4E07B2D","user_header":"https://static001.geekbang.org/account/avatar/00/18/57/f6/2c7ac1ad.jpg","comment_is_top":false,"comment_ctime":1571927876,"is_pvip":false,"replies":[{"id":55713,"content":"服务端是可以知道有多少个消费组，以及每个消费组的消费位置的，所以可以计算出哪些消息是可以安全删除的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571970962,"ip_address":"","comment_id":144458,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师您好，看到消费位置的概念我有一个问题，就是RocketMQ队列中的消息什么时候删除呢？我的理解是所有消费组都消费了这个消息之后，但是RocketMQ的队列会知道有多少个消费组吗？有点搞不明白","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471950,"discussion_content":"服务端是可以知道有多少个消费组，以及每个消费组的消费位置的，所以可以计算出哪些消息是可以安全删除的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571970962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134062,"user_name":"风随心动","can_delete":false,"product_type":"c1","uid":1613918,"ip_address":"","ucode":"E6797D80BF089A","user_header":"https://static001.geekbang.org/account/avatar/00/18/a0/5e/2b705812.jpg","comment_is_top":false,"comment_ctime":1568730495,"is_pvip":false,"replies":[{"id":51435,"content":"消费者数量少于队列数量是没关系的，每个消费者多负责几个队列就行了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568769469,"ip_address":"","comment_id":134062,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师，请问，一个消费组多个消费者，如5个，此时topic中的队列是7个，那么是不是有两个得不到消费？如果都会被消费，则消费采用的方法是什么？","like_count":2},{"had_liked":false,"id":126380,"user_name":"cfanbo","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/269eb3d6.jpg","comment_is_top":false,"comment_ctime":1566376347,"is_pvip":false,"replies":[{"id":46819,"content":"都可以，一般订阅的时候可以通过参数来选择。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566435264,"ip_address":"","comment_id":126380,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"一个主题已经有部分数据，这时新增加一个订阅者，这时消费的第一条消息是主题的第一条信息还是当前消费者订阅时间点以后的新增加的那条记录？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467606,"discussion_content":"消费者数量少于队列数量是没关系的，每个消费者多负责几个队列就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568769469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122471,"user_name":"Geek_bbe9ea","can_delete":false,"product_type":"c1","uid":1336413,"ip_address":"","ucode":"4A0DA7C81D233C","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/5d/c8e2663b.jpg","comment_is_top":false,"comment_ctime":1565400685,"is_pvip":false,"replies":[{"id":44947,"content":"2个consumer，你可以继续看下08答疑这节课，有补充的详细讲解。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565402567,"ip_address":"","comment_id":122471,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"RocketMq的图看的不是很懂，图里到底是一个consumer 还是两个？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462267,"discussion_content":"2个consumer，你可以继续看下08答疑这节课，有补充的详细讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565402567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336413,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/5d/c8e2663b.jpg","nickname":"Geek_bbe9ea","note":"","ucode":"4A0DA7C81D233C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4418,"discussion_content":"同一个consumer group下的两个consumer？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565405270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118882,"user_name":"kane","can_delete":false,"product_type":"c1","uid":1121849,"ip_address":"","ucode":"1B2735A33AF53E","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/39/923ed5b7.jpg","comment_is_top":false,"comment_ctime":1564457432,"is_pvip":false,"replies":[{"id":43697,"content":"要保证严格顺序，生产的时候需要指定队列发送。\n如果需要兼容队列数量变化，可以使用一致性哈希算法来分配队列。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564536455,"ip_address":"","comment_id":118882,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师，第一次发言，希望老师可以帮忙解答。\n 上面讲到的rocket mq队列数可以随意配置，如果更改了队列大写，顺序消费是不是没法保证，这个有没有什么比较好的解决办法。","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460635,"discussion_content":"要保证严格顺序，生产的时候需要指定队列发送。\n如果需要兼容队列数量变化，可以使用一致性哈希算法来分配队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564536455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118436,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1564365018,"is_pvip":false,"replies":[{"id":43402,"content":"不是这样的，生产者和消费者之间是不需要互斥的。原因是消息队列中的消息，它有一个不变性。消息写进去只能读或者删除，不能改变。所以不需要互斥。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564366478,"ip_address":"","comment_id":118436,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"李sir，就某个主题的某一队列，是不是可以抽象为一个生产者-多个消费者 的 读写互斥 问题。\n就是说：\n1.没有新消息准备写入队列时，可以让多个消费者同时占有这个队列，执行读操作；\n2.当新消息待写入队列时，如果又消费者在读，就等待所有消费者全部让出队列的读权限；\n3.而新消息写入队列过程中，只有生产者占有队列执行写操作；\n4.新消息写入完成后 或 所有消费者全部读完后，又可以让生产者或消费者抢占队列资源","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460409,"discussion_content":"不是这样的，生产者和消费者之间是不需要互斥的。原因是消息队列中的消息，它有一个不变性。消息写进去只能读或者删除，不能改变。所以不需要互斥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564366478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","nickname":"Jaising","note":"","ucode":"F68830B7B90F96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3282,"discussion_content":"原来这样子，谢谢李老师，看来我还需要进一步了解消息模型的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564375203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118356,"user_name":"大白先生","can_delete":false,"product_type":"c1","uid":1615335,"ip_address":"","ucode":"7EF709EF8FFE6B","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/e7/ed0a0131.jpg","comment_is_top":false,"comment_ctime":1564329316,"is_pvip":false,"replies":[{"id":43379,"content":"你这个问题可以用单据ID做一致性哈希计算出应发到那个队列中去，这样同样ID的单据总是会被发送同一个队列中，可以保证严格顺序。Kafka和RocketMQ都有指定分区&#47;队列的发送接口。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364708,"ip_address":"","comment_id":118356,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师，关于rocketmq和kafka主题内多个queue实现多实例并行消费这里我有个问题。\n假如一个单据信息在非常短的时间内有两种改动比如状态改动，消息推到两个queue上，主题不要求顺序的话，会不会是有新数据被老数据覆盖的问题。难道是需要在消息上增加version，然后靠业务系统做一些更新上的限制么？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460372,"discussion_content":"你这个问题可以用单据ID做一致性哈希计算出应发到那个队列中去，这样同样ID的单据总是会被发送同一个队列中，可以保证严格顺序。Kafka和RocketMQ都有指定分区/队列的发送接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3472,"discussion_content":"我怎么感觉想问的重复消费问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564503499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118196,"user_name":"微微一笑","can_delete":false,"product_type":"c1","uid":1250327,"ip_address":"","ucode":"CFA7ABE81D0B99","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","comment_is_top":false,"comment_ctime":1564287347,"is_pvip":false,"replies":[{"id":43391,"content":"可行。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365357,"ip_address":"","comment_id":118196,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"课后练习：同一个消费组，如果在一个消息队列里不保证严格顺序的情况下，实现并行消费，我觉得关键点在于这个队列的offset的分配。假设此时offset＝m，为消费者a分配m位点，m+＝1（注意：1，这个操作必须保证原子性；2，不用等待上个消息是否成功消费此消息）。然后为消费者b分配m位点，m+＝1，以此类推，达到并行消费。（为保证消息的不丢失，需要为每条消息设置一个状态，标记是否被某个消费组成功消费，若消费失败，需要另起任务来做重试的工作）","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460296,"discussion_content":"可行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193631,"user_name":"Geek_9ius3m","can_delete":false,"product_type":"c1","uid":1118352,"ip_address":"","ucode":"F46E3571FAE9FE","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/90/807689c3.jpg","comment_is_top":false,"comment_ctime":1584937226,"is_pvip":false,"replies":[{"id":73876,"content":"这个应该是IBM公司出品的商业MQ产品，因为没有开源，我不是很了解。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1585014724,"ip_address":"","comment_id":193631,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师我工作中用到的ibm websphere MQ属于哪种消息队列？这种MQ是不是太旧了没有办法支持多并发消费？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488601,"discussion_content":"这个应该是IBM公司出品的商业MQ产品，因为没有开源，我不是很了解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585014724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179513,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1582018722,"is_pvip":false,"replies":[{"id":69997,"content":"不同的MQ这块儿的实现是不一样的，一般都是整批来确认的。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582246939,"ip_address":"","comment_id":179513,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"“实际上并不是一条一条确认的，而是一批一批确认的。一般consumer取一批消息，然后确认的时候直接提交这批消息中最后一条消息的位置来确认这批消息。”\n看到老师的回复，有些疑问。consumer拉取一批消息 ，比如10个消息，当消费者处理到第2个消息失败了，是直接返回给broker确认只处理成功了第1个消息，是这样吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484290,"discussion_content":"不同的MQ这块儿的实现是不一样的，一般都是整批来确认的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582246939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162019,"user_name":"陈四丰","can_delete":false,"product_type":"c1","uid":1610789,"ip_address":"","ucode":"A4463BFD52FB4F","user_header":"https://static001.geekbang.org/account/avatar/00/18/94/25/3bf277e5.jpg","comment_is_top":false,"comment_ctime":1576440073,"is_pvip":false,"replies":[{"id":62382,"content":"1. 是的，一个Consumer Group中所有Consumer消费的消息加起来是一份完整的消息。\n\n2. 每个系统一个Consumer Group。\n\n我在“08 | 答疑解惑（一） : 网关如何接收服务端的秒杀结果？”中对这个问题有更详细的解释，你可以参考。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1576896654,"ip_address":"","comment_id":162019,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"请教老师两个问题：\n\n1, 既然，Consumer Group里面的每个Consumer只能消费Topic中的部分Message，那么每个Consumer不是漏掉很多Message吗？\n\n2, 如果我打算把Message发给三个系统(A,B,C)消费，那么，A,B,C三个系统合在一起，是一个Consumer Group呢？还是说每个系统就是一个Consumer Group? \n\n多谢解答！","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477941,"discussion_content":"1. 是的，一个Consumer Group中所有Consumer消费的消息加起来是一份完整的消息。\n\n2. 每个系统一个Consumer Group。\n\n我在“08 | 答疑解惑（一） : 网关如何接收服务端的秒杀结果？”中对这个问题有更详细的解释，你可以参考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576896654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134062,"user_name":"风随心动","can_delete":false,"product_type":"c1","uid":1613918,"ip_address":"","ucode":"E6797D80BF089A","user_header":"https://static001.geekbang.org/account/avatar/00/18/a0/5e/2b705812.jpg","comment_is_top":false,"comment_ctime":1568730495,"is_pvip":false,"replies":[{"id":51435,"content":"消费者数量少于队列数量是没关系的，每个消费者多负责几个队列就行了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568769469,"ip_address":"","comment_id":134062,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师，请问，一个消费组多个消费者，如5个，此时topic中的队列是7个，那么是不是有两个得不到消费？如果都会被消费，则消费采用的方法是什么？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467606,"discussion_content":"消费者数量少于队列数量是没关系的，每个消费者多负责几个队列就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568769469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126380,"user_name":"cfanbo","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/269eb3d6.jpg","comment_is_top":false,"comment_ctime":1566376347,"is_pvip":false,"replies":[{"id":46819,"content":"都可以，一般订阅的时候可以通过参数来选择。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566435264,"ip_address":"","comment_id":126380,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"一个主题已经有部分数据，这时新增加一个订阅者，这时消费的第一条消息是主题的第一条信息还是当前消费者订阅时间点以后的新增加的那条记录？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463963,"discussion_content":"都可以，一般订阅的时候可以通过参数来选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566435264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043738,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/269eb3d6.jpg","nickname":"cfanbo","note":"","ucode":"39D8D71453E575","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5921,"discussion_content":"原来一直以为只能收到订阅后的消息，基础不牢固呀！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566536638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122471,"user_name":"Geek_bbe9ea","can_delete":false,"product_type":"c1","uid":1336413,"ip_address":"","ucode":"4A0DA7C81D233C","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/5d/c8e2663b.jpg","comment_is_top":false,"comment_ctime":1565400685,"is_pvip":false,"replies":[{"id":44947,"content":"2个consumer，你可以继续看下08答疑这节课，有补充的详细讲解。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565402567,"ip_address":"","comment_id":122471,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"RocketMq的图看的不是很懂，图里到底是一个consumer 还是两个？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463963,"discussion_content":"都可以，一般订阅的时候可以通过参数来选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566435264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043738,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/269eb3d6.jpg","nickname":"cfanbo","note":"","ucode":"39D8D71453E575","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5921,"discussion_content":"原来一直以为只能收到订阅后的消息，基础不牢固呀！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566536638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118882,"user_name":"kane","can_delete":false,"product_type":"c1","uid":1121849,"ip_address":"","ucode":"1B2735A33AF53E","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/39/923ed5b7.jpg","comment_is_top":false,"comment_ctime":1564457432,"is_pvip":false,"replies":[{"id":43697,"content":"要保证严格顺序，生产的时候需要指定队列发送。\n如果需要兼容队列数量变化，可以使用一致性哈希算法来分配队列。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564536455,"ip_address":"","comment_id":118882,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师，第一次发言，希望老师可以帮忙解答。\n 上面讲到的rocket mq队列数可以随意配置，如果更改了队列大写，顺序消费是不是没法保证，这个有没有什么比较好的解决办法。","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462267,"discussion_content":"2个consumer，你可以继续看下08答疑这节课，有补充的详细讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565402567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336413,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/5d/c8e2663b.jpg","nickname":"Geek_bbe9ea","note":"","ucode":"4A0DA7C81D233C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4418,"discussion_content":"同一个consumer group下的两个consumer？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565405270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118436,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1564365018,"is_pvip":false,"replies":[{"id":43402,"content":"不是这样的，生产者和消费者之间是不需要互斥的。原因是消息队列中的消息，它有一个不变性。消息写进去只能读或者删除，不能改变。所以不需要互斥。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564366478,"ip_address":"","comment_id":118436,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"李sir，就某个主题的某一队列，是不是可以抽象为一个生产者-多个消费者 的 读写互斥 问题。\n就是说：\n1.没有新消息准备写入队列时，可以让多个消费者同时占有这个队列，执行读操作；\n2.当新消息待写入队列时，如果又消费者在读，就等待所有消费者全部让出队列的读权限；\n3.而新消息写入队列过程中，只有生产者占有队列执行写操作；\n4.新消息写入完成后 或 所有消费者全部读完后，又可以让生产者或消费者抢占队列资源","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460635,"discussion_content":"要保证严格顺序，生产的时候需要指定队列发送。\n如果需要兼容队列数量变化，可以使用一致性哈希算法来分配队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564536455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118356,"user_name":"大白先生","can_delete":false,"product_type":"c1","uid":1615335,"ip_address":"","ucode":"7EF709EF8FFE6B","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/e7/ed0a0131.jpg","comment_is_top":false,"comment_ctime":1564329316,"is_pvip":false,"replies":[{"id":43379,"content":"你这个问题可以用单据ID做一致性哈希计算出应发到那个队列中去，这样同样ID的单据总是会被发送同一个队列中，可以保证严格顺序。Kafka和RocketMQ都有指定分区&#47;队列的发送接口。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364708,"ip_address":"","comment_id":118356,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师，关于rocketmq和kafka主题内多个queue实现多实例并行消费这里我有个问题。\n假如一个单据信息在非常短的时间内有两种改动比如状态改动，消息推到两个queue上，主题不要求顺序的话，会不会是有新数据被老数据覆盖的问题。难道是需要在消息上增加version，然后靠业务系统做一些更新上的限制么？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460409,"discussion_content":"不是这样的，生产者和消费者之间是不需要互斥的。原因是消息队列中的消息，它有一个不变性。消息写进去只能读或者删除，不能改变。所以不需要互斥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564366478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","nickname":"Jaising","note":"","ucode":"F68830B7B90F96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3282,"discussion_content":"原来这样子，谢谢李老师，看来我还需要进一步了解消息模型的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564375203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118196,"user_name":"微微一笑","can_delete":false,"product_type":"c1","uid":1250327,"ip_address":"","ucode":"CFA7ABE81D0B99","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","comment_is_top":false,"comment_ctime":1564287347,"is_pvip":false,"replies":[{"id":43391,"content":"可行。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365357,"ip_address":"","comment_id":118196,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"课后练习：同一个消费组，如果在一个消息队列里不保证严格顺序的情况下，实现并行消费，我觉得关键点在于这个队列的offset的分配。假设此时offset＝m，为消费者a分配m位点，m+＝1（注意：1，这个操作必须保证原子性；2，不用等待上个消息是否成功消费此消息）。然后为消费者b分配m位点，m+＝1，以此类推，达到并行消费。（为保证消息的不丢失，需要为每条消息设置一个状态，标记是否被某个消费组成功消费，若消费失败，需要另起任务来做重试的工作）","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460372,"discussion_content":"你这个问题可以用单据ID做一致性哈希计算出应发到那个队列中去，这样同样ID的单据总是会被发送同一个队列中，可以保证严格顺序。Kafka和RocketMQ都有指定分区/队列的发送接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3472,"discussion_content":"我怎么感觉想问的重复消费问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564503499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193631,"user_name":"Geek_9ius3m","can_delete":false,"product_type":"c1","uid":1118352,"ip_address":"","ucode":"F46E3571FAE9FE","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/90/807689c3.jpg","comment_is_top":false,"comment_ctime":1584937226,"is_pvip":false,"replies":[{"id":73876,"content":"这个应该是IBM公司出品的商业MQ产品，因为没有开源，我不是很了解。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1585014724,"ip_address":"","comment_id":193631,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"老师我工作中用到的ibm websphere MQ属于哪种消息队列？这种MQ是不是太旧了没有办法支持多并发消费？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460296,"discussion_content":"可行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179513,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1582018722,"is_pvip":false,"replies":[{"id":69997,"content":"不同的MQ这块儿的实现是不一样的，一般都是整批来确认的。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582246939,"ip_address":"","comment_id":179513,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"“实际上并不是一条一条确认的，而是一批一批确认的。一般consumer取一批消息，然后确认的时候直接提交这批消息中最后一条消息的位置来确认这批消息。”\n看到老师的回复，有些疑问。consumer拉取一批消息 ，比如10个消息，当消费者处理到第2个消息失败了，是直接返回给broker确认只处理成功了第1个消息，是这样吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488601,"discussion_content":"这个应该是IBM公司出品的商业MQ产品，因为没有开源，我不是很了解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585014724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162019,"user_name":"陈四丰","can_delete":false,"product_type":"c1","uid":1610789,"ip_address":"","ucode":"A4463BFD52FB4F","user_header":"https://static001.geekbang.org/account/avatar/00/18/94/25/3bf277e5.jpg","comment_is_top":false,"comment_ctime":1576440073,"is_pvip":false,"replies":[{"id":62382,"content":"1. 是的，一个Consumer Group中所有Consumer消费的消息加起来是一份完整的消息。\n\n2. 每个系统一个Consumer Group。\n\n我在“08 | 答疑解惑（一） : 网关如何接收服务端的秒杀结果？”中对这个问题有更详细的解释，你可以参考。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1576896654,"ip_address":"","comment_id":162019,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"请教老师两个问题：\n\n1, 既然，Consumer Group里面的每个Consumer只能消费Topic中的部分Message，那么每个Consumer不是漏掉很多Message吗？\n\n2, 如果我打算把Message发给三个系统(A,B,C)消费，那么，A,B,C三个系统合在一起，是一个Consumer Group呢？还是说每个系统就是一个Consumer Group? \n\n多谢解答！","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484290,"discussion_content":"不同的MQ这块儿的实现是不一样的，一般都是整批来确认的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582246939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157829,"user_name":"wendell","can_delete":false,"product_type":"c1","uid":1359353,"ip_address":"","ucode":"40E47FED3124FA","user_header":"https://static001.geekbang.org/account/avatar/00/14/bd/f9/99c931bf.jpg","comment_is_top":false,"comment_ctime":1575267153,"is_pvip":false,"replies":[{"id":60577,"content":"1. 不会有问题，除了有点儿浪费资源以外。\n\n2. 这个是可以用策略控制的，比如轮询或随机选择队列。\n\n3. 见《08 | 答疑解惑》，里面有专门讲到严格顺序的问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1575333939,"ip_address":"","comment_id":157829,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师，你好！ 有几个疑问望抽空可以解答一下：\n\n1. RabbitMQ实现多个消费者的方式里，每个队列里都会冗余消息这会不会产生什么问题呢？\n\n2. RocketMQ里生成一个消息是如何知道放到主题的哪个队列中的？ \n\n3. 多个队列的情况下，并行生产和消费又是如何保证的有序性呢？比如同一个消费组内的C1和C2并行消费不同的队列，怎么保证顺序","like_count":1},{"had_liked":false,"id":153421,"user_name":"Geek_553596","can_delete":false,"product_type":"c1","uid":1711070,"ip_address":"","ucode":"9AD4E0577976E9","user_header":"","comment_is_top":false,"comment_ctime":1574233663,"is_pvip":false,"replies":[{"id":59494,"content":"是这样的，你的理解完全正确。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574643045,"ip_address":"","comment_id":153421,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师你好，您说的队列只能串行消费是指单个消费组的串行消费吗？\n多个消费组是不是能够并行消费某个队列？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476542,"discussion_content":"1. 不会有问题，除了有点儿浪费资源以外。\n\n2. 这个是可以用策略控制的，比如轮询或随机选择队列。\n\n3. 见《08 | 答疑解惑》，里面有专门讲到严格顺序的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575333939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150413,"user_name":"Shire","can_delete":false,"product_type":"c1","uid":1515610,"ip_address":"","ucode":"94CEDD514311C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/20/5a/91a1925e.jpg","comment_is_top":false,"comment_ctime":1573530301,"is_pvip":false,"replies":[{"id":58191,"content":"大多数MQ，只要使用方法正确，是可以保证全流程消息的严格顺序的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573692006,"ip_address":"","comment_id":150413,"utype":1}],"discussion_count":2,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师，mq应该是只能保证消息写入queue中的顺序，但是消息进入queue中的顺序和生产者发送消息的顺序没办法保证完全一致？可能会存在网络波动等问题!","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475158,"discussion_content":"是这样的，你的理解完全正确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574643045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144096,"user_name":"JasonZ","can_delete":false,"product_type":"c1","uid":1541735,"ip_address":"","ucode":"8340F9CD336DBF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLY5lcOAlRT7Gbw8ZjY3MdKLia0RDjMn5TMVUkYUXo10VstOYzmictVEiaxhFMITaQIn56qEN6NgPc8Q/132","comment_is_top":false,"comment_ctime":1571842802,"is_pvip":false,"replies":[{"id":55639,"content":"你的理解没错。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571883746,"ip_address":"","comment_id":144096,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师，对于一个消费者组来说，在消费同一个主题中的所有队列中消息时还是无序的，要保证严格的有序还是得在同一个队列中串行消费，对吧?","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474152,"discussion_content":"大多数MQ，只要使用方法正确，是可以保证全流程消息的严格顺序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573692006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018494,"avatar":"","nickname":"whhbbq","note":"","ucode":"4A93F3E375CB44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166424,"discussion_content":"也正想问这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581394216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141950,"user_name":"喜欢你的笑","can_delete":false,"product_type":"c1","uid":1076836,"ip_address":"","ucode":"DC9867EA2D4D97","user_header":"https://static001.geekbang.org/account/avatar/00/10/6e/64/9b000b4f.jpg","comment_is_top":false,"comment_ctime":1571273329,"is_pvip":false,"replies":[{"id":54794,"content":"一般都是基于Write Ahead Log模型。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571278298,"ip_address":"","comment_id":141950,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"想问一下这些消息队列中队列模型，是用数组还是链表实现的，是有界队列还是无界队列？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471812,"discussion_content":"你的理解没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571883746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134069,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1568732074,"is_pvip":false,"replies":[{"id":51430,"content":"很多应用场景是需要严格顺序保证的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568769032,"ip_address":"","comment_id":134069,"utype":1}],"discussion_count":2,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师,既然消息队列本来就五花八门没什么标准,那为啥还要遵循“严格有序”的规定呢,一次性取队列中的几个消息并行执行也可以吧,就算断电也还好吧,下一次继续让消费者拉到消息就可以啊,不知道我理解的对不对...","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470938,"discussion_content":"一般都是基于Write Ahead Log模型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571278298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129032,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1567012742,"is_pvip":false,"replies":[{"id":48036,"content":"现代的消息队列，包括RocketMQ、Kafka和RabbitMQ这些，都是可以保证不丢消息的。我们后面会专门有一节课来讲，如果保证不丢消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567044223,"ip_address":"","comment_id":129032,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"如果使用rocketmq，消息的可靠性就不用担心了吗？之前使用activemq时候，要想保证可靠性，每次发送消息的时候都会将消息预先存储到本地的消息库里，得到成功的反馈后再将消息投递出去。。。。如果用rocketmq，这个步骤就可以去掉了吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467607,"discussion_content":"很多应用场景是需要严格顺序保证的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568769032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317115,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/fb/c1334976.jpg","nickname":"王崧霁","note":"","ucode":"4F3284634293A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276192,"discussion_content":"有序无序是业务需要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590837887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129029,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1567011583,"is_pvip":false,"replies":[{"id":48037,"content":"是的，如果没收到消费确认，这个消息会被再次消费。实际上，是消费者去Broker上拉消息，而不是Broker主动推送。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567044312,"ip_address":"","comment_id":129029,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"“消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认。”\n\n否则它会给消费者重新发送消息，这句话怎么理解呢？\n意思是如果broker没有收到消费者的消息消费确认，这个时候broker会给消费者推送一次这个消息？？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465234,"discussion_content":"现代的消息队列，包括RocketMQ、Kafka和RabbitMQ这些，都是可以保证不丢消息的。我们后面会专门有一节课来讲，如果保证不丢消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567044223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127758,"user_name":"grey927","can_delete":false,"product_type":"c1","uid":1202782,"ip_address":"","ucode":"833E02ED835B4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","comment_is_top":false,"comment_ctime":1566788604,"is_pvip":false,"replies":[{"id":47518,"content":"不需要。因为exchange模块的下游是队列，队列的下游才是消费者。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868271,"ip_address":"","comment_id":127758,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"Exchange模块是不是意味着消息中间件需要知道有哪些消费者？而非消费者主动订阅","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465232,"discussion_content":"是的，如果没收到消费确认，这个消息会被再次消费。实际上，是消费者去Broker上拉消息，而不是Broker主动推送。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567044312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126384,"user_name":"renguangqian","can_delete":false,"product_type":"c1","uid":1116926,"ip_address":"","ucode":"91AD065B9259DE","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/fe/27012800.jpg","comment_is_top":false,"comment_ctime":1566377250,"is_pvip":false,"replies":[{"id":46820,"content":"这个地方RabbitMQ做了一个简单的并行扩展，背后其实还是串行消费。简单的说就是这样，RabbitMQ每次从队列中读出Prefetch count这么多条消息，把这些消息分给多个消费者（每个消费者分到其中的一部分），等到这些消息都被消费完了并返回ack之后，RabbitMQ把队列的消费位置更新至：原消费位置+ Prefetch count。\n\n对于队列来说，依然是批量串行消费。消费者看来，是在并行消费。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566435846,"ip_address":"","comment_id":126384,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"求助，“每个队列只能串行消费”，那一个队列对应很多consumer的意义是什么？rabbitmq消费者有Prefetch count参数，这块儿不是说每个消费者拿Prefetch count条消息，并行处理么？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463965,"discussion_content":"这个地方RabbitMQ做了一个简单的并行扩展，背后其实还是串行消费。简单的说就是这样，RabbitMQ每次从队列中读出Prefetch count这么多条消息，把这些消息分给多个消费者（每个消费者分到其中的一部分），等到这些消息都被消费完了并返回ack之后，RabbitMQ把队列的消费位置更新至：原消费位置+ Prefetch count。\n\n对于队列来说，依然是批量串行消费。消费者看来，是在并行消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566435846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157829,"user_name":"wendell","can_delete":false,"product_type":"c1","uid":1359353,"ip_address":"","ucode":"40E47FED3124FA","user_header":"https://static001.geekbang.org/account/avatar/00/14/bd/f9/99c931bf.jpg","comment_is_top":false,"comment_ctime":1575267153,"is_pvip":false,"replies":[{"id":60577,"content":"1. 不会有问题，除了有点儿浪费资源以外。\n\n2. 这个是可以用策略控制的，比如轮询或随机选择队列。\n\n3. 见《08 | 答疑解惑》，里面有专门讲到严格顺序的问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1575333939,"ip_address":"","comment_id":157829,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师，你好！ 有几个疑问望抽空可以解答一下：\n\n1. RabbitMQ实现多个消费者的方式里，每个队列里都会冗余消息这会不会产生什么问题呢？\n\n2. RocketMQ里生成一个消息是如何知道放到主题的哪个队列中的？ \n\n3. 多个队列的情况下，并行生产和消费又是如何保证的有序性呢？比如同一个消费组内的C1和C2并行消费不同的队列，怎么保证顺序","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476542,"discussion_content":"1. 不会有问题，除了有点儿浪费资源以外。\n\n2. 这个是可以用策略控制的，比如轮询或随机选择队列。\n\n3. 见《08 | 答疑解惑》，里面有专门讲到严格顺序的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575333939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153421,"user_name":"Geek_553596","can_delete":false,"product_type":"c1","uid":1711070,"ip_address":"","ucode":"9AD4E0577976E9","user_header":"","comment_is_top":false,"comment_ctime":1574233663,"is_pvip":false,"replies":[{"id":59494,"content":"是这样的，你的理解完全正确。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574643045,"ip_address":"","comment_id":153421,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师你好，您说的队列只能串行消费是指单个消费组的串行消费吗？\n多个消费组是不是能够并行消费某个队列？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475158,"discussion_content":"是这样的，你的理解完全正确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574643045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150413,"user_name":"Shire","can_delete":false,"product_type":"c1","uid":1515610,"ip_address":"","ucode":"94CEDD514311C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/20/5a/91a1925e.jpg","comment_is_top":false,"comment_ctime":1573530301,"is_pvip":false,"replies":[{"id":58191,"content":"大多数MQ，只要使用方法正确，是可以保证全流程消息的严格顺序的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573692006,"ip_address":"","comment_id":150413,"utype":1}],"discussion_count":2,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师，mq应该是只能保证消息写入queue中的顺序，但是消息进入queue中的顺序和生产者发送消息的顺序没办法保证完全一致？可能会存在网络波动等问题!","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474152,"discussion_content":"大多数MQ，只要使用方法正确，是可以保证全流程消息的严格顺序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573692006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018494,"avatar":"","nickname":"whhbbq","note":"","ucode":"4A93F3E375CB44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166424,"discussion_content":"也正想问这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581394216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144096,"user_name":"JasonZ","can_delete":false,"product_type":"c1","uid":1541735,"ip_address":"","ucode":"8340F9CD336DBF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLY5lcOAlRT7Gbw8ZjY3MdKLia0RDjMn5TMVUkYUXo10VstOYzmictVEiaxhFMITaQIn56qEN6NgPc8Q/132","comment_is_top":false,"comment_ctime":1571842802,"is_pvip":false,"replies":[{"id":55639,"content":"你的理解没错。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571883746,"ip_address":"","comment_id":144096,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师，对于一个消费者组来说，在消费同一个主题中的所有队列中消息时还是无序的，要保证严格的有序还是得在同一个队列中串行消费，对吧?","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471812,"discussion_content":"你的理解没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571883746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141950,"user_name":"喜欢你的笑","can_delete":false,"product_type":"c1","uid":1076836,"ip_address":"","ucode":"DC9867EA2D4D97","user_header":"https://static001.geekbang.org/account/avatar/00/10/6e/64/9b000b4f.jpg","comment_is_top":false,"comment_ctime":1571273329,"is_pvip":false,"replies":[{"id":54794,"content":"一般都是基于Write Ahead Log模型。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571278298,"ip_address":"","comment_id":141950,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"想问一下这些消息队列中队列模型，是用数组还是链表实现的，是有界队列还是无界队列？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470938,"discussion_content":"一般都是基于Write Ahead Log模型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571278298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134069,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1568732074,"is_pvip":false,"replies":[{"id":51430,"content":"很多应用场景是需要严格顺序保证的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568769032,"ip_address":"","comment_id":134069,"utype":1}],"discussion_count":2,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"老师,既然消息队列本来就五花八门没什么标准,那为啥还要遵循“严格有序”的规定呢,一次性取队列中的几个消息并行执行也可以吧,就算断电也还好吧,下一次继续让消费者拉到消息就可以啊,不知道我理解的对不对...","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467607,"discussion_content":"很多应用场景是需要严格顺序保证的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568769032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317115,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/fb/c1334976.jpg","nickname":"王崧霁","note":"","ucode":"4F3284634293A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276192,"discussion_content":"有序无序是业务需要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590837887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129032,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1567012742,"is_pvip":false,"replies":[{"id":48036,"content":"现代的消息队列，包括RocketMQ、Kafka和RabbitMQ这些，都是可以保证不丢消息的。我们后面会专门有一节课来讲，如果保证不丢消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567044223,"ip_address":"","comment_id":129032,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"如果使用rocketmq，消息的可靠性就不用担心了吗？之前使用activemq时候，要想保证可靠性，每次发送消息的时候都会将消息预先存储到本地的消息库里，得到成功的反馈后再将消息投递出去。。。。如果用rocketmq，这个步骤就可以去掉了吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465234,"discussion_content":"现代的消息队列，包括RocketMQ、Kafka和RabbitMQ这些，都是可以保证不丢消息的。我们后面会专门有一节课来讲，如果保证不丢消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567044223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129029,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1567011583,"is_pvip":false,"replies":[{"id":48037,"content":"是的，如果没收到消费确认，这个消息会被再次消费。实际上，是消费者去Broker上拉消息，而不是Broker主动推送。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567044312,"ip_address":"","comment_id":129029,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"“消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认。”\n\n否则它会给消费者重新发送消息，这句话怎么理解呢？\n意思是如果broker没有收到消费者的消息消费确认，这个时候broker会给消费者推送一次这个消息？？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465232,"discussion_content":"是的，如果没收到消费确认，这个消息会被再次消费。实际上，是消费者去Broker上拉消息，而不是Broker主动推送。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567044312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127758,"user_name":"grey927","can_delete":false,"product_type":"c1","uid":1202782,"ip_address":"","ucode":"833E02ED835B4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","comment_is_top":false,"comment_ctime":1566788604,"is_pvip":false,"replies":[{"id":47518,"content":"不需要。因为exchange模块的下游是队列，队列的下游才是消费者。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868271,"ip_address":"","comment_id":127758,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"Exchange模块是不是意味着消息中间件需要知道有哪些消费者？而非消费者主动订阅","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464640,"discussion_content":"不需要。因为exchange模块的下游是队列，队列的下游才是消费者。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126384,"user_name":"renguangqian","can_delete":false,"product_type":"c1","uid":1116926,"ip_address":"","ucode":"91AD065B9259DE","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/fe/27012800.jpg","comment_is_top":false,"comment_ctime":1566377250,"is_pvip":false,"replies":[{"id":46820,"content":"这个地方RabbitMQ做了一个简单的并行扩展，背后其实还是串行消费。简单的说就是这样，RabbitMQ每次从队列中读出Prefetch count这么多条消息，把这些消息分给多个消费者（每个消费者分到其中的一部分），等到这些消息都被消费完了并返回ack之后，RabbitMQ把队列的消费位置更新至：原消费位置+ Prefetch count。\n\n对于队列来说，依然是批量串行消费。消费者看来，是在并行消费。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566435846,"ip_address":"","comment_id":126384,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"求助，“每个队列只能串行消费”，那一个队列对应很多consumer的意义是什么？rabbitmq消费者有Prefetch count参数，这块儿不是说每个消费者拿Prefetch count条消息，并行处理么？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464640,"discussion_content":"不需要。因为exchange模块的下游是队列，队列的下游才是消费者。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121981,"user_name":"温润如玉","can_delete":false,"product_type":"c1","uid":1616444,"ip_address":"","ucode":"D298D3A9466995","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/3c/2dd33007.jpg","comment_is_top":false,"comment_ctime":1565262743,"is_pvip":false,"replies":[{"id":44793,"content":"不能实现，多个消费组的目的就是每个消费组都要消费主题上一份完整的消息。\n\n如果你只是希望消息只消费一次，你应该只使用一个消费组，组内可以配置多个消费者来达到并行消费的目的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565274278,"ip_address":"","comment_id":121981,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"有一个疑问想请老师解答：\nrocketMQ是发布订阅者模式，一个主题下的一条消息会被多个消费组消费，那请问如果在多消费组情况下，如何实现一条消息只被消费一次呢","like_count":1},{"had_liked":false,"id":121204,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1079657,"ip_address":"","ucode":"0335277F255F7A","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg","comment_is_top":false,"comment_ctime":1565077118,"is_pvip":false,"replies":[{"id":44614,"content":"理论上是有可能的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138445,"ip_address":"","comment_id":121204,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师, 我有一个疑问, 消息确认机制会不会出现订阅者接收到多条一样的消息呢?","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461678,"discussion_content":"理论上是有可能的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120879,"user_name":"我瑟瑟的方法","can_delete":false,"product_type":"c1","uid":1065819,"ip_address":"","ucode":"1364CD531E1B72","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg","comment_is_top":false,"comment_ctime":1565008861,"is_pvip":false,"replies":[{"id":44470,"content":"是的，较真的话，应该是“到达Broker的自然顺序。”","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565054597,"ip_address":"","comment_id":120879,"utype":1}],"discussion_count":2,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"消息的顺序就是这些生产者发送消息的自然顺序。这个不一定吧？先发后到也是有可能的啊，如网络抖动等","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461512,"discussion_content":"是的，较真的话，应该是“到达Broker的自然顺序。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565054597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065819,"avatar":"https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg","nickname":"我瑟瑟的方法","note":"","ucode":"1364CD531E1B72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4003,"discussion_content":"谢谢老师讲解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565054846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120251,"user_name":"康华","can_delete":false,"product_type":"c1","uid":1473875,"ip_address":"","ucode":"E0BC22AB32735B","user_header":"https://static001.geekbang.org/account/avatar/00/16/7d/53/23a1f93e.jpg","comment_is_top":false,"comment_ctime":1564815505,"is_pvip":false,"replies":[{"id":44180,"content":"A1，一般我们说“性能问题”主要是说代码或者配置不正确，导致性能异常的低。咱们这个例子就是一个常规的多个消费的配置，应该不存在性能问题。\n\nA2：RabbitMQ在Windows下的稳定性，老师没有验证过。但是，一般生产环境还是推荐使用Linux。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564891717,"ip_address":"","comment_id":120251,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"目前使用的rabbitmq,因为她的开箱即用、客户端全，目前是用queue(group)实现的负载均衡，比如一个订单事件，以常见的订单事件为例:\n一个订单事件有有三类消费者程序处理，消息的发送通过topic:mt.order.finish；exchange：mt.default.router\n发票消费者ConsumerA:通过mt.order.groupa订阅该exchange、topic，通过实现多实例部署实现了发票消费端的负载均衡;\n物流消费者ConsumerB:通过mt.order.groupB订阅该exchange、topic，通过实现多实例部署实现了物流消费端的负载均衡;\n通知消费者ConsumerC:通过mt.order.groupC订阅该exchange、topic，通过实现多实例部署实现了通知消费端的负载均衡;\n想问下老师:\nQ1:这种消息的消费方式会不会存在性能;\nQ2:如常见的开源项目一般，RabbitMQ是否在Windows下稳定性不如lLinux;","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461512,"discussion_content":"是的，较真的话，应该是“到达Broker的自然顺序。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565054597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065819,"avatar":"https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg","nickname":"我瑟瑟的方法","note":"","ucode":"1364CD531E1B72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4003,"discussion_content":"谢谢老师讲解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565054846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119367,"user_name":"aaagood","can_delete":false,"product_type":"c1","uid":1474494,"ip_address":"","ucode":"8A9FA77D8E5BAD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/d4icDuHa6CAvoZ54sz2qHqgkJpNaR0FMeO8pCR5YxxaaD6iaTnckGt7Z4PW1cP4AuEG9LcIDbIWrWGibmCBMub8Dg/132","comment_is_top":false,"comment_ctime":1564572183,"is_pvip":false,"replies":[{"id":43844,"content":"不会保证平均消费（但一般情况下都是基本均匀的）。\n\n通过消费确认的机制来保证所有消息都能被消费到。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564627068,"ip_address":"","comment_id":119367,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师你好，\n      一个消费组去消费队列中的数据，mq是如何保证队列被消费组中的消费者平均消费或者都能被消费到的？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460869,"discussion_content":"不会保证平均消费（但一般情况下都是基本均匀的）。\n\n通过消费确认的机制来保证所有消息都能被消费到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564627068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119305,"user_name":"潇洒的毅小峰","can_delete":false,"product_type":"c1","uid":1118141,"ip_address":"","ucode":"24638DAED92F08","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/bd/7a9b2a0c.jpg","comment_is_top":false,"comment_ctime":1564556233,"is_pvip":false,"replies":[{"id":43837,"content":"图是编辑小姐姐用Keynote绘制的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564626455,"ip_address":"","comment_id":119305,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师，没找到您咚咚，想问一下这个作图工具是什么","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460869,"discussion_content":"不会保证平均消费（但一般情况下都是基本均匀的）。\n\n通过消费确认的机制来保证所有消息都能被消费到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564627068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119100,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1564503202,"is_pvip":false,"replies":[{"id":43710,"content":"没问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564537919,"ip_address":"","comment_id":119100,"utype":1}],"discussion_count":2,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"比如a系统订阅了b系统和c系统的topic,对于a系统来说，配置的groupid是同一个。。groupid只与订阅者有关，与生产者和topic无关，这理解对吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460837,"discussion_content":"图是编辑小姐姐用Keynote绘制的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564626455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118987,"user_name":"潇洒的毅小峰","can_delete":false,"product_type":"c1","uid":1118141,"ip_address":"","ucode":"24638DAED92F08","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/bd/7a9b2a0c.jpg","comment_is_top":false,"comment_ctime":1564480218,"is_pvip":false,"replies":[{"id":43854,"content":"Keynote画的😁","user_name":"编辑回复","user_name_real":"孙茹","uid":1336776,"ctime":1564627369,"ip_address":"","comment_id":118987,"utype":2}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师的作图工具是什么，很可爱啊，推荐一下","like_count":1,"discussions":[{"author":{"id":1336776,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/c8/fc094eec.jpg","nickname":"大茹","note":"","ucode":"4681A1EDD8D6F7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460699,"discussion_content":"Keynote画的😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564627369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118915,"user_name":"mt11912","can_delete":false,"product_type":"c1","uid":1170742,"ip_address":"","ucode":"F9EE549D99C3CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/36/d60a6190.jpg","comment_is_top":false,"comment_ctime":1564467070,"is_pvip":false,"replies":[{"id":43701,"content":"必须滴，老师是最敬业滴。\n\n关于你这个作业，思路很好，但还需要想想，如何来扩容客户端的数量呢？","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564537010,"ip_address":"","comment_id":118915,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师，你是我订阅过的专栏中回复最多最认真的老师，您真的非常用心！！！\n单个队列并行消费，可以在客户端使用一个hash算法，比如有5个客户端，第一个客户端处理offset % 5 为 1的消息，第二个客户端处理offset % 5 为2的消息，以此类推。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460661,"discussion_content":"必须滴，老师是最敬业滴。\n\n关于你这个作业，思路很好，但还需要想想，如何来扩容客户端的数量呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564537010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118478,"user_name":"斑马斑马","can_delete":false,"product_type":"c1","uid":1617055,"ip_address":"","ucode":"A624433B6640A1","user_header":"https://static001.geekbang.org/account/avatar/00/18/ac/9f/968084df.jpg","comment_is_top":false,"comment_ctime":1564372166,"is_pvip":false,"replies":[{"id":43526,"content":"对于使用阻塞队列要慎重，处理不好容易丢消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449328,"ip_address":"","comment_id":118478,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师，关于并发处理这块，我这边有两个思路，我们这边主要用的kafka，所以我主要基于kafka说：\n1.主要思路是有个专门的消费线程，它读取到的数据放进阻塞队列中，然后具体的业务线程（多个）再去阻塞队列中去具体进行消费。前面有个兄弟说的很详细\n2.这个思路是用kafka的Partition的概念，kafka消费的时候允许指定消费哪一个Partition的数据，所以思路就是利用这个特点，每个线程消费一个Partition。这个思路感觉有几个缺点，首先是线程数是必须要小于Partition的数量，其次就是容易出现数据堆积或者数据倾斜的情况","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460426,"discussion_content":"对于使用阻塞队列要慎重，处理不好容易丢消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121981,"user_name":"温润如玉","can_delete":false,"product_type":"c1","uid":1616444,"ip_address":"","ucode":"D298D3A9466995","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/3c/2dd33007.jpg","comment_is_top":false,"comment_ctime":1565262743,"is_pvip":false,"replies":[{"id":44793,"content":"不能实现，多个消费组的目的就是每个消费组都要消费主题上一份完整的消息。\n\n如果你只是希望消息只消费一次，你应该只使用一个消费组，组内可以配置多个消费者来达到并行消费的目的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565274278,"ip_address":"","comment_id":121981,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"有一个疑问想请老师解答：\nrocketMQ是发布订阅者模式，一个主题下的一条消息会被多个消费组消费，那请问如果在多消费组情况下，如何实现一条消息只被消费一次呢","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462041,"discussion_content":"不能实现，多个消费组的目的就是每个消费组都要消费主题上一份完整的消息。\n\n如果你只是希望消息只消费一次，你应该只使用一个消费组，组内可以配置多个消费者来达到并行消费的目的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565274278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121204,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1079657,"ip_address":"","ucode":"0335277F255F7A","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg","comment_is_top":false,"comment_ctime":1565077118,"is_pvip":false,"replies":[{"id":44614,"content":"理论上是有可能的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138445,"ip_address":"","comment_id":121204,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师, 我有一个疑问, 消息确认机制会不会出现订阅者接收到多条一样的消息呢?","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462041,"discussion_content":"不能实现，多个消费组的目的就是每个消费组都要消费主题上一份完整的消息。\n\n如果你只是希望消息只消费一次，你应该只使用一个消费组，组内可以配置多个消费者来达到并行消费的目的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565274278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120879,"user_name":"我瑟瑟的方法","can_delete":false,"product_type":"c1","uid":1065819,"ip_address":"","ucode":"1364CD531E1B72","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg","comment_is_top":false,"comment_ctime":1565008861,"is_pvip":false,"replies":[{"id":44470,"content":"是的，较真的话，应该是“到达Broker的自然顺序。”","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565054597,"ip_address":"","comment_id":120879,"utype":1}],"discussion_count":2,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"消息的顺序就是这些生产者发送消息的自然顺序。这个不一定吧？先发后到也是有可能的啊，如网络抖动等","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461678,"discussion_content":"理论上是有可能的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120251,"user_name":"康华","can_delete":false,"product_type":"c1","uid":1473875,"ip_address":"","ucode":"E0BC22AB32735B","user_header":"https://static001.geekbang.org/account/avatar/00/16/7d/53/23a1f93e.jpg","comment_is_top":false,"comment_ctime":1564815505,"is_pvip":false,"replies":[{"id":44180,"content":"A1，一般我们说“性能问题”主要是说代码或者配置不正确，导致性能异常的低。咱们这个例子就是一个常规的多个消费的配置，应该不存在性能问题。\n\nA2：RabbitMQ在Windows下的稳定性，老师没有验证过。但是，一般生产环境还是推荐使用Linux。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564891717,"ip_address":"","comment_id":120251,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"目前使用的rabbitmq,因为她的开箱即用、客户端全，目前是用queue(group)实现的负载均衡，比如一个订单事件，以常见的订单事件为例:\n一个订单事件有有三类消费者程序处理，消息的发送通过topic:mt.order.finish；exchange：mt.default.router\n发票消费者ConsumerA:通过mt.order.groupa订阅该exchange、topic，通过实现多实例部署实现了发票消费端的负载均衡;\n物流消费者ConsumerB:通过mt.order.groupB订阅该exchange、topic，通过实现多实例部署实现了物流消费端的负载均衡;\n通知消费者ConsumerC:通过mt.order.groupC订阅该exchange、topic，通过实现多实例部署实现了通知消费端的负载均衡;\n想问下老师:\nQ1:这种消息的消费方式会不会存在性能;\nQ2:如常见的开源项目一般，RabbitMQ是否在Windows下稳定性不如lLinux;","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461258,"discussion_content":"A1，一般我们说“性能问题”主要是说代码或者配置不正确，导致性能异常的低。咱们这个例子就是一个常规的多个消费的配置，应该不存在性能问题。\n\nA2：RabbitMQ在Windows下的稳定性，老师没有验证过。但是，一般生产环境还是推荐使用Linux。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564891717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119367,"user_name":"aaagood","can_delete":false,"product_type":"c1","uid":1474494,"ip_address":"","ucode":"8A9FA77D8E5BAD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/d4icDuHa6CAvoZ54sz2qHqgkJpNaR0FMeO8pCR5YxxaaD6iaTnckGt7Z4PW1cP4AuEG9LcIDbIWrWGibmCBMub8Dg/132","comment_is_top":false,"comment_ctime":1564572183,"is_pvip":false,"replies":[{"id":43844,"content":"不会保证平均消费（但一般情况下都是基本均匀的）。\n\n通过消费确认的机制来保证所有消息都能被消费到。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564627068,"ip_address":"","comment_id":119367,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师你好，\n      一个消费组去消费队列中的数据，mq是如何保证队列被消费组中的消费者平均消费或者都能被消费到的？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461258,"discussion_content":"A1，一般我们说“性能问题”主要是说代码或者配置不正确，导致性能异常的低。咱们这个例子就是一个常规的多个消费的配置，应该不存在性能问题。\n\nA2：RabbitMQ在Windows下的稳定性，老师没有验证过。但是，一般生产环境还是推荐使用Linux。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564891717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119305,"user_name":"潇洒的毅小峰","can_delete":false,"product_type":"c1","uid":1118141,"ip_address":"","ucode":"24638DAED92F08","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/bd/7a9b2a0c.jpg","comment_is_top":false,"comment_ctime":1564556233,"is_pvip":false,"replies":[{"id":43837,"content":"图是编辑小姐姐用Keynote绘制的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564626455,"ip_address":"","comment_id":119305,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师，没找到您咚咚，想问一下这个作图工具是什么","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460837,"discussion_content":"图是编辑小姐姐用Keynote绘制的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564626455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119100,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1564503202,"is_pvip":false,"replies":[{"id":43710,"content":"没问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564537919,"ip_address":"","comment_id":119100,"utype":1}],"discussion_count":2,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"比如a系统订阅了b系统和c系统的topic,对于a系统来说，配置的groupid是同一个。。groupid只与订阅者有关，与生产者和topic无关，这理解对吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460744,"discussion_content":"没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564537919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018494,"avatar":"","nickname":"whhbbq","note":"","ucode":"4A93F3E375CB44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3513,"discussion_content":"谢谢大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564544070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118987,"user_name":"潇洒的毅小峰","can_delete":false,"product_type":"c1","uid":1118141,"ip_address":"","ucode":"24638DAED92F08","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/bd/7a9b2a0c.jpg","comment_is_top":false,"comment_ctime":1564480218,"is_pvip":false,"replies":[{"id":43854,"content":"Keynote画的😁","user_name":"编辑回复","user_name_real":"孙茹","uid":1336776,"ctime":1564627369,"ip_address":"","comment_id":118987,"utype":2}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师的作图工具是什么，很可爱啊，推荐一下","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460744,"discussion_content":"没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564537919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018494,"avatar":"","nickname":"whhbbq","note":"","ucode":"4A93F3E375CB44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3513,"discussion_content":"谢谢大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564544070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118915,"user_name":"mt11912","can_delete":false,"product_type":"c1","uid":1170742,"ip_address":"","ucode":"F9EE549D99C3CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/36/d60a6190.jpg","comment_is_top":false,"comment_ctime":1564467070,"is_pvip":false,"replies":[{"id":43701,"content":"必须滴，老师是最敬业滴。\n\n关于你这个作业，思路很好，但还需要想想，如何来扩容客户端的数量呢？","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564537010,"ip_address":"","comment_id":118915,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师，你是我订阅过的专栏中回复最多最认真的老师，您真的非常用心！！！\n单个队列并行消费，可以在客户端使用一个hash算法，比如有5个客户端，第一个客户端处理offset % 5 为 1的消息，第二个客户端处理offset % 5 为2的消息，以此类推。","like_count":1,"discussions":[{"author":{"id":1336776,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/c8/fc094eec.jpg","nickname":"大茹","note":"","ucode":"4681A1EDD8D6F7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460699,"discussion_content":"Keynote画的😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564627369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118478,"user_name":"斑马斑马","can_delete":false,"product_type":"c1","uid":1617055,"ip_address":"","ucode":"A624433B6640A1","user_header":"https://static001.geekbang.org/account/avatar/00/18/ac/9f/968084df.jpg","comment_is_top":false,"comment_ctime":1564372166,"is_pvip":false,"replies":[{"id":43526,"content":"对于使用阻塞队列要慎重，处理不好容易丢消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449328,"ip_address":"","comment_id":118478,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师，关于并发处理这块，我这边有两个思路，我们这边主要用的kafka，所以我主要基于kafka说：\n1.主要思路是有个专门的消费线程，它读取到的数据放进阻塞队列中，然后具体的业务线程（多个）再去阻塞队列中去具体进行消费。前面有个兄弟说的很详细\n2.这个思路是用kafka的Partition的概念，kafka消费的时候允许指定消费哪一个Partition的数据，所以思路就是利用这个特点，每个线程消费一个Partition。这个思路感觉有几个缺点，首先是线程数是必须要小于Partition的数量，其次就是容易出现数据堆积或者数据倾斜的情况","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460661,"discussion_content":"必须滴，老师是最敬业滴。\n\n关于你这个作业，思路很好，但还需要想想，如何来扩容客户端的数量呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564537010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118452,"user_name":"骑蜗牛的勇士","can_delete":false,"product_type":"c1","uid":1143338,"ip_address":"","ucode":"2702AEEA14BC4F","user_header":"https://static001.geekbang.org/account/avatar/00/11/72/2a/c4042a20.jpg","comment_is_top":false,"comment_ctime":1564367046,"is_pvip":false,"replies":[{"id":43416,"content":"如果团队用的都是Golang，可以尝试。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564375935,"ip_address":"","comment_id":118452,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"请教一下老师，NSQ呢，可不可以采用","like_count":1},{"had_liked":false,"id":118119,"user_name":"Mark Yao","can_delete":false,"product_type":"c1","uid":1091768,"ip_address":"","ucode":"0535CEB691F618","user_header":"https://static001.geekbang.org/account/avatar/00/10/a8/b8/73ef30ed.jpg","comment_is_top":false,"comment_ctime":1564247759,"is_pvip":false,"replies":[{"id":43388,"content":"嗯，这是一种解决思路。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365138,"ip_address":"","comment_id":118119,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"我觉得可以实现。我的思路：\n\n1，题目中提到并发，想到多线程，但kafka的消费端不是线程安全的，不支持直接多线程消费\n\n2，把消息放到类似管道队列后立刻确认消息，之后多线程处理数据。Java并发包有多个并发队列其中SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。队列本身不存储任何元素，吞吐量非常高。\n\n3，单独启动了一个线程读取阻塞队列数据，然后放入线程池进行处理\n\n4，2中提前确认了消息会导致处理消息的应用挂了消息丢失。解决这个问题可以在确认消息之前写库或记日志或者放在redis，这样保证消息的消费可靠性。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460414,"discussion_content":"如果团队用的都是Golang，可以尝试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564375935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118071,"user_name":"唐二毛","can_delete":false,"product_type":"c1","uid":1597884,"ip_address":"","ucode":"7C16F45165F4BA","user_header":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","comment_is_top":false,"comment_ctime":1564230063,"is_pvip":false,"replies":[{"id":43273,"content":"A1：关于RabbitMQ exchange的配置，你可以去看一下文档，明白原理之后，看文档只是学习如何操作和配置，会比较容易。\n\nA2： RocketMQ在创建订阅的时候，不会创建队列副本。如果不考虑集群的情况，每个队列就只有一个副本。注意，消费消息的时候，只是去读一下这条消息，并不是说在队列中，消息被“消费”了就没了，实际上服务端只是更新了一下消费位置，标记一下这些消息已经被这个消费组消费完了，并不会删除掉消息。其它的消费组依然可以消费这些消息，他们之间是互不影响的。这样就解决了一个队列可以被多个消费组消费的问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564239652,"ip_address":"","comment_id":118071,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"rabbit mq 通过配置多个exchange，来实现多次消费的功能，这和创建exchange的动作是在服务端配置的? 还是由客户端去触发的，动态添加的? \nrocket mq 每收到一个订阅请求，都会为这个consumer在对应的topic生成一个队列副本，这个队列副本跟rabbit mq 的 exchange 似乎是一样的思路，可以这样理解吗？每个consumer消费的count不一样，也就是每个队列副本的长度就会不一样，当有新的consumer发来订阅请求的时候，应该以那个队列作为基础来copy呢？ 还是说，每个topic都会维护一个origin队列，这个origin队列不会被消费，也就是说只会增加，不会减少，新的订阅请求过来，都会以这个队列做copy ? 如果这个origin队列就会无限膨胀，大到无法维护的地步，这怎么解决呢？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460251,"discussion_content":"A1：关于RabbitMQ exchange的配置，你可以去看一下文档，明白原理之后，看文档只是学习如何操作和配置，会比较容易。\n\nA2： RocketMQ在创建订阅的时候，不会创建队列副本。如果不考虑集群的情况，每个队列就只有一个副本。注意，消费消息的时候，只是去读一下这条消息，并不是说在队列中，消息被“消费”了就没了，实际上服务端只是更新了一下消费位置，标记一下这些消息已经被这个消费组消费完了，并不会删除掉消息。其它的消费组依然可以消费这些消息，他们之间是互不影响的。这样就解决了一个队列可以被多个消费组消费的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564239652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1597884,"avatar":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","nickname":"唐二毛","note":"","ucode":"7C16F45165F4BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3354,"discussion_content":"rabbitmq 发布/订阅的实现：\n这个功能是通过类型为&#34;fanout&#34;的exchange来实现的。\npublisher只负责将message发送到exchange, 后续exchange如何处理，他不关注\nconsumer端首先通过exchangeDeclare获取到exchange, 然后通过queueDeclare().getQueue()获取到一个queue,\n这个queue的name是broker自动生成的随机字符串，例如：amq.gen-oreyxihvegrndvnnva, 这样的queue叫做temporary queue,\n他具有以下特性：\n1. exclusive排他性，也就是说只能有一个connection使用这个queue, 如果其他connection试图来使用这个queue,会返回\nchannel-level exception resource-locked,\n2. autodeleted 当使用他的connection断开之后， 这个queue会被自动删除\n\nconsumer拿到queue之后，会做一个关键的操作，queueBind(),将queue绑定到exchange之后，一旦有publisher发送消息到\n这个exchange, exchange就会将消息放入到queue中，让consumer消费到。\n\n需要注意的一点是：exchange对message不会做buffer处理，所有的处理都是即时的，如果在pubulisher send mssage的时候，\nexchange没有被任何的queue绑定，那么这个消息就会discard掉。\n\n总结：rabbitmq的订阅功能是由consumer端驱动的，要增加一个订阅，就需要创建相应的temporary queue, 并bind到exchange.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564415226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229486,"user_name":"Chris","can_delete":false,"product_type":"c1","uid":1689346,"ip_address":"","ucode":"50A51AE2110A7A","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/02/8346ebf6.jpg","comment_is_top":false,"comment_ctime":1593011896,"is_pvip":false,"replies":[{"id":84986,"content":"是的，一般称为“消费位置（offset）”","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1593312284,"ip_address":"","comment_id":229486,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师，消息队列的每一个消费小组的目标是消费完主题中所有队列的消息，是不是那个示意图应该每个组在两个队列都有消费坐标呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499502,"discussion_content":"是的，一般称为“消费位置（offset）”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593312284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228561,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1592734717,"is_pvip":false,"replies":[{"id":84529,"content":"A1：在RMQ中没有Topic的概念，exchange相当于路由和转发消息的交换机。\n\nA2： 队列里存放的就是消息体，不是引用。\n\n\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1592917358,"ip_address":"","comment_id":228561,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"感觉看完之后满脑子问号，老师后续类似的文章\nRabbitMq相关\nQ1：引入exchange模块，生成者发送给exchange，exchange 决定投递给谁，那exchange不就是相当于是一个topic汇集地吗？只是名词不一样，可能后续会了解吗？\nQ2：exchange 投递到不同的队列，不同队列里是消息的引用还是消息body;如果是消息的引用，是不是还得有一个类似java收集器的那么一个东西，发现消息引用没有了，定时删除消息体呀\nRocketMQ\nQ3:没理解有没有队列和消费者的水平扩展有什么关系？\n发布订阅模型本身不就应该有队列吗？理由：订阅者接收主题，不可能全部推给订阅者吧，那中间就要有一个缓冲的，这个缓冲用队列实现不也挺正常的吗？\n\n\n 看RocketMq里，猜测RabbitMq估计也是存储的引用或者序列号,他们应该都有一个专门的线程来删除消息实体吧.\n最后的提醒：业务模型不等于实现模型，就突然懵逼了，不知道怎么问了","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499502,"discussion_content":"是的，一般称为“消费位置（offset）”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593312284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228380,"user_name":"芥末君","can_delete":false,"product_type":"c1","uid":1507918,"ip_address":"","ucode":"DC54FCB50C681A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV0tagXJJXHPic5nPiaf5cwQliaLQuQd5bOPrwa8FvemaNc9V2XvGbrsIoPVVdOZLbAIZoHF750OakA/132","comment_is_top":false,"comment_ctime":1592652536,"is_pvip":false,"replies":[{"id":84530,"content":"Kafka的分区数量是固定的，在创建Topic的时候指定，并不随消费组的实例数变化。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1592917534,"ip_address":"","comment_id":228380,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师你好，请问：\n消费组A（3台服务器）和消费组B（4台服务器）同时消费TopicA，这时Kafka的TopicA中有几个分区?如何保证消费者A和B的服务器负载均衡？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499016,"discussion_content":"Kafka的分区数量是固定的，在创建Topic的时候指定，并不随消费组的实例数变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592917534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228117,"user_name":"Kenny","can_delete":false,"product_type":"c1","uid":1615786,"ip_address":"","ucode":"8A95A5F4762463","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDLJibJ2qSjHHjU4L0hn5xrGw8xcY7fYf7L1St0jOwxNMOdne0GTxWibAxETJiaLVnsHBkIC8VBR9A/132","comment_is_top":false,"comment_ctime":1592559312,"is_pvip":false,"replies":[{"id":84534,"content":"RocketMQ消费的时候是不绑定队列的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1592917829,"ip_address":"","comment_id":228117,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师讲得比较透彻 易理解，点赞👍\n我这边有个问题问一下老师，\nRocketmq 消息模型图中，我们的消费者会从Broker中的topic的队列中获取消息，它一定是从topic中多个队列中的一个队列获取数据嘛？还是说是随机的？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498926,"discussion_content":"RocketMQ消费的时候是不绑定队列的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592917829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/10/4d2d6e64.jpg","nickname":"劳动维权","note":"","ucode":"1D5CEB96618E01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348024,"discussion_content":"如果消费者指定的是顺序消费，为什么需要消费者向broker发送锁定该MessageQueue的请求？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612405805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218415,"user_name":"Roger宇","can_delete":false,"product_type":"c1","uid":1703222,"ip_address":"","ucode":"CBA23C01409349","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","comment_is_top":false,"comment_ctime":1589799490,"is_pvip":false,"replies":[{"id":80841,"content":"技术其实是一直在迭代发展的，具体谁是原创，谁抄的谁，很多已经说不清楚了，Kafka一样也是借鉴了其它很多的论文和产品。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589867982,"ip_address":"","comment_id":218415,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"rocketMQ的消费组，主题，队列（分区）设计完全是在借鉴kafka呀。kafka的设计者还是厉害。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495451,"discussion_content":"技术其实是一直在迭代发展的，具体谁是原创，谁抄的谁，很多已经说不清楚了，Kafka一样也是借鉴了其它很多的论文和产品。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589867982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1703222,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","nickname":"Roger宇","note":"","ucode":"CBA23C01409349","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269121,"discussion_content":"老师说的对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589868661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214459,"user_name":"矫情是种状态💤","can_delete":false,"product_type":"c1","uid":1444555,"ip_address":"","ucode":"B5190684EC067A","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/cb/577cd661.jpg","comment_is_top":false,"comment_ctime":1588752601,"is_pvip":false,"replies":[{"id":79935,"content":"是这样的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589170588,"ip_address":"","comment_id":214459,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"我得理解：在上图，topic把消息载体分为两节，每次生产者产生消息往这q1和q2放入(也有可能分为q1,q2,q3对应消费组1，q4,q5,q6对应消费组二，每次生产者生产消息发往topic.接着topic就会存入q1,q2,q3中任意一条消息和就会存入q4,q5,q6中任意一条消息)，这样为了提升性能，多实例并发生产和消费，\n对于一个消费组，每个队列上只能串行消费，多个队列加一起就是并行消费了，并行度就是队列数量，队列数量越多并行度越大，所以水平扩展可以提升消费性能，但是如果把一个队列改为多个队列并行消费应该不能时序性吧？\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494065,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589170588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211224,"user_name":"花子翁","can_delete":false,"product_type":"c1","uid":1073674,"ip_address":"","ucode":"A687441DC6894F","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/0a/26d00cb9.jpg","comment_is_top":false,"comment_ctime":1587917078,"is_pvip":false,"replies":[{"id":78786,"content":"多个订阅之间是不会互相影响的，关于这一块儿，你可以看一下 08这节课，我有进一步的补充说明。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1588048997,"ip_address":"","comment_id":211224,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"有个疑惑，望老师解答一下：\n在发布订阅模式中，由于消息的确认机制，如果主题没有包含多个队列来实现多实例并行生成和消费，\n每个主题在任意时刻，至多只能有一个消费者实例在进行消费。\n我的问题是：由于多个消费者订阅了主题，应该是每个主题在任意时刻，\n至多只能有一个消息实例在进行消费，但是是多个消费者在消费同一个消息实例。\n是这样吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493224,"discussion_content":"多个订阅之间是不会互相影响的，关于这一块儿，你可以看一下 08这节课，我有进一步的补充说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588048997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118452,"user_name":"骑蜗牛的勇士","can_delete":false,"product_type":"c1","uid":1143338,"ip_address":"","ucode":"2702AEEA14BC4F","user_header":"https://static001.geekbang.org/account/avatar/00/11/72/2a/c4042a20.jpg","comment_is_top":false,"comment_ctime":1564367046,"is_pvip":false,"replies":[{"id":43416,"content":"如果团队用的都是Golang，可以尝试。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564375935,"ip_address":"","comment_id":118452,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"请教一下老师，NSQ呢，可不可以采用","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460414,"discussion_content":"如果团队用的都是Golang，可以尝试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564375935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118119,"user_name":"Mark Yao","can_delete":false,"product_type":"c1","uid":1091768,"ip_address":"","ucode":"0535CEB691F618","user_header":"https://static001.geekbang.org/account/avatar/00/10/a8/b8/73ef30ed.jpg","comment_is_top":false,"comment_ctime":1564247759,"is_pvip":false,"replies":[{"id":43388,"content":"嗯，这是一种解决思路。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365138,"ip_address":"","comment_id":118119,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"我觉得可以实现。我的思路：\n\n1，题目中提到并发，想到多线程，但kafka的消费端不是线程安全的，不支持直接多线程消费\n\n2，把消息放到类似管道队列后立刻确认消息，之后多线程处理数据。Java并发包有多个并发队列其中SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。队列本身不存储任何元素，吞吐量非常高。\n\n3，单独启动了一个线程读取阻塞队列数据，然后放入线程池进行处理\n\n4，2中提前确认了消息会导致处理消息的应用挂了消息丢失。解决这个问题可以在确认消息之前写库或记日志或者放在redis，这样保证消息的消费可靠性。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460270,"discussion_content":"嗯，这是一种解决思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118071,"user_name":"唐二毛","can_delete":false,"product_type":"c1","uid":1597884,"ip_address":"","ucode":"7C16F45165F4BA","user_header":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","comment_is_top":false,"comment_ctime":1564230063,"is_pvip":false,"replies":[{"id":43273,"content":"A1：关于RabbitMQ exchange的配置，你可以去看一下文档，明白原理之后，看文档只是学习如何操作和配置，会比较容易。\n\nA2： RocketMQ在创建订阅的时候，不会创建队列副本。如果不考虑集群的情况，每个队列就只有一个副本。注意，消费消息的时候，只是去读一下这条消息，并不是说在队列中，消息被“消费”了就没了，实际上服务端只是更新了一下消费位置，标记一下这些消息已经被这个消费组消费完了，并不会删除掉消息。其它的消费组依然可以消费这些消息，他们之间是互不影响的。这样就解决了一个队列可以被多个消费组消费的问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564239652,"ip_address":"","comment_id":118071,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"rabbit mq 通过配置多个exchange，来实现多次消费的功能，这和创建exchange的动作是在服务端配置的? 还是由客户端去触发的，动态添加的? \nrocket mq 每收到一个订阅请求，都会为这个consumer在对应的topic生成一个队列副本，这个队列副本跟rabbit mq 的 exchange 似乎是一样的思路，可以这样理解吗？每个consumer消费的count不一样，也就是每个队列副本的长度就会不一样，当有新的consumer发来订阅请求的时候，应该以那个队列作为基础来copy呢？ 还是说，每个topic都会维护一个origin队列，这个origin队列不会被消费，也就是说只会增加，不会减少，新的订阅请求过来，都会以这个队列做copy ? 如果这个origin队列就会无限膨胀，大到无法维护的地步，这怎么解决呢？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460270,"discussion_content":"嗯，这是一种解决思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229486,"user_name":"Chris","can_delete":false,"product_type":"c1","uid":1689346,"ip_address":"","ucode":"50A51AE2110A7A","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/02/8346ebf6.jpg","comment_is_top":false,"comment_ctime":1593011896,"is_pvip":false,"replies":[{"id":84986,"content":"是的，一般称为“消费位置（offset）”","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1593312284,"ip_address":"","comment_id":229486,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师，消息队列的每一个消费小组的目标是消费完主题中所有队列的消息，是不是那个示意图应该每个组在两个队列都有消费坐标呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460251,"discussion_content":"A1：关于RabbitMQ exchange的配置，你可以去看一下文档，明白原理之后，看文档只是学习如何操作和配置，会比较容易。\n\nA2： RocketMQ在创建订阅的时候，不会创建队列副本。如果不考虑集群的情况，每个队列就只有一个副本。注意，消费消息的时候，只是去读一下这条消息，并不是说在队列中，消息被“消费”了就没了，实际上服务端只是更新了一下消费位置，标记一下这些消息已经被这个消费组消费完了，并不会删除掉消息。其它的消费组依然可以消费这些消息，他们之间是互不影响的。这样就解决了一个队列可以被多个消费组消费的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564239652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1597884,"avatar":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","nickname":"唐二毛","note":"","ucode":"7C16F45165F4BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3354,"discussion_content":"rabbitmq 发布/订阅的实现：\n这个功能是通过类型为&#34;fanout&#34;的exchange来实现的。\npublisher只负责将message发送到exchange, 后续exchange如何处理，他不关注\nconsumer端首先通过exchangeDeclare获取到exchange, 然后通过queueDeclare().getQueue()获取到一个queue,\n这个queue的name是broker自动生成的随机字符串，例如：amq.gen-oreyxihvegrndvnnva, 这样的queue叫做temporary queue,\n他具有以下特性：\n1. exclusive排他性，也就是说只能有一个connection使用这个queue, 如果其他connection试图来使用这个queue,会返回\nchannel-level exception resource-locked,\n2. autodeleted 当使用他的connection断开之后， 这个queue会被自动删除\n\nconsumer拿到queue之后，会做一个关键的操作，queueBind(),将queue绑定到exchange之后，一旦有publisher发送消息到\n这个exchange, exchange就会将消息放入到queue中，让consumer消费到。\n\n需要注意的一点是：exchange对message不会做buffer处理，所有的处理都是即时的，如果在pubulisher send mssage的时候，\nexchange没有被任何的queue绑定，那么这个消息就会discard掉。\n\n总结：rabbitmq的订阅功能是由consumer端驱动的，要增加一个订阅，就需要创建相应的temporary queue, 并bind到exchange.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564415226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228561,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1592734717,"is_pvip":false,"replies":[{"id":84529,"content":"A1：在RMQ中没有Topic的概念，exchange相当于路由和转发消息的交换机。\n\nA2： 队列里存放的就是消息体，不是引用。\n\n\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1592917358,"ip_address":"","comment_id":228561,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"感觉看完之后满脑子问号，老师后续类似的文章\nRabbitMq相关\nQ1：引入exchange模块，生成者发送给exchange，exchange 决定投递给谁，那exchange不就是相当于是一个topic汇集地吗？只是名词不一样，可能后续会了解吗？\nQ2：exchange 投递到不同的队列，不同队列里是消息的引用还是消息body;如果是消息的引用，是不是还得有一个类似java收集器的那么一个东西，发现消息引用没有了，定时删除消息体呀\nRocketMQ\nQ3:没理解有没有队列和消费者的水平扩展有什么关系？\n发布订阅模型本身不就应该有队列吗？理由：订阅者接收主题，不可能全部推给订阅者吧，那中间就要有一个缓冲的，这个缓冲用队列实现不也挺正常的吗？\n\n\n 看RocketMq里，猜测RabbitMq估计也是存储的引用或者序列号,他们应该都有一个专门的线程来删除消息实体吧.\n最后的提醒：业务模型不等于实现模型，就突然懵逼了，不知道怎么问了","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499076,"discussion_content":"A1：在RMQ中没有Topic的概念，exchange相当于路由和转发消息的交换机。\n\nA2： 队列里存放的就是消息体，不是引用。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592917358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228380,"user_name":"芥末君","can_delete":false,"product_type":"c1","uid":1507918,"ip_address":"","ucode":"DC54FCB50C681A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV0tagXJJXHPic5nPiaf5cwQliaLQuQd5bOPrwa8FvemaNc9V2XvGbrsIoPVVdOZLbAIZoHF750OakA/132","comment_is_top":false,"comment_ctime":1592652536,"is_pvip":false,"replies":[{"id":84530,"content":"Kafka的分区数量是固定的，在创建Topic的时候指定，并不随消费组的实例数变化。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1592917534,"ip_address":"","comment_id":228380,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师你好，请问：\n消费组A（3台服务器）和消费组B（4台服务器）同时消费TopicA，这时Kafka的TopicA中有几个分区?如何保证消费者A和B的服务器负载均衡？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499076,"discussion_content":"A1：在RMQ中没有Topic的概念，exchange相当于路由和转发消息的交换机。\n\nA2： 队列里存放的就是消息体，不是引用。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592917358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228117,"user_name":"Kenny","can_delete":false,"product_type":"c1","uid":1615786,"ip_address":"","ucode":"8A95A5F4762463","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDLJibJ2qSjHHjU4L0hn5xrGw8xcY7fYf7L1St0jOwxNMOdne0GTxWibAxETJiaLVnsHBkIC8VBR9A/132","comment_is_top":false,"comment_ctime":1592559312,"is_pvip":false,"replies":[{"id":84534,"content":"RocketMQ消费的时候是不绑定队列的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1592917829,"ip_address":"","comment_id":228117,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师讲得比较透彻 易理解，点赞👍\n我这边有个问题问一下老师，\nRocketmq 消息模型图中，我们的消费者会从Broker中的topic的队列中获取消息，它一定是从topic中多个队列中的一个队列获取数据嘛？还是说是随机的？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499016,"discussion_content":"Kafka的分区数量是固定的，在创建Topic的时候指定，并不随消费组的实例数变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592917534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218415,"user_name":"Roger宇","can_delete":false,"product_type":"c1","uid":1703222,"ip_address":"","ucode":"CBA23C01409349","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","comment_is_top":false,"comment_ctime":1589799490,"is_pvip":false,"replies":[{"id":80841,"content":"技术其实是一直在迭代发展的，具体谁是原创，谁抄的谁，很多已经说不清楚了，Kafka一样也是借鉴了其它很多的论文和产品。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589867982,"ip_address":"","comment_id":218415,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"rocketMQ的消费组，主题，队列（分区）设计完全是在借鉴kafka呀。kafka的设计者还是厉害。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498926,"discussion_content":"RocketMQ消费的时候是不绑定队列的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592917829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/10/4d2d6e64.jpg","nickname":"劳动维权","note":"","ucode":"1D5CEB96618E01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348024,"discussion_content":"如果消费者指定的是顺序消费，为什么需要消费者向broker发送锁定该MessageQueue的请求？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612405805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214459,"user_name":"矫情是种状态💤","can_delete":false,"product_type":"c1","uid":1444555,"ip_address":"","ucode":"B5190684EC067A","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/cb/577cd661.jpg","comment_is_top":false,"comment_ctime":1588752601,"is_pvip":false,"replies":[{"id":79935,"content":"是这样的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589170588,"ip_address":"","comment_id":214459,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"我得理解：在上图，topic把消息载体分为两节，每次生产者产生消息往这q1和q2放入(也有可能分为q1,q2,q3对应消费组1，q4,q5,q6对应消费组二，每次生产者生产消息发往topic.接着topic就会存入q1,q2,q3中任意一条消息和就会存入q4,q5,q6中任意一条消息)，这样为了提升性能，多实例并发生产和消费，\n对于一个消费组，每个队列上只能串行消费，多个队列加一起就是并行消费了，并行度就是队列数量，队列数量越多并行度越大，所以水平扩展可以提升消费性能，但是如果把一个队列改为多个队列并行消费应该不能时序性吧？\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495451,"discussion_content":"技术其实是一直在迭代发展的，具体谁是原创，谁抄的谁，很多已经说不清楚了，Kafka一样也是借鉴了其它很多的论文和产品。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589867982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1703222,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","nickname":"Roger宇","note":"","ucode":"CBA23C01409349","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269121,"discussion_content":"老师说的对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589868661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211224,"user_name":"花子翁","can_delete":false,"product_type":"c1","uid":1073674,"ip_address":"","ucode":"A687441DC6894F","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/0a/26d00cb9.jpg","comment_is_top":false,"comment_ctime":1587917078,"is_pvip":false,"replies":[{"id":78786,"content":"多个订阅之间是不会互相影响的，关于这一块儿，你可以看一下 08这节课，我有进一步的补充说明。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1588048997,"ip_address":"","comment_id":211224,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"有个疑惑，望老师解答一下：\n在发布订阅模式中，由于消息的确认机制，如果主题没有包含多个队列来实现多实例并行生成和消费，\n每个主题在任意时刻，至多只能有一个消费者实例在进行消费。\n我的问题是：由于多个消费者订阅了主题，应该是每个主题在任意时刻，\n至多只能有一个消息实例在进行消费，但是是多个消费者在消费同一个消息实例。\n是这样吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494065,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589170588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205535,"user_name":"Joy Rick","can_delete":false,"product_type":"c1","uid":1906836,"ip_address":"","ucode":"A618544F763B4B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/18/94/e3993448.jpg","comment_is_top":false,"comment_ctime":1586666096,"is_pvip":false,"replies":[{"id":77022,"content":"Pub的时候，也需要，你看一下同一个例子的客户端：https:&#47;&#47;github.com&#47;micro&#47;examples&#47;blob&#47;9bf1a7d46dc410e12556cc678c2d887422d4b0ba&#47;pubsub&#47;cli&#47;main.go","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1586831286,"ip_address":"","comment_id":205535,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师看 Pub&#47;Sub 系统有个关于的 queue 的疑问：为什么 queue 参数在 Sub 客户端执行，而 Pub 的时候不需要呢？这样子岂不是 Pub 的时候不知道 Pub 到具体哪个 queue 上吗？ 代码例子：https:&#47;&#47;github.com&#47;micro&#47;examples&#47;blob&#47;9bf1a7d46dc410e12556cc678c2d887422d4b0ba&#47;pubsub&#47;srv&#47;main.go#L45 https:&#47;&#47;github.com&#47;micro&#47;examples&#47;blob&#47;master&#47;pubsub&#47;cli&#47;main.go#L45","like_count":0},{"had_liked":false,"id":148940,"user_name":"向往的生活","can_delete":false,"product_type":"c1","uid":1397298,"ip_address":"","ucode":"0E8DB45357820F","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","comment_is_top":false,"comment_ctime":1573113773,"is_pvip":false,"replies":[{"id":57587,"content":"关于消息模型的进一步详细解释，你可以看一下 08 这节课。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573346962,"ip_address":"","comment_id":148940,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"这句话该怎么理解呢？\n\n但是，引入这个‘请求-确认’机制在消费端带来了一个不小的问题。什么问题呢？为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则。也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473679,"discussion_content":"关于消息模型的进一步详细解释，你可以看一下 08 这节课。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573346962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143621,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1571746519,"is_pvip":false,"replies":[{"id":55631,"content":"从消息模型层面来说，NameServer并不是一个必须的模块，它只是用来路由寻址的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571882973,"ip_address":"","comment_id":143621,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师您好，RocketMQ图中的NameServer为什么没有画？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471622,"discussion_content":"从消息模型层面来说，NameServer并不是一个必须的模块，它只是用来路由寻址的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571882973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135522,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1569203271,"is_pvip":false,"replies":[{"id":52054,"content":"你说的“MQ插件”和“Cache插件”分别具体是指什么呢？","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569290987,"ip_address":"","comment_id":135522,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师好，请问一下MQ插件和Cache插件的区别和应用场景是什么呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468228,"discussion_content":"你说的“MQ插件”和“Cache插件”分别具体是指什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569290987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134499,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1568856276,"is_pvip":false,"replies":[{"id":51553,"content":"你这种需求，建议的解决方式是，把这些添加、删除的“操作”放到同一个主题中，如何保证严格顺序的问题，你可以看一下08这节课。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568856788,"ip_address":"","comment_id":134499,"utype":1}],"discussion_count":2,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"哦，是不是这个意思！对于添加订单和删除订单来说是2个主题！比如我先添加一个订单，再取消这个订单！应该是一个添加订单的主题，一个取消订单的主题？老师怎么保证添加订单的消息先被消费，取消后被消费？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467775,"discussion_content":"你这种需求，建议的解决方式是，把这些添加、删除的“操作”放到同一个主题中，如何保证严格顺序的问题，你可以看一下08这节课。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15863,"discussion_content":"好的，谢谢老师！我努力！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134497,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1568856131,"is_pvip":false,"replies":[{"id":51551,"content":"这个问题我们在08这节课中会讲到。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568856689,"ip_address":"","comment_id":134497,"utype":1}],"discussion_count":2,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师，您好！文中提到因为多消费者可以提高消费速度(提高并发度)，所以才引入了一个主题的多队列！但是怎么感觉多队列引入后消息的顺序性消费被打乱了！这个怎么考虑的？多个队列的情况下，消息顺序性怎么保证？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467775,"discussion_content":"你这种需求，建议的解决方式是，把这些添加、删除的“操作”放到同一个主题中，如何保证严格顺序的问题，你可以看一下08这节课。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15863,"discussion_content":"好的，谢谢老师！我努力！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130983,"user_name":"龍蝦","can_delete":false,"product_type":"c1","uid":1000076,"ip_address":"","ucode":"BE1D500833F070","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/8c/373d4027.jpg","comment_is_top":false,"comment_ctime":1567589110,"is_pvip":true,"replies":[{"id":49327,"content":"你可以继续看一下08疑难解答这节课，我在里面有详细的解释。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567648513,"ip_address":"","comment_id":130983,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"请教下老师：\nRocketMQ 一个队列不是对应一个消费者，多个消费者可以从同一个队列消费消息？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467774,"discussion_content":"这个问题我们在08这节课中会讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15861,"discussion_content":"好的，谢谢老师！我正在努力追赶进度！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128015,"user_name":"阿U","can_delete":false,"product_type":"c1","uid":1171359,"ip_address":"","ucode":"161A8E74E0D612","user_header":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","comment_is_top":false,"comment_ctime":1566820671,"is_pvip":false,"replies":[{"id":47529,"content":"你可以继续看一下08疑难解答，针对你这块儿的疑问，有详细的解释。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868702,"ip_address":"","comment_id":128015,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师 我看你这个rocketmq只是画了一个消费组，应该也可以有很多消费组，每个消费组可以且必须消费主题中所有队列吗？其中每个组内的消费者竞争关系","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466228,"discussion_content":"你可以继续看一下08疑难解答这节课，我在里面有详细的解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567648513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126359,"user_name":"丹枫无迹","can_delete":false,"product_type":"c1","uid":1218765,"ip_address":"","ucode":"61A508C2464AF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/cd/d85c6361.jpg","comment_is_top":false,"comment_ctime":1566371426,"is_pvip":false,"replies":[{"id":46816,"content":"在主题模型中，或者说在RocketMQ中，队列就是主题的分片，存放的是部分消息，具体我在08答疑这节课中有进一步的讲解。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566435049,"ip_address":"","comment_id":126359,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师，你好！对于队列我有点迷糊了，每一个队列中的消息是一份完整的消息，还是每个队列中都只是部分消息？前一种方式可以实现多个客户端各自消费一份完整的消息，而后一种方式可以实现扩容 Consumer 来提升消费性能。或者说这两种方式都可以，根据场景自行决定使用哪种？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464755,"discussion_content":"你可以继续看一下08疑难解答，针对你这块儿的疑问，有详细的解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126258,"user_name":"vi","can_delete":false,"product_type":"c1","uid":1504664,"ip_address":"","ucode":"943CADFE6C1A6A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIBabuBHlohpGYRDt4mwWghVDztHyRnC9SfyYnENUZNbCe8m05qQn0cHdiazU4eKmMtSQ0bHicwLLQ/132","comment_is_top":false,"comment_ctime":1566354017,"is_pvip":false,"replies":[{"id":46814,"content":"都是可以的，还是取决于你的代码是怎么写的呀。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566434769,"ip_address":"","comment_id":126258,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"请教老师，在rabbitmq中，启用多线程并行消费，原理是启动了多个消息消费同一个对列，还是多个消息者多个队列一一对应进行消息呢","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463952,"discussion_content":"在主题模型中，或者说在RocketMQ中，队列就是主题的分片，存放的是部分消息，具体我在08答疑这节课中有进一步的讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566435049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205535,"user_name":"Joy Rick","can_delete":false,"product_type":"c1","uid":1906836,"ip_address":"","ucode":"A618544F763B4B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/18/94/e3993448.jpg","comment_is_top":false,"comment_ctime":1586666096,"is_pvip":false,"replies":[{"id":77022,"content":"Pub的时候，也需要，你看一下同一个例子的客户端：https:&#47;&#47;github.com&#47;micro&#47;examples&#47;blob&#47;9bf1a7d46dc410e12556cc678c2d887422d4b0ba&#47;pubsub&#47;cli&#47;main.go","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1586831286,"ip_address":"","comment_id":205535,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师看 Pub&#47;Sub 系统有个关于的 queue 的疑问：为什么 queue 参数在 Sub 客户端执行，而 Pub 的时候不需要呢？这样子岂不是 Pub 的时候不知道 Pub 到具体哪个 queue 上吗？ 代码例子：https:&#47;&#47;github.com&#47;micro&#47;examples&#47;blob&#47;9bf1a7d46dc410e12556cc678c2d887422d4b0ba&#47;pubsub&#47;srv&#47;main.go#L45 https:&#47;&#47;github.com&#47;micro&#47;examples&#47;blob&#47;master&#47;pubsub&#47;cli&#47;main.go#L45","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491505,"discussion_content":"Pub的时候，也需要，你看一下同一个例子的客户端：https://github.com/micro/examples/blob/9bf1a7d46dc410e12556cc678c2d887422d4b0ba/pubsub/cli/main.go","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586831286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148940,"user_name":"向往的生活","can_delete":false,"product_type":"c1","uid":1397298,"ip_address":"","ucode":"0E8DB45357820F","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","comment_is_top":false,"comment_ctime":1573113773,"is_pvip":false,"replies":[{"id":57587,"content":"关于消息模型的进一步详细解释，你可以看一下 08 这节课。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573346962,"ip_address":"","comment_id":148940,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"这句话该怎么理解呢？\n\n但是，引入这个‘请求-确认’机制在消费端带来了一个不小的问题。什么问题呢？为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则。也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491505,"discussion_content":"Pub的时候，也需要，你看一下同一个例子的客户端：https://github.com/micro/examples/blob/9bf1a7d46dc410e12556cc678c2d887422d4b0ba/pubsub/cli/main.go","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586831286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143621,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1571746519,"is_pvip":false,"replies":[{"id":55631,"content":"从消息模型层面来说，NameServer并不是一个必须的模块，它只是用来路由寻址的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571882973,"ip_address":"","comment_id":143621,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师您好，RocketMQ图中的NameServer为什么没有画？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473679,"discussion_content":"关于消息模型的进一步详细解释，你可以看一下 08 这节课。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573346962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135522,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1569203271,"is_pvip":false,"replies":[{"id":52054,"content":"你说的“MQ插件”和“Cache插件”分别具体是指什么呢？","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1569290987,"ip_address":"","comment_id":135522,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师好，请问一下MQ插件和Cache插件的区别和应用场景是什么呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471622,"discussion_content":"从消息模型层面来说，NameServer并不是一个必须的模块，它只是用来路由寻址的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571882973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134499,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1568856276,"is_pvip":false,"replies":[{"id":51553,"content":"你这种需求，建议的解决方式是，把这些添加、删除的“操作”放到同一个主题中，如何保证严格顺序的问题，你可以看一下08这节课。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568856788,"ip_address":"","comment_id":134499,"utype":1}],"discussion_count":2,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"哦，是不是这个意思！对于添加订单和删除订单来说是2个主题！比如我先添加一个订单，再取消这个订单！应该是一个添加订单的主题，一个取消订单的主题？老师怎么保证添加订单的消息先被消费，取消后被消费？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468228,"discussion_content":"你说的“MQ插件”和“Cache插件”分别具体是指什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569290987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134497,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1568856131,"is_pvip":false,"replies":[{"id":51551,"content":"这个问题我们在08这节课中会讲到。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568856689,"ip_address":"","comment_id":134497,"utype":1}],"discussion_count":2,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师，您好！文中提到因为多消费者可以提高消费速度(提高并发度)，所以才引入了一个主题的多队列！但是怎么感觉多队列引入后消息的顺序性消费被打乱了！这个怎么考虑的？多个队列的情况下，消息顺序性怎么保证？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467774,"discussion_content":"这个问题我们在08这节课中会讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15861,"discussion_content":"好的，谢谢老师！我正在努力追赶进度！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130983,"user_name":"龍蝦","can_delete":false,"product_type":"c1","uid":1000076,"ip_address":"","ucode":"BE1D500833F070","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/8c/373d4027.jpg","comment_is_top":false,"comment_ctime":1567589110,"is_pvip":true,"replies":[{"id":49327,"content":"你可以继续看一下08疑难解答这节课，我在里面有详细的解释。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567648513,"ip_address":"","comment_id":130983,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"请教下老师：\nRocketMQ 一个队列不是对应一个消费者，多个消费者可以从同一个队列消费消息？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466228,"discussion_content":"你可以继续看一下08疑难解答这节课，我在里面有详细的解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567648513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128015,"user_name":"阿U","can_delete":false,"product_type":"c1","uid":1171359,"ip_address":"","ucode":"161A8E74E0D612","user_header":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","comment_is_top":false,"comment_ctime":1566820671,"is_pvip":false,"replies":[{"id":47529,"content":"你可以继续看一下08疑难解答，针对你这块儿的疑问，有详细的解释。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868702,"ip_address":"","comment_id":128015,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师 我看你这个rocketmq只是画了一个消费组，应该也可以有很多消费组，每个消费组可以且必须消费主题中所有队列吗？其中每个组内的消费者竞争关系","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464755,"discussion_content":"你可以继续看一下08疑难解答，针对你这块儿的疑问，有详细的解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126359,"user_name":"丹枫无迹","can_delete":false,"product_type":"c1","uid":1218765,"ip_address":"","ucode":"61A508C2464AF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/cd/d85c6361.jpg","comment_is_top":false,"comment_ctime":1566371426,"is_pvip":false,"replies":[{"id":46816,"content":"在主题模型中，或者说在RocketMQ中，队列就是主题的分片，存放的是部分消息，具体我在08答疑这节课中有进一步的讲解。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566435049,"ip_address":"","comment_id":126359,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师，你好！对于队列我有点迷糊了，每一个队列中的消息是一份完整的消息，还是每个队列中都只是部分消息？前一种方式可以实现多个客户端各自消费一份完整的消息，而后一种方式可以实现扩容 Consumer 来提升消费性能。或者说这两种方式都可以，根据场景自行决定使用哪种？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463952,"discussion_content":"在主题模型中，或者说在RocketMQ中，队列就是主题的分片，存放的是部分消息，具体我在08答疑这节课中有进一步的讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566435049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126258,"user_name":"vi","can_delete":false,"product_type":"c1","uid":1504664,"ip_address":"","ucode":"943CADFE6C1A6A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIBabuBHlohpGYRDt4mwWghVDztHyRnC9SfyYnENUZNbCe8m05qQn0cHdiazU4eKmMtSQ0bHicwLLQ/132","comment_is_top":false,"comment_ctime":1566354017,"is_pvip":false,"replies":[{"id":46814,"content":"都是可以的，还是取决于你的代码是怎么写的呀。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566434769,"ip_address":"","comment_id":126258,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"请教老师，在rabbitmq中，启用多线程并行消费，原理是启动了多个消息消费同一个对列，还是多个消息者多个队列一一对应进行消息呢","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463910,"discussion_content":"都是可以的，还是取决于你的代码是怎么写的呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566434769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123522,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1181647,"ip_address":"","ucode":"46A2F679C094E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","comment_is_top":false,"comment_ctime":1565691826,"is_pvip":false,"replies":[{"id":45345,"content":"你这些问题我在08答疑这节课中有详细的说明，可以看一下。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565745441,"ip_address":"","comment_id":123522,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"老师，对Rocket MQ有些疑惑，不知道理解的正不正确，望指正～\n1 为了增加消费性能，队列的数量是可以水平扩展的，那生产者生产的消息应该只会发送到一个队列里吧。\n2 消费组应该是可以消费所有队列里的的消息吧，只不过对于同一个队列它是按序依次消费的，所以才有offset来记录消费位置。\n3 对于第二点，消费组是通过什么机制来消费所有队列的，轮训吗？ 谢谢老师。\n","like_count":0},{"had_liked":false,"id":122685,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1565490804,"is_pvip":false,"replies":[{"id":45030,"content":"一般都是消费者去拉消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565523614,"ip_address":"","comment_id":122685,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"消息队列是主动给消费者发消息吗？还是消费者会向消息队列请求拉取消息？消息队列是部署在单独的机器上吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462710,"discussion_content":"你这些问题我在08答疑这节课中有详细的说明，可以看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565745441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121096,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1565057672,"is_pvip":false,"replies":[{"id":44630,"content":"我会在08答疑中详细再说一下的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138934,"ip_address":"","comment_id":121096,"utype":1}],"discussion_count":2,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"李老师，能解释下Topic、分区、Broker、MessageQueue之间的关系嘛，图例有点不是很明白","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462360,"discussion_content":"一般都是消费者去拉消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565523614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121061,"user_name":"风光","can_delete":false,"product_type":"c1","uid":1139441,"ip_address":"","ucode":"59B417675A2AEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/f1/05fe8d01.jpg","comment_is_top":false,"comment_ctime":1565053710,"is_pvip":false,"replies":[{"id":46920,"content":"请继续看一下08答疑这篇，对于你的疑问，我在里面有详细的讲解。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566521593,"ip_address":"","comment_id":121061,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"想问下老师，所谓的同一个消费组，可以理解为就是官方的集群模式？这个组内的消费者只有一个实例可以消费到订阅的主题","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461623,"discussion_content":"我会在08答疑中详细再说一下的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","nickname":"Jaising","note":"","ucode":"F68830B7B90F96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4425,"discussion_content":"看了答疑，还有一个疑惑点：\n同消费组的不同消费者是否可以消费同一条消息——RocketMQ和Kafka的集群消费（只要有一个消费者消费了，其他消费者不能再消费）和广播消费（所有消费者都可以消费，即使已经有消费者消费掉了）\n不知理解是否正确，请李老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565410626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121060,"user_name":"风光","can_delete":false,"product_type":"c1","uid":1139441,"ip_address":"","ucode":"59B417675A2AEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/f1/05fe8d01.jpg","comment_is_top":false,"comment_ctime":1565053709,"is_pvip":false,"replies":[{"id":44478,"content":"你这个问题我们会在第8节课中统一解答。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565055277,"ip_address":"","comment_id":121060,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"想问下老师，所谓的同一个消费组，可以理解为就是官方的集群模式？这个组内的消费者只有一个实例可以消费到订阅的主题","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461599,"discussion_content":"你这个问题我们会在第8节课中统一解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565055277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120490,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1564911475,"is_pvip":false,"replies":[{"id":46918,"content":"请继续看一下08答疑这节课，针对你这些以外，我在里面有详细的说明。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566521522,"ip_address":"","comment_id":120490,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"两个疑问，\n第一个疑问，消费队列，消费组 他们之间的关系不是很了解，是一一对应关系吗？一个消息队列对应一个消费组！还是一个消费组对应一个主题中所有消息队列。\n\n第二个疑问:据我的理解，消费组是针对不同的下游业务系统所做的不同的划分，比如订单系统，风控系统每个都是一个消费组。\n那消费队列在其中是怎么个角色，每一条生产者发布的消息往所有消息队列发布一条信息？还是只是往其中一个消息队列发布一条消息？\n\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461357,"discussion_content":"请继续看一下08答疑这节课，针对你这些以外，我在里面有详细的说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566521522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120489,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1564911475,"is_pvip":false,"replies":[{"id":44269,"content":"我在08 答疑中会专门再把这个问题详细讲一下。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564968007,"ip_address":"","comment_id":120489,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"两个疑问，\n第一个疑问，消费队列，消费组 他们之间的关系不是很了解，是一一对应关系吗？一个消息队列对应一个消费组！还是一个消费组对应一个主题中所有消息队列。\n\n第二个疑问:据我的理解，消费组是针对不同的下游业务系统所做的不同的划分，比如订单系统，风控系统每个都是一个消费组。\n那消费队列在其中是怎么个角色，每一条生产者发布的消息往所有消息队列发布一条信息？还是只是往其中一个消息队列发布一条消息？\n\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461357,"discussion_content":"请继续看一下08答疑这节课，针对你这些以外，我在里面有详细的说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566521522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119988,"user_name":"箭指流云","can_delete":false,"product_type":"c1","uid":1367877,"ip_address":"","ucode":"21571A7D60B10D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/VqgchrJWswwSLmxf1ict6icDDlZG5wChBEiaiblnJAQEdu1nYtB4EZq07mibUurOSDFr16dho6DhGyOpIW4eib57lK8Q/132","comment_is_top":false,"comment_ctime":1564745275,"is_pvip":false,"replies":[{"id":44103,"content":"A1：没有严格要求一定消费者的数量和队列数量一样。\nA2：应该说是“主题中包含队列”，队列是一个使用层面的逻辑概念，实际实现的时候各不一样。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564799090,"ip_address":"","comment_id":119988,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"麻烦老师解答\n1、rabbitMQ中有多少个消费者就要多少个队列吗\n2、rocketMQ和rabbitMQ中的主题都是用队列实现的吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461356,"discussion_content":"我在08 答疑中会专门再把这个问题详细讲一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564968007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119578,"user_name":"Zzz","can_delete":false,"product_type":"c1","uid":1126750,"ip_address":"","ucode":"9573B50F5B26CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/5e/542fa713.jpg","comment_is_top":false,"comment_ctime":1564628884,"is_pvip":false,"replies":[{"id":43952,"content":"即使在同一个消费组内多个消费者来消费，也是可以保证顺序的，你可以对照消息模型再想一下为什么可以保证顺序。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564707141,"ip_address":"","comment_id":119578,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"必须要有序消费的消息，在多消费者的情况下的实践是不是不太好？ 因为每个生产者每次都是去取一条或者一批消息来消费的，多个消费者就导致消息的消费无法保证无序了。 ","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461163,"discussion_content":"A1：没有严格要求一定消费者的数量和队列数量一样。\nA2：应该说是“主题中包含队列”，队列是一个使用层面的逻辑概念，实际实现的时候各不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564799090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119394,"user_name":"极客是一种精神","can_delete":false,"product_type":"c1","uid":1325365,"ip_address":"","ucode":"7CD9EF88F51E21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/uT6JB2EZEST9UKtXiaSvu4mjneI3bWMJe0blWhZ15jjndPQlEicib1PDbC7zGobiccHc4cSzpmic8ibdgzzFw0WqYarA/132","comment_is_top":false,"comment_ctime":1564578064,"is_pvip":false,"replies":[{"id":43839,"content":"同学，我们这个图里面只画了一个消费组啊。这个主题有2个队列，对于一个消费组，每个队列的消费位置都要记录。所以画了2个消费位置。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564626678,"ip_address":"","comment_id":119394,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"https:&#47;&#47;static001.geekbang.org&#47;resource&#47;image&#47;46&#47;17&#47;465142ab5b5096f283118c307e8cc117.jpg\n这边图里面的队列2是不是应当是队列1？同一个队列，维护了两个不同的消费组的消费位置？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460962,"discussion_content":"即使在同一个消费组内多个消费者来消费，也是可以保证顺序的，你可以对照消息模型再想一下为什么可以保证顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564707141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123522,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1181647,"ip_address":"","ucode":"46A2F679C094E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","comment_is_top":false,"comment_ctime":1565691826,"is_pvip":false,"replies":[{"id":45345,"content":"你这些问题我在08答疑这节课中有详细的说明，可以看一下。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565745441,"ip_address":"","comment_id":123522,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"老师，对Rocket MQ有些疑惑，不知道理解的正不正确，望指正～\n1 为了增加消费性能，队列的数量是可以水平扩展的，那生产者生产的消息应该只会发送到一个队列里吧。\n2 消费组应该是可以消费所有队列里的的消息吧，只不过对于同一个队列它是按序依次消费的，所以才有offset来记录消费位置。\n3 对于第二点，消费组是通过什么机制来消费所有队列的，轮训吗？ 谢谢老师。\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462710,"discussion_content":"你这些问题我在08答疑这节课中有详细的说明，可以看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565745441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122685,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1565490804,"is_pvip":false,"replies":[{"id":45030,"content":"一般都是消费者去拉消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565523614,"ip_address":"","comment_id":122685,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"消息队列是主动给消费者发消息吗？还是消费者会向消息队列请求拉取消息？消息队列是部署在单独的机器上吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462360,"discussion_content":"一般都是消费者去拉消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565523614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121096,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1565057672,"is_pvip":false,"replies":[{"id":44630,"content":"我会在08答疑中详细再说一下的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138934,"ip_address":"","comment_id":121096,"utype":1}],"discussion_count":2,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"李老师，能解释下Topic、分区、Broker、MessageQueue之间的关系嘛，图例有点不是很明白","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461623,"discussion_content":"我会在08答疑中详细再说一下的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","nickname":"Jaising","note":"","ucode":"F68830B7B90F96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4425,"discussion_content":"看了答疑，还有一个疑惑点：\n同消费组的不同消费者是否可以消费同一条消息——RocketMQ和Kafka的集群消费（只要有一个消费者消费了，其他消费者不能再消费）和广播消费（所有消费者都可以消费，即使已经有消费者消费掉了）\n不知理解是否正确，请李老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565410626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121061,"user_name":"风光","can_delete":false,"product_type":"c1","uid":1139441,"ip_address":"","ucode":"59B417675A2AEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/f1/05fe8d01.jpg","comment_is_top":false,"comment_ctime":1565053710,"is_pvip":false,"replies":[{"id":46920,"content":"请继续看一下08答疑这篇，对于你的疑问，我在里面有详细的讲解。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566521593,"ip_address":"","comment_id":121061,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"想问下老师，所谓的同一个消费组，可以理解为就是官方的集群模式？这个组内的消费者只有一个实例可以消费到订阅的主题","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461600,"discussion_content":"请继续看一下08答疑这篇，对于你的疑问，我在里面有详细的讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566521593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121060,"user_name":"风光","can_delete":false,"product_type":"c1","uid":1139441,"ip_address":"","ucode":"59B417675A2AEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/f1/05fe8d01.jpg","comment_is_top":false,"comment_ctime":1565053709,"is_pvip":false,"replies":[{"id":44478,"content":"你这个问题我们会在第8节课中统一解答。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565055277,"ip_address":"","comment_id":121060,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"想问下老师，所谓的同一个消费组，可以理解为就是官方的集群模式？这个组内的消费者只有一个实例可以消费到订阅的主题","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461600,"discussion_content":"请继续看一下08答疑这篇，对于你的疑问，我在里面有详细的讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566521593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120490,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1564911475,"is_pvip":false,"replies":[{"id":46918,"content":"请继续看一下08答疑这节课，针对你这些以外，我在里面有详细的说明。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566521522,"ip_address":"","comment_id":120490,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"两个疑问，\n第一个疑问，消费队列，消费组 他们之间的关系不是很了解，是一一对应关系吗？一个消息队列对应一个消费组！还是一个消费组对应一个主题中所有消息队列。\n\n第二个疑问:据我的理解，消费组是针对不同的下游业务系统所做的不同的划分，比如订单系统，风控系统每个都是一个消费组。\n那消费队列在其中是怎么个角色，每一条生产者发布的消息往所有消息队列发布一条信息？还是只是往其中一个消息队列发布一条消息？\n\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461599,"discussion_content":"你这个问题我们会在第8节课中统一解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565055277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120489,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1564911475,"is_pvip":false,"replies":[{"id":44269,"content":"我在08 答疑中会专门再把这个问题详细讲一下。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564968007,"ip_address":"","comment_id":120489,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"两个疑问，\n第一个疑问，消费队列，消费组 他们之间的关系不是很了解，是一一对应关系吗？一个消息队列对应一个消费组！还是一个消费组对应一个主题中所有消息队列。\n\n第二个疑问:据我的理解，消费组是针对不同的下游业务系统所做的不同的划分，比如订单系统，风控系统每个都是一个消费组。\n那消费队列在其中是怎么个角色，每一条生产者发布的消息往所有消息队列发布一条信息？还是只是往其中一个消息队列发布一条消息？\n\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461356,"discussion_content":"我在08 答疑中会专门再把这个问题详细讲一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564968007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119988,"user_name":"箭指流云","can_delete":false,"product_type":"c1","uid":1367877,"ip_address":"","ucode":"21571A7D60B10D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/VqgchrJWswwSLmxf1ict6icDDlZG5wChBEiaiblnJAQEdu1nYtB4EZq07mibUurOSDFr16dho6DhGyOpIW4eib57lK8Q/132","comment_is_top":false,"comment_ctime":1564745275,"is_pvip":false,"replies":[{"id":44103,"content":"A1：没有严格要求一定消费者的数量和队列数量一样。\nA2：应该说是“主题中包含队列”，队列是一个使用层面的逻辑概念，实际实现的时候各不一样。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564799090,"ip_address":"","comment_id":119988,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"麻烦老师解答\n1、rabbitMQ中有多少个消费者就要多少个队列吗\n2、rocketMQ和rabbitMQ中的主题都是用队列实现的吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461163,"discussion_content":"A1：没有严格要求一定消费者的数量和队列数量一样。\nA2：应该说是“主题中包含队列”，队列是一个使用层面的逻辑概念，实际实现的时候各不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564799090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119578,"user_name":"Zzz","can_delete":false,"product_type":"c1","uid":1126750,"ip_address":"","ucode":"9573B50F5B26CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/5e/542fa713.jpg","comment_is_top":false,"comment_ctime":1564628884,"is_pvip":false,"replies":[{"id":43952,"content":"即使在同一个消费组内多个消费者来消费，也是可以保证顺序的，你可以对照消息模型再想一下为什么可以保证顺序。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564707141,"ip_address":"","comment_id":119578,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"必须要有序消费的消息，在多消费者的情况下的实践是不是不太好？ 因为每个生产者每次都是去取一条或者一批消息来消费的，多个消费者就导致消息的消费无法保证无序了。 ","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460962,"discussion_content":"即使在同一个消费组内多个消费者来消费，也是可以保证顺序的，你可以对照消息模型再想一下为什么可以保证顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564707141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119394,"user_name":"极客是一种精神","can_delete":false,"product_type":"c1","uid":1325365,"ip_address":"","ucode":"7CD9EF88F51E21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/uT6JB2EZEST9UKtXiaSvu4mjneI3bWMJe0blWhZ15jjndPQlEicib1PDbC7zGobiccHc4cSzpmic8ibdgzzFw0WqYarA/132","comment_is_top":false,"comment_ctime":1564578064,"is_pvip":false,"replies":[{"id":43839,"content":"同学，我们这个图里面只画了一个消费组啊。这个主题有2个队列，对于一个消费组，每个队列的消费位置都要记录。所以画了2个消费位置。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564626678,"ip_address":"","comment_id":119394,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"https:&#47;&#47;static001.geekbang.org&#47;resource&#47;image&#47;46&#47;17&#47;465142ab5b5096f283118c307e8cc117.jpg\n这边图里面的队列2是不是应当是队列1？同一个队列，维护了两个不同的消费组的消费位置？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460884,"discussion_content":"同学，我们这个图里面只画了一个消费组啊。这个主题有2个队列，对于一个消费组，每个队列的消费位置都要记录。所以画了2个消费位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564626678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119231,"user_name":"小阿刁","can_delete":false,"product_type":"c1","uid":1553029,"ip_address":"","ucode":"1B9DDAFBE74136","user_header":"https://static001.geekbang.org/account/avatar/00/17/b2/85/3af6ec4a.jpg","comment_is_top":false,"comment_ctime":1564540212,"is_pvip":false,"replies":[{"id":43851,"content":"Keynote画的😊","user_name":"编辑回复","user_name_real":"孙茹","uid":1336776,"ctime":1564627320,"ip_address":"","comment_id":119231,"utype":2}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"这个图是用什么软件画的？","like_count":0},{"had_liked":false,"id":119102,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1564503442,"is_pvip":false,"replies":[{"id":43709,"content":"这个取决于你的需求了，一般来说不需要。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564537887,"ip_address":"","comment_id":119102,"utype":1}],"discussion_count":2,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"请教一下，对于消息的发送和消费，是否有必要将相关信息(比如messageid,tag,topic,消息体）记录到数据库 ，作为日志，以方便排查问题？因为用阿里云的消息中间件，默认只能查到最近三天的消息。。","like_count":0,"discussions":[{"author":{"id":1336776,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/c8/fc094eec.jpg","nickname":"大茹","note":"","ucode":"4681A1EDD8D6F7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460795,"discussion_content":"Keynote画的😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564627320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118951,"user_name":"陈泽坛","can_delete":false,"product_type":"c1","uid":1394861,"ip_address":"","ucode":"C81B402868E9E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/ad/8be724da.jpg","comment_is_top":false,"comment_ctime":1564473484,"is_pvip":false,"replies":[{"id":43706,"content":"额，实际就是这样的。但由于RabbitMQ默认都是在内存中保存消息，实际性能也还好。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564537800,"ip_address":"","comment_id":118951,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"rabbitmq的发送多人是否与\n“同样的一份消息数据被复制到多个队列中会浪费资源” 冲突？ rabiitmq会很蠢吗\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460745,"discussion_content":"这个取决于你的需求了，一般来说不需要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564537887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018494,"avatar":"","nickname":"whhbbq","note":"","ucode":"4A93F3E375CB44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3517,"discussion_content":"那消息一直消费失败，达到重试上线了，人还没发现，这种后面怎么去找到这条消息呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564545572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118929,"user_name":"lecy_L","can_delete":false,"product_type":"c1","uid":1127659,"ip_address":"","ucode":"7C96DDBB3D1F7E","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","comment_is_top":false,"comment_ctime":1564470561,"is_pvip":false,"replies":[{"id":43705,"content":"A1：可能是多次消费失败被丢到重试队列中了，具体还得实际看一下。\n\nA2：延时消息的实现，很难一两句话讲清楚，不同的队列实现方式也不一样，我后面在答疑里面或者开一个专题来讲一下这个问题。\n\nA3：延时消息是单独处理的，不会按照顺序消费。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564537733,"ip_address":"","comment_id":118929,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"老师你好，我有几个疑惑的地方，希望老师可以帮忙解答。\n疑问1：我现在系统用到的是rocketMQ,linux系统下查看某个topic默认有5个队列，我生产了一条消息，在消费端返回ACKfasle。刚开始这个消息进入了B队列，由于确认机制返回false，该消息在B队列显示已消费，不过在A队列多了一个未消费的消息，这是消息重试的队列吗？原理过程是怎么样的？\n疑问2：该消息进入到A队列后会有一定的延迟，和延时投递级别中的相对应。延时投递这块是什么样的原理。\n疑问3：通过实践发现，如果在A队列里，有多个未消费的消息。消息1延时投递级别到了3（默认30s），消息2级别是1（默认1s）。消息1在消息2的前面，那这种情况下消息2是否会等待消息1成功消费或者进入死信队列才进行消费？(实际应用中似乎是不会等待)不明白为什么","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460669,"discussion_content":"A1：可能是多次消费失败被丢到重试队列中了，具体还得实际看一下。\n\nA2：延时消息的实现，很难一两句话讲清楚，不同的队列实现方式也不一样，我后面在答疑里面或者开一个专题来讲一下这个问题。\n\nA3：延时消息是单独处理的，不会按照顺序消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564537733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118720,"user_name":"玩命","can_delete":false,"product_type":"c1","uid":1106854,"ip_address":"","ucode":"68FEEA5F541B7E","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/a6/3f6f0cea.jpg","comment_is_top":false,"comment_ctime":1564439989,"is_pvip":false,"replies":[{"id":43539,"content":"bingo！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564450545,"ip_address":"","comment_id":118720,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"Rocketmq 在多个消费组之间是广播模式，在单个消费者多台机器的情况下可以设置广播模式或者集群模式。不知这样的理解可对","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460669,"discussion_content":"A1：可能是多次消费失败被丢到重试队列中了，具体还得实际看一下。\n\nA2：延时消息的实现，很难一两句话讲清楚，不同的队列实现方式也不一样，我后面在答疑里面或者开一个专题来讲一下这个问题。\n\nA3：延时消息是单独处理的，不会按照顺序消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564537733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118607,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1564395368,"is_pvip":false,"replies":[{"id":43528,"content":"这个是无所谓的，只要一个消费组中所有实例能把所有队列都消费到就可以了，哪个实例消费哪个队列并没有特别的要求。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449474,"ip_address":"","comment_id":118607,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"老师  RocketMQ的那张图    consumer2的消费折线是不是指向Quene1更合理呢！！！","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460545,"discussion_content":"bingo！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564450545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118469,"user_name":"一个想偷懒的程序坑","can_delete":false,"product_type":"c1","uid":1013223,"ip_address":"","ucode":"C5F221A7065B74","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/e7/326d7515.jpg","comment_is_top":false,"comment_ctime":1564370723,"is_pvip":false,"replies":[{"id":43525,"content":"我们在答疑中统一解答。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449231,"ip_address":"","comment_id":118469,"utype":1}],"discussion_count":2,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"老师，能简单讲下消息空洞的概念吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460479,"discussion_content":"这个是无所谓的，只要一个消费组中所有实例能把所有队列都消费到就可以了，哪个实例消费哪个队列并没有特别的要求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118467,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1564370499,"is_pvip":false,"replies":[{"id":43524,"content":"同一个消费组中的每个consumer实例只消费一部分消息，所以对于一个特定的consumer实例没必要消费所有的queue。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449218,"ip_address":"","comment_id":118467,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"李老师\n    请问：producer1生产消息到topic下queue1，consumer1对应queue2，这时consumer1要消费queue1怎么办？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460421,"discussion_content":"同一个消费组中的每个consumer实例只消费一部分消息，所以对于一个特定的consumer实例没必要消费所有的queue。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118458,"user_name":"........Vendetta","can_delete":false,"product_type":"c1","uid":1163062,"ip_address":"","ucode":"B8DEB64395C84A","user_header":"https://static001.geekbang.org/account/avatar/00/11/bf/36/481f24da.jpg","comment_is_top":false,"comment_ctime":1564368414,"is_pvip":false,"replies":[{"id":43523,"content":"我会在答疑中统一讲一下RocketMQ是怎么做的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449131,"ip_address":"","comment_id":118458,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"消息位置的处理实现有经典算法么？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460416,"discussion_content":"我会在答疑中统一讲一下RocketMQ是怎么做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118409,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1564361388,"is_pvip":false,"replies":[{"id":43373,"content":"不需要，RocketMQ和Kafka通过消费组来解决这个问题，不同的订阅者使用不同的消费组，他们之间互不影响。\n\nRabbitMQ是需要为每个订阅者来创建队列的，它通过exchange来解耦。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364133,"ip_address":"","comment_id":118409,"utype":1}],"discussion_count":2,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"老师，我想问一下，文中说生产者给每个消费者都创建一条队列的做法是愚蠢的，同时无法解耦。那么我是否应该在broker中给每个消费者创建一条队列呢？(或者说主题给每个订阅者创建一条队列来存放消息)    ","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460397,"discussion_content":"不需要，RocketMQ和Kafka通过消费组来解决这个问题，不同的订阅者使用不同的消费组，他们之间互不影响。\n\nRabbitMQ是需要为每个订阅者来创建队列的，它通过exchange来解耦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613227,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","nickname":"林林","note":"","ucode":"7B6318B971E430","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3263,"discussion_content":"那同一个消费组中，就只存在一个队列吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119231,"user_name":"小阿刁","can_delete":false,"product_type":"c1","uid":1553029,"ip_address":"","ucode":"1B9DDAFBE74136","user_header":"https://static001.geekbang.org/account/avatar/00/17/b2/85/3af6ec4a.jpg","comment_is_top":false,"comment_ctime":1564540212,"is_pvip":false,"replies":[{"id":43851,"content":"Keynote画的😊","user_name":"编辑回复","user_name_real":"孙茹","uid":1336776,"ctime":1564627320,"ip_address":"","comment_id":119231,"utype":2}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"这个图是用什么软件画的？","like_count":0,"discussions":[{"author":{"id":1336776,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/c8/fc094eec.jpg","nickname":"大茹","note":"","ucode":"4681A1EDD8D6F7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460795,"discussion_content":"Keynote画的😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564627320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119102,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1564503442,"is_pvip":false,"replies":[{"id":43709,"content":"这个取决于你的需求了，一般来说不需要。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564537887,"ip_address":"","comment_id":119102,"utype":1}],"discussion_count":2,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"请教一下，对于消息的发送和消费，是否有必要将相关信息(比如messageid,tag,topic,消息体）记录到数据库 ，作为日志，以方便排查问题？因为用阿里云的消息中间件，默认只能查到最近三天的消息。。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460745,"discussion_content":"这个取决于你的需求了，一般来说不需要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564537887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018494,"avatar":"","nickname":"whhbbq","note":"","ucode":"4A93F3E375CB44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3517,"discussion_content":"那消息一直消费失败，达到重试上线了，人还没发现，这种后面怎么去找到这条消息呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564545572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118951,"user_name":"陈泽坛","can_delete":false,"product_type":"c1","uid":1394861,"ip_address":"","ucode":"C81B402868E9E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/ad/8be724da.jpg","comment_is_top":false,"comment_ctime":1564473484,"is_pvip":false,"replies":[{"id":43706,"content":"额，实际就是这样的。但由于RabbitMQ默认都是在内存中保存消息，实际性能也还好。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564537800,"ip_address":"","comment_id":118951,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"rabbitmq的发送多人是否与\n“同样的一份消息数据被复制到多个队列中会浪费资源” 冲突？ rabiitmq会很蠢吗\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460683,"discussion_content":"额，实际就是这样的。但由于RabbitMQ默认都是在内存中保存消息，实际性能也还好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564537800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118929,"user_name":"lecy_L","can_delete":false,"product_type":"c1","uid":1127659,"ip_address":"","ucode":"7C96DDBB3D1F7E","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","comment_is_top":false,"comment_ctime":1564470561,"is_pvip":false,"replies":[{"id":43705,"content":"A1：可能是多次消费失败被丢到重试队列中了，具体还得实际看一下。\n\nA2：延时消息的实现，很难一两句话讲清楚，不同的队列实现方式也不一样，我后面在答疑里面或者开一个专题来讲一下这个问题。\n\nA3：延时消息是单独处理的，不会按照顺序消费。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564537733,"ip_address":"","comment_id":118929,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"老师你好，我有几个疑惑的地方，希望老师可以帮忙解答。\n疑问1：我现在系统用到的是rocketMQ,linux系统下查看某个topic默认有5个队列，我生产了一条消息，在消费端返回ACKfasle。刚开始这个消息进入了B队列，由于确认机制返回false，该消息在B队列显示已消费，不过在A队列多了一个未消费的消息，这是消息重试的队列吗？原理过程是怎么样的？\n疑问2：该消息进入到A队列后会有一定的延迟，和延时投递级别中的相对应。延时投递这块是什么样的原理。\n疑问3：通过实践发现，如果在A队列里，有多个未消费的消息。消息1延时投递级别到了3（默认30s），消息2级别是1（默认1s）。消息1在消息2的前面，那这种情况下消息2是否会等待消息1成功消费或者进入死信队列才进行消费？(实际应用中似乎是不会等待)不明白为什么","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460683,"discussion_content":"额，实际就是这样的。但由于RabbitMQ默认都是在内存中保存消息，实际性能也还好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564537800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118720,"user_name":"玩命","can_delete":false,"product_type":"c1","uid":1106854,"ip_address":"","ucode":"68FEEA5F541B7E","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/a6/3f6f0cea.jpg","comment_is_top":false,"comment_ctime":1564439989,"is_pvip":false,"replies":[{"id":43539,"content":"bingo！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564450545,"ip_address":"","comment_id":118720,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"Rocketmq 在多个消费组之间是广播模式，在单个消费者多台机器的情况下可以设置广播模式或者集群模式。不知这样的理解可对","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460545,"discussion_content":"bingo！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564450545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118607,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1564395368,"is_pvip":false,"replies":[{"id":43528,"content":"这个是无所谓的，只要一个消费组中所有实例能把所有队列都消费到就可以了，哪个实例消费哪个队列并没有特别的要求。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449474,"ip_address":"","comment_id":118607,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"老师  RocketMQ的那张图    consumer2的消费折线是不是指向Quene1更合理呢！！！","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460479,"discussion_content":"这个是无所谓的，只要一个消费组中所有实例能把所有队列都消费到就可以了，哪个实例消费哪个队列并没有特别的要求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118469,"user_name":"一个想偷懒的程序坑","can_delete":false,"product_type":"c1","uid":1013223,"ip_address":"","ucode":"C5F221A7065B74","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/e7/326d7515.jpg","comment_is_top":false,"comment_ctime":1564370723,"is_pvip":false,"replies":[{"id":43525,"content":"我们在答疑中统一解答。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449231,"ip_address":"","comment_id":118469,"utype":1}],"discussion_count":2,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"老师，能简单讲下消息空洞的概念吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460422,"discussion_content":"我们在答疑中统一解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013223,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/e7/326d7515.jpg","nickname":"一个想偷懒的程序坑","note":"","ucode":"C5F221A7065B74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3384,"discussion_content":"OK","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118467,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1564370499,"is_pvip":false,"replies":[{"id":43524,"content":"同一个消费组中的每个consumer实例只消费一部分消息，所以对于一个特定的consumer实例没必要消费所有的queue。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449218,"ip_address":"","comment_id":118467,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"李老师\n    请问：producer1生产消息到topic下queue1，consumer1对应queue2，这时consumer1要消费queue1怎么办？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460422,"discussion_content":"我们在答疑中统一解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013223,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/e7/326d7515.jpg","nickname":"一个想偷懒的程序坑","note":"","ucode":"C5F221A7065B74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3384,"discussion_content":"OK","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118458,"user_name":"........Vendetta","can_delete":false,"product_type":"c1","uid":1163062,"ip_address":"","ucode":"B8DEB64395C84A","user_header":"https://static001.geekbang.org/account/avatar/00/11/bf/36/481f24da.jpg","comment_is_top":false,"comment_ctime":1564368414,"is_pvip":false,"replies":[{"id":43523,"content":"我会在答疑中统一讲一下RocketMQ是怎么做的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564449131,"ip_address":"","comment_id":118458,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"消息位置的处理实现有经典算法么？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460421,"discussion_content":"同一个消费组中的每个consumer实例只消费一部分消息，所以对于一个特定的consumer实例没必要消费所有的queue。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118409,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1564361388,"is_pvip":false,"replies":[{"id":43373,"content":"不需要，RocketMQ和Kafka通过消费组来解决这个问题，不同的订阅者使用不同的消费组，他们之间互不影响。\n\nRabbitMQ是需要为每个订阅者来创建队列的，它通过exchange来解耦。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364133,"ip_address":"","comment_id":118409,"utype":1}],"discussion_count":2,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"老师，我想问一下，文中说生产者给每个消费者都创建一条队列的做法是愚蠢的，同时无法解耦。那么我是否应该在broker中给每个消费者创建一条队列呢？(或者说主题给每个订阅者创建一条队列来存放消息)    ","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460416,"discussion_content":"我会在答疑中统一讲一下RocketMQ是怎么做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564449131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118404,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1564361009,"is_pvip":false,"replies":[{"id":43374,"content":"A1：消费者来维护消费位置，也要解决好空洞问题。\nA2：是的，但RocketMQ和Kafka都有消息堆积能力，只要存储空间足够大，它们可以一直保存消息。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364279,"ip_address":"","comment_id":118404,"utype":1}],"discussion_count":2,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"如果把offset指针放到消费者身上，由消费者自行维护，是否就可以实现并行消费呢？ 不过如果多个消费者的消费速度不一致，可能导致过多消息滞留在队列中？","like_count":0},{"had_liked":false,"id":118397,"user_name":"Felix","can_delete":false,"product_type":"c1","uid":1078852,"ip_address":"","ucode":"463050E4D6358C","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/44/8dc434dc.jpg","comment_is_top":false,"comment_ctime":1564360354,"is_pvip":false,"replies":[{"id":43376,"content":"这个问题我会在后面的课程中专门来讲，如何应对重复消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364455,"ip_address":"","comment_id":118397,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"请求确认机制，mq接受到生产者发来的消息，但在回复确认时没发出去或超时了。这时生产者没接收到确认信息就会重新发信息，那消息不就发重了吗？这种请求确认机制是否有办法能避免这种情况的发生呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460393,"discussion_content":"这个问题我会在后面的课程中专门来讲，如何应对重复消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118361,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1564332133,"is_pvip":false,"replies":[{"id":43377,"content":"我会在答疑中统一讲解这个问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364541,"ip_address":"","comment_id":118361,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"对于思考题，单个队列并发消费，如何维护消费偏移没想到方法。比如线程1在消费位置1上的，线程2在消费位置5上的，那么怎么让下一个消费者知道可以消费2、3、4，但是不能消费1和5。我能想到的是用bitmap，但是这个维护成本也比较高。希望老师在下期文章开始里解答一下这个思考题。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460375,"discussion_content":"我会在答疑中统一讲解这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118260,"user_name":"小菜","can_delete":false,"product_type":"c1","uid":1121738,"ip_address":"","ucode":"BC0A84C7055824","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/ca/6dd795d9.jpg","comment_is_top":false,"comment_ctime":1564303957,"is_pvip":false,"replies":[{"id":43397,"content":"消费组的作用不是为了并行消费提升性能，而是为了区分不同的消费订阅，确保他们之间互不影响。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564366036,"ip_address":"","comment_id":118260,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"有个问题哈，如果queue中的消息按严格的单条“请求-确认”机制处理，那么consume_group的概念发挥不了啥优势呢，每一时刻一个组中只能有一个实例在处理消息。除非支持单queue并行处理，才能通过扩展单group中的消费实例数来提高消费处理能力","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460329,"discussion_content":"消费组的作用不是为了并行消费提升性能，而是为了区分不同的消费订阅，确保他们之间互不影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564366036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118250,"user_name":"小菜","can_delete":false,"product_type":"c1","uid":1121738,"ip_address":"","ucode":"BC0A84C7055824","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/ca/6dd795d9.jpg","comment_is_top":false,"comment_ctime":1564302250,"is_pvip":false,"replies":[{"id":43396,"content":"这个方案没为题，但你还需要想一下，如何解决消息空洞的问题：如果一个滑动窗口中，有一条消息一直没收到确认，这时候该怎么办？","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365977,"ip_address":"","comment_id":118250,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"课后习题：采用TCP类似的消息累积确认机制+重传，消息分3个状态：已拉取待确认、已消费、未消费；\n设置个窗口用于限制单队列“已拉取待确认”的消息数，窗口大小为1时表示严格顺序处理，&gt;1时支持并行处理。这个方案是否OK？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460321,"discussion_content":"这个方案没为题，但你还需要想一下，如何解决消息空洞的问题：如果一个滑动窗口中，有一条消息一直没收到确认，这时候该怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118216,"user_name":"张洪阆","can_delete":false,"product_type":"c1","uid":1001954,"ip_address":"","ucode":"CFF7035D0DF059","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/e2/1fad12eb.jpg","comment_is_top":false,"comment_ctime":1564294824,"is_pvip":false,"replies":[{"id":43392,"content":"这个图里面画的2个队列，里面存的是不一样的消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365439,"ip_address":"","comment_id":118216,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"其实不必分开两个队列啊，直接用一个循环队列，共用一个offset","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460306,"discussion_content":"这个图里面画的2个队列，里面存的是不一样的消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118155,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1564280839,"is_pvip":false,"replies":[{"id":43389,"content":"A1：是需要维护订阅信息，这个没错。但是消费的时候一般都是客户端主动去服务端拉消息，而不是推送。\nA2：是。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365237,"ip_address":"","comment_id":118155,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"请老师帮忙确认下：\n\n1 发布订阅模式也需要依靠队列实现吧，然后我猜是维护一个消费者订阅列表，然后遍历所有消费者进行发送\n\n2 一个队列上的串行消费指的是当前消息必须ack之后才发送下一个消息是吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460306,"discussion_content":"这个图里面画的2个队列，里面存的是不一样的消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118100,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1564241185,"is_pvip":false,"replies":[{"id":43385,"content":"关于均匀客户端的问题，在服务端是有协调者来统一协调和分配的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364970,"ip_address":"","comment_id":118100,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"也想到过多个offset，但是没想明白多个offset怎么均匀的对队列进行划分来充分利用客户端(比如各个客户端消费能力一样，会不会有的饿死有的忙死)，producer是从入口一个个往队列里生产消息，那队列应该是慢慢被填充满的，各个消费者的offset要怎么设置呢？\n不知道有没有想偏，希望老师解惑~\n这章概念讲的真的很清楚，知其然又知其所以然！","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460282,"discussion_content":"A1：是需要维护订阅信息，这个没错。但是消费的时候一般都是客户端主动去服务端拉消息，而不是推送。\nA2：是。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118097,"user_name":"木刻","can_delete":false,"product_type":"c1","uid":1157430,"ip_address":"","ucode":"0A3226FEE3983B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","comment_is_top":false,"comment_ctime":1564239341,"is_pvip":false,"replies":[{"id":43383,"content":"不会。消费组之间是完全隔离的，每个消费组维护这个组内对应topic的所有分区的消费位置。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364872,"ip_address":"","comment_id":118097,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"老师您好，文中说&quot;消费组自己维护分区中的消费位置“，我今天看Kafka提到分区自己也维护了一个当前消费的位置，假设有多个分组消费同一个主题下的同一个分区，这里的位置就会不会造成混乱。谢谢老师","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460262,"discussion_content":"关于均匀客户端的问题，在服务端是有协调者来统一协调和分配的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118065,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1564225562,"is_pvip":false,"replies":[{"id":43260,"content":"由于RabbitMQ它的设计理念是不希望消息堆积的，所以多个queue也就相当于多个数据通道，在加上它的队列是可以不持久化到磁盘上的，所以复制消息到多个队列中的开销也还能接受。\n\n你的课后总结没问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564238007,"ip_address":"","comment_id":118065,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"有一个疑问，还请老师解答一下。RabbitMQ采用队列模式如果说为了给每个consumer都能发送到消息就创建多个队列，那不就与消费者硬绑定在一块了。成了那个很蠢的方案了吗。\n\n课后练习：每个queue上的数据被每个消费组消费完应该是不会被立刻删除的，会有一个过期时间，过期后删除，没有删除的数据还可以被新接进来的消费组消费。offset相当于数组下标，broker记录每个消费组在queue上的offset，每个queue上的不同的group的消费者之间不会有影响。consumer A消费失败了offset不会递增，等待消息重发，而consumer B继续向后消费。\n不知道理解的对不对，还请老师指点。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460247,"discussion_content":"由于RabbitMQ它的设计理念是不希望消息堆积的，所以多个queue也就相当于多个数据通道，在加上它的队列是可以不持久化到磁盘上的，所以复制消息到多个队列中的开销也还能接受。\n\n你的课后总结没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564238007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118404,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1564361009,"is_pvip":false,"replies":[{"id":43374,"content":"A1：消费者来维护消费位置，也要解决好空洞问题。\nA2：是的，但RocketMQ和Kafka都有消息堆积能力，只要存储空间足够大，它们可以一直保存消息。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364279,"ip_address":"","comment_id":118404,"utype":1}],"discussion_count":2,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"如果把offset指针放到消费者身上，由消费者自行维护，是否就可以实现并行消费呢？ 不过如果多个消费者的消费速度不一致，可能导致过多消息滞留在队列中？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460396,"discussion_content":"A1：消费者来维护消费位置，也要解决好空洞问题。\nA2：是的，但RocketMQ和Kafka都有消息堆积能力，只要存储空间足够大，它们可以一直保存消息。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613227,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","nickname":"林林","note":"","ucode":"7B6318B971E430","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3265,"discussion_content":"A2:所以一般消息队列都不会限制存放消息的数量吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118397,"user_name":"Felix","can_delete":false,"product_type":"c1","uid":1078852,"ip_address":"","ucode":"463050E4D6358C","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/44/8dc434dc.jpg","comment_is_top":false,"comment_ctime":1564360354,"is_pvip":false,"replies":[{"id":43376,"content":"这个问题我会在后面的课程中专门来讲，如何应对重复消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364455,"ip_address":"","comment_id":118397,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"请求确认机制，mq接受到生产者发来的消息，但在回复确认时没发出去或超时了。这时生产者没接收到确认信息就会重新发信息，那消息不就发重了吗？这种请求确认机制是否有办法能避免这种情况的发生呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460396,"discussion_content":"A1：消费者来维护消费位置，也要解决好空洞问题。\nA2：是的，但RocketMQ和Kafka都有消息堆积能力，只要存储空间足够大，它们可以一直保存消息。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613227,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","nickname":"林林","note":"","ucode":"7B6318B971E430","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3265,"discussion_content":"A2:所以一般消息队列都不会限制存放消息的数量吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118361,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1564332133,"is_pvip":false,"replies":[{"id":43377,"content":"我会在答疑中统一讲解这个问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364541,"ip_address":"","comment_id":118361,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"对于思考题，单个队列并发消费，如何维护消费偏移没想到方法。比如线程1在消费位置1上的，线程2在消费位置5上的，那么怎么让下一个消费者知道可以消费2、3、4，但是不能消费1和5。我能想到的是用bitmap，但是这个维护成本也比较高。希望老师在下期文章开始里解答一下这个思考题。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460393,"discussion_content":"这个问题我会在后面的课程中专门来讲，如何应对重复消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118260,"user_name":"小菜","can_delete":false,"product_type":"c1","uid":1121738,"ip_address":"","ucode":"BC0A84C7055824","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/ca/6dd795d9.jpg","comment_is_top":false,"comment_ctime":1564303957,"is_pvip":false,"replies":[{"id":43397,"content":"消费组的作用不是为了并行消费提升性能，而是为了区分不同的消费订阅，确保他们之间互不影响。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564366036,"ip_address":"","comment_id":118260,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"有个问题哈，如果queue中的消息按严格的单条“请求-确认”机制处理，那么consume_group的概念发挥不了啥优势呢，每一时刻一个组中只能有一个实例在处理消息。除非支持单queue并行处理，才能通过扩展单group中的消费实例数来提高消费处理能力","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460375,"discussion_content":"我会在答疑中统一讲解这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118250,"user_name":"小菜","can_delete":false,"product_type":"c1","uid":1121738,"ip_address":"","ucode":"BC0A84C7055824","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/ca/6dd795d9.jpg","comment_is_top":false,"comment_ctime":1564302250,"is_pvip":false,"replies":[{"id":43396,"content":"这个方案没为题，但你还需要想一下，如何解决消息空洞的问题：如果一个滑动窗口中，有一条消息一直没收到确认，这时候该怎么办？","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365977,"ip_address":"","comment_id":118250,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"课后习题：采用TCP类似的消息累积确认机制+重传，消息分3个状态：已拉取待确认、已消费、未消费；\n设置个窗口用于限制单队列“已拉取待确认”的消息数，窗口大小为1时表示严格顺序处理，&gt;1时支持并行处理。这个方案是否OK？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460329,"discussion_content":"消费组的作用不是为了并行消费提升性能，而是为了区分不同的消费订阅，确保他们之间互不影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564366036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118216,"user_name":"张洪阆","can_delete":false,"product_type":"c1","uid":1001954,"ip_address":"","ucode":"CFF7035D0DF059","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/e2/1fad12eb.jpg","comment_is_top":false,"comment_ctime":1564294824,"is_pvip":false,"replies":[{"id":43392,"content":"这个图里面画的2个队列，里面存的是不一样的消息。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365439,"ip_address":"","comment_id":118216,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"其实不必分开两个队列啊，直接用一个循环队列，共用一个offset","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460321,"discussion_content":"这个方案没为题，但你还需要想一下，如何解决消息空洞的问题：如果一个滑动窗口中，有一条消息一直没收到确认，这时候该怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118155,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1564280839,"is_pvip":false,"replies":[{"id":43389,"content":"A1：是需要维护订阅信息，这个没错。但是消费的时候一般都是客户端主动去服务端拉消息，而不是推送。\nA2：是。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564365237,"ip_address":"","comment_id":118155,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"请老师帮忙确认下：\n\n1 发布订阅模式也需要依靠队列实现吧，然后我猜是维护一个消费者订阅列表，然后遍历所有消费者进行发送\n\n2 一个队列上的串行消费指的是当前消息必须ack之后才发送下一个消息是吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460282,"discussion_content":"A1：是需要维护订阅信息，这个没错。但是消费的时候一般都是客户端主动去服务端拉消息，而不是推送。\nA2：是。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118100,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1564241185,"is_pvip":false,"replies":[{"id":43385,"content":"关于均匀客户端的问题，在服务端是有协调者来统一协调和分配的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364970,"ip_address":"","comment_id":118100,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"也想到过多个offset，但是没想明白多个offset怎么均匀的对队列进行划分来充分利用客户端(比如各个客户端消费能力一样，会不会有的饿死有的忙死)，producer是从入口一个个往队列里生产消息，那队列应该是慢慢被填充满的，各个消费者的offset要怎么设置呢？\n不知道有没有想偏，希望老师解惑~\n这章概念讲的真的很清楚，知其然又知其所以然！","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460262,"discussion_content":"关于均匀客户端的问题，在服务端是有协调者来统一协调和分配的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118097,"user_name":"木刻","can_delete":false,"product_type":"c1","uid":1157430,"ip_address":"","ucode":"0A3226FEE3983B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","comment_is_top":false,"comment_ctime":1564239341,"is_pvip":false,"replies":[{"id":43383,"content":"不会。消费组之间是完全隔离的，每个消费组维护这个组内对应topic的所有分区的消费位置。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564364872,"ip_address":"","comment_id":118097,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"老师您好，文中说&quot;消费组自己维护分区中的消费位置“，我今天看Kafka提到分区自己也维护了一个当前消费的位置，假设有多个分组消费同一个主题下的同一个分区，这里的位置就会不会造成混乱。谢谢老师","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460261,"discussion_content":"不会。消费组之间是完全隔离的，每个消费组维护这个组内对应topic的所有分区的消费位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118065,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1564225562,"is_pvip":false,"replies":[{"id":43260,"content":"由于RabbitMQ它的设计理念是不希望消息堆积的，所以多个queue也就相当于多个数据通道，在加上它的队列是可以不持久化到磁盘上的，所以复制消息到多个队列中的开销也还能接受。\n\n你的课后总结没问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564238007,"ip_address":"","comment_id":118065,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100032301,"comment_content":"有一个疑问，还请老师解答一下。RabbitMQ采用队列模式如果说为了给每个consumer都能发送到消息就创建多个队列，那不就与消费者硬绑定在一块了。成了那个很蠢的方案了吗。\n\n课后练习：每个queue上的数据被每个消费组消费完应该是不会被立刻删除的，会有一个过期时间，过期后删除，没有删除的数据还可以被新接进来的消费组消费。offset相当于数组下标，broker记录每个消费组在queue上的offset，每个queue上的不同的group的消费者之间不会有影响。consumer A消费失败了offset不会递增，等待消息重发，而consumer B继续向后消费。\n不知道理解的对不对，还请老师指点。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460261,"discussion_content":"不会。消费组之间是完全隔离的，每个消费组维护这个组内对应topic的所有分区的消费位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118025,"user_name":"sayid","can_delete":false,"product_type":"c1","uid":1101465,"ip_address":"","ucode":"E40E0D86768DCA","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/99/4382727b.jpg","comment_is_top":false,"comment_ctime":1564214441,"is_pvip":false,"replies":[{"id":43258,"content":"具体说说？","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564237491,"ip_address":"","comment_id":118025,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"并行消费，数据模式参考ConcurrentHashMap ?","like_count":0},{"had_liked":false,"id":117967,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1564199688,"is_pvip":false,"replies":[{"id":43185,"content":"你说的没错，并行消费是RocketMQ的一个功能，但它和我们讲的原理是不矛盾的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564206309,"ip_address":"","comment_id":117967,"utype":1}],"discussion_count":2,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"以rocketmq为例，虽然表面上一个group针对一个queue只能有一个consumer，看起来是顺序消费，但其实consumer的实现逻辑中，默认是多线程并行的。有点类似每个consumer又衍生出若干个sub consumer。实现起来，从consumer和broker通信的角度，要求允许靠后的offset的ack把前面的offset也确认了。在我印象里三大主流mq都有这个机制？\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460227,"discussion_content":"具体说说？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564237491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117965,"user_name":"兜兜","can_delete":false,"product_type":"c1","uid":1297941,"ip_address":"","ucode":"9033348BEF5F5A","user_header":"https://static001.geekbang.org/account/avatar/00/13/ce/15/51187703.jpg","comment_is_top":false,"comment_ctime":1564199615,"is_pvip":true,"replies":[{"id":43186,"content":"感谢你的反馈。你疑惑的地方，可以留言写出具体内容，我们来讨论。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564206341,"ip_address":"","comment_id":117965,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"RocketMQ的图是不是画错了","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460201,"discussion_content":"感谢你的反馈。你疑惑的地方，可以留言写出具体内容，我们来讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564206341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117925,"user_name":"我知道了嗯","can_delete":false,"product_type":"c1","uid":1138471,"ip_address":"","ucode":"9186EC1F32C490","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/27/a6873bc9.jpg","comment_is_top":false,"comment_ctime":1564193432,"is_pvip":false,"replies":[{"id":43207,"content":"不会。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564209008,"ip_address":"","comment_id":117925,"utype":1}],"discussion_count":2,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"kafka的一个主题如果都多个分区，那么这多个分区里面的数据是会有重复的嘛？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460183,"discussion_content":"不会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564209008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138471,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5f/27/a6873bc9.jpg","nickname":"我知道了嗯","note":"","ucode":"9186EC1F32C490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3134,"discussion_content":"消费同一个分区的数据我知道是有序的，但是如果有多个分区，每个分区之间怎么做到有序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564213299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117898,"user_name":"原军","can_delete":false,"product_type":"c1","uid":1016202,"ip_address":"","ucode":"003C988716FBCC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/8a/0b065758.jpg","comment_is_top":false,"comment_ctime":1564186051,"is_pvip":false,"replies":[{"id":43203,"content":"可以","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208882,"ip_address":"","comment_id":117898,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"老师好，rabbitMq能保证消息不丢失和严格顺序吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460183,"discussion_content":"不会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564209008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138471,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5f/27/a6873bc9.jpg","nickname":"我知道了嗯","note":"","ucode":"9186EC1F32C490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3134,"discussion_content":"消费同一个分区的数据我知道是有序的，但是如果有多个分区，每个分区之间怎么做到有序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564213299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117894,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1564185481,"is_pvip":false,"replies":[{"id":43202,"content":"如果每个tag对应一个consumer group，是可以并行的。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208872,"ip_address":"","comment_id":117894,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"老师记得rocket的topic下还有个tag的概念吧，消费者可以消费只同一topic下的不同tag里的消息。这样是否是实现并行？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460167,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117888,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1564181979,"is_pvip":false,"replies":[{"id":43199,"content":"不同的消费组之间，除了消费的是同一个topic以外，是完全没有任何关系的。每个消费组记录自己的消费位置，所以是不会“串”的。\n\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208185,"ip_address":"","comment_id":117888,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"我觉得如果不严格按照顺序的话：消费组是否会乱？可能我觉得至少当前模式，消费组的各个消费者所获得要处理的消息是差不多的-至少我觉得当前的模式是为了消费组各组的信息差不多，rockmq最大的特性不是稳定性么。\n其实老师在说问这个问题的时候我觉得在引发出了另外一个问题：如果不按照严格顺序，那么消费组的消息各组之间的消息数可能完全不一样，引发的问题如何处理？\n这只是我对于今天学习的理解：不足之处还望老师提点。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460164,"discussion_content":"如果每个tag对应一个consumer group，是可以并行的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118096,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1091781,"ip_address":"","ucode":"67802124F5181D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epjdWhOia2BKpvYDUIria0klBOvxU4v8CfsobsGYicUia6Hybb4n658LfJymFbuPk0koxldr6QIOpQsMA/132","comment_is_top":false,"comment_ctime":1564239294,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"类似TCP可靠传输方式，使用滑窗实现消息删除","like_count":8},{"had_liked":false,"id":280080,"user_name":"perkyoung","can_delete":false,"product_type":"c1","uid":1308321,"ip_address":"","ucode":"9EFB0BC6A6D5D6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJia2mqq4pWHVYtN9fXZ91iajnE0ib3JqQejD9oo7kusbY64uDPrib1yOBzowoFCA4ORHUDF3HEWCZIMQ/132","comment_is_top":false,"comment_ctime":1614071285,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"看了评论后，觉得如果老师在RocketMQ 的消息模型中，画两个消费组，就起码能解决很多人的疑惑","like_count":2},{"had_liked":false,"id":287357,"user_name":"三角形小于零","can_delete":false,"product_type":"c1","uid":1026174,"ip_address":"","ucode":"C2F89597662D4B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/7e/c9201b20.jpg","comment_is_top":false,"comment_ctime":1617898538,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"评论没法贴 ERD，老师请教一下这样理解是否正确：\n\nTopic : queue = 1 : n  一个 topic 下有多个 queue；  一条消息只会投递到这个 topic 的某一个 queue 下(具体哪一个取决于策略)。\n\nTopic : consumer group = 1 : n  一个 topic 下可以有多个 consumer group； 每个订阅该 topic 的 consumer group 会得到该 topic 的完整消息。 例如解耦场景中: 发给订单topic 的消息会分别送到支付系统consume group、风控系统 consumer group、客服系统 consumer group..... \n\nconsumer group : topic = 1:n 一个消费者组可以订阅多个 topic； \n\nqueue : consumer = 1 : n  可能会有多个消费者同时在等某一个 queue 的消息，而一条消息只能给其中一个等待中的消费者（当然这些消费者同属于一个消费者组） ；  如果有消息a和消息b要保证按顺序消费，那就要投递到同一个 topic 同一个 queue 下。在同一个queue 里的消息a处理完后，消费者才能取到消息b，所以是有序的。 \n\nconsumer group ：queue = 1:n   消费者组里的消费者们并行地从订阅的这个 topic 里的多个 queue  里取消息进行消费。\n\n\n订阅topic的人是 consumer group 而非 consumer， 订阅的是 topic 而非 queue。\n当某个 topic 下的消息堆积后，增加  queue 的数量、增加消费者组里的消费者的数量。 提高并行处理能力。\n\n\n\n","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460162,"discussion_content":"不同的消费组之间，除了消费的是同一个topic以外，是完全没有任何关系的。每个消费组记录自己的消费位置，所以是不会“串”的。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118025,"user_name":"sayid","can_delete":false,"product_type":"c1","uid":1101465,"ip_address":"","ucode":"E40E0D86768DCA","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/99/4382727b.jpg","comment_is_top":false,"comment_ctime":1564214441,"is_pvip":false,"replies":[{"id":43258,"content":"具体说说？","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564237491,"ip_address":"","comment_id":118025,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"并行消费，数据模式参考ConcurrentHashMap ?","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460227,"discussion_content":"具体说说？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564237491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117967,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1564199688,"is_pvip":false,"replies":[{"id":43185,"content":"你说的没错，并行消费是RocketMQ的一个功能，但它和我们讲的原理是不矛盾的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564206309,"ip_address":"","comment_id":117967,"utype":1}],"discussion_count":2,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"以rocketmq为例，虽然表面上一个group针对一个queue只能有一个consumer，看起来是顺序消费，但其实consumer的实现逻辑中，默认是多线程并行的。有点类似每个consumer又衍生出若干个sub consumer。实现起来，从consumer和broker通信的角度，要求允许靠后的offset的ack把前面的offset也确认了。在我印象里三大主流mq都有这个机制？\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460203,"discussion_content":"你说的没错，并行消费是RocketMQ的一个功能，但它和我们讲的原理是不矛盾的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564206309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","nickname":"Geek_zbvt62","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3142,"discussion_content":"误会了，其实我是在回答思考题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564218605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117965,"user_name":"兜兜","can_delete":false,"product_type":"c1","uid":1297941,"ip_address":"","ucode":"9033348BEF5F5A","user_header":"https://static001.geekbang.org/account/avatar/00/13/ce/15/51187703.jpg","comment_is_top":false,"comment_ctime":1564199615,"is_pvip":true,"replies":[{"id":43186,"content":"感谢你的反馈。你疑惑的地方，可以留言写出具体内容，我们来讨论。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564206341,"ip_address":"","comment_id":117965,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"RocketMQ的图是不是画错了","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460203,"discussion_content":"你说的没错，并行消费是RocketMQ的一个功能，但它和我们讲的原理是不矛盾的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564206309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","nickname":"Geek_zbvt62","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3142,"discussion_content":"误会了，其实我是在回答思考题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564218605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117925,"user_name":"我知道了嗯","can_delete":false,"product_type":"c1","uid":1138471,"ip_address":"","ucode":"9186EC1F32C490","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/27/a6873bc9.jpg","comment_is_top":false,"comment_ctime":1564193432,"is_pvip":false,"replies":[{"id":43207,"content":"不会。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564209008,"ip_address":"","comment_id":117925,"utype":1}],"discussion_count":2,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"kafka的一个主题如果都多个分区，那么这多个分区里面的数据是会有重复的嘛？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460201,"discussion_content":"感谢你的反馈。你疑惑的地方，可以留言写出具体内容，我们来讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564206341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117898,"user_name":"原军","can_delete":false,"product_type":"c1","uid":1016202,"ip_address":"","ucode":"003C988716FBCC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/8a/0b065758.jpg","comment_is_top":false,"comment_ctime":1564186051,"is_pvip":false,"replies":[{"id":43203,"content":"可以","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208882,"ip_address":"","comment_id":117898,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"老师好，rabbitMq能保证消息不丢失和严格顺序吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460167,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117894,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1564185481,"is_pvip":false,"replies":[{"id":43202,"content":"如果每个tag对应一个consumer group，是可以并行的。\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208872,"ip_address":"","comment_id":117894,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"老师记得rocket的topic下还有个tag的概念吧，消费者可以消费只同一topic下的不同tag里的消息。这样是否是实现并行？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460164,"discussion_content":"如果每个tag对应一个consumer group，是可以并行的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117888,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1564181979,"is_pvip":false,"replies":[{"id":43199,"content":"不同的消费组之间，除了消费的是同一个topic以外，是完全没有任何关系的。每个消费组记录自己的消费位置，所以是不会“串”的。\n\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1564208185,"ip_address":"","comment_id":117888,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"我觉得如果不严格按照顺序的话：消费组是否会乱？可能我觉得至少当前模式，消费组的各个消费者所获得要处理的消息是差不多的-至少我觉得当前的模式是为了消费组各组的信息差不多，rockmq最大的特性不是稳定性么。\n其实老师在说问这个问题的时候我觉得在引发出了另外一个问题：如果不按照严格顺序，那么消费组的消息各组之间的消息数可能完全不一样，引发的问题如何处理？\n这只是我对于今天学习的理解：不足之处还望老师提点。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460162,"discussion_content":"不同的消费组之间，除了消费的是同一个topic以外，是完全没有任何关系的。每个消费组记录自己的消费位置，所以是不会“串”的。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564208185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118096,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1091781,"ip_address":"","ucode":"67802124F5181D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epjdWhOia2BKpvYDUIria0klBOvxU4v8CfsobsGYicUia6Hybb4n658LfJymFbuPk0koxldr6QIOpQsMA/132","comment_is_top":false,"comment_ctime":1564239294,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"类似TCP可靠传输方式，使用滑窗实现消息删除","like_count":8},{"had_liked":false,"id":280080,"user_name":"perkyoung","can_delete":false,"product_type":"c1","uid":1308321,"ip_address":"","ucode":"9EFB0BC6A6D5D6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJia2mqq4pWHVYtN9fXZ91iajnE0ib3JqQejD9oo7kusbY64uDPrib1yOBzowoFCA4ORHUDF3HEWCZIMQ/132","comment_is_top":false,"comment_ctime":1614071285,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"看了评论后，觉得如果老师在RocketMQ 的消息模型中，画两个消费组，就起码能解决很多人的疑惑","like_count":2},{"had_liked":false,"id":287357,"user_name":"三角形小于零","can_delete":false,"product_type":"c1","uid":1026174,"ip_address":"","ucode":"C2F89597662D4B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/7e/c9201b20.jpg","comment_is_top":false,"comment_ctime":1617898538,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":14,"product_id":100032301,"comment_content":"评论没法贴 ERD，老师请教一下这样理解是否正确：\n\nTopic : queue = 1 : n  一个 topic 下有多个 queue；  一条消息只会投递到这个 topic 的某一个 queue 下(具体哪一个取决于策略)。\n\nTopic : consumer group = 1 : n  一个 topic 下可以有多个 consumer group； 每个订阅该 topic 的 consumer group 会得到该 topic 的完整消息。 例如解耦场景中: 发给订单topic 的消息会分别送到支付系统consume group、风控系统 consumer group、客服系统 consumer group..... \n\nconsumer group : topic = 1:n 一个消费者组可以订阅多个 topic； \n\nqueue : consumer = 1 : n  可能会有多个消费者同时在等某一个 queue 的消息，而一条消息只能给其中一个等待中的消费者（当然这些消费者同属于一个消费者组） ；  如果有消息a和消息b要保证按顺序消费，那就要投递到同一个 topic 同一个 queue 下。在同一个queue 里的消息a处理完后，消费者才能取到消息b，所以是有序的。 \n\nconsumer group ：queue = 1:n   消费者组里的消费者们并行地从订阅的这个 topic 里的多个 queue  里取消息进行消费。\n\n\n订阅topic的人是 consumer group 而非 consumer， 订阅的是 topic 而非 queue。\n当某个 topic 下的消息堆积后，增加  queue 的数量、增加消费者组里的消费者的数量。 提高并行处理能力。\n\n\n\n","like_count":1},{"had_liked":false,"id":172331,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1579155943,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"消息模型\n\n消息队列由队列这种数据结构演化而来。队列的基本定义是fifo，消息消费的顺序要与消息生产的顺序一致。\n而在现实世界常常有一份消息被多个消费者消费的需求。所以出现了发布订阅模型。发布订阅如果只有一个队列，就与普通的队列别无二致了。\n可以看出，消息队列的消息的有效性是通过原始意义上的队列实现的。每个队列上的消息消费是顺序的。发布订阅只是一个变体。\n\n主流的mq的消息模型一般都是发布订阅，例外的是rabbitmq，它的消息模型中重要的概念是交换机，生产者将消息发送给交换机，由交换机负责将消息投递到相关的队列。合理配置的话也可以实现发布订阅模型。\n\n为了保证消息的不丢失，mq通常采用一种请求确认机制。这带来了一个问题，那就是mq的并发能力。前一个消息没有收到确认，不能进行下一个消息的消费。在同一时刻只能有一个消费者进行消费。\nrocketmq引入了队列这一概念，消费者可以同时在一个主题下的多个队列并发消费消息。rocketmq只能保证单个队列上的消费有序性，不能保证整个主题层面的消息的有序性。\nrocketmq中还有一个消费者组的概念，组内成员是竞争关系。消息可以被多个消费组消费，实现了发布订阅模型。\n被多个消费组消费是如何实现的呢？rocketmq在每个队列上维护了每个消费者组消费的索引，一个组消费完成不会删除元素，只是修改了下标。\n\nkafka的消息模型与rocket的逻辑模型一致，当然实现不同。\n\n一个简简单单的队列，一旦遇到现实世界里的种种需求，立刻变得这么复杂。","like_count":1},{"had_liked":false,"id":129036,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1567013827,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"RocketMQ引入队列实际上是为了解决消息空洞的问题，只是间接提升了并发处理能力，也就是如果生产者连续向mq发送了3条消息，根据规则，路由到三个队列，这时候不同的消费组均可以同时消费这三条消息，这个时候就要看你的业务逻辑，如果你的目的是想去重，那么当一个消费组成功消费之后，获取分布式锁并记录一条消费日志，然后释放锁，当另一个消费组拿到锁之后发现有消费日志，这个时候不再消费，这样可以达到去重的目的。如果RocketMQ没有队列这个功能，那么就意味着你的多个消费组只能有一个消费组能消费到消息，如果消费组A消费到了，不巧这个时候消费组A网络抖动，那么这个时候整个消费集合都被卡住，系统崩溃。","like_count":1},{"had_liked":false,"id":118027,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1564214583,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"学习基础很重要，打卡","like_count":1},{"had_liked":false,"id":117930,"user_name":"AgCl","can_delete":false,"product_type":"c1","uid":1408804,"ip_address":"","ucode":"2C7660E3C5565D","user_header":"https://static001.geekbang.org/account/avatar/00/15/7f/24/719ce9d4.jpg","comment_is_top":false,"comment_ctime":1564194501,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"不同队列某种程度实现的是并行，一个队列的消费实现并行","like_count":1},{"had_liked":false,"id":396534,"user_name":"范飞扬","can_delete":false,"product_type":"c1","uid":2721761,"ip_address":"广东","ucode":"A665DF46833A81","user_header":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","comment_is_top":false,"comment_ctime":1734857140,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"感觉老师最后一张图有点问题，Queue1 和 Queue2 应该存放的消息是一样的呀？怎么Queue1 是 0、2、4 这样呢？\n\n比如在官方文档，不同的 Queue 都是一样的：https:&#47;&#47;rocketmq.apache.org&#47;docs&#47;domainModel&#47;01main&#47;#domain-model-of-apache-rocketmq\n\n\n又看了一会，想明白了，图里的序号是 offset... 不是消息序号。。","like_count":0},{"had_liked":false,"id":395410,"user_name":"Geek_ba3598","can_delete":false,"product_type":"c1","uid":3139074,"ip_address":"北京","ucode":"9D83A36A34189B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/XeGpHsAib2ZBic8PsR7z18plF2AccJ6Op5WmRDnv4Y9Vkmdiba9ibbcQSPGLJ1yuACAhkLQVQZHSz9WUcNj7UKSw6Q/132","comment_is_top":false,"comment_ctime":1730645851,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"老师，请教一下，通过offset来维护队列的消费进度，想保证消息不丢失，就得等待当前消息被消费成功后，offset才能+1，这样没法并发消费啊，为什么不能使用滑动窗口呢？窗口内的消息可以被并行消费，当出现连续的消费成功的消息时，窗口就向前推动。","like_count":0},{"had_liked":false,"id":380085,"user_name":"庄风","can_delete":false,"product_type":"c1","uid":1267661,"ip_address":"中国香港","ucode":"21FC66BA9E7EBB","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/cd/9235341a.jpg","comment_is_top":false,"comment_ctime":1692938645,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"按照上面的描述，我觉得RocketMQ的图画错了。消费位置是针对消费组（Consumer Group）级别的，而不是针对消费者（Consumer）级别。图中的主题中有两个Queue，意味着对应着两个消费组。应该画两个消费组才对。然后以组为单位来消费Queue。箭头应该是从组到消费位置，而不是从Consumer到消费位置。至于具体是组中的哪个Consumer消费的，那是组内的事情，对于主题来说是透明的。","like_count":0},{"had_liked":false,"id":377242,"user_name":"居昱","can_delete":false,"product_type":"c1","uid":2186957,"ip_address":"上海","ucode":"13D07D17B1720B","user_header":"https://static001.geekbang.org/account/avatar/00/21/5e/cd/19201ac6.jpg","comment_is_top":false,"comment_ctime":1688117625,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"老师，请问下消费组里的一个消费者，他只消费一个队列里的消息，还是他可以消费不同队列里的消息。","like_count":0},{"had_liked":false,"id":371263,"user_name":"不易乐乎","can_delete":false,"product_type":"c1","uid":1156273,"ip_address":"湖北","ucode":"1F68FC9E1495FB","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/b1/12f5d7df.jpg","comment_is_top":false,"comment_ctime":1679715816,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"回答 单队列实现并发 \n是否可以一次拿多条消息，然后允许多个消费者实例，在单个实例里面多线程串行或并行消费消息","like_count":0},{"had_liked":false,"id":369188,"user_name":"小红帽","can_delete":false,"product_type":"c1","uid":1135290,"ip_address":"广东","ucode":"876000FB67C980","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/ba/440c0157.jpg","comment_is_top":false,"comment_ctime":1677212030,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"老师的问题是不要求严格顺序，能否做到单个队列的并行消费呢？\n首先如果单个队列要并行消费肯定需要维护更多的offset，服务端和消费端会更加复杂，影响性能。\n\n如果这些都不考虑，就不管付出什么代价也要完成单个队列的并行消费，我想可以这样做，\n1.把队列再拆细一点，数量和消费者一致，让每个消费者都可以同时消费这样也是并行。\n2.如果如果在上面这种方案下还要对单个队列再并行，那也是参考这种模式，你要限制一个并发消费数量，在原来队列上再拆子队列，单独维护这些队列的消费情况，\n3.同时还要考虑，增大和减少并发量的情况，队列如何分裂和合并。","like_count":0,"discussions":[{"author":{"id":1896302,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCZFLPsTtw263Qq57ybL4SnibQFIqVCMibU8ic0Og2A7dclqZpg2cjY7u1jYpdGcK3EpcO7ty8kfuHw/132","nickname":"jiang_2020","note":"","ucode":"2B8AF2A51882A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629031,"discussion_content":"本质还是消费者，消费组是一个虚拟的概念，具体消费还是消费者在消费，拉取消息，确认消费确定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696562994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172331,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1579155943,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"消息模型\n\n消息队列由队列这种数据结构演化而来。队列的基本定义是fifo，消息消费的顺序要与消息生产的顺序一致。\n而在现实世界常常有一份消息被多个消费者消费的需求。所以出现了发布订阅模型。发布订阅如果只有一个队列，就与普通的队列别无二致了。\n可以看出，消息队列的消息的有效性是通过原始意义上的队列实现的。每个队列上的消息消费是顺序的。发布订阅只是一个变体。\n\n主流的mq的消息模型一般都是发布订阅，例外的是rabbitmq，它的消息模型中重要的概念是交换机，生产者将消息发送给交换机，由交换机负责将消息投递到相关的队列。合理配置的话也可以实现发布订阅模型。\n\n为了保证消息的不丢失，mq通常采用一种请求确认机制。这带来了一个问题，那就是mq的并发能力。前一个消息没有收到确认，不能进行下一个消息的消费。在同一时刻只能有一个消费者进行消费。\nrocketmq引入了队列这一概念，消费者可以同时在一个主题下的多个队列并发消费消息。rocketmq只能保证单个队列上的消费有序性，不能保证整个主题层面的消息的有序性。\nrocketmq中还有一个消费者组的概念，组内成员是竞争关系。消息可以被多个消费组消费，实现了发布订阅模型。\n被多个消费组消费是如何实现的呢？rocketmq在每个队列上维护了每个消费者组消费的索引，一个组消费完成不会删除元素，只是修改了下标。\n\nkafka的消息模型与rocket的逻辑模型一致，当然实现不同。\n\n一个简简单单的队列，一旦遇到现实世界里的种种需求，立刻变得这么复杂。","like_count":1},{"had_liked":false,"id":129036,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1567013827,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"RocketMQ引入队列实际上是为了解决消息空洞的问题，只是间接提升了并发处理能力，也就是如果生产者连续向mq发送了3条消息，根据规则，路由到三个队列，这时候不同的消费组均可以同时消费这三条消息，这个时候就要看你的业务逻辑，如果你的目的是想去重，那么当一个消费组成功消费之后，获取分布式锁并记录一条消费日志，然后释放锁，当另一个消费组拿到锁之后发现有消费日志，这个时候不再消费，这样可以达到去重的目的。如果RocketMQ没有队列这个功能，那么就意味着你的多个消费组只能有一个消费组能消费到消息，如果消费组A消费到了，不巧这个时候消费组A网络抖动，那么这个时候整个消费集合都被卡住，系统崩溃。","like_count":1},{"had_liked":false,"id":118027,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1564214583,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"学习基础很重要，打卡","like_count":1},{"had_liked":false,"id":117930,"user_name":"AgCl","can_delete":false,"product_type":"c1","uid":1408804,"ip_address":"","ucode":"2C7660E3C5565D","user_header":"https://static001.geekbang.org/account/avatar/00/15/7f/24/719ce9d4.jpg","comment_is_top":false,"comment_ctime":1564194501,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"不同队列某种程度实现的是并行，一个队列的消费实现并行","like_count":1},{"had_liked":false,"id":396534,"user_name":"范飞扬","can_delete":false,"product_type":"c1","uid":2721761,"ip_address":"广东","ucode":"A665DF46833A81","user_header":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","comment_is_top":false,"comment_ctime":1734857140,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"感觉老师最后一张图有点问题，Queue1 和 Queue2 应该存放的消息是一样的呀？怎么Queue1 是 0、2、4 这样呢？\n\n比如在官方文档，不同的 Queue 都是一样的：https:&#47;&#47;rocketmq.apache.org&#47;docs&#47;domainModel&#47;01main&#47;#domain-model-of-apache-rocketmq\n\n\n又看了一会，想明白了，图里的序号是 offset... 不是消息序号。。","like_count":0},{"had_liked":false,"id":395410,"user_name":"Geek_ba3598","can_delete":false,"product_type":"c1","uid":3139074,"ip_address":"北京","ucode":"9D83A36A34189B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/XeGpHsAib2ZBic8PsR7z18plF2AccJ6Op5WmRDnv4Y9Vkmdiba9ibbcQSPGLJ1yuACAhkLQVQZHSz9WUcNj7UKSw6Q/132","comment_is_top":false,"comment_ctime":1730645851,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"老师，请教一下，通过offset来维护队列的消费进度，想保证消息不丢失，就得等待当前消息被消费成功后，offset才能+1，这样没法并发消费啊，为什么不能使用滑动窗口呢？窗口内的消息可以被并行消费，当出现连续的消费成功的消息时，窗口就向前推动。","like_count":0},{"had_liked":false,"id":380085,"user_name":"庄风","can_delete":false,"product_type":"c1","uid":1267661,"ip_address":"中国香港","ucode":"21FC66BA9E7EBB","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/cd/9235341a.jpg","comment_is_top":false,"comment_ctime":1692938645,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"按照上面的描述，我觉得RocketMQ的图画错了。消费位置是针对消费组（Consumer Group）级别的，而不是针对消费者（Consumer）级别。图中的主题中有两个Queue，意味着对应着两个消费组。应该画两个消费组才对。然后以组为单位来消费Queue。箭头应该是从组到消费位置，而不是从Consumer到消费位置。至于具体是组中的哪个Consumer消费的，那是组内的事情，对于主题来说是透明的。","like_count":0,"discussions":[{"author":{"id":1896302,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCZFLPsTtw263Qq57ybL4SnibQFIqVCMibU8ic0Og2A7dclqZpg2cjY7u1jYpdGcK3EpcO7ty8kfuHw/132","nickname":"jiang_2020","note":"","ucode":"2B8AF2A51882A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629031,"discussion_content":"本质还是消费者，消费组是一个虚拟的概念，具体消费还是消费者在消费，拉取消息，确认消费确定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696562994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377242,"user_name":"居昱","can_delete":false,"product_type":"c1","uid":2186957,"ip_address":"上海","ucode":"13D07D17B1720B","user_header":"https://static001.geekbang.org/account/avatar/00/21/5e/cd/19201ac6.jpg","comment_is_top":false,"comment_ctime":1688117625,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"老师，请问下消费组里的一个消费者，他只消费一个队列里的消息，还是他可以消费不同队列里的消息。","like_count":0},{"had_liked":false,"id":371263,"user_name":"不易乐乎","can_delete":false,"product_type":"c1","uid":1156273,"ip_address":"湖北","ucode":"1F68FC9E1495FB","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/b1/12f5d7df.jpg","comment_is_top":false,"comment_ctime":1679715816,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"回答 单队列实现并发 \n是否可以一次拿多条消息，然后允许多个消费者实例，在单个实例里面多线程串行或并行消费消息","like_count":0},{"had_liked":false,"id":369188,"user_name":"小红帽","can_delete":false,"product_type":"c1","uid":1135290,"ip_address":"广东","ucode":"876000FB67C980","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/ba/440c0157.jpg","comment_is_top":false,"comment_ctime":1677212030,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":15,"product_id":100032301,"comment_content":"老师的问题是不要求严格顺序，能否做到单个队列的并行消费呢？\n首先如果单个队列要并行消费肯定需要维护更多的offset，服务端和消费端会更加复杂，影响性能。\n\n如果这些都不考虑，就不管付出什么代价也要完成单个队列的并行消费，我想可以这样做，\n1.把队列再拆细一点，数量和消费者一致，让每个消费者都可以同时消费这样也是并行。\n2.如果如果在上面这种方案下还要对单个队列再并行，那也是参考这种模式，你要限制一个并发消费数量，在原来队列上再拆子队列，单独维护这些队列的消费情况，\n3.同时还要考虑，增大和减少并发量的情况，队列如何分裂和合并。","like_count":0},{"had_liked":false,"id":367035,"user_name":"小宝","can_delete":false,"product_type":"c1","uid":1196694,"ip_address":"江西","ucode":"43A2CDA06FF7CE","user_header":"https://static001.geekbang.org/account/avatar/00/12/42/96/d4477372.jpg","comment_is_top":false,"comment_ctime":1674831973,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"关于老师最后的思考题：\n单个队列，是不是可以通过多线程方式实现并行消费MQ呢","like_count":0},{"had_liked":false,"id":364208,"user_name":"否极泰来","can_delete":false,"product_type":"c1","uid":1439355,"ip_address":"北京","ucode":"C249173266251A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","comment_is_top":false,"comment_ctime":1670654059,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"应该是坑实现 单队列并行消费的，这样就不能记录当前对接消费的位置，在不考虑有序性的前提下\n\n给消息新增“消息状态”字段，该字段值有：未消费、消费中、已消费，当消费者消费消息是，队列下发未消费的消息，并把消息状态改成消费中，当消费者消费成功后设置已消费。\n\n当然可以设计跟完善一些 新增其他字段 例如：消费消息的消费者ID，当前开始消费时间（超过多少时间自动设置成未消费）、消息消费失败&#47;成功次数","like_count":0},{"had_liked":false,"id":360887,"user_name":"子豪sirius","can_delete":false,"product_type":"c1","uid":1117023,"ip_address":"广东","ucode":"E8D08D2D33E785","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/5f/2cc4060c.jpg","comment_is_top":false,"comment_ctime":1666944592,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"&quot;RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的&quot;，这个不是很明白。","like_count":0},{"had_liked":false,"id":357511,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"上海","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1663322267,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"请教一个事，消费者组是一个服务系统就是一个消费者组吗？我再加一台机器就是俩个消费者组吗？还是消费者组只能MQ有关？","like_count":0},{"had_liked":false,"id":357507,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"上海","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1663320831,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"如果消息从MQ发送到消费者，一直没有ack确认。会不会导致那个没有ack确认的消息所在队列，它后面的消费一直无法被消费？","like_count":0},{"had_liked":false,"id":346366,"user_name":"NeverSeeYouAgainBUG","can_delete":false,"product_type":"c1","uid":2930836,"ip_address":"","ucode":"1B0E8CA284C181","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b8/94/d20583ef.jpg","comment_is_top":false,"comment_ctime":1653051409,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"老实说，老师你讲的这个东西确实比较难理解，但是老师你的语言很精炼而且讲的也足够明白。简直难得，看不懂的话，就是需要认真看了。","like_count":0},{"had_liked":false,"id":346337,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1653033583,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"重点讲了rocketmq 笔记如下\n\nprodcter-broker-consumer\n\t所有mq都有请求确认机制\n\t\t当p发送消息 b收到消息写入主题或者队列才会向p发送请求确认\n\t\t而当c消费了消息 也会向b发送请求确认\n\t如果没有收到ack 说明发送&#47;消费失败 会再次发送消息 这就是消息重试机制\n\t但这也带来了一个问题 前一个消息没有消费成功 后一个消息就无法消费了 如果能消费 就违背了有序性这个原则 产生了消息空洞\n而rocketmq为了解决这个问题就在主题下也引入了队列\n\t多个主题就有多个队列\n\t这样就满足了对列多示例的生产消费\n要点\n\t每个消费组都会消费完整的一份topic消息\n\t\t一个topic中包含多个队列的多条消息\n\t\t需要多少消费组 取决于业务  比如广播模型n个用户 那么就需要n个消费组了\n\t\t但消费组里的不同消费组是竞争关系 抢到哪条其他消费者就不能在消费了\n\t同一个队列 可以保证消费的顺序 但是topic下的多个对列是无法保证消费顺序的\n\t每个消费组都会在队列上维护一个offset 防止消费组的其他成员重复消费\n\t如何保证顺序消费？\n\t\t根据用户id&#47;订单id 通过hash算法 将消息放入一个队列中\n\t\t\t对于每个消费组来说都是顺序消费的 一个个的从队列中取值","like_count":0},{"had_liked":false,"id":340972,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649250466,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"在不要求严格顺序消费的前提下，可以给消费者消费消息的时候定义一个标签，表示这个消费者是已经消费完了，是空闲状态还是消息处理中是繁忙状态，然后只给空闲的消费者推送消息。","like_count":0},{"had_liked":false,"id":340150,"user_name":"刘帅","can_delete":false,"product_type":"c1","uid":1117630,"ip_address":"","ucode":"90FD56C0395B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/be/6acd4b18.jpg","comment_is_top":false,"comment_ctime":1648630112,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"课后思考题：可以依然保留先进先出的特性，由于对顺序没有强一致的要求，并发获取消息的线程处理各自获取到的消息，如果消息消费失败或超时未处理，则可以将原消息标记已失效，将消息重新加入到队列里","like_count":0},{"had_liked":false,"id":337965,"user_name":"i_chase","can_delete":false,"product_type":"c1","uid":1795511,"ip_address":"","ucode":"09C41C863F4EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","comment_is_top":false,"comment_ctime":1647184073,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"rabbitmq路由多个队列应该也只是抽象概念，而不是实际同时发送数据给多个队列吧？","like_count":0},{"had_liked":false,"id":367035,"user_name":"小宝","can_delete":false,"product_type":"c1","uid":1196694,"ip_address":"江西","ucode":"43A2CDA06FF7CE","user_header":"https://static001.geekbang.org/account/avatar/00/12/42/96/d4477372.jpg","comment_is_top":false,"comment_ctime":1674831973,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"关于老师最后的思考题：\n单个队列，是不是可以通过多线程方式实现并行消费MQ呢","like_count":0},{"had_liked":false,"id":364208,"user_name":"否极泰来","can_delete":false,"product_type":"c1","uid":1439355,"ip_address":"北京","ucode":"C249173266251A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","comment_is_top":false,"comment_ctime":1670654059,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"应该是坑实现 单队列并行消费的，这样就不能记录当前对接消费的位置，在不考虑有序性的前提下\n\n给消息新增“消息状态”字段，该字段值有：未消费、消费中、已消费，当消费者消费消息是，队列下发未消费的消息，并把消息状态改成消费中，当消费者消费成功后设置已消费。\n\n当然可以设计跟完善一些 新增其他字段 例如：消费消息的消费者ID，当前开始消费时间（超过多少时间自动设置成未消费）、消息消费失败&#47;成功次数","like_count":0},{"had_liked":false,"id":360887,"user_name":"子豪sirius","can_delete":false,"product_type":"c1","uid":1117023,"ip_address":"广东","ucode":"E8D08D2D33E785","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/5f/2cc4060c.jpg","comment_is_top":false,"comment_ctime":1666944592,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"&quot;RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的&quot;，这个不是很明白。","like_count":0},{"had_liked":false,"id":357511,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"上海","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1663322267,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"请教一个事，消费者组是一个服务系统就是一个消费者组吗？我再加一台机器就是俩个消费者组吗？还是消费者组只能MQ有关？","like_count":0},{"had_liked":false,"id":357507,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"上海","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1663320831,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"如果消息从MQ发送到消费者，一直没有ack确认。会不会导致那个没有ack确认的消息所在队列，它后面的消费一直无法被消费？","like_count":0},{"had_liked":false,"id":346366,"user_name":"NeverSeeYouAgainBUG","can_delete":false,"product_type":"c1","uid":2930836,"ip_address":"","ucode":"1B0E8CA284C181","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b8/94/d20583ef.jpg","comment_is_top":false,"comment_ctime":1653051409,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"老实说，老师你讲的这个东西确实比较难理解，但是老师你的语言很精炼而且讲的也足够明白。简直难得，看不懂的话，就是需要认真看了。","like_count":0},{"had_liked":false,"id":346337,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1653033583,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"重点讲了rocketmq 笔记如下\n\nprodcter-broker-consumer\n\t所有mq都有请求确认机制\n\t\t当p发送消息 b收到消息写入主题或者队列才会向p发送请求确认\n\t\t而当c消费了消息 也会向b发送请求确认\n\t如果没有收到ack 说明发送&#47;消费失败 会再次发送消息 这就是消息重试机制\n\t但这也带来了一个问题 前一个消息没有消费成功 后一个消息就无法消费了 如果能消费 就违背了有序性这个原则 产生了消息空洞\n而rocketmq为了解决这个问题就在主题下也引入了队列\n\t多个主题就有多个队列\n\t这样就满足了对列多示例的生产消费\n要点\n\t每个消费组都会消费完整的一份topic消息\n\t\t一个topic中包含多个队列的多条消息\n\t\t需要多少消费组 取决于业务  比如广播模型n个用户 那么就需要n个消费组了\n\t\t但消费组里的不同消费组是竞争关系 抢到哪条其他消费者就不能在消费了\n\t同一个队列 可以保证消费的顺序 但是topic下的多个对列是无法保证消费顺序的\n\t每个消费组都会在队列上维护一个offset 防止消费组的其他成员重复消费\n\t如何保证顺序消费？\n\t\t根据用户id&#47;订单id 通过hash算法 将消息放入一个队列中\n\t\t\t对于每个消费组来说都是顺序消费的 一个个的从队列中取值","like_count":0},{"had_liked":false,"id":340972,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649250466,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"在不要求严格顺序消费的前提下，可以给消费者消费消息的时候定义一个标签，表示这个消费者是已经消费完了，是空闲状态还是消息处理中是繁忙状态，然后只给空闲的消费者推送消息。","like_count":0},{"had_liked":false,"id":340150,"user_name":"刘帅","can_delete":false,"product_type":"c1","uid":1117630,"ip_address":"","ucode":"90FD56C0395B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/0d/be/6acd4b18.jpg","comment_is_top":false,"comment_ctime":1648630112,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"课后思考题：可以依然保留先进先出的特性，由于对顺序没有强一致的要求，并发获取消息的线程处理各自获取到的消息，如果消息消费失败或超时未处理，则可以将原消息标记已失效，将消息重新加入到队列里","like_count":0},{"had_liked":false,"id":337965,"user_name":"i_chase","can_delete":false,"product_type":"c1","uid":1795511,"ip_address":"","ucode":"09C41C863F4EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","comment_is_top":false,"comment_ctime":1647184073,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":16,"product_id":100032301,"comment_content":"rabbitmq路由多个队列应该也只是抽象概念，而不是实际同时发送数据给多个队列吧？","like_count":0},{"had_liked":false,"id":335721,"user_name":"程序员俊达","can_delete":false,"product_type":"c1","uid":1107484,"ip_address":"","ucode":"2573037D7C82C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","comment_is_top":false,"comment_ctime":1645664386,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"对于主题和队列，分区的概念有了了解，所以如果想要提高并发消费速度，消费者机器数量就是队列的数量，否则再多的机器，队列就那些，也提高不了整体的消费速度了。","like_count":0},{"had_liked":false,"id":333869,"user_name":"邱邱邱","can_delete":false,"product_type":"c1","uid":2611827,"ip_address":"","ucode":"828318EB2316EB","user_header":"https://static001.geekbang.org/account/avatar/00/27/da/73/7e7593a7.jpg","comment_is_top":false,"comment_ctime":1644568016,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"个人觉得：对单个队列的并行消费，由于队列的特性保障消息的有序性，所以改动的地方主要在消费端。可以让同一消费组内的消费组在获取消息后，剩下的消费组立即去获取接下来的消息，而不是等待前者消费完成。","like_count":0},{"had_liked":false,"id":333820,"user_name":"Geek_h6mwnx","can_delete":false,"product_type":"c1","uid":1227606,"ip_address":"","ucode":"DE125B56BF7818","user_header":"https://static001.geekbang.org/account/avatar/00/12/bb/56/05459f43.jpg","comment_is_top":false,"comment_ctime":1644548367,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"单个队列，不要求严格顺序，是可以并行消费的。个人认为最简单的方式是，在取消息时，消息直接出队，放入待ack列表(每个consumer对应一个列表)中，成功ack只从consumer列表删除，ack失败或超时则进入补偿机制。补偿机制可以是重新投递消息到队列中，或者出现严重问题将消息投递到死信队列","like_count":0},{"had_liked":false,"id":332445,"user_name":"hi","can_delete":false,"product_type":"c1","uid":2891918,"ip_address":"","ucode":"9E244E76A908EE","user_header":"https://static001.geekbang.org/account/avatar/00/2c/20/8e/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1643253978,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"老师，消息确认机制有点疑问，希望老师有空帮忙解答下。\n服务端多久没有收到消息判定为消费失败？如果服务正常消费但没及时返回消息确认，会不会被认为消费失败？这种情况下重发，导致多次消费或不断重发打满消费线程的情况怎么避免？","like_count":0},{"had_liked":false,"id":330533,"user_name":"walle斌","can_delete":false,"product_type":"c1","uid":1062848,"ip_address":"","ucode":"0DB3243004951F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","comment_is_top":false,"comment_ctime":1642032593,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"rocketmq实现的并行消费，其实kafka很多介绍文件都说过，但是没有broker配合，单纯在consumer下功夫始终有限。。再次强调，业务使用rocketmq，而不是kafka ！！","like_count":0},{"had_liked":false,"id":329821,"user_name":"一号","can_delete":false,"product_type":"c1","uid":1272320,"ip_address":"","ucode":"6E5DCC48AB5D07","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dB3AyEjSZicicr7yFEIOMiaLKes6rQan0ZHYHmM6zib9EUDB2zbwYR2icDPLrBoCXFuS3LicfyhWA4EKpP5EbGzQXzcQ/132","comment_is_top":false,"comment_ctime":1641552285,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"理解了消费者组消费主题里队列的模型，有个疑问：\n1.当消费组只有一个消费者，主题里有多个队列的情况下，那这个消费者岂不是依次循环消费每一个队列？\n2.当消费组里消费者的数量，多于主题里队列数量的情况下，会出现多个消费者消费同一个队列吗？\n\n不知道我的理解是否正确。","like_count":0},{"had_liked":false,"id":324890,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638704876,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"个人感觉串行化的有点就是和服务端确认消费完成比较方便，所以说如果可以并行随机化的话 主要是在服务端确认消费完成的时候需要对比当前是消费的哪个信息。然后为了避免重复消费，这个队列获取的方式就类似于迭代器一样，这个消费则只管拿不用管拿的是哪一个。\n服务端还可以维护一个数据结构来判断是否重复消费\n以上是个人的一些思考 ，不过确实没怎么用过正儿八经的消息队列 ","like_count":0},{"had_liked":false,"id":324888,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638704392,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"https:&#47;&#47;xie.infoq.cn&#47;article&#47;326100976e62a3eef317bf474\n课后笔记~ 还是思维导图做笔记方便","like_count":0},{"had_liked":false,"id":321762,"user_name":"wuhang202","can_delete":false,"product_type":"c1","uid":2638583,"ip_address":"","ucode":"2A81B4FE4F22DA","user_header":"https://static001.geekbang.org/account/avatar/00/28/42/f7/8b57263a.jpg","comment_is_top":false,"comment_ctime":1637033676,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"多线程下可以对同一个队列分段消费，首先获取最新消息offset和最早未消费offset的数值，将其中的差值除以线程数，进而分段，每个线程消费自己的一段起止offset","like_count":0},{"had_liked":false,"id":317773,"user_name":"克里斯","can_delete":false,"product_type":"c1","uid":1181844,"ip_address":"","ucode":"00B755C10AC1C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","comment_is_top":false,"comment_ctime":1634957511,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"1.一个生产组生产同一个topic类型的消息\n2.一个消费组消费同一个topic类型的消息\n3.一个topic有全量的消息\n4.topic有多个队列,所有队列的消息之和=topic消息\n5.多个队列是为了同一个消费组的多个消费者能并行消费\n6.如果消息需要串行顺序,那只能把消息发送到同一个队列中,此情况不能并行消费","like_count":0},{"had_liked":false,"id":335721,"user_name":"程序员俊达","can_delete":false,"product_type":"c1","uid":1107484,"ip_address":"","ucode":"2573037D7C82C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","comment_is_top":false,"comment_ctime":1645664386,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"对于主题和队列，分区的概念有了了解，所以如果想要提高并发消费速度，消费者机器数量就是队列的数量，否则再多的机器，队列就那些，也提高不了整体的消费速度了。","like_count":0},{"had_liked":false,"id":333869,"user_name":"邱邱邱","can_delete":false,"product_type":"c1","uid":2611827,"ip_address":"","ucode":"828318EB2316EB","user_header":"https://static001.geekbang.org/account/avatar/00/27/da/73/7e7593a7.jpg","comment_is_top":false,"comment_ctime":1644568016,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"个人觉得：对单个队列的并行消费，由于队列的特性保障消息的有序性，所以改动的地方主要在消费端。可以让同一消费组内的消费组在获取消息后，剩下的消费组立即去获取接下来的消息，而不是等待前者消费完成。","like_count":0},{"had_liked":false,"id":333820,"user_name":"Geek_h6mwnx","can_delete":false,"product_type":"c1","uid":1227606,"ip_address":"","ucode":"DE125B56BF7818","user_header":"https://static001.geekbang.org/account/avatar/00/12/bb/56/05459f43.jpg","comment_is_top":false,"comment_ctime":1644548367,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"单个队列，不要求严格顺序，是可以并行消费的。个人认为最简单的方式是，在取消息时，消息直接出队，放入待ack列表(每个consumer对应一个列表)中，成功ack只从consumer列表删除，ack失败或超时则进入补偿机制。补偿机制可以是重新投递消息到队列中，或者出现严重问题将消息投递到死信队列","like_count":0},{"had_liked":false,"id":332445,"user_name":"hi","can_delete":false,"product_type":"c1","uid":2891918,"ip_address":"","ucode":"9E244E76A908EE","user_header":"https://static001.geekbang.org/account/avatar/00/2c/20/8e/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1643253978,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"老师，消息确认机制有点疑问，希望老师有空帮忙解答下。\n服务端多久没有收到消息判定为消费失败？如果服务正常消费但没及时返回消息确认，会不会被认为消费失败？这种情况下重发，导致多次消费或不断重发打满消费线程的情况怎么避免？","like_count":0},{"had_liked":false,"id":330533,"user_name":"walle斌","can_delete":false,"product_type":"c1","uid":1062848,"ip_address":"","ucode":"0DB3243004951F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","comment_is_top":false,"comment_ctime":1642032593,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"rocketmq实现的并行消费，其实kafka很多介绍文件都说过，但是没有broker配合，单纯在consumer下功夫始终有限。。再次强调，业务使用rocketmq，而不是kafka ！！","like_count":0},{"had_liked":false,"id":329821,"user_name":"一号","can_delete":false,"product_type":"c1","uid":1272320,"ip_address":"","ucode":"6E5DCC48AB5D07","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dB3AyEjSZicicr7yFEIOMiaLKes6rQan0ZHYHmM6zib9EUDB2zbwYR2icDPLrBoCXFuS3LicfyhWA4EKpP5EbGzQXzcQ/132","comment_is_top":false,"comment_ctime":1641552285,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"理解了消费者组消费主题里队列的模型，有个疑问：\n1.当消费组只有一个消费者，主题里有多个队列的情况下，那这个消费者岂不是依次循环消费每一个队列？\n2.当消费组里消费者的数量，多于主题里队列数量的情况下，会出现多个消费者消费同一个队列吗？\n\n不知道我的理解是否正确。","like_count":0},{"had_liked":false,"id":324890,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638704876,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"个人感觉串行化的有点就是和服务端确认消费完成比较方便，所以说如果可以并行随机化的话 主要是在服务端确认消费完成的时候需要对比当前是消费的哪个信息。然后为了避免重复消费，这个队列获取的方式就类似于迭代器一样，这个消费则只管拿不用管拿的是哪一个。\n服务端还可以维护一个数据结构来判断是否重复消费\n以上是个人的一些思考 ，不过确实没怎么用过正儿八经的消息队列 ","like_count":0},{"had_liked":false,"id":324888,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638704392,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"https:&#47;&#47;xie.infoq.cn&#47;article&#47;326100976e62a3eef317bf474\n课后笔记~ 还是思维导图做笔记方便","like_count":0},{"had_liked":false,"id":321762,"user_name":"wuhang202","can_delete":false,"product_type":"c1","uid":2638583,"ip_address":"","ucode":"2A81B4FE4F22DA","user_header":"https://static001.geekbang.org/account/avatar/00/28/42/f7/8b57263a.jpg","comment_is_top":false,"comment_ctime":1637033676,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"多线程下可以对同一个队列分段消费，首先获取最新消息offset和最早未消费offset的数值，将其中的差值除以线程数，进而分段，每个线程消费自己的一段起止offset","like_count":0},{"had_liked":false,"id":317773,"user_name":"克里斯","can_delete":false,"product_type":"c1","uid":1181844,"ip_address":"","ucode":"00B755C10AC1C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","comment_is_top":false,"comment_ctime":1634957511,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":17,"product_id":100032301,"comment_content":"1.一个生产组生产同一个topic类型的消息\n2.一个消费组消费同一个topic类型的消息\n3.一个topic有全量的消息\n4.topic有多个队列,所有队列的消息之和=topic消息\n5.多个队列是为了同一个消费组的多个消费者能并行消费\n6.如果消息需要串行顺序,那只能把消息发送到同一个队列中,此情况不能并行消费","like_count":0},{"had_liked":false,"id":315941,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1634078086,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"应该可以吧：感觉是不是类似mysql里自增主键id的生成思路","like_count":0},{"had_liked":false,"id":311585,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1631324306,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"问题：在消费的时候，为了保证消息的不丢失和严格顺序，每个队列只能串行消费，无法做到并发，否则会出现消费空洞的问题。那如果放宽一下限制，不要求严格顺序，能否做到单个队列的并行消费呢？如果可以，该如何实现？\n回答：能。\n消费者，多个消费者消费同一个队列，或者单个消费者异步消费一个队列。\nmq服务，为每个队列提供一个待消费队列，若待消费队列不为空，先消费待消费队列。","like_count":0},{"had_liked":false,"id":307774,"user_name":"Ghoul Zhou","can_delete":false,"product_type":"c1","uid":1107457,"ip_address":"","ucode":"07E6FEE43E1D61","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/01/0ccb7a7c.jpg","comment_is_top":false,"comment_ctime":1629252114,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"老师，你这个画图工具叫什么呀，挺卡通的，感觉非常好！能推荐一下画图工具吗","like_count":0},{"had_liked":false,"id":303926,"user_name":"时二少","can_delete":false,"product_type":"c1","uid":1352255,"ip_address":"","ucode":"874213405EDEFC","user_header":"https://static001.geekbang.org/account/avatar/00/14/a2/3f/73d08b2a.jpg","comment_is_top":false,"comment_ctime":1627099809,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"老师，咨询一个问题，关于消息消费的\n业务不要求有序消费消息，\n在实践中，业务代码问题，导致某条消息失败，如果按照某个队列的方式，那么只能顺序消费，那个这个工作线程就废了。是否对于这个消费失败的消息，分配到另一个队列中或者放到列队尾部，这样不影响其他消息的消费","like_count":0},{"had_liked":false,"id":302964,"user_name":"H·H","can_delete":false,"product_type":"c1","uid":2108194,"ip_address":"","ucode":"113E95BA6B6F51","user_header":"https://static001.geekbang.org/account/avatar/00/20/2b/22/79d183db.jpg","comment_is_top":false,"comment_ctime":1626486643,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"老师，思考题可不可以这样，队列改为数组，可以随机访问，记录一个offset表示消费位置，但是这可能导致消息丢失，所以要有一定的补偿机制","like_count":0},{"had_liked":false,"id":302902,"user_name":"Geek_b9732e","can_delete":false,"product_type":"c1","uid":2689879,"ip_address":"","ucode":"8411F81CF8A44C","user_header":"","comment_is_top":false,"comment_ctime":1626427727,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"rocketmq是不是需要记录一个topic被几个消费组订阅了，当这几个消费组都更新了消费位置后，才会把这个消息删除，这样理解对么？老师","like_count":0},{"had_liked":false,"id":299462,"user_name":"天大","can_delete":false,"product_type":"c1","uid":1443589,"ip_address":"","ucode":"B9EB1B46AA4D85","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iamkqQRZFTAQgclRqskib3n860CStDuxq2aiaZO7EicDfLJwCdZ9gZiajhBoTNuFKH47DLKO5C4GHxukN5L1VOpcR6Q/132","comment_is_top":false,"comment_ctime":1624633850,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"老师您好，在评论区看到顺序消息的问题，发现为了解决消息的顺序性，一个方案就是将消息发到同一个队列中，保证了消息从生产者到队列的顺序性，但是在一个消费组中，同一个队列可以被多个消费者消费，比如consumerA 消费了队列1中的message1，consumerB 消费了队列1中的message2，但是由于某种原因，consumeB比consumeA 先消费，就导致了在同一个队列中消息在消费的时候不能顺序消费，老师这种情况该怎么解决呢？","like_count":0},{"had_liked":false,"id":294866,"user_name":"Wheat Liu","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/8b417c84.jpg","comment_is_top":false,"comment_ctime":1622115705,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"感觉消费者订阅主题，实际上就是消费者跟【主题】这个服务端建立长连接","like_count":0},{"had_liked":false,"id":286072,"user_name":"风无痕","can_delete":false,"product_type":"c1","uid":1205958,"ip_address":"","ucode":"C9C2E05A229043","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/c6/df252212.jpg","comment_is_top":false,"comment_ctime":1617150347,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"对于rocketmq的模型  我还有个疑问，因为主题分队列，所以消息无序，但保证完整性，如果需要一个有序队列，是不是主题队列设为1，比如实时同步数据库操作","like_count":0},{"had_liked":false,"id":278091,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1612756148,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"找到答案了：每个消费者组维护一个自己的offset，消息不会被删除，组之间不互相影响，但是对于rabbitmq来说，如果一个消息想被多个消费者消费，还是发送了多份数据，浪费了空间，看来选型的时候这个也得考虑进去。","like_count":0},{"had_liked":false,"id":315941,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1634078086,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"应该可以吧：感觉是不是类似mysql里自增主键id的生成思路","like_count":0},{"had_liked":false,"id":311585,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1631324306,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"问题：在消费的时候，为了保证消息的不丢失和严格顺序，每个队列只能串行消费，无法做到并发，否则会出现消费空洞的问题。那如果放宽一下限制，不要求严格顺序，能否做到单个队列的并行消费呢？如果可以，该如何实现？\n回答：能。\n消费者，多个消费者消费同一个队列，或者单个消费者异步消费一个队列。\nmq服务，为每个队列提供一个待消费队列，若待消费队列不为空，先消费待消费队列。","like_count":0},{"had_liked":false,"id":307774,"user_name":"Ghoul Zhou","can_delete":false,"product_type":"c1","uid":1107457,"ip_address":"","ucode":"07E6FEE43E1D61","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/01/0ccb7a7c.jpg","comment_is_top":false,"comment_ctime":1629252114,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"老师，你这个画图工具叫什么呀，挺卡通的，感觉非常好！能推荐一下画图工具吗","like_count":0},{"had_liked":false,"id":303926,"user_name":"时二少","can_delete":false,"product_type":"c1","uid":1352255,"ip_address":"","ucode":"874213405EDEFC","user_header":"https://static001.geekbang.org/account/avatar/00/14/a2/3f/73d08b2a.jpg","comment_is_top":false,"comment_ctime":1627099809,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"老师，咨询一个问题，关于消息消费的\n业务不要求有序消费消息，\n在实践中，业务代码问题，导致某条消息失败，如果按照某个队列的方式，那么只能顺序消费，那个这个工作线程就废了。是否对于这个消费失败的消息，分配到另一个队列中或者放到列队尾部，这样不影响其他消息的消费","like_count":0},{"had_liked":false,"id":302964,"user_name":"H·H","can_delete":false,"product_type":"c1","uid":2108194,"ip_address":"","ucode":"113E95BA6B6F51","user_header":"https://static001.geekbang.org/account/avatar/00/20/2b/22/79d183db.jpg","comment_is_top":false,"comment_ctime":1626486643,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"老师，思考题可不可以这样，队列改为数组，可以随机访问，记录一个offset表示消费位置，但是这可能导致消息丢失，所以要有一定的补偿机制","like_count":0},{"had_liked":false,"id":302902,"user_name":"Geek_b9732e","can_delete":false,"product_type":"c1","uid":2689879,"ip_address":"","ucode":"8411F81CF8A44C","user_header":"","comment_is_top":false,"comment_ctime":1626427727,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"rocketmq是不是需要记录一个topic被几个消费组订阅了，当这几个消费组都更新了消费位置后，才会把这个消息删除，这样理解对么？老师","like_count":0},{"had_liked":false,"id":299462,"user_name":"天大","can_delete":false,"product_type":"c1","uid":1443589,"ip_address":"","ucode":"B9EB1B46AA4D85","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iamkqQRZFTAQgclRqskib3n860CStDuxq2aiaZO7EicDfLJwCdZ9gZiajhBoTNuFKH47DLKO5C4GHxukN5L1VOpcR6Q/132","comment_is_top":false,"comment_ctime":1624633850,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"老师您好，在评论区看到顺序消息的问题，发现为了解决消息的顺序性，一个方案就是将消息发到同一个队列中，保证了消息从生产者到队列的顺序性，但是在一个消费组中，同一个队列可以被多个消费者消费，比如consumerA 消费了队列1中的message1，consumerB 消费了队列1中的message2，但是由于某种原因，consumeB比consumeA 先消费，就导致了在同一个队列中消息在消费的时候不能顺序消费，老师这种情况该怎么解决呢？","like_count":0},{"had_liked":false,"id":294866,"user_name":"Wheat Liu","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/8b417c84.jpg","comment_is_top":false,"comment_ctime":1622115705,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"感觉消费者订阅主题，实际上就是消费者跟【主题】这个服务端建立长连接","like_count":0},{"had_liked":false,"id":286072,"user_name":"风无痕","can_delete":false,"product_type":"c1","uid":1205958,"ip_address":"","ucode":"C9C2E05A229043","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/c6/df252212.jpg","comment_is_top":false,"comment_ctime":1617150347,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"对于rocketmq的模型  我还有个疑问，因为主题分队列，所以消息无序，但保证完整性，如果需要一个有序队列，是不是主题队列设为1，比如实时同步数据库操作","like_count":0},{"had_liked":false,"id":278091,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1612756148,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":18,"product_id":100032301,"comment_content":"找到答案了：每个消费者组维护一个自己的offset，消息不会被删除，组之间不互相影响，但是对于rabbitmq来说，如果一个消息想被多个消费者消费，还是发送了多份数据，浪费了空间，看来选型的时候这个也得考虑进去。","like_count":0},{"had_liked":false,"id":278089,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1612755480,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"老师您好，我在这里还是没搞明白：发布订阅模式是如何解决一份消息被多次消费的问题，文中说通过复制多份的做法显然不好，但是我没找到“发布-订阅”是具体是什么原理呐？","like_count":0},{"had_liked":false,"id":276126,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1611803250,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"首先说对于单个队列的并行消费,必然存在竞争,那么抛开竞争\n针对这个问题,我首先想到的是借鉴TCP协议的传输方式\nSACK传输加上滑动窗口协议\n1.SACK传输实现简单就是消费者返回已经确认的消息序号给队列,确认已接受\n2.然后再利用滑动窗口协议,我们将队列分为 已发送已确认,已发送未确认,未发送可发送,不可发送四个部分,然后通过消费的速率不断调整窗口大小,以及保证已发送和可发送的剩余来不断的进行消费","like_count":0},{"had_liked":false,"id":272864,"user_name":"乐萌TD","can_delete":false,"product_type":"c1","uid":1792420,"ip_address":"","ucode":"AAD1355E371620","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo62pttzxBohm02HCWdNyfa8ZslBt7579t4M2LySyv1PkorIGyx9Q7iaWEHOrS1S93By4kBTjeLkyA/132","comment_is_top":false,"comment_ctime":1610335926,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"老师好，多个消费组消费同一个队列时，每个消费组都要维护一个自己的消费位置吗？","like_count":0},{"had_liked":false,"id":270191,"user_name":"轻风细语","can_delete":false,"product_type":"c1","uid":2377659,"ip_address":"","ucode":"CF5DAF463AAABC","user_header":"https://static001.geekbang.org/account/avatar/00/24/47/bb/7022979e.jpg","comment_is_top":false,"comment_ctime":1608977745,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"老师，咨询一个设计的问题(基于RocketMQ)：一个订单请求涉及2个消息，这2个消息是需要串行顺序执行的；而不同的订单请求之间的消息是要无需可并行的。\n\t\n一个参考的设计方案：\n\t通过订单编号取模，将同一个订单的消息存入同一个队列中，因为队列是先进先出，并且队列只会被一个消费组串行消费。\n\t\n对这个设计的疑问：\n1，这个方案是否解决此业务问题？ 有更好的推荐方案吗？\n2，这个设计方案，我认为有一个前提条件是:同一个Topic的消息记录是可以多个不同的Broker中，并且同一个Topic在不同Broker中的消息是完全一样的。\n\t这个前提条件的观点是对的吗？","like_count":0},{"had_liked":false,"id":269118,"user_name":"老大不小","can_delete":false,"product_type":"c1","uid":1295609,"ip_address":"","ucode":"35BCDD3CB13467","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","comment_is_top":false,"comment_ctime":1608532421,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"我对思考题的答案：\n       如果不严格要求顺序，一个消费者组里可以做到单个队列并行消费的，前提是要处理好消息的幂等性问题。\n       ","like_count":0},{"had_liked":false,"id":267930,"user_name":"蔫巴的小白菜","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1607999282,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"关于消费者偏移量维护，我简单的对比了下RocketMQ与kafka的相关实现原理，Rocket主要在队列中用minOffset，currentOffset，maxOffset维护了队列中消费者消息的可见性，以及消息的写入点，这点与kafka的logStartOffset，HW，logEndOffset的设计不谋而合，但是他们都是通过消息队列来实现消息的消费进度。不同点在于广播消息，kafka也将广播消息的消费进度放入__consumer_offset这个主题中去保存了，增加了消息的可靠性，而RocketMQ对于广播消息消费偏移量的处理，是放在本地文件中处理的，这样到底靠不靠谱，我也没试过。以上是我的理解，理解错误的地方，还忘老师指正","like_count":0},{"had_liked":false,"id":267259,"user_name":"Jin Se","can_delete":false,"product_type":"c1","uid":2126729,"ip_address":"","ucode":"B731A09BA1BC16","user_header":"https://static001.geekbang.org/account/avatar/00/20/73/89/3082c8a1.jpg","comment_is_top":false,"comment_ctime":1607661720,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"RocketMQ只在队列上保证消息的有序性，主体层面是无法保证消息的有序性。我觉得这句话有问题，在RocketMQ的官方例子中，顺序消息也可以做到保证全局（topic）的有序性，只要该topic下只有一个queue(分区队列)，那消息不就是全局有序的嘛","like_count":0},{"had_liked":false,"id":265825,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1607044949,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"老师；同一个消费者组内消费者消费同一个队列中的消息的机制和rabbitmq是一样的吧，broker在确认消息成功消费后才会发送下一条消息；增加消费者数量实际上只是保证了消费者高可用。","like_count":0},{"had_liked":false,"id":258761,"user_name":"大橘为重","can_delete":false,"product_type":"c1","uid":1106152,"ip_address":"","ucode":"96479F205B8384","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/e8/66439469.jpg","comment_is_top":false,"comment_ctime":1604551186,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"看了很多遍才理解主题中的队列对并发的影响，没白费","like_count":0},{"had_liked":false,"id":253827,"user_name":"debugable","can_delete":false,"product_type":"c1","uid":1113497,"ip_address":"","ucode":"4CBF0A64E19BE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/99/6e05432a.jpg","comment_is_top":false,"comment_ctime":1602907950,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"老师您好：\nQ1:我们正在使用rocketmq，既然每个队列只能串行消费，无法做到并发，多个消费者组之间同一个队列是否也是串行消费呢？\nQ2:队列或主题的权限如何控制？可否指定topic只被某些组来消费呢？","like_count":0},{"had_liked":false,"id":278089,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1612755480,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"老师您好，我在这里还是没搞明白：发布订阅模式是如何解决一份消息被多次消费的问题，文中说通过复制多份的做法显然不好，但是我没找到“发布-订阅”是具体是什么原理呐？","like_count":0},{"had_liked":false,"id":276126,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1611803250,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"首先说对于单个队列的并行消费,必然存在竞争,那么抛开竞争\n针对这个问题,我首先想到的是借鉴TCP协议的传输方式\nSACK传输加上滑动窗口协议\n1.SACK传输实现简单就是消费者返回已经确认的消息序号给队列,确认已接受\n2.然后再利用滑动窗口协议,我们将队列分为 已发送已确认,已发送未确认,未发送可发送,不可发送四个部分,然后通过消费的速率不断调整窗口大小,以及保证已发送和可发送的剩余来不断的进行消费","like_count":0},{"had_liked":false,"id":272864,"user_name":"乐萌TD","can_delete":false,"product_type":"c1","uid":1792420,"ip_address":"","ucode":"AAD1355E371620","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo62pttzxBohm02HCWdNyfa8ZslBt7579t4M2LySyv1PkorIGyx9Q7iaWEHOrS1S93By4kBTjeLkyA/132","comment_is_top":false,"comment_ctime":1610335926,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"老师好，多个消费组消费同一个队列时，每个消费组都要维护一个自己的消费位置吗？","like_count":0},{"had_liked":false,"id":270191,"user_name":"轻风细语","can_delete":false,"product_type":"c1","uid":2377659,"ip_address":"","ucode":"CF5DAF463AAABC","user_header":"https://static001.geekbang.org/account/avatar/00/24/47/bb/7022979e.jpg","comment_is_top":false,"comment_ctime":1608977745,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"老师，咨询一个设计的问题(基于RocketMQ)：一个订单请求涉及2个消息，这2个消息是需要串行顺序执行的；而不同的订单请求之间的消息是要无需可并行的。\n\t\n一个参考的设计方案：\n\t通过订单编号取模，将同一个订单的消息存入同一个队列中，因为队列是先进先出，并且队列只会被一个消费组串行消费。\n\t\n对这个设计的疑问：\n1，这个方案是否解决此业务问题？ 有更好的推荐方案吗？\n2，这个设计方案，我认为有一个前提条件是:同一个Topic的消息记录是可以多个不同的Broker中，并且同一个Topic在不同Broker中的消息是完全一样的。\n\t这个前提条件的观点是对的吗？","like_count":0},{"had_liked":false,"id":269118,"user_name":"老大不小","can_delete":false,"product_type":"c1","uid":1295609,"ip_address":"","ucode":"35BCDD3CB13467","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","comment_is_top":false,"comment_ctime":1608532421,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"我对思考题的答案：\n       如果不严格要求顺序，一个消费者组里可以做到单个队列并行消费的，前提是要处理好消息的幂等性问题。\n       ","like_count":0},{"had_liked":false,"id":267930,"user_name":"蔫巴的小白菜","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1607999282,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"关于消费者偏移量维护，我简单的对比了下RocketMQ与kafka的相关实现原理，Rocket主要在队列中用minOffset，currentOffset，maxOffset维护了队列中消费者消息的可见性，以及消息的写入点，这点与kafka的logStartOffset，HW，logEndOffset的设计不谋而合，但是他们都是通过消息队列来实现消息的消费进度。不同点在于广播消息，kafka也将广播消息的消费进度放入__consumer_offset这个主题中去保存了，增加了消息的可靠性，而RocketMQ对于广播消息消费偏移量的处理，是放在本地文件中处理的，这样到底靠不靠谱，我也没试过。以上是我的理解，理解错误的地方，还忘老师指正","like_count":0},{"had_liked":false,"id":267259,"user_name":"Jin Se","can_delete":false,"product_type":"c1","uid":2126729,"ip_address":"","ucode":"B731A09BA1BC16","user_header":"https://static001.geekbang.org/account/avatar/00/20/73/89/3082c8a1.jpg","comment_is_top":false,"comment_ctime":1607661720,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"RocketMQ只在队列上保证消息的有序性，主体层面是无法保证消息的有序性。我觉得这句话有问题，在RocketMQ的官方例子中，顺序消息也可以做到保证全局（topic）的有序性，只要该topic下只有一个queue(分区队列)，那消息不就是全局有序的嘛","like_count":0},{"had_liked":false,"id":265825,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1607044949,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"老师；同一个消费者组内消费者消费同一个队列中的消息的机制和rabbitmq是一样的吧，broker在确认消息成功消费后才会发送下一条消息；增加消费者数量实际上只是保证了消费者高可用。","like_count":0},{"had_liked":false,"id":258761,"user_name":"大橘为重","can_delete":false,"product_type":"c1","uid":1106152,"ip_address":"","ucode":"96479F205B8384","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/e8/66439469.jpg","comment_is_top":false,"comment_ctime":1604551186,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"看了很多遍才理解主题中的队列对并发的影响，没白费","like_count":0},{"had_liked":false,"id":253827,"user_name":"debugable","can_delete":false,"product_type":"c1","uid":1113497,"ip_address":"","ucode":"4CBF0A64E19BE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/99/6e05432a.jpg","comment_is_top":false,"comment_ctime":1602907950,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100032301,"comment_content":"老师您好：\nQ1:我们正在使用rocketmq，既然每个队列只能串行消费，无法做到并发，多个消费者组之间同一个队列是否也是串行消费呢？\nQ2:队列或主题的权限如何控制？可否指定topic只被某些组来消费呢？","like_count":0},{"had_liked":false,"id":249377,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1600613524,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"如果不关注严格消费顺序，想要做到并行消费。可以借鉴高并发处理的思路，线程池和乐观锁悲观锁。具体实现是AQS和CAS .","like_count":0},{"had_liked":false,"id":245174,"user_name":"二少","can_delete":false,"product_type":"c1","uid":1442885,"ip_address":"","ucode":"190983809CD3EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/45/0c474d47.jpg","comment_is_top":false,"comment_ctime":1598855388,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"李老师，RocketMQ 的消息模型的那个图中，好像那几个重要概念没有在&quot;同一个层次&quot;上吧。对于消费者那部分，应该是有多个&quot;消费组&quot;，而不是同一个消费组中的&quot;多个消费者&quot;。而且，对于一个queue上的消费位置来说，是在&quot;消费组&quot;这个层面上维护的。文中的那个模型图将其标记在某一个&quot;消费者&quot;这个层次上了。有点令人费解。请李老师考虑一下。","like_count":0},{"had_liked":false,"id":244861,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1598705972,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"队列就是用来协调消费速度的，个人觉得这里有点像分治的感觉","like_count":0},{"had_liked":false,"id":243368,"user_name":"鹏小蔡","can_delete":false,"product_type":"c1","uid":1302573,"ip_address":"","ucode":"EA0EBE6817261D","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/2d/1332fad1.jpg","comment_is_top":false,"comment_ctime":1598075507,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"老师， 初学者有一些疑问的地方 ，希望老师可以帮忙解答:\n如果一个消费者服务有多个实例，部署的时候共用一份配置文件，如果想多个实例都要收到kafka推送的同一条消息，那是不是部署的时候要分不同的配置文件去指定不同的消费组呢?我记得用rabbitMQ是不是可以用广播的模式做到所有实例都能收到消息的。","like_count":0},{"had_liked":false,"id":242469,"user_name":"不工","can_delete":false,"product_type":"c1","uid":1462843,"ip_address":"","ucode":"A8725E6D0E1765","user_header":"https://static001.geekbang.org/account/avatar/00/16/52/3b/f1501d79.jpg","comment_is_top":false,"comment_ctime":1597736879,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"A1：“在某一条消息被成功消费之前，下一条消息是不能被消费的” ，那假设有一条消息，在队列A中消费失败了，然后重试，重试16次期间，这个队列一直阻塞在这一条信息这吗？","like_count":0},{"had_liked":false,"id":237711,"user_name":"团","can_delete":false,"product_type":"c1","uid":1113864,"ip_address":"","ucode":"D56ABBCE4E4D90","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/08/7c18d8a4.jpg","comment_is_top":false,"comment_ctime":1595931792,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"老师，您在精选留言中，回复一条问题时说kafka会给主题中的消息设置过时时间，时间到了就删除，那如果这条消息还没有被所有订阅消费到怎么办？那对那些还没有消费到的订阅来说是不是就属于丢消息了？","like_count":0},{"had_liked":false,"id":237707,"user_name":"团","can_delete":false,"product_type":"c1","uid":1113864,"ip_address":"","ucode":"D56ABBCE4E4D90","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/08/7c18d8a4.jpg","comment_is_top":false,"comment_ctime":1595931364,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"老师你好，我对文中讲的因为消费单队列时要保证严格有序所以同一时间只能有一个消费者在消费一个主题，这样效率低下，所以引入了多队列，这块没太理解，这个严格有序是指1）每一个消费者在自身消费队列消息时的严格有序，还是说2）所有消费者消费消息时统一的一个有序？如果是2）的话，那比如风控系统是一个消费者，仓库系统是一个消费者，假如二者互不影响，好像不应该互相保持一个统一的有序性；如果是1）的话，那么两个系统互不影响，可以在单队列上分别设置自己的消费位置，分别消费，但是文中又说，同一时间只能有一个消费者消费队列，性能低下，所以引入了多队列。就是说引入多队列的原因这块我还是有点糊涂，没太看明白。望老师指点。","like_count":0},{"had_liked":false,"id":233116,"user_name":"大碗碗小婉婉","can_delete":false,"product_type":"c1","uid":1887979,"ip_address":"","ucode":"A2F24BDBC5CDA9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIveS9MIL9ngiczzS9Nb2SibL7rw9uVHZnwo0SVYvX3MvAKnL7JHupcG8lCNvnYbicC02F5xmLFvZlkg/132","comment_is_top":false,"comment_ctime":1594220187,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"老师您好，初学者想问一下RocketMq中Tag的使用场景。1、如果同一个主题下，同一个分组不同Tag会导致消息错乱吗，例如TagA消费了TagB的消息，2、假如有影响的话需要同一个主题下对不同Tag进行消费要怎么做呢。","like_count":0},{"had_liked":false,"id":233018,"user_name":"Vin","can_delete":false,"product_type":"c1","uid":1522286,"ip_address":"","ucode":"57EAAB6CB351A7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AhKPj65f2kry3LbSu1yqRUJiaQfibkROCUfp1pNO3w0zGNBosNqF6Zx19UpbbsKyvr6ylpT6n4qiaC4vI46x4lABQ/132","comment_is_top":false,"comment_ctime":1594194297,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"老是您好，对于 rocketMQ 我这么理解，你看正确吗？\n       每个主题相当于一个队列，一个主题可以被多个消费组订阅，每个消费组中独对应多个消费着。消费组之间属于竞争关系，消费组中多个消费者也属于竞争关系。\n       每个主题（队列）中都有一个 offet ，用于维护消费的位置。","like_count":0},{"had_liked":false,"id":230196,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1593308630,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"单个队列并行消费需要解决的是消息确认的顺序问题。比如单个队列出去10条消息(并发)，那么该队列需要维护这10条消息的消费状态。对于那些一直没有重置状态的消息可以通过超时重发来弥补。","like_count":0},{"had_liked":false,"id":249377,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1600613524,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"如果不关注严格消费顺序，想要做到并行消费。可以借鉴高并发处理的思路，线程池和乐观锁悲观锁。具体实现是AQS和CAS .","like_count":0},{"had_liked":false,"id":245174,"user_name":"二少","can_delete":false,"product_type":"c1","uid":1442885,"ip_address":"","ucode":"190983809CD3EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/45/0c474d47.jpg","comment_is_top":false,"comment_ctime":1598855388,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"李老师，RocketMQ 的消息模型的那个图中，好像那几个重要概念没有在&quot;同一个层次&quot;上吧。对于消费者那部分，应该是有多个&quot;消费组&quot;，而不是同一个消费组中的&quot;多个消费者&quot;。而且，对于一个queue上的消费位置来说，是在&quot;消费组&quot;这个层面上维护的。文中的那个模型图将其标记在某一个&quot;消费者&quot;这个层次上了。有点令人费解。请李老师考虑一下。","like_count":0},{"had_liked":false,"id":244861,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1598705972,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"队列就是用来协调消费速度的，个人觉得这里有点像分治的感觉","like_count":0},{"had_liked":false,"id":243368,"user_name":"鹏小蔡","can_delete":false,"product_type":"c1","uid":1302573,"ip_address":"","ucode":"EA0EBE6817261D","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/2d/1332fad1.jpg","comment_is_top":false,"comment_ctime":1598075507,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"老师， 初学者有一些疑问的地方 ，希望老师可以帮忙解答:\n如果一个消费者服务有多个实例，部署的时候共用一份配置文件，如果想多个实例都要收到kafka推送的同一条消息，那是不是部署的时候要分不同的配置文件去指定不同的消费组呢?我记得用rabbitMQ是不是可以用广播的模式做到所有实例都能收到消息的。","like_count":0},{"had_liked":false,"id":242469,"user_name":"不工","can_delete":false,"product_type":"c1","uid":1462843,"ip_address":"","ucode":"A8725E6D0E1765","user_header":"https://static001.geekbang.org/account/avatar/00/16/52/3b/f1501d79.jpg","comment_is_top":false,"comment_ctime":1597736879,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"A1：“在某一条消息被成功消费之前，下一条消息是不能被消费的” ，那假设有一条消息，在队列A中消费失败了，然后重试，重试16次期间，这个队列一直阻塞在这一条信息这吗？","like_count":0},{"had_liked":false,"id":237711,"user_name":"团","can_delete":false,"product_type":"c1","uid":1113864,"ip_address":"","ucode":"D56ABBCE4E4D90","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/08/7c18d8a4.jpg","comment_is_top":false,"comment_ctime":1595931792,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"老师，您在精选留言中，回复一条问题时说kafka会给主题中的消息设置过时时间，时间到了就删除，那如果这条消息还没有被所有订阅消费到怎么办？那对那些还没有消费到的订阅来说是不是就属于丢消息了？","like_count":0},{"had_liked":false,"id":237707,"user_name":"团","can_delete":false,"product_type":"c1","uid":1113864,"ip_address":"","ucode":"D56ABBCE4E4D90","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/08/7c18d8a4.jpg","comment_is_top":false,"comment_ctime":1595931364,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"老师你好，我对文中讲的因为消费单队列时要保证严格有序所以同一时间只能有一个消费者在消费一个主题，这样效率低下，所以引入了多队列，这块没太理解，这个严格有序是指1）每一个消费者在自身消费队列消息时的严格有序，还是说2）所有消费者消费消息时统一的一个有序？如果是2）的话，那比如风控系统是一个消费者，仓库系统是一个消费者，假如二者互不影响，好像不应该互相保持一个统一的有序性；如果是1）的话，那么两个系统互不影响，可以在单队列上分别设置自己的消费位置，分别消费，但是文中又说，同一时间只能有一个消费者消费队列，性能低下，所以引入了多队列。就是说引入多队列的原因这块我还是有点糊涂，没太看明白。望老师指点。","like_count":0},{"had_liked":false,"id":233116,"user_name":"大碗碗小婉婉","can_delete":false,"product_type":"c1","uid":1887979,"ip_address":"","ucode":"A2F24BDBC5CDA9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIveS9MIL9ngiczzS9Nb2SibL7rw9uVHZnwo0SVYvX3MvAKnL7JHupcG8lCNvnYbicC02F5xmLFvZlkg/132","comment_is_top":false,"comment_ctime":1594220187,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"老师您好，初学者想问一下RocketMq中Tag的使用场景。1、如果同一个主题下，同一个分组不同Tag会导致消息错乱吗，例如TagA消费了TagB的消息，2、假如有影响的话需要同一个主题下对不同Tag进行消费要怎么做呢。","like_count":0},{"had_liked":false,"id":233018,"user_name":"Vin","can_delete":false,"product_type":"c1","uid":1522286,"ip_address":"","ucode":"57EAAB6CB351A7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AhKPj65f2kry3LbSu1yqRUJiaQfibkROCUfp1pNO3w0zGNBosNqF6Zx19UpbbsKyvr6ylpT6n4qiaC4vI46x4lABQ/132","comment_is_top":false,"comment_ctime":1594194297,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"老是您好，对于 rocketMQ 我这么理解，你看正确吗？\n       每个主题相当于一个队列，一个主题可以被多个消费组订阅，每个消费组中独对应多个消费着。消费组之间属于竞争关系，消费组中多个消费者也属于竞争关系。\n       每个主题（队列）中都有一个 offet ，用于维护消费的位置。","like_count":0},{"had_liked":false,"id":230196,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1593308630,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100032301,"comment_content":"单个队列并行消费需要解决的是消息确认的顺序问题。比如单个队列出去10条消息(并发)，那么该队列需要维护这10条消息的消费状态。对于那些一直没有重置状态的消息可以通过超时重发来弥补。","like_count":0},{"had_liked":false,"id":228379,"user_name":"芥末君","can_delete":false,"product_type":"c1","uid":1507918,"ip_address":"","ucode":"DC54FCB50C681A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV0tagXJJXHPic5nPiaf5cwQliaLQuQd5bOPrwa8FvemaNc9V2XvGbrsIoPVVdOZLbAIZoHF750OakA/132","comment_is_top":false,"comment_ctime":1592652221,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"消费组A（3台服务器）和消费组B（4台服务器）同时消费TopicA，这时Kafka的TopicA中有几个分区?如何保证消费者A和B的服务器负载均衡？","like_count":0},{"had_liked":false,"id":219300,"user_name":"丁乐洪","can_delete":false,"product_type":"c1","uid":1264392,"ip_address":"","ucode":"549CE57AB20B49","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","comment_is_top":false,"comment_ctime":1589986308,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"老师赞一个。\n提问前可以先看看留言，很多问题是重复的","like_count":0},{"had_liked":false,"id":207391,"user_name":"楼顶凉席看星星","can_delete":false,"product_type":"c1","uid":1101314,"ip_address":"","ucode":"8E20DFA8CDBF28","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/02/9947b2c8.jpg","comment_is_top":false,"comment_ctime":1587080535,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"建议将Kafka的介绍放到RocketMq的前面，从推出时间以及技术上来说，RcoetMq初期是依托了Kafka的设计并进行了业务针对性的改造","like_count":0},{"had_liked":false,"id":194720,"user_name":"王立光","can_delete":false,"product_type":"c1","uid":1058836,"ip_address":"","ucode":"3890B19E124960","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/14/875e8513.jpg","comment_is_top":false,"comment_ctime":1585099738,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"这两种模型现在看来都没有解耦啊，RabbitMQ，一个消费者对应一个队列，这样队列服务需要维护一个消费者列表，rocketMQ也有同样的问题的同时，还有另外的问题啊，比如：不同消费组的消费者数量是不一致的。望老师给予指导哈","like_count":0},{"had_liked":false,"id":190467,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1584662691,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"一个消费组的，用户是竞争关系呢？一个消息只会被同一个消费组的一个用户消费呢？","like_count":0},{"had_liked":false,"id":189380,"user_name":"StopLiu","can_delete":false,"product_type":"c1","uid":1007344,"ip_address":"","ucode":"1553FA4E3A285D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/f0/fab69114.jpg","comment_is_top":false,"comment_ctime":1584507855,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"老师，rabbitMQ 的这种处理方式和rocketMQ相比，有什么优劣呢？","like_count":0},{"had_liked":false,"id":183267,"user_name":"李朝辉","can_delete":false,"product_type":"c1","uid":1152951,"ip_address":"","ucode":"8E4A4469A77A88","user_header":"https://static001.geekbang.org/account/avatar/00/11/97/b7/d5a83264.jpg","comment_is_top":false,"comment_ctime":1582984446,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"课后题应该是指，同一个消费组中的不同消费者，对同一个队列的消息进行并行消费吧？\n我觉得可以参考RocketMQ为每个消费组在每个队列上维护一个消费位置的做法，延伸下去，每个消费者可以同时获取到消息，但是消费时需要进行一次CAS操作，比对当前的消费位置与拿到消息时是否发生了变化，如果不一致，就取消消费的操作，如果一致，就完成消费","like_count":0},{"had_liked":false,"id":180871,"user_name":"凌空飞起的剪刀腿","can_delete":false,"product_type":"c1","uid":1243680,"ip_address":"","ucode":"16FBBF4A3B54C6","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/20/0f06b080.jpg","comment_is_top":false,"comment_ctime":1582432545,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"老师您好！对于rocketMQ同组消费者是无法消费相同同一个队列的topic的啊？","like_count":0},{"had_liked":false,"id":156691,"user_name":"FreeMason","can_delete":false,"product_type":"c1","uid":1340120,"ip_address":"","ucode":"3D58AC2F9AB345","user_header":"https://static001.geekbang.org/account/avatar/00/14/72/d8/9eedbc5e.jpg","comment_is_top":false,"comment_ctime":1574935980,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"MQ 初学者，虽然对于 MQ 的名词有接触过旦未深入理解过，每见一个名词都要对应的搜索下名词的意思，理解可能会有出入，以下问题部分谷歌百度未搜索到满意的文章，还请老师更正解答\n\n文档关键词：生产者（发布者）、消费者（订阅者）、队列（分区）、主题、消费位置、消费组\n\n生产者（发布者）：数据的产生者\n消费者（订阅者）：数据的接收者（可以是一个或多个，RabbitMQ 通过 Exchange 变相实现一对多）\n主题：不是怎么理解\n队列（分区）：对数据水平分割，实现扩展性\n消费位置：类似钟表的指针，秒针走完一圈（消费完），分针就移动对应的一个分针位置\n消费组：对于队列来说，消费组就是一个消费者，把消息给了消费组，具体是由组内的某某消费，队列并不关心。\n\n一个 MQ ，可以有一个或多个 topic ，一个 topic 可以有一个或多个 queue，一个 queue 同一个时刻内只能有一个消费\n\n问题：\n\n1、topic 是什么？\n2、topic 主要职责是什么？\n3、topic 是把相同作用的队列放在一起管理吗还是只是对一组相同作用的队列命名？\n4、消费组接收消息是通过拉还是推得到的？\n5、得到消息后又是如何分配给组内某一个成员的及成员间是如何竞争？\n6、消费组、队列之间的关系？消费组与队列是一对一、一对多还是多对多？\n\n思考题\n这方面是外行，只能是根据自己已有的知识，谈谈看法，具有知识局限性\n\nA1：只有一个队列，一次只出一条数据，如何并行？如果出的速度远快于消费（异步操作），能想到的是对于消费者来说是准实时并行。但对这个列队来说，还是串行。\n","like_count":0},{"had_liked":false,"id":150011,"user_name":"恩佐","can_delete":false,"product_type":"c1","uid":1509370,"ip_address":"","ucode":"955C45137073EE","user_header":"https://static001.geekbang.org/account/avatar/00/17/07/fa/62186c97.jpg","comment_is_top":false,"comment_ctime":1573444957,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"李玥老师讲的太好了，看一遍我就全懂了","like_count":0},{"had_liked":false,"id":228379,"user_name":"芥末君","can_delete":false,"product_type":"c1","uid":1507918,"ip_address":"","ucode":"DC54FCB50C681A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV0tagXJJXHPic5nPiaf5cwQliaLQuQd5bOPrwa8FvemaNc9V2XvGbrsIoPVVdOZLbAIZoHF750OakA/132","comment_is_top":false,"comment_ctime":1592652221,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"消费组A（3台服务器）和消费组B（4台服务器）同时消费TopicA，这时Kafka的TopicA中有几个分区?如何保证消费者A和B的服务器负载均衡？","like_count":0},{"had_liked":false,"id":219300,"user_name":"丁乐洪","can_delete":false,"product_type":"c1","uid":1264392,"ip_address":"","ucode":"549CE57AB20B49","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","comment_is_top":false,"comment_ctime":1589986308,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"老师赞一个。\n提问前可以先看看留言，很多问题是重复的","like_count":0},{"had_liked":false,"id":207391,"user_name":"楼顶凉席看星星","can_delete":false,"product_type":"c1","uid":1101314,"ip_address":"","ucode":"8E20DFA8CDBF28","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/02/9947b2c8.jpg","comment_is_top":false,"comment_ctime":1587080535,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"建议将Kafka的介绍放到RocketMq的前面，从推出时间以及技术上来说，RcoetMq初期是依托了Kafka的设计并进行了业务针对性的改造","like_count":0},{"had_liked":false,"id":194720,"user_name":"王立光","can_delete":false,"product_type":"c1","uid":1058836,"ip_address":"","ucode":"3890B19E124960","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/14/875e8513.jpg","comment_is_top":false,"comment_ctime":1585099738,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"这两种模型现在看来都没有解耦啊，RabbitMQ，一个消费者对应一个队列，这样队列服务需要维护一个消费者列表，rocketMQ也有同样的问题的同时，还有另外的问题啊，比如：不同消费组的消费者数量是不一致的。望老师给予指导哈","like_count":0},{"had_liked":false,"id":190467,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1584662691,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"一个消费组的，用户是竞争关系呢？一个消息只会被同一个消费组的一个用户消费呢？","like_count":0},{"had_liked":false,"id":189380,"user_name":"StopLiu","can_delete":false,"product_type":"c1","uid":1007344,"ip_address":"","ucode":"1553FA4E3A285D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/f0/fab69114.jpg","comment_is_top":false,"comment_ctime":1584507855,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"老师，rabbitMQ 的这种处理方式和rocketMQ相比，有什么优劣呢？","like_count":0},{"had_liked":false,"id":183267,"user_name":"李朝辉","can_delete":false,"product_type":"c1","uid":1152951,"ip_address":"","ucode":"8E4A4469A77A88","user_header":"https://static001.geekbang.org/account/avatar/00/11/97/b7/d5a83264.jpg","comment_is_top":false,"comment_ctime":1582984446,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"课后题应该是指，同一个消费组中的不同消费者，对同一个队列的消息进行并行消费吧？\n我觉得可以参考RocketMQ为每个消费组在每个队列上维护一个消费位置的做法，延伸下去，每个消费者可以同时获取到消息，但是消费时需要进行一次CAS操作，比对当前的消费位置与拿到消息时是否发生了变化，如果不一致，就取消消费的操作，如果一致，就完成消费","like_count":0},{"had_liked":false,"id":180871,"user_name":"凌空飞起的剪刀腿","can_delete":false,"product_type":"c1","uid":1243680,"ip_address":"","ucode":"16FBBF4A3B54C6","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/20/0f06b080.jpg","comment_is_top":false,"comment_ctime":1582432545,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"老师您好！对于rocketMQ同组消费者是无法消费相同同一个队列的topic的啊？","like_count":0},{"had_liked":false,"id":156691,"user_name":"FreeMason","can_delete":false,"product_type":"c1","uid":1340120,"ip_address":"","ucode":"3D58AC2F9AB345","user_header":"https://static001.geekbang.org/account/avatar/00/14/72/d8/9eedbc5e.jpg","comment_is_top":false,"comment_ctime":1574935980,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"MQ 初学者，虽然对于 MQ 的名词有接触过旦未深入理解过，每见一个名词都要对应的搜索下名词的意思，理解可能会有出入，以下问题部分谷歌百度未搜索到满意的文章，还请老师更正解答\n\n文档关键词：生产者（发布者）、消费者（订阅者）、队列（分区）、主题、消费位置、消费组\n\n生产者（发布者）：数据的产生者\n消费者（订阅者）：数据的接收者（可以是一个或多个，RabbitMQ 通过 Exchange 变相实现一对多）\n主题：不是怎么理解\n队列（分区）：对数据水平分割，实现扩展性\n消费位置：类似钟表的指针，秒针走完一圈（消费完），分针就移动对应的一个分针位置\n消费组：对于队列来说，消费组就是一个消费者，把消息给了消费组，具体是由组内的某某消费，队列并不关心。\n\n一个 MQ ，可以有一个或多个 topic ，一个 topic 可以有一个或多个 queue，一个 queue 同一个时刻内只能有一个消费\n\n问题：\n\n1、topic 是什么？\n2、topic 主要职责是什么？\n3、topic 是把相同作用的队列放在一起管理吗还是只是对一组相同作用的队列命名？\n4、消费组接收消息是通过拉还是推得到的？\n5、得到消息后又是如何分配给组内某一个成员的及成员间是如何竞争？\n6、消费组、队列之间的关系？消费组与队列是一对一、一对多还是多对多？\n\n思考题\n这方面是外行，只能是根据自己已有的知识，谈谈看法，具有知识局限性\n\nA1：只有一个队列，一次只出一条数据，如何并行？如果出的速度远快于消费（异步操作），能想到的是对于消费者来说是准实时并行。但对这个列队来说，还是串行。\n","like_count":0},{"had_liked":false,"id":150011,"user_name":"恩佐","can_delete":false,"product_type":"c1","uid":1509370,"ip_address":"","ucode":"955C45137073EE","user_header":"https://static001.geekbang.org/account/avatar/00/17/07/fa/62186c97.jpg","comment_is_top":false,"comment_ctime":1573444957,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":21,"product_id":100032301,"comment_content":"李玥老师讲的太好了，看一遍我就全懂了","like_count":0},{"had_liked":false,"id":146080,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1572429347,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"个人理解：\n1）RabbitMQ 采用的是队列模型：\n生产者将消息发送给 Exchange，Exchange 有 fanout-广播，topic-主题，direct-直传 等不同的类型，队列绑定到 Exchange 上，Exchange 将消息转发给符合路由规则的队列，消费者监听队列获取消息进行消费。\n\n2）RocketMQ 和 Kafka 采用的是发布-订阅模型：\n生产者将消息发送给 Topic-主题，主题内可以包含多个队列（Kafka 为 Partition-分区），通过多个队列来实现多实例并行生产和消费，提高并发度，不同队列上接收的消息都是不同的（生产者发送的消息被主体内的某个队列接收，不会有多个队列接收同一个消息数据）。Topic-主题可以被多个消费组（Consumer Group）订阅，每个消费组内可以有多个消费者（Consumer），主体内的消息广播发送给已订阅的消费组，只能被消费组内的某一个消费者消费。每个消费组在主体内的每个队列上都维护一个消费位置（Consumer Offset），这样就可以记录队列上哪些消息被这个消费组消费过，保证消费组不会重复消费同一个消息。","like_count":0},{"had_liked":false,"id":143635,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1571749394,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"可以实现，不等待前一个消息的确定，下一个消息直接被消费，但需要异步的处理消息的失败重新消费的逻辑","like_count":0},{"had_liked":false,"id":132765,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1568215504,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"我说一下我的理解:\n目前消息队列没有严格的规范: 主要有两种模式,一种是传统的严格有序队列模式,数据结构为数组或链表,另一种是“发布-订阅”模式,它们两个本质上是一样的,只不过第二种是可以将消息进行分组(消费分组),组内都能收到相同的消息,第一种只能“先进先出”把消息给同一组消费者消费.还有一点就是由于第一种模式的局限性,消费者不能并行的消费消息,而第二种通过将主题内消息装填到多个“队列”(Kakfa叫分区)来供多个消费者去消费,来达到提升业务端消费能力的目的.\n\n总结一下,感觉名词很多:\n\n消费者\n主题 比如订单类消息、异步任务类消息是两种业务类型,可以建立两个主题\n订阅者 就是消费分组吧,组与组之间是完全分隔的,每个组都能拉到同一主题下的所有消息,比如订单主题的消息,下面消费者分组可以分为: 风控组、运营组、财务组\n发布(生产者) 创建消息,供消费者消费\n消费分组 同订阅者\nbroker 消息队列服务,接受生产者创建的消息,以及给消费者发送消息,或者供消费者主动拉取消息\n队列(分区) 在同一队列中的消息是严格有序的,遵循先进先出,消息被消费完并不会直接删除消息,因为有多个消息分组,A分组消费了消息M1,但是B分组可能还没开始消费M1呢,队列消费是有个“消费位置”的概念,具体这边还是比较模糊的,后续再看...\n","like_count":0},{"had_liked":false,"id":132379,"user_name":"顶新","can_delete":false,"product_type":"c1","uid":1036566,"ip_address":"","ucode":"241D3CCCAE536B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/16/6347bbc0.jpg","comment_is_top":false,"comment_ctime":1568103739,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"刚刚开始理解RocketMQ 时，确实有点乱。后来整理思路再理解后，发现核心并没有变化，本质上还是普通的P&#47;S 模式. 只是RocketMQ 在 Topic 上进行了量变拆分，在 Subscribe 上也进行了量变拆分。从而保证了在 Topic在单个Queue上有序，在Subscribe上并行（每个Groups相对独立的消费Topic中的所有消息，一个Consumer随机消费一个Queue，但对同一个Queue时是竞争关系），互不影响。","like_count":0},{"had_liked":false,"id":125799,"user_name":"angel😇txy🤓","can_delete":false,"product_type":"c1","uid":1133702,"ip_address":"","ucode":"C0AEE0D8BAF7ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","comment_is_top":false,"comment_ctime":1566261288,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"思考题，因为单个队列是先进先出的，一个只允许出一个，在队列层面上无法并行消费，不过在消费者短，可以开多个线程采用批量拉取的方式去消费。","like_count":0},{"had_liked":false,"id":120485,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1564910911,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"课后习题: 在不保证消息有序消费和可以容忍丢消息情况下，一个消费组可以并发消息消费队列的消息，但是后果是可能有消息丢失。\n\n另外有个疑问就是，在发布订阅模式中，为了提高并发性能，维护多个消费队列，每个队列持有主题的一个全量消息，那你多个消息队列不会造成重复消费嘛？","like_count":0},{"had_liked":false,"id":119890,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1419276,"ip_address":"","ucode":"FAACCA4E6D481F","user_header":"https://static001.geekbang.org/account/avatar/00/15/a8/0c/82ba8ef9.jpg","comment_is_top":false,"comment_ctime":1564721122,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"老师讲得很好，讲得很深入","like_count":0},{"had_liked":false,"id":119222,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1564539305,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"activemq在一个队列多个消费者监听，服务端push不保证严格顺序，经常出现后入的消息先消费掉的情况，能严格保证顺序性就是单队列单消费者","like_count":0},{"had_liked":false,"id":119182,"user_name":"Survivor","can_delete":false,"product_type":"c1","uid":1016872,"ip_address":"","ucode":"06EF9BDBD90F32","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/28/1175240c.jpg","comment_is_top":false,"comment_ctime":1564535168,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"老师讲的很清楚，声音很舒服，👍","like_count":0},{"had_liked":false,"id":119086,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1564500880,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"两个地儿没看懂:\n1，队列模型图中那个前端跟后端跟这模型有什么关系吗？\n2，消息队列那个模型也没看明白，怎么就有序了呢？","like_count":0,"discussions":[{"author":{"id":1036566,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d1/16/6347bbc0.jpg","nickname":"顶新","note":"","ucode":"241D3CCCAE536B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8923,"discussion_content":"这个解释一下哈，一个队列多个消费，从ActiveMQ 层面的borker 看是顺序的。由于实际业务中，多个消费者的速度不一样，从而看上去后入却先消费掉的情况。建议你加上Ack 机制，可以解决。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568101687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146080,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1572429347,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"个人理解：\n1）RabbitMQ 采用的是队列模型：\n生产者将消息发送给 Exchange，Exchange 有 fanout-广播，topic-主题，direct-直传 等不同的类型，队列绑定到 Exchange 上，Exchange 将消息转发给符合路由规则的队列，消费者监听队列获取消息进行消费。\n\n2）RocketMQ 和 Kafka 采用的是发布-订阅模型：\n生产者将消息发送给 Topic-主题，主题内可以包含多个队列（Kafka 为 Partition-分区），通过多个队列来实现多实例并行生产和消费，提高并发度，不同队列上接收的消息都是不同的（生产者发送的消息被主体内的某个队列接收，不会有多个队列接收同一个消息数据）。Topic-主题可以被多个消费组（Consumer Group）订阅，每个消费组内可以有多个消费者（Consumer），主体内的消息广播发送给已订阅的消费组，只能被消费组内的某一个消费者消费。每个消费组在主体内的每个队列上都维护一个消费位置（Consumer Offset），这样就可以记录队列上哪些消息被这个消费组消费过，保证消费组不会重复消费同一个消息。","like_count":0},{"had_liked":false,"id":143635,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1571749394,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"可以实现，不等待前一个消息的确定，下一个消息直接被消费，但需要异步的处理消息的失败重新消费的逻辑","like_count":0},{"had_liked":false,"id":132765,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1568215504,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"我说一下我的理解:\n目前消息队列没有严格的规范: 主要有两种模式,一种是传统的严格有序队列模式,数据结构为数组或链表,另一种是“发布-订阅”模式,它们两个本质上是一样的,只不过第二种是可以将消息进行分组(消费分组),组内都能收到相同的消息,第一种只能“先进先出”把消息给同一组消费者消费.还有一点就是由于第一种模式的局限性,消费者不能并行的消费消息,而第二种通过将主题内消息装填到多个“队列”(Kakfa叫分区)来供多个消费者去消费,来达到提升业务端消费能力的目的.\n\n总结一下,感觉名词很多:\n\n消费者\n主题 比如订单类消息、异步任务类消息是两种业务类型,可以建立两个主题\n订阅者 就是消费分组吧,组与组之间是完全分隔的,每个组都能拉到同一主题下的所有消息,比如订单主题的消息,下面消费者分组可以分为: 风控组、运营组、财务组\n发布(生产者) 创建消息,供消费者消费\n消费分组 同订阅者\nbroker 消息队列服务,接受生产者创建的消息,以及给消费者发送消息,或者供消费者主动拉取消息\n队列(分区) 在同一队列中的消息是严格有序的,遵循先进先出,消息被消费完并不会直接删除消息,因为有多个消息分组,A分组消费了消息M1,但是B分组可能还没开始消费M1呢,队列消费是有个“消费位置”的概念,具体这边还是比较模糊的,后续再看...\n","like_count":0},{"had_liked":false,"id":132379,"user_name":"顶新","can_delete":false,"product_type":"c1","uid":1036566,"ip_address":"","ucode":"241D3CCCAE536B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/16/6347bbc0.jpg","comment_is_top":false,"comment_ctime":1568103739,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"刚刚开始理解RocketMQ 时，确实有点乱。后来整理思路再理解后，发现核心并没有变化，本质上还是普通的P&#47;S 模式. 只是RocketMQ 在 Topic 上进行了量变拆分，在 Subscribe 上也进行了量变拆分。从而保证了在 Topic在单个Queue上有序，在Subscribe上并行（每个Groups相对独立的消费Topic中的所有消息，一个Consumer随机消费一个Queue，但对同一个Queue时是竞争关系），互不影响。","like_count":0},{"had_liked":false,"id":125799,"user_name":"angel😇txy🤓","can_delete":false,"product_type":"c1","uid":1133702,"ip_address":"","ucode":"C0AEE0D8BAF7ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","comment_is_top":false,"comment_ctime":1566261288,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"思考题，因为单个队列是先进先出的，一个只允许出一个，在队列层面上无法并行消费，不过在消费者短，可以开多个线程采用批量拉取的方式去消费。","like_count":0},{"had_liked":false,"id":120485,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1564910911,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"课后习题: 在不保证消息有序消费和可以容忍丢消息情况下，一个消费组可以并发消息消费队列的消息，但是后果是可能有消息丢失。\n\n另外有个疑问就是，在发布订阅模式中，为了提高并发性能，维护多个消费队列，每个队列持有主题的一个全量消息，那你多个消息队列不会造成重复消费嘛？","like_count":0},{"had_liked":false,"id":119890,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1419276,"ip_address":"","ucode":"FAACCA4E6D481F","user_header":"https://static001.geekbang.org/account/avatar/00/15/a8/0c/82ba8ef9.jpg","comment_is_top":false,"comment_ctime":1564721122,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"老师讲得很好，讲得很深入","like_count":0},{"had_liked":false,"id":119222,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1564539305,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"activemq在一个队列多个消费者监听，服务端push不保证严格顺序，经常出现后入的消息先消费掉的情况，能严格保证顺序性就是单队列单消费者","like_count":0,"discussions":[{"author":{"id":1036566,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d1/16/6347bbc0.jpg","nickname":"顶新","note":"","ucode":"241D3CCCAE536B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8923,"discussion_content":"这个解释一下哈，一个队列多个消费，从ActiveMQ 层面的borker 看是顺序的。由于实际业务中，多个消费者的速度不一样，从而看上去后入却先消费掉的情况。建议你加上Ack 机制，可以解决。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568101687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119182,"user_name":"Survivor","can_delete":false,"product_type":"c1","uid":1016872,"ip_address":"","ucode":"06EF9BDBD90F32","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/28/1175240c.jpg","comment_is_top":false,"comment_ctime":1564535168,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"老师讲的很清楚，声音很舒服，👍","like_count":0},{"had_liked":false,"id":119086,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1564500880,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":22,"product_id":100032301,"comment_content":"两个地儿没看懂:\n1，队列模型图中那个前端跟后端跟这模型有什么关系吗？\n2，消息队列那个模型也没看明白，怎么就有序了呢？","like_count":0},{"had_liked":false,"id":118665,"user_name":"Black King Bar","can_delete":false,"product_type":"c1","uid":1465228,"ip_address":"","ucode":"EE236175B2299C","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/8c/2f1a8aaa.jpg","comment_is_top":false,"comment_ctime":1564410127,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"读写分离就可以并行了吧，读并行不会消费空洞，写串行。","like_count":0},{"had_liked":false,"id":118640,"user_name":"DAV 🍃","can_delete":false,"product_type":"c1","uid":1614531,"ip_address":"","ucode":"47A6A7B1D997FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/a2/c3/83545c57.jpg","comment_is_top":false,"comment_ctime":1564404565,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"两点拙见：\n1. RabbitMQ的FANOUT模式可以支持一天消息多次消费\n2. 并行消费队列如果不修改源码，可以在消费端再加一层控制逻辑，比如连续读取10条分给10个线程去处理，这样就近似并行消费了，原理就是加一个预消费层","like_count":0},{"had_liked":false,"id":118450,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1564366676,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"思考题没什么确定的好想法，只能说说自己的思路：\n维护一个消费标记的数组，与队列长度相等，对应位置的消息发送出去后变更标记，保证标记数组的可见性","like_count":0},{"had_liked":false,"id":118413,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1564362139,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"老师讲的很好👍","like_count":0},{"had_liked":false,"id":118378,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1564356195,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"签到5","like_count":0},{"had_liked":false,"id":118105,"user_name":"孙成子","can_delete":false,"product_type":"c1","uid":1317819,"ip_address":"","ucode":"7DF58E9202FC60","user_header":"https://static001.geekbang.org/account/avatar/00/14/1b/bb/4a749b6c.jpg","comment_is_top":false,"comment_ctime":1564243020,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":118011,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1564212209,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"和这个专栏相见恨晚，以前是糊里糊涂的用，一直停留在使用阶段。","like_count":0},{"had_liked":false,"id":117992,"user_name":"HDZ","can_delete":false,"product_type":"c1","uid":1239063,"ip_address":"","ucode":"5E0E5ECDF86F61","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/17/6c9a12c6.jpg","comment_is_top":false,"comment_ctime":1564208047,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":117980,"user_name":"DUO2.0","can_delete":false,"product_type":"c1","uid":1565172,"ip_address":"","ucode":"B8C1A267F959F1","user_header":"https://static001.geekbang.org/account/avatar/00/17/e1/f4/456752ac.jpg","comment_is_top":false,"comment_ctime":1564202687,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"队列模型还是一个好的例子是AWS的SQS服务","like_count":0},{"had_liked":false,"id":117939,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1564196155,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"个人认为单个队列可以并行消费，文中提到Consumer Offset的概念，并行消费时每次都发送Consumer Offset后的消息给订阅者，由于并行消费其中一个线程的Consumer Offset可能还没来得及被队列接收，而另外一个线程就请求消息了，所以会出现重复发送的问题，消费者业务需要做幂等处理。","like_count":0},{"had_liked":false,"id":118665,"user_name":"Black King Bar","can_delete":false,"product_type":"c1","uid":1465228,"ip_address":"","ucode":"EE236175B2299C","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/8c/2f1a8aaa.jpg","comment_is_top":false,"comment_ctime":1564410127,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"读写分离就可以并行了吧，读并行不会消费空洞，写串行。","like_count":0},{"had_liked":false,"id":118640,"user_name":"DAV 🍃","can_delete":false,"product_type":"c1","uid":1614531,"ip_address":"","ucode":"47A6A7B1D997FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/a2/c3/83545c57.jpg","comment_is_top":false,"comment_ctime":1564404565,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"两点拙见：\n1. RabbitMQ的FANOUT模式可以支持一天消息多次消费\n2. 并行消费队列如果不修改源码，可以在消费端再加一层控制逻辑，比如连续读取10条分给10个线程去处理，这样就近似并行消费了，原理就是加一个预消费层","like_count":0},{"had_liked":false,"id":118450,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1564366676,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"思考题没什么确定的好想法，只能说说自己的思路：\n维护一个消费标记的数组，与队列长度相等，对应位置的消息发送出去后变更标记，保证标记数组的可见性","like_count":0},{"had_liked":false,"id":118413,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1564362139,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"老师讲的很好👍","like_count":0},{"had_liked":false,"id":118378,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1564356195,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"签到5","like_count":0},{"had_liked":false,"id":118105,"user_name":"孙成子","can_delete":false,"product_type":"c1","uid":1317819,"ip_address":"","ucode":"7DF58E9202FC60","user_header":"https://static001.geekbang.org/account/avatar/00/14/1b/bb/4a749b6c.jpg","comment_is_top":false,"comment_ctime":1564243020,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":118011,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1564212209,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"和这个专栏相见恨晚，以前是糊里糊涂的用，一直停留在使用阶段。","like_count":0},{"had_liked":false,"id":117992,"user_name":"HDZ","can_delete":false,"product_type":"c1","uid":1239063,"ip_address":"","ucode":"5E0E5ECDF86F61","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/17/6c9a12c6.jpg","comment_is_top":false,"comment_ctime":1564208047,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":117980,"user_name":"DUO2.0","can_delete":false,"product_type":"c1","uid":1565172,"ip_address":"","ucode":"B8C1A267F959F1","user_header":"https://static001.geekbang.org/account/avatar/00/17/e1/f4/456752ac.jpg","comment_is_top":false,"comment_ctime":1564202687,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"队列模型还是一个好的例子是AWS的SQS服务","like_count":0},{"had_liked":false,"id":117939,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1564196155,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":23,"product_id":100032301,"comment_content":"个人认为单个队列可以并行消费，文中提到Consumer Offset的概念，并行消费时每次都发送Consumer Offset后的消息给订阅者，由于并行消费其中一个线程的Consumer Offset可能还没来得及被队列接收，而另外一个线程就请求消息了，所以会出现重复发送的问题，消费者业务需要做幂等处理。","like_count":0},{"had_liked":false,"id":117936,"user_name":"渔村蓝","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1564195879,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":24,"product_id":100032301,"comment_content":"思考题:单个队列把消息发给多个group。","like_count":0},{"had_liked":false,"id":117927,"user_name":"一记妙蛙直拳","can_delete":false,"product_type":"c1","uid":1375256,"ip_address":"","ucode":"BC3556131D4D61","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/18/8e69f7cf.jpg","comment_is_top":false,"comment_ctime":1564193693,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":24,"product_id":100032301,"comment_content":"对于rocketmq中的发布-订阅模型的理解，出入之处还请老师指点：\n为通过水平拓展消费者数量提升消费效率，rocketmq在topic中加入队列的概念，一个topic中有多个队列。其中每个队列的消息互不相同，所有队列中的消息共同组成topic的消息集合，即所有生产者向topic发送消息的集合。而订阅的概念是通过消费组来实现的，消费组中的成员（消费者）一一对应topic中的队列进行消费，为保证消息被不同的消费组消费，消费者消费消息后并不删除，而是打一个consumer offset，待所有消费组的consumer offset相同时再做删除。","like_count":0},{"had_liked":false,"id":117903,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1564186834,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":24,"product_id":100032301,"comment_content":"我觉得如果不严格按照顺序的话：消费组是否会乱？可能我觉得至少当前模式，消费组的各个消费者所获得要处理的消息是差不多的-至少我觉得当前的模式是为了消费组各组的信息差不多，rockmq最大的特性不是稳定性么。\n其实老师在说问这个问题的时候我觉得在引发出了另外一个问题：如果不按照严格顺序，那么消费组的消息各组之间的消息数可能完全不一样，引发的问题如何处理？\n这只是我对于今天学习的理解：不足之处还望老师提点。","like_count":0},{"had_liked":false,"id":117936,"user_name":"渔村蓝","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1564195879,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":24,"product_id":100032301,"comment_content":"思考题:单个队列把消息发给多个group。","like_count":0},{"had_liked":false,"id":117927,"user_name":"一记妙蛙直拳","can_delete":false,"product_type":"c1","uid":1375256,"ip_address":"","ucode":"BC3556131D4D61","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/18/8e69f7cf.jpg","comment_is_top":false,"comment_ctime":1564193693,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":24,"product_id":100032301,"comment_content":"对于rocketmq中的发布-订阅模型的理解，出入之处还请老师指点：\n为通过水平拓展消费者数量提升消费效率，rocketmq在topic中加入队列的概念，一个topic中有多个队列。其中每个队列的消息互不相同，所有队列中的消息共同组成topic的消息集合，即所有生产者向topic发送消息的集合。而订阅的概念是通过消费组来实现的，消费组中的成员（消费者）一一对应topic中的队列进行消费，为保证消息被不同的消费组消费，消费者消费消息后并不删除，而是打一个consumer offset，待所有消费组的consumer offset相同时再做删除。","like_count":0},{"had_liked":false,"id":117903,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1564186834,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":24,"product_id":100032301,"comment_content":"我觉得如果不严格按照顺序的话：消费组是否会乱？可能我觉得至少当前模式，消费组的各个消费者所获得要处理的消息是差不多的-至少我觉得当前的模式是为了消费组各组的信息差不多，rockmq最大的特性不是稳定性么。\n其实老师在说问这个问题的时候我觉得在引发出了另外一个问题：如果不按照严格顺序，那么消费组的消息各组之间的消息数可能完全不一样，引发的问题如何处理？\n这只是我对于今天学习的理解：不足之处还望老师提点。","like_count":0}]}