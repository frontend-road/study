{"id":166581,"title":"01丨程序运行原理：程序是如何运行又是如何崩溃的？","content":"<p>软件的核心载体是程序代码，软件开发的主要工作产出也是代码，但是代码被存储在磁盘上本身没有任何价值，软件要想实现价值，代码就必须运行起来。那么代码是如何运行的？在运行中可能会出现什么问题呢？</p><h2>程序是如何运行起来的</h2><p>软件被开发出来，是文本格式的代码，这些代码通常不能直接运行，需要使用编译器编译成操作系统或者虚拟机可以运行的代码，即可执行代码，它们都被存储在文件系统中。不管是文本格式的代码还是可执行的代码，都被称为<strong>程序</strong>，程序是静态的，安静地呆在磁盘上，什么也干不了。要想让程序处理数据，完成计算任务，必须把程序从外部设备加载到内存中，并在操作系统的管理调度下交给CPU去执行，去运行起来，才能真正发挥软件的作用，程序运行起来以后，被称作<strong>进程</strong>。</p><p>进程除了包含可执行的程序代码，还包括进程在运行期使用的内存堆空间、栈空间、供操作系统管理用的数据结构。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/89/98/89c6e3bbc44cdc042e7a8bcddb3b4398.png?wh=920*852\" alt=\"\"><br>\n操作系统把可执行代码加载到内存中，生成相应的数据结构和内存空间后，就从可执行代码的起始位置读取指令交给CPU顺序执行。指令执行过程中，可能会遇到一条跳转指令，即CPU要执行的下一条指令不是内存中可执行代码顺序的下一条指令。编程中使用的循环for…，while…和if…else…最后都被编译成跳转指令。</p><!-- [[[read_end]]] --><p>程序运行时如果需要创建数组等数据结构，操作系统就会在进程的<strong>堆空间</strong>申请一块相应的内存空间，并把这块内存的首地址信息记录在进程的栈中。堆是一块无序的内存空间，任何时候进程需要申请内存，都会从堆空间中分配，分配到的内存地址则记录在栈中。</p><p>栈是严格的一个后进先出的数据结构，同样由操作系统维护，主要用来记录函数内部的局部变量、堆空间分配的内存空间地址等。</p><p>我们以如下代码示例，描述函数调用过程中，栈的操作过程：</p><pre><code>void f(){\n  int x = g(1);\n  x++; //g函数返回，当前堆栈顶部为f函数栈帧，在当前栈帧继续执行f函数的代码。\n}\nint g(int x){\n  return x + 1;\n}\n</code></pre><p>每次函数调用，操作系统都会在栈中创建一个栈帧（stack frame）。正在执行的函数参数、局部变量、申请的内存地址等都在当前栈帧中，也就是堆栈的顶部栈帧中。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/f7/f08d6fca893da5cac926a23f1f1aa7f7.png?wh=1450*468\" alt=\"\"><br>\n当f函数执行的时候，f函数就在栈顶，栈帧中存储着f函数的局部变量，输入参数等等。当f函数调用g函数，当前执行函数就变成g函数，操作系统会为g函数创建一个栈帧并放置在栈顶。当函数g()调用结束，程序返回f函数，g函数对应的栈帧出栈，顶部栈帧变又为f函数，继续执行f函数的代码，也就是说，真正执行的函数永远都在栈顶。而且因为栈帧是隔离的，所以不同函数可以定义相同的变量而不会发生混乱。</p><h2>一台计算机如何同时处理数以百计的任务</h2><p>我们自己日常使用的PC计算机通常只是一核或者两核的CPU，我们部署应用程序的服务器虽然有更多的CPU核心，通常也不过几核或者几十核。但是我们的PC计算机可以同时编程、听音乐，而且还能执行下载任务，而服务器则可以同时处理数以百计甚至数以千计的<strong>并发</strong>用户请求。</p><p>那么为什么一台计算机服务器可以同时处理数以百计，以千计的计算任务呢？这里主要依靠的是操作系统的CPU分时共享技术。如果同时有很多个进程在执行，操作系统会将CPU的执行时间分成很多份，进程按照某种策略轮流在CPU上运行。由于现代CPU的计算能力非常强大，虽然每个进程都只被执行了很短一个时间，但是在外部看来却好像是所有的进程都在同时执行，每个进程似乎都独占一个CPU执行。</p><p>所以虽然从外部看起来，多个进程在同时运行，但是在实际物理上，进程并不总是在CPU上运行的，一方面进程共享CPU，所以需要等待CPU运行，另一方面，进程在执行I/O操作的时候，也不需要CPU运行。进程在生命周期中，主要有三种状态，运行、就绪、阻塞。</p><ul>\n<li><strong>运行</strong>：当一个进程在CPU上运行时，则称该进程处于运行状态。处于运行状态的进程的数目小于等于CPU的数目。</li>\n<li><strong>就绪</strong>：当一个进程获得了除CPU以外的一切所需资源，只要得到CPU即可运行，则称此进程处于就绪状态，就绪状态有时候也被称为等待运行状态。</li>\n<li><strong>阻塞</strong>：也称为等待或睡眠状态，当一个进程正在等待某一事件发生（例如等待I/O完成，等待锁……）而暂时停止运行，这时即使把CPU分配给进程也无法运行，故称该进程处于阻塞状态。</li>\n</ul><p>不同进程轮流在CPU上执行，每次都要进行进程间CPU切换，代价是非常大的，实际上，每个用户请求对应的不是一个进程，而是一个线程。线程可以理解为轻量级的进程，在进程内创建，拥有自己的线程栈，在CPU上进行线程切换的代价也更小。线程在运行时，和进程一样，也有三种主要状态，从逻辑上看，进程的主要概念都可以套用到线程上。我们在进行服务器应用开发的时候，通常都是多线程开发，理解线程对我们设计、开发软件更有价值。</p><h2>系统为什么会变慢，为什么会崩溃</h2><p>现在的服务器软件系统主要使用多线程技术实现多任务处理，完成对很多用户的并发请求处理。也就是我们开发的应用程序通常以一个进程的方式在操作系统中启动，然后在进程中创建很多线程，每个线程处理一个用户请求。</p><p>以Java的web开发为例，似乎我们编程的时候通常并不需要自己创建和启动线程，那么我们的程序是如何被多线程并发执行，同时处理多个用户请求的呢？实际中，启动多线程，为每个用户请求分配一个处理线程的工作是在web容器中完成的，比如常用的Tomcat容器。</p><p>如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/9a/d40cc1e9a2a5ce3913670743f0543b9a.png?wh=1168*808\" alt=\"\"><br>\nTomcat启动多个线程，为每个用户请求分配一个线程，调用和请求URL路径相对应的Servlet（或者Controller）代码，完成用户请求处理。而Tomcat则在JVM虚拟机进程中，JVM虚拟机则被操作系统当做一个独立进程管理。真正完成最终计算的，是CPU、内存等服务器硬件，操作系统将这些硬件进行分时（CPU）、分片（内存）管理，虚拟化成一个独享资源让JVM进程在其上运行。</p><p>以上就是一个Java web应用运行时的主要<strong>架构</strong>，有时也被称作<strong>架构过程视图</strong>。需要注意的是，这里有个很多web开发者容易忽略的事情，那就是<strong>不管你是否有意识，你开发的web程序都是被多线程执行的，web开发天然就是多线程开发</strong>。</p><p>CPU以线程为单位进行分时共享执行，可以想象代码被加载到内存空间后，有多个线程在这些代码上执行，这些线程从逻辑上看，是同时在运行的，每个线程有自己的线程栈，所有的线程栈都是完全隔离的，也就是每个方法的参数和方法内的局部变量都是隔离的，一个线程无法访问到其他线程的栈内数据。</p><p>但是当某些代码修改内存堆里的数据的时候，如果有多个线程在同时执行，就可能会出现同时修改数据的情况，比如，两个线程同时对一个堆中的数据执行+1操作，最终这个数据只会被加一次，这就是人们常说的<strong>线程安全</strong>问题，实际上线程的结果应该是依次加一，即最终的结果应该是+2。</p><p>多个线程访问共享资源的这段代码被称为<strong>临界区</strong>，解决线程安全问题的主要方法是使用锁，将临界区的代码加锁，只有获得锁的线程才能执行临界区代码，如下：</p><pre><code>lock.lock();  //线程获得锁\ni++;  //临界区代码，i位于堆中\nlock.unlock();  //线程释放锁\n</code></pre><p>如果当前线程执行到第一行，获得锁的代码的时候，锁已经被其他线程获取并没有释放，那么这个线程就会进入阻塞状态，等待前面释放锁的线程将自己唤醒重新获得锁。</p><p>锁会引起线程阻塞，如果有很多线程同时在运行，那么就会出现线程排队等待锁的情况，线程无法并行执行，系统响应速度就会变慢。此外I/O操作也会引起阻塞，对数据库连接的获取也可能会引起阻塞。目前典型的web应用都是基于RDBMS关系数据库的，web应用要想访问数据库，必须获得数据库连接，而受数据库资源限制，每个web应用能建立的数据库的连接是有限的，如果并发线程数超过了连接数，那么就会有部分线程无法获得连接而进入阻塞，等待其他线程释放连接后才能访问数据库，并发的线程数越多，等待连接的时间也越多，从web请求者角度看，响应时间变长，<strong>系统变慢</strong>。</p><p>被阻塞的线程越多，占据的系统资源也越多，这些被阻塞的线程既不能继续执行，也不能释放当前已经占据的资源，在系统中一边等待一边消耗资源，如果阻塞的线程数超过了某个系统资源的极限，就会导致系统宕机，<strong>应用崩溃</strong>。</p><p>解决系统因高并发而导致的响应变慢、应用崩溃的主要手段是使用<strong>分布式系统架构</strong>，用更多的服务器构成一个集群，以便共同处理用户的并发请求，保证每台服务器的并发负载不会太高。此外必要时还需要在请求入口处进行<strong>限流</strong>，减小系统的并发请求数；在应用内进行业务<strong>降级</strong>，减小线程的资源消耗。高并发系统架构方案将在专栏的第三模块中进一步探讨。</p><h2>小结</h2><p>事实上，现代CPU和操作系统的设计远比这篇文章讲的要复杂得多，但是基础原理大致就是如此。为了让程序能很好地被执行，软件开发的时候要考虑很多情况，为了让软件能更好地发挥效能，需要在部署上进行规划和架构。软件是如何运行的，应该是软件工程师和架构师的常识，在设计开发软件的时候，应该时刻以常识去审视自己的工作，保证软件开发在正确的方向上前进。</p><h2>思考题</h2><p>线程安全的临界区需要依靠锁，而锁的获取必须也要保证自己是线程安全的，也就是说，不能出现两个线程同时得到锁的情况，那么锁是如何保证自己是线程安全的呢？或者说，在操作系统以及CPU层面，锁是如何实现的？</p><p>你不妨思考一下这个问题，把你的思考写在下面的评论区里，我会和你一起交流。也欢迎你把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","comments":[{"had_liked":false,"id":152750,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1574074722,"is_pvip":false,"replies":[{"id":"58709","content":"👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574121098,"ip_address":"","comment_id":152750,"utype":1}],"discussion_count":5,"race_medal":0,"score":"418185902434","product_id":100040201,"comment_content":"在java里 锁是通过cas把当前线程id刷新到对象的头信息里 在获取锁时会去头信息里拿这个信息 如果没有 则会cas刷新进去 刷新成功就获取到锁 刷新失败就表明有别的线程也在尝试刷新这个信息 在操作系统层面 有pv操作保证原子性 而pv操作也是利用cpu中原语指令 在获取锁时保证不会被别的指令打断（或被重排序）","like_count":97,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474925,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574121098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","nickname":"有米","note":"","ucode":"C9A10B7A67BC12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295824,"discussion_content":" 在操作系统层面，锁本质就是一个文件，通过读写文件来处理获取锁和释放锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596356934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1590465,"avatar":"https://static001.geekbang.org/account/avatar/00/18/44/c1/ebe870bb.jpg","nickname":"李郝","note":"","ucode":"4818313D933CE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325108,"discussion_content":"说的都是核心点，厉害！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605237347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670147,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7c/03/2941dea7.jpg","nickname":"幸福来敲门","note":"","ucode":"A9CF2FDA8315A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53286,"discussion_content":"不明觉厉，还需真正理解，名词太多，头疼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574155534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019254,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/76/994a9929.jpg","nickname":"OlafOO","note":"","ucode":"105F8B194ED37B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52908,"discussion_content":"还是要说明下是偏向锁吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574091438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152763,"user_name":"Luciano李鑫","can_delete":false,"product_type":"c1","uid":1329995,"ip_address":"","ucode":"5FBE5F86FD5B2C","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","comment_is_top":false,"comment_ctime":1574076562,"is_pvip":false,"replies":[{"id":"58719","content":"这样开发出来的也就不会是一个可以满足高并发的web应用😁 也就不会有我们标题提出的问题~<br><br>这个专栏的大部分文章都试图在一篇较小的篇幅内讲完整一个较大的问题场景，这样就会有一些绝对化和理想化，后面的文章也会有类似的情况😢<br><br>这也真是我在开篇词想要表达的意图，我们在构建自己的知识体系时，不追求细节的完整和绝对的严谨，而是在大的方向上建起支撑性的知识支柱。细节的缺失和瑕疵在未来的学习和实践中完善。<br><br>当然也欢迎大家在评论中指出各种问题，有兴趣的同学参与讨论，我们在评论区就完成部分知识的深入和完善。<br><br>感谢🌹","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574121682,"ip_address":"","comment_id":152763,"utype":1}],"discussion_count":9,"race_medal":0,"score":"160487866514","product_id":100040201,"comment_content":"“不管你是否有意识，你开发的 web 程序都是被多线程执行的，web 开发天然就是多线程开发。”这个会不会绝对了一些，比如go或者c++开发的没有额外创建线程的web程序呢？","like_count":37,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474930,"discussion_content":"这样开发出来的也就不会是一个可以满足高并发的web应用😁 也就不会有我们标题提出的问题~\n\n这个专栏的大部分文章都试图在一篇较小的篇幅内讲完整一个较大的问题场景，这样就会有一些绝对化和理想化，后面的文章也会有类似的情况😢\n\n这也真是我在开篇词想要表达的意图，我们在构建自己的知识体系时，不追求细节的完整和绝对的严谨，而是在大的方向上建起支撑性的知识支柱。细节的缺失和瑕疵在未来的学习和实践中完善。\n\n当然也欢迎大家在评论中指出各种问题，有兴趣的同学参与讨论，我们在评论区就完成部分知识的深入和完善。\n\n感谢🌹","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574121682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041465,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e4/39/a06ade33.jpg","nickname":"极客雷","note":"","ucode":"0DBAC4CB9C7BCD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225670,"discussion_content":"你要明白作者技术经历造成的自身局限性，尽信书不如无书，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586391635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1500535,"avatar":"","nickname":"潘pan","note":"","ucode":"5C7A04F1F79210","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64272,"discussion_content":"go程也可以算作是用户态的线程，并发性也很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574943778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1044216,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ee/f8/bc5faaec.jpg","nickname":"熊猫","note":"","ucode":"1C22CFD1652D9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1500535,"avatar":"","nickname":"潘pan","note":"","ucode":"5C7A04F1F79210","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285686,"discussion_content":"用户态的背后也是多线程调度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592915323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":64272,"ip_address":""},"score":285686,"extra":""}]},{"author":{"id":1135631,"avatar":"https://static001.geekbang.org/account/avatar/00/11/54/0f/48ef6a7d.jpg","nickname":"路人","note":"","ucode":"02FC717E0A4FB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53636,"discussion_content":"主要还是redis操作的是内存，如果操作大key 或者文件磁盘数据时你看他高并发不高并发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574182325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53109,"discussion_content":"既然是web程序，那就不可避免会有多人同时访问，如果不能支持并发，体验就很难保证，那我觉得这个web程序是有缺陷的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574133184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1329995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","nickname":"Luciano李鑫","note":"","ucode":"5FBE5F86FD5B2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":53143,"discussion_content":"redis是单线程的 能说他不是高并发的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574138617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53109,"ip_address":""},"score":53143,"extra":""},{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1329995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","nickname":"Luciano李鑫","note":"","ucode":"5FBE5F86FD5B2C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53213,"discussion_content":"😄Redis单线程没错，虽然Redis性能非常高，但恐怕没几个人能开发出到Redis这个水平，而且单线程的特点也使得操作要非常小心，很容易造成阻塞，比如keys命令，大key的操作，不小心就会造成主从切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574145651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53143,"ip_address":""},"score":53213,"extra":""},{"author":{"id":1041465,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e4/39/a06ade33.jpg","nickname":"极客雷","note":"","ucode":"0DBAC4CB9C7BCD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":225671,"discussion_content":"大把","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586391666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53213,"ip_address":""},"score":225671,"extra":""}]}]},{"had_liked":false,"id":152821,"user_name":"Allen_","can_delete":false,"product_type":"c1","uid":1677187,"ip_address":"","ucode":"CA5E00E4644CD5","user_header":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","comment_is_top":false,"comment_ctime":1574083623,"is_pvip":false,"replies":[{"id":"58708","content":"清晰👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574120944,"ip_address":"","comment_id":152821,"utype":1}],"discussion_count":4,"race_medal":0,"score":"100358331431","product_id":100040201,"comment_content":"有些地方可能不是很到位，欢迎补充<br>小结：<br>1. 我们平时开发出来的程序是文本格式代码，但只是在硬盘中还只是一个程序，只有加载到内存里面通过cpu执行成为进程才是发挥了程序作用。<br>2.进程里面有堆，栈，可执行代码和进程数据结构。<br>3.cpu分时共享技术进行并发操作，进程切换效率不高，所以有了线程切换<br>4.因为线程安全问题引入锁，不过也引入了更多造成阻塞的可能<br>5.线程阻塞可能是I&#47;O,锁，网络请求，数据库链接获取<br>6利用分布式系统架构来减缓高并发的性能不佳","like_count":23,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474952,"discussion_content":"清晰👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574120944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1271724,"avatar":"https://static001.geekbang.org/account/avatar/00/13/67/ac/af895343.jpg","nickname":"刘耳总","note":"","ucode":"6D157E6E960075","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54955,"discussion_content":"就6条怎么理解？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574329232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1271724,"avatar":"https://static001.geekbang.org/account/avatar/00/13/67/ac/af895343.jpg","nickname":"刘耳总","note":"","ucode":"6D157E6E960075","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105937,"discussion_content":"自己根据这些再学习，凡事得靠自己","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577500562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54955,"ip_address":""},"score":105937,"extra":""}]},{"author":{"id":1748225,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ad/01/137b2bfe.jpg","nickname":"斌","note":"","ucode":"34E77F753B2783","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53041,"discussion_content":"能否详细说一说现代操作系统在进程切换和线程切换是，CPU执行的过程有哪些具体的异同点么？这对于理解线程在切换时比进程切换效率高的本原有帮助。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574126546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152824,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1574084016,"is_pvip":false,"replies":[{"id":"58707","content":"JVM是一个进程；tomcat是一个框架；tomcat会启动线程处理应用请求，执行应用的代码；应用自己不能跑起来的，只能被tomcat的线程执行，应用在tomcat线程中执行时，也可以自己启动线程，并发、异步执行自己的某些计算。<br><br>tomcat会对不同应用做一些隔离，但是如果某个应用导致JVM crash，所有应用都crash。<br><br>可参考后续专栏《JVM虚拟机原理》","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574120902,"ip_address":"","comment_id":152824,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61703626160","product_id":100040201,"comment_content":"李老师好：我想请教下，一个JVM 是一个进程。JVM 上跑 tomcat，tomcat 可以部署多个应用？那每个跑在tomcat 上的应用是一个线程吗？那一个应用crash了，其他应用也会crash.这块感觉有点问题。不知道老师方便解释下吗？","like_count":14,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474954,"discussion_content":"JVM是一个进程；tomcat是一个框架；tomcat会启动线程处理应用请求，执行应用的代码；应用自己不能跑起来的，只能被tomcat的线程执行，应用在tomcat线程中执行时，也可以自己启动线程，并发、异步执行自己的某些计算。\n\ntomcat会对不同应用做一些隔离，但是如果某个应用导致JVM crash，所有应用都crash。\n\n可参考后续专栏《JVM虚拟机原理》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574120902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1083504,"avatar":"https://static001.geekbang.org/account/avatar/00/10/88/70/32534e2d.jpg","nickname":"David Mo","note":"","ucode":"66C30A3CD7EDA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52905,"discussion_content":"tomcat是一个进程共享一个jvm，应用的话可能是一个线程也可能多个线程(取决于应用的架构和设计模式)，多个应用的线程受到操作系统或者tomcat内部的调度","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574091246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153633,"user_name":"我爱布丁","can_delete":false,"product_type":"c1","uid":1575522,"ip_address":"","ucode":"660B495D34CD39","user_header":"","comment_is_top":false,"comment_ctime":1574292059,"is_pvip":false,"replies":[{"id":"59038","content":"1 多个协程通过自我调度复用同一个线程，所以某个协程IO等待的时候，会导致整个线程阻塞，并不能避免线程切换。更好的做法是使用异步IO，不要IO等待。<br><br>能否抢到时间片是操作系统调度的，协程自己控制不了，但是协程利用自己更轻量级，配合异步IO等方法，可以提高运行效率，整体性能得到优化。<br><br>2 是的。但是用好协程，减少额外的线程调度切换，可以提高整体的系统吞吐能力。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574298938,"ip_address":"","comment_id":153633,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48818932315","product_id":100040201,"comment_content":"老师，看完文章，联想到两个关于协程的问题：<br><br>1. 使用协程在出现IO等待时，程序会自己调度去执行其他的(CPU)任务。理论上这样可以避免额外的IO等待导致的线程间切换。我的问题是从系统的角度上看，使用协程可以抢占到更多的CPU时间片吗？<br><br>2. 感觉系统崩溃（除人为Bug外) 主要是系统资源不足导致的。那么即使用轻量级的协程也不会变得更好。因为当协程数量过多，导致event loop过大，变慢，系统还是要崩溃的对吗？<br>","like_count":11,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475234,"discussion_content":"1 多个协程通过自我调度复用同一个线程，所以某个协程IO等待的时候，会导致整个线程阻塞，并不能避免线程切换。更好的做法是使用异步IO，不要IO等待。\n\n能否抢到时间片是操作系统调度的，协程自己控制不了，但是协程利用自己更轻量级，配合异步IO等方法，可以提高运行效率，整体性能得到优化。\n\n2 是的。但是用好协程，减少额外的线程调度切换，可以提高整体的系统吞吐能力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574298938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152921,"user_name":"雷咏","can_delete":false,"product_type":"c1","uid":1671448,"ip_address":"","ucode":"890DF9E928C99F","user_header":"https://static001.geekbang.org/account/avatar/00/19/81/18/f3642be3.jpg","comment_is_top":false,"comment_ctime":1574124706,"is_pvip":false,"replies":[{"id":"58730","content":"👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574128055,"ip_address":"","comment_id":152921,"utype":1}],"discussion_count":3,"race_medal":0,"score":"48818764962","product_id":100040201,"comment_content":"我们用文本格式书写的程序有三种执行方式:<br>1.解释执行。例子是脚本语言书写的程序或类似于BASIC语言书写的程序。著名的PYTHON也属于这种情况。<br>2.编译执行。通常C&#47;C++程序属于这种情况。文本格式书写的程序称之为源程序，需要编译器编译成机器语言代码，称之为可执行程序一或目标程序。<br>3.虚拟机执行。将文本格式的程序先编译成一种中间代码，然后由驻留在计算机中的虚拟机解释执行。例子是通常的JAVA程序。<br>","like_count":11,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474991,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574128055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296475,"discussion_content":"我的理解是，一个是运行时临时翻译，适合经常变化的程序（比如网页，比如python）。\n另外一个是先翻译好，存在磁盘上，运行时直接拿来跑，适合需要反复运行，不用频繁更新的程序代码。\n至于是不是虚拟机执行的，应该是另外一个话题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596551861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1675892,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/74/8e12c0e2.jpg","nickname":"改变来自点滴的积累","note":"","ucode":"1B271EB9C6AB2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66440,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575069874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153194,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1574178403,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"35933916771","product_id":100040201,"comment_content":"# 01 程序运行原理<br><br>## 程序是如何运行起来的？<br><br>- 1 、程序员被开发出来，文本格式代码，不能直接运行，需要编译器或者虚拟机先编译成机器码（也叫可执行代码），存储在文件系统中（即磁盘）。<br>- 2 、操作系统将编译好的代码加载到内存中。<br>- 3、CPU去执行，运行，程序运行起来被称作进程。<br><br>运行起来的程序，在运行期使用内存堆空间，栈空间，等数据结构。<br><br>![如图](https:&#47;&#47;static001.geekbang.org&#47;resource&#47;image&#47;89&#47;98&#47;89c6e3bbc44cdc042e7a8bcddb3b4398.png)<br><br><br><br>程序运行时需要创建数组等数据结构，这些由操作系统在进程中分配。<br><br>进程的堆，栈中分配相应的空间，比如堆，堆的地址又存在栈中。<br><br><br><br>栈：一种数据结构，遵循先进后出，后进先出的顺序。<br><br>比如函数<br><br>```<br>void f(){<br>int x = g(1); x++; &#47;&#47;g函数返回，当前堆栈顶部为f函数栈帧，在当前栈帧继续执行f函数的代码。<br>}<br>int g(int x){ <br>return x + 1;<br>}<br>```<br><br><br><br><br><br>每次函数调用，操作系统都会在栈中创建一个栈帧，方法程序（函数）通常被压栈进栈，函数中的变量，内存都在当前栈帧中，如下图。<br><br><br><br>![如图](https:&#47;&#47;static001.geekbang.org&#47;resource&#47;image&#47;f0&#47;f7&#47;f08d6fca893da5cac926a23f1f1aa7f7.png)<br><br><br><br><br><br>## 计算机如何同时处理数以百计的任务<br><br><br><br>通常情况下我们个人的PC 可能会是一核心或两核，现在基本都4核或者更高核cpu了<br><br>我们个人通常是用电脑会同时打开很多程序软件，听歌的，看电影的，下载视频等等几十个任务。<br><br>而服务器可以同时处理成千上百个任务以及并发请求而且一点儿都不卡顿（这里也存在服务器配置高的因素）<br><br>### 为什么电脑可以同时处理这么多的任务呢？<br><br>`这里主要依靠的是操作系统的 CPU 分时共享技术`<br><br>很多个进程在执行，操作系统会将 CPU 的执行时间分成很多份，进程按照某种策略轮流在 CPU 上运行<br><br>&gt; 每个进程都只被执行了很短一个时间，但是在外部看来却好像是所有的进程都在同时执行，每个进程似乎都独占一个 CPU 执行<br><br><br><br>为什么每个程序不单独使用进程呢？<br><br>原因是因为CPU每个进程在CPU上轮训使用，消耗资源以及时间很大！<br><br>通常我们在打开自己电脑时候开了很多软件（或者进程）后明显的感觉自己电脑变慢了，卡顿了。<br><br>一方面是因为自己电脑内存小，另一方面是因为进程数太多了，cpu切换需要花费时间。<br><br><br><br>那么如何解决进程多cpu切换代价大的情况呢？<br><br>计算机的先辈们引入了线程的概念，比如我们开发中容器tomcat 每次用户请求时候，tomcat分配给用户一个线程，在进程里可以启动很多的线程，线程可以理解为轻量级的进程，在进程内创建，拥有自己的线程栈，在 CPU 上进行线程切换的代价也更小。<br><br><br><br>线程在运行时，和进程一样，也有三种主要状态<br><br>运行：当一个进程在 CPU 上运行时，则称该进程处于运行状态。处于运行状态的进程的数目小于等于 CPU 的数目。<br><br>就绪：当一个进程获得了除 CPU 以外的一切所需资源，只要得到 CPU 即可运行，则称此进程处于就绪状态，就绪状态有时候也被称为等待运行状态。<br><br>阻塞：也称为等待或睡眠状态，当一个进程正在等待某一事件发生（例如等待 I&#47;O 完成，等待锁……）而暂时停止运行，这时即使把 CPU 分配给进程也无法运行，故称该进程处于阻塞状态。<br><br><br><br>## 系统为什么会变慢，为什么会崩溃<br><br><br><br>主要大致可以分为一下几个步骤原因<br><br>- 1、线程锁，引起线程阻塞，多线程情况下可能会存在线程排队等锁，县城无法并行执行导致速度变慢。<br>- 2、此外I&#47;O阻塞同理，比如数据库连接，并行数量超过数据库连接数量，线程就会出现阻塞<br>- 3、等待其他县城释放连接才能访问数据库，并发越大等待连接越多，响应时间越长，系统越慢。<br>- 4、被阻塞的线程越多，占据的系统资源也越多，这些被阻塞的线程既不能继续执行，也不能释放当前已经占据的资源，在系统中一边等待一边消耗资源，如果阻塞的线程数超过了某个系统资源的极限，就会导致系统宕机，应用崩溃。<br><br><br><br><br><br>如何解决<br><br>- 1、采用请求限流<br>- 2 、集群架构<br>- 3、分布式架构<br><br>","like_count":8,"discussions":[{"author":{"id":1125104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","nickname":"Citizen Z","note":"","ucode":"9CA547640A8629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53967,"discussion_content":"这个笔记不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574242746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1125104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","nickname":"Citizen Z","note":"","ucode":"9CA547640A8629","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55990,"discussion_content":"哈哈哈哈哈哈一起学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574420622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53967,"ip_address":""},"score":55990,"extra":""}]}]},{"had_liked":false,"id":152901,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1574120910,"is_pvip":false,"replies":[{"id":"58731","content":"也许可以将来以彩蛋的方式专门写一篇文章讲讲~","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574128139,"ip_address":"","comment_id":152901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27343924686","product_id":100040201,"comment_content":"希望老师在第二节课可以谈谈上一节课留下的思考题，您是怎么理解分析的","like_count":6,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474984,"discussion_content":"也许可以将来以彩蛋的方式专门写一篇文章讲讲~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574128139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158071,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575320502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23050156982","product_id":100040201,"comment_content":"磁盘上的代码就是一堆静态的二进制数据，运行之间和一张图片没有本质区别。当被执行的时候，代码就被加载到内存变成进程，原先的代码被转化成CPU可以操作的指令。一般的指令是从前往后的，也有些指令是根据条件跳转的，循环条件语句都是跳转指令。程序除了消耗CPU外，还要消耗内存。内存又分为栈和堆，栈处理函数运行的局部变量，新的函数调用，会有新的栈帧。堆处理局部变量以外的变量，例如Java new的对象，这些对象又会被栈中的变量引用，堆栈一起协同工作，堆容量大，负责存储。栈记录活动变量，引用堆中存储，后进先出。进程就是把指令集合，堆栈打包并建立边界的一个容器。CPU是全局宝贵资源，可以被多个进程共享，如果有多核的话，也可以同时运行多个进程，Python中的并发就是这么实现的。但是，每个进程都有自己的堆栈和其他活动资源，切换代价高昂。所以，多数编程语言都有线程的概念，线程是CPU调度的单位，同一进程下的线程之间共享堆和其他资源，切换成本大降，但是多个线程共享堆也会引发一系列并发的问题，通常需要锁来解决。另外一种平凡调用IO的情况，线程也不算太合适，因为IO和CPU本身并不竞争，通常IO比CPU慢10倍以上，所以很多语言引入了协程，在单线程的情况下实现并发，让IO和CPU资源得到充分利用，协程切换的成本比线程更低，也没有并行的问题，但也要注意协程只是在单线程下调度IO和CPU资源，对于并行计算并无帮助。<br>单个进程或者线程消耗太多资源会让系统变慢甚至崩溃，更多的情况是，等待中的进程线程数目太多，无法释放资源而让系统变慢甚至崩溃。这就好比交通系统，一辆坦克车横冲直撞造成问题毕竟少，多数问题还是车多到一定数目，前面的车过不去，后面的车进不来，虽然，每辆车都遵守交通法则，但是还是造成了拥堵。这个时候，正常的交通规则已经不管用了，需要其他治理拥堵的特殊措施来处理。","like_count":5},{"had_liked":false,"id":274439,"user_name":"程同学","can_delete":false,"product_type":"c1","uid":2418763,"ip_address":"","ucode":"622B71D5A2DA5E","user_header":"https://static001.geekbang.org/account/avatar/00/24/e8/4b/8ddf36b0.jpg","comment_is_top":false,"comment_ctime":1611022166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18790891350","product_id":100040201,"comment_content":"太棒了，醍醐灌顶，这操作系统和应用开发融会贯通，太棒了。<br><br>老师，遇见你是我的幸运。","like_count":4},{"had_liked":false,"id":154826,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1574575892,"is_pvip":true,"replies":[{"id":"59634","content":"tomcat是一个程序，被JVM加载到JVM进程中。<br><br>Tomcat的代码在JVM被执行后，可以启动很多线程。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574687944,"ip_address":"","comment_id":154826,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18754445076","product_id":100040201,"comment_content":"一直以为tomcat是一个独立的进程。根据本文所述，tomcat只是一个线程，是虚拟机进程中的一个线程。是这样吗？","like_count":4,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475590,"discussion_content":"tomcat是一个程序，被JVM加载到JVM进程中。\n\nTomcat的代码在JVM被执行后，可以启动很多线程。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574687944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153496,"user_name":"Heidi","can_delete":false,"product_type":"c1","uid":1642586,"ip_address":"","ucode":"2751FD284068AA","user_header":"https://static001.geekbang.org/account/avatar/00/19/10/5a/3411221e.jpg","comment_is_top":false,"comment_ctime":1574247088,"is_pvip":true,"replies":[{"id":"59006","content":"思考问题从问题的根源出发思考，如果在解决问题的时候现场比较乱，无法做到。事后做复盘，复盘的时候重新从根源思考。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574292277,"ip_address":"","comment_id":153496,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18754116272","product_id":100040201,"comment_content":"你好，想提个问题。文章中大部分知识点都掌握，但是遇到问题的时候没有从这些角度出发，只是跟着一些关联去分析问题，对遇到的问题反应比较慢。这种情况是不是知识没有成体系？那么怎样建立比较完整的知识体系呢？","like_count":4,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475188,"discussion_content":"思考问题从问题的根源出发思考，如果在解决问题的时候现场比较乱，无法做到。事后做复盘，复盘的时候重新从根源思考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574292277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1328689,"avatar":"https://static001.geekbang.org/account/avatar/00/14/46/31/cb061c09.jpg","nickname":"陈小龙 Cheney","note":"","ucode":"4B721FE4DDB2F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77965,"discussion_content":"我想老师的意思是说, 遇到问题从底层, 基本的角度出发, 先在脑子过一下这些问题:\n一个程序是如何运行的? 无非就是硬盘, 内存, CPU\n程序为什么变慢了? 阻塞, 那是为什么阻塞了? 等待锁, 等待数据库连接, 等待硬盘IO等.\n这就是从基本, 从第一性出发!","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575961916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194395,"avatar":"https://static001.geekbang.org/account/avatar/00/12/39/9b/fc21f943.jpg","nickname":"睡浴缸的人","note":"","ucode":"AAA7476707D82F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132346,"discussion_content":"我也一样o(╥﹏╥)o","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578899750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153387,"user_name":"Tobe24","can_delete":false,"product_type":"c1","uid":1070912,"ip_address":"","ucode":"D1DAEF00A41437","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/40/6dcefbd5.jpg","comment_is_top":false,"comment_ctime":1574228526,"is_pvip":false,"replies":[{"id":"58974","content":"1 取决于CPU的核数<br>2 线程比进程占据的资源少，切换代价小，而且进程内线程可能执行相同的代码，切换线程后也许还可以复用CPU cache数据<br>3 线程切换和进程切换只依赖CPU是否空闲，和线程进程彼此没关系<br><br>PS，上面回复内容其实我也没有确切的资料证实，我是根据第一性原理推导出来的，我觉得仅根据专栏文章内容就可以推导出来，我希望你也可以自己分析推导，这样获得的知识会更加稳固","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574235189,"ip_address":"","comment_id":153387,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18754097710","product_id":100040201,"comment_content":"您好，老师，这节课太适合我这种新手了，这里有三个不太明白的地方，希望老师能够解惑。<br>问题1：CPU 分时共享技术同时执行进程的数量，取决于什么？<br>问题2：为什么线程切换的代价更小？<br>问题3：进程切换是不是必须要等到线程切换完毕后进行？如果不是，优先级是由什么决定的？<br>一点小建议：<br>有一些表达程度的词，如果能用数据举例简单说明一下，对于我们理解会更有帮助。比如2问题中，代价更小，小到什么程度，是进程切换速度的几倍?<br>思考题：<br>作为小白，我的思路是这样，锁是在线程的临界区，线程是在进程的线程栈，而 一个 cpu 同时只能运行一个进程，所以本质上都是轮流执行的……于是，只要保证在获取锁的时候，锁不在正在获取或已经被获取的状态即可，进而推断线程中会有一片内存区域用来存这些状态信息。<br>😂不知道这个思路对不对。<br>最后谢谢老师。","like_count":4,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475145,"discussion_content":"1 取决于CPU的核数\n2 线程比进程占据的资源少，切换代价小，而且进程内线程可能执行相同的代码，切换线程后也许还可以复用CPU cache数据\n3 线程切换和进程切换只依赖CPU是否空闲，和线程进程彼此没关系\n\nPS，上面回复内容其实我也没有确切的资料证实，我是根据第一性原理推导出来的，我觉得仅根据专栏文章内容就可以推导出来，我希望你也可以自己分析推导，这样获得的知识会更加稳固","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574235189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296484,"discussion_content":"复用cpu cache。不重复创建堆空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596552862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258359,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/77/0c593044.jpg","nickname":"碧雪天虹","note":"","ucode":"313CC048C7E341","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289803,"discussion_content":"进程是内存的隔离单位, 线程是CPU的调度单位, 可以简单理解第2个问题. 创建新进程不仅要创建主线程, 还要额外初始化一大块内存区域, 所以开销大很多.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594214690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152749,"user_name":"夜里饿煮面","can_delete":false,"product_type":"c1","uid":1201035,"ip_address":"","ucode":"21853FBC18FB78","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/8b/cf442e81.jpg","comment_is_top":false,"comment_ctime":1574074677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18753943861","product_id":100040201,"comment_content":"操作系统中PV原语是最小的原子，就是不知道硬件上是怎么实现的","like_count":4},{"had_liked":false,"id":172787,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1318915,"ip_address":"","ucode":"4907A3750CEAD6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo2SjCeylLv0P3Glle5277kA4b8cAuxr1NrC0njPKEqzSpB8IEicHB29GicFFwG1qiaxs4hxRiaBmoibVw/132","comment_is_top":false,"comment_ctime":1579312154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10169246746","product_id":100040201,"comment_content":"扩容，限流，降级。从无损到有损的解决高并发问题的手段","like_count":2},{"had_liked":false,"id":153492,"user_name":"Citizen Z","can_delete":false,"product_type":"c1","uid":1125104,"ip_address":"","ucode":"9CA547640A8629","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","comment_is_top":false,"comment_ctime":1574246346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164180938","product_id":100040201,"comment_content":"粗略思考：<br>1. 锁在内存中只有 1 份数据（JVM 用堆区中对象的 header 来实现，所以是每个线程都可见的），有开&#47;关两个状态<br>2. 不同线程访问锁时一定是有先后顺序的（JMM 的 happens-before 原则有规定，这个可能涉及较多手段来保证，问题难点主要出现在多核 CPU 和 CPU cache 的情况下）<br>3. 如果线程遇到打开状态的锁，就“获取并关闭“锁（这里的原子性由 CPU 指令保证，就是 cas 机制）<br><br>更复杂的锁优化策略都在这个基础上实现","like_count":2},{"had_liked":false,"id":279389,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1613746355,"is_pvip":false,"replies":[{"id":"101700","content":"包括内存，以及线程自身等等","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1614043008,"ip_address":"","comment_id":279389,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5908713651","product_id":100040201,"comment_content":"“被阻塞的线程越多，占据的系统资源也越多，这些被阻塞的线程既不能继续执行，也不能释放当前已经占据的资源”被阻塞的线程并不消耗cpu（或者说时间片）对吧？占据的资源是IO类的，比如文件描述符或者IP port之类的吗？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515718,"discussion_content":"包括内存，以及线程自身等等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614043008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","nickname":"布拉姆","note":"","ucode":"479FF27D73BCAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351142,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614164651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158594,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575421321,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5870388617","product_id":100040201,"comment_content":"请问老师，内存中的堆区域和数据结构中的最大堆最小堆，两者都叫做堆，两者有没有关系？","like_count":1,"discussions":[{"author":{"id":2119325,"avatar":"https://static001.geekbang.org/account/avatar/00/20/56/9d/4b2a7d29.jpg","nickname":"ryanxw","note":"","ucode":"0B91EAC8D06EED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549596,"discussion_content":"没有关系，不是一个内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644117582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296486,"discussion_content":"我觉得貌似没啥关系。计算机术语常常就是那么烂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596552917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158072,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575320643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870287939","product_id":100040201,"comment_content":"思考题<br>锁要全局共享但只有一处可得，应该有特殊的CPU指令来处理吧。","like_count":1},{"had_liked":false,"id":152849,"user_name":"VenFox","can_delete":false,"product_type":"c1","uid":1002112,"ip_address":"","ucode":"11F08AD5685505","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/80/b1862ca3.jpg","comment_is_top":false,"comment_ctime":1574089118,"is_pvip":true,"replies":[{"id":"58706","content":"C和C++的执行代码直接交给操作系统调度管理，Java和Go的执行代码在JVM和Go的虚拟机环境中运行，不仅仅是垃圾回收，Java和Go的虚拟机职责也不一样。详情可参考后续专栏《JVM虚拟机原理》。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574120344,"ip_address":"","comment_id":152849,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869056414","product_id":100040201,"comment_content":"老师，别人常说java和go等是带有运行时的语言，难道c和cpp没有吗？运行时是指垃圾回收这些功能吗？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474962,"discussion_content":"C和C++的执行代码直接交给操作系统调度管理，Java和Go的执行代码在JVM和Go的虚拟机环境中运行，不仅仅是垃圾回收，Java和Go的虚拟机职责也不一样。详情可参考后续专栏《JVM虚拟机原理》。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574120344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016571,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/fb/9d232a7a.jpg","nickname":"Pana","note":"","ucode":"6E016D4966B187","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218887,"discussion_content":"Go 是没有虚拟机的，但的确有运行时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585711324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360541,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"广东","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1666620584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666620584","product_id":100040201,"comment_content":"锁的线程安全：语言中通常使用cas，而cas有同步原语来保证各个cpu间的可见性。在操作系统中通常使用pv操作，该操作也是系统支持的原语。","like_count":0},{"had_liked":false,"id":335009,"user_name":"FelixFly","can_delete":false,"product_type":"c1","uid":1160461,"ip_address":"","ucode":"1D39A7C3D0E31F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg","comment_is_top":false,"comment_ctime":1645254723,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645254723","product_id":100040201,"comment_content":"锁如何实现的？<br>1. 必须要存在共享变量，CAS操作<br>2. 需要存储阻塞线程的队列，每次唤醒一个<br>3. 是否可以抢占(公平锁和非公平锁)","like_count":0},{"had_liked":false,"id":288941,"user_name":"书策稠浊","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1618794932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618794932","product_id":100040201,"comment_content":"CPU 以线程为单位进行分时共享执行，这句不是太理解。操作系统调度进程，Jvm调度线程，所以cpu以线程为单位执行吗？那其他非jvm的进程呢，他一定有线程吗","like_count":0},{"had_liked":false,"id":281465,"user_name":"曹翔","can_delete":false,"product_type":"c1","uid":1114878,"ip_address":"","ucode":"B4D8B42DFB535C","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/fe/d539b96b.jpg","comment_is_top":false,"comment_ctime":1614757578,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614757578","product_id":100040201,"comment_content":"语言层面的锁归根到底是使用了操作系统提供的锁机制，PV操作，而操作系统支持是硬件CPU提供了支持","like_count":0},{"had_liked":false,"id":273286,"user_name":"Rainbow福才","can_delete":false,"product_type":"c1","uid":1033440,"ip_address":"","ucode":"DA5843516F4930","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/e0/eb9f6b80.jpg","comment_is_top":false,"comment_ctime":1610524692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610524692","product_id":100040201,"comment_content":"本文小结：<br>1. 程序是如何运行起来的：<br>程序从外部设备加载到内存中，并在操作系统的管理调度下交给CPU执行，运行起来的程序称作为进程。<br><br>2. 进程包括：可执行程序代码、内存堆空间、栈空间、进程数据结构<br><br>3. 为什么系统会变慢，甚至崩溃？<br>--高并发请求、程序中针对共享资源使用锁，数据库连接数过多都会导致程序变慢。<br><br>4. 如何应对系统变慢、崩溃？<br>--对应系统变慢，应用崩溃的手段主要是使用分布式系统架构，使用更多服务器构成一个集群，共同处理用户的并发请求。<br>此外必要时还可以在请求入口进行限流，减少系统的并发请求数。在应用内部进行业务降级，极少线程的资源消耗。","like_count":0},{"had_liked":false,"id":264490,"user_name":"meijing0114","can_delete":false,"product_type":"c1","uid":1012416,"ip_address":"","ucode":"B349D33E2F3ECC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/c0/b09911a0.jpg","comment_is_top":false,"comment_ctime":1606478161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606478161","product_id":100040201,"comment_content":"Web应用或者说后端应用，应该说是软件中比较简单的一类，每次请求独立，主要进行外部存储或IO调用。但因为在互联网应用的广泛性，现在在可靠性、可扩展性、服务柔性等各方面要求越来越高。","like_count":0},{"had_liked":false,"id":264383,"user_name":"舀点米 | Titus Mi","can_delete":false,"product_type":"c1","uid":1105289,"ip_address":"","ucode":"43F5460C4501D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/89/4fda09bd.jpg","comment_is_top":false,"comment_ctime":1606452257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606452257","product_id":100040201,"comment_content":"因为CPU 以线程为单位进行分时共享执行…当又🔒后，CPU会优先执行有锁的线程，等这个带锁的线程执行完后，才分时给那些没有锁的线程执行。","like_count":0},{"had_liked":false,"id":261191,"user_name":"李郝","can_delete":false,"product_type":"c1","uid":1590465,"ip_address":"","ucode":"4818313D933CE6","user_header":"https://static001.geekbang.org/account/avatar/00/18/44/c1/ebe870bb.jpg","comment_is_top":false,"comment_ctime":1605237284,"is_pvip":false,"replies":[{"id":"94950","content":"������","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1605492366,"ip_address":"","comment_id":261191,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605237284","product_id":100040201,"comment_content":"很多年前看过智慧老师的那本大型网络技术架构，大致读了两遍，每次都获益匪浅，确实因为个人水平不足，很需要智慧老师这种能帮我将很多杂乱的知识言简意赅的融会贯通起来，让我对于未来遇到的问题可以更自信的去解决。同时，通过这些文章，也让我学会了如何提高自己学习的效率，以及如何去训练自己以达到目标等等，非常感谢！","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509412,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605492366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258224,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1604329268,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604329268","product_id":100040201,"comment_content":"之前翻过 intel 的开发人员手册, 里面提到了 cpu 层面的锁, 现代的 intel cpu 用的是一种 LOCK 的信号, 通过 MESIF 协议锁定缓存行来达到 确保该处理器能够独占使用共享内存 的目的<br>有兴趣可以读读之前我写的博客  <br>https:&#47;&#47;giraffetree.me&#47;2020&#47;07&#47;28&#47;volatile-LOCK-MESIF&#47;","like_count":0},{"had_liked":false,"id":248681,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1600260677,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1600260677","product_id":100040201,"comment_content":"这一篇专栏更像是与程序运行有关的操作系统概述，有一本日文翻译过来的书《程序是怎么跑起来的》。<br><br>系统变慢除了线程阻塞之外，也有可能是因为内存泄漏。<br><br>看了留言，并且结合之前的一些知识，大概知道在操作系统层面是通过 PV 原语实现的，在 Java 里面是通过 CAS 实现，不过具体的实现细节还需要再学习一下。","like_count":0},{"had_liked":false,"id":247142,"user_name":"志江","can_delete":false,"product_type":"c1","uid":2088626,"ip_address":"","ucode":"8A07D53769B3C3","user_header":"","comment_is_top":false,"comment_ctime":1599617353,"is_pvip":false,"replies":[{"id":"90803","content":"对，答疑篇有解释","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1599645185,"ip_address":"","comment_id":247142,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599617353","product_id":100040201,"comment_content":"李老师,<br>我理解tomcat就是一个jvm进程吧, tomcat启动的时候实际上是启动一个jvm进程(包含)tomcat字节码文件)<br>这么理解对么","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505325,"discussion_content":"对，答疑篇有解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599645185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241754,"user_name":"极客时间工程师","can_delete":false,"product_type":"c1","uid":1027953,"ip_address":"","ucode":"4453C22C440E50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/71/80dc0c53.jpg","comment_is_top":false,"comment_ctime":1597411582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597411582","product_id":100040201,"comment_content":"学习了","like_count":0},{"had_liked":false,"id":233210,"user_name":"着迷","can_delete":false,"product_type":"c1","uid":1716801,"ip_address":"","ucode":"429F1D4015A195","user_header":"https://static001.geekbang.org/account/avatar/00/1a/32/41/c1a7840b.jpg","comment_is_top":false,"comment_ctime":1594261353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594261353","product_id":100040201,"comment_content":"1.程序如何运行起来的？<br><br>我们编写的代码都是静态的，存放在磁盘上，当运行可执行文件时，操作系统会创建一个进程，为其分配堆栈、寄存器等资源，通过进程控制块方式管理进程，当进程达到运行条件时，操作系统将按照某种策略（如轮询时间片，先来先得，最短执行时间，优先级）为进程分配cpu时间片。<br><br>2.操作系统如何运行多个任务？<br>操作系统主要通过调度系统使用某种策略进行调度任务，保证每个任务都会获得cpu时间片。任务调度会存在线程上下文切换操作，当线程过多时，会带来较大的性能开销。<br><br>3.系统为什么会变慢,甚至崩溃？如何解决？<br>当系统多个线程因为等待资源（io、锁、网络连接）无法继续执行时，加上线程切换，系统会变慢，同时无法释放资源，当访问用户过多时，系统使用资源受限，会导致宕机。<br>可通过分布式架构，对服务器集群负载均衡、限流、尽可能缩小锁范围、引入缓存、读写分离等方式解决。<br>","like_count":0},{"had_liked":false,"id":225092,"user_name":"无涯","can_delete":false,"product_type":"c1","uid":1010253,"ip_address":"","ucode":"B9613B29B1677B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/4d/47e984c6.jpg","comment_is_top":false,"comment_ctime":1591640665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591640665","product_id":100040201,"comment_content":"1.进程可以理解为程序执行资源分配的分配的基本单元，真正的执行单元是进程中的线程。<br>2.多线程之所以支持高并发是因为程序执行过程中线程的切换资源消耗比较低。<br>3.为了保证多线程同时安全访问临界区的数据，通常会使用锁机制。为了防止死锁通常会给锁加一个超时时间，线程处理超时，自动解锁。或者允许资源抢占。（不知道这么说对不对）<br>4.采用分布式架构可以缓解单机流量的压力，但同时也个系统设计增加了难度。","like_count":0},{"had_liked":false,"id":196588,"user_name":"李英朋","can_delete":false,"product_type":"c1","uid":1904393,"ip_address":"","ucode":"D59D374C0E2CEC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/KZEI3yuCfgfuPcxfY9u02dL9LQSaIliaEMCb9icVgfSwqrWIib59868VyUibxxhrFR9friaemb7FEjvOLr5A8oYzuicg/132","comment_is_top":false,"comment_ctime":1585295303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585295303","product_id":100040201,"comment_content":"<br>1. 我们平时开发出来的程序是文本格式代码，但只是在硬盘中还只是一个程序，只有加载到内存里面通过cpu执行成为进程才是发挥了程序作用。<br>2.进程里面有堆，栈，可执行代码和进程数据结构。<br>3.cpu分时共享技术进行并发操作，进程切换效率不高，所以有了线程切换<br>4.因为线程安全问题引入锁，不过也引入了更多造成阻塞的可能<br>5.线程阻塞可能是I&#47;O,锁，网络请求，数据库链接获取<br>6利用分布式系统架构来减缓高并发的性能不佳","like_count":0},{"had_liked":false,"id":196484,"user_name":"非同凡想","can_delete":false,"product_type":"c1","uid":1934969,"ip_address":"","ucode":"713FD449A49D5A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/86/79/066a062a.jpg","comment_is_top":false,"comment_ctime":1585285107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585285107","product_id":100040201,"comment_content":"CPU指令层的cas","like_count":0},{"had_liked":false,"id":175302,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1580649231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580649231","product_id":100040201,"comment_content":"思考题：<br>按第一性原理，得有一个仲裁者来决定锁是否已被占据，而仲裁者本身不需要锁。据此原理，现代计算机是通过提供硬件原语指令(如cas)来充当仲裁者，以决定锁是否可以获取(cas成功或失败)。","like_count":0},{"had_liked":false,"id":171254,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1578886860,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578886860","product_id":100040201,"comment_content":"web容器有线程池，数据库JDBC连接也有个线程池。如果web容器访问的线程超过数据库线程池内线程的数量，那么就会导致线程阻塞。这些阻塞的线程等于尸位素餐，他们占用的资源无法释放被回收，这样就会导致资源的浪费，高并发请求时有可能就会导致系统奔溃。<br>多线程访问资源的时候面临的问题有三种：CPU缓存带来的可见性问题、线程切换带来的原子性问题、编译优化带来的顺序性（CPU指令顺序）问题","like_count":0},{"had_liked":false,"id":171238,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1578885389,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578885389","product_id":100040201,"comment_content":"IO操作是程序驱动完成的，不需要占用CPU。所以IO操作的时候，该线程会让出CPU时间片，转而执行其他线程的指令。","like_count":0},{"had_liked":false,"id":161792,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1576330265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576330265","product_id":100040201,"comment_content":"服务器的概念是什么，容器的概念是什么，虚拟机跟物理机的区别是什么？","like_count":0},{"had_liked":false,"id":161163,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1576134716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576134716","product_id":100040201,"comment_content":"回答思考题：<br>1.操作系统中实现的信号量、Mutex、管程等锁编程模型通过pv原子操作实现获取锁与释放锁的原子操作<br>2.扩展一下，在硬件层面，大名鼎鼎的“test and set”指令就是做这个事情的，该指令将读取内存、判断和设置值作为一个原子操作。在单核环境中，锁的操作肯定是原子性的; 在多核环境中，两个核上的代码同时申请一个锁，两个核同时读取锁变量，同时判断锁是空闲的，再各自修改锁变量为上锁状态，都返回成功，这样两个核同时获取到了锁， 这种情况可能吗？ 不可能，硬件提供了锁内存总线的机制，在锁内存总线的状态下执行“test and set”操作就可以保证一个只有一个核执行成功，也就保证了不会存在多线程获取到锁的情况。","like_count":0},{"had_liked":false,"id":157620,"user_name":"vega","can_delete":false,"product_type":"c1","uid":1748242,"ip_address":"","ucode":"5872FDA0974091","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJPNsfvnqsB8eTbKgzwIOhcKkzCTUSoAyujl8MtiazpP07zUfboOaWJaZK2jfRVH6S2ibXEc7WIibufA/132","comment_is_top":false,"comment_ctime":1575213658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575213658","product_id":100040201,"comment_content":"为何我总觉得这里的说法都比较针对Java，如果放在计算机操作系统这门课来说是不是会显得不严谨？","like_count":0},{"had_liked":false,"id":156871,"user_name":"樂文💤","can_delete":false,"product_type":"c1","uid":1073694,"ip_address":"","ucode":"CE4A46397521FC","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/1e/8054e6db.jpg","comment_is_top":false,"comment_ctime":1574990435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574990435","product_id":100040201,"comment_content":"操作系统层面应该是通过CPU 同步原语实现的 有原子性","like_count":0},{"had_liked":false,"id":156845,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1574987965,"is_pvip":false,"replies":[{"id":"60205","content":"堆栈是属于线程的堆栈，所以要看函数被哪个线程执行，具体要看编程语言和执行环境。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574998188,"ip_address":"","comment_id":156845,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574987965","product_id":100040201,"comment_content":"老师，您好，闭包函数的执行栈帧如何描述？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476253,"discussion_content":"堆栈是属于线程的堆栈，所以要看函数被哪个线程执行，具体要看编程语言和执行环境。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574998188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153846,"user_name":"小烽","can_delete":false,"product_type":"c1","uid":1114972,"ip_address":"","ucode":"E40BB9B46FB347","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq36dSapVA92lPpicBALBsecgwN1uIJQUfqwa6eTz2BuibebH11W4DAmeJeV5aedBY2KIcKLMTIl67A/132","comment_is_top":false,"comment_ctime":1574317234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574317234","product_id":100040201,"comment_content":"Java 中，锁的状态存在对象头中，包括线程id 等，因为是在堆中，是共享变量，所以所有的线程都能获取到，并通过cas判断是否能拿到锁。换成其他需要应该也是如此，在共享变量中存储锁相关的信息即可。但要具体实现还是有些困难<br><br>李老师，您好。我是非计算机专业的，在从事java 开发，听了课程，感觉收获很大，但是很多概念有些模糊，像操作系统基本不了解，在性能调优时也发现了必须懂底层原理，才能走的更远和更有竞争力，请问题老师，这底层原理，像操作系统需要怎么去学呢。","like_count":0},{"had_liked":false,"id":153295,"user_name":"stephen","can_delete":false,"product_type":"c1","uid":1313562,"ip_address":"","ucode":"68BEAF653814E7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/eyzvWHuvEwziby6ZsvRhF0l174d3jFZ4gRjOrUzX6uVRP2DLiaAnBVLzaia8ayaPRIhHYnnOusd2XB6wYDAscGIMA/132","comment_is_top":false,"comment_ctime":1574212137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574212137","product_id":100040201,"comment_content":"在系统层面分为两种锁:自旋锁（spinlock）这种锁是占用CPU直到获取锁，通常底层采用一个while循环获取来更改一个状态，更改的方式采用的是cas原语，底层CPU指令为rdtsc，这个操作不可中断，语义为，比较并交换，比较两者的值相等就交换目标值为指定值。还有一种锁，这种锁并不会占用CPU，而是在未获取锁之前等待，这个等待将让出CPU，供其他程序使用。而jvm中的线程模型和系统不同，锁的内部情况个人认为基本上是模拟系统的方式，需要进一步的查阅资料进行论证。","like_count":0},{"had_liked":false,"id":153247,"user_name":"超群","can_delete":false,"product_type":"c1","uid":1023959,"ip_address":"","ucode":"365D7F3A3BD73E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/d7/18ee8352.jpg","comment_is_top":false,"comment_ctime":1574207965,"is_pvip":true,"replies":[{"id":"58850","content":"专栏后面还有一些文章讨论高并发，包括反应式编程，分布式架构等等，欢迎继续关注~","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574210698,"ip_address":"","comment_id":153247,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574207965","product_id":100040201,"comment_content":"李老师可以写一篇细说并发的文章吗？现在有很多写高并发的书或者文章，但是几乎没有人写过并发是什么。对于并发总感觉一种雾里看花的感觉，有点清楚但是又不是很清楚。希望李老师考虑一下，谢谢","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475091,"discussion_content":"专栏后面还有一些文章讨论高并发，包括反应式编程，分布式架构等等，欢迎继续关注~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574210698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153175,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1574174728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574174728","product_id":100040201,"comment_content":"空间换时间，时间换空间。","like_count":0},{"had_liked":false,"id":153169,"user_name":"Asura","can_delete":false,"product_type":"c1","uid":1259901,"ip_address":"","ucode":"985499F24FB49A","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/7d/cafbd583.jpg","comment_is_top":false,"comment_ctime":1574173576,"is_pvip":false,"replies":[{"id":"58854","content":"🌹","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574210960,"ip_address":"","comment_id":153169,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574173576","product_id":100040201,"comment_content":"老师赶紧更新，无限期待中😄","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475070,"discussion_content":"🌹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574210960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153055,"user_name":"马超","can_delete":false,"product_type":"c1","uid":1254552,"ip_address":"","ucode":"38E328A993F9CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/98/24cb8ca0.jpg","comment_is_top":false,"comment_ctime":1574149601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574149601","product_id":100040201,"comment_content":"个人理解，欢迎指正<br>1.对地址总线加锁，粒度大，只有一个线程能访问内存，其他线程都会阻塞<br>2.对一块内存加锁，粒度小<br>但是感觉很模糊，因为对cpu和内存的底层硬件电路不懂<br>","like_count":0},{"had_liked":false,"id":152986,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1574134031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574134031","product_id":100040201,"comment_content":"听着还不错，希望继续试听后边的决定是否购入","like_count":0},{"had_liked":false,"id":152950,"user_name":"木风","can_delete":false,"product_type":"c1","uid":1339677,"ip_address":"","ucode":"3BAA80C2F1FB68","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/1d/8d1d27b2.jpg","comment_is_top":false,"comment_ctime":1574128698,"is_pvip":false,"replies":[{"id":"58800","content":"线程和进程都是动态的，被操作系统调度、执行的时候才存在，代码、数据这些静态的东西都不是线程。。。<br><br>线程和线程之间交换数据可以通过共享变量，这就是临界区和锁的由来。。。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574142005,"ip_address":"","comment_id":152950,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1574128698","product_id":100040201,"comment_content":"李老师，请问对于多个用户请求的线程，可否建立一个共享数据池。线程不直接访问数据库而是从数据池来“拿”数据？如何可以的话，共享数据池本身应该也是一个线程吧，哪请问一个线程怎么从另一个线程里获取数据？ 谢谢","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474998,"discussion_content":"线程和进程都是动态的，被操作系统调度、执行的时候才存在，代码、数据这些静态的东西都不是线程。。。\n\n线程和线程之间交换数据可以通过共享变量，这就是临界区和锁的由来。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574142005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206787,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/03/cb597311.jpg","nickname":"远心","note":"","ucode":"1157202C315655","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53809,"discussion_content":"介位童鞋，操作系统创建进程的时候，会创建相应的堆空间和栈空间。栈空间的数据是线程隔离的，而对于堆空间的数据，各个线程可以通过引用的方式进行修改，也就是说，在一定程度上，堆空间可以看作共享变量所在的空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574220032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1339677,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/1d/8d1d27b2.jpg","nickname":"木风","note":"","ucode":"3BAA80C2F1FB68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1206787,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/03/cb597311.jpg","nickname":"远心","note":"","ucode":"1157202C315655","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54164,"discussion_content":"谢谢童鞋的正解。再读一次后，也发现堆，是共享数据区。锁🔒的功能就是为了避免线程同时操作堆的数据。回到程序层面，是静态类放在堆里？函数内new的类，放在栈内？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574263367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53809,"ip_address":""},"score":54164,"extra":""},{"author":{"id":1206787,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/03/cb597311.jpg","nickname":"远心","note":"","ucode":"1157202C315655","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339677,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/1d/8d1d27b2.jpg","nickname":"木风","note":"","ucode":"3BAA80C2F1FB68","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54460,"discussion_content":"后面的两个问题就要去看看 JVM 的内存模型了，我的理解是 new 的对象放在堆，静态类应该放在方法区。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574300104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54164,"ip_address":""},"score":54460,"extra":""}]}]},{"had_liked":false,"id":152859,"user_name":"Archer-上源-嘿喵","can_delete":false,"product_type":"c1","uid":1090693,"ip_address":"","ucode":"9B2394B2660B10","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/85/6e018a8c.jpg","comment_is_top":false,"comment_ctime":1574090729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574090729","product_id":100040201,"comment_content":"在设计上，我们可以为每个线程生成一个二元组(线程ID ，程序ID)储存在在临界的缓存或者内存中，当一个程序需要修改临界区域的数据时，首先匹配程序ID如果程序ID相符则可以修改，如果程序ID不符则无法修改。如果程序ID为空，则可以修改该程序ID字段为自身ID。如过多线程也是如此，匹配线程ID。","like_count":0},{"had_liked":false,"id":152855,"user_name":"宇宙超人","can_delete":false,"product_type":"c1","uid":1073894,"ip_address":"","ucode":"28EBA3B0C136C2","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/e6/163eb9f8.jpg","comment_is_top":false,"comment_ctime":1574089617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574089617","product_id":100040201,"comment_content":"创建一个队列 里面管理锁的变量a为0<br><br>加锁 任务成为阻塞态去等待队列<br>          通过软中断之类机制引发cpu调度<br>cpu判断队列中a是否为0<br>     如果是0 使得变量为1<br>     发送队列 让之前阻塞的任务成为就绪 然后等到cpu调度时执行<br><br>不是0继续等待阻塞<br><br>释放锁<br>使得队列变量a为0<br><br><br><br>","like_count":0}]}