{"id":117272,"title":"10 | 如何使用异步设计提升系统性能？","content":"<p>你好，我是李玥，这一讲我们来聊一聊异步。</p><p>对于开发者来说，异步是一种程序设计的思想，使用异步模式设计的程序可以显著减少线程等待，从而在高吞吐量的场景中，极大提升系统的整体性能，显著降低时延。</p><p>因此，像消息队列这种需要超高吞吐量和超低时延的中间件系统，在其核心流程中，一定会大量采用异步的设计思想。</p><p>接下来，我们一起来通过一个非常简单的例子学习一下，使用异步设计是如何提升系统性能的。</p><h2>异步设计如何提升系统性能？</h2><p>假设我们要实现一个转账的微服务Transfer( accountFrom, accountTo, amount)，这个服务有三个参数：分别是转出账户、转入账户和转账金额。</p><p>实现过程也比较简单，我们要从账户A中转账100元到账户B中：</p><ol>\n<li>先从A的账户中减去100元；</li>\n<li>再给B的账户加上100元，转账完成。</li>\n</ol><p>对应的时序图是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/58/3f7faf335a9e6c3009902d85b71d3058.jpg?wh=3665*1790\" alt=\"\"></p><p>在这个例子的实现过程中，我们调用了另外一个微服务Add(account, amount)，它的功能是给账户account增加金额amount，当amount为负值的时候，就是扣减响应的金额。</p><p>需要特别说明的是，在这段代码中，我为了使问题简化以便我们能专注于异步和性能优化，省略了错误处理和事务相关的代码，你在实际的开发中不要这样做。</p><!-- [[[read_end]]] --><h4>1. 同步实现的性能瓶颈</h4><p>首先我们来看一下同步实现，对应的伪代码如下：</p><pre><code>Transfer(accountFrom, accountTo, amount) {\n  // 先从accountFrom的账户中减去相应的钱数\n  Add(accountFrom, -1 * amount)\n  // 再把减去的钱数加到accountTo的账户中\n  Add(accountTo, amount)\n  return OK\n}\n</code></pre><p>上面的伪代码首先从accountFrom的账户中减去相应的钱数，再把减去的钱数加到accountTo的账户中，这种同步实现是一种很自然方式，简单直接。那么性能表现如何呢？接下来我们就来一起分析一下性能。</p><p>假设微服务Add的平均响应时延是50ms，那么很容易计算出我们实现的微服务Transfer的平均响应时延大约等于执行2次Add的时延，也就是100ms。那随着调用Transfer服务的请求越来越多，会出现什么情况呢？</p><p>在这种实现中，每处理一个请求需要耗时100ms，并在这100ms过程中是需要独占一个线程的，那么可以得出这样一个结论：每个线程每秒钟最多可以处理10个请求。我们知道，每台计算机上的线程资源并不是无限的，假设我们使用的服务器同时打开的线程数量上限是10,000，可以计算出这台服务器每秒钟可以处理的请求上限是： 10,000 （个线程）* 10（次请求每秒） = 100,000 次每秒。</p><p>如果请求速度超过这个值，那么请求就不能被马上处理，只能阻塞或者排队，这时候Transfer服务的响应时延由100ms延长到了：排队的等待时延 + 处理时延(100ms)。也就是说，在大量请求的情况下，我们的微服务的平均响应时延变长了。</p><p>这是不是已经到了这台服务器所能承受的极限了呢？其实远远没有，如果我们监测一下服务器的各项指标，会发现无论是CPU、内存，还是网卡流量或者是磁盘的IO都空闲的很，那我们Transfer服务中的那10,000个线程在干什么呢？对，绝大部分线程都在等待Add服务返回结果。</p><p>也就是说，<strong>采用同步实现的方式，整个服务器的所有线程大部分时间都没有在工作，而是都在等待。</strong></p><p>如果我们能减少或者避免这种无意义的等待，就可以大幅提升服务的吞吐能力，从而提升服务的总体性能。</p><h4>2. 采用异步实现解决等待问题</h4><p>接下来我们看一下，如何用异步的思想来解决这个问题，实现同样的业务逻辑。</p><pre><code>TransferAsync(accountFrom, accountTo, amount, OnComplete()) {\n  // 异步从accountFrom的账户中减去相应的钱数，然后调用OnDebit方法。\n  AddAsync(accountFrom, -1 * amount, OnDebit(accountTo, amount, OnAllDone(OnComplete())))\n}\n// 扣减账户accountFrom完成后调用\nOnDebit(accountTo, amount, OnAllDone(OnComplete())) {\n  //  再异步把减去的钱数加到accountTo的账户中，然后执行OnAllDone方法\n  AddAsync(accountTo, amount, OnAllDone(OnComplete()))\n}\n// 转入账户accountTo完成后调用\nOnAllDone(OnComplete()) {\n  OnComplete()\n}\n</code></pre><p>细心的你可能已经注意到了，TransferAsync服务比Transfer多了一个参数，并且这个参数传入的是一个回调方法OnComplete()（虽然Java语言并不支持将方法作为方法参数传递，但像JavaScript等很多语言都具有这样的特性，在Java语言中，也可以通过传入一个回调类的实例来变相实现类似的功能）。</p><p>这个TransferAsync()方法的语义是：请帮我执行转账操作，当转账完成后，请调用OnComplete()方法。调用TransferAsync的线程不必等待转账完成就可以立即返回了，待转账结束后，TransferService自然会调用OnComplete()方法来执行转账后续的工作。</p><p>异步的实现过程相对于同步来说，稍微有些复杂。我们先定义2个回调方法：</p><ul>\n<li><strong>OnDebit()</strong>：扣减账户accountFrom完成后调用的回调方法；</li>\n<li><strong>OnAllDone()</strong>：转入账户accountTo完成后调用的回调方法。</li>\n</ul><p>整个异步实现的语义相当于：</p><ol>\n<li>异步从accountFrom的账户中减去相应的钱数，然后调用OnDebit方法；</li>\n<li>在OnDebit方法中，异步把减去的钱数加到accountTo的账户中，然后执行OnAllDone方法；</li>\n<li>在OnAllDone方法中，调用OnComplete方法。</li>\n</ol><p>绘制成时序图是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/38/0d/38ab8de8fbfaf4cd4b34fbd9ddd3360d.jpg?wh=3610*1831\" alt=\"\"></p><p>你会发现，异步化实现后，整个流程的时序和同步实现是完全一样的，<strong>区别只是在线程模型上由同步顺序调用改为了异步调用和回调的机制。</strong></p><p>接下来我们分析一下异步实现的性能，由于流程的时序和同步实现是一样，在低请求数量的场景下，平均响应时延一样是100ms。在超高请求数量场景下，异步的实现不再需要线程等待执行结果，只需要个位数量的线程，即可实现同步场景大量线程一样的吞吐量。</p><p>由于没有了线程的数量的限制，总体吞吐量上限会大大超过同步实现，并且在服务器CPU、网络带宽资源达到极限之前，响应时延不会随着请求数量增加而显著升高，几乎可以一直保持约100ms的平均响应时延。</p><p>看，这就是异步的魔力。</p><h2>简单实用的异步框架: CompletableFuture</h2><p>在实际开发时，我们可以使用异步框架和响应式框架，来解决一些通用的异步编程问题，简化开发。Java中比较常用的异步框架有Java8内置的<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\">CompletableFuture</a>和ReactiveX的<a href=\"https://github.com/ReactiveX/RxJava\">RxJava</a>，我个人比较喜欢简单实用易于理解的CompletableFuture，但是RxJava的功能更加强大。有兴趣的同学可以深入了解一下。</p><p>Java 8中新增了一个非常强大的用于异步编程的类：CompletableFuture，几乎囊获了我们在开发异步程序的大部分功能，使用CompletableFuture很容易编写出优雅且易于维护的异步代码。</p><p>接下来，我们来看下，如何用CompletableFuture实现的转账服务。</p><p>首先，我们用CompletableFuture定义2个微服务的接口：</p><pre><code>/**\n * 账户服务\n */\npublic interface AccountService {\n    /**\n     * 变更账户金额\n     * @param account 账户ID\n     * @param amount 增加的金额，负值为减少\n     */\n    CompletableFuture&lt;Void&gt; add(int account, int amount);\n}\n</code></pre><pre><code>/**\n * 转账服务\n */\npublic interface TransferService {\n    /**\n     * 异步转账服务\n     * @param fromAccount 转出账户\n     * @param toAccount 转入账户\n     * @param amount 转账金额，单位分\n     */\n    CompletableFuture&lt;Void&gt; transfer(int fromAccount, int toAccount, int amount);\n}\n</code></pre><p>可以看到这两个接口中定义的方法的返回类型都是一个带泛型的CompletableFuture，尖括号中的泛型类型就是真正方法需要返回数据的类型，我们这两个服务不需要返回数据，所以直接用Void类型就可以。</p><p>然后我们来实现转账服务：</p><pre><code>/**\n * 转账服务的实现\n */\npublic class TransferServiceImpl implements TransferService {\n    @Inject\n    private  AccountService accountService; // 使用依赖注入获取账户服务的实例\n    @Override\n    public CompletableFuture&lt;Void&gt; transfer(int fromAccount, int toAccount, int amount) {\n      // 异步调用add方法从fromAccount扣减相应金额\n      return accountService.add(fromAccount, -1 * amount)\n      // 然后调用add方法给toAccount增加相应金额\n      .thenCompose(v -&gt; accountService.add(toAccount, amount));    \n    }\n}\n</code></pre><p>在转账服务的实现类TransferServiceImpl里面，先定义一个AccountService实例，这个实例从外部注入进来，至于怎么注入不是我们关心的问题，就假设这个实例是可用的就好了。</p><p>然后我们看实现transfer()方法的实现，我们先调用一次账户服务accountService.add()方法从fromAccount扣减响应的金额，因为add()方法返回的就是一个CompletableFuture对象，可以用CompletableFuture的thenCompose()方法将下一次调用accountService.add()串联起来，实现异步依次调用两次账户服务完整转账。</p><p>客户端使用CompletableFuture也非常灵活，既可以同步调用，也可以异步调用。</p><pre><code>public class Client {\n    @Inject\n    private TransferService transferService; // 使用依赖注入获取转账服务的实例\n    private final static int A = 1000;\n    private final static int B = 1001;\n\n    public void syncInvoke() throws ExecutionException, InterruptedException {\n        // 同步调用\n        transferService.transfer(A, B, 100).get();\n        System.out.println(&quot;转账完成！&quot;);\n    }\n\n    public void asyncInvoke() {\n        // 异步调用\n        transferService.transfer(A, B, 100)\n                .thenRun(() -&gt; System.out.println(&quot;转账完成！&quot;));\n    }\n}\n</code></pre><p>在调用异步方法获得返回值CompletableFuture对象后，既可以调用CompletableFuture的get方法，像调用同步方法那样等待调用的方法执行结束并获得返回值，也可以像异步回调的方式一样，调用CompletableFuture那些以then开头的一系列方法，为CompletableFuture定义异步方法结束之后的后续操作。比如像上面这个例子中，我们调用thenRun()方法，参数就是将转账完成打印在控台上这个操作，这样就可以实现在转账完成后，在控制台打印“转账完成！”了。</p><h2>小结</h2><p>简单的说，异步思想就是，<strong>当我们要执行一项比较耗时的操作时，不去等待操作结束，而是给这个操作一个命令：“当操作完成后，接下来去执行什么。”</strong></p><p>使用异步编程模型，虽然并不能加快程序本身的速度，但可以减少或者避免线程等待，只用很少的线程就可以达到超高的吞吐能力。</p><p>同时我们也需要注意到异步模型的问题：相比于同步实现，异步实现的复杂度要大很多，代码的可读性和可维护性都会显著的下降。虽然使用一些异步编程框架会在一定程度上简化异步开发，但是并不能解决异步模型高复杂度的问题。</p><p>异步性能虽好，但一定不要滥用，只有类似在像消息队列这种业务逻辑简单并且需要超高吞吐量的场景下，或者必须长时间等待资源的地方，才考虑使用异步模型。如果系统的业务逻辑比较复杂，在性能足够满足业务需求的情况下，采用符合人类自然的思路且易于开发和维护的同步模型是更加明智的选择。</p><h2>思考题</h2><p>课后给你留2个思考题：</p><p>第一个思考题是，我们实现转账服务时，并没有考虑处理失败的情况。你回去可以想一下，在异步实现中，如果调用账户服务失败时，如何将错误报告给客户端？在两次调用账户服务的Add方法时，如果某一次调用失败了，该如何处理才能保证账户数据是平的？</p><p>第二个思考题是，在异步实现中，回调方法OnComplete()是在什么线程中运行的？我们是否能控制回调方法的执行线程数？该如何做？欢迎在留言区写下你的想法。</p><p>感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"09 | 学习开源代码该如何入手？","id":115519},"right":{"article_title":"11 | 如何实现高性能的异步网络传输？","id":118322}},"comments":[{"had_liked":false,"id":126696,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":true,"comment_ctime":1566450793,"is_pvip":false,"replies":[{"id":"46924","content":"人工置顶🔝","user_name":"作者回复","comment_id":126696,"uid":"1501046","ip_address":"","utype":1,"ctime":1566521975,"user_name_real":"李玥"}],"discussion_count":23,"race_medal":0,"score":"9.2233725667022008e+18","product_id":100032301,"comment_content":"个人的一点想法：<br>异步回调机制的本质是通过减少线程等待时占用的CPU时间片，来提供CPU时间片的利用率。<br>具体做法是用少数线程响应业务请求，但处理时这些线程并不真正调用业务逻辑代码，而是简单的把业务处理逻辑扔到另一个专门执行业务逻辑代码的线程后就返回了，故不会有任何等待(CPU时间片浪费)。专门执行业务逻辑的线程可能会由于IO慢导致上下文切换而浪费一些CPU时间片，但这已经不影响业务请求的响应了，而业务逻辑执行完毕后会把回调处理逻辑再扔到专门执行回调业务逻辑的线程中，这时的执行业务逻辑线程的使命已完成，线程返回，然后会去找下一个需要执行的业务逻辑，这里也没有任何等待。回调业务处理线程也是同理。<br>以上于《摩登时代》里的卓别林很像，每个人只做自己的那点事(卓别林只拧螺丝)。有的线程只负责响应请求(放螺丝)，有的线程只负责执行业务逻辑(拧螺丝)，有的线程只负责执行回调代码(敲螺丝)，完成后就返回并继续执行下一个相同任务(拧完这个螺丝再找下一个需要拧的螺丝)，没有相互依赖的等待(放螺丝的不等螺丝拧好就直接放下一个螺丝)。<br>有利就有弊，分开后是不用等别人了，但想知道之前的步骤是否已经做好了就难了。比如螺丝没有拧紧就开始敲，会导致固定不住。如果发现螺丝没拧好，敲螺丝的人就要和工头说这块板要返工，螺丝取下，重新放，重新拧，之后才能敲。<br>个人感觉把关联性强且无需长时间等待的操作(如大量磁盘或网络IO)打包成同步，其他用异步，这样可以在规避CPU时间片浪费的同时兼顾了一致性，降低了补偿的频率和开销。<br>","like_count":122,"discussions":[{"author":{"id":1221682,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a4/32/4fac3a6c.jpg","nickname":"晓丹","note":"","ucode":"A90E8888A161C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81341,"discussion_content":"整个都说错了，不明白为什么置顶。\n异步的本质是为了不占用过多的线程对象。\n比如一个响应时间是1秒的http1.1请求,并且不考虑http pipeline:\n同步模式下，一个请求在未返回前，需要独占一个线程和一个httpconnection。\n异步模式下，一个请求在未返回前，只需要独占一个httpconnection,那个线程在提交完io任务后就回到线程池了。\n也就是说一秒并发5000的话，同步需要5000个connection和5000个线程，而异步可以省下5000个线程的内存以及操作系统对这些线程的管理能耗。","likes_number":32,"is_delete":false,"is_hidden":false,"ctime":1576242558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1414197,"avatar":"https://static001.geekbang.org/account/avatar/00/15/94/35/42e7d75c.jpg","nickname":"鱼仔💪","note":"","ucode":"10DB3F693AD0AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1221682,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a4/32/4fac3a6c.jpg","nickname":"晓丹","note":"","ucode":"A90E8888A161C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126950,"discussion_content":"我赞同你的说法，如果同步时，线程等待需要占用cpu时间片，那上面说的cpu也不会空闲。 线程等待时，是阻塞状态，会让出cpu资源。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578552481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":81341,"ip_address":""},"score":126950,"extra":""},{"author":{"id":1111899,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","nickname":"时隐时现","note":"","ucode":"DA4D622FF84920","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1221682,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a4/32/4fac3a6c.jpg","nickname":"晓丹","note":"","ucode":"A90E8888A161C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250992,"discussion_content":"这个才是正解，作者怎么会手工置顶那条留言，是字太多没来得及看吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588056687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":81341,"ip_address":""},"score":250992,"extra":""},{"author":{"id":1621660,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","nickname":"子非鱼","note":"","ucode":"020DA0784E728C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1221682,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a4/32/4fac3a6c.jpg","nickname":"晓丹","note":"","ucode":"A90E8888A161C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293313,"discussion_content":"你的说的对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595502897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":81341,"ip_address":""},"score":293313,"extra":""}]},{"author":{"id":2050256,"avatar":"","nickname":"Geek_ab094a","note":"","ucode":"4493162A159904","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287322,"discussion_content":"“异步回调机制的本质是通过减少线程等待时占用的CPU时间片，来提供CPU时间片的利用率。” 第一句话就错了，线程等待不会占用CPU时间片","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1593415399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","nickname":"楊_宵夜","note":"","ucode":"7BA0CADC5F23BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177349,"discussion_content":"晓丹同学说的没错, 异步的本质就是为了节省线程对象;\n小伟同学说的IO分配独立的线程池, 整体思想没错,  但IO操作区域已经在内存外了, 反而应该异步; 纯内存操作应该同步, 如果纯内存操作用异步, 反而增加了事件通知的开销;","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1582097275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2610962,"avatar":"https://static001.geekbang.org/account/avatar/00/27/d7/12/2a45141d.jpg","nickname":"腾","note":"","ucode":"78B7EBCAD332D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372748,"discussion_content":"异步回调机制的本质是通过减少线程等待时占用的CPU时间片，来提供CPU时间片的利用率。\n\n操作系统没学好，线程等待时已经释放了cpu，何来减少等待时占用的cpu时间片。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1620450376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1255277,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDVXsv6JOOficLK07867AkAb21eoG5KBgYFmwhMXKJooU5B6iaIZwyDxExicokVQSiaKEwZ4qPicqVFcg/132","nickname":"拼yin世界","note":"","ucode":"9571428A12B72A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2610962,"avatar":"https://static001.geekbang.org/account/avatar/00/27/d7/12/2a45141d.jpg","nickname":"腾","note":"","ucode":"78B7EBCAD332D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376255,"discussion_content":"我这个学过操作系统的，也和你有同样的疑问～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622039292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372748,"ip_address":""},"score":376255,"extra":""}]},{"author":{"id":1621660,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","nickname":"子非鱼","note":"","ucode":"020DA0784E728C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293319,"discussion_content":"第一句本质那块确实不对，但是整体思路我感觉是对的。你打那么多字，其实老师的例子就是说明两点。\n1.异步操作，减少的是客户端和服务器的响应时间，进而更多服务器可以接受更多的请求。（因为客户端不需要，同步等待服务执行结果。）\n2.异步操作，提高了cpu和线程的利用率。（表面上看是每个转账操作，都创建一个线程去执行业务逻辑。但是相对于同步来说，这样的异步操作其实是每个线程都有事可干）","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595503430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2610962,"avatar":"https://static001.geekbang.org/account/avatar/00/27/d7/12/2a45141d.jpg","nickname":"腾","note":"","ucode":"78B7EBCAD332D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1621660,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","nickname":"子非鱼","note":"","ucode":"020DA0784E728C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372755,"discussion_content":"我理解\n1、cpu利用率，站在整个调用链条上的服务器来说，减少了同步引起的等待，提升了服务器整体的cpu利用率，各个服务器都拼命干活了，吞吐量自然上去了。\n2、响应时间，对于同一个请求来说，异步响应时间只会增加。\n3、可用性，如果链条上全是同步，估计整个系统的高可靠性下降会比较明显，异步，损失一些时间，保障了高可用性。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620451336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293319,"ip_address":""},"score":372755,"extra":""}]},{"author":{"id":1103356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/fc/00af6446.jpg","nickname":"团子","note":"","ucode":"42832AC5B3C535","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237778,"discussion_content":"线程io阻塞状态，会让出cpu执行时间片，没看明白减少线程占用cpu时间片没看明白","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587183900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232111,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cc/ef/644afce7.jpg","nickname":"王旭","note":"","ucode":"635A50B2BBC2D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7104,"discussion_content":"是不是说反了？大量磁盘或网络IO是需要长时间等待的操作。\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567386457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1583859,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2a/f3/b9607a15.jpg","nickname":"绅士","note":"","ucode":"5B58E5A958F489","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1232111,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cc/ef/644afce7.jpg","nickname":"王旭","note":"","ucode":"635A50B2BBC2D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7715,"discussion_content":"我觉得也是说反了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567650348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7104,"ip_address":""},"score":7715,"extra":""},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1232111,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cc/ef/644afce7.jpg","nickname":"王旭","note":"","ucode":"635A50B2BBC2D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85562,"discussion_content":"请问哪里说反了？我上面的例子是说把一个任务垂直切分成若干部分，每个部分由少量线程专责处理，可减少上一个步骤没完成之前时，后一部分的等待时间，提高cpu利用率。io等耗时部分，可以先放队列，少量线程专门io。有哪里不对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576555409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7104,"ip_address":""},"score":85562,"extra":""}]},{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301154,"discussion_content":"字太多了，兄弟们，我就不看了~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598427763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2050256,"avatar":"","nickname":"Geek_ab094a","note":"","ucode":"4493162A159904","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287323,"discussion_content":"作者为什么置顶这条留言？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593415444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2050256,"avatar":"","nickname":"Geek_ab094a","note":"","ucode":"4493162A159904","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575636,"discussion_content":"除了让出cpu时间不准确外其他逻辑很通顺","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654964270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287323,"ip_address":""},"score":575636,"extra":""}]},{"author":{"id":1162081,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bb/61/2c2f5024.jpg","nickname":"haijian.yang","note":"","ucode":"E3D13ABA2CA347","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223890,"discussion_content":"线程阻塞的时候除了线下切换 需要消耗 CPU 时间，并不需要 CPU 时间吧，线程要消耗资源明显。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586260519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1221682,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a4/32/4fac3a6c.jpg","nickname":"晓丹","note":"","ucode":"A90E8888A161C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114103,"discussion_content":"少量负责io的线程提高吞吐量了吗，比如这个少量是1,这个线程被阻塞时，队列里的其他io是不是都在等待？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577957987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1221682,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a4/32/4fac3a6c.jpg","nickname":"晓丹","note":"","ucode":"A90E8888A161C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115641,"discussion_content":"如果你的任务唯一做的事就是io操作，那么就像你说的，都需要阻塞等待临界资源。但如果一个任务可以拆分成io和非io部分，且非io部分已可基本满足要求，那么少量线程专职非io任务就可提高吞吐量。\n举例，一个秒杀系统，少量线程消费秒杀请求，只要把请求扔到mq里就返回，客户被通知“秒杀已接受，请等待结果通知”。这样少量线程就可处理海量秒杀请求，就是所谓提高了吞吐量。再后面若干线程专职负责从mq里拉消息，做出库、订单生成等高耗时操作。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1578025150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114103,"ip_address":""},"score":115641,"extra":""}]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464124,"discussion_content":"人工置顶🔝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566521975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","nickname":"静水流深","note":"","ucode":"644F05EFBD2E7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41619,"discussion_content":"说的有问题吧！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572480955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","nickname":"静水流深","note":"","ucode":"644F05EFBD2E7B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85560,"discussion_content":"哪里有问题，请指教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576555055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41619,"ip_address":""},"score":85560,"extra":""}]}]},{"had_liked":false,"id":123422,"user_name":"笑傲流云","can_delete":false,"product_type":"c1","uid":1012594,"ip_address":"","ucode":"40DF87D569C530","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep3DicN9rHZiblia3zNpKJ3hEegicBFZqzZBS7l0oSENZicnqw340TnHVQsfNL33OtGyxEVQuS8DmqhPDQ/132","comment_is_top":false,"comment_ctime":1565673871,"is_pvip":false,"replies":[{"id":"45342","content":"👍👍👍","user_name":"作者回复","comment_id":123422,"uid":"1501046","ip_address":"","utype":1,"ctime":1565745287,"user_name_real":"李玥"}],"discussion_count":11,"race_medal":0,"score":"379522795919","product_id":100032301,"comment_content":"个人的思路，欢迎老师点评下哈。<br>1，调用账户失败，可以在异步callBack里执行通知客户端的逻辑；<br>2，如果是第一次失败，那后面的那一步就不用执行了，所以转账失败；如果是第一次成功但是第二次失败，首先考虑重试，如果转账服务是幂等的,可以考虑一定次数的重试，如果不能重试，可以考虑采用补偿机制，undo第一次的转账操作。<br>3，CompletableFuture默认是在ForkjoinPool commonpool里执行的，也可以指定一个Executor线程池执行，借鉴guava的ListenableFuture的时间，回调可以指定线程池执行，这样就能控制这个线程池的线程数目了。","like_count":89,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5723,"discussion_content":"个人感觉，老师这里以转账举例同步转异步不是很合适，原因是转账是强一致性的，且不说转账几乎不可能是幂等的，单就补偿的开销就可能比同步转账大了。\n异步回调适合非强一致性的，如付款成功后发送短信，付款成功后即使短信发送失败了也没有太大关系，短信补发或不补发都不影响付款业务，只会影响到客户体验。\n不妥之处，请指教。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1566447699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1012594,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep3DicN9rHZiblia3zNpKJ3hEegicBFZqzZBS7l0oSENZicnqw340TnHVQsfNL33OtGyxEVQuS8DmqhPDQ/132","nickname":"笑傲流云","note":"","ucode":"40DF87D569C530","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5996,"discussion_content":"你说的很对，转账不适合做成异步的，补偿的话用户体验不好，系统开销也很大。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566572243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5723,"ip_address":""},"score":5996,"extra":""},{"author":{"id":1012594,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep3DicN9rHZiblia3zNpKJ3hEegicBFZqzZBS7l0oSENZicnqw340TnHVQsfNL33OtGyxEVQuS8DmqhPDQ/132","nickname":"笑傲流云","note":"","ucode":"40DF87D569C530","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5997,"discussion_content":"一般都是用数据库事务去保证一致性，这两个操作应该是一组原子操作；不过分布式事务开销比较大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566572381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5723,"ip_address":""},"score":5997,"extra":""},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294726,"discussion_content":"这里整体上是同步的，两个转账异步并发执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595983318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5723,"ip_address":""},"score":294726,"extra":""}]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462665,"discussion_content":"👍👍👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565745287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016463,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/8f/abb7bfe3.jpg","nickname":"湖州黄老爷","note":"","ucode":"0B8B974EE7BBF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5828,"discussion_content":"如何得知第一步失败了呢？如果需要等待返回结果不久恢复成同步的了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566475036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585638,"discussion_content":"不懂转账为啥能解耦成异步，第一步扣款要是没明确成功你敢直接异步进行第二步？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661743291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1564721,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e0/31/052714e0.jpg","nickname":"PinuoC","note":"","ucode":"219D10B6996396","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584730,"discussion_content":"请教一下，用了这么多异步，他的持久化该怎么做呢，如果提交了一个异步任务到线程里，这时候服务宕机重启了，之前的任务还会在吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661069282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254582,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/FqZKG3aII9YzXkfSh1Wuc2urQPZX9tZ9AwQKevDlic3mAD9C0ceVpLrSNeCLYfKAY9PtjVjVP2JBLwqRkvMoaQg/132","nickname":"晓μ","note":"","ucode":"4C6A062C43B570","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":11182,"discussion_content":"我在网上查询了一些关于CompleteFuture的生成方法，使用一些静态方法，比如runAsync(Runnable runnable )，其中这个线程是否就是回调函数呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568364759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7940,"discussion_content":"老铁，请教一下，像异步编程这些有没有什么好的资料推荐的，谢了诶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567734804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123269,"user_name":"senekis","can_delete":false,"product_type":"c1","uid":1446025,"ip_address":"","ucode":"CD88681F0278FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erTlRJ6skf7iawAeqNfIT1PPgjD7swUdRIRkX1iczjj97GNrxnsnn3QuOhkVbCLgFYAm7sMZficNTSbA/132","comment_is_top":false,"comment_ctime":1565656396,"is_pvip":true,"replies":[{"id":"45334","content":"太多的线程会造成频繁的cpu上下文切换，你可以想象一下，假设你的小公司只有8台电脑，你雇8个程序员一直不停的工作显然是效率最高的。考虑到程序员要休息不可能连轴转，雇佣24个人，每天三班倒，效率也还行。<br><br>但是，你要雇佣10000个人，他们还是只能用这8台电脑，大部分时间不都浪费在换人、交接工作上了吗？","user_name":"作者回复","comment_id":123269,"uid":"1501046","ip_address":"","utype":1,"ctime":1565744149,"user_name_real":"李玥"}],"discussion_count":26,"race_medal":0,"score":"272148596044","product_id":100032301,"comment_content":"老师，我一直有一个困惑，就是想不明白为何异步可以节省线程。每次发起一个异步调用不都会创建一个新的线程吗？我理解了好几次，感觉只是异步处理线程在等待时可以让出时间片给其他线程运行啊？一直想不明白这个问题，困扰了好久，求老师解惑。","like_count":64,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462604,"discussion_content":"太多的线程会造成频繁的cpu上下文切换，你可以想象一下，假设你的小公司只有8台电脑，你雇8个程序员一直不停的工作显然是效率最高的。考虑到程序员要休息不可能连轴转，雇佣24个人，每天三班倒，效率也还行。\n\n但是，你要雇佣10000个人，他们还是只能用这8台电脑，大部分时间不都浪费在换人、交接工作上了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565744149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131956,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","nickname":"oscarwin","note":"","ucode":"492430BA342593","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4997,"discussion_content":"异步相比与同步的优势在于：同步等待的时间被异步的方式拿来接受新的请求了。因此相同线程的数量下，异步支持的并发和吞吐量都高的多。","likes_number":52,"is_delete":false,"is_hidden":false,"ctime":1565867113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1053921,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","nickname":"Zend","note":"","ucode":"80EBB0B6772E27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1131956,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","nickname":"oscarwin","note":"","ucode":"492430BA342593","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5137,"discussion_content":"这个解释言简意赅","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566000095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4997,"ip_address":""},"score":5137,"extra":""},{"author":{"id":1577210,"avatar":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","nickname":"刘大人","note":"","ucode":"F66AE613E80398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1131956,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","nickname":"oscarwin","note":"","ucode":"492430BA342593","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336821,"discussion_content":"漂亮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608709231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4997,"ip_address":""},"score":336821,"extra":""},{"author":{"id":2538236,"avatar":"","nickname":"Geek_6770f0","note":"","ucode":"371AB3E9417600","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1131956,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","nickname":"oscarwin","note":"","ucode":"492430BA342593","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400314,"discussion_content":"漂亮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633231770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4997,"ip_address":""},"score":400314,"extra":""}]},{"author":{"id":1128702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/fe/00ddeb81.jpg","nickname":"learn more","note":"","ucode":"0EF628B2E0F95E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6551,"discussion_content":"开始我也有同样的疑惑，我都数不清这是第几次看这篇文章了，我说说我的理解，希望对你有帮助。\n首先，Java 异步调用一定会有个新线程，不管是新创建还是从线程池获取已创建好的，总之要个新线程去处理业务逻辑，那么作者说可以节省线程是怎么回事呢？其实作者的例子里有两个服务，一个是 transfer，一个是 account ，把transfer调用account的服务作为异步，那么transfer的线程立刻返回且被回收到线程池供下一次使用，然后 account 服务还是要开一个线程去处理真正的转账操作。相比之前的同步，每一个请求过来，transfer 要一个线程，account 要一个线程，而且transfer必须等待account返回才能回收这个线程，因此，说节约线程数是针对transfer而言的。","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1566968732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1128702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/fe/00ddeb81.jpg","nickname":"learn more","note":"","ucode":"0EF628B2E0F95E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25044,"discussion_content":"Account服务一定是运行在另外一个process中的，transfer服务通过RPC或MQ来调用account服务，否则在同一个thread中运行transfer和Account服务才最省线程。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1570389861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6551,"ip_address":""},"score":25044,"extra":""},{"author":{"id":1101959,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/87/6880e490.jpg","nickname":"Prozombie","note":"","ucode":"ADB4753F00595E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47545,"discussion_content":"我也是这样想的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573361739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25044,"ip_address":""},"score":47545,"extra":""},{"author":{"id":1016232,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/81/a8/559afe8b.jpg","nickname":"Sruby","note":"","ucode":"A7D1B93F41DA0F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1128702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/fe/00ddeb81.jpg","nickname":"learn more","note":"","ucode":"0EF628B2E0F95E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309010,"discussion_content":"没有说是另外一个服务吧，前面有个评论说得有些道理，因为http请求不只是占用1个线程，还会占用一个http连接，异步后节省了1个http连接的开销。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601170452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6551,"ip_address":""},"score":309010,"extra":""}]},{"author":{"id":1219496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","nickname":"Leon📷","note":"","ucode":"B9BBD1EFAAE5A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4821,"discussion_content":"我帮老师回答下楼上，线程系统调用需要主动让出cpu，等系统准备好了再切换回来继续执行，一来一回上下文的开销，加上线程本来还有时间片没有用完，所以同步调用会形成大量的时间片空洞，和开会上下文的开销，对系统资源是很大的浪费，异步程序相当于用户态切换cpu，对于本线程而言并没有把cpu切换出来，剩下的时间片可以继续执行代码，直到时间片用完，异步程序提升的就是把这个时间片充分利用和省去了这个频繁的不必要的来回上下文切换开销","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1565752910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1058526,"avatar":"","nickname":"DeathKnightH","note":"","ucode":"632E00A01247A3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4712,"discussion_content":"说下我的理解：这里节省线程的前提是线程数量是有限的（废话），同步情况下只要一整套的操作没有完成，线程资源就还被占用着，可用线程数就不会变多，而异步的情况下，请求进来，调用了异步的方法之后，不用等异步方法返回，当前的请求线程就可以结束了，这样线程资源就释放了，可以有更多的请求可以进来，个人理解异步是提高了线程资源本身的使用效率，让线程资源的申请和释放更灵活，所以从宏观上看是节省了所需线程总量的。","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1565682871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1878896,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ab/70/336b8ec1.jpg","nickname":"杀入禁区的勒布朗","note":"","ucode":"AF89E123F075DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1058526,"avatar":"","nickname":"DeathKnightH","note":"","ucode":"632E00A01247A3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":306205,"discussion_content":"你这个应该才是作者想要表达的意思，楼上很多过度解读，看了让人更迷惑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600218814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4712,"ip_address":""},"score":306205,"extra":""}]},{"author":{"id":1611886,"avatar":"https://static001.geekbang.org/account/avatar/00/18/98/6e/38b4a4ce.jpg","nickname":"渊鱼","note":"","ucode":"EC52C7F6863FA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214881,"discussion_content":"线程不等结果，结果出来了通知线程来继续执行。没出来线程就去忙别的任务去了以减少更多线程创建","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585238100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7938,"discussion_content":"我想您的意思是不是，就算是异步的，需要去监听返回的那个结果，这也是要开一个线程的吧","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567734285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37527,"discussion_content":"可以采用消息通知 或者会调的方式  不一定要开一个线程的吧~~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571629919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7938,"ip_address":""},"score":37527,"extra":""},{"author":{"id":1213325,"avatar":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","nickname":"徐李","note":"","ucode":"41550F6CA1E112","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":560408,"discussion_content":"只要是执行总是要开线程的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649317512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37527,"ip_address":""},"score":560408,"extra":""}]},{"author":{"id":1495497,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKmB1DWZP1l7QsgU8eXpyuicS6oWbuia3NUI6R77Sib9HHgOoDeX9lYcR9csU4BNZXg1dK9wjLq0Ehcg/132","nickname":"武子","note":"","ucode":"2F865ED507742E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5033,"discussion_content":"我说一下我的理解 其实更试用这种异步处理的是IO类型的操作 比如一个rpc 网络调用可能会出现很多耗时比较高的情况 举个例子 假如你的服务也是一个rpc server 接收请求之后需要调用其他服务的一个rpc接口 如果你用同步调用的方法 每当你接收一个请求 就开启一个线程去同步调用 如果这个服务调用一次要1s 而你1s接收100个请求 你就要开100个线程去处理 而这100个线程大多都在等待IO ，如果你要用异步调用的方式 你每接收一个请求之后可以把请求扔到一个buffer中（或者线程池 线程池个数可控），调用其他服务的rpc IO等待可以由一个或者固定的几个线程去做（IO多路复用），扔到buffer的操作很快 一个线程1s就能处理好几万 也就是说 处理这几万的请求 也就最少只是用了几个线程而已。 如果说不是IO操作 而是其他计算密集型的操作 就算异步处理 一样也是需要异步的线程（比如说线程池）来处理 处理相同的请求 线程数几乎是一样的 ","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1565882003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4700,"discussion_content":"这里说说我的理解，线程在等待时让出时间片应该是由CPU控制的，而不是异步。异步应该是在有限的时间片执行时间内，因为异步直接返回，那么原来等待磁盘IO的时间就可以用来再多执行几个请求，从而达到节省线程。至于异步调用会多创建一个线程是可以通过异步线程池来控制线程数量的吧，如spring中的async就可结合线程池来实现异步调用","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1565675113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736650,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyuuhxu0HH4cIKCClCqx0LTurCCYWmNcFwfTWV5te5afsibp2yuDmC9mibEHx0Xy8QlvqvMWWcAib8g/132","nickname":"我的喵","note":"","ucode":"A7435BDBDD2587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570715,"discussion_content":"我觉得通过异步来提升吞吐量只是因为使用异步的方式要比同步的方式在相同时间内能够接收更多的请求，从而提升整体吞吐，当然如果是单个请求完整闭环的效率未必提升，可能降低","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651888286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2167756,"avatar":"","nickname":"Geek_98ce3c","note":"","ucode":"16E56FF6EDE3DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306963,"discussion_content":"异步便于线程资源及时回收，减少等待、处理时间，化整为零。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600433489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087945,"avatar":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","nickname":"冰激凌的眼泪","note":"","ucode":"5DCB974667E93A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4917,"discussion_content":"想同时处理多个客户端，同步模式下一般要一个线程处理一个请求，由于同步阻塞的可能，这些线程大部分时间是空闲的，这就为优化线程数带来了可能。异步的模式为这个线程优化带来了可能。具体实现，未必一定能优化线程数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565831630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1087945,"avatar":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","nickname":"冰激凌的眼泪","note":"","ucode":"5DCB974667E93A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37529,"discussion_content":"赞同你的观点   异步 提高了系统的并发量和吞吐量  关于优化线程 老师的回答我也没看懂~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571629996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4917,"ip_address":""},"score":37529,"extra":""}]},{"author":{"id":1613161,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIqdDwaegnfzFbkibAdmyXh8EVI5No2MESZa0D1Y2QePDdhBVvug11Qbx7y3yFE4fVtrMn56Oeu3SQ/132","nickname":"Geek_53fdc0","note":"","ucode":"AC791BEE2D03C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4684,"discussion_content":"若是同步的话，1个流程耗时100ms，2个线程在100ms以内可以执行两次操作。若是异步的话，1个线程执行加额操作（50ms），另起一个线程执行减额操作（50ms）。那同样的100ms内也是需要两个线程才能完成两次操作呀。为啥会异步可以节省线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565661118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123568,"user_name":"付永强","can_delete":false,"product_type":"c1","uid":1419544,"ip_address":"","ucode":"898998296EBD56","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/18/393a841d.jpg","comment_is_top":false,"comment_ctime":1565704187,"is_pvip":false,"replies":[{"id":"45347","content":"👍👍👍<br>线程就是为了能自动分配CPU时间片而生的。","user_name":"作者回复","comment_id":123568,"uid":"1501046","ip_address":"","utype":1,"ctime":1565745718,"user_name_real":"李玥"}],"discussion_count":6,"race_medal":0,"score":"237788905467","product_id":100032301,"comment_content":"老师可能里面过多提到线程这两个字，所以很多人把异步设计理解成节约线程，其实李玥老师这里想说明的是异步是用来提高cup的利用率，而不是节省线程。<br>异步编程是通过分工的方式，是为了减少了cpu因线程等待的可能，让CPU一直处于工作状态。换句话说，如果我们能想办法减少CPU空闲时间，我们的计算机就可以支持更多的线程。<br>其实线程是一个抽象概念，我们从物理层面理解，就是单位时间内把每毫核分配处理不同的任务，从而提高单位时间内CPU的利用率。","like_count":56,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462729,"discussion_content":"👍👍👍\n线程就是为了能自动分配CPU时间片而生的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565745718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7941,"discussion_content":"其实所以说就不是线程节约了，其实依然会有一个监听返回结果的线程之类的存在的吧，但是这个线程不会进行cpu的抢占，所以CPU可以去处理别的需要用到的CPU计算资源的线程。可以这样理解吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567734997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1222422,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a7/16/64f125ed.jpg","nickname":"疆行","note":"","ucode":"D2A0DE791DDEBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":146255,"discussion_content":"不是必须有监听结果的线程。\n另外这个回答真的很棒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579605227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7941,"ip_address":""},"score":146255,"extra":""}]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415036,"discussion_content":"这就意味着 负载的算力没有完全释放 而此时请求如果放大N倍 给外部的感觉就是站点越来越卡 所以提升吞吐量是一种方式（假设时延无法再降低的情况下）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636968657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415035,"discussion_content":"这里的区别不是cpu利用率 应该说cpu的算力没有得到释放。按照老师的意思实际上是 cpu load 此时可能到1与2之间 但是cpu rate / mem rate其实很低 而带宽也远远没有被压榨完。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636968585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508329,"avatar":"https://static001.geekbang.org/account/avatar/00/17/03/e9/6358059c.jpg","nickname":"GalaxyCreater","note":"","ucode":"C79E8A088D57CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305206,"discussion_content":"应该是省了线程-->省了cpu在调度上的开销-->提供了cpu有效利用率；和你说的减少cpu空闲是有差别的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599816354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179922,"user_name":"我丢了一只小凳子","can_delete":false,"product_type":"c1","uid":1116340,"ip_address":"","ucode":"54F4AE0579711C","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/b4/c5118ad4.jpg","comment_is_top":false,"comment_ctime":1582122034,"is_pvip":false,"replies":[{"id":"70008","content":"首先，你要理解，为什么请求多了程序会变慢这个事儿。<br><br>计算的资源，比如说CPU、磁盘IO，它的处理能力是恒定的，都不会因为请求量大而“变慢”。<br><br>比如说CPU执行一次加法，任何情况下耗时都是差不多的。<br><br>我们所看到的请求量大“系统变慢”的现象，一定是因为某一种资源忙，达到了瓶颈。比如说，一个单核CPU，每做一次加法需要0.1秒，那它每秒最多做10次加法。<br><br>一下子100个程序同时都来请求CPU做一次加法，这个CPU就需要10秒才能算完。对于这个CPU，它并没变慢，仍然是每秒做10次加法。<br><br>但是对于某一个请求CPU的程序来说，它看到的现象是，我让CPU做了一次加法，它八秒才做完，看起来就是“变慢”了。<br><br>所以，程序变慢一定是因为某一个资源忙，遇到了瓶颈。同步程序因为线程数量的限制，它的瓶颈往往是线程数量。并不能发挥服务器的全部处理能力。异步程序不需要那么多线程，所以可以发挥出服务器的全部处理能力，直到把CPU或者磁盘IO打满，所以要快得多。","user_name":"作者回复","comment_id":179922,"uid":"1501046","ip_address":"","utype":1,"ctime":1582248126,"user_name_real":"李玥"}],"discussion_count":1,"race_medal":0,"score":"199150617650","product_id":100032301,"comment_content":"老师，有一点不太懂，异步转账时，假如专门几个线程（Threads_quest）处理转账请求，其他的线程处理账户增减金额逻辑，虽然大量请求来的时候，Threads_quest 这几个线程可以接受请求之后扔给其他线程处理增减金额，但是由于请求量过大，不也会导致其他线程处理变慢吗，导致完整的处理也变慢","like_count":47,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484450,"discussion_content":"首先，你要理解，为什么请求多了程序会变慢这个事儿。\n\n计算的资源，比如说CPU、磁盘IO，它的处理能力是恒定的，都不会因为请求量大而“变慢”。\n\n比如说CPU执行一次加法，任何情况下耗时都是差不多的。\n\n我们所看到的请求量大“系统变慢”的现象，一定是因为某一种资源忙，达到了瓶颈。比如说，一个单核CPU，每做一次加法需要0.1秒，那它每秒最多做10次加法。\n\n一下子100个程序同时都来请求CPU做一次加法，这个CPU就需要10秒才能算完。对于这个CPU，它并没变慢，仍然是每秒做10次加法。\n\n但是对于某一个请求CPU的程序来说，它看到的现象是，我让CPU做了一次加法，它八秒才做完，看起来就是“变慢”了。\n\n所以，程序变慢一定是因为某一个资源忙，遇到了瓶颈。同步程序因为线程数量的限制，它的瓶颈往往是线程数量。并不能发挥服务器的全部处理能力。异步程序不需要那么多线程，所以可以发挥出服务器的全部处理能力，直到把CPU或者磁盘IO打满，所以要快得多。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582248126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134959,"user_name":"mark","can_delete":false,"product_type":"c1","uid":1015720,"ip_address":"","ucode":"39EDFEA8010F9B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/a8/d103904b.jpg","comment_is_top":false,"comment_ctime":1568962800,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"96058243312","product_id":100032301,"comment_content":"go 语言的本质就是 用同步的方式，写出异步的代码。<br><br>每个用户过来直接启动一个 go routine ，可以同时启动上百万的协程<br>go processConn()<br><br>而go 的内部 只启动少量线程，io 的等待全部做了异步处理。","like_count":23},{"had_liked":false,"id":123548,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1565699533,"is_pvip":false,"replies":[{"id":"45346","content":"总结的非常好！<br><br>有一点需要改进一下，转账服务的实现中，异常处理的部分，还是需要先检查再补偿，否则有可能出现重复补偿的情况。","user_name":"作者回复","comment_id":123548,"uid":"1501046","ip_address":"","utype":1,"ctime":1565745637,"user_name_real":"李玥"}],"discussion_count":2,"race_medal":0,"score":"35925437901","product_id":100032301,"comment_content":"尝试回答课后习题，老师有空帮忙看下哦<br>思考题一、如果在异步实现中，如果调用账户服务失败，可以以账单的形式将转账失败的记录下来，比如客户在转账一段时间后<br>查看账单就可以知道转账是否成功，只要保证转账失败，客户的钱没有少就可以。两次调用账户服务，感觉可以这样写<br>&#47;**<br>     * 转账服务的实现<br>     *&#47;<br>    public class TransferServiceImpl implements TransferService {<br>        @Inject<br>        private  AccountService accountService; &#47;&#47; 使用依赖注入获取账户服务的实例<br>        @Override<br>        public CompletableFuture&lt;Void&gt; transfer(int fromAccount, int toAccount, int amount) {<br>            &#47;&#47; 异步调用 add 方法从 fromAccount 扣减相应金额<br>            return accountService.add(fromAccount, -1 * amount).exceptionally(add(fromAccount, amount))<br>                    &#47;&#47; 然后调用 add 方法给 toAccount 增加相应金额<br>                    .thenCompose(v -&gt; accountService.add(toAccount, amount)).exceptionally(add(toAccount, -1 * amount));<br>        }<br>    }<br>思考题二、在异步实现中，回调方法OnComplete()可以在另一个线程池执行，比如rocketmq中异步实现，<br>再异步发送消息时，会将封装一个ResponseFuture包含回调方法、通道、请求消息id，将其请求id做为key，ResponseFuture做为value放入map中<br>等响应返回时，根据请求id从map中获取ResponseFuture，然后将ResponseFuture中的回调方法封装成任务放入到线程池中执行。然后执行<br>特定的回调方法。CompletableFuture有点需要注意的是，在不同的业务中需创建各自的线程池，否则都是共用ForkJoinPool。<br>写下对异步的理解，如果同步一个请求线程需要等待处理结果完，才可以处理其他请求，这样的话会导致如果请求多，创建很多线程<br>但是这些线程大部分都是等待处理结果，如果有后续的请求，没有其他线程及时处理会导致延迟（等待线程时间+处理时间），<br>会出现机器的cpu、磁盘、内存都不高（因为等待的线程是不占CPU的）很多请求超时之类的情况。异步的话，就是让线程调用处理接口就直接返回<br>不用等待处理结果，后续的处理结果可以用回调的形式来处理。如果对那些不需要实时拿到结果的业务就很适合，可以提高整个系统的吞吐率<br>","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462721,"discussion_content":"总结的非常好！\n\n有一点需要改进一下，转账服务的实现中，异常处理的部分，还是需要先检查再补偿，否则有可能出现重复补偿的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565745637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552085,"discussion_content":"会出现机器的cpu、磁盘、内存都不高（因为等待的线程是不占CPU的）很多请求超时之类的情况。异步的话，就是让线程调用处理接口就直接返回\n\n个人的理解：\n系统资源的利用率不高，不代表剩下的资源你可以使用，比如，创建了很多的线程，cpu，内存等系统资源虽然利用率不高，但是系统已经没办法，再创建线程，这时线程成了限制瓶颈，导致请求超时，--- 创建线程也是需要分配占用资源的，但是这些资源是否被利用，则是另外一回儿事儿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645280731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123444,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1565678111,"is_pvip":true,"replies":[{"id":"45343","content":"👍👍👍","user_name":"作者回复","comment_id":123444,"uid":"1501046","ip_address":"","utype":1,"ctime":1565745307,"user_name_real":"李玥"}],"discussion_count":1,"race_medal":0,"score":"35925416479","product_id":100032301,"comment_content":"对于思考题:<br>1、应该可以通过编程式事物来保证数据的完整性。如何将错误结果返回给客户端，感觉这边和老师上次答疑网关如何接收服务端秒杀结果有点类似，通过方法回调，在回调方法中保存下转账成功或失败<br>2、在异步实现中，回调方法 OnComplete()在执行OnAllDone()回调方法的那个线程，可以通过一个异步线程池去控制回调方法的线程数，如Spring中的async就是通过结合线程池来实现异步调用<br>看了两遍才稍微有点思路，老师有空看看","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462676,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565745307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212209,"user_name":"沧浪之水","can_delete":false,"product_type":"c1","uid":1126491,"ip_address":"","ucode":"3819CB439BFB4C","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/5b/ed3b2211.jpg","comment_is_top":false,"comment_ctime":1588074916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27357878692","product_id":100032301,"comment_content":"一直有个困惑：异步可以解决io等待的问题，我感觉只是把等待的线程从业务线程转到异步框架线程了。最后的结果是，总有一个线程在io等待。 不是业务线程就是异步线程。 从整个机器来考虑，都是在消耗线程资源。  那怎么理解使用异步能够提升吞吐量呢，因为业务总是要有返回数据的。 数据在异步线程中等待，并不节约时间。 吞吐量的卡点还是io时间。 ","like_count":7},{"had_liked":false,"id":232640,"user_name":"王建坤","can_delete":false,"product_type":"c1","uid":1134287,"ip_address":"","ucode":"84F140AF468D1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/cf/21bea6bb.jpg","comment_is_top":false,"comment_ctime":1594077044,"is_pvip":false,"replies":[{"id":"86780","content":"这里说一下我的理解：<br><br>CompletableFuture还不能等完全同于ForkJoin。<br>可以简单的理解为<br><br>CompletableFuture.then() 等于 Fork<br>CompletableFuture.get() 等于 Join<br><br>但不是所有场景下，CompletableFuture都需要用get()结束的。也就是说，有时候是不需要调用阻塞的get()方法的。<br><br>另外，虽然CompletableFuture 默认使用 ForkJoinPool，但你完全可以给它提供一个自定义的执行器。","user_name":"作者回复","comment_id":232640,"uid":"1501046","ip_address":"","utype":1,"ctime":1594901642,"user_name_real":"李玥"}],"discussion_count":1,"race_medal":0,"score":"18773946228","product_id":100032301,"comment_content":"老师你好，CompletableFuture这种回调底层还是forkjoin框架，forkjoin对于io这种操作还是会阻塞线程，而且CompletableFuture默认线程数是与cpu核数一样的。在现在容器化的场景下，Cpu核数都不会很多（一般都是个位数），那么使用CompletableFuture是执行io操作是不是会更早的无响应？因为个位数的线程很快就都被阻塞了。","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500717,"discussion_content":"这里说一下我的理解：\n\nCompletableFuture还不能等完全同于ForkJoin。\n可以简单的理解为\n\nCompletableFuture.then() 等于 Fork\nCompletableFuture.get() 等于 Join\n\n但不是所有场景下，CompletableFuture都需要用get()结束的。也就是说，有时候是不需要调用阻塞的get()方法的。\n\n另外，虽然CompletableFuture 默认使用 ForkJoinPool，但你完全可以给它提供一个自定义的执行器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594901642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146244,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1572482932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14457384820","product_id":100032301,"comment_content":"这一篇写的有点歧义，我觉得举的例子主要是网络IO方面的情况，其实发送请求本身就是串行的，不论是回调还是阻塞发送，其实都是串行的，不同的是：同步等待这种情况是利用了当前线程栈，而异步发送时创建了新线程发送，而抛弃了原有线程。从CPU时间片利用效率来说，这两者没有区别，而且异步可能会更消耗CPU时间片，因为创建线程需要。再者网络IO时间也不会减少，吞吐量也不会增加，还是走了两趟。如果真的需要减少时间增加吞吐，那需要计算好结果发送给ADD，比如-100 +80 =-20 最后发送直接发-20即可。","like_count":3},{"had_liked":false,"id":131508,"user_name":"小祺","can_delete":false,"product_type":"c1","uid":1193548,"ip_address":"","ucode":"2819BCA9E71C9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/4c/46c43cce.jpg","comment_is_top":false,"comment_ctime":1567771396,"is_pvip":false,"replies":[{"id":"50414","content":"性能上没有区别。<br>区别是代码结构更清晰简单，易于维护。","user_name":"作者回复","comment_id":131508,"uid":"1501046","ip_address":"","utype":1,"ctime":1567991885,"user_name_real":"李玥"}],"discussion_count":1,"race_medal":0,"score":"14452673284","product_id":100032301,"comment_content":"老师，你用CompletableFuture这种方式跟我自己用一个固定大小的线程池去submit, 然后返回Future再get有什么本质的区别吗？吞吐量上呢？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466490,"discussion_content":"性能上没有区别。\n区别是代码结构更清晰简单，易于维护。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567991885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126446,"user_name":"timmy21","can_delete":false,"product_type":"c1","uid":1174860,"ip_address":"","ucode":"9D6DED247B1F38","user_header":"https://static001.geekbang.org/account/avatar/00/11/ed/4c/8674b6ad.jpg","comment_is_top":false,"comment_ctime":1566387229,"is_pvip":false,"replies":[{"id":"46822","content":"线程A在异步调用完账户服务后就可以结束了，不需要等待，响应可以由其他的线程负责返回给调用者，由于这个过程中不涉及任何具体的业务逻辑，是非常快的，可以认为瞬间就结束了。所以并不需要很多的线程。","user_name":"作者回复","comment_id":126446,"uid":"1501046","ip_address":"","utype":1,"ctime":1566436094,"user_name_real":"李玥"}],"discussion_count":1,"race_medal":0,"score":"14451289117","product_id":100032301,"comment_content":"我有一个困惑，客户端发起一个请求转账服务，此时转账服务会启动一个线程A处理该请求，然后转账再使用线程池异步调用账户服务。但是线程A还是存在，并等待处理结果的。我的问题来了，如果有10万个转账请求，转账服务还是最少开启10万个线程A的吧？","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463989,"discussion_content":"线程A在异步调用完账户服务后就可以结束了，不需要等待，响应可以由其他的线程负责返回给调用者，由于这个过程中不涉及任何具体的业务逻辑，是非常快的，可以认为瞬间就结束了。所以并不需要很多的线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566436094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123291,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1565657260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14450559148","product_id":100032301,"comment_content":"异步虽好，但使用场景有限！","like_count":3},{"had_liked":false,"id":208712,"user_name":"团子","can_delete":false,"product_type":"c1","uid":1103356,"ip_address":"","ucode":"42832AC5B3C535","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/fc/00af6446.jpg","comment_is_top":false,"comment_ctime":1587426368,"is_pvip":false,"replies":[{"id":"78323","content":"结合Netty或者NIO，是可以做到全异步的，不需要线程在阻塞等待响应。","user_name":"作者回复","comment_id":208712,"uid":"1501046","ip_address":"","utype":1,"ctime":1587691571,"user_name_real":"李玥"}],"discussion_count":1,"race_medal":0,"score":"10177360960","product_id":100032301,"comment_content":"老师，即使转账和账户服务都是异步，但是只是在我们代码端的异步，如果add方法设计到io传输，那completeablefuture中线程还是要block的把","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492588,"discussion_content":"结合Netty或者NIO，是可以做到全异步的，不需要线程在阻塞等待响应。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587691571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135749,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1569252375,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10159186967","product_id":100032301,"comment_content":"同步会有等待，导致线程没活干，CPU利用率低，但创建的大量线程占着内存等资源。如果换成异步，将一个任务切成多个片段，切点是IO阻塞的地方。维护一个线程池，当执行每一个片段时，从线程池取线程。这样，同样多任务，用更少线程数就可以，线程少了，线程等待时间少，利用率提高了。","like_count":2,"discussions":[{"author":{"id":1249970,"avatar":"https://static001.geekbang.org/account/avatar/00/13/12/b2/3fb9a4a1.jpg","nickname":"招财","note":"","ucode":"8A6781148A9932","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331269,"discussion_content":"等待的线程，也会占用一定的资源，所以不能让线程等待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606819844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131513,"user_name":"小祺","can_delete":false,"product_type":"c1","uid":1193548,"ip_address":"","ucode":"2819BCA9E71C9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/4c/46c43cce.jpg","comment_is_top":false,"comment_ctime":1567775984,"is_pvip":false,"replies":[{"id":"50417","content":"第一个问题，转入转出这两个操作不需要串行，是可以并行的。甚至执行顺序都没什么要求。我们唯一要保证的是这两个操作在一个事务中执行， “要么都成功，要么都失败”，就可以了。<br><br>你这个场景是在调用方（转账服务）异步，而服务提供方（账户服务）还是同步服务的情况下，才会出现。<br><br>你仔细看一下我们的异步设计，服务提供方提供的也是异步服务，那调用账户服务也是一瞬间就完成了，这样就不会出现你说的“几万个请求对象在CompletableFuture内部线程池内部还是排队”的情况了。<br><br>","user_name":"作者回复","comment_id":131513,"uid":"1501046","ip_address":"","utype":1,"ctime":1567992584,"user_name_real":"李玥"}],"discussion_count":1,"race_medal":0,"score":"10157710576","product_id":100032301,"comment_content":"老师，我理解异步是可以解决请求超时的问题，但是像文中举例这种转账操作，转出转入两个操作是前后依赖的没法并行，那么这种前后依赖的任务使用异步跟同步又有什么区别呢？<br>另外，当10万请求过来之后，虽然用了异步可以瞬间返回，但是其实几万个请求对象在CompletableFuture内部线程池内部还是排队啊，所以最后来的请求还是要等很久才能被执行到。那么既然同步or异步都需要排队，异步究竟快在哪里了呢？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466495,"discussion_content":"第一个问题，转入转出这两个操作不需要串行，是可以并行的。甚至执行顺序都没什么要求。我们唯一要保证的是这两个操作在一个事务中执行， “要么都成功，要么都失败”，就可以了。\n\n你这个场景是在调用方（转账服务）异步，而服务提供方（账户服务）还是同步服务的情况下，才会出现。\n\n你仔细看一下我们的异步设计，服务提供方提供的也是异步服务，那调用账户服务也是一瞬间就完成了，这样就不会出现你说的“几万个请求对象在CompletableFuture内部线程池内部还是排队”的情况了。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567992584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123603,"user_name":"谢清","can_delete":false,"product_type":"c1","uid":1069849,"ip_address":"","ucode":"31B2862A790CEB","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/19/dec74631.jpg","comment_is_top":false,"comment_ctime":1565711033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10155645625","product_id":100032301,"comment_content":"学习了，一点思路，欢迎老师点评<br>第一个问题：<br>两次add方法保持最终一致性，第一次add失败不在调用第二次，告知客户转账失败；第一次成功调第二次失败，告知用户：转账进行中，转账对象收款中；可设置补偿策略，还是失败的话，转账后台人工介入补偿，还是不行则人工还原账户金额并告知用户：转账失败<br>第二个问题：<br>笑傲流云的答案不错。结合前面课程，用流量控制也可实现","like_count":2},{"had_liked":false,"id":123393,"user_name":"亚洲舞王.尼古拉斯赵四","can_delete":false,"product_type":"c1","uid":1443078,"ip_address":"","ucode":"7159F5D7232696","user_header":"https://static001.geekbang.org/account/avatar/00/16/05/06/f5979d65.jpg","comment_is_top":false,"comment_ctime":1565666868,"is_pvip":false,"replies":[{"id":"45337","content":"A1：是的，异步方式下少量和大量请求都不需要等待执行结果。<br><br>A2： 在onComplete()方法中通知。","user_name":"作者回复","comment_id":123393,"uid":"1501046","ip_address":"","utype":1,"ctime":1565744743,"user_name_real":"李玥"}],"discussion_count":1,"race_medal":0,"score":"10155601460","product_id":100032301,"comment_content":"1.老师，能否解释一下为什么“使用异步编程模型之后，在少量请求之下，时延依旧是100ms，但是在大量请求之下，异步的实现不需要等待线程的执行结果”？少量请求不也不需要等待吗<br>2.如果使用异步方式实现，我的onComplete()方法在另一个线程里执行，我怎么通知我的客户端我执行成功还是失败呢？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462650,"discussion_content":"A1：是的，异步方式下少量和大量请求都不需要等待执行结果。\n\nA2： 在onComplete()方法中通知。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565744743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235004,"user_name":"tongZi","can_delete":false,"product_type":"c1","uid":2041790,"ip_address":"","ucode":"8BBAE4FA37FF79","user_header":"https://static001.geekbang.org/account/avatar/00/1f/27/be/b666abb4.jpg","comment_is_top":false,"comment_ctime":1594867474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889834770","product_id":100032301,"comment_content":"看到评论区大家的评论，发表一下自己的一些小观点，望指正<br>1、client调用transfer service，transfer然后异步调用account service；<br>transfer和client保持连接的线程大大减少了。<br>由于使用异步调用，达到线程上线时，减少了线程的创建等待，但是真正占用cpu时间片，的线程可以更多了；<br>像文中老师说的“服务器 CPU、网络带宽资源达到极限之前”，可以处理更多的任务，提高了cpu使用率","like_count":1},{"had_liked":false,"id":230668,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1593444583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5888411879","product_id":100032301,"comment_content":"异步模型与io多路复用原理类似。<br>存在瓶颈的资源可能是cpu，存储。操纵cpu的媒介是线程，而操纵存储的媒介是io。它俩是可以独立的。因此，理想情况下，很多次调用在进行io操作且比较耗时时，这些调用所占的线程无缘无故被阻塞，对应的cpu时间也被浪费。<br>解决方法就是在执行io操作时，释放线程，那么线程就可以去做其他事情，提高cpu执行效率。<br>当然，io执行完还是要线程去继续直行后续操作。<br>因此，这类做io操作的调用需要有一个订阅发布机制，当io执行完就去通知线程去执行下一步操作。<br>因此，订阅发布机制是异步的核心。类似于io多路复用吧。","like_count":1},{"had_liked":false,"id":127601,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1566747129,"is_pvip":false,"replies":[{"id":"47514","content":"实际生产系统中的转账服务，大部分都是异步的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566868067,"ip_address":"","comment_id":127601,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5861714425","product_id":100032301,"comment_content":"有个疑问，我觉得真正调用转账服务的线程应该还是会阻塞等待结果返回的吧，区别只是阻塞的是处理用户请求的线程还是ForkJoinPool的线程，除非操作系统支持真正的异步io，否则并发瓶颈应该还是存在的，不知道我的理解有没有问题。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464571,"discussion_content":"实际生产系统中的转账服务，大部分都是异步的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101234,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/b2/807137b9.jpg","nickname":"北方易初","note":"","ucode":"C57FDBD37F43E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561153,"discussion_content":"必须呀，你工商银行的钱，转到别人建设银行上，数据库都不在一个集群，怎么同步，肯定都是异步的，工商银行调用银联的服务，银联再调用农业银行的服务，然后再各种回调","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649562426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1255277,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDVXsv6JOOficLK07867AkAb21eoG5KBgYFmwhMXKJooU5B6iaIZwyDxExicokVQSiaKEwZ4qPicqVFcg/132","nickname":"拼yin世界","note":"","ucode":"9571428A12B72A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414736,"discussion_content":"我没看错吗？    生产中，转账服务，都是异步的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636880705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123335,"user_name":"木小柒","can_delete":false,"product_type":"c1","uid":1000802,"ip_address":"","ucode":"947439CDD0B5B1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/45/62/3c6041e7.jpg","comment_is_top":false,"comment_ctime":1565660047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860627343","product_id":100032301,"comment_content":"accountService如果本身是自己处理逻辑，那将其放入一个事务中就解决部分失败。如果调用三方服务，就比较麻烦。需要把两步操作都留存，失败的列表每天都要处理。<br><br>一般都有专门的异步线程池来运行异步task任务，比如spring 的async。","like_count":1},{"had_liked":false,"id":123290,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1565657229,"is_pvip":false,"replies":[{"id":"45335","content":"感谢指正，我尽快让编辑小姐姐改正。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565744315,"ip_address":"","comment_id":123290,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5860624525","product_id":100032301,"comment_content":"老师，转账例子代码中给转入账号加钱写错了吧","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462611,"discussion_content":"感谢指正，我尽快让编辑小姐姐改正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565744315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123265,"user_name":"白小白","can_delete":false,"product_type":"c1","uid":1400416,"ip_address":"","ucode":"143F1C8294818A","user_header":"https://static001.geekbang.org/account/avatar/00/15/5e/60/1c13626b.jpg","comment_is_top":false,"comment_ctime":1565656091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860623387","product_id":100032301,"comment_content":"嗯……第一遍有点懵……我再来两遍……再回答思考问题……","like_count":1},{"had_liked":false,"id":346438,"user_name":"云开","can_delete":false,"product_type":"c1","uid":1297758,"ip_address":"","ucode":"74541653336DDA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/nSvVtStiaQzslFM7YRnlhP7FxdVsz8abjlwY6XZ4guKtkXNUgG8EibxztoeosKL2YuxDsb159NTQhVXFBkj31kBw/132","comment_is_top":false,"comment_ctime":1653136097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653136097","product_id":100032301,"comment_content":"CompletableFuture的thenRun方法是同步的吧","like_count":0},{"had_liked":false,"id":344939,"user_name":"我的喵","can_delete":false,"product_type":"c1","uid":1736650,"ip_address":"","ucode":"A7435BDBDD2587","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyuuhxu0HH4cIKCClCqx0LTurCCYWmNcFwfTWV5te5afsibp2yuDmC9mibEHx0Xy8QlvqvMWWcAib8g/132","comment_is_top":false,"comment_ctime":1651888732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651888732","product_id":100032301,"comment_content":"异步之所有能够提升系统吞吐，是因为在同步模式下，线程由于阻塞导致无法接收更多的请求，从而CPU也无法得到充分利用；如果使用异步模式，接收请求的线程由于收到请求后将业务逻辑扔到另外一个线程池后，直接返回，进而可以接收更多的请求，而那个处理业务逻辑的线程池中线程由于阻塞释放出CPU的同时，其他线程可以接管继续处理，因为最大化的提升了CPU的利用率","like_count":0},{"had_liked":false,"id":340739,"user_name":"再见理想","can_delete":false,"product_type":"c1","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1649087624,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649087624","product_id":100032301,"comment_content":"异步处理通过减少线程等待占用的cup时间片提升cpu时间片的利用率。<br>思考题：<br>第一步扣减失败的话，直接返回客户端失败，流程结束。<br>第二部增加失败，可以选择重试，重试一定次数后，仍然失败后，可以对第一步进行冲正处理。<br><br>","like_count":0},{"had_liked":false,"id":335064,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1645281559,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645281559","product_id":100032301,"comment_content":"看了不少的评论，感觉大家对操作系统这块都不是很熟悉，还是好好学习下操作系统吧，当然我是菜鸟，也需要好好学习。<br><br>还是说下个人的理解：<br>&quot;会出现机器的cpu、磁盘、内存都不高（因为等待的线程是不占CPU的）很多请求超时之类的情况。异步的话，就是让线程调用处理接口就直接返回&quot; -- 这是下面某个网友的评论的一段话<br><br>系统资源的利用率不高，不代表那些系统资源你可以使用。<br>比如，并发请求，导致创建了很多的线程来处理，结果是，cpu，内存等系统资源虽然利用率不高，但是系统已经没办法，再创建线程，这时线程成了限制瓶颈，导致请求超时 --- 创建线程也是需要分配占用资源的，但是这些资源是否被利用，则是另外一回儿事儿，尽管线程等待的时候，会让出CPU，但是内存等系统资源，并不会让出，被系统回收，所以成为了限制瓶颈。------ 供参考","like_count":1},{"had_liked":false,"id":327678,"user_name":"scwyfy","can_delete":false,"product_type":"c1","uid":1762148,"ip_address":"","ucode":"F4AE8D4A315B0C","user_header":"","comment_is_top":false,"comment_ctime":1640230156,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1640230156","product_id":100032301,"comment_content":"老师，有个疑惑，异步回调通知，是怎么能从后台通知到前台的呢（轮询查询吗）","like_count":0,"discussions":[{"author":{"id":1621432,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WxLKJlXCibwqO92vB8XTicLQiahrhuUEqP7yT9dearZxLzbia7oMdsLmon5J4LJyTfIWchHY3bKfibm1lS1aZarZs4Q/132","nickname":"jie","note":"","ucode":"E93A1818AB2459","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543569,"discussion_content":"前台注册了回调\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641207190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324716,"user_name":"达叔灬","can_delete":false,"product_type":"c1","uid":2404887,"ip_address":"","ucode":"5CCBAF13548F02","user_header":"https://static001.geekbang.org/account/avatar/00/24/b2/17/3161b49c.jpg","comment_is_top":false,"comment_ctime":1638585736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638585736","product_id":100032301,"comment_content":"说下 netcore的TPL 任务库 。web应用中 调用程序异步调用方法（await method）的时候 会从线程池中调用其它线程执行 主线程会丢到线程池中执行其它任务，方法执行完后 会线程池会收到通知 然后从池中选派一个线程去执行接下来的操作。","like_count":0},{"had_liked":false,"id":305331,"user_name":"我麋鹿啦","can_delete":false,"product_type":"c1","uid":1251124,"ip_address":"","ucode":"C2BEADC2FEA35A","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/34/86e6c003.jpg","comment_is_top":false,"comment_ctime":1627908845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627908845","product_id":100032301,"comment_content":"例如请求处理时间划分是ABCB，其中B是请求下游的时间，也就是线程等待时候，其中AC是线程忙碌时间。例如请求处理时间划分是ABCB，其中B是请求下游的时间，也就是线程等待时候，其中AC是线程忙碌时间。<br><br>&#47;&#47;同步情况，处理四次请求，用了两个线程。其中横看是时间轴，分别为时刻一、时刻二、时刻三... ...<br>线程A.   ABCBABCB<br>线程B.   ABCBABCB<br>      <br>&#47;&#47;异步情况 处理四次请求，用了一个线程。提高了线程的利用率。<br>线程A.   ABCBABCB<br>线程A.     ABCBABCB","like_count":0},{"had_liked":false,"id":298624,"user_name":"八宝","can_delete":false,"product_type":"c1","uid":1324501,"ip_address":"","ucode":"89D991A930FDEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/35/d5/17833946.jpg","comment_is_top":false,"comment_ctime":1624241455,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1624241455","product_id":100032301,"comment_content":"优化前属于多线程同步串行模型，网络 i&#47;o 处理时线程阻塞会出现CPU资源闲置。瓶颈是线程数量有上限(go可用此模型，起N多goroutine，百万easy)；<br>优化思路：网络 i&#47;o 用多路复用(reactor)--少量线程 i&#47;o 事件监听(eventloop)；计算处理用多核并行(核心数相当的多线程); 用异步模型衔接彼此，根据任务特点划分不同的处理资源。<br>整体上来说，减少线程数量，提高资源利用率","like_count":0},{"had_liked":false,"id":295964,"user_name":"LQS  KF","can_delete":false,"product_type":"c1","uid":1364737,"ip_address":"","ucode":"3C0A07A8220094","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/01/716d45b6.jpg","comment_is_top":false,"comment_ctime":1622684984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622684984","product_id":100032301,"comment_content":"同步: 主线程在等待rpc结果返回<br>异步：主线程将等待rpc结果返回的事情交给io线程，主线程可以去执行下面的事情<br>异步能提升下面两点：<br>      1. 若多个io线程异步任务无关联，则可以并行执行(多cpu)，有效的减少rt<br>      2. 若io线程异步任务有关联，则解放了主线程，此时可以执行其他的任务。","like_count":0},{"had_liked":false,"id":269597,"user_name":"刘大人","can_delete":false,"product_type":"c1","uid":1577210,"ip_address":"","ucode":"F66AE613E80398","user_header":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","comment_is_top":false,"comment_ctime":1608709259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608709259","product_id":100032301,"comment_content":"异步相比与同步的优势在于：同步等待的时间被异步的方式拿来接受新的请求了。因此相同线程的数量下，异步支持的并发和吞吐量都高的多。","like_count":0},{"had_liked":false,"id":250257,"user_name":"Cyber","can_delete":false,"product_type":"c1","uid":1613123,"ip_address":"","ucode":"A7842494F57D0C","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/43/bf628743.jpg","comment_is_top":false,"comment_ctime":1601004478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601004478","product_id":100032301,"comment_content":"public void syncInvoke() throws ExecutionException, InterruptedException { &#47;&#47; 同步调用 transferService.transfer(A, B, 100).get(); System.out.println(&quot;转账完成！&quot;); } public void asyncInvoke() { &#47;&#47; 异步调用 transferService.transfer(A, B, 100) .thenRun(() -&gt; System.out.println(&quot;转账完成！&quot;)); }  这里我觉得都是同步调用， 都是执行完转账操作后才再控制台打印“转账完成”","like_count":0},{"had_liked":false,"id":234990,"user_name":"tongZi","can_delete":false,"product_type":"c1","uid":2041790,"ip_address":"","ucode":"8BBAE4FA37FF79","user_header":"https://static001.geekbang.org/account/avatar/00/1f/27/be/b666abb4.jpg","comment_is_top":false,"comment_ctime":1594864114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594864114","product_id":100032301,"comment_content":"在没有学习评论区回答前，先尝试回答一下思考题<br>第一个思考题：<br>a、<br>异步执行，目前理解，已经和客户端断开连接<br>客户端如果想得到错误报告<br>第一种：客户端主动轮询，但是感觉对性能损耗较大；如果此时转账的并发很高，对于每一个转账服务，都要开启一个线程轮询，可能会导致服务异常<br>第二种：维护转账记录结果页；用户可以在转账记录页，查看自己的转账记录，以及失败的原因<br>b、<br>为转账服务加入事务<br>如果第一次转账服务，失败直接回滚，双方数据是平的<br>第二次异步调用转账服务时，失败；此时已经和第一次转账无关了，首先想到是放入消息队列进行重试；或者放入重试表；但是感觉这么做很有风险，如果重试都不成功；而且这样延迟比较大，用户也接受不了<br>第二个思考题<br>暂时触及知识盲区，评论区学习","like_count":0},{"had_liked":false,"id":219012,"user_name":"Roger宇","can_delete":false,"product_type":"c1","uid":1703222,"ip_address":"","ucode":"CBA23C01409349","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","comment_is_top":false,"comment_ctime":1589933205,"is_pvip":false,"replies":[{"id":"81468","content":"一般都会设定一个超时时间来解决这个问题。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1590369928,"ip_address":"","comment_id":219012,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589933205","product_id":100032301,"comment_content":"老师，关于异步编程模型还是有一些疑问。异步模型处理请求的线程将实际业务逻辑的处理提交给专门的工作线程后就返回了，那如果工作线程最终无法完成任务该怎么办呢？同步模式下可以给调用方报错，异步下已经返回给调用方，任务已经做了，之后这个请求已经结束了，如果实际任务没有成功要怎么办呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495651,"discussion_content":"一般都会设定一个超时时间来解决这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590369928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217465,"user_name":"贺宇","can_delete":false,"product_type":"c1","uid":1445040,"ip_address":"","ucode":"55854825CC4AD2","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/b0/26c0e53f.jpg","comment_is_top":false,"comment_ctime":1589509069,"is_pvip":true,"replies":[{"id":"80856","content":"确实是不太容易理解。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1589869332,"ip_address":"","comment_id":217465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589509069","product_id":100032301,"comment_content":"CompletableFuture太不好编写，原来看的时候真的是感觉头发要掉光了","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495157,"discussion_content":"确实是不太容易理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589869332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215706,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1589080563,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589080563","product_id":100032301,"comment_content":"消息队列，日志流，我看来都是为了让大型系统的处理的串行化。框架和组件都是为了规避系统本身的并发和异步，让业务处理代码回归到最朴素的线性串行的代码。即使不能完全规避并发和异步，也要让异步和并发尽量少发生。","like_count":0},{"had_liked":false,"id":215697,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1589079789,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1589079789","product_id":100032301,"comment_content":"业务代码层面的异步都是垃圾，完全无视业务开发人员的辛苦，做这些框架的更是垃圾，自以为自己的框架多么牛逼。微信的libco，完全秒杀了腾讯内部的一切异步框架。c++层面都可以做到的，其它js和java还有rust搞一堆async，await，我都完全搞不懂那些人是在干嘛，炫技吗。协程和异步框架都开发过，但做业务开发的时候，有谁喜欢异步框架。并发和异步的事情，完全应该是框架应该屏蔽的细节，让异步的复杂性扩散到业务代码上就是作恶。业务流上的异步才是对用户有意义的，这种代码上的假异步只是掩盖框架的不足。","like_count":0,"discussions":[{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338840,"discussion_content":"暴躁老哥在线开喷😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609398883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190862,"user_name":"极客雷","can_delete":false,"product_type":"c1","uid":1041465,"ip_address":"","ucode":"0DBAC4CB9C7BCD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/39/a06ade33.jpg","comment_is_top":false,"comment_ctime":1584700329,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584700329","product_id":100032301,"comment_content":"同步才是正常思维，异步才是想要性能","like_count":0},{"had_liked":false,"id":154291,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574405077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574405077","product_id":100032301,"comment_content":"不觉明历<br>","like_count":0},{"had_liked":false,"id":153927,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574332500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574332500","product_id":100032301,"comment_content":"看不懂<br>","like_count":0},{"had_liked":false,"id":151611,"user_name":"Tulane","can_delete":false,"product_type":"c1","uid":1242467,"ip_address":"","ucode":"E1F5108B9E738F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/63/53639bb7.jpg","comment_is_top":false,"comment_ctime":1573750045,"is_pvip":false,"replies":[{"id":"58294","content":"你举的那个微服务异步调用的例子是没问题的，但它和单机还是远程调用没关系，单机同样可以做异步调用。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1573779700,"ip_address":"","comment_id":151611,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573750045","product_id":100032301,"comment_content":"老师我还有点疑问想确认下, 望解答.<br>如果就是在单机环境下, 不是微服务的话, 是不是说同步与异步调用, 其实是一致的, 异步并不会缩短线程等待时间<br>因为同一时间下, 同步与异步, 都是有一个线程去跑service的, 线程不会处于无用的等待状态, 而是一直在处理任务<br>而在微服务下, 一个方法调取另一个服务的方法, 从时间片上来看, 就是在同一时间产生了两个线程, 原方法的线程在等待, 而另一个服务的线程在执行. 微服务下的异步可以优化掉上一个等待线程.","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474555,"discussion_content":"你举的那个微服务异步调用的例子是没问题的，但它和单机还是远程调用没关系，单机同样可以做异步调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573779700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144777,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":1595382,"ip_address":"","ucode":"A77322C4E07B2D","user_header":"https://static001.geekbang.org/account/avatar/00/18/57/f6/2c7ac1ad.jpg","comment_is_top":false,"comment_ctime":1572056101,"is_pvip":false,"replies":[{"id":"55898","content":"是的，就是这个意思。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1572141805,"ip_address":"","comment_id":144777,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572056101","product_id":100032301,"comment_content":"异步的处理方式我理解跟现实生活里的流水线类似，比如一共有10个工人（对应于线程），把货车上的东西搬到仓库里，那如果每个人跳上车搬起货物，然后再下车，再走进仓库，这个时间很大程度上都浪费在了路上（也就是线程等待），那如果流水线式的工作，几个人专门负责把货物从车上搬下来，其余人负责吧货物搬进仓库，这样的话效率就较高了，这只是我个人的理解，不知道对不对","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472108,"discussion_content":"是的，就是这个意思。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572141805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138637,"user_name":"开心小毛","can_delete":false,"product_type":"c1","uid":1023762,"ip_address":"","ucode":"9D57A2773759F3","user_header":"","comment_is_top":false,"comment_ctime":1570387760,"is_pvip":false,"replies":[{"id":"53485","content":"你说的“同步非阻塞”什么情况呢？在我的理解，非阻塞就是异步。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1570497873,"ip_address":"","comment_id":138637,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1570387760","product_id":100032301,"comment_content":"为什么不用同步非阻塞呢？老师文中的Add微服务是不是单纯的慢，但吞吐能力足够，我可以这样理解么？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469602,"discussion_content":"你说的“同步非阻塞”什么情况呢？在我的理解，非阻塞就是异步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570497873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126757,"discussion_content":"首先明确同步和异步的区别：同步调用者是自己去拿执行结果，异步是执行者通过回调把结果塞给调用者。同步非阻塞应该是transfer线程自己轮训add服务的结果，直到得到add成功或失败为止。两次轮训期间如果什么都不做就是阻塞，如果再去受理下一个add服务就是非阻塞。\n同步非阻塞的好处是可以自己控制执行结果的获取和补偿逻辑，如超时重试或回滚；坏处是轮训和结果处理逻辑占用了cpu时间片，降低了调用者的吞吐量。\n异步非阻塞的结果处理全看回调，对执行结果的掌控降低，但简化了调用者的职责，提升了调用者的吞吐量。\n看场景选择吧，没有放之四海而皆准的模式。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578535974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485489,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/b1/c834aab5.jpg","nickname":"张小勋","note":"","ucode":"8C5E434EF53BF4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37545,"discussion_content":"看了很多文章  异常非阻塞的方式 是最优的~  同步 非同步 关心的应该是  是否要等待Add 减服务的结果 才能继续执行Add 加服务~  阻塞 非阻塞 是关心的线程的状态  在等待过程中 线程 是否是阻塞的状态~ 这个如果是同步非阻塞  那线程不是要一直检查Add 服务的结果   感觉还是异步通知的 异步非阻塞 是最好~ 不知道说的对不对~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571632407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25310,"discussion_content":"我说的同步非阻塞是指的Transfer服务的调用者是会被阻塞的（transfer服务一定是异步调用Add服务的，这个我同意）例如transfer 服务可以写成reactor，用非阻塞socket将收到的链接请求生成相应的handler并dispatch给add服务异步处理，但相应的链接直到handler被add服务回调之前一直是同步阻塞的。\n请老师比较一下我上面说的同步非阻塞调用transfer与文中异步调用Transfer的优劣，多谢老师咯。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570499644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137301,"user_name":"姑射仙人","can_delete":false,"product_type":"c1","uid":1008517,"ip_address":"","ucode":"3EFC1F3E592165","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","comment_is_top":false,"comment_ctime":1569681863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569681863","product_id":100032301,"comment_content":"看了大家的讨论，此处的异步执行应该也有一点意义，就算netty处理了所有的异步，那也是在网络传输层的异步。在业务层面，到最终发起tcp请求前也干了好多事，如果能异步处理也是好的。个人浅见。","like_count":0},{"had_liked":false,"id":133776,"user_name":"逍遥子","can_delete":false,"product_type":"c1","uid":1127109,"ip_address":"","ucode":"777CF0635970E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/c5/38a59795.jpg","comment_is_top":false,"comment_ctime":1568652041,"is_pvip":false,"replies":[{"id":"51341","content":"同学你说的内容我们会在下一节课讲。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1568684264,"ip_address":"","comment_id":133776,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568652041","product_id":100032301,"comment_content":"这里的异步不止是业务代码上的异步吧？是不是用到了网络编程io模型中的同步非阻塞模型呢？拿多路复用模型来说，应用进程向操作系统内核发起select命令请求数据，内核创建去向另外一台机器发起tcp连接。内核获取到数据通知应用进程，进程向内核发起recvfrom命令将数据从内核拷贝到用户空间，拷贝完成应用进程就能读取到数据。<br>不知这里的异步用的是哪种模型呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467503,"discussion_content":"同学你说的内容我们会在下一节课讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568684264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126585,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566433509,"is_pvip":false,"replies":[{"id":"46828","content":"回答你的问题，异步具体是怎么实现的？<br><br>安红.嫁给我吧(然后安红你要干啥看这里());<br><br>func 然后安红你要干啥看这里()<br>  if(不同意）<br>    给我打个电话让我哭死吧。<br>  else<br>    准备婚礼，摆酒，拍婚纱照balabala.....<br><br><br>也就是说后面的事儿都丢给安红来做了。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566436933,"ip_address":"","comment_id":126585,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1566433509","product_id":100032301,"comment_content":"课后思考及问题<br>1：什么是同步？<br>大望：安红嫁给我吧——等待回复，然后准备婚礼<br><br>2：什么是异步？<br>大望：安红嫁给我吧——然后准备婚礼，回复不嫁，则哭死，嫁，则婚礼事宜也准备好了<br><br>3：同步和异步的区别？<br>同步——正常的人思维，简单直接，但会被等待阻塞<br>异步——想要更快，不等待回复，直接进行下一步，等待通知是否OK，若OK，则皆大欢喜，提高了速度，否则要想好怎么收场，有点费事<br><br>4：常说异步比同步快，那她快在哪里？<br>异步快就快在不等慢人，所以，合作起来烦人一点<br>同步更易合作，代价就是要等一等肉喇叭几的人<br>想要走的更快就一个人走，想要走的更远就一群人走——异步单独走确实更快，但异步还想一群人走，那就容易出问题啦！<br><br>5：异步是怎么实现的？<br>这个需要老师回答一下，感觉文中只是讲了明面上异步大概怎么实现的，水下的动作没有讲。<br>比如：异步说是发个命令执行某个动作，那发给谁了？那个动作什么时候执行完，总需要人监控着吧？不然谁知道啥时候执行完？另外，即使执行完了，什么时候通知？怎么通知？通知谁？如果通知她的时候，她正在忙怎么办？是等待还是打断强行通知？另外，我觉得问题的根源在于，处理速度有差异，有了阶级什么事就需要分出个三六九等，就需要兼顾平等、效率，因为无论如何大家是有速度差的，有都生活在一块不得不分工协作。<br>希望，老师就以上问题，能在细致的回答一下，多谢！<br><br>6：异步的使用原则<br>1：异步虽快，也不要贪多哟——能不用，就不用<br>2：前后结果有依赖，不可用<br>3：复杂系统，不建议用，会增加维护成本<br>4：尽量坚守第一条","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464071,"discussion_content":"回答你的问题，异步具体是怎么实现的？\n\n安红.嫁给我吧(然后安红你要干啥看这里());\n\nfunc 然后安红你要干啥看这里()\n  if(不同意）\n    给我打个电话让我哭死吧。\n  else\n    准备婚礼，摆酒，拍婚纱照balabala.....\n\n\n也就是说后面的事儿都丢给安红来做了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566436933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099875,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c8/63/f94f9fda.jpg","nickname":"smily","note":"","ucode":"E2FDA059724A02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168458,"discussion_content":"好好看看I/O同步，异步，多路复用模型在说异步同步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581582556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128508,"discussion_content":"线程1：安红，嫁给我(godtrue)吧(run()), 请回复我(callback)，线程结束返回线程池；红安，嫁给我吧(下一个run()), 请回复我(下一个callback)，线程结束返回线程池；....\n线程2：不同意，给godtrue打电话(安红调用callback)，线程结束返回线程池；\n线程3：同意，给godtrue打电话(红安调用callback)，线程结束返回线程池；\n发现没有，callback的调用已经和线程1没有一毛钱关系了，只和godtrue有关系，线程1就是异步执行，线程2、3就是返回执行结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578645609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5719,"discussion_content":"😂，老师，比喻我是完全能明白的，我感觉好多事情应该是OS来操刀的，我对这块不清楚，对我像个小黑盒，我希望老师讲解一下这一块。估计一句两句说不清，但这个非常重要，我回头课下再补补吧!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566444876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1493899,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/hWjwsc6FgZfNkKiacOSUZicscNGFgdqvoo08QFQlfrg39srZJlZicbBP9zsLcDnKAkBfia2lZoKJ8h7QwTYiboiaRT6g/132","nickname":"成都小郭","note":"","ucode":"4399AA8C64DF21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16264,"discussion_content":"异步不是立即执行,而是给一个执行的内容,等回调之后执行..我都看插了,老师解释了才反应过来 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568880067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5719,"ip_address":""},"score":16264,"extra":""}]}]},{"had_liked":false,"id":125957,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1566282832,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1566282832","product_id":100032301,"comment_content":"单个线程，其实同步和异步都没啥区别，但是多线程情况下，因为只有一个CPU，处理每个阻塞线程的询问请求都会涉及到不同线程上下文的切换乃至用户态、核心态的转换，这才是最耗时的。","like_count":0,"discussions":[{"author":{"id":1581390,"avatar":"https://static001.geekbang.org/account/avatar/00/18/21/4e/363b1e65.jpg","nickname":"Andrew胖虎","note":"","ucode":"ED70A22E7DF733","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344071,"discussion_content":"单cpu，多线程还是有用武之地的，甚至是多进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611280519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125917,"user_name":"缺点就是太吊","can_delete":false,"product_type":"c1","uid":1194596,"ip_address":"","ucode":"5B8021C96815DB","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/64/3435b5fc.jpg","comment_is_top":false,"comment_ctime":1566271389,"is_pvip":false,"replies":[{"id":"46500","content":"这样做是可以的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566349897,"ip_address":"","comment_id":125917,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566271389","product_id":100032301,"comment_content":"我在想，转账操作是原子操作，我们可不可以直接通过amountService定义转账方法，通过数据库事务保证，amountService.transfer(fromAccount, toAccount, money);transerService只是简单委托accountService","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463749,"discussion_content":"这样做是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566349897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124256,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1565845925,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1565845925","product_id":100032301,"comment_content":"老师文章末尾留的问题都不错，希望老师在下一篇文章结尾处给出老师的答案供参考，谢谢","like_count":0},{"had_liked":false,"id":124011,"user_name":"monalisali","can_delete":false,"product_type":"c1","uid":1299521,"ip_address":"","ucode":"1FDEC87C133E28","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJbh5FQajwKhNlMrkoSklPpOXBtEYXCLvuWibhfWIS9QxHWDqzhEHJzEdmtUiaiaqFjfpsr2LwgNGpbQ/132","comment_is_top":false,"comment_ctime":1565791162,"is_pvip":false,"replies":[{"id":"45711","content":"这个问题异步解决不了。如果说真的cpu或者磁盘占用率达到100%了，并且你的代码逻辑没什么问题，那这就是程序的极限了。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565916716,"ip_address":"","comment_id":124011,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1565791162","product_id":100032301,"comment_content":"老师，问个问题：如何CPU和内存占有率都很高，用异步可以解决吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462956,"discussion_content":"这个问题异步解决不了。如果说真的cpu或者磁盘占用率达到100%了，并且你的代码逻辑没什么问题，那这就是程序的极限了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565916716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299521,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJbh5FQajwKhNlMrkoSklPpOXBtEYXCLvuWibhfWIS9QxHWDqzhEHJzEdmtUiaiaqFjfpsr2LwgNGpbQ/132","nickname":"monalisali","note":"","ucode":"1FDEC87C133E28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5087,"discussion_content":"那是不是就应该上负载均衡了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565936090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1299521,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJbh5FQajwKhNlMrkoSklPpOXBtEYXCLvuWibhfWIS9QxHWDqzhEHJzEdmtUiaiaqFjfpsr2LwgNGpbQ/132","nickname":"monalisali","note":"","ucode":"1FDEC87C133E28","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415040,"discussion_content":"不是 这个时候意味着你的负载资源已经全部拉满 。要拆资源了 如果线上紧急的话确实是可以用nginx+上云机器先扛一波。\n治本还是要分拆 假设此时你吞吐量、时延、系统指标都已经不能再压榨了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636969508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5087,"ip_address":""},"score":415040,"extra":""}]}]},{"had_liked":false,"id":124007,"user_name":"monalisali","can_delete":false,"product_type":"c1","uid":1299521,"ip_address":"","ucode":"1FDEC87C133E28","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJbh5FQajwKhNlMrkoSklPpOXBtEYXCLvuWibhfWIS9QxHWDqzhEHJzEdmtUiaiaqFjfpsr2LwgNGpbQ/132","comment_is_top":false,"comment_ctime":1565790770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565790770","product_id":100032301,"comment_content":"思考题一：<br>可以写一个兜底函数类似与catch，所有异常都走到这个函数中。然后通过传入catch的参数来判断错误类型，并决定后续操作<br><br>转入方法也类似，先判断下转出方法是否成功，成功了再执行。","like_count":0},{"had_liked":false,"id":123746,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1565750017,"is_pvip":false,"replies":[{"id":"45708","content":"你说的“StreamingData“指的是Lambda表达式还是流计算，或是其他什么技术呢？能具体说一下吗？","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565916385,"ip_address":"","comment_id":123746,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1565750017","product_id":100032301,"comment_content":"老师能否对比一下异步和StreamingData，据说StreamingData可以让线程使用率更高，效率比异步处理也更高，这是怎么实现的？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462795,"discussion_content":"你说的“StreamingData“指的是Lambda表达式还是流计算，或是其他什么技术呢？能具体说一下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565916385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165364,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","nickname":"海罗沃德","note":"","ucode":"8704F1D6980FA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5327,"discussion_content":"流式計算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566181061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123696,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1565744405,"is_pvip":false,"replies":[{"id":"45350","content":"是的，一般都会使用线程池。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565746151,"ip_address":"","comment_id":123696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565744405","product_id":100032301,"comment_content":"异步实现里面还是要用线程池限制一下线程数吧，否则没有达到减少线程的效果","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462775,"discussion_content":"是的，一般都会使用线程池。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565746151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123465,"user_name":"DAV 🍃","can_delete":false,"product_type":"c1","uid":1614531,"ip_address":"","ucode":"47A6A7B1D997FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/a2/c3/83545c57.jpg","comment_is_top":false,"comment_ctime":1565681958,"is_pvip":false,"replies":[{"id":"45344","content":"可以继续学习后面的课程，我们会有相应的源码分析。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565745356,"ip_address":"","comment_id":123465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565681958","product_id":100032301,"comment_content":"请教一下，在整个消息队列的场景里面怎么融合异步调用？举例，A发送消息到消息队列，消费进程处理后如何通过回调形式返回结果给A? ","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462685,"discussion_content":"可以继续学习后面的课程，我们会有相应的源码分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565745356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123411,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1565670427,"is_pvip":false,"replies":[{"id":"45341","content":"第一，OnDebit()和OnAllDone()可以在同一个线程中执行。没必要每个回调方法都开启一个新的线程。<br><br>第二，由于不需要等待，执行每个异步方法的耗时会非常短。<br><br>第三，可以使用线程池来避免反复创建销毁线程的开销，所以只需要很少的线程。<br><br>最后一个问题，“通知转账成功”这个业务逻辑，不一定非得在接收请求的那个线程里面执行，可以直接在OnAllDone()里面通知转账成功。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565745259,"ip_address":"","comment_id":123411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565670427","product_id":100032301,"comment_content":"老师，请教个问题，吞吐量增加可以理解，因为请求发生后就直接返回了，从而避免了后续等待的延时；但是，以今天内容为例：<br>1、TransferAsync请求发生，直接返回，并开启新线程处理OnDebit函数；<br>2、OnDebit处理完毕，开启新线程处理OnAllDone函数；<br>3、OnAllDone函数处理完毕；<br>那么，从宏观来看，线程数量是不是要比同步多很多？<br>还有一个问题，调用方如何得知转账成功？前台开启一个新线程去轮询吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462662,"discussion_content":"第一，OnDebit()和OnAllDone()可以在同一个线程中执行。没必要每个回调方法都开启一个新的线程。\n\n第二，由于不需要等待，执行每个异步方法的耗时会非常短。\n\n第三，可以使用线程池来避免反复创建销毁线程的开销，所以只需要很少的线程。\n\n最后一个问题，“通知转账成功”这个业务逻辑，不一定非得在接收请求的那个线程里面执行，可以直接在OnAllDone()里面通知转账成功。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565745259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123401,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1565668011,"is_pvip":false,"replies":[{"id":"45339","content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565744843,"ip_address":"","comment_id":123401,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565668011","product_id":100032301,"comment_content":"如何将错误报告给客户端？<br>javascript中用.catch捕获异常<br><br>在两次调用账户服务的 Add 方法时，如果某一次调用失败了，该如何处理才能保证账户数据是平的？<br>事务补偿","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462656,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565744843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123328,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1565659735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565659735","product_id":100032301,"comment_content":"1.提个问题，为什么要1w个线程？java的线程模型不是1:1的吗，实际在跑的线程仅有核数*2，1w这个数量不是造成了内存浪费和上下文切换成本吗。<br>2.异步异常回传，并传回当前操作绑定在线程本地空间的事务实例。只有当两次都成功才提交两个add的事务。（事务不能声明，只能手动开启和提交了）","like_count":0},{"had_liked":false,"id":123325,"user_name":"大魔王汪汪","can_delete":false,"product_type":"c1","uid":1010680,"ip_address":"","ucode":"4B205CB52FC95F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","comment_is_top":false,"comment_ctime":1565659186,"is_pvip":false,"replies":[{"id":"45336","content":"一般是传一个回调方法，就像我们这节课讲的那样。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565744532,"ip_address":"","comment_id":123325,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1565659186","product_id":100032301,"comment_content":"jdk1.8之前没有completablefuture应该用什么搞异步呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462622,"discussion_content":"一般是传一个回调方法，就像我们这节课讲的那样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565744532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372348,"discussion_content":"可以用guava的 或者自己用个map接住这些Future 再一个个取出来。事实上kafka这类就是这么做的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620293516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052195,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0e/23/205b6f9a.jpg","nickname":"一","note":"","ucode":"8DE197959E7FC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4767,"discussion_content":"future","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565708133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1010680,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","nickname":"大魔王汪汪","note":"","ucode":"4B205CB52FC95F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1052195,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0e/23/205b6f9a.jpg","nickname":"一","note":"","ucode":"8DE197959E7FC7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5396,"discussion_content":"这种不是非阻塞的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566225956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4767,"ip_address":""},"score":5396,"extra":""}]}]},{"had_liked":false,"id":123317,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1565658661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565658661","product_id":100032301,"comment_content":"   其实异步减少的是等待时间。关于第一个思考题：调用失败是不是就可以抛出error，直接不执行第一步；代码中是否少了相应的查询操作进行核对啊，否则万一就根本没有执行成功呢。操作完成后相应的查询核对应当时候放到了后面吧：有问题再进行相应的类似于回滚之类的操作。<br>    第二个问题oncomplete()在什么线程中执行这个不是很清楚：不过我觉得可以通过线程去控制回调方法的执行线程数，具体实现方式就暂时还没想到。","like_count":0},{"had_liked":false,"id":123307,"user_name":"HadesFX","can_delete":false,"product_type":"c1","uid":1052835,"ip_address":"","ucode":"221590B6D85266","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/a3/25e48834.jpg","comment_is_top":false,"comment_ctime":1565658024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565658024","product_id":100032301,"comment_content":"1.可以增加异步调用后的返回值用来判断是否成功。<br>2.应该是存在一个默认线程池，使用线程池中的线程，可能存在一个配置自定义线程池的方法用来定制控制数量。<br>不知道理解的对不对。","like_count":0}]}