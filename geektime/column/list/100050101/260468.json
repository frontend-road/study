{"id":260468,"title":"33 | GroupCoordinator：在Rebalance中，如何进行组同步？","content":"<p>你好，我是胡夕。今天，我们继续学习消费者组Rebalance流程，这节课我们重点学习这个流程的第2大步，也就是组同步。</p><p>组同步，也就是成员向Coordinator发送SyncGroupRequest请求，等待Coordinator发送分配方案。在GroupCoordinator类中，负责处理这个请求的入口方法就是handleSyncGroup。它进一步调用doSyncGroup方法完成组同步的逻辑。后者除了给成员下发分配方案之外，还需要在元数据缓存中注册组消息，以及把组状态变更为Stable。一旦完成了组同步操作，Rebalance宣告结束，消费者组开始正常工作。</p><p>接下来，我们就来具体学习下组同步流程的实现逻辑。我们先从顶层的入口方法handleSyncGroup方法开始学习，<strong>该方法被KafkaApis类的handleSyncGroupRequest方法调用，用于处理消费者组成员发送的SyncGroupRequest请求</strong>。顺着这个入口方法，我们会不断深入，下沉到具体实现组同步逻辑的私有化方法doSyncGroup。</p><h2>handleSyncGroup方法</h2><p>我们从handleSyncGroup的方法签名开始学习，代码如下：</p><!-- [[[read_end]]] --><pre><code>def handleSyncGroup(\n  groupId: String,  // 消费者组名\n  generation: Int,  // 消费者组Generation号\n  memberId: String,  // 消费者组成员ID\n  protocolType: Option[String],  // 协议类型\n  protocolName: Option[String],  // 分区消费分配策略名称\n  groupInstanceId: Option[String],  // 静态成员Instance ID\n  groupAssignment: Map[String, Array[Byte]],  // 按照成员分组的分配方案\n  responseCallback: SyncCallback  // 回调函数\n  ): Unit = {\n  ......\n}\n</code></pre><p>该方法总共定义了8个参数，你可以看下注释，了解它们的含义，我重点介绍6个比较关键的参数。</p><ul>\n<li><strong>groupId</strong>：消费者组名，标识这个成员属于哪个消费者组。</li>\n<li><strong>generation</strong>：消费者组Generation号。Generation类似于任期的概念，标识了Coordinator负责为该消费者组处理的Rebalance次数。每当有新的Rebalance开启时，Generation都会自动加1。</li>\n<li><strong>memberId</strong>：消费者组成员ID。该字段由Coordinator根据一定的规则自动生成。具体的规则上节课我们已经学过了，我就不多说了。总体而言，成员ID的值不是由你直接指定的，但是你可以通过client.id参数，间接影响该字段的取值。</li>\n<li><strong>protocolType</strong>：标识协议类型的字段，这个字段可能的取值有两个：consumer和connect。对于普通的消费者组而言，这个字段的取值就是consumer，该字段是Option类型，因此，实际的取值是Some(“consumer”)；Kafka Connect组件中也会用到消费者组机制，那里的消费者组的取值就是connect。</li>\n<li><strong>protocolName</strong>：消费者组选定的分区消费分配策略名称。这里的选择方法，就是我们之前学到的GroupMetadata.selectProtocol方法。</li>\n<li><strong>groupAssignment</strong>：按照成员ID分组的分配方案。需要注意的是，<strong>只有Leader成员发送的SyncGroupRequest请求，才包含这个方案</strong>，因此，Coordinator在处理Leader成员的请求时，该字段才有值。</li>\n</ul><p>你可能已经注意到了，protocolType和protocolName都是Option类型，这说明，它们的取值可能是None，即表示没有值。这是为什么呢？</p><p>目前，这两个字段的取值，其实都是Coordinator帮助消费者组确定的，也就是在Rebalance流程的上一步加入组中确定的。</p><p>如果成员成功加入组，那么，Coordinator会给这两个字段赋上正确的值，并封装进JoinGroupRequest的Response里，发送给消费者程序。一旦消费者拿到了Response中的数据，就提取出这两个字段的值，封装进SyncGroupRequest请求中，再次发送给Coordinator。</p><p>如果成员没有成功加入组，那么，Coordinator会将这两个字段赋值成None，加到Response中。因此，在这里的handleSyncGroup方法中，它们的类型就是Option。</p><p>说完了handleSyncGroup的方法签名，我们看下它的代码：</p><pre><code>// 验证消费者状态及合法性 \nvalidateGroupStatus(groupId, ApiKeys.SYNC_GROUP) match {\n  // 如果未通过合法性检查，且错误原因是Coordinator正在加载\n  // 那么，封装REBALANCE_IN_PROGRESS异常，并调用回调函数返回\n  case Some(error) if error == Errors.COORDINATOR_LOAD_IN_PROGRESS =&gt;\n    responseCallback(SyncGroupResult(Errors.REBALANCE_IN_PROGRESS))\n  // 如果是其它错误，则封装对应错误，并调用回调函数返回\n  case Some(error) =&gt; responseCallback(SyncGroupResult(error))\n  case None =&gt;\n    // 获取消费者组元数据\n    groupManager.getGroup(groupId) match {\n      // 如果未找到，则封装UNKNOWN_MEMBER_ID异常，并调用回调函数返回\n      case None =&gt; \n        responseCallback(SyncGroupResult(Errors.UNKNOWN_MEMBER_ID))\n      // 如果找到的话，则调用doSyncGroup方法执行组同步任务\n      case Some(group) =&gt; doSyncGroup(\n        group, generation, memberId, protocolType, protocolName,\n        groupInstanceId, groupAssignment, responseCallback)\n    }\n}\n</code></pre><p>为了方便你理解，我画了一张流程图来说明此方法的主体逻辑。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/a7/a252eb065397fc8a78e92b26fe2fc6a7.jpg?wh=3064*2392\" alt=\"\"></p><p>handleSyncGroup方法首先会调用上一节课我们学习过的validateGroupStatus方法，校验消费者组状态及合法性。这些检查项包括：</p><ol>\n<li>消费者组名不能为空；</li>\n<li>Coordinator组件处于运行状态；</li>\n<li>Coordinator组件当前没有执行加载过程；</li>\n<li>SyncGroupRequest请求发送给了正确的Coordinator组件。</li>\n</ol><p>前两个检查项很容易理解，我重点解释一下最后两项的含义。</p><p>当Coordinator变更到其他Broker上时，需要从内部位移主题中读取消息数据，并填充到内存上的消费者组元数据缓存，这就是所谓的加载。</p><ul>\n<li>如果Coordinator变更了，那么，发送给老Coordinator所在Broker的请求就失效了，因为它没有通过第4个检查项，即发送给正确的Coordinator；</li>\n<li>如果发送给了正确的Coordinator，但此时Coordinator正在执行加载过程，那么，它就没有通过第3个检查项，因为Coordinator尚不能对外提供服务，要等加载完成之后才可以。</li>\n</ul><p>代码对消费者组依次执行上面这4项校验，一旦发现有项目校验失败，validateGroupStatus方法就会将检查失败的原因作为结果返回。如果是因为Coordinator正在执行加载，就意味着<strong>本次Rebalance的所有状态都丢失了</strong>。这里的状态，指的是消费者组下的成员信息。那么，此时最安全的做法，是<strong>让消费者组重新从加入组开始</strong>，因此，代码会封装REBALANCE_IN_PROGRESS异常，然后调用回调函数返回。一旦消费者组成员接收到此异常，就会知道，它至少找到了正确的Coordinator，只需要重新开启Rebalance，而不需要在开启Rebalance之前，再大费周章地去定位Coordinator组件了。但如果是其它错误，就封装该错误，然后调用回调函数返回。</p><p>倘若消费者组通过了以上校验，那么，代码就会获取该消费者组的元数据信息。如果找不到对应的元数据，就封装UNKNOWN_MEMBER_ID异常，之后调用回调函数返回；如果找到了元数据信息，就调用doSyncGroup方法执行真正的组同步逻辑。</p><p>显然，接下来我们应该学习doSyncGroup方法的源码了，这才是真正实现组同步功能的地方。</p><h2>doSyncGroup方法</h2><p>doSyncGroup方法接收的输入参数，与它的调用方法handleSyncGroup如出一辙，所以这里我就不再展开讲了，我们重点关注一下它的源码实现。</p><p>鉴于它的代码很长，我把它拆解成两个部分，并配以流程图进行介绍。</p><ul>\n<li>第1部分：主要<strong>对消费者组做各种校验</strong>，如果没有通过校验，就封装对应的异常给回调函数；</li>\n<li>第2部分：<strong>根据不同的消费者组状态选择不同的执行逻辑</strong>。你需要特别关注一下，在CompletingRebalance状态下，代码是如何实现组同步的。</li>\n</ul><p>我先给出第1部分的流程图，你可以先看一下，对这个流程有个整体的感知。</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/4b/f0d4274cc5d37663fb3d0da6b0af954b.jpg?wh=2504*3112\" alt=\"\"></p><p>下面，我们来看这部分的代码：</p><pre><code>if (group.is(Dead)) {\n responseCallback(\n   SyncGroupResult(Errors.COORDINATOR_NOT_AVAILABLE))\n} else if (group.isStaticMemberFenced(memberId, groupInstanceId, &quot;sync-group&quot;)) {\n  responseCallback(SyncGroupResult(Errors.FENCED_INSTANCE_ID))\n} else if (!group.has(memberId)) {\n  responseCallback(SyncGroupResult(Errors.UNKNOWN_MEMBER_ID))\n} else if (generationId != group.generationId) {\n  responseCallback(SyncGroupResult(Errors.ILLEGAL_GENERATION))\n} else if (protocolType.isDefined &amp;&amp; !group.protocolType.contains(protocolType.get)) {\n responseCallback(SyncGroupResult(Errors.INCONSISTENT_GROUP_PROTOCOL))\n} else if (protocolName.isDefined &amp;&amp; !group.protocolName.contains(protocolName.get)) {\n responseCallback(SyncGroupResult(Errors.INCONSISTENT_GROUP_PROTOCOL))\n} else {\n  // 第2部分源码......\n}\n</code></pre><p>可以看到，代码非常工整，全是if-else类型的判断。</p><p><strong>首先</strong>，这部分代码会判断消费者组的状态是否是Dead。如果是的话，就说明该组的元数据信息已经被其他线程从Coordinator中移除了，这很可能是因为Coordinator发生了变更。此时，最佳的做法是<strong>拒绝该成员的组同步操作</strong>，封装COORDINATOR_NOT_AVAILABLE异常，显式告知它去寻找最新Coordinator所在的Broker节点，然后再尝试重新加入组。</p><p>接下来的isStaticMemberFenced方法判断是有关静态成员的，我们可以不用理会。</p><p><strong>之后</strong>，代码判断memberId字段标识的成员是否属于这个消费者组。如果不属于的话，就封装UNKNOWN_MEMBER_ID异常，并调用回调函数返回；如果属于的话，则继续下面的判断。</p><p><strong>再之后</strong>，代码<strong>判断成员的Generation是否和消费者组的相同</strong>。如果不同的话，则封装ILLEGAL_GENERATION异常给回调函数；如果相同的话，则继续下面的判断。</p><p>接下来，代码<strong>判断成员和消费者组的协议类型是否一致</strong>。如果不一致，则封装INCONSISTENT_GROUP_PROTOCOL异常给回调函数；如果一致，就进行下一步。</p><p><strong>最后</strong>，判断<strong>成员和消费者组的分区消费分配策略是否一致</strong>。如果不一致，同样封装INCONSISTENT_GROUP_PROTOCOL异常给回调函数。</p><p>如果这些都一致，则顺利进入到第2部分。在开始之前，我依然用一张图来展示一下这里的实现逻辑。</p><p><img src=\"https://static001.geekbang.org/resource/image/91/bf/9184344e316c3cb5e6e797c1b574acbf.jpg?wh=4084*4312\" alt=\"\"></p><p>进入到这部分之后，代码要做什么事情，完全<strong>取决于消费者组的当前状态</strong>。如果消费者组处于CompletingRebalance状态，这部分代码要做的事情就比较复杂，我们一会儿再说，现在先看除了这个状态之外的逻辑代码。</p><pre><code>group.currentState match {\n  case Empty =&gt;\n    // 封装UNKNOWN_MEMBER_ID异常，调用回调函数返回\n    responseCallback(SyncGroupResult(Errors.UNKNOWN_MEMBER_ID))\n  case PreparingRebalance =&gt;\n    // 封装REBALANCE_IN_PROGRESS异常，调用回调函数返回\n    responseCallback(SyncGroupResult(Errors.REBALANCE_IN_PROGRESS))\n  case CompletingRebalance =&gt;\n    // 下面详细展开......\n  case Stable =&gt;\n    // 获取消费者组成员元数据\n    val memberMetadata = group.get(memberId)\n    // 封装组协议类型、分配策略、成员分配方案，调用回调函数返回\n    responseCallback(SyncGroupResult(group.protocolType, group.protocolName, memberMetadata.assignment, Errors.NONE))\n    // 设定成员下次心跳时间\n    completeAndScheduleNextHeartbeatExpiration(group, group.get(memberId))\n  case Dead =&gt;\n    // 抛出异常\n    throw new IllegalStateException(s&quot;Reached unexpected condition for Dead group ${group.groupId}&quot;)\n}\n</code></pre><p>如果消费者组的当前状态是Empty或PreparingRebalance，那么，代码会封装对应的异常给回调函数，供其调用。</p><p>如果是Stable状态，则说明，此时消费者组已处于正常工作状态，无需进行组同步的操作。因此，在这种情况下，简单返回消费者组当前的分配方案给回调函数，供它后面发送给消费者组成员即可。</p><p>如果是Dead状态，那就说明，这是一个异常的情况了，因为理论上，不应该为处于Dead状态的组执行组同步，因此，代码只能选择抛出IllegalStateException异常，让上层方法处理。</p><p>如果这些状态都不是，那么，消费者组就只能处于CompletingRebalance状态，这也是执行组同步操作时消费者组最有可能处于的状态。因此，这部分的逻辑要复杂一些，我们看下代码：</p><pre><code>// 为该消费者组成员设置组同步回调函数\ngroup.get(memberId).awaitingSyncCallback = responseCallback\n// 组Leader成员发送的SyncGroupRequest请求需要特殊处理\nif (group.isLeader(memberId)) {\n  info(s&quot;Assignment received from leader for group ${group.groupId} for generation ${group.generationId}&quot;)\n  // 如果有成员没有被分配任何消费方案，则创建一个空的方案赋给它\n  val missing = group.allMembers.diff(groupAssignment.keySet)\n  val assignment = groupAssignment ++ missing.map(_ -&gt; Array.empty[Byte]).toMap\n\n  if (missing.nonEmpty) {\n    warn(s&quot;Setting empty assignments for members $missing of ${group.groupId} for generation ${group.generationId}&quot;)\n  }\n  // 把消费者组信息保存在消费者组元数据中，并且将其写入到内部位移主题\n  groupManager.storeGroup(group, assignment, (error: Errors) =&gt; {\n    group.inLock {\n      // 如果组状态是CompletingRebalance以及成员和组的generationId相同\n      if (group.is(CompletingRebalance) &amp;&amp; generationId == group.generationId) {\n        // 如果有错误\n        if (error != Errors.NONE) {\n          // 清空分配方案并发送给所有成员\n          resetAndPropagateAssignmentError(group, error)\n          // 准备开启新一轮的Rebalance\n          maybePrepareRebalance(group, s&quot;error when storing group assignment during SyncGroup (member: $memberId)&quot;)\n        // 如果没错误\n        } else {\n          // 在消费者组元数据中保存分配方案并发送给所有成员\n          setAndPropagateAssignment(group, assignment)\n          // 变更消费者组状态到Stable\n          group.transitionTo(Stable)\n        }\n      }\n    }\n  })\n  groupCompletedRebalanceSensor.record()\n}\n</code></pre><p>第1步，为该消费者组成员设置组同步回调函数。我们总说回调函数，其实它的含义很简单，也就是将传递给回调函数的数据，通过Response的方式发送给消费者组成员。</p><p>第2步，判断当前成员是否是消费者组的Leader成员。如果不是Leader成员，方法直接结束，因为，只有Leader成员的groupAssignment字段才携带了分配方案，其他成员是没有分配方案的；如果是Leader成员，则进入到下一步。</p><p>第3步，为没有分配到任何分区的成员创建一个空的分配方案，并赋值给这些成员。这一步的主要目的，是构造一个统一格式的分配方案字段assignment。</p><p>第4步，调用storeGroup方法，保存消费者组信息到消费者组元数据，同时写入到内部位移主题中。一旦完成这些动作，则进入到下一步。</p><p>第5步，在组状态是CompletingRebalance，而且成员和组的Generation ID相同的情况下，就判断一下刚刚的storeGroup操作过程中是否出现过错误：</p><ul>\n<li>如果有错误，则清空分配方案并发送给所有成员，同时准备开启新一轮的Rebalance；</li>\n<li>如果没有错误，则在消费者组元数据中保存分配方案，然后发送给所有成员，并将消费者组状态变更到Stable。</li>\n</ul><p>倘若组状态不是CompletingRebalance，或者是成员和组的Generation ID不相同，这就说明，消费者组可能开启了新一轮的Rebalance，那么，此时就不能继续给成员发送分配方案。</p><p>至此，CompletingRebalance状态下的组同步操作完成。总结一下，组同步操作完成了以下3件事情：</p><ol>\n<li>将包含组成员分配方案的消费者组元数据，添加到消费者组元数据缓存以及内部位移主题中；</li>\n<li>将分配方案通过SyncGroupRequest响应的方式，下发给组下所有成员。</li>\n<li>将消费者组状态变更到Stable。</li>\n</ol><p>我建议你对照着代码，自行寻找并阅读一下完成这3件事情的源码，这不仅有助于你复习下今天所学的内容，还可以帮你加深对源码的理解。阅读的时候，你思考一下，这些代码的含义是否真的如我所说。如果你有不一样的理解，欢迎写在留言区，我们可以开放式讨论。</p><h2>总结</h2><p>今天，我们重点学习了Rebalance流程的第2步，也就是组同步。至此，关于Rebalance的完整流程，我们就全部学完了。</p><p>Rebalance流程是Kafka提供的一个非常关键的消费者组功能。由于它非常重要，所以，社区在持续地对它进行着改进，包括引入增量式的Rebalance以及静态成员等。我们在这两节课学的Rebalance流程，是理解这些高级功能的基础。如果你不清楚Rebalance过程中的这些步骤都是做什么的，你就无法深入地掌握增量式Rebalance或静态成员机制所做的事情。</p><p>因此，我建议你结合上节课的内容，好好学习一下消费者组的Rebalance，彻底弄明白一个消费者组成员是如何参与其中并最终完成Rebalance过程的。</p><p>我们来回顾一下这节课的重点。</p><ul>\n<li>组同步：成员向Coordinator发送SyncGroupRequest请求以获取分配方案。</li>\n<li>handleSyncGroup方法：接收KafkaApis发来的SyncGroupRequest请求体数据，执行组同步逻辑。</li>\n<li>doSyncGroup方法：真正执行组同步逻辑的方法，执行组元数据保存、分配方案下发以及状态变更操作。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/fc/e9/fccc73c2867102f2ec6e8e3666f101e9.jpg?wh=2250*1984\" alt=\"\"></p><p>讲到这里，Coordinator组件的源码，我就介绍完了。在这个模块中，我们基本上还是践行“自上而下+自下而上”的学习方式。我们先从最低层次的消费者组元数据类开始学习，逐渐上浮到它的管理器类GroupMetadataManager类以及顶层类GroupCoordinator类。接着，在学习Rebalance流程时，我们反其道而行之，先从GroupCoordinator类的入口方法进行拆解，又逐渐下沉到GroupMetadataManager和更底层的GroupMetadata以及MemberMetadata。</p><p>如果你追随着课程的脚步一路走来，你就会发现，我经常采用这种方式讲解源码。我希望，你在日后的源码学习中，也可以多尝试运用这种方法。所谓择日不如撞日，我今天就给你推荐一个课后践行此道的绝佳例子。</p><p>我建议你去阅读下clients工程中的实现消息、消息批次以及消息集合部分的源码，也就是Record、RecordBatch和Records这些接口和类的代码，去反复实践“自上而下”和“自下而上”这两种阅读方法。</p><p>其实，这种方式不只适用于Kafka源码，在阅读其他框架的源码时，也可以采用这种方式。希望你可以不断总结经验，最终提炼出一套适合自己的学习模式。</p><h2>课后讨论</h2><p>Coordinator不会将所有消费者组的所有成员的分配方案下发给单个成员，这就是说，成员A看不到成员B的分区消费分配方案。那么，你能找出来，源码中的哪行语句做了这件事情吗？</p><p>欢迎在留言区写下你的思考和答案，跟我交流讨论，也欢迎你把今天的内容分享给你的朋友。</p>","comments":[{"had_liked":false,"id":236053,"user_name":"胡夕","can_delete":false,"product_type":"c1","uid":1288090,"ip_address":"","ucode":"5709A689B6683B","user_header":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","comment_is_top":true,"comment_ctime":1595299028,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"9.2233720384501002e+18","product_id":100050101,"comment_content":"你好，我是胡夕。我来公布上节课的“课后讨论”题答案啦～<br><br>上节课，我们重点学习了GroupCoordinator执行Rebalance第一步加入组的代码。课后我请你思考一下maybePrepareRebalance方法满足什么条件才会开启Rebalance？如果你翻开maybePrepareRebalance的代码，可以看到它会调用canRebalance方法执行是否允许Rebalance的判断，而判断的依据很简单，就是看当前消费者组状态是否在PreparingRebalance状态的合法前置状态集合中。也就是说，当前消费者组状态必须是Stable、Empty或CompletingRebalance中的一个才可以。<br><br>okay，你同意这个说法吗？或者说你有其他的看法吗？我们可以一起讨论下。","like_count":0,"discussions":[{"author":{"id":2056150,"avatar":"","nickname":"Geek_32b33d","note":"","ucode":"8280003B299F2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302741,"discussion_content":"老师有没有Transaction coordinator的讲解啊？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599017063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283901,"user_name":"Jasonji","can_delete":false,"product_type":"c1","uid":1184156,"ip_address":"","ucode":"5859FBFDA931B1","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/9c/eb4d62ff.jpg","comment_is_top":false,"comment_ctime":1615977354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5910944650","product_id":100050101,"comment_content":"  private def setAndPropagateAssignment(group: GroupMetadata, assignment: Map[String, Array[Byte]]): Unit = {<br>    assert(group.is(CompletingRebalance))<br>    group.allMemberMetadata.foreach(member =&gt; member.assignment = assignment(member.memberId))<br>    propagateAssignment(group, Errors.NONE)<br>  }<br>这个方法中的group.allMemberMetadata.foreach(member =&gt; member.assignment = assignment(member.memberId))这行","like_count":1},{"had_liked":false,"id":356491,"user_name":"dawn","can_delete":false,"product_type":"c1","uid":1296063,"ip_address":"江苏","ucode":"1757B28F1EF5C4","user_header":"https://static001.geekbang.org/account/avatar/00/13/c6/bf/52b3f71d.jpg","comment_is_top":false,"comment_ctime":1662363696,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1662363696","product_id":100050101,"comment_content":"我不太能理解，分配方案为什么是消费端出，只是一个简单的映射，讲道理不会有太多的消耗，协调者为啥不一起做了。<br>如果这块很重，把这个逻辑丢给消费者来做，能减少broker的压力，我还能理解，现在看下来，协调者做了大量的同步工作，也不差方案分配这一步啊","like_count":1,"discussions":[{"author":{"id":3178210,"avatar":"","nickname":"Geek_234834","note":"","ucode":"28C3B811C76135","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587278,"discussion_content":"有可能是为了分区分配策略定制化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662956621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351473,"user_name":"Geek_aec36b","can_delete":false,"product_type":"c1","uid":3055867,"ip_address":"","ucode":"9B330EC7A9B267","user_header":"","comment_is_top":false,"comment_ctime":1657813611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657813611","product_id":100050101,"comment_content":"最近线上遇到一个case，consumer group 执行Rebalance时，消费实例A 没有执行 revoke partition，然后消费实例 B又获取到了消费实例A的其中一个partition，导致 同一个consumer group 在subscribe（）方法下，出现一个分区被两个消费实例消费到，请问这种case，胡老师觉得是什么原因导致的呢？","like_count":0},{"had_liked":false,"id":316403,"user_name":"mushan","can_delete":false,"product_type":"c1","uid":2756810,"ip_address":"","ucode":"B57CCB0A1FA653","user_header":"","comment_is_top":false,"comment_ctime":1634296815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634296815","product_id":100050101,"comment_content":"老师你好，<br>groupManager.getGroup(groupId) match {<br>          case None =&gt; responseCallback(SyncGroupResult(Errors.UNKNOWN_MEMBER_ID))<br>          case Some(group) =&gt; doSyncGroup(group, generation, memberId, protocolType, protocolName,<br>            groupInstanceId, groupAssignment, responseCallback)<br>        }<br>什么情况下会出现获取不到消费者组元数据呢？请求同步组数据是必须在正常加入组的情况下，那时候消费者组元数据是应该能保证存在的吧？","like_count":0},{"had_liked":false,"id":238119,"user_name":"云端漫漫步","can_delete":false,"product_type":"c1","uid":1024490,"ip_address":"","ucode":"80C9E1E477E921","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/ea/4afba3f1.jpg","comment_is_top":false,"comment_ctime":1596073905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596073905","product_id":100050101,"comment_content":"GroupCoordinator中的propagateAssignment方法会遍历组成员元数据，然后根据每个member信息针对下发","like_count":0},{"had_liked":false,"id":237479,"user_name":"现实中游走","can_delete":false,"product_type":"c1","uid":1025081,"ip_address":"","ucode":"120FD5755469CA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/39/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1595842271,"is_pvip":false,"replies":[{"id":"87883","content":"请问是什么版本的Kafka呢？这个错误是之前很早版本中的一个bug，最近比较新的Kafka中已经很少见了，需要排除下是否是已知bug","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1596005875,"ip_address":"","comment_id":237479,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1595842271","product_id":100050101,"comment_content":"老师，您好，请教个问题，下面的报错是什么原因导致的，要怎么查找问题的原因并解决<br>java.lang.IllegalStateException: Correlation id for response (62213091) does not match request (62213090),<br>","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502430,"discussion_content":"请问是什么版本的Kafka呢？这个错误是之前很早版本中的一个bug，最近比较新的Kafka中已经很少见了，需要排除下是否是已知bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596005875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1025081,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a4/39/abb7bfe3.jpg","nickname":"现实中游走","note":"","ucode":"120FD5755469CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295136,"discussion_content":"0.10.0版本","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596100700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234406,"user_name":"伯安知心","can_delete":false,"product_type":"c1","uid":1961835,"ip_address":"","ucode":"6C17706658672C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/ef/6b/5e8f6536.jpg","comment_is_top":false,"comment_ctime":1594686859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594686859","product_id":100050101,"comment_content":"handleSyncGroup方法验证组状态的时候validateGroupStatus通过模式匹配如果发现没有错误，执行查找自己broker保存的组groupManager.getGroup(groupId) 然后每个组依次执行自己的doSyncGroup方法。","like_count":0}]}