{"id":2748,"title":"37 | 编程范式游记（8）- Go 语言的委托模式","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p>\n<p>我们再来看Go语言这个模式，Go语言的这个模式挺好玩儿的。声明一个struct，跟C很一样，然后直接把这个struct类型放到另一个struct里。</p>\n<h1>委托的简单示例</h1>\n<p>我们来看几个示例：</p>\n<pre><code>type Widget struct {\n    X, Y int\n}\n\ntype Label struct {\n    Widget        // Embedding (delegation)\n    Text   string // Aggregation\n    X int         // Override \n}\n\nfunc (label Label) Paint() {\n\t// [0xc4200141e0] - Label.Paint(&quot;State&quot;)\n    fmt.Printf(&quot;[%p] - Label.Paint(%q)\\n&quot;, \n    \t&amp;label, label.Text)\n}\n</code></pre>\n<p>由上面可知：</p>\n<ul>\n<li>\n<p>我们声明了一个 <code>Widget</code>，其有 <code>X</code>和<code>Y</code>；</p>\n</li>\n<li>\n<p>然后用它来声明一个 <code>Label</code>，直接把 <code>Widget</code> 委托进去；</p>\n</li>\n<li>\n<p>然后再给 <code>Label</code> 声明并实现了一个 <code>Paint()</code> 方法。</p>\n</li>\n</ul>\n<p>于是，我们就可以这样编程了：</p>\n<pre><code>label := Label{Widget{10, 10}, &quot;State&quot;, 100}\n\n// X=100, Y=10, Text=State, Widget.X=10\nfmt.Printf(&quot;X=%d, Y=%d, Text=%s Widget.X=%d\\n&quot;, \n\tlabel.X, label.Y, label.Text, \n\tlabel.Widget.X)\nfmt.Println()\n// {Widget:{X:10 Y:10} Text:State X:100} \n// {{10 10} State 100}\nfmt.Printf(&quot;%+v\\n%v\\n&quot;, label, label)\n\nlabel.Paint()\n</code></pre>\n<p>我们可以看到，如果有成员变量重名，则需要手动地解决冲突。</p>\n<!-- [[[read_end]]] -->\n<p>我们继续扩展代码。</p>\n<p>先来一个 <code>Button</code>：</p>\n<pre><code>type Button struct {\n    Label // Embedding (delegation)\n}\n \nfunc NewButton(x, y int, text string) Button {\n    return Button{Label{Widget{x, y}, text, x}}\n}\nfunc (button Button) Paint() { // Override\n    fmt.Printf(&quot;[%p] - Button.Paint(%q)\\n&quot;, \n    \t&amp;button, button.Text)\n}\nfunc (button Button) Click() {\n    fmt.Printf(&quot;[%p] - Button.Click()\\n&quot;, &amp;button)\n}\n</code></pre>\n<p>再来一个 <code>ListBox</code>：</p>\n<pre><code>type ListBox struct {\n    Widget          // Embedding (delegation)\n    Texts  []string // Aggregation\n    Index  int      // Aggregation\n}\nfunc (listBox ListBox) Paint() {\n    fmt.Printf(&quot;[%p] - ListBox.Paint(%q)\\n&quot;, \n    \t&amp;listBox, listBox.Texts)\n}\nfunc (listBox ListBox) Click() {\n    fmt.Printf(&quot;[%p] - ListBox.Click()\\n&quot;, &amp;listBox)\n}\n</code></pre>\n<p>然后，声明两个接口用于多态：</p>\n<pre><code>type Painter interface {\n    Paint()\n}\n\ntype Clicker interface {\n    Click()\n}\n</code></pre>\n<p>于是我们就可以这样泛型地使用（注意其中的两个for循环）：</p>\n<pre><code>button1 := Button{Label{Widget{10, 70}, &quot;OK&quot;, 10}}\nbutton2 := NewButton(50, 70, &quot;Cancel&quot;)\nlistBox := ListBox{Widget{10, 40}, \n    []string{&quot;AL&quot;, &quot;AK&quot;, &quot;AZ&quot;, &quot;AR&quot;}, 0}\n\nfmt.Println()\n//[0xc4200142d0] - Label.Paint(&quot;State&quot;)\n//[0xc420014300] - ListBox.Paint([&quot;AL&quot; &quot;AK&quot; &quot;AZ&quot; &quot;AR&quot;])\n//[0xc420014330] - Button.Paint(&quot;OK&quot;)\n//[0xc420014360] - Button.Paint(&quot;Cancel&quot;)\nfor _, painter := range []Painter{label, listBox, button1, button2} {\n\tpainter.Paint()\n}\n\nfmt.Println()\n//[0xc420014450] - ListBox.Click()\n//[0xc420014480] - Button.Click()\n//[0xc4200144b0] - Button.Click()\nfor _, widget := range []interface{}{label, listBox, button1, button2} {\n    if clicker, ok := widget.(Clicker); ok {\n    \tclicker.Click()\n    }\n}\n</code></pre>\n<h1>一个 Undo 的委托重构</h1>\n<p>上面这个是 Go 语言中的委托和接口多态的编程方式，其实是面向对象和原型编程综合的玩法。这个玩法可不可以玩得更有意思呢？这是可以的。</p>\n<p>首先，我们先声明一个数据容器，其中有 <code>Add()</code>、 <code>Delete()</code> 和 <code>Contains()</code> 方法。还有一个转字符串的方法。</p>\n<pre><code>type IntSet struct {\n    data map[int]bool\n}\n\nfunc NewIntSet() IntSet {\n    return IntSet{make(map[int]bool)}\n}\n\nfunc (set *IntSet) Add(x int) {\n    set.data[x] = true\n}\n\nfunc (set *IntSet) Delete(x int) {\n    delete(set.data, x)\n}\n\nfunc (set *IntSet) Contains(x int) bool {\n    return set.data[x]\n}\n\nfunc (set *IntSet) String() string { // Satisfies fmt.Stringer interface\n    if len(set.data) == 0 {\n        return &quot;{}&quot;\n    }\n    ints := make([]int, 0, len(set.data))\n    for i := range set.data {\n        ints = append(ints, i)\n    }\n    sort.Ints(ints)\n    parts := make([]string, 0, len(ints))\n    for _, i := range ints {\n        parts = append(parts, fmt.Sprint(i))\n    }\n    return &quot;{&quot; + strings.Join(parts, &quot;,&quot;) + &quot;}&quot;\n}\n</code></pre>\n<p>我们如下使用这个数据容器：</p>\n<pre><code>ints := NewIntSet()\nfor _, i := range []int{1, 3, 5, 7} {\n    ints.Add(i)\n    fmt.Println(ints)\n}\nfor _, i := range []int{1, 2, 3, 4, 5, 6, 7} {\n    fmt.Print(i, ints.Contains(i), &quot; &quot;)\n    ints.Delete(i)\n    fmt.Println(ints)\n}\n</code></pre>\n<p>这个数据容器平淡无奇，我们想给它加一个Undo的功能。我们可以这样来做：</p>\n<pre><code>type UndoableIntSet struct { // Poor style\n    IntSet    // Embedding (delegation)\n    functions []func()\n}\n\nfunc NewUndoableIntSet() UndoableIntSet {\n    return UndoableIntSet{NewIntSet(), nil}\n}\n\nfunc (set *UndoableIntSet) Add(x int) { // Override\n    if !set.Contains(x) {\n        set.data[x] = true\n        set.functions = append(set.functions, func() { set.Delete(x) })\n    } else {\n        set.functions = append(set.functions, nil)\n    }\n}\n\nfunc (set *UndoableIntSet) Delete(x int) { // Override\n    if set.Contains(x) {\n        delete(set.data, x)\n        set.functions = append(set.functions, func() { set.Add(x) })\n    } else {\n        set.functions = append(set.functions, nil)\n    }\n}\n\nfunc (set *UndoableIntSet) Undo() error {\n    if len(set.functions) == 0 {\n        return errors.New(&quot;No functions to undo&quot;)\n    }\n    index := len(set.functions) - 1\n    if function := set.functions[index]; function != nil {\n        function()\n        set.functions[index] = nil // Free closure for garbage collection\n    }\n    set.functions = set.functions[:index]\n    return nil\n}\n</code></pre>\n<p>于是就可以这样使用了：</p>\n<pre><code>ints := NewUndoableIntSet()\nfor _, i := range []int{1, 3, 5, 7} {\n    ints.Add(i)\n    fmt.Println(ints)\n}\nfor _, i := range []int{1, 2, 3, 4, 5, 6, 7} {\n    fmt.Println(i, ints.Contains(i), &quot; &quot;)\n    ints.Delete(i)\n    fmt.Println(ints)\n}\nfmt.Println()\nfor {\n    if err := ints.Undo(); err != nil {\n        break\n    }\n    fmt.Println(ints)\n}\n</code></pre>\n<p>但是，需要注意的是，我们用了一个新的 <code>UndoableIntSet</code> 几乎重写了所有的 <code>IntSet</code> 和 “写” 相关的方法，这样就可以把操作记录下来，然后 <strong>Undo</strong> 了。</p>\n<p>但是，可能别的类也需要Undo的功能，我是不是要重写所有的需要这个功能的类啊？这样的代码类似，就是因为数据容器不一样，我就要去重写它们，这太二了。</p>\n<p>我们能不能利用前面学到的泛型编程、函数式编程、IoC等范式来把这个事干得好一些呢？当然是可以的。</p>\n<p>如下所示：</p>\n<ul>\n<li>\n<p>我们先声明一个 <code>Undo[]</code> 的函数数组（其实是一个栈）；</p>\n</li>\n<li>\n<p>并实现一个通用 <code>Add()</code>。其需要一个函数指针，并把这个函数指针存放到 <code>Undo[]</code> 函数数组中。</p>\n</li>\n<li>\n<p>在 <code>Undo()</code> 的函数中，我们会遍历<code>Undo[]</code>函数数组，并执行之，执行完后就弹栈。</p>\n</li>\n</ul>\n<pre><code>type Undo []func()\n\nfunc (undo *Undo) Add(function func()) {\n    *undo = append(*undo, function)\n}\n\nfunc (undo *Undo) Undo() error {\n    functions := *undo\n    if len(functions) == 0 {\n        return errors.New(&quot;No functions to undo&quot;)\n    }\n    index := len(functions) - 1\n    if function := functions[index]; function != nil {\n        function()\n        functions[index] = nil // Free closure for garbage collection\n    }\n    *undo = functions[:index]\n    return nil\n}\n\n</code></pre>\n<p>那么我们的 <code>IntSet</code> 就可以改写成如下的形式：</p>\n<pre><code>type IntSet struct {\n    data map[int]bool\n    undo Undo\n}\n\nfunc NewIntSet() IntSet {\n    return IntSet{data: make(map[int]bool)}\n}\n\n</code></pre>\n<p>然后在其中的 <code>Add</code> 和 <code>Delete</code>中实现 Undo 操作。</p>\n<ul>\n<li><code>Add</code> 操作时加入 <code>Delete</code> 操作的 Undo。</li>\n<li><code>Delete</code> 操作时加入 <code>Add</code> 操作的 Undo。</li>\n</ul>\n<pre><code>\nfunc (set *IntSet) Add(x int) {\n    if !set.Contains(x) {\n        set.data[x] = true\n        set.undo.Add(func() { set.Delete(x) })\n    } else {\n        set.undo.Add(nil)\n    }\n}\n\nfunc (set *IntSet) Delete(x int) {\n    if set.Contains(x) {\n        delete(set.data, x)\n        set.undo.Add(func() { set.Add(x) })\n    } else {\n        set.undo.Add(nil)\n    }\n}\n\nfunc (set *IntSet) Undo() error {\n    return set.undo.Undo()\n}\n\nfunc (set *IntSet) Contains(x int) bool {\n    return set.data[x]\n}\n\n</code></pre>\n<p>我们再次看到，Go语言的Undo接口把Undo的流程给抽象出来，而要怎么Undo的事交给了业务代码来维护（通过注册一个Undo的方法）。这样在Undo的时候，就可以回调这个方法来做与业务相关的Undo操作了。</p>\n<h1>小结</h1>\n<p>这是不是和最一开始的C++的泛型编程很像？也和map、reduce、filter这样的只关心控制流程，不关心业务逻辑的做法很像？而且，一开始用一个UndoableIntSet来包装<code>IntSet</code>类，到反过来在<code>IntSet</code>里依赖<code>Undo</code>类，这就是控制反转IoC。</p>\n<p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。</p>\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/301\">01 | 编程范式游记：起源</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/303\">02 | 编程范式游记：泛型编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2017\">03 | 编程范式游记：类型系统和泛型的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2711\">04 | 编程范式游记：函数式编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2723\">05 | 编程范式游记：修饰器模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2729\">06 | 编程范式游记：面向对象编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2741\">07 | 编程范式游记：基于原型的编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2748\">08 | 编程范式游记：Go 语言的委托模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2751\">09 | 编程范式游记：编程的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2752\">10 | 编程范式游记：逻辑编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2754\">11 | 编程范式游记：程序世界里的编程范式</a></li>\n</ul>\n","comments":[{"had_liked":false,"id":2582,"user_name":"milley","can_delete":false,"product_type":"c1","uid":1001175,"ip_address":"","ucode":"8C95F693644CDE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/d7/00e99ebb.jpg","comment_is_top":false,"comment_ctime":1517884061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"130366902941","product_id":100002201,"comment_content":"这样的代码和思维只能说赏心悦目！","like_count":31},{"had_liked":false,"id":258603,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1604499698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35964238066","product_id":100002201,"comment_content":"1、文章说了什么？<br>文章分了两部分，一部分先简单说了 Golang 的委托用法。简单来说，就是讲一个 structA 嵌套到另外一个 structB 中，structB 会自动继承 structA 的字段。其后，通过一个更加复杂的例子说明委托的用法。（作为一个 Java 程序员，Golang 为 struct 增加方法，和定义接口的方法让人印象深刻）<br><br>另一部分，作者举了一个更加复杂的例子说明 Go 中委托和接口多态是如何实现一个数据容器的 Undo 实现的。为了说明这部分，作者通过以下步骤一说说进阶说明：<br>1、最简单的一个 IntSet，并定义了 Add ，Delete 方法；<br>2、通过一个委托的方法，将 IntSet 委托给一个新的 struct，新 struct 再重写一次 Add，Delete 方法以记录步骤（保存Undo函数对象），完成 Undo 功能；<br>3、最后作者希望可以进一步改写，编写一个 Undo 栈，委托给 IntSet ，并在 IntSet 编写 Add，Delete 的方法中就完成 Undo 函数对象的保存。这也是一个实现方法。","like_count":9},{"had_liked":false,"id":260749,"user_name":"Jie","can_delete":false,"product_type":"c1","uid":1045078,"ip_address":"","ucode":"AB94041E548FEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","comment_is_top":false,"comment_ctime":1605095012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10195029604","product_id":100002201,"comment_content":"求教，最后那段代码执行undo的时候会继续添加undo函数，那样不就回不到最初的状态了？后续一直在撤销undo—撤销撤销undo……","like_count":2},{"had_liked":false,"id":98829,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1559101594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10149036186","product_id":100002201,"comment_content":"go里面这个undo功能的实现类似scala里面的trait,也是把一些功能模块（以及实现）单独封装起来，然后以委托或者继承的形式组装到类里面，这种灵活组装的方式确实比java的interface要更方便使用，不同语言之间是有共同点的","like_count":3},{"had_liked":false,"id":281842,"user_name":"Jacob.C","can_delete":false,"product_type":"c1","uid":1070253,"ip_address":"","ucode":"034998E7A7CCD1","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ad/6ee2b7cb.jpg","comment_is_top":false,"comment_ctime":1614921318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5909888614","product_id":100002201,"comment_content":"再在undo里加个反撤销的功能，就更秀了","like_count":1},{"had_liked":false,"id":70823,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1551190705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846158001","product_id":100002201,"comment_content":"依赖的东西要可靠、稳定，也就是接口。<br>业务与控制分离，控制就可以复用。<br>把变化频率不同的事物分开。","like_count":2},{"had_liked":false,"id":65517,"user_name":"寻找的人cs","can_delete":false,"product_type":"c1","uid":1293788,"ip_address":"","ucode":"CA12463D24A8E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/bd/dc/1ea396d2.jpg","comment_is_top":false,"comment_ctime":1549424821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5844392117","product_id":100002201,"comment_content":"web端功能多一点就好了，比如显示文章列表的时候感觉不如app端那么清爽","like_count":2},{"had_liked":false,"id":2583,"user_name":"Z3","can_delete":false,"product_type":"c1","uid":1000005,"ip_address":"","ucode":"CC1B59C7A53FB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/45/cdfe6842.jpg","comment_is_top":false,"comment_ctime":1517884453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5812851749","product_id":100002201,"comment_content":"sort.Ints(ints) parts := make([]string, 0, len(ints)) for _, i := range ints {<br><br><br>这块要sort吗？  能否直接for （i=0；i&lt;len）print ints[i]","like_count":1},{"had_liked":false,"id":2576,"user_name":"小破","can_delete":false,"product_type":"c1","uid":1049333,"ip_address":"","ucode":"E7980E15909E4D","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/f5/3aaae06f.jpg","comment_is_top":false,"comment_ctime":1517872923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5812840219","product_id":100002201,"comment_content":"几个月前听到代码时间做节目，陈老师讲的内容让我感觉很实在，今天终于跟过来了😃","like_count":1},{"had_liked":false,"id":317150,"user_name":"seedjyh","can_delete":false,"product_type":"c1","uid":2309641,"ip_address":"","ucode":"D590E526A9A1D7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er4IPqj4H3jQHq4C1lgKh6ZroK3CVmGLiadic7S1rxbuy09JM9x8Aib6VkozPkO4lrUTHAhicX1z9Cg2w/132","comment_is_top":false,"comment_ctime":1634695852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634695852","product_id":100002201,"comment_content":"委托模式其实就是利用了go的组合功能实现了类似C++的继承功能。就undo数组而言，继承了基类的栈、注册undo的方法和执行undo的方法。","like_count":0},{"had_liked":false,"id":317143,"user_name":"seedjyh","can_delete":false,"product_type":"c1","uid":2309641,"ip_address":"","ucode":"D590E526A9A1D7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er4IPqj4H3jQHq4C1lgKh6ZroK3CVmGLiadic7S1rxbuy09JM9x8Aib6VkozPkO4lrUTHAhicX1z9Cg2w/132","comment_is_top":false,"comment_ctime":1634694721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634694721","product_id":100002201,"comment_content":"最后的undo数组很有意思。<br>在C++里，一般是基类Undoable有一个public的实体函数Undo和一个private的纯虚函数undo，前者调用后最后；各个需要undo的子类实现这个纯虚函数。但这样就引入了强耦合（继承）。<br>在go里是注册一个闭包，让Undo数组回调。","like_count":0},{"had_liked":false,"id":268136,"user_name":"Geek_bc461b","can_delete":false,"product_type":"c1","uid":1513600,"ip_address":"","ucode":"3F86688191CC3B","user_header":"https://static001.geekbang.org/account/avatar/00/17/18/80/741d9e98.jpg","comment_is_top":false,"comment_ctime":1608082915,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1608082915","product_id":100002201,"comment_content":"单从undo功能来说用装饰器模式是不是更好","like_count":0},{"had_liked":false,"id":248423,"user_name":"你为啥那么牛","can_delete":false,"product_type":"c1","uid":1503506,"ip_address":"","ucode":"1ABC604A54A8F6","user_header":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","comment_is_top":false,"comment_ctime":1600158452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600158452","product_id":100002201,"comment_content":"写了半年的go语言了，终于体会到go语言的美感了。那种只要会嘎嘎叫的，我就认为是一只🦆的境界。😃","like_count":1},{"had_liked":false,"id":211730,"user_name":"高科","can_delete":false,"product_type":"c1","uid":1107568,"ip_address":"","ucode":"81A4DDF41D3C1C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/70/b9907b0e.jpg","comment_is_top":false,"comment_ctime":1587999626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587999626","product_id":100002201,"comment_content":"不久前刚刚把go的环境搭好，部署了一个开源应用，准备学习起来","like_count":0},{"had_liked":false,"id":180964,"user_name":"whiledoing","can_delete":false,"product_type":"c1","uid":1049643,"ip_address":"","ucode":"1BEB769E13F47C","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/2b/68d6ac0d.jpg","comment_is_top":false,"comment_ctime":1582449865,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1582449865","product_id":100002201,"comment_content":"有点不理解，为什么 Undo 的函数不是直接 delete(set.data, x)，而是 set.Delete(x)，这样子会不会导致undo 的队列一直在递归","like_count":0,"discussions":[{"author":{"id":1164195,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c3/a3/50aa836d.jpg","nickname":"特立独行的猪","note":"","ucode":"E96B277F45F60E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378135,"discussion_content":"//获取切片最后一个元素的索引\nindex := len(functions) - 1\n//这里执行的代码，会append一个元素\n...\n//删除索引之后的所有元素（包含当前索引）弹栈操作\n*undo = functions[:index]\nindex是在functions改变之前获取的，后面再怎么变都不影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623063976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324352,"discussion_content":"我也有这个疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605094814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":2619,"user_name":"xiao豪","can_delete":false,"product_type":"c1","uid":1026417,"ip_address":"","ucode":"F7969A9785E37B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/71/78796fd5.jpg","comment_is_top":false,"comment_ctime":1518067301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1518067301","product_id":100002201,"comment_content":"声明为type Inset map[int]bool就不用写成set.data[x]=true这样了，直接set[x]=true就可以了。","like_count":0},{"had_liked":false,"id":2592,"user_name":"小虾米","can_delete":false,"product_type":"c1","uid":1005528,"ip_address":"","ucode":"F543987A7FAB20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/d8/425e1b0a.jpg","comment_is_top":false,"comment_ctime":1517915050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1517915050","product_id":100002201,"comment_content":"这样写的undo在第一次插入过后，可以无限撤销了吧","like_count":0}]}