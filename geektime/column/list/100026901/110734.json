{"id":110734,"title":"35 | RESTful & Socket：行情数据对接和抓取","content":"<p>你好，我是景霄。</p><p>上一节课，我们介绍了交易所的交易模式，数字货币交易所RESTful接口的常见概念，以及如何调用RESTful接口进行订单操作。众所周知，买卖操作的前提，是你需要已知市场的最新情况。这节课里，我将介绍交易系统底层另一个最重要的部分，行情数据的对接和抓取。</p><p>行情数据，最重要的是实时性和有效性。市场的情况瞬息万变，合适的买卖时间窗口可能只有几秒。在高频交易里，合适的买卖机会甚至在毫秒级别。要知道，一次从北京发往美国的网络请求，即使是光速传播，都需要几百毫秒的延迟。更别提用Python这种解释型语言，建立HTTP连接导致的时间消耗。</p><p>经过上节课的学习，你对交易应该有了基本的了解，这也是我们今天学习的基础。接下来，我们先从交易所撮合模式讲起，然后介绍行情数据有哪些；之后，我将带你基于Websocket的行情数据来抓取模块。</p><h2>行情数据</h2><p>回顾上一节我们提到的，交易所是一个买方、卖方之间的公开撮合平台。买卖方把需要/可提供的商品数量和愿意出/接受的价格提交给交易所，交易所按照公平原则进行撮合交易。</p><p>那么撮合交易是怎么进行的呢？假设你是一个人肉比特币交易所，大量的交易订单往你这里汇总，你应该如何选择才能让交易公平呢？</p><!-- [[[read_end]]] --><p>显然，最直观的操作就是，把买卖订单分成两个表，按照价格由高到低排列。下面的图，就是买入和卖出的委托表。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/2d/6bade6ffe3b8d439b7826cbe6d84a22d.png?wh=1282*388\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/0d/4c/0d7f5bcbb766097b84b7ad36d2b26a4c.png?wh=1272*344\" alt=\"\"></p><p>如果最高的买入价格小于最低的卖出价格，那就不会有任何交易发生。这通常是你看到的委托列表的常态。</p><p>如果最高的买入价格和最低的卖出价格相同，那么就尝试进行撮合。比如BTC在9002.01就会发生撮合，最后按照9002.01的价格，成交0.0330个BTC。当然，交易完成后，小林未完成部分的订单（余下0.1126 - 0.0330 = 0.0796 个 BTC 未卖出），还会继续在委托表里。</p><p>不过你可能会想，如果买入和卖出的价格有交叉，那么成交价格又是什么呢？事实上，这种情况并不会发生。我们来试想一下下面这样的场景。</p><p>如果你尝试给一个委托列表里加入一个新买入订单，它的价格比所有已有的最高买入价格高，也比所有的卖出价格高。那么此时，它会直接从最低的卖出价格撮合。等到最低价格的卖出订单吃完了，它便开始吃价格第二低的卖出订单，直到这个买入订单完全成交。反之亦然。所以，委托列表价格不会出现交叉。</p><p>当然，请注意，这里我说的只是限价订单的交易方式。而对于市价订单，交易规则会有一些轻微的区别，这里我就不详细解释了，主要是让你有个概念。</p><p>其实说到这里，所谓的“交易所行情”概念就呼之欲出了。交易所主要有两种行情数据：委托账本（Order Book）和活动行情（Tick data）。</p><p>我们把委托表里的具体用户隐去，相同价格的订单合并，就得到了下面这种委托账本。我们主要观察右边的数字部分，其中：</p><ul>\n<li>上半部分里，第一列红色数字代表BTC的卖出价格，中间一列数字是这个价格区间的订单BTC总量，最右边一栏是从最低卖出价格到当前价格区间的积累订单量。</li>\n<li>中间的大字部分，9994.10 USD是当前的市场价格，也就是上一次成交交易的价格。</li>\n<li>下面绿色部分的含义与上半部分类似，不过指的是买入委托和对应的数量。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/74/1e/740e88e95dcab334652f8761ca58171e.png?wh=932*964\" alt=\"\"></p><center>Gemini的委托账本，来自<a href=\"https://cryptowat.ch\">https://cryptowat.ch</a></center><p>这张图中，最低的卖出价格比最高的买入价格要高 6.51 USD，这个价差通常被称为Spread。这里验证了我们前面提到的，委托账本的价格永不交叉； 同时，Spread很小也能说明这是一个非常活跃的交易所。</p><p>每一次撮合发生，意味着一笔交易（Trade）的发生。卖方买方都很开心，于是交易所也很开心地通知行情数据的订阅者：刚才发生了一笔交易，交易的价格是多少，成交数量是多少。这个数据就是活动行情Tick。</p><p>有了这些数据，我们也就掌握了这个交易所的当前状态，可以开始搞事情了。</p><h2>Websocket介绍</h2><p>在本文的开头我们提到过：行情数据很讲究时效性。所以，行情从交易所产生到传播给我们的程序之间的延迟，应该越低越好。通常，交易所也提供了REST的行情数据抓取接口。比如下面这段代码：</p><pre><code>import requests\nimport timeit\n\n\ndef get_orderbook():\n  orderbook = requests.get(&quot;https://api.gemini.com/v1/book/btcusd&quot;).json()\n\n\nn = 10\nlatency = timeit.timeit('get_orderbook()', setup='from __main__ import get_orderbook', number=n) * 1.0 / n\nprint('Latency is {} ms'.format(latency * 1000))\n\n###### 输出 #######\n\nLatency is 196.67642089999663 ms\n</code></pre><p>我在美国纽约附近城市的一个服务器上测试了这段代码，你可以看到，平均每次访问orderbook的延迟有0.25秒左右。显然，如果在国内，这个延迟只会更大。按理说，这两个美国城市的距离很短，为什么延迟会这么大呢？</p><p>这是因为，REST接口本质上是一个HTTP接口，在这之下是TCP/TLS套接字（Socket）连接。每一次REST请求，通常都会重新建立一次TCP/TLS握手；然后，在请求结束之后，断开这个链接。这个过程，比我们想象的要慢很多。</p><p>举个例子来验证这一点，在同一个城市我们试验一下。我从纽约附近的服务器和Gemini在纽约的服务器进行连接，TCP/SSL握手花了多少时间呢？</p><pre><code>curl -w &quot;TCP handshake: %{time_connect}s, SSL handshake: %{time_appconnect}s\\n&quot; -so /dev/null https://www.gemini.com\n\nTCP handshake: 0.072758s, SSL handshake: 0.119409s\n</code></pre><p>结果显示，HTTP连接构建的过程，就占了一大半时间！也就是说，我们每次用REST请求，都要浪费一大半的时间在和服务器建立连接上，这显然是非常低效的。很自然的你会想到，我们能否实现一次连接、多次通信呢？</p><p>事实上，Python的某些HTTP请求库，也可以支持重用底层的TCP/SSL连接。但那种方法，一来比较复杂，二来也需要服务器的支持。该怎么办呢？其实，在有WebSocket的情况下，我们完全不需要舍近求远。</p><p>我先来介绍一下WebSocket。WebSocket是一种在单个TCP/TLS连接上，进行全双工、双向通信的协议。WebSocket可以让客户端与服务器之间的数据交换变得更加简单高效，服务端也可以主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以直接创建持久性的连接，并进行双向数据传输。</p><p>概念听着很痛快，不过还是有些抽象。为了让你快速理解刚刚的这段话，我们还是来看两个简单的例子。二话不说，先看一段代码：</p><pre><code>import websocket\nimport thread\n\n# 在接收到服务器发送消息时调用\ndef on_message(ws, message):\n    print('Received: ' + message)\n\n# 在和服务器建立完成连接时调用   \ndef on_open(ws):\n    # 线程运行函数\n    def gao():\n        # 往服务器依次发送0-4，每次发送完休息0.01秒\n        for i in range(5):\n            time.sleep(0.01)\n            msg=&quot;{0}&quot;.format(i)\n            ws.send(msg)\n            print('Sent: ' + msg)\n        # 休息1秒用于接收服务器回复的消息\n        time.sleep(1)\n        \n        # 关闭Websocket的连接\n        ws.close()\n        print(&quot;Websocket closed&quot;)\n    \n    # 在另一个线程运行gao()函数\n    thread.start_new_thread(gao, ())\n\n\nif __name__ == &quot;__main__&quot;:\n    ws = websocket.WebSocketApp(&quot;ws://echo.websocket.org/&quot;,\n                              on_message = on_message,\n                              on_open = on_open)\n    \n    ws.run_forever()\n\n#### 输出 #####\nSent: 0\nSent: 1\nReceived: 0\nSent: 2\nReceived: 1\nSent: 3\nReceived: 2\nSent: 4\nReceived: 3\nReceived: 4\nWebsocket closed\n</code></pre><p>这段代码尝试和<code>wss://echo.websocket.org</code>建立连接。当连接建立的时候，就会启动一条线程，连续向服务器发送5条消息。</p><p>通过输出可以看出，我们在连续发送的同时，也在不断地接受消息。这并没有像REST一样，每发送一个请求，要等待服务器完成请求、完全回复之后，再进行下一个请求。换句话说，<strong>我们在请求的同时也在接受消息</strong>，这也就是前面所说的”全双工“。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/b6/7bbb7936b56dcae7f1e5dfbc644b4fb6.png?wh=1876*2491\" alt=\"\"></p><center>REST（HTTP）单工请求响应的示意图</center><p><img src=\"https://static001.geekbang.org/resource/image/9d/4c/9d4072dedfd5944a08e3bbee5059194c.png?wh=1681*2596\" alt=\"\"></p><center>Websocket全双工请求响应的示意图</center><p>再来看第二段代码。为了解释”双向“，我们来看看获取Gemini的委托账单的例子。</p><pre><code>import ssl\nimport websocket\nimport json\n\n# 全局计数器\ncount = 5\n\ndef on_message(ws, message):\n    global count\n    print(message)\n    count -= 1\n    # 接收了5次消息之后关闭websocket连接\n    if count == 0:\n        ws.close()\n\nif __name__ == &quot;__main__&quot;:\n    ws = websocket.WebSocketApp(\n        &quot;wss://api.gemini.com/v1/marketdata/btcusd?top_of_book=true&amp;offers=true&quot;,\n        on_message=on_message)\n    ws.run_forever(sslopt={&quot;cert_reqs&quot;: ssl.CERT_NONE})\n\n###### 输出 #######\n{&quot;type&quot;:&quot;update&quot;,&quot;eventId&quot;:7275473603,&quot;socket_sequence&quot;:0,&quot;events&quot;:[{&quot;type&quot;:&quot;change&quot;,&quot;reason&quot;:&quot;initial&quot;,&quot;price&quot;:&quot;11386.12&quot;,&quot;delta&quot;:&quot;1.307&quot;,&quot;remaining&quot;:&quot;1.307&quot;,&quot;side&quot;:&quot;ask&quot;}]}\n{&quot;type&quot;:&quot;update&quot;,&quot;eventId&quot;:7275475120,&quot;timestamp&quot;:1562380981,&quot;timestampms&quot;:1562380981991,&quot;socket_sequence&quot;:1,&quot;events&quot;:[{&quot;type&quot;:&quot;change&quot;,&quot;side&quot;:&quot;ask&quot;,&quot;price&quot;:&quot;11386.62&quot;,&quot;remaining&quot;:&quot;1&quot;,&quot;reason&quot;:&quot;top-of-book&quot;}]}\n{&quot;type&quot;:&quot;update&quot;,&quot;eventId&quot;:7275475271,&quot;timestamp&quot;:1562380982,&quot;timestampms&quot;:1562380982387,&quot;socket_sequence&quot;:2,&quot;events&quot;:[{&quot;type&quot;:&quot;change&quot;,&quot;side&quot;:&quot;ask&quot;,&quot;price&quot;:&quot;11386.12&quot;,&quot;remaining&quot;:&quot;1.3148&quot;,&quot;reason&quot;:&quot;top-of-book&quot;}]}\n{&quot;type&quot;:&quot;update&quot;,&quot;eventId&quot;:7275475838,&quot;timestamp&quot;:1562380986,&quot;timestampms&quot;:1562380986270,&quot;socket_sequence&quot;:3,&quot;events&quot;:[{&quot;type&quot;:&quot;change&quot;,&quot;side&quot;:&quot;ask&quot;,&quot;price&quot;:&quot;11387.16&quot;,&quot;remaining&quot;:&quot;0.072949&quot;,&quot;reason&quot;:&quot;top-of-book&quot;}]}\n{&quot;type&quot;:&quot;update&quot;,&quot;eventId&quot;:7275475935,&quot;timestamp&quot;:1562380986,&quot;timestampms&quot;:1562380986767,&quot;socket_sequence&quot;:4,&quot;events&quot;:[{&quot;type&quot;:&quot;change&quot;,&quot;side&quot;:&quot;ask&quot;,&quot;price&quot;:&quot;11389.22&quot;,&quot;remaining&quot;:&quot;0.06204196&quot;,&quot;reason&quot;:&quot;top-of-book&quot;}]}\n</code></pre><p>可以看到，在和Gemini建立连接后，我们并没有向服务器发送任何消息，没有任何请求，但是服务器却源源不断地向我们推送数据。这可比REST接口“每请求一次获得一次回复”的沟通方式高效多了！</p><p>因此，相对于REST来说，Websocket是一种更加实时、高效的数据交换方式。当然缺点也很明显：因为请求和回复是异步的，这让我们程序的状态控制逻辑更加复杂。这一点，后面的内容里我们会有更深刻的体会。</p><h2>行情抓取模块</h2><p>有了 Websocket 的基本概念，我们就掌握了和交易所连接的第二种方式。</p><p>事实上，Gemini 提供了两种 Websocket 接口，一种是 Public 接口，一种为 Private 接口。</p><p>Public 接口，即公开接口，提供 orderbook 服务，即每个人都能看到的当前挂单价和深度，也就是我们这节课刚刚详细讲过的 orderbook。</p><p>而 Private 接口，和我们上节课讲的挂单操作有关，订单被完全执行、被部分执行等等其他变动，你都会得到通知。</p><p>我们以 orderbook 爬虫为例，先来看下如何抓取 orderbook 信息。下面的代码详细写了一个典型的爬虫，同时使用了类进行封装，希望你不要忘记我们这门课的目的，了解  Python 是如何应用于工程实践中的：</p><pre><code>import copy\nimport json\nimport ssl\nimport time\nimport websocket\n\n\nclass OrderBook(object):\n\n    BIDS = 'bid'\n    ASKS = 'ask'\n\n    def __init__(self, limit=20):\n\n        self.limit = limit\n\n        # (price, amount)\n        self.bids = {}\n        self.asks = {}\n\n        self.bids_sorted = []\n        self.asks_sorted = []\n\n    def insert(self, price, amount, direction):\n        if direction == self.BIDS:\n            if amount == 0:\n                if price in self.bids:\n                    del self.bids[price]\n            else:\n                self.bids[price] = amount\n        elif direction == self.ASKS:\n            if amount == 0:\n                if price in self.asks:\n                    del self.asks[price]\n            else:\n                self.asks[price] = amount\n        else:\n            print('WARNING: unknown direction {}'.format(direction))\n\n    def sort_and_truncate(self):\n        # sort\n        self.bids_sorted = sorted([(price, amount) for price, amount in self.bids.items()], reverse=True)\n        self.asks_sorted = sorted([(price, amount) for price, amount in self.asks.items()])\n\n        # truncate\n        self.bids_sorted = self.bids_sorted[:self.limit]\n        self.asks_sorted = self.asks_sorted[:self.limit]\n\n        # copy back to bids and asks\n        self.bids = dict(self.bids_sorted)\n        self.asks = dict(self.asks_sorted)\n\n    def get_copy_of_bids_and_asks(self):\n        return copy.deepcopy(self.bids_sorted), copy.deepcopy(self.asks_sorted)\n\n\nclass Crawler:\n    def __init__(self, symbol, output_file):\n        self.orderbook = OrderBook(limit=10)\n        self.output_file = output_file\n\n        self.ws = websocket.WebSocketApp('wss://api.gemini.com/v1/marketdata/{}'.format(symbol),\n                                         on_message = lambda ws, message: self.on_message(message))\n        self.ws.run_forever(sslopt={'cert_reqs': ssl.CERT_NONE})\n\n    def on_message(self, message):\n        # 对收到的信息进行处理，然后送给 orderbook\n        data = json.loads(message)\n        for event in data['events']:\n            price, amount, direction = float(event['price']), float(event['remaining']), event['side']\n            self.orderbook.insert(price, amount, direction)\n\n        # 整理 orderbook，排序，只选取我们需要的前几个\n        self.orderbook.sort_and_truncate()\n\n        # 输出到文件\n        with open(self.output_file, 'a+') as f:\n            bids, asks = self.orderbook.get_copy_of_bids_and_asks()\n            output = {\n                'bids': bids,\n                'asks': asks,\n                'ts': int(time.time() * 1000)\n            }\n            f.write(json.dumps(output) + '\\n')\n\n\nif __name__ == '__main__':\n    crawler = Crawler(symbol='BTCUSD', output_file='BTCUSD.txt')\n\n###### 输出 #######\n\n{&quot;bids&quot;: [[11398.73, 0.96304843], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.95, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], &quot;asks&quot;: [[11407.42, 1.30814001], [11407.92, 1.0], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11412.42, 1.0], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], &quot;ts&quot;: 1562558996535}\n{&quot;bids&quot;: [[11398.73, 0.96304843], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.95, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], &quot;asks&quot;: [[11407.42, 1.30814001], [11407.92, 1.0], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11412.42, 1.0], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], &quot;ts&quot;: 1562558997377}\n{&quot;bids&quot;: [[11398.73, 0.96304843], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.95, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], &quot;asks&quot;: [[11407.42, 1.30814001], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11412.42, 1.0], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], &quot;ts&quot;: 1562558997765}\n{&quot;bids&quot;: [[11398.73, 0.96304843], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.95, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], &quot;asks&quot;: [[11407.42, 1.30814001], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], &quot;ts&quot;: 1562558998638}\n{&quot;bids&quot;: [[11398.73, 0.97131753], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.95, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], &quot;asks&quot;: [[11407.42, 1.30814001], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], &quot;ts&quot;: 1562558998645}\n{&quot;bids&quot;: [[11398.73, 0.97131753], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], &quot;asks&quot;: [[11407.42, 1.30814001], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], &quot;ts&quot;: 1562558998748}\n</code></pre><p>代码比较长，接下来我们具体解释一下。</p><p>这段代码的最开始，封装了一个叫做 orderbook 的 class，专门用来存放与之相关的数据结构。其中的 bids 和 asks 两个字典，用来存储当前时刻下的买方挂单和卖方挂单。</p><p>此外，我们还专门维护了一个排过序的 bids_sorted 和 asks_sorted。构造函数有一个参数 limit，用来指示 orderbook 的 bids 和 asks 保留多少条数据。对于很多策略，top 5 的数据往往足够，这里我们选择的是前 10 个。</p><p>再往下看，insert() 函数用于向 orderbook 插入一条数据。需要注意，这里的逻辑是，如果某个 price 对应的 amount 是 0，那么意味着这一条数据已经不存在了，删除即可。insert 的数据可能是乱序的，因此在需要的时候，我们要对 bids 和 asks 进行排序，然后选取前面指定数量的数据。这其实就是 sort_and_truncate() 函数的作用，调用它来对 bids 和 asks 排序后截取，最后保存回 bids 和 asks。</p><p>接下来的 get_copy_of_bids_and_asks()函数，用来返回排过序的 bids 和 asks 数组。这里使用深拷贝，是因为如果直接返回，将会返回 bids_sorted 和 asks_sorted 的指针；那么，在下一次调用 sort_and_truncate() 函数的时候，两个数组的内容将会被改变，这就造成了潜在的 bug。</p><p>最后来看一下 Crawler 类。构造函数声明 orderbook，然后定义 Websocket 用来接收交易所数据。这里需要注意的一点是，回调函数 on_message() 是一个类成员函数。因此，应该你注意到了，它的第一个参数是 self，这里如果直接写成 <code>on_message = self.on_message</code> 将会出错。</p><p>为了避免这个问题，我们需要将函数再次包装一下。这里我使用了前面学过的匿名函数，来传递中间状态，注意我们只需要 message，因此传入 message 即可。</p><p>剩下的部分就很清晰了，on_message 回调函数在收到一个新的 tick 时，先将信息解码，枚举收到的所有改变；然后插入 orderbook，排序；最后连同 timestamp 一并输出即可。</p><p>虽然这段代码看起来挺长，但是经过我这么一分解，是不是发现都是学过的知识点呢？这也是我一再强调基础的原因，如果对你来说哪部分内容变得陌生了（比如面向对象编程的知识点），一定要记得及时往前复习，这样你学起新的更复杂的东西，才能轻松很多。</p><p>回到正题。刚刚的代码，主要是为了抓取 orderbook 的信息。事实上，Gemini 交易所在建立数据流 Websocket 的时候，第一条信息往往非常大，因为里面包含了那个时刻所有的 orderbook 信息。这就叫做初始数据。之后的消息，都是基于初始数据进行修改的，直接处理即可。</p><h2>总结</h2><p>这节课我们继承上一节，从委托账本讲起，然后讲述了 WebSocket 的定义、工作机制和使用方法，最后以一个例子收尾，带你学会如何爬取 Orderbook 的信息。希望你在学习这节课的内容时，能够和上节课的内容联系起来，仔细思考 Websocket 和 RESTFul 的区别，并试着总结网络编程中不同模型的适用范围。</p><h2>思考题</h2><p>最后给你留一道思考题。WebSocket 会丢包吗？如果丢包的话， Orderbook 爬虫又会发生什么？这一点应该如何避免呢？欢迎留言和我讨论，也欢迎你把这篇文章分享出去。</p>","comments":[{"had_liked":false,"id":119464,"user_name":"Jingxiao","can_delete":false,"product_type":"c1","uid":1259521,"ip_address":"","ucode":"EB966BB87132F6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","comment_is_top":true,"comment_ctime":1564601608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233722359879004e+18","product_id":100026901,"comment_content":"思考题答案：<br>Websocket 可能丢包。TCP 协议保证了所有的包按顺序抵达（即使是乱序抵达，在前面的包收到之前，TCP 协议下的底层程序也会讲先到达的靠后的包缓存，直到前面的包抵达，才送给上层的应用程序），但是并不能保证不可恢复的错误发生的时候，包不会丢失。这种情况发生的时候，就会出现 Orderbook 中一个或多个（价格，数量）信息没得到及时更新。这种错误越积攒越多的情况下，就会导致本地的 Orderbook 充满垃圾信息，变得完全不可靠。因此一个很好的做法是，可以设置一个时间间隔，通过 RESTFul 或者其他方式重新抓一下 Orderbook 的 Snapshot，然后和本地的 Orderbook 进行比对，纠正错误。","like_count":47},{"had_liked":false,"id":118527,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1564381268,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"186247974996","product_id":100026901,"comment_content":"websocket包的安装使用如下命令:<br><br>pip -m install websocket_client安装。<br><br>pip -m install websocket会安装另外一个完全不同的包","like_count":44,"discussions":[{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342667,"discussion_content":"pip -m install websocket会安装另外一个完全不同的包\n这里的websocket是什么东西呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610770985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118528,"user_name":"SCAR","can_delete":false,"product_type":"c1","uid":1031209,"ip_address":"","ucode":"38C0927FA3C5FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/29/022905e6.jpg","comment_is_top":false,"comment_ctime":1564381372,"is_pvip":false,"replies":[{"id":"43826","content":"👍","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1564622855,"ip_address":"","comment_id":118528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"181953007804","product_id":100026901,"comment_content":"思考题：<br>1. websocket基于tcp的，虽然协议上有纠错，重传和等待的机制，但一些特殊的情况还是可能会有丢包的情况，比如同时有超过服务器负载的客户端在请求数据。<br>2.如果丢包的情况发生时，类似开大会会场人人都发微信图片，看着WiFi信号满格，却发不出去，差不多一样的道理爬虫也是收不到数据的。<br>3.查了下websocket的WebSocketApp的函数，有个参数on_error，是websocket发生错误的时候触发的，那么我们可以编写这个对应的回调函数来让服务器重发或者其他有效的处理。","like_count":43,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460440,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564622855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118594,"user_name":"tux","can_delete":false,"product_type":"c1","uid":1477811,"ip_address":"","ucode":"BB7202009FC885","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/b3/a74a7125.jpg","comment_is_top":false,"comment_ctime":1564393229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61693935373","product_id":100026901,"comment_content":"干布球和tt 的提示，解决了报错。<br>import websocket     #pip install websocket-client<br>import _thread as thread<br><br>在查找资料时，看到了：<br>import websocket<br>try:<br>    import thread<br>except ImportError:<br>    import _thread as thread<br>","like_count":15},{"had_liked":false,"id":120543,"user_name":"Claywoow","can_delete":false,"product_type":"c1","uid":1524797,"ip_address":"","ucode":"1F1C70BCE33536","user_header":"https://static001.geekbang.org/account/avatar/00/17/44/3d/35d6670d.jpg","comment_is_top":false,"comment_ctime":1564926295,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31629697367","product_id":100026901,"comment_content":"老师，请教个问题，为什么我把这两个类分成两个模块来测试的时候，程序会进入无响应的状态，好像一直在运行，这会是什么原因呢？","like_count":7,"discussions":[{"author":{"id":2684646,"avatar":"","nickname":"Geek_cce35a","note":"","ucode":"0AC7505A043C16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384729,"discussion_content":"我也是这个情况","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626721901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118457,"user_name":"干布球","can_delete":false,"product_type":"c1","uid":1218173,"ip_address":"","ucode":"048ABC199D89B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/7d/c7e8cd34.jpg","comment_is_top":false,"comment_ctime":1564368052,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31629139124","product_id":100026901,"comment_content":"第二段代码少了个import time，python3里面thread用import _thread，不知是不是这样？","like_count":7,"discussions":[{"author":{"id":1043780,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/44/2267a5a7.jpg","nickname":"一期一会","note":"","ucode":"1C44A6453F6381","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6684,"discussion_content":"我也发现了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567049409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118520,"user_name":"SCAR","can_delete":false,"product_type":"c1","uid":1031209,"ip_address":"","ucode":"38C0927FA3C5FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/29/022905e6.jpg","comment_is_top":false,"comment_ctime":1564380459,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"27334184235","product_id":100026901,"comment_content":"尝试回答下Destroy的问题：<br>查看WebsocketApp函数：<br>on_message: callable object which is called when received data.<br> on_message has 2 arguments.<br> The 1st argument is this class object.<br> The 2nd argument is utf-8 string which we get from the server.<br>你如果直接on_message = self.on_message，那么会缺少第一个参数，因为class Crawler类里on_message(self,message)是缺少如最上面老师例子def on_message(ws, message)里的ws的。所以<br>on_message = lambda ws, message: self.on_message(message)是通过lambda补上第一个参数ws。","like_count":7,"discussions":[{"author":{"id":1101006,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","nickname":"jxs1211","note":"","ucode":"B7F1F2D84389E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3780,"discussion_content":"实测on_message = self.on_message没有问题，源码中_callback中只是对回调函数做了类型判断，self.on_message是和method，所以直接将返回data给了形参message，执行接受数据的处理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564806261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2369413,"avatar":"https://static001.geekbang.org/account/avatar/00/24/27/85/ddeeaf30.jpg","nickname":"dived","note":"","ucode":"141916A3BAF5A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101006,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","nickname":"jxs1211","note":"","ucode":"B7F1F2D84389E7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375309,"discussion_content":"直接这样写是不会返回任何东西的，当然也不会报错\n得把类函数def on_message(self,  message)改成def on_message(self, ws, message)才有效果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621569932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3780,"ip_address":""},"score":375309,"extra":""}]},{"author":{"id":1229070,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","nickname":"蜉蝣","note":"","ucode":"77CF92496855D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6058,"discussion_content":"```python\n                if inspect.ismethod(callback):\n                    callback(*args)\n                else:\n                    callback(self, *args)\n```\nwebsocket-client 0.56 中有以上源码。对传入对象有一个判断，如果是[方法]，则不需要把 self 传进去，也就是老师代码里的 ws; 如果不是 [方法]，那么正确传参情况下就会是[函数]，此时会把 self 传进入。其他版本如何处理的就不得而知了。\n\n额外想说，私以为这样的设计是为了让使用者在自己设计的类中强制绑定一个 WebSocketApp 对象，避免用户在使用类的情况下还把 ws 到处传。减免了资源开销，还做到了让代码简洁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566645812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120204,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1564806274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18744675458","product_id":100026901,"comment_content":"实测on_message = self.on_message没有问题，源码中_callback中只是对回调函数做了类型判断，self.on_message是和method，所以直接将返回data给了形参message，执行接受数据的处理","like_count":4},{"had_liked":false,"id":118553,"user_name":"JustDoDT","can_delete":false,"product_type":"c1","uid":1127175,"ip_address":"","ucode":"6AF0B80F00EAEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","comment_is_top":false,"comment_ctime":1564386982,"is_pvip":false,"replies":[{"id":"43825","content":"👍","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1564622776,"ip_address":"","comment_id":118553,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18744256166","product_id":100026901,"comment_content":"websocket资料<br>https:&#47;&#47;pypi.org&#47;project&#47;websocket_client&#47;","like_count":5,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460451,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564622776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118472,"user_name":"TKbook","can_delete":false,"product_type":"c1","uid":1073829,"ip_address":"","ucode":"F6E0E99CC79059","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/a5/43aa0c27.jpg","comment_is_top":false,"comment_ctime":1564371406,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14449273294","product_id":100026901,"comment_content":"因此，应该你注意到了，它的第一个参数是 self，这里如果直接写成 on_message = self.on_message 将会出错。<br>为了避免这个问题，我们需要将函数再次包装一下。这里我使用了前面学过的匿名函数，来传递中间状态，注意我们只需要 message，因此传入 message 即可。<br>这段没看懂，老师或者哪位大神能解释一下？","like_count":3,"discussions":[{"author":{"id":1026955,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/8b/fdb853c4.jpg","nickname":"Weining Cao","note":"","ucode":"6E3DB699A41518","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157994,"discussion_content":"这里一开始我也没看懂，后来回过头复习了老师lambda函数的课，试着来解释下。\non_message一般是绑定一个带2个参数的普通函数的。这里self. on_message是类的成员函数，所以需要转换成普通的双参数函数。怎么转呢？\nf = lambda ws，message: self.on_message(message)\n\n这个定义的意思就是你可以直接调用f(ws, message), 它等价于调用self.on_message(message)。所以这里我发现lambda函数可以有如此巧妙的用法：把类的成员函数转换成一个普通函数。\n\n不知道我的理解对不对。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580539792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3296,"discussion_content":"调用类的绑定方法时，如果把方法看做普通函数，那这个函数的第一个参数是必须是self。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564379460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299760,"user_name":"BinyGo","can_delete":false,"product_type":"c1","uid":2639381,"ip_address":"","ucode":"182ADA4532C98B","user_header":"https://static001.geekbang.org/account/avatar/00/28/46/15/0f215f66.jpg","comment_is_top":false,"comment_ctime":1624848418,"is_pvip":true,"discussion_count":0,"race_medal":3,"score":"10214783010","product_id":100026901,"comment_content":"    理解：on_message = lambda ws, message: self.on_message(message)<br>    我们先来看一个lambda的函数写法：<br>    g = lambda x, y=2, z=3: x + y + z<br>    g(1, z=4, y=5)  # 输出结果是10<br>    这个表达式也可以写成<br>    def g(x, y=2, z=3):<br>        return x + y + z<br><br><br>    那么再来理解老师的写法，也就好理解多了<br><br>    websocket原本的on_message被我们修改为匿名函数，<br>    也就是当websocket回调的时候，本来是带2个参数ws和message去找on_message函数的，变成了去找我们写的匿名函数<br>    on_message(ws, message)，改成匿名函数：anonymous(ws, message)，也对应了lambda ws, message 因此这里参数必须一致<br>    def anonymous(ws, message):  # 这里函数名称随意，因为是匿名函数，只是来理解lambda的写法<br>        self.on_message(message) #这里再让程序去执行我们需要的代码。绕了一个圈<br><br>    为了验证这个逻辑流程，下面2行代码参数名改一下，做一个输出，执行老师的代码大概就20多秒就有打印采集的数据，验证成功<br>    self.ws = websocket.WebSocketApp(&#39;wss:&#47;&#47;api.gemini.com&#47;v1&#47;marketdata&#47;{}&#39;.format(symbol),<br>                                     on_message=lambda gg, mmm: self.on_message(mmm))<br>    def on_message(self, mmm):<br>        print(mmm)<br>    最后不知道有没更优美的写法呢？？？","like_count":2},{"had_liked":false,"id":219188,"user_name":"shiziwen","can_delete":false,"product_type":"c1","uid":1016917,"ip_address":"","ucode":"ADADC770D82D66","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/55/1e40bd61.jpg","comment_is_top":false,"comment_ctime":1589963745,"is_pvip":false,"replies":[{"id":"84947","content":"orderbook 的买方和卖方：https:&#47;&#47;www.investopedia.com&#47;terms&#47;b&#47;bid-and-ask.asp","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1593301613,"ip_address":"","comment_id":219188,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179898337","product_id":100026901,"comment_content":"请问文章中，接口获取的数据中，bids和ask是什么意思呢？","like_count":2,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495706,"discussion_content":"orderbook 的买方和卖方：https://www.investopedia.com/terms/b/bid-and-ask.asp","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593301613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179828,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1582105798,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"10172040390","product_id":100026901,"comment_content":"网络编程没有经验，想问下老师，我用的是Python3，用ws = websocket.WebSocketApp(&quot;ws:&#47;&#47;echo.websocket.org&#47;&quot;,<br>                              on_message = on_message,<br>                              on_open = on_open)是报错的，错误信息：AttributeError: module &#39;websocket&#39; has no attribute &#39;WebSocketApp&#39;，这是什么原因？","like_count":2,"discussions":[{"author":{"id":2143277,"avatar":"https://static001.geekbang.org/account/avatar/00/20/b4/2d/44680897.jpg","nickname":"Resolution","note":"","ucode":"F74C067C58CD05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341496,"discussion_content":"装一下websocket-client-py3  这个包就可以了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1610437770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021548,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/96/6c/1ed88ae9.jpg","nickname":"saneryee","note":"","ucode":"607A1BF09391ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328683,"discussion_content":"还有文件名不要命名为 websocket.py，否则也会出现这个错误。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606208822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032464,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c1/10/28d5a686.jpg","nickname":"Longerian","note":"","ucode":"0B74EE70D09A2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228972,"discussion_content":"如果是在jupyter里测试，已经安装里 websocket，可以要先卸载websocket，再重新安装下 websocket-client，再重启下jupyter","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586596667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1705468,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/05/fc/bceb3f2b.jpg","nickname":"开心哥","note":"","ucode":"D44C1F03B23C5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226621,"discussion_content":"这个说是要装websocket_client","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586437529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155930,"user_name":"Merlin","can_delete":false,"product_type":"c1","uid":1151085,"ip_address":"","ucode":"3EBF6C78C5F731","user_header":"https://static001.geekbang.org/account/avatar/00/11/90/6d/f0dd5cb3.jpg","comment_is_top":false,"comment_ctime":1574779909,"is_pvip":false,"replies":[{"id":"60078","content":"嗯嗯","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1574900538,"ip_address":"","comment_id":155930,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164714501","product_id":100026901,"comment_content":"对于web socket的编程，可以用asyncio，我觉得用asyncio来开发web socket更为方便","like_count":2,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475930,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574900538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118912,"user_name":"Geek_adeba6","can_delete":false,"product_type":"c1","uid":1313206,"ip_address":"","ucode":"78B05B44FCC268","user_header":"","comment_is_top":false,"comment_ctime":1564466785,"is_pvip":false,"replies":[{"id":"43824","content":"理论上他可以这么做，但是 Gemini 目前官方只支持 RESTFul 和 Websocket，以及金融工程中经常用到的 FIX 协议，这些协议都有着广泛支持的开源库和经过充分时间验证的安全性，切换到新的协议没有太大必要，但是以后的事情谁也说不定呢","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1564622765,"ip_address":"","comment_id":118912,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10154401377","product_id":100026901,"comment_content":"想请问是否可以使用STOMP协议与Gemini这样的交易平台通信, 像消息队列rabbitmq 有 stomp的plugins","like_count":3,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460658,"discussion_content":"理论上他可以这么做，但是 Gemini 目前官方只支持 RESTFul 和 Websocket，以及金融工程中经常用到的 FIX 协议，这些协议都有着广泛支持的开源库和经过充分时间验证的安全性，切换到新的协议没有太大必要，但是以后的事情谁也说不定呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564622765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333272,"user_name":"Geek_688e7c","can_delete":false,"product_type":"c1","uid":1763183,"ip_address":"","ucode":"1361D27AA36772","user_header":"","comment_is_top":false,"comment_ctime":1644242171,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5939209467","product_id":100026901,"comment_content":"按照老师的代码来都没有反应，是不是Url失效了？ 我直接在浏览器里访问Url是说无法访问。<br>出现程序运行没有报错但是没有任何输出和结果的情况，是不是就是服务端出了问题呢","like_count":2,"discussions":[{"author":{"id":1177382,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f7/26/0e254010.jpg","nickname":"王佳","note":"","ucode":"C447B807ED4CDA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586052,"discussion_content":"url需要梯子才能访问，开了梯子之后需要在代码中增加proxy项，参照下面的链接就可以了\nhttps://blog.csdn.net/tz_zs/article/details/119363470","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661949174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1085046,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/76/6d55e26f.jpg","nickname":"张晓辉","note":"","ucode":"1CD9717DE399C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552183,"discussion_content":"同样的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645339746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131285,"user_name":"hel793","can_delete":false,"product_type":"c1","uid":1414844,"ip_address":"","ucode":"4E4F51EE321162","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKxqOFPRvW2d6WEC705zuSSvxBOBxibBib4XQxBGAGPOx2bRGqhsSeQkUNa0Z11OJoKbuGsNaMR4GNg/132","comment_is_top":false,"comment_ctime":1567691985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862659281","product_id":100026901,"comment_content":"Latency is 2630.9838048 ms","like_count":1},{"had_liked":false,"id":129910,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1567324279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862291575","product_id":100026901,"comment_content":"最近在复习js的相关知识，js中socket.io库封装了websocket，同时也包含了其他连接方式，比如ajax。socket.on(event_name, callback)中的内置事件名有10种。https:&#47;&#47;socket.io&#47;docs&#47;client-api&#47;","like_count":1},{"had_liked":false,"id":120213,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1564807952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859775248","product_id":100026901,"comment_content":"会丢包，在on_error(ws, error)回调函数中做处理","like_count":1},{"had_liked":false,"id":345586,"user_name":"肖肖","can_delete":false,"product_type":"c1","uid":1500176,"ip_address":"","ucode":"5F958993EA8E4A","user_header":"","comment_is_top":false,"comment_ctime":1652413455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652413455","product_id":100026901,"comment_content":"并发执行websocket连接，都能连接成功，但都立马断了，只会连接一个，是什么原因呢","like_count":0},{"had_liked":false,"id":340647,"user_name":"Geek_fc975d","can_delete":false,"product_type":"c1","uid":2459939,"ip_address":"","ucode":"05B6507FE4349B","user_header":"https://static001.geekbang.org/account/avatar/00/25/89/23/e71f180b.jpg","comment_is_top":false,"comment_ctime":1648990388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648990388","product_id":100026901,"comment_content":"我安装了websocket_Client了，但是发现这个函数run_foreve总是提示找不到对应函数，请问大家有遇到相同问题的吗？","like_count":0},{"had_liked":false,"id":320665,"user_name":"小庞","can_delete":false,"product_type":"c1","uid":1554764,"ip_address":"","ucode":"7C8367CDB47163","user_header":"https://static001.geekbang.org/account/avatar/00/17/b9/4c/8c9edc85.jpg","comment_is_top":false,"comment_ctime":1636444984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636444984","product_id":100026901,"comment_content":"sha384是非对称算法？难道不是计算消息认证码的吗？解决不可否认性和完整性的","like_count":0},{"had_liked":false,"id":300346,"user_name":"Ilovek8s","can_delete":false,"product_type":"c1","uid":1542450,"ip_address":"","ucode":"64DF0F7D0CF0B0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a8PMLmCTCBa40j7JIy3d8LsdbW5hne7lkk9KOGQuiaeVk4cn06KWwlP3ic69BsQLpNFtRTjRdUM2ySDBAv1MOFfA/132","comment_is_top":false,"comment_ctime":1625124633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625124633","product_id":100026901,"comment_content":"http2最怕包头阻塞","like_count":0},{"had_liked":false,"id":256518,"user_name":"Geek_a16bbc","can_delete":false,"product_type":"c1","uid":2008721,"ip_address":"","ucode":"6F12AFEF638413","user_header":"","comment_is_top":false,"comment_ctime":1603646155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603646155","product_id":100026901,"comment_content":"還是不能理解為何需要用lambda才能把self傳進去？<br>lambda ws, message: self.on_message(message))<br>ws 和self有什麼關係？","like_count":0},{"had_liked":false,"id":234252,"user_name":"daowuli_chihai","can_delete":false,"product_type":"c1","uid":2017371,"ip_address":"","ucode":"13E5DD278D8E95","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIiaeebUYxl7e1b8DhQGz7v6uibGcytfL8iaTke1S6NwSVxicOy5iaLGbRn2aZtxZy8vVnF6j3fjtxDEbQ/132","comment_is_top":false,"comment_ctime":1594630805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594630805","product_id":100026901,"comment_content":"下面代码 【import thread】报错，python3要不要改成【import _thread】<br><br><br>import websocket<br>import thread<br><br># 在接收到服务器发送消息时调用<br>def on_message(ws, message):<br>    print(&#39;Received: &#39; + message)<br><br># 在和服务器建立完成连接时调用   <br>def on_open(ws):<br>    # 线程运行函数<br>    def gao():<br>        # 往服务器依次发送0-4，每次发送完休息0.01秒<br>        for i in range(5):<br>            time.sleep(0.01)<br>            msg=&quot;{0}&quot;.format(i)<br>            ws.send(msg)<br>            print(&#39;Sent: &#39; + msg)<br>        # 休息1秒用于接收服务器回复的消息<br>        time.sleep(1)<br>        <br>        # 关闭Websocket的连接<br>        ws.close()<br>        print(&quot;Websocket closed&quot;)<br>    <br>    # 在另一个线程运行gao()函数<br>    thread.start_new_thread(gao, ())<br><br><br>if __name__ == &quot;__main__&quot;:<br>    ws = websocket.WebSocketApp(&quot;ws:&#47;&#47;echo.websocket.org&#47;&quot;,<br>                              on_message = on_message,<br>                              on_open = on_open)<br>    <br>    ws.run_forever()<br><br>#### 输出 #####<br>Sent: 0<br>Sent: 1<br>Received: 0<br>Sent: 2<br>Received: 1<br>Sent: 3<br>Received: 2<br>Sent: 4<br>Received: 3<br>Received: 4<br>Websocket closed","like_count":0},{"had_liked":false,"id":219144,"user_name":"shiziwen","can_delete":false,"product_type":"c1","uid":1016917,"ip_address":"","ucode":"ADADC770D82D66","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/55/1e40bd61.jpg","comment_is_top":false,"comment_ctime":1589955490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589955490","product_id":100026901,"comment_content":"想问一个业务逻辑的问题，想获取一段时间内的订单，用来测试自己的交易所逻辑，应该使用哪个接口呢？orderbook和tick data的概念还没有理解透。<br>Gemini的账户没有注册成功，所以调试遇到了些问题。","like_count":0},{"had_liked":false,"id":180670,"user_name":"YqY","can_delete":false,"product_type":"c1","uid":1524154,"ip_address":"","ucode":"73FB936045DCB9","user_header":"https://static001.geekbang.org/account/avatar/00/17/41/ba/ae028565.jpg","comment_is_top":false,"comment_ctime":1582361413,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582361413","product_id":100026901,"comment_content":"请问抓取 orderbook 信息的脚本在第50和51行转换成字典的意义何在？没怎么看明白，请老师解答下","like_count":0,"discussions":[{"author":{"id":1352697,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a3/f9/9180d6d1.jpg","nickname":"szm","note":"","ucode":"53E753D3D04431","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263064,"discussion_content":"这么设计的结果是买卖字典最多保留10条信息，可能是这就已经足够策略分析了吧，而且这样可以降低后面每次更新message时的处理时间，因为从第二次接受message回调时，字典最多只有10条信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589168554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120206,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1564806679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564806679","product_id":100026901,"comment_content":"请问老师，下面代码中select.select是什么意思，这段代码主要起到什么作用<br>class Dispatcher:<br>    def __init__(self, app, ping_timeout):<br>        self.app  = app<br>        self.ping_timeout = ping_timeout<br><br>    def read(self, sock, read_callback, check_callback):<br>        while self.app.sock.connected:<br>            r, w, e = select.select(<br>                    (self.app.sock.sock, ), (), (), self.ping_timeout)<br>            if r:<br>                if not read_callback():<br>                    break<br>            check_callback()<br>","like_count":0},{"had_liked":false,"id":119279,"user_name":"_stuView","can_delete":false,"product_type":"c1","uid":1244561,"ip_address":"","ucode":"C2D4AAB08515F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/91/65ff3154.jpg","comment_is_top":false,"comment_ctime":1564549647,"is_pvip":false,"replies":[{"id":"43823","content":"如果一定要回答 Python 是不是解释型语言，那么答案是它是部分编译型语言。它和 Java 类似，不会像 C++ 一样编译到机器语言，而是编译成字节码来提高执行速度。https:&#47;&#47;stackoverflow.com&#47;questions&#47;6889747&#47;is-python-interpreted-or-compiled-or-both","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1564622570,"ip_address":"","comment_id":119279,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1564549647","product_id":100026901,"comment_content":"我之前看到Linux公众号讲python并不是一个解释型语言，而是一个运行在虚拟机上的语言https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Yqwk_eXO1t5N2cjRz_u0sw","like_count":0,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460822,"discussion_content":"如果一定要回答 Python 是不是解释型语言，那么答案是它是部分编译型语言。它和 Java 类似，不会像 C++ 一样编译到机器语言，而是编译成字节码来提高执行速度。https://stackoverflow.com/questions/6889747/is-python-interpreted-or-compiled-or-both","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564622570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244561,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fd/91/65ff3154.jpg","nickname":"_stuView","note":"","ucode":"C2D4AAB08515F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3601,"discussion_content":"好的，谢谢您","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564628574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119088,"user_name":"enjoylearning","can_delete":false,"product_type":"c1","uid":1000237,"ip_address":"","ucode":"DCAF8538DEA277","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","comment_is_top":false,"comment_ctime":1564501053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564501053","product_id":100026901,"comment_content":"既然是网络传输就一定会丢包，所以需要建一个队列","like_count":0},{"had_liked":false,"id":118427,"user_name":"jutsu","can_delete":false,"product_type":"c1","uid":1124574,"ip_address":"","ucode":"95CEDEF5D085CF","user_header":"https://static001.geekbang.org/account/avatar/00/11/28/de/54667f13.jpg","comment_is_top":false,"comment_ctime":1564364101,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1564364101","product_id":100026901,"comment_content":"有没有异步非阻塞这类的，非得websocket吗","like_count":0},{"had_liked":false,"id":118398,"user_name":"无法言喻.","can_delete":false,"product_type":"c1","uid":1322328,"ip_address":"","ucode":"7F375BE388D4FC","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/58/aa35c402.jpg","comment_is_top":false,"comment_ctime":1564360565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564360565","product_id":100026901,"comment_content":"1.会丢包<br>2.timeout错误<br>3.用每次请求的数据量和数据时间进行对比<br>不知道有没有说对1个：)","like_count":0}]}