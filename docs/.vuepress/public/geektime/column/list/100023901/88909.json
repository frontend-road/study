{"id":88909,"title":"17 | ReadWriteLock：如何快速实现一个完备的缓存？","content":"<p>前面我们介绍了管程和信号量这两个同步原语在Java语言中的实现，理论上用这两个同步原语中任何一个都可以解决所有的并发问题。那Java SDK并发包里为什么还有很多其他的工具类呢？原因很简单：<strong>分场景优化性能，提升易用性</strong>。</p><p>今天我们就介绍一种非常普遍的并发场景：读多写少场景。实际工作中，为了优化性能，我们经常会使用缓存，例如缓存元数据、缓存基础数据等，这就是一种典型的读多写少应用场景。缓存之所以能提升性能，一个重要的条件就是缓存的数据一定是读多写少的，例如元数据和基础数据基本上不会发生变化（写少），但是使用它们的地方却很多（读多）。</p><p>针对读多写少这种并发场景，Java SDK并发包提供了读写锁——ReadWriteLock，非常容易使用，并且性能很好。</p><p><strong>那什么是读写锁呢？</strong></p><p>读写锁，并不是Java语言特有的，而是一个广为使用的通用技术，所有的读写锁都遵守以下三条基本原则：</p><ol>\n<li>允许多个线程同时读共享变量；</li>\n<li>只允许一个线程写共享变量；</li>\n<li>如果一个写线程正在执行写操作，此时禁止读线程读共享变量。</li>\n</ol><p>读写锁与互斥锁的一个重要区别就是<strong>读写锁允许多个线程同时读共享变量</strong>，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但<strong>读写锁的写操作是互斥的</strong>，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。</p><!-- [[[read_end]]] --><h2>快速实现一个缓存</h2><p>下面我们就实践起来，用ReadWriteLock快速实现一个通用的缓存工具类。</p><p>在下面的代码中，我们声明了一个Cache&lt;K, V&gt;类，其中类型参数K代表缓存里key的类型，V代表缓存里value的类型。缓存的数据保存在Cache类内部的HashMap里面，HashMap不是线程安全的，这里我们使用读写锁ReadWriteLock 来保证其线程安全。ReadWriteLock 是一个接口，它的实现类是ReentrantReadWriteLock，通过名字你应该就能判断出来，它是支持可重入的。下面我们通过rwl创建了一把读锁和一把写锁。</p><p>Cache这个工具类，我们提供了两个方法，一个是读缓存方法get()，另一个是写缓存方法put()。读缓存需要用到读锁，读锁的使用和前面我们介绍的Lock的使用是相同的，都是try{}finally{}这个编程范式。写缓存则需要用到写锁，写锁的使用和读锁是类似的。这样看来，读写锁的使用还是非常简单的。</p><pre><code>class Cache&lt;K,V&gt; {\n  final Map&lt;K, V&gt; m =\n    new HashMap&lt;&gt;();\n  final ReadWriteLock rwl =\n    new ReentrantReadWriteLock();\n  // 读锁\n  final Lock r = rwl.readLock();\n  // 写锁\n  final Lock w = rwl.writeLock();\n  // 读缓存\n  V get(K key) {\n    r.lock();\n    try { return m.get(key); }\n    finally { r.unlock(); }\n  }\n  // 写缓存\n  V put(K key, V value) {\n    w.lock();\n    try { return m.put(key, v); }\n    finally { w.unlock(); }\n  }\n}\n</code></pre><p>如果你曾经使用过缓存的话，你应该知道<strong>使用缓存首先要解决缓存数据的初始化问题</strong>。缓存数据的初始化，可以采用一次性加载的方式，也可以使用按需加载的方式。</p><p>如果源头数据的数据量不大，就可以采用一次性加载的方式，这种方式最简单（可参考下图），只需在应用启动的时候把源头数据查询出来，依次调用类似上面示例代码中的put()方法就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/62/1e/627be6e80f96719234007d0a6426771e.png?wh=1142*683\" alt=\"\"></p><center><span class=\"reference\">缓存一次性加载示意图</span></center><p>如果源头数据量非常大，那么就需要按需加载了，按需加载也叫懒加载，指的是只有当应用查询缓存，并且数据不在缓存里的时候，才触发加载源头相关数据进缓存的操作。下面你可以结合文中示意图看看如何利用ReadWriteLock 来实现缓存的按需加载。</p><p><img src=\"https://static001.geekbang.org/resource/image/4e/73/4e036a6b38244accfb74a0d18300f073.png?wh=1142*685\" alt=\"\"></p><center><span class=\"reference\">缓存按需加载示意图</span></center><h2>实现缓存的按需加载</h2><p>文中下面的这段代码实现了按需加载的功能，这里我们假设缓存的源头是数据库。需要注意的是，如果缓存中没有缓存目标对象，那么就需要从数据库中加载，然后写入缓存，写缓存需要用到写锁，所以在代码中的⑤处，我们调用了 <code>w.lock()</code> 来获取写锁。</p><p>另外，还需要注意的是，在获取写锁之后，我们并没有直接去查询数据库，而是在代码⑥⑦处，重新验证了一次缓存中是否存在，再次验证如果还是不存在，我们才去查询数据库并更新本地缓存。为什么我们要再次验证呢？</p><pre><code>class Cache&lt;K,V&gt; {\n  final Map&lt;K, V&gt; m =\n    new HashMap&lt;&gt;();\n  final ReadWriteLock rwl = \n    new ReentrantReadWriteLock();\n  final Lock r = rwl.readLock();\n  final Lock w = rwl.writeLock();\n \n  V get(K key) {\n    V v = null;\n    //读缓存\n    r.lock();         ①\n    try {\n      v = m.get(key); ②\n    } finally{\n      r.unlock();     ③\n    }\n    //缓存中存在，返回\n    if(v != null) {   ④\n      return v;\n    }  \n    //缓存中不存在，查询数据库\n    w.lock();         ⑤\n    try {\n      //再次验证\n      //其他线程可能已经查询过数据库\n      v = m.get(key); ⑥\n      if(v == null){  ⑦\n        //查询数据库\n        v=省略代码无数\n        m.put(key, v);\n      }\n    } finally{\n      w.unlock();\n    }\n    return v; \n  }\n}\n</code></pre><p>原因是在高并发的场景下，有可能会有多线程竞争写锁。假设缓存是空的，没有缓存任何东西，如果此时有三个线程T1、T2和T3同时调用get()方法，并且参数key也是相同的。那么它们会同时执行到代码⑤处，但此时只有一个线程能够获得写锁，假设是线程T1，线程T1获取写锁之后查询数据库并更新缓存，最终释放写锁。此时线程T2和T3会再有一个线程能够获取写锁，假设是T2，如果不采用再次验证的方式，此时T2会再次查询数据库。T2释放写锁之后，T3也会再次查询一次数据库。而实际上线程T1已经把缓存的值设置好了，T2、T3完全没有必要再次查询数据库。所以，再次验证的方式，能够避免高并发场景下重复查询数据的问题。</p><h2>读写锁的升级与降级</h2><p>上面按需加载的示例代码中，在①处获取读锁，在③处释放读锁，那是否可以在②处的下面增加验证缓存并更新缓存的逻辑呢？详细的代码如下。</p><pre><code>//读缓存\nr.lock();         ①\ntry {\n  v = m.get(key); ②\n  if (v == null) {\n    w.lock();\n    try {\n      //再次验证并更新缓存\n      //省略详细代码\n    } finally{\n      w.unlock();\n    }\n  }\n} finally{\n  r.unlock();     ③\n}\n</code></pre><p>这样看上去好像是没有问题的，先是获取读锁，然后再升级为写锁，对此还有个专业的名字，叫<strong>锁的升级</strong>。可惜ReadWriteLock并不支持这种升级。在上面的代码示例中，读锁还没有释放，此时获取写锁，会导致写锁永久等待，最终导致相关线程都被阻塞，永远也没有机会被唤醒。锁的升级是不允许的，这个你一定要注意。</p><p>不过，虽然锁的升级是不允许的，但是锁的降级却是允许的。以下代码来源自ReentrantReadWriteLock的官方示例，略做了改动。你会发现在代码①处，获取读锁的时候线程还是持有写锁的，这种锁的降级是支持的。</p><pre><code>class CachedData {\n  Object data;\n  volatile boolean cacheValid;\n  final ReadWriteLock rwl =\n    new ReentrantReadWriteLock();\n  // 读锁  \n  final Lock r = rwl.readLock();\n  //写锁\n  final Lock w = rwl.writeLock();\n  \n  void processCachedData() {\n    // 获取读锁\n    r.lock();\n    if (!cacheValid) {\n      // 释放读锁，因为不允许读锁的升级\n      r.unlock();\n      // 获取写锁\n      w.lock();\n      try {\n        // 再次检查状态  \n        if (!cacheValid) {\n          data = ...\n          cacheValid = true;\n        }\n        // 释放写锁前，降级为读锁\n        // 降级是可以的\n        r.lock(); ①\n      } finally {\n        // 释放写锁\n        w.unlock(); \n      }\n    }\n    // 此处仍然持有读锁\n    try {use(data);} \n    finally {r.unlock();}\n  }\n}\n</code></pre><h2>总结</h2><p>读写锁类似于ReentrantLock，也支持公平模式和非公平模式。读锁和写锁都实现了 java.util.concurrent.locks.Lock接口，所以除了支持lock()方法外，tryLock()、lockInterruptibly() 等方法也都是支持的。但是有一点需要注意，那就是只有写锁支持条件变量，读锁是不支持条件变量的，读锁调用newCondition()会抛出UnsupportedOperationException异常。</p><p>今天我们用ReadWriteLock实现了一个简单的缓存，这个缓存虽然解决了缓存的初始化问题，但是没有解决缓存数据与源头数据的同步问题，这里的数据同步指的是保证缓存数据和源头数据的一致性。解决数据同步问题的一个最简单的方案就是<strong>超时机制</strong>。所谓超时机制指的是加载进缓存的数据不是长久有效的，而是有时效的，当缓存的数据超过时效，也就是超时之后，这条数据在缓存中就失效了。而访问缓存中失效的数据，会触发缓存重新从源头把数据加载进缓存。</p><p>当然也可以在源头数据发生变化时，快速反馈给缓存，但这个就要依赖具体的场景了。例如MySQL作为数据源头，可以通过近实时地解析binlog来识别数据是否发生了变化，如果发生了变化就将最新的数据推送给缓存。另外，还有一些方案采取的是数据库和缓存的双写方案。</p><p>总之，具体采用哪种方案，还是要看应用的场景。</p><h2>课后思考</h2><p>有同学反映线上系统停止响应了，CPU利用率很低，你怀疑有同学一不小心写出了读锁升级写锁的方案，那你该如何验证自己的怀疑呢？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"16 | Semaphore：如何快速实现一个限流器？","id":88499},"right":{"article_title":"18 | StampedLock：有没有比读写锁更快的锁？","id":89456}},"comments":[{"had_liked":false,"id":83281,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1554516404,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"882022812084","product_id":100023901,"comment_content":"有多少跟我一样，发的内容能够看的懂。一到思考题，要么不会，要么心里的答案答非所问。","like_count":206,"discussions":[{"author":{"id":1014603,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/4b/95812b15.jpg","nickname":"抱紧我的小鲤鱼","note":"","ucode":"139780FB860FA3","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295067,"discussion_content":"俺也一样","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1596079933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066046,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","nickname":"灰太狼","note":"","ucode":"C17DD5D5ED9DC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211279,"discussion_content":"自己写代码验证，理解很快还深入，而且可以改动代码试验各种情况，很有用","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584837339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053921,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","nickname":"Zend","note":"","ucode":"80EBB0B6772E27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169596,"discussion_content":"我也是，看懂了，合上专栏 又说不出来","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581629381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30694,"discussion_content":"我就是这样，能听懂课，就是不会做题","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1570852091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279424,"discussion_content":"哈哈哈，确实有时候是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591343630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069001,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4f/c9/88837387.jpg","nickname":"😜哈哈","note":"","ucode":"1FF58FB3A91135","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216728,"discussion_content":"同感哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585479939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1813207,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/aa/d7/a417ad5b.jpg","nickname":"CharAt","note":"","ucode":"D7D44B48FC4E79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":176064,"discussion_content":"俺也一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582019426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258209,"avatar":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","nickname":"段启超","note":"","ucode":"164CF3018071B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51141,"discussion_content":"我也是，究其原因，用的太少，只是存在知道这个层面上，没有自己进一步思考过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573816311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1402570,"avatar":"https://static001.geekbang.org/account/avatar/00/15/66/ca/fb5c3a30.jpg","nickname":"tungSing","note":"","ucode":"F7147EA351BE44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42689,"discussion_content":"我也是，怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572752725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1619082,"avatar":"","nickname":"Geek_b77477","note":"","ucode":"9B27C9F12122CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4073,"discussion_content":"我也不知道要回答啥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565092783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508654,"avatar":"https://static001.geekbang.org/account/avatar/00/17/05/2e/5a6b6b6e.jpg","nickname":"Fortune","note":"","ucode":"6B9465AC996523","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3691,"discussion_content":"可能是老师提供了一种思想，实际代码中还是要使用api来操作吧，加上自己的基础有限，只能多看几遍了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564714584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83260,"user_name":"西西弗与卡夫卡","can_delete":false,"product_type":"c1","uid":1001710,"ip_address":"","ucode":"B4C27B8335B76A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/ee/872ad07e.jpg","comment_is_top":false,"comment_ctime":1554483843,"is_pvip":true,"replies":[{"id":"31829","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556029554,"ip_address":"","comment_id":83260,"utype":1}],"discussion_count":5,"race_medal":0,"score":"280727358083","product_id":100023901,"comment_content":"考虑到是线上应用，可采用以下方法<br>1. 源代码分析。查找ReentrantReadWriteLock在项目中的引用，看下写锁是否在读锁释放前尝试获取<br>2. 如果线上是Web应用，应用服务器比如说是Tomcat，并且开启了JMX，则可以通过JConsole等工具远程查看下线上死锁的具体情况","like_count":66,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445943,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556029554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482915,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","nickname":"业余爱好者","note":"","ucode":"A890935A982988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294717,"discussion_content":"第一种方式应该人人都能想到的，但没想到的是，最简单直接的方式最易被人忽略，以至于看到问题竟然无从下手。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1595982128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6307,"discussion_content":"学习学习","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566829062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003104,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","nickname":"gogo","note":"","ucode":"E8F0F3B000020A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301120,"discussion_content":"线上一般不会开启jmx的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598411947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1003104,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","nickname":"gogo","note":"","ucode":"E8F0F3B000020A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318892,"discussion_content":"对啊，感觉打印堆栈的方式更普遍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603875038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301120,"ip_address":""},"score":318892,"extra":""}]}]},{"had_liked":false,"id":83562,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1554651600,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"267842623952","product_id":100023901,"comment_content":"1、课后习题感觉可以使用第一种方法：①ps -ef | grep java查看pid②top -p查看java中的线程③使用jstack将其堆栈信息保存下来，查看是否是锁升级导致的阻塞问题。第二种方法：感觉可以调用下有获取只有读锁的接口，看下是否会阻塞，如果没有阻塞可以在调用下写锁的接口，如果阻塞表明有读锁。<br>2、读写锁也是使用volatile的state变量+加上happens-before来保证可见性么？<br>3、写下缓存和数据库的一致性问题的理解，如果先写缓存再写数据库，使用分布式锁，如果先写数据库再写缓存，①比如文中所说的使用binlog，canal+mq，但是感觉这个还得看具体情况，有可能binlog使用了组提交，不是马上写的binlog文件中，感觉也是会有延迟②感觉也可以使用定时任务定时的扫描任务表③使用消息队列","like_count":63,"discussions":[{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351967,"discussion_content":"我觉得没有必要追求缓存一致性，如果真要一致性，只能用一致性协议。但是一致性协议付出的代价获取比直接读库还要大。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614531070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2280894,"avatar":"","nickname":"Geek_781cba","note":"","ucode":"E419728928D36E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336656,"discussion_content":"缓存一致性先写db，再删缓存","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608646158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2280894,"avatar":"","nickname":"Geek_781cba","note":"","ucode":"E419728928D36E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380779,"discussion_content":"延时双删","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624695883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336656,"ip_address":""},"score":380779,"extra":""},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2280894,"avatar":"","nickname":"Geek_781cba","note":"","ucode":"E419728928D36E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573117,"discussion_content":"删缓存，可能失败","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653207767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336656,"ip_address":""},"score":573117,"extra":""}]},{"author":{"id":1533266,"avatar":"https://static001.geekbang.org/account/avatar/00/17/65/52/07c09c7f.jpg","nickname":"josancpp","note":"","ucode":"0CDC39B3E716A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275437,"discussion_content":"为什么会有先写缓存，再写DB？\n先写DB，在写缓存，用分布式锁不也可以吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590715628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1096248,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ba/38/cc5b50f6.jpg","nickname":"森淼👌","note":"","ucode":"B98AE9B22F50F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1533266,"avatar":"https://static001.geekbang.org/account/avatar/00/17/65/52/07c09c7f.jpg","nickname":"josancpp","note":"","ucode":"0CDC39B3E716A3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292799,"discussion_content":"先写缓存再写数据库这种方案及时性比较高，可以去慢慢去写数据库的，这种方式和cpu缓存写到内存差不多的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595335555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275437,"ip_address":""},"score":292799,"extra":""},{"author":{"id":1101534,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/de/31caf2ff.jpg","nickname":"相遇了久别重逢","note":"","ucode":"75B7571520A2A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1096248,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ba/38/cc5b50f6.jpg","nickname":"森淼👌","note":"","ucode":"B98AE9B22F50F6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315112,"discussion_content":"其实就是和MySQL的落盘机制一样，我们的insert也并不是里面，写到硬盘的，而是先写到日志。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1603243094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292799,"ip_address":""},"score":315112,"extra":""},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101534,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/de/31caf2ff.jpg","nickname":"相遇了久别重逢","note":"","ucode":"75B7571520A2A6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380780,"discussion_content":"WAL","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624696055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":315112,"ip_address":""},"score":380780,"extra":""}]}]},{"had_liked":false,"id":92367,"user_name":"ycfHH","can_delete":false,"product_type":"c1","uid":1498283,"ip_address":"","ucode":"084FF6C86CBCE4","user_header":"","comment_is_top":false,"comment_ctime":1557240329,"is_pvip":false,"replies":[{"id":"33511","content":"获取写锁的前提是读锁和写锁均未被占用<br>获取读锁的前提是没有其他线程占用写锁<br>申请写锁时不中断其他线程申请读锁<br>公平锁如果过有写申请，能禁止读锁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557645691,"ip_address":"","comment_id":92367,"utype":1}],"discussion_count":5,"race_medal":0,"score":"233485474313","product_id":100023901,"comment_content":"问题1：获取写锁的前提是读锁和写锁均未被占用？<br>问题2：获取读锁的前提是没有其他线程占用写锁？<br>基于以上两点所以只支持锁降级而不允许锁升级。<br>问题3<br>高并发下，申请写锁时是不是中断其他线程申请读锁，然后等待已有读锁全部释放再获取写锁？因为如果没有禁止读锁的申请的话在读多写少的情况下写锁可能一直获取不到。<br>这块不太懂，希望老师能指点一下。","like_count":54,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449230,"discussion_content":"获取写锁的前提是读锁和写锁均未被占用\n获取读锁的前提是没有其他线程占用写锁\n申请写锁时不中断其他线程申请读锁\n公平锁如果过有写申请，能禁止读锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557645691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178818,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/c2/74b75427.jpg","nickname":"提醒我学习","note":"","ucode":"673019FDDA4427","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190552,"discussion_content":"读锁是共享的,读/写是互斥的\n所以:\n问题1:写锁获取的前提是未被占用;读锁获取允许其他线程占用读锁,不允许获取已被写锁占用的\n问题3:ReentrantReadWriteLock 基于AQS实现,支持公平锁和非公平锁两种模式,获取不到锁的线程会放到同步队列中排队,公平模式下,按照FIFO,公平获取锁;非公平模式下,队列中的线程公平竞争锁资源\n以上个人理解,不对的地方,还请指正\n没明白老师说的公平锁如果过有写申请，能禁止读锁 ,在哪里禁止的呢?","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582958148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2924187,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/SluScDGqnhBNwmOQ774QEzuXiazk8Ab7ng8xCT81gunl9Hls9oibwB4AibCDxDtZwTe4mEib5QiaLXUqMv8iceXicXSYg/132","nickname":"Geek_080ce7","note":"","ucode":"C74D97C84983B9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577222,"discussion_content":"获取写锁的前提是读锁和写锁均未被占用  ，线程自己占用也不行吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655974623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2046055,"avatar":"","nickname":"杜总","note":"","ucode":"C6600875A265E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286993,"discussion_content":"你想啊，如果锁可以升级，那就是先获取读锁，再获取写锁，读读是共享的，那数据不都乱套了，读写锁提出来的目的是解决多读少些的场景，提升性能，还有第一个我问题获取写锁的前提，给老师补充下，如果写锁是当前线程，是可以重入的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593343046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30701,"discussion_content":"问题提问的很棒，我也正好得到了老师的回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570852711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83537,"user_name":"缪文","can_delete":false,"product_type":"c1","uid":1042262,"ip_address":"","ucode":"59603B50EF5FC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/56/c72997f3.jpg","comment_is_top":false,"comment_ctime":1554642798,"is_pvip":false,"replies":[{"id":"30265","content":"可以这样","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554703540,"ip_address":"","comment_id":83537,"utype":1}],"discussion_count":7,"race_medal":0,"score":"216303007598","product_id":100023901,"comment_content":"老师，感觉这里的读写锁，性能还有可以提升的地方，因为这里可能很多业务都会使用这个缓存懒加载，实际生产环境，写缓存操作可能会比较多，那么不同的缓存key，实际上是没有并发冲突的，所以这里的读写锁可以按key前缀拆分，即使是同一个key，也可以类似ConcurrentHash 一样分段来减少并发冲突","like_count":50,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446062,"discussion_content":"可以这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554703540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f0/a5/6934a639.jpg","nickname":"赖学良","note":"","ucode":"99E63A28E0CDAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386031,"discussion_content":"这个就是提升并发性能中的减小锁粒度的方案呀，串联起来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627385088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2405512,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b4/88/73f446d2.jpg","nickname":"我只是想简单的试一下名字到底可以取多长吧","note":"","ucode":"7CBA9CACC684C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381057,"discussion_content":"就是 写一个单例的缓存管理器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624882633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1370932,"avatar":"https://static001.geekbang.org/account/avatar/00/14/eb/34/9756d116.jpg","nickname":"一路向北","note":"","ucode":"B688B1C748D019","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369963,"discussion_content":"干的漂亮，参考了concurrenthashmap的机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619233700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318891,"discussion_content":"跟mysql的表锁和行锁好像啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603874973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186712,"discussion_content":"可以解释下按key前缀拆分么，没懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582708532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200473,"discussion_content":"示例代码中的Cache内通过Map维护了所有key对应的value，并且整个map使用了同一个 rwl，也就是说所有key使用了同一个rwl。\n当 对k1 获取写锁，从db加载数据时，整个对map的访问都被阻塞，即使对其他key的读请求也被阻塞，比如  cache.get(k2)。所以实例里的rwl维度是整个cache。\n\n可以使用更小粒度的rwl，比如每个key 维护一个 rwl，对k1的访问和 对k2 的访问分别用 rwl_k1，rwk_k2 进行控制，当一个线程对k1进行写操作时，该线程只是获取 rwl_k1 的写锁，并不需要获取 rwl_k2的锁，其他线程可以正常对k2 对应的数据进行读写操作，并不受 读写k1线程的影响。\n\n如果缓存的数据中key比较多，每个key 都维护一个rwl 的话，开销太大。\n可以对所有的key 进行分组，分组的方式多种多样，比如评论里提到的对key按前缀进行拆分。举个例子，假如所有key都是由于a-z的26个字母组成的string，可以按第一个字母进行分组，所有 a 开头的 key 划为 group_a , 所有 b 开头的 key 划为 gourp_b，以此类推，所有 z 开头的 key 划为 group_b。\n\n每一组key维护一个 rwl，属于 group_a 的key 用 rwl_a 进行控制，第二组key 用 rwl_b进行控制。当一个线程获取 rwl_a的写锁时，所有对 以a开头的key 进行读写操作的线程都被阻塞，但是对其他读写 不以 a 开头的key 的线程不受影响。\n\n降低锁粒度越小 以降低 并发冲突的概率，降低线程被阻塞的效率，也就提供了程序的运行效率 。","likes_number":47,"is_delete":false,"is_hidden":false,"ctime":1583681132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186712,"ip_address":""},"score":200473,"extra":""}]}]},{"had_liked":false,"id":90826,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1556679587,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"169060404131","product_id":100023901,"comment_content":"读锁不能升级为写锁：好理解，本线程在释放读锁之前，想要获取写锁是不一定能获取到的，因为其他线程可能持有读锁（读锁共享），可能导致阻塞较长的时间，所以java干脆直接不支持读锁升级为写锁。<br>写锁可以降级为读锁：也好理解，本线程在释放写锁之前，获取读锁一定是可以立刻获取到的，不存在其他线程持有读锁或者写锁（读写锁互斥），所以java允许锁降级","like_count":40,"discussions":[{"author":{"id":1619082,"avatar":"","nickname":"Geek_b77477","note":"","ucode":"9B27C9F12122CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4072,"discussion_content":"读锁不能升级为写锁是因为线程持有读锁还未释放，未释放便无法进行写锁的加锁","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1565092743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1619082,"avatar":"","nickname":"Geek_b77477","note":"","ucode":"9B27C9F12122CB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30697,"discussion_content":"我感觉也是这样，先持有了读锁，再去持有写锁，读锁还未释放，导致写锁死等，然后finally中的读锁的释放也永远执行不到","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1570852542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4072,"ip_address":""},"score":30697,"extra":""}]},{"author":{"id":1751214,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b8/ae/085484e7.jpg","nickname":"Insomnia","note":"","ucode":"5986A48988D6E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341150,"discussion_content":"锁升级不支持的原因是, 读写锁设计的时候就说明了: 获取写锁的前提是读锁和写锁都必须未被占用, 而锁升级违背了这个设计原则, 当前线程持有读锁, 然后想升级获取写锁, 就算其他并行线程最终释放了读锁, 当前线程自己还是占用着读锁, 所以会导致写锁永远获取不到.","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1610331097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1855137,"avatar":"","nickname":"Geek_e6f358","note":"","ucode":"C21E94A90258A2","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385305,"discussion_content":"锁升级时，自己会占着一个读锁，所以会永远阻塞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626996820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2165655,"avatar":"https://static001.geekbang.org/account/avatar/00/21/0b/97/3d3133b0.jpg","nickname":"enjoygill","note":"","ucode":"558EEC9DE48B70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306102,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600170336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482915,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","nickname":"业余爱好者","note":"","ucode":"A890935A982988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294718,"discussion_content":"解释绝了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595982329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83277,"user_name":"crazypokerk","can_delete":false,"product_type":"c1","uid":1158383,"ip_address":"","ucode":"9AAD5D9726E503","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/ef/494f56c3.jpg","comment_is_top":false,"comment_ctime":1554515074,"is_pvip":false,"replies":[{"id":"30079","content":"可以这样理解，不过释放了读锁，也就谈不上升级了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554516590,"ip_address":"","comment_id":83277,"utype":1}],"discussion_count":5,"race_medal":0,"score":"126108566658","product_id":100023901,"comment_content":"老师，可不可以这样理解，ReadWirteLock不支持锁的升级，指的是：在不释放读锁的前提下，无法继续获取写锁，但是如果在释放了读锁之后，是可以升级为写锁的。锁的降级就是：在不释放写锁的前提下，获取读锁是可以的。请老师指正，感谢。","like_count":29,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445955,"discussion_content":"可以这样理解，不过释放了读锁，也就谈不上升级了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554516590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365463,"discussion_content":"锁降级的目的是啥呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617803722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560980,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649506963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365463,"ip_address":""},"score":560980,"extra":""},{"author":{"id":2820632,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/0a/18/cdfd70ad.jpg","nickname":"LetMeCode","note":"","ucode":"AD6D729D42BB44","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586939,"discussion_content":"同疑惑，我试了下其他线程还是不能施加读锁，那降级没啥用啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662621353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":560980,"ip_address":"上海"},"score":586939,"extra":""}]},{"author":{"id":1382006,"avatar":"https://static001.geekbang.org/account/avatar/00/15/16/76/f2422695.jpg","nickname":"王小","note":"","ucode":"03DDDB3FD20D5F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549663,"discussion_content":"持有写锁的情况下，也就是互斥，所以只有一个线程能够获得锁，这个线程也就自然可以读，从而能够获取读锁，也就是锁的降级","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644197425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233664,"user_name":"sibyl","can_delete":false,"product_type":"c1","uid":1323652,"ip_address":"","ucode":"0D142011860D69","user_header":"","comment_is_top":false,"comment_ctime":1594377128,"is_pvip":false,"replies":[{"id":"87243","content":"尤其是涉及多个共享变量的时候，这个作用尤其明显，如果只是一个int，就不那么明显了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1595342243,"ip_address":"","comment_id":233664,"utype":1}],"discussion_count":6,"race_medal":0,"score":"113263526824","product_id":100023901,"comment_content":"老师好，回答一下有些同学关于读锁有什么用的疑问，您看看对不对，如果对，给个置顶鼓励一下，谢谢老铁啦，啊哈哈<br><br>1、有些同学认为读锁没有用，他们的理由是：读操作又不会修改数据，想读就读呗，无论读的是就值还是新值，反正能读到。<br><br><br>2、也有同学认为读锁是为了防止多线程读到的数据不一致。<br><br>我认为不是这个原因，只需要问两个问题就知道了，首先问不一致的是什么？然后反问不一致会导致什么问题呢？<br><br>有些同学认为不一致就是有些线程读的是旧值，有些读的是新值，所以不一致。但是反问导致什么问题，就不是很好回答了，可能回答说为了保险吧，哈哈哈。<br><br>实际上即使加读锁，还是会存在有的线程读旧值，有的线程读新值，甚至非公平锁情况下，先开始的线程反而读到新值，而后开始的线程反而读到旧值，所以读锁并不是为了保证多线程读到的值是一样的。<br><br>3、那么读锁的作用是什么呢？<br><br>任何锁表面上是互斥，但本质是都是为了避免原子性问题（如果程序没有原子性问题，那只用volatile来避免可见性和有序性问题就可以了，效率更高），读锁自然也是为了避免原子性问题，比如一个long型参数的写操作并不是原子性的，如果允许同时读和写，那读到的数很可能是就是写操作的中间状态，比如刚写完前32位的中间状态。long型数都如此，而实际上一般读的都是复杂的对象，那中间状态的情况就更多了。<br><br>所以读锁是防止读到写操作的中间状态的值。","like_count":27,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501124,"discussion_content":"尤其是涉及多个共享变量的时候，这个作用尤其明显，如果只是一个int，就不那么明显了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595342243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540212,"discussion_content":"果然，如果看文章时有疑问，再看看下面的评论，一般都是能够找到答案的。通过这位兄弟的解答以及老师的点评，我感觉我顿悟了。加读锁目的是是保证读写能够互斥：在写数据过程中，不能读的话就可以防止读取到写过程中数据的中间状态，光是修改一个共享变量倒还没啥感觉，如果是修改多个共享变量，中间状态的数据跟最终状态的数据那区别就大了。就像数据库的事务隔离级别，当前事务如果能读取到其他事务未提交的数据，肯定是有问题的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1639990843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380788,"discussion_content":"本质上是为了减少线程的阻塞时间，假如没有读写锁，99个读，1个写，此时用syschrozied，那么只能100个线程依次等待，引入读写锁之后，读读不互斥，提高了性能","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624697335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1832266,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIIP4P45S9HTzVH2SAH7u9UoKcjibh3smlme8Ieh4921diaaRJYcRcBWwq7XiaCySXO9lopRpDtzp7yA/132","nickname":"yezj","note":"","ucode":"38BD97834AC8F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377534,"discussion_content":"原来如此","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622699528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363554,"discussion_content":"有道理的，刚看的时候就很疑问读锁的作用是啥。所以看完就来翻评论了，果然有答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617236892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2165655,"avatar":"https://static001.geekbang.org/account/avatar/00/21/0b/97/3d3133b0.jpg","nickname":"enjoygill","note":"","ucode":"558EEC9DE48B70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306104,"discussion_content":"深刻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600170648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83348,"user_name":"WhoAmI","can_delete":false,"product_type":"c1","uid":1445156,"ip_address":"","ucode":"58588E643EB842","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/24/b07de4f2.jpg","comment_is_top":false,"comment_ctime":1554542453,"is_pvip":false,"replies":[{"id":"30124","content":"可以，ArrayBlockingQueue有界是因为必须传capacity参数，LinkedBlockingQueue传capacity参数就是有界，不传就是无界","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554555906,"ip_address":"","comment_id":83348,"utype":1}],"discussion_count":4,"race_medal":0,"score":"83158921077","product_id":100023901,"comment_content":"一般都说线程池有界队列使用ArrayBlockingQueue，无界队列使用LinkedBlockingQueue，我很奇怪，有界无界不是取决于创建的时候传不传capacity参数么，我现在想创建线程池的时候，new LinkedBlockingQueue(2000)这样定义有界队列，请问可以吗？","like_count":19,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445987,"discussion_content":"可以，ArrayBlockingQueue有界是因为必须传capacity参数，LinkedBlockingQueue传capacity参数就是有界，不传就是无界","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554555906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100717,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq65BWyJb39rq0Qgx1fnELVSZGGuLY6oBmYcmFj2Oqy9iauAWfbqO5U63I22Uo1POrrTp7tFWXibxvg/132","nickname":"zyl","note":"","ucode":"2F872341AC8D7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250182,"discussion_content":"不传也不是无界，默认int最大值，concurrentlinkedqueue才是真无界","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587995840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365471,"discussion_content":"还是因为数组和链表数据结构的差异呀，创建数组必须指定size（集合也有默认size），链表节点可以一直添加呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617804375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572150,"discussion_content":"不传也不是无界，默认int最大值，int max这个值很大，21亿，一般不会有这么大的任务队列，所以就说是无解了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652621307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84249,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1554812736,"is_pvip":false,"replies":[{"id":"30391","content":"分布式有分布式的锁，单机的效率就是靠多线程了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554819873,"ip_address":"","comment_id":84249,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74569256768","product_id":100023901,"comment_content":"老师我们现在的项目全都是集群部署, 感觉在这种情况下是不是单机的Lock,和Synchronized都用不上, 只能采用分布式锁的方案? 那么这种情况下, 如何提高每个实例的并发效率?","like_count":17,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446292,"discussion_content":"分布式有分布式的锁，单机的效率就是靠多线程了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554819873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127747,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1566787818,"is_pvip":false,"replies":[{"id":"47356","content":"本地缓存更快","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566793606,"ip_address":"","comment_id":127747,"utype":1}],"discussion_count":5,"race_medal":0,"score":"44516460778","product_id":100023901,"comment_content":"老师你好，我们在项目开发中，如果要实现缓存，会直接采用Redis，感觉更合适，所以不太清楚，实际中ReadWriteLock可以解决哪些问题？","like_count":10,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464634,"discussion_content":"本地缓存更快","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566793606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279428,"discussion_content":"本地缓存可以和分布式缓存互为补充，在某些业务需求下还是有用的，现在本地缓存也有很多现成的轮子","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591344021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540134,"discussion_content":"搞成多级缓存呗，本地一级，redis两级，然后就是db","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639968671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1474579,"avatar":"https://static001.geekbang.org/account/avatar/00/16/80/13/df2a0ced.jpg","nickname":"郑思雨","note":"","ucode":"F1F4B08FC94E7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410643,"discussion_content":"除非缓存内容是固定的，否则分布式环境下的本地缓存还要解决同步问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635750752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378908,"discussion_content":"本地缓存少一次网路操作更快","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623503923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96931,"user_name":"文灏","can_delete":false,"product_type":"c1","uid":1122739,"ip_address":"","ucode":"177D548FC87BED","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/b3/db933462.jpg","comment_is_top":false,"comment_ctime":1558538016,"is_pvip":false,"replies":[{"id":"34752","content":"不用关心可见性，原子性，读到的都是对的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558617075,"ip_address":"","comment_id":96931,"utype":1}],"discussion_count":4,"race_medal":0,"score":"40213243680","product_id":100023901,"comment_content":"王老师你好，有个问题想请教一下。既然允许多个线程同时读，那么这个时候的读锁意义在哪里？","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451071,"discussion_content":"不用关心可见性，原子性，读到的都是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558617075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1382006,"avatar":"https://static001.geekbang.org/account/avatar/00/15/16/76/f2422695.jpg","nickname":"王小","note":"","ucode":"03DDDB3FD20D5F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549665,"discussion_content":"可见性类似于数据库事务的隔离性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644197539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380789,"discussion_content":"提高了性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624697500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365478,"discussion_content":"反过来想如果允许多个线程同时读不加锁，那是不是可以同时读写了，是不是就可能读到中间状态，但这不是我们期望的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617804986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88185,"user_name":"随风而逝","can_delete":false,"product_type":"c1","uid":1447169,"ip_address":"","ucode":"4E4D46905697AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/15/01/927d96e5.jpg","comment_is_top":false,"comment_ctime":1555890656,"is_pvip":false,"replies":[{"id":"31766","content":"降级稍微快一点，而且一定能成功。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555947146,"ip_address":"","comment_id":88185,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40210596320","product_id":100023901,"comment_content":"缓存一致性问题，我们都是双删缓存。老师，读写锁的降级和单独使用有什么区别？或者说有什么优势？","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447761,"discussion_content":"降级稍微快一点，而且一定能成功。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555947146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504651,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNDKOCoZvCqoYVM1t97Q77QPLmRBGvOLYzFsh8073RicycoIuwGrIsCXpAFEyVBOxcyE3Ih1mr6Vw/132","nickname":"Geek_bbbda3","note":"","ucode":"737394CE472C21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296736,"discussion_content":"个人理解：降级能够避免，在拿到缓存对象后被其他方法（销毁缓存）置空，导致空指针（在有读锁存在的时候，写锁获取也是要排队）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596636311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83648,"user_name":"刘志兵","can_delete":false,"product_type":"c1","uid":1441734,"ip_address":"","ucode":"A90C2FA49EDC23","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/c6/8b5cbe97.jpg","comment_is_top":false,"comment_ctime":1554689922,"is_pvip":false,"replies":[{"id":"30258","content":"读写锁本身就是个通用的概念","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554697027,"ip_address":"","comment_id":83648,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40209395586","product_id":100023901,"comment_content":"这里讲的读写锁和丁奇老师讲的mysql中的mdl锁和ddl锁原理好像是一样的，就是读写互斥，写写互斥，读读不互斥，老师讲的这个应该是读写锁的基本原理，mysql是这个锁的一种典型应用吧","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446114,"discussion_content":"读写锁本身就是个通用的概念","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554697027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488601,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b6/d9/4d8a4d4c.jpg","nickname":"红豆成香","note":"","ucode":"FB8FBB639B4BA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568455,"discussion_content":"mysql的mvcc 读写不互斥","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651141317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158949,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1575506064,"is_pvip":false,"replies":[{"id":"60828","content":"是的，只允许同时读","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1575520880,"ip_address":"","comment_id":158949,"utype":1}],"discussion_count":3,"race_medal":0,"score":"35935244432","product_id":100023901,"comment_content":"王老师，&quot;&quot;如果一个写线程正在执行写操作，此时禁止读线程读共享变量&quot;&quot;  这句话反过来也成立，是不是意味着读操作和写操作是互斥的，不能同时进行？","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476898,"discussion_content":"是的，只允许同时读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575520880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028951,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/97/9a7ee7b3.jpg","nickname":"Geek4329","note":"","ucode":"D6FB8D1B2D5DAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294316,"discussion_content":"同一个线程可以既获得写锁也可以获得读锁么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595853701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028951,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/97/9a7ee7b3.jpg","nickname":"Geek4329","note":"","ucode":"D6FB8D1B2D5DAC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365475,"discussion_content":"这就是锁的降级吧，我获取了写锁，必然其他线程不能获取读锁，所以我一个操作数据没啥问题，等我释放了写锁，其他读数据的线程就就可以来获取读锁了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617804760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294316,"ip_address":""},"score":365475,"extra":""}]}]},{"had_liked":false,"id":83312,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1554529570,"is_pvip":false,"replies":[{"id":"30118","content":"不会一直拿不到，只是等待的时间会很长","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554537717,"ip_address":"","comment_id":83312,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31619300642","product_id":100023901,"comment_content":"老师，如果读锁的持有时间较长，读操作又比较多，会不会一直拿不到写锁？","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445971,"discussion_content":"不会一直拿不到，只是等待的时间会很长","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554537717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1384698,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6Nic6V6iawbbIF1RRbRlwNmC0Cmt3LlQRAiaiayCibpplSDPXticVyOp97CEypEuQm2Iib7ZYCjrrlIgWQ/132","nickname":"奔跑的蜗牛","note":"","ucode":"C5277C80B423A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88430,"discussion_content":"请问老师，会不会导致读多写少的情况下，写锁饥饿呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576714668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1290245,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b0/05/48e3f940.jpg","nickname":"无心","note":"","ucode":"2AD84413DB4A72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1384698,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6Nic6V6iawbbIF1RRbRlwNmC0Cmt3LlQRAiaiayCibpplSDPXticVyOp97CEypEuQm2Iib7ZYCjrrlIgWQ/132","nickname":"奔跑的蜗牛","note":"","ucode":"C5277C80B423A0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":108512,"discussion_content":"有了写请求的话，无论使用公平锁还是非公平锁，后续读请求都会排队的，只要正在执行的读请求和排队排在写请求前面的读请求不死锁，就不会发生饥饿","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577631333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":88430,"ip_address":""},"score":108512,"extra":""}]}]},{"had_liked":false,"id":138483,"user_name":"铿然","can_delete":false,"product_type":"c1","uid":1162461,"ip_address":"","ucode":"D529242EC2E2EA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/dd/c9413f59.jpg","comment_is_top":false,"comment_ctime":1570267668,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"27340071444","product_id":100023901,"comment_content":"读写锁本身很好理解，但是实际应用场景太难想了，比如文中举的缓存的例子，个人觉得这个例子只是套上了读写锁，但是实际业务中没有解决问题。比如：<br><br>T1时间A,B,C同时读了到a，然后A先修改a变成a’，B接着也修改a，但B并不是在a‘的基础上修改，B看到的数据a已经展现在页面上了，也就是A修改a后怎么让B实时可见，如果要保证B在A修改后的基础上修改，那么顺序是B先加锁，然后读最新数据，然后再修改。<br><br>也就是说A,B因为各自读写顺序的原因不能保证结果是想要的（这个顺序是异步的，不可控的），缓存这个例子并没有解决上述场景的问题。<br><br>那么缓存使用读、写锁解决了啥实际问题呢？  读读不互斥，读写互斥，写写互斥并不是实际需要解决的问题，它只是一个实现结果。<br><br>读写锁的场景在生活中的例子：<br><br>1. 理发店总共有10个理发师<br>2. 其中有4个理发师正在给顾客理发，可以理解为获得了写锁<br>3. 新来的两个顾客不想等待，要立即理发，那么只有剩下6个理发师可供两个顾客同时选择，选的过程中理发师不应该去干别的事情, 这就是读锁，和已经在理发的4个理发师的写锁是互斥的<br>4. 其中一个顾客选中了理发师，变为写锁 （可以看到实际生活读锁可以升级为写锁）<br><br>这个场景中在读的时候有一个选择过程，而读取缓存没有选择过程，就只是固定的读取某个key的缓存。想不出应用程序中啥场景和理发店这个例子很相似。<br><br>所以虽然缓存应用了读写锁，但是没有看到到底利用读写锁解决了啥问题？  ","like_count":6,"discussions":[{"author":{"id":1855137,"avatar":"","nickname":"Geek_e6f358","note":"","ucode":"C21E94A90258A2","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385306,"discussion_content":"你一直纠结的是可见性问题。读写锁的目的是并发读，并且读写互斥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626997452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83371,"user_name":"iron_man","can_delete":false,"product_type":"c1","uid":1099883,"ip_address":"","ucode":"C0053A59442910","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/6b/0f3876ef.jpg","comment_is_top":false,"comment_ctime":1554546428,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"27324350204","product_id":100023901,"comment_content":"王老师，写锁降级为读锁的话，前面的写锁是释放了么？后面可不可以讲一下这个读写锁的实现机制呢，这样可以对这种锁有更深入的理解，锁的升级降级也就不会用错了","like_count":6,"discussions":[{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280904,"discussion_content":"在释放写锁之前申请读锁，然后释放写锁，好处是因为拥有写锁的线程一定能直接获取读锁，。 如果释放写锁之后再申请读锁，是可能失败的，因为有可能存在申请写锁的线程","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1591626544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2165655,"avatar":"https://static001.geekbang.org/account/avatar/00/21/0b/97/3d3133b0.jpg","nickname":"enjoygill","note":"","ucode":"558EEC9DE48B70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306103,"discussion_content":"✔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600170498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280904,"ip_address":""},"score":306103,"extra":""},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560982,"discussion_content":"为啥还要继续获得 读锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649507193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280904,"ip_address":""},"score":560982,"extra":""}]}]},{"had_liked":false,"id":83279,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1554516225,"is_pvip":false,"replies":[{"id":"30122","content":"系统停止了响应,cpu利用率低大概率是死锁了，没法推断，只能大胆假设，小心求证","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554545910,"ip_address":"","comment_id":83279,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27324320001","product_id":100023901,"comment_content":"系统停止了响应，说明线程可能被占满了。cpu利用率低为什么会推断出，是读锁升级为写锁？是因为锁升级后，线程都是等待状态吗？是不是cpu高是锁竞争？还有怎么验证读锁升级为写锁？","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445957,"discussion_content":"系统停止了响应,cpu利用率低大概率是死锁了，没法推断，只能大胆假设，小心求证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554545910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121959,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1565257913,"is_pvip":false,"replies":[{"id":"44971","content":"一个是出于性能的考虑，一个是防止数据的不一致","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1565429379,"ip_address":"","comment_id":121959,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18745127097","product_id":100023901,"comment_content":"老师您好，我想问下锁的升级&#47;降级有什么好处么？","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462026,"discussion_content":"一个是出于性能的考虑，一个是防止数据的不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565429379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85243,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1555026991,"is_pvip":false,"replies":[{"id":"30802","content":"我觉得没必要用双重检查。分布式下面的锁和进程内部的锁区别很大，要考虑容错，redis的锁都有时效，假设是5分钟，获取redis锁之后，sleep（6分钟）后再执行业务代码，那么理论上起不到互斥的作用，这种情况不能说没有（有些进程就是突然假死，一会又活过来了），但是一般都是忽略了。<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555173626,"ip_address":"","comment_id":85243,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18734896175","product_id":100023901,"comment_content":"老师，我想问一个“超纲”的问题:<br><br>我看分布式锁使用redis实现，主要就是在while循环里使用jedis的get(key); setnx(key,value);  <br><br>那这里分布式锁的实现，有没有必要采用今天讲的读写所+双检查来实现啊？<br><br>恳请老师回答，谢谢老师!","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446604,"discussion_content":"我觉得没必要用双重检查。分布式下面的锁和进程内部的锁区别很大，要考虑容错，redis的锁都有时效，假设是5分钟，获取redis锁之后，sleep（6分钟）后再执行业务代码，那么理论上起不到互斥的作用，这种情况不能说没有（有些进程就是突然假死，一会又活过来了），但是一般都是忽略了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555173626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f0/a5/6934a639.jpg","nickname":"赖学良","note":"","ucode":"99E63A28E0CDAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386045,"discussion_content":"3.0之后加锁过程已经合并成一条指令了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627386992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380790,"discussion_content":"lua脚本实现操作的原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624698161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307731,"discussion_content":"直接在while先get再setnx不能保证两个操作的原子性啊，建议使用redission里面提供的lock方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600744736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227482,"user_name":"guihaiyizhu","can_delete":false,"product_type":"c1","uid":1345682,"ip_address":"","ucode":"CB385DABA2E1E8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJic27dia65Z8OfsQBEmaIUdo53DgLCakbK9ulIrNgT86pe3RbbybuGCDh6StIzJ7XYFLrSYtibNe7Xg/132","comment_is_top":false,"comment_ctime":1592389425,"is_pvip":false,"replies":[{"id":"84700","content":"大神，你好😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1593003554,"ip_address":"","comment_id":227482,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14477291313","product_id":100023901,"comment_content":"看了下juc的源码，尝试着分析一波 为啥为啥ReentrantReadWriteLock不能锁的降低不能锁的降低，但是可以锁的升级。<br>ReentrantReadWriteLock 实现了 ReadWriteLock 的结构。所以会有读锁和写锁两个方法来获取对应的锁。<br><br>先说下 JUC 锁的一般讨论：<br>1. status 表示状态，比如：status 大于0 表示线程可以获得锁，线程等于0 表示需等待其他线程释放锁<br>2. 等待队列： 获取不到锁的线程会丢到等待队列。<br>3. LockSuppert.park &#47; unpark: 来作用线程的通信。<br><br>获取锁的大概逻辑可以认为是：1. status 不满足要求， 2. 线程丢到等到队列 3. 调用LockSuppert.park(thread.current)<br><br>可以分析出 判断线程是否可以进入的关键方法即是：status 是否符合要求，也就是 tryAcquire 的方法<br><br>基于此，我们来看ReentrantReadWriteLock 里面读锁写锁的设计了：<br><br>先给出状态定义的代码<br>static final int SHARED_SHIFT   = 16;<br>static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);<br>static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;<br>static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;<br>static int sharedCount(int c)    { return c &gt;&gt;&gt; SHARED_SHIFT; }<br>static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }<br><br>给出结论：status 低16位用来做 排它锁的状态，高16位用来做共享锁的状态<br><br>WriteLock:<br>        protected final boolean tryAcquire(int acquires) {<br>            Thread current = Thread.currentThread();<br>            int c = getState();<br>            &#47;&#47; 获取写锁的status<br>            int w = exclusiveCount(c);<br>            if (c != 0) {<br>                &#47;&#47; 如果 c ！= 0 &amp;&amp; w == 0. 说明这个RWLock 被其他写锁占着，所有不会锁的升级<br>                if (w == 0 || current != getExclusiveOwnerThread())<br>                    return false;<br>            }<br>        }<br><br><br>ReadLock:<br>        protected final int tryAcquireShared(int unused) {<br>            Thread current = Thread.currentThread();<br>            int c = getState();<br>            &#47;&#47; 排它状态不等0 且 current 不是写锁的线程 才不能持有锁，<br>            if (exclusiveCount(c) != 0 &amp;&amp;<br>                getExclusiveOwnerThread() != current)<br>                return -1;<br>            &#47;&#47; ...<br>            return fullTryAcquireShared(current);<br>        }","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498659,"discussion_content":"大神，你好😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593003554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83291,"user_name":"IMSolar","can_delete":false,"product_type":"c1","uid":1155392,"ip_address":"","ucode":"1F57A438DFAF68","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/40/2c4ba425.jpg","comment_is_top":false,"comment_ctime":1554520781,"is_pvip":false,"replies":[{"id":"30083","content":"可以使用 lock.tryLock() 或者 lock.tryLock(timeout, unit))","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554522512,"ip_address":"","comment_id":83291,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14439422669","product_id":100023901,"comment_content":"当有一个线程获取到写锁，其他线程都被阻塞了，假设这时候回源数据库时间比较长，会影响请求的响应时间，请问老师这里有什么办法可以在获取不到锁的情况直接返回null？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445961,"discussion_content":"可以使用 lock.tryLock() 或者 lock.tryLock(timeout, unit))","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554522512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83274,"user_name":"邋遢的流浪剑客","can_delete":false,"product_type":"c1","uid":1260881,"ip_address":"","ucode":"32AF6F9070506D","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/51/9723276c.jpg","comment_is_top":false,"comment_ctime":1554513869,"is_pvip":false,"replies":[{"id":"30080","content":"看并发量，单机redis的qps也就5万左右，再高了就有超时，所以最好是加上","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554516880,"ip_address":"","comment_id":83274,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14439415757","product_id":100023901,"comment_content":"老师，在Spring的环境下，如果使用redis实现缓存（用RedisTemplate操作），需要像Cache中代码中一样再做一次检查吗？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445953,"discussion_content":"看并发量，单机redis的qps也就5万左右，再高了就有超时，所以最好是加上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554516880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346515,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1653209354,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10243143946","product_id":100023901,"comment_content":"今日收获<br><br><br> ①  读写锁不能进行锁升级（即读锁升级到写锁）；<br><br> ②  读写锁支持锁降级（即写锁降级到读锁）；<br><br> ③  写锁支持条件变量，读锁不支持条件变量；<br><br> ④  读写锁是可重如锁；","like_count":2},{"had_liked":false,"id":109009,"user_name":"杨鹏程baci","can_delete":false,"product_type":"c1","uid":1205949,"ip_address":"","ucode":"3D22F6B74340A8","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/bd/bd5d503e.jpg","comment_is_top":false,"comment_ctime":1561948174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151882766","product_id":100023901,"comment_content":"老师好，我来理解一下，我们对缓存这个例子来说，完全可以用volatile来达到可见性的目的，只是说用了读写锁支持读操作不用写回内存，可以并发执行，只是写操作还是需要每次保持可见性。我还有一个问题，读锁的意义是不是配合写锁时需要线程等待？","like_count":2},{"had_liked":false,"id":101811,"user_name":"Delong","can_delete":false,"product_type":"c1","uid":1154589,"ip_address":"","ucode":"673C7045971EEA","user_header":"https://static001.geekbang.org/account/avatar/00/11/9e/1d/dfe22860.jpg","comment_is_top":false,"comment_ctime":1559980451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10149915043","product_id":100023901,"comment_content":"用jstack看是不是在waiting自己","like_count":2},{"had_liked":false,"id":83473,"user_name":"Geek_961eed","can_delete":false,"product_type":"c1","uid":1444566,"ip_address":"","ucode":"A62198D96379F5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erWxMXolPylQk8Z6V6yt2LtibksrksC4bHtmxkuCC4Wzw7trl6CfwmsSFMyHFItFnvl21RvQ8fyOBQ/132","comment_is_top":false,"comment_ctime":1554617805,"is_pvip":false,"replies":[{"id":"30171","content":"估计是考虑的升级到需求太少","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554633666,"ip_address":"","comment_id":83473,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10144552397","product_id":100023901,"comment_content":"为什么允许锁的降级而不允许锁的升级？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446037,"discussion_content":"估计是考虑的升级到需求太少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554633666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83323,"user_name":"我是卖报小行家","can_delete":false,"product_type":"c1","uid":1303013,"ip_address":"","ucode":"43530EA291B66D","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/e5/815d4271.jpg","comment_is_top":false,"comment_ctime":1554532905,"is_pvip":false,"replies":[{"id":"30117","content":"是这样，不过也没有降级的需求吧。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554537625,"ip_address":"","comment_id":83323,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10144467497","product_id":100023901,"comment_content":"synchronized内部是支持升级却不支持降级，偏向锁可以升级成轻量级锁，反之则不行，是不是这样老师","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445977,"discussion_content":"是这样，不过也没有降级的需求吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554537625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306315,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","nickname":"官人","note":"","ucode":"ECEF55B08E252B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537071,"discussion_content":"synchronized是可以降级的 在到安全点 会检查闲置的monitor 进行降级 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638949944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346511,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1653208004,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5948175300","product_id":100023901,"comment_content":"实现数据库（MySQL）与缓存一致我们一般这么做<br><br>① 监控MySQL的Binlog文件，开源组件有canal；<br><br>② 先删数据库在删缓存（删缓存可能会失败，如果删缓存失败，立即重试大概率还是会失败，此时可以将删除动作投递到mq在另外的地方消费进行缓存删除）；","like_count":1},{"had_liked":false,"id":270053,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1608887312,"is_pvip":false,"replies":[{"id":"98285","content":"应该是禁止其他线程读，这样更严谨","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1609376133,"ip_address":"","comment_id":270053,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903854608","product_id":100023901,"comment_content":"锁的降级：释放写锁前，降级为读锁<br>和<br>读写锁的原则3：如果一个写线程正在执行写操作，此时禁止读线程读共享变量。<br>老师，这样是否是矛盾了呢？怎么同时理解呢？<br><br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512499,"discussion_content":"应该是禁止其他线程读，这样更严谨","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609376133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163377,"user_name":"奔跑的蜗牛","can_delete":false,"product_type":"c1","uid":1384698,"ip_address":"","ucode":"C5277C80B423A0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6Nic6V6iawbbIF1RRbRlwNmC0Cmt3LlQRAiaiayCibpplSDPXticVyOp97CEypEuQm2Iib7ZYCjrrlIgWQ/132","comment_is_top":false,"comment_ctime":1576715391,"is_pvip":false,"replies":[{"id":"62402","content":"一般不会饿死，除非读锁异常导致释放不了。公平锁也不是导致写锁等待时间久的主要原因。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1576910138,"ip_address":"","comment_id":163377,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871682687","product_id":100023901,"comment_content":"请教下老师，如果读多写少情况下，是否会存在写锁饿死的情况？如果用公平锁，是否会导致写锁很久才能获取到的情况呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478371,"discussion_content":"一般不会饿死，除非读锁异常导致释放不了。公平锁也不是导致写锁等待时间久的主要原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576910138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134158,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1568768605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863735901","product_id":100023901,"comment_content":"读写锁的写操作是互斥的，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。","like_count":1},{"had_liked":false,"id":102184,"user_name":"GEEKBANG_6638780","can_delete":false,"product_type":"c1","uid":1268264,"ip_address":"","ucode":"952194E56FD8C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","comment_is_top":false,"comment_ctime":1560157576,"is_pvip":false,"replies":[{"id":"36885","content":"进到等待队列，都是按顺序的，没听说写操作会强行排到前面。你可以参考《Java并发编程之美》，里面有代码分析。也可以参考https:&#47;&#47;sourceforge.net&#47;projects&#47;javaconcurrenta&#47;来理解原理。<br>老杨同志的意思是，我猜测是，可能存在1000个读线程在读，而且读的慢，这个时候写操作就会等待的比较久。一旦有一个写操作等待，再有读操作的请求，就会进入等待队列里了，所以写操作不会一直拿不到锁。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1560182544,"ip_address":"","comment_id":102184,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855124872","product_id":100023901,"comment_content":"老杨同志<br>老师，如果读锁的持有时间较长，读操作又比较多，会不会一直拿不到写锁？<br>作者回复: 不会一直拿不到，只是等待的时间会很长<br>----------------------------------------------------<br>老师，你这个回答不对吧。我记得之前看源码是，读写锁，对于写锁是优先的。意思就是说，当有写线程时，哪怕有读线程在等待，都会优先分配给写线程的","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453289,"discussion_content":"进到等待队列，都是按顺序的，没听说写操作会强行排到前面。你可以参考《Java并发编程之美》，里面有代码分析。也可以参考https://sourceforge.net/projects/javaconcurrenta/来理解原理。\n老杨同志的意思是，我猜测是，可能存在1000个读线程在读，而且读的慢，这个时候写操作就会等待的比较久。一旦有一个写操作等待，再有读操作的请求，就会进入等待队列里了，所以写操作不会一直拿不到锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560182544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94589,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1557846503,"is_pvip":false,"replies":[{"id":"33937","content":"可以用公平锁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557930161,"ip_address":"","comment_id":94589,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852813799","product_id":100023901,"comment_content":"王老师，读写锁中加读锁后如何避免写线程饿死？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450120,"discussion_content":"可以用公平锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557930161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89853,"user_name":"有渔@蔡","can_delete":false,"product_type":"c1","uid":1099829,"ip_address":"","ucode":"4AB669229892C8","user_header":"","comment_is_top":false,"comment_ctime":1556283416,"is_pvip":false,"replies":[{"id":"32338","content":"我们做服务工作的......，尽力而已:)。感谢感谢！！！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556464778,"ip_address":"","comment_id":89853,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851250712","product_id":100023901,"comment_content":"真的是用心写了，想必老师工作中也是很负责任的那种。每个要点，都从原理出发。而且纵横比较，这专栏太值了","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448290,"discussion_content":"我们做服务工作的......，尽力而已:)。感谢感谢！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556464778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89063,"user_name":"程序员就要进步","can_delete":false,"product_type":"c1","uid":1245578,"ip_address":"","ucode":"155E2DE1771E79","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/aNdZY7YBA3jx7354T4vLkrQmfzGYXMQ34eqlUSK3jbh8zccLx9rkysCeU0Qic1PkAlukFAibb3hoodpXcF0RjnibA/132","comment_is_top":false,"comment_ctime":1556070788,"is_pvip":false,"replies":[{"id":"31951","content":"互斥锁太慢<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556113147,"ip_address":"","comment_id":89063,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5851038084","product_id":100023901,"comment_content":"老师，我有点不太理解这个读锁存在的意义是什么，既然支持多线程访问，直接不加锁不就行了。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448001,"discussion_content":"互斥锁太慢\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556113147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290205,"discussion_content":"您好，回答下您的疑问。楼上同学说是为了防止多线程读到的数据不一致，其实并不是这个原因，首先要问什么是不一致？然后反问：不一致有什么问题呢？\n\n有些同学认为不一致就是有些读的是旧值，有些读的是新值，所以不一致。\n\n但是即使加读锁，还是会存在有的线程读旧值，有的线程读新值，甚至非公平锁情况下，先开始的线程反而读到新值，而后开始的线程反而读到旧值，所以读锁并不是为了保证多线程读到的值是一样的。\n\n那么读锁的作用是什么呢？\n\n任何锁表面上是互斥，但本质是都是为了避免原子性问题（如果没有原子性问题，那光只用volatile就可以了），读锁自然也是为了避免原子性问题，比如一个long型参数的写操作并不是原子性的，如果允许同时读和写，那读到的数很可能是就是写操作的中间状态。\n\n所以读锁是防止读到写操作的中间值。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594376056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540140,"discussion_content":"说的有道理，解决了我的疑惑。所以我觉得get()数据到底要不要加读锁，还是取决于具体的场景，如果能够容忍不具备原子性所带来的影响，不加读锁也是可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639969807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290205,"ip_address":""},"score":540140,"extra":""}]},{"author":{"id":1444122,"avatar":"https://static001.geekbang.org/account/avatar/00/16/09/1a/e0f95684.jpg","nickname":"空空","note":"","ucode":"8F6EFE5A6F6F64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269927,"discussion_content":"读锁的意义就是，就是在多线程读的时候保证没有其它线程写的操作，要是不加读锁，那读到的数据可能是不一致的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589964279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87739,"user_name":"_light","can_delete":false,"product_type":"c1","uid":1324723,"ip_address":"","ucode":"ACE2ABC357C5FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/36/b3/c4a2f3fd.jpg","comment_is_top":false,"comment_ctime":1555675597,"is_pvip":false,"replies":[{"id":"31568","content":"放到try里面也可以，但是放到外面更清晰一些","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555686209,"ip_address":"","comment_id":87739,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5850642893","product_id":100023901,"comment_content":"老师好，有一个问题想请教一下您，感谢😊<br>对于锁我一直有个疑问，我看了不少源码，发现每次加锁的时候，lock()都是在try语句上面，加锁这个动作放在异常捕获里面会有什么影响吗？<br>private void signalNotEmpty() {<br>    ReentrantLock takeLock = takeLock;<br>    takeLock.lock();<br>    try {<br>        notEmpty.signal();<br>    } finally {<br>        takeLock.unlock();<br>    }<br>}","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447581,"discussion_content":"放到try里面也可以，但是放到外面更清晰一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555686209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306315,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","nickname":"官人","note":"","ucode":"ECEF55B08E252B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537073,"discussion_content":"推荐你放到try上面  你想如果放在try 里面 如果lock 操作抛出异常了 是不是得执行finally  这时候没加锁 你就执行unlock 这就报错了把  而你放在try上面 出异常了 直接就结束了  这才是为什么try 要放在上面的原因呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638950169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84929,"user_name":"Sunny_Lu","can_delete":false,"product_type":"c1","uid":1453000,"ip_address":"","ucode":"4327DE41D7DB28","user_header":"https://static001.geekbang.org/account/avatar/00/16/2b/c8/61eeae65.jpg","comment_is_top":false,"comment_ctime":1554946213,"is_pvip":false,"replies":[{"id":"30661","content":"存在<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555118357,"ip_address":"","comment_id":84929,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849913509","product_id":100023901,"comment_content":"老师，读锁释放，获取写锁的时候，会存在并发，获取不到写锁阻塞的情况吧？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446500,"discussion_content":"存在\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555118357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84756,"user_name":"Geek_c33c8e","can_delete":false,"product_type":"c1","uid":1467234,"ip_address":"","ucode":"A5B70E0A346BDC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BpprxVMjsB0Ok4wGunDLHOLEI9wJX5HIEVsqs2EaXpuODfM7tuiaNfjPcxKWc60TwTaJnTuSicGMicib4r4um02qicQ/132","comment_is_top":false,"comment_ctime":1554902801,"is_pvip":false,"replies":[{"id":"30454","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554903918,"ip_address":"","comment_id":84756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849870097","product_id":100023901,"comment_content":"老师，看到你说写锁可以降级为读锁，是指在同一线程吗？如果是两个线程的话，读写就是互斥的了吧？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446436,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554903918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83284,"user_name":"zhangtnty","can_delete":false,"product_type":"c1","uid":1180553,"ip_address":"","ucode":"3C9A14BD7CF432","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/89/e1621a01.jpg","comment_is_top":false,"comment_ctime":1554516897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849484193","product_id":100023901,"comment_content":"老师好，首先在机器启动未挂机时，监控JVM的GC运行指标，Survivor区一定持续升高，GC次数增多，而且释放空间有限。说明有线程肯定被持续阻塞。然后可以查看JVM的error.log，可以看到lock.BLOCK日志。可排查出锁的阻塞异常。要进一步排查，可review代码的锁使用情况。","like_count":1},{"had_liked":false,"id":83265,"user_name":"Lemon","can_delete":false,"product_type":"c1","uid":1155474,"ip_address":"","ucode":"FED3B7D2931152","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/92/ad27079c.jpg","comment_is_top":false,"comment_ctime":1554505908,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5849473204","product_id":100023901,"comment_content":"看线程的堆栈","like_count":1,"discussions":[{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265664,"discussion_content":"dump","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589425568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353376,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1149402,"ip_address":"北京","ucode":"AD6933D125C930","user_header":"https://static001.geekbang.org/account/avatar/00/11/89/da/136cdca6.jpg","comment_is_top":false,"comment_ctime":1659407973,"is_pvip":false,"replies":[{"id":"130075","content":"基本思路都是这样，最近还遇到内核层协议栈把数据包丢弃的","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1663219307,"ip_address":"北京","comment_id":353376,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1659407973","product_id":100023901,"comment_content":"进程存活，端口还在，cpu很低，内存不高，但是系统不响应，一般就是线程数耗尽，长时间网络IO等待，线程死锁都是有可能的。可以jstack打印看下线程堆栈，这种情况一般会有大量的线程在干同一件事。找到对应的代码再进行分析。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587684,"discussion_content":"基本思路都是这样，最近还遇到内核层协议栈把数据包丢弃的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663219307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349266,"user_name":"Geek_2c6fcd","can_delete":false,"product_type":"c1","uid":2713546,"ip_address":"","ucode":"7A3AF7815351F8","user_header":"","comment_is_top":false,"comment_ctime":1655858377,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655858377","product_id":100023901,"comment_content":"读写锁，为啥写的时候不能读呢。反正map是线程安全的","like_count":0},{"had_liked":false,"id":347913,"user_name":"谦谦","can_delete":false,"product_type":"c1","uid":1029511,"ip_address":"","ucode":"6EBF5F3A158FCA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/87/c8cc2659.jpg","comment_is_top":false,"comment_ctime":1654576991,"is_pvip":false,"replies":[{"id":"127016","content":"拿到读锁，写操作会阻塞，开启这个词不是特别准确","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1655508408,"ip_address":"","comment_id":347913,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1654576991","product_id":100023901,"comment_content":"当开启读锁的时候，写操作会被阻塞吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576390,"discussion_content":"拿到读锁，写操作会阻塞，开启这个词不是特别准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655508408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345830,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652620865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652620865","product_id":100023901,"comment_content":"正如老师所说锁升级可能会导致不释放锁，也就是会死锁。<br>死锁可以通过jdk 自带命令jvisualvm 死锁检测。<br><br>另外就是代码review了，可以发现代码死锁问题。","like_count":0},{"had_liked":false,"id":329380,"user_name":"你的小可爱呀🇩🇪","can_delete":false,"product_type":"c1","uid":1603472,"ip_address":"","ucode":"E1E51D8F45E4BB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9MJ10zCwaUDkHKafchibJ6UTVibVZNpy2ckDkGUzoPM7xgTOO9OokpLSkycYiaT90EcsZ7SyQH9olQ/132","comment_is_top":false,"comment_ctime":1641307971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641307971","product_id":100023901,"comment_content":"读锁升级为写锁的时候，为什么说写锁会永久等待呢？有点没想明白","like_count":0},{"had_liked":false,"id":304457,"user_name":"chenssy","can_delete":false,"product_type":"c1","uid":1074196,"ip_address":"","ucode":"CB5AF27229E2D1","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/14/c980c239.jpg","comment_is_top":false,"comment_ctime":1627434968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627434968","product_id":100023901,"comment_content":"查看线程死锁情况就可以了","like_count":0},{"had_liked":false,"id":293736,"user_name":"Geek_edc76d","can_delete":false,"product_type":"c1","uid":2313724,"ip_address":"","ucode":"E6B9E1930C3AAD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/drctCc7ys2K91CKqc1OgBeAJWgx0wvGvtlgCo8gmtobmVicu1W9Z89RCqaHW86emMRt17Cr1RHaQvnR7QqUUPfg/132","comment_is_top":false,"comment_ctime":1621513506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621513506","product_id":100023901,"comment_content":"每个读写锁只有一个读锁和一个写锁","like_count":0},{"had_liked":false,"id":285210,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1616666560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616666560","product_id":100023901,"comment_content":"1. 分析线程dump堆栈，可以用jconsle<br>2. 查看源码找到读写锁的代码，查看是不是有升级的情况出现","like_count":0},{"had_liked":false,"id":284139,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1616075936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616075936","product_id":100023901,"comment_content":"锁降级是不是违反第3个规则：如果一个写线程正在执行写操作，此时禁止读线程读共享变量。","like_count":0},{"had_liked":false,"id":283630,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1615860414,"is_pvip":true,"replies":[{"id":"103346","content":"optionsWhenMiss.get() 后面要刷新一下cache，其他没看出来有啥问题。内存缓存用行锁的效率，你可以再测试一下","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1616513055,"ip_address":"","comment_id":283630,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1615860414","product_id":100023901,"comment_content":"自己实现了一个基于读写锁的缓存，按照 Cache Key 的粒度进行加锁，减少锁竞争，请老师指正：https:&#47;&#47;github.com&#47;ZhangShenao&#47;architect&#47;blob&#47;master&#47;architect&#47;cache&#47;src&#47;main&#47;java&#47;william&#47;pattern&#47;SimpleCache.java","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517098,"discussion_content":"optionsWhenMiss.get() 后面要刷新一下cache，其他没看出来有啥问题。内存缓存用行锁的效率，你可以再测试一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616513055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281387,"user_name":"丁乐洪","can_delete":false,"product_type":"c1","uid":1264392,"ip_address":"","ucode":"549CE57AB20B49","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","comment_is_top":false,"comment_ctime":1614735537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614735537","product_id":100023901,"comment_content":"锁降级没理解。写锁释放后，读锁也会同时释放吗？","like_count":0},{"had_liked":false,"id":271852,"user_name":"LQS  KF","can_delete":false,"product_type":"c1","uid":1364737,"ip_address":"","ucode":"3C0A07A8220094","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/01/716d45b6.jpg","comment_is_top":false,"comment_ctime":1609841367,"is_pvip":false,"replies":[{"id":"98607","content":"������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1609895784,"ip_address":"","comment_id":271852,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1609841367","product_id":100023901,"comment_content":"使用jps+jstat 或者JMC和JVisual VM等监控工具获取线程dump信息。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513068,"discussion_content":"������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609895784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244095,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1125259,"ip_address":"","ucode":"7BF52ADBFD4F5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/8b/dd02189a.jpg","comment_is_top":false,"comment_ctime":1598402092,"is_pvip":false,"replies":[{"id":"90226","content":"你可以结合锁重入理解一下，自己获取了锁不属于其他线程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1598926564,"ip_address":"","comment_id":244095,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1598402092","product_id":100023901,"comment_content":"王老师，ReentrantLock获取读锁的前提是没有其他线程占用写锁。那为啥可以支持锁降级呢？你的最后一个demo中是没有释放写锁的情况下获取到了读锁","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504478,"discussion_content":"你可以结合锁重入理解一下，自己获取了锁不属于其他线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598926564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380792,"discussion_content":"获取读锁的时候不能有其他线程占有写锁，此时写锁在自己手上，再去获取写锁时，线程ID还是自己，而读写锁又是可重入的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624698779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241992,"user_name":"VIC","can_delete":false,"product_type":"c1","uid":1114064,"ip_address":"","ucode":"3B3E6D344488B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/d0/402be1e9.jpg","comment_is_top":false,"comment_ctime":1597554707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597554707","product_id":100023901,"comment_content":"synchronized(string.intern)<br>writelock.lock<br><br>老师，能分析下吗","like_count":0},{"had_liked":false,"id":238098,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1596070777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596070777","product_id":100023901,"comment_content":"锁降级的体现形式就是写锁未释放之前获取读锁，可是开篇不是说在获取读锁的时候不允许其他线程读和写吗？想到这我仔细一看，是和其他线程仍然保持互斥的，也就是本线程的降级，这是不是可重入锁的体现啊？","like_count":0},{"had_liked":false,"id":236436,"user_name":"denofiend","can_delete":false,"product_type":"c1","uid":1594508,"ip_address":"","ucode":"FC9A750C96E01C","user_header":"https://static001.geekbang.org/account/avatar/00/18/54/8c/a3b98f6c.jpg","comment_is_top":false,"comment_ctime":1595415256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595415256","product_id":100023901,"comment_content":"&#47;&#47; 写缓存 V put(K key, V value) { w.lock(); try { return m.put(key, v); } finally { w.unlock(); } } 这里put里面的v变量应该是value吧？","like_count":0},{"had_liked":false,"id":234204,"user_name":"古夜","can_delete":false,"product_type":"c1","uid":1341612,"ip_address":"","ucode":"0A82D3CFCEDF07","user_header":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","comment_is_top":false,"comment_ctime":1594619494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594619494","product_id":100023901,"comment_content":"为什么写锁-&gt;读锁就是降级呢？","like_count":0},{"had_liked":false,"id":224696,"user_name":"迈克糖","can_delete":false,"product_type":"c1","uid":1749228,"ip_address":"","ucode":"A55D3DB2B20C4B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b0/ec/78be126d.jpg","comment_is_top":false,"comment_ctime":1591511874,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1591511874","product_id":100023901,"comment_content":"读写锁，我读的部分设锁干什么，我直接在写的部分设锁不信吗","like_count":0,"discussions":[{"author":{"id":1975331,"avatar":"","nickname":"Geek_247d5f","note":"","ucode":"3B69CD116FDC01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281995,"discussion_content":"假设读的时候不加读锁，现在有一堆线程正在读，这是突然来了一个写线程，写的过程中，其他读的线程就可能读取到不一致的内容。如果加了读锁，这个写线程就会阻塞，等其他读线程都执行完后才会去写数据。说白了用读锁就是为了防止写线程写数据。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591858352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1749228,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/ec/78be126d.jpg","nickname":"迈克糖","note":"","ucode":"A55D3DB2B20C4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1975331,"avatar":"","nickname":"Geek_247d5f","note":"","ucode":"3B69CD116FDC01","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282866,"discussion_content":"感谢感谢明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592104914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281995,"ip_address":""},"score":282866,"extra":""}]}]},{"had_liked":false,"id":224530,"user_name":"Just","can_delete":false,"product_type":"c1","uid":2022626,"ip_address":"","ucode":"35FA6917DE1D04","user_header":"https://static001.geekbang.org/account/avatar/00/1e/dc/e2/a3abd320.jpg","comment_is_top":false,"comment_ctime":1591431594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591431594","product_id":100023901,"comment_content":"写锁之后获取读锁，释放顺序没做要求，理解的是不是同一个锁，顺序没做要求，但只能进行锁降级","like_count":0},{"had_liked":false,"id":224335,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1591347238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591347238","product_id":100023901,"comment_content":"关于重复查询数据库的问题，现在一般mybatis类似的框架会有一级&#47;二级缓存吧，问题应该不算太大","like_count":0},{"had_liked":false,"id":223274,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1591053519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591053519","product_id":100023901,"comment_content":"用 Top 、Jstack 确认阻塞的线程及代码位置。","like_count":0},{"had_liked":false,"id":223015,"user_name":"UniqueDirt","can_delete":false,"product_type":"c1","uid":2001375,"ip_address":"","ucode":"1E5555EE495733","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkDobVTaXD0oWouJBHQQSvnicJnzfZ7cSKmZeV20svZ7uWKGkibnL8xXiaOPRPYP7IibVIWPaCBDhjMw/132","comment_is_top":false,"comment_ctime":1590982065,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1590982065","product_id":100023901,"comment_content":"老师你好！<br>对于这句话有点不理解的地方：<br>“在上面的代码示例中，读锁还没有释放，此时获取写锁，会导致写锁永久等待，最终导致相关线程都被阻塞，永远也没有机会被唤醒”<br>如果写锁的前提是读锁没有被占用；  为啥在读锁里获取写锁不会直接报错呢  ？ 既然已经获取了读锁又获取的写锁为啥写锁还会进入永久等待呢","like_count":0,"discussions":[{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307733,"discussion_content":"A thread that tries to acquire a fair write lock (non-reentrantly) will block unless both the read lock and write lock are free (which implies there are no waiting threads).\n(Note that the non-blocking\n {@link ReadLock#tryLock()} and {@link WriteLock#tryLock()} methods do not honor this fair setting and will immediately acquire the lock if it is possible, regardless of waiting threads.)\n\n使用lock()获取锁是阻塞式的，非阻塞式获取锁需要用trylock（）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600745534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222202,"user_name":"josancpp","can_delete":false,"product_type":"c1","uid":1533266,"ip_address":"","ucode":"0CDC39B3E716A3","user_header":"https://static001.geekbang.org/account/avatar/00/17/65/52/07c09c7f.jpg","comment_is_top":false,"comment_ctime":1590716055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590716055","product_id":100023901,"comment_content":"说下我的理解，为什么读写锁不支持升级。<br>因为读锁是可以多个线程访问临界区的，如果支持某个线程升级到写锁，修改数据。那么，其他拥有读锁的线程，就很有可能读入脏数据。","like_count":0},{"had_liked":false,"id":221264,"user_name":"Geek_3422b1","can_delete":false,"product_type":"c1","uid":2007135,"ip_address":"","ucode":"ECD3AF9B1AFF13","user_header":"","comment_is_top":false,"comment_ctime":1590458460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590458460","product_id":100023901,"comment_content":"不支持锁升级的原因（源码层面）：<br>              获取写锁的时候，tryAcquire()  内会判断时候获取了读锁，如果有读锁，返回false<br>支持锁降级的原因:<br>               tryAcquireShared 内部，如果有写锁且获取写锁的线程不是本线程则失败，否则允许继续","like_count":0},{"had_liked":false,"id":217138,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1589424721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589424721","product_id":100023901,"comment_content":"思考题：<br>我会先看线程dump文件，分析具体哪里有阻塞现象，来判断具体的问题","like_count":0},{"had_liked":false,"id":214265,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1008071,"ip_address":"","ucode":"9FE5F43055D3AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/c7/b64ac05e.jpg","comment_is_top":false,"comment_ctime":1588687995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588687995","product_id":100023901,"comment_content":"老师请问:<br>如果一个写线程正在执行写操作，此时禁止读线程读共享变量<br><br>上面的锁降级之所以可以时不时因为是同一个线程同时拿了读写锁,而且是先拿写锁再拿读锁,所以可以锁降级,反之锁升级不行？","like_count":0},{"had_liked":false,"id":214153,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588667975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588667975","product_id":100023901,"comment_content":"读写锁: 读写互斥，读读并行<br>支持锁降级，不支持锁升级<br>缓存加载: 全部缓存和按需加载<br><br>cpu利用率很低的时候，系统不响应外部请求。<br>读写锁升级时检查: 根据外部请求检查代码, 通过堆栈信息查看死锁位置。","like_count":0},{"had_liked":false,"id":213329,"user_name":"程序员马称","can_delete":false,"product_type":"c1","uid":1313565,"ip_address":"","ucode":"97CA62BF9AA10E","user_header":"https://static001.geekbang.org/account/avatar/00/14/0b/1d/4e80cd22.jpg","comment_is_top":false,"comment_ctime":1588386441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588386441","product_id":100023901,"comment_content":"老师,请问为什么拥有读锁时,尝试获取写锁会死锁","like_count":0},{"had_liked":false,"id":208848,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1587449872,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587449872","product_id":100023901,"comment_content":"数据库插入一条在缓存里没有的数据，然后前端发送请求读取并缓存该数据，如果出现写等待，那么该请求应该出现请求超时，缓存里没有该数据","like_count":0},{"had_liked":false,"id":205527,"user_name":"Ever After","can_delete":false,"product_type":"c1","uid":1740386,"ip_address":"","ucode":"AF3941A3B92BD1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8e/62/569b7d1f.jpg","comment_is_top":false,"comment_ctime":1586664705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586664705","product_id":100023901,"comment_content":"对于读写锁的升级和降级，对老师文中的解释优点疑问：“读锁还没有释放，此时获取写锁，会导致写锁永久等待，最后导致相关线程被阻塞，永远没有机会被唤醒。”那锁的降级岂不是也有这种情况：“写锁还没有释放，此时获取读锁，会导致读锁永久等待，最后导致相关线程被阻塞，永远没有机会被唤醒。” 我个人理解是读写锁的特性决定的：某一时刻，只允许一个线程写；或者某一时刻，允许多个线程同时读；写时不允许读。从多线程角度考虑，如果当前线程在未释放读锁的前提下，获取到写锁，那么等待获取该资源写锁的多个线程可能永远没有机会获得写锁而被饿死，所以不允许锁的升级；但是锁的降级就不一样了，允许多个线程同时获得该资源的读锁，所以就算当前线程继续获得读锁，在该线程释放写锁后，其它线程仍然可以获取到读锁，不会出现被饿死的现象。<br>请老师指正！","like_count":0},{"had_liked":false,"id":201988,"user_name":"Zend","can_delete":false,"product_type":"c1","uid":1053921,"ip_address":"","ucode":"80EBB0B6772E27","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","comment_is_top":false,"comment_ctime":1585885009,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585885009","product_id":100023901,"comment_content":"请问ReentrantReadWriteLock 在写锁的时候，是不是不能有读锁被占用？","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380793,"discussion_content":"不行，获取写锁的前提是读锁和写锁均未被占用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624699525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199702,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1585494124,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585494124","product_id":100023901,"comment_content":"想请教老师一个问题，既然写锁能解决并发的问题，为什么在写锁前还需要加上读锁","like_count":0,"discussions":[{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265666,"discussion_content":"主要是提高性能，读锁是能被多个线程共享的，对于这一块是并行，而到了写锁那一块，就转变成了串行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589425861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178287,"user_name":"林","can_delete":false,"product_type":"c1","uid":1543907,"ip_address":"","ucode":"E1D26D1AB1B14D","user_header":"https://static001.geekbang.org/account/avatar/00/17/8e/e3/a9f4ed7f.jpg","comment_is_top":false,"comment_ctime":1581651070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581651070","product_id":100023901,"comment_content":"懒加载例子的代码好像有点小问题 最后返回的v可能为null 在写锁里再次校验后如果还是为null，做了写入缓存的操作但是并没有读出v的值 最后应该36行返回 return m.get(key)  或者在写锁里再拿一次v的值，不知道我理解的有问题没","like_count":0},{"had_liked":false,"id":175817,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1580838116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580838116","product_id":100023901,"comment_content":"获取缓存的多次校验 应该是和 用二次校验实现的单例模式  目的是一样的","like_count":0},{"had_liked":false,"id":173556,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1579596053,"is_pvip":false,"replies":[{"id":"67405","content":"降级后，允许同时读","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579743800,"ip_address":"","comment_id":173556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579596053","product_id":100023901,"comment_content":"大佬老师，为啥锁要降级呢?不是又要消耗一次获取读锁的操作么? 锁降级有啥子用呀。。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482114,"discussion_content":"降级后，允许同时读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579743800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167050,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1577677983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577677983","product_id":100023901,"comment_content":"老师，建议在这个篇文章中添加一下读写锁的简单实现，否则很难理解为什么读写锁不适合做升级操作。我找了一些资料，才算明白。","like_count":0},{"had_liked":false,"id":164826,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1577096770,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577096770","product_id":100023901,"comment_content":"哪有缓存读取还加锁的  就直接读，读不到再加锁从db加载数据","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380795,"discussion_content":"假如变量i，get(){ return i } ,set(){ return i++ } get不加锁，set加锁，就会导致可能get在读的时候，set在写，此时get的值是不对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624699783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164658,"user_name":"哈喽沃德","can_delete":false,"product_type":"c1","uid":1749033,"ip_address":"","ucode":"7620366C16826B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b0/29/7ab573f4.jpg","comment_is_top":false,"comment_ctime":1577067342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577067342","product_id":100023901,"comment_content":"在看到第一个例子里，先获取读取锁，获取数据后再释放读取锁，然后再获取写入锁，再进行写入操作的时候，我就想到为啥这么麻烦，然后后面就出现了我头脑里的错误的例子。","like_count":0},{"had_liked":false,"id":154654,"user_name":"草戊","can_delete":false,"product_type":"c1","uid":1044202,"ip_address":"","ucode":"F1B0CB0A4FA762","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/ea/c8136dfd.jpg","comment_is_top":false,"comment_ctime":1574501229,"is_pvip":false,"replies":[{"id":"59683","content":"锁什么，保护什么是前面理论部分讲的，读锁如果能写，还要写锁做什么呢？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1574728255,"ip_address":"","comment_id":154654,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574501229","product_id":100023901,"comment_content":"读写锁的三条原则感觉写的有缺漏，只写了写锁后无法读，但是读锁后能不能写？读锁的意义是什么，到底锁什么？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475536,"discussion_content":"锁什么，保护什么是前面理论部分讲的，读锁如果能写，还要写锁做什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574728255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1044202,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ee/ea/c8136dfd.jpg","nickname":"草戊","note":"","ucode":"F1B0CB0A4FA762","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66760,"discussion_content":"道理能明白，个人觉得既然作为原则列出来，应该准确一致描述更好。如果列出了写锁无法读，读锁无法写是对称性的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575105101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143083,"user_name":"Carisy","can_delete":false,"product_type":"c1","uid":1657429,"ip_address":"","ucode":"67E887967347BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwTZdUafC5YM7bCASt8icUnoyYfV4hUHulexibDI7B4eaokTxYXHFtoic97DBlCAU9j5Jw4QUuGhyZQ/132","comment_is_top":false,"comment_ctime":1571627815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571627815","product_id":100023901,"comment_content":"最后一段代码，在try块里进行读锁的加锁会不会有问题，抛出异常写锁能接掉但是最后代码块的释放读锁会不会有问题","like_count":0},{"had_liked":false,"id":140506,"user_name":"民工597","can_delete":false,"product_type":"c1","uid":1529858,"ip_address":"","ucode":"DB6857E21E9318","user_header":"https://static001.geekbang.org/account/avatar/00/17/58/02/2b7ccf09.jpg","comment_is_top":false,"comment_ctime":1570971602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570971602","product_id":100023901,"comment_content":"请问如果hashmap扩容怎么办？","like_count":0},{"had_liked":false,"id":136375,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1569418468,"is_pvip":true,"replies":[{"id":"52308","content":"java并发编程艺术里讲的挺详细，建议看书吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569459057,"ip_address":"","comment_id":136375,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569418468","product_id":100023901,"comment_content":"arrayList肯定是不能用的，并访问List资源不单单会有各种异常，就单单List的Fast-Fail规则就不允许。老师什么时候可以讲解下AQS不？刚刚看了下ReentrantReadWriteLock的源码，发现它依赖的是AQS中的share和exclusive模式实现的，但是具体看源代码，整个人就懵逼了，完全没啥头绪","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468599,"discussion_content":"java并发编程艺术里讲的挺详细，建议看书吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569459057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129454,"user_name":"dingdongfm","can_delete":false,"product_type":"c1","uid":1564213,"ip_address":"","ucode":"7D17D2BC392A66","user_header":"","comment_is_top":false,"comment_ctime":1567132066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567132066","product_id":100023901,"comment_content":"当一个线程在写共享变量的时候，是不允其他线程读和写的；但是可在同一线程中实现锁的降级，即由写锁降级为读锁。","like_count":0},{"had_liked":false,"id":122625,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1565443560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565443560","product_id":100023901,"comment_content":"用jstack查看是否存在多个线程在等待同一个对象，但这个对象却并没有被其他线程占用？","like_count":0},{"had_liked":false,"id":119874,"user_name":"Fortune","can_delete":false,"product_type":"c1","uid":1508654,"ip_address":"","ucode":"6B9465AC996523","user_header":"https://static001.geekbang.org/account/avatar/00/17/05/2e/5a6b6b6e.jpg","comment_is_top":false,"comment_ctime":1564716516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564716516","product_id":100023901,"comment_content":"来自小白的理解哈：<br>锁的升级：获取读锁，获取写锁，释放写锁，释放读锁，这样会导致线程读锁还没有释放，就要拿写锁，导致阻塞，不支持：<br>锁的降级：获取读锁，释放读锁，获取写锁，获取读锁，释放写锁，释放读锁，这种是支持的。","like_count":0},{"had_liked":false,"id":118609,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1564396040,"is_pvip":false,"replies":[{"id":"43621","content":"数据库主要是读写锁，和管程不同。你可以查询一下mdl锁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1564485710,"ip_address":"","comment_id":118609,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564396040","product_id":100023901,"comment_content":"宝令老师，可以问一个数据库MDL锁的问题么？<br><br>session A: begin; select * from t limit 1; 最先启动sessionA<br>session B: begin; select * from t limit 1; 紧接着启动sessionB<br>session C: alter table t add f int; 然后再是启动sessionC<br>session D: begin; select * from t limit 1; 最后是启动sessionD<br><br>在MySQL里，session A和B正常启动，然后session C被block，之后session D也被block。当把 session A 和 session B 不会阻塞，发现session C是block的，Session D读也被C阻塞<br><br>我想问的这里的锁实现用JAVA里的管程模型一致么？为什么Session C阻塞在写锁上，会导致Session D和后面的事务都不能读？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460481,"discussion_content":"数据库主要是读写锁，和管程不同。你可以查询一下mdl锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564485710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114653,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1563357159,"is_pvip":false,"replies":[{"id":"41902","content":"大部分都是查询前做的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1563405469,"ip_address":"","comment_id":114653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563357159","product_id":100023901,"comment_content":"请问下一次性缓存初始化是在碰到查询后才做的还是查询前预先做好的","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458760,"discussion_content":"大部分都是查询前做的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563405469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110382,"user_name":"空白","can_delete":false,"product_type":"c1","uid":1084378,"ip_address":"","ucode":"1E1E05CF8A7B1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/8b/da/c3c2a324.jpg","comment_is_top":false,"comment_ctime":1562246082,"is_pvip":false,"replies":[{"id":"40643","content":"现在处理高并发主要靠分布式，单机的性能损失就不那么重要了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562597678,"ip_address":"","comment_id":110382,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562246082","product_id":100023901,"comment_content":"老师，像这种需要排查的情况下，在生产环境中gc日志打印功能是不是要打开？如果打开的话会影响程序的性能吧。如果不打开的话，生产环境就不太好定位问题了吧？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456849,"discussion_content":"现在处理高并发主要靠分布式，单机的性能损失就不那么重要了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562597678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107550,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1561556142,"is_pvip":false,"replies":[{"id":"38923","content":"我只能说，没有必要用读写锁实现一个线程安全的map，读写锁还有很多其他应用场景","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561595219,"ip_address":"","comment_id":107550,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561556142","product_id":100023901,"comment_content":"老师 听说concurrentHashMap做过优化(通过无锁cas操作) 不一定非要用读写锁 是不是这样","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455554,"discussion_content":"我只能说，没有必要用读写锁实现一个线程安全的map，读写锁还有很多其他应用场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561595219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023688,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9e/c8/d261f700.jpg","nickname":"yswang","note":"","ucode":"B9CB98838B215C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3158,"discussion_content":"ConcurrentHashMap无法做到 lazy load。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564233348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103238,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1560402261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560402261","product_id":100023901,"comment_content":"有写禁止读。读锁无法升级成写锁。那么写锁持有锁时已经在执行逻辑的读锁会怎么样？有读不禁止写，那么读写锁的写锁🐔饿又是什么情况下出现的？","like_count":0},{"had_liked":false,"id":103116,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1560386140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560386140","product_id":100023901,"comment_content":"关于思考题，直接在代码里找读写锁应用的地方看他有没有写错来验证呀，原谅我啥也不会233","like_count":0},{"had_liked":false,"id":99939,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1559363091,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1559363091","product_id":100023901,"comment_content":"老师既然读写锁的都是可以多线程读的，那为什么还要读锁，不是可以读的时候不加锁了么，有读锁的原因是不是因为有写锁，读到的时候要判断有没有写吧，如果没有写就读锁是没用的？","like_count":0,"discussions":[{"author":{"id":1733692,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/74/3c/da79d2a1.jpg","nickname":"朕爱吾妃","note":"","ucode":"B10EB69934F9E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53908,"discussion_content":"如果没有读锁，我认为写锁不能判断是否存在有线程是否在访问，写锁必须保证没有线程再读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574231944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93473,"user_name":"JackLei","can_delete":false,"product_type":"c1","uid":1099989,"ip_address":"","ucode":"01128A61A9E80F","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/d5/e88c1805.jpg","comment_is_top":false,"comment_ctime":1557476949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557476949","product_id":100023901,"comment_content":"这个课程值得，我在极客买了9个课程","like_count":0},{"had_liked":false,"id":91009,"user_name":"小小少年","can_delete":false,"product_type":"c1","uid":1446717,"ip_address":"","ucode":"BCBEC92B9DFA85","user_header":"https://static001.geekbang.org/account/avatar/00/16/13/3d/63bab08c.jpg","comment_is_top":false,"comment_ctime":1556786296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556786296","product_id":100023901,"comment_content":"我才勉强能看懂，😁😂","like_count":0},{"had_liked":false,"id":89928,"user_name":"有渔@蔡","can_delete":false,"product_type":"c1","uid":1099829,"ip_address":"","ucode":"4AB669229892C8","user_header":"","comment_is_top":false,"comment_ctime":1556333601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556333601","product_id":100023901,"comment_content":"关于你说的锁升级问题，我觉得应该从ReadWriteLock的实现原理来解释。1.假如有线程在写，肯定不让读，这时读线程wait。所以，先读后写的锁升级就导致读线程永远等待。2.假如有线程在读，可以写，那么先读后写的锁降级是可以的。如果有线程在读时，不允许写，那么锁降级一样永远等待下去","like_count":0},{"had_liked":false,"id":89354,"user_name":"大利小新","can_delete":false,"product_type":"c1","uid":1450812,"ip_address":"","ucode":"4571E53355A476","user_header":"https://static001.geekbang.org/account/avatar/00/16/23/3c/566b2b26.jpg","comment_is_top":false,"comment_ctime":1556157815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556157815","product_id":100023901,"comment_content":"HashMap线程不安全准确的说法是存时可能不安全。","like_count":0},{"had_liked":false,"id":86300,"user_name":"JGOS","can_delete":false,"product_type":"c1","uid":1237592,"ip_address":"","ucode":"46A905A169408F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/58/2468a5e9.jpg","comment_is_top":false,"comment_ctime":1555341448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555341448","product_id":100023901,"comment_content":"所谓升级降级，本质上是一把锁的排它性的变化，此处的读写锁其实是一把锁的不同视图。","like_count":0},{"had_liked":false,"id":84566,"user_name":"Geek_c33c8e","can_delete":false,"product_type":"c1","uid":1467234,"ip_address":"","ucode":"A5B70E0A346BDC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BpprxVMjsB0Ok4wGunDLHOLEI9wJX5HIEVsqs2EaXpuODfM7tuiaNfjPcxKWc60TwTaJnTuSicGMicib4r4um02qicQ/132","comment_is_top":false,"comment_ctime":1554877247,"is_pvip":false,"replies":[{"id":"30451","content":"互斥锁能满足，只是慢","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554898787,"ip_address":"","comment_id":84566,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1554877247","product_id":100023901,"comment_content":"老师还是有点不明白这个读写锁，譬如在get方法的是，r.lock和r.unlock没有什么意义啊，因为r锁是支持并发，在get方法获取不到的时候，才加write锁，那这样岂不是ReentrantLock应该也可以满足，不同的是，ReentrantReadWriteLock写的时候，可以控制其他线程不同读，ReentrantLock不能做到这点而已。这对于多线程的影响会大吗？求解答下","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446389,"discussion_content":"互斥锁能满足，只是慢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554898787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380797,"discussion_content":"提升了性能，而不是读写都阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624701152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84135,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1554791532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554791532","product_id":100023901,"comment_content":"锁降级为读锁可以直接获取当前锁,避免可能发生其他线程的写锁获取写操作","like_count":0},{"had_liked":false,"id":84134,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1554791448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554791448","product_id":100023901,"comment_content":"写锁没结束,锁降级为读锁,读锁可以操作共享变量 这还是同一个线程操作 所以跟原则第三条互斥 不矛盾~~~","like_count":0},{"had_liked":false,"id":84114,"user_name":"悟空","can_delete":false,"product_type":"c1","uid":1451125,"ip_address":"","ucode":"F9DFBA74B35B40","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/75/808ac160.jpg","comment_is_top":false,"comment_ctime":1554787255,"is_pvip":false,"replies":[{"id":"31319","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555511870,"ip_address":"","comment_id":84114,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554787255","product_id":100023901,"comment_content":"我会dump出线程信息，查看有没有线程在等待获取写锁","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446257,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555511870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84092,"user_name":"胡桥","can_delete":false,"product_type":"c1","uid":1055874,"ip_address":"","ucode":"673C3207614010","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/82/74ab79df.jpg","comment_is_top":false,"comment_ctime":1554781317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554781317","product_id":100023901,"comment_content":"课后思考：因为读锁与读锁直接不会互斥，所以可以看看系统中仅有“读操作”的模块是否还能响应。","like_count":0},{"had_liked":false,"id":84026,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1554771063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554771063","product_id":100023901,"comment_content":"jstack两次以上，对比堆栈信息","like_count":0},{"had_liked":false,"id":83631,"user_name":"彭锐","can_delete":false,"product_type":"c1","uid":1179669,"ip_address":"","ucode":"F2CB53DE42026D","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/15/6e399ec7.jpg","comment_is_top":false,"comment_ctime":1554686728,"is_pvip":false,"replies":[{"id":"30262","content":"抢占不了，等着所有的读锁释放<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554702601,"ip_address":"","comment_id":83631,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554686728","product_id":100023901,"comment_content":"思考题的答案是看调用栈。<br>还有一个问题是，在读多写少的场景会不会很容易出现一直获取不到写锁的情况？这怎么办，一直重试，还是抢占读锁，逼迫读锁走异常流程？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446105,"discussion_content":"抢占不了，等着所有的读锁释放\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554702601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83529,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1554641090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554641090","product_id":100023901,"comment_content":"回答老师的问题，我觉得可以用arthas通过命令thread -b可以查看当前的阻塞线程具体分析","like_count":0},{"had_liked":false,"id":83526,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1554640714,"is_pvip":false,"replies":[{"id":"30260","content":"是<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554701280,"ip_address":"","comment_id":83526,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554640714","product_id":100023901,"comment_content":"老师，想请问锁降级后读锁内拿到的共享数据是最新的吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446056,"discussion_content":"是\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554701280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83416,"user_name":"一眼万年","can_delete":false,"product_type":"c1","uid":1018200,"ip_address":"","ucode":"7B0823E39AE809","user_header":"","comment_is_top":false,"comment_ctime":1554567326,"is_pvip":false,"replies":[{"id":"30147","content":"读写互斥，读读不用互斥","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554606864,"ip_address":"","comment_id":83416,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554567326","product_id":100023901,"comment_content":"读锁可以多线程同时获取？那跟锁本质(解决互斥)有冲突？似乎只是保证可见性","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446014,"discussion_content":"读写互斥，读读不用互斥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554606864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83405,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1554561665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554561665","product_id":100023901,"comment_content":"有源码的话可以直接查阅有没有 锁升级吧; <br>如果写了锁升级了   写锁的操作一直阻塞 不能发生,读锁一直没问题,通过这个也可以猜读锁可能发生锁升级","like_count":0},{"had_liked":false,"id":83393,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1554555073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554555073","product_id":100023901,"comment_content":"dump线程信息，查看锁请求","like_count":0},{"had_liked":false,"id":83392,"user_name":"缪文","can_delete":false,"product_type":"c1","uid":1042262,"ip_address":"","ucode":"59603B50EF5FC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/56/c72997f3.jpg","comment_is_top":false,"comment_ctime":1554554760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554554760","product_id":100023901,"comment_content":"guava 的local cache实现就是这个原理吧？","like_count":0},{"had_liked":false,"id":83388,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1554554118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554554118","product_id":100023901,"comment_content":"去检查上锁的地方，创建线程的时候个每个线程创建独立的名称，在线程上锁和释放锁的地方打上日志，并打上关键字线程名称，并记录从上锁到释放锁的时长，观察日志，可以通过模块测试跑日志去查看","like_count":0},{"had_liked":false,"id":83345,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1299615,"ip_address":"","ucode":"528DD5C8399AEC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKlwpFM3tkeG15YqyJTYWkfqkdmro9POq6SicYm57TaEFDOUZCXjoe0Z0Iz6UibGQqic3icJRsHdFzibtw/132","comment_is_top":false,"comment_ctime":1554541563,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554541563","product_id":100023901,"comment_content":"可以通过jstack来dump出来线程栈来分析系统的线程状态，通过dump结果就可以看出是否有线程死锁。","like_count":0},{"had_liked":false,"id":83329,"user_name":"夏日雨","can_delete":false,"product_type":"c1","uid":1117422,"ip_address":"","ucode":"D8066F89D3A8A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/ee/7667642c.jpg","comment_is_top":false,"comment_ctime":1554534598,"is_pvip":false,"replies":[{"id":"30116","content":"火眼金睛！！！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554537482,"ip_address":"","comment_id":83329,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554534598","product_id":100023901,"comment_content":"最后一段代码里面的注释&quot;&#47;&#47; 释放读锁，因为允许读锁的升级&quot;应该是&quot;不允许读锁的升级&quot;吧~","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445979,"discussion_content":"火眼金睛！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554537482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83306,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1554526432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554526432","product_id":100023901,"comment_content":"jstack查看线程阻塞情况","like_count":0}]}