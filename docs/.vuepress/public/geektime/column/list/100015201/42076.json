{"id":42076,"title":"25 | 深入解析声明式API（二）：编写自定义控制器","content":"<p>你好，我是张磊。今天我和你分享的主题是：深入解析声明式API之编写自定义控制器。</p><p>在上一篇文章中，我和你详细分享了Kubernetes中声明式API的实现原理，并且通过一个添加Network对象的实例，为你讲述了在Kubernetes里添加API资源的过程。</p><p>在今天的这篇文章中，我就继续和你一起完成剩下一半的工作，即：为Network这个自定义API对象编写一个自定义控制器（Custom Controller）。</p><p>正如我在上一篇文章结尾处提到的，“声明式API”并不像“命令式API”那样有着明显的执行逻辑。这就使得<strong>基于声明式API的业务功能实现，往往需要通过控制器模式来“监视”API对象的变化（比如，创建或者删除Network），然后以此来决定实际要执行的具体工作。</strong></p><p>接下来，我就和你一起通过编写代码来实现这个过程。这个项目和上一篇文章里的代码是同一个项目，你可以从<a href=\"https://github.com/resouer/k8s-controller-custom-resource\">这个GitHub库</a>里找到它们。我在代码里还加上了丰富的注释，你可以随时参考。</p><p>总得来说，编写自定义控制器代码的过程包括：编写main函数、编写自定义控制器的定义，以及编写控制器里的业务逻辑三个部分。</p><p><span class=\"orange\">首先，我们来编写这个自定义控制器的main函数。</span></p><!-- [[[read_end]]] --><p>main函数的主要工作就是，定义并初始化一个自定义控制器（Custom Controller），然后启动它。这部分代码的主要内容如下所示：</p><pre><code>func main() {\n  ...\n  \n  cfg, err := clientcmd.BuildConfigFromFlags(masterURL, kubeconfig)\n  ...\n  kubeClient, err := kubernetes.NewForConfig(cfg)\n  ...\n  networkClient, err := clientset.NewForConfig(cfg)\n  ...\n  \n  networkInformerFactory := informers.NewSharedInformerFactory(networkClient, ...)\n  \n  controller := NewController(kubeClient, networkClient,\n  networkInformerFactory.Samplecrd().V1().Networks())\n  \n  go networkInformerFactory.Start(stopCh)\n \n  if err = controller.Run(2, stopCh); err != nil {\n    glog.Fatalf(&quot;Error running controller: %s&quot;, err.Error())\n  }\n}\n</code></pre><p>可以看到，这个main函数主要通过三步完成了初始化并启动一个自定义控制器的工作。</p><p><strong>第一步</strong>：main函数根据我提供的Master配置（APIServer的地址端口和kubeconfig的路径），创建一个Kubernetes的client（kubeClient）和Network对象的client（networkClient）。</p><p>但是，如果我没有提供Master配置呢？</p><p>这时，main函数会直接使用一种名叫<strong>InClusterConfig</strong>的方式来创建这个client。这个方式，会假设你的自定义控制器是以Pod的方式运行在Kubernetes集群里的。</p><p>而我在第15篇文章<a href=\"https://time.geekbang.org/column/article/40466\">《深入解析Pod对象（二）：使用进阶》</a>中曾经提到过，Kubernetes 里所有的Pod都会以Volume的方式自动挂载Kubernetes的默认ServiceAccount。所以，这个控制器就会直接使用默认ServiceAccount数据卷里的授权信息，来访问APIServer。</p><p><strong>第二步</strong>：main函数为Network对象创建一个叫作InformerFactory（即：networkInformerFactory）的工厂，并使用它生成一个Network对象的Informer，传递给控制器。</p><p><strong>第三步</strong>：main函数启动上述的Informer，然后执行controller.Run，启动自定义控制器。</p><p>至此，main函数就结束了。</p><p>看到这，你可能会感到非常困惑：编写自定义控制器的过程难道就这么简单吗？这个Informer又是个什么东西呢？</p><p>别着急。</p><p>接下来，我就为你<strong>详细解释一下这个自定义控制器的工作原理。</strong></p><p>在Kubernetes项目中，一个自定义控制器的工作原理，可以用下面这样一幅流程图来表示（在后面的叙述中，我会用“示意图”来指代它）：</p><p><img src=\"https://static001.geekbang.org/resource/image/32/c3/32e545dcd4664a3f36e95af83b571ec3.png?wh=1846*822\" alt=\"\"></p><center><span class=\"reference\">图1 自定义控制器的工作流程示意图</span></center><p>我们先从这幅示意图的最左边看起。</p><p><strong>这个控制器要做的第一件事，是从Kubernetes的APIServer里获取它所关心的对象，也就是我定义的Network对象</strong>。</p><p>这个操作，依靠的是一个叫作Informer（可以翻译为：通知器）的代码库完成的。Informer与API对象是一一对应的，所以我传递给自定义控制器的，正是一个Network对象的Informer（Network Informer）。</p><p>不知你是否已经注意到，我在创建这个Informer工厂的时候，需要给它传递一个networkClient。</p><p>事实上，Network Informer正是使用这个networkClient，跟APIServer建立了连接。不过，真正负责维护这个连接的，则是Informer所使用的Reflector包。</p><p>更具体地说，Reflector使用的是一种叫作<strong>ListAndWatch</strong>的方法，来“获取”并“监听”这些Network对象实例的变化。</p><p>在ListAndWatch机制下，一旦APIServer端有新的Network实例被创建、删除或者更新，Reflector都会收到“事件通知”。这时，该事件及它对应的API对象这个组合，就被称为增量（Delta），它会被放进一个Delta FIFO Queue（即：增量先进先出队列）中。</p><p>而另一方面，Informe会不断地从这个Delta FIFO Queue里读取（Pop）增量。每拿到一个增量，Informer就会判断这个增量里的事件类型，然后创建或者更新本地对象的缓存。这个缓存，在Kubernetes里一般被叫作Store。</p><p>比如，如果事件类型是Added（添加对象），那么Informer就会通过一个叫作Indexer的库把这个增量里的API对象保存在本地缓存中，并为它创建索引。相反，如果增量的事件类型是Deleted（删除对象），那么Informer就会从本地缓存中删除这个对象。</p><p>这个<strong>同步本地缓存的工作，是Informer的第一个职责，也是它最重要的职责。</strong></p><p>而<strong>Informer的第二个职责，则是根据这些事件的类型，触发事先注册好的ResourceEventHandler</strong>。这些Handler，需要在创建控制器的时候注册给它对应的Informer。</p><p>接下来，我们就来<span class=\"orange\">编写这个控制器的定义</span>，它的主要内容如下所示：</p><pre><code>func NewController(\n  kubeclientset kubernetes.Interface,\n  networkclientset clientset.Interface,\n  networkInformer informers.NetworkInformer) *Controller {\n  ...\n  controller := &amp;Controller{\n    kubeclientset:    kubeclientset,\n    networkclientset: networkclientset,\n    networksLister:   networkInformer.Lister(),\n    networksSynced:   networkInformer.Informer().HasSynced,\n    workqueue:        workqueue.NewNamedRateLimitingQueue(...,  &quot;Networks&quot;),\n    ...\n  }\n    networkInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{\n    AddFunc: controller.enqueueNetwork,\n    UpdateFunc: func(old, new interface{}) {\n      oldNetwork := old.(*samplecrdv1.Network)\n      newNetwork := new.(*samplecrdv1.Network)\n      if oldNetwork.ResourceVersion == newNetwork.ResourceVersion {\n        return\n      }\n      controller.enqueueNetwork(new)\n    },\n    DeleteFunc: controller.enqueueNetworkForDelete,\n return controller\n}\n</code></pre><p><strong>我前面在main函数里创建了两个client（kubeclientset和networkclientset），然后在这段代码里，使用这两个client和前面创建的Informer，初始化了自定义控制器。</strong></p><p>值得注意的是，在这个自定义控制器里，我还设置了一个工作队列（work queue），它正是处于示意图中间位置的WorkQueue。这个工作队列的作用是，负责同步Informer和控制循环之间的数据。</p><blockquote>\n<p>实际上，Kubernetes项目为我们提供了很多个工作队列的实现，你可以根据需要选择合适的库直接使用。</p>\n</blockquote><p><strong>然后，我为networkInformer注册了三个Handler（AddFunc、UpdateFunc和DeleteFunc），分别对应API对象的“添加”“更新”和“删除”事件。而具体的处理操作，都是将该事件对应的API对象加入到工作队列中。</strong></p><p>需要注意的是，实际入队的并不是API对象本身，而是它们的Key，即：该API对象的<code>&lt;namespace&gt;/&lt;name&gt;</code>。</p><p>而我们后面即将编写的控制循环，则会不断地从这个工作队列里拿到这些Key，然后开始执行真正的控制逻辑。</p><p>综合上面的讲述，你现在应该就能明白，<strong>所谓Informer，其实就是一个带有本地缓存和索引机制的、可以注册EventHandler的client</strong>。它是自定义控制器跟APIServer进行数据同步的重要组件。</p><p>更具体地说，Informer通过一种叫作ListAndWatch的方法，把APIServer中的API对象缓存在了本地，并负责更新和维护这个缓存。</p><p>其中，ListAndWatch方法的含义是：首先，通过APIServer的LIST API“获取”所有最新版本的API对象；然后，再通过WATCH API来“监听”所有这些API对象的变化。</p><p>而通过监听到的事件变化，Informer就可以实时地更新本地缓存，并且调用这些事件对应的EventHandler了。</p><p>此外，在这个过程中，每经过resyncPeriod指定的时间，Informer维护的本地缓存，都会使用最近一次LIST返回的结果强制更新一次，从而保证缓存的有效性。在Kubernetes中，这个缓存强制更新的操作就叫作：resync。</p><p>需要注意的是，这个定时resync操作，也会触发Informer注册的“更新”事件。但此时，这个“更新”事件对应的Network对象实际上并没有发生变化，即：新、旧两个Network对象的ResourceVersion是一样的。在这种情况下，Informer就不需要对这个更新事件再做进一步的处理了。</p><p>这也是为什么我在上面的UpdateFunc方法里，先判断了一下新、旧两个Network对象的版本（ResourceVersion）是否发生了变化，然后才开始进行的入队操作。</p><p>以上，就是Kubernetes中的Informer库的工作原理了。</p><p>接下来，我们就来到了示意图中最后面的控制循环（Control Loop）部分，也正是我在main函数最后调用controller.Run()启动的“控制循环”。它的主要内容如下所示：</p><pre><code>func (c *Controller) Run(threadiness int, stopCh &lt;-chan struct{}) error {\n ...\n  if ok := cache.WaitForCacheSync(stopCh, c.networksSynced); !ok {\n    return fmt.Errorf(&quot;failed to wait for caches to sync&quot;)\n  }\n  \n  ...\n  for i := 0; i &lt; threadiness; i++ {\n    go wait.Until(c.runWorker, time.Second, stopCh)\n  }\n  \n  ...\n  return nil\n}\n</code></pre><p>可以看到，启动控制循环的逻辑非常简单：</p><ul>\n<li>首先，等待Informer完成一次本地缓存的数据同步操作；</li>\n<li>然后，直接通过goroutine启动一个（或者并发启动多个）“无限循环”的任务。</li>\n</ul><p>而这个“无限循环”任务的每一个循环周期，执行的正是我们真正关心的业务逻辑。</p><p>所以接下来，我们就来<span class=\"orange\">编写这个自定义控制器的业务逻辑</span>，它的主要内容如下所示：</p><pre><code>func (c *Controller) runWorker() {\n  for c.processNextWorkItem() {\n  }\n}\n\nfunc (c *Controller) processNextWorkItem() bool {\n  obj, shutdown := c.workqueue.Get()\n  \n  ...\n  \n  err := func(obj interface{}) error {\n    ...\n    if err := c.syncHandler(key); err != nil {\n     return fmt.Errorf(&quot;error syncing '%s': %s&quot;, key, err.Error())\n    }\n    \n    c.workqueue.Forget(obj)\n    ...\n    return nil\n  }(obj)\n  \n  ...\n  \n  return true\n}\n\nfunc (c *Controller) syncHandler(key string) error {\n\n  namespace, name, err := cache.SplitMetaNamespaceKey(key)\n  ...\n  \n  network, err := c.networksLister.Networks(namespace).Get(name)\n  if err != nil {\n    if errors.IsNotFound(err) {\n      glog.Warningf(&quot;Network does not exist in local cache: %s/%s, will delete it from Neutron ...&quot;,\n      namespace, name)\n      \n      glog.Warningf(&quot;Network: %s/%s does not exist in local cache, will delete it from Neutron ...&quot;,\n    namespace, name)\n    \n     // FIX ME: call Neutron API to delete this network by name.\n     //\n     // neutron.Delete(namespace, name)\n     \n     return nil\n  }\n    ...\n    \n    return err\n  }\n  \n  glog.Infof(&quot;[Neutron] Try to process network: %#v ...&quot;, network)\n  \n  // FIX ME: Do diff().\n  //\n  // actualNetwork, exists := neutron.Get(namespace, name)\n  //\n  // if !exists {\n  //   neutron.Create(namespace, name)\n  // } else if !reflect.DeepEqual(actualNetwork, network) {\n  //   neutron.Update(namespace, name)\n  // }\n  \n  return nil\n}\n</code></pre><p>可以看到，在这个执行周期里（processNextWorkItem），我们<strong>首先</strong>从工作队列里出队（workqueue.Get）了一个成员，也就是一个Key（Network对象的：namespace/name）。</p><p><strong>然后</strong>，在syncHandler方法中，我使用这个Key，尝试从Informer维护的缓存中拿到了它所对应的Network对象。</p><p>可以看到，在这里，我使用了networksLister来尝试获取这个Key对应的Network对象。这个操作，其实就是在访问本地缓存的索引。实际上，在Kubernetes的源码中，你会经常看到控制器从各种Lister里获取对象，比如：podLister、nodeLister等等，它们使用的都是Informer和缓存机制。</p><p>而如果控制循环从缓存中拿不到这个对象（即：networkLister返回了IsNotFound错误），那就意味着这个Network对象的Key是通过前面的“删除”事件添加进工作队列的。所以，尽管队列里有这个Key，但是对应的Network对象已经被删除了。</p><p>这时候，我就需要调用Neutron的API，把这个Key对应的Neutron网络从真实的集群里删除掉。</p><p><strong>而如果能够获取到对应的Network对象，我就可以执行控制器模式里的对比“期望状态”和“实际状态”的逻辑了。</strong></p><p>其中，自定义控制器“千辛万苦”拿到的这个Network对象，<strong>正是APIServer里保存的“期望状态”</strong>，即：用户通过YAML文件提交到APIServer里的信息。当然，在我们的例子里，它已经被Informer缓存在了本地。</p><p><strong>那么，“实际状态”又从哪里来呢？</strong></p><p>当然是来自于实际的集群了。</p><p>所以，我们的控制循环需要通过Neutron API来查询实际的网络情况。</p><p>比如，我可以先通过Neutron来查询这个Network对象对应的真实网络是否存在。</p><ul>\n<li>如果不存在，这就是一个典型的“期望状态”与“实际状态”不一致的情形。这时，我就需要使用这个Network对象里的信息（比如：CIDR和Gateway），调用Neutron API来创建真实的网络。</li>\n<li>如果存在，那么，我就要读取这个真实网络的信息，判断它是否跟Network对象里的信息一致，从而决定我是否要通过Neutron来更新这个已经存在的真实网络。</li>\n</ul><p>这样，我就通过对比“期望状态”和“实际状态”的差异，完成了一次调协（Reconcile）的过程。</p><p>至此，一个完整的自定义API对象和它所对应的自定义控制器，就编写完毕了。</p><blockquote>\n<p>备注：与Neutron相关的业务代码并不是本篇文章的重点，所以我仅仅通过注释里的伪代码为你表述了这部分内容。如果你对这些代码感兴趣的话，可以自行完成。最简单的情况，你可以自己编写一个Neutron Mock，然后输出对应的操作日志。</p>\n</blockquote><p>接下来，<span class=\"orange\">我们就一起来把这个项目运行起来，查看一下它的工作情况。</span></p><p>你可以自己编译这个项目，也可以直接使用我编译好的二进制文件（samplecrd-controller）。编译并启动这个项目的具体流程如下所示：</p><pre><code># Clone repo\n$ git clone https://github.com/resouer/k8s-controller-custom-resource$ cd k8s-controller-custom-resource\n\n### Skip this part if you don't want to build\n# Install dependency\n$ go get github.com/tools/godep\n$ godep restore\n# Build\n$ go build -o samplecrd-controller .\n\n$ ./samplecrd-controller -kubeconfig=$HOME/.kube/config -alsologtostderr=true\nI0915 12:50:29.051349   27159 controller.go:84] Setting up event handlers\nI0915 12:50:29.051615   27159 controller.go:113] Starting Network control loop\nI0915 12:50:29.051630   27159 controller.go:116] Waiting for informer caches to sync\nE0915 12:50:29.066745   27159 reflector.go:134] github.com/resouer/k8s-controller-custom-resource/pkg/client/informers/externalversions/factory.go:117: Failed to list *v1.Network: the server could not find the requested resource (get networks.samplecrd.k8s.io)\n...\n</code></pre><p>你可以看到，自定义控制器被启动后，一开始会报错。</p><p>这是因为，此时Network对象的CRD还没有被创建出来，所以Informer去APIServer里“获取”（List）Network对象时，并不能找到Network这个API资源类型的定义，即：</p><pre><code>Failed to list *v1.Network: the server could not find the requested resource (get networks.samplecrd.k8s.io)\n</code></pre><p>所以，接下来我就需要创建Network对象的CRD，这个操作在上一篇文章里已经介绍过了。</p><p>在另一个shell窗口里执行：</p><pre><code>$ kubectl apply -f crd/network.yaml\n</code></pre><p>这时候，你就会看到控制器的日志恢复了正常，控制循环启动成功：</p><pre><code>...\nI0915 12:50:29.051630   27159 controller.go:116] Waiting for informer caches to sync\n...\nI0915 12:52:54.346854   25245 controller.go:121] Starting workers\nI0915 12:52:54.346914   25245 controller.go:127] Started workers\n</code></pre><p>接下来，我就可以进行Network对象的增删改查操作了。</p><p>首先，创建一个Network对象：</p><pre><code>$ cat example/example-network.yaml \napiVersion: samplecrd.k8s.io/v1\nkind: Network\nmetadata:\n  name: example-network\nspec:\n  cidr: &quot;192.168.0.0/16&quot;\n  gateway: &quot;192.168.0.1&quot;\n  \n$ kubectl apply -f example/example-network.yaml \nnetwork.samplecrd.k8s.io/example-network created\n</code></pre><p>这时候，查看一下控制器的输出：</p><pre><code>...\nI0915 12:50:29.051349   27159 controller.go:84] Setting up event handlers\nI0915 12:50:29.051615   27159 controller.go:113] Starting Network control loop\nI0915 12:50:29.051630   27159 controller.go:116] Waiting for informer caches to sync\n...\nI0915 12:52:54.346854   25245 controller.go:121] Starting workers\nI0915 12:52:54.346914   25245 controller.go:127] Started workers\nI0915 12:53:18.064409   25245 controller.go:229] [Neutron] Try to process network: &amp;v1.Network{TypeMeta:v1.TypeMeta{Kind:&quot;&quot;, APIVersion:&quot;&quot;}, ObjectMeta:v1.ObjectMeta{Name:&quot;example-network&quot;, GenerateName:&quot;&quot;, Namespace:&quot;default&quot;, ... ResourceVersion:&quot;479015&quot;, ... Spec:v1.NetworkSpec{Cidr:&quot;192.168.0.0/16&quot;, Gateway:&quot;192.168.0.1&quot;}} ...\nI0915 12:53:18.064650   25245 controller.go:183] Successfully synced 'default/example-network'\n...\n</code></pre><p>可以看到，我们上面创建example-network的操作，触发了EventHandler的“添加”事件，从而被放进了工作队列。</p><p>紧接着，控制循环就从队列里拿到了这个对象，并且打印出了正在“处理”这个Network对象的日志。</p><p>可以看到，这个Network的ResourceVersion，也就是API对象的版本号，是479015，而它的Spec字段的内容，跟我提交的YAML文件一摸一样，比如，它的CIDR网段是：192.168.0.0/16。</p><p>这时候，我来修改一下这个YAML文件的内容，如下所示：</p><pre><code>$ cat example/example-network.yaml \napiVersion: samplecrd.k8s.io/v1\nkind: Network\nmetadata:\n  name: example-network\nspec:\n  cidr: &quot;192.168.1.0/16&quot;\n  gateway: &quot;192.168.1.1&quot;\n</code></pre><p>可以看到，我把这个YAML文件里的CIDR和Gateway字段修改成了192.168.1.0/16网段。</p><p>然后，我们执行了kubectl apply命令来提交这次更新，如下所示：</p><pre><code>$ kubectl apply -f example/example-network.yaml \nnetwork.samplecrd.k8s.io/example-network configured\n</code></pre><p>这时候，我们就可以观察一下控制器的输出：</p><pre><code>...\nI0915 12:53:51.126029   25245 controller.go:229] [Neutron] Try to process network: &amp;v1.Network{TypeMeta:v1.TypeMeta{Kind:&quot;&quot;, APIVersion:&quot;&quot;}, ObjectMeta:v1.ObjectMeta{Name:&quot;example-network&quot;, GenerateName:&quot;&quot;, Namespace:&quot;default&quot;, ...  ResourceVersion:&quot;479062&quot;, ... Spec:v1.NetworkSpec{Cidr:&quot;192.168.1.0/16&quot;, Gateway:&quot;192.168.1.1&quot;}} ...\nI0915 12:53:51.126348   25245 controller.go:183] Successfully synced 'default/example-network'\n</code></pre><p>可以看到，这一次，Informer注册的“更新”事件被触发，更新后的Network对象的Key被添加到了工作队列之中。</p><p>所以，接下来控制循环从工作队列里拿到的Network对象，与前一个对象是不同的：它的ResourceVersion的值变成了479062；而Spec里的字段，则变成了192.168.1.0/16网段。</p><p>最后，我再把这个对象删除掉：</p><pre><code>$ kubectl delete -f example/example-network.yaml\n</code></pre><p>这一次，在控制器的输出里，我们就可以看到，Informer注册的“删除”事件被触发，并且控制循环“调用”Neutron API“删除”了真实环境里的网络。这个输出如下所示：</p><pre><code>W0915 12:54:09.738464   25245 controller.go:212] Network: default/example-network does not exist in local cache, will delete it from Neutron ...\nI0915 12:54:09.738832   25245 controller.go:215] [Neutron] Deleting network: default/example-network ...\nI0915 12:54:09.738854   25245 controller.go:183] Successfully synced 'default/example-network'\n</code></pre><p>以上，就是编写和使用自定义控制器的全部流程了。</p><p>实际上，<span class=\"orange\">这套流程不仅可以用在自定义API资源上，也完全可以用在Kubernetes原生的默认API对象上。</span></p><p>比如，我们在main函数里，除了创建一个Network Informer外，还可以初始化一个Kubernetes默认API对象的Informer工厂，比如Deployment对象的Informer。这个具体做法如下所示：</p><pre><code>func main() {\n  ...\n  \n  kubeInformerFactory := kubeinformers.NewSharedInformerFactory(kubeClient, time.Second*30)\n  \n  controller := NewController(kubeClient, exampleClient,\n  kubeInformerFactory.Apps().V1().Deployments(),\n  networkInformerFactory.Samplecrd().V1().Networks())\n  \n  go kubeInformerFactory.Start(stopCh)\n  ...\n}\n</code></pre><p>在这段代码中，我们<strong>首先</strong>使用Kubernetes的client（kubeClient）创建了一个工厂；</p><p><strong>然后</strong>，我用跟Network类似的处理方法，生成了一个Deployment Informer；</p><p><strong>接着</strong>，我把Deployment Informer传递给了自定义控制器；当然，我也要调用Start方法来启动这个Deployment Informer。</p><p>而有了这个Deployment Informer后，这个控制器也就持有了所有Deployment对象的信息。接下来，它既可以通过deploymentInformer.Lister()来获取Etcd里的所有Deployment对象，也可以为这个Deployment Informer注册具体的Handler来。</p><p>更重要的是，<strong>这就使得在这个自定义控制器里面，我可以通过对自定义API对象和默认API对象进行协同，从而实现更加复杂的编排功能</strong>。</p><p>比如：用户每创建一个新的Deployment，这个自定义控制器，就可以为它创建一个对应的Network供它使用。</p><p>这些对Kubernetes API编程范式的更高级应用，我就留给你在实际的场景中去探索和实践了。</p><h2>总结</h2><p>在今天这篇文章中，我为你剖析了Kubernetes API编程范式的具体原理，并编写了一个自定义控制器。</p><p>这其中，有如下几个概念和机制，是你一定要理解清楚的：</p><p>所谓的Informer，就是一个自带缓存和索引机制，可以触发Handler的客户端库。这个本地缓存在Kubernetes中一般被称为Store，索引一般被称为Index。</p><p>Informer使用了Reflector包，它是一个可以通过ListAndWatch机制获取并监视API对象变化的客户端封装。</p><p>Reflector和Informer之间，用到了一个“增量先进先出队列”进行协同。而Informer与你要编写的控制循环之间，则使用了一个工作队列来进行协同。</p><p>在实际应用中，除了控制循环之外的所有代码，实际上都是Kubernetes为你自动生成的，即：pkg/client/{informers, listers, clientset}里的内容。</p><p>而这些自动生成的代码，就为我们提供了一个可靠而高效地获取API对象“期望状态”的编程库。</p><p>所以，接下来，作为开发者，你就只需要关注如何拿到“实际状态”，然后如何拿它去跟“期望状态”做对比，从而决定接下来要做的业务逻辑即可。</p><p>以上内容，就是Kubernetes API编程范式的核心思想。</p><h2>思考题</h2><p>请思考一下，为什么Informer和你编写的控制循环之间，一定要使用一个工作队列来进行协作呢？</p><p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p>","neighbors":{"left":{"article_title":"24 | 深入解析声明式API（一）：API对象的奥秘","id":41876},"right":{"article_title":"26 | 基于角色的权限控制：RBAC","id":42154}},"comments":[{"had_liked":false,"id":33876,"user_name":"mgxian","can_delete":false,"product_type":"c1","uid":1014806,"ip_address":"","ucode":"7B7E77E6A83B87","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/16/4d1e5cc1.jpg","comment_is_top":false,"comment_ctime":1539913835,"is_pvip":false,"replies":[{"id":"12139","content":"是的","user_name":"作者回复","comment_id":33876,"uid":"1218095","ip_address":"","utype":1,"ctime":1539924124,"user_name_real":"Geek_6ef93d"}],"discussion_count":3,"race_medal":0,"score":"388086970475","product_id":100015201,"comment_content":"Informer 和控制循环分开是为了解耦，防止控制循环执行过慢把Informer 拖死","like_count":91,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427066,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539924124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740409,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/79/f9d5dd3a.jpg","nickname":"吕超","note":"","ucode":"B36883984BE16B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354363,"discussion_content":"只要是队列，那就是解耦+削峰","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615280157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1793475,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5d/c3/69019d24.jpg","nickname":"江东","note":"","ucode":"391A62BC7039B3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560567,"discussion_content":"控制器使用死循环实现的，队列这里是不是在数据为空的情况下会阻塞控制器进程，从而避免cpu100%","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649392990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36219,"user_name":"142","can_delete":false,"product_type":"c1","uid":1149480,"ip_address":"","ucode":"A5D7C484E3503C","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/28/45cf7f34.jpg","comment_is_top":false,"comment_ctime":1540983710,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"323663530910","product_id":100015201,"comment_content":"运维人员看起来越来越费力了😢","like_count":75,"discussions":[{"author":{"id":1444321,"avatar":"https://static001.geekbang.org/account/avatar/00/16/09/e1/100a0526.jpg","nickname":"kakj","note":"","ucode":"9F052B64B9A4FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1614,"discussion_content":"java开发人员也越来越费力了","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1562732529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1799687,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/76/07/db4ef4a8.jpg","nickname":"曹娟儿","note":"","ucode":"9969F9DB46E5E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292980,"discussion_content":"懵圈ing","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1595402454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000884,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/45/b4/afa76165.jpg","nickname":"华子91","note":"","ucode":"68E792FB90CDDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16485,"discussion_content":"完全懵逼了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1568896309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048441,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/79/f400c4d1.jpg","nickname":"douge","note":"","ucode":"A6EB1AA3D53516","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369395,"discussion_content":"其实思想不难，就是对 API 对象的增删查改 CRUD 的处理，来了一个请求 merge 得到最新状态，这个状态是用户期望的，再和实际状态对比，不一致就作相应处理。对用户来说无非是声明我要达到什么状态，控制器来实现；而以前命令式操作的话，无非是把控制器实现逻辑一步步敲成命令执行而已。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1619017126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1275407,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","nickname":"豆豆","note":"","ucode":"97788B134C3212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552378,"discussion_content":"之前死磕这一块，啃不下去。跳槽后，同事跟我说，直接上kubebuilder，我不想，我就想搞懂，回过头来，一行一行的看这几节关于operator的开发章节，就想搞清楚内部原理，终于看懂了，终于搞明白了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1645438507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2663721,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8sYHCPqtn0TRP72qup5YicYAvTDNP7b8cuykCR0o5Yb6ViaQJFKShJbMsWahVk4sQdwDU2UQf6NiaA/132","nickname":"akai","note":"","ucode":"8D4AA48A86B71C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1275407,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","nickname":"豆豆","note":"","ucode":"97788B134C3212","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577045,"discussion_content":"羡慕老哥，只有大厂才需要自己开发CRD和Operator吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655899673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":552378,"ip_address":""},"score":577045,"extra":""}]},{"author":{"id":1648999,"avatar":"https://static001.geekbang.org/account/avatar/00/19/29/67/fc61a741.jpg","nickname":"田小麦","note":"","ucode":"4C10997F6173ED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589685,"discussion_content":"难嘛，可以理解为观察者模式的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665237067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2068141,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq5tIy8LaGwcm0gSibjaEvKIgkk5AoOfBGwgZMfZpm9Scyia3b1sEoQhOsWTynCt6Vt2YC5tXe7hFMA/132","nickname":"Hiram","note":"","ucode":"197F4B7F45E8EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408823,"discussion_content":"一脸懵圈…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635327532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1259323,"avatar":"https://static001.geekbang.org/account/avatar/00/13/37/3b/495e2ce6.jpg","nickname":"陈斯佳","note":"","ucode":"C236F874FC767A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403821,"discussion_content":"一脸懵圈…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634170104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219746,"user_name":"Tarjintor","can_delete":false,"product_type":"c1","uid":1519558,"ip_address":"","ucode":"AC5DD78B2EB962","user_header":"https://static001.geekbang.org/account/avatar/00/17/2f/c6/b7448158.jpg","comment_is_top":false,"comment_ctime":1590073527,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"254993143991","product_id":100015201,"comment_content":"不知道现在还有人看回复没，我用了不少operator，重度使用rook&#47;ceph<br>感觉声明式api还是有一些本质不足的地方，主要是<br>1.通常operator都是用来描述复杂有状态集群的，这个集群本身就已经很复杂了<br>2.声明式api通过diff的方式来得出集群要做怎么样的状态变迁，这个过程中，常常会有很多状况不能覆盖到，而如果使用者对此没有深刻的认识，就会越用越糊涂<br>大致来说，如果一个集群本身的状态有n种，那么operator理论上就要覆盖n*(n-1)种变迁的可能性，而这个体力活几乎是不可能完成的，所有很多operator经常性的不支持某些操作，而不是像使用者想象的那样，我改改yaml，apply一下就完事了<br>更重要的是，由于情况太多太复杂，甚至无法通过文档的方式，告诉使用者，状态1的集群，按某种方式修改了yaml之后，是不能变成使用者期待的状态2的<br><br>如果是传统的命令式方式，那么就是所有可能有的功能，都会罗列出来，可能n个状态，只有2n+3个操作是合法的，剩下都是做不到的，这样使用者固然受到了限制，但这种限制也让很多时候的操作变得更加清晰明了,而不是每次改yaml还要思考一下，这么改，operator支持吗？<br><br>当然，声明式api的好处也是明显的，如果这个diff是operator覆盖到的，那么就能极大的减轻使用者的负担，apply下就解脱了<br><br>而这个集群状态变迁的问题是本质复杂的，必然没有可以消除复杂度的解法，无非就是这个复杂度在operator的实现者那里，还是在运维者那里，在operator的实现者那里，好处就是固化的常用的变迁路径，使用起来很方便，但如果operator的开发者没有实现某个状态的变迁路径，而这个本身是可以做到的，这个时候，就比不上命令式灵活，个人感觉就是取舍了","like_count":60,"discussions":[{"author":{"id":1048441,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/79/f400c4d1.jpg","nickname":"douge","note":"","ucode":"A6EB1AA3D53516","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293565,"discussion_content":"一个复杂的问题和用命令式语言还是函数式语言实现无关，但是不同的语言表达能力和抽象程度是不一样的，个人觉得声明式 api 用统一的框架描述了状态变更，抽象程度更高，对使用者更加友好。你说的状态爆炸问题，我觉得更多的是怎么设计 operator 的问题，比如是否可以将 n 个状态拆分，把无依赖关系的状态独立出来，这样编写和维护更加方便，用户理解状态该如何变更也更加清晰。至于你说的文档问题，只要保证状态变迁基本符合大家约定的基本规则即可，特殊情况特殊注明。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1595582644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1380758,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","nickname":"Helios","note":"","ucode":"BE6B98EE8F0D09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292899,"discussion_content":"有状态应用的复杂度无论通过什么样的方式部署的都是一样的，operator的目标是通过一个yaml文件让这个有状态应用部署在集群中。\n“.声明式api通过diff的方式来得出集群要做怎么样的状态变迁”对于这一点，k8s只是关心目标状态，apply的时候是类似于git diff的时候去patch。\n\n\n“大致来说，如果一个集群本身的状态有n种，那么operator理论上就要覆盖n*(n-1)种变迁的可能性，而这个体力活几乎是不可能完成的，所有很多operator经常性的不支持某些操作，而不是像使用者想象的那样，我改改yaml，apply一下就完事了\n更重要的是，由于情况太多太复杂，甚至无法通过文档的方式，告诉使用者，状态1的集群，按某种方式修改了yaml之后，是不能变成使用者期待的状态2的\n\n如果是传统的命令式方式，那么就是所有可能有的功能，都会罗列出来，可能n个状态，只有2n+3个操作是合法的，剩下都是做不到的，这样使用者固然受到了限制，但这种限制也让很多时候的操作变得更加清晰明了,而不是每次改yaml还要思考一下，这么改，operator支持吗？”\n您这个说的比较抽象，能举个具体的例子么。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595381170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2057451,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/64/eb/732e9707.jpg","nickname":"青苹果","note":"","ucode":"D85EE1743F9CC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381509,"discussion_content":"说出了我的心声……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625106948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073261,"avatar":"https://static001.geekbang.org/account/avatar/00/10/60/6d/3c2a5143.jpg","nickname":"二进制傻瓜","note":"","ucode":"FA8E76339CF512","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580583,"discussion_content":"前端开发也是从命令式慢慢转到声明式，声明式使用门槛比较低","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658279603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308473,"discussion_content":"对小白来说声明式API还是很友好的，比如我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600959163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33946,"user_name":"Joe Black","can_delete":false,"product_type":"c1","uid":1052528,"ip_address":"","ucode":"21FE222A286445","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/70/c8680841.jpg","comment_is_top":false,"comment_ctime":1539924878,"is_pvip":false,"replies":[{"id":"12148","content":"说对了。所以说把kubernetes跟swarm mesos各种paas等横向比较没啥实际意义","user_name":"作者回复","comment_id":33946,"uid":"1218095","ip_address":"","utype":1,"ctime":1539935005,"user_name_real":"Geek_6ef93d"}],"discussion_count":2,"race_medal":0,"score":"181928551310","product_id":100015201,"comment_content":"看了这两天的文章，感觉k8s的机制实在是太具有普适性了，可以基于它构建各种分布式业务平台。本质上它就是一个分布式对象管理平台。","like_count":42,"discussions":[{"author":{"id":1837179,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/08/7b/7f086546.jpg","nickname":"Alex","note":"","ucode":"70806CEA9AB15E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584366,"discussion_content":"说的太对了我也有这种赶脚，k8s给人的感觉就是一个分布式对象管理平台，容器化部署","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1660789813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427080,"discussion_content":"说对了。所以说把kubernetes跟swarm mesos各种paas等横向比较没啥实际意义","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1539935005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37565,"user_name":"超","can_delete":false,"product_type":"c1","uid":1019528,"ip_address":"","ucode":"84165555837698","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/88/8cbf2527.jpg","comment_is_top":false,"comment_ctime":1541641651,"is_pvip":false,"replies":[{"id":"13576","content":"所以说kubernetes 当前规模是5000","user_name":"作者回复","comment_id":37565,"uid":"1218095","ip_address":"","utype":1,"ctime":1541719375,"user_name_real":"Geek_6ef93d"}],"discussion_count":3,"race_medal":0,"score":"117505758643","product_id":100015201,"comment_content":"如果一个master 管理的node非常多 通过ListAndWatch 会对master的性能有影响吧","like_count":27,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428403,"discussion_content":"所以说kubernetes 当前规模是5000","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1541719375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308474,"discussion_content":"原来master有这么多工作要做，我还以为它就是像Nginx一样，转发一下请求，看看哪个挂了，重启一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600959255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113864,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/08/7c18d8a4.jpg","nickname":"团","note":"","ucode":"D56ABBCE4E4D90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534533,"discussion_content":"Mark.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638203197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50143,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1544878285,"is_pvip":false,"replies":[{"id":"18030","content":"对的","user_name":"作者回复","comment_id":50143,"uid":"1218095","ip_address":"","utype":1,"ctime":1544904175,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"74559322317","product_id":100015201,"comment_content":"一般这种工作队列结构主要是为了匹配双方速度不一致，也为了decouple双方。比如典型生产者消费者问题","like_count":17,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432889,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544904175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72432,"user_name":"哈哼","can_delete":false,"product_type":"c1","uid":1417824,"ip_address":"","ucode":"C1108406573D49","user_header":"https://static001.geekbang.org/account/avatar/00/15/a2/60/f3939ab4.jpg","comment_is_top":false,"comment_ctime":1551623854,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"44501296814","product_id":100015201,"comment_content":"自定义的controler这么手动跑着，挂了咋办？，是不是应该准备好镜像，用Deployment跑起来？","like_count":11,"discussions":[{"author":{"id":1198816,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4a/e0/eff34583.jpg","nickname":"马超","note":"","ucode":"FAFF55DC5DD15C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200056,"discussion_content":"对的，和deployment一样交给k8s管理生命周期","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583653266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1513000,"avatar":"https://static001.geekbang.org/account/avatar/00/17/16/28/41aed84a.jpg","nickname":"Zwj","note":"","ucode":"6F1A01F27BEC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587826,"discussion_content":"无线套娃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663310484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1076347,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM5suA7q5mM40ULTY5OlQpoerPRMQD8NcMbKxDHhNmjQNUCngkSJEzRvMVDibAHw2whGZxAFlibzribOA/132","nickname":"jxlwqq","note":"","ucode":"94AEEEEB55C6AA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395419,"discussion_content":"operator-sdk 和 olm 的作用就体现出来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632303042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702153,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f9/09/57877ee6.jpg","nickname":"L、t t t","note":"","ucode":"68D62F4BA6088B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380316,"discussion_content":"对象管理对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624435491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218501,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","nickname":"罗峰","note":"","ucode":"5F3D6AF8F28322","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374629,"discussion_content":"所以一种资源类型处理对应的事件，可以嵌套使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621296375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1354151,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a9/a7/de3ee890.jpg","nickname":"拉我吃","note":"","ucode":"8BC9C44FE00097","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1218501,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","nickname":"罗峰","note":"","ucode":"5F3D6AF8F28322","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378532,"discussion_content":"这个解释没有看懂，能麻烦详细说说吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623279037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":374629,"ip_address":""},"score":378532,"extra":""}]}]},{"had_liked":false,"id":33959,"user_name":"gogo","can_delete":false,"product_type":"c1","uid":1003104,"ip_address":"","ucode":"E8F0F3B000020A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","comment_is_top":false,"comment_ctime":1539930112,"is_pvip":false,"replies":[{"id":"12147","content":"要用滚动更新就不要用latest tag，否则你准备怎么知道当前在用的是哪个版本的镜像？","user_name":"作者回复","comment_id":33959,"uid":"1218095","ip_address":"","utype":1,"ctime":1539934921,"user_name_real":"Geek_6ef93d"}],"discussion_count":2,"race_medal":0,"score":"44489603072","product_id":100015201,"comment_content":"请问老师，如果用deployment部署一个tag是latest的镜像，怎样进行滚动更新呢？set image的话tag不变，不能出发更新呢","like_count":10,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427087,"discussion_content":"要用滚动更新就不要用latest tag，否则你准备怎么知道当前在用的是哪个版本的镜像？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1539934921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2086973,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d8/3d/8a44993f.jpg","nickname":"OldFox","note":"","ucode":"6195262F3A9AA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380390,"discussion_content":"非要搞的话，不用set image，patch点别的信息，镜像拉取策略为always。但是还是推荐别用tag latest。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624463638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252042,"user_name":"ch_ort","can_delete":false,"product_type":"c1","uid":1580926,"ip_address":"","ucode":"B79746E687F29E","user_header":"","comment_is_top":false,"comment_ctime":1602075553,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40256781217","product_id":100015201,"comment_content":"Kuberentes的API对象由三部分组成，通常可以归结为： &#47;apis&#47;group&#47;version&#47;resource，例如<br><br>    apiVersion: Group&#47;Version<br>    kind: Resource<br><br>APIServer在接收一个请求之后，会按照 &#47;apis&#47;group&#47;version&#47;resource的路径找到对应的Resource类型定义，根据这个类型定义和用户提交的yaml里的字段创建出一个对应的Resource对象<br><br>CRD机制：<br>（1）声明一个CRD，让k8s能够认识和处理所有声明了API是&quot;&#47;apis&#47;group&#47;version&#47;resource&quot;的YAML文件了。包括：组（Group）、版本（Version）、资源类型（Resource）等。<br>（2）编写go代码，让k8s能够识别yaml对象的描述。包括：Spec、Status等<br>（3）使用k8s代码生成工具自动生成clientset、informer和lister<br>（4） 编写一个自定义控制器，来对所关心对象进行相关操作<br><br><br><br>（1）（2）步骤之后，就可以顺利通过kubectl apply xxx.yaml 来创建出对应的CRD和CR了。 但实际上，k8s的etcd中有了这样的对象，却不会进行实际的一些后续操作，因为我们还没有编写对应CRD的控制器。控制器需要：感知所关心对象过的变化，这是通过一个Informer来完成的。而Informer所需要的代码，正是上述（3）步骤生成。<br>","like_count":9,"discussions":[{"author":{"id":1254691,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/23/06a37753.jpg","nickname":"jesse","note":"","ucode":"8A72075A22D973","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368123,"discussion_content":"（1）之后k8s就可以识别你定义的资源了，编写go代码是为了实现控制器，资源增删改变化触发控制器对应回调函数，回调函数通过资源的具体对象描述(spec定义的字段)执行具体的事件操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618574457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266700,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1175329,"ip_address":"","ucode":"603DFFAC6A3755","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/21/69c181b8.jpg","comment_is_top":false,"comment_ctime":1607442858,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27377246634","product_id":100015201,"comment_content":"```此外，在这个过程中，每经过 resyncPeriod 指定的时间，Informer 维护的本地缓存，都会使用最近一次 LIST 返回的结果强制更新一次，从而保证缓存的有效性。在 Kubernetes 中，这个缓存强制更新的操作就叫作：resync。需要注意的是，这个定时 resync 操作，也会触发 Informer 注册的“更新”事件。```<br>老师，这个地方貌似说的有点问题，看代码逻辑，正常情况下，ListAndWatch只会执行一次，即先执行List把数据拉过来，然后更新一次本地缓存，后续就进入Watch阶段，通过监听事件来实时更新本地缓存，而只有在ListAndWatch过程中，因异常退出时，比如apiserver有问题，没法正常ListAndWatch时，才会周期性的尝试进行ListAndWatch，而这个周期也不是resyncPeriod来控制的，而是一个变动的backoff时间，以防止给apiserver造成压力，而真正的resync，其实说的不是周期性更新缓存，而是根据现有的缓存，周期性的触发UpdateFunc，即同步当前状态和目的状态，确保幂等性，这个周期则是由resyncPeriod控制的。所以“每经过resyncPeriod时间，强制更新缓存”，应该是没这个逻辑的吧，还请老师确认下:)<br><br>","like_count":6,"discussions":[{"author":{"id":1207457,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/a1/80d83f0a.jpg","nickname":"Ellison","note":"","ucode":"A2FB94D4F6A332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335168,"discussion_content":"貌似现在确实是， 只是全量更新一次， 后面就是watch and list","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608109640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326471,"user_name":"Casper","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1639536798,"is_pvip":true,"discussion_count":2,"race_medal":5,"score":"23114373278","product_id":100015201,"comment_content":"实际操作环境: k8s v1.22.4, go1.17.4<br>将原始代码clone下来后, 执行 go mod init -&gt; go mod tidy -&gt; go build -o samplecrd-controller .<br><br>运行:<br>.&#47;samplecrd-controller -kubeconfig=$HOME&#47;.kube&#47;config -alsologtostderr=true<br><br>crd 的yaml格式需要修改为:<br>apiVersion: apiextensions.k8s.io&#47;v1<br>kind: CustomResourceDefinition<br>metadata:<br>  name: networks.samplecrd.k8s.io<br>  annotations:<br>    &quot;api-approved.kubernetes.io&quot;: &quot;https:&#47;&#47;github.com&#47;kubernetes&#47;kubernetes&#47;pull&#47;78458&quot;<br>spec:<br>  group: samplecrd.k8s.io<br>  names:<br>    kind: Network<br>    plural: networks<br>    singular: network<br>    shortNames:<br>    - nw<br>  scope: Namespaced<br>  versions:<br>  - served: true<br>    storage: true<br>    name: v1<br>    schema:<br>      openAPIV3Schema:<br>        type: object<br>        properties:<br>          spec:<br>            type: object<br>            properties:<br>              cidr:<br>                type: string<br>              gateway:<br>                type: string<br><br>之后按照文章中的操作即可","like_count":5,"discussions":[{"author":{"id":2291160,"avatar":"https://static001.geekbang.org/account/avatar/00/22/f5/d8/121e4b68.jpg","nickname":"Woa 🤞","note":"","ucode":"6033F496082F3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546361,"discussion_content":"热乎的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642305237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043785,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep1KzIk3KeeFFCDdHDr7vO41FzmY78m4YvbicmGhgiboIOWOt58yJDy5m6Nib1dL12Dicn3NnqynmZpnw/132","nickname":"sweetweapen","note":"","ucode":"B64A55429DEABF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538904,"discussion_content":"妈呀，刚调试通，几分钟后就看见了跟我一模一样的环境和yaml文件\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639554120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125174,"user_name":"Monokai","can_delete":false,"product_type":"c1","uid":1625051,"ip_address":"","ucode":"367B7F2EFB6BA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLtwSXKialWYQgo1OXWYIsyj4zxK8AbQb1tp6iceZ5cGPYFcoczlubd7VicJPuvWqHrFXJXtUTP4kd9A/132","comment_is_top":false,"comment_ctime":1566111468,"is_pvip":false,"replies":[{"id":"46505","content":"需要，所有对etcd的操作都要走apiserver","user_name":"作者回复","comment_id":125174,"uid":"1218095","ip_address":"","utype":1,"ctime":1566350923,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"18745980652","product_id":100015201,"comment_content":"处理完api对象的事件后就直接存储在etcd里了么？需不需要再和apiserver打交道？","like_count":4,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463463,"discussion_content":"需要，所有对etcd的操作都要走apiserver","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566350923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37907,"user_name":"LinYongRui","can_delete":false,"product_type":"c1","uid":1222977,"ip_address":"","ucode":"56FE9D9B277F0F","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/41/9170f607.jpg","comment_is_top":false,"comment_ctime":1541798629,"is_pvip":false,"replies":[{"id":"13661","content":"这个逻辑可以自己在handler里处理一下，我没cover这种情况而已","user_name":"作者回复","comment_id":37907,"uid":"1218095","ip_address":"","utype":1,"ctime":1541841712,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"18721667813","product_id":100015201,"comment_content":"张老师您好，请问如果在这个框架下，有人手动删除了一个实际的neutron network，但是本地缓存和apiserver的状态是一致的，那么在period sync的时候，是不是就不会去真正检查实际状态和本地缓存的差别了呢？因为我看到eventhandler的update那边会直接return了？ 谢谢","like_count":4,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428522,"discussion_content":"这个逻辑可以自己在handler里处理一下，我没cover这种情况而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541841712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190036,"user_name":"Geek_c22199","can_delete":false,"product_type":"c1","uid":1441876,"ip_address":"","ucode":"1CE5B65513E360","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2vn8hyjICTCletGs0omz28lhriaZKX2XX9icYzAEon2IEoRnlXqyOia2bEPP0j7T6xexTnr77JJic8w/132","comment_is_top":false,"comment_ctime":1584596824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14469498712","product_id":100015201,"comment_content":"自定义？打扰打扰，等我过半个月再来","like_count":3},{"had_liked":false,"id":78442,"user_name":"单朋荣","can_delete":false,"product_type":"c1","uid":1272662,"ip_address":"","ucode":"8AD121BEDD9675","user_header":"https://static001.geekbang.org/account/avatar/00/13/6b/56/37a4cea7.jpg","comment_is_top":false,"comment_ctime":1553148598,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14438050486","product_id":100015201,"comment_content":"张老师好，很感谢您的课程分享。另外，我想深入做些自定义组件的开发，您一路已经走过来了，想听下您的建议，顺便推荐书，万分感谢！","like_count":3,"discussions":[{"author":{"id":2543101,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cd/fd/9122de17.jpg","nickname":"warning","note":"","ucode":"89B7933979F813","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388403,"discussion_content":"同求，请问您现在找到合适的用书了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628752858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43034,"user_name":"jssfy","can_delete":false,"product_type":"c1","uid":1137238,"ip_address":"","ucode":"F16353CFE607B7","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/56/115c6433.jpg","comment_is_top":false,"comment_ctime":1543145660,"is_pvip":false,"replies":[{"id":"15413","content":"无所谓，哪都行","user_name":"作者回复","comment_id":43034,"uid":"1218095","ip_address":"","utype":1,"ctime":1543192167,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"14428047548","product_id":100015201,"comment_content":"请问这个控制器是跑在node节点上的？一般哪些控制器是跑在node上哪些是跑在master上呢","like_count":3,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430281,"discussion_content":"无所谓，哪都行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543192167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34191,"user_name":"hugeo","can_delete":false,"product_type":"c1","uid":1042824,"ip_address":"","ucode":"438F289EDD21CD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/88/941e488a.jpg","comment_is_top":false,"comment_ctime":1540037896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14424939784","product_id":100015201,"comment_content":"厉害了，原来这才是k8s的精髓","like_count":3},{"had_liked":false,"id":34015,"user_name":"runner","can_delete":false,"product_type":"c1","uid":1200107,"ip_address":"","ucode":"6037BEDDF7AA48","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/eb/b5bb4227.jpg","comment_is_top":false,"comment_ctime":1539948768,"is_pvip":false,"replies":[{"id":"12184","content":"给它们写yaml描述起来吧。","user_name":"作者回复","comment_id":34015,"uid":"1218095","ip_address":"","utype":1,"ctime":1540026641,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"14424850656","product_id":100015201,"comment_content":"张老师，问个问题，我们公司的docker业务，容器总数上万个，部分容器依赖宿主机配置文件。现在我们想迁k8s 的话，能不改动这些容器，把他们加入pod管理起来么？如果上万容器都重新调度生成的话，这个改动太大了。","like_count":3,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427104,"discussion_content":"给它们写yaml描述起来吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540026641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307458,"user_name":"八台上","can_delete":false,"product_type":"c1","uid":1391143,"ip_address":"","ucode":"FB3D74B522C720","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/27/5d218272.jpg","comment_is_top":false,"comment_ctime":1629109784,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10219044376","product_id":100015201,"comment_content":"想问一下 工作队列或者delta队列  会持久化吗， 不然controller异常重启的话，队列信息不是丢了吗？","like_count":2,"discussions":[{"author":{"id":2058258,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/68/12/031a05c3.jpg","nickname":"A免帅叫哥","note":"","ucode":"76D2522E602AEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551093,"discussion_content":"controller重启，第一步做的就是list操作，把对象从api-server哪里从新获取一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644895910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2589474,"avatar":"https://static001.geekbang.org/account/avatar/00/27/83/22/a44b65f5.jpg","nickname":"JamonJou","note":"","ucode":"C77E647E2FA7A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545266,"discussion_content":"我觉得应该是自己实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641890483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222002,"user_name":"waterjiao","can_delete":false,"product_type":"c1","uid":1283989,"ip_address":"","ucode":"74F2F75BF0CA6F","user_header":"https://static001.geekbang.org/account/avatar/00/13/97/95/aad51e9b.jpg","comment_is_top":false,"comment_ctime":1590654287,"is_pvip":true,"discussion_count":2,"race_medal":1,"score":"10180588879","product_id":100015201,"comment_content":"磊哥，如果控制器一段时间不可用，删除的事件到了，这个资源在etcd中被删掉了，控制器重启后，期望状态和实际状态对不齐了，这个时候是不是还要用缓存的数据和实际数据做对比？如果数据较多时，又该怎么办呢？","like_count":2,"discussions":[{"author":{"id":1283989,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/95/aad51e9b.jpg","nickname":"waterjiao","note":"","ucode":"74F2F75BF0CA6F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278122,"discussion_content":"查了下可以用Finalizer可以解决此问题，还有两个问题想问下\n1）状态这个字段怎么返回到api-server中呢？\n2）如果一个控制器要管理多种资源的话，需要把各个资源生成的informer整合起来吗？还是每一种资源都单独使用一个控制器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591152917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1207457,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/a1/80d83f0a.jpg","nickname":"Ellison","note":"","ucode":"A2FB94D4F6A332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1283989,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/95/aad51e9b.jpg","nickname":"waterjiao","note":"","ucode":"74F2F75BF0CA6F","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":335164,"discussion_content":"多创建几个infomer就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608109181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278122,"ip_address":""},"score":335164,"extra":""}]}]},{"had_liked":false,"id":96346,"user_name":"sonald","can_delete":false,"product_type":"c1","uid":1028090,"ip_address":"","ucode":"BBE5F144978952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/fa/5714677b.jpg","comment_is_top":false,"comment_ctime":1558401718,"is_pvip":true,"replies":[{"id":"36297","content":"那个就变成aggregator api sever了？","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1559619112,"ip_address":"","comment_id":96346,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10148336310","product_id":100015201,"comment_content":"看起来自定义的控制器是独立运行的，而不能像一个API对象一样注册到master，并且部署到master上之类的？","like_count":2,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450840,"discussion_content":"那个就变成aggregator api sever了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559619112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61417,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1547694270,"is_pvip":false,"replies":[{"id":"22067","content":"一个东西","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1548053800,"ip_address":"","comment_id":61417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10137628862","product_id":100015201,"comment_content":"我在读完后，和学习的期间，发现不仅仅CRD有Informer,workqueue构成的自定义控制器，而且client-go中也有个类似的，这两者之间有什么联系吗，还是就是一个东西","like_count":2,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436868,"discussion_content":"一个东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548053800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57405,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1546782496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10136717088","product_id":100015201,"comment_content":"E0107 05:44:18.230692   35973 reflector.go:134] github.com&#47;resouer&#47;k8s-controller-custom-resource&#47;pkg&#47;client&#47;informers&#47;externalversions&#47;factory.go:117: Failed to list *v1.Network: networks.samplecrd.k8s.io is forbidden: User &quot;system:node:node01&quot; cannot list resource &quot;networks&quot; in API group &quot;samplecrd.k8s.io&quot; at the cluster scope<br>我在node1上面运行打包后的程序报这个错，使用的kubeconfig 不是 ~&#47;.kube&#47;config 而是请问&#47;etc&#47;kubernetes&#47;kubelet.conf ，因为我没有那个config文件，请问报这个错误的原因是什么呢？<br>","like_count":2},{"had_liked":false,"id":34283,"user_name":"silver","can_delete":false,"product_type":"c1","uid":1186740,"ip_address":"","ucode":"908E3C8560D6E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/1b/b4/a6db1c1e.jpg","comment_is_top":false,"comment_ctime":1540086410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10130021002","product_id":100015201,"comment_content":"思考题：一个FIFO可能会support多个controller，所以controller层面的业务逻辑retry不能放在FIFO而是得有独立的retry queue。同时work queue可以用来实现backoff on error等业务逻辑，而这些逻辑不适合放在FIFO中","like_count":2},{"had_liked":false,"id":329227,"user_name":"cosz3","can_delete":false,"product_type":"c1","uid":1218665,"ip_address":"","ucode":"B9023D4A088CF2","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/69/5a1c6620.jpg","comment_is_top":false,"comment_ctime":1641222959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5936190255","product_id":100015201,"comment_content":"有两个问题：<br>1. APIServer 触发 event 的时候，是怎么知道给哪个 informer 发送 event 呢？通过文章没有看出 APIServer 加载 informer，也没看出某个 informer 主动去 APIServer 上注册自己。<br><br>2. informer ListandWatch 最多可以一次性 ListAndWatch 多少个 pod 呢？ ","like_count":1},{"had_liked":false,"id":287617,"user_name":"Podman","can_delete":false,"product_type":"c1","uid":1801003,"ip_address":"","ucode":"1C9C7EA8C28ED7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7b/2b/97e4d599.jpg","comment_is_top":false,"comment_ctime":1618050913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5913018209","product_id":100015201,"comment_content":"有个小白问题请教下~<br>所以上一篇文章代码部分最后生成的pkg&#47;client&#47;{informers, listers, clientset}客户端代码<br>这个“客户端”指的就是本篇的自定义controller<br>而且这些informers, listers, clientset代码就是用于实现informer、list&#47;watch机制等逻辑的<br><br>不知道我这样理解对么","like_count":1},{"had_liked":false,"id":139341,"user_name":"LQ","can_delete":false,"product_type":"c1","uid":1005635,"ip_address":"","ucode":"0E33CBE474F877","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/43/15be800e.jpg","comment_is_top":false,"comment_ctime":1570615757,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5865583053","product_id":100015201,"comment_content":"日志跑到 Waiting for informer caches to sync 就 hang 住了，紧跟着的 Starting workers 一直没开始跑，这个是什么原因？","like_count":1},{"had_liked":false,"id":138463,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1570260504,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5865227800","product_id":100015201,"comment_content":"godep restore获取依赖获取不到k8s.io的相关包有伙伴解决了吗","like_count":1,"discussions":[{"author":{"id":1269156,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5d/a4/2e4b6d33.jpg","nickname":"素还真","note":"","ucode":"9ABA456355F7E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344094,"discussion_content":"改用go mod吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611288138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90726,"user_name":"solaris.lin","can_delete":false,"product_type":"c1","uid":1516139,"ip_address":"","ucode":"A72313100825F3","user_header":"https://static001.geekbang.org/account/avatar/00/17/22/6b/7779a4c5.jpg","comment_is_top":false,"comment_ctime":1556617549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851584845","product_id":100015201,"comment_content":"请问，自定义控制器部署方案在生产场景中是怎么样的呢<br>1 耦合在controller-manager中，通过manager来统一部署和高可用，但原生和自定义控制器代码耦合。<br>2 独立部署，代码解耦了，但是后期维护成本变高了。","like_count":1},{"had_liked":false,"id":73636,"user_name":"arlose","can_delete":false,"product_type":"c1","uid":1154358,"ip_address":"","ucode":"C58C16EC025AE6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9d/36/2f36e1a8.jpg","comment_is_top":false,"comment_ctime":1551946175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846913471","product_id":100015201,"comment_content":"请问张老师main函数里面的networkInformerFactory := informers.NewSharedInformerFactory(networkClient, time.Second*30)中second*30意思是每个30秒监听一次么？请问有没有详细的文档或者什么网址解释这些api函数的功能参数的呢？","like_count":1},{"had_liked":false,"id":63117,"user_name":"Jacking","can_delete":false,"product_type":"c1","uid":1324134,"ip_address":"","ucode":"B5341C55EB84CB","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/66/cdcc7f97.jpg","comment_is_top":false,"comment_ctime":1548262083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843229379","product_id":100015201,"comment_content":"之前做过一个k8s资源状态监控的程序，就用到了 informer，所以这章内容看起来还好。没接触过informer可能要多动手写写代码，多看几遍才好理解","like_count":1},{"had_liked":false,"id":38301,"user_name":"寒青","can_delete":false,"product_type":"c1","uid":1271316,"ip_address":"","ucode":"568B08BFA91E91","user_header":"https://static001.geekbang.org/account/avatar/00/13/66/14/060890da.jpg","comment_is_top":false,"comment_ctime":1542018473,"is_pvip":false,"replies":[{"id":"13792","content":"会提一下。这个比较复杂。","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1542070670,"ip_address":"","comment_id":38301,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5836985769","product_id":100015201,"comment_content":"通过aggregation layer扩展k8s api 的方式会讲吗？谢谢","like_count":1,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428669,"discussion_content":"会提一下。这个比较复杂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542070670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34091,"user_name":"Vincen","can_delete":false,"product_type":"c1","uid":1218185,"ip_address":"","ucode":"1029A901EC7BA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/89/9312b3a2.jpg","comment_is_top":false,"comment_ctime":1539999217,"is_pvip":false,"replies":[{"id":"12181","content":"不需要。这个demo最后只会打出log来，不会真的去call neutron","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1540026334,"ip_address":"","comment_id":34091,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834966513","product_id":100015201,"comment_content":"按照文章中的步骤，还需要安装neutron网络吗","like_count":1,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427114,"discussion_content":"不需要。这个demo最后只会打出log来，不会真的去call neutron","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540026334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359076,"user_name":"陈麒文","can_delete":false,"product_type":"c1","uid":2187256,"ip_address":"福建","ucode":"41475885FA5AD5","user_header":"https://static001.geekbang.org/account/avatar/00/21/5f/f8/1d16434b.jpg","comment_is_top":false,"comment_ctime":1665221721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665221721","product_id":100015201,"comment_content":"看到这里还是很蒙圈，我还有救么😂","like_count":0},{"had_liked":false,"id":355399,"user_name":"Geek_3635b2","can_delete":false,"product_type":"c1","uid":2850687,"ip_address":"河南","ucode":"46674380343EEF","user_header":"","comment_is_top":false,"comment_ctime":1661333436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661333436","product_id":100015201,"comment_content":"学完go再来看这两篇","like_count":0},{"had_liked":false,"id":354288,"user_name":"Geek_1cc6d1","can_delete":false,"product_type":"c1","uid":1850248,"ip_address":"北京","ucode":"3E083616DD0742","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZCyXaP2gbxwFHxvtnyaaF2Pyy5KkSMsk9kh7SJl8icp1CD6wicb6VJibiblGibbpDo6IuHrdST6AnWQg/132","comment_is_top":false,"comment_ctime":1660265155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660265155","product_id":100015201,"comment_content":"有点跟不上了","like_count":0},{"had_liked":false,"id":353332,"user_name":"Sanping","can_delete":false,"product_type":"c1","uid":2160620,"ip_address":"北京","ucode":"3E82B6F0F54639","user_header":"https://static001.geekbang.org/account/avatar/00/20/f7/ec/b0e9ecd2.jpg","comment_is_top":false,"comment_ctime":1659361103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659361103","product_id":100015201,"comment_content":"一脸懵逼加一","like_count":0},{"had_liked":false,"id":349046,"user_name":"Geek_db7579","can_delete":false,"product_type":"c1","uid":3017841,"ip_address":"","ucode":"6C95FF72F1B73F","user_header":"","comment_is_top":false,"comment_ctime":1655690796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655690796","product_id":100015201,"comment_content":"如果对象更新（update）了，缓存里是有两个resource version的crd对象吗，而且强制更新缓存的时候，add、delete、update的事件不会丢失吗","like_count":0},{"had_liked":false,"id":346277,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1652971198,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652971198","product_id":100015201,"comment_content":"面向k8s编程。。。","like_count":0},{"had_liked":false,"id":341151,"user_name":"江东","can_delete":false,"product_type":"c1","uid":1793475,"ip_address":"","ucode":"391A62BC7039B3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5d/c3/69019d24.jpg","comment_is_top":false,"comment_ctime":1649390808,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649390808","product_id":100015201,"comment_content":"k8s是如何避免控制器死循环运行中cpu100%","like_count":0},{"had_liked":false,"id":335280,"user_name":"豆豆","can_delete":false,"product_type":"c1","uid":1275407,"ip_address":"","ucode":"97788B134C3212","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","comment_is_top":false,"comment_ctime":1645438535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645438535","product_id":100015201,"comment_content":"之前死磕这一块，啃不下去。跳槽后，同事跟我说，直接上kubebuilder，我不想，我就想搞懂，回过头来，一行一行的看这几节关于operator的开发章节，就想搞清楚内部原理，终于看懂了，终于搞明白了。","like_count":0},{"had_liked":false,"id":334725,"user_name":"Run","can_delete":false,"product_type":"c1","uid":1371941,"ip_address":"","ucode":"6738D2F36ACFF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLMDBq7lqg9ZasC4f21R0axKJRVCBImPKlQF8yOicLLXIsNgsZxsVyN1mbvFOL6eVPluTNgJofwZeA/132","comment_is_top":false,"comment_ctime":1645091405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645091405","product_id":100015201,"comment_content":"醍醐灌顶","like_count":0},{"had_liked":false,"id":324984,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1638771121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638771121","product_id":100015201,"comment_content":"越来越费劲了  头疼","like_count":0},{"had_liked":false,"id":287977,"user_name":"Ether","can_delete":false,"product_type":"c1","uid":1680140,"ip_address":"","ucode":"A2E94A92242015","user_header":"https://static001.geekbang.org/account/avatar/00/19/a3/0c/962ab5d7.jpg","comment_is_top":false,"comment_ctime":1618237753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618237753","product_id":100015201,"comment_content":"syncHandler 函数的key是传的什么？有大佬能跑老师代码跑起来吗？","like_count":0},{"had_liked":false,"id":277286,"user_name":"米唐","can_delete":false,"product_type":"c1","uid":2058106,"ip_address":"","ucode":"B56506718181CE","user_header":"https://static001.geekbang.org/account/avatar/00/1f/67/7a/94f6c178.jpg","comment_is_top":false,"comment_ctime":1612345050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612345050","product_id":100015201,"comment_content":"哪位大佬可以讲解一下，这个Network对象建立的整个过程","like_count":0},{"had_liked":false,"id":268235,"user_name":"Ellison","can_delete":false,"product_type":"c1","uid":1207457,"ip_address":"","ucode":"A2FB94D4F6A332","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/a1/80d83f0a.jpg","comment_is_top":false,"comment_ctime":1608108718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608108718","product_id":100015201,"comment_content":"我理解需要队列应该是， 比如控制器处理不过来数据时， 这时候某个对象在持续更新， 这时候resource version就会频繁改变， 这时候informe就会把本地频繁改变的版本改成一个最新的。","like_count":0},{"had_liked":false,"id":248641,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1600249951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600249951","product_id":100015201,"comment_content":"经典的消费者生产者模型,主要是为了协调两者的速度不一致来使用,利用一个队列进行存储,避免消费者的消费速度过慢<br>这一章的思路我读懂了,但是由于没从事过GO语言的学习过,所以代码并不是很了解,看来有必要学习下Go语言的编写","like_count":0},{"had_liked":false,"id":228370,"user_name":"Mr.Brooks","can_delete":false,"product_type":"c1","uid":1118650,"ip_address":"","ucode":"D47A6B0236A79F","user_header":"https://static001.geekbang.org/account/avatar/00/11/11/ba/2175bc50.jpg","comment_is_top":false,"comment_ctime":1592649805,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1592649805","product_id":100015201,"comment_content":"informer 和 控制循环，也算一种reactor模式吧","like_count":0,"discussions":[{"author":{"id":2415037,"avatar":"https://static001.geekbang.org/account/avatar/00/24/d9/bd/d65fa667.jpg","nickname":"宇智波鼬","note":"","ucode":"893886790C7D86","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570351,"discussion_content":"可能不是一个层面的东西吧，kubernetes 整体对外表现是 声明式 API，但是内部编排是怎么实现的，可能会用到事件驱动。个人理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651740703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135544,"user_name":"坤","can_delete":false,"product_type":"c1","uid":1010922,"ip_address":"","ucode":"74E6838226A405","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6c/ea/ce9854a5.jpg","comment_is_top":false,"comment_ctime":1569207882,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1569207882","product_id":100015201,"comment_content":"张老师，您好，请问可以补充一下code-generator的使用吗？ 我自己根据搜到的一些资料https:&#47;&#47;itnext.io&#47;how-to-generate-client-codes-for-kubernetes-custom-resource-definitions-crd-b4b9907769ba， 目前还是无法得到生成的listers informer等客户端代码。","like_count":0,"discussions":[{"author":{"id":1283989,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/95/aad51e9b.jpg","nickname":"waterjiao","note":"","ucode":"74F2F75BF0CA6F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274329,"discussion_content":"可以贴下报错的信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590568907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36682,"user_name":"hhhhhh","can_delete":false,"product_type":"c1","uid":1017443,"ip_address":"","ucode":"0826CE1D2C9F1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/86/63/0112cc96.jpg","comment_is_top":false,"comment_ctime":1541233615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541233615","product_id":100015201,"comment_content":"思考题： <br>为了在不阻塞informer的同时控制并发数量。  <br><br>如果直接在handler里执行具体业务逻辑，可能会很慢，出错重试也不好处理；而如果在handler里开一个新的线程来处理，虽然是不阻塞了，但却不好控制并发数量。","like_count":0},{"had_liked":false,"id":34940,"user_name":"Pixar","can_delete":false,"product_type":"c1","uid":1197659,"ip_address":"","ucode":"E653387BA8EA16","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/5b/07858c33.jpg","comment_is_top":false,"comment_ctime":1540363159,"is_pvip":false,"replies":[{"id":"12536","content":"就是输出events啊，跟打日志一样。怎么会接受events……","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1540439949,"ip_address":"","comment_id":34940,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540363159","product_id":100015201,"comment_content":"张老师, 例子中关于event有一个疑问<br>`utilruntime.Must(networkscheme.AddToScheme(scheme.Scheme))<br>glog.V(4).Info(&quot;Creating event broadcaster&quot;)<br>eventBroadcaster := record.NewBroadcaster()<br>eventBroadcaster.StartLogging(glog.Infof)<br>eventBroadcaster.StartRecordingToSink(&amp;typedcorev1.EventSinkImpl{Interface: kubeclientset.CoreV1().Events(&quot;&quot;)})<br>recorder := eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: controllerAgentName})<br><br>这段代码的目的是什么可以详细在详细解释下吗? 从注释能看出是为了 custom controller可以正常接收event, 但其中的原因可以说下吗?","like_count":0,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427393,"discussion_content":"就是输出events啊，跟打日志一样。怎么会接受events……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540439949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33936,"user_name":"fiisio","can_delete":false,"product_type":"c1","uid":1148088,"ip_address":"","ucode":"87CB8F5EAA033B","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/b8/0b73ecdc.jpg","comment_is_top":false,"comment_ctime":1539921235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539921235","product_id":100015201,"comment_content":"大概是因为深入贯彻的声明式，异步同时防丢失数据","like_count":0}]}