{"id":241123,"title":"05 | Spring DI容器：如何分析一个软件的模型？","content":"<p>你好！我是郑晔。</p><p>在上一讲中，我们讨论了如何了解一个软件的设计，主要是从三个部分入手：模型、接口和实现。那么，在接下来的三讲中，我将结合几个典型的开源项目，告诉你如何具体地理解一个软件的模型、接口和实现。</p><p>今天这一讲，我们就先来谈谈了解设计的第一步：模型。如果拿到一个项目，我们怎么去理解它的模型呢？</p><p><strong>我们肯定要先知道项目提供了哪些模型，模型又提供了怎样的能力。</strong>这是所有人都知道的事情，我并不准备深入地去探讨。但如果只知道这些，你只是在了解别人设计的结果，这种程度并不足以支撑你后期对模型的维护。</p><p>在一个项目中，常常会出现新人随意向模型中添加内容，修改实现，让模型变得难以维护的情况。造成这一现象的原因就在于他们对于模型的理解不到位。</p><p>我们都知道，任何模型都是为了解决问题而生的，所以，理解一个模型，需要了解在没有这个模型之前，问题是如何被解决的，这样，你才能知道新的模型究竟提供了怎样的提升。也就是说，<strong>理解一个模型的关键在于，要了解这个模型设计的来龙去脉，知道它是如何解决相应的问题。</strong></p><p>今天我们以Spring的DI容器为例，来看看怎样理解软件的模型。</p><h2>耦合的依赖</h2><p>Spring在Java世界里绝对是大名鼎鼎，如果你今天在做Java开发而不用Spring，那么你大概率会被认为是个另类。</p><!-- [[[read_end]]] --><p>今天很多程序员都把Spring当成一个成熟的框架，很少去仔细分析Spring的设计。但作为一个从0.8版本就开始接触Spring的程序员，我刚好有幸经历了Spring从渺小到壮大的过程，得以体会到Spring给行业带来的巨大思维转变。</p><p>如果说Spring这棵参天大树有一个稳健的根基，那其根基就应该是 Spring的DI容器。DI是Dependency Injection的缩写，也就是“依赖注入”。Spring的各个项目都是这个根基上长出的枝芽。</p><p>那么，DI容器要解决的问题是什么呢？它解决的是<strong>组件创建和组装</strong>的问题，但是为什么这是一个需要解决的问题呢？这就需要我们了解一下组件的创建和组装。</p><p>在前面的课程中，我讲过，软件设计需要有一个分解的过程，所以，它必然还要面对一个组装的过程，也就是把分解出来的各个组件组装到一起，完成所需要的功能。</p><p>为了叙述方便，我采用Java语言来进行后续的描述。</p><p>我们从程序员最熟悉的一个查询场景开始。假设我们有一个文章服务（ArticleService）提供根据标题查询文章的功能。当然，数据是需要持久化的，所以，这里还有一个ArticleRepository，用来与持久化数据打交道。</p><p>熟悉DDD的同学可能发现了，这个仓库（Repository）的概念来自于DDD。如果你不熟悉也没关系，它就是与持久化数据打交道的一层，和一些人习惯的Mapper或者DAO（Data Access Object）类似，你可以简单地把它理解成访问数据库的代码。</p><pre><code>class ArticleService {\n  //提供根据标题查询文章的服务\n  Article findByTitle(final String title) {\n    ...\n  }\n}\n\ninterface ArticleRepository {\n  //在持久化存储中，根据标题查询文章\n  Article findByTitle(final String title)；\n}\n</code></pre><p>在ArticleService处理业务的过程中，需要用到ArticleRepository辅助它完成功能，也就是说，ArticleService要依赖于ArticleRepository。这时你该怎么做呢？一个直接的做法就是在 ArticleService中增加一个字段表示ArticleRepository。</p><pre><code>class ArticleService {\n  private ArticleRepository repository;\n  \n  public Article findByTitle(final String title) {\n    // 做参数校验\n    return this.repository.findByTitle(title);\n  }\n}\n</code></pre><p>目前看起来一切都还好，但是接下来，问题就来了，这个字段怎么初始化呢？程序员一般最直接的反应就是直接创建这个对象。这里选用了一个数据库版本的实现（DBArticleRepository）。</p><pre><code>class ArticleService {\n  private ArticleRepository repository = new DBArticleRepository();\n  \n  public Article findByTitle(final String title) {\n    // 做参数校验\n    return this.repository.findByTitle(title);\n  }\n}\n</code></pre><p>看上去很好，但实际上DBArticleRepository并不能这样初始化。正如这个实现类的名字所表示的那样，我们这里要用到数据库。但在真实的项目中，由于资源所限，我们一般不会在应用中任意打开数据库连接，而是会选择共享数据库连接。所以，DBArticleRepository需要一个数据库连接（Connection）的参数。在这里，你决定在构造函数里把这个参数传进来。</p><pre><code>class ArticlService {\n  private ArticleRepository repository;\n  \n  public ArticlService(final Connection connection) {\n    this.repository = new DBArticleRepository(connection);\n  }\n  \n  public Article findByTitle(final String title) {\n    // 做参数校验\n    return this.repository.findByTitle(title);\n  }\n}\n</code></pre><p>好，代码写完了，它看上去一切正常。如果你的开发习惯仅仅到此为止，可能你会觉得这还不错。但我们并不打算做一个只写代码的程序员，所以，我们要进入下一个阶段：测试。</p><p>一旦开始准备测试，你就会发现，要让ArticleService跑起来，那就得让ArticleRepository也跑起来；要让ArticleRepository跑起来，那就得准备数据库连接。</p><p>是不是觉得太麻烦，想放弃测试。但有职业素养的你，决定坚持一下，去准备数据库连接信息。</p><p>然后，真正开始写测试时，你才发现，要测试，你还要在数据库里准备各种数据。比如，要测查询，你就得插入一些数据，看查出来的结果和插入的数据是否一致；要测更新，你就得先插入数据，测试跑完，再看数据更新是否正确。</p><p>不过，你还是没有放弃，咬着牙准备了一堆数据之后，你突然困惑了：我在干什么？我不是要测试服务吗？做数据准备不是测试仓库的时候应该做的事吗？</p><p>那么，问题出在哪儿呢？其实就在你创建对象的那一刻，问题就出现了。</p><h2>分离的依赖</h2><p>为什么说从创建对象开始就出问题了呢？</p><p>因为当我们创建一个对象时，就必须要有一个具体的实现类，对应到我们这里，就是那个 DBArticleRepository。虽然我们的ArticleService写得很干净，其他部分根本不依赖于 DBArticleRepository，只在构造函数里依赖了，但依赖就是依赖。</p><p>与此同时，由于要构造DBArticleRepository的缘故，我们这里还引入了Connection这个类，这个类只与DBArticleRepository的构造有关系，与我们这个ArticleService的业务逻辑一点关系都没有。</p><p>所以，你看到了，只是因为引入了一个具体的实现，我们就需要把它周边配套的东西全部引入进来，而这一切与这个类本身的业务逻辑没有任何关系。</p><p>这就好像，你原本打算买一套家具，现在却让你必须了解树是怎么种的、怎么伐的、怎么加工的，以及家具是怎么设计、怎么组装的，而你想要的只是一套能够使用的家具而已。</p><p>这还只是最简单的场景，在真实的项目中，构建一个对象可能还会牵扯到更多的内容：</p><ul>\n<li>根据不同的参数，创建不同的实现类对象，你可能需要用到工厂模式。</li>\n<li>为了了解方法的执行时间，需要给被依赖的对象加上监控。</li>\n<li>依赖的对象来自于某个框架，你自己都不知道具体的实现类是什么。</li>\n<li>……</li>\n</ul><p>所以，即便是最简单的对象创建和组装，也不像看起来那么简单。</p><p>既然直接构造存在这么多的问题，那么最简单的办法就是把创建的过程拿出去，只留下与字段关联的过程：</p><pre><code>class ArticleService {\n  private ArticleRepository repository;\n  \n  public ArticleService(final ArticleRepository repository) {\n    this.repository = repository;\n  }\n  \n  public Article findByTitle(final String title) {\n    // 做参数校验\n    return this.repository.findByTitle(title);\n  }\n}\n</code></pre><p>这时候，ArticleService就只依赖ArticleRepository。而测试ArticleService也很简单，只要用一个对象将ArticleRepository的行为模拟出来就可以了。通常这种模拟对象行为的工作用一个现成的程序库就可以完成，这就是那些Mock框架能够帮助你完成的工作。</p><p>或许你想问，在之前的代码里，如果我用Mock框架模拟Connection类是不是也可以呢？理论上，的确可以。但是想要让ArticleService的测试通过，就必须打开DBArticleRepository的实现，只有配合着其中的实现，才可能让ArticleService跑起来。显然，你跑远了。</p><p>现在，对象的创建已经分离了出去，但还是要要有一个地方完成这个工作，最简单的解决方案自然是，把所有的对象创建和组装在一个地方完成：</p><pre><code>...\nArticleRepository repository = new DBArticleRepository(connection);\nAriticleService service = new ArticleService(repository);\n...\n</code></pre><p>相比于业务逻辑，组装过程并没有什么复杂的部分。一般而言，纯粹是一个又一个对象的创建以及传参的过程，这部分的代码看上去会非常的无聊。</p><p>虽然很无聊，但这一部分代码很重要，最好的解决方案就是有一个框架把它解决掉。在Java世界里，这种组装一堆对象的东西一般被称为“容器”，我们也用这个名字。</p><pre><code>Container container = new Container();\ncontainer.bind(Connection.class).to(connection);\ncontainer.bind(ArticleReposistory.class).to(DBArticleRepository.class);\ncontainer.bind(ArticleService.class).to(ArticleService.class)\n\nArticleService service = container.getInstance(ArticleService.class);\n</code></pre><p>至此，一个容器就此诞生。因为它解决的是依赖的问题，把被依赖的对象像药水一样，注入到了目标对象中，所以，它得名“依赖注入”（Dependency Injection，简称 DI）。这个容器也就被称为DI容器了。</p><p>至此，我简单地给你介绍了DI容器的来龙去脉。虽然上面这段和Spring DI容器长得并不一样，但其原理是一致的，只是接口的差异而已。</p><p>事实上，这种创建和组装对象的方式在当年引发了很大的讨论，直到最后Martin Fowler写了一篇《<a href=\"http://www.martinfowler.com/articles/injection.html\">反转控制容器和依赖注入模式</a>》的文章，才算把大家的讨论做了一个总结，行业里总算是有了一个共识。</p><p>那段时间，DI容器也得到了蓬勃的发展，很多开源项目都打造了自己的DI容器，Spring是其中最有名的一个。只不过，Spring并没有就此止步，而是在这样一个小内核上面发展出了更多的东西，这才有了我们今天看到的庞大的Spring王国。</p><p>讲到这里，你会想，那这和我们要讨论的“模型”有什么关系呢？</p><p>正如我前面所说，很多人习惯性把对象的创建和组装写到了一个类里面，这样造成的结果就是，代码出现了大量的耦合。时至今日，很多项目依然在犯同样的错误。很多项目测试难做，原因就在于此。这也从另外一个侧面佐证了可测试性的作用，我们曾在<a href=\"https://time.geekbang.org/column/article/241094\">第3讲</a>中说过：可测试性是衡量设计优劣的一个重要标准。</p><p>由此可见，在没有DI容器之前，那是怎样的一个蛮荒时代啊！</p><p>有了DI容器之后呢？你的代码就只剩下关联的代码，对象的创建和组装都由DI容器完成了。甚至在不经意间，你有了一个还算不错的设计：至少你做到了面向接口编程，它的实现是可以替换的，它还是可测试的。与之前相比，这是一种截然不同的思考方式，而这恰恰就是DI容器这个模型带给我们的。</p><p>而且，一旦有了容器的概念，它还可以不断增强。比如，我们想给所有与数据库相关的代码加上时间监控，只要在容器构造对象时添加处理即可。你可能已经发现了，这就是 AOP（Aspect Oriented Programming，面向切面编程）的处理手法。而这些改动，你的业务代码并无感知。</p><p>Spring的流行，对于提升Java世界整体编程的质量是大有助益的。因为它引导的设计方向是一个好的方向，一个普通的Java程序员写出来的程序只要符合Spring引导的方向，那么它的基本质量就是有保障的，远超那个随意写程序的年代。</p><p>不过，如果你不能认识到DI容器引导的方向，我们还是无法充分利用它的优势，更糟糕的是，我们也不能太低估一些程序员的破坏力。我还是见过很多程序员即便在用了Spring之后，依然是自己构造对象，静态方法满天飞，把原本一个还可以的设计，打得七零八落。</p><p>你看，通过上面的分析，我们知道了，只有理解了模型设计的来龙去脉，清楚认识到它在解决的问题，才能更好地运用这个模型去解决后面遇到的问题。如果你是这个项目的维护者，你才能更好地扩展这个模型，以便适应未来的需求。</p><h2>总结时刻</h2><p>今天，我们学习了如何了解设计的第一部分：看模型。<strong>理解模型，要知道项目提供了哪些模型，这些模型都提供了怎样的能力</strong>。但还有更重要的一步就是，<strong>要了解模型设计的来龙去脉</strong>。这样，一方面，可以增进了我们对它的了解，但另一方面，也会减少我们对模型的破坏或滥用。</p><p>我以Spring的DI容器为例给你讲解了如何理解模型。DI容器的引入有效地解决了对象的创建和组装的问题，让程序员们拥有了一个新的编程模型。</p><p>按照这个编程模型去写代码，整体的质量会得到大幅度的提升，也会规避掉之前的许多问题。这也是一个好的模型对项目起到的促进作用。像DI这种设计得非常好的模型，你甚至不觉得自己在用一个特定的模型在编程。</p><p>有了对模型的了解，我们已经迈出了理解设计的第一步，下一讲，我们来看看怎样理解接口。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>理解模型，要了解模型设计的来龙去脉。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/50/a2/50983d3d104c811f33f02db1783d4da2.jpg?wh=2323*652\" alt=\"\"></p><h2>思考题</h2><p>最后，我想请你思考一个问题，DI容器看上去如此地合情合理，为什么在其他编程语言的开发中，它并没有流行起来呢？欢迎在留言区写下你的思考。</p><p>感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。</p>","comments":[{"had_liked":false,"id":223576,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1591124477,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"323713671677","product_id":100052601,"comment_content":"1.斟酌再三，虽说直接说spring di容器好像也没啥毛病，但个人觉得这描述并不是很准确，故阐述下自己的认知。<br><br>2.我认为spring提供的这个编程模型应该叫ioc（控制反转和响应式编程有点像）而不是di。因为最开始被提出来的是ioc（好莱坞原则），而且最早的实现也不是spring，jdk和ejb都有对ioc的实现，spring才是后来者。但是di确实好像是在spring上被流行起来，且长期主流的（spring di容器没毛病的原因）。不过spring对ioc的实现，除了di还有依赖查找，在我眼里ioc是模型，依赖查找和依赖注入是功能，所以我认为应该是spring提供了ioc的编程模型，利用ioc容器+di的功能简化了开发。<br><br>3.依赖注入相对于依赖查找，透明度更好，调用方对ioc容器的api和具体接口实现的查表获取被隐藏了（技术与业务的解耦最终都该透明无感）。但依赖查找在需要动态选择策略时依旧有其用武之地。<br><br>4.回答课后题： 对于py和go这类函数式编程语言，函数是一等公民，是可以作为参数传递的。那么直接改变所传的函数就可以实现mock和函数替换（使用和创建天然解耦）。  为什么java会流行？我认为有个原因，是因为java是单分派的语言，编译期方法和参数类型是绑定死的（强类型），运行期走哪个bean的方法是动态决定的。如此就引出了面向接口编程的多态实现方案，才会有后面ioc的诉求。","like_count":75,"discussions":[{"author":{"id":1060803,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2f/c3/5759e127.jpg","nickname":"严晓东","note":"","ucode":"CF8BB9106F4CC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285576,"discussion_content":"py可不是函数式编程语言哦，设计上是纯面相对象编程的。everything is object. Haskell 这种才是函数式编程语言","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1592883084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1060803,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2f/c3/5759e127.jpg","nickname":"严晓东","note":"","ucode":"CF8BB9106F4CC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285593,"discussion_content":"嗯嗯，感谢指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592887249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285576,"ip_address":""},"score":285593,"extra":""},{"author":{"id":1178825,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/c9/52d8e1f0.jpg","nickname":"鱼叔","note":"","ucode":"6DCBCBD6C57002","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1060803,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2f/c3/5759e127.jpg","nickname":"严晓东","note":"","ucode":"CF8BB9106F4CC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585595,"discussion_content":"go 也不是函数式语言，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1661695330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285576,"ip_address":"广东"},"score":585595,"extra":""}]},{"author":{"id":1390170,"avatar":"https://static001.geekbang.org/account/avatar/00/15/36/5a/9188729f.jpg","nickname":"阿彪","note":"","ucode":"69FFF3454A2E13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388944,"discussion_content":"模型可大可小，你讲的也有道理。 老师讲的也没毛病，在我眼里你说的是实现这个模型所使用的模型。属于更小力度的模型  当然我也不确定自己是不是对的，期望大佬回复","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629076877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438470,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/06/8da1bf0c.jpg","nickname":"Fredo","note":"","ucode":"681D6692617DAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407539,"discussion_content":"我觉得是更高一层的抽象吧，设计思想-->模型-->接口-->实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635056118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613919,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a0/5f/cf72d453.jpg","nickname":"小豹哥","note":"","ucode":"115FF45CAA6FAD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283464,"discussion_content":"这评论一看就是大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592277483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223605,"user_name":"Moonus","can_delete":false,"product_type":"c1","uid":1813327,"ip_address":"","ucode":"F8261DA1E8DF2C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqia9gfbDeu8RqUlSozxmnzr6micGefNs5QGehBBl23xH6V82GxYwjgFgCKIA9n6iafFVKFoxVw5fHWw/132","comment_is_top":false,"comment_ctime":1591143769,"is_pvip":true,"replies":[{"id":"82405","content":"唉，你说的现状，我非常理解。所谓的“快”，只是从当前一个时点上看，放在长期，就是越跑越慢。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591181997,"ip_address":"","comment_id":223605,"utype":1}],"discussion_count":7,"race_medal":0,"score":"91785456985","product_id":100052601,"comment_content":"我觉得最根本原因是大多数开发不写测试，所以不会考虑依赖问题，大多数方法都是面向实现而不是接口，使用DI容器反而增加了工作量。<br>目前所在小组偏向于外包，代码只有一层，不是单列，就是静态方法；为了达到快速交付，基本没有设计，不管怎么说这都是不合理的。是前人挖，后人跳。","like_count":21,"discussions":[{"author":{"id":1520986,"avatar":"https://static001.geekbang.org/account/avatar/00/17/35/5a/f96a46ba.jpg","nickname":"kd","note":"","ucode":"F7C5C027831976","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336503,"discussion_content":"另一个现状是，不少项目走不到“长期”这个时间点 o(╯□╰)o","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1608610492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1520986,"avatar":"https://static001.geekbang.org/account/avatar/00/17/35/5a/f96a46ba.jpg","nickname":"kd","note":"","ucode":"F7C5C027831976","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573317,"discussion_content":"这个是我认为的真正原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653352870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336503,"ip_address":""},"score":573317,"extra":""}]},{"author":{"id":1241842,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/f2/2a9a6e9a.jpg","nickname":"行与修","note":"","ucode":"11F21B663EF6D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278493,"discussion_content":"越是图快，软件的生命周期越短，能沉淀下来的项目就越少，越难成为经典和最佳实践，恶性循环","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1591192862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497185,"discussion_content":"唉，你说的现状，我非常理解。所谓的“快”，只是从当前一个时点上看，放在长期，就是越跑越慢。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591181997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000417,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/e1/b7be5560.jpg","nickname":"sam","note":"","ucode":"8D48F4B9045947","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282943,"discussion_content":"同感同感","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592124349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570953,"discussion_content":"一个现实问题，一个程序员能够在一个公司呆多久，还需要考虑长期？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652004122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2064776,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/81/88/ac059d9a.jpg","nickname":"少安倾听","note":"","ucode":"7D6388A816D4CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537770,"discussion_content":"当我知道了这些事，我就不会置之不理了，设法去实践","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639184819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223583,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1591136714,"is_pvip":false,"replies":[{"id":"84913","content":"很好的总结。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1593262669,"ip_address":"","comment_id":223583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70310613450","product_id":100052601,"comment_content":"理解软件设计中模型首先要理解模型解决的核心问题是什么，然后抽丝剥茧了解模型的来龙去脉，深入理解模型解决问题的过程。<br>spring中的di模型是为了解决对象的创建和组装的问题。<br>那为什么创建对象和组装要用di来解决？<br>一个重要的原因是为了解耦。分离接口与实现的强依赖，也就是软件设计第一步分离关注点。<br>而这个恰恰就是为了可测试性，当一个代码是可测的，其实就是说明它是比较灵活的，修改起来不会牵一发而动全身，提高开发的体验，减少因修改引入的额外问题","like_count":16,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497177,"discussion_content":"很好的总结。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593262669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223885,"user_name":"keep_curiosity","can_delete":false,"product_type":"c1","uid":1246273,"ip_address":"","ucode":"794DC1D3FB9214","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/41/082e2706.jpg","comment_is_top":false,"comment_ctime":1591208176,"is_pvip":false,"replies":[{"id":"82459","content":"静态方法，没法去模拟它的行为，所以，要做测试的话，遇到静态方法，你必须关注它的实现，而不是它的接口。总的来说，静态方法是写着爽，但测着不方便。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591249433,"ip_address":"","comment_id":223885,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48835848432","product_id":100052601,"comment_content":"为什么不建议使用静态方法？如果只是简单的模型转换，用静态方法不是更好吗？","like_count":11,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497282,"discussion_content":"静态方法，没法去模拟它的行为，所以，要做测试的话，遇到静态方法，你必须关注它的实现，而不是它的接口。总的来说，静态方法是写着爽，但测着不方便。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591249433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566315,"discussion_content":"还是没理解晶态方法在测试方面的弊端～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650642463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223572,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1591117422,"is_pvip":false,"replies":[{"id":"82410","content":"将 Connection 这个类绑定在 connection 这个对象上，当需要一个 Connection 对象时，返回 connection 这个对象。<br><br>将 ArticleReposistory 这个接口绑定在 DBArticleRepository 这个类上，当需要一个 ArticleReposistory 对象时，返回 DBArticleRepository 这个类的一个对象。<br><br>将 ArticleService 这个类就绑定在其自身，当需要一个 ArticleService 对象时，返回这个类的一个对象。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591182337,"ip_address":"","comment_id":223572,"utype":1}],"discussion_count":3,"race_medal":0,"score":"40245823086","product_id":100052601,"comment_content":"container.bind(Connection.class).to(connection);<br>container.bind(ArticleReposistory.class).to(DBArticleRepository.class);<br>container.bind(ArticleService.class).to(ArticleService.class)<br>请问这3行代码的具体含义是啥？","like_count":9,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497170,"discussion_content":"将 Connection 这个类绑定在 connection 这个对象上，当需要一个 Connection 对象时，返回 connection 这个对象。\n\n将 ArticleReposistory 这个接口绑定在 DBArticleRepository 这个类上，当需要一个 ArticleReposistory 对象时，返回 DBArticleRepository 这个类的一个对象。\n\n将 ArticleService 这个类就绑定在其自身，当需要一个 ArticleService 对象时，返回这个类的一个对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591182337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110662,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg","nickname":"Hank_Yan","note":"","ucode":"86899B561C502B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278067,"discussion_content":"这几行是将对象放到到容器中, 同时处理其依赖关系。ioc 容器在创建每一个对象的时候，会同时创建其依赖的对象。这里的 to 就是在声明其依赖的对象有哪些。这样 ioc 容器能在框架层面解决对象的创建和组装问题。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1591146560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d4/78/66b3f2a2.jpg","nickname":"斯盖丸","note":"","ucode":"B881D14B028F14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348581,"discussion_content":"完全看不懂这段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612658522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223649,"user_name":"JohnnyB0Y","can_delete":false,"product_type":"c1","uid":1003784,"ip_address":"","ucode":"805A3EF7B62227","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/08/4b2d2499.jpg","comment_is_top":false,"comment_ctime":1591148529,"is_pvip":false,"replies":[{"id":"84630","content":"AOP 早在 DI 之前就有了，它并没有那么大的推动作用，DI 兴起之后，它才有了更多的用武之地。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1592968603,"ip_address":"","comment_id":223649,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35950886897","product_id":100052601,"comment_content":"回答作业：<br>1，Java有反射，其他语言不一定有；<br>2，Java生态比较完善，大神比较多，有模版可以学；<br>3，前端开发集中在UI界面和数据解析，需求变更快，用DI容器去做有点吃力；（UI大多是包含的方式，很难把子控件拎出来初始化）<br>4，DI容器的AOP可能更适合后端，突如其来的统计、归档之类的需求。而前端的应用生命周期和页面生命周期都由UI框架提供了，AOP自然用的少。<br><br>总结：我觉得AOP可能才是开发者爱用DI的主要原因，加上Java生态的繁荣最终流行起来。（个人看法）","like_count":8,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497201,"discussion_content":"AOP 早在 DI 之前就有了，它并没有那么大的推动作用，DI 兴起之后，它才有了更多的用武之地。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592968603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2064776,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/81/88/ac059d9a.jpg","nickname":"少安倾听","note":"","ucode":"7D6388A816D4CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537771,"discussion_content":"PHP的Laravel框架也有类似的思想设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639184881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223651,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1591148632,"is_pvip":true,"replies":[{"id":"82402","content":"学习一个软件，要从基础模型开始。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591181776,"ip_address":"","comment_id":223651,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31655919704","product_id":100052601,"comment_content":"接触spring 七八年， 一直在学习BeanFactory 和 ApplicationContext 上打转，今天才算对容器这个概念有一个直觉性的认识，感谢老师！","like_count":7,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497202,"discussion_content":"学习一个软件，要从基础模型开始。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591181776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223700,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1591160418,"is_pvip":false,"replies":[{"id":"82430","content":"没错，简化开发是结果，模型才是动因。<br><br>Spring Boot 是在 Spring 出现好多年之后才出现的。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591225202,"ip_address":"","comment_id":223700,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23065996898","product_id":100052601,"comment_content":"一个框架的流行根本原因不是它简化了开发，而是导致了问题的简化的那个开发模型。像spring 提供的di 模型，你甚至感受不到它的存在。它更像是一种理念，而这是一个模型的最高级形态。在di的核心模型之上，又出现了starter,auto configuration 等理念，这就是spring boot 的模型创新。在springboot 之上，又有springcloud.....<br><br>Spring 这个框架，真的是，，，牛逼(找不到合适的词了）","like_count":5,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497218,"discussion_content":"没错，简化开发是结果，模型才是动因。\n\nSpring Boot 是在 Spring 出现好多年之后才出现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591225202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2530282,"avatar":"https://static001.geekbang.org/account/avatar/00/26/9b/ea/e6a3b97d.jpg","nickname":"zenos.chen","note":"","ucode":"256301956D0792","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362385,"discussion_content":"动因和原因是两回事吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616934829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224817,"user_name":"六一王","can_delete":false,"product_type":"c1","uid":1154621,"ip_address":"","ucode":"2349E4F540CEC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/9e/3d/928b41f1.jpg","comment_is_top":false,"comment_ctime":1591545579,"is_pvip":false,"replies":[{"id":"82949","content":"后面会讲到函数式编程，简单来说，面向对象提供了组织类的能力，函数式编程提供了组织动作的能力，二者可以混合使用。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591706899,"ip_address":"","comment_id":224817,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18771414763","product_id":100052601,"comment_content":"我是一个两年的前端程序媛，不太了解 java。面向对象编程时，你只想要一颗树，却得到整个森林，于是有些人就觉得面向对象编程是不好的，所以认为函数式编程的方式更好，不过文章提到的组件创建和组合放入到一个容器中，也就是说将所有依赖都放入都一个地方，提供业务需要的接口，而不写到业务中，那么为啥没有在前端火起来呢？函数式编程是不是就是面向接口编程的一种呢？","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497616,"discussion_content":"后面会讲到函数式编程，简单来说，面向对象提供了组织类的能力，函数式编程提供了组织动作的能力，二者可以混合使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591706899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223972,"user_name":"小鱼儿","can_delete":false,"product_type":"c1","uid":1053492,"ip_address":"","ucode":"989EC453936B91","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/34/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1591247320,"is_pvip":false,"replies":[{"id":"82539","content":"这是我在开篇词里的立论，软件设计是一门关注长期变化的学问。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591315135,"ip_address":"","comment_id":223972,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18771116504","product_id":100052601,"comment_content":"放下历史长河之中去看问题，比如 现在去看几年前甚至10年前的代码，才知道这样做的好处，分离关注点，可测试性是多么需要，不然真的改不动。","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497318,"discussion_content":"这是我在开篇词里的立论，软件设计是一门关注长期变化的学问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591315135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570954,"discussion_content":"你现在加入的公司，能不能再活5年都难说。现在吐惨前辈的代码没有10年的生命力就是扯蛋。我记得有个设计原则是，不要过度设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652004258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573409,"discussion_content":"过度设计，和此处的分离关注点和可测试性，不冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653394380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":570954,"ip_address":""},"score":573409,"extra":""}]}]},{"had_liked":false,"id":227672,"user_name":"迈步","can_delete":false,"product_type":"c1","uid":1747737,"ip_address":"","ucode":"BA9B69CEDA6176","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ab/19/829f321f.jpg","comment_is_top":false,"comment_ctime":1592450998,"is_pvip":false,"replies":[{"id":"84684","content":"IoC、DI、DIP 其实这几个名字在早先的讨论里是类似的，容易混淆的，其重点都是把依赖通过接口隔离开。最后 DI 容器这里选了 DI，后面我们会讲到 DIP，可以再来看。IoC 远远到不了 OO 的级别，只是一种设计原则。<br><br>静态方法能不用就不用，大多数情况下都可以用普通方法代替。只有少数程序库适合写成 static 的。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1592996908,"ip_address":"","comment_id":227672,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14477352886","product_id":100052601,"comment_content":"我的理解，IoC是一种思想，就像OOP、AOP一样都是思想。而DI是技术实现，是IoC的最常见以及最合理的实现方式。按照老马（Martin Fowler）的意思，可以使用DI代替掉IoC。因为DI就基本能够体现出IoC的意思了。省得搞混淆了。<br><br>另外对于静态方法，在日常开发中，老师的建议是什么呀？推荐使用吗？在什么场景下可以推荐使用？","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498743,"discussion_content":"IoC、DI、DIP 其实这几个名字在早先的讨论里是类似的，容易混淆的，其重点都是把依赖通过接口隔离开。最后 DI 容器这里选了 DI，后面我们会讲到 DIP，可以再来看。IoC 远远到不了 OO 的级别，只是一种设计原则。\n\n静态方法能不用就不用，大多数情况下都可以用普通方法代替。只有少数程序库适合写成 static 的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592996908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2017008,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c6/f0/3c6fa392.jpg","nickname":"_","note":"","ucode":"E9E7AB20E306EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":589589,"discussion_content":"但是很多工具类 都是静态方法，我有点 不太理解为啥说 静态方法能不用就不用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665152348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":498743,"ip_address":"浙江"},"score":589589,"extra":""}]}]},{"had_liked":false,"id":223838,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1591194158,"is_pvip":false,"replies":[{"id":"82431","content":"往前一步，你就成长了。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591225228,"ip_address":"","comment_id":223838,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14476096046","product_id":100052601,"comment_content":"你只是在了解别人设计的结果... 这就是我最欠缺的<br>","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497258,"discussion_content":"往前一步，你就成长了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591225228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223579,"user_name":"西西弗与卡夫卡","can_delete":false,"product_type":"c1","uid":1001710,"ip_address":"","ucode":"B4C27B8335B76A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/ee/872ad07e.jpg","comment_is_top":false,"comment_ctime":1591133690,"is_pvip":true,"replies":[{"id":"82408","content":"DI没有成为主流时，Java也已经很流行了，比如，J2EE。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591182117,"ip_address":"","comment_id":223579,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14476035578","product_id":100052601,"comment_content":"多半因为Java在企业级应用里独占鳌头，所以Java的DI更为人所知，也因为更早地出现了容器级的DI，Java才这么流行","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497173,"discussion_content":"DI没有成为主流时，Java也已经很流行了，比如，J2EE。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591182117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236347,"user_name":"Geek_f091d5","can_delete":false,"product_type":"c1","uid":1762584,"ip_address":"","ucode":"F48624826C47F2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/F7I06BSAsrkqVdz1gNogToKO1fria5iagU7icR6vM6qZDpz8wDHK6gFLXBgUKuI2QCZv39ylgmibZJw53hcK4LdeGQ/132","comment_is_top":false,"comment_ctime":1595394868,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10185329460","product_id":100052601,"comment_content":"也许是我理解有误，标题是模型的设计，内容怎么说起了依赖注入的实现，我认为也许应该从某一简单的业务着手，讲解针对该业务的错误的模型设计和正确的模型设计。<br>","like_count":2},{"had_liked":false,"id":228711,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1592792083,"is_pvip":false,"replies":[{"id":"84504","content":"打开盖子，才能看到细节。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1592905286,"ip_address":"","comment_id":228711,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10182726675","product_id":100052601,"comment_content":"跳出软件设计领域，像家具装潢（比如买沙发）等传统行业是可以找到对应概念的，但是相比软件设计复杂多；<br>客户期望只关注产品功能（对应模型），然而企业销售产品时往往揉入了很多客户并不想了解的产品实现细节比如加工工艺、材料源头等（杂糅模型和实现）；<br>这也算是造就了程序员的单纯吧😓","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499158,"discussion_content":"打开盖子，才能看到细节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592905286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223994,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1591252065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10181186657","product_id":100052601,"comment_content":"郑老师你好,文中模型感觉和我理解的模型不一样, 我觉得模型是软件内在的东西,是其独有的东西,是对问题域的建模.<br>拿spring DI来说,问题域是如何自动化对象的创建和组装<br>对问题域建模后,我们的模型由哪几部分组成,各部分之间怎么交互的,我认为这个是模型.至于文中提到的编程模型,我觉得理解成接口更加合适.<br>","like_count":2},{"had_liked":false,"id":223681,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1591155079,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"10181089671","product_id":100052601,"comment_content":"其实很早就听说过 Inversion of Control 和 Dependency Injection，但是似乎一直没有搞明白其中的概念，也没有机会有意识的去使用 DI（也许是用了，但是没有意识到）。<br><br>重读了 Martin Fowler 的长（旧）文，有一个疑惑，专栏里面的 Spring DI 是属于哪一种类型的 IoC，看上去比较像 type 1，Constructor Injection。<br><br>但是在 Martin Fowler 的文章里面说道 Spring 的开发者更推荐使用 Setter Injection（Spring 框架应该是同时支持这两种依赖注入方式的），不知道是因为框架的进展，改用了 Constructor Injection，或者只是局限于作者的这个例子。<br><br>结合专栏的内容，简单的了解了一下 Spring 中的 DI。<br><br>在 Ruby 中可以使用 dry-rb 实现依赖倒置 https:&#47;&#47;medium.com&#47;@Bakku1505&#47;introduction-to-dependency-injection-in-ruby-dc238655a278<br><br>但是 DHH 也说过，Dependency injection is not a virtue https:&#47;&#47;dhh.dk&#47;2012&#47;dependency-injection-is-not-a-virtue.html","like_count":2},{"had_liked":false,"id":223669,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1591153237,"is_pvip":false,"replies":[{"id":"82401","content":"为了方便，定义静态方法，到处调用，然后，没法 mock，不好测试。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591181749,"ip_address":"","comment_id":223669,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10181087829","product_id":100052601,"comment_content":"文中说“静态方法满天飞”是为了在实例方法中调用别的方法所以改为静态方法，是这样的意思吗","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497207,"discussion_content":"为了方便，定义静态方法，到处调用，然后，没法 mock，不好测试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591181749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2563584,"avatar":"","nickname":"Ronin","note":"","ucode":"1B8BCAC3A1EF06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367541,"discussion_content":"没法mock, 可以举个例子吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618389341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223641,"user_name":"Asanz","can_delete":false,"product_type":"c1","uid":1005200,"ip_address":"","ucode":"430AB7ED59EE3F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/90/be01bb8d.jpg","comment_is_top":false,"comment_ctime":1591147407,"is_pvip":false,"replies":[{"id":"82404","content":"当年，IoC、DIP和 DI几个名字争论了好久，最后决定叫了DI，这个几个词确实有很多类似的地方。其实，它们都是设计原则。后面讲设计原则的时候，还会提到DIP的。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591181917,"ip_address":"","comment_id":223641,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10181081999","product_id":100052601,"comment_content":"DI是模型？我理解的DI是一种实现，IoC是模型😂","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497196,"discussion_content":"当年，IoC、DIP和 DI几个名字争论了好久，最后决定叫了DI，这个几个词确实有很多类似的地方。其实，它们都是设计原则。后面讲设计原则的时候，还会提到DIP的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591181917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270077,"user_name":"Geek_8c790c","can_delete":false,"product_type":"c1","uid":1836819,"ip_address":"","ucode":"7561910D8E8642","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/69KUCz9tfaImVeVjOY4zVvWx2VDd77D9dcNicEcPY2yxUDTAMPeCudbCFAl0yuOHcMu3A5RoH58ZX1iaouF9EG7g/132","comment_is_top":false,"comment_ctime":1608894148,"is_pvip":false,"replies":[{"id":"98094","content":"通常来说，一个业务项目最基础的模型就是那些实体，然后是结构，就是你熟悉的controller或resource，service还有repository或mapper。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1609154762,"ip_address":"","comment_id":270077,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903861444","product_id":100052601,"comment_content":"&quot;我们肯定要先知道项目提供了哪些模型，模型又提供了怎样的能力。这是所有人都知道的事情，我并不准备深入地去探讨。&quot;确实不懂项目提供了哪些模型，有大佬解释下吗","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512511,"discussion_content":"通常来说，一个业务项目最基础的模型就是那些实体，然后是结构，就是你熟悉的controller或resource，service还有repository或mapper。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609154762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224394,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1591363391,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5886330687","product_id":100052601,"comment_content":"我感觉 老师文中讲的是 编程模型不是 一个项目的功能模型（功能建模或者 DDD领域建模）。 我认为在熟悉一个项目的时候，领域模型是首先要看的， 编程模型的选择只是为了 接口 或者 实现  提供基础 ","like_count":1,"discussions":[{"author":{"id":2016572,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c5/3c/d589ef4d.jpg","nickname":"蜗牛不会飞","note":"","ucode":"866F46E1FD8EE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284523,"discussion_content":"在spring DI 容器中，依赖注入就是业务模型，它的业务就是对象依赖的解耦呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592546921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224107,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1079657,"ip_address":"","ucode":"0335277F255F7A","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg","comment_is_top":false,"comment_ctime":1591276246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886243542","product_id":100052601,"comment_content":"读第二遍：模型和模型设计，按照上面所说，Spring DI容器就是一个模型，那好的模型是不是就可以说是一个模型设计呢？按照现在的理解，模型确实不是早期脑海中的类了，早期就觉得类就是模型，从现在看看远远不足呀，模型的具体定义有点模糊了，希望能一直跟下去，看完之后再过一边可能会学到更多的东西。","like_count":1},{"had_liked":false,"id":224101,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1079657,"ip_address":"","ucode":"0335277F255F7A","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg","comment_is_top":false,"comment_ctime":1591275335,"is_pvip":false,"replies":[{"id":"82532","content":"面向对象和面向过程只是用到了不同的设计元素，其实，使用程序设计语言完全可以兼顾二者，稍后，我会在编程方范式部分进一步讲解。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1591314034,"ip_address":"","comment_id":224101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5886242631","product_id":100052601,"comment_content":"我觉得是因为Java面向对象，更多的是使用组合解决问题，使用组合那就避免不了对象的依赖，加上接口实现分离，就更加依赖于DI，而像其他的语言，像面向过程全程使用函数来解决问题，貌似有点用不到对象的组合和创建。我的一点小理解，也不知道有没有问题。","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497365,"discussion_content":"面向对象和面向过程只是用到了不同的设计元素，其实，使用程序设计语言完全可以兼顾二者，稍后，我会在编程方范式部分进一步讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591314034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223609,"user_name":"宝宝太喜欢极客时间了","can_delete":false,"product_type":"c1","uid":1215152,"ip_address":"","ucode":"9CDB679C257612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoOGZ6lbHiboIZMN9USbeutnmCWBahVLtSlKlIENKvrZQCUQzpzeZQOxTntIkBUeDk6qZUPdqmfKrQ/132","comment_is_top":false,"comment_ctime":1591144025,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5886111321","product_id":100052601,"comment_content":"还是感觉模型是个很虚得东西，只可意会不可言传，能不能通过一种方式把他表现出来呢？比如图形？","like_count":1,"discussions":[{"author":{"id":1613919,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a0/5f/cf72d453.jpg","nickname":"小豹哥","note":"","ucode":"115FF45CAA6FAD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283467,"discussion_content":"文中的例子我觉得很生动啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592277762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361059,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"河北","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1667176986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1667176986","product_id":100052601,"comment_content":"理解模型要了解他的由来！","like_count":0},{"had_liked":false,"id":348573,"user_name":"我在黄浦江边","can_delete":false,"product_type":"c1","uid":1309842,"ip_address":"","ucode":"5855E03C7C6600","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIviaLGOXmibXUJdaytS1IWP4ia4DuglRuTLPHWo918U7EVHqDrqA1sAaF7stUhb5XuBc8kcHNSG351A/132","comment_is_top":false,"comment_ctime":1655203721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655203721","product_id":100052601,"comment_content":"问题是怎样去了解一个模型的来龙去脉，如果换个其他小众项目，如何才能了解，","like_count":0},{"had_liked":false,"id":345270,"user_name":"阿姐的阿杰","can_delete":false,"product_type":"c1","uid":1001156,"ip_address":"","ucode":"89F5CF4D1E0C2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/c4/128338f8.jpg","comment_is_top":false,"comment_ctime":1652165754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652165754","product_id":100052601,"comment_content":"有一个疑问一直没想明白：相同接口的不同实现类在实际开发中动态切换，如果是通过注解的方式指定具体实现，那不管是在调用端的注解还是实现端的注解，都还是至少有一处需要修改源代码来通过 byName 方式调用，这样就没法做到开闭原则。这个怎么处理好呢？","like_count":0},{"had_liked":false,"id":345062,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1651996426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651996426","product_id":100052601,"comment_content":"理解模型，要了解模型设计的来龙去脉。--记下来","like_count":0},{"had_liked":false,"id":339182,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1647959120,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647959120","product_id":100052601,"comment_content":"spring是solid原则的践行者","like_count":0},{"had_liked":false,"id":337564,"user_name":"云会宾","can_delete":false,"product_type":"c1","uid":2696335,"ip_address":"","ucode":"8DFC2DD03D7E51","user_header":"https://static001.geekbang.org/account/avatar/00/29/24/8f/77140e34.jpg","comment_is_top":false,"comment_ctime":1646895620,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646895620","product_id":100052601,"comment_content":"也就是说容器的出现其实就是接口的发展？","like_count":0},{"had_liked":false,"id":317384,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1634781473,"is_pvip":false,"replies":[{"id":"115149","content":"好吧，这是我做得不够好的地方","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1634895032,"ip_address":"","comment_id":317384,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634781473","product_id":100052601,"comment_content":"原来DI容器解决的是组件创建和组装的问题！终于明白了！老师的课程内容非常优秀，就是课程名字没有《设计模式之美》拉风，比较偏学术风格，吓的我不敢看，以为会枯燥乏味，所以购买很久都没看。无意间看了一下，内容精彩，停不下来，收货很大！感谢老师！","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528793,"discussion_content":"好吧，这是我做得不够好的地方","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634895032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289770,"user_name":"林铭铭","can_delete":false,"product_type":"c1","uid":1068499,"ip_address":"","ucode":"AB392BEE7CD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/d3/67bdcca9.jpg","comment_is_top":false,"comment_ctime":1619169868,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619169868","product_id":100052601,"comment_content":"一个好的模型就是一个可扩展的解决方案！","like_count":0},{"had_liked":false,"id":240044,"user_name":"butterfly","can_delete":false,"product_type":"c1","uid":1392924,"ip_address":"","ucode":"1B724973303FB0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rRCSdTPyqWcW6U8DO9xL55ictNPlbQ38VAcaBNgibqaAhcH7mn1W9ddxIJLlMiaA5sngBicMX02w2HP5pAWpBAJsag/132","comment_is_top":false,"comment_ctime":1596725295,"is_pvip":false,"replies":[{"id":"88636","content":"是不是提取一个接口，就是项目的约定了。后面讲到过一个观点，如果你不提取接口，你的实现类本质上就扮演了接口的角色。<br><br>我的项目中，往往是定义一个接口，却不用写实现，由框架替你处理。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1596753554,"ip_address":"","comment_id":240044,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596725295","product_id":100052601,"comment_content":"我了解需要面向接口编程，编码时很少写过DAO层的interface：ArticleRepository， 常常是直接写实现. 如果DAO层使用的底层是确定的，是否需要先写接口，再写该实现?<br>","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503317,"discussion_content":"是不是提取一个接口，就是项目的约定了。后面讲到过一个观点，如果你不提取接口，你的实现类本质上就扮演了接口的角色。\n\n我的项目中，往往是定义一个接口，却不用写实现，由框架替你处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596753554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236351,"user_name":"Geek_f091d5","can_delete":false,"product_type":"c1","uid":1762584,"ip_address":"","ucode":"F48624826C47F2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/F7I06BSAsrkqVdz1gNogToKO1fria5iagU7icR6vM6qZDpz8wDHK6gFLXBgUKuI2QCZv39ylgmibZJw53hcK4LdeGQ/132","comment_is_top":false,"comment_ctime":1595395926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595395926","product_id":100052601,"comment_content":"也许是我理解有误，这篇文章好像是打算以java中的类为例子讲模型，但是在讲解过程中，着重于讲java类的特征而忽视了本应该抽象于具体语言的模型的特征。","like_count":0},{"had_liked":false,"id":226108,"user_name":"轧钢机.Net","can_delete":false,"product_type":"c1","uid":1625322,"ip_address":"","ucode":"CD63BF8BC19ABB","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/ea/0ccc5091.jpg","comment_is_top":false,"comment_ctime":1591952784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591952784","product_id":100052601,"comment_content":".net core 都自带DI","like_count":0},{"had_liked":false,"id":223836,"user_name":"行与修","can_delete":false,"product_type":"c1","uid":1241842,"ip_address":"","ucode":"11F21B663EF6D3","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/f2/2a9a6e9a.jpg","comment_is_top":false,"comment_ctime":1591193714,"is_pvip":false,"replies":[{"id":"84632","content":"对，只有脑子里面有一个该怎么做的主线，才不会被各种语言带偏了。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1592968698,"ip_address":"","comment_id":223836,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591193714","product_id":100052601,"comment_content":"我觉得可能是用的太浅吧，或者把发挥的空间就留给了一小部分人，所谓的上手快，形成的优质案例不多影响也不大。编程思想是跨语言层面的，比如说java实现的用其它高级语言也能实现，要我说都是用的人的问题。人的因素很大，比如C++也可以不写成多继承啊，不能因为语言层面没有禁止就说是语言设计的不好是吧～","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497257,"discussion_content":"对，只有脑子里面有一个该怎么做的主线，才不会被各种语言带偏了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592968698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}