{"id":741065,"title":"第 10 章 架构设计思路和要点","content":"\n<p>前 9 章介绍了分布式系统对于应用服务的拆分、调用、协同、计算、存储、调度、监控等，让我们从整体上对分布式系统有了了解。当我们遇到分布式系统相关的问题时，可以根据前面讲到的原理和实践去处理。不过对于分布式架构设计而言，除了需要了解这些原理和实践以外，还需要对架构设计的思维有所涉猎。比如一个合格的架构师如何看待架构设计，哪些常用的设计模型能够帮助我们思考，在面对现成架构体系时如何实现代码重构、性能测试与压力测试，以及如何规划自己的学习和发展线路，这些都是架构师在成长之路上会遇到的问题。本章就围绕着这几个问题展开，希望能对前 9 章的学习内容起到锦上添花的作用。本章将会讲解以下内容。</p>\n<ul>\n<li>架构设计思维方式</li>\n<li>重构与测试</li>\n<li>学习与发展</li>\n</ul>\n<h2 id=\"nav_point_188\">10.1　架构设计思维方式</h2>\n<p>说起架构设计，想必大家都能侃侃而谈，都有自己的一套看法。实际上设计思维早在软件还没有出现的时候就已经存在了，比如建筑设计、艺术设计等。这里我们想探讨一下，设计模型的思维是否能给我们的架构设计带来一些帮助和启发。在思考架构设计之初，我花了大量时间回忆之前搭建架构的经历，并尝试从这些经历中总结出有价值的东西，直到阅读了《设计原本》这本书，发现其中的一些观点很有借鉴价值。后面的讲解以架构师的设计模型为切入点，先介绍设计模型的由来，然后逐步介绍过程设计模型、协作式设计模型和扩展立方设计模型。</p><!-- [[[read_end]]] -->\n<h3 id=\"nav_point_189\">10.1.1　架构师的设计模型</h3>\n<p>Frederick P. Brooks. Jr. 在其《设计原本》一书中对设计进行了定义，他将设计分为 3 个阶段，如图 10-1 所示，其内容按照顺序分别如下。</p>\n<ul>\n<li><strong>构想</strong>：这是根据目标形成的概念，它虽然看不见摸不着，却可以满足我们的产品或者服务需求，而且这个概念往往存在于设计者的大脑中。</li>\n<li><strong>实现</strong>：真实存在的产品或者服务。这个东西看得见摸得着，是一个真实的交付物，能够为人们提供产品或者服务，满足人们的需求。</li>\n<li><strong>交互</strong>：人们与实现的具体产品或者服务进行互动，并产生一些使用体验。例如产品经理提交产品原型给客户，客户根据与原型的交互结果提出修改意见。又例如一个真实的 App 上线后，用户会对其功能评头论足。通过交互形成反馈以后，又会进入构想阶段。如此这般周而复始，可以看出设计是一个不断迭代的过程，其 3 个阶段本身具有先后顺序，又互为依赖。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00607.jpeg\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-1　设计包括构想、实现和交互这三个阶段</strong></p>\n<p>了解了设计的定义，再来看看其价值。很多项目在获取用户需求以后，架构师想到的是先建立数据库，再把功能实现起来。结果几个“大神”就开始了牛仔式的编码之路，这种开发方式看上去高效快捷，让人不禁联想到“敏捷”一词。但是随着项目的推进和用户需求的增加、功能的增加、开发人员的增加，我们会发现这样开发起来是没有方向的，公用功能没有整理抽象，网络调用协议千人千样，负责维护代码的同事需要忍受各种风格的开发方式，等等。诸如这些问题都是由于没有经过设计，这里的设计不仅包括软件架构设计、编码规范设计、单元测试规范设计，还包括数据库设计、系统设计、网络安全设计等。设计就是开发过程的指路明灯，旨在帮助开发团队提高开发效率、帮助投资人高效地拿到交付物，因此对于架构设计师而言，设计是一个理性的过程，需要通过理性模型将杂乱无章的函数、接口、方法、数据库表，根据结构化的思维模型转换为一个有机的整体。在这个结构化的整体中，需要定义接入层、微服务、缓存、队列、数据库和安全组件之间的关系，以及它们之间的协作方式。架构设计师的理性模型如图 10-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00608.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-2　架构设计师的理性模型</strong></p>\n<p>既然设计这么重要，那么我们在进行设计的时候，特别是进行软件架构设计的时候是否有规律可循呢？答案是“有”。理性思维模型包括以下几个方面。</p>\n<ul>\n<li><p><strong>目标</strong>：这个很容易想到，目标就是用户价值，是架构师努力的方向，也是开发一个软件的原因。如图 10-3 所示，客户、交付团队以及资源都会指向同一个目标。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00609.jpeg\" alt=\"\" width=\"43%\" style=\"width: 43%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-3　客户、交付团队和资源的目标保持一致</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>必要条件</strong>：有了目标，便会有与之对应的交付物，此时就需要必要条件作为支撑。如图 10-4 所示，必要条件包括硬件条件和软件条件，例如服务器、数据库、中间件、第三方组件、开发人员、测试人员、项目经理和产品经理。这里我们也可以将必要条件理解为需要的资源。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00610.jpeg\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-4　必要条件对交付物起到支撑作用</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>加权效果值</strong>：根据必要条件在系统中的重要程度、紧急程度以及成本，我们通过打分的方式评估哪些必要条件是需要专门提高的，哪些是需要放弃的。如图 10-5 所示，针对第三方组件这个必要条件，从重要性、紧急性、成本这三个维度分别定义了权重，可以根据定义的权重得到最终的加权效果值。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00611.jpeg\" alt=\"\" width=\"95%\" style=\"width: 95%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-5　必要条件的加权效果值</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>约束条件</strong>：如果说必要条件是达成目的所需的资源，那么约束条件就是让我们知道任何软件交付所需要的资源都不是无限的，都会有一个限制条件。例如项目完成的时间点、需要用到的服务器数量、数据库的存储大小、所需的开发人员和测试人员的数量，这些都是用来制约或者考核项目的标准。</p>\n</li>\n</ul>\n<p>了解了设计是何物以后，作为架构师的我们需要通过理性的思维模型构建软件架构，并将这种思维模型定位于目标、必要条件、加权效果值和约束条件。</p>\n<h3 id=\"nav_point_190\">10.1.2　过程设计模型</h3>\n<p>上一节介绍了设计模型，它可以帮助架构师厘清思路。在软件的设计过程中，架构师可能会遇到各种各样的问题。这时候一般会从业务入手，利用技术解决方案满足业务的需求。那么在设计软件的时候，是否有一定的套路或者一定的思维模式可以遵循呢？当然是有的。接下来，我们将介绍 3 种过程设计模型，希望能给大家带来一些启发。</p>\n<p>过程设计模型的主要思想是把抽象的概念反映成现实。它必须满足三方面的要求，如图 10-6 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00612.jpeg\" alt=\"\" width=\"43%\" style=\"width: 43%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-6　过程设计模型的要点</strong></p>\n<ul>\n<li><strong>探索演化</strong>：过程设计模型认为设计过程是不断探索和演化的，任何需求和设计都不可能一蹴而就。这也印证了程序员小步快跑的思想，边想边做、边做边改，越来越完善。</li>\n<li><strong>观念同步</strong>：由于参与架构设计的利益相关者比较多，有客户、项目经理、产品经理、架构设计师、程序员、测试人员、运维人员等，因此，需要在软件观念上让这些人保持同步，也就是让大家对同一个问题保持一致的认知。第 2 章讲的通用语言就是为了实现这个目的。</li>\n<li><strong>达成合同</strong>：无论是探索演化还是观念同步，最终目的都是让产品的交付者和使用者达成合同。</li>\n</ul>\n<p>下面介绍 3 个过程设计模型，分别是共同演化模型、Raymond 的集市模型和 Boehm 的螺旋模型。</p>\n<ul>\n<li><p><strong>共同演化模型</strong>。这个模型是对需求进行递进式探索的过程，也是发现问题和解决问题不断交织的过程。该模型最早由 Maher、Poon 和 Boulanger 提出，其思想是让构造问题和解决问题同时进行，两者互为辅助和参照，不断迭代和演化。架构师在设计某个产品或者架构的时候，为了解决一个问题，通常会引入新的问题。随着对问题认知度的提高，解决问题的方式也变得更全面、更深入。这种模型既可能由设计师单独完成，也可能由设计师、用户和开发人员在不断的交互过程中协作完成。在把抽象概念具体化到问题时，就可以使用这种模型，尤其是系统级别的应用，需要考虑的问题越多、涵盖范围越广，越会用到这个模型。系统级别的应用包含软件架构、硬件设备、第三方集成等。如图 10-7 所示，把共同演化模型理解为需求层面和技术层面的对话，用户不断地发现问题，架构师、产品经理不断地解决问题，响应用户的需求。发现问题和解决问题既可以在不同层面串行展开，也可以并行展开，在不断演进的过程中逐步完善。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00613.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-7　共同演化模型</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Raymond 的集市模型</strong>。这个模型是 Eric Steven Raymond 在 <em>The Cathedral and the Bazaar</em> 一书中提出的观点，其主要思想是通过开源的方式推进软件设计的发展。对此可以举一个例子，如图 10-8 所示，在设计池（开源社区）中，一位设计贡献者（开发人员）为了解决一个问题开发了一个组件，并且将这个组件上传到了设计池。其他设计贡献者发现这个组件很好用，就用到自己的项目中。随着使用次数的增加，组件存在的问题被挖掘出来，于是有些设计贡献者开始对这个组件进行优化，同时把优化结果分享给其他人员。经过这种击鼓传花式的打磨之后，组件变成一个可以被更多人使用的通用组件。这就是 Raymond 的集市模型要达到的目的，通过多个“设计师”基于不同场景的反复打磨，得到最终的产品或者服务。在一些软件的开源设计中，经常能够看到这种模式的身影，例如一个大厂设计出一套开源框架，为了打磨这套框架，便将其放到开源社区，让更多的企业看到并应用，而企业在应用的过程中势必会对框架进行修改，这个修改的过程就是框架演化的过程。这种模式下，由于多方人员会对同一产品或者服务进行迭代，因此需要把控迭代的内容和使用场景。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00614.jpeg\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-8　Raymond 的集市模型</strong></p>\n<p>Raymond 的集市模型可以应用于大型系统的开发，该模型通过不断扩张组件的方式逐渐填充整个系统，例如 Linux。设计贡献者同时也是设计的使用者，他们在不断满足自身需求的前提下推动软件架构向前发展。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Boehm 的螺旋模型</strong>。这个模型是 Barry Boehm 于 1998 年提出的，也是过程设计模型的一种形式。其实这种形式很像原型设计法，即借助可以运行的原型界面与用户产生互动。产品经理将需要设计的产品以原型的方式展示给用户，这些原型除了包括功能界面，还具有基本的交互功能。用户通过原型对产品进行体验或者测试，并将结果反馈给设计师，设计师对原型做改进，这样一直循环，逐渐逼近最终的产品。图 10-9 是 Boehm 的螺旋模型的示意图，其驱动原动力来自设计师，终点是用户，用户的反馈又会帮助设计师完善产品原型，从而将产品原型从 1.0 版推向 2.0 版。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00615.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-9　Boehm 的螺旋模型</strong></p>\n<p>除了上面那种情况，还有一种是产品团队根本就不知道用户需要什么样的产品，用户自己也不知道，而且产品团队没有足够多的时间和资源去做一个可交互的原型给用户。这时可以设计一些毛坯页面，页面上含有基础功能，但这些功能是没有实现的。当用户点击这些功能的时候，通过日志将用户的使用轨迹，即用户行为记录下来，然后把使用轨迹多的功能视为用户需要的，并根据这些功能进行针对性的开发。这种模型在互联网设计中比较常见，因为互联网设计讲究时效性和用户体验。采用这种方式可以用最少的成本和最短的时间快速试错，缩短整个产品的生命周期，做到快速迭代，如图 10-10 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00616.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-10　利用毛坯页面实现快速迭代</strong></p>\n</li>\n</ul>\n<h3 id=\"nav_point_191\">10.1.3　协作式设计模型</h3>\n<p>随着互联网的发展，业务功能越来越复杂，技术架构需要满足变化多端的业务，同时还要兼顾可用性、高性能、扩展性、伸缩性，实属不易。以前的系统只要一个架构师就能完成，现在系统复杂了，接口多了，承载的业务量也大了，架构设计需要考虑的因素也跟着多起来了，此时便需要引入团队，这就是协作式设计模型存在的意义。</p>\n<p>在第 1 章中曾提到，以前的系统只要一个数据库加一个桌面应用程序就可以搞定。现在的系统不仅要满足高并发的特性，还要实现高可用、可伸缩，因此对内要对微服务进行水平扩展、对数据库进行分表分库，对外要接入 Web、H5、Android、iOS，甚至各个企业级别的第三方接口。其复杂性远超之前的应用系统，因此有了团队设计的概念。团队由软件架构师、系统架构师、用户体验师、安全顾问组成，这些人协作设计出来的架构相对而言功能更加全面。这里将协作式设计模式的要点总结为如下几方面。</p>\n<ul>\n<li><p><strong>快速推向市场</strong>。以前的系统开发可谓四平八稳，按照瀑布模型推进，而现在的市场瞬息万变，技术架构必须跟上这个高速发展的时代才行。这时如果发挥团队的力量，将设计切分成一个个小的任务，推进速度自然会加快。如图 10-11 所示，按从左往右的方向看，在获得需求文档以后，将其拆分成多个 Backlog，再把每个 Backlog 拆分成多个 UserStory（用户故事），针对 UserStory 去建立开发任务，然后把任务放到迭代计划中，此时再引入架构的具体工作，通过编码、需求澄清、集成测试、测试用例编写不断推进迭代计划的实施。在经过数周的迭代之后，软件才能发布上线。这种方式使大块的需求逐渐细化，并且团队成员都能参与进来，共同完成交付任务。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00617.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-11　快速迭代帮助产品快速推向市场</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>团队协助架构设计的成本</strong>。团队成员参与设计的过程中必定会产生成本，我们需要关注以下两类成本。</p>\n<ul>\n<li><p><strong>任务分割成本</strong>：把一整块设计任务分割成多个小的设计任务时，就存在任务分割成本。分割的时候需要明确每个小任务负责完成的范围、程度、输入和输出；需要让参与设计的各成员做好设计对接，保证没有错误的理解，没有遗漏的任务。通常来说，产品人员获取用户需求后，会将其转化为产品需求。如图 10-12 所示，架构师会根据产品需求生成架构设计需求，然后切分架构任务，最终形成架构设计模块。如此细致的切分，目的是让架构工作更加清晰、准确，但是与此同时带来的副作用也很明显，就是切割成本的上升。由于任务分割的过程相对重要，建议由产品经理、系统架构师、软件架构师、安全顾问等组成专家小组，在固定时间内（例如 1~2 天）进行整体评估，得到纲领性的结果。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00618.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-12　架构设计切割</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>学习成本</strong>：参与设计的团队成员需要了解和学习其他领域的知识，例如软件架构师需要了解用户交互知识，系统架构师需要了解安全领域的知识，此时架构设计师、系统设计师、系统安全设计师以及用户体验设计师需要加强沟通协作，如图 10-13 所示。可以通过交流会议或者在线文档的方式，把大家拉到同一层面上进行交流，将专业术语和知识以文档的方式固化下来，并在团队中形成共识，从而降低学习成本。此外，也可以把各领域的设计师聚集到同一个实体空间中，降低沟通成本，提高设计效率，在最短的时间内达成一致。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00619.jpeg\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-13　架构设计师、系统设计师、系统安全设计师和用户体验设计师之间的沟通</strong></p>\n<p>&nbsp;</p>\n</li>\n</ul>\n</li>\n<li><p><strong>如何开展团队协作架构设计</strong>？了解相关人员的需求和愿望。这需要市场人员或者业务人员的参与，需要明确应用是为了解决业务上的什么问题而开发的，或者业务能带来什么收益。在开展团队协作架构设计时，需要关注以下几点。</p>\n<ul>\n<li><strong>建立目标</strong>：给团队定义一个可以量化的目标，比如功能范围、系统参数指标（并发数、在线用户数）等，这在审核设计的时候是一个重要的参考标准。指标型的目标通常会一直贯穿在产品或项目的整个生命周期中，团队参考这些目标构建架构。</li>\n<li><strong>概念探索</strong>：这步实际上是确定架构设计的边界，通过不断的头脑风暴和归一化，确定系统设计的范围，让所有参与者达成共识。这里的边界是根据业务需求划分的，也可以参考第 2 章的内容根据领域进行划分。这部分需要描述每个领域完成的功能，包括哪些功能需要实现、哪些不需要实现。</li>\n<li><strong>设计审核</strong>：架构设计的结果应该包括设计图纸（架构图）和设计范围描述，甚至可以展示某些核心功能的原型。由业务部门、管理者或外部顾问组成的评审小组负责对每个产出物打分，按照 RASCI 的原则来评估一个设计是否能投入实施。RASCI 由几个单词的首字母组成，具体内容如下。<ul>\n<li class=\"第3级无序列表\">R（Responsible）：负责，对设计负责的人。</li>\n<li class=\"第3级无序列表\">A（Accountable）：批准，指关键设计决策的审批者。</li>\n<li class=\"第3级无序列表\">S（Supportive）：支持，指支撑设计并且提供资源的人。</li>\n<li class=\"第3级无序列表\">C（Consulted）：咨询，指为设计提供相关信息的人。</li>\n<li class=\"第3级无序列表\">I（Informed）：知情，指需要了解的相关者。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"nav_point_192\">10.1.4　扩展立方设计模型</h3>\n<p>在架构设计初期，会遇到诸如服务、流程、服务对象的问题。针对这些问题，我们可以通过“扩展立方”协助思考。另外在公司发展的不同阶段，也可以借助这个思路找到突破口。</p>\n<p>在介绍扩展立方之前，我们先介绍一下设计架构的时候需要关注的几个点：客户是谁（服务对象），需要交付什么给客户（服务），交付内容是如何组织的（流程）。如图 10-14 所示，把这 3 个点用 3 个坐标轴表示，分别为 <em>x</em> 轴（服务）、<em>y</em> 轴（流程）和 <em>z</em> 轴（服务对象）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00620.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-14　服务、流程、服务对象形成的扩展立方</strong></p>\n<p>如果说在坐标轴的原点处，上述 3 点所做的扩展都是零，那么随着向 3 个坐标轴的正方向延伸，这 3 点就是在不断扩展，最终呈现为一个类似立方体的东西，这个东西就是我们要讨论的扩展立方。大家可以回想一下，自己在做架构设计的时候，是否都是依葫芦画瓢，按照已有的业务逻辑设计一套可以实施的软件系统。殊不知随着业务的发展，软件系统也会不断扩展，大多数架构师忽略了这个扩展性，想的都是先解决眼前的问题，等业务发展了再修改架构。其实，通过扩展立方的思维方式可以弥补这方面的不足，可以实现预见性，为未来的扩展留下接口，这对于架构设计和公司未来的业务扩展非常有帮助。</p>\n<p><em>x</em> 轴的服务扩展，可以用一个例子解释。如图 10-15 所示，假设电商网站的订单业务比较多，需要承载较高的并发量，原来的“单个订单服务”已经无法满足需求，这时我们可以通过横向扩展的方式增加更多订单服务。增加后的这些订单服务在本质上其实没什么不同，都是原有订单服务的副本。通过对服务进行横向扩展（水平扩展）来应对高并发的行为就是在做服务扩展。能够进行扩展的服务都有这样的特点：业务本身较为独立，功能不是很复杂，可以独立管理。架构师在设计初期，可以通过了解业务，识别这部分服务，然后对其做横向扩展。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00621.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-15　<em>x</em> 轴服务扩展</strong></p>\n<p><em>y</em> 轴的流程扩展，同样也用一个电商的例子解释。假设商品的整个购买流程包括浏览商品、加入购物车、下单、付款、发货、确认收货这几个步骤，每个步骤都完成一个标准的动作，所有动作串联起来形成一个完成的流程。我们可以把中间那些能够被重复使用的步骤抽离出来，形成通用组件，例如浏览商品、付款、发货，通用组件可以作为基础服务供其他业务服务调用。流程扩展就是做这个事情的。实际上，面向对象设计中的抽象做的也是这个事情，说得再通俗一点，现在的中台服务就是把企业的那些基础服务提供给业务服务使用。架构师可以在设计初期把这部分考虑进去，针对不同的服务分别定义好接口，方便日后“搭积木”。流程扩展的示意图如图 10-16 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00622.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-16　<em>y</em> 轴流程扩展</strong></p>\n<p>在实际的应用开发过程中，<em>z</em> 轴的服务对象扩展会有来自各个方面的请求，例如北京用户请求系统、上海用户请求系统、广州用户请求系统，或者 5000 人规模的企业请求系统、500 人规模的企业请求系统。事实上，针对不同的请求类型、不同地区的请求系统、不同访问量的请求系统，可以设计不同的系统边界，分配不同的软硬件资源，甚至用故障隔离的思路设计系统。比如向企业客户提供服务时，需要了解这个企业用的是私有云还是公有云，这个企业在中国乃至世界有哪些分公司，总公司和分公司如何共享数据和请求，是否需要对不同区域的公司提供不同访问量的服务等问题。</p>\n<p>在扩展立方的设计原则中，通常 <em>x</em> 轴的扩展成本相对较低，可以马上看到效果，比较适合刚刚起步的企业。<em>y</em> 轴的扩展成本就略高了，需要设计师对流程本身理解得比较透彻，并且是经过长时间磨炼的，最好是架构师和业务专家共同定义流程基础组件。公司发展到一定规模时，才会建立自己的流程，比如中台系统。<em>z</em> 轴的扩展成本更高，需要针对不同的客户区域、请求类型、访问量设计对应的系统，对硬件和软件的要求都很高，比较适合大型的企业和互联网公司，比如阿里、腾讯在中国各地甚至世界各地都有机房。可以自行根据公司规模和发展方向酌情设计架构，做到因地制宜、因人而异。当然，在设计方面，我们希望 <em>x</em>、<em>y</em>、<em>z</em> 三个扩展方向是齐头并进的，哪个快一些、哪个慢一些取决于公司所在的环境和发展速度。</p>\n<h2 id=\"nav_point_193\">10.2　重构与测试</h2>\n<p>上一节描述的是架构设计的思维方式，并没有涉及具体的架构，都是一些抽象的概念。这一节依旧从思维方式入手，描述代码重构与测试。其实在日常的架构开发过程中，设计师都免不了接触这两方面的内容，但是在真正执行的时候又不知如何下手，这里同样给大家介绍一些思路，仅供参考。</p>\n<h3 id=\"nav_point_194\">10.2.1　代码重构</h3>\n<p>业务量的增加一般会导致系统架构的代码量增加，代码暴露的问题也随之增多。原来为了抢着上线在代码中留下的坑，终于要自己填了。为了提高代码质量，让业务走得更远，设计师加大了代码审核和重构的力度。我总结了几点自己的经验，同时借鉴了同行的做法，这里给大家分享一下。</p>\n<ul>\n<li><p><strong>何时重构是一个有趣的问题</strong>。通常，在我们开始编码的时候，就应该对代码架构和组件模型进行设计。但是由于种种原因，基本上采取的都是牛仔式编程，即想到哪里就写到哪里，之后踩了坑才明白应该时刻对代码进行重构。针对这一点，我总结了以下几个方面。</p>\n<ul>\n<li><p><strong>事不过三原则</strong>：如图 10-17 所示，在你第 1 次写代码实现某业务功能的时候，没有做设计，姑且就这么写了；第 2 次遇到相似的功能，发现这个功能之前好像用过，于是又写一遍；第 3 次又遇到了同样的功能，这时就要告诉自己需要重构了。这个原则有大量的应用场景，特别是开发应用时，遇到一些通用的业务组件或者系统组件抽取的时候。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00623.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-17　事不过三原则</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>添加功能时重构</strong>：当你往旧模块里添加新功能的时候，发现这个新功能原来可以由几个原有功能组合完成，但是那几个原有功能的通用性不太好，于是重构原有功能，让其具有更强的复用性，如图 10-18 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00624.jpeg\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-18　添加功能时重构</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>修复 bug 时重构</strong>：程序员在修复完 bug 之后，往往会有非常深的满足感。如果在修复以后能分析一下 bug 出现的原因，检查一下其他地方是否也存在相同的 bug，是否能够通过通用组件抽取的方式彻底解决 bug，那么代码重构就显得非常有意义了，如图 10-19 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00625.jpeg\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-19　修复 bug 时重构</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>审核代码时重构</strong>：这在极限编程和结对编程中比较多见。一个程序员写代码，另一个程序员审核代码，二人教学相长，共同进步。不同的人拥有不同的背景、思路以及理解深度，因此协作编写同一段代码会使代码显得更加立体，此时的重构是高效的，如图 10-20 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00626.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-20　审核代码时重构</strong></p>\n</li>\n</ul>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>重构难题</strong>。在实施重构的时候，往往会遇到一些具体的问题，这里也给大家总结一下。</p>\n<ul>\n<li><p><strong>数据库重构</strong>：数据库的结构通常在项目建立初期就确立了，因此想要改变数据库的结构简直是难上加难。如图 10-21 所示，聪明的程序员通常会在数据库和业务层之间加入一个中间层，也有人称之为 Mapping，可以保证业务层的数据结构发生变化时，无须修改数据库的结构也能完成调整。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00627.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-21　在业务层和数据库之间加入中间层</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>接口与实现</strong>：我们在做架构设计的时候，通常会给每个模块都设计一个接口，这个接口定义了各模块相互调用时遵守的契约，所有模块和组件都必须遵守这个契约。如图 10-22 所示，在进行重构的时候，显然是不需要修改这些接口的（牵扯的修改范围较大）。定义好业务接口以后，它会供给业务模块调用。假如此时该业务接口对应的是业务实现 1，如果需要重构，那么在保证业务不变的情况下，将原来的业务实现 1 替换为业务实现 2 即可。对于调用者来说，接口是没有变的，但是具体的实现方式已经被重构了。这种情况下我们是对接口对应的实现做了重构，这样就保证了接口不变、调用不变，而具体的实现得到了优化。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00628.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-22　针对接口的实现进行重构</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>重构不如重写</strong>：遇到大量逻辑复杂的代码时，如果要求重构，就需要花费大量的时间去阅读业务逻辑，并且理解这个模块与其他模块是如何协同工作的，这个工作量是相当大的。这时重新设计往往比重构要简单很多。</p>\n</li>\n<li><strong>项目进行到后期</strong>：项目进入尾声，单元测试、功能测试、集成测试基本都完成了，此时的重构风险很高。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"nav_point_195\">10.2.2　性能测试与压力测试</h3>\n<p>谈到测试，很多开发人员会认为这是测试人员的事情。其实不然，一个良好的应用测试应该是研发人员、测试人员、项目管理人员，甚至公司高层共同关心的事情，因为测试和所交付软件产品的质量息息相关。有测试作为基础，才能从软件和硬件两个角度对整个系统进行有效的调整。传统测试包括开发人员和测试人员共同完成的部分，具体内容如下。</p>\n<ul>\n<li><strong>单元测试</strong>：开发人员编写完代码以后，针对具体的功能进行小范围的逻辑和技术测试。</li>\n<li><strong>集成测试</strong>：针对多个模块和组件进行的测试。主要用来判断模块或者服务之间的调用是否正确。</li>\n<li><strong>系统测试</strong>：将通过集成测试的组件或者服务放到整个系统中进行测试，此时的测试主要围绕主要功能点和业务闭环完成。</li>\n<li><strong>端到端测试</strong>：将系统部署到和正常生产环境类似的场景中做测试，模拟用户使用的客户端和用户行为。此时的测试除了包括系统测试中的功能，还要模拟实际场景中发生的情况，例如高并发的请求，或者网络、数据库异常等。</li>\n</ul>\n<p>实际上，一个系统在开发完成后，就应该已经通过了前面 4 个阶段的测试，从功能角度讲是没有问题了。接下来要做的是模拟高并发场景，对系统中一些服务（例如商品查询、商品订单）进行性能和压力测试。</p>\n<p>性能测试要解决的是系统提供的资源每秒能够承受多少并发数，得到这个并发数后，将其作为系统的基准线。压力测试是在这条基准线上加大压力，看达到多少并发数的时候，系统会濒临崩溃。</p>\n<ol>\n<li><p><strong>性能测试</strong></p>\n<p>性能测试针对的是目标应用或者目标系统的速度、吞吐量，还有设备或者硬件的有效性。说白了，就是看应用或者系统是否达到了设计之初定的预期效果。如果给系统设计打分，满分是 100，那么性能测试就是看应用或者系统是否达到了最基本的可用预期，即及格分数 60。</p>\n<p>图 10-23 演示了执行性能测试需要经历的几个阶段——标准、环境、定义、执行、分析、报告、验证，这些阶段形成一个闭环。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00629.jpeg\" alt=\"\" width=\"53%\" style=\"width: 53%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-23　性能测试经历的阶段</strong></p>\n<p>下面展开描述上述的 7 个阶段。</p>\n<p>第一，标准，即建立测试标准。假如我们给开发的系统在规定时间内能够支持多少并发数定了一个标准，比如 5000 个/秒，那么定义这个目标的依据是什么呢？如图 10-24 所示，通常是通过对系统运行的历史数据进行归纳总结，获得标准。对于新建的系统，还可以根据同行参考数据和业务量估算得到标准。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00630.jpeg\" alt=\"\" width=\"57%\" style=\"width: 57%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-24　建立性能测试的标准</strong></p>\n<p>第二，环境，即建立测试环境。如图 10-25 所示，最理想的情况是测试环境和真实生产环境一模一样，但测试环境很难达到生产环境的配置，因为需要动用大量的服务器资源。我们可以使用折中的办法，根据生产环境中服务器资源的 1/2、1/4、1/8 的配置来设置测试环境，再将测试结果按照 2、4、8 的倍数放大。当然，还需要考虑设备增多以后的通信损耗问题，所以对最后的结果再打一个折扣。在这样的测试环境中得到的预估效果和从真实生产环境得到的效果已经差不了多少了。不过对于秒杀系统而言，最好是获取真实生产环境中的用户和访问数据，并且搭建一个和生产环境一模一样的环境进行测试。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00631.jpeg\" alt=\"\" width=\"67%\" style=\"width: 67%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-25　建立测试环境</strong></p>\n<p>第三，定义，即对测试进行定义。如图 10-26 所示，有以下 5 种测试。</p>\n<ul>\n<li><strong>耐久性测试</strong>：适用于访问量不大但是持续时间长的场景，例如浏览商品信息。</li>\n<li><strong>负载性测试</strong>：适用于瞬时访问量大但是持续时间不长的测试场景，例如限时秒杀。</li>\n<li><strong>场景测试</strong>：针对特殊场景的测试。例如，4G 信号不佳的时候，就降级到 3G 信号，测试这个时候的用户访问情况；又如测试离线状态下的信息访问。</li>\n<li><strong>部件测试</strong>：针对核心功能的测试，例如电商系统中的订单服务。</li>\n<li><strong>系统测试</strong>：考虑整个系统闭环的测试。</li>\n</ul>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00632.jpeg\" alt=\"\" width=\"78%\" style=\"width: 78%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-26　定义测试</strong></p>\n<p>以上这些测试都需要根据具体的测试场景，写出测试用例以及需要的数据。这一步的数据要尽量使用生产环境中的。</p>\n<p>第四，执行，即执行测试。测试有很多具体的执行方法。图 10-27 就是一种常用的测试套路，每次发布完毕后，可以进行一些功能性测试，而这以人工测试为主；对于耗时长的负载测试，则在下班之后通过脚本执行，利用夜间这段较长的时间进行耐久性测试。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00633.jpeg\" alt=\"\" width=\"95%\" style=\"width: 95%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-27　执行测试</strong></p>\n<p>第五，分析，即分析数据。测试执行完毕后，会收集到一些数据，这些显然是我们应该关心的，例如响应时间、数据库在单位时间内处理的查询请求个数。可以通过 <em>t</em>-校验、因子分析、主效应图、方差分析等方法对收集到的数据进行分析，看是否达到了预期。</p>\n<p>第六，报告，即记录报告问题。说白了就是发现问题之后，需要找人解决问题。如图 10-28 所示，将这个步骤分为四步：记录测试结果、结果与标准对比、获得偏差、向工程师报告。具体点讲，就是对比分析的结果和预期的结果，如果有偏差（例如团队定义的偏差是 5%），就把问题记录下来，并且分配给对应的工程师解决。当然，有些比较特殊的问题需要团队成员共同审核决定。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00634.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-28　记录报告问题</strong></p>\n<p>第七，验证，即重复测试和分析。这步还是比较清楚的，即发现问题并解决问题后再次验证问题，使整个测试过程形成一个闭环。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>压力测试</strong></p>\n<p>压力测试的步骤和性能测试的步骤基本相同，但是两者需要达到的目的却大相径庭。</p>\n<p>压力测试是通过测试的方法一步步逼近系统的临近崩溃点，这个点包括系统资源、内存、线程、应用、连接数等。目的是让运维和开发人员知道系统的极限在哪里，让业务人员和公司高层知道如果需要突破业务的极限，必须先突破系统的极限。压力测试还能为评估业务升级、系统升级提供有力的数据保障。假设对系统进行压力测试后发现，它可以承受每秒 10 万的并发量，这便是系统承受量的基准线。要是并发量高于这个基准线，谁也不知道会发生什么。但是实际有多少并发请求，谁也不知道。压力测试就是要搞清楚系统的极限在哪里，极限一旦确定，就可以制定针对性的措施。例如对服务器进行进一步扩容，多申请几台服务器做备份；或者进行弹性扩展，当并发量达到压力测试的 80%（8 万）时就启动扩容预案，类似这些后续的计划都需要压力测试作为支撑。公司的管理层也需要对压力测试有所了解，帮助技术人员组织更多的资源。压力测试一般分为如下两类。</p>\n<ul>\n<li><p><strong>正压力测试</strong>。以之前提到的性能测试为基础，要想知道系统能够承受的基本压力是多少，可以在这个基础上对系统逐步加压，直到系统接近崩溃或者真正崩溃。具体做法如图 10-29 所示，基于当前的系统负载加大访问量、并发数、吞吐量，而且不改变支撑系统负载的服务个数，简单点讲就是做“加法”。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00635.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-29　正压力测试</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>负压力测试</strong>。这是在系统正常运行的情况下，逐步减少支撑系统的服务，直到系统无法响应正常的业务请求。如图 10-30 所示，在正常的系统负载下，保持访问量、并发数、吞吐量不变，逐步减少支撑服务的数量，观察业务是否受影响，说白了就是做“减法”。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00636.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-30　负压力测试</strong></p>\n</li>\n</ul>\n<p>压力测试的步骤如图 10-31 所示，过程大致分为 8 步。</p>\n<p>(1) 确定测试目标。与性能测试不同，压力测试的目标是确定系统什么时候会接近崩溃。</p>\n<p>(2) 确定关键服务。压力测试其实是有重点的，根据二八原则，系统中只有 20% 的功能使用得最多，所以可以对这些核心功能做压力测试。例如秒杀系统中的关键服务就是商品服务和订单服务，这两个是用户使用最多的，特别是订单服务中的下单操作还存在数据一致性问题。</p>\n<p>(3) 定义负载。这和第 (2) 步的思路是一致的，并非每个服务都要承受高负载，需要重点关注的是那些负载量大的服务，或者在一段时间内负载有波动的服务，这些都是测试目标。</p>\n<p>(4) 选择环境。和性能测试一样，建议使用生产环境，不过也可以用 workaround 的方法。</p>\n<p>(5) 确定监视点。实际上就是对关注的参数进行监视，例如 CPU 负载、内存使用率、系统吞吐量等。</p>\n<p>(6) 产生负载。从生产环境中获取一些真实的数据，将其作为负载数据源。脚本根据目标系统的承受要求驱动负载数据源，对系统进行冲击。</p>\n<p>(7) 执行测试。根据目标系统和关键组件，对负载进行测试，返回监视点的数据。建议团队针对测试制订一个计划，模拟不同的网络环境和硬件条件进行有规律的测试。</p>\n<p>(8) 分析数据。分析对关键服务进行压力测试后得到的数据，得知服务的承受上限在哪儿。对一段时间内有负载波动或者大负载的服务进行数据分析，得出服务改造的方向。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00637.jpeg\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10-31　压力测试的步骤</strong></p>\n<p>如果说性能测试的结果是系统的基准线，那么压力测试的结果就是系统的上限或者高压线。基准线到高压线之间就是系统可以伸缩的范围，我们通过这两条线密切关注系统的负载情况。</p>\n</li>\n</ol>\n<h2 id=\"nav_point_196\">10.3　学习与发展</h2>\n<p>不知不觉已经到了本书的最后一节，这里就个人发展的经验和心得跟大家做一个分享，包括思维方式、学习提升、职业发展等方面的内容，也算是和大家说说心里话吧。</p>\n<h3 id=\"nav_point_197\">10.3.1　思维方式</h3>\n<p>稻盛和夫的《干法》一书，对人生和工作给出了这样一个公式：</p>\n<p style=\"text-align: center\">人生（工作）的结果 = 思维方式 × 热情 × 能力</p>\n<p>公式中的热情可以理解为努力，取值范围是 0 到 100 分。能力可以理解为智商、情商、组织能力、表达能力、健康等，取值范围也是 0 到 100 分。思维方式则与热情、能力不同，其取值范围是  100 到 100 分，意味着思维方式有可能是负数。当思维方式取负数时，付出的努力越大，拥有的能力越强，就越有可能得到相反的结果。我时常反思，自己在平时的工作和学习中，是否运用了正确的思维方式。当程序出现 bug 时，是找到原因并进行总结，还是埋怨项目进度太紧、系统混乱；当遇到需求不清楚的时候，是努力整理问题列表，还是抱怨产品经理不专业；当老板、客户持有不同意见时，是积极倾听并采取改进措施，还是怨天尤人。有人说程序员只要专业知识过硬就够了，其他的不用过多考虑。这种说法既正确，又不正确。专业能力是进入 IT 行业的门槛，进入之后还需要在各个方面不断地打磨和提升自己。大多数人平时的工作就是一直发现问题和解决问题，能否在这个过程中受益、思考就显得尤为重要。在职业生涯的头几年，我是在摸索中度过的，并不清晰工作的意义是什么，只是把写代码当作一个赚钱的营生。每天想的都是快点把手上的任务完成，下班以后尽情地打游戏、刷剧。测试同事给我报 bug 的时候，能推就推，认为这是操作问题，而非程序问题。对于产品经理报上来的需求，通常会说难度太大，需要更多的时间，总之找各种理由搪塞。久而久之，发现自己仍然在原地踏步，于是开始观察身边优秀的人和阅读一些书来找答案。《终生成长》一书中提到，人有两种思维模式，一种是固定型思维，另一种是成长型思维。拥有固定型思维的人认为自己不需要改变，遇到问题时保持原有的处理方式就行，需要改变的是外界。而拥有成长型思维的人则认为，自己需要不断调整做事方式来满足不断变化的世界。尤其当今是一个复杂、多变、不确定的时代，程序员更应该拥抱变化，迭代自己，专注思考。</p>\n<h3 id=\"nav_point_198\">10.3.2　学习提升</h3>\n<p>学习提升的道路有很多条，基本上分为自我学习和向他人学习。</p>\n<ol>\n<li><p><strong>自我学习</strong></p>\n<p>很多时候为了学习专业的知识，我会上网翻看博客，关注微信公众号，看推文。工作中遇到问题时，我会打开搜索引擎以最快的速度找到答案。我逐渐习惯了享受“快餐知识”带来的愉悦感，甚至不清楚复制粘贴的代码表达的是什么意思，看过专业人士的文章后也不得要领，只有莫名觉得很厉害的感觉。古人讲究“观，为，得”，大部分时候，我们只做到了“观”，知道有某个知识，大致知道如何使用某个工具，但没有形成自己的一套知识体系。在“观”的基础上，把所学知识的前后关系梳理一遍，在知道 what 和 how 的同时也知道 why，将每个知识点做好笔记保存下来，之后遇到有关联的知识时，拿出之前的笔记对照，才是做到了“为”。最后，把所有知识点串联起来，连成线，再将线扩展成面，讲给别人听，或者以文章的形式分享给别人，才能做到“得”。如果每次遇到问题的时候都能做到这三步，周而复始，技术和理解能力一定会有明显的提高。特别是有了几年工作经验以后，更需要系统地学习基础的计算机知识，例如数据结构、组成原理、数据库设计、设计模式、算法。编程技巧和工具都离不开这些基本原理的支持。在这个回顾的过程中，可以对知识重新梳理、分类，站在更高的位置审视自己。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>向他人学习</strong></p>\n<p>在《易经》中，有一卦叫作“比”卦，意思是要“亲比”他人。任何一个组织中都有领袖，即需要大家辅佐的对象，公司的领袖就是项目经理、技术组长、架构师等。“亲比”的意思是围绕在有能力的人周围，辅助他们，同时从他们身上学习知识、技能和经验。不妨观察一下自己身边的人，你会发现无论在家里、公司还是学校，都有可以“亲比”的对象。这些人身上有很多闪光点，值得我们去学习，甚至我们应该努力成为跟他们一样的人。把他们当作目标，结合自己的发展方向（比如 Java 架构师、项目管理员），列出学习条目（架构设计、项目管理），以半年为期限，定时查看目标是否已实现，以及还有哪些地方需要继续努力，时刻提醒自己要成为理想中的那个人。我之前的项目组，有一个程序员写的代码 bug 很少，于是我就学习并且模仿他的编码风格，半年以后发现我的代码质量确实有了明显的改善。除了身边的人，GitHub 上面的一些开源项目也是可以学习的对象，看别人如何设计系统架构、如何使用设计模式，也能给自己的工作带来启发。模仿是最好的老师，结合自身的特点，久而久之就会形成自己的风格。</p>\n<p>检验所学知识的方法有很多，例如把学到的知识应用到工作中，就可以检验自己是否学到位了。检验方式根据场景的不同而不同，遇到问题时再去探索解决方案，是一种被动的验证方式。如果日常工作中没有那么多需要解决的问题，而又需要检验所学的知识，该如何操作？这里分享一种主动的验证方式，即从学习知识转为教授知识。在开始学习的时候，就要把学习目标定为学完后教别人。换言之，学完后，自己就应该是这方面的专家了，有责任让其他人也搞懂这个知识。如此这般，才能在学习过程中“吃透”知识。具体可以这样做，学完一个知识后，对着镜子用自己的话讲一遍。刚开始肯定会卡壳，不过不要紧，针对不清楚的部分，查资料，搞懂之后再演讲，直到整个讲述过程顺畅为止。此时，想必你已经建立了信心，可以找三五个好友对着他们讲，有了观众，难免会紧张，可以准备简单的 PPT 以便梳理和回忆。接着，再找机会在公司里或者小组内做一次分享。逐步扩大分享的范围，并在每次分享完后及时总结，对于不熟悉的地方进行加强。这是一个不断自我完善的过程，期间还能形成自己的学习体系和方法，锻炼组织、演讲能力。另外，在不断扩大分享范围的过程中，一定会得到不少反馈，使自己对知识的认知程度不断提高。最后，在时机成熟的时候可以发表一篇文章，做一个总结。整个过程不但验证了知识，还极有可能让你成为某个垂直领域的专家，提高自己的专业知名度。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_199\">10.3.3　职业发展</h3>\n<p>职业发展路线是经常被提及的一个话题，不同阶段的职业规划是不同的。刚进入 IT 行业的人，考虑的是掌握一门可以安身立命的技术，在养活自己之余，还要有成长空间。刚开始可以多涉猎一点技术，然后在其中选择一个觉得“舒服”的坚持下去。我前几年读过的一本书叫作《逝去的武林》，讲述的是一位老者 40 年学武的经历。其中有一段讲到，他刚开始学武时，师傅教了他好几招，然后问他哪几招练起来最舒服，他告诉师傅自己的想法以后，师傅就只要他练“觉得舒服”的那几招。一年以后，才教他其他招式。他问师傅为什么。师傅说招式虽然变化多端，但原理是不变的。如果有几招已经精熟了，那么学习其他招数便易如反掌。学习 IT 技术不也是这样吗？那么多编程语言的底层原理其实都是相通的。分布式架构、通信方式、设计模式在思考方式上也有互通互联的地方。所以，在初入职场的 3~5 年内可以在一个垂直的技术领域深耕，精通这个领域以后，再选择后面的路。</p>\n<p>除了技术能力，综合能力也是必不可少的，例如演讲、写作、沟通、管理。不管今后是往技术方向发展还是往管理方向发展，这些能力都能帮到你。所以，在适当的时候也要锻炼自己的综合能力。比如定期进行技术演讲，把技术干货分享给同事；将平时工作中遇到的问题写成文章并在网络上分享；读几本心理学的书，学会如何与人沟通；定期在网上学习管理视频。在学习专业知识的同时，也获取其他领域的知识，丰富自己的知识体系。</p>\n<p>好的开始有了，那么发展时有哪些路可以走呢？下面列举三条路线以供参考。</p>\n<ul>\n<li>技术路线：初级程序员→中级程序员→高级程序员→技术经理。<ul>\n<li>这是一条技术发展路线。随着开发经验的增加以及对架构理解水平的提高，可以先往中级程序员、高级程序员方向发展。初级程序员关心的是如何编写代码、减少 bug、实现功能和通过模块测试；而中高级程序员需要从项目整体出发，考虑如何编写模块、算法。之后，可向技术经理的方向发展。在程序员阶段，如果积累了各种大中型项目的经验，熟悉了技术标准、技术规范，学会了编写、审核各种技术方案和文档，同时具备了编写软件核心代码、处理软件故障和领导团队的能力，基本能够胜任技术经理的岗位。</li>\n<li>技术经理可以往技术总监、CTO（首席技术官）等岗位发展，这些岗位的要求会更高，因此在编程过程中要注重其他方面的积累，比如算法思维、测试方法、技术文档、技术团队管理等。</li>\n</ul>\n</li>\n<li>管理路线：程序员→中级工程师→系统架构师→项目经理。<ul>\n<li>系统架构师是一个对沟通能力、设计能力和技术能力都有要求的岗位。技术是基于业务的，因此系统架构师还要深入了解业务，与客户、产品经理、技术人员、项目经理等都保持良好的沟通。在业务场景中，要设计系统架构和应用场景、解决开发过程中遇到的疑难问题，还要提高开发质量、推进开发进度、协助管理技术团队、维护好技术文档和说明文件等。</li>\n<li>项目经理是软件项目的组织者和领导者。对内要组织、管理技术团队，制订开发计划、测试计划、培训计划，量化任务；解决开发过程中出现的问题，保证软件开发按照进度推进；做好技术文档、说明文件的存档工作等。对外要与客户沟通，了解、完善、修改需求；要与公司沟通，及时汇报项目进度、工作情况和资源需求；要做好市场调研，及时调整技术方案等。</li>\n<li>程序员如果具备很强的沟通、设计和团队管理能力，就可以考虑往管理路线发展。如果不具备这些方面的能力，则可以多考虑向技术管理方向发展。系统架构师和技术经理在工作内容上是有一些区别的，架构师对内负责技术架构，对外需要和业务人员沟通；技术经理更多地专注于制定和执行内部的技术规范、技术标准。</li>\n</ul>\n</li>\n<li>产品路线：程序员→产品助理→产品设计师→产品经理。<ul>\n<li>在日常工作中，如果程序员对产品设计、产品管理有很好的想法，那么他已经拥有了产品设计的基础能力：理解产品的功能逻辑时有思路、有判断。程序员往产品路线发展，既有自己的优势，也有劣势。优势在于程序员知道程序开发的过程、熟悉功能的实现方式，因此从产品的角度能够和开发人员良好地沟通，能够很好地把控产品的开发周期、实现方式、故障判断等，使产品在技术层面出现的问题尽快得到沟通和解决。劣势是程序员在客户需求分析、市场调研、产品设计、产品管理、运营分析、用户培训等方面都要从零开始学习，这是需要一定时间的。如果往产品方向发展，基本需要从产品助理开始，不仅要保持住自己的优势，还要一步一个脚印地学习、积累，逐渐消除自己的劣势，往产品设计师、产品经理，甚至是 CIO（首席信息官）方向努力。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"nav_point_200\">10.4　总结</h2>\n<p>本章从架构设计的思维方式入手，介绍了架构师在设计中用到的三种设计模型：过程设计模型、协作式设计模型和扩展立方设计模型。然后介绍了几种代码重构：事不过三原则、添加功能时重构、修复 bug 时重构、审核代码时重构，以及重构时的难题。之后了解了性能测试得到的是系统的基准线，而压力测试得到的是系统的高压线。最后分享了终生成长的思维方式和如何提升自己，以及程序员的职业发展路线。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 9 章 指标与监控(2)","id":741064},"right":{"article_title":"作者简介","id":741066}},"comments":[]}