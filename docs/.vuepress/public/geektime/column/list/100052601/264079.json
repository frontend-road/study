{"id":264079,"title":"24 | 依赖倒置原则：高层代码和底层代码，到底谁该依赖谁？","content":"<p>你好！我是郑晔。</p><p>上一讲，我们讲了ISP原则，知道了在设计接口的时候，我们应该设计小接口，不应该让使用者依赖于用不到的方法。但在结尾的时候，我留下了一个尾巴，说在那个例子里面还有一个根本性的问题：依赖方向搞反了。</p><p>依赖这个词，程序员们都好理解，意思就是，我这段代码用到了谁，我就依赖了谁。依赖容易有，但能不能把依赖弄对，就需要动点脑子了。如果依赖关系没有处理好，就会导致一个小改动影响一大片，而把依赖方向搞反，就是最典型的错误。</p><p>那什么叫依赖方向搞反呢？这一讲我们就来讨论关于依赖的设计原则：依赖倒置原则。</p><h2>谁依赖谁</h2><p>依赖倒置原则（Dependency inversion principle，简称DIP）是这样表述的：</p><blockquote>\n<p>高层模块不应依赖于低层模块，二者应依赖于抽象。<br>\nHigh-level modules should not depend on low-level modules. Both should depend on abstractions.</p>\n</blockquote><blockquote>\n<p>抽象不应依赖于细节，细节应依赖于抽象。<br>\nAbstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p>\n</blockquote><!-- [[[read_end]]] --><p>我们学习这个原则，最重要的是要理解“倒置”，而要理解什么是“倒置”，就要先理解所谓的“正常依赖”是什么样的。</p><p>讲<a href=\"https://time.geekbang.org/column/article/252589\">结构化编程</a>时，我们曾经说过结构化编程解决问题的思路是自上而下地进行功能分解，这种解决问题的思路很自然地就会延续到很多人的编程习惯中。按照分解的结果，进行组合。所以，我们很自然地就会写出类似下面的这种代码：</p><pre><code>class CriticalFeature {\n  private Step1 step1;\n  private Step2 step2;\n  ...\n  \n  void run() {\n    // 执行第一步\n    step1.execute();\n    // 执行第二步\n    step2.execute();\n    ...\n  }\n}\n</code></pre><p>但是，这种未经审视的结构天然就有一个问题：<strong>高层模块会依赖于低层模块</strong>。在上面这段代码里，CriticalFeature类就是高层类，Step1和Step2就是低层模块，而且Step1和Step2通常都是具体类。虽然这是一种自然而然的写法，但是这种写法确实是有问题的。</p><p>在实际的项目中，代码经常会直接耦合在具体的实现上。比如，我们用Kafka做消息传递，我们就在代码里直接创建了一个KafkaProducer去发送消息。我们就可能会写出这样的代码：</p><pre><code>class Handler {\n  private KafkaProducer producer;\n  \n  void execute() {\n    ...\n    Message message = ...;\n    producer.send(new KafkaRecord&lt;&gt;(&quot;topic&quot;, message);\n    ...\n  }\n}\n</code></pre><p>也许你会问，我就是用了Kafka发消息，创建一个KafkaProducer，这有什么问题吗？其实，这个问题我们在课程中已经讲过了，就是说我们需要站在长期的角度去看，什么东西是变的、什么东西是不变的。Kafka虽然很好，但它并不是系统最核心的部分，我们在未来是可能把它换掉的。</p><p>你可能会想，这可是我实现的一个关键组件，我怎么可能会换掉它呢？你还记得吗，软件设计需要关注长期、放眼长期，所有那些不在自己掌控之内的东西，都是有可能被替换的。其实，在我前面讲的很多内容里，你也可以看到，替换一个中间件是经常发生的。所以，依赖于一个可能会变的东西，从设计的角度看，并不是一个好的做法。</p><p>那我们应该怎么做呢？这就轮到倒置登场了。</p><p><strong>所谓倒置，就是把这种习惯性的做法倒过来，让高层模块不再依赖于低层模块</strong>。那要是这样的话，我们的功能又该如何完成呢？计算机行业中一句名言告诉了我们答案：</p><blockquote>\n<p>计算机科学中的所有问题都可以通过引入一个间接层得到解决。<br>\nAll problems in computer science can be solved by another level of indirection<br>\n—— David Wheeler</p>\n</blockquote><p>是的，引入一个间接层。这个间接层指的就是DIP里所说的抽象。不过，在我们课程里，我一直用的说法是<strong>模型</strong>。也就是说，这段代码里面缺少了一个模型，而这个模型就是这个低层模块在这个过程中所承担的角色。</p><p>既然这个模块扮演的就是消息发送者的角色，那我们就可以引入一个消息发送者（MessageSender）的模型：</p><pre><code>interface MessageSender {\n  void send(Message message);\n}\n\nclass Handler {\n  private MessageSender sender;\n  \n  void execute() {\n    ...\n    Message message = ...;\n    sender.send(message);\n    ...\n  }\n}\n</code></pre><p>有了消息发送者这个模型，那我们又该如何把Kafka和这个模型结合起来呢？那就要实现一个Kafka的消息发送者：</p><pre><code>class KafkaMessageSender implements MessageSender {\n  private KafkaProducer producer;\n  \n  public void send(final Message message) {\n    this.producer.send(new KafkaRecord&lt;&gt;(&quot;topic&quot;, message));\n  }\n}\n</code></pre><p>这样一来，高层模块就不像原来一样<strong>直接</strong>依赖低层模块，而是将依赖关系“倒置”过来，让低层模块去依赖由高层定义好的接口。这样做的好处就在于，将高层模块与低层实现解耦开来。</p><p>如果未来我们要替换掉Kafka，只要重写一个MessageSender就好了，其他部分并不需要改变。这样一来，我们就可以让高层模块保持相对稳定，不会随着低层代码的改变而改变。</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/9e/b1063bfe3dc3390d7a13eb6bcee7a89e.jpg?wh=2284*1285\" alt=\"\"></p><h2>依赖于抽象</h2><p>理解了DIP的第一部分后，我们已经知道了要建立起模型（抽象）的概念。</p><p>你有没有发现，我们学习的所有原则都是在讲，尽可能把变的部分和不变的部分分开，让不变的部分稳定下来。我们知道，模型是相对稳定的，实现细节则是容易变动的部分。所以，构建出一个稳定的模型层，对任何一个系统而言，都是至关重要的。</p><p>那接下来，我们再来分析DIP的第二个部分：抽象不应依赖于细节，细节应依赖于抽象。</p><p>其实，这个可以更简单地理解为一点：<strong>依赖于抽象</strong>，从这点出发，我们可以推导出一些更具体的指导编码的规则：</p><ul>\n<li>任何变量都不应该指向一个具体类；</li>\n<li>任何类都不应继承自具体类；</li>\n<li>任何方法都不应该改写父类中已经实现的方法。</li>\n</ul><p>我们在讲<a href=\"https://time.geekbang.org/column/article/252612\">多态</a>时，提到过一个List声明的例子，其实背后遵循的就是这里的第一条规则：</p><pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\n</code></pre><p>在实际的项目中，这些编码规则有时候也并不是绝对的。如果一个类特别稳定，我们也是可以直接用的，比如字符串类。但是，请注意，这种情况非常少。因为大多数人写的代码稳定度并没有那么高。所以，上面几条编码规则可以成为覆盖大部分情况的规则，出现例外时，我们就需要特别关注一下。</p><p>到这里，你已经理解了在DIP的指导下，具体类还是能少用就少用。但还有一个问题，最终，具体类我们还是要用的，毕竟代码要运行起来不能只依赖于接口。那具体类应该在哪用呢？</p><p>我们讨论的这些设计原则，核心的关注点都是一个个的业务模型。此外，还有一些代码做的工作是负责把这些模型组装起来，这些负责组装的代码就需要用到一个一个的具体类。</p><p>是不是说到这里，感觉话题很熟悉呢？是的，我们在<a href=\"https://time.geekbang.org/column/article/241123\">第五讲</a>讨论过DI容器的来龙去脉，在Java世界里，做这些组装工作的就是DI容器。</p><p>因为这些组装工作几乎是标准化的，而且非常繁琐。如果你常用的语言中，没有提供DI容器，最好还是把负责组装的代码和业务模型放到不同的代码里。</p><p>DI容器在最初的讨论中有另外一个说法叫IoC容器，这个IoC是Inversion of Control的缩写，你会看到IoC和DIP中的I都是inversion，二者表现的意图实际上是一致的。</p><p>理解了DIP，再来使用DI容器，你会觉得一切顺理成章，因为依赖之所以可以注入，是因为我们的设计遵循了 DIP。而只知道DI容器不了解DIP，时常会出现让你觉得很为难的模型组装，根本的原因就是设计没有做好。</p><p>关于DIP，还有一个形象的说法，称为好莱坞规则：“Don’t call us, we’ll call you”。放在设计里面，这个翻译应该是“别调用我，我会调你的”。显然，这是一个框架才会有的说法，有了一个稳定的抽象，各种具体的实现都应该是由框架去调用。</p><p>是的，如果你想去编写一个框架，理解DIP是非常重要的。毫不夸张地说，不理解DIP的程序员，就只能写功能，不能构建出模型，也就很难再上一个台阶。在前面讨论程序库时，我建议每个程序员都去锻炼编写程序库，这其实就是让你去锻炼构建模型的能力。</p><p>有了对DIP的讨论，我们再回过头看上一讲留下的疑问，为什么说一开始TransactionRequest是把依赖方向搞反了？因为最初的TransactionRequest是一个具体类，而TransactionHandler是业务类。</p><p>我们后来改进的版本里引入一个模型，把TransactionRequest变成了接口，ActualTransactionRequest 实现这个接口，TransactionHandler只依赖于接口，而原来的具体类从这个接口继承而来，相对来说，比原来的版本好一些。</p><p><strong>对于任何一个项目而言，了解不同模块的依赖关系是一件很重要的事</strong>。你可以去找一些工具去生成项目的依赖关系图，然后，你就可以用DIP作为一个评判标准，去衡量一下你的项目在依赖关系上表现得到底怎么样了。很有可能，你就找到了项目改造的一些着力点。</p><p>理解了 DIP，再来看一些关于依赖的讨论，我们也可以看到不同的角度。比如，循环依赖，有人会说从技术上要如何解决它，但实际上，循环依赖就是设计没有做好的结果，把依赖关系弄错了，才可能会出现循环依赖，先把设计做对，把该有的接口提取出来，依赖就不会循环了。</p><p>至此，SOLID的五个原则，我们已经讲了一遍。有了前面对于分离关注点和面向对象基础知识的铺垫，相信你理解这些原则的难度也会相应的降低了一些。</p><p>你会看到，理解这些原则，关键的第一步还是<strong>分离关注点</strong>，把不同的内容区分开来。然后，用这些原则再把它们组合起来。而当你理解了这些原则，再回头去看，也能加深对面向对象特点的认识，现在你应该更能深刻体会到多态在面向对象世界里发挥的作用了。</p><h2>总结时刻</h2><p>今天我们讲了依赖倒置原则，它的表述是：</p><ul>\n<li>高层模块不应依赖于低层模块，二者应依赖于抽象。</li>\n<li>抽象不应依赖于细节，细节应依赖于抽象。</li>\n</ul><p>理解这个原则的关键在于理解“倒置”，它是相对于传统自上而下的解决问题然后组合的方式而言的。高层模块不依赖于低层模块，可以通过引入一个抽象，或者模型，将二者解耦开来。高层模块依赖于这个模型，而低层模块实现这个模型。</p><p>DIP 还可以简单理解成要依赖于抽象，由此，还可以推导出一些指导编码的规则：</p><ul>\n<li>任何变量都不应该指向一个具体类；</li>\n<li>任何类都不应继承自具体类；</li>\n<li>任何方法都不应该改写父类中已经实现的方法。</li>\n</ul><p>如果我们的模型都按照DIP去编写，具体类可以放到模型组装的过程去使用，对于 Java 世界而言，这个工作是由 DI 容器完成的。即便是没有 DI 容器的语言，组装代码与模型代码也应该是分开的。把 DIP 应用于项目，可以先从生成依赖关系图开始，找到可以改进的点。</p><p>学习了设计原则之后，我们已经有了标准去指导我们的设计，有了尺子去衡量我们的设计。接下来，我们要学习比设计原则更具体的内容：设计模式，下一讲，我们来谈谈如何学习设计模式。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>依赖于构建出来的抽象，而不是具体类</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/cf/64101aa6088db60f8c9921a4c374b0cf.jpg?wh=2284*1215\" alt=\"\"></p><h2>思考题</h2><p>最后我想请你去了解一下防腐层（Anti-Corruption Layer），结合今天讲的DIP，谈谈它的适用场景，欢迎在留言区写下你的想法。</p><p>感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。</p>","comments":[{"had_liked":false,"id":236277,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1595383093,"is_pvip":false,"replies":[{"id":"87392","content":"没错！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595463419,"ip_address":"","comment_id":236277,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70314859829","product_id":100052601,"comment_content":"防腐层可以解耦对外部系统的依赖。包括接口和参数。防腐层还可以贯彻接口隔离的思想，以及做一些功能增强(加缓存,异步并发取值)。","like_count":17,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502012,"discussion_content":"没错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595463419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237638,"user_name":"魂淡","can_delete":false,"product_type":"c1","uid":2004583,"ip_address":"","ucode":"77DB54491C9521","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjTY9B9a8iaGibMCWocpjE1YvYPpdXytBC13wg1Tiaw6avoiaQPjlYRt6OKw2UEhWibutRR8YjBWbibteA/132","comment_is_top":false,"comment_ctime":1595907309,"is_pvip":false,"replies":[{"id":"88317","content":"如果你想去研究开源项目，我推荐 Spring 框架、Google Guava 和我的 Moco。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1596436754,"ip_address":"","comment_id":237638,"utype":1}],"discussion_count":2,"race_medal":0,"score":"53135514861","product_id":100052601,"comment_content":"老师能不能推荐一些项目，或者框架什么的，去研究和实践老师说的这些理论，听了这么多理论，已经热血沸腾，迫不及待的实践一番！","like_count":13,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502488,"discussion_content":"如果你想去研究开源项目，我推荐 Spring 框架、Google Guava 和我的 Moco。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596436754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411060,"discussion_content":"嗯，看来我有出师的迹象，我的关注点是你的名字。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635840188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236264,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1595380939,"is_pvip":false,"replies":[{"id":"87393","content":"总结得好！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595463439,"ip_address":"","comment_id":236264,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27365184715","product_id":100052601,"comment_content":"依赖倒置原则说的是：<br>1.高层模块不应依赖于低层模块，二者都应依赖于抽象<br>2.抽象不应依赖于细节，细节应依赖于抽象<br>总结起来就是依赖抽象（模型），具体实现抽象接口，然后把模型代码和组装代码分开，这样的设计就是分离关注点，将不变的与不变有效的区分开","like_count":6,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502008,"discussion_content":"总结得好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595463439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236254,"user_name":"人间四月天","can_delete":false,"product_type":"c1","uid":1048314,"ip_address":"","ucode":"11BE219C23EEBC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/fa/2a046821.jpg","comment_is_top":false,"comment_ctime":1595378546,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23070215026","product_id":100052601,"comment_content":"非常赞同！<br>如果把设计原则，设计模式，结合一个开源框架讲解就更到位了，如果自己实现一个具体的框架，在把这些原则和模式结合进去，作为评价这个具体框架的依据，就会理解的非常通透。","like_count":5,"discussions":[{"author":{"id":1061005,"avatar":"https://static001.geekbang.org/account/avatar/00/10/30/8d/a2a4e97e.jpg","nickname":"Atong","note":"","ucode":"7E9D4B8D108E4E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306064,"discussion_content":"可以拿自己以往的项目，和已学的原则，两者对比看看是否匹配了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600159040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294365,"discussion_content":"\n嗯，没有实战，纸上谈兵都是白搭","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595860773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277395,"user_name":"Geek_0315ca","can_delete":false,"product_type":"c1","uid":1810532,"ip_address":"","ucode":"675254A9FC25A8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVAVOYIoohh3bCdgErne0VHtoPorcrtmOAR45rsWPmJsLkzlvqMulbRyv0Skj8JHajrA9bPia3Lxw/132","comment_is_top":false,"comment_ctime":1612404104,"is_pvip":false,"replies":[{"id":"100681","content":"嗯，很好的总结。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1612483449,"ip_address":"","comment_id":277395,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18792273288","product_id":100052601,"comment_content":"依赖倒置的关键点在于在高层模块和底层模块之间抽象出一个通用的稳定不变的公共接口。这个接口作为了一个隔板，将稳定部分和易变部分隔离开。这时用到开闭原则-分离关注点，找共性，对修改封闭，对扩展开放。当可变部分扩展业务功能时，只要实现接口方可。接口的粒度需要接口隔离原则和单一职责原则来指导","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515033,"discussion_content":"嗯，很好的总结。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612483449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238079,"user_name":"桃子-夏勇杰","can_delete":false,"product_type":"c1","uid":1158436,"ip_address":"","ucode":"5D5F38AABA980F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/24/c6b763b4.jpg","comment_is_top":false,"comment_ctime":1596067777,"is_pvip":true,"replies":[{"id":"88014","content":"先确定接口再开发。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1596105328,"ip_address":"","comment_id":238079,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18775936961","product_id":100052601,"comment_content":"前后端团队经常因为接口变动而延误工期，这个接口到底由谁负责会靠谱一些？前端经常因为后端的接口未实现而延误某个功能，后端则因为对于其他依赖的系统而无法确定和实现接口。","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502637,"discussion_content":"先确定接口再开发。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596105328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236570,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1595469571,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"18775338755","product_id":100052601,"comment_content":"1、面向接口编程以及思考题中的防腐层（Anti-Corruption Layer）应该都算作是DIP下的一种具体方案或一种手段。<br><br>2、“理解了 DIP，再来使用 DI 容器，你会觉得一切顺理成章，因为依赖之所以可以注入，是因为我们的设计遵循了 DIP。而只知道 DI 容器不了解 DIP，时常会出现让你觉得很为难的模型组装，根本的原因就是设计没有做好。”<br>一时没想明白，又反复把本文和第05讲看了2遍，新的理解是：<br>1）DIP设计模型之间的依赖关系，关注抽象，而不是具体的实现类。<br>2）DI容器负责创建和组装具体的实现类，比如通过一个环境变量的值来判断，在config文件中具体实例化哪个类；因为业务代码中都是抽象接口，所以DI容器根据对应的名字或类型，将前面实例化的具体实现类，注入到业务代码中，程序员无感知。<br>3）很为难的模型组装？没有想到好的例子，05讲中的例子，好像也不算DI容器的中为难的模型组装，老师有更好例子吗？<br><br>以上，请老师指正。","like_count":4},{"had_liked":false,"id":245567,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1598979805,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14483881693","product_id":100052601,"comment_content":"还有一个很重要的地方，抽象是属于高层模块的，由高层模块定义；而不是由低层模块根据实现再抽出接口。","like_count":4,"discussions":[{"author":{"id":1359669,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/35/0e3a92a7.jpg","nickname":"晴天了","note":"","ucode":"5310E02F8DF1F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361645,"discussion_content":"高层模块说:我要这种工作模式标准的功能 ,底层模块说 : 好 我就按照这种标准做 . 把制作标准的权利交给高层模块 .倒置思想很重要啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616721559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250667,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1601191159,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"10191125751","product_id":100052601,"comment_content":"以前一直没有搞明白依赖倒置原则，后来看到隔壁李智慧老师的专栏里面说，Spring、Tomcat 这些框架都是依赖倒置，然后就理解了。<br><br>再回过头来看郑晔老师的文章，从结构化编程高层依赖低层的代码，到直接依赖 KafkaProducer 的 Handler，再到消息发送者 MessageSender 接口和 KafkaMessageSender 类，这个过程显得很平顺。<br><br>不过，如果是我的话，可能不太敢想象换掉 Kafka。<br><br>依赖于抽象的三条编码规则比较实用，但是也挺极端的。<br><br>* 任何变量都不应该指向一个具体类<br>* 任何类都不应继承自具体类<br>* 任何方法都不应该改写父类中已经实现的方法<br><br>虽然不那么容易做到，但是应该是一个努力的方向。<br><br>可能是因为代码写的不多，DI 容器，或者说 IoC 容器的部分有点陌生，所以又回过头去看第五讲。<br><br>还是有一点没明白上一讲中为什么要引入 ActualTransactionRequest，而且还实现了几乎所有的 TransactionRequest 子类接口，是想要吧 ActualTransactionRequest 当做 DI 容器么？","like_count":2},{"had_liked":false,"id":236262,"user_name":"大雁小鱼","can_delete":false,"product_type":"c1","uid":1101017,"ip_address":"","ucode":"44090581E59FDA","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","comment_is_top":false,"comment_ctime":1595380243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10185314835","product_id":100052601,"comment_content":"防腐层就是做隔离，一般用于系统集成中，新系统与旧系统集成，为了不让改变扩散，在系统之间多了一个层，叫防腐层，用于控制修改扩散，防腐层也有抽象对方系统的味道。","like_count":2},{"had_liked":false,"id":295923,"user_name":"猪肉怂","can_delete":false,"product_type":"c1","uid":2011383,"ip_address":"","ucode":"59C909384E1116","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b0/f7/9016fbbb.jpg","comment_is_top":false,"comment_ctime":1622643160,"is_pvip":false,"replies":[{"id":"107559","content":"很到位的理解","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1622975382,"ip_address":"","comment_id":295923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5917610456","product_id":100052601,"comment_content":"读了郑老师这篇，恍然大悟:  原来防腐层在本质上，是一种依赖倒置。<br><br>业务逻辑依赖于防腐层提供的接口，而防腐层则接管了对于外部接口细节的处理，这样当外部系统接口改变的时候，只需要更新防腐层的实现。我觉得这可以理解为系统间的 DIP 原则。<br><br>进一步地，「六边形架构」则把这种做法推向极致，把每层都通过 Adapter 与外部进行隔离，无论是访问底层的数据库、缓存基础设施，还是其他的领域服务，全部通过「中间层」进行隔离，让每层都依赖于「抽象」。","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521264,"discussion_content":"很到位的理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622975382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237841,"user_name":"OlafOO","can_delete":false,"product_type":"c1","uid":1019254,"ip_address":"","ucode":"105F8B194ED37B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/76/994a9929.jpg","comment_is_top":false,"comment_ctime":1595985377,"is_pvip":true,"replies":[{"id":"87861","content":"有问题，你无法确定真的是Step1和Step2，还会不会有Step3，这个设计是不好的。如果你的设计是多个Step，这也许是一个更好的设计。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595989509,"ip_address":"","comment_id":237841,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5890952673","product_id":100052601,"comment_content":"老师你好，请教下开头的例子，step1和step2如果是接口，还有问题么；像这种流程式的代码还挺常见的","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502563,"discussion_content":"有问题，你无法确定真的是Step1和Step2，还会不会有Step3，这个设计是不好的。如果你的设计是多个Step，这也许是一个更好的设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595989509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236606,"user_name":"吴","can_delete":false,"product_type":"c1","uid":1495840,"ip_address":"","ucode":"4807FB811B2EDC","user_header":"https://static001.geekbang.org/account/avatar/00/16/d3/20/95e71191.jpg","comment_is_top":false,"comment_ctime":1595476271,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5890443567","product_id":100052601,"comment_content":"怎么才能不动调用代码，而只新建一个类，这才比较好","like_count":1,"discussions":[{"author":{"id":1396147,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4d/b3/85828cc4.jpg","nickname":"f","note":"","ucode":"686BD6C21FE02B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299962,"discussion_content":"同问 作者说替换就好了 我们用spring的autowired 还是需要去改代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597889541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236603,"user_name":"吴","can_delete":false,"product_type":"c1","uid":1495840,"ip_address":"","ucode":"4807FB811B2EDC","user_header":"https://static001.geekbang.org/account/avatar/00/16/d3/20/95e71191.jpg","comment_is_top":false,"comment_ctime":1595475830,"is_pvip":false,"replies":[{"id":"87472","content":"这是Java语言的实例代码。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595502063,"ip_address":"","comment_id":236603,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5890443126","product_id":100052601,"comment_content":"private MessageSender sender;<br>  <br>  void execute() {<br>    ...<br>    Message message = ...;<br>    sender.send(message);<br>这是啥语言可以这样写？php好像不可以吧？","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502136,"discussion_content":"这是Java语言的实例代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595502063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236258,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1595379541,"is_pvip":false,"replies":[{"id":"87394","content":"这里的关键在于隔离，虽然它是一个数据类，但在不同的地方扮演了不同的角色。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595463511,"ip_address":"","comment_id":236258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5890346837","product_id":100052601,"comment_content":"感觉TransactionRequest只是存储了数据, 没必要要在抽象出一个接口来吧 ","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502005,"discussion_content":"这里的关键在于隔离，虽然它是一个数据类，但在不同的地方扮演了不同的角色。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595463511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353882,"user_name":"小袁","can_delete":false,"product_type":"c1","uid":1811495,"ip_address":"广东","ucode":"3F5D8721F577D9","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","comment_is_top":false,"comment_ctime":1659884367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659884367","product_id":100052601,"comment_content":"我有一个疑问，什么是高层模块，什么是低层模块。","like_count":0},{"had_liked":false,"id":346748,"user_name":"风木","can_delete":false,"product_type":"c1","uid":1976084,"ip_address":"","ucode":"3CCC225333F55F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/g9rRFb3ibAX0BcY4Dlmh1oMl87eUdshNbicoZJtd6bT8W36WdxYbmBL13HmOQBowf5WZwoLgPhCAjUgKA2LxrJyw/132","comment_is_top":false,"comment_ctime":1653396275,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653396275","product_id":100052601,"comment_content":"类的设计基本都是抽象的，只有到最后使用时才具体化。代码的大部分应对的都是通用逻辑，解决各种复杂的业务情况，只有最后使用到具体参数时，才会调用具体业务。而这些具体的内容，应该放在最外面","like_count":0},{"had_liked":false,"id":346236,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1652936077,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1652936077","product_id":100052601,"comment_content":"依赖于构建出来的抽象，而不是具体类--记下来<br>老师请问，分离关注点，关注点就是稳定和易变的部分吗？","like_count":0,"discussions":[{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579995,"discussion_content":"关注点是业务中变化的部分，将这个部分隔离出来，客户代码（调用者）依赖接口，隐藏实现。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657790634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343619,"user_name":"阿姐的阿杰","can_delete":false,"product_type":"c1","uid":1001156,"ip_address":"","ucode":"89F5CF4D1E0C2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/c4/128338f8.jpg","comment_is_top":false,"comment_ctime":1650957220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650957220","product_id":100052601,"comment_content":"想到了一个不太恰当的比方：就好像 Photoshop 里要在图片中新加一点东西，并不是直接在图片上去画，而是新建一个图层，在新建的图层中处理。总之，变化是一定存在的，只是把变化通过手段迁移至一个明显的边界之外。","like_count":0},{"had_liked":false,"id":342255,"user_name":"Nio","can_delete":false,"product_type":"c1","uid":1529642,"ip_address":"","ucode":"A1B8D3C01FB937","user_header":"https://static001.geekbang.org/account/avatar/00/17/57/2a/c6c95f37.jpg","comment_is_top":false,"comment_ctime":1650159539,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1650159539","product_id":100052601,"comment_content":"高层模块和低层模块不直接依赖，而是抽离出一个接口模型，高层模块去依赖这个接口模块，低层模块来具体实现，这样高底层就解耦了。这样的好处是结构清晰，扩展性好。","like_count":0},{"had_liked":false,"id":340506,"user_name":"laolinshi","can_delete":false,"product_type":"c1","uid":1024994,"ip_address":"","ucode":"269B879389D7D5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/e2/5cb4f43f.jpg","comment_is_top":false,"comment_ctime":1648868523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648868523","product_id":100052601,"comment_content":"防腐层的目的是了为了隔离技术的变化对业务模型层的影响。比如调用的外部接口方式需要变更时，最典型的场景如同步调用改成异步调用，这时候只需要修改防腐层的逻辑，业务模型层不会受到影响。","like_count":0},{"had_liked":false,"id":337073,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1646592333,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646592333","product_id":100052601,"comment_content":"老师 话说什么时候用静态方法呢？ 静态方法就没法依赖抽象啥的了呀","like_count":0},{"had_liked":false,"id":319411,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1635782960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635782960","product_id":100052601,"comment_content":"计算机科学中的所有问题都可以通过引入一个间接层得到解决。阅读完这段话，通过依赖接口而不是具体实现，让原本乱到写不下去的代码，变的简单整洁了","like_count":0},{"had_liked":false,"id":311778,"user_name":"肖韬","can_delete":false,"product_type":"c1","uid":1059962,"ip_address":"","ucode":"BBCDBFD08C8B8E","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/7a/f2e63f58.jpg","comment_is_top":false,"comment_ctime":1631457153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631457153","product_id":100052601,"comment_content":"郑老师，这句话我还是不理解，文中也没有特别解释：『任何方法都不应该改写父类中已经实现的方法』。<br><br>假设父类A有10个子类，B1&#47;B2&#47;B3…&#47;B10。其中前9个子类都使用父类A中方法f()的默认实现，但是B10对于这个方法有自己的特殊需求，为什么B10.f()的实现就不能改写呢？<br><br>如果不应该改写的话，该怎么实现它的特殊功能要求呢？<br><br>谢谢。","like_count":0},{"had_liked":false,"id":298008,"user_name":"KevinSu","can_delete":false,"product_type":"c1","uid":1627982,"ip_address":"","ucode":"768FEAB2400766","user_header":"https://static001.geekbang.org/account/avatar/00/18/d7/4e/395b6cc5.jpg","comment_is_top":false,"comment_ctime":1623889242,"is_pvip":false,"replies":[{"id":"110800","content":"很多人的问题在于没有抽象和实现的区分","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1628426406,"ip_address":"","comment_id":298008,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623889242","product_id":100052601,"comment_content":"我的理解是高层模块应该依赖高层模块，这样即使底层代码改动也不会影响上层的调用，高层模块依赖底层模块的原因是没有意识到要对底层模块进行抽象后提供给高层使用","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521990,"discussion_content":"很多人的问题在于没有抽象和实现的区分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628426406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283076,"user_name":"李文彬","can_delete":false,"product_type":"c1","uid":2251534,"ip_address":"","ucode":"4CD326DC443028","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia4qBUs5bFs5tU3yVCcBapIcnVftM60nrJ73eu30YDMbDNvjhvnibct3pMYlj62G1c7nH8jSBaiaLw/132","comment_is_top":false,"comment_ctime":1615539422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615539422","product_id":100052601,"comment_content":"前端写公共组件的时候，由于不同父组件可能有不同的数据格式，没法在子组件里写统一的“防腐层”，一般会让父组件满足这种特定的格式或者直接传一个dataHandler函数进来，不知道dataHandler算不算一种“防腐层”？","like_count":0},{"had_liked":false,"id":258835,"user_name":"Feng","can_delete":false,"product_type":"c1","uid":1015205,"ip_address":"","ucode":"42DB60B7BF69D0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/a5/930c9103.jpg","comment_is_top":false,"comment_ctime":1604565502,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1604565502","product_id":100052601,"comment_content":"Anti-Corruption Layer 防腐层，可作为单独的组件或服务，用于隔离互相依赖的两个子系统，各子系统依赖于本系统内的数据模型接口，通过防腐层实现具体的接口消息转换。<br>防腐层可用于新老系统等使用不同协议情况下的数据交互。","like_count":0},{"had_liked":false,"id":256028,"user_name":"Janenesome","can_delete":false,"product_type":"c1","uid":1276572,"ip_address":"","ucode":"15D2673CC31D9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/9c/a4bc748d.jpg","comment_is_top":false,"comment_ctime":1603509084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603509084","product_id":100052601,"comment_content":"防腐层是一个很好的隔离和抽象，把对外部依赖隔离在这一层，做好各种监控和异常处理、数据处理等等。调用的地方只需要关注抽象，起个表达力强一点的见名知意的名字，业务系统中不用关注具体实现。<br><br>平时的业务开发中，经常写文中 CriticalFeature 类似的代码，对比周围还以为写得不错了，不得不再次感叹自己看得太少了😭","like_count":0},{"had_liked":false,"id":244838,"user_name":"CPP","can_delete":false,"product_type":"c1","uid":1074165,"ip_address":"","ucode":"2313F6BD693F48","user_header":"https://static001.geekbang.org/account/avatar/00/10/63/f5/9c7ef5ce.jpg","comment_is_top":false,"comment_ctime":1598696155,"is_pvip":false,"replies":[{"id":"100664","content":"防腐层是一个基础的模式，将内外部隔离开来。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1612432228,"ip_address":"","comment_id":244838,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598696155","product_id":100052601,"comment_content":"这次总算是把依赖倒置搞明白了，这个思想非常重要，具有里程碑意义。<br>防腐层其实类似于适配模式的思想，实现供应端和消费端的一种隔离，避免因消费端的变更引起应用接口的变化，由防腐层承受这个变更。","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504716,"discussion_content":"防腐层是一个基础的模式，将内外部隔离开来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612432228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236605,"user_name":"吴","can_delete":false,"product_type":"c1","uid":1495840,"ip_address":"","ucode":"4807FB811B2EDC","user_header":"https://static001.geekbang.org/account/avatar/00/16/d3/20/95e71191.jpg","comment_is_top":false,"comment_ctime":1595476187,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595476187","product_id":100052601,"comment_content":"声明以后还得去创交具体的累，将来提换的时候，还得改调用类的创建代码，感觉架构上还是有影响","like_count":0,"discussions":[{"author":{"id":1382147,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7qJDGibf9lypwDxOXicZUf67voaQavibw6XdORbAicV55Q5ia1UuLMmy3lgawKU0BFhEcyHibqAaOMSnQ/132","nickname":"zipoopiz","note":"","ucode":"B1E6DEDCF024D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300500,"discussion_content":"如果是java的话,用工厂类读取配置文件再使用ApplicationContext的getBean方法可以获取具体字类的实例,这样就不用改代码了.\n当然,用这种方法的话,需要改配置文件","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598150478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236328,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1595390435,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1595390435","product_id":100052601,"comment_content":"“任何类都不应继承自具体类”和“任何方法都不应该改写父类中已经实现的方法”，放在一起是说，类可以继承自抽象类，但不应该改写抽象类中已实现的方法吗？因为如果类都只是依赖和实现接口的话，就没有所谓的继承和父类中的实现了。","like_count":0}]}