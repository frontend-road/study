{"id":740763,"title":"第 4 章 响应系统的作用与实现(2)","content":"<h2 id=\"nav_point_38\">4.7　调度执行</h2>\r\n<p>可调度性是响应系统非常重要的特性。首先我们需要明确什么是可调度性。所谓可调度，指的是当 <code>trigger</code> 动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式。</p>\r\n<p>首先来看一下，如何决定副作用函数的执行方式，以下面的代码为例：</p>\r\n<pre class=\"no-line-number\"><code>01 const data = { foo: 1 }\r\n02 const obj = new Proxy(data, { /* ... */ })\r\n03\r\n04 effect(() => {\r\n05   console.log(obj.foo)\r\n06 })\r\n07\r\n08 obj.foo++\r\n09\r\n10 console.log('结束了')</code></pre>\r\n<p>在副作用函数中，我们首先使用 <code>console.log</code> 语句打印 <code>obj.foo</code> 的值，接着对 <code>obj.foo</code> 执行自增操作，最后使用 <code>console.log</code> 语句打印 <code>'结束了'</code>。这段代码的输出结果如下：</p>\r\n<pre class=\"no-line-number\"><code>01 1\r\n02 2\r\n03 '结束了'</code></pre>\r\n<p>现在假设需求有变，输出顺序需要调整为：</p>\r\n<pre class=\"no-line-number\"><code>01 1\r\n02 '结束了'\r\n03 2</code></pre>\r\n<p>根据打印结果我们很容易想到对策，即把语句 <code>obj.foo++</code> 和语句 <code>console.log('结束了')</code> 位置互换即可。那么有没有什么办法能够在不调整代码的情况下实现需求呢？这时就需要响应系统支持<strong>调度</strong>。</p>\r\n<p>我们可以为 <code>effect</code> 函数设计一个选项参数 <code>options</code>，允许用户指定调度器：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(\r\n02   () => {\r\n03     console.log(obj.foo)\r\n04   },\r\n05   // options\r\n06   {\r\n07     // 调度器 scheduler 是一个函数\r\n08     scheduler(fn) {\r\n09       // ...\r\n10     }\r\n11   }\r\n12 )</code></pre>\r\n<p>如上面的代码所示，用户在调用 <code>effect</code> 函数注册副作用函数时，可以传递第二个参数 <code>options</code>。它是一个对象，其中允许指定 <code>scheduler</code> 调度函数，同时在 <code>effect</code> 函数内部我们需要把 <code>options</code> 选项挂载到对应的副作用函数上：</p>\r\n<pre class=\"no-line-number\"><code>01 function effect(fn, options = {}) {\r\n02   const effectFn = () => {\r\n03     cleanup(effectFn)\r\n04     // 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect\r\n05     activeEffect = effectFn\r\n06     // 在调用副作用函数之前将当前副作用函数压栈\r\n07     effectStack.push(effectFn)\r\n08     fn()\r\n09     // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把 activeEffect 还原为之前的值\r\n10     effectStack.pop()\r\n11     activeEffect = effectStack[effectStack.length - 1]\r\n12   }\r\n13   // 将 options 挂载到 effectFn 上\r\n14   effectFn.options = options  // 新增\r\n15   // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合\r\n16   effectFn.deps = []\r\n17   // 执行副作用函数\r\n18   effectFn()\r\n19 }</code></pre>\r\n<p>有了调度函数，我们在 <code>trigger</code> 函数中触发副作用函数重新执行时，就可以直接调用用户传递的调度器函数，从而把控制权交给用户：</p>\r\n<pre class=\"no-line-number\"><code>01 function trigger(target, key) {\r\n02   const depsMap = bucket.get(target)\r\n03   if (!depsMap) return\r\n04   const effects = depsMap.get(key)\r\n05\r\n06   const effectsToRun = new Set()\r\n07   effects && effects.forEach(effectFn => {\r\n08     if (effectFn !== activeEffect) {\r\n09       effectsToRun.add(effectFn)\r\n10     }\r\n11   })\r\n12   effectsToRun.forEach(effectFn => {\r\n13     // 如果一个副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递\r\n14     if (effectFn.options.scheduler) {  // 新增\r\n15       effectFn.options.scheduler(effectFn)  // 新增\r\n16     } else {\r\n17       // 否则直接执行副作用函数（之前的默认行为）\r\n18       effectFn()  // 新增\r\n19     }\r\n20   })\r\n21 }</code></pre>\r\n<p>如上面的代码所示，在 <code>trigger</code> 动作触发副作用函数执行时，我们优先判断该副作用函数是否存在调度器，如果存在，则直接调用调度器函数，并把当前副作用函数作为参数传递过去，由用户自己控制如何执行；否则保留之前的行为，即直接执行副作用函数。</p>\r\n<p>有了这些基础设施之后，我们就可以实现前文的需求了，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 const data = { foo: 1 }\r\n02 const obj = new Proxy(data, { /* ... */ })\r\n03\r\n04 effect(\r\n05   () => {\r\n06     console.log(obj.foo)\r\n07   },\r\n08   // options\r\n09   {\r\n10     // 调度器 scheduler 是一个函数\r\n11     scheduler(fn) {\r\n12       // 将副作用函数放到宏任务队列中执行\r\n13       setTimeout(fn)\r\n14     }\r\n15   }\r\n16 )\r\n17\r\n18\r\n19 obj.foo++\r\n20\r\n21 console.log('结束了')</code></pre>\r\n<p>我们使用 <code>setTimeout</code> 开启一个宏任务来执行副作用函数 <code>fn</code>，这样就能实现期望的打印顺序了：</p>\r\n<pre class=\"no-line-number\"><code>01 1\r\n02 '结束了'\r\n03 2</code></pre>\r\n<p>除了控制副作用函数的执行顺序，通过调度器还可以做到控制它的执行次数，这一点也尤为重要。我们思考如下例子：</p>\r\n<pre class=\"no-line-number\"><code>01 const data = { foo: 1 }\r\n02 const obj = new Proxy(data, { /* ... */ })\r\n03\r\n04 effect(() => {\r\n05   console.log(obj.foo)\r\n06 })\r\n07\r\n08 obj.foo++\r\n09 obj.foo++</code></pre>\r\n<p>首先在副作用函数中打印 <code>obj.foo</code> 的值，接着连续对其执行两次自增操作，在没有指定调度器的情况下，它的输出如下：</p>\r\n<pre class=\"no-line-number\"><code>01 1\r\n02 2\r\n03 3</code></pre>\r\n<p>由输出可知，字段 <code>obj.foo</code> 的值一定会从 <code>1</code> 自增到 <code>3</code>，<code>2</code> 只是它的过渡状态。如果我们只关心最终结果而不关心过程，那么执行三次打印操作是多余的，我们期望的打印结果是：</p>\r\n<pre class=\"no-line-number\"><code>01 1\r\n02 3</code></pre>\r\n<p>其中不包含过渡状态，基于调度器我们可以很容易地实现此功能：</p>\r\n<pre class=\"no-line-number\"><code>01 // 定义一个任务队列\r\n02 const jobQueue = new Set()\r\n03 // 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列\r\n04 const p = Promise.resolve()\r\n05\r\n06 // 一个标志代表是否正在刷新队列\r\n07 let isFlushing = false\r\n08 function flushJob() {\r\n09   // 如果队列正在刷新，则什么都不做\r\n10   if (isFlushing) return\r\n11   // 设置为 true，代表正在刷新\r\n12   isFlushing = true\r\n13   // 在微任务队列中刷新 jobQueue 队列\r\n14   p.then(() => {\r\n15     jobQueue.forEach(job => job())\r\n16   }).finally(() => {\r\n17     // 结束后重置 isFlushing\r\n18     isFlushing = false\r\n19   })\r\n20 }\r\n21\r\n22\r\n23 effect(() => {\r\n24   console.log(obj.foo)\r\n25 }, {\r\n26   scheduler(fn) {\r\n27     // 每次调度时，将副作用函数添加到 jobQueue 队列中\r\n28     jobQueue.add(fn)\r\n29     // 调用 flushJob 刷新队列\r\n30     flushJob()\r\n31   }\r\n32 })\r\n33\r\n34 obj.foo++\r\n35 obj.foo++</code></pre>\r\n<p>观察上面的代码，首先，我们定义了一个任务队列 <code>jobQueue</code>，它是一个 <code>Set</code> 数据结构，目的是利用 <code>Set</code> 数据结构的自动去重能力。接着我们看调度器 <code>scheduler</code> 的实现，在每次调度执行时，先将当前副作用函数添加到 <code>jobQueue</code> 队列中，再调用 <code>flushJob</code> 函数刷新队列。然后我们把目光转向 <code>flushJob</code> 函数，该函数通过 <code>isFlushing</code> 标志判断是否需要执行，只有当其为 <code>false</code> 时才需要执行，而一旦 <code>flushJob</code> 函数开始执行，<code>isFlushing</code> 标志就会设置为 <code>true</code>，意思是无论调用多少次 <code>flushJob</code> 函数，在一个周期内都只会执行一次。需要注意的是，在 <code>flushJob</code> 内通过 <code>p.then</code> 将一个函数添加到微任务队列，在微任务队列内完成对 <code>jobQueue</code> 的遍历执行。</p>\r\n<p>整段代码的效果是，连续对 <code>obj.foo</code> 执行两次自增操作，会同步且连续地执行两次 <code>scheduler</code> 调度函数，这意味着同一个副作用函数会被 <code>jobQueue.add(fn)</code> 语句添加两次，但由于 <code>Set</code> 数据结构的去重能力，最终 <code>jobQueue</code> 中只会有一项，即当前副作用函数。类似地，<code>flushJob</code> 也会同步且连续地执行两次，但由于 <code>isFlushing</code> 标志的存在，实际上 <code>flushJob</code> 函数在一个事件循环内只会执行一次，即在微任务队列内执行一次。当微任务队列开始执行时，就会遍历 <code>jobQueue</code> 并执行里面存储的副作用函数。由于此时 <code>jobQueue</code> 队列内只有一个副作用函数，所以只会执行一次，并且当它执行时，字段 <code>obj.foo</code> 的值已经是 <code>3</code> 了，这样我们就实现了期望的输出：</p>\r\n<pre class=\"no-line-number\"><code>01 1\r\n02 3</code></pre>\r\n<p>可能你已经注意到了，这个功能有点类似于在 Vue.js 中连续多次修改响应式数据但只会触发一次更新，实际上 Vue.js 内部实现了一个更加完善的调度器，思路与上文介绍的相同。</p>\r\n<h2 id=\"nav_point_39\">4.8　计算属性 <code>computed</code> 与 <code>lazy</code></h2>\r\n<p>前文介绍了 <code>effect</code> 函数，它用来注册副作用函数，同时它也允许指定一些选项参数 <code>options</code>，例如指定 <code>scheduler</code> 调度器来控制副作用函数的执行时机和方式；也介绍了用来追踪和收集依赖的 <code>track</code> 函数，以及用来触发副作用函数重新执行的 <code>trigger</code> 函数。实际上，综合这些内容，我们就可以实现 Vue.js 中一个非常重要并且非常有特色的能力——计算属性。</p>\r\n<p>在深入讲解计算属性之前，我们需要先来聊聊关于懒执行的 <code>effect</code>，即 <code>lazy</code> 的 <code>effect</code>。这是什么意思呢？举个例子，现在我们所实现的 <code>effect</code> 函数会立即执行传递给它的副作用函数，例如：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(\r\n02   // 这个函数会立即执行\r\n03   () => {\r\n04     console.log(obj.foo)\r\n05   }\r\n06 )</code></pre>\r\n<p>但在有些场景下，我们并不希望它立即执行，而是希望它在需要的时候才执行，例如计算属性。这时我们可以通过在 <code>options</code> 中添加 <code>lazy</code> 属性来达到目的，如下面的代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(\r\n02   // 指定了 lazy 选项，这个函数不会立即执行\r\n03   () => {\r\n04     console.log(obj.foo)\r\n05   },\r\n06   // options\r\n07   {\r\n08     lazy: true\r\n09   }\r\n10 )</code></pre>\r\n<p><code>lazy</code> 选项和之前介绍的 <code>scheduler</code> 一样，它通过 <code>options</code> 选项对象指定。有了它，我们就可以修改 <code>effect</code> 函数的实现逻辑了，当 <code>options.lazy</code> 为 <code>true</code> 时，则不立即执行副作用函数：</p>\r\n<pre class=\"no-line-number\"><code>01 function effect(fn, options = {}) {\r\n02   const effectFn = () => {\r\n03     cleanup(effectFn)\r\n04     activeEffect = effectFn\r\n05     effectStack.push(effectFn)\r\n06     fn()\r\n07     effectStack.pop()\r\n08     activeEffect = effectStack[effectStack.length - 1]\r\n09   }\r\n10   effectFn.options = options\r\n11   effectFn.deps = []\r\n12   // 只有非 lazy 的时候，才执行\r\n13   if (!options.lazy) {  // 新增\r\n14     // 执行副作用函数\r\n15     effectFn()\r\n16   }\r\n17   // 将副作用函数作为返回值返回\r\n18   return effectFn  // 新增\r\n19 }</code></pre>\r\n<p>通过这个判断，我们就实现了让副作用函数不立即执行的功能。但问题是，副作用函数应该什么时候执行呢？通过上面的代码可以看到，我们将副作用函数 <code>effectFn</code> 作为 <code>effect</code> 函数的返回值，这就意味着当调用 <code>effect</code> 函数时，通过其返回值能够拿到对应的副作用函数，这样我们就能手动执行该副作用函数了：</p>\r\n<pre class=\"no-line-number\"><code>01 const effectFn = effect(() => {\r\n02   console.log(obj.foo)\r\n03 }, { lazy: true })\r\n04\r\n05 // 手动执行副作用函数\r\n06 effectFn()</code></pre>\r\n<p>如果仅仅能够手动执行副作用函数，其意义并不大。但如果我们把传递给 <code>effect</code> 的函数看作一个 <code>getter</code>，那么这个 <code>getter</code> 函数可以返回任何值，例如：</p>\r\n<pre class=\"no-line-number\"><code>01 const effectFn = effect(\r\n02   // getter 返回 obj.foo 与 obj.bar 的和\r\n03   () => obj.foo + obj.bar,\r\n04   { lazy: true }\r\n05 )</code></pre>\r\n<p>这样我们在手动执行副作用函数时，就能够拿到其返回值：</p>\r\n<pre class=\"no-line-number\"><code>01 const effectFn = effect(\r\n02   // getter 返回 obj.foo 与 obj.bar 的和\r\n03   () => obj.foo + obj.bar,\r\n04   { lazy: true }\r\n05 )\r\n06 // value 是 getter 的返回值\r\n07 const value = effectFn()</code></pre>\r\n<p>为了实现这个目标，我们需要再对 <code>effect</code> 函数做一些修改，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 function effect(fn, options = {}) {\r\n02   const effectFn = () => {\r\n03     cleanup(effectFn)\r\n04     activeEffect = effectFn\r\n05     effectStack.push(effectFn)\r\n06     // 将 fn 的执行结果存储到 res 中\r\n07     const res = fn()  // 新增\r\n08     effectStack.pop()\r\n09     activeEffect = effectStack[effectStack.length - 1]\r\n10     // 将 res 作为 effectFn 的返回值\r\n11     return res  // 新增\r\n12   }\r\n13   effectFn.options = options\r\n14   effectFn.deps = []\r\n15   if (!options.lazy) {\r\n16     effectFn()\r\n17   }\r\n18\r\n19   return effectFn\r\n20 }</code></pre>\r\n<p>通过新增的代码可以看到，传递给 <code>effect</code> 函数的参数 <code>fn</code> 才是真正的副作用函数，而 <code>effectFn</code> 是我们包装后的副作用函数。为了通过 <code>effectFn</code> 得到真正的副作用函数 <code>fn</code> 的执行结果，我们需要将其保存到 <code>res</code> 变量中，然后将其作为 <code>effectFn</code> 函数的返回值。</p>\r\n<p>现在我们已经能够实现懒执行的副作用函数，并且能够拿到副作用函数的执行结果了，接下来就可以实现计算属性了，如下所示：</p>\r\n<pre class=\"no-line-number\"><code>01 function computed(getter) {\r\n02   // 把 getter 作为副作用函数，创建一个 lazy 的 effect\r\n03   const effectFn = effect(getter, {\r\n04     lazy: true\r\n05   })\r\n06\r\n07   const obj = {\r\n08     // 当读取 value 时才执行 effectFn\r\n09     get value() {\r\n10       return effectFn()\r\n11     }\r\n12   }\r\n13\r\n14   return obj\r\n15 }</code></pre>\r\n<p>首先我们定义一个 <code>computed</code> 函数，它接收一个 <code>getter</code> 函数作为参数，我们把 <code>getter</code> 函数作为副作用函数，用它创建一个 <code>lazy</code> 的 <code>effect</code>。<code>computed</code> 函数的执行会返回一个对象，该对象的 <code>value</code> 属性是一个访问器属性，只有当读取 <code>value</code> 的值时，才会执行 <code>effectFn</code> 并将其结果作为返回值返回。</p>\r\n<p>我们可以使用 <code>computed</code> 函数来创建一个计算属性：</p>\r\n<pre class=\"no-line-number\"><code>01 const data = { foo: 1, bar: 2 }\r\n02 const obj = new Proxy(data, { /* ... */ })\r\n03\r\n04 const sumRes = computed(() => obj.foo + obj.bar)\r\n05\r\n06 console.log(sumRes.value)  // 3</code></pre>\r\n<p>可以看到它能够正确地工作。不过现在我们实现的计算属性只做到了懒计算，也就是说，只有当你真正读取 <code>sumRes.value</code> 的值时，它才会进行计算并得到值。但是还做不到对值进行缓存，即假如我们多次访问 <code>sumRes.value</code> 的值，会导致 <code>effectFn</code> 进行多次计算，即使 <code>obj.foo</code> 和 <code>obj.bar</code> 的值本身并没有变化：</p>\r\n<pre class=\"no-line-number\"><code>01 console.log(sumRes.value)  // 3\r\n02 console.log(sumRes.value)  // 3\r\n03 console.log(sumRes.value)  // 3</code></pre>\r\n<p>上面的代码多次访问 <code>sumRes.value</code> 的值，每次访问都会调用 <code>effectFn</code> 重新计算。</p>\r\n<p>为了解决这个问题，就需要我们在实现 <code>computed</code> 函数时，添加对值进行缓存的功能，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 function computed(getter) {\r\n02   // value 用来缓存上一次计算的值\r\n03   let value\r\n04   // dirty 标志，用来标识是否需要重新计算值，为 true 则意味着“脏”，需要计算\r\n05   let dirty = true\r\n06\r\n07   const effectFn = effect(getter, {\r\n08     lazy: true\r\n09   })\r\n10\r\n11   const obj = {\r\n12     get value() {\r\n13       // 只有“脏”时才计算值，并将得到的值缓存到 value 中\r\n14       if (dirty) {\r\n15         value = effectFn()\r\n16         // 将 dirty 设置为 false，下一次访问直接使用缓存到 value 中的值\r\n17         dirty = false\r\n18       }\r\n19       return value\r\n20     }\r\n21   }\r\n22\r\n23   return obj\r\n24 }</code></pre>\r\n<p>我们新增了两个变量 <code>value</code> 和 <code>dirty</code>，其中 <code>value</code> 用来缓存上一次计算的值，而 <code>dirty</code> 是一个标识，代表是否需要重新计算。当我们通过 <code>sumRes.value</code> 访问值时，只有当 <code>dirty</code> 为 <code>true</code> 时才会调用 <code>effectFn</code> 重新计算值，否则直接使用上一次缓存在 <code>value</code> 中的值。这样无论我们访问多少次 <code>sumRes.value</code>，都只会在第一次访问时进行真正的计算，后续访问都会直接读取缓存的 <code>value</code> 值。</p>\r\n<p>相信聪明的你已经看到问题所在了，如果此时我们修改 <code>obj.foo</code> 或 <code>obj.bar</code> 的值，再访问 <code>sumRes.value</code> 会发现访问到的值没有发生变化：</p>\r\n<pre class=\"no-line-number\"><code>01 const data = { foo: 1, bar: 2 }\r\n02 const obj = new Proxy(data, { /* ... */ })\r\n03\r\n04 const sumRes = computed(() => obj.foo + obj.bar)\r\n05\r\n06 console.log(sumRes.value)  // 3\r\n07 console.log(sumRes.value)  // 3\r\n08\r\n09 // 修改 obj.foo\r\n10 obj.foo++\r\n11\r\n12 // 再次访问，得到的仍然是 3，但预期结果应该是 4\r\n13 console.log(sumRes.value)  // 3</code></pre>\r\n<p>这是因为，当第一次访问 <code>sumRes.value</code> 的值后，变量 <code>dirty</code> 会设置为 <code>false</code>，代表不需要计算。即使我们修改了 <code>obj.foo</code> 的值，但只要 <code>dirty</code> 的值为 <code>false</code>，就不会重新计算，所以导致我们得到了错误的值。</p>\r\n<p>解决办法很简单，当 <code>obj.foo</code> 或 <code>obj.bar</code> 的值发生变化时，只要 <code>dirty</code> 的值重置为 <code>true</code> 就可以了。那么应该怎么做呢？这时就用到了上一节介绍的 <code>scheduler</code> 选项，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 function computed(getter) {\r\n02   let value\r\n03   let dirty = true\r\n04\r\n05   const effectFn = effect(getter, {\r\n06     lazy: true,\r\n07     // 添加调度器，在调度器中将 dirty 重置为 true\r\n08     scheduler() {\r\n09       dirty = true\r\n10     }\r\n11   })\r\n12\r\n13   const obj = {\r\n14     get value() {\r\n15       if (dirty) {\r\n16         value = effectFn()\r\n17         dirty = false\r\n18       }\r\n19       return value\r\n20     }\r\n21   }\r\n22\r\n23   return obj\r\n24 }</code></pre>\r\n<p>我们为 <code>effect</code> 添加了 <code>scheduler</code> 调度器函数，它会在 <code>getter</code> 函数中所依赖的响应式数据变化时执行，这样我们在 <code>scheduler</code> 函数内将 <code>dirty</code> 重置为 <code>true</code>，当下一次访问 <code>sumRes.value</code> 时，就会重新调用 <code>effectFn</code> 计算值，这样就能够得到预期的结果了。</p>\r\n<p>现在，我们设计的计算属性已经趋于完美了，但还有一个缺陷，它体现在当我们在另外一个 <code>effect</code> 中读取计算属性的值时：</p>\r\n<pre class=\"no-line-number\"><code>01 const sumRes = computed(() => obj.foo + obj.bar)\r\n02\r\n03 effect(() => {\r\n04   // 在该副作用函数中读取 sumRes.value\r\n05   console.log(sumRes.value)\r\n06 })\r\n07\r\n08 // 修改 obj.foo 的值\r\n09 obj.foo++</code></pre>\r\n<p>如以上代码所示，<code>sumRes</code> 是一个计算属性，并且在另一个 <code>effect</code> 的副作用函数中读取了 <code>sumRes.value</code> 的值。如果此时修改 <code>obj.foo</code> 的值，我们期望副作用函数重新执行，就像我们在 Vue.js 的模板中读取计算属性值的时候，一旦计算属性发生变化就会触发重新渲染一样。但是如果尝试运行上面这段代码，会发现修改 <code>obj.foo</code> 的值并不会触发副作用函数的渲染，因此我们说这是一个缺陷。</p>\r\n<p>分析问题的原因，我们发现，从本质上看这就是一个典型的 <code>effect</code> 嵌套。一个计算属性内部拥有自己的 <code>effect</code>，并且它是懒执行的，只有当真正读取计算属性的值时才会执行。对于计算属性的 <code>getter</code> 函数来说，它里面访问的响应式数据只会把 <code>computed</code> 内部的 <code>effect</code> 收集为依赖。而当把计算属性用于另外一个 <code>effect</code> 时，就会发生 <code>effect</code> 嵌套，外层的 <code>effect</code> 不会被内层 <code>effect</code> 中的响应式数据收集。</p>\r\n<p>解决办法很简单。当读取计算属性的值时，我们可以手动调用 <code>track</code> 函数进行追踪；当计算属性依赖的响应式数据发生变化时，我们可以手动调用 <code>trigger</code> 函数触发响应：</p>\r\n<pre class=\"no-line-number\"><code>01 function computed(getter) {\r\n02   let value\r\n03   let dirty = true\r\n04\r\n05   const effectFn = effect(getter, {\r\n06     lazy: true,\r\n07     scheduler() {\r\n08       if (!dirty) {\r\n09         dirty = true\r\n10         // 当计算属性依赖的响应式数据变化时，手动调用 trigger 函数触发响应\r\n11         trigger(obj, 'value')\r\n12       }\r\n13     }\r\n14   })\r\n15\r\n16   const obj = {\r\n17     get value() {\r\n18       if (dirty) {\r\n19         value = effectFn()\r\n20         dirty = false\r\n21       }\r\n22       // 当读取 value 时，手动调用 track 函数进行追踪\r\n23       track(obj, 'value')\r\n24       return value\r\n25     }\r\n26   }\r\n27\r\n28   return obj\r\n29 }</code></pre>\r\n<p>如以上代码所示，当读取一个计算属性的 <code>value</code> 值时，我们手动调用 <code>track</code> 函数，把计算属性返回的对象 <code>obj</code> 作为 <code>target</code>，同时作为第一个参数传递给 <code>track</code> 函数。当计算属性所依赖的响应式数据变化时，会执行调度器函数，在调度器函数内手动调用 <code>trigger</code> 函数触发响应即可。这时，对于如下代码来说：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(function effectFn() {\r\n02   console.log(sumRes.value)\r\n03 })</code></pre>\r\n<p>它会建立这样的联系：</p>\r\n<pre class=\"no-line-number\"><code>01 computed(obj)\r\n02     └── value\r\n03         └── effectFn</code></pre>\r\n<p>图 4-10 给出了更详细的描述.</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00507.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-10　计算属性的响应联系</strong></p>\r\n<h2 id=\"nav_point_40\">4.9　<code>watch</code> 的实现原理</h2>\r\n<p>所谓 <code>watch</code>，其本质就是观测一个响应式数据，当数据发生变化时通知并执行相应的回调函数。举个例子：</p>\r\n<pre class=\"no-line-number\"><code>01 watch(obj, () => {\r\n02   console.log('数据变了')\r\n03 })\r\n04\r\n05 // 修改响应数据的值，会导致回调函数执行\r\n06 obj.foo++</code></pre>\r\n<p>假设 <code>obj</code> 是一个响应数据，使用 <code>watch</code> 函数观测它，并传递一个回调函数，当修改响应式数据的值时，会触发该回调函数执行。</p>\r\n<p>实际上，<code>watch</code> 的实现本质上就是利用了 <code>effect</code> 以及 <code>options.scheduler</code> 选项，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 effect(() => {\r\n02   console.log(obj.foo)\r\n03 }, {\r\n04   scheduler() {\r\n05     // 当 obj.foo 的值变化时，会执行 scheduler 调度函数\r\n06   }\r\n07 })</code></pre>\r\n<p>在一个副作用函数中访问响应式数据 <code>obj.foo</code>，通过前面的介绍，我们知道这会在副作用函数与响应式数据之间建立联系，当响应式数据变化时，会触发副作用函数重新执行。但有一个例外，即如果副作用函数存在 <code>scheduler</code> 选项，当响应式数据发生变化时，会触发 <code>scheduler</code> 调度函数执行，而非直接触发副作用函数执行。从这个角度来看，其实 <code>scheduler</code> 调度函数就相当于一个回调函数，而 <code>watch</code> 的实现就是利用了这个特点。下面是最简单的 <code>watch</code> 函数的实现：</p>\r\n<pre class=\"no-line-number\"><code>01 // watch 函数接收两个参数，source 是响应式数据，cb 是回调函数\r\n02 function watch(source, cb) {\r\n03   effect(\r\n04     // 触发读取操作，从而建立联系\r\n05     () => source.foo,\r\n06     {\r\n07       scheduler() {\r\n08         // 当数据变化时，调用回调函数 cb\r\n09         cb()\r\n10       }\r\n11     }\r\n12   )\r\n13 }</code></pre>\r\n<p>我们可以如下所示使用 <code>watch</code> 函数：</p>\r\n<pre class=\"no-line-number\"><code>01 const data = { foo: 1 }\r\n02 const obj = new Proxy(data, { /* ... */ })\r\n03\r\n04 watch(obj, () => {\r\n05   console.log('数据变化了')\r\n06 })\r\n07\r\n08 obj.foo++</code></pre>\r\n<p>上面这段代码能正常工作，但是我们注意到在 <code>watch</code> 函数的实现中，硬编码了对 <code>source.foo</code> 的读取操作。换句话说，现在只能观测 <code>obj.foo</code> 的改变。为了让 <code>watch</code> 函数具有通用性，我们需要一个封装一个通用的读取操作：</p>\r\n<pre class=\"no-line-number\"><code>01 function watch(source, cb) {\r\n02   effect(\r\n03     // 调用 traverse 递归地读取\r\n04     () => traverse(source),\r\n05     {\r\n06       scheduler() {\r\n07         // 当数据变化时，调用回调函数 cb\r\n08         cb()\r\n09       }\r\n10     }\r\n11   )\r\n12 }\r\n13\r\n14 function traverse(value, seen = new Set()) {\r\n15   // 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做\r\n16   if (typeof value !== 'object' || value === null || seen.has(value)) return\r\n17   // 将数据添加到 seen 中，代表遍历地读取过了，避免循环引用引起的死循环\r\n18   seen.add(value)\r\n19   // 暂时不考虑数组等其他结构\r\n20   // 假设 value 就是一个对象，使用 for...in 读取对象的每一个值，并递归地调用 traverse 进行处理\r\n21   for (const k in value) {\r\n22     traverse(value[k], seen)\r\n23   }\r\n24\r\n25   return value\r\n26 }</code></pre>\r\n<p>如上面的代码所示，在 <code>watch</code> 内部的 <code>effect</code> 中调用 <code>traverse</code> 函数进行递归的读取操作，代替硬编码的方式，这样就能读取一个对象上的任意属性，从而当任意属性发生变化时都能够触发回调函数执行。</p>\r\n<p><code>watch</code> 函数除了可以观测响应式数据，还可以接收一个 <code>getter</code> 函数：</p>\r\n<pre class=\"no-line-number\"><code>01 watch(\r\n02   // getter 函数\r\n03   () => obj.foo,\r\n04   // 回调函数\r\n05   () => {\r\n06     console.log('obj.foo 的值变了')\r\n07   }\r\n08 )</code></pre>\r\n<p>如以上代码所示，传递给 <code>watch</code> 函数的第一个参数不再是一个响应式数据，而是一个 <code>getter</code> 函数。在 <code>getter</code> 函数内部，用户可以指定该 <code>watch</code> 依赖哪些响应式数据，只有当这些数据变化时，才会触发回调函数执行。如下代码实现了这一功能：</p>\r\n<pre class=\"no-line-number\"><code>01 function watch(source, cb) {\r\n02   // 定义 getter\r\n03   let getter\r\n04   // 如果 source 是函数，说明用户传递的是 getter，所以直接把 source 赋值给 getter\r\n05   if (typeof source === 'function') {\r\n06     getter = source\r\n07   } else {\r\n08     // 否则按照原来的实现调用 traverse 递归地读取\r\n09     getter = () => traverse(source)\r\n10   }\r\n11\r\n12   effect(\r\n13     // 执行 getter\r\n14     () => getter(),\r\n15     {\r\n16       scheduler() {\r\n17         cb()\r\n18       }\r\n19     }\r\n20   )\r\n21 }</code></pre>\r\n<p>首先判断 <code>source</code> 的类型，如果是函数类型，说明用户直接传递了 <code>getter</code> 函数，这时直接使用用户的 <code>getter</code> 函数；如果不是函数类型，那么保留之前的做法，即调用 <code>traverse</code> 函数递归地读取。这样就实现了自定义 <code>getter</code> 的功能，同时使得 <code>watch</code> 函数更加强大。</p>\r\n<p>细心的你可能已经注意到了，现在的实现还缺少一个非常重要的能力，即在回调函数中拿不到旧值与新值。通常我们在使用 Vue.js 中的 <code>watch</code> 函数时，能够在回调函数中得到变化前后的值：</p>\r\n<pre class=\"no-line-number\"><code>01 watch(\r\n02   () => obj.foo,\r\n03   (newValue, oldValue) => {\r\n04     console.log(newValue, oldValue)  // 2, 1\r\n05   }\r\n06 )\r\n07\r\n08 obj.foo++</code></pre>\r\n<p>那么如何获得新值与旧值呢？这需要充分利用 <code>effect</code> 函数的 <code>lazy</code> 选项，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 function watch(source, cb) {\r\n02   let getter\r\n03   if (typeof source === 'function') {\r\n04     getter = source\r\n05   } else {\r\n06     getter = () => traverse(source)\r\n07   }\r\n08   // 定义旧值与新值\r\n09   let oldValue, newValue\r\n10   // 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用\r\n11   const effectFn = effect(\r\n12     () => getter(),\r\n13     {\r\n14       lazy: true,\r\n15       scheduler() {\r\n16         // 在 scheduler 中重新执行副作用函数，得到的是新值\r\n17         newValue = effectFn()\r\n18         // 将旧值和新值作为回调函数的参数\r\n19         cb(newValue, oldValue)\r\n20         // 更新旧值，不然下一次会得到错误的旧值\r\n21         oldValue = newValue\r\n22       }\r\n23     }\r\n24   )\r\n25   // 手动调用副作用函数，拿到的值就是旧值\r\n26   oldValue = effectFn()\r\n27 }</code></pre>\r\n<p>在这段代码中，最核心的改动是使用 <code>lazy</code> 选项创建了一个懒执行的 <code>effect</code>。注意上面代码中最下面的部分，我们手动调用 <code>effectFn</code> 函数得到的返回值就是旧值，即第一次执行得到的值。当变化发生并触发 <code>scheduler</code> 调度函数执行时，会重新调用 <code>effectFn</code> 函数并得到新值，这样我们就拿到了旧值与新值，接着将它们作为参数传递给回调函数 <code>cb</code> 就可以了。最后一件非常重要的事情是，不要忘记使用新值更新旧值：<code>oldValue = newValue</code>，否则在下一次变更发生时会得到错误的旧值。</p>\r\n<h2 id=\"nav_point_41\">4.10　立即执行的 <code>watch</code> 与回调执行时机</h2>\r\n<p>上一节中我们介绍了 <code>watch</code> 的基本实现。在这个过程中我们认识到，<code>watch</code> 的本质其实是对 <code>effect</code> 的二次封装。本节我们继续讨论关于 <code>watch</code> 的两个特性：一个是立即执行的回调函数，另一个是回调函数的执行时机。</p>\r\n<p>首先来看立即执行的回调函数。默认情况下，一个 <code>watch</code> 的回调只会在响应式数据发生变化时才执行：</p>\r\n<pre class=\"no-line-number\"><code>01 // 回调函数只有在响应式数据 obj 后续发生变化时才执行\r\n02 watch(obj, () => {\r\n03   console.log('变化了')\r\n04 })</code></pre>\r\n<p>在 Vue.js 中可以通过选项参数 <code>immediate</code> 来指定回调是否需要立即执行：</p>\r\n<pre class=\"no-line-number\"><code>01 watch(obj, () => {\r\n02   console.log('变化了')\r\n03 }, {\r\n04   // 回调函数会在 watch 创建时立即执行一次\r\n05   immediate: true\r\n06 })</code></pre>\r\n<p>当 <code>immediate</code> 选项存在并且为 <code>true</code> 时，回调函数会在该 <code>watch</code> 创建时立刻执行一次。仔细思考就会发现，回调函数的立即执行与后续执行本质上没有任何差别，所以我们可以把 <code>scheduler</code> 调度函数封装为一个通用函数，分别在初始化和变更时执行它，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 function watch(source, cb, options = {}) {\r\n02   let getter\r\n03   if (typeof source === 'function') {\r\n04     getter = source\r\n05   } else {\r\n06     getter = () => traverse(source)\r\n07   }\r\n08\r\n09   let oldValue, newValue\r\n10\r\n11   // 提取 scheduler 调度函数为一个独立的 job 函数\r\n12   const job = () => {\r\n13     newValue = effectFn()\r\n14     cb(newValue, oldValue)\r\n15     oldValue = newValue\r\n16   }\r\n17\r\n18   const effectFn = effect(\r\n19     // 执行 getter\r\n20     () => getter(),\r\n21     {\r\n22       lazy: true,\r\n23       // 使用 job 函数作为调度器函数\r\n24       scheduler: job\r\n25     }\r\n26   )\r\n27\r\n28   if (options.immediate) {\r\n29     // 当 immediate 为 true 时立即执行 job，从而触发回调执行\r\n30     job()\r\n31   } else {\r\n32     oldValue = effectFn()\r\n33   }\r\n34 }</code></pre>\r\n<p>这样就实现了回调函数的立即执行功能。由于回调函数是立即执行的，所以第一次回调执行时没有所谓的旧值，因此此时回调函数的 <code>oldValue</code> 值为 <code>undefined</code>，这也是符合预期的。</p>\r\n<p>除了指定回调函数为立即执行之外，还可以通过其他选项参数来指定回调函数的执行时机，例如在 Vue.js 3 中使用 <code>flush</code> 选项来指定：</p>\r\n<pre class=\"no-line-number\"><code>01 watch(obj, () => {\r\n02   console.log('变化了')\r\n03 }, {\r\n04   // 回调函数会在 watch 创建时立即执行一次\r\n05   flush: 'pre' // 还可以指定为 'post' | 'sync'\r\n06 })</code></pre>\r\n<p><code>flush</code> 本质上是在指定调度函数的执行时机。前文讲解过如何在微任务队列中执行调度函数 <code>scheduler</code>，这与 <code>flush</code> 的功能相同。当 <code>flush</code> 的值为 <code>'post'</code> 时，代表调度函数需要将副作用函数放到一个微任务队列中，并等待 DOM 更新结束后再执行，我们可以用如下代码进行模拟：</p>\r\n<pre class=\"no-line-number\"><code>01 function watch(source, cb, options = {}) {\r\n02   let getter\r\n03   if (typeof source === 'function') {\r\n04     getter = source\r\n05   } else {\r\n06     getter = () => traverse(source)\r\n07   }\r\n08\r\n09   let oldValue, newValue\r\n10\r\n11   const job = () => {\r\n12     newValue = effectFn()\r\n13     cb(newValue, oldValue)\r\n14     oldValue = newValue\r\n15   }\r\n16\r\n17   const effectFn = effect(\r\n18     // 执行 getter\r\n19     () => getter(),\r\n20     {\r\n21       lazy: true,\r\n22       scheduler: () => {\r\n23         // 在调度函数中判断 flush 是否为 'post'，如果是，将其放到微任务队列中执行\r\n24         if (options.flush === 'post') {\r\n25           const p = Promise.resolve()\r\n26           p.then(job)\r\n27         } else {\r\n28           job()\r\n29         }\r\n30       }\r\n31     }\r\n32   )\r\n33\r\n34   if (options.immediate) {\r\n35     job()\r\n36   } else {\r\n37     oldValue = effectFn()\r\n38   }\r\n39 }</code></pre>\r\n<p>如以上代码所示，我们修改了调度器函数 <code>scheduler</code> 的实现方式，在调度器函数内检测 <code>options.flush</code> 的值是否为 <code>post</code>，如果是，则将 <code>job</code> 函数放到微任务队列中，从而实现异步延迟执行；否则直接执行 <code>job</code> 函数，这本质上相当于 <code>'sync'</code> 的实现机制，即同步执行。对于 <code>options.flush</code> 的值为 <code>'pre'</code> 的情况，我们暂时还没有办法模拟，因为这涉及组件的更新时机，其中 <code>'pre'</code> 和 <code>'post'</code> 原本的语义指的就是组件更新前和更新后，不过这并不影响我们理解如何控制回调函数的更新时机。</p>\r\n<h2 id=\"nav_point_42\">4.11　过期的副作用</h2>\r\n<p>竞态问题通常在多进程或多线程编程中被提及，前端工程师可能很少讨论它，但在日常工作中你可能早就遇到过与竞态问题相似的场景，举个例子：</p>\r\n<pre class=\"no-line-number\"><code>01 let finalData\r\n02\r\n03 watch(obj, async () => {\r\n04   // 发送并等待网络请求\r\n05   const res = await fetch('/path/to/request')\r\n06   // 将请求结果赋值给 data\r\n07   finalData = res\r\n08 })</code></pre>\r\n<p>在这段代码中，我们使用 <code>watch</code> 观测 <code>obj</code> 对象的变化，每次 <code>obj</code> 对象发生变化都会发送网络请求，例如请求接口数据，等数据请求成功之后，将结果赋值给 <code>finalData</code> 变量。</p>\r\n<p>观察上面的代码，乍一看似乎没什么问题。但仔细思考会发现这段代码会发生竞态问题。假设我们第一次修改 <code>obj</code> 对象的某个字段值，这会导致回调函数执行，同时发送了第一次请求 A。随着时间的推移，在请求 A 的结果返回之前，我们对 <code>obj</code> 对象的某个字段值进行了第二次修改，这会导致发送第二次请求 B。此时请求 A 和请求 B 都在进行中，那么哪一个请求会先返回结果呢？我们不确定，如果请求 B 先于请求 A 返回结果，就会导致最终 <code>finalData</code> 中存储的是 A 请求的结果，如图 4-11 所示。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00508.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-11　请求 A 的结果覆盖请求 B 的结果</strong></p>\r\n<p>但由于请求 B 是后发送的，因此我们认为请求 B 返回的数据才是“最新”的，而请求 A 则应该被视为“过期”的，所以我们希望变量 <code>finalData</code> 存储的值应该是由请求 B 返回的结果，而非请求 A 返回的结果。</p>\r\n<p>实际上，我们可以对这个问题做进一步总结。请求 A 是副作用函数第一次执行所产生的副作用，请求 B 是副作用函数第二次执行所产生的副作用。由于请求 B 后发生，所以请求 B 的结果应该被视为“最新”的，而请求 A 已经“过期”了，其产生的结果应被视为无效。通过这种方式，就可以避免竞态问题导致的错误结果。</p>\r\n<p>归根结底，我们需要的是一个让副作用过期的手段。为了让问题更加清晰，我们先拿 Vue.js 中的 <code>watch</code> 函数来复现场景，看看 Vue.js 是如何帮助开发者解决这个问题的，然后尝试实现这个功能。</p>\r\n<p>在 Vue.js 中，<code>watch</code> 函数的回调函数接收第三个参数 <code>onInvalidate</code>，它是一个函数，类似于事件监听器，我们可以使用 <code>onInvalidate</code> 函数注册一个回调，这个回调函数会在当前副作用函数过期时执行：</p>\r\n<pre class=\"no-line-number\"><code>01 watch(obj, async (newValue, oldValue, onInvalidate) => {\r\n02   // 定义一个标志，代表当前副作用函数是否过期，默认为 false，代表没有过期\r\n03   let expired = false\r\n04   // 调用 onInvalidate() 函数注册一个过期回调\r\n05   onInvalidate(() => {\r\n06     // 当过期时，将 expired 设置为 true\r\n07     expired = true\r\n08   })\r\n09\r\n10   // 发送网络请求\r\n11   const res = await fetch('/path/to/request')\r\n12\r\n13   // 只有当该副作用函数的执行没有过期时，才会执行后续操作。\r\n14   if (!expired) {\r\n15     finalData = res\r\n16   }\r\n17 })</code></pre>\r\n<p>如上面的代码所示，在发送请求之前，我们定义了 <code>expired</code> 标志变量，用来标识当前副作用函数的执行是否过期；接着调用 <code>onInvalidate</code> 函数注册了一个过期回调，当该副作用函数的执行过期时将 <code>expired</code> 标志变量设置为 <code>true</code>；最后只有当没有过期时才采用请求结果，这样就可以有效地避免上述问题了。</p>\r\n<p>那么 Vue.js 是怎么做到的呢？换句话说，<code>onInvalidate</code> 的原理是什么呢？其实很简单，在 <code>watch</code> 内部每次检测到变更后，在副作用函数重新执行之前，会先调用我们通过 <code>onInvalidate</code> 函数注册的过期回调，仅此而已，如以下代码所示：</p>\r\n<pre class=\"no-line-number\"><code>01 function watch(source, cb, options = {}) {\r\n02   let getter\r\n03   if (typeof source === 'function') {\r\n04     getter = source\r\n05   } else {\r\n06     getter = () => traverse(source)\r\n07   }\r\n08\r\n09   let oldValue, newValue\r\n10\r\n11   // cleanup 用来存储用户注册的过期回调\r\n12   let cleanup\r\n13   // 定义 onInvalidate 函数\r\n14   function onInvalidate(fn) {\r\n15     // 将过期回调存储到 cleanup 中\r\n16     cleanup = fn\r\n17   }\r\n18\r\n19   const job = () => {\r\n20     newValue = effectFn()\r\n21     // 在调用回调函数 cb 之前，先调用过期回调\r\n22     if (cleanup) {\r\n23       cleanup()\r\n24     }\r\n25     // 将 onInvalidate 作为回调函数的第三个参数，以便用户使用\r\n26     cb(newValue, oldValue, onInvalidate)\r\n27     oldValue = newValue\r\n28   }\r\n29\r\n30   const effectFn = effect(\r\n31     // 执行 getter\r\n32     () => getter(),\r\n33     {\r\n34       lazy: true,\r\n35       scheduler: () => {\r\n36         if (options.flush === 'post') {\r\n37           const p = Promise.resolve()\r\n38           p.then(job)\r\n39         } else {\r\n40           job()\r\n41         }\r\n42       }\r\n43     }\r\n44   )\r\n45\r\n46   if (options.immediate) {\r\n47     job()\r\n48   } else {\r\n49     oldValue = effectFn()\r\n50   }\r\n51 }</code></pre>\r\n<p>在这段代码中，我们首先定义了 <code>cleanup</code> 变量，这个变量用来存储用户通过 <code>onInvalidate</code> 函数注册的过期回调。可以看到 <code>onInvalidate</code> 函数的实现非常简单，只是把过期回调赋值给了 <code>cleanup</code> 变量。这里的关键点在 <code>job</code> 函数内，每次执行回调函数 <code>cb</code> 之前，先检查是否存在过期回调，如果存在，则执行过期回调函数 <code>cleanup</code>。最后我们把 <code>onInvalidate</code> 函数作为回调函数的第三个参数传递给 <code>cb</code>，以便用户使用。</p>\r\n<p>我们还是通过一个例子来进一步说明：</p>\r\n<pre class=\"no-line-number\"><code>01 watch(obj, async (newValue, oldValue, onInvalidate) => {\r\n02   let expired = false\r\n03   onInvalidate(() => {\r\n04     expired = true\r\n05   })\r\n06\r\n07   const res = await fetch('/path/to/request')\r\n08\r\n09   if (!expired) {\r\n10     finalData = res\r\n11   }\r\n12 })\r\n13\r\n14 // 第一次修改\r\n15 obj.foo++\r\n16 setTimeout(() => {\r\n17   // 200ms 后做第二次修改\r\n18   obj.foo++\r\n19 }, 200)</code></pre>\r\n<p>如以上代码所示，我们修改了两次 <code>obj.foo</code> 的值，第一次修改是立即执行的，这会导致 <code>watch</code> 的回调函数执行。由于我们在回调函数内调用了 <code>onInvalidate</code>，所以会注册一个过期回调，接着发送请求 A。假设请求 A 需要 1000ms 才能返回结果，而我们在 200ms 时第二次修改了 <code>obj.foo</code> 的值，这又会导致 <code>watch</code> 的回调函数执行。这时要注意的是，在我们的实现中，每次执行回调函数之前要先检查过期回调是否存在，如果存在，会优先执行过期回调。由于在 <code>watch</code> 的回调函数第一次执行的时候，我们已经注册了一个过期回调，所以在 <code>watch</code> 的回调函数第二次执行之前，会优先执行之前注册的过期回调，这会使得第一次执行的副作用函数内闭包的变量 <code>expired</code> 的值变为 <code>true</code>，即副作用函数的执行过期了。于是等请求 A 的结果返回时，其结果会被抛弃，从而避免了过期的副作用函数带来的影响，如图 4-12 所示。</p>\r\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00509.jpeg\" alt=\"{%}\" /></p>\r\n<p class=\"ebook-image-title\"><strong>图 4-12　请求过期</strong></p>\r\n<h2 id=\"nav_point_43\">4.12　总结</h2>\r\n<p>在本章中，我们首先介绍了副作用函数和响应式数据的概念，以及它们之间的关系。一个响应式数据最基本的实现依赖于对“读取”和“设置”操作的拦截，从而在副作用函数与响应式数据之间建立联系。当“读取”操作发生时，我们将当前执行的副作用函数存储到“桶”中；当“设置”操作发生时，再将副作用函数从“桶”里取出并执行。这就是响应系统的根本实现原理。</p>\r\n<p>接着，我们实现了一个相对完善的响应系统。使用 <code>WeakMap</code> 配合 <code>Map</code> 构建了新的“桶”结构，从而能够在响应式数据与副作用函数之间建立更加精确的联系。同时，我们也介绍了 <code>WeakMap</code> 与 <code>Map</code> 这两个数据结构之间的区别。<code>WeakMap</code> 是弱引用的，它不影响垃圾回收器的工作。当用户代码对一个对象没有引用关系时，<code>WeakMap</code> 不会阻止垃圾回收器回收该对象。</p>\r\n<p>我们还讨论了分支切换导致的冗余副作用的问题，这个问题会导致副作用函数进行不必要的更新。为了解决这个问题，我们需要在每次副作用函数重新执行之前，清除上一次建立的响应联系，而当副作用函数重新执行后，会再次建立新的响应联系，新的响应联系中不存在冗余副作用问题，从而解决了问题。但在此过程中，我们还遇到了遍历 <code>Set</code> 数据结构导致无限循环的新问题，该问题产生的原因可以从 ECMA 规范中得知，即“在调用 <code>forEach</code> 遍历 <code>Set</code> 集合时，如果一个值已经被访问过了，但这个值被删除并重新添加到集合，如果此时 <code>forEach</code> 遍历没有结束，那么这个值会重新被访问。”解决方案是建立一个新的 <code>Set</code> 数据结构用来遍历。</p>\r\n<p>然后，我们讨论了关于嵌套的副作用函数的问题。在实际场景中，嵌套的副作用函数发生在组件嵌套的场景中，即父子组件关系。这时为了避免在响应式数据与副作用函数之间建立的响应联系发生错乱，我们需要使用副作用函数栈来存储不同的副作用函数。当一个副作用函数执行完毕后，将其从栈中弹出。当读取响应式数据的时候，被读取的响应式数据只会与当前栈顶的副作用函数建立响应联系，从而解决问题。而后，我们遇到了副作用函数无限递归地调用自身，导致栈溢出的问题。该问题的根本原因在于，对响应式数据的读取和设置操作发生在同一个副作用函数内。解决办法很简单，<strong>如果 <code>trigger</code> 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</strong>。</p>\r\n<p>随后，我们讨论了响应系统的可调度性。所谓可调度，指的是当 <code>trigger</code> 动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式。为了实现调度能力，我们为 <code>effect</code> 函数增加了第二个选项参数，可以通过 <code>scheduler</code> 选项指定调用器，这样用户可以通过调度器自行完成任务的调度。我们还讲解了如何通过调度器实现任务去重，即通过一个微任务队列对任务进行缓存，从而实现去重。</p>\r\n<p>而后，我们讲解了计算属性，即 <code>computed</code>。计算属性实际上是一个懒执行的副作用函数，我们通过 <code>lazy</code> 选项使得副作用函数可以懒执行。被标记为懒执行的副作用函数可以通过手动方式让其执行。利用这个特点，我们设计了计算属性，当读取计算属性的值时，只需要手动执行副作用函数即可。当计算属性依赖的响应式数据发生变化时，会通过 <code>scheduler</code> 将 <code>dirty</code> 标记设置为 <code>true</code>，代表“脏”。这样，下次读取计算属性的值时，我们会重新计算真正的值。</p>\r\n<p>之后，我们讨论了 <code>watch</code> 的实现原理。它本质上利用了副作用函数重新执行时的可调度性。一个 <code>watch</code> 本身会创建一个 <code>effect</code>，当这个 <code>effect</code> 依赖的响应式数据发生变化时，会执行该 <code>effect</code> 的调度器函数，即 <code>scheduler</code>。这里的 <code>scheduler</code> 可以理解为“回调”，所以我们只需要在 <code>scheduler</code> 中执行用户通过 <code>watch</code> 函数注册的回调函数即可。此外，我们还讲解了立即执行回调的 <code>watch</code>，通过添加新的 <code>immediate</code> 选项来实现，还讨论了如何控制回调函数的执行时机，通过 <code>flush</code> 选项来指定回调函数具体的执行时机，本质上是利用了调用器和异步的微任务队列。</p>\r\n<p>最后，我们讨论了过期的副作用函数，它会导致竞态问题。为了解决这个问题，Vue.js 为 <code>watch</code> 的回调函数设计了第三个参数，即 <code>onInvalidate</code>。它是一个函数，用来注册过期回调。每当 <code>watch</code> 的回调函数执行之前，会优先执行用户通过 <code>onInvalidate</code> 注册的过期回调。这样，用户就有机会在过期回调中将上一次的副作用标记为“过期”，从而解决竞态问题。</p>\r\n\r\n<br style=\"page-break-after:always\" /><div style=\"page-break-after:always\"></div>\r\n","comments":[{"had_liked":false,"id":395609,"user_name":"李凯旋","can_delete":false,"product_type":"c1","uid":1116001,"ip_address":"河北","ucode":"FC267DD00F620D","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/61/8adbd0ae.jpg","comment_is_top":false,"comment_ctime":1731401255,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636603,"comment_content":"计算属性如果按文中在get value 内再 track(obj, &#39;value&#39;)后，如果不再effect内嵌套读取计算属性就会栈溢出了","like_count":0},{"had_liked":false,"id":389775,"user_name":"之风","can_delete":false,"product_type":"c1","uid":1382279,"ip_address":"江苏","ucode":"8F5577B8DEBD80","user_header":"https://static001.geekbang.org/account/avatar/00/15/17/87/75d20082.jpg","comment_is_top":false,"comment_ctime":1713436363,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636603,"comment_content":"oldValue 和 newValue 那，是不是监听的是一个对象，就会导致引用地址一致，oldValue 始终等于 newValue.","like_count":0}]}