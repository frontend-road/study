{"id":41607,"title":"22 | 撬动离线业务：Job与CronJob","content":"<p>你好，我是张磊。今天我和你分享的主题是：撬动离线业务之Job与CronJob。</p><p>在前面的几篇文章中，我和你详细分享了Deployment、StatefulSet，以及DaemonSet这三个编排概念。你有没有发现它们的共同之处呢？</p><p>实际上，它们主要编排的对象，都是“在线业务”，即：Long Running Task（长作业）。比如，我在前面举例时常用的Nginx、Tomcat，以及MySQL等等。这些应用一旦运行起来，除非出错或者停止，它的容器进程会一直保持在Running状态。</p><p>但是，有一类作业显然不满足这样的条件，这就是“离线业务”，或者叫作Batch Job（计算业务）。这种业务在计算完成后就直接退出了，而此时如果你依然用Deployment来管理这种业务的话，就会发现Pod会在计算结束后退出，然后被Deployment Controller不断地重启；而像“滚动更新”这样的编排功能，更无从谈起了。</p><p>所以，早在Borg项目中，Google就已经对作业进行了分类处理，提出了LRS（Long Running Service）和Batch Jobs两种作业形态，对它们进行“分别管理”和“混合调度”。</p><p>不过，在2015年Borg论文刚刚发布的时候，Kubernetes项目并不支持对Batch Job的管理。直到v1.4版本之后，社区才逐步设计出了一个用来描述离线业务的API对象，它的名字就是：Job。</p><!-- [[[read_end]]] --><p><span class=\"orange\">Job API对象的定义非常简单，我来举个例子</span>，如下所示：</p><pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: pi\nspec:\n  template:\n    spec:\n      containers:\n      - name: pi\n        image: resouer/ubuntu-bc \n        command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo 'scale=10000; 4*a(1)' | bc -l &quot;]\n      restartPolicy: Never\n  backoffLimit: 4\n</code></pre><p>此时，相信你对Kubernetes的API对象已经不再陌生了。在这个Job的YAML文件里，你肯定一眼就会看到一位“老熟人”：Pod模板，即spec.template字段。</p><p>在这个Pod模板中，我定义了一个Ubuntu镜像的容器（准确地说，是一个安装了bc命令的Ubuntu镜像），它运行的程序是：</p><pre><code>echo &quot;scale=10000; 4*a(1)&quot; | bc -l \n</code></pre><p>其中，bc命令是Linux里的“计算器”；-l表示，我现在要使用标准数学库；而a(1)，则是调用数学库中的arctangent函数，计算atan(1)。这是什么意思呢？</p><p>中学知识告诉我们：<code>tan(π/4) = 1</code>。所以，<code>4*atan(1)</code>正好就是π，也就是3.1415926…。</p><blockquote>\n<p>备注：如果你不熟悉这个知识也不必担心，我也是在查阅资料后才知道的。</p>\n</blockquote><p>所以，这其实就是一个计算π值的容器。而通过scale=10000，我指定了输出的小数点后的位数是10000。在我的计算机上，这个计算大概用时1分54秒。</p><p>但是，跟其他控制器不同的是，Job对象并不要求你定义一个spec.selector来描述要控制哪些Pod。具体原因，我马上会讲解到。</p><p>现在，我们就可以创建这个Job了：</p><pre><code>$ kubectl create -f job.yaml\n</code></pre><p>在成功创建后，我们来查看一下这个Job对象，如下所示：</p><pre><code>$ kubectl describe jobs/pi\nName:             pi\nNamespace:        default\nSelector:         controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495\nLabels:           controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495\n                  job-name=pi\nAnnotations:      &lt;none&gt;\nParallelism:      1\nCompletions:      1\n..\nPods Statuses:    0 Running / 1 Succeeded / 0 Failed\nPod Template:\n  Labels:       controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495\n                job-name=pi\n  Containers:\n   ...\n  Volumes:              &lt;none&gt;\nEvents:\n  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message\n  ---------    --------    -----    ----            -------------    --------    ------            -------\n  1m           1m          1        {job-controller }                Normal      SuccessfulCreate  Created pod: pi-rq5rl\n</code></pre><p>可以看到，这个Job对象在创建后，它的Pod模板，被自动加上了一个controller-uid=&lt;一个随机字符串&gt;这样的Label。而这个Job对象本身，则被自动加上了这个Label对应的Selector，从而 保证了Job与它所管理的Pod之间的匹配关系。</p><p>而Job Controller之所以要使用这种携带了UID的Label，就是为了避免不同Job对象所管理的Pod发生重合。需要注意的是，<strong>这种自动生成的Label对用户来说并不友好，所以不太适合推广到Deployment等长作业编排对象上。</strong></p><p>接下来，我们可以看到这个Job创建的Pod进入了Running状态，这意味着它正在计算Pi的值。</p><pre><code>$ kubectl get pods\nNAME                                READY     STATUS    RESTARTS   AGE\npi-rq5rl                            1/1       Running   0          10s\n</code></pre><p>而几分钟后计算结束，这个Pod就会进入Completed状态：</p><pre><code>$ kubectl get pods\nNAME                                READY     STATUS      RESTARTS   AGE\npi-rq5rl                            0/1       Completed   0          4m\n</code></pre><p>这也是我们需要在Pod模板中定义restartPolicy=Never的原因：离线计算的Pod永远都不应该被重启，否则它们会再重新计算一遍。</p><blockquote>\n<p>事实上，restartPolicy在Job对象里只允许被设置为Never和OnFailure；而在Deployment对象里，restartPolicy则只允许被设置为Always。</p>\n</blockquote><p>此时，我们通过kubectl logs查看一下这个Pod的日志，就可以看到计算得到的Pi值已经被打印了出来：</p><pre><code>$ kubectl logs pi-rq5rl\n3.141592653589793238462643383279...\n</code></pre><p>这时候，你一定会想到这样一个问题，<strong>如果这个离线作业失败了要怎么办？</strong></p><p>比如，我们在这个例子中<strong>定义了restartPolicy=Never，那么离线作业失败后Job Controller就会不断地尝试创建一个新Pod</strong>，如下所示：</p><pre><code>$ kubectl get pods\nNAME                                READY     STATUS              RESTARTS   AGE\npi-55h89                            0/1       ContainerCreating   0          2s\npi-tqbcz                            0/1       Error               0          5s\n</code></pre><p>可以看到，这时候会不断地有新Pod被创建出来。</p><p>当然，这个尝试肯定不能无限进行下去。所以，我们就在Job对象的spec.backoffLimit字段里定义了重试次数为4（即，backoffLimit=4），而这个字段的默认值是6。</p><p>需要注意的是，Job Controller重新创建Pod的间隔是呈指数增加的，即下一次重新创建Pod的动作会分别发生在10 s、20 s、40 s …后。</p><p>而如果你<strong>定义的restartPolicy=OnFailure，那么离线作业失败后，Job Controller就不会去尝试创建新的Pod。但是，它会不断地尝试重启Pod里的容器</strong>。这也正好对应了restartPolicy的含义（你也可以借此机会再回顾一下第15篇文章<a href=\"https://time.geekbang.org/column/article/40466\">《深入解析Pod对象（二）：使用进阶》</a>中的相关内容）。</p><p>如前所述，当一个Job的Pod运行结束后，它会进入Completed状态。但是，如果这个Pod因为某种原因一直不肯结束呢？</p><p>在Job的API对象里，有一个spec.activeDeadlineSeconds字段可以设置最长运行时间，比如：</p><pre><code>spec:\n backoffLimit: 5\n activeDeadlineSeconds: 100\n</code></pre><p>一旦运行超过了100 s，这个Job的所有Pod都会被终止。并且，你可以在Pod的状态里看到终止的原因是reason: DeadlineExceeded。</p><p>以上，就是一个Job API对象最主要的概念和用法了。不过，离线业务之所以被称为Batch Job，当然是因为它们可以以“Batch”，也就是并行的方式去运行。</p><p>接下来，我就来为你讲解一下<span class=\"orange\">Job Controller对并行作业的控制方法。</span></p><p>在Job对象中，负责并行控制的参数有两个：</p><ol>\n<li>\n<p>spec.parallelism，它定义的是一个Job在任意时间最多可以启动多少个Pod同时运行；</p>\n</li>\n<li>\n<p>spec.completions，它定义的是Job至少要完成的Pod数目，即Job的最小完成数。</p>\n</li>\n</ol><p>这两个参数听起来有点儿抽象，所以我准备了一个例子来帮助你理解。</p><p>现在，我在之前计算Pi值的Job里，添加这两个参数：</p><pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: pi\nspec:\n  parallelism: 2\n  completions: 4\n  template:\n    spec:\n      containers:\n      - name: pi\n        image: resouer/ubuntu-bc\n        command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo 'scale=5000; 4*a(1)' | bc -l &quot;]\n      restartPolicy: Never\n  backoffLimit: 4\n</code></pre><p>这样，我们就指定了这个Job最大的并行数是2，而最小的完成数是4。</p><p>接下来，我们来创建这个Job对象：</p><pre><code>$ kubectl create -f job.yaml\n</code></pre><p>可以看到，这个Job其实也维护了两个状态字段，即DESIRED和SUCCESSFUL，如下所示：</p><pre><code>$ kubectl get job\nNAME      DESIRED   SUCCESSFUL   AGE\npi        4         0            3s\n</code></pre><p>其中，DESIRED的值，正是completions定义的最小完成数。</p><p>然后，我们可以看到，这个Job首先创建了两个并行运行的Pod来计算Pi：</p><pre><code>$ kubectl get pods\nNAME       READY     STATUS    RESTARTS   AGE\npi-5mt88   1/1       Running   0          6s\npi-gmcq5   1/1       Running   0          6s\n</code></pre><p>而在40 s后，这两个Pod相继完成计算。</p><p>这时我们可以看到，每当有一个Pod完成计算进入Completed状态时，就会有一个新的Pod被自动创建出来，并且快速地从Pending状态进入到ContainerCreating状态：</p><pre><code>$ kubectl get pods\nNAME       READY     STATUS    RESTARTS   AGE\npi-gmcq5   0/1       Completed   0         40s\npi-84ww8   0/1       Pending   0         0s\npi-5mt88   0/1       Completed   0         41s\npi-62rbt   0/1       Pending   0         0s\n\n$ kubectl get pods\nNAME       READY     STATUS    RESTARTS   AGE\npi-gmcq5   0/1       Completed   0         40s\npi-84ww8   0/1       ContainerCreating   0         0s\npi-5mt88   0/1       Completed   0         41s\npi-62rbt   0/1       ContainerCreating   0         0s\n</code></pre><p>紧接着，Job Controller第二次创建出来的两个并行的Pod也进入了Running状态：</p><pre><code>$ kubectl get pods \nNAME       READY     STATUS      RESTARTS   AGE\npi-5mt88   0/1       Completed   0          54s\npi-62rbt   1/1       Running     0          13s\npi-84ww8   1/1       Running     0          14s\npi-gmcq5   0/1       Completed   0          54s\n</code></pre><p>最终，后面创建的这两个Pod也完成了计算，进入了Completed状态。</p><p>这时，由于所有的Pod均已经成功退出，这个Job也就执行完了，所以你会看到它的SUCCESSFUL字段的值变成了4：</p><pre><code>$ kubectl get pods \nNAME       READY     STATUS      RESTARTS   AGE\npi-5mt88   0/1       Completed   0          5m\npi-62rbt   0/1       Completed   0          4m\npi-84ww8   0/1       Completed   0          4m\npi-gmcq5   0/1       Completed   0          5m\n\n$ kubectl get job\nNAME      DESIRED   SUCCESSFUL   AGE\npi        4         4            5m\n</code></pre><p>通过上述Job的DESIRED和SUCCESSFUL字段的关系，我们就可以很容易地理解<span class=\"orange\">Job Controller的工作原理</span>了。</p><p>首先，Job Controller控制的对象，直接就是Pod。</p><p>其次，Job Controller在控制循环中进行的调谐（Reconcile）操作，是根据实际在Running状态Pod的数目、已经成功退出的Pod的数目，以及parallelism、completions参数的值共同计算出在这个周期里，应该创建或者删除的Pod数目，然后调用Kubernetes API来执行这个操作。</p><p>以创建Pod为例。在上面计算Pi值的这个例子中，当Job一开始创建出来时，实际处于Running状态的Pod数目=0，已经成功退出的Pod数目=0，而用户定义的completions，也就是最终用户需要的Pod数目=4。</p><p>所以，在这个时刻，需要创建的Pod数目 = 最终需要的Pod数目 - 实际在Running状态Pod数目 - 已经成功退出的Pod数目 = 4 - 0 - 0= 4。也就是说，Job Controller需要创建4个Pod来纠正这个不一致状态。</p><p>可是，我们又定义了这个Job的parallelism=2。也就是说，我们规定了每次并发创建的Pod个数不能超过2个。所以，Job Controller会对前面的计算结果做一个修正，修正后的期望创建的Pod数目应该是：2个。</p><p>这时候，Job Controller就会并发地向kube-apiserver发起两个创建Pod的请求。</p><p>类似地，如果在这次调谐周期里，Job Controller发现实际在Running状态的Pod数目，比parallelism还大，那么它就会删除一些Pod，使两者相等。</p><p>综上所述，Job Controller实际上控制了，作业执行的<strong>并行度</strong>，以及总共需要完成的<strong>任务数</strong>这两个重要参数。而在实际使用时，你需要根据作业的特性，来决定并行度（parallelism）和任务数（completions）的合理取值。</p><p>接下来，<span class=\"orange\">我再和你分享三种常用的、使用Job对象的方法。</span></p><p><strong>第一种用法，也是最简单粗暴的用法：外部管理器+Job模板。</strong></p><p>这种模式的特定用法是：把Job的YAML文件定义为一个“模板”，然后用一个外部工具控制这些“模板”来生成Job。这时，Job的定义方式如下所示：</p><pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: process-item-$ITEM\n  labels:\n    jobgroup: jobexample\nspec:\n  template:\n    metadata:\n      name: jobexample\n      labels:\n        jobgroup: jobexample\n    spec:\n      containers:\n      - name: c\n        image: busybox\n        command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo Processing item $ITEM &amp;&amp; sleep 5&quot;]\n      restartPolicy: Never\n</code></pre><p>可以看到，我们在这个Job的YAML里，定义了$ITEM这样的“变量”。</p><p>所以，在控制这种Job时，我们只要注意如下两个方面即可：</p><ol>\n<li>\n<p>创建Job时，替换掉$ITEM这样的变量；</p>\n</li>\n<li>\n<p>所有来自于同一个模板的Job，都有一个jobgroup: jobexample标签，也就是说这一组Job使用这样一个相同的标识。</p>\n</li>\n</ol><p>而做到第一点非常简单。比如，你可以通过这样一句shell把$ITEM替换掉：</p><pre><code>$ mkdir ./jobs\n$ for i in apple banana cherry\ndo\n  cat job-tmpl.yaml | sed &quot;s/\\$ITEM/$i/&quot; &gt; ./jobs/job-$i.yaml\ndone\n</code></pre><p>这样，一组来自于同一个模板的不同Job的yaml就生成了。接下来，你就可以通过一句kubectl create指令创建这些Job了：</p><pre><code>$ kubectl create -f ./jobs\n$ kubectl get pods -l jobgroup=jobexample\nNAME                        READY     STATUS      RESTARTS   AGE\nprocess-item-apple-kixwv    0/1       Completed   0          4m\nprocess-item-banana-wrsf7   0/1       Completed   0          4m\nprocess-item-cherry-dnfu9   0/1       Completed   0          4m\n</code></pre><p>这个模式看起来虽然很“傻”，但却是Kubernetes社区里使用Job的一个很普遍的模式。</p><p>原因很简单：大多数用户在需要管理Batch Job的时候，都已经有了一套自己的方案，需要做的往往就是集成工作。这时候，Kubernetes项目对这些方案来说最有价值的，就是Job这个API对象。所以，你只需要编写一个外部工具（等同于我们这里的for循环）来管理这些Job即可。</p><p>这种模式最典型的应用，就是TensorFlow社区的KubeFlow项目。</p><p>很容易理解，在这种模式下使用Job对象，completions和parallelism这两个字段都应该使用默认值1，而不应该由我们自行设置。而作业Pod的并行控制，应该完全交由外部工具来进行管理（比如，KubeFlow）。</p><p><strong>第二种用法：拥有固定任务数目的并行Job</strong>。</p><p>这种模式下，我只关心最后是否有指定数目（spec.completions）个任务成功退出。至于执行时的并行度是多少，我并不关心。</p><p>比如，我们这个计算Pi值的例子，就是这样一个典型的、拥有固定任务数目（completions=4）的应用场景。 它的parallelism值是2；或者，你可以干脆不指定parallelism，直接使用默认的并行度（即：1）。</p><p>此外，你还可以使用一个工作队列（Work Queue）进行任务分发。这时，Job的YAML文件定义如下所示：</p><pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: job-wq-1\nspec:\n  completions: 8\n  parallelism: 2\n  template:\n    metadata:\n      name: job-wq-1\n    spec:\n      containers:\n      - name: c\n        image: myrepo/job-wq-1\n        env:\n        - name: BROKER_URL\n          value: amqp://guest:guest@rabbitmq-service:5672\n        - name: QUEUE\n          value: job1\n      restartPolicy: OnFailure\n</code></pre><p>我们可以看到，它的completions的值是：8，这意味着我们总共要处理的任务数目是8个。也就是说，总共会有8个任务会被逐一放入工作队列里（你可以运行一个外部小程序作为生产者，来提交任务）。</p><p>在这个实例中，我选择充当工作队列的是一个运行在Kubernetes里的RabbitMQ。所以，我们需要在Pod模板里定义BROKER_URL，来作为消费者。</p><p>所以，一旦你用kubectl create创建了这个Job，它就会以并发度为2的方式，每两个Pod一组，创建出8个Pod。每个Pod都会去连接BROKER_URL，从RabbitMQ里读取任务，然后各自进行处理。这个Pod里的执行逻辑，我们可以用这样一段伪代码来表示：</p><pre><code>/* job-wq-1的伪代码 */\nqueue := newQueue($BROKER_URL, $QUEUE)\ntask := queue.Pop()\nprocess(task)\nexit\n</code></pre><p>可以看到，每个Pod只需要将任务信息读取出来，处理完成，然后退出即可。而作为用户，我只关心最终一共有8个计算任务启动并且退出，只要这个目标达到，我就认为整个Job处理完成了。所以说，这种用法，对应的就是“任务总数固定”的场景。</p><p><strong>第三种用法，也是很常用的一个用法：指定并行度（parallelism），但不设置固定的completions的值。</strong></p><p>此时，你就必须自己想办法，来决定什么时候启动新Pod，什么时候Job才算执行完成。在这种情况下，任务的总数是未知的，所以你不仅需要一个工作队列来负责任务分发，还需要能够判断工作队列已经为空（即：所有的工作已经结束了）。</p><p>这时候，Job的定义基本上没变化，只不过是不再需要定义completions的值了而已：</p><pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: job-wq-2\nspec:\n  parallelism: 2\n  template:\n    metadata:\n      name: job-wq-2\n    spec:\n      containers:\n      - name: c\n        image: gcr.io/myproject/job-wq-2\n        env:\n        - name: BROKER_URL\n          value: amqp://guest:guest@rabbitmq-service:5672\n        - name: QUEUE\n          value: job2\n      restartPolicy: OnFailure\n</code></pre><p>而对应的Pod的逻辑会稍微复杂一些，我可以用这样一段伪代码来描述：</p><pre><code>/* job-wq-2的伪代码 */\nfor !queue.IsEmpty($BROKER_URL, $QUEUE) {\n  task := queue.Pop()\n  process(task)\n}\nprint(&quot;Queue empty, exiting&quot;)\nexit\n</code></pre><p>由于任务数目的总数不固定，所以每一个Pod必须能够知道，自己什么时候可以退出。比如，在这个例子中，我简单地以“队列为空”，作为任务全部完成的标志。所以说，这种用法，对应的是“任务总数不固定”的场景。</p><p>不过，在实际的应用中，你需要处理的条件往往会非常复杂。比如，任务完成后的输出、每个任务Pod之间是不是有资源的竞争和协同等等。</p><p>所以，在今天这篇文章中，我就不再展开Job的用法了。因为，在实际场景里，要么干脆就用第一种用法来自己管理作业；要么，这些任务Pod之间的关系就不那么“单纯”，甚至还是“有状态应用”（比如，任务的输入/输出是在持久化数据卷里）。在这种情况下，我在后面要重点讲解的Operator，加上Job对象一起，可能才能更好地满足实际离线任务的编排需求。</p><p><span class=\"orange\">最后，我再来和你分享一个非常有用的Job对象，叫作：CronJob。</span></p><p>顾名思义，CronJob描述的，正是定时任务。它的API对象，如下所示：</p><pre><code>apiVersion: batch/v1beta1\nkind: CronJob\nmetadata:\n  name: hello\nspec:\n  schedule: &quot;*/1 * * * *&quot;\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: hello\n            image: busybox\n            args:\n            - /bin/sh\n            - -c\n            - date; echo Hello from the Kubernetes cluster\n          restartPolicy: OnFailure\n</code></pre><p>在这个YAML文件中，最重要的关键词就是<strong>jobTemplate</strong>。看到它，你一定恍然大悟，原来CronJob是一个Job对象的控制器（Controller）！</p><p>没错，CronJob与Job的关系，正如同Deployment与ReplicaSet的关系一样。CronJob是一个专门用来管理Job对象的控制器。只不过，它创建和删除Job的依据，是schedule字段定义的、一个标准的<a href=\"https://en.wikipedia.org/wiki/Cron\">Unix Cron</a>格式的表达式。</p><p>比如，\"*/1 * * * *\"。</p><p>这个Cron表达式里*/1中的*表示从0开始，/表示“每”，1表示偏移量。所以，它的意思就是：从0开始，每1个时间单位执行一次。</p><p>那么，时间单位又是什么呢？</p><p>Cron表达式中的五个部分分别代表：分钟、小时、日、月、星期。</p><p>所以，上面这句Cron表达式的意思是：从当前开始，每分钟执行一次。</p><p>而这里要执行的内容，就是jobTemplate定义的Job了。</p><p>所以，这个CronJob对象在创建1分钟后，就会有一个Job产生了，如下所示：</p><pre><code>$ kubectl create -f ./cronjob.yaml\ncronjob &quot;hello&quot; created\n\n# 一分钟后\n$ kubectl get jobs\nNAME               DESIRED   SUCCESSFUL   AGE\nhello-4111706356   1         1         2s\n</code></pre><p>此时，CronJob对象会记录下这次Job执行的时间：</p><pre><code>$ kubectl get cronjob hello\nNAME      SCHEDULE      SUSPEND   ACTIVE    LAST-SCHEDULE\nhello     */1 * * * *   False     0         Thu, 6 Sep 2018 14:34:00 -070\n</code></pre><p>需要注意的是，由于定时任务的特殊性，很可能某个Job还没有执行完，另外一个新Job就产生了。这时候，你可以通过spec.concurrencyPolicy字段来定义具体的处理策略。比如：</p><ol>\n<li>\n<p>concurrencyPolicy=Allow，这也是默认情况，这意味着这些Job可以同时存在；</p>\n</li>\n<li>\n<p>concurrencyPolicy=Forbid，这意味着不会创建新的Pod，该创建周期被跳过；</p>\n</li>\n<li>\n<p>concurrencyPolicy=Replace，这意味着新产生的Job会替换旧的、没有执行完的Job。</p>\n</li>\n</ol><p>而如果某一次Job创建失败，这次创建就会被标记为“miss”。当在指定的时间窗口内，miss的数目达到100时，那么CronJob会停止再创建这个Job。</p><p>这个时间窗口，可以由spec.startingDeadlineSeconds字段指定。比如startingDeadlineSeconds=200，意味着在过去200 s里，如果miss的数目达到了100次，那么这个Job就不会被创建执行了。</p><h2>总结</h2><p>在今天这篇文章中，我主要和你分享了Job这个离线业务的编排方法，讲解了completions和parallelism字段的含义，以及Job Controller的执行原理。</p><p>紧接着，我通过实例和你分享了Job对象三种常见的使用方法。但是，根据我在社区和生产环境中的经验，大多数情况下用户还是更倾向于自己控制Job对象。所以，相比于这些固定的“模式”，掌握Job的API对象，和它各个字段的准确含义会更加重要。</p><p>最后，我还介绍了一种Job的控制器，叫作：CronJob。这也印证了我在前面的分享中所说的：用一个对象控制另一个对象，是Kubernetes编排的精髓所在。</p><h2>思考题</h2><p>根据Job控制器的工作原理，如果你定义的parallelism比completions还大的话，比如：</p><pre><code> parallelism: 4\n completions: 2\n</code></pre><p>那么，这个Job最开始创建的时候，会同时启动几个Pod呢？原因是什么？</p><p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p>","neighbors":{"left":{"article_title":"21 | 容器化守护进程的意义：DaemonSet","id":41366},"right":{"article_title":"23 | 声明式API与Kubernetes编程范式","id":41769}},"comments":[{"had_liked":false,"id":31816,"user_name":"刘孟","can_delete":false,"product_type":"c1","uid":1066088,"ip_address":"","ucode":"4DD548432D4ACC","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/68/5d1fcf32.jpg","comment_is_top":false,"comment_ctime":1539306669,"is_pvip":false,"replies":[{"id":"11461","content":"聪明宝宝","user_name":"作者回复","comment_id":31816,"uid":"1218095","ip_address":"","utype":1,"ctime":1539308694,"user_name_real":"Geek_6ef93d"}],"discussion_count":3,"race_medal":0,"score":"422446101677","product_id":100015201,"comment_content":"需要创建的 Pod 数目 = 最终需要的 Pod 数目 - 实际在 Running 状态 Pod 数目 - 已经成功退出的 Pod 数目 = 2 - 0 - 0= 2。而parallelism数量为4，2小于4，所以应该会创建2个。","like_count":99,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426521,"discussion_content":"聪明宝宝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539308694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1837179,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/08/7b/7f086546.jpg","nickname":"Alex","note":"","ucode":"70806CEA9AB15E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382049,"discussion_content":"聪明宝宝","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625388002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41824,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572512946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31888,"user_name":"DJH","can_delete":false,"product_type":"c1","uid":1256740,"ip_address":"","ucode":"2BDEF123B3DB6A","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/24/28acca15.jpg","comment_is_top":false,"comment_ctime":1539321025,"is_pvip":false,"replies":[{"id":"11539","content":"restartpoliccy当然是针对容器。pod没有重启这个说法。至于ip，那跟用户容器没关系，那是infra container","user_name":"作者回复","comment_id":31888,"uid":"1218095","ip_address":"","utype":1,"ctime":1539330429,"user_name_real":"Geek_6ef93d"}],"discussion_count":3,"race_medal":0,"score":"138978274497","product_id":100015201,"comment_content":"说到pod的重新启动，我想再请教一个问题：假设我把deployment的restart policy设置成always，假设某个pod中的容器运行失败，那么是重新创建了一个新的pod，还是仅仅重启了pod里的容器？pod的名称和ip地址会变化吗？","like_count":33,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426550,"discussion_content":"restartpoliccy当然是针对容器。pod没有重启这个说法。至于ip，那跟用户容器没关系，那是infra container","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1539330429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2066376,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/87/c8/4a321341.jpg","nickname":"panghu","note":"","ucode":"9C572247F7EEC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579229,"discussion_content":"MARK","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657258998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113864,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/08/7c18d8a4.jpg","nickname":"团","note":"","ucode":"D56ABBCE4E4D90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532664,"discussion_content":"Mark。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637662745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56649,"user_name":"柯察金","can_delete":false,"product_type":"c1","uid":1115149,"ip_address":"","ucode":"F722BF8FCD2C47","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/0d/3dc5683a.jpg","comment_is_top":false,"comment_ctime":1546516443,"is_pvip":false,"replies":[{"id":"21377","content":"这得看应用咋写的。configmap volume里的内容已经就是自动更新的。但应用能做到监视文件的更新吗？","user_name":"作者回复","comment_id":56649,"uid":"1218095","ip_address":"","utype":1,"ctime":1547317513,"user_name_real":"Geek_6ef93d"}],"discussion_count":4,"race_medal":0,"score":"100330764251","product_id":100015201,"comment_content":"问个不相关的问题：configmap 更新，怎么做到不重启 pod 生效","like_count":23,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435167,"discussion_content":"这得看应用咋写的。configmap volume里的内容已经就是自动更新的。但应用能做到监视文件的更新吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547317513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2160620,"avatar":"https://static001.geekbang.org/account/avatar/00/20/f7/ec/b0e9ecd2.jpg","nickname":"Sanping","note":"","ucode":"3E82B6F0F54639","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582145,"discussion_content":"kubelet有一个启动参数--sync-frequency，控制同步配置的时间间隔，它的默认值是1min，所以更新configmap的内容后，真正容器中的挂载内容变化可能在0~1min之后。修改一下这个值，修改为5s，然后更改configmap的数据，检查热更新延迟时间，都降低到了3s左右，但同时kubelet的资源消耗会上升，尤其运行比较多pod的node上，性能会显著下降。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659260414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109528,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","nickname":"王大喵","note":"","ucode":"C14AAE3ED964DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574022,"discussion_content":"watch 文件即可，config挂载到pod的文件上\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653797263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207457,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/a1/80d83f0a.jpg","nickname":"Ellison","note":"","ucode":"A2FB94D4F6A332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329406,"discussion_content":"可以用k8s client watch ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606380655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31924,"user_name":"abc","can_delete":false,"product_type":"c1","uid":1198332,"ip_address":"","ucode":"A4E989E85848D9","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/fc/f46062b6.jpg","comment_is_top":false,"comment_ctime":1539330923,"is_pvip":false,"replies":[{"id":"11573","content":"这个是写死的","user_name":"作者回复","comment_id":31924,"uid":"1218095","ip_address":"","utype":1,"ctime":1539358404,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"53078938475","product_id":100015201,"comment_content":"请问老师：miss的数目100是默认的吗？哪个参数可以修改呢","like_count":13,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426566,"discussion_content":"这个是写死的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539358404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56500,"user_name":"柯察金","can_delete":false,"product_type":"c1","uid":1115149,"ip_address":"","ucode":"F722BF8FCD2C47","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/0d/3dc5683a.jpg","comment_is_top":false,"comment_ctime":1546478589,"is_pvip":false,"replies":[{"id":"21219","content":"需要删除掉，或者设置规则","user_name":"作者回复","comment_id":56500,"uid":"1218095","ip_address":"","utype":1,"ctime":1547179489,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"48791118845","product_id":100015201,"comment_content":"job 执行结束，处于 completed 状态之后，还会占用系统资源吗，可以让它执行结束后自动退出吗","like_count":12,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435073,"discussion_content":"需要删除掉，或者设置规则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547179489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42905,"user_name":"jssfy","can_delete":false,"product_type":"c1","uid":1137238,"ip_address":"","ucode":"F16353CFE607B7","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/56/115c6433.jpg","comment_is_top":false,"comment_ctime":1543080702,"is_pvip":false,"replies":[{"id":"15423","content":"对","user_name":"作者回复","comment_id":42905,"uid":"1218095","ip_address":"","utype":1,"ctime":1543192629,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"35902819070","product_id":100015201,"comment_content":"请问job成功结束后一直处于completed状态吗？需要手动清吗？","like_count":9,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430237,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543192629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42130,"user_name":"fangxuan","can_delete":false,"product_type":"c1","uid":1073369,"ip_address":"","ucode":"3870F2BF5679A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/d9/829ac53b.jpg","comment_is_top":false,"comment_ctime":1542930762,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"35902669130","product_id":100015201,"comment_content":"从公式可以看出，启动的job的最大值由completion决定","like_count":9},{"had_liked":false,"id":32171,"user_name":"silver","can_delete":false,"product_type":"c1","uid":1186740,"ip_address":"","ucode":"908E3C8560D6E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/1b/b4/a6db1c1e.jpg","comment_is_top":false,"comment_ctime":1539475083,"is_pvip":false,"replies":[{"id":"11711","content":"不需要的。completion没设置默认等于1，所以任何一个pod判断到队列为空退出进入succeed状态，Job controller就不会再创建新pod了。","user_name":"作者回复","comment_id":32171,"uid":"1218095","ip_address":"","utype":1,"ctime":1539502048,"user_name_real":"Geek_6ef93d"}],"discussion_count":2,"race_medal":0,"score":"31604246155","product_id":100015201,"comment_content":"Job的第三种方法中是不是需要有其他process最后去Kill这个Job，否则Job会在Pod退出后不断创建新的Pod？","like_count":7,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426664,"discussion_content":"不需要的。completion没设置默认等于1，所以任何一个pod判断到队列为空退出进入succeed状态，Job controller就不会再创建新pod了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1539502048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1097240,"avatar":"https://static001.geekbang.org/account/avatar/00/10/be/18/ecac08dc.jpg","nickname":"阿伦","note":"","ucode":"EEB5FAA3E65C91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571572,"discussion_content":"那completion默认设置是1， 上面个例子设置parallelism: 2，岂不是最多只会启动一个？parallelism: 2设置了还有什么额外意义嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652274524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31982,"user_name":"参悟","can_delete":false,"product_type":"c1","uid":1186023,"ip_address":"","ucode":"AAD3D8BB695658","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/e7/d58e287c.jpg","comment_is_top":false,"comment_ctime":1539349041,"is_pvip":true,"replies":[{"id":"11568","content":"多套集群。","user_name":"作者回复","comment_id":31982,"uid":"1218095","ip_address":"","utype":1,"ctime":1539357224,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"27309152817","product_id":100015201,"comment_content":"最近实践遇到的问题，盼请赐教，多套分支的开发，测试环境，是按一套k8s集群按命名空间分区，还是按多套集群，实践方案哪种更好，有何优缺点？如果按一套多空间，会有nodeport冲突的问题，比如数据库需要暴露稳定的端口，方便运维。","like_count":6,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426592,"discussion_content":"多套集群。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539357224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250506,"user_name":"ch_ort","can_delete":false,"product_type":"c1","uid":1580926,"ip_address":"","ucode":"B79746E687F29E","user_header":"","comment_is_top":false,"comment_ctime":1601108010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23075944490","product_id":100015201,"comment_content":"K8S支持编排长期运行作业和执行完即退出的作业：<br><br>（1）支持Long Running Job（长期运行的作业）： Deployment 、StatefulSet、DaemonSet<br><br>（2）这次好Batch Job（执行完即退出的作业）：Job、CronJob<br><br>CronJob与Job关系，正如同Deployment与ReplicaSet的关系一样。CronJob是一个专门用来管理Job对象的控制器。只不过，它创建和删除Job的依据，是schedule字段定义的<br><br><br>","like_count":6},{"had_liked":false,"id":31858,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1539313611,"is_pvip":false,"replies":[{"id":"11542","content":"不错","user_name":"作者回复","comment_id":31858,"uid":"1218095","ip_address":"","utype":1,"ctime":1539330901,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"23014150091","product_id":100015201,"comment_content":"并发度为4，意味着可以同时启动不超过4个job。<br><br>completion2 - running0 - completed0 = 2<br><br>所以会启动2个job","like_count":5,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426540,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539330901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36767,"user_name":"hochuenw","can_delete":false,"product_type":"c1","uid":1231781,"ip_address":"","ucode":"303B389F81508A","user_header":"","comment_is_top":false,"comment_ctime":1541317811,"is_pvip":false,"replies":[{"id":"13031","content":"你说operator 管理的是啥呢？","user_name":"作者回复","comment_id":36767,"uid":"1218095","ip_address":"","utype":1,"ctime":1541338487,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"14426219699","product_id":100015201,"comment_content":"老师请问kubeflow在哪一部分用到了第一种job的使用方法？他们不是自己写了tf-operator吗","like_count":3,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428008,"discussion_content":"你说operator 管理的是啥呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541338487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33569,"user_name":"Nokiak8","can_delete":false,"product_type":"c1","uid":1230506,"ip_address":"","ucode":"8063D1A3F06842","user_header":"","comment_is_top":false,"comment_ctime":1539826387,"is_pvip":false,"replies":[{"id":"12083","content":"有个字段叫backofflimit","user_name":"作者回复","comment_id":33569,"uid":"1218095","ip_address":"","utype":1,"ctime":1539850864,"user_name_real":"Geek_6ef93d"}],"discussion_count":2,"race_medal":0,"score":"14424728275","product_id":100015201,"comment_content":"老师，请教一个问题，假如Job中定义的pod运行失败，比如有异常。pod就会接着新生成，这样带来的就是会有大量的pod 产生，如何解决这种问题？","like_count":3,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427000,"discussion_content":"有个字段叫backofflimit","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539850864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1715064,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2b/78/97532f60.jpg","nickname":"","note":"","ucode":"FCC8B496F9A621","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308384,"discussion_content":"restartPolicy=OnFailure时并不会生成新的pod，只会重启当前的container","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600935305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31892,"user_name":"DJH","can_delete":false,"product_type":"c1","uid":1256740,"ip_address":"","ucode":"2BDEF123B3DB6A","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/24/28acca15.jpg","comment_is_top":false,"comment_ctime":1539323481,"is_pvip":false,"replies":[{"id":"11541","content":"当然是失效了。这是保护措施。","user_name":"作者回复","comment_id":31892,"uid":"1218095","ip_address":"","utype":1,"ctime":1539330886,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"14424225369","product_id":100015201,"comment_content":"放miss数量达到100时，cronjob是永远不再创建新的job（相当于整个cronjob失效），亦或只是不再运行miss（错过）的那些job？","like_count":3,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426553,"discussion_content":"当然是失效了。这是保护措施。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539330886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31768,"user_name":"DJH","can_delete":false,"product_type":"c1","uid":1256740,"ip_address":"","ucode":"2BDEF123B3DB6A","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/24/28acca15.jpg","comment_is_top":false,"comment_ctime":1539302099,"is_pvip":false,"replies":[{"id":"11458","content":"当然是产生新的job","user_name":"作者回复","comment_id":31768,"uid":"1218095","ip_address":"","utype":1,"ctime":1539308445,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"14424203987","product_id":100015201,"comment_content":"另外我想请教一下，CronJob是定期产生新的Job，还是定期重启同一个Job任务？","like_count":3,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426500,"discussion_content":"当然是产生新的job","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539308445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34180,"user_name":"georgesuper GoodTOGreater","can_delete":false,"product_type":"c1","uid":1015169,"ip_address":"","ucode":"FD2F13B26D0942","user_header":"","comment_is_top":false,"comment_ctime":1540032842,"is_pvip":false,"replies":[{"id":"12252","content":"这个差别可就太大了","user_name":"作者回复","comment_id":34180,"uid":"1218095","ip_address":"","utype":1,"ctime":1540104541,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":1,"score":"10129967434","product_id":100015201,"comment_content":"是不是Spark job,hadoop job,k8s job 底层原理都相似？","like_count":2,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427144,"discussion_content":"这个差别可就太大了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540104541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297846,"user_name":"江","can_delete":false,"product_type":"c1","uid":1398148,"ip_address":"","ucode":"DA8378171C959E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIC5FK1ibcFwyTQ5TugfhJicSsZ3x5GfibRrUNTxpb8IY88wNREl4GlbJqUUibCHAhZp9wqic2eia2Dpgsw/132","comment_is_top":false,"comment_ctime":1623811348,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5918778644","product_id":100015201,"comment_content":"请教一下，如果多个job 间存在拓扑关系，比如有顺序依赖，这个是不是得用外部工具?","like_count":1},{"had_liked":false,"id":281420,"user_name":"小猪","can_delete":false,"product_type":"c1","uid":1201662,"ip_address":"","ucode":"EAD6A4876CEF3B","user_header":"https://static001.geekbang.org/account/avatar/00/12/55/fe/ab541300.jpg","comment_is_top":false,"comment_ctime":1614743343,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5909710639","product_id":100015201,"comment_content":"我想把job在每一个物理机上定期执行，来删除指定目录下的日志文件，就像DaemonSet那样部署到每一个物理机。这种需求怎么使用job处理？","like_count":1,"discussions":[{"author":{"id":1129543,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3c/47/3809bf42.jpg","nickname":"Drol🐵","note":"","ucode":"9BAD3E5F9580DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384988,"discussion_content":"直接用DaemonSet，容器里用Crontab定时执行删除日志文件的脚本不就行了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626844221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1643296,"avatar":"https://static001.geekbang.org/account/avatar/00/19/13/20/2d22b331.jpg","nickname":"H.Z","note":"","ucode":"728417BD5B4DA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392483,"discussion_content":"加一个selector也可以实现的吧，让job调度到每一个node上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631017288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34167,"user_name":"大星星","can_delete":false,"product_type":"c1","uid":1082286,"ip_address":"","ucode":"4EAC1D22AE420C","user_header":"https://static001.geekbang.org/account/avatar/00/10/83/ae/c082bb25.jpg","comment_is_top":false,"comment_ctime":1540026362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834993658","product_id":100015201,"comment_content":"你好，磊哥，我想问下job运行后，会有字段controller-uid。这个东西和node节点有关系么，还是它只是用来标识job。job应该是调度器随便调度一个节点，执行job吧，谢谢。","like_count":1},{"had_liked":false,"id":32041,"user_name":"acmore","can_delete":false,"product_type":"c1","uid":1109695,"ip_address":"","ucode":"CA5335DD61865E","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/bf/aacc0d22.jpg","comment_is_top":false,"comment_ctime":1539394781,"is_pvip":true,"replies":[{"id":"11637","content":"离线业务本来就是被强占的对象，为啥还要不影响状态？不想被强占就把优先级提高。想恢复就设置好restartpolicy或者编写外部控制器。","user_name":"作者回复","comment_id":32041,"uid":"1218095","ip_address":"","utype":1,"ctime":1539481553,"user_name_real":"Geek_6ef93d"}],"discussion_count":1,"race_medal":0,"score":"5834362077","product_id":100015201,"comment_content":"如果开启了Pod优先级和抢占调度，Job起的Pod被抢占时，可能会出现Job的succeeded 或者failed的值为1，但是我们应该期望Job的pod被抢占时不应该影响Job的状态。有什么解决办法吗？","like_count":1,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426618,"discussion_content":"离线业务本来就是被强占的对象，为啥还要不影响状态？不想被强占就把优先级提高。想恢复就设置好restartpolicy或者编写外部控制器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539481553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31834,"user_name":"Caesar","can_delete":false,"product_type":"c1","uid":1253220,"ip_address":"","ucode":"0319C9E19387CD","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/64/54458855.jpg","comment_is_top":false,"comment_ctime":1539309147,"is_pvip":true,"replies":[{"id":"11487","content":"对头","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1539310623,"ip_address":"","comment_id":31834,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834276443","product_id":100015201,"comment_content":"(1) 若所有容器重启成功，pod应该是running，或者succeeded<br>(2) 若有容器没有成功，看具体原因,pending,failed...","like_count":1,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426532,"discussion_content":"对头","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31826,"user_name":"Caesar","can_delete":false,"product_type":"c1","uid":1253220,"ip_address":"","ucode":"0319C9E19387CD","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/64/54458855.jpg","comment_is_top":false,"comment_ctime":1539307585,"is_pvip":true,"replies":[{"id":"11460","content":"在pod lifecycle 部分已经讲过了","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1539308604,"ip_address":"","comment_id":31826,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834274881","product_id":100015201,"comment_content":"另外一个问题，如果restartpolicy=on-failure的话，只重启pod中的容器<br>（1）如果pod中的所有容器重启成功，pod是什么状态？<br>（2）pod中有容器重启不成功，pod是什么状态？","like_count":1,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426527,"discussion_content":"在pod lifecycle 部分已经讲过了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539308604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346333,"user_name":"大贤良师","can_delete":false,"product_type":"c1","uid":1986657,"ip_address":"","ucode":"D82BB415F2578F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/uPcj4HhpuNbeGuuOLw2dgphyGI2icdjMIvDZiaricrld6RjONht3sXB0HOyO9DFBHSPtbEGLA1zfK2agMOvIibWduA/132","comment_is_top":false,"comment_ctime":1653032243,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653032243","product_id":100015201,"comment_content":"老师，Cronjob每次都创建新的job。那频繁拉取镜像，网络压力不是会很大。如果定时任务多的话","like_count":0},{"had_liked":false,"id":329214,"user_name":"fromzerotohero","can_delete":false,"product_type":"c1","uid":1117324,"ip_address":"","ucode":"51C78BDD0368D4","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/8c/4dd0dd3c.jpg","comment_is_top":false,"comment_ctime":1641215678,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1641215678","product_id":100015201,"comment_content":"磊哥，您好！银行的批量调度都比较多，而且可能多个批量任务存在先后顺序，还要考虑异常情况的补处理，请问这种情况是不是只能自己写代码调API实现，社区有比较好的批量调度的案例吗","like_count":0},{"had_liked":false,"id":315693,"user_name":"陈斯佳","can_delete":false,"product_type":"c1","uid":1259323,"ip_address":"","ucode":"C236F874FC767A","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/3b/495e2ce6.jpg","comment_is_top":false,"comment_ctime":1633945606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633945606","product_id":100015201,"comment_content":"第二十二课:撬动离线业务：Job和CronJob<br>K8s的Task分为Long Run Task：Deployment、StatefulSet、DaemonSet和一次性执行任务Batch Job<br><br>离线任务Job的restartPolicy只允许Never或OnFailure，而在Deployment里，restartPolicy只允许被设置为Always。<br><br> Job 对象的 spec.backoffLimit 字段表示失败后重启次数<br><br>spec.activeDeadlineSeconds 字段可以设置最长运行时间<br><br>spec.parallelism，它定义的是一个 Job 在任意时间最多可以启动多少个 Pod 同时运行<br><br>spec.completions，它定义的是 Job 至少要完成的 Pod 数目，即 Job 的最小完成数<br><br>Job Controller 控制的对象，直接就是 Pod。<br><br>CronJob和Job的关系就像Deployment和ReplicaSet的关系，CronJob是专门用来管理Job对象的控制器，它通过schedule这个字段创建和删除job。<br><br>可以通过 spec.concurrencyPolicy 字段来定义具体的处理策略。比如：<br>concurrencyPolicy=Allow，这也是默认情况，这意味着这些 Job 可以同时存在；<br>concurrencyPolicy=Forbid，这意味着不会创建新的 Pod，该创建周期被跳过；<br>concurrencyPolicy=Replace，这意味着新产生的 Job 会替换旧的、没有执行完的 Job。<br><br>","like_count":0},{"had_liked":false,"id":288189,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1618355618,"is_pvip":false,"discussion_count":1,"race_medal":2,"score":"1618355618","product_id":100015201,"comment_content":"创建了 job 之后，没有 pod 被创建出来，describe 的时候 events 也是空，都不知道如何定位这个问题了。","like_count":0,"discussions":[{"author":{"id":1320487,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","nickname":"罗杰","note":"","ucode":"96BAFAA147341F","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367728,"discussion_content":"过了五分钟，然后创建出来了，pull image 和 执行花费了比较长的时间","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618450622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248208,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1600064829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600064829","product_id":100015201,"comment_content":"总共需要完成的-已经创建的-已经完成的<br>2-0-0=2<br>虽然parallelism定义了4,但是只会多退,不会少补,所以还是2个","like_count":0},{"had_liked":false,"id":246623,"user_name":"牛逼中…","can_delete":false,"product_type":"c1","uid":1197614,"ip_address":"","ucode":"CBCB80CFDC2180","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/2e/1017900c.jpg","comment_is_top":false,"comment_ctime":1599441093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599441093","product_id":100015201,"comment_content":"对于第三种用法不是很理解，如果completions为缺省的1，那是不是意味着初始只会创建1个pod，那配置的并发参数有何意义呢？","like_count":0},{"had_liked":false,"id":214321,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1588723958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588723958","product_id":100015201,"comment_content":"第一种用法里边提到的第二点，同一组job有相同的标签，pod模板也有相同的标签，而不是让job自动添加随机字符串，是有什么特别的用意吗？","like_count":0},{"had_liked":false,"id":210825,"user_name":"Andy","can_delete":false,"product_type":"c1","uid":1119133,"ip_address":"","ucode":"4BCA899B8E4E85","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/9d/0ff43179.jpg","comment_is_top":false,"comment_ctime":1587829790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587829790","product_id":100015201,"comment_content":"打卡，努力追赶中。","like_count":0},{"had_liked":false,"id":174947,"user_name":"黄磊","can_delete":false,"product_type":"c1","uid":1810130,"ip_address":"","ucode":"5302FE454A5904","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9e/d2/002b58c1.jpg","comment_is_top":false,"comment_ctime":1580472189,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1580472189","product_id":100015201,"comment_content":"请问如何解决Job所使用的资源冲突问题？例如某个job已经在处理某个工作（资源），如何避免其他job也来处理它？","like_count":0,"discussions":[{"author":{"id":1006424,"avatar":"","nickname":"门窗小二","note":"","ucode":"0BF3780C247F22","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363892,"discussion_content":"首先老师讲了有策略配置，如果上一个周期执行太久，可以配置跳过下一周期的配置；但如果你允许同时执行不是应该应用自己控制么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617321834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102245,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/a5/2bbedc3b.jpg","nickname":"over","note":"","ucode":"FE272AC19842D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347222,"discussion_content":"黄老师，最近没接戏吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612176104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169024,"user_name":"tangzc1","can_delete":false,"product_type":"c1","uid":1311254,"ip_address":"","ucode":"78CB596D2F33DC","user_header":"https://static001.geekbang.org/account/avatar/00/14/02/16/6fe3fe44.jpg","comment_is_top":false,"comment_ctime":1578240443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578240443","product_id":100015201,"comment_content":"按照文中介绍的job的control loop逻辑，先检查completions=2，表明期望状态需要创建出2个pod，后检查parallelism=4，4指的是并发数≤4，2满足条件，所以最终create2个pod。","like_count":0},{"had_liked":false,"id":164491,"user_name":"cobb","can_delete":false,"product_type":"c1","uid":1421306,"ip_address":"","ucode":"0DFF2F0A683B61","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7hsTibhnpQPxd4YexYrFvySzvnmSIzSIpdhBtgcoGlV4hL1BFfttmhz8pdZPOjDQbtDggZyG6NMg/132","comment_is_top":false,"comment_ctime":1577008457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577008457","product_id":100015201,"comment_content":"想问一个问题，就是CronJob怎么和现有的pod结合到一起使用。<br>例如起一个php项目 构建了pod 。怎么给这个pod 指定定时任务呢？因为需要用到php里面的逻辑 <br>官方文档的示例写的太简单了。","like_count":0},{"had_liked":false,"id":111572,"user_name":"frozen","can_delete":false,"product_type":"c1","uid":1382241,"ip_address":"","ucode":"D07C6850C79817","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Cv9qQvRibIiccxiaDsuoIv9fEI7C2c24MG85qmgMniasg0YsRa1pibGk5obH6hraj4Fs13DqXQvmfqg5R15BEyS4NDQ/132","comment_is_top":false,"comment_ctime":1562568085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562568085","product_id":100015201,"comment_content":"请教老师，cronjob每次启动执行都需要拉取镜像，而拉取镜像需要一定时间，这就会导致容器里的服务启动时间是对比cron表达式要延迟，这个不算问题的问题怎么解决","like_count":0},{"had_liked":false,"id":100662,"user_name":"每日都想上班","can_delete":false,"product_type":"c1","uid":1060466,"ip_address":"","ucode":"1DE64120C8B14A","user_header":"https://static001.geekbang.org/account/avatar/00/10/2e/72/145c10db.jpg","comment_is_top":false,"comment_ctime":1559612765,"is_pvip":false,"replies":[{"id":"36289","content":"可以想一下linux cron 的语法支持秒么？","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1559618404,"ip_address":"","comment_id":100662,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559612765","product_id":100015201,"comment_content":"cronjob可以每秒执行吗","like_count":0,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452627,"discussion_content":"可以想一下linux cron 的语法支持秒么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559618404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43178,"user_name":"单朋荣","can_delete":false,"product_type":"c1","uid":1272662,"ip_address":"","ucode":"8AD121BEDD9675","user_header":"https://static001.geekbang.org/account/avatar/00/13/6b/56/37a4cea7.jpg","comment_is_top":false,"comment_ctime":1543194533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543194533","product_id":100015201,"comment_content":"大神，我一直很喜欢你的课程。现在更新的也比较多了~能不能在以后的章节里讲讲自动伸缩控制HPA、VPA、CA的知识点，谢谢了。","like_count":0},{"had_liked":false,"id":42904,"user_name":"jssfy","can_delete":false,"product_type":"c1","uid":1137238,"ip_address":"","ucode":"F16353CFE607B7","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/56/115c6433.jpg","comment_is_top":false,"comment_ctime":1543079609,"is_pvip":false,"replies":[{"id":"15424","content":"不需要","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1543192648,"ip_address":"","comment_id":42904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543079609","product_id":100015201,"comment_content":"请问这里的label必须成对出现吗？<br>apiVersion: batch&#47;v1<br>kind: Job<br>metadata:<br>  name: process-item-$ITEM<br>  labels:<br>    jobgroup: jobexample<br>spec:<br>  template:<br>    metadata:<br>      name: jobexample<br>      labels:<br>        jobgroup: jobexample","like_count":0,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430236,"discussion_content":"不需要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543192648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32885,"user_name":"Joe Black","can_delete":false,"product_type":"c1","uid":1052528,"ip_address":"","ucode":"21FE222A286445","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/70/c8680841.jpg","comment_is_top":false,"comment_ctime":1539730581,"is_pvip":false,"replies":[{"id":"11975","content":"1000个并行度没必要吧……","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1539743792,"ip_address":"","comment_id":32885,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539730581","product_id":100015201,"comment_content":"如果想模仿传统调度系统，比如执行1000个Job，是不是可以为Job指定资源需求，然后把并行度和完成度都设为1000，这样k8s调度时会不会调度尽可能多的Pod，直到集群资源耗尽（但此时可能只能运行300个Pod）。然后若有Pod退出，k8s自动再补上新的Pod，直到满足完成数。不知道是不是这样？如果是就能满足一个基本调度系统的需求了。","like_count":0,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426907,"discussion_content":"1000个并行度没必要吧……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539743792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32217,"user_name":"acmore","can_delete":false,"product_type":"c1","uid":1109695,"ip_address":"","ucode":"CA5335DD61865E","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/bf/aacc0d22.jpg","comment_is_top":false,"comment_ctime":1539486580,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539486580","product_id":100015201,"comment_content":"Job里的Pod被抢占的时候，我觉得pod的containers exit code应该是未知，pod的状态应该是被抢占，当job看到pod的状态是被抢占，应该等着它被重新调度。因为pod被抢占，是外部的干预，用户的container 还没有退出。","like_count":0},{"had_liked":false,"id":32117,"user_name":"北卡","can_delete":false,"product_type":"c1","uid":1218128,"ip_address":"","ucode":"2D947A61689FC6","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/50/bde525b1.jpg","comment_is_top":false,"comment_ctime":1539421167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539421167","product_id":100015201,"comment_content":"第一次接触到k8s job这个概念，开心。","like_count":0},{"had_liked":false,"id":31810,"user_name":"Caesar","can_delete":false,"product_type":"c1","uid":1253220,"ip_address":"","ucode":"0319C9E19387CD","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/64/54458855.jpg","comment_is_top":false,"comment_ctime":1539306108,"is_pvip":true,"replies":[{"id":"11459","content":"可以复习一下讲pod lifecycle 的部分，这个讲到了。","user_name":"作者回复","user_name_real":"Geek_6ef93d","uid":"1218095","ctime":1539308505,"ip_address":"","comment_id":31810,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539306108","product_id":100015201,"comment_content":"还有一个问题，设置restartpolicy=on-fauilure 时，如果只重启pod中的容器并且重启成功，那么pod的状态是什么呢？","like_count":0,"discussions":[{"author":{"id":1218095,"avatar":"https://static001.geekbang.org/account/avatar/00/12/96/2f/876085fa.jpg","nickname":"张磊 Kubernetes","note":"","ucode":"16E29BDAB1F5BC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426517,"discussion_content":"可以复习一下讲pod lifecycle 的部分，这个讲到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539308505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31795,"user_name":"Caesar","can_delete":false,"product_type":"c1","uid":1253220,"ip_address":"","ucode":"0319C9E19387CD","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/64/54458855.jpg","comment_is_top":false,"comment_ctime":1539304899,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539304899","product_id":100015201,"comment_content":"个人觉得，会创建4个，然后再删除两个。","like_count":0},{"had_liked":false,"id":31767,"user_name":"DJH","can_delete":false,"product_type":"c1","uid":1256740,"ip_address":"","ucode":"2BDEF123B3DB6A","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/24/28acca15.jpg","comment_is_top":false,"comment_ctime":1539302001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539302001","product_id":100015201,"comment_content":"最后留的问题的答案应该是先启动并行数量的POD，当目标数量的POD成功完成后，多余的POD被强制终止？","like_count":0}]}