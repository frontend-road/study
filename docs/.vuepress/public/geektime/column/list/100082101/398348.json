{"id":398348,"title":"说点题外话02｜模式并不是解决方案","content":"<p>你好，我是徐昊。今天我们再来专门说点题外话。</p><p>说点题外话系列，是我根据评论区的留言，以及不少读者直接给到编辑的反馈中，挑选出来一些值得回答，但又不好直接回答的问题，然后呢，我会讲讲这些问题背后对应的原则。希望你可以感受到我强烈的暗示，在学完之后，不仅要思考，还要主动去寻找一下答案。</p><p>除此之外，我也希望给平淡的连载生活带来一定的现场感。比如今天这篇文章是周四零点推送，那么编辑小姐姐会在周三中午12点截止反馈收集。然后呢，我会从中挑选要写的话题，从下午两点开始写，然后录音。这样或多或少可以为专栏课程带来一些不可预知的可能性（比如编辑小姐姐一整个下午都在担心专栏是不是会断更，以及一整个下午，都保持着随时待命的状态）。</p><p>言归正传，今天我要讲一讲<strong>模式</strong>（Pattern）。自从GoF（Gang of Four）在1994年发布设计模式（Design Pattern）以来，模式就成了获得可重用的对象模型的重要手段，而模式语言（Design Language），也成了我们描述架构和解决方案的重要手段。</p><p>我知道我们这个专栏的读者都有比较长的工作年限，也有比较丰富的工作经验，想来对于模式，你肯定是不陌生的。那么我先问一下，如下图所示是什么模式：<br>\n<img src=\"https://static001.geekbang.org/resource/image/db/3c/dbbc7f365963eb4508b81b75f774be3c.jpg?wh=1439x728\" alt=\"\"></p><!-- [[[read_end]]] --><p>如图所示，某个类A将自己的行为委托给某个接口B，然后某个具体实现类C，实现了B的接口。你能想到什么模式呢？</p><p>如果仅从这个结构来看，那么对应的模式有很多很多可能性，我随便可以列出五种：</p><ul>\n<li>策略模式（Stragegy Pattern）：B是策略的接口，C是具体的策略实现。</li>\n<li>适配器模式（Adapter Pattern）：B是某个接口，C是将另一个实现转换为B的实现。</li>\n<li>状态模式（State Pattern）：B表示状态的接口，C是某个具体状态。</li>\n<li>备忘录模式（Memento Pattern）：B表示备忘录的接口，C是备忘录某个特定的数据备份。</li>\n<li>装饰器模式（Decorator Pattern）：B是某个接口，C是装饰了这个接口的额外功能。</li>\n</ul><p>我们会发现，如果仅仅给定最终的实现结构，那对应的模式可能有很多很多种。那么，怎么才能判断我们到底使用的是什么模式呢？</p><p>这个时候，我们就要回到模式的定义了。模式至少包含两个部分：问题和解决方案。<strong>同样的解决方案可能会对应着不同的问题。那么，同样的解决方案与不同的问题配对，也就产生了不同的模式</strong>。</p><p>比如说，对于<strong>策略模式</strong>，问题是对于某个类，需要施加不同的算法以完成不同的功能。那么怎么做才能使得算法可以替换，还不会影响到使用这些算法的类呢？</p><p>那么对应的解决方案就是，通过接口表示算法，然后将不同的算法封装到不同的对象中，并让这些对象实现这个表示算法的接口，这样就可以实现算法的替换了。</p><p>而对于<strong>状态模式</strong>而言，问题是某个类的行为随着它内部状态的改变而改变，我们如何将不同内部状态下的行为进行有效地封装，并在状态改变时做出与之对应的变化呢？</p><p>对应的解决方案就是，通过接口表示状态，然后将不同状态下的行为，封装到不同的对象中，并让这些对象实现这个表示状态的接口，这样就可以在内部状态改变的时候，实现行为的改变了。</p><p>虽然从最后结果上看，我们得到了类似的代码结构，但实际上，两者却是完全不同的两个模式，因为它们要解决的问题完全不同。那么我们不禁要问了，<strong>是否能够从解决方案反推它要解决的问题，然后判断我们使用了什么模式呢？</strong></p><p>答案是，<strong>不行，最好也别这么做</strong>！</p><p>其实不光是在写代码，与人交往的时候，也最怕从行为贸然推断意图。比如说，哪个小姐姐多看了你一眼，你就觉得人家看上你了。于是批《红楼梦》的脂砚斋就跳出来说，古来穷酸最会替别人取中自己。你看，你和脂砚斋都已经在意图批判了，这样不好。</p><p>再比如这道经典送命题：为什么你去喝酒都不陪我，你一定是不爱我了。这也是标准的意图推断，多少不和谐都是从这里来的。</p><p>所以如果你深受其苦，那么请反思一下自己，<strong>为什么你看到某个具体的实现方案，就会猜测它是不是某个模式呢</strong>？我们还是要理解具体在解决什么问题，然后结合解决方案，才能明白具体是什么模式。</p><p>因为这样做其实也带来了另一个问题，就是不对问题加以判断，盲目地去套用某个解决方案的结构。这造就了大量看起来很高级，实则一无是处的烂代码，而且这种代码还充满了酸臭的匠气。</p><p>所以说，模式与建模是一样的，都是<strong>问题先行</strong>。模式<strong>最难的地方就在于判断当前的问题与模式要解决的是否是同一个问题</strong>，这也是为什么我们提倡通过重构获得模式：当问题明显出现的时候（以坏味道的形式），那么最难的一步其实你已经解决了。这时再通过重构去得到具体的解决方案，反而是简单的。</p><h2>思考题</h2><p>最后是非常值得我们思考的思考题环节。请问：我们在第4-6节所讲的模式，它们各自对应的问题和解决方案分别是什么？</p><p>一定记得把你的思考和想法分享在留言区，我会和你交流。同时，也非常期待你能把自己的疑问和想听的话题，写在留言区，或者反馈给专栏编辑（微信号：seekforli）。我们下个题外话再见！</p>","comments":[{"had_liked":false,"id":303634,"user_name":"Oops!","can_delete":false,"product_type":"c1","uid":1479474,"ip_address":"","ucode":"E2678CC12121A7","user_header":"https://static001.geekbang.org/account/avatar/00/16/93/32/e11fcd33.jpg","comment_is_top":true,"comment_ctime":1626899056,"is_pvip":false,"replies":[{"id":"109901","content":"课代表你好","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626908242,"ip_address":"","comment_id":303634,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233722016904008e+18","product_id":100082101,"comment_content":"夜不能寐，尝试答一下…<br>1 关联对象，通过将集合逻辑封装到关联对象中的方式解决聚合时性能和逻辑封装之间的矛盾。<br>2 角色对象，通过将实体在不同上下文中的逻辑封装在不同的角色对象中，解决上下文过载问题。<br>3 上下文对象，通过显式的对上下文进行建模，将跨域业务逻辑和上下文依赖封装到领域对象中，进一步解决上下文过载问题。<br>4 能力供应商，通过从基础设施层提取具备业务含义的能力接口纳入到领域层，消除基础设施层，将其转变为能力供应商，参与各层逻辑，解决传统分层下，领域层和基础设施层之间“不正当”的依赖关系破坏了领域层的稳定性的问题。","like_count":39,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523769,"discussion_content":"课代表你好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626908242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303749,"user_name":"码农戏码","can_delete":false,"product_type":"c1","uid":1607342,"ip_address":"","ucode":"2472A68B8A851E","user_header":"https://static001.geekbang.org/account/avatar/00/18/86/ae/163ec4e5.jpg","comment_is_top":true,"comment_ctime":1626961207,"is_pvip":false,"replies":[{"id":"109960","content":"为你鼓掌","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1627010370,"ip_address":"","comment_id":303749,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233721157910999e+18","product_id":100082101,"comment_content":"貌似开了点窍，总结一下，有把锤子哪里都是钉子，有了一套解决方案什么问题都能套得上，但不是每个问题都是同一个问题<br><br>由具体问题抽象出解决方案，再在解决方案指导下给出处理具体问题具体路径<br>问题N：N模式 转化为 问题N：1 解决方案 1：N具体模式<br><br>这是N:N的关系，必然从一边是推导不出另一边的<br><br>文中的每个问题抽象出是要可扩展，解决方案是面向接口编程，但每个问题都不同，所以具体行为也不同，策略模式是应对行为，状态模式是应对状态<br><br>解决方案是一个，可问题却各自具象，魔鬼在细节<br><br>能力供应商模式也是同样的，从表面看是接口定义在domain,实现在其它地方，保证domain的稳定，形式上跟很多相似，ACL、整洁架构，也就是解决方案相似，但其实解决的具体问题不同，所以不能说能力供应商就是ACL<br><br><br>很多时候程序员不是在编写代码，而是在摸索业务领域知识；也就是从当前的代码去推测当时在解决什么问题，再重新定义问题，进行重构，这是因为知识没有有效传承，或者没有达到代码即模型","like_count":19,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523810,"discussion_content":"为你鼓掌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627010370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303669,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1626921642,"is_pvip":false,"replies":[{"id":"109913","content":"需要知识管理","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626927537,"ip_address":"","comment_id":303669,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14511823530","product_id":100082101,"comment_content":"说的非常对，but现在很多的实际场景就是根据代码来推测当时要解决的问题，也确实容易走偏（在熟悉业务之后，发现当时可能偏了）","like_count":3,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523780,"discussion_content":"需要知识管理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626927537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303790,"user_name":"林铭铭","can_delete":false,"product_type":"c1","uid":1068499,"ip_address":"","ucode":"AB392BEE7CD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/d3/67bdcca9.jpg","comment_is_top":false,"comment_ctime":1627002379,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5921969675","product_id":100082101,"comment_content":"最难的还是如何把问题定义好。","like_count":1,"discussions":[{"author":{"id":1047773,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/dd/0e17bf09.jpg","nickname":"worry","note":"","ucode":"AF2BDAF6F6370E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557121,"discussion_content":"是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647666361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303684,"user_name":"冯","can_delete":false,"product_type":"c1","uid":1161601,"ip_address":"","ucode":"7369C8B1A50D29","user_header":"https://static001.geekbang.org/account/avatar/00/11/b9/81/1680ec3f.jpg","comment_is_top":false,"comment_ctime":1626927685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5921894981","product_id":100082101,"comment_content":"设计模式不是设计出来的","like_count":1},{"had_liked":false,"id":354121,"user_name":"201201624","can_delete":false,"product_type":"c1","uid":2310202,"ip_address":"中国香港","ucode":"F47BD99C818F0E","user_header":"","comment_is_top":false,"comment_ctime":1660107518,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660107518","product_id":100082101,"comment_content":"策略模式是应对行为，状态模式是应对状态","like_count":0},{"had_liked":false,"id":303895,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1205777,"ip_address":"","ucode":"EB19F80070FE23","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/11/f7408e3e.jpg","comment_is_top":false,"comment_ctime":1627053893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627053893","product_id":100082101,"comment_content":"深呼吸啊😮‍💨","like_count":0}]}