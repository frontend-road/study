{"id":740877,"title":"第 9 章 Spring MVC 实践(2)","content":"<h2 id=\"nav_point_137\">9.2　Spring MVC 的请求处理逻辑</h2>\n<p>在看过了如何编写一个简单的 Spring MVC 程序后，大家心中应该会有一些好奇：这背后到底发生了什么？Spring MVC 是怎么把这些功能串联起来的？我们只是写了一个控制器而已，HTTP 请求是怎么转换为控制器方法的调用的？结果又是怎么变成 JSON 的……这一节就让我们一点一点来解释其中的逻辑。</p>\n<h3 id=\"nav_point_138\">9.2.1　请求的处理流程</h3>\n<p>现代 Java Web 项目在处理 HTTP 请求时基本都遵循一样的规范，即 Java Servlet 规范 <span class=\"comment-number\">7</span>（JSR 340）。其处理流程都是 Servlet 容器（例如 Tomcat 或者 Jetty）收到一个请求，接着找到合适的 Servlet 进行处理，随后返回响应。在 Spring MVC 中，这个处理请求的 Servlet 就是前面提到过的 <code>DispatcherServlet</code>。根据配置，Servlet 容器会将指定的请求都交由它来处理，在收到请求后，<code>DispatcherServlet</code> 会在 Spring 容器中找到合适的处理器（大部分情况下是控制器，即带有 <code>@Controller</code> 注解的类）来处理请求，处理结果经过视图模板后得到可以呈现（render）的响应内容，最后再返回给用户，图 9-2<span class=\"comment-number\">8</span> 展示了上述大致的过程。</p>\n\n\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00771.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-2　Spring MVC 的请求处理流程概要</strong></p>\n<ol>\n<li><p><strong>DispatcherServlet 的初始化</strong></p>\n<p>既然 <code>DispatcherServlet</code> 是一个 Servlet 的实现，那就会遵循其生命过程，例如会在创建后进行初始化。<code>HttpServletBean.init()</code> 方法调用了子类的方法 <code>FrameworkServlet.initServletBean()</code>，其中做了 Web 应用上下文的初始化，用的就是 <code>initWebApplicationContext()</code>。在初始化 Web 应用上下文或者是上下文更新时，都会调用 <code>DispatcherServlet.onRefresh()</code>，而这个方法就一句话，直接调用了下面的 <code>initStrategies()</code> 方法。</p>\n<pre class=\"code-rows\"><code>protected void initStrategies(ApplicationContext context) {\n    initMultipartResolver(context);\n    initLocaleResolver(context);\n    initThemeResolver(context);\n    initHandlerMappings(context);\n    initHandlerAdapters(context);\n    initHandlerExceptionResolvers(context);\n    initRequestToViewNameTranslator(context);\n    initViewResolvers(context);\n    initFlashMapManager(context);\n}</code></pre>\n<p>这段代码不难理解，就是在初始化 Spring MVC 的很多特殊类型的 Bean，表 9-4 对这些 Bean 做了一个简单的说明。</p>\n<p><strong>表 9-4　Spring MVC 中的特殊 Bean 类型</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>Bean 类型</th><th>说明</th></tr><tr><td><code>MultipartResolver</code></td><td>用来解析 <code>MultiPart</code> 请求的解析器，通常是上传文件的请求，<code>MultipartResolver</code> 这层抽象的背后会有多种实现，例如基于 Commons FileUpload</td></tr><tr><td><code>LocaleResolver</code></td><td>和语言环境有关的解析器，通常用于国际化相关的场景中，包含时区、语言等多种信息</td></tr><tr><td><code>ThemeResolver</code></td><td>主题（Theme）解析器，选择应用程序的外观界面，主题通常是一组静态资源</td></tr><tr><td><code>HandlerMapping</code></td><td>用于将请求映射到处理器上，过程中还包括各种前置与后置处理，两个主要的实现类是 <code>RequestMappingHandlerMapping</code> 和 <code>SimpleUrlHandlerMapping</code></td></tr><tr><td><code>HandlerAdapter</code></td><td>用于触发执行处理器，通过这层抽象，<code>DispatcherServlet</code> 可以不用关心具体如何执行调用</td></tr><tr><td><code>HandlerExceptionResolver</code></td><td>异常处理解析器</td></tr><tr><td><code>ViewResolver</code></td><td>用于将字符串形式的视图名称转化为具体的 <code>View</code>，<code>RequestToViewNameTranslator</code> 会根据请求信息转换对应的视图名称</td></tr><tr><td><code>FlashMapManager</code></td><td>用于存取在请求间暂存的输入与输出信息，通常会用在重定向时</td></tr></table>\n\n<p>&nbsp;</p>\n</li>\n<li><p><strong>请求的处理过程</strong></p>\n<p><code>DispatcherServlet</code> 在收到请求后，会交由 <code>doService()</code> 方法来进行处理，其中包含了两个主要的步骤：第一步，向请求中设置 Spring MVC 相关的一些属性；第二步，调用 <code>doDispatch()</code> 将请求分派给具体的处理器执行实际的处理。表 9-5 罗列了第一步里主要设置的几个属性。</p>\n<p><strong>表 9-5　<code>doService()</code> 方法中设置到 <code>HttpServletRequest</code> 里的几个属性</strong><sup><b>9</b></sup></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>属性名<sup><b>9</b></sup></th><th>说明</th></tr><tr><td><code>WEB_APPLICATION_CONTEXT_ATTRIBUTE</code></td><td><code>WebApplicationContext</code>，即 Web 的应用上下文</td></tr><tr><td><code>LOCALE_RESOLVER_ATTRIBUTE</code></td><td>处理请求时可能会需要用到的 <code>LocaleResolver</code>，如果没有国际化需求，可以忽略它</td></tr><tr><td><code>THEME_RESOLVER_ATTRIBUTE</code></td><td>用来决定使用哪个显示主题的 <code>ThemeResolver</code>，如果没有这个需求，也可以忽略它</td></tr><tr><td><code>THEME_SOURCE_ATTRIBUTE</code></td><td>用来获取主题的 <code>ThemeSource</code>，默认是当前的 <code>WebApplicationContext</code></td></tr><tr><td><code>INPUT_FLASH_MAP_ATTRIBUTE</code></td><td>上个请求传递过来暂存到 <code>FlashMapManager</code> 里的 <code>FlashMap</code></td></tr><tr><td><code>OUTPUT_FLASH_MAP_ATTRIBUTE</code></td><td>用来向后传递的 <code>FlashMap</code> 中的暂存信息</td></tr><tr><td><code>FLASH_MAP_MANAGER_ATTRIBUTE</code></td><td>如果当前存在 <code>FlashMapManager</code>，则将它设置到请求里</td></tr></table>\n\n<blockquote>\n<p><sup><b>9</b></sup>这里都是定义的常量名，并非具体的值。</p>\n</blockquote>\n<p><code>doDispatch()</code> 方法的大致处理逻辑如图 9-3 所示，<code>DispatcherServlet</code> 会尝试根据请求来找到合适的处理器，再通过 <code>HandlerAdapter</code> 来执行处理器的逻辑，经过前置处理、处理器处理和后置处理等多个步骤，最终返回一个 <code>ModelAndView</code>。<code>RequestMappingHandlerAdapter</code> 是专门用来调用 <code>@RequestMapping</code> 注解标记的处理器的。在处理结果的那一步，如果有异常就处理异常，例如交给专门的 <code>HandlerExceptionResolver</code> 来处理；如果没有异常就看 <code>ModelAndView</code>，不为空则呈现具体的视图，不存在也不用担心，因为请求可能已经处理完成了。</p>\n<p>通读了 <code>DispatcherServlet</code> 的 <code>doService()</code> 和 <code>doDispatch()</code> 方法之后，我们能大致了解整个请求的处理过程。如果感兴趣的话，你还可以通过 IDE 一步步调试一个请求的处理过程。例如，将端点加在 <code>doDispatch()</code> 的下面这行上，进入内部就能看到 <code>DispatcherServlet</code> 具体是如何从一个 <code>HttpServletRequest</code> 找到对应的处理器的：</p>\n<pre class=\"code-rows\"><code>mappedHandler = getHandler(processedRequest);</code></pre>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00772.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-3　<code>doDispatch()</code> 方法的大致处理逻辑</strong></p>\n<p>需要特别说明的是，在调用处理器逻辑处理的过程中，针对方法的返回值，会调用 <code>HandlerMethodReturnValueHandler</code> 进行处理——根据不同的情况，会有不同的实现来做处理，例如，加了 <code>@ResponseBody</code> 的方法，返回值就直接被 <code>RequestResponseBodyMethodProcessor</code> 处理掉了，选择合适的 <code>HttpMessageConverter</code> 将对象直接序列化为相应的内容；而返回字符串作为视图名的情况，则是由 <code>ViewNameMethodReturnValueHandler</code> 来处理的。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置 Spring MVC</strong></p>\n<p>在 9.1 节中，我们没有做任何配置，只是引入了 Web 相关的依赖，靠着 Spring Boot 的自动配置，就能直接开发 Spring MVC 的代码。Spring Boot 是先用 Spring 的配置启动，随后再启动内嵌的 Web 容器；如果没有 Spring Boot，就需要使用外置的 Web 容器，或者说 Servlet 容器了。</p>\n<p>因为现在大部分情况下会使用 Spring Boot，而 Spring Boot 又有完善的自动配置机制，我们不用太操心配置，所以在这部分就简单介绍一下如何在没有 Spring Boot 的情况下配置 Spring MVC。在传统的 Web 工程里，基本都会有一个 web.xml，我们可以把 <code>DispatcherServlet</code> 配置在这个文件里，例如：</p>\n<pre class=\"code-rows\"><code>&lt;web-app&gt;\n    &lt;!-- 配置应用上下文 --&gt;\n    &lt;listener&gt;\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n    &lt;/listener&gt;\n\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;\n    &lt;/context-param&gt;\n    &lt;!-- 配置Servlet --&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;</code></pre>\n<p>在上面的配置中，<code>ContextLoaderListener</code> 会加载指定的 XML 文件创建一个上下文，<code>DispatcherServlet</code> 再加载自己的配置文件，创建 Servlet 并映射到 <code>/</code>，两个上下文的关系就如 2.1.4 节中描述的那样，是继承关系。</p>\n<p>在 Servlet 3.0 以上的容器里，还可以通过 Java 类的方式来注册并初始化 <code>DispatcherServlet</code>，只要实现 <code>WebApplicationInitializer</code> 接口，容器会自动找到它。例如：</p>\n<pre class=\"code-rows\"><code>public class WebInitializer implements WebApplicationInitializer {\n    @Override\n    public void onStartup(ServletContext container) {\n        XmlWebApplicationContext appContext = new XmlWebApplicationContext();\n        appContext.setConfigLocation(\"classpath:dispatcher-servlet.xml\");\n\n        ServletRegistration.Dynamic registration = container.addServlet(\"dispatcher\",\n            new DispatcherServlet(appContext));\n        registration.setLoadOnStartup(1);\n        registration.addMapping(\"/\");\n    }\n}</code></pre>\n<p>在上面的代码中，我们还需要自己配置 Spring 的上下文，Spring MVC 提供了一个实现了 <code>WebApplicationInitializer</code> 的抽象类 <code>AbstractDispatcherServletInitializer</code>，通过它的子类 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 和 <code>AbstractDispatcherServletInitializer</code> 可以轻松地配置基于 Java 配置类的 <code>DispatcherServlet</code> 和基于 XML 文件的 <code>DispatcherServlet</code>。在实践时，更推荐使用这两个子类。</p>\n<p>在配置完 Servlet 后，就该配置 Spring MVC 了，同样有 XML 和 Java 类两种配置方式。在 XML 文件中，使用 <code>&lt;mvc:annotation-driven/&gt;</code> 来开启 Spring MVC，就像下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n        xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                              https://www.springframework.org/schema/beans/spring-beans.xsd\n                              http://www.springframework.org/schema/mvc\n                              https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;\n\n    &lt;mvc:annotation-driven/&gt;\n\n&lt;/beans&gt;</code></pre>\n<p>基于 Java 类的配置大概是下面这样的。我们需要在配置类上添加 <code>@EnableWebMvc</code> 注解，为了实现更精准的配置，还可以让配置类实现 <code>WebMvcConfigurer</code> 接口。在 Java 8 里，接口的方法可以带有默认实现，而 Spring Framework 5.0 开始支持的最低 Java 版本就是 Java 8，所以我们可以直接实现这个接口，不需要以前的 <code>WebMvcConfigurerAdapter</code> 抽象类了。</p>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n    // 按需实现对应方法\n}</code></pre>\n<p>图 9-4 列出了 <code>WebMvcConfigurer</code> 接口的各个方法，覆盖这些方法就能实现对 Spring MVC 的精准配置。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00773.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-4　<code>WebMvcConfigurer</code> 接口的各个方法</strong></p>\n<p>最后，再让我们回到 Spring Boot，Spring Boot 的 <code>DispatcherServletAutoConfiguration</code> 提供了针对 <code>DispatcherServlet</code> 的自动配置，而 <code>WebMvcAutoConfiguration</code> 则提供了 Spring MVC 的自动配置。后者的配置能满足绝大部分的系统需求，在 Spring 的默认配置基础之上还增加了很多额外的功能，例如，自动注册 <code>Converter</code>、<code>GenericConverter</code>、<code>Formatter</code>、<code>HttpMessageConverters</code> 和 <code>MessageCodesResolver</code> 类型的 Bean，支持静态资源等。</p>\n<p>如果希望在保留自动配置的基础上再做一些 Spring MVC 的定制，可以添加一个实现了 <code>WebMvcConfigurer</code> 的配置类，但<strong>一定不要加 <code>@EnableWebMvc</code> 注解</strong>，因为这样会破坏 Spring Boot 对 Spring MVC 的自动配置。如果希望定制 <code>RequestMappingHandlerMapping</code>、<code>RequestMappingHandlerAdapter</code> 和 <code>ExceptionHandlerExceptionResolver</code>，可以声明一个 <code>WebMvcRegistrations</code> 类型的 Bean，把那些对象塞到这个 Bean 里。</p>\n<p>如果希望完全由自己来控制 Spring MVC 的配置，可以选择关闭自动配置，或者定义一个带有 <code>@EnableWebMvc</code> 注解的配置类。在没有特殊理由的情况下，不建议这么操作，就让 Spring Boot 的自动配置替我们操心一切吧！</p>\n<blockquote>\n<p><strong>茶歇时间：Servlet 的基础知识</strong></p>\n<p>早期的 Web 只是简单地提供静态资源，例如页面和图片。随着技术的发展，逐步出现了一些动态技术，能够通过调用服务器上的一些程序动态地响应用户的请求。1993 年美国国家超级电脑应用中心（NCSA）提出了 CGI（Common Gateway Interface，通用网关接口）的概念并成功开发了一套 CGI 程序。后来 CGI 就成为了服务器和请求处理程序之间的一种标准，像 Perl、Python、PHP 等很多语言都能拿来开发 CGI 程序。</p>\n<p>不过，当时开发一个 CGI 程序还是比较麻烦的，用 Java 从头开发一个 CGI 程序也一样。为了规范 Java Web 程序，提升开发效率，Java EE（以前叫 J2EE）中诞生了 Java Servlet 技术。Oracle 官方是这样来介绍它的——Java Servlet 技术为 Web 开发者提供了一套既简单又一致的机制，可以用来扩展 Web 服务器的功能，访问现有的业务系统。通常情况下，运行在 Servlet 容器（例如 Tomcat）里的 Servlet 能够完全实现 CGI 程序的功能，甚至有过之而无不及。</p>\n<p>Servlet 规范定义了如何接收请求，如何返回响应，如何处理表单，如何处理异常，如何处理 Cookie，如何处理 Session……总之，其中定义了在日常 Web 开发时会遇到的绝大部分内容，只要我们遵循这个规范，使用它的实现，Web 的开发工作相比之前就能轻松不少。</p>\n<p>所有的 Servlet 都必须实现 <code>Servlet</code> 接口，其中有 5 个方法，分别是：</p>\n<ul>\n<li class=\"第3级无序列表\"><code>init()</code>，初始化方法；</li>\n<li class=\"第3级无序列表\"><code>getServletConfig()</code>，获得 Servlet 的配置，例如名称、初始化参数等；</li>\n<li class=\"第3级无序列表\"><code>getServletInfo()</code>，获得 Servlet 的信息，例如作者、版本等；</li>\n<li class=\"第3级无序列表\"><code>service()</code>，主要的执行方法；</li>\n<li class=\"第3级无序列表\"><code>destroy()</code>，销毁方法。</li>\n</ul>\n<p>但在实际开发时，我们更多地会使用 <code>HttpServlet</code> 这个抽象类，去实现里面的 <code>doXxx()</code> 方法，例如 <code>doGet()</code> 就是用来处理 <code>GET</code> 请求的。</p>\n<p>再后来，Java 程序员不满足于直接开发 Servlet，于是出现了各种 Web 开发框架，尤其是 MVC 模式的框架—Struts、WebWork 就是早期流行的 MVC 框架。当然，后来出现的 Spring MVC 超越了它们，成为了事实上的行业标准。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"nav_point_139\">9.2.2　请求处理方法</h3>\n<p>在 9.1.2 节中，我们已经看过了如何编写简单的控制器，其中介绍了 <code>@RequestMapping</code> 的用法。其实，Spring MVC 的控制器方法定义非常灵活，可以有各种参数和返回值，接下来就让我们详细了解一下具体的情况。</p>\n<ol>\n<li><p><strong>方法的定义</strong></p>\n<p>添加了 <code>@RequestMapping</code> 的方法就是用来处理 HTTP 请求的，所以可以通过方法的参数获得请求的各种信息，可以是原始的，也可以是经过处理的。表 9-6 列出了一些常用的参数类型，更多的内容可以参考 Spring Framework 官方文档中 Spring MVC 相关的章节。</p>\n<p><strong>表 9-6　Spring MVC 请求处理方法的常用参数类型</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><td>参数类型</td><td>说明</td></tr><tr><td><code>ServletRequest</code>、<code>ServletResponse</code></td><td>获取当前对应的请求与响应，可以是这两个接口的子类型，例如 <code>HttpServletRequest</code>，对这些对象的操作是最灵活的，但如果没有特殊原因，不建议直接操作 <code>ServletRequest</code> 和 <code>ServletResponse</code></td></tr><tr><td><code>HttpEntity&lt;T&gt;</code> 与 <code>RequestEntity&lt;T&gt;</code></td><td>获取当前请求的 HTTP 头和请求体，请求体会被 <code>HttpMessageConverter</code> 转换成对应的泛型类型</td></tr><tr><td><code>HttpSession</code></td><td>获取当前的 Session 信息，注意这里对 <code>Session</code> 的操作不是线程安全的</td></tr><tr><td><code>HttpMethod</code></td><td>获得请求的 HTTP 方法，例如 <code>GET</code> 或 <code>POST</code></td></tr><tr><td><code>InputStream</code> 与 <code>Reader</code></td><td>获得请求的原始消息体内容</td></tr><tr><td><code>OutputStream</code> 与 <code>Writer</code></td><td>获得响应的输出流，以便能够直接输出内容</td></tr><tr><td><code>Map</code>、<code>Model</code> 与 <code>ModelMap</code></td><td>获得用于呈现视图时要使用的模型信息，这三个类型的本质都是 <code>Map</code></td></tr><tr><td><code>Errors</code> 与 <code>BindingResult</code></td><td>获得绑定对象和校验时的错误信息</td></tr><tr><td><code>Principal</code></td><td>获得当前认证的用户信息</td></tr><tr><td><code>SessionStatus</code></td><td>与 <code>@SessionAttributes</code> 搭配使用，这是一个加在控制器类上的注解，指定将模型中的哪个属性作为 Session 属性存储起来，<code>SessionStatus</code> 的 <code>setComplete()</code> 方法用来清除存储的内容</td></tr></table>\n\n<p>除了上述类型，还可以在参数上增加一些注解，获取特定的信息，常用的注解如表 9-7 所示。</p>\n<p><strong>表 9-7　Spring MVC 请求处理方法的常用参数注解</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><td>注解</td><td>说明</td></tr><tr><td><code>@PathVariable</code></td><td>获得 <code>@RequestMapping</code> 的 <code>path</code> 里配置的占位符对应的值</td></tr><tr><td><code>@RequestParam</code></td><td>获得请求的参数</td></tr><tr><td><code>@RequestHeader</code></td><td>获得请求的 HTTP 头</td></tr><tr><td><code>@RequestBody</code></td><td>获得请求的消息体</td></tr><tr><td><code>@RequestPart</code></td><td>针对 Multipart 请求，获取其中指定的一段内容</td></tr><tr><td><code>@CookieValue</code></td><td>获得 Cookie 内容</td></tr><tr><td><code>@ModelAttribute</code></td><td>获得模型中的属性，如果不存在则初始化一个，请求数据会绑定到对象上并做校验。这个注解的用途比较多，建议查阅官方文档做更进一步的了解</td></tr><tr><td><code>@SessionAttribute</code></td><td>获得 Session 中已有的属性（注意和前面提到的类上的 <code>@SessionAttributes</code> 差一个 s）</td></tr><tr><td><code>@RequestAttribute</code></td><td>获得请求中已有的属性</td></tr></table>\n\n<p>上面提到的这些参数，大部分内容都会被转换成参数对应的类型，如果没有匹配到表 9-6 的类型，也没有带表 9-7 的注解，并且是简单类型（例如原子类型及其包装类、<code>String</code> 等），那就会被当做带有 <code>@RequestParam</code> 注解，否则就当做带有 <code>@ModelAttribute</code> 注解。</p>\n<p>聊完了方法的参数，再来看看方法的返回值，表 9-8 中列出了一些常见的返回值类型，基本都是围绕着呈现结果需要的模型与视图展开的，或者直接给出响应正文。</p>\n<p><strong>表 9-8　Spring MVC 请求处理方法的常见返回值类型</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><td>返回值类型</td><td>说明</td></tr><tr><td><code>@ResponseBody</code></td><td>方法的返回值会直接序列化为响应的消息正文</td></tr><tr><td><code>ModelAndView</code></td><td>返回最终呈现结果时会用到的模型与视图</td></tr><tr><td><code>Map</code> 与 <code>Model</code></td><td>返回的数据会被加入模型中，用来最终呈现的视图由 <code>RequestToViewNameTranslator</code> 来决定</td></tr><tr><td><code>View</code></td><td>返回视图对象，结合模型呈现最终内容</td></tr><tr><td><code>String</code></td><td>返回一个视图名，<code>ViewResolver</code> 要从中解析出视图，再结合模型呈现最终内容</td></tr><tr><td><code>HttpEntity&lt;T&gt;</code> 与 <code>ResponseEntity&lt;T&gt;</code></td><td>返回的对象就是完整的响应，包含了头和正文</td></tr><tr><td><code>HttpHeaders</code></td><td>响应只有 HTTP 头，没有消息正文</td></tr></table>\n\n<p>如果方法的返回值类型是 <code>void</code>，那么下面几种情况意味着请求已经被处理：</p>\n<ul>\n<li>有 <code>ServletResponse</code> 和 <code>OutputStream</code> 参数；</li>\n<li>有 <code>@ResponseStatus</code> 注解设置了返回的 HTTP 响应码；</li>\n<li>做过 HTTP 缓存处理，例如检查过 <code>E-TAG</code> 没变化。</li>\n</ul>\n<p>其他情况下，<code>void</code> 类型的返回值会用 <code>RequestToViewNameTranslator</code> 来解析获得视图的名称，再呈现结果。至于简单类型的返回值就不做解析，保留原样。</p>\n<blockquote>\n<p><strong>茶歇时间：请求处理过程中遇到的几个作用范围</strong></p>\n<p>在处理 HTTP 请求时，我们经常会获取一些信息，有时是从请求中，有时是从 Session 中，有时是从 Cookie 中，那它们又有哪些区别呢？</p>\n<p>请求的参数或正文里取得的内容，仅在当前这一次请求中有效，请求处理结束后它们也就随之消亡了。</p>\n<p>一个 Web 用户在正常操作时往往不会只请求一次，而是会与 Web 系统进行交互，这就是会话。会话期间会发生多次请求，这些请求彼此之间要共享一些信息，这些信息就可以放在 Session 里。Session 的信息是存储在服务器端的，用户的请求里带有名为 <code>JSESSIONID</code> 的 Cookie 值，通过这个值就能在服务器上找到对应的 Session 信息。这里面可以存储不同类型的数据，但出于服务器性能考虑一般不会存太多内容。Session 保存在服务器上，换一台服务器信息就没有了，因此在无状态的集群环境中，我们通常会将 Session 存储在共享存储里，例如放进关系型数据库或者 Redis，本书后面的章节里会再聊到分布式 Session 这个话题。</p>\n<p>Cookie 的本质是一个小型的文本文件，存放在客户端，单个 Cookie 文件的大小不超过 4KB，在指定的有效期内 Cookie 中存储的信息都会一直存在。如果在发起请求时带上客户端的 Cookie，处理时我们就能获取上传的 Cookie 信息了。</p>\n<p>在 Spring MVC 中，也有几个 Bean 的作用范围，在 Spring 容器基本的 <code>singleton</code> 和 <code>prototype</code> 的基础上，Web 应用程序上下文里还有如表 9-9 所示的 4 种特殊范围。</p>\n<p><strong>表 9-9　Web 应用程序上下文中所特有的作用范围</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>范围</th><th>说明</th></tr><tr><td><code>request</code></td><td>仅存活在单次 HTTP 请求里</td></tr><tr><td><code>session</code></td><td>仅存活在单个 Session 范围里，会话失效（也就是 Session 失效后），Bean 也就被销毁了</td></tr><tr><td><code>application</code></td><td>在整个 <code>ServletContext</code> 的生命周期里有效</td></tr><tr><td><code>websocket</code></td><td>在单个 <code>WebSocket</code> 的生命周期里有效</td></tr></table>\n\n<p>不过这几种作用范围相比 <code>singleton</code> 和 <code>prototype</code> 而言实在是太小众了，通常没有特殊情况不建议做专门的配置。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>请求内容的转换</strong></p>\n<p>前面有提到好几个参数类型都带有泛型，此外 <code>@RequestBody</code> 和 <code>@RequestPart</code> 也会对请求的内容进行转换，将它们转换为各种不同的类型传到参数中，这里的转换其实就是由 <code>HttpMessageConverter</code> 来实现的。在 Spring MVC 中，框架为我们内置了大量的转换器，例如之前已经用到过的 Jackson JSON 的转换，其他默认的常用 <code>HttpMessageConverter</code> 如表 9-10 所示。</p>\n<p><strong>表 9-10　Spring MVC 内置的常用<code>HttpMessageConverter</code> 列表</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><td>类名</td><th>生效条件</th><th>处理类型</th></tr><tr><td><code>ByteArrayHttpMessageConverter</code></td><td>默认生效</td><td>字节数组</td></tr><tr><td><code>StringHttpMessageConverter</code></td><td>默认生效</td><td>文本</td></tr><tr><td><code>AllEncompassingFormHttpMessageConverter</code></td><td>默认生效</td><td>按 CLASSPATH 加载支持的所有类型</td></tr><tr><td><code>AtomFeedHttpMessageConverter</code></td><td>存在 ROME 依赖</td><td>Atom Feed，即 <code>application/atom+xml</code></td></tr><tr><td><code>RssChannelHttpMessageConverter</code></td><td>存在 ROME 依赖</td><td>RSS Feed，即 <code>application/rss+xml</code></td></tr><tr><td><code>MappingJackson2XmlHttpMessageConverter</code></td><td>存在 Jackson 的 XML 依赖</td><td>XML</td></tr><tr><td><code>Jaxb2RootElementHttpMessageConverter</code></td><td>存在 <code>javax.xml.bind.Binder</code></td><td>XML</td></tr><tr><td><code>MappingJackson2HttpMessageConverter</code></td><td>存在 Jackson 的 JSON 依赖</td><td>JSON</td></tr><tr><td><code>GsonHttpMessageConverter</code></td><td>存在 Gson 依赖</td><td>JSON</td></tr><tr><td><code>JsonbHttpMessageConverter</code></td><td>存在 JSON Binding API 依赖</td><td>JSON</td></tr><tr><td><code>MappingJackson2SmileHttpMessageConverter</code></td><td>存在 Jackson 的 Smile 依赖</td><td>二进制 JSON，即 <code>application/x-jackson-smile</code></td></tr></table>\n\n<p>其中 XML 和 JSON 的优先顺序都是自上而下的，也就是如果存在 Jackson 的依赖，会先用 Jackson 来处理。</p>\n<p>在 Spring MVC 里，相关的判断和初始化设置都是在 <code>WebMvcConfigurationSupport</code> 里做的，例如判断依赖是否满足，就是下面这样的：</p>\n<pre class=\"code-rows\"><code>static {\n    ClassLoader classLoader = WebMvcConfigurationSupport.class.getClassLoader();\n    romePresent = ClassUtils.isPresent(\"com.rometools.rome.feed.WireFeed\", classLoader);\n    jaxb2Present = ClassUtils.isPresent(\"javax.xml.bind.Binder\", classLoader);\n    jackson2Present = ClassUtils.isPresent(\"com.fasterxml.jackson.databind.ObjectMapper\", classLoader)\n        &amp;&amp; ClassUtils.isPresent(\"com.fasterxml.jackson.core.JsonGenerator\", classLoader);\n    jackson2XmlPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.xml.XmlMapper\", classLoader);\n    jackson2SmilePresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.smile.SmileFactory\", classLoader);\n    jackson2CborPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.cbor.CBORFactory\", classLoader);\n    gsonPresent = ClassUtils.isPresent(\"com.google.gson.Gson\", classLoader);\n    jsonbPresent = ClassUtils.isPresent(\"javax.json.bind.Jsonb\", classLoader);\n}</code></pre>\n<p>我们可以实现 <code>WebMvcConfigurer</code> 接口，覆盖 <code>configureMessageConverters()</code> 方法来配置自己的 <code>HttpMessageConverter</code>。但在 Spring Boot 里，还有更简单的方法，有一个 <code>HttpMessageConvertersAutoConfiguration</code> 自动配置类，大致代码如下：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(HttpMessageConverter.class)\n@Conditional(NotReactiveWebApplicationCondition.class)\n@AutoConfigureAfter({ GsonAutoConfiguration.class, JacksonAutoConfiguration.class,\n    JsonbAutoConfiguration.class })\n@Import({\nJacksonHttpMessageConvertersConfiguration.class,\nGsonHttpMessageConvertersConfiguration.class,\nJsonbHttpMessageConvertersConfiguration.class\n})\npublic class HttpMessageConvertersAutoConfiguration {\n    static final String PREFERRED_MAPPER_PROPERTY = \"spring.mvc.converters.preferred-json-mapper\";\n\n    @Bean\n    @ConditionalOnMissingBean\n    public HttpMessageConverters messageConverters(ObjectProvider&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {\n        return new HttpMessageConverters(converters.orderedStream().collect(Collectors.toList()));\n    }\n    // 省略其他代码\n}</code></pre>\n<p>其中，除了有相关依赖的导入和自动配置执行顺序设置，更重要的是它还会从上下文里获取 <code>HttpMessageConverter</code> 并设置到 <code>HttpMessageConverters</code> 对象中。而这个对象会被 Spring MVC 的自动配置类 <code>WebMvcAutoConfiguration</code> 所使用，其内部类 <code>WebMvcAutoConfigurationAdapter</code> 的 <code>configureMessageConverters()</code> 就会从 <code>HttpMessageConverters</code> 中取出所有的 <code>HttpMessageConverter</code>。</p>\n<pre class=\"code-rows\"><code>public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {\n    this.messageConvertersProvider\n        .ifAvailable((customConverters) -&gt; converters.addAll(customConverters.getConverters()));\n}</code></pre>\n<p>综上所述，在 Spring Boot 的加持下，我们只需要把自己定制好的 <code>HttpMessageConverter</code> 对象配置为 Spring 上下文中的 Bean，剩下的就不用操心了。</p>\n<blockquote>\n<p><strong>茶歇时间：Spring Boot 自动配置预埋的扩展点</strong></p>\n<p>通常，Spring Boot 针对它内置的自动配置都会提供一些扩展点，我们希望在调整某些配置时，不必彻底禁用相关自动配置，而是找到这些扩展点。以 JSON 配置为例，如果我们希望对 Jackson JSON 的配置做些小修改，例如调整几个序列化参数，可以不用自己新配一个 <code>ObjectMapper</code>，而是看看前面代码中出现的 <code>JacksonAutoConfiguration</code>。</p>\n<p>通读其中的逻辑，可以发现下面这几个细节：</p>\n<ul>\n<li class=\"第3级无序列表\">自动配置中的 <code>JacksonObjectMapperConfiguration</code>，使用 <code>Jackson2ObjectMapperBuilder</code> 来创建 <code>ObjectMapper</code>；</li>\n<li class=\"第3级无序列表\"><code>Jackson2ObjectMapperBuilder</code> 是由 <code>JacksonObjectMapperBuilderConfiguration</code> 提供的；</li>\n<li class=\"第3级无序列表\">自动配置的 <code>Jackson2ObjectMapperBuilder</code> 在创建后会使用上下文中的 <code>Jackson2ObjectMapperBuilderCustomizer</code> 来做个性化配置。</li>\n</ul>\n<p>因此，如果我们想要调整 <code>ObjectMapper</code>，只需要在上下文中提供自己的 <code>Jackson2ObjectMapperBuilderCustomizer</code> Bean 就行了。它可以定制序列化器、反序列化器、Jackson JSON 的各种 Feature 等。除此之外，其他还有很多自动配置也有类似的扩展点，例如，后面会接触到的 <code>RestTemplate</code>，它的 <code>RestTemplateAutoConfiguration</code> 也有提供 <code>RestTemplateCustomizer</code> 来做个性化配置。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>绑定与校验</strong></p>\n<p>之前有提到过，在定义控制器方法时，不少参数的取值都是绑定了请求中的内容。如果是将完整的请求转换成对象，可以用 <code>HttpMessageConverter</code> 来处理类型转换，那类似 HTTP 表单这样的，将某个属性绑定到参数对象里，又是通过什么来实现类型转换的呢？</p>\n<p>在 Spring MVC 中可以通过带有 <code>@InitBinder</code> 注解的方法来初始化 <code>WebDataBinder</code>，它能将请求参数（表单或查询数据）绑定到模型对象上；将请求中的字符串转换为控制器方法中的各种参数类型；在呈现 HTML 表单时，将模型对象中的值格式化为字符串。虽说 <code>WebDataBinder</code> 可以注册 <code>PropertyEditor</code> 做转化，但个人更倾向注册 <code>Converter</code> 和 <code>Formatter</code>，官方文档中有这么一段例子，非常简单：</p>\n<pre class=\"code-rows\"><code>@Controller\npublic class FormController {\n    @InitBinder\n    protected void initBinder(WebDataBinder binder) {\n        binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\"));\n    }\n    // ...\n}</code></pre>\n<p>自 3.0 开始，Spring Framework 提供了一套类型转换机制，其核心就是上面讲到的 <code>Converter&lt;S, T&gt;</code> 接口，它能将一个类型转换为另一个，具体的接口定义如下所示：</p>\n<pre class=\"code-rows\"><code>public interface Converter&lt;S, T&gt; {\n    T convert(S source);\n}</code></pre>\n<p>这个接口十分通用，能够处理各种类型，但在 Web 中，我们更多是在与 <code>String</code> 打交道，所以可以用 <code>Formatter</code> 来实现上面 <code>Converter</code> 的功能，可以说前者是后者的一个特例。<code>Formatter</code> 的定义如下所示：</p>\n<pre class=\"code-rows\"><code>public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {}</code></pre>\n<p><code>Printer&lt;T&gt;</code> 和 <code>Parser&lt;T&gt;</code> 都是针对 <code>String</code> 和类型 <code>T</code> 的，一个将 <code>T</code> 变为 <code>String</code>，另一个则反过来。以 <code>Money</code> 类为例，我们可以像代码示例 9-8<span class=\"comment-number\">10</span> 那样来做处理。这里只做了最基本的判断，不能用于生产环境，在转换为文本时只输出了金额，没有带币种，从文本转为 <code>Money</code> 时，使用了 <code>org.apache.commons:commons-lang3</code> 中的 <code>NumberUtils</code> 对数字进行了判断，如果是数字再将其转为 <code>BigDecimal</code>，用它来创建人民币。</p>\n<blockquote>\n<p><strong>代码示例 9-8</strong>　简单的 <code>Money</code> 类型转换</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\npublic class MoneyFormatter implements Formatter&lt;Money&gt; {\n    @Override\n    public Money parse(String text, Locale locale) throws ParseException {\n        if (NumberUtils.isParsable(text)) {\n            return Money.of(CurrencyUnit.of(\"CNY\"), NumberUtils.createBigDecimal(text));\n        }\n        throw new ParseException(text, 0);\n    }\n\n    @Override\n    public String print(Money object, Locale locale) {\n        return object.getAmount().toString();\n    }\n}</code></pre>\n<p>在 Spring Boot 中，我们无须去手动初始化 <code>WebDataBinder</code>，注册 <code>MoneyFormatter</code>，Spring Boot 的 MVC 自动配置会收集上下文中的 <code>Converter</code> 和 <code>Formatter</code>，自动完成注册。我们只需通过 <code>@Component</code> 或其他方式将它们声明为 Bean 就可以了。</p>\n<p>在将请求内容绑定到参数上之后，一般还会做一些内容的校验，Spring Framework 中就支持 Jakarta Bean Validation API，Hibernate Validator 就是它的一种实现。可以通过注解来标记一些属性，为它加上约束，表 9-11 列举了一些常用注解，这些注解在 <code>javax.validation.constraints</code> 包里 <span class=\"comment-number\">11</span>。可以在 pom.xml 中引入 Hibernate Validator 的依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n     &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;\n     &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p><strong>表 9-11　Jakarta Bean Validation API 中的一些常用注解</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>注解</th><th>说明</th></tr><tr><td><code>@Null</code>、<code>@NotNull</code>、<code>@NotBlank</code>、<code>@NotEmpty</code></td><td>各种 <code>null</code>、非 <code>null</code>、非空白、非空的判断</td></tr><tr><td><code>@Email</code></td><td>是否为电子邮件地址</td></tr><tr><td><code>@Digits</code></td><td>是否是指定范围和类型的数字</td></tr><tr><td><code>@Min</code>、<code>@Max</code>、<code>@DecimalMin</code>、<code>@DecimalMax</code></td><td>数字是否在给定最大、最小范围内</td></tr><tr><td><code>@Negative</code>、<code>@NegativeOrZero</code>、<code>@Positive</code>、<code>@PositiveOrZero</code></td><td>数字是负数、正数和零的相关判断</td></tr><tr><td><code>@Future</code>、<code>@FutureOrPresent</code>、<code>@Past</code>、<code>@PastOrPresent</code></td><td>时间是过去、现在和将来的判断</td></tr><tr><td><code>@Size</code></td><td>集合类型、数组、字符串的长度判断</td></tr><tr><td><code>@Pattern</code></td><td>按正则表达式进行匹配</td></tr></table>\n\n<p>在对象的属性上添加了上述注解后，还需要在控制器方法的对应参数上增加 <code>@Valid</code> 注解，声明这个参数需要进行绑定校验。紧随其后的参数必须是 <code>Errors</code> 或 <code>BindingResult</code> 类型的，以便我们能够获得校验的错误信息。</p>\n<p>在了解了绑定与校验的基本内容后，让我们通过实际的例子来看看具体该如何使用这些功能。</p>\n<blockquote>\n<p><strong>需求描述</strong>　二进制奶茶店的菜单中有一部分饮品是根据季节调整的。店员需要有途径来新增饮品，例如，草莓上市的季节，就可以推出草莓主题的水果茶。为此，我们需要开发一个接口，让店员能方便地新增菜单项。</p>\n</blockquote>\n<p>在 9.1 节中，我们已经看过了如何使用 JSON 来做交互，这里，我们换种方式，用 HTTP 的 Form 表单来提交一些表单。表单对象如代码示例 9-9 所示。</p>\n<blockquote>\n<p><strong>代码示例 9-9</strong>　表单对象 <code>NewMenuItemForm</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Getter\n@Setter\npublic class NewMenuItemForm {\n    @NotBlank\n    private String name;\n    @NotNull\n    private Money price;\n    @NotNull\n    private Size size;\n}</code></pre>\n<p>处理新建表单请求的 <code>createByForm()</code> 方法，如代码示例 9-10 所示，它接收发往 <code>/menu</code> 的 <code>POST</code> 请求（请求的媒体类型是 <code>application/x-www-form-urlencoded</code>），将表单绑定到 <code>NewMenuItemForm</code> 后再进行校验，如果 <code>result.hasErrors()</code> 为 <code>true</code>，说明有问题，这时将 HTTP 的响应码设置为 <code>400 Bad Request</code>；如果没有问题，则调用 <code>MenuService</code> 的 <code>save()</code> 方法。</p>\n<blockquote>\n<p><strong>代码示例 9-10</strong>　增加了 <code>createByForm()</code> 方法后的 <code>MenuController</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Controller\n@ResponseBody\n@RequestMapping(\"/menu\")\n@Slf4j\npublic class MenuController {\n    @Autowired\n    private MenuService menuService;\n\n    @PostMapping(consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n    public Optional&lt;MenuItem&gt; createByForm(@Valid NewMenuItemForm form, BindingResult result,\n                                           HttpServletResponse response) {\n        if (result.hasErrors()) {\n            log.warn(\"绑定参数错误：{}\", result.getAllErrors());\n            response.setStatus(HttpStatus.BAD_REQUEST.value());\n            return Optional.empty();\n        }\n        MenuItem item = MenuItem.builder().name(form.getName())\n                .price(form.getPrice()).size(form.getSize()).build();\n        return menuService.save(item);\n    }\n    // 省略其他内容\n}</code></pre>\n<p><code>MenuService</code> 中要增加一个保存 <code>MenuItem</code> 的方法，具体如代码示例 9-11 所示，就是简单地调用了 <code>MenuRepository</code> 的同名方法。</p>\n<blockquote>\n<p><strong>代码示例 9-11</strong>　增加了 <code>save()</code> 方法的 <code>MenuService</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Transactional\n@CacheConfig(cacheNames = \"menu\")\npublic class MenuService {\n    @Autowired\n    private MenuRepository menuRepository;\n\n    public Optional&lt;MenuItem&gt; save(MenuItem menuItem) {\n        return Optional.ofNullable(menuRepository.save(menuItem));\n    }\n    // 省略其他内容\n}</code></pre>\n<p>由于我们目前使用的是 H2 内存数据库，Spring Data JPA 在映射时会将自增主键自动配置为从序列中获取 ID。我们可以考虑稍作调整，在 <code>@GeneratedValue</code> 中将生成策略设置为 <code>GenerationType.IDENTITY</code>，直接使用 H2 的自增主键。代码示例 9-12 是 <code>MenuItem</code> 的 <code>id</code> 属性，其他几个类也需要调整一下注解。</p>\n<blockquote>\n<p><strong>代码示例 9-12</strong>　设置了 <code>GenerationType.IDENTITY</code> 策略的 <code>MenuItem</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Builder\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\n@Table(name = \"t_menu\")\npublic class MenuItem implements Serializable {\n    private static final long serialVersionUID = 8585684450527309518L;\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    // 省略其他内容\n}</code></pre>\n<p>表单 <code>POST</code> 请求不太好用浏览器模拟，这时就需要引入新的工具了，本书将使用 Postman<span class=\"comment-number\">12</span> 来发送 HTTP 请求。在其主界面上，通过 New 按钮打开菜单，选择 Request 来创建新请求，也可以新建 Collection，将请求分门别类地收纳在集合中。现在，假设我们创建了一个“创建饮料”的请求，在 Body 中选择 <code>x-www-form-urlencoded</code> 作为正文类型，输入表单中对应的内容，如图 9-5 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00774.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-5　Postman 中创建的“创建饮料”请求</strong></p>\n<p>在 <code>BinaryTeaApplication</code> 程序运行后，点击 Send 按钮，后端服务就能收到我们发往 http://localhost:8080/menu 的 <code>POST</code> 请求，返回的内容是个 JSON，大致如下所示：</p>\n<pre class=\"code-rows\"><code>{\n    \"id\": 4,\n    \"name\": \"Ruby草莓果茶\",\n    \"size\": \"MEDIUM\",\n    \"price\": {\n        \"amount\": 15.00,\n        \"currency\": \"CNY\"\n    },\n    \"createTime\": \"2020-11-23T16:57:10.562+00:00\",\n    \"updateTime\": \"2020-11-23T16:57:10.563+00:00\"\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>文件上传</strong></p>\n<p>除了常见的请求，HTTP 也支持上传文件，使用的媒体类型是 <code>multipart/form-data</code> 或者 <code>multipart/mixed</code>，在定义方法时，我们可以通过 <code>MultipartFile</code> 这个参数类型来获得上传的文件，从中取得 <code>InputStream</code> 读取内容，接下来看个例子。</p>\n<blockquote>\n<p><strong>需求描述</strong>　在之前的二进制奶茶店例子中，一次新建一个条目的做法虽然简单直接，但在遇到需要添加大量菜单项的时候不免效率低下，最好能够一次性编辑好要添加的内容，完成添加的动作。这时，我们就可以选择先编写文件，然后将文件全部上传，从而实现批量添加的操作。</p>\n</blockquote>\n<p>代码示例 9-13 是用来批量创建菜单条目的方法，在 <code>@PostMapping</code> 注解中标记了该方法接受 <code>multipart/form-data</code> 这种媒体类型，用 <code>@RequestParam</code> 注解将请求中的文件部分绑定给了 <code>file</code> 参数，该方法主要做了这么一些动作：</p>\n<p>(1) 获取当前请求的 URI 地址，以便在后面构造返回对象时使用；</p>\n<p>(2) 判断获取的文件是否为空，如果为空则返回 <code>400 Bad Request</code> 响应；</p>\n<p>(3) 取得文件的输入流，逐行读取内容，并转换为 <code>MenuItem</code> 对象；</p>\n<p>(4) 将 <code>MenuItem</code> 集合一起保存到数据库，返回 <code>201 Created</code> 响应，并带上保存后的对象；</p>\n<p>(5) 如果发生异常，则返回 <code>500 Internal Server Error</code> 响应。</p>\n<blockquote>\n<p><strong>代码示例 9-13</strong>　<code>MenuController</code> 中的 <code>createBatch()</code> 方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)\npublic ResponseEntity&lt;List&lt;MenuItem&gt;&gt; createBatch(@RequestParam(\"file\") MultipartFile file) {\n    List&lt;MenuItem&gt; menuItemList = new ArrayList&lt;&gt;();\n    URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().build().toUri();\n    log.info(\"Current URI: {}\", uri);\n    if (file == null || file.isEmpty()) {\n        log.warn(\"File can NOT be null or empty.\");\n        return ResponseEntity.badRequest().body(menuItemList);\n    }\n    try (BufferedReader reader = new BufferedReader(new InputStreamReader(file.getInputStream()))) {\n        menuItemList = reader.lines().map(l -&gt; StringUtils.split(l))\n        .filter(f -&gt; f != null &amp;&amp; f.length == 3)\n        .map(f -&gt; MenuItem.builder()\n        .name(f[0])\n        .size(Size.valueOf(f[1]))\n        .price(Money.of(CurrencyUnit.of(\"CNY\"), NumberUtils.createBigDecimal(f[2])))\n        .build()).collect(Collectors.toList());\n        return ResponseEntity.created(uri).body(menuService.save(menuItemList));\n    } catch (Exception e) {\n        log.error(\"Exception occurred while creating menu list.\", e);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(menuItemList);\n    }\n}</code></pre>\n<p>这段代码里，我们用到了 <code>ResponseEntity&lt;T&gt;</code>，通过它可以方便地设置返回的 HTTP 响应码；用到了 <code>try-with-resource</code> 的语法，这样可以不用操心资源的关闭问题；还用到了 Lambda 表达式过滤并转换读取的文本内容。代码中调用的 <code>save()</code> 方法如代码示例 9-14 所示，在控制器的方法里只做一些校验和转换工作，实际的保存逻辑建议还是放在 <code>Service</code> 类中。再者，<code>Service</code> 类上增加了事务注解，可以保证这批对象要么一起保存成功，要么一起失败。如果在 <code>createBatch()</code> 方法中循环调用单个对象的保存，则有可能出现部分成功，部分失败的情况。</p>\n<blockquote>\n<p><strong>代码示例 9-14</strong>　<code>MenuService</code> 中用来批量保存 <code>MenuItem</code> 的 <code>save()</code> 方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public List&lt;MenuItem&gt; save(List&lt;MenuItem&gt; items) {\n    return menuRepository.saveAll(items);\n}</code></pre>\n<p>我们使用的文件就是普通的文本，格式如下所示，用空格分隔，内容依次是名称、大小规格、价格：</p>\n<pre class=\"code-rows\"><code>Ruby草莓果茶 SMALL 12.00\nRuby草莓果茶 MEDIUM 15.00\nRuby草莓果茶 LARGE 18.00</code></pre>\n<p>在 Postman 中，可以新建一个请求，HTTP 方法选择 <code>POST</code>，填上地址，Body 部分的格式选择 <code>form-data</code>，请求内容 KEY 为 <code>file</code>，类型为文件 <code>File</code>，这时 VALUE 就是一个文件选择按钮，可以选择事先准备好的文本，例如，把上面的三行文字保存为一个 drinks.txt，如图 9-6 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00775.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-6　上传文件到 http://localhost:8080/menu 的 Postman 请求</strong></p>\n<p>发送这个请求，就能得到如下的 JSON 响应了：</p>\n<pre class=\"code-rows\"><code>[\n    {\n        \"id\": 3,\n        \"name\": \"Ruby草莓果茶\",\n        \"size\": \"SMALL\",\n        \"price\": {\n            \"amount\": 12.00,\n            \"currency\": \"CNY\"\n        },\n        \"createTime\": \"2020-11-27T09:53:18.041+00:00\",\n        \"updateTime\": \"2020-11-27T09:53:18.041+00:00\"\n    },\n    // 省略另外两个饮品的信息\n]</code></pre>\n<p>如果用单元测试来验证是否上传了空内容，那就会像代码示例 9-15 那样，大家记得把构建时的 <code>alwaysExpect(status().isOk())</code> 注释掉，因为这里我们返回的是 <code>400 Bad Request</code>。</p>\n<blockquote>\n<p><strong>代码示例 9-15</strong>　对于上传空内容的测试</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass MenuControllerTest {\n    // 省略其他内容\n    @Test\n    void testCreateBatchWithEmptyFile() throws Exception {\n        mockMvc.perform(multipart(\"/menu\")\n                .file(\"file\", null))\n                .andExpect(status().isBadRequest())\n                .andExpect(content().string(\"[]\"));\n    }\n}</code></pre>\n</li>\n</ol>\n\n\n\n<h2 id=\"nav_point_140\">9.3　Spring MVC 的视图机制</h2>\n<p>在控制器处理完请求之后，需要向前端来呈现最终的结果，这时就会涉及视图的解析，以及解析得到的视图的最终呈现。这个过程总共分为三步：第一步，得到视图名；第二步，根据视图名获取对应的视图对象；第三步，通过视图对象呈现视图。最后一步的实现与具体的视图技术有关，这里就不再详细展开，我们将关注的重点放在前两步上。</p>\n<h3 id=\"nav_point_141\">9.3.1　视图解析</h3>\n<p>在讨论控制器的方法定义时，我们聊到有如下几种常用的返回值能指定视图名称，即 <code>String</code>、<code>ModelAndView</code> 和 <code>View</code>，这三种类型都直接指定了视图。在没有明确指定的情况下，<code>DispatcherServlet</code> 会尝试根据请求设置默认的视图，这项工作是由 <code>RequestToViewNameTranslator</code> 接口来实现的。</p>\n<p><code>DispatcherServlet</code> 在初始化时，会先尝试从上下文中查找名称为 <code>viewNameTranslator</code> 的 Bean，没有找到的话就初始化一个 <code>DefaultRequestToViewNameTranslator</code> 实例。它的逻辑非常简单，去掉 URI 里开头和结尾的斜杠，以及文件扩展名，剩下的部分拼上指定的前后缀作为视图名返回。</p>\n<p>有了视图名之后，就该根据它来解析出视图对象了，这个步骤依靠 <code>ViewResolver</code> 来实现，图 9-7<span class=\"comment-number\">13</span> 展示了该接口及其部分实现类的关系，表 9-12 对其中的一些类做了说明。</p>\n\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00776.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-7　<code>ViewResolver</code> 及其部分实现类的关系</strong></p>\n<p><strong>表 9-12　<code>ViewResolver</code> 的部分实现类</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类名</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>BeanNameViewResolver</code></p></td>\n<td><p>将视图名称作为 Bean 名称在上下文中查找视图</p></td>\n</tr>\n<tr>\n<td><p><code>ContentNegotiatingViewResolver</code></p></td>\n<td><p>支持内容协商的视图解析器，可以根据 HTTP 的 <code>Accept</code> 头或者请求参数来确定视图</p></td>\n</tr>\n<tr>\n<td><p><code>ViewResolverComposite</code></p></td>\n<td><p>组合视图解析器，能够按照指定顺序逐一进行视图名的匹配</p></td>\n</tr>\n<tr>\n<td><p><code>UrlBasedViewResolver</code></p></td>\n<td><p>基于 URL 进行视图解析的解析器。除了解析正常的视图之外，如果视图名中包含 <code>redirect:</code> 和 <code>forward:</code> 前缀，它还会做一些特殊的处理，前者是客户端的重定向，相当于 HTTP 302 跳转；后者是服务端的重定向，实际是做了一次 <code>RequestDispatcher.forward()</code> 操作</p></td>\n</tr>\n<tr>\n<td><p><code>AbstractTemplateViewResolver</code></p></td>\n<td><p>针对模板的解析器抽象类，FreeMarker、Velocity 这些模板的解析器都是其实现类</p></td>\n</tr>\n<tr>\n<td><p><code>InternalResourceViewResolver</code></p></td>\n<td><p>内置资源视图解析器，用于 JSP 和 JSTL 如果没有特殊处理，这个解析器是用来“兜底”的</p></td>\n</tr>\n</tbody>\n</table>\n<p>Spring Boot 的 <code>WebMvcAutoConfiguration</code> 自动配置类默认提供了 <code>InternalResourceViewResolver</code>、<code>BeanNameViewResolver</code> 和 <code>ContentNegotiatingViewResolver</code> 的 Bean 配置，如果存在可以支持的模板引擎，也会做对应的处理，后面的常用视图部分会再展开。</p>\n<p>在 <code>WebMvcConfigurationSupport</code> 里其实也有视图解析器相关的逻辑，<code>mvcViewResolver()</code> 中通过 <code>ViewResolverRegistry</code> 来收集配置上下文里的视图解析器，随后创建了一个 <code>ViewResolverComposite</code>，按顺序尝试解析最合适的视图。</p>\n<h3 id=\"nav_point_142\">9.3.2　常用视图类型</h3>\n<p>Spring MVC 支持多种不同的视图，例如，模板语言 Thymeleaf、FreeMarker、Groovy Markup 等，只要是支持 JSR-223 的脚本引擎（Nashron、JRuby、Jython 等），Spring MVC 都能正确地将脚本结果作为视图；此外，还支持 PDF、Excel、RSS 和 Atom，上文也提到了 JSP 与 JSTL；如果是作为 REST 服务，还会经常用到 JSON 和 XML 来作为响应，Spring MVC 对主流的 JSON 和 XML 的库也有很好的支持，比如 Jackson 和 Gson 等。</p>\n<p>之前的章节中，我们已经多次使用过 JSON 了，在本节中就分别介绍一下如何在 Spring MVC 中使用 XML 和 Thymeleaf 模板。</p>\n<ol>\n<li><p><strong>XML</strong></p>\n<p>在基于 SOAP 的 WebService 流行的时候，XML 是分布式系统交互的重要格式之一，虽然后来越来越多的系统开始使用 JSON 和更高效的二进制协议（例如 Google 的 Protobuf）进行交互，但 XML 的地位依然十分重要。</p>\n<p>Spring MVC 中内置了对 Jackson XML 的支持，我们可以通过它来序列化 XML。<code>MappingJackson2XmlView</code> 与 <code>MappingJackson2JsonView</code> 都是继承自 <code>AbstractJackson2View</code> 的，拥有几乎一致的处理逻辑，只是输出的 <code>Content-Type</code> 不同。它们会在代表返回 Model 的 <code>Map</code> 中查找键为 <code>JsonView.class.getName()</code> 对应的对象，然后对其做序列化输出。</p>\n<p>在 9.2.1 节中，我们还介绍过添加了 <code>@ResponseBody</code> 注解的方法，其返回值会直接被 <code>HttpMessageConverter</code> 序列化为对应的格式，无须再通过一系列视图解析和呈现的过程（也就是<strong>和视图没什么关系</strong>），两种方式其实都能帮我们实现相同的目的。在前后端分离、后端以提供 REST 服务为主的大前提下，这种方式似乎使用得更多一些。</p>\n<p>我们可以在 pom.xml 中像下面这样加入 Jackson 的 XML 格式支持：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>Spring Boot 的 <code>JacksonHttpMessageConvertersConfiguration</code> 配置类会帮助我们处理剩下的工作，像下面这样，在 CLASSPATH 里有 <code>XmlMapper</code> 类，上下文里存在 <code>Jackson2ObjectMapperBuilder</code> 类型的 Bean 时，为我们创建一个 <code>MappingJackson2XmlHttpMessageConverter</code>：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(XmlMapper.class)\n@ConditionalOnBean(Jackson2ObjectMapperBuilder.class)\nprotected static class MappingJackson2XmlHttpMessageConverterConfiguration {\n    @Bean\n    @ConditionalOnMissingBean\n    public MappingJackson2XmlHttpMessageConverter mappingJackson2XmlHttpMessageConverter(\n        Jackson2ObjectMapperBuilder builder) {\n        return new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build());\n    }\n}</code></pre>\n<p>代码部分无须任何改动，我们就可以让 binarytea-form-controller 这个例子根据请求的 <code>Accept</code> 头来指定返回 JSON 还是 XML。除了下面这个方法，其他都能直接支持返回 XML，因为我们在 <code>produces</code> 里指定了只支持返回 JSON，可以去掉这个限制，或者将其改为 <code></code>，同时支持两种格式。一般如果没有特殊的要求，不太会限制返回类型：</p>\n<pre class=\"code-rows\"><code>@GetMapping(path = \"/\", produces = MediaType.APPLICATION_JSON_VALUE)\npublic Optional&lt;MenuItem&gt; getById(@PathVariable Long id) {}</code></pre>\n<p>在 Postman 中，我们可以像图 9-8 那样来指定 <code>Accept</code> 头，Postman 会自动生成一些头，且不允许修改，所以我们把自动生成的 <code>Accept</code> 去掉，手动添加一个值为 <code>application/xml</code> 的 <code>Accept</code> 头。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00777.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-8　在 Postman 中指定请求的 <code>Accept</code> 头</strong></p>\n<p>上述请求返回的就是一段 XML，大概会是下面这样的：</p>\n<pre class=\"code-rows\"><code>&lt;List&gt;\n    &lt;item&gt;\n        &lt;id&gt;1&lt;/id&gt;\n        &lt;name&gt;Java咖啡&lt;/name&gt;\n        &lt;size&gt;MEDIUM&lt;/size&gt;\n        &lt;price&gt;\n            &lt;amount&gt;12.00&lt;/amount&gt;\n            &lt;currency&gt;CNY&lt;/currency&gt;\n        &lt;/price&gt;\n        &lt;createTime&gt;2020-11-30T12:08:08.545+00:00&lt;/createTime&gt;\n        &lt;updateTime&gt;2020-11-30T12:08:08.545+00:00&lt;/updateTime&gt;\n    &lt;/item&gt;\n    &lt;!-- 省略其他部分 --&gt;\n&lt;/List&gt;</code></pre>\n<p>如果明确希望返回 JSON 格式，可以将 <code>Accept</code> 头设置为 <code>application/json</code>。在没有设置，或者将 <code>Accept</code> 设置为 <code>*/*</code> 时，则会根据可产生的应答类型，选择第一顺位的那个来做输出。</p>\n<p>通过 Accept 头来做选择有时不太方便，Spring Boot 还为我们提供了另外的途径，在 <code>application.properties</code> 里进行如下配置，可以根据 <code>URL</code> 后的 <code>format</code> 参数（这个参数默认的名字是 <code>format</code>）来设置需要的格式，例如：<code>http://localhost:8080/menu?format=xml</code>。</p>\n<pre class=\"code-rows\"><code>spring.mvc.contentnegotiation.favor-parameter=true\nspring.mvc.contentnegotiation.parameter-name=format</code></pre>\n<p>也可以换种方式，像下面这样配置，直接在 URL 里添加文件的后缀，上面的请求 URL 就变成了 <code>http://localhost:8080/menu.xml</code>。不过现在 Spring Boot 中这两个参数已经被打上了 <code>@Deprecated</code> 注解，不再推荐使用了：</p>\n<pre class=\"code-rows\"><code>spring.mvc.contentnegotiation.favor-path-extension=true\nspring.mvc.pathmatch.use-registered-suffix-pattern=true</code></pre>\n<p>Spring Boot 默认的推荐顺序是优先使用 <code>Accept</code> 头，通过配置可以开启 <code>format</code> 参数的支持，不建议使用后缀名的方式。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Thymeleaf</strong></p>\n<p>JSON 与 XML 可能更多地还是通过 <code>HttpMessageConverter</code> 来做输出，基于模板的呈现就必须使用视图相关的技术了。说到模板引擎，早期 Apache Velocity 非常流行，但后来因为一直缺少维护，就逐步淡出了人们的视野，Spring MVC 中也将它直接排除掉了。此外，以前比较流行的模板引擎还有 FreeMarker。与前两位相比，Thymeleaf 算是一个后起之秀，它应该算是面向 HTML 的模板，最大的好处是可以在不用服务端的情况下，直接通过浏览器预览到模板的呈现效果，更重要的是目前它还非常活跃，持续有人在对这个项目进行维护。</p>\n<p>Spring Boot 的项目中，只需在 pom.xml 中引入 Thymeleaf 依赖，相关配置都可以交由相关的 <code>ThymeleafAutoConfiguration</code> 自动配置类来完成，例如配置 <code>SpringResourceTemplateResolver</code>、<code>SpringTemplateEngine</code> 和 <code>ThymeleafViewResolver</code> 等一系列的 Bean。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>所需要的模板文件默认放在 src/main/resources/templates 目录里，这个位置可以通过配置文件中的配置进行调整，表 9-13 就罗列了 Spring Boot 中关于 Thymeleaf 的一些常用配置。</p>\n<p><strong>表 9-13　Spring Boot 关于 Thymeleaf 的一些常用配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>spring.thymeleaf.enabled</code></td><td><code>true</code></td><td>是否开启 Thymeleaf 支持</td></tr><tr><td><code>spring.thymeleaf.encoding</code></td><td><code>UTF-8</code></td><td>模板的编码格式</td></tr><tr><td><code>spring.thymeleaf.prefix</code></td><td><code>classpath:/templates/</code></td><td>拼接视图模板路径时的前缀，模板文件位置就是通过它来设置的</td></tr><tr><td><code>spring.thymeleaf.suffix</code></td><td><code>.html</code></td><td>拼接视图模板路径时的后缀</td></tr><tr><td><code>spring.thymeleaf.mode</code></td><td><code>HTML</code></td><td>模板所应用的模式，有 6 种模式，具体见 Thymeleaf 的 <code>TemplateMode</code> 枚举类</td></tr><tr><td><code>spring.thymeleaf.cache</code></td><td><code>true</code></td><td>是否开启模板文件缓存，在开发时可以设置为 <code>false</code>，方便修改后立即生效</td></tr><tr><td><code>spring.thymeleaf.check-template</code></td><td><code>true</code></td><td>在呈现视图前检查模板文件是否存在</td></tr><tr><td><code>spring.thymeleaf.check-template-location</code></td><td><code>true</code></td><td>检查模板文件路径是否存在</td></tr><tr><td><code>spring.thymeleaf.servlet.content-type</code></td><td><code>text/html</code></td><td>HTTP 应答时使用的 <code>Content-Type</code></td></tr></table>\n\n<p>目前 Spring Boot 一共支持四种模板引擎，分别是 FreeMaker、Groovy、Mustache 和 Thyemleaf，它们的使用方式大同小异。下面，让我们通过一个例子来详细了解下如何在项目中使用 Thyemleaf 编写 Web 页面。</p>\n<blockquote>\n<p><strong>需求描述</strong>　奶茶店差不多可以正式对外营业了，但光有菜单可不够，顾客看了菜单总得要能点单吧？这就需要有个可以操作的界面，让服务员能做些手动下单的操作。为了满足这个需求，我们可以设计一个下单页面，让服务员可以在页面中勾选顾客订单中包含的饮品，同时在页面还可以展示所有的订单。此外，当订单填写有问题时，还要能提示具体的错误。</p>\n</blockquote>\n<p>在开始编写相关的控制器前，先做些基本的准备工作，与菜单类似，我们需要准备一个订单的 <code>Service</code> 类，提供查询所有订单还有创建订单的方法，具体如代码示例 9-16 所示。</p>\n<blockquote>\n<p><strong>代码示例 9-16</strong>　提供订单相关服务的 <code>OrderService</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Transactional\npublic class OrderService {\n    @Autowired\n    private OrderRepository orderRepository;\n\n    public List&lt;Order&gt; getAllOrders() {\n        return orderRepository.findAll();\n    }\n    // 传入订单内容对应的MenuItem，以及整单折扣\n    public Order createOrder(List&lt;MenuItem&gt; itemList, int discount) {\n        Money total = itemList.stream().map(i -&gt; i.getPrice()).collect(Collectors.collectingAndThen\n                (Collectors.toList(),l -&gt; Money.total(l)));\n        Money pay = total.multipliedBy(discount / 100d, RoundingMode.HALF_DOWN);\n\n        Amount amount = Amount.builder().discount(discount).totalAmount(total).payAmount(pay).build();\n        Order order = Order.builder().amount(amount).status(OrderStatus.ORDERED).items(itemList).build();\n        return orderRepository.save(order);\n    }\n}</code></pre>\n<p>具体的订单控制器如代码示例 9-17 所示，处理器映射到 <code>/order</code>，主要由以下几个部分组成：</p>\n<ul>\n<li>整个控制器的方法在处理时公用的 <code>@ModelAttribute</code>，用来存放菜单内容；</li>\n<li>处理 <code>/order</code> 的 <code>GET</code> 请求的方法，返回 <code>ModelAndView</code>，指定使用 <code>order</code> 视图，还向 Model 中设置了两个属性，第一个不指定名字，会用非全限定性类名，首字母小写；</li>\n<li>处理 <code>/order</code> 的 <code>POST</code> 请求的方法，收到的表单绑定后还会进行校验，根据表单里的 ID 获取 <code>MenuItem</code> 再去调用创建订单的方法，这个方法直接返回视图名称，所需的 Model 内容由方法参数里的 <code>modelMap</code> 来传递。</li>\n</ul>\n<blockquote>\n<p><strong>代码示例 9-17</strong>　订单处理器 <code>OrderController</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Controller\n@RequestMapping(\"/order\")\n@Slf4j\npublic class OrderController {\n    @Autowired\n    private OrderService orderService;\n    @Autowired\n    private MenuService menuService;\n\n    @ModelAttribute(\"items\")\n    public List&lt;MenuItem&gt; items() {\n        return menuService.getAllMenu();\n    }\n\n    @GetMapping\n    public ModelAndView orderPage() {\n        return new ModelAndView(\"order\").addObject(new NewOrderForm())\n            .addObject(\"orders\", orderService.getAllOrders());\n    }\n\n    @PostMapping\n    public String createNewOrder(@Valid NewOrderForm form, BindingResult result,ModelMap modelMap) {\n        if (result.hasErrors()) {\n            modelMap.addAttribute(\"orders\", orderService.getAllOrders());\n            return \"order\";\n        }\n        List&lt;MenuItem&gt; itemList = form.getItemIdList().stream().map(i -&gt; NumberUtils.toLong(i))\n            .collect(Collectors.collectingAndThen(Collectors.toList(),list -&gt; menuService.getByIdList(list)));\n        Order order = orderService.createOrder(itemList, form.getDiscount());\n        log.info(\"创建新订单，Order={}\", order);\n        modelMap.addAttribute(\"orders\", orderService.getAllOrders());\n        return \"order\";\n    }\n}</code></pre>\n<p>表单对应的 <code>NewOrderForm</code> 如代码示例 9-18 所示，上面做了些基本的校验，折扣只能在 50 到 100 的范围内。</p>\n<blockquote>\n<p><strong>代码示例 9-18</strong>　新订单表单对应的 <code>NewOrderForm</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Getter\n@Setter\npublic class NewOrderForm {\n    @NotEmpty\n    private List&lt;String&gt; itemIdList;\n    @Min(50)\n    @Max(100)\n    private int discount;\n}</code></pre>\n<p><code>order</code> 视图对应了 src/main/resources/templates/order.html 文件。Thymeleaf 的好处之一就是可以直接在浏览器里看到模板文件处理后的效果，它只是在 HTML 中增加了一些 <code>th</code> 标签。例如，我们的表单会绑定上 <code>newOrderForm</code> 对象；<code>th:if</code> 可以做些判断，在某些属性有问题时显示对应的内容；<code>th:each</code> 能够处理循环，如代码示例 9-19 所示。关于 Thymeleaf 的具体语法，我们就不在这里展开了，大家可以查询官方文档了解更多细节。</p>\n<blockquote>\n<p><strong>代码示例 9-19</strong>　订单页面使用的 order.html</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh_CN\" xmlns:th=\"http://www.thymeleaf.org\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;title&gt;二进制奶茶&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;二进制奶茶&lt;/h1&gt;\n        &lt;h2&gt;下单&lt;/h2&gt;\n        &lt;div&gt;\n            &lt;form action=\"#\" th:action=\"@{/order}\" th:object=\"$\" method=\"post\"&gt;\n                &lt;p&gt;\n                    &lt;label&gt;折扣&lt;/label&gt;\n                    &lt;input type=\"number\" th:field=\"*\" th:value=\"*\" /&gt;\n                &lt;/p&gt;\n                &lt;p&gt;\n                    &lt;p th:if=\"${#fields.hasErrors('discount')}\" th:errors=\"*\"\n                        style=\"color:red\"&gt;折扣错误&lt;/p&gt;\n                    &lt;label&gt;饮料&lt;/label&gt;\n                    &lt;ul&gt;\n                        &lt;li th:each=\"item : $\"&gt;\n                            &lt;input type=\"checkbox\" th:field=\"*\" th:value=\"$\" /&gt;\n                            &lt;label th:text=\"$\"&gt;Java咖啡&lt;/label&gt;\n                            &lt;label th:text=\"$\"&gt;MEDIUM&lt;/label&gt;\n                            &lt;label th:text=\"$\"&gt;CNY 12.00&lt;/label&gt;\n                        &lt;/li&gt;\n                    &lt;/ul&gt;\n                &lt;/p&gt;\n                &lt;p th:if=\"${#fields.hasErrors('itemIdList')}\" th:errors=\"*\"\n                    style=\"color:red\"&gt;点单错误&lt;/p&gt;\n                &lt;p&gt;\n                    &lt;input type=\"submit\" value=\"提交\"/&gt;\n                &lt;/p&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n        &lt;h2&gt;订单&lt;/h2&gt;\n        &lt;div&gt;\n            &lt;table border=\"1px\"&gt;\n                &lt;thead&gt;\n                    &lt;tr&gt;\n                        &lt;th&gt;订单编号&lt;/th&gt;\n                        &lt;th&gt;总价&lt;/th&gt;\n                        &lt;th&gt;实付&lt;/th&gt;\n                        &lt;th&gt;状态&lt;/th&gt;\n                        &lt;th&gt;内容&lt;/th&gt;\n                    &lt;/tr&gt;\n                &lt;/thead&gt;\n                &lt;tbody&gt;\n                    &lt;tr th:each=\"order : $\"&gt;\n                        &lt;td th:text=\"$\"&gt;1&lt;/td&gt;\n                        &lt;td th:text=\"$\"&gt;CNY 12.0&lt;/td&gt;\n                        &lt;td th:text=\"$\"&gt;CNY 12.0&lt;/td&gt;\n                        &lt;td th:text=\"$\"&gt;ORDERED&lt;/td&gt;\n                        &lt;td&gt;\n                            &lt;div th:each=\"item : $\"&gt;\n                                &lt;label th:text=\"$\"&gt;Java咖啡&lt;/label&gt;-&lt;label th:text=\n                                    \"$\"&gt;MEDIUM&lt;/label&gt;&lt;br/&gt;\n                            &lt;/div&gt;\n                        &lt;/td&gt;\n                    &lt;/tr&gt;\n                &lt;/tbody&gt;\n            &lt;/table&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>将程序运行起来后，我们访问 http://localhost:8080/order 就能看到订单页面了。如果提交了一个错误的订单，你能看到如图 9-9 所示的结果。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00778.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-9　提交错误订单后的效果</strong></p>\n</li>\n</ol>\n<h3 id=\"nav_point_143\">9.3.3　静态资源与缓存</h3>\n<p>现在基本上中大型系统都采用了前后端分离的开发模式，前后端通过接口进行交互，前端所有的资源都会放在静态资源服务器上，而且用户对静态资源的访问都会先经过 CDN。但对一些小系统，可能还是会将静态资源放在 Servlet 容器里，性能虽然不好，但勉强够用就行。Spring MVC 不仅能够处理动态请求，也为静态资源提供了一定的支持。这一节我们就来简单了解一下 Spring MVC 的静态资源与缓存支持。</p>\n<ol>\n<li><p><strong>静态资源</strong></p>\n<p>在 Spring Boot 中，可以通过配置来调整静态资源的设置，相关的属性在 <code>ResourceProperties</code> 类中，例如表 9-14 中列举的这些。</p>\n<p><strong>表 9-14　部分静态资源相关配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置</th><th>默认值</th><th>说明</th></tr><tr><td><code>spring.mvc.static-path-pattern</code></td><td><code>/**</code></td><td>静态资源映射的路径</td></tr><tr><td><code>spring.web.resources.static-locations</code></td><td><code>[classpath:/META-INF/resources/, classpath:/resources/, classpath:/static/, classpath:/public/]</code></td><td>静态资源的存放位置</td></tr><tr><td><code>spring.web.resources.cache.period</code></td><td></td><td>静态资源的缓存时间，不指定单位的话，默认以秒为单位</td></tr></table>\n\n<p>也就是说，我们可以把项目中的静态资源都放到 CLASSPATH 的 /META-INF/resources/、/resources/、/static/ 和/public/ 这四个位置中，也就是 src/main/resources 里的四个目录，Spring Boot 已经做好了配置。</p>\n<p>如果没有在 Spring Boot 中，或者我们希望自己配置静态资源，那也可以使用 Spring MVC 原生的配置方式，例如，想把静态资源都映射到 /static/ 下，XML 的配置是这样的：</p>\n<pre class=\"code-rows\"><code>&lt;mvc:resources mapping=\"/static/**\"\n    location=\"/static, classpath:/static/\"\n    cache-period=\"600\" /&gt;</code></pre>\n<p>对应的 Java 配置，需要在 <code>WebMvcConfigurer</code> 的实现类里覆盖 <code>addResourceHandlers()</code> 方法，就像下面这样：</p>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry)    {\n        registry.addResourceHandler(\"/static/**\")\n                 .addResourceLocations(\"/static\", \"classpath:/static/\")\n                 .setCachePeriod(600);\n    }\n}</code></pre>\n<p>而在 Spring Boot 中，只需在配置文件里添加如下几行，相比之下是不是简单多了：</p>\n<pre class=\"code-rows\"><code>spring.mvc.static-path-pattern=/static/**\nspring.web.resources.static-locations=/static,classpath:/static/\nspring.web.resources.cache.period=600</code></pre>\n<p>除了 JavaScript 和 CSS 这类静态资源，一些静态的页面，尤其是错误页面，也可以放在静态资源目录里，在下面添加一个 error 子目录，文件名为具体的 HTTP 响应码，例如，404.html 或者 5xx.html。代码示例 9-20 展示的就是一个最简单的 404 错误页的 HTML 代码。当我们用浏览器访问二进制奶茶店在线网站上一个不存在的页面时，就会显示这个页面。</p>\n<blockquote>\n<p><strong>代码示例 9-20</strong>　src/main/resources/static/error/404.html</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;二进制奶茶&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;啊呀，没找到页面啊&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>此外，如果有欢迎页，也就是浏览器地址栏里未添加路径直接访问系统域名时会自动跳转的页面，可以将其放在静态资源目录里，用 index.html 作为文件名，Spring Boot 会优先找它，如果没有找到，再用 <code>index</code> 作为视图名进行查找。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>缓存</strong></p>\n<p>对于静态资源，为了提升性能，通常浏览器或者一些代理服务器会对其进行缓存处理，如果命中缓存，服务器会直接返回不带正文的 <code>304 Not Modified</code> 应答。如果使用静态资源服务器，那这个缓存的设置由静态资源服务器来完成。如果通过 Spring MVC 的应用程序来提供静态资源，那有两种选择，一是由程序来处理缓存，另一个是交由前端的负载均衡（例如 Nginx）来处理。这里我们就来看看 Spring MVC 的程序是如何处理缓存的。</p>\n<p>在 HTTP 中，使用 <code>Cache-Control</code> 这个响应头来标识相关的缓存配置，RFC 7234 对这个响应头做了详细的规定。在上一部分里，我们已经看到了如何为静态资源设置一个 600 秒的缓存了。其实，除了 <code>spring.web.resources.cache.period</code>，Spring Boot 可以对静态资源缓存做更精细的控制，相关的配置就在 <code>WebProperties.Resources.Cache.Cachecontrol</code> 这个内部类里，对应的就是 <code>spring.web.resources.cache.cachecontrol.*</code> 的配置项，用来直接控制 <code>Cache-Control</code>，表 9-15 罗列了其中的一些配置项。</p>\n<p><strong>表 9-15　<code>Cachecontrol</code> 的部分配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>说明</th></tr><tr><td><code>spring.web.resources.cache.cachecontrol.max-age</code></td><td>最大的可缓存时间，例如 <code>3600s</code>，如果没有指定时间单位，默认为秒</td></tr><tr><td><code>spring.web.resources.cache.cachecontrol.no-store</code></td><td>是否可缓存，取值为 <code>true</code> 和 <code>false</code></td></tr><tr><td><code>spring.web.resources.cache.cachecontrol.cache-public</code></td><td>是否是公开缓存，所有地方都可进行缓存，取值为 <code>true</code> 和 <code>false</code></td></tr><tr><td><code>spring.web.resources.cache.cachecontrol.cache-private</code></td><td>是否是针对单个用户的私有缓存，共享缓存不可对其进行缓存，取值为 <code>true</code> 和 <code>false</code></td></tr><tr><td><code>spring.web.resources.cache.cachecontrol.no-transform</code></td><td>缓存或其他中介不能对响应内容进行转换处理，取值为 <code>true</code> 和 <code>false</code></td></tr></table>\n\n<p>在 <code>application.properties</code> 中，可以像下面这样设置静态资源缓存：</p>\n<pre class=\"code-rows\"><code>spring.web.resources.cache.cachecontrol.max-age=7200\nspring.web.resources.cache.cachecontrol.cache-public=true</code></pre>\n<p>除了静态资源，Spring MVC 控制器的返回对象也能做缓存，Spring Framework 提供了一个 <code>CacheControl</code> 类，帮助我们方便地构建 <code>Cache-Control</code> 响应头，例如，与上面的配置相对应的代码可以是下面这样的：</p>\n<pre class=\"code-rows\"><code>// \"Cache-Control: max-age=7200, public\"\nCacheControl cc = CacheControl.maxAge(2, TimeUnit.HOURS).cachePublic();</code></pre>\n<p>如果不希望客户端缓存响应，可以像下面这样：</p>\n<pre class=\"code-rows\"><code>// \"Cache-Control: no-store\"\nCacheControl cc = CacheControl.noStore();</code></pre>\n<p>有了 <code>CacheControl</code> 对象后，将其设置到要返回的 <code>ResponseEntity</code> 里去，像下面这样：</p>\n<pre class=\"code-rows\"><code>ResponseEntity.ok().cacheControl(cc).body(menu);</code></pre>\n<p>在 <code>Cache-Control</code> 响应头之外，HTTP 还有 <code>Last-Modified</code> 和 <code>ETag</code> 头。<code>Last-Modified</code> 的内容是服务器资源的最后修改时间，后续发起请求时用 <code>If-Modify-Since</code> 头将之前保存的最后修改时间再发给服务器，如果资源没有再修改过，则直接返回 <code>304 Not Modified</code>。在代码中，可以通过 <code>WebRequest.checkNotModified()</code> 方法来判断是否有更新。</p>\n<p><code>ETag</code> 是在 <code>Last-Modified</code> 之后再出现的头，前者更强调资源版本的变更，而后者则关注修改的时间，文件可能定时刷新，但刷新的内容是一样的。请求时带上 <code>If-Match</code> 或者 <code>If-None-Match</code> 头，内容就是之前返回的 <code>ETag</code> 值，服务器会在判断后决定是否返回 <code>304 Not Modified</code>。Spring MVC 提供了一个 <code>ShallowEtagHeaderFilter</code> 过滤器，可以方便地基于返回的内容来生成 <code>ETag</code>。</p>\n<blockquote>\n<p><strong>茶歇时间：时间 vs. 空间</strong></p>\n<p>在一个系统中，总会有很多非功能性指标，例如，耗时、CPU 使用率、吞吐量、内存占用量、磁盘使用量、带宽、IOPS（Input/Output Operations Per Second，每秒读写次数）……在一定的条件下，鱼和熊掌不可兼得，为了满足某些要求，我们需要放弃另外一些。最常见的就是大家熟悉的“用空间换时间”，以及“用时间换空间”。</p>\n<p>缓存是典型的“用空间换时间”。以前流行的 Memcached 就是用大量内存来存储计算后的数据，节省了反复计算的时间和 CPU 开销，我们在之前介绍过的 JVM 内部缓存、Redis 也基本是这个思路。</p>\n<p>而大家日常用的文件压缩就是“用时间换空间”。通过压缩算法的计算将大文件压缩成小文件，随后存储在磁盘中或者在网络中进行传输。传输的内容越少，传输的速度就越快，从而节省了传输时间。</p>\n<p>本节中谈到的 <code>ShallowEtagHeaderFilter</code> 本质上并不会减少服务器端的计算工作量，所有的操作都会发生，它对发送给客户端的数据进行了额外的计算，产生一个 <code>ETag</code>，如果这个值与客户端传过来的值一样，就不再传输内容，直接告诉客户端没有变化，用以前的就行。因此，它是用额外的服务端 CPU 时间优化了网络传输和客户端感受到的耗时。</p>\n</blockquote>\n<p>在 Spring Boot 项目中，要注册 <code>Servlet</code>、<code>Filter</code> 或者 <code>Listener</code>，最简单的办法就是把它们配置为 Bean。如果需要做更多定制，就注册对应的 <code>ServletRegistrationBean</code>、<code>FilterRegistrationBean</code> 和 <code>ServletListenerRegistrationBean</code>。以 <code>ShallowEtagHeaderFilter</code> 为例，可以在 <code>BinaryTeaApplication</code> 中添加一个 Bean 定义，如代码示例 9-21 所示。</p>\n<blockquote>\n<p><strong>代码示例 9-21</strong>　添加了 <code>ShallowEtagHeaderFilter</code> 的配置类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableCaching\npublic class BinaryTeaApplication {\n    // 省略其他内容\n\n    @Bean\n    public ShallowEtagHeaderFilter shallowEtagHeaderFilter() {\n        return new ShallowEtagHeaderFilter();\n    }\n}</code></pre>\n</li>\n</ol>\n","comments":[]}