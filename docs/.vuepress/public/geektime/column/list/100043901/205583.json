{"id":205583,"title":"18 | 重新认识数据结构（上）：初识链表结构","content":"<p>你好，我是胡光，欢迎来到“算法数据结构篇”的第一课。</p><p>在之前的学习中，我们对数据结构的认识，主要集中在它是用来做数据的表示，更具体地讲，就是数据结构所讨论的问题，是将现实中的数据如何合理地表示在程序中，以使程序完成既定的目标任务。</p><p>不知道你还记不记得，在上节课 Shift-And 算法的学习中，我们发现不同的数据，或者说信息表示方式，会给解决问题的效率带来很大的影响。因此，基本确定了数据的表示，在程序设计过程中发挥着非常重要的作用，也就意味着我们必须对数据结构的学习重视起来。</p><p>之前我们所讨论的数据结构呢，其实都只是停留在程序内部的数据结构，这是一种具体的，可见的数据结构，并对我们设计的程序产生重要影响。我们也认识到，这种具体的数据结构的重要作用，会对我们设计的程序产生重要的影响。今天呢，我将带你重新认识数据结构，发现它的另一面，那就是数据结构对我们思维方式的影响，这种影响更抽象，也更重要。</p><p>接下来的两次课程内容呢，我将通过链表结构的讲解，让你认识这种思维层面的数据结构。</p><h2>必知必会，查缺补漏</h2><p>今天我们将要学习的链表，是一种常见的基础数据结构，属于数据结构中线性结构的一种。在讲如何学习链表之前，我们先来看一看通常情况下，如何学习数据结构的相关的知识。</p><!-- [[[read_end]]] --><h4>1.数据结构：结构定义+结构操作</h4><p>你应该玩过拼装式的玩具吧，类似于高达机器人之类的。面对这样的玩具，我一般在拼装之前看看说明书，知道这个玩具包含哪几部分，然后对这些部分进行拼装，等把各部分拼好了后，再把它们组合起来，最终的成品就完成了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/59/32/590065eaa40bacd12f44af281b272f32.jpg?wh=3697*3864\" alt=\"\" title=\"图1：高达机器人\"></p><p>其实学习某样知识也是一样的，要先搞清楚这门知识的组成部分，从组成部分开始入手学习，最后把所有的知识碎片整合到一起，就是知识的全貌了。</p><p>回到如何理解数据结构这个问题，我先给你列出重要的两句话：</p><ol>\n<li><strong>数据结构 = 结构定义 + 结构操作</strong></li>\n<li><strong>数据结构，就是定义一种性质，并且维护这种性质</strong></li>\n</ol><p>其实这两句话，说的是一回事儿。结构定义，指的是就是说明这种数据结构长成什么样子，具备什么性质。结构操作，就是确定这种数据结构都支持哪些操作，同时结构操作的结果，不能破坏这类结构原本的性质。这也就到了第二句话中说的内容，维护这种性质。</p><p>这就好像刚才我说到的高达机器人，结构定义类比高达机器人的样子，结构操作就是这个机器人都支持什么功能，比如抬手、伸腿之类的。但是无论是哪种结构操作，你都不能把机器人玩坏掉（也就是不能破坏结构定义），这就是我们所说的：操作归操作，但是你要维护这种性质。</p><p>接下来呢，我将会通过这两句话，带你学习<strong>链表</strong>这种数据结构。</p><h4>2.链表的结构定义</h4><p><strong>链表的结构定义中，包含了两个信息，一个是数据信息，用来存储数据的，也叫做数据域；另外一个是地址信息，用来存储下一个节点地址的，也叫做指针域。</strong><br>\n<img src=\"https://static001.geekbang.org/resource/image/18/5f/1848443e25f6494b85b9064fc1b3d85f.jpg?wh=1966*1276\" alt=\"\" title=\"图2：链表结构定义\"></p><p>记住，链表结构是由一个一个链表节点组成的，在应用这种结构的时候，你无需对这种结构本身做改变，你只需要按照自己的需求，把自己想要的数据，放在链表结构定义的数据域中即可。比如说，整型是你想存储在链表中的数据，那么数据域的类型就是整型，如果字符串类型是你想存储的数据，那么数据域的类型就是字符串类型。</p><p>在示意图中可以看到，链表节点以整型作为数据域的类型，其中第一个链表节点，存储了 763 这个数据，指针域中呢，存储了一个 0x56432地址，这个地址而 0x56432正是第二个链表节点的地址。我们可以说，第一个节点指向第二个节点，因此这两个节点之间，在逻辑上构成了一个指向关系。</p><p>在第二个节点的指针域中呢，存储了一个地址，是0x0，这个地址值所对应的整型值就是 0。这是一个特殊的地址，我们称它为空地址，在 C 语言中用 NULL 宏表示这个空地址，读作nào。我们让第二个链表节点指向空地址，就意味着它就是这个链表结构的最后一个节点。</p><p>看完了链表的结构示意图以后，就来让我们看一下在代码中，如何定义链表节点结构吧：</p><pre><code>struct Node {\n    int data;\n    struct Node *next;\n};\n</code></pre><p>正如这段代码所示，我们使用结构体，定义一种新的类型，叫做 struct Node 类型，来表示链表的节点结构。链表的每个节点内部，有一个数据域，一个指针域，对应到代码中，就是一个整型的 data 字段，和一个指向 struct Node 类型本身的指针字段 next。</p><p>值得注意的是，链表结构的指针域只有一个 next 变量，这就说明每一个链表节点，只能唯一地指向后续的一个节点，这是链表结构非常重要的一个性质，后续我们也会用到这个性质。</p><p>总地来说，链表结构中，数据域是留出来让我们实现自我需求的，就是想存整型，就改成整型，想存浮点型，就改成浮点型。而 next 指针域，是用来维护链表这个结构的，这里一般不需要你自由发挥，记住怎么回事儿，直接用就行了。<strong>记住，要想修改内存中的链表结构，就一定要修改节点内部 next 指针域中存储的地址值。</strong></p><h4>3.链表的结构操作</h4><p>接下来呢，我会给你介绍一种链表的基础操作，就是向链表中插入节点的操作。</p><p>在讲解链表的插入和删除方法之前呢，我们先来对齐一个概念，就是<strong>链表节点的位置</strong>。当你把链表结构画出来以后，你会发现链表结构和数组结构很类似，只不过数组结构在内存中存储是连续的，链表结构由于有指针域的存在，它的每一个节点在内存中存储的位置未必连续。</p><p>我们也可以参考数组下标的编号规则，给每个链表节点编一个号，从第一个开始依次是0、1、2，具体如下图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/8c/dd/8c7c7e5628911d108ea871360657b7dd.jpg?wh=2694*998\" alt=\"\" title=\"图3：链表节点位置定义\"></p><p>明白了什么是链表的节点位置以后呢，我们定义一个向链表中插入节点的函数方法：</p><pre><code>struct Node *insert(struct Node *head, int ind, struct Node *a);\n</code></pre><p>这个插入方法呢，传入三个参数，第一个是待操作的链表的头结点地址，也就是链表中第一个节点的地址；第二个参数代表插入位置；第三个参数是一个指针变量，指向要插入的新节点。</p><p>简单来说，就是向 head 所指向的链表的 ind 位置插入一个由 a 所指向的节点，返回值代表插入新节点以后的链表头结点地址。为什么要返回插入以后的链表头结点地址呢？因为新节点有可能插入到链表的第 0 位，插入以后，链表的头结点地址就发生了改变，我们必须把这个信息返回。</p><p>由于插入操作，会改变链表结构，刚刚我们说了，只有修改链表节点中的 next 指针域的值，才算是修改了链表的结构。为了完成插入操作，我们都需要修改哪些节点的 next 指针域的值呢？</p><p>首先是让 ind - 1 位置的节点指向 a 节点，然后是 a 节点指向原 ind 位置的节点，也就是说，涉及到两个节点的 next 指针域的值的修改，一个是 ind - 1 位置的节点，一个是 a 节点自身。我们就可以先找到 ind - 1位置的节点，然后再进行相关操作即可。写成代码，如下所示：</p><pre><code>struct Node *insert(struct Node *head, int ind, struct Node *a) {\n    struct Node ret, *p = &amp;ret;\n    ret.next = head;\n    // 从【虚拟头节点】开始向后走 ind 步\n    while (ind--) p = p-&gt;next;\n    // 完成节点的插入操作\n    a-&gt;next = p-&gt;next;\n    p-&gt;next = a;\n    // 返回真正的链表头节点地址  \n    return ret.next;\n}\n</code></pre><p>代码中，涉及到一个很重要的技巧，就是  “虚拟头结点” 这个链表操作技巧。所谓虚拟头结点，就是在原有的链表头结点前面，加上另外一个节点，这个额外增加的头结点，就是虚拟头结点。增加虚拟头结点的目的，是为了让我们操作链表更方便，实际上，如果在某个操作中，头结点地址有可能发生改变，我们也可以使用虚拟头结点这个技巧。</p><p>我们来分析一下，对于插入操作，虚拟头结点有什么重要的作用。首先如果我们要在第 5 个位置插入新节点，那我们就要找到 4 号位的节点，也就是从头结点开始，向后走 4 步，确定了 4 号节点以后，再修改相关节点的 next 指针域即可。</p><p>也就是说，如果我们想插入到 ind 位，就需要从头结点向后走 ind - 1 步，定位到 ind - 1 号节点。如果插入的位置为 0 呢？我们总不能走 -1 步吧？这个时候，在程序中我们就只能对 ind 等于 0 的情况进行特殊判断了。这确实是一种可行的实现方法，可不够优美，因为这种做法没有统一 ind 在等于 0 和 不等于 0 时候的处理情况。</p><p>可是当我们在原链表前面，加入了一个虚拟头结点以后，这一切的操作就变得自然了许多！一开始 p 指向虚拟头结点，由于链表头部增加了一个节点，原先我们要定位链表 ind - 1 位置，要走 ind - 1步，现在就是走 ind 步。</p><p>也就是说，在有虚拟头结点的情况下，如果我们插入到 5 号位，就从虚拟头结点向后走 5 步就行，同样的，想要插入到 0 号位呢，就向后走 0 步即可，即 p 指针指向虚拟头结点不动，直接将新的节点，插入到虚拟头结点后面即可。<br>\n<img src=\"https://static001.geekbang.org/resource/image/f3/77/f3c19fb1a46d0917509bdac33e0a4577.jpg?wh=2637*1370\" alt=\"\" title=\"图4：虚拟节点示意图\"></p><p>其实，对于链表的相关操作，无论是插入还是删除，只要是有可能改变原有链表头结点的操作，增加虚拟头结点都是一个很实用的处理技巧。</p><h2>一起动手，搞事情</h2><p>今天给你留的作业呢，与链表的操作有关系，请看如下函数接口定义：</p><pre><code>struct Node *erase(struct Node *head, int ind);\n</code></pre><p>请你参照文中的链表插入操作，实现一个链表节点删除的操作，删除函数传入两个参数，分别代表指向链表头结点的指针变量 head，以及要删除的节点位置 ind，返回值代表删除节点以后的链表头结点地址。</p><p>由于删除操作，有可能改变链表的头结点，所以你可以尝试使用前面我们讲到的虚拟头结点的编码技巧。仔细分析，你可以的！</p><h2>课程小结</h2><p>我们今天介绍的链表呢，其实真实姓名叫做“单向链表”，这是一种很有代表性的链表结构。实际上，你学会了单向链表，也就很容易掌握其他形式的链表了。比如说：单向循环链表、双向链表、双向循环链表、块状链表、跳跃表。</p><p>尤其是块状链表和跳跃表， 在工程中应用最广泛，C++ STL 中的 vector 底层用的就是块状链表。关于这些概念，如果你感兴趣，可以自行上网搜索相关资料。篇幅有限，我们就不一个个展开介绍了。</p><p>最后，我们来做一下今天课程的总结，今天我希望你记住如下几点：</p><ol>\n<li>数据结构 = 结构定义 + 结构操作，这个等式说明了我们学习数据结构的方法顺序。</li>\n<li>单向链表节点中，存在数据域和指针域，指针域控制了链表的结构，一般不会根据应用场景的变化而变化，而数据域是根据应用场景的需求而设计的。</li>\n</ol><p>下节课呢，我将给你讲几种更有意思的链表操作。好了，今天就到这里了，我是胡光，咱们下期见。</p>","comments":[{"had_liked":false,"id":183025,"user_name":"🤪HappyJoo","can_delete":false,"product_type":"c1","uid":1234591,"ip_address":"","ucode":"96E1858F06BABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","comment_is_top":false,"comment_ctime":1582933758,"is_pvip":false,"replies":[{"id":"70834","content":"d(^_^o)给个封号：最强助教！","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1582954143,"ip_address":"","comment_id":183025,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877901054","product_id":100043901,"comment_content":"不知道有没有用，“画”了一个图给对于插入不太懂的同学看看哈哈哈哈：<br><br>----p----p.next----|    ----&gt;   |----p     p.next----<br>                             |   ----&gt;    |       \\   &#47;<br>                             |   ----&gt;    |        \\ &#47;<br>-------a-----------|   ----&gt;     |         a","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485535,"discussion_content":"d(^_^o)给个封号：最强助教！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582954143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183024,"user_name":"🤪HappyJoo","can_delete":false,"product_type":"c1","uid":1234591,"ip_address":"","ucode":"96E1858F06BABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","comment_is_top":false,"comment_ctime":1582933646,"is_pvip":false,"replies":[{"id":"70835","content":"当然不是计算机自动创造的，而是我们通过代码逻辑加上去的。所谓虚拟，就是只有在操作过程中，存在的一个节点，这个节点完全是为了操作简便，额外加上去的，不是链表的实际节点。","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1582954444,"ip_address":"","comment_id":183024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877900942","product_id":100043901,"comment_content":"老师您好，请问一下，这个虚拟头结点是如何不影响链表的呢？我的理解是，每次执行插入函数（这个*insert是函数吧。C语言的函数就是方法？）时，都创造一个虚拟结点（计算机会自动创造吗？），让它指向链表的真正头结点，执行函数。函数执行结束后，将虚拟结点与真正头结点断开，这样子就可以做到“虚拟”了。请问老师我的理解有哪些不对的地方吗？谢谢老师~~~","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485534,"discussion_content":"当然不是计算机自动创造的，而是我们通过代码逻辑加上去的。所谓虚拟，就是只有在操作过程中，存在的一个节点，这个节点完全是为了操作简便，额外加上去的，不是链表的实际节点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582954444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182626,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1582817518,"is_pvip":true,"replies":[{"id":"70693","content":"完美！d(^_^o)","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1582865948,"ip_address":"","comment_id":182626,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877784814","product_id":100043901,"comment_content":"&#47;&#47; 删除指定索引位置的节点<br>struct Node *erase(struct Node *head, int ind) {<br>    struct Node preNode, *p = &amp;preNode;<br>    preNode.next = head;<br>        while (ind--) {<br>        p = p-&gt;next;<br>    }<br>    &#47;&#47; 指向删除节点的下一个位置<br>    p-&gt;next = p-&gt;next-&gt;next;<br>    return preNode.next;<br>}","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485390,"discussion_content":"完美！d(^_^o)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582865948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182461,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1582791530,"is_pvip":true,"replies":[{"id":"70691","content":"python中的list不是用链表实现的，那样的话，查找效率太差了，C中的话，可以用指针数组实现，指针类型是void *即可指向任意一种类型数据。","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1582865875,"ip_address":"","comment_id":182461,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877758826","product_id":100043901,"comment_content":"python里的list可以存放不同数据类型，也是用链表实现的嘛，C语言如何写出这种数据结构呢","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485346,"discussion_content":"python中的list不是用链表实现的，那样的话，查找效率太差了，C中的话，可以用指针数组实现，指针类型是void *即可指向任意一种类型数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582865875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349686,"user_name":"注意力$","can_delete":false,"product_type":"c1","uid":1142316,"ip_address":"","ucode":"7FB3399A1EAB72","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/2c/e2f3cfc0.jpg","comment_is_top":false,"comment_ctime":1656229170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656229170","product_id":100043901,"comment_content":"struct LinkNode * init_LinkList(){<br>\tstruct LinkNode * pHeader=malloc(sizeof(struct LinkNode));<br>\tif(pHeader == NULL){<br>\t\treturn NULL;<br>\t}<br>\t&#47;&#47;头结点不维护数据域<br>\tpHeader-&gt;num=-1;<br>\tpHeader-&gt;next=NULL;<br>\t<br>\t&#47;&#47; 创建尾结点指针 用户记录当前链表尾部节点位置，方便尾插<br>\tstruct LinkNode * pTail=pHeader;<br>\t<br>\tint val=-1;<br>\t<br>\twhile(1)<br>\t{<br>\t\tprintf(&quot;qingshuru\\n&quot;);<br>\t\tscanf(&quot;%d&quot;,&amp;val);<br>\t\tif(val ==-1){<br>\t\t\tbreak;<br>\t\t}<br>\t\t&#47;&#47;创建新节点<br>\t\tstruct LinkNode * newNode=malloc(sizeof(struct LinkNode));<br>\t\tnewNode-&gt;num=val;<br>\t\tnewNode-&gt;next=NULL;<br>\t\t<br>\t\t&#47;&#47;更新节点的指向<br>\t\tpTail-&gt;next=newNode;<br>\t\tpTail=newNode;<br>\t}<br>\t<br>\t<br>\t<br>\treturn pHeader;<br>}<br><br>void foreach_LinkList(struct LinkNode * pHeader){<br>\t<br>\tif(pHeader ==NULL){<br>\t\treturn;<br>\t}<br>\t&#47;&#47;当前节点 指向第一个有真实数据的节点<br>\tstruct LinkNode * pCurrent = pHeader-&gt;next;<br>\twhile(pCurrent !=NULL)<br>\t{<br>\t\tprintf(&quot;%d\\n&quot;,pCurrent-&gt;num);<br>\t\tpCurrent=pCurrent-&gt;next;<br>\t}<br>}<br><br><br>void insert_LinkList(struct LinkNode * pHeader,int oldVal,int newVal){<br>\t\tif(pHeader ==NULL){<br>\t\treturn;<br>\t}<br>\t<br>\t&#47;&#47; 创建2个临时指针实现节点插入<br>\t\tstruct LinkNode * pPrev=pHeader;<br>\t\tstruct LinkNode * pCurrent=pHeader-&gt;next;<br>\t\twhile(pCurrent != NULL)<br>\t{<br>\t\tif(pCurrent-&gt;num=oldVal)<br>\t\t{<br>\t\t\tbreak;<br>\t\t}<br>\t\t&#47;&#47;两个辅助指针往后移动<br>\t\tpPrev=pCurrent;<br>\t\tpCurrent=pCurrent-&gt;next;<br>\t}<br>\t\t&#47;&#47;创建新节点<br>\t\tstruct LinkNode * newNode=malloc(sizeof(struct LinkNode));<br>\t\tnewNode-&gt;num=newVal;<br>\t\tnewNode-&gt;next=NULL;<br>\t\t<br>\t\t&#47;&#47;更改指针的指向<br>\t\tnewNode-&gt;next=pCurrent;<br>\t\tpPrev-&gt;next=newNode;<br>\t}\t<br><br>老师上面是我实现链表的插入节点的方法，然后<br>\tinsert_LinkList(pHeader,20,100);<br>\tinsert_LinkList(pHeader,21,1000);<br>\t\tprintf(&quot;charuhou \\n&quot;);<br>\tforeach_LinkList(pHeader);<br>最后发现结果不对<br>qingshuru<br>10<br>qingshuru<br>20<br>qingshuru<br>30<br>qingshuru<br>-1<br>bianlijie<br>10<br>20<br>30<br>charuhou<br>1000<br>21<br>20<br>20<br>30<br><br>能看出来哪里错了吗\t","like_count":1},{"had_liked":false,"id":348137,"user_name":"阿牛","can_delete":false,"product_type":"c1","uid":2923242,"ip_address":"","ucode":"B833FDE24BBB46","user_header":"https://static001.geekbang.org/account/avatar/00/2c/9a/ea/cfb28cda.jpg","comment_is_top":false,"comment_ctime":1654767046,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1654767046","product_id":100043901,"comment_content":"看评论区有位伙伴的代码写的是<br>p-&gt;next = p-&gt;next-&gt;next<br><br>我写出来的是<br>p = p-&gt;next<br><br>其他部分相同，<br>想问下如果想删除第3个节点，取ind=3<br>那两个代码哪个正确呢","like_count":0,"discussions":[{"author":{"id":1459157,"avatar":"https://static001.geekbang.org/account/avatar/00/16/43/d5/a7eaf722.jpg","nickname":"look for","note":"","ucode":"B19F0DED81B2BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592050,"discussion_content":"p-&gt;next = p-&gt;next-&gt;next 是对的，你可以画下图，理解一下代码的执行流程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667046030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285448,"user_name":"马建华","can_delete":false,"product_type":"c1","uid":1185974,"ip_address":"","ucode":"928189590259AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/b6/f3f68a39.jpg","comment_is_top":false,"comment_ctime":1616817229,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616817229","product_id":100043901,"comment_content":"请问老师ret.next和p-&gt;next有何区别？为何不写为p=p.next？","like_count":0,"discussions":[{"author":{"id":1459157,"avatar":"https://static001.geekbang.org/account/avatar/00/16/43/d5/a7eaf722.jpg","nickname":"look for","note":"","ucode":"B19F0DED81B2BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592052,"discussion_content":"-&gt; 是间接引用运算符。是结构体变量引用字段，就直接引用，如果是指针想引用字段，就是间接引用，老师在第八讲中有讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667046268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240665,"user_name":"一溢孤行","can_delete":false,"product_type":"c1","uid":1800923,"ip_address":"","ucode":"27DDEB08081BBD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/db/5c51a72e.jpg","comment_is_top":false,"comment_ctime":1597029729,"is_pvip":false,"replies":[{"id":"90014","content":"代码 BUG 尽量自己找吧，程序员的职业道德是，自己写的 bug 自己找啊~~~~~<br><br>你首先看你的 print_node 里面的 while 循环逻辑。不应该是 p-&gt;next != NULL，而是 p 就不能为 null 啊~~~，p 不为 null，才能合法访问 p-&gt;data 啊","user_name":"作者回复","user_name_real":"胡光","uid":"1374625","ctime":1598594573,"ip_address":"","comment_id":240665,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597029729","product_id":100043901,"comment_content":"#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br><br>&#47;&#47;定义单链表结点的数据结构<br>typedef struct Node<br>{<br>\tint data;  &#47;&#47;数据类型及其相应的值<br>\tstruct Node* next;  &#47;&#47;指向下一个结点 <br>}Node;<br><br>&#47;&#47;创建单链表的一个结点<br>Node* create_node(int num)<br>{<br>\t&#47;&#47;给每个节点分配结构体一样的空间大小 <br>\tNode* p = malloc(sizeof(Node));<br>\tif (p == NULL)<br>\t{<br>\t\tprintf(&quot;malloc error!\\n&quot;);<br>\t\treturn NULL;<br>\t}<br>\t&#47;&#47;由于结构体在未初始化的时候数据是杂乱的，所以要清先进行清理 <br>\tmemset(p, 0, sizeof(Node));<br>\t&#47;&#47;初始化第一个节点 <br>\tp-&gt;data = num;<br>\t&#47;&#47;将节点的后继指针设置为NULL <br>\tp-&gt;next = NULL;<br>}<br><br>Node* insert(Node* head, int ind, Node* a) {<br>\tNode ret, * p = &amp;ret;<br>\tret.next = head;<br>\t&#47;&#47; 从【虚拟头节点】开始向后走 ind 步<br>\twhile (ind--) p = p-&gt;next;<br>\t&#47;&#47; 完成节点的插入操作<br>\ta-&gt;next = p-&gt;next;<br>\tp-&gt;next = a;<br>\t&#47;&#47; 返回真正的链表头节点地址  <br>\treturn ret.next;<br>}<br><br><br>&#47;&#47;链表的遍历 <br>void Print_Node(Node* pH)<br>{<br>\t&#47;&#47;获取当前的位置 <br>\tNode* p = pH;<br>\t&#47;&#47;获取第一个节点的位置 <br>\tp = p-&gt;next;<br>\t&#47;&#47;如果当前位置的下一个节点不为空 <br>\twhile (p-&gt;next != NULL)<br>\t{<br>\t\t&#47;&#47;(1)打印节点的数据 <br>\t\tprintf(&quot;data: %d\\n&quot;, p-&gt;data);<br>\t\t&#47;&#47;(2)移动到下一个节点,如果条件仍为真，则重复(1)，再(2) <br>\t\tp = p-&gt;next;<br>\t}<br>\t&#47;&#47;如果当前位置的下一个节点为空，则打印数据<br>\t&#47;&#47;说明只有一个节点 <br>\tprintf(&quot;data: %d\\n&quot;, p-&gt;data);<br>}<br><br>int main()<br>{<br>\tint i;<br>\tNode* header = create_node(0);&#47;&#47;给头结点赋值为0<br>\tfor (i = 1; i &lt; 10; ++i)<br>\t{<br>\t\tinsert(header, i, i);<br>\t}<br>\tPrint_Node(header);<br>}<br>老师，我这段代码哪里有错误啊，为什么编译到你提供的插入函数的时候就访问异常了呀？","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503518,"discussion_content":"代码 BUG 尽量自己找吧，程序员的职业道德是，自己写的 bug 自己找啊~~~~~\n\n你首先看你的 print_node 里面的 while 循环逻辑。不应该是 p-&amp;gt;next != NULL，而是 p 就不能为 null 啊~~~，p 不为 null，才能合法访问 p-&amp;gt;data 啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598594573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240298,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1596855177,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1596855177","product_id":100043901,"comment_content":"茶艺师学编程<br><br>是这样吗？<br><br>struct Node *erase(struct Node *head, int ind){<br>\tstruct Node ret, *p = &amp;ret;<br>\tret.next = head;<br>\twhile(ind--)p = p-&gt;next;<br>\tp-&gt;next = NULL;<br>\treturn ret.next;<br>}","like_count":0},{"had_liked":false,"id":206369,"user_name":"1043","can_delete":false,"product_type":"c1","uid":1485365,"ip_address":"","ucode":"AAA69CC175AEE3","user_header":"https://static001.geekbang.org/account/avatar/00/16/aa/35/1a4884f9.jpg","comment_is_top":false,"comment_ctime":1586849259,"is_pvip":false,"replies":[{"id":"77175","content":"结构性质是自己定义的，结构操作也是你自己实现的，所以是否规范，主要看操作是否破坏结构性质。操作系统是C语言写的，你想想C语言如果要是想干坏事儿，得多容易。(｡ì _ í｡)","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1586879760,"ip_address":"","comment_id":206369,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1586849259","product_id":100043901,"comment_content":"在“数据结构 = 结构定义 + 结构操作”这个公式里结构定义已经是像乐高玩具的形状一样做好的模型，这个基本上不改动硬件设施就不能变了，在计算机中这个操作是否是操作计算机是指令系统？结构操作是以给定的形状和结构特点自己拼装，这就涉及操作是否规范了，有的操作可能带来破坏性的结果，在计算机中这个结构操作也可能出现破坏性的结果或者直接能去通过计算操作损坏硬件吗？最古老的时代有个病毒记得叫CHI还行就能损坏硬件，好像也是c语言编写的，c真的有这么大的破坏力吗？","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491765,"discussion_content":"结构性质是自己定义的，结构操作也是你自己实现的，所以是否规范，主要看操作是否破坏结构性质。操作系统是C语言写的，你想想C语言如果要是想干坏事儿，得多容易。(｡ì _ í｡)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586879760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201460,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1585790800,"is_pvip":true,"replies":[{"id":"75371","content":"可以可以！d(^_^o)","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1585793458,"ip_address":"","comment_id":201460,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585790800","product_id":100043901,"comment_content":"```golang<br>type Node struct {<br>\tVal  int<br>\tNext *Node<br>}<br><br>func erase(head *Node, ind int) *Node {<br>\tif head == nil {<br>\t\treturn head<br>\t}<br><br>\tret := &amp;Node{<br>\t\tNext: head,<br>\t}<br><br>\tp, prev := ret, ret<br>\tfor ; ind &gt;= 0; ind-- {<br>\t\tif p == nil || p.Next == nil {<br>\t\t\treturn ret.Next<br>\t\t}<br>\t\tprev = p<br>\t\tp = p.Next<br>\t}<br>\tprev.Next = p.Next<br>\treturn ret.Next<br>}<br><br>func NewNode(nums []int) *Node {<br>\tif len(nums) == 0 {<br>\t\treturn nil<br>\t}<br>\thead := &amp;Node{<br>\t\tVal: nums[0],<br>\t}<br>\th := &amp;Node{<br>\t\tNext: head,<br>\t}<br>\tfor i := 1; i &lt; len(nums); i++ {<br>\t\thead.Next = &amp;Node{<br>\t\t\tVal: nums[i],<br>\t\t}<br>\t\thead = head.Next<br>\t}<br>\treturn h.Next<br>}<br><br>func TestErase(t *testing.T) {<br>\thead := NewNode([]int{1, 2, 3, 4, 5, 6})<br>\thead = erase(head, 3)<br>\tfor head != nil {<br>\t\tfmt.Printf(&quot;%d -&gt; &quot;, head.Val)<br>\t\thead = head.Next<br>\t}<br><br>\tfmt.Println()<br>\tfmt.Println(&quot;###########&quot;)<br>\thead = NewNode([]int{1, 2, 3, 4, 5, 6})<br>\thead = erase(head, 0)<br>\tfor head != nil {<br>\t\tfmt.Printf(&quot;%d -&gt; &quot;, head.Val)<br>\t\thead = head.Next<br>\t}<br><br>\tfmt.Println()<br>\tfmt.Println(&quot;###########&quot;)<br>\thead = NewNode([]int{})<br>\thead = erase(head, 1)<br>\tfor head != nil {<br>\t\tfmt.Printf(&quot;%d -&gt; &quot;, head.Val)<br>\t\thead = head.Next<br>\t}\t<br><br>\tfmt.Println()<br>\tfmt.Println(&quot;###########&quot;)<br>\thead = NewNode([]int{1, 2, 3, 4, 5, 6})<br>\thead = erase(head, 5)<br>\tfor head != nil {<br>\t\tfmt.Printf(&quot;%d -&gt; &quot;, head.Val)<br>\t\thead = head.Next<br>\t}<br><br>\tfmt.Println()<br>\tfmt.Println(&quot;###########&quot;)<br>\thead = NewNode([]int{1, 2, 3, 4, 5, 6})<br>\thead = erase(head, 7)<br>\tfor head != nil {<br>\t\tfmt.Printf(&quot;%d -&gt; &quot;, head.Val)<br>\t\thead = head.Next<br>\t}<br>}<br>```","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490341,"discussion_content":"可以可以！d(^_^o)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585793458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187583,"user_name":"信念","can_delete":false,"product_type":"c1","uid":1673076,"ip_address":"","ucode":"3D32CA6E096CF8","user_header":"https://static001.geekbang.org/account/avatar/00/19/87/74/68c35700.jpg","comment_is_top":false,"comment_ctime":1584164404,"is_pvip":false,"replies":[{"id":"72425","content":"老师说的没错！","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1584202097,"ip_address":"","comment_id":187583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584164404","product_id":100043901,"comment_content":"我记得我们上学期计算机老师专门有一节课讲过数组和链表，数组是连续的，而链表不一定是连续的","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487156,"discussion_content":"老师说的没错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584202097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183293,"user_name":"宋不肥","can_delete":false,"product_type":"c1","uid":1240126,"ip_address":"","ucode":"32B34AF579C91C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","comment_is_top":false,"comment_ctime":1582988090,"is_pvip":false,"replies":[{"id":"71085","content":"对，实际上是需要手动释放的，如果是 C 的话，你可以使用 free 来进行释放。没有强调释放的原因是，咱们这个不是一份完整的链表代码，没有从创建开始讲，所以突然提到释放，就会很突兀。你可以想到这个问题，是很棒的！","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1583114752,"ip_address":"","comment_id":183293,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582988090","product_id":100043901,"comment_content":"作业打卡：<br>#include&lt;stdio.h&gt; <br>struct Node {<br>    int data;<br>    struct Node *next;<br>};<br><br>struct Node *insert(struct Node *head, int ind, struct Node *a) {<br>    struct Node ret, *p = &amp;ret;<br>    ret.next = head;<br>    &#47;&#47; 从【虚拟头节点】开始向后走 ind 步<br>    while (ind--) p = p-&gt;next;<br>    &#47;&#47; 完成节点的插入操作<br>    a-&gt;next = p-&gt;next;<br>    p-&gt;next = a;<br>    &#47;&#47; 返回真正的链表头节点地址  <br>    return ret.next;<br>}<br><br>struct Node *erase(struct Node *head, int ind){<br>\tstruct Node ret, *p = &amp;ret;<br>    ret.next = head;<br>\twhile(ind--) p = p-&gt;next;<br>\tp-&gt;next = p-&gt;next-&gt;next;<br>\treturn ret.next;<br>}<br><br>main(){<br>\tstruct Node N1,N0,N3;<br>\tN0.data = 0;<br>\tN0.next = &amp;N1;<br>\tN1.data = 1;<br>\tN1.next = &amp;N3;<br>\tN3.data = 3;<br>\tN3.next = NULL;<br>\tstruct Node N2;<br>\tN2.data = 2;<br>\tN2.next = NULL;<br>\tinsert(&amp;N0, 2, &amp;N2);<br>\tprintf(&quot;%d\\n&quot;,(N1.next)-&gt;data);<br>\terase(&amp;N0, 2);<br>\tprintf(&quot;%d&quot;,(*N1.next).data);<br>}<br>然后有个问题，被删除的结点的内存需要手动释放嘛？感觉这样就只是不用这个结点了，他占用的内存会被当做垃圾碎片嘛","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485636,"discussion_content":"对，实际上是需要手动释放的，如果是 C 的话，你可以使用 free 来进行释放。没有强调释放的原因是，咱们这个不是一份完整的链表代码，没有从创建开始讲，所以突然提到释放，就会很突兀。你可以想到这个问题，是很棒的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583114752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183027,"user_name":"🤪HappyJoo","can_delete":false,"product_type":"c1","uid":1234591,"ip_address":"","ucode":"96E1858F06BABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","comment_is_top":false,"comment_ctime":1582934742,"is_pvip":false,"replies":[{"id":"71094","content":"代码中 ret 的类型，不是一个指针类型哦，而应该是一个实实在在的节点类型，虚拟节点，本身就是一个节点，把前面的 * 去掉就好了。","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1583114908,"ip_address":"","comment_id":183027,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582934742","product_id":100043901,"comment_content":"作业：https:&#47;&#47;github.com&#47;HappyJoo&#47;CLearningScript&#47;blob&#47;master&#47;Linked-list&#47;2_Erase_Node.cpp<br>但是暂时还不清楚如何使用这个函数，等会了再来update哈~老师辛苦啦~","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485537,"discussion_content":"代码中 ret 的类型，不是一个指针类型哦，而应该是一个实实在在的节点类型，虚拟节点，本身就是一个节点，把前面的 * 去掉就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583114908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182864,"user_name":"doge","can_delete":false,"product_type":"c1","uid":1593251,"ip_address":"","ucode":"9E2D4C8F9B4CBC","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","comment_is_top":false,"comment_ctime":1582879074,"is_pvip":false,"replies":[{"id":"70746","content":"非常棒！还实现了非法情况判断！d(^_^o)","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1582903367,"ip_address":"","comment_id":182864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582879074","product_id":100043901,"comment_content":"struct Node* erase(struct Node *head, int ind){<br>    struct Node ret, *p = &amp;ret, *q = NULL;<br>    if (ind &lt; 1){<br>        err(&quot;invalid position %d\\n&quot;, ind);<br>        return head;<br>    }<br>    ret.next = head;<br>    while (--ind &amp;&amp; p-&gt;next != NULL) p = p-&gt;next;<br>    if (ind != 0) err(&quot;invaild position, node not found\\n&quot;);<br>    else {<br>        q = p-&gt;next;<br>        p-&gt;next = q-&gt;next;<br>        free(q);<br>    }<br>    return ret.next;<br>","like_count":1,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485476,"discussion_content":"非常棒！还实现了非法情况判断！d(^_^o)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582903367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182340,"user_name":"宋jia wen","can_delete":false,"product_type":"c1","uid":1346058,"ip_address":"","ucode":"9DB9BB7892B409","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/0a/29171291.jpg","comment_is_top":false,"comment_ctime":1582770330,"is_pvip":false,"replies":[{"id":"70692","content":"这是一个函数，返回值是struct Node 类型的地址。","user_name":"作者回复","user_name_real":"胡炜燚","uid":"1374625","ctime":1582865911,"ip_address":"","comment_id":182340,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1582770330","product_id":100043901,"comment_content":"struct Node *insert(strcut Node *head, int ind, struct Node *a)<br>老师这是 struct Node 型指针 还是 一个函数","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485311,"discussion_content":"这是一个函数，返回值是struct Node 类型的地址。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582865911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314643,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","nickname":"徐洲更","note":"","ucode":"F8A323CB732D05","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188022,"discussion_content":"这是一个函数 返回一个指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582788545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}