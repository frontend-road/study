{"id":644976,"title":"09｜分解Dispatcher：如何把专门的事情交给专门的部件去做？","content":"<p>你好，我是郭屹。今天我们继续手写MiniSpring。</p><p>经过上节课的工作，我们已经实现了IoC与MVC的结合，还定义了Dispatcher与WebApplicationContext两个相对独立又互相关联的结构。</p><p>这节课我们计划在已有的ApplicationConfigWebApplicationContext 和DispatcherServlet基础上，把功能做进一步地分解，让Dispatcher只负责解析request请求，用Context 专门用来管理各个Bean。</p><h2>两级ApplicationContext</h2><p>按照通行的Web分层体系，一个程序它在结构上会有Controller和Service 两层。在我们的程序中，Controller由DispatcherServlet负责启动，Service由Listener负责启动。我们计划把这两部分所对应的容器进行进一步地切割，拆分为XmlWebApplicationContext和AnnotationConfigWebApplicationContext。</p><p>首先在 DispatcherServlet 这个类里，增加一个对WebApplicationContext 的引用，命名为parentApplicationContext。这样，当前这个类里就有了两个对WebApplicationContext 的引用。</p><!-- [[[read_end]]] --><pre><code class=\"language-java\">private WebApplicationContext webApplicationContext;\nprivate WebApplicationContext parentApplicationContext;\n</code></pre><p>新增parentApplicationContext 的目的是，把Listener启动的上下文和DispatcherServlet启动的上下文两者区分开来。按照时序关系，Listener启动在前，对应的上下文我们把它叫作parentApplicationContext。</p><p>我们调整一下init() 方法。</p><pre><code class=\"language-java\">public void init(ServletConfig config) throws ServletException {\n&nbsp; &nbsp; super.init(config);\n&nbsp; &nbsp; this.parentApplicationContext = (WebApplicationContext)&nbsp;\nthis.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION\n_CONTEXT_ATTRIBUTE);\n&nbsp; &nbsp; sContextConfigLocation =&nbsp;\nconfig.getInitParameter(\"contextConfigLocation\");\n\n&nbsp; &nbsp; URL xmlPath = null;\n\ttry {\n\t\txmlPath = this.getServletContext().getResource(sContextConfigLocation);\n\t} catch (MalformedURLException e) {\n\t\te.printStackTrace();\n\t}\n&nbsp; &nbsp; this.packageNames = XmlScanComponentHelper.getNodeValue(xmlPath);\n&nbsp; &nbsp; this.webApplicationContext = new&nbsp;\nAnnotationConfigWebApplicationContext(sContextConfigLocation,&nbsp;\nthis.parentApplicationContext);\n&nbsp; &nbsp; Refresh();\n}\n</code></pre><p>初始化的时候先从ServletContext里拿属性WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，得到的是前一步Listener存放在这里的那个parentApplicationContext。然后通过contextConfigLocation配置文件，创建一个新的WebApplicationContext。</p><p>从上述代码，我们可以发现，里面构建了一个AnnotationConfigWebApplicationContext对象，这个对象的构造函数需要两个参数，一个是配置文件路径，另一个是父上下文。但以前AnnotationConfigWebApplicationContext只有一个参数为String的构造函数。所以这里我们需要扩展改造一下，把DispatcherServlet里一部分和扫描包相关的代码移到AnnotationConfigWebApplicationContext里。你可以看一下修改后的AnnotationConfigWebApplicationContext代码。</p><pre><code class=\"language-java\">package com.minis.web;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.servlet.ServletContext;\nimport com.minis.beans.BeansException;\nimport com.minis.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor;\nimport com.minis.beans.factory.config.BeanDefinition;\nimport com.minis.beans.factory.config.BeanFactoryPostProcessor;\nimport com.minis.beans.factory.config.ConfigurableListableBeanFactory;\nimport com.minis.beans.factory.support.DefaultListableBeanFactory;\nimport com.minis.context.AbstractApplicationContext;\nimport com.minis.context.ApplicationEvent;\nimport com.minis.context.ApplicationEventPublisher;\nimport com.minis.context.ApplicationListener;\nimport com.minis.context.SimpleApplicationEventPublisher;\n\npublic class AnnotationConfigWebApplicationContext&nbsp;\n\t\t\t\t\textends AbstractApplicationContext implements WebApplicationContext{\n\tprivate WebApplicationContext parentApplicationContext;\n\tprivate ServletContext servletContext;\n\tDefaultListableBeanFactory beanFactory;\n\tprivate final List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors =\n\t\t\tnew ArrayList&lt;BeanFactoryPostProcessor&gt;();\t\n\n\tpublic AnnotationConfigWebApplicationContext(String fileName) {\n\t\tthis(fileName, null);\n\t}\n\tpublic AnnotationConfigWebApplicationContext(String fileName, WebApplicationContext parentApplicationContext) {\n\t\tthis.parentApplicationContext = parentApplicationContext;\n\t\tthis.servletContext = this.parentApplicationContext.getServletContext();\n&nbsp; &nbsp; &nbsp; &nbsp; URL xmlPath = null;\n\t\ttry {\n\t\t\txmlPath = this.getServletContext().getResource(fileName);\n\t\t} catch (MalformedURLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; List&lt;String&gt; packageNames = XmlScanComponentHelper.getNodeValue(xmlPath);\n&nbsp; &nbsp; &nbsp; &nbsp; List&lt;String&gt; controllerNames = scanPackages(packageNames);\n&nbsp; &nbsp; \tDefaultListableBeanFactory bf = new DefaultListableBeanFactory();\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactory = bf;\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactory.setParent(this.parentApplicationContext.getBeanFactory());\n&nbsp; &nbsp; &nbsp; &nbsp; loadBeanDefinitions(controllerNames);\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (true) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n\t\t\t\trefresh();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\t}\n\tpublic void loadBeanDefinitions(List&lt;String&gt; controllerNames) {\n&nbsp; &nbsp; &nbsp; &nbsp; for (String controller : controllerNames) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String beanID=controller;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String beanClassName=controller;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BeanDefinition beanDefinition=new BeanDefinition(beanID,beanClassName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.beanFactory.registerBeanDefinition(beanID,beanDefinition);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\t}\n&nbsp; &nbsp; private List&lt;String&gt; scanPackages(List&lt;String&gt; packages) {\n&nbsp; &nbsp; \tList&lt;String&gt; tempControllerNames = new ArrayList&lt;&gt;();\n&nbsp; &nbsp; \tfor (String packageName : packages) {\n&nbsp; &nbsp; \t\ttempControllerNames.addAll(scanPackage(packageName));\n&nbsp; &nbsp; \t}\n&nbsp; &nbsp; \treturn tempControllerNames;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; private List&lt;String&gt; scanPackage(String packageName) {\n&nbsp; &nbsp; \tList&lt;String&gt; tempControllerNames = new ArrayList&lt;&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; URL url&nbsp; =this.getClass().getClassLoader().getResource(\"/\"+packageName.replaceAll(\"\\\\.\", \"/\"));\n&nbsp; &nbsp; &nbsp; &nbsp; File dir = new File(url.getFile());\n&nbsp; &nbsp; &nbsp; &nbsp; for (File file : dir.listFiles()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(file.isDirectory()){\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \tscanPackage(packageName+\".\"+file.getName());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String controllerName = packageName +\".\" +file.getName().replace(\".class\", \"\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tempControllerNames.add(controllerName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return tempControllerNames;\n&nbsp; &nbsp; }\n\tpublic void setParent(WebApplicationContext parentApplicationContext) {\n\t\tthis.parentApplicationContext = parentApplicationContext;\n\t\tthis.beanFactory.setParent(this.parentApplicationContext.getBeanFactory());\n\t}\n\tpublic ServletContext getServletContext() {\n\t\treturn this.servletContext;\n\t}\n\tpublic void setServletContext(ServletContext servletContext) {\n\t\tthis.servletContext = servletContext;\n\t}\n\tpublic void publishEvent(ApplicationEvent event) {\n\t\tthis.getApplicationEventPublisher().publishEvent(event);\n\t}\n\tpublic void addApplicationListener(ApplicationListener listener) {\n\t\tthis.getApplicationEventPublisher().addApplicationListener(listener);\n\t}\n\tpublic void registerListeners() {\n\t\tApplicationListener listener = new ApplicationListener();\n\t\tthis.getApplicationEventPublisher().addApplicationListener(listener);\n\t}\n\tpublic void initApplicationEventPublisher() {\n\t\tApplicationEventPublisher aep = new SimpleApplicationEventPublisher();\n\t\tthis.setApplicationEventPublisher(aep);\n\t}\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory bf) {\n\t}\n\tpublic void registerBeanPostProcessors(ConfigurableListableBeanFactory bf) {\n\t\tthis.beanFactory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());\n\t}\n\tpublic void onRefresh() {\n\t\tthis.beanFactory.refresh();\n\t}\n\tpublic void finishRefresh() {\n\t}\n\tpublic ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException {\n\t\treturn this.beanFactory;\n\t}\n}\n</code></pre><p>这段代码的核心是扩充原有的构造方法。通过下面两行代码得到parentApplicationContext和servletContext的引用。</p><pre><code class=\"language-plain\"> this.parentApplicationContext = parentApplicationContext;\n&nbsp;this.servletContext = this.parentApplicationContext.getServletContext();\n</code></pre><p>为了兼容原有构造方法，在只有1个参数的时候，给WebApplicationContext传入了一个null。可以看到，修改后的AnnotationConfigWebApplicationContext继承自抽象类AbstractApplicationContext，所以也具备了上下文的通用功能，例如注册监听器、发布事件等。</p><p>其次是改造&nbsp;DefaultListableBeanFactory，因为AnnotationConfigWebApplicationContext里调用了DefaultListableBeanFactory的setParent方法，所以我们需要提供相应的实现方法，你可以看一下相关代码。</p><pre><code class=\"language-java\">&nbsp; &nbsp; ConfigurableListableBeanFactory parentBeanFactory;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; public void setParent(ConfigurableListableBeanFactory beanFactory) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.parentBeanFactory = beanFactory;\n&nbsp; &nbsp; }\n</code></pre><p>接下来我们还要改造XmlWebApplicationContext，在继承ClassPathXmlApplicationContext的基础上实现WebApplicationContext接口，基本上我们可以参考AnnotationConfigWebApplicationContext来实现。</p><pre><code class=\"language-java\">package com.minis.web;\n\nimport javax.servlet.ServletContext;\nimport com.minis.context.ClassPathXmlApplicationContext;\n\npublic class XmlWebApplicationContext&nbsp;\n\t\t\t\t\textends ClassPathXmlApplicationContext implements WebApplicationContext{\n\tprivate ServletContext servletContext;\n\t\n\tpublic XmlWebApplicationContext(String fileName) {\n\t\tsuper(fileName);\n\t}\n\n\tpublic ServletContext getServletContext() {\n\t\treturn this.servletContext;\n\t}\n\tpublic void setServletContext(ServletContext servletContext) {\n\t\tthis.servletContext = servletContext;\n\t}\n}\n</code></pre><p>到这里，我们就进一步拆解了DispatcherServlet，拆分出两级ApplicationContext，当然启动过程还是由Listener来负责。所以最后ContextLoaderListener初始化时是创建XmlWebApplicationContext对象。</p><pre><code class=\"language-java\">WebApplicationContext wac = new&nbsp;XmlWebApplicationContext(sContextLocation); \n</code></pre><p>到这里，Web环境下的两个ApplicationContext都构建完毕了，WebApplicationContext持有对parentApplicationContext的单向引用。当调用getBean()获取Bean时，先从WebApplicationContext中获取，若为空则通过parentApplicationContext获取，你可以看一下代码。</p><pre><code class=\"language-java\">&nbsp; &nbsp; public Object getBean(String beanName) throws BeansException {\n&nbsp; &nbsp; &nbsp; &nbsp; Object result = super.getBean(beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; if (result == null) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = this.parentBeanFactory.getBean(beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; }\n</code></pre><h2>抽取调用方法</h2><p>拆解的工作还要继续进行，基本的思路是将专业事情交给不同的专业部件来做，我们来看看还有哪些工作是可以分出来的。从代码可以看到现在doGet()方法是这样实现的。</p><pre><code class=\"language-plain\">\tMethod method = this.mappingMethods.get(sPath);\n\tobj = this.mappingObjs.get(sPath);\n\tobjResult = method.invoke(obj);\n\tresponse.getWriter().append(objResult.toString());\n</code></pre><p>这个程序就是简单地根据URL找到对应的方法和对象，然后通过反射调用方法，最后把方法执行的返回值写到response里。我们考虑把通过URL映射到某个实例方法的过程抽取出来，还要考虑把对方法的调用也单独抽取出来。仿照Spring框架，我们新增RequestMappingHandlerMapping与RequestMappingHandlerAdapter，分别对应这两个独立的部件。</p><p>首先将HandlerMapping与HandlerAdapter抽象出来，定义接口，然后基于接口来编程。</p><pre><code class=\"language-java\">package com.minis.web.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic interface HandlerMapping {\n\tHandlerMethod getHandler(HttpServletRequest request) throws Exception;\n}\n\n\n\npackage com.minis.web.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic interface HandlerAdapter {\n\tvoid handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;\n}\n\n</code></pre><p>其中可以看到，HandlerMapping中定义的getHandler方法参数是http request，返回一个HandlerMethod对象，这个地方就是封装的这种映射关系。你可以看一下HandlerMethod对象的定义。</p><pre><code class=\"language-java\">package com.minis.web.servlet;\n\nimport java.lang.reflect.Method;\n\npublic class HandlerMethod {\n\tprivate&nbsp; Object bean;\n\tprivate&nbsp; Class&lt;?&gt; beanType;\n\tprivate&nbsp; Method method;\n\tprivate&nbsp; MethodParameter[] parameters;\n\tprivate&nbsp; Class&lt;?&gt; returnType;\n\tprivate&nbsp; String description;\n\tprivate&nbsp; String className;\n\tprivate&nbsp; String methodName;\n\t\n\tpublic HandlerMethod(Method method, Object obj) {\n\t\tthis.setMethod(method);\n\t\tthis.setBean(obj);\t\n\t}\n\tpublic Method getMethod() {\n\t\treturn method;\n\t}\n\tpublic void setMethod(Method method) {\n\t\tthis.method = method;\n\t}\n\tpublic Object getBean() {\n\t\treturn bean;\n\t}\n\tpublic void setBean(Object bean) {\n\t\tthis.bean = bean;\n\t}\n}\n</code></pre><p>接下来增加一个MappingRegistry类，这个类有三个属性：urlMappingNames、mappingObjs和mappingMethods，用来存储访问的URL名称与对应调用方法及Bean实例的关系。你可以看一下相关定义。</p><pre><code class=\"language-java\">package com.minis.web.servlet;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class MappingRegistry {\n&nbsp; &nbsp; private List&lt;String&gt; urlMappingNames = new ArrayList&lt;&gt;();\n&nbsp; &nbsp; private Map&lt;String,Object&gt; mappingObjs = new HashMap&lt;&gt;();\n&nbsp; &nbsp; private Map&lt;String,Method&gt; mappingMethods = new HashMap&lt;&gt;();\n&nbsp; &nbsp;&nbsp;\n\tpublic List&lt;String&gt; getUrlMappingNames() {\n\t\treturn urlMappingNames;\n\t}\n\tpublic void setUrlMappingNames(List&lt;String&gt; urlMappingNames) {\n\t\tthis.urlMappingNames = urlMappingNames;\n\t}\n\tpublic Map&lt;String,Object&gt; getMappingObjs() {\n\t\treturn mappingObjs;\n\t}\n\tpublic void setMappingObjs(Map&lt;String,Object&gt; mappingObjs) {\n\t\tthis.mappingObjs = mappingObjs;\n\t}\n\tpublic Map&lt;String,Method&gt; getMappingMethods() {\n\t\treturn mappingMethods;\n\t}\n\tpublic void setMappingMethods(Map&lt;String,Method&gt; mappingMethods) {\n\t\tthis.mappingMethods = mappingMethods;\n\t}\n}\n</code></pre><p>通过上面的代码可以看出，这三个属性以前其实都已经存在了，是定义在DispatcherServlet里的，现在换一个位置，通过MappingRegistry这个单独的部件来存放和管理这个映射关系。</p><p>好了，有了这些准备之后，我们来看RequestMappingHandlerMapping的实现，它要实现HandlerMapping 接口，初始化过程就是遍历WAC中已经注册的所有的Bean，并处理带有@RequestMapping注解的类，使用mappingRegistry存储URL地址与方法和实例的映射关系。对外它要实现getHandler()方法，通过URL拿到method的调用。</p><p>相关源代码如下：</p><pre><code class=\"language-java\">package com.minis.web.servlet;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport javax.servlet.http.HttpServletRequest;\nimport com.minis.beans.BeansException;\nimport com.minis.web.RequestMapping;\nimport com.minis.web.WebApplicationContext;\n\npublic class RequestMappingHandlerMapping implements HandlerMapping{\n&nbsp; &nbsp; WebApplicationContext wac;\n&nbsp; &nbsp; private final MappingRegistry mappingRegistry = new MappingRegistry();\n&nbsp; &nbsp; public RequestMappingHandlerMapping(WebApplicationContext wac) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.wac = wac;\n&nbsp; &nbsp; &nbsp; &nbsp; initMapping();\n&nbsp; &nbsp; }\n    //建立URL与调用方法和实例的映射关系，存储在mappingRegistry中\n&nbsp; &nbsp; protected void initMapping() {\n&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; clz = null;\n&nbsp; &nbsp; &nbsp; &nbsp; Object obj = null;\n&nbsp; &nbsp; &nbsp; &nbsp; String[] controllerNames = this.wac.getBeanDefinitionNames();\n        //扫描WAC中存放的所有bean\n&nbsp; &nbsp; &nbsp; &nbsp; for (String controllerName : controllerNames) {\n            try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     clz = Class.forName(controllerName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     obj = this.wac.getBean(controllerName);\n            } catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Method[] methods = clz.getDeclaredMethods();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (methods != null) {\n                //检查每一个方法声明\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Method method : methods) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean isRequestMapping =&nbsp;\nmethod.isAnnotationPresent(RequestMapping.class);\n                    //如果该方法带有@RequestMapping注解,则建立映射关系\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (isRequestMapping) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String methodName = method.getName();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String urlmapping =&nbsp;\nmethod.getAnnotation(RequestMapping.class).value();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n                        this.mappingRegistry.getUrlMappingNames().add(urlmapping);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.mappingRegistry.getMappingObjs().put(urlmapping,&nbsp;\nobj);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.mappingRegistry.getMappingMethods().put(urlmapping,&nbsp;\nmethod);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n    //根据访问URL查找对应的调用方法\n&nbsp; &nbsp; public HandlerMethod getHandler(HttpServletRequest request) throws Exception&nbsp;\n{\n&nbsp; &nbsp; &nbsp; &nbsp; String sPath = request.getServletPath();\n\t\tif (!this.mappingRegistry.getUrlMappingNames().contains(sPath)) {\n\t\t\treturn null;\n\t\t}\n&nbsp; &nbsp; &nbsp; &nbsp; Method method = this.mappingRegistry.getMappingMethods().get(sPath);\n&nbsp; &nbsp; &nbsp; &nbsp; Object obj = this.mappingRegistry.getMappingObjs().get(sPath);\n&nbsp; &nbsp; &nbsp; &nbsp; HandlerMethod handlerMethod = new HandlerMethod(method, obj);\n&nbsp; &nbsp; &nbsp; &nbsp; return handlerMethod;\n&nbsp; &nbsp; }\n}\n</code></pre><p>这样我们就得到了独立的RequestMappingHandlerMapping部件，把以前写在DispatcherServlet里的代码移到这里来了。</p><p>接下来就轮到RequestMappingHandlerAdapter的实现了，它要实现HandlerAdapter接口，主要就是实现handle()方法，基本过程是接受前端传request、&nbsp;response与handler，通过反射中的invoke调用方法并处理返回数据。</p><p>相关源代码如下：</p><pre><code class=\"language-java\">package com.minis.web.servlet;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport com.minis.web.WebApplicationContext;\n\npublic class RequestMappingHandlerAdapter implements HandlerAdapter {\n\tWebApplicationContext wac;\n\n\tpublic RequestMappingHandlerAdapter(WebApplicationContext wac) {\n\t\tthis.wac = wac;\n\t}\n\n\tpublic void handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\t\thandleInternal(request, response, (HandlerMethod) handler);\n\t}\n\tprivate void handleInternal(HttpServletRequest request, HttpServletResponse response,\n\t\t\tHandlerMethod handler) {\n\t\tMethod method = handler.getMethod();\n\t\tObject obj = handler.getBean();\n\t\tObject objResult = null;\n\t\ttry {\n\t\t\tobjResult = method.invoke(obj);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\ttry {\n\t\t\tresponse.getWriter().append(objResult.toString());\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n</code></pre><p>重点看一下handleInternal()方法就知道了，这里就是简单地通过反射调用某个方法，然后把返回值写到response里。这些程序代码以前就有，只不过现在移到单独的这个部件中了。</p><p>最后需要修改DispatcherServlet中的实现，相关代码移走，放到了上面的两个部件中。所以在DispatcherServlet类中需要增加对HandlerMapping与HandlerAdapter的引用，在初始化方法refresh()中增加initHandlerMapping 与initHandlerAdapter两个方法，为引用的HandlerMapping与HandlerAdapter赋值。</p><p>你可以看下DispatcherServlet的refresh()的改造结果。</p><pre><code class=\"language-plain\">refresh()\t{\n&nbsp; &nbsp; \tinitController();\n&nbsp; &nbsp; \t\n\t\tinitHandlerMappings(this.webApplicationContext);\n\t\tinitHandlerAdapters(this.webApplicationContext);\n}\n</code></pre><p>初始化这两个部件的代码如下：</p><pre><code class=\"language-plain\">&nbsp; &nbsp; protected void initHandlerMappings(WebApplicationContext wac) {\n&nbsp; &nbsp; \tthis.handlerMapping = new RequestMappingHandlerMapping(wac);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; protected void initHandlerAdapters(WebApplicationContext wac) {\n&nbsp; &nbsp; \tthis.handlerAdapter = new RequestMappingHandlerAdapter(wac);\n&nbsp; &nbsp; }\n</code></pre><p>DispatcherServlet的分发过程也要改造一下，不再通过doGet()方法了，而是通过重写的service方法来实现的，而service方法则调用了doDispatch方法，这个方法内部通过handlerMapping获取到对应handlerMethod，随后通过HandlerAdapter进行处理，你可以看一下这个类修改后的源代码。</p><pre><code class=\"language-java\">protected void service(HttpServletRequest request, HttpServletResponse&nbsp;\nresponse) {\n&nbsp; &nbsp; request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE,&nbsp;\nthis.webApplicationContext);\n\ttry {\n\t\tdoDispatch(request, response);\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\tfinally {\n\t}\n}\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse&nbsp;\nresponse) throws Exception{\n&nbsp; &nbsp; HttpServletRequest processedRequest = request;\n&nbsp; &nbsp; HandlerMethod handlerMethod = null;\n&nbsp; &nbsp; handlerMethod = this.handlerMapping.getHandler(processedRequest);\n    if (handlerMethod == null) {\n\t\treturn;\n\t}\n&nbsp; &nbsp; HandlerAdapter ha = this.handlerAdapter;\n&nbsp; &nbsp; ha.handle(processedRequest, response, handlerMethod);\n}\n</code></pre><p>可以看到，经过这么一改造，相比之前DispatcherServlet的代码简化了很多，并且当前业务程序不用再固定写死在doGet()方法里面，可以按照自身的业务需求随意使用任何方法名，也为今后提供多种请求方式，例如POST、PUT、DELETE等提供了便利。</p><p>以前，用原始的Servlet规范，我们的业务逻辑全部写在doGet()、doPost()等方法中，每一个业务逻辑程序都是一个独立的Servlet。现在经过我们这几节课的操作，整个系统用一个唯一的DispatcherServlet来拦截请求，并根据注解，定位需要调用的方法，我们就能够更加专注于本身业务代码的实现。这种我们称之为Dispatcher的设计模式也是要用心学习的。</p><h2>小结</h2><p>这节课我们的主要工作就是拆解Dispatcher。首先拆解的是ApplicationContext，现在我们有了两级上下文，一级用于IoC容器，我们叫parent上下文，一级用于Web上下文，WebApplicationContext持有对parent上下文的引用。方便起见，我们还增加了@RequestMapping注解来声明URL映射，然后新增RequestMappingHandlerMapping 与RequestMappingHandlerAdapter，分别包装URL映射关系和映射后的处理过程。</p><p>通过这些拆解工作，我们就把DispatcherServlet的功能进行了分治，把专门的事情交给专门的部件去完成，有利于今后的扩展。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课，我也给你留一道思考题。目前，我们只支持了GET方法，你能不能尝试自己增加POST方法。想一想，需要改变现有的程序结构吗？欢迎你在留言区和我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","neighbors":{"left":{"article_title":"08｜整合IoC和MVC：如何在Web环境中启动IoC容器？","id":643539},"right":{"article_title":"10｜数据绑定: 如何自动转换传入的参数？","id":644987}},"comments":[{"had_liked":false,"id":371761,"user_name":"马儿","can_delete":false,"product_type":"c1","uid":2247080,"ip_address":"四川","ucode":"542E23D7B6AB01","user_header":"","comment_is_top":false,"comment_ctime":1680279344,"is_pvip":false,"replies":[{"id":135633,"content":"赞你一个","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680352404,"ip_address":"澳大利亚","comment_id":371761,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"总结一下：\n1. Listener初始化的时候将交给Ioc管理的Bean初始化\n2.Servlet初始化的时候将controller相关的bean初始化\n这两步初始化将bean的管理从DispatcherServlet剥离交给了第一章创建的Ioc容器\n3.将具体的url和对象+方法的管理从Servlet交给HandlerMapping来处理\n4.将具体的方法执行剥离到HandlerAdapter\n这两步将DispatcherServlet变得更抽象了，利用serviece方法可以同时处理不同类型的请求\n一点建议：\n1. DispatcherServlet中的controller相关bean的初始化已经交给AnnotationConfigWebApplicationContext管理了，它的init方法不用在调用initController了","like_count":11,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611837,"discussion_content":"赞你一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680352405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374539,"user_name":"lmnsds","can_delete":false,"product_type":"c1","uid":1069422,"ip_address":"北京","ucode":"0ED5B1443059DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/6e/757d42a0.jpg","comment_is_top":false,"comment_ctime":1684162205,"is_pvip":false,"replies":[{"id":136730,"content":"多谢提醒","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684208703,"ip_address":"澳大利亚","comment_id":374539,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"在github代码的geek_mvc3分支找了半天 这节课的 DispatcherServlet，原来不是在web包下改的原有类，而是在web.servlet包下新增了个DispatcherServlet！浪费了好多时间！给后来人提个醒吧。","like_count":4,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618365,"discussion_content":"多谢提醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684208703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372292,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1680946738,"is_pvip":false,"replies":[{"id":135911,"content":"思考题后面有再回首章节里面给出了参考，你可以到时候再思考一下。\nQ1，习惯问题吧，Spring框架本身也是经常这样写。有一个潜在原因，但是我不是很确定，就是方法中尽量使用local变量，只在尽量少的场合使用实例变量和方法参数，这样提高性能减少开销。编译器优化是这么说的，但是我也不确定一定就是这样。另外，对源码，我还是建议最后去读Spring框架的源代码，那是世界顶级程序员的力作（推广到别的也是一样的，Apache Tomcat，JDK，Apache Dubbo）。我自己也是在跟着他们的时候一旁偷学了几招，MiniSpring的目的是剖析Spring框架内部结构，作为一个简明地图引导大家理解Spring。\nQ2，就是这样解释的。Spring体系中IoC是核心层，MVC只是外周的部分，理论上是可以不启用的可选部件。软件是一层层堆积的，层次感要慢慢培养。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681044562,"ip_address":"澳大利亚","comment_id":372292,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"思考题:我的想法是模仿SpringMVC,在RequestMapping注解上增加一个HttpMethod的属性(当前方法允许的请求方式)。在解析RequestMapping注解的时候改动一下,拿到RequestMapping注解上的HttpMethod,将其放到HandlerMethod中,然后将HandlerMathod对象放进MappingRegistry的一个map中,key:path,value:HandlerMethod。用户发起请求时,doDispatch方法中,获取到HttpServletRequest对象中的请求方式和MappingRegistry中存储的HandlerMethod上的请求方式进行比较,如果符合就可以访问,否则就报出方法类型不匹配\n另外，有两个问题请教一下老师。\n1、问题一:\nDefaultListableBeanFactory beanFactory;\nDefaultListableBeanFactory bf = new DefaultListableBeanFactory();        \nthis.beanFactory = bf;\n我看老师在很多地方都是这样写的，为啥不直接给成员变量赋值呢?this.beanFactory = = new DefaultListableBeanFactory();\n\n2、问题2\n为什么Spring要搞出两个容器来呢?\n我从StackOverFLow上搜了一下相关解释:https:&#47;&#47;stackoverflow.com&#47;questions&#47;18578143&#47;about-multiple-containers-in-spring-framework\n看上面的解释是:\n这样分开更清晰,Dispatcher驱动的子容器专门用来处理controller组件,ContextLoaderListener驱动的父容器专门用来处理业务逻辑组件以及持久化组件。\n除了这个原因,Spring搞2个容器还有其他原因吗?","like_count":4,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612967,"discussion_content":"思考题后面有再回首章节里面给出了参考，你可以到时候再思考一下。\nQ1，习惯问题吧，Spring框架本身也是经常这样写。有一个潜在原因，但是我不是很确定，就是方法中尽量使用local变量，只在尽量少的场合使用实例变量和方法参数，这样提高性能减少开销。编译器优化是这么说的，但是我也不确定一定就是这样。另外，对源码，我还是建议最后去读Spring框架的源代码，那是世界顶级程序员的力作（推广到别的也是一样的，Apache Tomcat，JDK，Apache Dubbo）。我自己也是在跟着他们的时候一旁偷学了几招，MiniSpring的目的是剖析Spring框架内部结构，作为一个简明地图引导大家理解Spring。\nQ2，就是这样解释的。Spring体系中IoC是核心层，MVC只是外周的部分，理论上是可以不启用的可选部件。软件是一层层堆积的，层次感要慢慢培养。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1681044562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","nickname":"风轻扬","note":"","ucode":"DB972F2DF059C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612970,"discussion_content":"好的，知道了，老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681046128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388604,"user_name":"赵欣","can_delete":false,"product_type":"c1","uid":1423699,"ip_address":"广东","ucode":"6066BD20C6123E","user_header":"https://static001.geekbang.org/account/avatar/00/15/b9/53/a72bebcc.jpg","comment_is_top":false,"comment_ctime":1710468955,"is_pvip":false,"replies":[{"id":141496,"content":"赞你","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1710751478,"ip_address":"澳大利亚","comment_id":388604,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"有几个文件跟原来版本相比也有些变化了，大家注意下，一个是AbstractBeanFactory.java一个是DefaultListableBeanFactory.java文件。","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639528,"discussion_content":"赞你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710751478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375915,"user_name":"睿智的仓鼠","can_delete":false,"product_type":"c1","uid":2781305,"ip_address":"湖北","ucode":"914D56E47B01F2","user_header":"https://static001.geekbang.org/account/avatar/00/2a/70/79/bb591140.jpg","comment_is_top":false,"comment_ctime":1686124678,"is_pvip":false,"replies":[{"id":137164,"content":"感谢！","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1686143581,"ip_address":"澳大利亚","comment_id":375915,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"不可多得的好课，跟到现在学到很多","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620417,"discussion_content":"感谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686143581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372091,"user_name":"梦某人","can_delete":false,"product_type":"c1","uid":3228991,"ip_address":"河北","ucode":"D9F14B15AC2A12","user_header":"https://static001.geekbang.org/account/avatar/00/31/45/3f/e4fc2781.jpg","comment_is_top":false,"comment_ctime":1680705133,"is_pvip":false,"replies":[{"id":135814,"content":"写得很好很好。我觉得，不管通过什么方式，最后能达到理解了Spring框架的目的就好了，我的建议还是读文稿，听我讲，手工练习，自己动手过一遍就是不一样的，线下班学员还要做扩展练习，加上更多功能和鲁棒性。源代码方面，MiniSpring主要是便于教学时理解Spring框架的结构，代码最后要学习Spring框架本身的源代码。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680783982,"ip_address":"澳大利亚","comment_id":372091,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"首先以个人理解回答课后题，目前的请求并不分 get 或者 post，主要是以请求的路径进行区分，如果想要处理 post 请求，\n需要构建新的 HandlerAdapter，对 Request 中的 post body 内容进行额外的解析和处理，然后操作方法。当然可能还需要构建 HandlerMapping 来处理请求路径，但是个人没想到什么 get 和 post 区别很大的地方。\n第二和第三点是个人跟写的时候遇到的一些问题，给其他同学一点参考。\n第二个， \n```\n&#47;&#47; getBeanDefinitionNames 方法中\nreturn (String[]) this.beanNames.toArray(); \n&#47;&#47;替换成\n return this.beanNames.toArray(new String[0]); \n```\n可以减少一些类型转换异常，特别是当 ArrayList 里面只有一个 String 元素的时候。\n第三个，BeanDefinition 中的部分 get 方法应该增加运算符 防止返回 Null 而不是 empty，导致空指针异常。例如：\n```\n  public ArgumentValues getArgumentValues() {\n        return argumentValues == null? new ArgumentValues(): argumentValues;\n    }\n```\n第四点是课程个人理解了：两级的 WebApplicationContext 第一级在 Listener 的时候加载，加载了 beans.xml (或者 Application.xml ) 中的 bean， 然后作为 第二级 AnnotationConfigWebApplicationContext 的父级， 第二级别通过 mvc.xml 提供的扫包路径进行扫包加载 bean，同时注册带有注解的方法。 当路由请求来的时候，先从第二级的 WebApplicationContext 获取 bean 和其方法进行处理，所以这个两级在最后的时候以 Controller 和 Service 来进行讲解，不是真的 Controller 和 Service， 而是说 第二级处理事物的触发逻辑比第一级更早，加载的逻辑则比他更晚，就好像 请求先到 Controller 后到 Service 一样。\n\n最后的最后，，，看着老师文稿给的代码来吵，已经是和 GitHub 中的代码差别越来越大了， Debug 起来更加费时，但是好处是理解加深了。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612567,"discussion_content":"写得很好很好。我觉得，不管通过什么方式，最后能达到理解了Spring框架的目的就好了，我的建议还是读文稿，听我讲，手工练习，自己动手过一遍就是不一样的，线下班学员还要做扩展练习，加上更多功能和鲁棒性。源代码方面，MiniSpring主要是便于教学时理解Spring框架的结构，代码最后要学习Spring框架本身的源代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680783982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371908,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1680512369,"is_pvip":false,"replies":[{"id":135704,"content":"赞","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680558644,"ip_address":"澳大利亚","comment_id":371908,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"出去玩了两天，今天把这章也结束掉了。代码运行一切正常。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612174,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680558644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371837,"user_name":"Geek_320730","can_delete":false,"product_type":"c1","uid":3035552,"ip_address":"北京","ucode":"CF7E6C8E91D2C4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/XWv3mvIFORNgRk9wF8QLb9aXfh1Uz1hADtUmlFwQJVxIzhBf8HWc4QqU7iaTzj8wB5p5QJLRAvlQNrOqXtrg1Og/132","comment_is_top":false,"comment_ctime":1680410067,"is_pvip":false,"replies":[{"id":135655,"content":"你的思考和练习很好有深度，用心了。MiniSpring是为了学习构建的，不是工业级的。线下听课的几波学生，要对照代码进行扩展练习，自己增加功能特性增加鲁棒性。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680500097,"ip_address":"澳大利亚","comment_id":371837,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"1. 课后题：重写service后不是Get 和Post都能处理吗？\n2.扫描的包里有接口，接口应该是不能实例化的，我过滤了下接口类型才能启动起来，对比了下老师的代码，好像并没有处理。\n3.尝试了下在HelloWorldBean里注入parentApplicationContext中创建的Bean，发现了个小问题，AbstractBeanFactory#getBean方法中如果获取不到BeanDefinition 应该返回个null，而不是抛出异常，否则不会去父类查找。对构造器注入参数和set注入参数增加null校验","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612042,"discussion_content":"你的思考和练习很好有深度，用心了。MiniSpring是为了学习构建的，不是工业级的。线下听课的几波学生，要对照代码进行扩展练习，自己增加功能特性增加鲁棒性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680500097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3567201,"avatar":"https://static001.geekbang.org/account/avatar/00/36/6e/61/b1273106.jpg","nickname":"Shark","note":"","ucode":"DDF4B1A407C669","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611927,"discussion_content":"老师的代码中的scanPackage方法是这样的：\nprivate List&lt;String&gt; scanPackage(String packageName) {\n    \tList&lt;String&gt; tempControllerNames = new ArrayList&lt;&gt;();\n        URL url  =this.getClass().getClassLoader().getResource(&#34;/&#34;+packageName.replaceAll(&#34;\\\\.&#34;, &#34;/&#34;));\n        File dir = new File(url.getFile());\n        for (File file : dir.listFiles()) {\n            if(file.isDirectory()){\n            \tscanPackage(packageName+&#34;.&#34;+file.getName());\n            }else{\n                String controllerName = packageName +&#34;.&#34; +file.getName().replace(&#34;.class&#34;, &#34;&#34;);\n                tempControllerNames.add(controllerName);\n            }\n        }\n        return tempControllerNames;\n    }\n对于子目录的递归扫描并没有接收返回值，所以相当于只会扫描test目录下，不会将test/service包下的扫描进，所以在示例代码中只会扫到一个HelloWorldBean。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680423617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371772,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1680311424,"is_pvip":false,"replies":[{"id":135634,"content":"不是同一个，是两级context.\ncontroller和service是两层，并不特别规定是谁。我这里主要想描述的是dispatcherservlet中的控制逻辑与ioc容器中管理的bean的业务逻辑是前后两层的关系。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680352635,"ip_address":"澳大利亚","comment_id":371772,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"请教两个问题：\nDispatcherServlet 这个类里，有两个WebApplicationContext对象：private WebApplicationContext webApplicationContext;\nprivate WebApplicationContext parentApplicationContext;\n请问，这两个对象是同一个对象吗？？\nQ2：文中的controller和service是业务层的吗？\n文中有这样的描述：“按照通行的 Web 分层体系，一个程序它在结构上会有 Controller 和 Service 两层。在我们的程序中，Controller 由 DispatcherServlet 负责启动，Service 由 Listener 负责启动。”\n程序员写业务代码的时候，会按照controller、service、dao来写。\n请问，文中的controller和service是业务层的controller、service吗？（即程序员写的controller、service）","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611839,"discussion_content":"不是同一个，是两级context.\ncontroller和service是两层，并不特别规定是谁。我这里主要想描述的是dispatcherservlet中的控制逻辑与ioc容器中管理的bean的业务逻辑是前后两层的关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680352636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132427,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/8b/0d33954c.jpg","nickname":"摩诃不思议","note":"","ucode":"2BC7CC50218C59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611804,"discussion_content":"A1：你仔细看代码呀，webApplicationContext 和 parentApplicationContext 是不同的对象\n\nA2：我的理解是这里的【controller】由 DispatcherServlet 来启动，接收 web 请求的。【service】由 Listener 来启动，读的是 contextConfigLocation 地址下配置文件中配置的 bean","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680333276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377372,"user_name":"Geek_149cde","can_delete":false,"product_type":"c1","uid":3634218,"ip_address":"山西","ucode":"4447C15B2A083B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep9YJC0GnicC7TDcrGFsfAZ6ATQLO29icXSKvntKcAcJGGJN6IibLrzHyp35Lia36fVlpSE8HsicIyOQyw/132","comment_is_top":false,"comment_ctime":1688390121,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"不明白 AnnotationConfigWebApplicationContext 文件里 loadBeanDefinitions 加载的时候不应该把 AService 接口也加载进去了吗？创建 Bean 的时候不是就报错了","like_count":0}]}