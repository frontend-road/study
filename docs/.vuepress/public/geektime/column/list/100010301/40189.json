{"id":40189,"title":"27 | 注解处理器","content":"<p>注解（annotation）是Java 5引入的，用来为类、方法、字段、参数等Java结构提供额外信息的机制。我先举个例子，比如，Java核心类库中的<code>@Override</code>注解是被用来声明某个实例方法重写了父类的同名同参数类型的方法。</p>\n<pre><code>package java.lang;\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n</code></pre>\n<p><code>@Override</code>注解本身被另外两个元注解（即作用在注解上的注解）所标注。其中，<code>@Target</code>用来限定目标注解所能标注的Java结构，这里<code>@Override</code>便只能被用来标注方法。</p>\n<p><code>@Retention</code>则用来限定当前注解生命周期。注解共有三种不同的生命周期：<code>SOURCE</code>，<code>CLASS</code>或<code>RUNTIME</code>，分别表示注解只出现在源代码中，只出现在源代码和字节码中，以及出现在源代码、字节码和运行过程中。</p>\n<p>这里<code>@Override</code>便只能出现在源代码中。一旦标注了<code>@Override</code>的方法所在的源代码被编译为字节码，该注解便会被擦除。</p>\n<p>我们不难猜到，<code>@Override</code>仅对Java编译器有用。事实上，它会为Java编译器引入了一条新的编译规则，即如果所标注的方法不是Java语言中的重写方法，那么编译器会报错。而当编译完成时，它的使命也就结束了。</p>\n<p>我们知道，Java的注解机制允许开发人员自定义注解。这些自定义注解同样可以为Java编译器添加编译规则。不过，这种功能需要由开发人员提供，并且以插件的形式接入Java编译器中，这些插件我们称之为注解处理器（annotation processor）。</p><!-- [[[read_end]]] -->\n<p>除了引入新的编译规则之外，注解处理器还可以用于修改已有的Java源文件（不推荐），或者生成新的Java源文件。下面，我将用几个案例来详细阐述注解处理器的这些功能，以及它背后的原理。</p>\n<h2>注解处理器的原理</h2>\n<p>在介绍注解处理器之前，我们先来了解一下Java编译器的工作流程。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/64/b8/64e93f67c3b422afd90966bfe9aaf5b8.png?wh=600*75\" alt=\"\" /></p>\n<p>如上图所示 出处[1]，Java源代码的编译过程可分为三个步骤：</p>\n<ol>\n<li>将源文件解析为抽象语法树；</li>\n<li>调用已注册的注解处理器；</li>\n<li>生成字节码。</li>\n</ol>\n<p>如果在第2步调用注解处理器过程中生成了新的源文件，那么编译器将重复第1、2步，解析并且处理新生成的源文件。每次重复我们称之为一轮（Round）。</p>\n<p>也就是说，第一轮解析、处理的是输入至编译器中的已有源文件。如果注解处理器生成了新的源文件，则开始第二轮、第三轮，解析并且处理这些新生成的源文件。当注解处理器不再生成新的源文件，编译进入最后一轮，并最终进入生成字节码的第3步。</p>\n<pre><code>package foo;\n\nimport java.lang.annotation.*;\n\n@Target({ ElementType.TYPE, ElementType.FIELD })\n@Retention(RetentionPolicy.SOURCE)\npublic @interface CheckGetter {\n}\n</code></pre>\n<p>在上面这段代码中，我定义了一个注解<code>@CheckGetter</code>。它既可以用来标注类，也可以用来标注字段。此外，它和<code>@Override</code>相同，其生命周期被限定在源代码中。</p>\n<p>下面我们来实现一个处理<code>@CheckGetter</code>注解的处理器。它将遍历被标注的类中的实例字段，并检查有没有相应的<code>getter</code>方法。</p>\n<pre><code>public interface Processor {\n\n  void init(ProcessingEnvironment processingEnv);\n  \n  Set&lt;String&gt; getSupportedAnnotationTypes();\n  \n  SourceVersion getSupportedSourceVersion();\n  \n  boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv);\n  \n  ...\n}\n</code></pre>\n<p>所有的注解处理器类都需要实现接口<code>Processor</code>。该接口主要有四个重要方法。其中，<code>init</code>方法用来存放注解处理器的初始化代码。之所以不用构造器，是因为在Java编译器中，注解处理器的实例是通过反射API生成的。也正是因为使用反射API，每个注解处理器类都需要定义一个无参数构造器。</p>\n<p>通常来说，当编写注解处理器时，我们不声明任何构造器，并依赖于Java编译器，为之插入一个无参数构造器。而具体的初始化代码，则放入<code>init</code>方法之中。</p>\n<p>在剩下的三个方法中，<code>getSupportedAnnotationTypes</code>方法将返回注解处理器所支持的注解类型，这些注解类型只需用字符串形式表示即可。</p>\n<p><code>getSupportedSourceVersion</code>方法将返回该处理器所支持的Java版本，通常，这个版本需要与你的Java编译器版本保持一致；而<code>process</code>方法则是最为关键的注解处理方法。</p>\n<p>JDK提供了一个实现<code>Processor</code>接口的抽象类<code>AbstractProcessor</code>。该抽象类实现了<code>init</code>、<code>getSupportedAnnotationTypes</code>和<code>getSupportedSourceVersion</code>方法。</p>\n<p>它的子类可以通过<code>@SupportedAnnotationTypes</code>和<code>@SupportedSourceVersion</code>注解来声明所支持的注解类型以及Java版本。</p>\n<p>下面这段代码便是<code>@CheckGetter</code>注解处理器的实现。由于我使用了Java 10的编译器，因此将支持版本设置为<code>SourceVersion.RELEASE_10</code>。</p>\n<pre><code>package bar;\n\nimport java.util.Set;\n\nimport javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.*;\nimport javax.lang.model.util.ElementFilter;\nimport javax.tools.Diagnostic.Kind;\n\nimport foo.CheckGetter;\n\n@SupportedAnnotationTypes(&quot;foo.CheckGetter&quot;)\n@SupportedSourceVersion(SourceVersion.RELEASE_10)\npublic class CheckGetterProcessor extends AbstractProcessor {\n\n  @Override\n  public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n    // TODO: annotated ElementKind.FIELD\n    for (TypeElement annotatedClass : ElementFilter.typesIn(roundEnv.getElementsAnnotatedWith(CheckGetter.class))) {\n      for (VariableElement field : ElementFilter.fieldsIn(annotatedClass.getEnclosedElements())) {\n        if (!containsGetter(annotatedClass, field.getSimpleName().toString())) {\n          processingEnv.getMessager().printMessage(Kind.ERROR,\n              String.format(&quot;getter not found for '%s.%s'.&quot;, annotatedClass.getSimpleName(), field.getSimpleName()));\n        }\n      }\n    }\n    return true;\n  }\n\n  private static boolean containsGetter(TypeElement typeElement, String name) {\n    String getter = &quot;get&quot; + name.substring(0, 1).toUpperCase() + name.substring(1).toLowerCase();\n    for (ExecutableElement executableElement : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {\n      if (!executableElement.getModifiers().contains(Modifier.STATIC)\n          &amp;&amp; executableElement.getSimpleName().toString().equals(getter)\n          &amp;&amp; executableElement.getParameters().isEmpty()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre>\n<p>该注解处理器仅重写了<code>process</code>方法。这个方法将接收两个参数，分别代表该注解处理器所能处理的注解类型，以及囊括当前轮生成的抽象语法树的<code>RoundEnvironment</code>。</p>\n<p>由于该处理器针对的注解仅有<code>@CheckGetter</code>一个，而且我们并不会读取注解中的值，因此第一个参数并不重要。在代码中，我直接使用了</p>\n<pre><code>`roundEnv.getElementsAnnotatedWith(CheckGetter.class)`\n</code></pre>\n<p>来获取所有被<code>@CheckGetter</code>注解的类（以及字段）。</p>\n<p><code>process</code>方法涉及各种不同类型的<code>Element</code>，分别指代Java程序中的各个结构。如<code>TypeElement</code>指代类或者接口，<code>VariableElement</code>指代字段、局部变量、enum常量等，<code>ExecutableElement</code>指代方法或者构造器。</p>\n<pre><code>package foo;     // PackageElement\n\nclass Foo {      // TypeElement\n  int a;           // VariableElement\n  static int b;    // VariableElement\n  Foo () {}        // ExecutableElement\n  void setA (      // ExecutableElement\n    int newA         // VariableElement\n  ) {}\n}\n</code></pre>\n<p>这些结构之间也有从属关系，如上面这段代码所示(出处[2]）。我们可以通过<code>TypeElement.getEnclosedElements</code>方法，获得上面这段代码中<code>Foo</code>类的字段、构造器以及方法。</p>\n<p>我们也可以通过<code>ExecutableElement.getParameters</code>方法，获得<code>setA</code>方法的参数。具体这些<code>Element</code>类都有哪些API，你可以参考它们的Javadoc[3]。</p>\n<p>在将该注解处理器编译成class文件后，我们便可以将其注册为Java编译器的插件，并用来处理其他源代码。注册的方法主要有两种。第一种是直接使用javac命令的<code>-processor</code>参数，如下所示：</p>\n<pre><code>$ javac -cp /CLASSPATH/TO/CheckGetterProcessor -processor bar.CheckGetterProcessor Foo.java\nerror: Class 'Foo' is annotated as @CheckGetter, but field 'a' is without getter\n1 error\n</code></pre>\n<p>第二种则是将注解处理器编译生成的class文件压缩入jar包中，并在jar包的配置文件中记录该注解处理器的包名及类名，即<code>bar.CheckGetterProcessor</code>。</p>\n<pre><code>（具体路径及配置文件名为`META-INF/services/javax.annotation.processing.Processor`）\n</code></pre>\n<p>当启动Java编译器时，它会寻找classpath路径上的jar包是否包含上述配置文件，并自动注册其中记录的注解处理器。</p>\n<pre><code>$ javac -cp /PATH/TO/CheckGetterProcessor.jar Foo.java\nerror: Class 'Foo' is annotated as @CheckGetter, but field 'a' is without getter\n1 error\n</code></pre>\n<p>此外，我们还可以在IDE中配置注解处理器。这里我就不过多演示了，感兴趣的同学可以自行搜索。</p>\n<h2>利用注解处理器生成源代码</h2>\n<p>前面提到，注解处理器可以用来修改已有源代码或者生成源代码。</p>\n<p>确切地说，注解处理器并不能真正地修改已有源代码。这里指的是修改由Java源代码生成的抽象语法树，在其中修改已有树节点或者插入新的树节点，从而使生成的字节码发生变化。</p>\n<p>对抽象语法树的修改涉及了Java编译器的内部API，这部分很可能随着版本变更而失效。因此，我并不推荐这种修改方式。</p>\n<p>如果你感兴趣的话，可以参考[Project Lombok][4]。这个项目自定义了一系列注解，并根据注解的内容来修改已有的源代码。例如它提供了<code>@Getter</code>和<code>@Setter</code>注解，能够为程序自动添加<code>getter</code>以及<code>setter</code>方法。有关对使用内部API的讨论，你可以参考[这篇博客][5]，以及[Lombok的回应][6]。</p>\n<p>用注解处理器来生成源代码则比较常用。我们以前介绍过的压力测试jcstress，以及接下来即将介绍的JMH工具，都是依赖这种方式来生成测试代码的。</p>\n<pre><code>package foo;\n\nimport java.lang.annotation.*;\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Adapt {\n  Class&lt;?&gt; value();\n}\n</code></pre>\n<p>在上面这段代码中，我定义了一个注解<code>@Adapt</code>。这个注解将接收一个<code>Class</code>类型的参数<code>value</code>（如果注解类仅包含一个名为<code>value</code>的参数时，那么在使用注解时，我们可以省略<code>value=</code>），具体用法如这段代码所示。</p>\n<pre><code>// Bar.java\npackage test;\nimport java.util.function.IntBinaryOperator;\nimport foo.Adapt;\n\npublic class Bar {\n  @Adapt(IntBinaryOperator.class)\n  public static int add(int a, int b) {\n    return a + b;\n  }\n}\n</code></pre>\n<p>接下来，我们来实现一个处理<code>@Adapt</code>注解的处理器。该处理器将生成一个新的源文件，实现参数<code>value</code>所指定的接口，并且调用至被该注解所标注的方法之中。具体的实现代码比较长，建议你在<a href=\"https://time.geekbang.org/column/108\">网页端</a>观看。</p>\n<pre><code>package bar;\n\nimport java.io.*;\nimport java.util.Set;\n\nimport javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.*;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementFilter;\nimport javax.tools.JavaFileObject;\n\nimport javax.tools.Diagnostic.Kind;\n\n@SupportedAnnotationTypes(&quot;foo.Adapt&quot;)\n@SupportedSourceVersion(SourceVersion.RELEASE_10)\npublic class AdaptProcessor extends AbstractProcessor {\n\n  @Override\n  public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n    for (TypeElement annotation : annotations) {\n      if (!&quot;foo.Adapt&quot;.equals(annotation.getQualifiedName().toString())) {\n        continue;\n      }\n\n      ExecutableElement targetAsKey = getExecutable(annotation, &quot;value&quot;);\n\n      for (ExecutableElement annotatedMethod : ElementFilter.methodsIn(roundEnv.getElementsAnnotatedWith(annotation))) {\n        if (!annotatedMethod.getModifiers().contains(Modifier.PUBLIC)) {\n          processingEnv.getMessager().printMessage(Kind.ERROR, &quot;@Adapt on non-public method&quot;);\n          continue;\n        }\n        if (!annotatedMethod.getModifiers().contains(Modifier.STATIC)) {\n          // TODO support non-static methods\n          continue;\n        }\n\n        TypeElement targetInterface = getAnnotationValueAsTypeElement(annotatedMethod, annotation, targetAsKey);\n        if (targetInterface.getKind() != ElementKind.INTERFACE) {\n          processingEnv.getMessager().printMessage(Kind.ERROR, &quot;@Adapt with non-interface input&quot;);\n          continue;\n        }\n\n        TypeElement enclosingType = getTopLevelEnclosingType(annotatedMethod);\n        createAdapter(enclosingType, annotatedMethod, targetInterface);\n      }\n    }\n    return true;\n  }\n\n  private void createAdapter(TypeElement enclosingClass, ExecutableElement annotatedMethod,\n      TypeElement targetInterface) {\n    PackageElement packageElement = (PackageElement) enclosingClass.getEnclosingElement();\n    String packageName = packageElement.getQualifiedName().toString();\n    String className = enclosingClass.getSimpleName().toString();\n    String methodName = annotatedMethod.getSimpleName().toString();\n    String adapterName = className + &quot;_&quot; + methodName + &quot;Adapter&quot;;\n\n    ExecutableElement overriddenMethod = getFirstNonDefaultExecutable(targetInterface);\n\n    try {\n      Filer filer = processingEnv.getFiler();\n      JavaFileObject sourceFile = filer.createSourceFile(packageName + &quot;.&quot; + adapterName, new Element[0]);\n\n      try (PrintWriter out = new PrintWriter(sourceFile.openWriter())) {\n        out.println(&quot;package &quot; + packageName + &quot;;&quot;);\n        out.println(&quot;import &quot; + targetInterface.getQualifiedName() + &quot;;&quot;);\n        out.println();\n        out.println(&quot;public class &quot; + adapterName + &quot; implements &quot; + targetInterface.getSimpleName() + &quot; {&quot;);\n        out.println(&quot;  @Override&quot;);\n        out.println(&quot;  public &quot; + overriddenMethod.getReturnType() + &quot; &quot; + overriddenMethod.getSimpleName()\n            + formatParameter(overriddenMethod, true) + &quot; {&quot;);\n        out.println(&quot;    return &quot; + className + &quot;.&quot; + methodName + formatParameter(overriddenMethod, false) + &quot;;&quot;);\n        out.println(&quot;  }&quot;);\n        out.println(&quot;}&quot;);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private ExecutableElement getExecutable(TypeElement annotation, String methodName) {\n    for (ExecutableElement method : ElementFilter.methodsIn(annotation.getEnclosedElements())) {\n      if (methodName.equals(method.getSimpleName().toString())) {\n        return method;\n      }\n    }\n    processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Incompatible @Adapt.&quot;);\n    return null;\n  }\n\n  private ExecutableElement getFirstNonDefaultExecutable(TypeElement annotation) {\n    for (ExecutableElement method : ElementFilter.methodsIn(annotation.getEnclosedElements())) {\n      if (!method.isDefault()) {\n        return method;\n      }\n    }\n    processingEnv.getMessager().printMessage(Kind.ERROR,\n        &quot;Target interface should declare at least one non-default method.&quot;);\n    return null;\n  }\n\n  private TypeElement getAnnotationValueAsTypeElement(ExecutableElement annotatedMethod, TypeElement annotation,\n      ExecutableElement annotationFunction) {\n    TypeMirror annotationType = annotation.asType();\n\n    for (AnnotationMirror annotationMirror : annotatedMethod.getAnnotationMirrors()) {\n      if (processingEnv.getTypeUtils().isSameType(annotationMirror.getAnnotationType(), annotationType)) {\n        AnnotationValue value = annotationMirror.getElementValues().get(annotationFunction);\n        if (value == null) {\n          processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Unknown @Adapt target&quot;);\n          continue;\n        }\n        TypeMirror targetInterfaceTypeMirror = (TypeMirror) value.getValue();\n        return (TypeElement) processingEnv.getTypeUtils().asElement(targetInterfaceTypeMirror);\n      }\n    }\n    processingEnv.getMessager().printMessage(Kind.ERROR, &quot;@Adapt should contain target()&quot;);\n    return null;\n  }\n\n  private TypeElement getTopLevelEnclosingType(ExecutableElement annotatedMethod) {\n    TypeElement enclosingType = null;\n    Element enclosing = annotatedMethod.getEnclosingElement();\n\n    while (enclosing != null) {\n      if (enclosing.getKind() == ElementKind.CLASS) {\n        enclosingType = (TypeElement) enclosing;\n      } else if (enclosing.getKind() == ElementKind.PACKAGE) {\n        break;\n      }\n      enclosing = enclosing.getEnclosingElement();\n    }\n    return enclosingType;\n  }\n\n  private String formatParameter(ExecutableElement method, boolean includeType) {\n    StringBuilder builder = new StringBuilder();\n    builder.append('(');\n    String separator = &quot;&quot;;\n\n    for (VariableElement parameter : method.getParameters()) {\n      builder.append(separator);\n      if (includeType) {\n        builder.append(parameter.asType());\n        builder.append(' ');\n      }\n      builder.append(parameter.getSimpleName());\n      separator = &quot;, &quot;;\n    }\n    builder.append(')');\n    return builder.toString();\n  }\n}\n</code></pre>\n<p>在这个注解处理器实现中，我们将读取注解中的值，因此我将使用<code>process</code>方法的第一个参数，并通过它获得被标注方法对应的<code>@Adapt</code>注解中的<code>value</code>值。</p>\n<p>之所以采用这种麻烦的方式，是因为<code>value</code>值属于<code>Class</code>类型。在编译过程中，被编译代码中的<code>Class</code>常量未必被加载进Java编译器所在的虚拟机中。因此，我们需要通过<code>process</code>方法的第一个参数，获得<code>value</code>所指向的接口的抽象语法树，并据此生成源代码。</p>\n<p>生成源代码的方式实际上非常容易理解。我们可以通过<code>Filer.createSourceFile</code>方法获得一个类似于文件的概念，并通过<code>PrintWriter</code>将具体的内容一一写入即可。</p>\n<p>当将该注解处理器作为插件接入Java编译器时，编译前面的<code>test/Bar.java</code>将生成下述代码，并且触发新一轮的编译。</p>\n<pre><code>package test;\nimport java.util.function.IntBinaryOperator;\n\npublic class Bar_addAdapter implements IntBinaryOperator {\n  @Override\n  public int applyAsInt(int arg0, int arg1) {\n    return Bar.add(arg0, arg1);\n  }\n}\n</code></pre>\n<blockquote>\n<p>注意，该注解处理器没有处理所编译的代码包名为空的情况。</p>\n</blockquote>\n<h2>总结与实践</h2>\n<p>今天我介绍了Java编译器的注解处理器。</p>\n<p>注解处理器主要有三个用途。一是定义编译规则，并检查被编译的源文件。二是修改已有源代码。三是生成新的源代码。其中，第二种涉及了Java编译器的内部API，因此并不推荐。第三种较为常见，是OpenJDK工具jcstress，以及JMH生成测试代码的方式。</p>\n<p>Java源代码的编译过程可分为三个步骤，分别为解析源文件生成抽象语法树，调用已注册的注解处理器，和生成字节码。如果在第2步中，注解处理器生成了新的源代码，那么Java编译器将重复第1、2步，直至不再生成新的源代码。</p>\n<hr />\n<p>今天的实践环节，请实现本文的案例<code>CheckGetterProcessor</code>中的TODO项，处理由<code>@CheckGetter</code>注解的字段。</p>\n<p>[1] <a href=\"http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html\">http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html</a><br />\n[2] <a href=\"http://hannesdorfmann.com/annotation-processing/annotationprocessing101\">http://hannesdorfmann.com/annotation-processing/annotationprocessing101</a><br />\n[3] <a href=\"https://docs.oracle.com/javase/10/docs/api/javax/lang/model/element/package-summary.html\">https://docs.oracle.com/javase/10/docs/api/javax/lang/model/element/package-summary.html</a><br />\n[4] <a href=\"https://projectlombok.org/\">https://projectlombok.org/</a><br />\n[5] <a href=\"http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html\">http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html</a><br />\n[6] <a href=\"http://jnb.ociweb.com/jnb/jnbJan2010.html#controversy\">http://jnb.ociweb.com/jnb/jnbJan2010.html#controversy</a></p>\n<p></p>\n","comments":[{"had_liked":false,"id":26053,"user_name":"聚变","can_delete":false,"product_type":"c1","uid":1006040,"ip_address":"","ucode":"1068849263833F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/d8/baf0dea1.jpg","comment_is_top":false,"comment_ctime":1537493808,"is_pvip":false,"replies":[{"id":"9514","content":"Cglib等字节码工具会影响启动性能，峰值性能上没啥区别。<br><br>如果对字节码不熟的话，用注解处理器比较容易些。另一方面，字节码处理工具更强大些，能做很多源代码不能做的。","user_name":"作者回复","comment_id":26053,"uid":"1176688","ip_address":"","utype":1,"ctime":1537512986,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"70256970544","product_id":100010301,"comment_content":"编译时生成与 运行时使用cglib等类库生成的字节码,在性能和使用场景上有什么区别吗??","like_count":17,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424507,"discussion_content":"Cglib等字节码工具会影响启动性能，峰值性能上没啥区别。\n\n如果对字节码不熟的话，用注解处理器比较容易些。另一方面，字节码处理工具更强大些，能做很多源代码不能做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537512986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":26984,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1537790434,"is_pvip":false,"replies":[{"id":"10287","content":"注解相当于给某些代码贴了个标签。我们既可以通过注解处理器在编译时解析这些标签，也可以在运行时通过反射解析这些标签。解析后都会有一系列动作，这些动作就是对标签语义的诠释。","user_name":"作者回复","comment_id":26984,"uid":"1176688","ip_address":"","utype":1,"ctime":1538115217,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"48782430690","product_id":100010301,"comment_content":"嗯，之前写过注解方面的功能，不过虽然能自定义注解，也能明白Java语言层面的有关注解相关的知识点，但是往下怎么样就不太清楚了？<br>注解代码本质也是代码，也会被编译为.class文件，然后在JVM上面被转换成机器码，然后被计算机执行，不过感觉他好特别，他的存在仅是为了是编码更简洁吗？<br>读之前我就在想上面的问题，文中虽然没有介绍这些内容，不过介绍了其他的内容也挺好！<br><br>小结一下：<br>1：注解处理器-本质也是代码，以插件的形式存在，以插件的形式接入Java编译器，这些插件有什么用呢？<br><br>2：注解处理器的作用？<br>注解处理器有三个作用<br>2-1：可以为Java编译器添加一些编译规则，这也就是传说中的自定义注解，它可以定义一些编译规则，这些编译规则会以插件的形式提供给Java编译器。<br>2-2：可以修改已有的JAVA源文件（不推荐，为什么呢？因为本质上注解处理器不能修改已有的JAVA源代码，但是它可以修改有java源代码生成的抽象语法树，从而使生成的字节码发生变化，不过对抽象语法树的修改修改设计了java编译器的内部API，这部分很可能随着版本的变更而失效，所以，才不推荐使用的，存在埋深坑的隐患。）<br>2-3：可以生成一些新的JAVA源文件<br><br>3：元注解-给注解使用的注解就是元注解，这些注解是JDK的开发人员提前定义了的，也同样是以插件的形式接入Java编译器的。注意：所有的注解处理器都必须实现Processor接口，这个接口中有四个方法，每个方法都有其特殊的作用在，详情需要回头细看。另外，JDK提供了一个实现Processor接口的抽象类AbstractProcessor，这个抽象类实现了Processor接口的其中三个方法。<br><br>4：自定义的注解被编译为.class文件后，便可以将其注册为Java编译器的插件了，注册方法有两种，祥看专栏内容吧！<br><br>5：Java源代码的编译过程分为三个步骤<br>     5-1：解析源文件生成抽象语法树<br>     5-2：调用已注册的注解处理器（注解处理器有两种注册到JAVA编译器的方式）<br>     5-3：生成字节码<br>     5-4：如果5-2步中，注解处理器生成了新的源代码，那么JAVA编译器将重复第5-1&#47;5-2步，直到不再生成新的源代码。","like_count":12,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424779,"discussion_content":"注解相当于给某些代码贴了个标签。我们既可以通过注解处理器在编译时解析这些标签，也可以在运行时通过反射解析这些标签。解析后都会有一系列动作，这些动作就是对标签语义的诠释。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1538115217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28289,"user_name":"lovedebug","can_delete":false,"product_type":"c1","uid":1004115,"ip_address":"","ucode":"292FB1FD078AE8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/53/a9918d0b.jpg","comment_is_top":false,"comment_ctime":1538044191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27307847967","product_id":100010301,"comment_content":"讲的很好，赞。结合java语法看印象更深","like_count":7},{"had_liked":false,"id":25958,"user_name":"补心","can_delete":false,"product_type":"c1","uid":1124789,"ip_address":"","ucode":"9DB51E8A6C4B62","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/b5/2b477ed4.jpg","comment_is_top":false,"comment_ctime":1537488267,"is_pvip":false,"replies":[{"id":"9513","content":"有可能，因为用的是internal API。","user_name":"作者回复","comment_id":25958,"uid":"1176688","ip_address":"","utype":1,"ctime":1537512434,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"27307292043","product_id":100010301,"comment_content":"Lombok随着Java版本的问题，是不是有可能没法使用。","like_count":6,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424474,"discussion_content":"有可能，因为用的是internal API。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537512434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76833,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1552722355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23027558835","product_id":100010301,"comment_content":"反射在运行时，注解解释器在编译时","like_count":5},{"had_liked":false,"id":28688,"user_name":"白三岁","can_delete":false,"product_type":"c1","uid":1109892,"ip_address":"","ucode":"39594C357FEA1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/84/a0ffbd8b.jpg","comment_is_top":false,"comment_ctime":1538127509,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18717996693","product_id":100010301,"comment_content":"spring中的那些注解也是通过注解处理器实现的吗。我们项目中一般好像都是通过spring的aop来实现自定义注解的功能。","like_count":4,"discussions":[{"author":{"id":1625364,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/14/fcf8545e.jpg","nickname":"Gray","note":"","ucode":"7C5DD6CE817E64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400751,"discussion_content":"Spring中的不是，是运行时通过CGLib增强实现的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633409175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":26536,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1537644080,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10127578672","product_id":100010301,"comment_content":"郑老师  有个问题我一直想不明白?java 源码生成语法树 java APT 处理器处理后生成代码， 从新走那个过程  有重复生成了  那不是死循环了吗？可能是自己知识浅薄  麻烦在这点上正老师能指点下☺️  自己水平比较low  模仿了写一直没成功☺️ 不知道郑老师能发一个demo 工程吗","like_count":2,"discussions":[{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294850,"discussion_content":"如果 --> 在第 2 步中，注解处理器生成了新的源代码，那么 Java 编译器将重复第 1、2 步，直至不再生成  -->  新的源代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596015076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198850,"user_name":"小陈","can_delete":false,"product_type":"c1","uid":1009385,"ip_address":"","ucode":"A03A299310AD18","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/e9/814d057a.jpg","comment_is_top":false,"comment_ctime":1585470518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880437814","product_id":100010301,"comment_content":"这个比深入理解jvm那部分详细","like_count":2},{"had_liked":false,"id":89434,"user_name":"奇奇","can_delete":false,"product_type":"c1","uid":1399097,"ip_address":"","ucode":"BC86B0CB55E35A","user_header":"","comment_is_top":false,"comment_ctime":1556173713,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5851141009","product_id":100010301,"comment_content":"老师，这个 ExecutableElement targetAsKey = getExecutable(annotation, &quot;value&quot;); 这一句是干嘛的，我看语义是找出所有名字是value的方法？难道不应该找的是value所指向的类吗？","like_count":1},{"had_liked":false,"id":45693,"user_name":"山顶的洞","can_delete":false,"product_type":"c1","uid":1246664,"ip_address":"","ucode":"D3E9E928A3FA62","user_header":"https://static001.geekbang.org/account/avatar/00/13/05/c8/2f849dfb.jpg","comment_is_top":false,"comment_ctime":1543752712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838720008","product_id":100010301,"comment_content":"自定义注解都是aop实现的吗？好像没看到过注解处理器。","like_count":1},{"had_liked":false,"id":26347,"user_name":"Egos","can_delete":false,"product_type":"c1","uid":1071143,"ip_address":"","ucode":"9F0055B140E935","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/27/1188e017.jpg","comment_is_top":false,"comment_ctime":1537572208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5832539504","product_id":100010301,"comment_content":"问一下RetentionPolicy.CLASS 的使用场景。有一些用来生成Java 文件的注解是可以使用SOURCE的，但是用了CLASS。","like_count":1},{"had_liked":false,"id":339274,"user_name":"כן אני אמריקאי","can_delete":false,"product_type":"c1","uid":1527429,"ip_address":"","ucode":"56C5C2B369121B","user_header":"https://static001.geekbang.org/account/avatar/00/17/4e/85/ef0108cd.jpg","comment_is_top":false,"comment_ctime":1648018750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648018750","product_id":100010301,"comment_content":"深入源码分析注解处理器是如何工作的，带你手撸@Getter注解，让你体会一下Lombok是如何工作的。欢迎大家阅读：https:&#47;&#47;juejin.cn&#47;post&#47;7077550257344610312","like_count":1},{"had_liked":false,"id":337555,"user_name":"cv0cv0","can_delete":false,"product_type":"c1","uid":1360093,"ip_address":"","ucode":"93FF9277F03FD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","comment_is_top":false,"comment_ctime":1646892016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646892016","product_id":100010301,"comment_content":"一直不知道 Lombok 有啥用，完全可以用 Kotlin 代替。","like_count":0},{"had_liked":false,"id":298313,"user_name":"godliness","can_delete":false,"product_type":"c1","uid":1341267,"ip_address":"","ucode":"1C1976C39DCFE6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIuUYcwKWUuib5mpdIbTwQzTGNWBmk0ktZSwm2vteUXf4TxWF2aVCv7Hvshcq0OaG7JRLj6rJyPLicA/132","comment_is_top":false,"comment_ctime":1624009492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624009492","product_id":100010301,"comment_content":"请教个问题：我在匿名内部类中的方法使用注解声明后，在相应的注解处理器却获取不到，内部类在编译阶段应该会被编译为跟外部类一样的顶级类，为什么获取不到呢？","like_count":0},{"had_liked":false,"id":198437,"user_name":"妥协","can_delete":false,"product_type":"c1","uid":1249656,"ip_address":"","ucode":"7201DFE9C12669","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg","comment_is_top":false,"comment_ctime":1585451458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585451458","product_id":100010301,"comment_content":"是不是运行时，就是通过反射创建代理实现的","like_count":0},{"had_liked":false,"id":75426,"user_name":"孜孜","can_delete":false,"product_type":"c1","uid":1018203,"ip_address":"","ucode":"7EF4FB644357CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/5b/d8f78c1e.jpg","comment_is_top":false,"comment_ctime":1552396571,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"1552396571","product_id":100010301,"comment_content":"@Getter 和例子自己定义的@CheckGetter 一起使用，@CheckGetter先生效。有点搞不明白Lombok和自己定义的执行顺序。","like_count":0,"discussions":[{"author":{"id":1440912,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","nickname":"ack","note":"","ucode":"69CA1233EEA8E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272629,"discussion_content":"你好，请问你是怎么编译生效的呢？我试了cmd编译以及idea都直接编译通过，使用的是jdk8","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590329473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1018203,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/5b/d8f78c1e.jpg","nickname":"孜孜","note":"","ucode":"7EF4FB644357CE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1440912,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","nickname":"ack","note":"","ucode":"69CA1233EEA8E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273079,"discussion_content":"你是指@checkgetter，这个用老师的两种方法都可以好用啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590408113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272629,"ip_address":""},"score":273079,"extra":""},{"author":{"id":1440912,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","nickname":"ack","note":"","ucode":"69CA1233EEA8E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018203,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/5b/d8f78c1e.jpg","nickname":"孜孜","note":"","ucode":"7EF4FB644357CE","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":273838,"discussion_content":"我两种都不行😢，想问下你用的是哪个jdk版本呀，然后我是用idea编译过程正常，以及用cmd执行编译也是正常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590504018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273079,"ip_address":""},"score":273838,"extra":""},{"author":{"id":1018203,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/5b/d8f78c1e.jpg","nickname":"孜孜","note":"","ucode":"7EF4FB644357CE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1440912,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","nickname":"ack","note":"","ucode":"69CA1233EEA8E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274119,"discussion_content":"我也是jdk8，编译通过就可以按照老师提供的命令运行了，然后就会看到没有get方法的提醒。或者你可以给个githublink，我看一眼你对我code。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590543354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273838,"ip_address":""},"score":274119,"extra":""}]}]},{"had_liked":false,"id":64274,"user_name":"金龟","can_delete":false,"product_type":"c1","uid":1228500,"ip_address":"","ucode":"1C7D35C8AE8D9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d4/ff1c1319.jpg","comment_is_top":false,"comment_ctime":1548731405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548731405","product_id":100010301,"comment_content":"CheckGetterProcessor这个是怎么用的？？我感觉我没有运行起来一个类里没有getter方法，我一样能够编译通过。","like_count":0},{"had_liked":false,"id":29991,"user_name":"lewis","can_delete":false,"product_type":"c1","uid":1253640,"ip_address":"","ucode":"128DA8287C180B","user_header":"https://static001.geekbang.org/account/avatar/00/13/21/08/94d145c1.jpg","comment_is_top":false,"comment_ctime":1538621093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538621093","product_id":100010301,"comment_content":"老师你好，我在使用Annotation Processor过程中，遇到了一个问题，比如某个Element是一个方法，我想获取这个方法的返回值类型，当这个返回值是泛型的时候，无法获取全路径的类型；比如返回值是自定义类型com.xxx.module.domain.UserInfo这个类型，通过下面的语句只能知道返回值是字面量UserInfo,而不是com.xxx.module.domain.UserInfo这个全路径类型 。<br> ExecutableElement methodElement = ExecutableElement.class.cast(element);<br>            TypeMirror returnType = methodElement.getReturnType();<br>            TypeName returnTypeName = ClassName.get(returnType);<br>这个returnTypeName只是UserInfo,不是com.xxx.module.domain.UserInfo，拿不到UserInfo的包路径信息，通过messager提示说是找不到com.xxx.module.domain这个包，请老师指导","like_count":0},{"had_liked":false,"id":26370,"user_name":"mtfelix","can_delete":false,"product_type":"c1","uid":1045809,"ip_address":"","ucode":"8C838BC0FC1F58","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/31/bbb513ba.jpg","comment_is_top":false,"comment_ctime":1537581030,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1537581030","product_id":100010301,"comment_content":"不错哦","like_count":0,"discussions":[{"author":{"id":1168269,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d3/8d/f4ab1eab.jpg","nickname":"zero","note":"","ucode":"B5D2A838392DF2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211261,"discussion_content":"不错的学习资料","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584834218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}