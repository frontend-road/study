{"id":740828,"title":"第 21 章 宏","content":"\n<blockquote>\n<p>cento（来自拉丁语，意为“拼凑而成”）是一种完全由引自其他诗人的诗句组成的诗。</p>\n<p style=\"text-align: right\">——Matt Madden</p>\n</blockquote>\n<p>&nbsp;</p>\n<p>Rust 支持<strong>宏</strong>。宏是一种扩展语言的方式，它能做到单纯用函数无法做到的一些事。例如，我们已经见过 <code>assert_eq!</code> 宏，它是用于测试的好工具：</p>\n<pre class=\"code-rows\"><code>assert_eq!(gcd(6, 10), 2);</code></pre>\n<p>这也可以写成泛型函数，但是 <code>assert_eq!</code> 宏能做到一些无法用函数做到的事。一是当断言失败时，<code>assert_eq!</code> 会生成一条错误消息，其中包含断言的文件名和行号。函数无法获取这些信息，而宏可以，因为它们的工作方式完全不同。</p>\n<p>宏是一种简写形式。在编译期间，在检查类型并生成任何机器码之前，每个宏调用都会被<strong>展开</strong>。也就是说，每个宏调用都会被替换成一些 Rust 代码。前面的宏调用展开后大致如下所示：</p>\n<pre class=\"code-rows\"><code>match (&amp;gcd(6, 10), &amp;2) {\n    (left_val, right_val) =&gt; {\n        if !(*left_val == *right_val) {\n            panic!(\"assertion failed: `(left == right)`, \\\n                    (left: `{:?}`, right: `{:?}`)\", left_val, right_val);\n        }\n    }\n}</code></pre>\n<p><code>panic!</code> 也是一个宏，它本身可以展开为更多的 Rust 代码（此处未展示）。这些代码使用了另外两个宏，即 <code>file!()</code> 和 <code>line!()</code>。一旦 crate 中的每个宏调用都已完全展开，Rust 就会进入下一个编译阶段。</p>\n<p>在运行期，断言失败时是这样的（同时指出了 <code>gcd()</code> 函数中存在 bug，因为 <code>2</code> 才是正确答案）：</p>\n<pre class=\"code-rows\"><code>thread 'main' panicked at 'assertion failed: `(left == right)`, (left: `17`,\nright: `2`)', gcd.rs:7</code></pre>\n<p>如果你是 C++ 用户，那么可能对宏有过一些不好的体验。Rust 宏采用了完全不同的设计，类似于 Scheme 的 <code>syntax-rules</code>。与 C++ 宏相比，Rust 宏能与语言的其余部分更好地集成，因此更不容易出错。宏调用总是标有感叹号，因此在你阅读代码时很容易发现它们，并且当你想要调用函数时也不会意外调用它们。Rust 宏永远不会插入不匹配的方括号或圆括号，它们天生支持模式匹配，因此编写既可维护又易于使用的宏非常容易。</p><!-- [[[read_end]]] -->\n<p>本章会使用几个简单的示例来展示如何编写宏。与 Rust 的大部分内容一样，深入理解宏会获得回报，因此我们将设计一个更复杂的宏，以将 JSON 字面量直接嵌入程序中。但是，由于本书并不能涵盖宏的所有内容，因此本章将在结尾处提供一些指导，以便你进一步学习，内容包括这里展示的这些工具的高级技术，以及称为<strong>过程宏</strong>的更强大的机制。</p>\n<h2 id=\"nav_point_428\">21.1　宏基础</h2>\n<p>图 21-1 展示了 <code>assert_eq!</code> 宏的部分源代码。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00894.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 21-1：<code>assert_eq!</code> 宏</strong></p>\n<p><code>macro_rules!</code> 是在 Rust 中定义宏的主要方式。请注意，这个宏定义中的 <code>assert_eq</code> 之后没有 <code>!</code>：只有调用宏时才要用到 <code>!</code>，定义宏时不用。</p>\n<p>但并非所有的宏都是这样定义的：有一些宏是内置于编译器中的，比如 <code>file!</code>、<code>line!</code> 和 <code>macro_rules!</code>。本章会在结尾处讨论另一种方法，称为过程宏。但在本章的大部分内容里，我们会聚焦于 <code>macro_rules!</code>，这是迄今为止编写宏的最简单方式。</p>\n<p>使用 <code>macro_rules!</code> 定义的宏完全借助“模式匹配”方式发挥作用。宏的主体只是一系列规则：</p>\n<pre>\n( <i>pattern1</i> ) =&gt; ( <i>template1</i> );\n\n( <i>pattern2</i> ) =&gt; ( <i>template2</i> );\n\n...\n</pre>\n\n<p>图 21-1 中的 <code>assert_eq!</code> 版本只有一个模式和一个模板。</p>\n<p>另外，可以在模式或模板周围随意使用方括号或花括号来代替圆括号，这对 Rust 没有影响。同样，在调用宏时，下面这些都是等效的：</p>\n<pre class=\"code-rows\"><code>assert_eq!(gcd(6, 10), 2);\nassert_eq![gcd(6, 10), 2];\nassert_eq!</code></pre>\n<p>唯一的区别是花括号后面的分号通常是可选的。按照惯例，在调用 <code>assert_eq!</code> 时使用圆括号，在调用 <code>vec!</code> 时使用方括号，而在调用 <code>macro_rules!</code> 时使用花括号。</p>\n<p>刚才我们展示了一个宏展开的简单例子和用来生成它的宏定义，接下来会深入了解实现这些所需的必要细节。</p>\n<ul>\n<li>详细解释 Rust 是如何在程序中查找和展开宏定义的。</li>\n<li>指出从宏模板生成代码的过程中固有的一些微妙细节。</li>\n<li>展示模式是如何处理重复性结构的。</li>\n</ul>\n<h3 id=\"nav_point_429\">21.1.1　宏展开的基础</h3>\n<p>Rust 在编译期间的很早阶段就展开了宏。编译器会从头到尾阅读你的源代码，定义并展开宏。你不能在定义宏之前就调用它，因为 Rust 在查看程序的其余部分之前就已经展开了每个宏调用。（相比之下，函数和其他语法项则不必按任何特定顺序排列。调用一个稍后才会在其 crate 中定义的函数是完全可行的。）</p>\n<p>Rust 展开 <code>assert_eq!</code> 宏调用的过程与对 <code>match</code> 表达式求值很像。Rust 会首先将参数与模式进行匹配，如图 21-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00895.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 21-2：展开宏的第一部分：对参数做模式匹配</strong></p>\n<p>宏模式是 Rust 中的一种迷你语言。它们本质上是用来匹配代码的正则表达式。不过正则表达式操作的是字符，而模式操作的是语法标记（Token，包括数值、名称、标点符号等），这些语法标记是 Rust 程序的基础构造块。这意味着可以在宏模式中自由使用注释和空白字符，以尽量提高模式的可读性。因为注释和空白字符不是语法标记，所以不会影响匹配。</p>\n<p>正则表达式和宏模式之间的另一个重要区别是圆括号、方括号和花括号在 Rust 中总是成对出现。Rust 会在展开宏之前进行检查，不仅仅在宏模式中检查，而且会贯穿整个语言。</p>\n<p>在此示例中，我们的模式包含<strong>片段</strong> <code>$left:expr</code>，它告诉 Rust 要匹配一个表达式（在本例中是 <code>gcd(6, 10)</code>）并将其命名为 <code>$left</code>。然后 Rust 会将模式中的逗号与 <code>gcd</code> 的参数后面的逗号进行匹配。就像正则表达式一样，模式中只有少数特殊字符会触发有意义的匹配行为；其他字符，比如逗号，则必须逐字匹配，否则匹配就会失败。最后，Rust 会匹配表达式 <code>2</code> 并将其命名为 <code>$right</code>。</p>\n<p>这个模式中的两个代码片段都是 <code>expr</code> 类型的，表示它们期待表达式。21.4.1 节会展示其他类型的代码片段。</p>\n<p>因为这个模式已经匹配到了所有的参数，所以 Rust 展开了相应的<strong>模板</strong>，如图 21-3 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00896.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 21-3：展开宏的第二部分：填充模板</strong></p>\n<p>Rust 会将 <code>$left</code> 和 <code>$right</code> 替换为它在匹配过程中找到的代码片段。</p>\n<p>在输出模板中包含片段类型（比如写成 <code>$left:expr</code> 而不仅是 <code>$left</code>）是一个常见的错误。Rust 不会立即检测到这种错误。它会将 <code>$left</code> 视为替代品，然后将 <code>:expr</code> 视为模板中的其他内容——要包含在宏输出中的语法标记。所以宏在被<strong>调用</strong>之前不会发生错误，然而它将生成实际无法编译的伪输出。如果在使用新宏时收到像 <code>cannot find type 'expr' in this scope</code> 和 <code>help: maybe you meant to use a path separator here</code> 这样的错误消息，请检查是否存在这种错误。（21.3 节为此类情况提供了更一般化的建议。）</p>\n<p>宏模板与 Web 编程中常用的十几种模板语言没有太大差别，唯一的差别（也是重大差别）是它输出的是 Rust 代码。</p>\n<h3 id=\"nav_point_430\">21.1.2　意外后果</h3>\n<p>将代码片段插入模板与用来处理值的常规代码略有不同。这些差异起初并不明显。我们一直在讲的宏 <code>assert_eq!</code> 就包含一些略显奇怪的代码，其原因大部分和宏编程有关。我们重点看看其中两个比较有意思的部分。</p>\n<p>首先，为什么这个宏会创建变量 <code>left_val</code> 和 <code>right_val</code>？为什么不能将模板简化成下面这样呢？</p>\n<pre class=\"code-rows\"><code>if !($left == $right) {\n    panic!(\"assertion failed: `(left == right)` \\\n            (left: `{:?}`, right: `{:?}`)\", $left, $right)\n}</code></pre>\n<p>要回答这个问题，请尝试在心里展开宏调用 <code>assert_eq!(letters.pop(), Some('z'))</code>。它的输出会是什么呢？自然，Rust 会将匹配的表达式插入模板中的多个位置。但是，在构建错误消息时重新计算表达式似乎是个坏主意，不仅仅是因为需要花两倍的时间，更是因为这会导致第二次调用后它的值发生变化（因为 <code>letters.pop()</code> 会从向量中移除一个值）。这就是为什么真正的宏只会计算一次 <code>$left</code> 和 <code>$right</code> 并存储它们的值。</p>\n<p>继续第二个问题：为什么这个宏会借用对 <code>$left</code> 值和 <code>$right</code> 值的引用？为什么不像下面这样将值存储在变量中？</p>\n<pre class=\"code-rows\"><code>macro_rules! bad_assert_eq {\n    ($left:expr, $right:expr) =&gt; ({\n        match ($left, $right) {\n            (left_val, right_val) =&gt; {\n                if !(left_val == right_val) {\n                    panic!(\"assertion failed\" /* ... */);\n                }\n            }\n        }\n    });\n}</code></pre>\n<p>对于我们一直在考虑的这个特定情况（宏参数是整数），这当然会正常工作。但是，如果调用者将一个 <code>String</code> 变量作为 <code>$left</code> 或 <code>$right</code> 传递，则上述代码会将该值移动出变量。</p>\n<pre class=\"code-rows\"><code>fn main() {\n    let s = \"a rose\".to_string();\n    bad_assert_eq!(s, \"a rose\");\n    println!(\"confirmed: {} is a rose\", s);  // 错误：使用了已移动出去的值 \"s\"\n}</code></pre>\n<p>我们不希望断言移动值，因此这个宏改成了借入引用。</p>\n<p>（你可能想知道为什么这个宏要使用 <code>match</code> 而不是 <code>let</code> 来定义变量。嗯……我们也想知道。事实证明这样做没有特别的原因。使用 <code>let</code> 也可以达到同样的效果。）</p>\n<p>简而言之，宏可以做一些令人惊讶的事情。如果在你编写的宏周围发生了某些奇怪的事，那么很可能就是宏造成的。</p>\n<p>你<strong>肯定不会</strong>看到下面这个经典的 C++ 宏 bug：</p>\n<pre class=\"code-rows\"><code>// 有bug的C++宏：把数值n加上1\n#define ADD_ONE(n) n + 1</code></pre>\n<p>由于大多数 C++ 程序员很熟悉，因而不值得在这里展开解释的原因，对于像 <code>ADD_ONE(1) * 10</code> 或 <code>ADD_ONE(1 &lt;&lt; 4)</code> 这样不起眼的代码，使用这个宏会产生令人非常吃惊的结果。要修复这个 bug，就要在宏定义中添加更多圆括号。这在 Rust 中是不必要的，因为 Rust 宏能更好地与语言集成。Rust 知道自己什么时候是在处理表达式，因此在将一个表达式粘贴到另一个表达式时能有效地添加合理的圆括号。</p>\n<h3 id=\"nav_point_431\">21.1.3　重复</h3>\n<p>标准的 <code>vec!</code> 宏有两种形式：</p>\n<pre class=\"code-rows\"><code>// 把一个值重复N次\nlet buffer = vec![0_u8; 1000];\n\n// 由逗号分隔的值列表\nlet numbers = vec![\"udon\", \"ramen\", \"soba\"];</code></pre>\n<p>它可以这样实现：</p>\n<pre class=\"code-rows\"><code>macro_rules! vec {\n    ($elem:expr ; $n:expr) =&gt; {\n        ::std::vec::from_elem($elem, $n)\n    };\n    ( $( $x:expr ),* ) =&gt; {\n        &lt;[_]&gt;::into_vec(Box::new([ $( $x ),* ]))\n    };\n    ( $( $x:expr ),+ ,) =&gt; {\n        vec![ $( $x ),* ]\n    };\n}</code></pre>\n<p>这里有 3 条规则。我们将解释“多规则”宏的工作原理，然后再依次查看每条规则。</p>\n<p>Rust 在展开像 <code>vec![1, 2, 3]</code> 这样的宏调用时，会先尝试将参数 <code>1, 2, 3</code> 与第一条规则的模式相匹配，在本例中就是 <code>$elem:expr ; $n:expr</code>。这无法匹配上，因为 <code>1</code> 是一个表达式，但模式要求其后有一个分号，而这里没有。所以 Rust 继续匹配第二条规则，以此类推。如果没有匹配任何规则，则视为错误。</p>\n<p>第一条规则处理像 <code>vec![0u8; 1000]</code> 这样的用法。碰巧标准库（但未写入文档）函数 <code>std::vec::from_elem</code> 完全满足这里的需要，所以这条规则是显而易见的。</p>\n<p>第二条规则处理 <code>vec![\"udon\", \"ramen\", \"soba\"]</code>。<code>$( $x:expr ),*</code> 模式使用了我们从未见过的一个特性：重复。它会匹配 0 个或多个表达式，以逗号分隔。更一般地说，语法 <code>$( PATTERN ),*</code> 可用于匹配任何以逗号分隔的列表，其中列表的每个条目都会匹配 <code>PATTERN</code>。</p>\n<p>这里的 <code>*</code> 与正则表达式中的 <code>*</code> 具有相同的含义（“0 或更多”），只是公认的正则表达式中并没有特殊的 <code>,*</code> 重复器。还可以使用 <code>+</code> 要求至少匹配一次，或者使用 <code>?</code> 要求有 0 个或 1 个匹配项。表 21-1 给出了全套的重复模式。</p>\n<p><strong>表 21-1：重复模式</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>模式</p></th>\n<th><p>含义</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>$( ... )*</code></p></td>\n<td><p>匹配 0 次或多次，没有分隔符</p></td>\n</tr>\n<tr>\n<td><p><code>$( ... ),*</code></p></td>\n<td><p>匹配 0 次或多次，以逗号分隔</p></td>\n</tr>\n<tr>\n<td><p><code>$( ... );*</code></p></td>\n<td><p>匹配 0 次或多次，以分号分隔</p></td>\n</tr>\n<tr>\n<td><p><code>$( ... )+</code></p></td>\n<td><p>匹配 1 次或多次，没有分隔符</p></td>\n</tr>\n<tr>\n<td><p><code>$( ... ),+</code></p></td>\n<td><p>匹配 1 次或多次，以逗号分隔</p></td>\n</tr>\n<tr>\n<td><p><code>$( ... );+</code></p></td>\n<td><p>匹配 1 次或多次，以分号分隔</p></td>\n</tr>\n<tr>\n<td><p><code>$( ... )?</code></p></td>\n<td><p>匹配 0 次或 1 次，没有分隔符</p></td>\n</tr>\n</tbody>\n</table>\n<p>代码片段 <code>$x</code> 不是单个表达式，而是一个表达式列表。这条规则的模板也使用了重复语法：</p>\n<pre class=\"code-rows\"><code>&lt;[_]&gt;::into_vec(Box::new([ $( $x ),* ]))</code></pre>\n<p>同样，有一些标准库方法可以完全满足我们的需要。此代码会创建一个 Box 数组，然后使用 <code>[T]::into_vec</code> 方法将 Box 数组转换为向量。</p>\n<p>第一个代码片段 <code>&lt;[_]&gt;</code> 是用于编写“某物的切片”类型的一种不寻常的方式，它会期待 Rust 推断出元素类型。那些名称为普通标识符的类型可以不经任何修改直接用在表达式中，但是像 <code>fn()</code>、<code>&amp;str</code> 或 <code>[_]</code> 这样的特殊类型必须用尖括号括起来。</p>\n<p>重复要出现在模板的末尾，在我们这里是 <code>$($x),*</code>。这个 <code>$(...),*</code> 与我们在模式中看到的语法是一样的。它会遍历我们为 <code>$x</code> 匹配出的表达式列表，并将它们全部插入模板中，以逗号分隔。</p>\n<p>在这个例子中，重复输出看起来和重复输入差不多。但事实并非如此。也可以这样写规则：</p>\n<pre class=\"code-rows\"><code>( $( $x:expr ),* ) =&gt; {\n    {\n        let mut v = Vec::new();\n        $( v.push($x); )*\n        v\n    }\n};</code></pre>\n<p>在这里，模板中读取 <code>$( v.push($x); )*</code> 的部分会为 <code>$x</code> 中的每个表达式插入对 <code>v.push()</code> 的调用。宏里的分支可以展开为一系列表达式，但这里只需要一个表达式，所以要把向量的集合包装在一个块中。</p>\n<p>与 Rust 的其余部分不同，使用 <code>$( ... ),*</code> 的模式不会自动支持可选的尾随逗号。但是，有一个标准技巧，即通过添加额外的规则来支持尾随逗号。这正是 <code>vec!</code> 宏的第三条规则的作用：</p>\n<pre class=\"code-rows\"><code>( $( $x:expr ),+ ,) =&gt; {  // 如果出现了尾随逗号，\n    vec![ $( $x ),* ]     // 就按没有这个逗号时的样子重试\n};</code></pre>\n<p>我们使用 <code>$( ... ),+ ,</code> 来匹配带有额外逗号的列表。然后在模板中递归地调用 <code>vec!</code>，并剥离额外的逗号。这次会匹配上第二条规则。</p>\n<h2 id=\"nav_point_432\">21.2　内置宏</h2>\n<p>Rust 编译器提供了几个内置宏，它们在你定义自己的宏时很有用。这些宏都不能使用 <code>macro_rules!</code> 来实现。它们是硬编码在 <code>rustc</code> 中的。</p>\n<blockquote>\n<p><code>file!()</code>（文件名）、<code>line!()</code>（行号）和 <code>column!()</code>（列号）</p>\n</blockquote>\n<p><code>file!()</code> 会展开为字符串字面量，即当前文件名。<code>line!()</code> 和 <code>column!()</code> 会展开为 <code>u32</code> 字面量，以给出当前行号和列号（从 1 开始计数）。</p>\n<p>如果一个宏调用了另一个宏，后者又调用了别的宏，并且最后一个宏调用了 <code>file!()</code>、<code>line!()</code> 或 <code>column!()</code>，而它们都在不同的文件中，则最终展开之后的结果指示的是<strong>第一个</strong>宏所在的位置。</p>\n<blockquote>\n<p><code>stringify!(...tokens...)</code>（代码字符串）</p>\n</blockquote>\n<p>该宏会展开为包含给定语法标记的字符串字面量。<code>assert!</code> 宏会使用它来生成包含断言代码的错误消息。</p>\n<p>它的参数中的宏调用<strong>不会</strong>展开，比如 <code>stringify!(line!())</code> 会展开为字符串 <code>\"line!()\"</code>。</p>\n<p>Rust 会从这些语法标记构造出字符串，因此字符串中没有换行符或注释（因为它们都不是语法标记）。</p>\n<blockquote>\n<p><code>concat!(str0, str1, ...)</code>（串联）</p>\n</blockquote>\n<p>该宏会通过串联它的各个参数展开为单个字符串字面量。</p>\n<p>Rust 还定义了下面这些用于查询构建环境的宏。</p>\n<blockquote>\n<p><code>cfg!(...)</code>（配置）</p>\n</blockquote>\n<p>该宏会展开为布尔常量，如果当前正构建的配置与圆括号中的条件匹配则为 <code>true</code>。如果在启用了调试断言的情况下进行编译，则 <code>cfg!(debug_assertions)</code> 为 <code>true</code>。</p>\n<p>这个宏支持与 8.5 节所讲的 <code>#[cfg(...)]</code> 属性完全相同的语法，但其结果不是条件编译，而是给出像 <code>true</code> 或 <code>false</code> 这样的答案。</p>\n<blockquote>\n<p><code>env!(\"VAR_NAME\")</code>（环境变量）</p>\n</blockquote>\n<p>展开为字符串，即在编译期指定的环境变量的值。如果该变量不存在，则为编译错误。</p>\n<p>Cargo 会在编译 crate 时设置几个有实质性内容的环境变量，这样此宏才有价值。例如，要获取 crate 的当前版本字符串，可以这样写：</p>\n<pre class=\"code-rows\"><code>let version = env!(\"CARGO_PKG_VERSION\");</code></pre>\n<p>Cargo 文档中有这些环境变量的完整列表。</p>\n<blockquote>\n<p><code>option_env!(\"VAR_NAME\")</code>（可选环境变量）</p>\n</blockquote>\n<p>和 <code>env!</code> 基本一样，不过该宏会返回 <code>Option&lt;&amp;'static str&gt;</code>，如果没有设置指定的变量，则返回 <code>None</code>。</p>\n<p>以下 3 个内置宏支持从另一个文件中引入代码或数据。</p>\n<blockquote>\n<p><code>include!(\"file.rs\")</code>（包含代码文件）</p>\n</blockquote>\n<p>该宏会展开为指定文件的内容，这个文件必须是有效的 Rust 代码——表达式或语法项的序列。</p>\n<blockquote>\n<p><code>include_str!(\"file.txt\")</code>（包含字符串）</p>\n</blockquote>\n<p>该宏会展开为包含指定文件中文本的 <code>&amp;'static str</code>。可以像这样使用它：</p>\n<pre class=\"code-rows\"><code>const COMPOSITOR_SHADER: &amp;str =\n    include_str!(\"../resources/compositor.glsl\");</code></pre>\n<p>如果文件不存在或不是有效的 UTF-8 格式，你将收到编译错误。</p>\n<blockquote>\n<p><code>include_bytes!(\"file.dat\")</code>（包含一些字节）</p>\n</blockquote>\n<p>和上一个宏基本相同，不过该宏会把文件视为二进制数据而非 UTF-8 文本。结果是 <code>&amp;'static [u8]</code>。</p>\n<p>与所有宏一样，这些内置宏也都在编译期处理。如果文件不存在或无法读取，则编译失败。它们不会在运行期失败。在任何情况下，如果文件名是相对路径，就会相对于当前文件所在的目录进行解析。</p>\n<p>Rust 还提供了几个我们未曾涉及的便捷宏。</p>\n<blockquote>\n<p><code>todo!()</code>（待做）和 <code>unimplemented!()</code>（未实现）</p>\n</blockquote>\n<p>这两个宏的作用相当于 <code>panic!()</code>，但传达了不同的意图。<code>unimplemented!()</code> 适用于 <code>if</code> 子句、<code>match</code> 分支和其他尚未处理的情况。它总会 panic。<code>todo!()</code> 大致相同，但传达了这样的想法，即这段代码还没有编写，一些 IDE 会对其进行标记以提请关注。</p>\n<blockquote>\n<p><code>matches!(value, pattern)</code>（匹配）</p>\n</blockquote>\n<p>将值与模式进行比较，如果匹配就返回 <code>true</code>，否则返回 <code>false</code>。类似于如下写法：</p>\n<pre class=\"code-rows\"><code>match value {\n  pattern =&gt; true,\n  _ =&gt; false\n}</code></pre>\n<p>如果你正在寻求编写基本宏的练习，那么该宏是一个很好的复刻目标——特别是你可以直接在标准库文档中找到它的源代码，其实现非常简单。</p>\n<h2 id=\"nav_point_433\">21.3　调试宏</h2>\n<p>调试率性而为的宏颇具挑战性。最大的问题是宏展开过程缺乏可见性。Rust 经常会展开所有宏，在发现某种错误后打印一条错误消息，但不会展示包含该错误的完全展开后的代码。</p>\n<p>以下是 3 个有助于解决宏问题的工具。（这些特性都还不稳定，但由于它们实际上是为了在开发过程中使用而设计的，而不会出现在要签入的代码中，因此这在实践中并不是什么大问题。）</p>\n<p>第一，也是最简单的，可以让 <code>rustc</code> 展示代码在展开所有宏后的样子。使用 <code>cargo build --verbose</code> 查看 Cargo 如何调用 <code>rustc</code>。复制 <code>rustc</code> 命令行并添加 <code>-Z unstable-options --pretty expanded</code> 选项。完全展开的代码将转储到终端。很遗憾，只有当代码没有语法错误时才能这样做。</p>\n<p>第二，Rust 提供了一个 <code>log_syntax!()</code> 宏，它只会在编译期将自己的参数打印到终端。你可以将其用于 <code>println!</code> 式调试。此宏需要添加 <code>#![feature(log_syntax)]</code> 特性标志。</p>\n<p>第三，可以要求 Rust 编译器把所有宏调用记录到终端。在代码中的某个地方插入 <code>trace_macros!(true);</code>。从那时起，每当 Rust 展开宏时，它都会打印宏的名称和各个参数。例如，考虑下面这个程序：</p>\n<pre class=\"code-rows\"><code>#![feature(trace_macros)]\n\nfn main() {\n    trace_macros!(true);\n    let numbers = vec![1, 2, 3];\n    trace_macros!(false);\n    println!(\"total: {}\", numbers.iter().sum::&lt;u64&gt;());\n}</code></pre>\n<p>它会生成这样的输出：</p>\n<pre class=\"code-rows\"><code>$ rustup override set nightly\n...\n$ rustc trace_example.rs\nnote: trace_macro\n --&gt; trace_example.rs:5:19\n  |\n5 |     let numbers = vec![1, 2, 3];\n  |                   ^^^^^^^^^^^^^\n  |\n  = note: expanding `vec! { 1 , 2 , 3 }`\n  = note: to `&lt; [ _ ] &gt; :: into_vec ( box [ 1 , 2 , 3 ] )`</code></pre>\n<p>编译器会展示每个宏调用的代码，既包括展开前的也包括展开后的。<code>trace_macros!(false);</code> 这一行再次关闭了跟踪，因此不会跟踪对 <code>println!()</code> 的调用。</p>\n<h2 id=\"nav_point_434\">21.4　构建 <code>json!</code> 宏</h2>\n<p>我们已经讨论过了 <code>macro_rules!</code> 的核心特性。本节将逐步开发用于构建 JSON 数据的宏。我们将使用这个例子来展示宏的开发过程，同时会介绍 <code>macro_rules!</code> 剩下的几个特性，并就如何确保你的宏如预期般运行提供一些建议。</p>\n<p>回想第 10 章，我们介绍过下面这个用于表示 JSON 数据的枚举：</p>\n<pre class=\"code-rows\"><code>#[derive(Clone, PartialEq, Debug)]\nenum Json {\n    Null,\n    Boolean(bool),\n    Number(f64),\n    String(String),\n    Array(Vec&lt;Json&gt;),\n    Object(Box&lt;HashMap&lt;String, Json&gt;&gt;)\n}</code></pre>\n<p>遗憾的是，编写 <code>Json</code> 值的语法相当冗长：</p>\n<pre class=\"code-rows\"><code>let students = Json::Array(vec![\n    Json::Object(Box::new(vec![\n        (\"name\".to_string(), Json::String(\"Jim Blandy\".to_string())),\n        (\"class_of\".to_string(), Json::Number(1926.0)),\n        (\"major\".to_string(), Json::String(\"Tibetan throat singing\".to_string()))\n    ].into_iter().collect())),\n    Json::Object(Box::new(vec![\n        (\"name\".to_string(), Json::String(\"Jason Orendorff\".to_string())),\n        (\"class_of\".to_string(), Json::Number(1702.0)),\n        (\"major\".to_string(), Json::String(\"Knots\".to_string()))\n    ].into_iter().collect()))\n]);</code></pre>\n<p>我们希望使用更具 JSON 风格的语法来编写：</p>\n<pre class=\"code-rows\"><code>let students = json!([\n    {\n        \"name\": \"Jim Blandy\",\n        \"class_of\": 1926,\n        \"major\": \"Tibetan throat singing\"\n    },\n    {\n        \"name\": \"Jason Orendorff\",\n        \"class_of\": 1702,\n        \"major\": \"Knots\"\n    }\n]);</code></pre>\n<p>我们想要的是一个将 JSON 值作为参数并展开为 Rust 表达式的 <code>json!</code> 宏，就像上面示例中的那样。</p>\n<h3 id=\"nav_point_435\">21.4.1　片段类型</h3>\n<p>如果想编写一个复杂的宏，那么第一项工作是弄清楚如何匹配或<strong>解析</strong>所期望的输入。</p>\n<p>我们可以预见 <code>Json</code> 宏内部将会有多条规则，因为 JSON 数据有多种类型：对象、数组、数值等。事实上，我们可以合理地猜测每种 JSON 类型都将有一条规则：</p>\n<pre class=\"code-rows\"><code>macro_rules! json {\n    (null)    =&gt; { Json::Null };\n    ([ ... ]) =&gt; { Json::Array(...) };\n    ({ ... }) =&gt; { Json::Object(...) };\n    (???)     =&gt; { Json::Boolean(...) };\n    (???)     =&gt; { Json::Number(...) };\n    (???)     =&gt; { Json::String(...) };\n}</code></pre>\n<p>然而这不太正确，因为宏模式无法区分最后 3 种情况，稍后我们会讨论如何处理。至于前 3 种情况，显然它们是以不同的语法标记开始的，所以我们先从它们开始讨论。</p>\n<p>第一条规则已经奏效：</p>\n<pre class=\"code-rows\"><code>macro_rules! json {\n    (null) =&gt; {\n        Json::Null\n    }\n}\n\n#[test]\nfn json_null() {\n    assert_eq!(json!(null), Json::Null);  // 通过！\n}</code></pre>\n<p>要添加对 JSON 数组的支持，可以尝试将这些元素匹配为 <code>expr</code>：</p>\n<pre class=\"code-rows\"><code>macro_rules! json {\n    (null) =&gt; {\n        Json::Null\n    };\n    ([ $( $element:expr ),* ]) =&gt; {\n        Json::Array(vec![ $( $element ),* ])\n    };\n}</code></pre>\n<p>很遗憾，这无法匹配所有 JSON 数组。下面是阐明此问题的一个测试：</p>\n<pre class=\"code-rows\"><code>#[test]\nfn json_array_with_json_element() {\n    let macro_generated_value = json!(\n        [\n            // 无法匹配`$element:expr`的有效JSON\n            {\n                \"pitch\": 440.0\n            }\n        ]\n    );\n    let hand_coded_value =\n        Json::Array(vec![\n            Json::Object(Box::new(vec![\n                (\"pitch\".to_string(), Json::Number(440.0))\n            ].into_iter().collect()))\n        ]);\n    assert_eq!(macro_generated_value, hand_coded_value);\n}</code></pre>\n<p>模式 <code>$( $element:expr ),*</code> 表示“以逗号分隔的 Rust 表达式列表”。但是许多 JSON 值，尤其是对象，并不是有效的 Rust 表达式。它们无法匹配。</p>\n<p>既然待匹配的每一小段代码并不一定都是表达式，那么 Rust 就肯定要支持另外几种片段类型，如表 21-2 所示。</p>\n<p><strong>表 21-2：<code>macro_rules!</code> 支持的片段类型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>片段类型</p></th>\n<th><p>匹配（带例子）</p></th>\n<th><p>后面可以跟……</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>expr</code></p></td>\n<td><p>表达式：<br /><code>2 + 2</code>、<code>\"udon\"</code>、<code>x.len()</code></p></td>\n<td><p><code>=&gt;</code>,<code>;</code></p></td>\n</tr>\n<tr>\n<td><p><code>stmt</code></p></td>\n<td><p>表达式或声明，不包括任何尾随分号（很难用，请尝试使用 <code>expr</code> 或 <code>block</code>）</p></td>\n<td><p><code>=&gt;</code>,<code>;</code></p></td>\n</tr>\n<tr>\n<td><p><code>ty</code></p></td>\n<td><p>类型：<br /><code>String</code>、<code>Vec&lt;u8&gt;</code>、<code>(&amp;str, bool)</code>、<code>dyn Read + Send</code></p></td>\n<td><p><code>=&gt;</code>,<code>; =| { [ : &gt; as where</code></p></td>\n</tr>\n<tr>\n<td><p><code>path</code></p></td>\n<td><p>路径（参见 8.2.3 节）：<br /><code>ferns</code>、<code>::std::sync::mpsc</code></p></td>\n<td><p><code>=&gt;</code>,<code>; = | { [ : &gt; as where</code></p></td>\n</tr>\n<tr>\n<td><p><code>pat</code></p></td>\n<td><p>模式（参见 10.2 节）：<br /><code>_</code> , <code>Some(ref x)</code></p></td>\n<td><p><code>=&gt;</code>,<code>= | if in</code></p></td>\n</tr>\n<tr>\n<td><p><code>item</code></p></td>\n<td><p>语法项（参见 6.4 节）：<br /><code>struct Point { x: f64, y: f64 }</code> , <code>mod ferns</code>;</p></td>\n<td><p>任意</p></td>\n</tr>\n<tr>\n<td><p><code>block</code></p></td>\n<td><p>块（参见 6.3 节）：<br /><code>{ s += \"ok\\n\"; true }</code></p></td>\n<td><p>任意</p></td>\n</tr>\n<tr>\n<td><p><code>meta</code></p></td>\n<td><p>属性的主体（参见 8.5 节）：<br /><code>inline</code> , <code>derive(Copy, Clone)</code> , <code>doc=\"3D models.\"</code></p></td>\n<td><p>任意</p></td>\n</tr>\n<tr>\n<td><p><code>literal</code></p></td>\n<td><p>字面量值：<br /><code>1024</code>，<code>\"Hello, world!\"</code>, <code>1_000_000f64</code></p></td>\n<td><p>任意</p></td>\n</tr>\n<tr>\n<td><p><code>lifetime</code></p></td>\n<td><p>生命周期：<br /><code>'a</code>，<code>'item</code>，<code>'static</code></p></td>\n<td><p>任意</p></td>\n</tr>\n<tr>\n<td><p><code>vis</code></p></td>\n<td><p>可见性说明符：<br /><code>pub</code>、<code>pub(crate)</code>、<code>pub(in module::submodule)</code></p></td>\n<td><p>任意</p></td>\n</tr>\n<tr>\n<td><p><code>ident</code></p></td>\n<td><p>标识符：<br /><code>std</code>、<code>Json</code>、<code>longish_variable_name</code></p></td>\n<td><p>任意</p></td>\n</tr>\n<tr>\n<td><p><code>tt</code></p></td>\n<td><p>语法标记树（参见正文）：<br /><code>;</code>, <code>&gt;=</code> , <code>{}</code> , <code>[0 1 (+ 0 1)]</code></p></td>\n<td><p>任意</p></td>\n</tr>\n</tbody>\n</table>\n<p>表 21-2 中的大多数选项会严格执行 Rust 语法。<code>expr</code> 类型只会匹配 Rust 表达式（而不是 JSON 值），<code>ty</code> 只会匹配 Rust 类型，等等。这些选项都不可展开，即无法定义 <code>expr</code> 可以识别的新算术运算符或新关键字。所以无法让它们匹配任意 JSON 数据。</p>\n<p>最后两个选项（<code>ident</code> 和 <code>tt</code>）支持匹配看起来不像 Rust 代码的宏参数。<code>ident</code> 能匹配任何标识符。<code>tt</code> 能匹配单个<strong>语法标记树</strong>：正确匹配的一对括号，比如 <code>(...)</code>、<code>[...]</code> 或 <code>{...}</code>，以及位于两者之间的所有内容，包括嵌套的语法标记树，或者单独的非括号语法标记，比如 <code>1926</code> 或 <code>\"Knots\"</code>。</p>\n<p>看来语法标记树正是我们这个 <code>json!</code> 宏所需要的。每个 JSON 值都是一个语法标记树：数值、字符串、布尔值和 <code>null</code> 是单个语法标记，对象和数组则是有括号的语法标记。所以可以像下面这样写匹配模式：</p>\n<pre class=\"code-rows\"><code>macro_rules! json {\n    (null) =&gt; {\n        Json::Null\n    };\n    ([ $( $element:tt ),* ]) =&gt; {\n        Json::Array(...)\n    };\n    ({ $( $key:tt : $value:tt ),* }) =&gt; {\n        Json::Object(...)\n    };\n    ($other:tt) =&gt; {\n        ... // TODO: 返回Number、String或Boolean\n    };\n}</code></pre>\n<p>这个版本的 <code>json!</code> 宏可以匹配所有的 JSON 数据。现在只要生成正确的 Rust 代码就好了。</p>\n<p>为了使得将来在增加新特性的同时不破坏你今天编写的代码，Rust 限制模式中的语法标记必须出现在片断类型的后面。表 21-2 中的“后面可以跟……”那列展示了哪些语法标记是允许的。例如，模式 <code>$x:expr ~ $y:expr</code> 是错误的，因为不允许 <code>~</code> 跟在 <code>expr</code> 之后。模式 <code>$vars:pat =&gt; $handler:expr</code> 则是正确的，因为 <code>$vars:pat</code> 后面跟着箭头 <code>=&gt;</code>，这是 <code>pat</code> 允许的语法标记之一，而 <code>$handler:expr</code> 后面什么都没有，这总是允许的。</p>\n<h3 id=\"nav_point_436\">21.4.2　宏中的递归</h3>\n<p>我们已经看过宏调用自身的一个简单例子：<code>vec!</code> 的实现就使用了递归来支持尾随逗号。这里我们会展示一个更重要的例子：<code>json!</code> 需要递归调用自己。</p>\n<p>我们可能会尝试在不使用递归的情况下支持 JSON 数组，如下所示：</p>\n<pre class=\"code-rows\"><code>([ $( $element:tt ),* ]) =&gt; {\n    Json::Array(vec![ $( $element ),* ])\n};</code></pre>\n<p>但这是行不通的，因为这样做就会将 JSON 数据（<code>$element</code> 语法标记树）直接粘贴到 Rust 表达式中，而它们是两种不同的语言。</p>\n<p>因此，我们需要将数组的每个元素从 JSON 格式转换为 Rust。幸运的是，有一个宏可以执行此操作，也就是我们正在写的这个。</p>\n<pre class=\"code-rows\"><code>([ $( $element:tt ),* ]) =&gt; {\n    Json::Array(vec![ $( json!($element) ),* ])\n};</code></pre>\n<p>可以用相同的方式支持对象：</p>\n<pre class=\"code-rows\"><code>({ $( $key:tt : $value:tt ),* }) =&gt; {\n    Json::Object(Box::new(vec![\n        $( ($key.to_string(), json!($value)) ),*\n    ].into_iter().collect()))\n};</code></pre>\n<p>编译器会对宏施加递归限制：默认情况下最多递归 64 层。这对于 <code>json!</code> 这样的正常用法足够了，但复杂的递归宏有时会达到这个极限。可以通过在使用宏的 crate 顶部添加如下属性来调整它：</p>\n<pre class=\"code-rows\"><code>#![recursion_limit = \"256\"]</code></pre>\n<p>我们的 <code>json!</code> 宏接近完成了。剩下的就是支持布尔值、数值和字符串值。</p>\n<h3 id=\"nav_point_437\">21.4.3　将特型与宏一起使用</h3>\n<p>编写复杂的宏总会给人带来困惑。请务必记住，宏本身并不是你可以使用的唯一解谜工具。</p>\n<p>在这里，我们需要支持 <code>json!(true)</code>、<code>json!(1.0)</code> 和 <code>json!(\"yes\")</code>，将值（无论它是什么）转换为适当类型的 <code>Json</code> 值。但是宏并不擅长区分类型。可以想象像下面这样写：</p>\n<pre class=\"code-rows\"><code>macro_rules! json {\n    (true) =&gt; {\n        Json::Boolean(true)\n    };\n    (false) =&gt; {\n        Json::Boolean(false)\n    };\n    ...\n}</code></pre>\n<p>这种方法马上就会失效。如果只有两个布尔值，这样写当然没问题。但可能还有更多数值，甚至更多字符串，那时候就不能再这样写了。</p>\n<p>幸运的是，有一种标准库方法可以将各种类型的值转换为一种指定类型，它就是 <code>From</code> 特型（参见 13.9 节）。我们只需要为少数几种类型实现这个特型：</p>\n<pre class=\"code-rows\"><code>impl From&lt;bool&gt; for Json {\n    fn from(b: bool) -&gt; Json {\n        Json::Boolean(b)\n    }\n}\n\nimpl From&lt;i32&gt; for Json {\n    fn from(i: i32) -&gt; Json {\n        Json::Number(i as f64)\n    }\n}\n\nimpl From&lt;String&gt; for Json {\n    fn from(s: String) -&gt; Json {\n        Json::String(s)\n    }\n}\n\nimpl&lt;'a&gt; From&lt;&amp;'a str&gt; for Json {\n    fn from(s: &amp;'a str) -&gt; Json {\n        Json::String(s.to_string())\n    }\n}\n...</code></pre>\n<p>事实上，所有 12 种数值类型都有非常相似的实现，所以仅仅为了避免复制粘贴而编写一个宏也是合理的：</p>\n<pre class=\"code-rows\"><code>macro_rules! impl_from_num_for_json {\n    ( $( $t:ident )* ) =&gt; {\n        $(\n            impl From&lt;$t&gt; for Json {\n                fn from(n: $t) -&gt; Json {\n                    Json::Number(n as f64)\n                }\n            }\n        )*\n    };\n}\n\nimpl_from_num_for_json!(u8 i8 u16 i16 u32 i32 u64 i64 u128 i128\n                        usize isize f32 f64);</code></pre>\n<p>现在可以使用 <code>Json::from(value)</code> 将任何受支持类型的 <code>value</code> 转换为 <code>Json</code> 了。在我们的宏中，它看起来是这样的：</p>\n<pre class=\"code-rows\"><code>( $other:tt ) =&gt; {\n    Json::from($other)  // 处理布尔值、数值和字符串\n};</code></pre>\n<p>将这条规则添加到 <code>json!</code> 宏中，让它通过我们迄今已编写的所有测试。将所有部分放在一起，就变成了这样：</p>\n<pre class=\"code-rows\"><code>macro_rules! json {\n    (null) =&gt; {\n        Json::Null\n    };\n    ([ $( $element:tt ),* ]) =&gt; {\n        Json::Array(vec![ $( json!($element) ),* ])\n    };\n    ({ $( $key:tt : $value:tt ),* }) =&gt; {\n        Json::Object(Box::new(vec![\n            $( ($key.to_string(), json!($value)) ),*\n        ].into_iter().collect()))\n    };\n    ( $other:tt ) =&gt; {\n        Json::from($other)  // 处理布尔值、数值和字符串\n    };\n}</code></pre>\n<p>事实证明，宏出乎意料地支持在 JSON 数据中使用变量甚至任意 Rust 表达式，这是一个方便的额外特性：</p>\n<pre class=\"code-rows\"><code>let width = 4.0;\nlet desc =\n    json!({\n        \"width\": width,\n        \"height\": (width * 9.0 / 4.0)\n    });</code></pre>\n<p>因为 <code>(width * 9.0 / 4.0)</code> 被圆括号括起来了，所以它是一个单语法标记树，这样宏在解析对象时就能成功地将它与 <code>$value:tt</code> 匹配起来。</p>\n<h3 id=\"nav_point_438\">21.4.4　作用域界定与卫生宏</h3>\n<p>编写宏时一个非常棘手的问题是需要将来自不同作用域的代码粘贴在一起。所以接下来的内容涵盖了 Rust 处理作用域的两种方式：一种方式用于局部变量和参数，另一种方式用于其他一切。</p>\n<p>为了说明为什么这个问题很重要，我们来重写一下解析 JSON 对象的规则（前面展示的 <code>json!</code> 宏中的第三条规则）以消除临时向量。可以这样写：</p>\n<pre class=\"code-rows\"><code>({ $($key:tt : $value:tt),* }) =&gt; {\n    {\n        let mut fields = Box::new(HashMap::new());\n        $( fields.insert($key.to_string(), json!($value)); )*\n        Json::Object(fields)\n    }\n};</code></pre>\n<p>现在不是通过使用 <code>collect()</code> 而是通过重复调用 <code>.insert()</code> 方法来填充 <code>HashMap</code>。这意味着需要将此映射表存储在名为 <code>fields</code> 的临时变量中。</p>\n<p>但是如果调用 <code>json!</code> 时碰巧使用了自己的一个变量，而这个变量也叫 <code>fields</code>，会发生什么呢？</p>\n<pre class=\"code-rows\"><code>let fields = \"Fields, W.C.\";\nlet role = json!({\n    \"name\": \"Larson E. Whipsnade\",\n    \"actor\": fields\n});</code></pre>\n<p>展开宏会将两小段代码粘贴在一起，两者都使用 <code>fields</code> 这个名字，但表示不同的东西。</p>\n<pre class=\"code-rows\"><code>let fields = \"Fields, W.C.\";\nlet role = {\n    let mut fields = Box::new(HashMap::new());\n    fields.insert(\"name\".to_string(), Json::from(\"Larson E. Whipsnade\"));\n    fields.insert(\"actor\".to_string(), Json::from(fields));\n    Json::Object(fields)\n};</code></pre>\n<p>每当宏使用临时变量时，这似乎是一个无法回避的陷阱，你也许已经在考虑可能的修复方法了。也许应该重命名 <code>json!</code> 宏，以便定义其调用者不太可能传入的东西，比如可以叫 <code>__json$fields</code>。</p>\n<p>令人吃惊的是这个<strong>宏现在就能正常工作</strong>。Rust 会替你重命名此变量。这个特性是首先在 Scheme 语言的宏中实现的，被称为<strong>卫生的</strong>（hygiene），因此 Rust 被称为支持<strong>卫生宏</strong>（hygienic macro）的语言。</p>\n<p>理解卫生宏的最简单方法是想象每次展开宏时，来自宏本身的展开结果都会被涂上不同的颜色。</p>\n<p>然后，不同颜色的变量被视为具有不同的名称：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00897.jpeg\" alt=\"{%}\" /></p>\n<p>请注意，由宏调用者传入并粘贴到输出中的那点儿代码（如 <code>\"name\"</code> 和 <code>\"actor\"</code>）会保持其原始颜色（黑色）。这里只会对源自宏模板的语法标记进行染色。</p>\n<p>现在有一个名为 <code>fields</code> 的变量（在调用者中声明）和另一个同样名为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00898.jpeg\" alt=\"\" width=\"9%\" style=\"width: 9%\" inline-img=\"true\" /> 的变量（由宏引入）。由于名称是不同的颜色，因此这两个变量不会混淆。</p>\n<p>如果宏确实需要引用调用者作用域内的变量，则调用者必须将变量的名称传给宏。</p>\n<p>（染色的比喻并不是要准确描述卫生宏的工作原理。真正的机制甚至比这种方式更“聪明一点儿”。只要两个标识符引用的是位于宏及其调用者作用域内的公共变量，不管“染成了什么颜色”，都能识别出它们是相同的。但这种情况在 Rust 中很少见。如果你理解前面的例子，就知道该如何使用卫生宏了。）</p>\n<p>你可能已经注意到，随着宏的展开，许多其他标识符（比如 <code>Box</code>、<code>HashMap</code> 和 <code>Json</code>）被染上了不止一种颜色。虽然这些类型名称的颜色不同，但 Rust 仍然毫不费力地识别出了它们。那是因为 Rust 中的卫生工作仅限于局部变量和参数。对于常量、类型、方法、模块、静态值和宏名称，Rust 是“色盲”。</p>\n<p>这意味着如果我们的 <code>json!</code> 宏在尚未导入 <code>Box</code>、<code>HashMap</code> 或 <code>Json</code> 的模块中使用，那么宏就无法正常工作。21.4.5 节会展示如何避免这一问题。</p>\n<p>首先，需要考虑 Rust 的严格卫生机制构成某种障碍的情况，我们要解决这一问题。假设我们有很多包含下面这行代码的函数：</p>\n<pre class=\"code-rows\"><code>let req = ServerRequest::new(server_socket.session());</code></pre>\n<p>复制和粘贴这行代码很痛苦。可以改用宏吗？</p>\n<pre class=\"code-rows\"><code>macro_rules! setup_req {\n    () =&gt; {\n        let req = ServerRequest::new(server_socket.session());\n    }\n}\n\nfn handle_http_request(server_socket: &amp;ServerSocket) {\n    setup_req!();  // 使用`server_socket`来声明`req`\n    …… // 使用`req`的代码\n}</code></pre>\n<p>这样写是不行的。它需要宏中的名称 <code>server_socket</code> 来引用函数中声明的局部变量 <code>server_socket</code>，对于变量 <code>req</code> 也是如此，只不过方向相反。但是卫生机制会防止宏中的名称与其他作用域中的名称“冲突”——不过在这种情况下，你想要的正是变量 <code>req</code>。</p>\n<p>解决方案是把你打算同时在宏代码内部和外部使用的任何标识符都传给宏：</p>\n<pre class=\"code-rows\"><code>macro_rules! setup_req {\n    ($req:ident, $server_socket:ident) =&gt; {\n        let $req = ServerRequest::new($server_socket.session());\n    }\n}\n\nfn handle_http_request(server_socket: &amp;ServerSocket) {\n    setup_req!(req, server_socket);\n    …… // 使用`req`的代码\n}</code></pre>\n<p>由于函数现在提供了 <code>req</code> 和 <code>server_socket</code>，因此它们在该作用域内就有正确的“颜色”了。</p>\n<p>卫生机制让这个宏使用起来有点儿冗长，但这是一个特性，而不是 bug：了解到卫生宏不会背着你干扰局部变量，就更容易理解它。如果你在函数中搜索像 <code>server_socket</code> 这样的标识符，就会找到使用过它的所有地方，包括宏调用。</p>\n<h3 id=\"nav_point_439\">21.4.5　导入宏和导出宏</h3>\n<p>由于宏会在编译早期展开，那时候 Rust 甚至都不知道项目的完整模块结构，因此编译器需要对宏的导入和导出进行特殊支持。</p>\n<p>在一个模块中可见的宏也会自动在其子模块中可见。要将宏从当前模块“向上”导出到其父模块，请使用 <code>#[macro_use]</code> 属性。假设我们的 lib.rs 是这样的：</p>\n<pre class=\"code-rows\"><code>#[macro_use] mod macros;\nmod client;\nmod server;</code></pre>\n<p>那么 <code>macros</code> 模块中定义的所有宏都会导入 lib.rs 中，因此在 crate 的其余部分（包括在 <code>client</code> 和 <code>server</code> 中）都可见。</p>\n<p>标有 <code>#[macro_export]</code> 的宏会自动成为公共的，并且可以像其他语法项一样通过路径引用。</p>\n<p>例如，<code>lazy_static</code> crate 提供了一个名为 <code>lazy_static</code> 的宏，该宏会被标记为 <code>#[macro_export]</code>。要在自己的 crate 中使用这个宏，可以这样写：</p>\n<pre class=\"code-rows\"><code>use lazy_static::lazy_static;\nlazy_static!{ }</code></pre>\n<p>一旦导入了宏，就可以像其他任何语法项一样使用它：</p>\n<pre class=\"code-rows\"><code>use lazy_static::lazy_static;\n\nmod m {\n    crate::lazy_static! { }\n}</code></pre>\n<p>当然，实际上做这些就意味着你的宏可能会在其他模块中调用。因此，导出的宏不应该依赖作用域内的任何内容，因为在使用时无从确定它的作用域内会有哪些内容。它甚至可以遮蔽标准库预导入中的特性。</p>\n<p>相反，宏应该对它用到的任何名称都使用绝对路径。<code>macro_rules!</code> 提供了特殊片段 <code>$crate</code> 来帮助解决这个问题。这与<code>crate</code> 不同，<code>crate</code> 关键字可以用在任何地方的路径中而不仅仅是宏中。<code>$crate</code> 相当于定义此宏的 crate 的根模块绝对路径。我们可以写成 <code>$crate::Json</code> 而非 <code>Json</code> 的形式，这样即使没有导入 <code>Json</code> 也能工作。<code>HashMap</code> 可以被更改为 <code>::std::collections::HashMap</code> 或 <code>$crate::macros::HashMap</code>。在后一种情况下，我们将不得不重新导出 <code>HashMap</code>，因为 <code>$crate</code> 不能用于访问 crate 的私有特性。它实际上只是展开成类似于 <code>::jsonlib</code> 的普通路径。可见性规则不受影响。</p>\n<p>将宏移到它自己的模块 <code>macros</code> 并修改为使用 <code>$crate</code> 后，代码是下面这样的。这是最终版本：</p>\n<pre class=\"code-rows\"><code>// macros.rs\npub use std::collections::HashMap;\npub use std::boxed::Box;\npub use std::string::ToString;\n\n#[macro_export]\nmacro_rules! json {\n    (null) =&gt; {\n        $crate::Json::Null\n    };\n    ([ $( $element:tt ),* ]) =&gt; {\n        $crate::Json::Array(vec![ $( json!($element) ),* ])\n    };\n    ({ $( $key:tt : $value:tt ),* }) =&gt; {\n        {\n            let mut fields = $crate::macros::Box::new(\n                $crate::macros::HashMap::new());\n            $(\n                fields.insert($crate::macros::ToString::to_string($key),\n                              json!($value));\n            )*\n            $crate::Json::Object(fields)\n        }\n    };\n    ($other:tt) =&gt; {\n        $crate::Json::from($other)\n    };\n}</code></pre>\n<p>由于 <code>.to_string()</code> 方法是标准 <code>ToString</code> 特型的一部分，因此我们也会通过 <code>$crate</code> 来引用它，而使用的语法是 11.3 节介绍的 <code>$crate::macros::ToString::to_string($key)</code>。在这个例子中，这一句并不是必要的，因为 <code>ToString</code> 位于标准库预导入中。但是，如果你调用的特型方法可能不在调用宏的作用域内，则使用完全限定的方法调用是最好的办法。</p>\n<h2 id=\"nav_point_440\">21.5　在匹配过程中避免语法错误</h2>\n<p>下面的宏看起来很合理，但它给 Rust 带来了一些麻烦：</p>\n<pre class=\"code-rows\"><code>macro_rules! complain {\n    ($msg:expr) =&gt; {\n        println!(\"Complaint filed: {}\", $msg)\n    };\n    (user : $userid:tt , $msg:expr) =&gt; {\n        println!(\"Complaint from user {}: {}\", $userid, $msg)\n    };\n}</code></pre>\n<p>假设我们这样调用它：</p>\n<pre class=\"code-rows\"><code>complain!(user: \"jimb\", \"the AI lab's chatbots keep picking on me\");</code></pre>\n<p>在人类眼中，这显然符合第二条规则。但是 Rust 会首先尝试第一条规则，试图将所有输入与 <code>$msg:expr</code> 匹配。事情开始变得棘手了。<code>user: \"jimb\"</code> 当然不是表达式，所以我们得到了一个语法错误。Rust 拒绝隐藏语法错误，因为调试宏本来就已经够艰难了，再隐藏语法错误简直要命。因此，它会立即报告并停止编译。</p>\n<p>如果无法匹配模式中的任何其他语法标记，Rust 就会继续执行下一条规则。只有语法错误才会导致匹配失败，并且只在试图匹配片段时才会发生。</p>\n<p>这里的问题并不难理解：我们是在错误的规则中试图匹配片段 <code>$msg:expr</code>。这无法匹配，因为我们本来就不应该在这里匹配。调用者想要匹配其他规则。有两种简单的方法可以避免这种情况。</p>\n<p>第一种方法，避免混淆各条规则。例如，可以更改宏，让每个模式都以不同的标识符开头：</p>\n<pre class=\"code-rows\"><code>macro_rules! complain {\n    (msg : $msg:expr) =&gt; {\n        println!(\"Complaint filed: {}\", $msg);\n    };\n    (user : $userid:tt , msg : $msg:expr) =&gt; {\n        println!(\"Complaint from user {}: {}\", $userid, $msg);\n    };\n}</code></pre>\n<p>当宏参数以 <code>msg</code> 开头时，就匹配第一条规则。当宏参数以 <code>user</code> 开头时，就匹配第二条规则。无论是哪种参数，我们都能知道在尝试匹配片段之前已经找到了正确的规则。</p>\n<p>避免虚假语法错误的另一种方法是将更具体的规则放在前面。将 <code>user:</code> 规则放在前面就可以解决 <code>complain!</code> 的问题，因为永远不会到达导致语法错误的那条规则。</p>\n<h2 id=\"nav_point_441\">21.6　超越 <code>macro_rules!</code></h2>\n<p>宏模式固然可以解析比 JSON 更复杂的输入，但我们也发现这种复杂性很快就会失控。</p>\n<p>Daniel Keep 等人撰写的 <em>The Little Book of Rust Macros</em> 是一本优秀的高级 <code>macro_rules!</code> 编程书。该书写得清晰明了，关于宏展开的各个方面都比本章讲得更详尽。另外，该书还提供了几种非常聪明的技巧来借助 <code>macro_rules!</code> 模式实现某种玄奥的编程语言，以用这种模式解析复杂的输入。不过我们对这些技巧持保留态度。请小心使用。</p>\n<p>Rust 1.15 引入了一种称为<strong>过程宏</strong>的独立机制。过程宏不仅支持扩展 <code>#[derive]</code> 属性以处理自定义派生（参见图 21-4），还支持创建自定义属性和像前面讨论过的 <code>macro_rules!</code> 这样的宏。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00899.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 21-4：通过 <code>#[derive]</code> 属性调用假设的 <code>IntoJson</code> 过程宏</strong></p>\n<p>没有 <code>IntoJson</code> 特型，但这并不重要：过程宏可以利用这个钩子插入它想要的任何代码（在这个例子中，可能是 <code>impl From&lt;Money&gt; for Json { ... }</code>）。</p>\n<p>让过程宏得名“过程”的原因在于它是作为 Rust 函数而不是声明性规则集实现的。这个函数会通过一个很薄的抽象层与编译器交互，进而实现任意复杂的功能。例如，<code>diesel</code> 数据库 crate 就会使用过程宏连接到数据库并在编译期根据该数据库的模式（schema）生成代码。</p>\n<p>因为过程宏要与编译器内部交互，所以要写出有效的宏就要了解编译器是如何运行的，这超出了本书的范畴。有关详细信息，可以查阅 Rust 在线文档。</p>\n<p>也许在阅读了所有这些内容后，你开始有点儿讨厌宏了。那么，还有什么其他选择吗？还有一种方法是使用构建脚本生成 Rust 代码。Cargo 文档展示了如何一步一步地做到这一点。它涉及编写一个生成所需 Rust 代码的程序，然后向 Cargo.toml 中添加一行，以便在构建过程中运行该程序并使用 <code>include!</code> 将生成的代码放入你的 crate 中。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 20 章 异步编程(3)","id":740827},"right":{"article_title":"第 22 章 不安全代码(1)","id":740829}},"comments":[]}