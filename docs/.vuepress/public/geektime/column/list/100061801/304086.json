{"id":304086,"title":"11 | Context：信息穿透上下文","content":"<p>你好，我是鸟窝。</p><p>在这节课正式开始之前，我想先带你看一个工作中的场景。</p><p>假设有一天你进入办公室，突然同事们都围住你，然后大喊“小王小王你最帅”，此时你可能一头雾水，只能尴尬地笑笑。为啥呢？因为你缺少上下文的信息，不知道之前发生了什么。</p><p>但是，如果同事告诉你，由于你业绩突出，一天之内就把云服务化的主要架构写好了，因此被评为9月份的工作之星，总经理还特意给你发1万元的奖金，那么，你心里就很清楚了，原来同事恭喜你，是因为你的工作被表扬了，还获得了奖金。同事告诉你的这些前因后果，就是上下文信息，他把上下文传递给你，你接收后，就可以获取之前不了解的信息。</p><p>你看，上下文（Context）就是这么重要。在我们的开发场景中，上下文也是不可或缺的，缺少了它，我们就不能获取完整的程序信息。那到底啥是上下文呢？其实，这就是指，在API之间或者方法调用之间，所传递的除了业务参数之外的额外信息。</p><p>比如，服务端接收到客户端的HTTP请求之后，可以把客户端的IP地址和端口、客户端的身份信息、请求接收的时间、Trace ID等信息放入到上下文中，这个上下文可以在后端的方法调用中传递，后端的业务方法除了利用正常的参数做一些业务处理（如订单处理）之外，还可以从上下文读取到消息请求的时间、Trace  ID等信息，把服务处理的时间推送到Trace服务中。Trace服务可以把同一Trace ID的不同方法的调用顺序和调用时间展示成流程图，方便跟踪。</p><!-- [[[read_end]]] --><p>不过，Go标准库中的Context功能还不止于此，它还提供了超时（Timeout）和取消（Cancel）的机制，下面就让我一一道来。</p><h1>Context的来历</h1><p>在学习Context的功能之前呢，我先带你了解下它的来历。毕竟，知道了它的来龙去脉，我们才能应用得更加得心应手一些。</p><p>Go在1.7的版本中才正式把Context加入到标准库中。在这之前，很多Web框架在定义自己的handler时，都会传递一个自定义的Context，把客户端的信息和客户端的请求信息放入到Context中。Go最初提供了golang.org/x/net/context库用来提供上下文信息，最终还是在Go1.7中把此库提升到标准库context包中。</p><p>为啥呢？这是因为，在Go1.7之前，有很多库都依赖golang.org/x/net/context中的Context实现，这就导致Go 1.7发布之后，出现了标准库Context和golang.org/x/net/context并存的状况。新的代码使用标准库Context的时候，没有办法使用这个标准库的Context去调用旧有的使用x/net/context实现的方法。</p><p>所以，在Go1.9中，还专门实现了一个叫做type alias的新特性，然后把x/net/context中的Context定义成标准库Context的别名，以解决新旧Context类型冲突问题，你可以看一下下面这段代码：</p><pre><code>    // +build go1.9\n\tpackage context\n\t\n\timport &quot;context&quot;\n\t\n\ttype Context = context.Context\n\ttype CancelFunc = context.CancelFunc\n</code></pre><p>Go标准库的Context不仅提供了上下文传递的信息，还提供了cancel、timeout等其它信息，这些信息貌似和context这个包名没关系，但是还是得到了广泛的应用。所以，你看，context包中的Context不仅仅传递上下文信息，还有timeout等其它功能，是不是“名不副实”呢？</p><p>其实啊，这也是这个Context的一个问题，比较容易误导人，Go布道师Dave Cheney还专门写了一篇文章讲述这个问题：<a href=\"https://dave.cheney.net/2017/08/20/context-isnt-for-cancellation\">Context isn’t for cancellation</a>。</p><p>同时，也有一些批评者针对Context提出了批评：<a href=\"https://faiface.github.io/post/context-should-go-away-go2/\">Context should go away for Go 2</a>，这篇文章把Context比作病毒，病毒会传染，结果把所有的方法都传染上了病毒（加上Context参数），绝对是视觉污染。</p><p>Go的开发者也注意到了“关于Context，存在一些争议”这件事儿，所以，Go核心开发者Ian Lance Taylor专门开了一个<a href=\"https://github.com/golang/go/issues/28342\">issue 28342</a>，用来记录当前的Context的问题：</p><ul>\n<li>Context包名导致使用的时候重复ctx context.Context；</li>\n<li>Context.WithValue可以接受任何类型的值，非类型安全；</li>\n<li>Context包名容易误导人，实际上，Context最主要的功能是取消goroutine的执行；</li>\n<li>Context漫天飞，函数污染。</li>\n</ul><p>尽管有很多的争议，但是，在很多场景下，使用Context其实会很方便，所以现在它已经在Go生态圈中传播开来了，包括很多的Web应用框架，都切换成了标准库的Context。标准库中的database/sql、os/exec、net、net/http等包中都使用到了Context。而且，如果我们遇到了下面的一些场景，也可以考虑使用Context：</p><ul>\n<li>上下文信息传递 （request-scoped），比如处理http请求、在请求处理链路上传递信息；</li>\n<li>控制子goroutine的运行；</li>\n<li>超时控制的方法调用；</li>\n<li>可以取消的方法调用。</li>\n</ul><p>所以，我们需要掌握Context的具体用法，这样才能在不影响主要业务流程实现的时候，实现一些通用的信息传递，或者是能够和其它goroutine协同工作，提供timeout、cancel等机制。</p><h1>Context基本使用方法</h1><p>首先，我们来学习一下Context接口包含哪些方法，这些方法都是干什么用的。</p><p>包context定义了Context接口，Context的具体实现包括4个方法，分别是Deadline、Done、Err和Value，如下所示：</p><pre><code>type Context interface {\n    Deadline() (deadline time.Time, ok bool)\n    Done() &lt;-chan struct{}\n    Err() error\n    Value(key interface{}) interface{}\n}\n</code></pre><p>下面我来具体解释下这4个方法。</p><p><strong>Deadline</strong>方法会返回这个Context被取消的截止日期。如果没有设置截止日期，ok的值是false。后续每次调用这个对象的Deadline方法时，都会返回和第一次调用相同的结果。</p><p><strong>Done</strong>方法返回一个Channel对象。在Context被取消时，此Channel会被close，如果没被取消，可能会返回nil。后续的Done调用总是返回相同的结果。当Done被close的时候，你可以通过ctx.Err获取错误信息。Done这个方法名其实起得并不好，因为名字太过笼统，不能明确反映Done被close的原因，因为cancel、timeout、deadline都可能导致Done被close，不过，目前还没有一个更合适的方法名称。</p><p>关于Done方法，你必须要记住的知识点就是：如果Done没有被close，Err方法返回nil；如果Done被close，Err方法会返回Done被close的原因。</p><p><strong>Value</strong>返回此ctx中和指定的key相关联的value。</p><p>Context中实现了2个常用的生成顶层Context的方法。</p><ul>\n<li>context.Background()：返回一个非nil的、空的Context，没有任何值，不会被cancel，不会超时，没有截止日期。一般用在主函数、初始化、测试以及创建根Context的时候。</li>\n<li>context.TODO()：返回一个非nil的、空的Context，没有任何值，不会被cancel，不会超时，没有截止日期。当你不清楚是否该用Context，或者目前还不知道要传递一些什么上下文信息的时候，就可以使用这个方法。</li>\n</ul><p>官方文档是这么讲的，你可能会觉得像没说一样，因为界限并不是很明显。其实，你根本不用费脑子去考虑，可以直接使用context.Background。事实上，它们两个底层的实现是一模一样的：</p><pre><code>var (\n    background = new(emptyCtx)\n    todo       = new(emptyCtx)\n)\n\nfunc Background() Context {\n    return background\n}\n\nfunc TODO() Context {\n    return todo\n}\n</code></pre><p>在使用Context的时候，有一些约定俗成的规则。</p><ol>\n<li>一般函数使用Context的时候，会把这个参数放在第一个参数的位置。</li>\n<li>从来不把nil当做Context类型的参数值，可以使用context.Background()创建一个空的上下文对象，也不要使用nil。</li>\n<li>Context只用来临时做函数之间的上下文透传，不能持久化Context或者把Context长久保存。把Context持久化到数据库、本地文件或者全局变量、缓存中都是错误的用法。</li>\n<li>key的类型不应该是字符串类型或者其它内建类型，否则容易在包之间使用Context时候产生冲突。使用WithValue时，key的类型应该是自己定义的类型。</li>\n<li>常常使用struct{}作为底层类型定义key的类型。对于exported key的静态类型，常常是接口或者指针。这样可以尽量减少内存分配。</li>\n</ol><p>其实官方的文档也是比较搞笑的，文档中强调key的类型不要使用string，结果接下来的例子中就是用string类型作为key的类型。你自己把握住这个要点就好，如果你能保证别人使用你的Context时不会和你定义的key冲突，那么key的类型就比较随意，因为你自己保证了不同包的key不会冲突，否则建议你尽量采用保守的unexported的类型。</p><h1>创建特殊用途Context的方法</h1><p>接下来，我会介绍标准库中几种创建特殊用途Context的方法：WithValue、WithCancel、WithTimeout和WithDeadline，包括它们的功能以及实现方式。</p><h2>WithValue</h2><p>WithValue基于parent Context生成一个新的Context，保存了一个key-value键值对。它常常用来传递上下文。</p><p>WithValue方法其实是创建了一个类型为valueCtx的Context，它的类型定义如下：</p><pre><code>type valueCtx struct {\n    Context\n    key, val interface{}\n}\n</code></pre><p>它持有一个key-value键值对，还持有parent的Context。它覆盖了Value方法，优先从自己的存储中检查这个key，不存在的话会从parent中继续检查。</p><p>Go标准库实现的Context还实现了链式查找。如果不存在，还会向parent Context去查找，如果parent还是valueCtx的话，还是遵循相同的原则：valueCtx会嵌入parent，所以还是会查找parent的Value方法的。</p><pre><code>ctx = context.TODO()\nctx = context.WithValue(ctx, &quot;key1&quot;, &quot;0001&quot;)\nctx = context.WithValue(ctx, &quot;key2&quot;, &quot;0001&quot;)\nctx = context.WithValue(ctx, &quot;key3&quot;, &quot;0001&quot;)\nctx = context.WithValue(ctx, &quot;key4&quot;, &quot;0004&quot;)\n\nfmt.Println(ctx.Value(&quot;key1&quot;))\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/03/fe/035a1b8e090184c1feba1ef194ec53fe.jpg?wh=4000*557\" alt=\"\"></p><h2>WithCancel</h2><p>WithCancel 方法返回parent的副本，只是副本中的Done Channel是新建的对象，它的类型是cancelCtx。</p><p>我们常常在一些需要主动取消长时间的任务时，创建这种类型的Context，然后把这个Context传给长时间执行任务的goroutine。当需要中止任务时，我们就可以cancel这个Context，这样长时间执行任务的goroutine，就可以通过检查这个Context，知道Context已经被取消了。</p><p>WithCancel返回值中的第二个值是一个cancel函数。其实，这个返回值的名称（cancel）和类型（Cancel）也非常迷惑人。</p><p>记住，不是只有你想中途放弃，才去调用cancel，只要你的任务正常完成了，就需要调用cancel，这样，这个Context才能释放它的资源（通知它的children 处理cancel，从它的parent中把自己移除，甚至释放相关的goroutine）。很多同学在使用这个方法的时候，都会忘记调用cancel，切记切记，而且一定尽早释放。</p><p>我们来看下WithCancel方法的实现代码：</p><pre><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {\n    c := newCancelCtx(parent)\n    propagateCancel(parent, &amp;c)// 把c朝上传播\n    return &amp;c, func() { c.cancel(true, Canceled) }\n}\n\n// newCancelCtx returns an initialized cancelCtx.\nfunc newCancelCtx(parent Context) cancelCtx {\n    return cancelCtx{Context: parent}\n}\n</code></pre><p>代码中调用的propagateCancel方法会顺着parent路径往上找，直到找到一个cancelCtx，或者为nil。如果不为空，就把自己加入到这个cancelCtx的child，以便这个cancelCtx被取消的时候通知自己。如果为空，会新起一个goroutine，由它来监听parent的Done是否已关闭。</p><p>当这个cancelCtx的cancel函数被调用的时候，或者parent的Done被close的时候，这个cancelCtx的Done才会被close。</p><p>cancel是向下传递的，如果一个WithCancel生成的Context被cancel时，如果它的子Context（也有可能是孙，或者更低，依赖子的类型）也是cancelCtx类型的，就会被cancel，但是不会向上传递。parent Context不会因为子Context被cancel而cancel。</p><p>cancelCtx被取消时，它的Err字段就是下面这个Canceled错误：</p><pre><code>var Canceled = errors.New(&quot;context canceled&quot;)\n</code></pre><h2>WithTimeout</h2><p>WithTimeout其实是和WithDeadline一样，只不过一个参数是超时时间，一个参数是截止时间。超时时间加上当前时间，其实就是截止时间，因此，WithTimeout的实现是：</p><pre><code>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {\n    // 当前时间+timeout就是deadline\n    return WithDeadline(parent, time.Now().Add(timeout))\n}\n</code></pre><h2>WithDeadline</h2><p>WithDeadline会返回一个parent的副本，并且设置了一个不晚于参数d的截止时间，类型为timerCtx（或者是cancelCtx）。</p><p>如果它的截止时间晚于parent的截止时间，那么就以parent的截止时间为准，并返回一个类型为cancelCtx的Context，因为parent的截止时间到了，就会取消这个cancelCtx。</p><p>如果当前时间已经超过了截止时间，就直接返回一个已经被cancel的timerCtx。否则就会启动一个定时器，到截止时间取消这个timerCtx。</p><p>综合起来，timerCtx的Done被Close掉，主要是由下面的某个事件触发的：</p><ul>\n<li>截止时间到了；</li>\n<li>cancel函数被调用；</li>\n<li>parent的Done被close。</li>\n</ul><p>下面的代码是WithDeadline方法的实现：</p><pre><code>func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {\n    // 如果parent的截止时间更早，直接返回一个cancelCtx即可\n    if cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) {\n        return WithCancel(parent)\n    }\n    c := &amp;timerCtx{\n        cancelCtx: newCancelCtx(parent),\n        deadline:  d,\n    }\n    propagateCancel(parent, c) // 同cancelCtx的处理逻辑\n    dur := time.Until(d)\n    if dur &lt;= 0 { //当前时间已经超过了截止时间，直接cancel\n        c.cancel(true, DeadlineExceeded)\n        return c, func() { c.cancel(false, Canceled) }\n    }\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    if c.err == nil {\n        // 设置一个定时器，到截止时间后取消\n        c.timer = time.AfterFunc(dur, func() {\n            c.cancel(true, DeadlineExceeded)\n        })\n    }\n    return c, func() { c.cancel(true, Canceled) }\n}\n</code></pre><p>和cancelCtx一样，WithDeadline（WithTimeout）返回的cancel一定要调用，并且要尽可能早地被调用，这样才能尽早释放资源，不要单纯地依赖截止时间被动取消。正确的使用姿势是啥呢？我们来看一个例子。</p><pre><code>func slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\tdefer cancel() // 一旦慢操作完成就立马调用cancel\n\treturn slowOperation(ctx)\n}\n</code></pre><h1>总结</h1><p>我们经常使用Context来取消一个goroutine的运行，这是Context最常用的场景之一，Context也被称为goroutine生命周期范围（goroutine-scoped）的Context，把Context传递给goroutine。但是，goroutine需要尝试检查Context的Done是否关闭了：</p><pre><code>func main() {\n    ctx, cancel := context.WithCancel(context.Background())\n\n    go func() {\n        defer func() {\n            fmt.Println(&quot;goroutine exit&quot;)\n        }()\n\n        for {\n            select {\n            case &lt;-ctx.Done():\n                return\n            default:\n                time.Sleep(time.Second)\n            }\n        }\n    }()\n\n    time.Sleep(time.Second)\n    cancel()\n    time.Sleep(2 * time.Second)\n}\n</code></pre><p>如果你要为Context实现一个带超时功能的调用，比如访问远程的一个微服务，超时并不意味着你会通知远程微服务已经取消了这次调用，大概率的实现只是避免客户端的长时间等待，远程的服务器依然还执行着你的请求。</p><p>所以，有时候，Context并不会减少对服务器的请求负担。如果在Context被cancel的时候，你能关闭和服务器的连接，中断和数据库服务器的通讯、停止对本地文件的读写，那么，这样的超时处理，同时能减少对服务调用的压力，但是这依赖于你对超时的底层处理机制。</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/2b/2dcbb1ca54c31b4f3e987b602a38e82b.jpg?wh=2250*2441\" alt=\"\"></p><h1>思考题</h1><p>使用WithCancel和WithValue写一个级联的使用Context的例子，验证一下parent Context被cancel后，子conext是否也立刻被cancel了。</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","comments":[{"had_liked":false,"id":312486,"user_name":"楼梯口倒立","can_delete":false,"product_type":"c1","uid":1037367,"ip_address":"","ucode":"BE53FDB3A3F085","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d4/37/bb19dbcd.jpg","comment_is_top":false,"comment_ctime":1631840773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70351317509","product_id":100061801,"comment_content":"这个例子讲的一言难尽，还不如百度出来的","like_count":17},{"had_liked":false,"id":258490,"user_name":"虫子樱桃","can_delete":false,"product_type":"c1","uid":1226331,"ip_address":"","ucode":"F8244A9E9BC5A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/b6/5b/4486e4f9.jpg","comment_is_top":false,"comment_ctime":1604460398,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"66028969838","product_id":100061801,"comment_content":"Using Context Package in GO (Golang) – Complete Guide https:&#47;&#47;golangbyexample.com&#47;using-context-in-golang-complete-guide&#47;","like_count":16,"discussions":[{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337118,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608801044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260691,"user_name":"愤怒的显卡","can_delete":false,"product_type":"c1","uid":1640898,"ip_address":"","ucode":"5027D73E1CCDD4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhZZ4YhWluhayDIDDicJXJkDe86hm2mYEpPZzYdyopt8hPbt2EMcwgZ4jzPBqFyVUEQzb3sEYXWuA/132","comment_is_top":false,"comment_ctime":1605084227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40259789891","product_id":100061801,"comment_content":"可以写几个应用的实例","like_count":9},{"had_liked":false,"id":276001,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1611741492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35971479860","product_id":100061801,"comment_content":"Context  就像 糖葫芦中的 竹签子  ","like_count":8},{"had_liked":false,"id":258593,"user_name":"Remember九离","can_delete":false,"product_type":"c1","uid":1237327,"ip_address":"","ucode":"97EE6E6344689F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","comment_is_top":false,"comment_ctime":1604496509,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35964234877","product_id":100061801,"comment_content":"思考题简单写了下:<br>```go<br>package main<br><br>import (<br>\t&quot;context&quot;<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tparent := context.Background()<br>\tctx, cancel := context.WithCancel(parent)<br>\tchild := context.WithValue(ctx, &quot;name&quot;, &quot;wuqq&quot;)<br>\tgo func() {<br>\t\tfor {<br>\t\t\tselect {<br>\t\t\tcase &lt;-child.Done():<br>\t\t\t\tfmt.Println(&quot;it&#39;s over&quot;)<br>\t\t\t\treturn<br>\t\t\tdefault:<br>\t\t\t\tres := child.Value(&quot;name&quot;)<br>\t\t\t\tfmt.Println(&quot;name:&quot;, res)<br>\t\t\t\ttime.Sleep(1 * time.Second)<br>\t\t\t}<br>\t\t}<br>\t}()<br>\tgo func() {<br>\t\ttime.Sleep(3 * time.Second)<br>\t\tcancel()<br>\t}()<br><br>\ttime.Sleep(5 * time.Second)<br>}<br><br>```<br>源码在：https:&#47;&#47;github.com&#47;wuqinqiang&#47;Go_Concurrency","like_count":9,"discussions":[{"author":{"id":1430378,"avatar":"https://static001.geekbang.org/account/avatar/00/15/d3/6a/c3b152ab.jpg","nickname":"沫沫哒","note":"","ucode":"A23CF90D85914C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333873,"discussion_content":"文章中说的是context.WithValue中的k要使用自定义类型，最好时使用struct {}作为底层类型作为key，可是这样的类型是怎么作为key的呢，如果struct{}里面的元素变了，这个类型是不是也变了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607657118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258489,"user_name":"虫子樱桃","can_delete":false,"product_type":"c1","uid":1226331,"ip_address":"","ucode":"F8244A9E9BC5A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/b6/5b/4486e4f9.jpg","comment_is_top":false,"comment_ctime":1604460299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35964198667","product_id":100061801,"comment_content":"context其实上几个例子更好。哈哈。大家可以参考 go by Example的例子 http:&#47;&#47;play.golang.org&#47;p&#47;0_bu1o8rIBO","like_count":8},{"had_liked":false,"id":267187,"user_name":"缘","can_delete":false,"product_type":"c1","uid":1102058,"ip_address":"","ucode":"F310AB5BE2A3BF","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ea/8269574b.jpg","comment_is_top":false,"comment_ctime":1607646167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27377449943","product_id":100061801,"comment_content":"context讲的比较简单，特别是goroutine怎么不断的去检查是否超时，什么阶段检查合适","like_count":6},{"had_liked":false,"id":264911,"user_name":"50%","can_delete":false,"product_type":"c1","uid":1674992,"ip_address":"","ucode":"3E4247B5844B5B","user_header":"https://static001.geekbang.org/account/avatar/00/19/8e/f0/18720510.jpg","comment_is_top":false,"comment_ctime":1606705801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27376509577","product_id":100061801,"comment_content":"其实这章我觉得通过例子来吃透比较好，建议大家看看那个golangbyexample的文章","like_count":7},{"had_liked":false,"id":259561,"user_name":"syuan","can_delete":false,"product_type":"c1","uid":1215879,"ip_address":"","ucode":"D9BBC2ADAB5F2E","user_header":"https://static001.geekbang.org/account/avatar/00/12/8d/87/47d95f4a.jpg","comment_is_top":false,"comment_ctime":1604755665,"is_pvip":false,"replies":[{"id":"94385","content":"引入的时候已经初始化了。同一个。","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604832036,"ip_address":"","comment_id":259561,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5899722961","product_id":100061801,"comment_content":"老师，您好。<br>var (<br>    background = new(emptyCtx)<br>    todo       = new(emptyCtx)<br>)<br>在实际使用中，这两个变量在什么时候执行，在引入包的时候就执行了吗？<br>还是在执行Background() ，TODO() 这两个函数调用的时候执行？<br>在一个main函数中多次调用Background() ，TODO()，background，todo变量始终是指向同一个值吗？","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508958,"discussion_content":"引入的时候已经初始化了。同一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604832036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215879,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/87/47d95f4a.jpg","nickname":"syuan","note":"","ucode":"D9BBC2ADAB5F2E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322922,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604843011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342080,"user_name":"极客酱酱","can_delete":false,"product_type":"c1","uid":2934665,"ip_address":"","ucode":"18CDC1DB754D58","user_header":"https://static001.geekbang.org/account/avatar/00/2c/c7/89/16437396.jpg","comment_is_top":false,"comment_ctime":1650007287,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1650007287","product_id":100061801,"comment_content":"思考题实践<br><br>package main<br><br>import (<br>\t&quot;context&quot;<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tctx, cancel := context.WithCancel(context.Background())<br>\tctx1 := context.WithValue(ctx, &quot;key1&quot;, &quot;val1&quot;)<br>\tgo func() {<br>\t\tdefer func() { fmt.Println(&quot;goroutine exit&quot;) }()<br>\t\tfor {<br>\t\t\tselect {<br>\t\t\tcase &lt;-ctx1.Done():<br>\t\t\t\tfmt.Println(&quot;ctx1 done&quot;)<br>\t\t\t\treturn<br>\t\t\t}<br>\t\t}<br>\t}()<br>\tcancel()<br>\ttime.Sleep(time.Millisecond)<br>}<br>","like_count":0},{"had_liked":false,"id":322355,"user_name":"努力的狗狗","can_delete":false,"product_type":"c1","uid":2418932,"ip_address":"","ucode":"8283736FE13134","user_header":"https://static001.geekbang.org/account/avatar/00/24/e8/f4/40d6c39c.jpg","comment_is_top":false,"comment_ctime":1637313847,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637313847","product_id":100061801,"comment_content":"只是概念，应该多举两个例子的","like_count":0},{"had_liked":false,"id":321491,"user_name":"徐改","can_delete":false,"product_type":"c1","uid":1298380,"ip_address":"","ucode":"82276A584AC602","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","comment_is_top":false,"comment_ctime":1636902472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636902472","product_id":100061801,"comment_content":"func TestCascadeContext(t *testing.T) {<br>\ttype key int<br>\tquit := false<br>\tctx, cancel := context.WithCancel(context.TODO())<br>\tk := key(100)<br>\tctx = context.WithValue(ctx, k, 100)<br>\tgo func() {<br>\t\ttime.Sleep(time.Second)<br>\t\tcancel()\t&#47;&#47; parent context被cancel后，其子context也会被取消<br>\t}()<br>\tfor {<br>\t\tif quit {<br>\t\t\tbreak<br>\t\t}<br>\t\tselect {<br>\t\tcase &lt;- ctx.Done():\t\t&#47;&#47; 子context被取消，结束循环<br>\t\t\tquit = true<br>\t\tdefault:<br>\t\t\tfmt.Println(ctx.Value(k))<br>\t\t\ttime.Sleep(time.Second)<br>\t\t}<br>\t}<br>}","like_count":0},{"had_liked":false,"id":293597,"user_name":"寻","can_delete":false,"product_type":"c1","uid":1167430,"ip_address":"","ucode":"473B2CC14158A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/d0/46/7f9af8de.jpg","comment_is_top":false,"comment_ctime":1621439491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621439491","product_id":100061801,"comment_content":"grpc 客户端 传 backgroud类型的ctx，为什么服务端收到显示已经超时？","like_count":0},{"had_liked":false,"id":281311,"user_name":"芒果少侠","can_delete":false,"product_type":"c1","uid":1350159,"ip_address":"","ucode":"98D0BBB52BB80F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","comment_is_top":false,"comment_ctime":1614685519,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614685519","product_id":100061801,"comment_content":"思考题：<br>package context<br><br>import (<br>\t&quot;context&quot;<br>\t&quot;log&quot;<br>\t&quot;testing&quot;<br>\t&quot;time&quot;<br>)<br><br>func TestContextCancel(t *testing.T) {<br>\tparent := context.Background()<br>\tcancelCtx, cancelFunc := context.WithCancel(parent) &#47;&#47; parent<br>\tvalueCtx := context.WithValue(cancelCtx, &quot;key&quot;, &quot;value&quot;) &#47;&#47; child<br><br>\tgo func() {<br>\t\tfor {<br>\t\t\tselect {<br>\t\t\tcase &lt;-cancelCtx.Done(): {<br>\t\t\t\tlog.Printf(&quot;cancelCtx done&quot;)<br>\t\t\t\treturn<br>\t\t\t}<br>\t\t\tdefault:<br>\t\t\t\tlog.Printf(&quot;cancelCtx working&quot;)<br>\t\t\t}<br>\t\t\ttime.Sleep(time.Millisecond * 500)<br>\t\t}<br>\t}()<br><br>\ttime.Sleep(time.Second)<br><br>\tgo func() {<br>\t\tfor {<br>\t\t\tselect {<br>\t\t\tcase &lt;-valueCtx.Done(): {<br>\t\t\t\tlog.Printf(&quot;valueCtx done&quot;)<br>\t\t\t\treturn<br>\t\t\t}<br>\t\t\tdefault:<br>\t\t\t\tlog.Printf(&quot;valueCtx working&quot;)<br>\t\t\t}<br>\t\t\ttime.Sleep(time.Millisecond * 500)<br>\t\t}<br>\t}()<br><br><br>\ttime.Sleep(time.Second)<br>\t&#47;&#47; cancel<br>\tlog.Printf(&quot;now start to cancel..&quot;)<br>\tcancelFunc()<br><br>\ttime.Sleep(time.Second)<br>}<br>","like_count":0},{"had_liked":false,"id":274257,"user_name":"科科","can_delete":false,"product_type":"c1","uid":1647304,"ip_address":"","ucode":"7DAE6FE781172E","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","comment_is_top":false,"comment_ctime":1610942384,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1610942384","product_id":100061801,"comment_content":"Done 方法返回一个 Channel 对象。在 Context 被取消时，此 Channel 会被 close，如果没被取消，可能会返回 nil。<br><br>我看了半天，到底是这个Done()方法返回nil,还是这个Channel返回nil，其实应该是Channel返回nil。<br><br>一般来说都把Done方法返回的这个Channel对象放在select里面监听，也不会直接去把Done()返回的channel关闭，既然WithConcel都返回一个函数了，就是在stop操作的时候调用cancelFunc，由这个函数去做资源的释放，关闭channel。","like_count":0},{"had_liked":false,"id":274120,"user_name":"( ･᷄ὢ･᷅ )","can_delete":false,"product_type":"c1","uid":2234129,"ip_address":"","ucode":"E5F5EDEBB74C46","user_header":"https://static001.geekbang.org/account/avatar/00/22/17/11/a63acc6a.jpg","comment_is_top":false,"comment_ctime":1610862555,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1610862555","product_id":100061801,"comment_content":"【记住，不是只有你想中途放弃，才去调用 cancel，只要你的任务正常完成了，就需要调用 cancel，这样，这个 Context 才能释放它的资源（通知它的 children 处理 cancel，从它的 parent 中把自己移除，甚至释放相关的 goroutine】<br><br>既然这样如果只是想做主动停止goroutine的操作，那么还不如直接使用make(chan struct{})这种情况了，而且context对子对象的遍历取消也会对性能有影响吧","like_count":0,"discussions":[{"author":{"id":1647304,"avatar":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","nickname":"科科","note":"","ucode":"7DAE6FE781172E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343096,"discussion_content":"很多事情都是操作简单起来，性能就会有影响，context如果出现级联应该会比chan勇气来更清晰，封装出来方法很大程度上是为了能写出更统一美观的项目，管理起来更方便，但是context这个性能应该也不会有太多影响，毕竟都准备cancel了，性能也不是什么首要考虑的东西了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610942371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259077,"user_name":"锋","can_delete":false,"product_type":"c1","uid":1807836,"ip_address":"","ucode":"F26BC1F14AB0D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/95/dc/07195a63.jpg","comment_is_top":false,"comment_ctime":1604627431,"is_pvip":false,"replies":[{"id":"94251","content":"这主要是context设计的问题，这个cancel你必须调用。即使子goroutine正常退出后，父goroutine也需要做一些额外的动作，如文中所示。这种情况不是&#39;cancel&#39;子goroutine,而是&#39;free resources&#39;.<br>所以这个cancel的叫法不准确，容易误导人，但go开发者也没想出更合适的名字","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604636813,"ip_address":"","comment_id":259077,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1604627431","product_id":100061801,"comment_content":"老师好。<br>【记住，不是只有你想中途放弃，才去调用 cancel，只要你的任务正常完成了，就需要调用 cancel，这样，这个 Context 才能释放它的资源（通知它的 children 处理 cancel，从它的 parent 中把自己移除，甚至释放相关的 goroutine】<br>上面这一段中任务正常完成 parent来cancel不太理解，正常父主动cancel基本都属于中断操作。但是老师讲到要正常退出的时候来cancel一下，既然是正常结束，那么父应该知道子结束了才去cancel，那父子之间不是还要单独建立一个channel来进行通讯？没有get到老师的点，麻烦老师能不能举个例子","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508838,"discussion_content":"这主要是context设计的问题，这个cancel你必须调用。即使子goroutine正常退出后，父goroutine也需要做一些额外的动作，如文中所示。这种情况不是&amp;#39;cancel&amp;#39;子goroutine,而是&amp;#39;free resources&amp;#39;.\n所以这个cancel的叫法不准确，容易误导人，但go开发者也没想出更合适的名字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604636813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258558,"avatar":"https://static001.geekbang.org/account/avatar/00/13/34/3e/0b1c2b7f.jpg","nickname":"S.S Mr Lin","note":"","ucode":"1DDD5132B0DA64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324121,"discussion_content":"我想问下，如果我只有一个cancelCtx管理了很多子goroutine的话，如果其中一个任务完成了，需要调用cancel吗？感觉文中说的是给每个子goroutine都单独生成一个cancelCtx这种才需要每个都单独cancel？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605059569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258709,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1604541687,"is_pvip":false,"replies":[{"id":"94179","content":"exported是go语言的说法，首字母大写，其它package可见。 “保守的.....”？","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604556107,"ip_address":"","comment_id":258709,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1604541687","product_id":100061801,"comment_content":"请问老师，文中提到的 exported key 的静态类型和保守的 unexported 的类型，它们各自指的是什么类型呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508734,"discussion_content":"exported是go语言的说法，首字母大写，其它package可见。 “保守的.....”？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604556107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323232,"discussion_content":"&#34;因为你自己保证了不同包的 key 不会冲突，否则建议你尽量采用保守的 unexported 的类型&#34; -- 原文的意思应该是：你在选择 key 时可以保守一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604903372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258436,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1604444713,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604444713","product_id":100061801,"comment_content":"打卡。","like_count":0,"discussions":[{"author":{"id":1102058,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/ea/8269574b.jpg","nickname":"缘","note":"","ucode":"F310AB5BE2A3BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333829,"discussion_content":"context讲的比较简单，特别是goroutine怎么不断的去检查是否超时，什么阶段检查合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607646119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}