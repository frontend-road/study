{"id":740840,"title":"第 3 章 容器类型(2)","content":"<h2 id=\"nav_point_61\">3.3　编程建议</h2>\n<h3 id=\"nav_point_62\">3.3.1　用按需返回替代容器</h3>\n<p>在 Python 中，用 <code>range()</code> 内置函数可以获得一个数字序列：</p>\n<pre class=\"code-rows\"><code># 打印 0 到 100 之间的所有数字（不含 100）\n&gt;&gt;&gt; for i in range(100):\n...     print(i)\n...\n0\n1\n...\n99</code></pre>\n<p>在 Python 2 时代，如果你想用 <code>range()</code> 生成一个非常大的数字序列——比如 0 到 1 亿间的所有数字，速度会非常慢。这是因为 <code>range()</code> 需要组装并返回一个巨大的列表，整个计算与内存分配过程会耗费大量时间。</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; range(10)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ➊</code></pre>\n<blockquote>\n<p>❶ Python 2 中的 <code>range()</code> 会一次性返回所有数字</p>\n</blockquote>\n<p>但到了 Python 3，调用 <code>range(100000000)</code> 瞬间就会返回结果。因为它不再返回列表，而是返回一个类型为 <code>range</code> 的惰性计算对象。</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; r = range(100000000)\n&gt;&gt;&gt; r\nrange(0, 100000000) ➊\n&gt;&gt;&gt; type(r)\n&lt;class 'range'&gt;\n&gt;&gt;&gt; for i in r: ➋\n...     print(i)\n...\n0\n1\n...</code></pre>\n<blockquote>\n<p>❶ <code>r</code> 是 <code>range</code> 对象，而非装满数字的列表</p>\n<p>❷ 只有在迭代 <code>range</code> 对象时，它才会不断生成新的数字</p>\n</blockquote>\n<p>当序列过大时，新的 <code>range()</code> 函数不再会一次性耗费大量内存和时间，生成一个巨大的列表，而是仅在被迭代时按需返回数字。<code>range()</code> 的进化过程虽然简单，但它其实代表了一种重要的编程思维——<strong>按需生成，而不是一次性返回</strong>。</p>\n<p>在日常编码中，实践这种思维可以有效提升代码的执行效率。Python 里的生成器对象非常适合用来实现“按需生成”。</p>\n<ol>\n<li><p><strong>生成器简介</strong></p>\n<p><strong>生成器</strong>（generator）是 Python 里的一种特殊的数据类型。顾名思义，它是一个不断给调用方“生成”内容的类型。定义一个生成器，需要用到生成器函数与 <code>yield</code> 关键字。</p>\n<p>一个最简单的生成器如下：</p>\n<pre class=\"code-rows\"><code>def generate_even(max_number):\n    \"\"\"一个简单生成器，返回 0 到 max_number 之间的所有偶数\"\"\"\n    for i in range(0, max_number):\n        if i % 2 == 0:\n            yield i\n\nfor i in generate_even(10):\n    print(i)</code></pre>\n<p>执行后输出：</p>\n<pre class=\"code-rows\"><code>0\n2\n4\n6\n8</code></pre>\n<p>虽然都是返回结果，但 <code>yield</code> 和 <code>return</code> 的最大不同之处在于，<code>return</code> 的返回是一次性的，使用它会直接中断整个函数执行，而 <code>yield</code> 可以逐步给调用方生成结果：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; i = generate_even(10)\n&gt;&gt;&gt; next(i)\n0\n&gt;&gt;&gt; next(i) ➊\n2</code></pre>\n<blockquote>\n<p>❶ 调用 <code>next()</code> 可以逐步从生成器对象里拿到结果</p>\n</blockquote>\n<p>因为生成器是可迭代对象，所以你可以使用 <code>list()</code> 等函数方便地把它转换为各种其他容器类型：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; list(generate_even(10))\n[0, 2, 4, 6, 8]</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>用生成器替代列表</strong></p>\n<p>在日常工作中，我们经常需要编写下面这样的代码：</p>\n<pre class=\"code-rows\"><code>def batch_process(items):\n    \"\"\"\n    批量处理多个 items 对象\n    \"\"\"\n    # 初始化空结果列表\n    results = []\n    for item in items:\n        # 处理 item，可能需要耗费大量时间……\n        # processed_item = ...\n        results.append(processed_item)\n    # 将拼装后的结果列表返回\n    return results</code></pre>\n<p>这样的函数遵循同一种模式：“初始化结果容器→处理→将结果存入容器→返回容器”。这个模式虽然简单，但它有两个问题。</p>\n<p>一个问题是，如果需要处理的对象 <code>items</code> 过大，<code>batch_process()</code> 函数就会像 Python 2 里的 <code>range()</code> 函数一样，每次执行都特别慢，存放结果的对象 <code>results</code> 也会占用大量内存。</p>\n<p>另一个问题是，如果<strong>函数调用方</strong>想在某个 <code>processed_item</code> 对象满足特定条件时中断，不再继续处理后面的对象，现在的 <code>batch_process()</code> 函数也做不到——它每次都得一次性处理完所有 <code>items</code> 才会返回。</p>\n<p>为了解决这两个问题，我们可以用生成器函数来改写它。简单来说，就是用 <code>yield item</code> 替代 <code>append</code> 语句：</p>\n<pre class=\"code-rows\"><code>def batch_process(items):\n    for item in items:\n        # 处理 item，可能需要耗费大量时间……\n        # processed_item = ...\n        yield processed_item</code></pre>\n<p>生成器函数不仅看上去更短，而且很好地解决了前面的两个问题。当输入参数 <code>items</code> 很大时，<code>batch_process()</code> 不再需要一次性拼装返回一个巨大的结果列表，内存占用更小，执行起来也更快。</p>\n<p>如果调用方需要在某些条件下中断处理，也完全可以做到：</p>\n<pre class=\"code-rows\"><code># 调用方\nfor processed_item in batch_process(items):\n    # 如果某个已处理对象过期了，就中断当前的所有处理\n    if processed_item.has_expired():\n        break</code></pre>\n<p>在上面的代码里，当调用方退出循环后，<code>batch_process()</code> 函数也会直接中断，不需要再接着处理 <code>items</code> 里剩下的内容。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_63\">3.3.2　了解容器的底层实现</h3>\n<p>Python 是一门高级编程语言，它提供的所有内置容器类型都经过了高度的封装和抽象。学会基本操作后，你就可以随意使用它们，根本不用关心某个容器底层是如何实现的。</p>\n<p>易上手是 Python 语言的一大优势。相比 C 语言这种更接近计算机底层的编程语言，Python 实现了对开发者更友好的内置容器类型，屏蔽了内存管理等工作，提供了更好的开发体验。</p>\n<p>但即便如此，了解各容器的底层实现仍然很重要。因为只有了解底层实现，你才可以在编程时避开一些常见的性能陷阱，写出运行更快的代码。</p>\n<ol>\n<li><p><strong>避开列表的性能陷阱</strong></p>\n<p>列表是一种非常灵活的容器类型。要往列表里插入数据，可以选择用 <code>.append()</code> 方法往尾部追加，也可以选择用 <code>.insert()</code> 在任意位置插入。得益于这种灵活性，各种常见数据结构似乎都可以用列表来实现，比如先进先出的队列、先进后出的堆栈，等等。</p>\n<p>虽然列表支持各种操作，但其中某些操作可能没你想得那么快。我们看一个例子：</p>\n<pre class=\"code-rows\"><code>def list_append():\n    \"\"\"不断往尾部追加\"\"\"\n    l = []\n    for i in range(5000):\n        l.append(i)\n　\n　\ndef list_insert():\n    \"\"\"不断往头部插入\"\"\"\n    l = []\n    for i in range(5000):\n        l.insert(0, i)\n　\n　\nimport timeit\n　\n　\n# 默认执行 1 万次\nappend_spent = timeit.timeit(\n    setup='from __main__ import list_append',\n    stmt='list_append()',\n    number=10000,\n)\nprint(\"list_append:\", append_spent)\n\ninsert_spent = timeit.timeit(\n    setup='from __main__ import list_insert',\n    stmt='list_insert()',\n    number=10000,\n)\nprint(\"list_insert\", insert_spent)</code></pre>\n<p>在上面的代码里，我们分别用了 <code>append</code> 与 <code>insert</code> 从头尾部来构建列表，并记录了两种操作的耗时。</p>\n<p>执行结果如下：</p>\n<pre class=\"code-rows\"><code>list_append: 3.407903105\nlist_insert 49.336992618000004</code></pre>\n<p>可以看到，同样是构建一个长度为 5000 的列表，不断往头部插入的 <code>insert</code> 方式的耗时是从尾部追加的 <code>append</code> 方式的 16 倍还多。为什么会这样呢？</p>\n<p>这个性能差距与列表的底层实现有关。Python 在实现列表时，底层使用了<strong>数组</strong>（array）数据结构。这种结构最大的一个特点是，当你在数组中间插入新成员时，该成员之后的其他成员都需要移动位置，该操作的平均时间复杂度是 <code>O(n)</code>。因此，在列表的头部插入成员，比在尾部追加要慢得多（后者的时间复杂度为 <code>O(1)</code>）。</p>\n<p>如果你经常需要往列表头部插入数据，请考虑使用 <code>collections.deque</code> 类型来替代列表（代码如下）。因为 <code>deque</code> 底层使用了双端队列，无论在头部还是尾部追加成员，时间复杂度都是 <code>O(1)</code>。</p>\n<pre class=\"code-rows\"><code>from collections import deque\n　\n　\ndef deque_append():\n    \"\"\"不断往尾部追加\"\"\"\n    l = deque()\n    for i in range(5000):\n        l.append(i)\n　\n　\ndef deque_appendleft():\n    \"\"\"不断往头部插入\"\"\"\n    l = deque()\n    for i in range(5000):\n        l.appendleft(i)\n　\n　\n# timeit 性能测试代码已省略\n...</code></pre>\n<p>执行结果如下：</p>\n<pre class=\"code-rows\"><code>deque_append: 3.739269677\ndeque_appendleft 3.7188512409999994</code></pre>\n<p>可以看到，使用 <code>deque</code> 以后，不论从尾部还是头部追加成员都非常快。</p>\n<p>除了 <code>insert</code> 操作，列表还有一个常见的性能陷阱——判断“成员是否存在”的耗时问题：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; nums = list(range(10))\n&gt;&gt;&gt; nums\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 判断成员是否存在\n&gt;&gt;&gt; 3 in nums\nTrue</code></pre>\n<p>因为列表在底层使用了数组结构，所以要判断某个成员是否存在，唯一的办法是从前往后遍历所有成员，执行该操作的时间复杂度是 <code>O(n)</code>。如果列表内容很多，这种 <code>in</code> 操作耗时就会很久。</p>\n<p>对于这类判断成员是否存在的场景，我们有更好的选择。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用集合判断成员是否存在</strong></p>\n<p>要判断某个容器是否包含特定成员，用集合比用列表更合适。</p>\n<p>在列表中搜索，有点儿像在一本没有目录的书里找一个单词。因为不知道它会出现在哪里，所以只能一页一页翻看，挨个对比。完成这种操作需要的时间复杂度是 <code>O(n)</code>。</p>\n<p>而在集合里搜索，就像通过字典查字。我们先按照字的拼音从索引找到它所在的页码，然后直接翻到那一页。完成这种操作需要的时间复杂度是 <code>O(1)</code>。</p>\n<p>在集合里搜索之所以这么快，是因为其底层使用了哈希表数据结构。要判断集合中是否存在某个对象 <code>obj</code>，Python 只需先用 <code>hash(obj)</code> 算出它的哈希值，然后直接去哈希表对应位置检查 <code>obj</code> 是否存在即可，根本不需要关心哈希表的其他部分，一步到位。</p>\n<p>如果代码需要进行 <code>in</code> 判断，可以考虑把目标容器转换成集合类型，作为查找时的索引使用：</p>\n<pre class=\"code-rows\"><code># 注意：这里的示例列表很短，所以转不转集合对性能的影响可能微乎其微\n# 在实际编码时，列表越长、执行的判断次数越多，转成集合的收益就越高\nVALID_NAMES = [\"piglei\", \"raymond\", \"bojack\", \"caroline\"]\n\n# 转换为集合类型专门用于成员判断\nVALID_NAMES_SET = set(VALID_NAMES)\n　\n　\ndef validate_name(name):\n    if name not in VALID_NAMES_SET:\n        raise ValueError(f\" is not a valid name!\")</code></pre>\n<p>除了集合，对字典进行 <code>key in ...</code> 查询同样非常快，因为二者都是基于哈希表结构实现的。</p>\n</li>\n</ol>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　除了上面提到的这些性能陷阱，你还可以阅读 Python 官方 wiki：“TimeComplexity - Python Wiki”，了解更多与常见容器操作的时间复杂度有关的内容。</p>\n</blockquote>\n<h3 id=\"nav_point_64\">3.3.3　掌握如何快速合并字典</h3>\n<p>在 Python 里，合并两个字典听上去挺简单，实际操作起来比想象中麻烦。下面有两个字典：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d1 = {'name': 'apple'}\n&gt;&gt;&gt; d2 = {'price': 10}</code></pre>\n<p>假如我想合并 <code>d1</code> 和 <code>d2</code> 的值，拿到 <code>{'name': 'apple', 'price': 10}</code>，最简单的做法是调用 <code>d1.update(d2)</code>，然后 <code>d1</code> 就会变成目标值。但这样做有个问题：它会修改字典 <code>d1</code> 的原始内容，因此并不算无副作用的合并。</p>\n<p>要在不修改原字典的前提下合并两个字典，需要定义一个函数：</p>\n<pre class=\"code-rows\"><code>def merge_dict(d1, d2):\n    # 因为字典是可修改的对象，为了避免修改原对象\n    # 此处需要复制一个 d1 的浅拷贝对象\n    result = d1.copy()\n    result.update(d2)\n    return result</code></pre>\n<p>使用 <code>merge_dict</code> 可以拿到合并后的字典：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; merge_dict(d1, d2)\n{'name': 'apple', 'price': 10}</code></pre>\n<p>使用这种方式，<code>d1</code> 和 <code>d2</code> 仍然是原来的值，不会因为合并操作被修改。</p>\n<p>虽然上面的方案可以完成合并，但显得有些烦琐。使用动态解包表达式可以更简单地完成操作。</p>\n<p>要实现合并功能，需要用到双星号 <code>**</code> 运算符来做解包操作。在字典中使用 <code>**dict_obj</code> 表达式，可以动态解包 <code>dict_obj</code> 字典的所有内容，并与当前字典合并：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d1 = {'name': 'apple'}\n# 把 d1 解包，与外部字典合并\n&gt;&gt;&gt; {'foo': 'bar', **d1}\n{'foo': 'bar', 'name': 'apple'}</code></pre>\n<p>因为解包过程会默认进行浅拷贝操作，所以我们可以用它方便地合并两个字典：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d1 = {'name': 'apple'}\n&gt;&gt;&gt; d2 = {'price': 10}\n\n# d1、d2 原始值不会受影响\n&gt;&gt;&gt; {**d1, **d2}\n{'name': 'apple', 'price': 10}</code></pre>\n<p>除了使用 <code>**</code> 解包字典，你还可以使用单星号 <code>*</code> 运算符来解包任何可迭代对象：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; [1, 2, *range(3)]\n[1, 2, 0, 1, 2]\n\n&gt;&gt;&gt; l1 = [1, 2]\n&gt;&gt;&gt; l2 = [3, 4]\n# 合并两个列表\n&gt;&gt;&gt; [*l1, *l2]\n[1, 2, 3, 4]</code></pre>\n<p>合理利用 <code>*</code> 和 <code>**</code> 运算符，可以帮助我们高效构建列表与字典对象。</p>\n<blockquote>\n<p><strong>字典的 <code>|</code> 运算符</strong></p>\n<p>在写作本书的过程中，Python 发布了 3.9 版本。在这个版本中，字典类型新增了对 <code>|</code> 运算符的支持。只要执行 <code>d1 | d2</code>，就能快速拿到两个字典合并后的结果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d1 = {'name': 'apple'}\n&gt;&gt;&gt; d2 = {'name': 'orange', 'price': 10}\n&gt;&gt;&gt; d1 | d2\n{'name': 'orange', 'price': 10}\n&gt;&gt;&gt; d2 | d1  ➊\n{'name': 'apple', 'price': 10}</code></pre>\n<blockquote>\n<p>➊ 运算顺序不同，会影响最终的合并结果</p>\n</blockquote>\n</blockquote>\n<h3 id=\"nav_point_65\">3.3.4　使用有序字典去重</h3>\n<p>前面提到过，集合里的成员不会重复，因此它经常用来去重。但是，使用集合去重有一个很大的缺点：得到的结果会丢失集合内成员原有的顺序：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; nums = [10, 2, 3, 21, 10, 3]\n# 去重但是丢失了顺序\n&gt;&gt;&gt; set(nums)\n</code></pre>\n<p>这种无序性是由集合所使用的哈希表结构所决定的，无法避免。如果你既需要去重，又想要保留原有顺序，怎么办？可以使用前文提到过的有序字典 <code>OrderedDict</code> 来完成这件事。因为 <code>OrderedDict</code> 同时满足两个条件：</p>\n<p>(1) 它的键是有序的；</p>\n<p>(2) 它的键绝对不会重复。</p>\n<p>因此，只要根据列表构建一个字典，字典的所有键就是有序去重的结果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; list(OrderedDict.fromkeys(nums).keys()) ➊\n[10, 2, 3, 21]</code></pre>\n<blockquote>\n<p>❶ 调用 <code>fromkeys</code> 方法会创建一个有序字典对象。字典的键来自方法的第一个参数：可迭代对象（此处为 <code>nums</code> 列表），字典的值默认为 <code>None</code></p>\n</blockquote>\n<h3 id=\"nav_point_66\">3.3.5　别在遍历列表时同步修改</h3>\n<p>许多人在初学 Python 时会写出类似下面的代码——遍历列表的同时根据某些条件修改它：</p>\n<pre class=\"code-rows\"><code>def remove_even(numbers):\n    \"\"\"去掉列表里所有的偶数\"\"\"\n    for number in numbers:\n        if number % 2 == 0:\n            # 有问题的代码\n            numbers.remove(number)\n\n\nnumbers = [1, 2, 7, 4, 8, 11]\nremove_even(numbers)\nprint(numbers)</code></pre>\n<p>运行上述代码会输出下面的结果：</p>\n<pre class=\"code-rows\"><code>[1, 7, 8, 11]</code></pre>\n<p>注意到那个本不该出现的数字 <code>8</code> 了吗？遍历列表的同时修改列表就会发生这样的怪事。</p>\n<p>之所以会出现这样的结果，是因为：在遍历过程中，循环所使用的索引值不断增加，而被遍历对象 <code>numbers</code> 里的成员又同时在被删除，长度不断缩短——这最终导致列表里的一些成员其实根本就没被遍历到。</p>\n<p>因此，要修改列表，请不要在遍历时直接修改。只需选择启用一个新列表来保存修改后的成员，就不会碰到这种奇怪的问题。</p>\n<h3 id=\"nav_point_67\">3.3.6　编写推导式的两个“不要”</h3>\n<p>前文提到，列表、字典、集合，都有一种特殊的压缩构建语法：推导式。这些表达式非常好用，但如果过于随意地使用，也会给代码带来一些问题。下面我们就来看看关于编写“推导式”的两个建议。</p>\n<ol>\n<li><p><strong>别写太复杂的推导式</strong></p>\n<p>在编写推导式的过程中，我们会有一种倾向——一味追求把逻辑压缩在一个表达式内，而这有时就会导致代码过于复杂，影响阅读。</p>\n<p>比如，列表推导式的狂热爱好者很可能会写出下面这样的代码：</p>\n<pre class=\"code-rows\"><code>results = [\n    task.result if task.result_version == VERSION_2 else get_legacy_result(task)\n    for tasks_group in tasks\n    for task in tasks_group\n    if task.is_active() and task.has_completed()\n]</code></pre>\n<p>上面的表达式有两层嵌套循环，在获取任务结果部分还使用了一个三元表达式，读起来非常费劲。假如用原生循环代码来改写这段逻辑，代码量不见得会多出多少，但一定会更易读：</p>\n<pre class=\"code-rows\"><code>results = []\nfor tasks_group in tasks:\n    for task in tasks_group:\n        if not (task.is_active() and task.has_completed()):\n            continue\n\n        if task.result_version == VERSION_2:\n            result = task.result\n        else:\n            result = get_legacy_result(task)\n        results.append(result)</code></pre>\n<p>当你在编写推导式时，请一定记得时常问自己：“现在的表达式逻辑是不是太复杂了？如果不用表达式，代码会不会更易懂？”假如答案是肯定的，那还是删掉表达式，用最朴实的代码来替代吧。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>别把推导式当作代码量更少的循环</strong></p>\n<p>推导式是一种高度压缩的语法，这导致开发者有可能会把它当作一种更精简的循环来使用。比如在下面的代码里，我想要处理 <code>tasks</code> 列表里的所有任务，但其实并不关心 <code>process(task)</code> 的执行结果；为了节约代码量，我把代码写成了这样：</p>\n<pre class=\"code-rows\"><code>[process(task) for task in tasks if not task.started]</code></pre>\n<p>但这样做其实并不合适。推导式的核心意义在于<strong>它会返回值</strong>——一个全新构建的列表，如果你不需要这个新列表，就失去了使用表达式的意义。直接编写循环并不会多出多少代码量，而且代码更直观：</p>\n<pre class=\"code-rows\"><code>for task in tasks:\n    if not task.started:\n        process(task)</code></pre>\n</li>\n</ol>\n<h3 id=\"nav_point_68\">3.3.7　让函数返回 <code>NamedTuple</code></h3>\n<p>在日常编码中，我们经常需要写一些返回多个值的函数。举个例子，下面这个地理位置相关的函数，用 Python 的标准做法返回了多个结果：</p>\n<pre class=\"code-rows\"><code>def latlon_to_address(lat, lon):\n    \"\"\"返回某个经纬度的地理位置信息\"\"\"\n    ...\n    # 返回多个结果——其实就是一个元组\n    return country, province, city\n\n# 所有的调用方都会这样将结果一次解包为多个变量\ncountry, province, city = latlon_to_address(lat, lon)</code></pre>\n<p>但有一天，产品需求变了，除了国家、省份和城市，调用方还需要用到一个新的位置信息：“城区”（district）。因此 <code>latlon_to_address()</code> 函数得增加一个新的返回值，返回 4 个结果：<code>country</code>、<code>province</code>、<code>city</code>、<code>district</code>。</p>\n<p>修改函数的返回结果后，为了保证兼容，你还需要找到所有调用 <code>latlon_to_address()</code> 的地方，补上多出来的 <code>district</code> 变量，否则代码就会报错：</p>\n<pre class=\"code-rows\"><code># 旧的调用方式会报错：ValueError: too many values to unpack\n# country, province, city = latlon_to_address(lat, lon)\n\n# 增加新的返回值\ncountry, province, city, district = latlon_to_address(lat, lon)\n# 或者使用 _ 忽略多出来的返回值\ncountry, province, city, _ = latlon_to_address(lat, lon)</code></pre>\n<p>但以上这些为了保证兼容性的批量修改，其实原本可以避免。</p>\n<p>对于这种<strong>未来可能会变动</strong>的多返回值函数来说，如果一开始就使用 <code>NamedTuple</code> 类型对返回结果进行建模，上面的改动会变得简单许多：</p>\n<pre class=\"code-rows\"><code>from typing import NamedTuple\n\nclass Address(NamedTuple):\n    \"\"\"地址信息结果\"\"\"\n    country: str\n    province: str\n    city: str\n\ndef latlon_to_address(lat, lon):\n    return Address(\n        country=country,\n        province=province,\n        city=city,\n    )\n\naddr = latlon_to_address(lat, lon)\n# 通过属性名来使用 addr\n# addr.country / addr.province / addr.city</code></pre>\n<p>假如我们在 <code>Address</code> 里增加了新的返回值 <code>district</code>，已有的函数调用代码也不用进行任何适配性修改，因为函数结果只是多了一个新属性，没有任何破坏性影响。</p>\n<h2 id=\"nav_point_69\">3.4　总结</h2>\n<p>在本章中，我们简单介绍了四种内置容器类型，它们是 Python 语言最为重要的组成之一。在介绍这些容器类型的过程中，我们引申出了对象的可变性、可哈希性等诸多基础概念。</p>\n<p>内置容器功能丰富，基于它构建的自定义容器更为强大，能帮助我们完成许多有趣的事情。在案例故事里，我们就通过一个自定义字典类型，优化了整个日志分析脚本。</p>\n<p>虽然无须了解列表的底层实现原理就可以使用列表，但如果你深入理解了列表是基于数组实现的，就能避开一些性能陷阱，知道在什么情况下应该选择其他数据结构实现某些需求。所以，不论使用多么高级的编程语言，掌握基础的算法与数据结构知识永远不会过时。</p>\n<p>以下是本章要点知识总结。</p>\n<p>(1) 基础知识</p>\n<ul>\n<li>在进行函数调用时，传递的不是变量的值或者引用，而是变量所指对象的引用</li>\n<li>Python 内置类型分为可变与不可变两种，可变性会影响一些操作的行为，比如 <code>+=</code></li>\n<li>对于可变类型，必要时对其进行拷贝操作，能避免产生意料之外的影响</li>\n<li>常见的浅拷贝方式：<code>copy.copy</code>、推导式、切片操作</li>\n<li>使用 <code>copy.deepcopy</code> 可以进行深拷贝操作</li>\n</ul>\n<p>(2) 列表与元组</p>\n<ul>\n<li>使用 <code>enumerate</code> 可以在遍历列表的同时获取下标</li>\n<li>函数的多返回值其实是一个元组</li>\n<li>不存在元组推导式，但可以使用 <code>tuple</code> 来将生成器表达式转换为元组</li>\n<li>元组经常用来表示一些结构化的数据</li>\n</ul>\n<p>(3) 字典与集合</p>\n<ul>\n<li>在 Python 3.7 版本前，字典类型是无序的，之后变为保留数据的插入顺序</li>\n<li>使用 <code>OrderedDict</code> 可以在 Python 3.7 以前的版本里获得有序字典</li>\n<li>只有可哈希的对象才能存入集合，或者作为字典的键使用</li>\n<li>使用有序字典 <code>OrderedDict</code> 可以快速实现有序去重</li>\n<li>使用 <code>fronzenset</code> 可以获得一个不可变的集合对象</li>\n<li>集合可以方便地进行集合运算，计算交集、并集</li>\n<li>不要通过继承 <code>dict</code> 来创建自定义字典类型</li>\n</ul>\n<p>(4) 代码可读性技巧</p>\n<ul>\n<li>具名元组比普通元组可读性更强</li>\n<li>列表推导式可以更快速地完成遍历、过滤、处理以及构建新列表操作</li>\n<li>不要编写过于复杂的推导式，用朴实的代码替代就好</li>\n<li>不要把推导式当作代码量更少的循环，写普通循环就好</li>\n</ul>\n<p>(5) 代码可维护性技巧</p>\n<ul>\n<li>当访问的字典键不存在时，可以选择捕获异常或先做判断，优先推荐捕获异常</li>\n<li>使用 <code>get</code>、<code>setdefault</code>、带参数的 <code>pop</code> 方法可以简化边界处理逻辑</li>\n<li>使用具名元组作为返回值，比普通元组更好扩展</li>\n<li>当字典键不存在时，使用 <code>defaultdict</code> 可以简化处理</li>\n<li>继承 <code>MutableMapping</code> 可以方便地创建自定义字典类，封装处理逻辑</li>\n<li>用生成器按需返回成员，比直接返回一个结果列表更灵活，也更省内存</li>\n<li>使用动态解包语法可以方便地合并字典</li>\n<li>不要在遍历列表的同时修改，否则会出现不可预期的结果</li>\n</ul>\n<p>(6) 代码性能要点</p>\n<ul>\n<li>列表的底层实现决定了它的头部操作很慢，<code>deque</code> 类型则没有这个问题</li>\n<li>当需要判断某个成员在容器中是否存在时，使用字典 / 集合更快</li>\n</ul>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 3 章 容器类型(1)","id":740839},"right":{"article_title":"第 4 章 条件分支控制流","id":740841}},"comments":[]}