{"id":470087,"title":"27｜自定义渲染器：如何实现Vue的跨端渲染 ？","content":"<p>你好，我是大圣。</p><p>上一讲我们讲完了组件库的核心知识点，这一讲我们来学习一个叫Vue 3的进阶知识点：自定义渲染器，这个功能可以自定义Vue渲染的逻辑。</p><p>在给你讲清楚原理之后，我还会带你一起实现一个Canvas的渲染器实际上手体验一下。</p><h2>什么是渲染器</h2><p>我们都知道，Vue内部的组件是以虚拟dom形式存在的。下面的代码就是一个很常见的虚拟Dom，用对象的方式去描述一个项目。相比dom标签相比，这种形式可以让整个Vue项目脱离浏览器的限制，更方便地实现Vuejs的跨端。</p><pre><code class=\"language-javascript\">{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  chidren: [\n    {\n      tag: Container,\n      props: {\n        className: 'el-container'\n      },\n      chidren: [\n        '哈喽小老弟!!!'\n      ]\n    }\n  ]\n}\n</code></pre><p>渲染器是围绕虚拟Dom存在的。在浏览器中，我们把虚拟Dom渲染成真实的Dom对象，Vue源码内部把一个框架里所有和平台相关的操作，抽离成了独立的方法。所以，我们只需要实现下面这些方法，就可以实现Vue 3在一个平台的渲染。</p><p>首先用createElement创建标签，还有用createText创建文本。创建之后就需要用insert新增元素，通过remote删除元素，通过setText更新文本和patchProps修改属性。然后再实现parentNode、nextSibling等方法实现节点的查找关系。完成这些工作，理论上就可以在一个平台内实现一个应用了。</p><!-- [[[read_end]]] --><p>在Vue 3中的runtime-core模块，就对外暴露了这些接口，runtime-core内部基于这些函数实现了整个Vue内部的所有操作，然后在runtime-dom中传入以上所有方法。</p><p>下面的代码就是Vue代码提供浏览器端操作的函数，这些DOM编程接口完成了浏览器端增加、添加和删除操作，这些API都是浏览器端独有的，如果一个框架强依赖于这些函数，那就只能在浏览器端运行。</p><pre><code class=\"language-javascript\">export const nodeOps: Omit&lt;RendererOptions&lt;Node, Element&gt;, 'patchProp'&gt; = {\n  //插入元素\n  insert: (child, parent, anchor) =&gt; {\n    parent.insertBefore(child, anchor || null)\n  },\n  // 删除元素\n  remove: child =&gt; {\n    const parent = child.parentNode\n    if (parent) {\n      parent.removeChild(child)\n    }\n  },\n  // 创建元素\n  createElement: (tag, isSVG, is, props): Element =&gt; {\n    const el = isSVG\n      ? doc.createElementNS(svgNS, tag)\n      : doc.createElement(tag, is ? { is } : undefined)\n\n    if (tag === 'select' &amp;&amp; props &amp;&amp; props.multiple != null) {\n      ;(el as HTMLSelectElement).setAttribute('multiple', props.multiple)\n    }\n\n    return el\n  }\n  //...其他操作函数\n}\n</code></pre><p>如果一个框架想要实现实现跨端的功能，那么渲染器本身不能依赖任何平台下特有的接口。</p><p>在后面的代码中，我们通过createRenderer函数区创建了一个渲染器。通过参数options获取增删改查所有的函数以后，在内部的render、mount、patch等函数中，需要去渲染一个元素的时候，就可以通过option.createElement和option.insert来实现。</p><p>这段代码给你展现的是核心逻辑，完整版本你可以看一下<a href=\"https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/renderer.ts#L334\">Vue 3的源码</a>。</p><pre><code class=\"language-javascript\">export default function createRenderer(options) {\n  const {\n\t    insert: hostInsert,\n\t    remove: hostRemove,\n\t    patchProp: hostPatchProp,\n\t    createElement: hostCreateElement,\n\t    createText: hostCreateText,\n\t    createComment: hostCreateComment,\n\t    setText: hostSetText,\n\t    setElementText: hostSetElementText,\n\t    parentNode: hostParentNode,\n\t    nextSibling: hostNextSibling,\n\t    setScopeId: hostSetScopeId = NOOP,\n\t    cloneNode: hostCloneNode,\n\t    insertStaticContent: hostInsertStaticContent\n   } = options\n\n&nbsp; function render(vnode, container) {  }\n\n&nbsp; function mount(vnode, container, isSVG, refNode) {  }\n\n&nbsp; function mountElement(vnode, container, isSVG, refNode) {  }\n\n&nbsp; function mountText(vnode, container) {  }\n\n&nbsp; function patch(prevVNode, nextVNode, container) {  }\n\n&nbsp; function replaceVNode(prevVNode, nextVNode, container) {  }\n&nbsp; function patchElement(prevVNode, nextVNode, container) {  }\n&nbsp; function patchChildren(\n&nbsp; &nbsp; prevChildFlags,\n&nbsp; &nbsp; nextChildFlags,\n&nbsp; &nbsp; prevChildren,\n&nbsp; &nbsp; nextChildren,\n&nbsp; &nbsp; container\n&nbsp; ) {  }\n\n&nbsp; function patchText(prevVNode, nextVNode) {  }\n&nbsp; function patchComponent(prevVNode, nextVNode, container) {  }\n\n&nbsp; return { render }\n}\n</code></pre><p>在每个函数实现的内部，比如mountElemnt，我们之前的实现方式是调用浏览器的API创建。</p><pre><code class=\"language-javascript\">function mountElement(vnode, container, isSVG, refNode) {\n&nbsp; const el = isSVG\n&nbsp; &nbsp; ? document.createElementNS(....)\n&nbsp; &nbsp; : document.createElement(vnode.tag)\n}\n\n</code></pre><p>对比一下，经过渲染器抽离之后，内部的mountElmenet就会把所有document的操作全部换成options传递进来的hostCreate函数。</p><pre><code class=\"language-javascript\">function mountElement(vnode, container, isSVG, refNode) {\n&nbsp; const el = hostCreateElement(vnode.tag, isSVG)\n}\n</code></pre><p>然后，我们使用后面的代码创建一个具体平台的渲染器，这也是Vue 3中的runtime-dom包主要做的事。了解了Vue中自定义渲染器的实现方式后，我们还可以基于Vue 3的runtime-core包封装其他平台的渲染器，让其他平台也能使用Vue内部的响应式和组件化等优秀的特性。</p><pre><code class=\"language-javascript\">const { render } = createRenderer({\n&nbsp; nodeOps: {\n&nbsp; &nbsp; createElement() {   },\n&nbsp; &nbsp; createText() {   }\n&nbsp; &nbsp; // more...\n&nbsp; },\n&nbsp; patchData\n})\n\n</code></pre><h2>自定义渲染</h2><p>说完了渲染器创建，我们再来看看自定义渲染。</p><p>自定义渲染器让Vue脱离了浏览器的限制，我们只需要实现平台内部的增删改查函数后，就可以直接对接Vue 3。比方说，我们可以把Vue渲染到小程序平台，实现Vue 3-minipp；也可以渲染到Canvas，实现vue 3-canvas，把虚拟dom渲染成Canvas；甚至还可以尝试把Vue 3渲染到threee.js中，在3D世界使用响应式开发。</p><p>接下来，我们一起尝试实现一个Canvas的渲染器。具体操作是这样的，我们在项目的src目录下新建renderer.js，通过这个文件实现一个简易的Canvas渲染逻辑。Canvas平台中操作的方式相对简单，没有太多节点的概念，我们可以把整个Canvas维护成一个对象，每次操作的时候直接把Canvas重绘一下就可以了。</p><pre><code class=\"language-javascript\">import { createRenderer } from '@vue/runtime-core'\nconst { createApp: originCa } = createRenderer({\n  insert: (child, parent, anchor) =&gt; {\n  },\n  createElement(type, isSVG, isCustom) {\n  },\n  setElementText(node, text) {\n  },\n  patchProp(el, key, prev, next) {\n  },\n});\n</code></pre><p>下面的代码中我们实现了draw函数，这里我们就是用Canvas的操作方法<strong>递归</strong>地把Canvas对象渲染到Canvas标签内部。</p><pre><code class=\"language-javascript\">let ctx\nfunction draw(ele, isChild) {\n  if (!isChild) {\n    ctx.clearRect(0, 0, 500, 500)\n  }\n\n  ctx.fillStyle = ele.fill || 'white'\n  ctx.fillRect(...ele.pos)\n  if (ele.text) {\n    ctx.fillStyle = ele.color || 'white'\n    ele.fontSize = ele.type == \"h1\" ? 20 : 12\n    ctx.font = (ele.fontSize || 18) + 'px serif'\n    ctx.fillText(ele.text, ele.pos[0] + 10, ele.pos[1] + ele.fontSize)\n  }\n  ele.child &amp;&amp; ele.child.forEach(c =&gt; {\n    console.log('child:::', c)\n    draw(c, true)\n  })\n\n}\n</code></pre><p>由于我们主体需要维护的逻辑就是对于对象的操作，所以创建和更新操作直接操作对象即可。新增insert需要维护parent和child元素。另外，插入的时候也需要调用draw函数，并且需要监听onclick事件。</p><pre><code class=\"language-javascript\">const { createApp: originCa } = createRenderer({\n  insert: (child, parent, anchor) =&gt; {\n    if (typeof child == 'string') {\n      parent.text = child\n    } else {\n      child.parent = parent\n      if (!parent.child) {\n        parent.child = [child]\n      } else {\n        parent.child.push(child)\n      }\n    }\n    if (parent.nodeName) {\n      draw(child)\n      if (child.onClick) {\n        ctx.canvas.addEventListener('click', () =&gt; {\n          child.onClick()\n          setTimeout(() =&gt; {\n            draw(child)\n          })\n        }, false)\n      }\n    }\n  },\n  createElement(type, isSVG, isCustom) {\n    return {\n      type\n    }\n  },\n  setElementText(node, text) {\n    node.text = text\n  },\n  patchProp(el, key, prev, next) {\n    el[key] = next\n  },\n\n});\n</code></pre><p>现在我们来到src/main.js中，这时候就不能直接从vue中引入createApp了，而是需要从runtime-core中导入createRenderer。</p><p>接下来，通过createRenderer用我们自已定义的renderer去创建createApp，并且重写mount函数。在Canvas的mount中，我们需要创建Canvas标签并且挂载到App上。</p><pre><code class=\"language-javascript\">import { createRenderer } from '@vue/runtime-core'\nconst { createApp: originCa } = createRenderer({\n\n}）\nfunction createApp(...args) {\n  const app = originCa(...args)\n  return {\n    mount(selector) {\n      const canvas = document.createElement('canvas')\n      canvas.width = window.innerWidth\n      canvas.height = window.innerHeight\n      document.querySelector(selector).appendChild(canvas)\n      ctx = canvas.getContext('2d')\n      app.mount(canvas)\n    }\n  }\n}\n</code></pre><p>下一步进入src/App.vue中，我们就可以在Vue组件中使用ref等响应式的写法了。我们实现了通过ref返回的响应式对象，渲染Canvas内部的文字和高度，并且点击的时候还可以修改文字。完成上面的操作，我们就实现了Canvas平台的基本渲染。</p><pre><code class=\"language-xml\">&lt;template&gt;\n&lt;div @click=\"setName('vue3真棒')\" :pos=\"[10,10,300,300]\" fill=\"#eee\"&gt;\n    &lt;h1 :pos=\"[20,20,200,100]\" fill=\"red\" color=\"#000\"&gt;累加器{{count}}&lt;/h1&gt;\n    &lt;span :pos=\"pos\" fill=\"black\" &gt;哈喽{{name}}&lt;/span&gt;\n&lt;/div&gt;\n\n\n\n&lt;/template&gt;\n\n&lt;script setup&gt;\n\nimport {ref} from 'vue'\nconst name = ref('vue3入门')\nconst pos = ref([20,120,200,100])\nconst count = ref(1)\nconst setName = (n)=&gt;{\n&nbsp; name.value = n\n&nbsp; pos.value[1]+=20\n&nbsp; count.value+=2\n}\n&lt;/script&gt;\n</code></pre><p>上面的代码在浏览器里就会有下图的显示效果。我们点击Canvas后，文案就会显示为“哈喽vue3真棒”，并且黑色方块和红色方块的距离也会变大。<br>\n<img src=\"https://static001.geekbang.org/resource/image/b4/7b/b466ca102ef94ebce2d05c865ca4637b.png?wh=1920x992\" alt=\"图片\"></p><p>基于这个原理，我们其实可以做很多有意思的尝试，社区也也有越来越多开源的Vue 3的自定义渲染器，比如小程序跨端框架uni-app，Vugel可以使用Vue渲染Webgl等，你也可以动手多多体验。</p><p>比如下面的代码中，我们对three.js进行一个渲染的尝试。它的实现逻辑和Canvas比较类似，通过对于对象的维护和draw函数实现最终的绘制。在draw函数内部，我们调用three.js的操作方法去创建camera，sence，geometry等概念，最后对外暴露three.js的createApp函数。</p><pre><code class=\"language-xml\">import { createRenderer } from '@vue/runtime-core'\nimport * as THREE from 'three'\nimport {nextTick} from '@vue/runtime-core'\n\nlet renderer\n\nfunction draw(obj) {\n    const {camera,cameraPos, scene, geometry,geometryArg,material,mesh,meshY,meshX} = obj\n    if([camera,cameraPos, scene, geometry,geometryArg,material,mesh,meshY,meshX].filter(v=&gt;v).length&lt;9){\n        return \n    }\n    let cameraObj = new THREE[camera]( 40, window.innerWidth / window.innerHeight, 0.1, 10 )\n    Object.assign(cameraObj.position,cameraPos)\n\n    let sceneObj = new THREE[scene]()\n\n    let geometryObj = new THREE[geometry]( ...geometryArg)\n    let materialObj = new THREE[material]()\n\n    let meshObj = new THREE[mesh]( geometryObj, materialObj )\n    meshObj.rotation.x = meshX\n    meshObj.rotation.y = meshY\n    sceneObj.add( meshObj )\n    renderer.render( sceneObj, cameraObj );\n\n}\n\nconst { createApp: originCa } = createRenderer({\n  insert: (child, parent, anchor) =&gt; {\n    if(parent.domElement){\n        draw(child)\n    }\n  },\n  createElement(type, isSVG, isCustom) {\n    return {\n      type\n    }\n  },\n  setElementText(node, text) {\n  },\n  patchProp(el, key, prev, next) {\n    el[key] = next\n    draw(el)\n  },\n  parentNode: node =&gt; node,\n  nextSibling: node =&gt; node,\n  createText: text =&gt; text,\n  remove:node=&gt;node\n\n});\nfunction createApp(...args) {\n  const app = originCa(...args)\n  return {\n    mount(selector) {\n        renderer = new THREE.WebGLRenderer( { antialias: true } );\n        renderer.setSize( window.innerWidth, window.innerHeight );\n        document.body.appendChild( renderer.domElement );\n        app.mount(renderer)\n    }\n  }\n}\nexport { createApp }\n\n\n\n</code></pre><p>然后我们在App.vue中，使用下面的代码渲染出一个立方体，并且通过ref响应式对象控制立方体偏移的监督，再通过setInterval实现立方体的动画，实现下图的反转效果。</p><pre><code class=\"language-xml\">&lt;template&gt;\n&nbsp; &nbsp; &lt;div\n&nbsp; &nbsp; &nbsp; &nbsp; camera=\"PerspectiveCamera\"\n&nbsp; &nbsp; &nbsp; &nbsp; :cameraPos={z:1}\n&nbsp; &nbsp; &nbsp; &nbsp; scene=\"Scene\"\n&nbsp; &nbsp; &nbsp; &nbsp; geometry=\"BoxGeometry\"\n&nbsp; &nbsp; &nbsp; &nbsp; :geometryArg=\"[0.2,0.2,0.2]\"\n&nbsp; &nbsp; &nbsp; &nbsp; material=\"MeshNormalMaterial\"\n&nbsp; &nbsp; &nbsp; &nbsp; mesh=\"Mesh\"\n&nbsp; &nbsp; &nbsp; &nbsp; :meshY=\"y\"\n&nbsp; &nbsp; &nbsp; &nbsp; :meshX=\"x\"\n&nbsp; &nbsp; &gt;\n&nbsp; &nbsp; &lt;/div&gt;\n\n&lt;/template&gt;\n\n&lt;script&gt;\nimport {ref} from 'vue'\nexport default {\n&nbsp; &nbsp; setup(){\n&nbsp; &nbsp; &nbsp; &nbsp; const y = ref(0.3)\n&nbsp; &nbsp; &nbsp; &nbsp; const x = ref(0.3)\n&nbsp; &nbsp; &nbsp; &nbsp; setInterval(()=&gt;{\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y.value+=0.3\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x.value+=0.5\n&nbsp; &nbsp; &nbsp; &nbsp; },100)\n&nbsp; &nbsp; &nbsp; &nbsp; return {y,x}\n&nbsp; &nbsp; }\n}\n&lt;/script&gt;\n</code></pre><p>反转效果演示如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/b0/4f/b0b20b2a314bcf650b8b56256bdf804f.gif?wh=1182x761\" alt=\"图片\"></p><p>我们还可以在Canvas的封装上更进一步，并且实现对一些Canvas已有框架Pixi.js的封装，这样就可以通过Vue 3的响应式的开发方式，快速开发一个小游戏。</p><p>下面的代码中就是针对Pixi.js实现的封装函数，你可以看一下。</p><pre><code class=\"language-xml\"> import {Graphics} from \"PIXI.js\";\n\nexport const getNodeOps = (app) =&gt; {\n  return {\n    insert: (child, parent, anchor) =&gt; {\n      parent.addChild(child);\n    },\n\n    remove: (child) =&gt; {\n      const parent = child.parentNode;\n      if (parent) {\n        parent.removeChild(child);\n      }\n    },\n\n    createElement: (tag, isSVG, is) =&gt; {\n      let element;\n      if (tag === \"Rectangle\") {\n        // 创建一个矩形\n        element = new window.PIXI.Graphics();\n        element.lineStyle(4, 0xff3300, 1);\n        element.beginFill(0x66ccff);\n        element.drawRect(0, 0, 64, 64);\n        element.endFill();\n        element.x = 0;\n        element.y = 0;\n        // Opt-in to interactivity\n        element.interactive = true;\n\n        // Shows hand cursor\n        element.buttonMode = true;\n      } else if (tag === \"Sprite\") {\n        element = new window.PIXI.Sprite();\n        element.x = 0;\n        element.y = 0;\n      } else if (tag === \"Container\") {\n        element = new window.PIXI.Container();\n        element.x = 0;\n        element.y = 0;\n      }\n\n      return element;\n    },\n\n    createText: (text) =&gt; doc.createTextNode(text),\n\n    createComment: (text) =&gt; {\n    //   console.log(text);\n    },\n\n    setText: (node, text) =&gt; {\n      node.nodeValue = text;\n    },\n\n    setElementText: (el, text) =&gt; {\n      el.textContent = text;\n    },\n\n    parentNode: (node) =&gt; node.parentNode,\n\n    nextSibling: (node) =&gt; node.nextSibling,\n\n    querySelector: (selector) =&gt; doc.querySelector(selector),\n\n    setScopeId(el, id) {\n      el.setAttribute(id, \"\");\n    },\n\n    cloneNode(el) {\n      return el.cloneNode(true);\n    },\n  };\n};\n</code></pre><p>Pixi中的属性修改可以使用下面的代码，判断x、y、width和on属性不同的操作，就是用响应式包裹了Pixi的对象。关于Vue 3和Pixi实现的代码效果，你可以在<a href=\"https://github.dev/shengxinjing/vue3-vs-vue2/blob/0911af848941c2eeb2783c32c1907fd286134be1/vue3-runtime-canvas/index.js\">GitHub</a>看到全部的源码。</p><pre><code class=\"language-xml\">export const patchProp = (\n  el,\n  key,\n  prevValue,\n  nextValue,\n  isSVG = false,\n) =&gt; {\n  switch (key) {\n    case \"x\":\n    case \"y\":\n    case \"width\":\n    case \"height\":\n        el[key] = nextValue;\n        break;\n    case \"on\":\n      Object.keys(nextValue).forEach((eventName) =&gt; {\n        const callback = nextValue[eventName];\n        el.on(eventName, callback);\n      });\n      break;\n    case \"texture\":\n        let texture = PIXI.Texture.from(nextValue);\n        el.texture = texture;\n        break;\n  }\n};\n\n</code></pre><h2>总结</h2><p>今天聊的内容到此就结束了，我们来总结一下今天学到的知识点。</p><p>首先我们了解了自定义渲染器的原理，就是<strong>把所有的增删改查操作暴露出去，使用的时候不需要知道内部的实现细节，我们只需要针对每个平台使用不同的API即可</strong>。</p><p>你可以这样理解，就像武侠小说中高手可以通过给你传输内力的方式控制你进行比武。我们打出去的每招每式都是来源于背后的高手，只不过自己做了简单的适配。在Vue渲染器的设计中就把document所有的操作都抽离成了nodeOps，并且通过调用Vue的createRenderer函数创建平台的渲染器。</p><p>这样一来，只要我们实现了Canvas平台的增删改查，就可以在Canvas的世界中使用Vue的响应式语法控制绘图和做游戏，Vue生态中对小程序和原生app的支持原理也是基于自定义渲染器实现的。</p><p>其实，自定义渲染器也代表着适配器设计模式的一个实践。除了自定义渲染器 API 的学习，我们也要反思一下自己现在负责的项目中，有哪些地方为了不同的接口或者平台写了太多的判断代码，是否也可以使用类似自定义渲染器的逻辑和模式，把多个组件、平台、接口之间不同的操作方式封装成一个核心模块，去进行单独函数的扩展。</p><h2>思考题</h2><p>最后留个思考题给你，Vue如何在node环境中渲染呢？欢迎在评论区分享你的答案，我们下一讲再见！</p>","comments":[{"had_liked":false,"id":327538,"user_name":"ll","can_delete":false,"product_type":"c1","uid":1296458,"ip_address":"","ucode":"57C5DAC5B51036","user_header":"https://static001.geekbang.org/account/avatar/00/13/c8/4a/3a322856.jpg","comment_is_top":false,"comment_ctime":1640164957,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"53179772509","product_id":100094401,"comment_content":"开眼界的一课。平时工作中涉及相关内容较少，所以这部分的内容还需课下多练几遍。<br>结合之前所学，写几点感想，首先有以下几种“过程”;<br>1. html --&gt; dom --&gt; 浏览器<br>2. html --&gt; v-dom --&gt; dom --&gt; 浏览器<br>3. svg, canvas, webgl --&gt; v-dom --&gt; dom --&gt; 浏览器<br>4. html等 --&gt; v-dom --&gt; dom --&gt; &quot;web内核&quot; --&gt; 其他平台<br>5. html等 --&gt; v-dom --&gt; &quot;xxx object model&quot; --&gt; 其他平台<br>然后，<br>vue 的角色是提供了操作 v-dom 的“方式”，并且在 v-dom --&gt; dom 这个过程中，非常&quot;高效&quot;且&quot;专业&quot;,<br><br>今天的内容聚焦过程 4. 的前半段，即 html等 --&gt; v-dom.<br><br>为什么？或者解决了什么问题？ 答: 我们操作 v-dom 的方式不会因需要”适配“不同的&quot;标准&quot;而发生”任何“改变。<br><br>怎么实现的？svg，canvas 等怎么变成“统一”的 v-dom，需要什么？vue 也给你提供了 createRenderer。<br><br>“适配器&quot;出场了，在代码抽象实现上来说就是“适配器模式”。我开始看文章时猜的是“策略模式”，当然我学艺不精，这也是个复习“设计模式”的好机会。<br><br>至于思考题，Vue 在 在 node 环境中渲染我能想到的应用场景，是前后端同构，SSR，SSG，产生这个问题的根本原因就是，node 它不懂 “dom&quot;, 不懂怎么办？配个翻译？要不你翻译成它能懂的再给它？<br><br>已上，就是我的一些大致想法，谬误之处还望大家不吝赐教。","like_count":12,"discussions":[{"author":{"id":1217641,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/69/4937e1e4.jpg","nickname":"Sean","note":"","ucode":"2178FD5B59B620","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563223,"discussion_content":"3. svg, canvas, webgl --&gt; v-dom --&gt; dom --&gt; 浏览器\n这个不对，本质上是object（v-dom）转成dom、canvas、webgal-&gt;浏览器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649951176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1296458,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c8/4a/3a322856.jpg","nickname":"ll","note":"","ucode":"57C5DAC5B51036","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548005,"discussion_content":"补充一下，vue 操作的是 v-dom， 渲染器”生成“ v-dom，不同平台提供不同 options ”供“ 渲染器生成 v-dom","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642993846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327420,"user_name":"Johnson","can_delete":false,"product_type":"c1","uid":1326108,"ip_address":"","ucode":"C6B6FF9EA4CC60","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/1c/47e5b7aa.jpg","comment_is_top":false,"comment_ctime":1640131172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23114967652","product_id":100094401,"comment_content":"这一讲的跨端原理讲解太实用啦！😁","like_count":5},{"had_liked":false,"id":342133,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1217641,"ip_address":"","ucode":"2178FD5B59B620","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/69/4937e1e4.jpg","comment_is_top":false,"comment_ctime":1650032232,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5944999528","product_id":100094401,"comment_content":"老师 这没有代码 可以运行一下吗","like_count":1},{"had_liked":false,"id":341737,"user_name":"乐多","can_delete":false,"product_type":"c1","uid":1562891,"ip_address":"","ucode":"286632BFF7D68D","user_header":"https://static001.geekbang.org/account/avatar/00/17/d9/0b/d842b71a.jpg","comment_is_top":false,"comment_ctime":1649815810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5944783106","product_id":100094401,"comment_content":"老师，这一讲的源码哪里有？","like_count":1},{"had_liked":false,"id":327511,"user_name":"无双","can_delete":false,"product_type":"c1","uid":1238757,"ip_address":"","ucode":"405779043D091E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/e5/e3daa1a7.jpg","comment_is_top":false,"comment_ctime":1640157462,"is_pvip":false,"replies":[{"id":"119454","content":"可以看下这个库<br>https:&#47;&#47;github.com&#47;troisjs&#47;trois","user_name":"作者回复","comment_id":327511,"uid":"1003715","ip_address":"","utype":1,"ctime":1640529793,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5935124758","product_id":100094401,"comment_content":"想深入了解一下three.js和vue的结合，有没有这方面的资料，或者最佳实践？","like_count":2,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541720,"discussion_content":"可以看下这个库\nhttps://github.com/troisjs/trois","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640529793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356432,"user_name":"迷路森林","can_delete":false,"product_type":"c1","uid":2740863,"ip_address":"四川","ucode":"2A381C5A140A85","user_header":"https://static001.geekbang.org/account/avatar/00/29/d2/7f/44fbd96b.jpg","comment_is_top":false,"comment_ctime":1662301345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662301345","product_id":100094401,"comment_content":"我的renderer.js文件一直渲染不出来，请问是要安装什么依赖包吗","like_count":0},{"had_liked":false,"id":356145,"user_name":"Chaos浩","can_delete":false,"product_type":"c1","uid":1675943,"ip_address":"浙江","ucode":"4FFAE6EEAA460B","user_header":"https://static001.geekbang.org/account/avatar/00/19/92/a7/00fefed5.jpg","comment_is_top":false,"comment_ctime":1662010044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662010044","product_id":100094401,"comment_content":"还是这种内容更吸引人","like_count":0},{"had_liked":false,"id":352395,"user_name":"东方奇骥","can_delete":false,"product_type":"c1","uid":1354850,"ip_address":"","ucode":"DEE7085F7E55A4","user_header":"https://static001.geekbang.org/account/avatar/00/14/ac/62/37912d51.jpg","comment_is_top":false,"comment_ctime":1658643036,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658643036","product_id":100094401,"comment_content":"好文！最近工作中正要自定义stater，没想道就找到了。","like_count":0},{"had_liked":false,"id":349593,"user_name":"江无花","can_delete":false,"product_type":"c1","uid":1599154,"ip_address":"","ucode":"AE415FD7A202DF","user_header":"https://static001.geekbang.org/account/avatar/00/18/66/b2/cf691f56.jpg","comment_is_top":false,"comment_ctime":1656127489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656127489","product_id":100094401,"comment_content":"Vue 如何在 node 环境中渲染，这个其实没太明白。是指在node环境中，使用命令行输出？","like_count":0},{"had_liked":false,"id":342137,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1217641,"ip_address":"","ucode":"2178FD5B59B620","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/69/4937e1e4.jpg","comment_is_top":false,"comment_ctime":1650033378,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650033378","product_id":100094401,"comment_content":"源码地址：https:&#47;&#47;github.com&#47;shengxinjing&#47;vue3-vs-vue2.git","like_count":0},{"had_liked":false,"id":337579,"user_name":"李文华","can_delete":false,"product_type":"c1","uid":1613802,"ip_address":"","ucode":"DC570A509F7EEB","user_header":"https://static001.geekbang.org/account/avatar/00/18/9f/ea/b587985a.jpg","comment_is_top":false,"comment_ctime":1646901584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646901584","product_id":100094401,"comment_content":"第一个例子累加器值并不会增加","like_count":0},{"had_liked":false,"id":329798,"user_name":"Geek_15264a","can_delete":false,"product_type":"c1","uid":2829354,"ip_address":"","ucode":"3D5C9171F8A3B2","user_header":"","comment_is_top":false,"comment_ctime":1641543462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641543462","product_id":100094401,"comment_content":"最终找到了，感觉还是需要把本节涉及的源码，在显眼的位置贴出来，找到本章中提的一个链接，打开有问题，结果直接去你的github仓库下找到对应的代码","like_count":0},{"had_liked":false,"id":327419,"user_name":"海阔天空","can_delete":false,"product_type":"c1","uid":1327016,"ip_address":"","ucode":"16C87A0052A08B","user_header":"https://static001.geekbang.org/account/avatar/00/14/3f/a8/8da58e53.jpg","comment_is_top":false,"comment_ctime":1640130870,"is_pvip":false,"replies":[{"id":"119158","content":"哪里不懂留言讨论啊～","user_name":"编辑回复","comment_id":327419,"uid":"1501385","ip_address":"","utype":2,"ctime":1640137560,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1640130870","product_id":100094401,"comment_content":"有很多都不是很懂。。。","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540687,"discussion_content":"哪里不懂留言讨论啊～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640137560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]}]}