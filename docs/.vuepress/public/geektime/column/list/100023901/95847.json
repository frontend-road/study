{"id":95847,"title":"35 | 两阶段终止模式：如何优雅地终止线程？","content":"<p>前面两篇文章我们讲述的内容，从纯技术的角度看，都是<strong>启动</strong>多线程去执行一个异步任务。既启动，那又该如何终止呢？今天咱们就从技术的角度聊聊如何优雅地<strong>终止</strong>线程，正所谓有始有终。</p><p>在<a href=\"https://time.geekbang.org/column/article/86366\">《09 | Java线程（上）：Java线程的生命周期》</a>中，我曾讲过：线程执行完或者出现异常就会进入终止状态。这样看，终止一个线程看上去很简单啊！一个线程执行完自己的任务，自己进入终止状态，这的确很简单。不过我们今天谈到的“优雅地终止线程”，不是自己终止自己，而是在一个线程T1中，终止线程T2；这里所谓的“优雅”，指的是给T2一个机会料理后事，而不是被一剑封喉。</p><p>Java语言的Thread类中曾经提供了一个stop()方法，用来终止线程，可是早已不建议使用了，原因是这个方法用的就是一剑封喉的做法，被终止的线程没有机会料理后事。</p><p>既然不建议使用stop()方法，那在Java领域，我们又该如何优雅地终止线程呢？</p><h2>如何理解两阶段终止模式</h2><p>前辈们经过认真对比分析，已经总结出了一套成熟的方案，叫做<strong>两阶段终止模式</strong>。顾名思义，就是将终止过程分成两个阶段，其中第一个阶段主要是线程T1向线程T2<strong>发送终止指令</strong>，而第二阶段则是线程T2<strong>响应终止指令</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/a5/5c/a5ea3cb2106f11ef065702f34703645c.png?wh=1142*278\" alt=\"\"></p><center><span class=\"reference\">两阶段终止模式示意图</span></center><!-- [[[read_end]]] --><p>那在Java语言里，终止指令是什么呢？这个要从Java线程的状态转换过程说起。我们在<a href=\"https://time.geekbang.org/column/article/86366\">《09 | Java线程（上）：Java线程的生命周期》</a>中曾经提到过Java线程的状态转换图，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/8c/3f6c6bf95a6e8627bdf3cb621bbb7f8c.png?wh=1142*714\" alt=\"\"></p><center><span class=\"reference\">Java中的线程状态转换图</span></center><p>从这个图里你会发现，Java线程进入终止状态的前提是线程进入RUNNABLE状态，而实际上线程也可能处在休眠状态，也就是说，我们要想终止一个线程，首先要把线程的状态从休眠状态转换到RUNNABLE状态。如何做到呢？这个要靠Java Thread类提供的<strong>interrupt()方法</strong>，它可以将休眠状态的线程转换到RUNNABLE状态。</p><p>线程转换到RUNNABLE状态之后，我们如何再将其终止呢？RUNNABLE状态转换到终止状态，优雅的方式是让Java线程自己执行完 run() 方法，所以一般我们采用的方法是<strong>设置一个标志位</strong>，然后线程会在合适的时机检查这个标志位，如果发现符合终止条件，则自动退出run()方法。这个过程其实就是我们前面提到的第二阶段：<strong>响应终止指令</strong>。</p><p>综合上面这两点，我们能总结出终止指令，其实包括两方面内容：<strong>interrupt()方法</strong>和<strong>线程终止的标志位</strong>。</p><p>理解了两阶段终止模式之后，下面我们看一个实际工作中的案例。</p><h2>用两阶段终止模式终止监控操作</h2><p>实际工作中，有些监控系统需要动态地采集一些数据，一般都是监控系统发送采集指令给被监控系统的监控代理，监控代理接收到指令之后，从监控目标收集数据，然后回传给监控系统，详细过程如下图所示。出于对性能的考虑（有些监控项对系统性能影响很大，所以不能一直持续监控），动态采集功能一般都会有终止操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/11/5f/11e3b0a4a9cf743124091b22e10d275f.png?wh=1142*339\" alt=\"\"></p><center><span class=\"reference\">动态采集功能示意图</span></center><p>下面的示例代码是<strong>监控代理</strong>简化之后的实现，start()方法会启动一个新的线程rptThread来执行监控数据采集和回传的功能，stop()方法需要优雅地终止线程rptThread，那stop()相关功能该如何实现呢？</p><pre><code>class Proxy {\n  boolean started = false;\n  //采集线程\n  Thread rptThread;\n  //启动采集功能\n  synchronized void start(){\n    //不允许同时启动多个采集线程\n    if (started) {\n      return;\n    }\n    started = true;\n    rptThread = new Thread(()-&gt;{\n      while (true) {\n        //省略采集、回传实现\n        report();\n        //每隔两秒钟采集、回传一次数据\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e) {  \n        }\n      }\n      //执行到此处说明线程马上终止\n      started = false;\n    });\n    rptThread.start();\n  }\n  //终止采集功能\n  synchronized void stop(){\n    //如何实现？\n  }\n}  \n</code></pre><p>按照两阶段终止模式，我们首先需要做的就是将线程rptThread状态转换到RUNNABLE，做法很简单，只需要在调用 <code>rptThread.interrupt()</code> 就可以了。线程rptThread的状态转换到RUNNABLE之后，如何优雅地终止呢？下面的示例代码中，我们选择的标志位是线程的中断状态：<code>Thread.currentThread().isInterrupted()</code> ，需要注意的是，我们在捕获Thread.sleep()的中断异常之后，通过 <code>Thread.currentThread().interrupt()</code> 重新设置了线程的中断状态，因为JVM的异常处理会清除线程的中断状态。</p><pre><code>class Proxy {\n  boolean started = false;\n  //采集线程\n  Thread rptThread;\n  //启动采集功能\n  synchronized void start(){\n    //不允许同时启动多个采集线程\n    if (started) {\n      return;\n    }\n    started = true;\n    rptThread = new Thread(()-&gt;{\n      while (!Thread.currentThread().isInterrupted()){\n        //省略采集、回传实现\n        report();\n        //每隔两秒钟采集、回传一次数据\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e){\n          //重新设置线程中断状态\n          Thread.currentThread().interrupt();\n        }\n      }\n      //执行到此处说明线程马上终止\n      started = false;\n    });\n    rptThread.start();\n  }\n  //终止采集功能\n  synchronized void stop(){\n    rptThread.interrupt();\n  }\n}\n</code></pre><p>上面的示例代码的确能够解决当前的问题，但是建议你在实际工作中谨慎使用。原因在于我们很可能在线程的run()方法中调用第三方类库提供的方法，而我们没有办法保证第三方类库正确处理了线程的中断异常，例如第三方类库在捕获到Thread.sleep()方法抛出的中断异常后，没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。所以强烈建议你<strong>设置自己的线程终止标志位</strong>，例如在下面的代码中，使用isTerminated作为线程终止标志位，此时无论是否正确处理了线程的中断异常，都不会影响线程优雅地终止。</p><pre><code>class Proxy {\n  //线程终止标志位\n  volatile boolean terminated = false;\n  boolean started = false;\n  //采集线程\n  Thread rptThread;\n  //启动采集功能\n  synchronized void start(){\n    //不允许同时启动多个采集线程\n    if (started) {\n      return;\n    }\n    started = true;\n    terminated = false;\n    rptThread = new Thread(()-&gt;{\n      while (!terminated){\n        //省略采集、回传实现\n        report();\n        //每隔两秒钟采集、回传一次数据\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e){\n          //重新设置线程中断状态\n          Thread.currentThread().interrupt();\n        }\n      }\n      //执行到此处说明线程马上终止\n      started = false;\n    });\n    rptThread.start();\n  }\n  //终止采集功能\n  synchronized void stop(){\n    //设置中断标志位\n    terminated = true;\n    //中断线程rptThread\n    rptThread.interrupt();\n  }\n}\n</code></pre><h2>如何优雅地终止线程池</h2><p>Java领域用的最多的还是线程池，而不是手动地创建线程。那我们该如何优雅地终止线程池呢？</p><p>线程池提供了两个方法：<strong>shutdown()<strong>和</strong>shutdownNow()</strong>。这两个方法有什么区别呢？要了解它们的区别，就先需要了解线程池的实现原理。</p><p>我们曾经讲过，Java线程池是生产者-消费者模式的一种实现，提交给线程池的任务，首先是进入一个阻塞队列中，之后线程池中的线程从阻塞队列中取出任务执行。</p><p>shutdown()方法是一种很保守的关闭线程池的方法。线程池执行shutdown()后，就会拒绝接收新的任务，但是会等待线程池中正在执行的任务和已经进入阻塞队列的任务都执行完之后才最终关闭线程池。</p><p>而shutdownNow()方法，相对就激进一些了，线程池执行shutdownNow()后，会拒绝接收新的任务，同时还会中断线程池中正在执行的任务，已经进入阻塞队列的任务也被剥夺了执行的机会，不过这些被剥夺执行机会的任务会作为shutdownNow()方法的返回值返回。因为shutdownNow()方法会中断正在执行的线程，所以提交到线程池的任务，如果需要优雅地结束，就需要正确地处理线程中断。</p><p>如果提交到线程池的任务不允许取消，那就不能使用shutdownNow()方法终止线程池。不过，如果提交到线程池的任务允许后续以补偿的方式重新执行，也是可以使用shutdownNow()方法终止线程池的。<a href=\"time://mall?url=https%3A%2F%2Fh5.youzan.com%2Fv2%2Fgoods%2F2758xqdzr6uuw\">《Java并发编程实战》</a>这本书第7章《取消与关闭》的“shutdownNow的局限性”一节中，提到一种将已提交但尚未开始执行的任务以及已经取消的正在执行的任务保存起来，以便后续重新执行的方案，你可以参考一下，方案很简单，这里就不详细介绍了。</p><p>其实分析完shutdown()和shutdownNow()方法你会发现，它们实质上使用的也是两阶段终止模式，只是终止指令的范围不同而已，前者只影响阻塞队列接收任务，后者范围扩大到线程池中所有的任务。</p><h2>总结</h2><p>两阶段终止模式是一种应用很广泛的并发设计模式，在Java语言中使用两阶段终止模式来优雅地终止线程，需要注意两个关键点：一个是仅检查终止标志位是不够的，因为线程的状态可能处于休眠态；另一个是仅检查线程的中断状态也是不够的，因为我们依赖的第三方类库很可能没有正确处理中断异常。</p><p>当你使用Java的线程池来管理线程的时候，需要依赖线程池提供的shutdown()和shutdownNow()方法来终止线程池。不过在使用时需要注意它们的应用场景，尤其是在使用shutdownNow()的时候，一定要谨慎。</p><h2>课后思考</h2><p>本文的示例代码中，线程终止标志位isTerminated被声明为volatile，你觉得是否有必要呢？</p><pre><code>class Proxy {\n  //线程终止标志位\n  volatile boolean terminated = false;\n  ......\n}\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"34 | Worker Thread模式：如何避免重复创建线程？","id":95525},"right":{"article_title":"36 | 生产者-消费者模式：用流水线思想提高效率","id":96168}},"comments":[{"had_liked":false,"id":96158,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1558346219,"is_pvip":false,"replies":[{"id":"34431","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558357938,"ip_address":"","comment_id":96158,"utype":1}],"discussion_count":4,"race_medal":0,"score":"254961416683","product_id":100023901,"comment_content":"stop和start方法对于terminated访问由于syn关键字，线程安全，但是start中新起了一个线程rptthread，导致stop方法中对于terminated存在可见性问题，因此需要volatie，原子性问题对这个代码段没有影响，所以原子性问题无需关注。","like_count":60,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450745,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558357938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1655940,"avatar":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","nickname":"呆瓜","note":"","ucode":"C98C7B224D0640","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343653,"discussion_content":"应该是:stop()修改terminated后,rptThread对terminated值的可见性存在问题!","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1611123938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008933,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/65/25/c6de04bc.jpg","nickname":"斜月浮云","note":"","ucode":"25CECBB175DA02","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301159,"discussion_content":"没有可见性问题吧。修改后就调用了interrupt(), 根据传递原则，terminated一直是可见的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598429368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2849095,"avatar":"","nickname":"京力","note":"","ucode":"2E11C03FC757E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008933,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/65/25/c6de04bc.jpg","nickname":"斜月浮云","note":"","ucode":"25CECBB175DA02","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":584627,"discussion_content":"新线程rptThread和this主线程可能不在同一个cpu执行，this中的terminated和rptThread中的terminated可能不是同一块内存，因此需要volatile强制flush到各个cpu的内存里。我的第一感觉也觉得不需要，后来想到volatile的原理才想起来同一个字段可能不是同一块内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660981277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301159,"ip_address":"上海"},"score":584627,"extra":""}]}]},{"had_liked":false,"id":95671,"user_name":"echo＿陈","can_delete":false,"product_type":"c1","uid":1080794,"ip_address":"","ucode":"EFAEADA8A05906","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/da/780f149e.jpg","comment_is_top":false,"comment_ctime":1558139842,"is_pvip":false,"replies":[{"id":"34256","content":"是的，线程不调用wait,sleep等方法，是无法响应中断的，这个时候基于interrupt的可见性就不成立了，所以工程上这类变量都需要加volatile","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558168955,"ip_address":"","comment_id":95671,"utype":1}],"discussion_count":12,"race_medal":0,"score":"156176962498","product_id":100023901,"comment_content":"我觉得，在本例子中。stop中，设置终止标识位对interupt是可见的。而interrupt对被中断线程检测到中断事件是可见的……根据传递性原则……我觉得本例子不需要volatile关键字。但平时开发中，一般会加上，主要是因为怕后续开发不注意这些事情导致修改破坏了规则，引起可见性问题产生bug，保险起见会加上volatile","like_count":37,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450551,"discussion_content":"是的，线程不调用wait,sleep等方法，是无法响应中断的，这个时候基于interrupt的可见性就不成立了，所以工程上这类变量都需要加volatile","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558168955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1855137,"avatar":"","nickname":"Geek_e6f358","note":"","ucode":"C21E94A90258A2","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388343,"discussion_content":"stop方法，和start方法是两条线程跑，所以会有可见性问题","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628725030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1231302,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c9/c6/16136ab3.jpg","nickname":"龙行天下","note":"","ucode":"90BEED7A164ADE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565727,"discussion_content":"这个happens-before传递性有问题，happens-before只保证了rptThread.interupt()先行发生于catch(INterruptedException e),根据串行一致性，terminated=true完全有可能被重排于rptThread.interupt()之后","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650529312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1231302,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c9/c6/16136ab3.jpg","nickname":"龙行天下","note":"","ucode":"90BEED7A164ADE","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":585241,"discussion_content":"这个没事， catch好后， 下一个循环就可见了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661416135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":565727,"ip_address":"上海"},"score":585241,"extra":""}]},{"author":{"id":1450462,"avatar":"https://static001.geekbang.org/account/avatar/00/16/21/de/c935d3bd.jpg","nickname":"文培","note":"","ucode":"D8BC9BD6F2B261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386062,"discussion_content":"高手，马上能想到HB，理解的很透彻啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627390499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/e8/d2e88567.jpg","nickname":"ssrsdzry","note":"","ucode":"89BCFA6A1997E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":142345,"discussion_content":"下面也有同学提到started 变量的可见性问题，感觉是和传递性有关，因为线程终止了started变量的值肯定能被其它线程看见。而interrupted变量由于子线程持续运行中无法保证可见性。不知道理解对不对，希望老师答疑时解答一下，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579450747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031327,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bc/9f/a19fe018.jpg","nickname":"风笑墙","note":"","ucode":"6E584A01644218","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73387,"discussion_content":"这不是传递性吧？假设类有两个int变量，其中一个声明为volatile，那另一个是否多线程可见呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575558677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1031327,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bc/9f/a19fe018.jpg","nickname":"风笑墙","note":"","ucode":"6E584A01644218","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299933,"discussion_content":"回去看看happenbefore原则就明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597882920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73387,"ip_address":""},"score":299933,"extra":""}]},{"author":{"id":1302670,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e0/8e/2376cd87.jpg","nickname":"蓝天白云看大海","note":"","ucode":"02EF13FE37174B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239,"discussion_content":"线程不调用wait,sleep等方法，是无法响应中断的###对老师这段话很疑惑，为什么，这里的响应中断指的是啥？难道不是isInterrupted=true？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561346423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1302670,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e0/8e/2376cd87.jpg","nickname":"蓝天白云看大海","note":"","ucode":"02EF13FE37174B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167991,"discussion_content":"当线程处于睡眠状态才能去响应中断,也就是从睡眠状态变为了Runnable状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581545821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":239,"ip_address":""},"score":167991,"extra":""},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1302670,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e0/8e/2376cd87.jpg","nickname":"蓝天白云看大海","note":"","ucode":"02EF13FE37174B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301360,"discussion_content":"认为Java设置线程中断就是表示线程停止了，不往前执行了， Thread.currentThread().interrupt()   其实不是这样的，线程中断只是一个状态而已，true表示已中断，false表示未中断。 设置线程中断不影响线程的继续执行，但是线程设置中断后，线程内调用了wait、jion、sleep方法中的一种， 立马抛出一个 InterruptedException，且中断标志被清除，重新设置为false。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1598501986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":239,"ip_address":""},"score":301360,"extra":""},{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585227,"discussion_content":"本来以为是先wait,join,sleep然后interrupt会进入异常处理块。 先interrupt然后在wait,join,sleep也会进入异常处理块是吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661409301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301360,"ip_address":"上海"},"score":585227,"extra":""}]}]},{"had_liked":false,"id":95687,"user_name":"孙志强","can_delete":false,"product_type":"c1","uid":1325997,"ip_address":"","ucode":"9C070F1E4EC6FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ad/31193b83.jpg","comment_is_top":false,"comment_ctime":1558143426,"is_pvip":true,"replies":[{"id":"34254","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558168251,"ip_address":"","comment_id":95687,"utype":1}],"discussion_count":3,"race_medal":0,"score":"108932325826","product_id":100023901,"comment_content":"有必要，变量被多个线程访问，需要保证可见性","like_count":26,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450560,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558168251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2436755,"avatar":"https://static001.geekbang.org/account/avatar/00/25/2e/93/81e3e4ca.jpg","nickname":"ฅSlekฅ","note":"","ucode":"B732C672B3D301","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550306,"discussion_content":"其实就这么简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644479696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041534,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoEb4oys1R20cc9FfpZsVEt04Dias86A30LUNWM8lPyBahKaMRISNB854hhXRjoohCIIwX1sO86zfA/132","nickname":"0909","note":"","ucode":"56BAF3C6FBF200","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119115,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578216378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95827,"user_name":"遇见阳光","can_delete":false,"product_type":"c1","uid":1203576,"ip_address":"","ucode":"378E5D37B3CD0E","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/78/f011d586.jpg","comment_is_top":false,"comment_ctime":1558193159,"is_pvip":false,"replies":[{"id":"34356","content":"问题是start方法里又启动了一个新的线程，synchronized管不到这个新的线程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558314211,"ip_address":"","comment_id":95827,"utype":1}],"discussion_count":3,"race_medal":0,"score":"104637408263","product_id":100023901,"comment_content":"按道理而言，synchronized保证原子性的同时，也能间接的保证可见性啊。感觉可以不加 volatile关键字","like_count":25,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450609,"discussion_content":"问题是start方法里又启动了一个新的线程，synchronized管不到这个新的线程","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1558314211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":585225,"discussion_content":"那么started变量也是主线程和子线程都访问了，怎么没加volatile呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661409076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":450609,"ip_address":"上海"},"score":585225,"extra":""}]},{"author":{"id":1231829,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cb/d5/fab32cf7.jpg","nickname":"卖藥郎","note":"","ucode":"0539EF1D335918","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576120,"discussion_content":"就一条：变量被多个线程访问了 所以要保证可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655283429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96191,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1558354862,"is_pvip":false,"replies":[{"id":"34430","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558357883,"ip_address":"","comment_id":96191,"utype":1}],"discussion_count":1,"race_medal":0,"score":"65982864302","product_id":100023901,"comment_content":"请问一下老师&quot;JVM 的异常处理会清除线程的中断状态&quot;指的是什么意思, 是指把线程的为true的中断状态改为false吗, JVM是在catch到Interrupt异常的时候重置线程中断状态的吗? ","like_count":16,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450760,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558357883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140289,"user_name":"远东通信-应用软件","can_delete":false,"product_type":"c1","uid":1351651,"ip_address":"","ucode":"3A1796000AC089","user_header":"","comment_is_top":false,"comment_ctime":1570871351,"is_pvip":false,"replies":[{"id":"54229","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570881714,"ip_address":"","comment_id":140289,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48815511607","product_id":100023901,"comment_content":"在本章节后面一个实例代码中while循环没有使用线程的中断标志位做判断，但是stop里面仍然去调用rptThread.interrupt()有必要吗？只是为了将采集线程从sleep状态唤醒吗？","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470331,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570881714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2861352,"avatar":"","nickname":"阿狸弟弟的包子店","note":"","ucode":"0CCF598B029075","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556101,"discussion_content":"如果有多个sleep难道要多次interrupt","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647217857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95773,"user_name":"ZOU志伟","can_delete":false,"product_type":"c1","uid":1029179,"ip_address":"","ucode":"439779871CC992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","comment_is_top":false,"comment_ctime":1558170866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48802811122","product_id":100023901,"comment_content":"shutdown()调用后，还要再调用awaitTermination方法等待一点时间，线程池里的线程才会终止。","like_count":11},{"had_liked":false,"id":170734,"user_name":"jason","can_delete":false,"product_type":"c1","uid":1167872,"ip_address":"","ucode":"3329F08BAF307E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d2/00/9a247b1e.jpg","comment_is_top":false,"comment_ctime":1578696202,"is_pvip":false,"replies":[{"id":"66613","content":"加上更保险，不加数据也不会错，只是可能需要多等一会","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579014022,"ip_address":"","comment_id":170734,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23053532682","product_id":100023901,"comment_content":"按这样说，新线程里会修改start变量的值，为了保证start的最新值能被start()方法看见，是不是也要对start变量加volatile修饰？","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481088,"discussion_content":"加上更保险，不加数据也不会错，只是可能需要多等一会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579014022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114163,"user_name":"其","can_delete":false,"product_type":"c1","uid":1486367,"ip_address":"","ucode":"93A2EBA79E3066","user_header":"https://static001.geekbang.org/account/avatar/00/16/ae/1f/43b13ef0.jpg","comment_is_top":false,"comment_ctime":1563244531,"is_pvip":false,"replies":[{"id":"41674","content":"线程不能被中断，但是很多系统函数如sleep是响应中断的。极端地讲，纯CPU计算一定不会被中断","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1563262893,"ip_address":"","comment_id":114163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23038081011","product_id":100023901,"comment_content":"老师，想问一个问题如果interrupt()方法只是给线程打一个中断的标签，那么如果我线程本身没有显示的去做这个标的判断，线程还能被中断么，当然线程是runnable的，如果能中断又是谁去识别的呢？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458534,"discussion_content":"线程不能被中断，但是很多系统函数如sleep是响应中断的。极端地讲，纯CPU计算一定不会被中断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563262893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96169,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1558348091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23033184571","product_id":100023901,"comment_content":"两阶段终止模式：发送终止指令+响应终止指令。<br>终止指令通常可以定义一个终止标识变量(注意并发问题,需要volatie保证可见性)。<br>如果线程中调用了可中断方法(wait等)，在发送终止指令的同时需要调用Thread.interrupt()。<br>不建议使用线程自身的中断标识作为终止指令，因为项目中第三方的调用无法保证该标志位。","like_count":5},{"had_liked":false,"id":214143,"user_name":"青铜5 周群力","can_delete":false,"product_type":"c1","uid":1111965,"ip_address":"","ucode":"EA80B442EC8A68","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/9d/c7295d17.jpg","comment_is_top":false,"comment_ctime":1588666522,"is_pvip":false,"replies":[{"id":"80123","content":"基本上带池字的，生命周期都和应用同龄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1589286818,"ip_address":"","comment_id":214143,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18768535706","product_id":100023901,"comment_content":"什么情况需要手动shutdown线程池呢，我理解只要线程池不再被引用，里面的线程自己就被gc回收掉了，不需要手动调shutdown?","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493967,"discussion_content":"基本上带池字的，生命周期都和应用同龄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589286818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055854,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","nickname":"终结者999号","note":"","ucode":"33ADE61580B6DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263312,"discussion_content":"例如使用redisson框架之后，在容器shutdown之前。我们倾向于先关闭线程池再关闭redisson","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589198403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97283,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1558627769,"is_pvip":false,"replies":[{"id":"35832","content":"started的读写都在同步方法里面","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559304502,"ip_address":"","comment_id":97283,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18738496953","product_id":100023901,"comment_content":"老师，思考题前的最后一个示例代码，为什么<br>&#47;&#47; 线程终止标志位<br>volatile boolean terminated = false;<br>boolean started = false;<br><br>为什么started可以不加volatile，terminated却要加呢？","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451212,"discussion_content":"started的读写都在同步方法里面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559304502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95892,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1558245726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18738114910","product_id":100023901,"comment_content":"有必要，因为stop方法对isTerminated的修改需要被start方法读取到，保证共享变量的可见性","like_count":4},{"had_liked":false,"id":101775,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1559967815,"is_pvip":false,"replies":[{"id":"54026","content":"println内部有锁，而且还有io操作，所以会让结果不准确","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570767380,"ip_address":"","comment_id":101775,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14444869703","product_id":100023901,"comment_content":"```java<br>&#47;&#47; 因为留言超字数：1. 省略未修改的代码片段，2. println 是 System.out.println 的简写<br>class Proxy {<br>&#47;&#47; 变量声明，（留言超字数，此处未做修改，省略）<br><br>public static void main(String[] args) {<br>  Proxy proxy=new Proxy();<br>  for (int i=0; i&lt;100; i++) {<br>    new Thread(() -&gt; {<br>    proxy.start();<br>    proxy.stop();<br>    }, &quot;外部线程_&quot;+i)<br>    .start();<br>  }<br>}<br><br>&#47;&#47; 启动采集功能<br>synchronized void start() {<br>  &#47;&#47; 不允许同时启动多个采集线程<br>  String outerName=Thread.currentThread().getName();<br>  println(&quot;[&quot;+outerName+&quot;]线程是否启动？&quot;+started);<br><br>  if (started) {<br>    println(&quot;[&quot;+outerName+&quot;]线程 return&quot;);<br>    return;<br>  }<br>  started=true;<br>  terminated=false;<br><br>  rptThread=new Thread(() -&gt; {<br>    while (!terminated) {<br>      &#47;&#47; 每隔两秒钟采集、回传一次数据（留言超字数，此处未做修改，省略）<br>    }<br>    &#47;&#47; 执行到此处说明线程马上终止<br>    started=false;<br>    println(&quot;[&quot;+outerName+&quot;,内部线程：&quot;+Thread.currentThread().getName()+&quot;] started=false 成功执行&quot;);<br>  });<br><br>  rptThread.start();<br>  println(&quot;[&quot;+outerName+&quot;]线程执行完毕，内部子线程正在执行中...&quot;);<br>}<br><br>&#47;&#47; 终止采集功能（留言超字数，此处未做修改，省略）<br>}<br>```<br><br>```<br>执行结果：<br>[外部线程_77]线程是否启动？false<br>[外部线程_77]线程执行完毕，内部子线程正在执行中...<br>[外部线程_82]线程是否启动？true<br>[外部线程_82]线程 return<br>[外部线程_81]线程是否启动？false<br>[外部线程_77,内部线程：Thread-72] started=false 成功执行<br>[外部线程_81]线程执行完毕，内部子线程正在执行中...<br>[外部线程_81,内部线程：Thread-73] started=false 成功执行<br>[外部线程_84]线程是否启动？false<br>[外部线程_84]线程执行完毕，内部子线程正在执行中...<br>[外部线程_80]线程是否启动？true<br>[外部线程_84,内部线程：Thread-74] started=false 成功执行<br>[外部线程_80]线程执行完毕，内部子线程正在执行中...<br>[外部线程_79]线程是否启动？true<br>[外部线程_80,内部线程：Thread-75] started=false 成功执行<br>```<br><br>解释说明：<br>1. “[外部线程_81]线程是否启动？false” 先于 “[外部线程_77,内部线程：Thread-72] started=false 成功执行”：<br>[外部线程_77,内部线程：Thread-72] 执行完 started=false，还没执行 System.out 输出语句，[外部线程_81] 就已经拿到 started=false 的结果了。<br><br>2. “[外部线程_80]线程是否启动？true” 然后又 “[外部线程_80]线程执行完毕，内部子线程正在执行中...”：<br>这时[外部线程_80]让出了 cpu，等到时间片后再次执行时并没有 return，而是成功执行了内部子线程。<br><br>结论：started 在线程之间可以保证可见性的，但是具体原因，自己也没想明白。<br><br>-----<br><br>自己套用了下面的 Happens-Before 规则：<br>0. Happens-Before 的传递性。<br>1. 管程中锁的规则。<br>2. 线程启动规则。<br>3. 线程终止规则。<br>4. 线程中断规则。<br>好像也无法推导出：为何在内部线程 rptThread 修改的 started 变量，可以保证可见性。<br>是根据什么规则，保证了 started 变量的可见性，老师可以帮忙分析一下么？期待您的回复，谢谢老师！！","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453111,"discussion_content":"println内部有锁，而且还有io操作，所以会让结果不准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570767380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7053,"discussion_content":"这个貌似没有办法通过heppens-before规则导出，但确实保证可见性，引用第三篇中一个同学评论的内容来回答。Doug Lea大神的Concurrent Programming in Java一书中有这样一个片段来描述synchronized这个关键字：\n \n这里英文就不放出来了 字数超过两千……\n这篇文章也有提及https://www.jianshu.com/p/3c06ffbf0d52\n \n简单翻译一下：从本质上来说，当线程释放一个锁时会强制性的将工作内存中之前所有的写操作都刷新到主内存中去，而获取一个锁则会强制性的加载可访问到的值到线程工作内存中来。虽然锁操作只对同步方法和同步代码块这一块起到作用，但是影响的却是线程执行操作所使用的所有字段。\n","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1567325091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7073,"discussion_content":"谢谢大佬的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567337519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7053,"ip_address":""},"score":7073,"extra":""}]}]},{"had_liked":false,"id":256370,"user_name":"蚝不鱿鱼","can_delete":false,"product_type":"c1","uid":1428043,"ip_address":"","ucode":"5DB98E406F1D3E","user_header":"https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg","comment_is_top":false,"comment_ctime":1603611082,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10193545674","product_id":100023901,"comment_content":"大龄程序员的周末，必须来点精神食粮，不然就很慌，尽管它可能没啥用，但是谁知道呢，谁让咱输在了起跑线上呢……","like_count":2,"discussions":[{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318293,"discussion_content":"同是大龄的路过","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603699951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172421,"user_name":"IF You","can_delete":false,"product_type":"c1","uid":1108957,"ip_address":"","ucode":"C14188B97658A6","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/dd/3c9c613c.jpg","comment_is_top":false,"comment_ctime":1579174576,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10169109168","product_id":100023901,"comment_content":"本文中的start()方法有问题，使用的sleep()方法，而该方法不会释放锁，导致调用stop的方法阻塞在获取监视器锁的状态，永远不能通过stop方法优雅停止线程","like_count":2,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372411,"discussion_content":"sleep的是新开的线程，sleep的时候调用start的线程已经释放Proxy对象这把锁这把锁了。stop的时候是另一个线程获取Proxy对象这把锁，为啥调用stop会阻塞呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620310598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286899,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1617674133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912641429","product_id":100023901,"comment_content":"这里加不加volatile其实影响不大，应为程序中的stop()方法中只是把terminated设置为true，即使多个线程同时访问，影响的也只是多上报一段时间，影响不大，个人观点","like_count":2},{"had_liked":false,"id":270215,"user_name":"放牧人","can_delete":false,"product_type":"c1","uid":1980326,"ip_address":"","ucode":"CA248909EFE7E0","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/a6/3e7c2d5c.jpg","comment_is_top":false,"comment_ctime":1608992095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5903959391","product_id":100023901,"comment_content":"有趣的事，这里的terminate变量加上了volatile修饰，正常来说按照 happen-before的规则，对synchronize的解锁是能够被加锁可见的。<br>但这个应该是保证在一个线程下的可见，例如对Proxy对象的解锁是在主线程中调用的，加锁也在主线程，那么主线程加锁时可以查看到解锁变量的最新值，但是这个代码的加锁新开了一个线程C，这个时候可见性是传递不到线程C的，只能传递给执行解锁的线程即主线程，所以要加volatile修饰 terminate变量","like_count":2},{"had_liked":false,"id":140346,"user_name":"虚竹","can_delete":false,"product_type":"c1","uid":1691109,"ip_address":"","ucode":"8D8C96C793724E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJIocn8OMjfSGqyeSJEV3ID2rquLR0S6xo0ibdNYQgzicib6L6VlqWjhgxOqD2iaicX1KhbWXWCsmBTskA/132","comment_is_top":false,"comment_ctime":1570886079,"is_pvip":false,"replies":[{"id":"54344","content":"可以这样写","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571017990,"ip_address":"","comment_id":140346,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865853375","product_id":100023901,"comment_content":"王老师好，请教下：<br>1.自定义标志位终止线程时，是不是这样可以这样写？<br>whlie(!Thread.currentThread()isInterrupted() || !terminated){}<br>2.线程池关闭时，完整的是这样吧?<br>exec.shutdown();<br>while(true){<br>  if(exec.isTerminated()){<br>    print(&quot;所有的任务都结束了~&quot;);<br>  }<br>  Thread.sleep(1000);<br>}<br><br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470352,"discussion_content":"可以这样写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571017990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113999,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1563202337,"is_pvip":false,"replies":[{"id":"41576","content":"没有while可以关键点上检查，也可以等待自然结束，看实际需求","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1563234840,"ip_address":"","comment_id":113999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858169633","product_id":100023901,"comment_content":"我看结束线程的示例都有while方法，如果没有while，如果中断呢？同时也没有处于休眠状态的话，是不是只能等程序自然结束了，是不是我的问题有问题。。。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458473,"discussion_content":"没有while可以关键点上检查，也可以等待自然结束，看实际需求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563234840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111624,"user_name":"胡小禾","can_delete":false,"product_type":"c1","uid":1132315,"ip_address":"","ucode":"1C23B7492C0C9E","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/1b/64262861.jpg","comment_is_top":false,"comment_ctime":1562575060,"is_pvip":false,"replies":[{"id":"40630","content":"核心逻辑是异步执行的，所以还是有必要的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562590350,"ip_address":"","comment_id":111624,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857542356","product_id":100023901,"comment_content":"第一段代码中的第九行：<br>      started = true;<br>有必要存在吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457393,"discussion_content":"核心逻辑是异步执行的，所以还是有必要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562590350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97901,"user_name":"八百","can_delete":false,"product_type":"c1","uid":1253530,"ip_address":"","ucode":"79F1F79ADF5A00","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/9a/3b1c65fd.jpg","comment_is_top":false,"comment_ctime":1558836341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853803637","product_id":100023901,"comment_content":"我记得在kafka0.8版本的时候，我设置中断来关闭消费者线程，结果不行，然后我把中断标志位，恢复了，就好了。。Ծ‸Ծ","like_count":1},{"had_liked":false,"id":97064,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1558579625,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5853546921","product_id":100023901,"comment_content":"请问老师 用interrupt方式中断线程是设置标志位，在run方法中用循环检测该中断标志位，如果中断则不再循环。<br>这里有个问题是必须执行完循环里的代码，重新检测循环条件才能中断，那有没有办法能在循环中中断，实现类似ctrl-C的功能，用Thread.stop吗？","like_count":1},{"had_liked":false,"id":96062,"user_name":"包子","can_delete":false,"product_type":"c1","uid":1089345,"ip_address":"","ucode":"6CC4EBB8CD3924","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/41/82306dfe.jpg","comment_is_top":false,"comment_ctime":1558318531,"is_pvip":false,"replies":[{"id":"34433","content":"stop方法里设置过了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558358043,"ip_address":"","comment_id":96062,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853285827","product_id":100023901,"comment_content":"老师你好，<br>优雅关闭线程最后一个案例代码使用terminated作为线程中断的标志位，那cache住sleep时，不用设置terminated为true吗。不设置线程是关闭不了的啊。<br>        try {<br>          Thread.sleep(2000);<br>        } catch (InterruptedException e){<br>          &#47;&#47; 重新设置线程中断状态<br>          Thread.currentThread().interrupt();<br>        }<br><br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450703,"discussion_content":"stop方法里设置过了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558358043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95964,"user_name":"风起时","can_delete":false,"product_type":"c1","uid":1125840,"ip_address":"","ucode":"41E3E457F1E970","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/d0/1fe7144e.jpg","comment_is_top":false,"comment_ctime":1558276918,"is_pvip":false,"replies":[{"id":"34352","content":"synchronized 就不需要了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558313146,"ip_address":"","comment_id":95964,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5853244214","product_id":100023901,"comment_content":"老师，started是否需要加voliatle保证，多个线程看到的都是最新的值","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450661,"discussion_content":"synchronized 就不需要了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558313146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2143963,"avatar":"https://static001.geekbang.org/account/avatar/00/20/b6/db/ffaed7bf.jpg","nickname":"刘鹏","note":"","ucode":"EA8BD8810350C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":555407,"discussion_content":"老师那这样started变量存在是为了什么呢？synchronized已经保证了线程互斥了呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646895154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":450661,"ip_address":""},"score":555407,"extra":""}]}]},{"had_liked":false,"id":338759,"user_name":"一点点就好","can_delete":false,"product_type":"c1","uid":1055913,"ip_address":"","ucode":"3082B6E93FA7D8","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/a9/49ffc8c7.jpg","comment_is_top":false,"comment_ctime":1647703010,"is_pvip":true,"replies":[{"id":"123923","content":"可以试试用队列，b消费队列任务，如果被中断，就执行中断逻辑，最后b在把任务增加到队列中。<br>a生产队列任务，同时检测是否任务在执行中，如果在执行中，就中断任务执行线程。<br>需要一个任务对象来保存一些状态","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1647912979,"ip_address":"","comment_id":338759,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647703010","product_id":100023901,"comment_content":"有这样一个场景<br>A线程发次两次任务调度，将其放入到B线程中进行执行，如果B中已经有任务在执行，那么A线程中先中断线程中执行这个任务的进程后在进行任务提交，这个场景有没有优雅的方式","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557631,"discussion_content":"可以试试用队列，b消费队列任务，如果被中断，就执行中断逻辑，最后b在把任务增加到队列中。\na生产队列任务，同时检测是否任务在执行中，如果在执行中，就中断任务执行线程。\n需要一个任务对象来保存一些状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647912979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290823,"user_name":"我真不是地球","can_delete":false,"product_type":"c1","uid":1451048,"ip_address":"","ucode":"873F7222DE35BE","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/28/9b5b1396.jpg","comment_is_top":false,"comment_ctime":1619769740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619769740","product_id":100023901,"comment_content":"Thread.currentThread().interrupt()和rptThread().interrupt()<br>有什么区别啊老师，感觉是一回事吧","like_count":0},{"had_liked":false,"id":271310,"user_name":"啸歌","can_delete":false,"product_type":"c1","uid":1113874,"ip_address":"","ucode":"D8C8963BB940F6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er2rgam9XfHbuSIZB4S3UG2GLrf9CLkiatDG62eEMicT4yprYdSAZET3kfqQBPxqBHkZw2KRhMdJX4Q/132","comment_is_top":false,"comment_ctime":1609550711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609550711","product_id":100023901,"comment_content":"1、自定义中断标志位的问题：如果run方法里有阻塞调用时会无法很快检测到中断标志，线程必须从阻塞调用返回后，才会检查这个中断标志<br>2、示例代码stop方法设置了中断标志位 却没有主动检查。<br>whlie(!Thread.currentThread()isInterrupted() || !terminated){}","like_count":0},{"had_liked":false,"id":269638,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1608722972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608722972","product_id":100023901,"comment_content":"JVM会在异常处理清除线程中断状态。我也重现了。<br>但是为什么JVM要这样做呢？","like_count":0},{"had_liked":false,"id":250805,"user_name":"witluo","can_delete":false,"product_type":"c1","uid":1443117,"ip_address":"","ucode":"3D9608C3DDDD95","user_header":"","comment_is_top":false,"comment_ctime":1601251088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601251088","product_id":100023901,"comment_content":"有些疑惑：Happend-Before原则中有个start()原则。 主线程A启动子线程B， 对于主线程启动子线程B.start()之前的操作 Happens-Before 与 start()方法。   再加上传递性，我怎么觉得 volatitle也没必要呢？","like_count":0},{"had_liked":false,"id":225603,"user_name":"石头汤","can_delete":false,"product_type":"c1","uid":1022282,"ip_address":"","ucode":"45E4578E54F585","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/4a/bdf26d5c.jpg","comment_is_top":false,"comment_ctime":1591798455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591798455","product_id":100023901,"comment_content":"synchronized 本身已经解决了原子性问题，如果对某变量的操作都用了 synchronized ，happen before 生效，是不需要 volatile 的; 示例需要用volatile ，是因为在 new Thread() 内对此变量的读操作没有加 syncronized","like_count":0},{"had_liked":false,"id":224208,"user_name":"咸鱼","can_delete":false,"product_type":"c1","uid":1179028,"ip_address":"","ucode":"5E79636DE48155","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","comment_is_top":false,"comment_ctime":1591317871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591317871","product_id":100023901,"comment_content":"感觉可以不需要的啊，虽然volatile保证内存可见性，但是这里仅有一处写操作，甚至stop都可以不用做同步操作，terminal的修改并不需要立马可见，也就是可以不需要立马去响应停止采集，在这个例子下感觉可以不用","like_count":0},{"had_liked":false,"id":219451,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1008071,"ip_address":"","ucode":"9FE5F43055D3AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/c7/b64ac05e.jpg","comment_is_top":false,"comment_ctime":1590027164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590027164","product_id":100023901,"comment_content":"这里不是只能启动一个线程么，由于sync 了start方法，根据jmm 不会同时有两个线程创建吧，是不是就不会有terminate 可见性问题","like_count":0},{"had_liked":false,"id":212033,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588049875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588049875","product_id":100023901,"comment_content":"问个问题:  sutdownnow这个方法，是通过设置中断位来停止线程吗？如果我在代码中不处理标志位退出，正在执行的线程会执行完吗","like_count":0},{"had_liked":false,"id":209721,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1587604943,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587604943","product_id":100023901,"comment_content":"先不说课后题的volaitle是否有必要，文中所举的例子，是否有必要用synchronized来互斥，状态是一个布尔型，用原子类就可以吧？不过这个类的方法应该只被调用一次，用重量级锁也不会引起什么性能问题。<br>再说课后题，根据happends-before原则，变量的可见性没有问题，不需要通过volatile来标识，倒是有序性可能会产生问题，所以此处的volatile应该是达成volatile原则，避免指令重排序的","like_count":0},{"had_liked":false,"id":202888,"user_name":"hellojd","can_delete":false,"product_type":"c1","uid":1341697,"ip_address":"","ucode":"4E51807AE7E472","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","comment_is_top":false,"comment_ctime":1586080150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586080150","product_id":100023901,"comment_content":"Proxy.java例子中，我感觉 没必要定义2个变量。<br>volatile boolean terminated = false; <br>boolean started = false;<br>一个也可以实现优雅关闭效果。而且不需要start,stop方法无需实行同步。仅仅是一个状态而已，不涉及原子性操作，无需处理同步。","like_count":0},{"had_liked":false,"id":198834,"user_name":"genji","can_delete":false,"product_type":"c1","uid":1906775,"ip_address":"","ucode":"43C2959371373F","user_header":"https://static001.geekbang.org/account/avatar/00/1d/18/57/6229a783.jpg","comment_is_top":false,"comment_ctime":1585470009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585470009","product_id":100023901,"comment_content":"妙啊妙啊。两阶段终止，interrupt()可以主动调起异常来处理中止(可以防止某些线程在阻塞状态而没有立即中止)，terminated则可以保证无论出现什么异常都能直接关闭线程的循环状态，实现了运行-&gt;中止的过程，彻底的中断了线程。","like_count":0},{"had_liked":false,"id":196010,"user_name":"Mr.wang","can_delete":false,"product_type":"c1","uid":1224805,"ip_address":"","ucode":"86F341A5316BBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/b0/65/90387745.jpg","comment_is_top":false,"comment_ctime":1585230132,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585230132","product_id":100023901,"comment_content":"我认为是有必要性的，当设置terminated为true的时候，需要系统立刻知道当前terminated的值，并响应设置后的线程变化。","like_count":0},{"had_liked":false,"id":194905,"user_name":"污名侦探","can_delete":false,"product_type":"c1","uid":1049154,"ip_address":"","ucode":"D9C4D175E5EF7B","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/42/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1585118407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585118407","product_id":100023901,"comment_content":"挺好，很清楚，收获很多","like_count":0},{"had_liked":false,"id":178575,"user_name":"benjamindora","can_delete":false,"product_type":"c1","uid":1046455,"ip_address":"","ucode":"66C29727AE47C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/b7/a2b4c9b9.jpg","comment_is_top":false,"comment_ctime":1581749514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581749514","product_id":100023901,"comment_content":"老师，个人觉得terminated不需要volatile。从代码上看，start方法与stop方法中，terminated状态不管可不可见都对后续的业务逻辑没有影响。","like_count":0},{"had_liked":false,"id":178558,"user_name":"supermouse","can_delete":false,"product_type":"c1","uid":1321860,"ip_address":"","ucode":"88072D5F881827","user_header":"https://static001.geekbang.org/account/avatar/00/14/2b/84/07f0c0d6.jpg","comment_is_top":false,"comment_ctime":1581743943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581743943","product_id":100023901,"comment_content":"有必要，因为要保证 terminated 的可见性。比如线程 T1 要终止线程 T2，那么只有加上 volatile 才能让 T1 对 terminated 的修改对 T2 是可见的。","like_count":0},{"had_liked":false,"id":146825,"user_name":"potato00fa","can_delete":false,"product_type":"c1","uid":1307080,"ip_address":"","ucode":"D179E68D87CC50","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/c8/8e6dc340.jpg","comment_is_top":false,"comment_ctime":1572665846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572665846","product_id":100023901,"comment_content":"有必要加volatie，父线程调用stop改标志位通知子线程，标志位属于跨线程的共享变量","like_count":0},{"had_liked":false,"id":145443,"user_name":"十大杰出青年","can_delete":false,"product_type":"c1","uid":1559178,"ip_address":"","ucode":"BAB4AA12604CF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a5U0nqaicLy5ZJkESxBd5lMicNQcTTDK8vURyyWiabHxic7vS1VVk7HWTZg6ltyWJ3n9jb3Gq554ibfjsf7bv1v1Sdw/132","comment_is_top":false,"comment_ctime":1572274061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572274061","product_id":100023901,"comment_content":"老师，可以举一个调用第三方类库，第三方类库捕获了异常，却没有正常处理的例子吗？","like_count":0},{"had_liked":false,"id":112018,"user_name":"胡小禾","can_delete":false,"product_type":"c1","uid":1132315,"ip_address":"","ucode":"1C23B7492C0C9E","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/1b/64262861.jpg","comment_is_top":false,"comment_ctime":1562654220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562654220","product_id":100023901,"comment_content":"class Proxy {<br>  &#47;&#47; 线程终止标志位<br>  volatile boolean terminated = false;<br>  boolean started = false;<br>  &#47;&#47; 采集线程<br>  Thread rptThread;<br>  &#47;&#47; 启动采集功能<br>  synchronized void start(){<br>    &#47;&#47; 不允许同时启动多个采集线程<br>    if (started) {<br>      return;<br>    }<br>    started = true;<br>    terminated = false;<br>    rptThread = new Thread(()-&gt;{<br>      while (!terminated){<br>        &#47;&#47; 省略采集、回传实现<br>        report();<br>        &#47;&#47; 每隔两秒钟采集、回传一次数据<br>        try {<br>          Thread.sleep(2000);<br>        } catch (InterruptedException e){<br>          &#47;&#47; 重新设置线程中断状态<br>          Thread.currentThread().interrupt();<br>        }<br>      }<br>      &#47;&#47; 执行到此处说明线程马上终止<br>      started = false;<br>    });<br>    rptThread.start();<br>  }<br>  &#47;&#47; 终止采集功能<br>  synchronized void stop(){<br>    &#47;&#47; 设置中断标志位<br>    terminated = true;<br>    &#47;&#47; 中断线程 rptThread<br>    rptThread.interrupt();<br>  }<br>}<br><br>这里使用了 terminated 作为中断标志位了，<br>是不是说 就不需要 rptThread.interrupt()<br>或者    Thread.currentThread().interrupt() <br>的中断标志位了？","like_count":0},{"had_liked":false,"id":109420,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1446282,"ip_address":"","ucode":"2D3A1F6FE2C495","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/8a/cbcbab41.jpg","comment_is_top":false,"comment_ctime":1562030951,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562030951","product_id":100023901,"comment_content":"老师，started=true这一行明显在新起的线程内操作的，不能保证可见性，是不是应该移出到新起的线程外。在); 后面而不是在里面","like_count":0,"discussions":[{"author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7056,"discussion_content":"Doug Lea大神的Concurrent Programming in Java一书中有这样一个片段来描述synchronized这个关键字：\n \n这里英文就不放出来了 字数超过两千……\n这篇文章也有提及https://www.jianshu.com/p/3c06ffbf0d52\n \n简单翻译一下：从本质上来说，当线程释放一个锁时会强制性的将工作内存中之前所有的写操作都刷新到主内存中去，而获取一个锁则会强制性的加载可访问到的值到线程工作内存中来。虽然锁操作只对同步方法和同步代码块这一块起到作用，但是影响的却是线程执行操作所使用的所有字段。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567325906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106876,"user_name":"narsil的梦","can_delete":false,"product_type":"c1","uid":1185187,"ip_address":"","ucode":"67110C673BD951","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/a3/e67d6039.jpg","comment_is_top":false,"comment_ctime":1561420866,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561420866","product_id":100023901,"comment_content":"自己设置isTerminate标志位的意义何在，没太明白","like_count":0,"discussions":[{"author":{"id":1437158,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ed/e6/75a32708.jpg","nickname":"日拱一兵","note":"","ucode":"D6386E5CD7C061","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6247,"discussion_content":"不依赖系统的标志位，万一线程被终端的代码在第三方库，第三方库源码没有重置标志位，这就死循环了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566810365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98535,"user_name":"Kaleidoscoper","can_delete":false,"product_type":"c1","uid":1031741,"ip_address":"","ucode":"E705716641B08F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/3d/b782c7a5.jpg","comment_is_top":false,"comment_ctime":1559019573,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1559019573","product_id":100023901,"comment_content":"老师，started字段是不是也有可见性问题，存在在rptthread和执行start方法线程之间，rpt里started＝false之后，另外一个线程不能马上接收到这个信息，导致不能正常进行下一次rptthead执行","like_count":0,"discussions":[{"author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7057,"discussion_content":"Doug Lea大神的Concurrent Programming in Java一书中有这样一个片段来描述synchronized这个关键字：\n \n这里英文就不放出来了 字数超过两千……\n这篇文章也有提及https://www.jianshu.com/p/3c06ffbf0d52\n \n简单翻译一下：从本质上来说，当线程释放一个锁时会强制性的将工作内存中之前所有的写操作都刷新到主内存中去，而获取一个锁则会强制性的加载可访问到的值到线程工作内存中来。虽然锁操作只对同步方法和同步代码块这一块起到作用，但是影响的却是线程执行操作所使用的所有字段。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567325933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97289,"user_name":"S","can_delete":false,"product_type":"c1","uid":1339720,"ip_address":"","ucode":"9B6B225657BD26","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/48/e5570f84.jpg","comment_is_top":false,"comment_ctime":1558629744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558629744","product_id":100023901,"comment_content":"为什么Thread.sleep()之后要重新中断设置标识位?Thread.sleep()将中断标识位清除了之后,不设置中断标识位也不会对上述代码有什么影响啊","like_count":0},{"had_liked":false,"id":96195,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1558355272,"is_pvip":false,"replies":[{"id":"34429","content":"实际场景都不会这么简单","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558357836,"ip_address":"","comment_id":96195,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1558355272","product_id":100023901,"comment_content":"老师请问一下对&quot;没有办法保证第三方类库正确处理了线程的中断异常&quot;这句话我不是很理解,  例子中的sleep方法不是在本地执行的吗, 为什么会跟第三方类库有关系 ?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450762,"discussion_content":"实际场景都不会这么简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558357836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079495,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","nickname":"新世界","note":"","ucode":"4473DC1505F158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549118,"discussion_content":"难道是第三方类库中有sleep或者wait😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643588787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96007,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1558311711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558311711","product_id":100023901,"comment_content":"所以优雅停止线程的关键在于如何优雅地处理中断","like_count":0},{"had_liked":false,"id":96002,"user_name":"搏未来","can_delete":false,"product_type":"c1","uid":1034079,"ip_address":"","ucode":"4A339B35E3B419","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/5f/2028aae5.jpg","comment_is_top":false,"comment_ctime":1558309427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558309427","product_id":100023901,"comment_content":"有必要，保持可见性.","like_count":0},{"had_liked":false,"id":95749,"user_name":"兔斯基","can_delete":false,"product_type":"c1","uid":1061320,"ip_address":"","ucode":"146A5FE2D8B301","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/c8/a64e4aef.jpg","comment_is_top":false,"comment_ctime":1558164706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558164706","product_id":100023901,"comment_content":"有必要，项目中就是这么设置的，踩过一次了坑了","like_count":0},{"had_liked":false,"id":95734,"user_name":"ZOU志伟","can_delete":false,"product_type":"c1","uid":1029179,"ip_address":"","ucode":"439779871CC992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","comment_is_top":false,"comment_ctime":1558152526,"is_pvip":false,"replies":[{"id":"34253","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558168224,"ip_address":"","comment_id":95734,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558152526","product_id":100023901,"comment_content":"有必要，stop()方法执行后，读terminated的start()方法要再次执行才会可见","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450579,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558168224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95705,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1558146192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558146192","product_id":100023901,"comment_content":"有必要，假设不加volatile， 那么在while (!terminated)时读terminated的值可能会在stop()方法中写terminated值之前，并且stop()方法执行的线程A和在while循环的线程B是不同的，也就是说都有自己变量副本，A线程在自己缓存设置值后不知道什么时候才写回内存，可能导致中断延迟。","like_count":0},{"had_liked":false,"id":95701,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1558145866,"is_pvip":false,"replies":[{"id":"34252","content":"有必要","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558168153,"ip_address":"","comment_id":95701,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558145866","product_id":100023901,"comment_content":"start() 和stop()都是使用的同一把锁this，这样的话，没必要再用volatile声明isTerminated了吧<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450563,"discussion_content":"有必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558168153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95681,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1299615,"ip_address":"","ucode":"528DD5C8399AEC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKlwpFM3tkeG15YqyJTYWkfqkdmro9POq6SicYm57TaEFDOUZCXjoe0Z0Iz6UibGQqic3icJRsHdFzibtw/132","comment_is_top":false,"comment_ctime":1558141794,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558141794","product_id":100023901,"comment_content":"是有必要的，保证可见性","like_count":0},{"had_liked":false,"id":95674,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1558140523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558140523","product_id":100023901,"comment_content":"打卡，有必要","like_count":0},{"had_liked":false,"id":95659,"user_name":"Corner","can_delete":false,"product_type":"c1","uid":1446316,"ip_address":"","ucode":"7862D593172536","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg","comment_is_top":false,"comment_ctime":1558135106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558135106","product_id":100023901,"comment_content":"多线程读写共享变量，保证可见性使用volitale没毛病","like_count":0},{"had_liked":false,"id":95653,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1558118121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558118121","product_id":100023901,"comment_content":"打卡！","like_count":0}]}