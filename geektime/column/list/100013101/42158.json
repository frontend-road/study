{"id":42158,"title":"32 | context.Context类型","content":"<p>我们在上篇文章中讲到了<code>sync.WaitGroup</code>类型：一个可以帮我们实现一对多goroutine协作流程的同步工具。</p><p><strong>在使用<code>WaitGroup</code>值的时候，我们最好用“先统一<code>Add</code>，再并发<code>Done</code>，最后<code>Wait</code>”的标准模式来构建协作流程。</strong></p><p>如果在调用该值的<code>Wait</code>方法的同时，为了增大其计数器的值，而并发地调用该值的<code>Add</code>方法，那么就很可能会引发panic。</p><p>这就带来了一个问题，如果我们不能在一开始就确定执行子任务的goroutine的数量，那么使用<code>WaitGroup</code>值来协调它们和分发子任务的goroutine，就是有一定风险的。一个解决方案是：分批地启用执行子任务的goroutine。</p><h2>前导内容：WaitGroup值补充知识</h2><p>我们都知道，<code>WaitGroup</code>值是可以被复用的，但需要保证其计数周期的完整性。尤其是涉及对其<code>Wait</code>方法调用的时候，它的下一个计数周期必须要等到，与当前计数周期对应的那个<code>Wait</code>方法调用完成之后，才能够开始。</p><p>我在前面提到的可能会引发panic的情况，就是由于没有遵循这条规则而导致的。</p><p>只要我们在严格遵循上述规则的前提下，分批地启用执行子任务的goroutine，就肯定不会有问题。具体的实现方式有不少，其中最简单的方式就是使用<code>for</code>循环来作为辅助。这里的代码如下：</p><!-- [[[read_end]]] --><pre><code>func coordinateWithWaitGroup() {\n total := 12\n stride := 3\n var num int32\n fmt.Printf(&quot;The number: %d [with sync.WaitGroup]\\n&quot;, num)\n var wg sync.WaitGroup\n for i := 1; i &lt;= total; i = i + stride {\n  wg.Add(stride)\n  for j := 0; j &lt; stride; j++ {\n   go addNum(&amp;num, i+j, wg.Done)\n  }\n  wg.Wait()\n }\n fmt.Println(&quot;End.&quot;)\n}\n</code></pre><p>这里展示的<code>coordinateWithWaitGroup</code>函数，就是上一篇文章中同名函数的改造版本。而其中调用的<code>addNum</code>函数，则是上一篇文章中同名函数的简化版本。这两个函数都已被放置在了demo67.go文件中。</p><p>我们可以看到，经过改造后的<code>coordinateWithWaitGroup</code>函数，循环地使用了由变量<code>wg</code>代表的<code>WaitGroup</code>值。它运用的依然是“先统一<code>Add</code>，再并发<code>Done</code>，最后<code>Wait</code>”的这种模式，只不过它利用<code>for</code>语句，对此进行了复用。</p><p>好了，至此你应该已经对<code>WaitGroup</code>值的运用有所了解了。不过，我现在想让你使用另一种工具来实现上面的协作流程。</p><p><strong>我们今天的问题就是：怎样使用<code>context</code>包中的程序实体，实现一对多的goroutine协作流程？</strong></p><p>更具体地说，我需要你编写一个名为<code>coordinateWithContext</code>的函数。这个函数应该具有上面<code>coordinateWithWaitGroup</code>函数相同的功能。</p><p>显然，你不能再使用<code>sync.WaitGroup</code>了，而要用<code>context</code>包中的函数和<code>Context</code>类型作为实现工具。这里注意一点，是否分批启用执行子任务的goroutine其实并不重要。</p><p>我在这里给你一个参考答案。</p><pre><code>func coordinateWithContext() {\n total := 12\n var num int32\n fmt.Printf(&quot;The number: %d [with context.Context]\\n&quot;, num)\n cxt, cancelFunc := context.WithCancel(context.Background())\n for i := 1; i &lt;= total; i++ {\n  go addNum(&amp;num, i, func() {\n   if atomic.LoadInt32(&amp;num) == int32(total) {\n    cancelFunc()\n   }\n  })\n }\n &lt;-cxt.Done()\n fmt.Println(&quot;End.&quot;)\n}\n</code></pre><p>在这个函数体中，我先后调用了<code>context.Background</code>函数和<code>context.WithCancel</code>函数，并得到了一个可撤销的<code>context.Context</code>类型的值（由变量<code>cxt</code>代表），以及一个<code>context.CancelFunc</code>类型的撤销函数（由变量<code>cancelFunc</code>代表）。</p><p>在后面那条唯一的<code>for</code>语句中，我在每次迭代中都通过一条<code>go</code>语句，异步地调用<code>addNum</code>函数，调用的总次数只依据了<code>total</code>变量的值。</p><p>请注意我给予<code>addNum</code>函数的最后一个参数值。它是一个匿名函数，其中只包含了一条<code>if</code>语句。这条<code>if</code>语句会“原子地”加载<code>num</code>变量的值，并判断它是否等于<code>total</code>变量的值。</p><p>如果两个值相等，那么就调用<code>cancelFunc</code>函数。其含义是，如果所有的<code>addNum</code>函数都执行完毕，那么就立即通知分发子任务的goroutine。</p><p>这里分发子任务的goroutine，即为执行<code>coordinateWithContext</code>函数的goroutine。它在执行完<code>for</code>语句后，会立即调用<code>cxt</code>变量的<code>Done</code>函数，并试图针对该函数返回的通道，进行接收操作。</p><p>由于一旦<code>cancelFunc</code>函数被调用，针对该通道的接收操作就会马上结束，所以，这样做就可以实现“等待所有的<code>addNum</code>函数都执行完毕”的功能。</p><h2>问题解析</h2><p><code>context.Context</code>类型（以下简称<code>Context</code>类型）是在Go 1.7发布时才被加入到标准库的。而后，标准库中的很多其他代码包都为了支持它而进行了扩展，包括：<code>os/exec</code>包、<code>net</code>包、<code>database/sql</code>包，以及<code>runtime/pprof</code>包和<code>runtime/trace</code>包，等等。</p><p><code>Context</code>类型之所以受到了标准库中众多代码包的积极支持，主要是因为它是一种非常通用的同步工具。它的值不但可以被任意地扩散，而且还可以被用来传递额外的信息和信号。</p><p>更具体地说，<code>Context</code>类型可以提供一类代表上下文的值。此类值是并发安全的，也就是说它可以被传播给多个goroutine。</p><p>由于<code>Context</code>类型实际上是一个接口类型，而<code>context</code>包中实现该接口的所有私有类型，都是基于某个数据类型的指针类型，所以，如此传播并不会影响该类型值的功能和安全。</p><p><code>Context</code>类型的值（以下简称<code>Context</code>值）是可以繁衍的，这意味着我们可以通过一个<code>Context</code>值产生出任意个子值。这些子值可以携带其父值的属性和数据，也可以响应我们通过其父值传达的信号。</p><p>正因为如此，所有的<code>Context</code>值共同构成了一颗代表了上下文全貌的树形结构。这棵树的树根（或者称上下文根节点）是一个已经在<code>context</code>包中预定义好的<code>Context</code>值，它是全局唯一的。通过调用<code>context.Background</code>函数，我们就可以获取到它（我在<code>coordinateWithContext</code>函数中就是这么做的）。</p><p>这里注意一下，这个上下文根节点仅仅是一个最基本的支点，它不提供任何额外的功能。也就是说，它既不可以被撤销（cancel），也不能携带任何数据。</p><p>除此之外，<code>context</code>包中还包含了四个用于繁衍<code>Context</code>值的函数，即：<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>和<code>WithValue</code>。</p><p>这些函数的第一个参数的类型都是<code>context.Context</code>，而名称都为<code>parent</code>。顾名思义，这个位置上的参数对应的都是它们将会产生的<code>Context</code>值的父值。</p><p><code>WithCancel</code>函数用于产生一个可撤销的<code>parent</code>的子值。在<code>coordinateWithContext</code>函数中，我通过调用该函数，获得了一个衍生自上下文根节点的<code>Context</code>值，和一个用于触发撤销信号的函数。</p><p>而<code>WithDeadline</code>函数和<code>WithTimeout</code>函数则都可以被用来产生一个会定时撤销的<code>parent</code>的子值。至于<code>WithValue</code>函数，我们可以通过调用它，产生一个会携带额外数据的<code>parent</code>的子值。</p><p>到这里，我们已经对<code>context</code>包中的函数和<code>Context</code>类型有了一个基本的认识了。不过这还不够，我们再来扩展一下。</p><h2>知识扩展</h2><h3>问题1：“可撤销的”在<code>context</code>包中代表着什么？“撤销”一个<code>Context</code>值又意味着什么？</h3><p>我相信很多初识<code>context</code>包的Go程序开发者，都会有这样的疑问。确实，“可撤销的”（cancelable）这个词在这里是比较抽象的，很容易让人迷惑。我这里再来解释一下。</p><p>这需要从<code>Context</code>类型的声明讲起。这个接口中有两个方法与“撤销”息息相关。<code>Done</code>方法会返回一个元素类型为<code>struct{}</code>的接收通道。不过，这个接收通道的用途并不是传递元素值，而是让调用方去感知“撤销”当前<code>Context</code>值的那个信号。</p><p>一旦当前的<code>Context</code>值被撤销，这里的接收通道就会被立即关闭。我们都知道，对于一个未包含任何元素值的通道来说，它的关闭会使任何针对它的接收操作立即结束。</p><p>正因为如此，在<code>coordinateWithContext</code>函数中，基于调用表达式<code>cxt.Done()</code>的接收操作，才能够起到感知撤销信号的作用。</p><p>除了让<code>Context</code>值的使用方感知到撤销信号，让它们得到“撤销”的具体原因，有时也是很有必要的。后者即是<code>Context</code>类型的<code>Err</code>方法的作用。该方法的结果是<code>error</code>类型的，并且其值只可能等于<code>context.Canceled</code>变量的值，或者<code>context.DeadlineExceeded</code>变量的值。</p><p>前者用于表示手动撤销，而后者则代表：由于我们给定的过期时间已到，而导致的撤销。</p><p>你可能已经感觉到了，对于<code>Context</code>值来说，“撤销”这个词如果当名词讲，指的其实就是被用来表达“撤销”状态的信号；如果当动词讲，指的就是对撤销信号的传达；而“可撤销的”指的则是具有传达这种撤销信号的能力。</p><p>我在前面讲过，当我们通过调用<code>context.WithCancel</code>函数产生一个可撤销的<code>Context</code>值时，还会获得一个用于触发撤销信号的函数。</p><p>通过调用这个函数，我们就可以触发针对这个<code>Context</code>值的撤销信号。一旦触发，撤销信号就会立即被传达给这个<code>Context</code>值，并由它的<code>Done</code>方法的结果值（一个接收通道）表达出来。</p><p>撤销函数只负责触发信号，而对应的可撤销的<code>Context</code>值也只负责传达信号，它们都不会去管后边具体的“撤销”操作。实际上，我们的代码可以在感知到撤销信号之后，进行任意的操作，<code>Context</code>值对此并没有任何的约束。</p><p>最后，若再深究的话，这里的“撤销”最原始的含义其实就是，终止程序针对某种请求（比如HTTP请求）的响应，或者取消对某种指令（比如SQL指令）的处理。这也是Go语言团队在创建<code>context</code>代码包，和<code>Context</code>类型时的初衷。</p><p>如果我们去查看<code>net</code>包和<code>database/sql</code>包的API和源码的话，就可以了解它们在这方面的典型应用。</p><h3>问题2：撤销信号是如何在上下文树中传播的？</h3><p>我在前面讲了，<code>context</code>包中包含了四个用于繁衍<code>Context</code>值的函数。其中的<code>WithCancel</code>、<code>WithDeadline</code>和<code>WithTimeout</code>都是被用来基于给定的<code>Context</code>值产生可撤销的子值的。</p><p><code>context</code>包的<code>WithCancel</code>函数在被调用后会产生两个结果值。第一个结果值就是那个可撤销的<code>Context</code>值，而第二个结果值则是用于触发撤销信号的函数。</p><p>在撤销函数被调用之后，对应的<code>Context</code>值会先关闭它内部的接收通道，也就是它的<code>Done</code>方法会返回的那个通道。</p><p>然后，它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个<code>Context</code>值会断开它与其父值之间的关联。</p><p><img src=\"https://static001.geekbang.org/resource/image/a8/9e/a801f8f2b5e89017ec2857bc1815fc9e.png?wh=1112*647\" alt=\"\"></p><p>（在上下文树中传播撤销信号）</p><p>我们通过调用<code>context</code>包的<code>WithDeadline</code>函数或者<code>WithTimeout</code>函数生成的<code>Context</code>值也是可撤销的。它们不但可以被手动撤销，还会依据在生成时被给定的过期时间，自动地进行定时撤销。这里定时撤销的功能是借助它们内部的计时器来实现的。</p><p>当过期时间到达时，这两种<code>Context</code>值的行为与<code>Context</code>值被手动撤销时的行为是几乎一致的，只不过前者会在最后停止并释放掉其内部的计时器。</p><p>最后要注意，通过调用<code>context.WithValue</code>函数得到的<code>Context</code>值是不可撤销的。撤销信号在被传播时，若遇到它们则会直接跨过，并试图将信号直接传给它们的子值。</p><h3>问题 3：怎样通过<code>Context</code>值携带数据？怎样从中获取数据？</h3><p>既然谈到了<code>context</code>包的<code>WithValue</code>函数，我们就来说说<code>Context</code>值携带数据的方式。</p><p><code>WithValue</code>函数在产生新的<code>Context</code>值（以下简称含数据的<code>Context</code>值）的时候需要三个参数，即：父值、键和值。与“字典对于键的约束”类似，这里键的类型必须是可判等的。</p><p>原因很简单，当我们从中获取数据的时候，它需要根据给定的键来查找对应的值。不过，这种<code>Context</code>值并不是用字典来存储键和值的，后两者只是被简单地存储在前者的相应字段中而已。</p><p><code>Context</code>类型的<code>Value</code>方法就是被用来获取数据的。在我们调用含数据的<code>Context</code>值的<code>Value</code>方法时，它会先判断给定的键，是否与当前值中存储的键相等，如果相等就把该值中存储的值直接返回，否则就到其父值中继续查找。</p><p>如果其父值中仍然未存储相等的键，那么该方法就会沿着上下文根节点的方向一路查找下去。</p><p>注意，除了含数据的<code>Context</code>值以外，其他几种<code>Context</code>值都是无法携带数据的。因此，<code>Context</code>值的<code>Value</code>方法在沿路查找的时候，会直接跨过那几种值。</p><p>如果我们调用的<code>Value</code>方法的所属值本身就是不含数据的，那么实际调用的就将会是其父辈或祖辈的<code>Value</code>方法。这是由于这几种<code>Context</code>值的实际类型，都属于结构体类型，并且它们都是通过“将其父值嵌入到自身”，来表达父子关系的。</p><p>最后，提醒一下，<code>Context</code>接口并没有提供改变数据的方法。因此，在通常情况下，我们只能通过在上下文树中添加含数据的<code>Context</code>值来存储新的数据，或者通过撤销此种值的父值丢弃掉相应的数据。如果你存储在这里的数据可以从外部改变，那么必须自行保证安全。</p><h2>总结</h2><p>我们今天主要讨论的是<code>context</code>包中的函数和<code>Context</code>类型。该包中的函数都是用于产生新的<code>Context</code>类型值的。<code>Context</code>类型是一个可以帮助我们实现多goroutine协作流程的同步工具。不但如此，我们还可以通过此类型的值传达撤销信号或传递数据。</p><p><code>Context</code>类型的实际值大体上分为三种，即：根<code>Context</code>值、可撤销的<code>Context</code>值和含数据的<code>Context</code>值。所有的<code>Context</code>值共同构成了一颗上下文树。这棵树的作用域是全局的，而根<code>Context</code>值就是这棵树的根。它是全局唯一的，并且不提供任何额外的功能。</p><p>可撤销的<code>Context</code>值又分为：只可手动撤销的<code>Context</code>值，和可以定时撤销的<code>Context</code>值。</p><p>我们可以通过生成它们时得到的撤销函数来对其进行手动的撤销。对于后者，定时撤销的时间必须在生成时就完全确定，并且不能更改。不过，我们可以在过期时间达到之前，对其进行手动的撤销。</p><p>一旦撤销函数被调用，撤销信号就会立即被传达给对应的<code>Context</code>值，并由该值的<code>Done</code>方法返回的接收通道表达出来。</p><p>“撤销”这个操作是<code>Context</code>值能够协调多个goroutine的关键所在。撤销信号总是会沿着上下文树叶子节点的方向传播开来。</p><p>含数据的<code>Context</code>值可以携带数据。每个值都可以存储一对键和值。在我们调用它的<code>Value</code>方法的时候，它会沿着上下文树的根节点的方向逐个值的进行查找。如果发现相等的键，它就会立即返回对应的值，否则将在最后返回<code>nil</code>。</p><p>含数据的<code>Context</code>值不能被撤销，而可撤销的<code>Context</code>值又无法携带数据。但是，由于它们共同组成了一个有机的整体（即上下文树），所以在功能上要比<code>sync.WaitGroup</code>强大得多。</p><h2>思考题</h2><p>今天的思考题是：<code>Context</code>值在传达撤销信号的时候是广度优先的，还是深度优先的？其优势和劣势都是什么？</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","comments":[{"had_liked":false,"id":34893,"user_name":"Cloud","can_delete":false,"product_type":"c1","uid":1147061,"ip_address":"","ucode":"86B1C459EC9F82","user_header":"https://static001.geekbang.org/account/avatar/00/11/80/b5/f59d92f1.jpg","comment_is_top":false,"comment_ctime":1540347200,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"482576684352","product_id":100013101,"comment_content":"还没用过context包的我看得一愣一愣的","like_count":112,"discussions":[{"author":{"id":1251238,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/a6/fae3dd91.jpg","nickname":"扭断翅膀的猪","note":"","ucode":"E94AE44B950C91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384336,"discussion_content":"写得不咋地这文章","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1626506719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1534500,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qhonwcQle1RBufvLdTm4MgSNl554GBXUZtNNH65oYajbbRLxKsZX4hM9vFtrLLpDM0H93ZNWRFAZSrIZC7yAsQ/132","nickname":"Geek_as","note":"","ucode":"AB7B70DBC2B5F8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565359,"discussion_content":"吾道不孤","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650448906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2626977,"avatar":"https://static001.geekbang.org/account/avatar/00/28/15/a1/eb056e50.jpg","nickname":"🇲 🇳 🇸 🇮 🇳 🇷","note":"","ucode":"ECE45138BE7C1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410096,"discussion_content":"直接蒙蔽……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635599703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065849,"avatar":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","nickname":"test","note":"","ucode":"9A4973E591DD12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374564,"discussion_content":"直接懵逼","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621247816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46923,"user_name":"Spike","can_delete":false,"product_type":"c1","uid":1200587,"ip_address":"","ucode":"9548DF1596CF9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/cb/c8b42257.jpg","comment_is_top":false,"comment_ctime":1544002448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"259242040208","product_id":100013101,"comment_content":"https:&#47;&#47;blog.golang.org&#47;pipelines<br>https:&#47;&#47;blog.golang.org&#47;context<br>要了解context的来源和用法，建议先阅读官网的这两篇blog<br>","like_count":60},{"had_liked":false,"id":55953,"user_name":"勉才","can_delete":false,"product_type":"c1","uid":1054033,"ip_address":"","ucode":"D2A1E7E5043B45","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/51/223b6e04.jpg","comment_is_top":false,"comment_ctime":1546354107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"156165176763","product_id":100013101,"comment_content":"context 树不难理解，context.Background 是根节点，但它是个空的根节点，然后通过它我们可以创建出自己的 context 节点，在这个节点之下又可以创建出新的 context 节点。看了 context 的实现，其实它就是通过一个 channel 来实现，cancel() 就是关闭该管道，context.Done() 在 channel 关闭后，会返回。替我们造的轮子主要实现两个功能：1. 加锁，实现线程安全；2. cancel() 会将本节点，及子节点的 channel 都关闭。","like_count":37},{"had_liked":false,"id":39876,"user_name":"Li Yao","can_delete":false,"product_type":"c1","uid":1129838,"ip_address":"","ucode":"703E1E5505F70D","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/6e/60680aa4.jpg","comment_is_top":false,"comment_ctime":1542373191,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"143276293959","product_id":100013101,"comment_content":"如果能举一个实际的应用场景就更好了，这篇看不太懂用途","like_count":33,"discussions":[{"author":{"id":1474954,"avatar":"https://static001.geekbang.org/account/avatar/00/16/81/8a/15a96a64.jpg","nickname":"Gatsby","note":"","ucode":"5DBFDA12556BDB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540511,"discussion_content":"https://www.topgoer.com/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/Context.html 可以看这个","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1640073243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45226,"user_name":"丁香与茉莉","can_delete":false,"product_type":"c1","uid":1160240,"ip_address":"","ucode":"D07BD61BF23B34","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/30/d929bf57.jpg","comment_is_top":false,"comment_ctime":1543562725,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"87442908645","product_id":100013101,"comment_content":"http:&#47;&#47;www.flysnow.org&#47;2017&#47;05&#47;12&#47;go-in-action-go-context.html","like_count":20,"discussions":[{"author":{"id":1000028,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/5c/5b4149dc.jpg","nickname":"飞翔123","note":"","ucode":"F66CA8B6BED91F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587454,"discussion_content":"可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663064493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212313,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/99/6a92ff95.jpg","nickname":"Jesson","note":"","ucode":"EBADA87D9E5AE6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561079,"discussion_content":"讲的很清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649547867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2038856,"avatar":"","nickname":"Geek_b93edf","note":"","ucode":"DD0C362D29C359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293204,"discussion_content":"这个可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595476929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98557,"user_name":"Timo","can_delete":false,"product_type":"c1","uid":1223829,"ip_address":"","ucode":"6A7FEB30B09797","user_header":"https://static001.geekbang.org/account/avatar/00/12/ac/95/9b3e3859.jpg","comment_is_top":false,"comment_ctime":1559027603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61688569747","product_id":100013101,"comment_content":"Context 使用原则<br>不要把Context放在结构体中，要以参数的方式传递<br>以Context作为参数的函数方法，应该把Context作为第一个参数，放在第一位。<br>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO<br>Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递<br>Context是线程安全的，可以放心的在多个goroutine中传递","like_count":14},{"had_liked":false,"id":246283,"user_name":"鸠摩·智","can_delete":false,"product_type":"c1","uid":1211909,"ip_address":"","ucode":"6CD93CD1DB6955","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/05/431d380f.jpg","comment_is_top":false,"comment_ctime":1599256274,"is_pvip":false,"replies":[{"id":"90521","content":"首先要明确：<br>1. coordinateWithContext函数里的for语句是为了启用12个goroutine，但是这些go函数谁先执行谁后执行与这些goroutine的启用顺序而关。<br>2. addNum函数里的defer函数会在它后面的for语句执行完毕之后才开始执行。<br><br>所以，第一个问题的答案是：不会。因为总会有一个addNum函数把num的值变成12，然后执行deferFunc函数，并由于num==12而执行cancelFunc函数。<br><br>另外，这些go函数在调用addNum函数时会碰到自旋的情况（程序会打印出来），但是绝不会造成死锁，因为这些AddNum函数中的CAS操作早晚会执行成功。原子的Load+CAS外加for语句，相当于乐观锁，而且它们的操作都很“规矩”（都只是+1而已）。你也可以理解为把这12次“累加”串行化了，只不过大家是并发的，都在寻找自己“累加”成功的机会。<br><br>第二个问题：当前context会马上感知到，但前提是它是可撤销的。通过WithValue函数构造出来的context只会传递不会感知（通过匿名字段实现的）。<br><br>第三个问题：你已经把答案说出来了，我就不复述了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1599273513,"ip_address":"","comment_id":246283,"utype":1}],"discussion_count":4,"race_medal":5,"score":"31664027346","product_id":100013101,"comment_content":"@郝老师 有几点疑问烦劳回答下，谢谢！<br>1、在coordinateWithContext的例子中，总共有12个子goroutine被创建，第12个即最后一个子goroutine在运行结束时，会通过计算defer表达式从而触发cancelFunc的调用，从而通知主goroutine结束在ctx.Done上获取通道的接收等待。我的问题是，在第12个子goroutine计算defer表达式的时候，会不会存在if条件不满足，未执行到cancelFunc的情况？或者说，在此时，第1到第11的子goroutine中，会存在自旋cas未执行完的情况吗？如果这种情况有，是否会导致主goroutine永远阻塞的情况？<br>2、在撤销函数被调用的时候，在当前context上，通过contex.Done获取的通道会马上感知到吗？还是会同步等待，使撤销信号在当前context的所有subtree上的所有context传播完成后，再感知到？还是有其他情况？<br>3、WithDeadline和WithTimeout的区别是什么？具体说，deadline是针对某个具体时间，而timeout是针对当前时间的延时来定义自动撤销时间吗？<br>感谢回复！","like_count":7,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505100,"discussion_content":"首先要明确：\n1. coordinateWithContext函数里的for语句是为了启用12个goroutine，但是这些go函数谁先执行谁后执行与这些goroutine的启用顺序而关。\n2. addNum函数里的defer函数会在它后面的for语句执行完毕之后才开始执行。\n\n所以，第一个问题的答案是：不会。因为总会有一个addNum函数把num的值变成12，然后执行deferFunc函数，并由于num==12而执行cancelFunc函数。\n\n另外，这些go函数在调用addNum函数时会碰到自旋的情况（程序会打印出来），但是绝不会造成死锁，因为这些AddNum函数中的CAS操作早晚会执行成功。原子的Load+CAS外加for语句，相当于乐观锁，而且它们的操作都很“规矩”（都只是+1而已）。你也可以理解为把这12次“累加”串行化了，只不过大家是并发的，都在寻找自己“累加”成功的机会。\n\n第二个问题：当前context会马上感知到，但前提是它是可撤销的。通过WithValue函数构造出来的context只会传递不会感知（通过匿名字段实现的）。\n\n第三个问题：你已经把答案说出来了，我就不复述了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599273513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1987829,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoOia8n2xdlIBYWVBmevjIuaMickvceJ2JX4IHOaibrmEWmia1gM29jhjLCJcYU9lSXLInNlToAbc5Gg/132","nickname":"张伟","note":"","ucode":"3A45B9536F91E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369460,"discussion_content":"第二个问题，我也迷惑，看源码，确实是直接影响主函数，取消后，ctx.Done就结束了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619051390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103450,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d6/5a/bd2378eb.jpg","nickname":"刘义宝","note":"","ucode":"CF402E390B2442","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346056,"discussion_content":"老师说的很清晰，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611846544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211909,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7e/05/431d380f.jpg","nickname":"鸠摩·智","note":"","ucode":"6CD93CD1DB6955","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303515,"discussion_content":"谢谢 @郝老师 仔细认真耐心地回复。我仔细研读了你的回复内容，和回想了以前课程的章节内容，问题一我彻底理解了，逻辑是没有问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599289686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86914,"user_name":"郝林","can_delete":false,"product_type":"c1","uid":1026643,"ip_address":"","ucode":"F66BA62BA56FFA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","comment_is_top":false,"comment_ctime":1555476256,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"31620247328","product_id":100013101,"comment_content":"我看不少读者都说写一篇难理解。可能的确如此，因为我假设你们已对context包有基本的了解。<br><br>不过没关系，你们有此方面的任何问题都可以通过以下三个途径与我讨论：<br><br>1. 直接在专栏文章下留言；<br>2. 在 GoHackers 微信群或者 BearyChat 中的 GoHackers 团队空间里艾特我；<br>3. 在知识星球中的 GoHackers VIP 社群里向我提问。","like_count":7,"discussions":[{"author":{"id":1329995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","nickname":"Luciano李鑫","note":"","ucode":"5FBE5F86FD5B2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328346,"discussion_content":"为什么不是在这里讲清楚？这老师怪怪的","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1606125143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445504,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/gVfU7icdia3o5ZNaHjaWAdgkSYIpU1rdhIlVYiahYCvRlDZu2K6oPSvVobNjzwZbUaiayQcKjicZ44WjfWJCj5xdlPA/132","nickname":"红尘","note":"","ucode":"CCCD5736755DF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33406,"discussion_content":"老师就是微信群必须有人拉我啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571121187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1495497,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKmB1DWZP1l7QsgU8eXpyuicS6oWbuia3NUI6R77Sib9HHgOoDeX9lYcR9csU4BNZXg1dK9wjLq0Ehcg/132","nickname":"武子","note":"","ucode":"2F865ED507742E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3923,"discussion_content":"老师你好，gohackers微信群怎么加入 我微信搜了公众号 说主要已入群的朋友拉我 能帮忙拉我进去吗 谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564983393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1395689,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4b/e9/bbccf643.jpg","nickname":"sanmao","note":"","ucode":"D695D88677E3D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1495497,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKmB1DWZP1l7QsgU8eXpyuicS6oWbuia3NUI6R77Sib9HHgOoDeX9lYcR9csU4BNZXg1dK9wjLq0Ehcg/132","nickname":"武子","note":"","ucode":"2F865ED507742E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353340,"discussion_content":"有人拉你了吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615136622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3923,"ip_address":""},"score":353340,"extra":""}]}]},{"had_liked":false,"id":39442,"user_name":"憶海拾貝","can_delete":false,"product_type":"c1","uid":1054727,"ip_address":"","ucode":"99E883A8601DED","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/07/9f5f5dd3.jpg","comment_is_top":false,"comment_ctime":1542276735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31607047807","product_id":100013101,"comment_content":"服务间调用通常要传递上下文数据，用带值Context在每个函数间传递是一种方式，但从Python过来的我觉得这对代码侵入性蛮大的。请问go中还有什么更好的办法传递上下文数据呢？","like_count":7},{"had_liked":false,"id":35089,"user_name":"Shawn","can_delete":false,"product_type":"c1","uid":1198804,"ip_address":"","ucode":"8CCF006786999B","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/d4/a3231668.jpg","comment_is_top":false,"comment_ctime":1540404825,"is_pvip":false,"replies":[{"id":"13315","content":"打印出来的顺序不定是正常的，因为goroutine会被实时调度啊，打印出来的顺序不一定就是真实顺序。每填语句执行完都可能被调度。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541482317,"ip_address":"","comment_id":35089,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27310208601","product_id":100013101,"comment_content":"看代码是深度优先，但是我自己写了demo，顺序是乱的，求老师讲解","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427442,"discussion_content":"打印出来的顺序不定是正常的，因为goroutine会被实时调度啊，打印出来的顺序不一定就是真实顺序。每填语句执行完都可能被调度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541482317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149336,"user_name":"Geek_f39659","can_delete":false,"product_type":"c1","uid":1636568,"ip_address":"","ucode":"2206A8C590423C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6iagw7ct4ca3niaSEFNicu2wy2KuCibO6eiaRzoRGJb50WTrbkKQib9mTArnTr8jJUazO9O2ibLZNfjjl35cfCHkBPs7N/132","comment_is_top":false,"comment_ctime":1573196278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23048032758","product_id":100013101,"comment_content":"根据这句话：“A great mental model of using Context is that it should flow through your program. Imagine a river or running water. This generally means that you don’t want to store it somewhere like in a struct. Nor do you want to keep it around any more than strictly needed. Context should be an interface that is passed from function to function down your call stack, augmented as needed.”<br><br>感觉上Context设计上更像是一个运行时的动态概念，它更像是代表传统call stack 层层镶套外加分叉关系的那颗树。代表着运行时态的调用树。所以它最好就是只存在于函数体的闭包之中，大家口口相传，“传男不传女”。“因为我调用你，所以我才把这个传给你，你可以传给你的子孙，但不要告诉别人！”。所以最好不要把它保存起来让旁人有机会看得到或用到。<br><br>楼上有人提到这种风格的入侵性，我能理解你的感觉。但以我以前玩Node.js中的cls (continuation local storage)踩过的那些坑来看，我宁愿两害相权取其轻。这种入侵性至少是可控的，显式的。同步编程的世界我们只需要TLS(Thread local storage)就好了，但对应的异步编程的世界里玩cls很难搞的。在我来看，Context显然是踩过那些坑的老鸟搞出来的。","like_count":5},{"had_liked":false,"id":333915,"user_name":"mclee","can_delete":false,"product_type":"c1","uid":1382972,"ip_address":"","ucode":"294D4A0BFAF0FD","user_header":"https://static001.geekbang.org/account/avatar/00/15/1a/3c/60b12211.jpg","comment_is_top":false,"comment_ctime":1644581419,"is_pvip":false,"replies":[{"id":"121984","content":"我说的跳过是源码级别的跳过，是跳过value节点直接传到它下级的节点，因为value节点本身是没有timeout机制，无需让cancel信号在那里发挥什么作用。<br><br>在value节点上的Done()在源码级别实际上调用的并不是value节点自己的方法，而是它上级节点（甚至上上级）的方法。","user_name":"作者回复","user_name_real":"作者","uid":"1026643","ctime":1644639276,"ip_address":"","comment_id":333915,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18824450603","product_id":100013101,"comment_content":"<br>实测了下，context.WithValue 得到的新的 ctx 当其 parent context cancle 时也能收到 done 信号啊，并不是文中说的那样会跳过！<br><br>package main<br><br>import (<br>\t&quot;context&quot;<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tctx1, cancelFun := context.WithCancel(context.Background())<br>\tctx2 := context.WithValue(ctx1, &quot;&quot;, &quot;&quot;)<br>\tctx3, _ := context.WithCancel(ctx1)<br><br>\tgo watch(ctx1, &quot;ctx1&quot;)<br>\tgo watch(ctx2, &quot;ctx2&quot;)<br>\tgo watch(ctx3, &quot;ctx3&quot;)<br><br>\ttime.Sleep(2 * time.Second)<br>\tfmt.Println(&quot;可以了，通知监控停止&quot;)<br>\tcancelFun()<br><br>\t&#47;&#47;为了检测监控过是否停止，如果没有监控输出，就表示停止了<br>\ttime.Sleep(5 * time.Second)<br><br>}<br><br>func watch(ctx context.Context, name string) {<br>\tfor {<br>\t\tselect {<br>\t\tcase &lt;-ctx.Done():<br>\t\t\tfmt.Println(name,&quot;监控退出，停止了...&quot;)<br>\t\t\treturn<br>\t\tdefault:<br>\t\t\tfmt.Println(name,&quot;goroutine监控中...&quot;)<br>\t\t\ttime.Sleep(2 * time.Second)<br>\t\t}<br>\t}<br>}<br>","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550617,"discussion_content":"我说的跳过是源码级别的跳过，是跳过value节点直接传到它下级的节点，因为value节点本身是没有timeout机制，无需让cancel信号在那里发挥什么作用。\n\n在value节点上的Done()在源码级别实际上调用的并不是value节点自己的方法，而是它上级节点（甚至上上级）的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644639276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134895,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/2f/7b04140c.jpg","nickname":"孫やさん","note":"","ucode":"C60877C1C71685","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584042,"discussion_content":"我也理解成withValue不会被取消了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660572022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1002201,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/d9/75dd7cf9.jpg","nickname":"Mew151","note":"","ucode":"D4793F5874F345","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134895,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/2f/7b04140c.jpg","nickname":"孫やさん","note":"","ucode":"C60877C1C71685","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":585407,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661511728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":584042,"ip_address":"北京"},"score":585407,"extra":""}]},{"author":{"id":1217554,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","nickname":"Jason","note":"","ucode":"C5A540BC5A60B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580391,"discussion_content":"WithValue生成的ctx没有自己的Done函数，它应该是&#34;继承&#34;自父辈的。还有一点是只有WitchCancel和witchDealine/timeout产生的ctx，才会放在父辈的child里，从而在cancel时去通知child","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658138513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255554,"user_name":"Direction","can_delete":false,"product_type":"c1","uid":1731977,"ip_address":"","ucode":"298D5109EA28EE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6d/89/14031273.jpg","comment_is_top":false,"comment_ctime":1603371794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18783240978","product_id":100013101,"comment_content":"在 Go 服务中，每个传入的请求都在它自己的 goroutine 中处理。请求处理程序通常启动额外的 goroutine 来访问后端，如数据库和 RPC 服务。<br>  处理请求的 goroutine 集通常需要访问特定于请求的值，例如最终用户的身份、授权令牌和请求的截止日期。当一个请求被取消或超时时（cancelFunc() or WithTimeout()），处理该请求的所<br>  有 goroutines 应该快速退出(ctx.Done（）)，以便系统可以回收（reclaim）它们正在使用的任何资源。<br><br>感觉这个举例挺好的（参考至：https:&#47;&#47;blog.golang.org&#47;context）","like_count":4},{"had_liked":false,"id":117243,"user_name":"茴香根","can_delete":false,"product_type":"c1","uid":1316111,"ip_address":"","ucode":"B91C00B72077F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/15/0f/954be2db.jpg","comment_is_top":false,"comment_ctime":1564014773,"is_pvip":false,"replies":[{"id":"42959","content":"是的，这涉及到两个方面，需要综合起来看。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1564020838,"ip_address":"","comment_id":117243,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18743883957","product_id":100013101,"comment_content":"留言区很多人说Context 是深度优先，但是我在想每个goroutine 被调用的顺序都是不确定的，因此在编写goroutine 代码时，实际的撤销响应不能假定其父或子context 所在的goroutine一定先或者后结束。","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459877,"discussion_content":"是的，这涉及到两个方面，需要综合起来看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564020838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84001,"user_name":"Cutler","can_delete":false,"product_type":"c1","uid":1228136,"ip_address":"","ucode":"2EDECFE039845B","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/68/3fd6428d.jpg","comment_is_top":false,"comment_ctime":1554768393,"is_pvip":false,"replies":[{"id":"30331","content":"很明显，context.Background()返回的是全局的上下文根（我在文章中多次提到），context.TODO()返回的是空的上下文（表明应用的不确定性）。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1554781647,"ip_address":"","comment_id":84001,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18734637577","product_id":100013101,"comment_content":"cotext.backround()和cotext.todo()有什么区别","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446211,"discussion_content":"很明显，context.Background()返回的是全局的上下文根（我在文章中多次提到），context.TODO()返回的是空的上下文（表明应用的不确定性）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554781647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548574,"discussion_content":"context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生出来；\ncontext.TODO 应该仅在不确定应该使用哪种上下文时使用；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643268036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23408,"discussion_content":"context.TODO() 的主要应用场景是什么呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569813915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35169,"user_name":"属雨","can_delete":false,"product_type":"c1","uid":1202624,"ip_address":"","ucode":"700236847A5C94","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/c0/6f02c096.jpg","comment_is_top":false,"comment_ctime":1540443423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14425345311","product_id":100013101,"comment_content":"深度优先，看func (c *cancelCtx) cancel(removeFromParent bool, err error)方法的源代码。","like_count":3},{"had_liked":false,"id":38258,"user_name":"HOPE","can_delete":false,"product_type":"c1","uid":1017740,"ip_address":"","ucode":"3A7E10C245BACD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/8c/468aa27b.jpg","comment_is_top":false,"comment_ctime":1542005863,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10131940455","product_id":100013101,"comment_content":"老师，请教个问题。我运行了多个goroutine，每个goroutine有不同的配置。我现在想修改运行时的goroutine的配置，使用context可以实现吗？或者可以用什么办法实现？","like_count":2,"discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145864,"discussion_content":"etcd？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579585356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34899,"user_name":"罗志洪","can_delete":false,"product_type":"c1","uid":1205524,"ip_address":"","ucode":"F8A6E6958F0744","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/14/2e4edf4e.jpg","comment_is_top":false,"comment_ctime":1540349049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10130283641","product_id":100013101,"comment_content":"context树有点难理解。","like_count":2},{"had_liked":false,"id":291365,"user_name":"hunterlodge","can_delete":false,"product_type":"c1","uid":1069755,"ip_address":"","ucode":"5B83A79E784161","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/bb/225e70a6.jpg","comment_is_top":false,"comment_ctime":1620229523,"is_pvip":false,"replies":[{"id":"105569","content":"你引用的这段话其实有两层含义：<br><br>1. 某个值的指针值的传递并不会导致源值（即指针指向的那个值）的拷贝。<br>2. 接口值里面其实会存储实际值的指针值，而不是实际值。所以在拷贝之后，其中的实际值依然是源值。<br><br>你看过sync包的文档吗？里面的同步工具大都不允许“使用之后的再传递”。<br><br>其实这种约束的原因就是，传递值会导致值的拷贝。如此一来，原值（即拷贝前的值）和拷贝值就是两个（几乎）不相干的值了。在两边分别对它们进行操作，也就起不到同步工具原有的作用了。<br><br>但如果是传递指针值的话，两边操作的仍然会是同一个源值，对吧？这就避免了同步工具的“操作失灵”的问题。<br><br>你说的“指针会导致数据共享和竞争”是另一个视角的问题。但是这两个问题的底层知识是一个，即：传递指针值的时候并不会拷贝源值，导致分别操作两个指针值相当于在操作同一个源值。<br><br>同步工具的内部自有避免竞争的手段，所以拷贝其指针值在大多数情况下是可以的。但是，最好还是不要拷贝它们的指针值（尤其是sync包中的那些工具），因为这样很可能会迷惑住读代码和后续写代码的人，导致理解错误或操作错误的概率很大。<br><br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1620280098,"ip_address":"","comment_id":291365,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5915196819","product_id":100013101,"comment_content":"“由于Context类型实际上是一个接口类型，而context包中实现该接口的所有私有类型，都是基于某个数据类型的指针类型，所以，如此传播并不会影响该类型值的功能和安全。”<br>请问老师，这句话中的「所以」二字怎么理解呢？指针不是会导致数据共享和竞争吗？为什么反而是安全的呢？谢谢！","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519451,"discussion_content":"你引用的这段话其实有两层含义：\n\n1. 某个值的指针值的传递并不会导致源值（即指针指向的那个值）的拷贝。\n2. 接口值里面其实会存储实际值的指针值，而不是实际值。所以在拷贝之后，其中的实际值依然是源值。\n\n你看过sync包的文档吗？里面的同步工具大都不允许“使用之后的再传递”。\n\n其实这种约束的原因就是，传递值会导致值的拷贝。如此一来，原值（即拷贝前的值）和拷贝值就是两个（几乎）不相干的值了。在两边分别对它们进行操作，也就起不到同步工具原有的作用了。\n\n但如果是传递指针值的话，两边操作的仍然会是同一个源值，对吧？这就避免了同步工具的“操作失灵”的问题。\n\n你说的“指针会导致数据共享和竞争”是另一个视角的问题。但是这两个问题的底层知识是一个，即：传递指针值的时候并不会拷贝源值，导致分别操作两个指针值相当于在操作同一个源值。\n\n同步工具的内部自有避免竞争的手段，所以拷贝其指针值在大多数情况下是可以的。但是，最好还是不要拷贝它们的指针值（尤其是sync包中的那些工具），因为这样很可能会迷惑住读代码和后续写代码的人，导致理解错误或操作错误的概率很大。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620278448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137688,"user_name":"moooofly","can_delete":false,"product_type":"c1","uid":1008348,"ip_address":"","ucode":"4A20795C281B6F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","comment_is_top":false,"comment_ctime":1569823767,"is_pvip":false,"replies":[{"id":"53001","content":"逻辑上会一起断开的。但由于 value context 本身不会去传递信号，所以实质上不用做断开操作。这几种 context 所起到的作用是不同的，所以有些专属的操作只会在对应的 context 上做。不过与它们临近的其他种类的 context 会随之联动。你看下源码就清楚了，它们不是完全“链接”在一起的，有的会紧密嵌套在一起，所以有的操作可以很自然地进行跨越式处理。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1569914737,"ip_address":"","comment_id":137688,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5864791063","product_id":100013101,"comment_content":"“它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个 Context 值会断开它与其父值之间的关联。”--这里有一个问题，我能理解，当在这个上下文树上的某个 node 上触发 cancel 信号时，以该 node 为根的子上下文树会从原来的树上断开；而文中又提到“撤销信号在被传播时，若遇到它们（调用 context.WithValue 函数得到的 Context 值）则会直接跨过” ，那么，这些被“跨过”的 node ，在上面说的子上下文树断开的过程里，是一起断开了？还是仍旧会和更上层的 node 节点有关联？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469212,"discussion_content":"逻辑上会一起断开的。但由于 value context 本身不会去传递信号，所以实质上不用做断开操作。这几种 context 所起到的作用是不同的，所以有些专属的操作只会在对应的 context 上做。不过与它们临近的其他种类的 context 会随之联动。你看下源码就清楚了，它们不是完全“链接”在一起的，有的会紧密嵌套在一起，所以有的操作可以很自然地进行跨越式处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569914737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24003,"discussion_content":"多谢解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569978672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130278,"user_name":"海盗船长","can_delete":false,"product_type":"c1","uid":1363634,"ip_address":"","ucode":"ECB28BA21A4113","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/b2/1f914527.jpg","comment_is_top":false,"comment_ctime":1567416733,"is_pvip":false,"replies":[{"id":"48679","content":"你可以说的具体一些。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1567475204,"ip_address":"","comment_id":130278,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862384029","product_id":100013101,"comment_content":"实际使用中 http.ReverseProxy经常会报 proxy error：context canceled 请问老师有哪些原因可能导致这个问题","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465888,"discussion_content":"你可以说的具体一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567475204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114073,"user_name":"闫飞","can_delete":false,"product_type":"c1","uid":1013162,"ip_address":"","ucode":"30C782D30108D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/aa/21275b9d.jpg","comment_is_top":false,"comment_ctime":1563236186,"is_pvip":false,"replies":[{"id":"41615","content":"翻译的词？这是我找到的一个比较贴切的词。把 Context 比喻成可以繁衍后代的生物不会更容易理解一些么？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1563243682,"ip_address":"","comment_id":114073,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858203482","product_id":100013101,"comment_content":"繁衍一词的翻译有些生硬，是否能换一个好理解一些的中文词汇","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458503,"discussion_content":"翻译的词？这是我找到的一个比较贴切的词。把 Context 比喻成可以繁衍后代的生物不会更容易理解一些么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563243682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357388,"user_name":"黄仲辉","can_delete":false,"product_type":"c1","uid":1593521,"ip_address":"河南","ucode":"D7EB3C3ADD99DA","user_header":"https://static001.geekbang.org/account/avatar/00/18/50/b1/7b701518.jpg","comment_is_top":false,"comment_ctime":1663218368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663218368","product_id":100013101,"comment_content":"context实现goroutine的协调，此处并不严谨，触发cancel的gorutine执行完任务了，不代表其他gorutine也执行完了，这样就有任务被中断了。","like_count":0},{"had_liked":false,"id":345445,"user_name":"寻风","can_delete":false,"product_type":"c1","uid":2230331,"ip_address":"","ucode":"A5294CF85BDA50","user_header":"https://static001.geekbang.org/account/avatar/00/22/08/3b/6fbc7ea0.jpg","comment_is_top":false,"comment_ctime":1652273886,"is_pvip":false,"replies":[{"id":"126245","content":"严格来说，Context的功用是在多个goroutine之间传递信号，比如传递状态开关。传值只是它的一个副作用而已，而且需要用特定的实现类型来做（涉及到context.WithValue函数）。<br><br>如果你的主要目的是传值，那么推荐使用channel。当然了，在一对多传值的时候，Context显然更方便一些。<br><br>另外，从源码中我们可以看到，实现Context接口的类型都是某个结构体的指针类型。这更符合你说的第二段话。但同时，在内部也是有并发安全方面的保障的。","user_name":"作者回复","user_name_real":"作者","uid":"1026643","ctime":1652763261,"ip_address":"","comment_id":345445,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652273886","product_id":100013101,"comment_content":"Context可以看作是某个父goroutine的一个变量,并且这个变量是线程安全的, 当这个变量传入子的goroutine后, 就意味着父goroutine和子goroutine可以通过这个变量来进行信息交互?<br>或者Context是一个独立申请的的内存区域, 父goroutine和子goroutine都有一个指针指向它, 这样就可以通过这块共享的内存进行信息交互了?<br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572390,"discussion_content":"严格来说，Context的功用是在多个goroutine之间传递信号，比如传递状态开关。传值只是它的一个副作用而已，而且需要用特定的实现类型来做（涉及到context.WithValue函数）。\n\n如果你的主要目的是传值，那么推荐使用channel。当然了，在一对多传值的时候，Context显然更方便一些。\n\n另外，从源码中我们可以看到，实现Context接口的类型都是某个结构体的指针类型。这更符合你说的第二段话。但同时，在内部也是有并发安全方面的保障的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652763261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331012,"user_name":"窝窝头","can_delete":false,"product_type":"c1","uid":1063866,"ip_address":"","ucode":"5C2635ED6484F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/ba/3b30dcde.jpg","comment_is_top":false,"comment_ctime":1642378866,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642378866","product_id":100013101,"comment_content":"撤回的时候我觉得应该是深度优先的，先把自身的接收捅到关闭再传递给自身的所有子节点","like_count":0},{"had_liked":false,"id":327971,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1640425147,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1640425147","product_id":100013101,"comment_content":"func (c *cancelCtx) cancel(removeFromParent bool, err error) {<br>        ...<br>\tfor child := range c.children {<br>\t\t&#47;&#47; NOTE: acquiring the child&#39;s lock while holding parent&#39;s lock.<br>\t\tchild.cancel(false, err)<br>\t}<br>\t...<br>}<br>深度优先","like_count":0},{"had_liked":false,"id":322843,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1637631144,"is_pvip":false,"replies":[{"id":"117220","content":"“如果足够公平的话，至少要在等到当前执行的goroutine阻塞而让出cpu，才切到其他goroutine执行”<br><br>你说的这个策略才叫不公平啊。按照这种策略，如果一个goroutine一直不阻塞，那其他的goroutine就只能在那里傻等嘛？<br><br>另外，CPU的调度粒度是指令级别的，它根本就不知道goroutine的存在。即使是Go语言的运行时系统，它的调度粒度也是语句级别的。Goroutine只是Go程序中的并发执行单元，而不是调度单元。<br><br>具体地说，Goroutine（或者说go函数）只是把“对内需要串行执行，但对外需要并发执行”的那些代码归拢在了一起。而Go语言的runtime会在这些goroutine所包含的各个语句的执行间隙来做切换，比如：一个goroutine中的某条语句刚执行完，runtime就可能会转而去执行另一个goroutine中的（在中止点之后的那条）语句。<br><br>所以，回答你最后的疑问：你确实可以这样理解，Go语言的runtime是在多个goroutine之间不停的切换来并发的执行语句。<br><br>（而CPU并不知道这些，它只知道下面该执行哪条指令了，以及该指令涉及的数据在存储器的哪个位置。所以说，操作系统在这两边的中间扮演了相当重要的角色。）","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1637650058,"ip_address":"","comment_id":322843,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637631144","product_id":100013101,"comment_content":"coordinateWithContext中，如果改成WithTimeout创建ctx的话，主goroutine只要&lt;-ctx.Done()接收到挂壁通道的信号后就会立马解除阻塞，而执行退出，这个时候即使for中的子goroutine还没有执行完成也会被强制退出了，这样情况下某个子goroutine执行到一半的时候，会被‘中断’，感觉上没有得到公平的对待，个人理解的cpu在goroutine中调度，如果足够公平的话，至少要在等到当前执行的goroutine阻塞而让出cpu，才切到其他goroutine执行，还是我理解错了，cpu就是不停的在各个goroutine间切来来去的执行，而不管某个goroutine有没有阻塞","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532589,"discussion_content":"“如果足够公平的话，至少要在等到当前执行的goroutine阻塞而让出cpu，才切到其他goroutine执行”\n\n你说的这个策略才叫不公平啊。按照这种策略，如果一个goroutine一直不阻塞，那其他的goroutine就只能在那里傻等嘛？\n\n另外，CPU的调度粒度是指令级别的，它根本就不知道goroutine的存在。即使是Go语言的运行时系统，它的调度粒度也是语句级别的。Goroutine只是Go程序中的并发执行单元，而不是调度单元。\n\n具体地说，Goroutine（或者说go函数）只是把“对内需要串行执行，但对外需要并发执行”的那些代码归拢在了一起。而Go语言的runtime会在这些goroutine所包含的各个语句的执行间隙来做切换，比如：一个goroutine中的某条语句刚执行完，runtime就可能会转而去执行另一个goroutine中的（在中止点之后的那条）语句。\n\n所以，回答你最后的疑问：你确实可以这样理解，Go语言的runtime是在多个goroutine之间不停的切换来并发的执行语句。\n\n（而CPU并不知道这些，它只知道下面该执行哪条指令了，以及该指令涉及的数据在存储器的哪个位置。所以说，操作系统在这两边的中间扮演了相当重要的角色。）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637650058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322459,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1637399165,"is_pvip":false,"replies":[{"id":"117155","content":"goroutine依然是并发的，只不过到了最后需要等一等，可以叫“阶段性串行”吧。跟分布式系统里的“最终一致性”这个概念神似，都是到了某个执行节点上卡一下并保证同步性。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1637562752,"ip_address":"","comment_id":322459,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637399165","product_id":100013101,"comment_content":"waitgroup的改进版中，每批就是一个wg的技术周期，当前循环的计数周期没有完成，下一次不会开始，也就是说每stride这么多个个goroutine执行完成之前，是不会开起下一批goroutine的，这样的话，其实每一批之间是串行的，并不是并发total那么多goroutine，而是只并发了stride个goroutine，对吗？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532246,"discussion_content":"goroutine依然是并发的，只不过到了最后需要等一等，可以叫“阶段性串行”吧。跟分布式系统里的“最终一致性”这个概念神似，都是到了某个执行节点上卡一下并保证同步性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637562752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1101006,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","nickname":"jxs1211","note":"","ucode":"B7F1F2D84389E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":532421,"discussion_content":"那这个改进版的waitgroup和context.WithCancel的版本，本质上在goroutine的并发上是没有区别的吗，试想如果 go func中是一个耗时比较长的操作，那么总的执行时长上wg会更长吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637595794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532246,"ip_address":""},"score":532421,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":318268,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1635221517,"is_pvip":false,"replies":[{"id":"115435","content":"先不说你的程序是否真是并发的。<br><br>并发问题的出现是有一定概率的，不是说你自己写个简单程序测试没有问题就没有问题，通常都是需要压测的。而且就算像这种简单的程序在不同机器上的表现往往也是不同的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1635248704,"ip_address":"","comment_id":318268,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635221517","product_id":100013101,"comment_content":"func defaultCompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) {<br>\tif old != *addr {<br>\t\treturn false<br>\t}<br>\t*addr = new<br>\treturn true<br>}<br>这是我自己写的一个没有原子操作的defaultCompareAndSwapInt32，替换atomic.CompareAndSwapInt32，total := 120，测试的数据好像没有错乱，每个goroutine的交换都是都是递增的，是我理解错了吗<br>added from 0 to 1 --2 <br>added from 1 to 2 --4 <br>added from 2 to 3 --3 <br>added from 3 to 4 --5 <br>added from 4 to 5 --6 <br>added from 5 to 6 --7 <br>added from 6 to 7 --9 <br>added from 7 to 8 --8 <br>added from 8 to 9 --10 <br>added from 9 to 10 --11 <br>added from 10 to 11 --12 <br>added from 11 to 12 --13 <br>added from 12 to 13 --15 <br>added from 13 to 14 --14 <br>added from 14 to 15 --16 <br>added from 15 to 16 --18 <br>added from 16 to 17 --17 <br>added from 17 to 18 --19 <br>added from 18 to 19 --20 <br>added from 19 to 20 --22 <br>added from 20 to 21 --21 <br>added from 21 to 22 --23 <br>added from 22 to 23 --24 <br>added from 23 to 24 --25 <br>added from 24 to 25 --27 <br>added from 25 to 26 --28 <br>added from 26 to 27 --26 <br>。。。。<br>added from 83 to 84 --85 <br>added from 84 to 85 --87 <br>added from 85 to 86 --86 <br>added from 86 to 87 --88 <br>added from 87 to 88 --89 <br>added from 88 to 89 --91 <br>added from 89 to 90 --90 <br>added from 90 to 91 --93 <br>added from 91 to 92 --94 <br>added from 92 to 93 --92 <br>added from 93 to 94 --96 <br>added from 94 to 95 --97 <br>added from 95 to 96 --95 <br>added from 96 to 97 --98 <br>added from 97 to 98 --99 <br>added from 98 to 99 --100 <br>added from 99 to 100 --103 <br>added from 100 to 101 --101 <br>added from 101 to 102 --102 <br>added from 102 to 103 --104 <br>added from 103 to 104 --105 <br>added from 104 to 105 --106 <br>added from 105 to 106 --107 <br>added from 106 to 107 --108 <br>added from 107 to 108 --109 <br>added from 108 to 109 --112 <br>added from 109 to 110 --110 <br>added from 110 to 111 --111 <br>added from 111 to 112 --114 <br>added from 112 to 113 --113 <br>added from 113 to 114 --115 <br>added from 114 to 115 --117 <br>added from 115 to 116 --118 <br>added from 116 to 117 --116 <br>added from 117 to 118 --120 <br>added from 118 to 119 --119 <br>added from 119 to 120 --121 <br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529161,"discussion_content":"先不说你的程序是否真是并发的。\n\n并发问题的出现是有一定概率的，不是说你自己写个简单程序测试没有问题就没有问题，通常都是需要压测的。而且就算像这种简单的程序在不同机器上的表现往往也是不同的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635248704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318232,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1635211367,"is_pvip":false,"replies":[{"id":"115436","content":"当然存在并发安全问题，一定要通过相应手段进行保护，否则到了线上很可能会出问题（不同机器、不同配置、不同流量）","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1635248873,"ip_address":"","comment_id":318232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635211367","product_id":100013101,"comment_content":"把old := atomic.LoadInt32(num)<br>改成old := *num这样在没有防中断的情况下取值，实际测试了一些数据，没有出现错乱的情况，都能顺序递增（如下),这样是否存在线程不安全的情况，运行时间足够长是否就会出现数据错乱的情况<br>added from 201 to 202 --5<br>add failed from 201 to 202 --4<br>add failed from 201 to 202 --6<br>added from 202 to 203 --6<br>add failed from 202 to 203 --4<br>added from 203 to 204 --4<br>added from 204 to 205 --6<br>add failed from 204 to 205 --5<br>add failed from 204 to 205 --4<br>added from 205 to 206 --4<br>add failed from 205 to 206 --5<br>added from 206 to 207 --5<br>added from 207 to 208 --4<br>add failed from 207 to 208 --5<br>add failed from 207 to 208 --6<br>added from 208 to 209 --6<br>add failed from 208 to 209 --5<br>added from 209 to 210 --5<br>added from 210 to 211 --4<br>add failed from 210 to 211 --5<br>add failed from 210 to 211 --6<br>added from 211 to 212 --6<br>add failed from 211 to 212 --5<br>added from 212 to 213 --5<br>added from 213 to 214 --5<br>add failed from 213 to 214 --6<br>add failed from 213 to 214 --4<br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529146,"discussion_content":"当然存在并发安全问题，一定要通过相应手段进行保护，否则到了线上很可能会出问题（不同机器、不同配置、不同流量）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635248873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314125,"user_name":"Geek_74baaf","can_delete":false,"product_type":"c1","uid":2730544,"ip_address":"","ucode":"C881699AAF8D0E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er3buhru0LAs0WQZh9vdDk8P6duwdEIxvTwLTviasadOcP5nlKOjKlKJicNV2QHa9qSIxwUQoYhhYBg/132","comment_is_top":false,"comment_ctime":1632867137,"is_pvip":false,"replies":[{"id":"113788","content":"这两个很简单，我简单说一下你就明白了。<br><br>你可以想象一下，每个Go程序中都有一棵 context 树，而 Background 就是这棵树的根。你可以用 WithXXX 函数基于 Background 延伸出树枝和叶子，甚至构建出属于自己程序的子树（或者说支干）。要是没有 Background，你自己构建的 context 就没地方着落了（没有树根哪来的树干和枝叶？）。<br><br>TODO 的话，你可以把它想象成一个占位符。如果你决定要在某个地方使用 context，但是还没想好怎么用，那么就可以先用 TODO。比如，把它传给某个需要 context 的函数，或者把它赋给某个结构体的 Context 类型的字段，等等。由于 TODO() 函数返回的也是 Context 类型值，所以之后做替换的时候并不用更改函数参数等的类型。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1632885993,"ip_address":"","comment_id":314125,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632867137","product_id":100013101,"comment_content":"老师，能请问一下backGround和TODO两种类型的具体又什么区别吗，如果方便的话，可不可以麻烦您举个小例子说明一下，看文档实在看的一愣一愣的","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527577,"discussion_content":"这两个很简单，我简单说一下你就明白了。\n\n你可以想象一下，每个Go程序中都有一棵 context 树，而 Background 就是这棵树的根。你可以用 WithXXX 函数基于 Background 延伸出树枝和叶子，甚至构建出属于自己程序的子树（或者说支干）。要是没有 Background，你自己构建的 context 就没地方着落了（没有树根哪来的树干和枝叶？）。\n\nTODO 的话，你可以把它想象成一个占位符。如果你决定要在某个地方使用 context，但是还没想好怎么用，那么就可以先用 TODO。比如，把它传给某个需要 context 的函数，或者把它赋给某个结构体的 Context 类型的字段，等等。由于 TODO() 函数返回的也是 Context 类型值，所以之后做替换的时候并不用更改函数参数等的类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632885993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300800,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1625391612,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625391612","product_id":100013101,"comment_content":"只知道context 在写代码的时候整个调用链每个方法我们都当做参数传了。有时候会用context来放一些本服务的一些全局信息。如服务名、一些特征值、服务库参数等。","like_count":0},{"had_liked":false,"id":292806,"user_name":"moonfox","can_delete":false,"product_type":"c1","uid":1526355,"ip_address":"","ucode":"902BFF40EFA9FA","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","comment_is_top":false,"comment_ctime":1620985541,"is_pvip":false,"replies":[{"id":"106007","content":"是的，源码前无秘密。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1620990318,"ip_address":"","comment_id":292806,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1620985541","product_id":100013101,"comment_content":"建议打开源码文件，一边阅读，一边看源码文件，利于理解","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519963,"discussion_content":"是的，源码前无秘密。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620990318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230574,"user_name":"www","can_delete":false,"product_type":"c1","uid":1898338,"ip_address":"","ucode":"ADC9BC655EA16C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f7/62/947004d0.jpg","comment_is_top":false,"comment_ctime":1593421738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593421738","product_id":100013101,"comment_content":"看到demo68代码中，cancelFunc直接在go程里，又想起了函数是第一公民","like_count":0},{"had_liked":false,"id":205960,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1586763773,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586763773","product_id":100013101,"comment_content":"看了一下画的树  我觉得应该是广度优先的  因为广度优先遍历层数是小于等于深度优先的","like_count":0,"discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389621,"discussion_content":"很遗憾，错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629360550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166894,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1577626875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577626875","product_id":100013101,"comment_content":"用文字将技术知识表达清晰是一件很不容易的事，我接触过一点WithCancel的用法，边看老师的文章边动手实践一下WithTimeout和WithDeadline这两个和WithCancel相关的Context函数，感觉阐述得很清晰。但是WithValue完全没用过，确实看起来就不太明白，但是敲一遍demo69以后再看老师的讲述就很清楚了。","like_count":0},{"had_liked":false,"id":156148,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1574824748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574824748","product_id":100013101,"comment_content":"对着源码进行二刷","like_count":0},{"had_liked":false,"id":110148,"user_name":"后端进阶","can_delete":false,"product_type":"c1","uid":1125656,"ip_address":"","ucode":"480F48F5378307","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/18/918eaecf.jpg","comment_is_top":false,"comment_ctime":1562201822,"is_pvip":false,"replies":[{"id":"40036","content":"如果我没记错的话，还是不一样的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1562238961,"ip_address":"","comment_id":110148,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562201822","product_id":100013101,"comment_content":"context包其实相当于Java的同步工具类，比如cancelFunc其实就是一个countDownLatch","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456744,"discussion_content":"如果我没记错的话，还是不一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562238961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107562,"user_name":"糊李糊涂","can_delete":false,"product_type":"c1","uid":1197625,"ip_address":"","ucode":"E0F6064CBA32B1","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/39/e545c885.jpg","comment_is_top":false,"comment_ctime":1561557756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561557756","product_id":100013101,"comment_content":"mark","like_count":0},{"had_liked":false,"id":103457,"user_name":"benying","can_delete":false,"product_type":"c1","uid":1247522,"ip_address":"","ucode":"DEBAB485F381CC","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/22/22c0c4fa.jpg","comment_is_top":false,"comment_ctime":1560439651,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1560439651","product_id":100013101,"comment_content":"打卡,谢谢","like_count":0},{"had_liked":false,"id":86579,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1168220,"ip_address":"","ucode":"DF08B67EAD61E7","user_header":"https://static001.geekbang.org/account/avatar/00/11/d3/5c/796962de.jpg","comment_is_top":false,"comment_ctime":1555402950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555402950","product_id":100013101,"comment_content":"能讲得通俗一点就好了，感觉被带沟里转了好久出不来了","like_count":0},{"had_liked":false,"id":42959,"user_name":"ofuxas3","can_delete":false,"product_type":"c1","uid":1231626,"ip_address":"","ucode":"13934EB7B5092C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/HjzM5h6pLub9UG85tIQa8oVlKJTROYx4nM3VTUW14xBVQ2PeibwmoALmfQqmt0zbqpgVh5iagTCicEicUB4mLjWveA/132","comment_is_top":false,"comment_ctime":1543119377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543119377","product_id":100013101,"comment_content":"更具体地说，Context类型可以提供一类代表上下文的值。此... <br>后面应该是 goruntime 拼错了","like_count":0},{"had_liked":false,"id":35081,"user_name":"torwang","can_delete":false,"product_type":"c1","uid":1254218,"ip_address":"","ucode":"C91223AEC0C69F","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/4a/603a4e4b.jpg","comment_is_top":false,"comment_ctime":1540396808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540396808","product_id":100013101,"comment_content":"递归深度吧  思考题 有哪些实际应用场景","like_count":0},{"had_liked":false,"id":35080,"user_name":"torwang","can_delete":false,"product_type":"c1","uid":1254218,"ip_address":"","ucode":"C91223AEC0C69F","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/4a/603a4e4b.jpg","comment_is_top":false,"comment_ctime":1540396744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540396744","product_id":100013101,"comment_content":"递归深度吧   思考题  有哪些实际应用场景","like_count":0}]}