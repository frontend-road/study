{"id":727216,"title":"加餐｜尝鲜Gateway API：更强大、更灵活、面向未来的Ingress","content":"<p>你好，我是Chrono。</p><p>距离《Kubernetes入门实战课》完结已经有一段时间了，不知道你是否还在持续地学习、实践这个云原生时代的操作系统呢？我想答案应该是肯定的吧。</p><p>这次我带来了一个关于Kubernetes的最新消息，长期以来被关注的“下一代” Ingress 对象：Gateway API，在经过了近4年的讨论、测试和验证之后，终于在2023年的11月正式发布，可以用于生产环境，也就是我们常说的GA（generally available）。</p><p>那么，什么是Gateway API呢？它与Ingress有什么样的联系和区别呢？我们应该怎样在Kubernetes里部署和使用它呢？</p><p>今天我就来深入探讨这个话题，来看看Kubernetes的最新进展。</p><h2>什么是 Gateway API</h2><p>我们在<a href=\"https://time.geekbang.org/column/article/538760\">第21讲</a>对Ingress做过详细的介绍，相信你已经对它很熟悉了，它管理集群的进出口流量，提供完善的负载均衡和反向代理功能，<strong>是部署Kubernetes应用必不可缺的组件</strong>。</p><p>但是，Ingress的缺点也很明显，它自身的能力较弱，只能编写有限的路由规则，不能完全满足各种实际需求，所以Ingress Controller的实现者（如NGINX Ingress Controller、Kong Ingress Controller等）不得不使用大量的annotation和CRD来定制、扩展功能。</p><!-- [[[read_end]]] --><p>这种实现混乱的局面被戏称为 “annotations wild west”，对Kubernetes用户非常不友好，同一个功能在不同的Ingress Controller之间用法差异极大，迁移的成本非常高，没有统一的标准导致Ingress使用起来相当麻烦。</p><p>有鉴于此，Kubernetes社区就打算参考Ingress，重新设计一组对象来解决这些问题。于是在2019年末圣地亚哥的KubeCon上，许多不同背景的人们发起了一个新的项目，也就是Gateway API，<strong>目标是全面替代和超越Ingress，更好地管理Kubernetes里各方向的流量</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/c0/cd8bd1ee97087c357760239yyc02a2c0.png?wh=900x250\" alt=\"\" title=\"图片来源：https://kubernetes.io/blog/2023/10/31/gateway-api-ga/gateway-api-logo.png\"></p><p>在随后的几年，陆续有一些公司加入了Gateway API项目，因为有Ingress的“前车之鉴”，Gateway API一开始就具备了良好的架构，避免了Ingress所踩过的“坑”，所以它的进展还是比较顺利的。</p><p>下图来自Kubernetes的官方统计数据，显示了在这个过程中各个公司的<strong>贡献程度</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/20/c7/20e0aeaab81b9a4a5ab0451fa52206c7.png?wh=2802x1448\" alt=\"\"></p><p>在2023年11月发布的1.0版本里包括3个已经成熟稳定的对象，Gateway Class、Gateway和HTTPRoute（相关的<a href=\"https://kubernetes.io/blog/2023/10/31/gateway-api-ga/\">博客</a>在这里）。</p><p>在Gateway API项目的<a href=\"https://gateway-api.sigs.k8s.io/\">主页</a>上，对这3个重要的对象有简单的介绍。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/26/bcfb81598c01a23f28745b9b00a19d26.png?wh=2414x1418\" alt=\"\" title=\"图片来源：https://gateway-api.sigs.k8s.io/images/api-model.png\"></p><p>由于Gateway API是Ingress的后继者，所以我们可以对比Ingress来理解它们的概念和作用。</p><p>最上层的Gateway Class类似于Ingress Class，由各个云厂商提供；中间的Gateway类似于Ingress Controller，由集群管理员管理；下面的HTTPRoute类似于Ingress，由开发人员管理，定义路由规则，规定流量将如何被Gateway分发到集群里的Service和Pod。</p><p>可以看到，Gateway API的结构非常清晰明了，很容易理解。</p><p>在Gateway API正式发布时（11月1日），大部分厂商还没有提供完整支持，基本都是预览版或测试版，但也有两家公司几乎同步实现了GA，这就是GKE（Google Kubernetes Engine）和Kong，所以下面我就以Kong为例，来介绍Gateway API的用法。</p><h2>安装 Gateway API</h2><p>首先要说的是，Gateway API只支持较新的Kubernetes，不能运行在Kubernetes 1.23上，为了体验Gateway API，我们最好使用最新版本的Kubernetes。</p><p>这里我选用了minikube 1.32.0，Kubernetes是1.28.3，你可以参考<a href=\"https://time.geekbang.org/column/article/529780\">第9讲</a>的内容来安装，或者直接用下面的命令。</p><pre><code class=\"language-plain\"># Intel x86_64\ncurl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\n\n# Apple arm64\ncurl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-arm64\n\nsudo install minikube /usr/local/bin/\n\nminikube start --kubernetes-version=v1.28.3\nkubectl version\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/fd/d3/fd97a8d12705951a840ceff5421214d3.png?wh=1620x1438\" alt=\"图片\"></p><p>有了合适的Kubernetes环境，下面就来部署Gateway API。</p><p>要注意的是Gateway API比较特殊，并不是集成在Kubernetes内部，而是在外部以相对独立的方式开发实现的，所以需要用YAML文件的形式来部署进Kubernetes。</p><p>你可以在<a href=\"https://gateway-api.sigs.k8s.io/guides/\">Gateway API项目网站</a>里找到安装命令，很简单，用 <code>kubectl apply</code> 就能够搞定。</p><pre><code class=\"language-plain\">wget https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml\nkubectl apply -f standard-install.yaml\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/24/e0/2449fd1d96136aaae9d7b5b6d7996be0.png?wh=1920x232\" alt=\"图片\"></p><p>安装完成后，可以用 <code>kubectl api-resources</code> 命令来查看新的Gateway API对象。</p><pre><code class=\"language-plain\">kubectl api-resources | grep gateway\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/ec/yc/ec938c5b47edfff23a38f1e17126dyyc.png?wh=1920x197\" alt=\"图片\"></p><p>这就证明Gateway API已经成功安装到了当前的Kubernetes集群里，而且你还应该注意到Gateway Class的缩写是 “gc”，Gateway的缩写是 “gtw”。</p><p>现在用YAML创建实验用的Gateway Class和Gateway对象，但目前它们还不能使用 <code>kubectl create</code> 生成样板，只能手动编写。</p><pre><code class=\"language-plain\">apiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n&nbsp; name: kong-gc\n&nbsp; annotations:\n&nbsp; &nbsp; konghq.com/gatewayclass-unmanaged: 'true'\n\nspec:\n&nbsp; controllerName: konghq.com/kic-gateway-controller\n\n---\n\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n&nbsp; name: kong-gtw\nspec:\n&nbsp; gatewayClassName: kong-gc\n&nbsp; listeners:\n&nbsp; - name: proxy\n&nbsp; &nbsp; port: 80\n&nbsp; &nbsp; protocol: HTTP\n</code></pre><p>这个YAML定义了一个叫 kong-gc 的Gateway Class对象，指定使用的Controller是 konghq.com/kic-gateway-controller。然后Gateway对象的名字是 kong-gtw，它关联了 kong-gc，在80端口上处理HTTP协议。</p><p><code>kubectl apply</code> 后再用 <code>kubectl get</code> 命令，会看到它们已经创建成功。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/55/6b54ecccbf830d9482e0f99e993bc855.png?wh=1586x360\" alt=\"图片\"></p><h2>安装 Kong Ingress Controller</h2><p>刚才部署好了Kubernetes环境和Gateway API，现在就可以安装Kong Gateway，它的实现仍然是以Ingress Controller的形式，也就是Kong Ingress Controller，在之前的<a href=\"https://time.geekbang.org/column/article/612952\">加餐</a>中我也对它做过详细的介绍。</p><p>不过那个时候使用的Kong Ingress Controller还是2.7.0，而现在它已经升级到了3.0.0，里里外外都发生了很多变化，完全是一个新的应用。</p><p>Kong Ingress Controller 2.x 可以使用YAML文件直接安装，但3.0.0已经废弃了这种方式，只能够使用Helm或Operator来安装，这里我选用的是Helm。</p><p>你也许不太熟悉Helm，我来简单介绍一下。它类似于Linux里的yum、apt，对复杂的云原生应用非常有用，可以把众多的YAML文件组合成安装包的形式，再轻松地把应用部署进Kubernetes集群。但由于它不是我们今天的重点，所以就不多说了。</p><p>Helm的安装很简单，它提供了一个<a href=\"https://helm.sh/docs/intro/install/\">官方脚本</a>，直接执行即可。</p><pre><code class=\"language-plain\">curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/2d/86/2d1cc05530497261db10e30bdca79486.png?wh=1920x155\" alt=\"图片\"></p><p>然后我们需要添加远端仓库（Helm charts），用法和yum、apt也很类似。</p><pre><code class=\"language-plain\">helm repo add kong https://charts.konghq.com\nhelm repo update\n</code></pre><p>之后可以查看远端仓库里可用的安装包。</p><pre><code class=\"language-plain\">helm repo list\nhelm search repo kong\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/72/1a/721064f98d17534d58d5b05b298a771a.png?wh=1920x325\" alt=\"图片\"></p><p>这里显示的 kong/ingress 就是Kong Ingress Controller。</p><p>使用命令 <code>helm install</code> 指定名字和安装包，再加上一些定制参数就可以安装Kong Ingress Controller。</p><pre><code class=\"language-plain\">helm install \\\n&nbsp; &nbsp; kong kong/ingress \\\n&nbsp; &nbsp; -n kong \\\n&nbsp; &nbsp; --create-namespace \\\n&nbsp; &nbsp; --set gateway.env.router_flavor=expressions\n</code></pre><p>这里我多加了一个 “–set” 选项，启用Kong Ingress Controller的表达式路由，能够更好地支持Gateway API。</p><p>Kong Ingress Controller默认安装在kong名字空间，用 <code>kubectl get</code> 就可以看到它的Pod、Service等对象。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/7c/501c7cef1dyy43c351e7424c29609d7c.png?wh=1920x403\" alt=\"图片\"></p><p>要注意的是kong-gateway-proxy这个Service，它的类型是LoadBalancer，也就是对外的服务接口，在实验环境里使用的端口是 31198，后续我们要使用这个端口来测试。</p><p>使用 <code>curl</code> 访问这个服务可以验证Kong Ingress Controller是否正常工作。</p><pre><code class=\"language-plain\">curl -i $(minikube ip):31198\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/71/47/7104ccb33e4e936d20e80b544e4a5d47.png?wh=1270x726\" alt=\"图片\"></p><p><code>curl</code> 命令的输出是404，这是因为我们还没有配置HTTPRoute资源，没有路由规则，所以Gateway无法处理流量。</p><p>这时再检查Gateway Class和Gateway对象，会看到 ACCEPTED 和 PROGRAMMED 字段都已经变成了 True，这就表示Gateway对象已经正确关联了Kong Ingress Controller。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/0f/5c63c241286b27690591afbab3dfa30f.png?wh=1590x366\" alt=\"图片\"></p><h2>准备后端服务</h2><p>为了验证Gateway API的流量管理效果，我们还要创建测试用的后端服务，具体做法可以参考<a href=\"https://time.geekbang.org/column/article/536829\">第20讲</a>和<a href=\"https://time.geekbang.org/column/article/538760\">第21讲</a>，部署NGINX来输出简单的字符串。</p><p>下面的这个YAML是一个样板文件，你可以使用查找替换的方式生成多个不同名字的服务。</p><pre><code class=\"language-plain\">apiVersion: v1\nkind: ConfigMap\nmetadata:\n&nbsp; name: ngx-conf\n\ndata:\n&nbsp; default.conf: |\n&nbsp; &nbsp; server {\n&nbsp; &nbsp; &nbsp; listen 80;\n&nbsp; &nbsp; &nbsp; location / {\n&nbsp; &nbsp; &nbsp; &nbsp; default_type text/plain;\n&nbsp; &nbsp; &nbsp; &nbsp; return 200\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'ngx\\nsrv : $server_addr:$server_port\\nhost: $hostname\\nuri : $request_method $host $request_uri\\n';\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n---\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n&nbsp; name: ngx-dep\n&nbsp; labels:\n&nbsp; &nbsp; app: ngx-dep\n\nspec:\n&nbsp; replicas: 1\n&nbsp; selector:\n&nbsp; &nbsp; matchLabels:\n&nbsp; &nbsp; &nbsp; app: ngx-dep\n\n&nbsp; template:\n&nbsp; &nbsp; metadata:\n&nbsp; &nbsp; &nbsp; labels:\n&nbsp; &nbsp; &nbsp; &nbsp; app: ngx-dep\n&nbsp; &nbsp; spec:\n&nbsp; &nbsp; &nbsp; volumes:\n&nbsp; &nbsp; &nbsp; - name: ngx-conf-vol\n&nbsp; &nbsp; &nbsp; &nbsp; configMap:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: ngx-conf\n\n&nbsp; &nbsp; &nbsp; containers:\n&nbsp; &nbsp; &nbsp; - image: nginx:alpine\n&nbsp; &nbsp; &nbsp; &nbsp; name: nginx\n&nbsp; &nbsp; &nbsp; &nbsp; ports:\n&nbsp; &nbsp; &nbsp; &nbsp; - containerPort: 80\n\n&nbsp; &nbsp; &nbsp; &nbsp; volumeMounts:\n&nbsp; &nbsp; &nbsp; &nbsp; - mountPath: /etc/nginx/conf.d\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: ngx-conf-vol\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n&nbsp; name: ngx-svc\n\nspec:\n&nbsp; selector:\n&nbsp; &nbsp; app: ngx-dep\n\n&nbsp; ports:\n&nbsp; - port: 80\n&nbsp; &nbsp; protocol: TCP\n&nbsp; &nbsp; targetPort: 80\n</code></pre><p>比如使用 <code>sed</code> 命令，就可以快速得到 “red-svc”“green-svc”“bule-svc”“black-svc” 等4个Service。</p><pre><code class=\"language-plain\">sed 's/ngx/red/g'&nbsp; &nbsp;backend.yml | kubectl apply -f -\nsed 's/ngx/green/g' backend.yml | kubectl apply -f -\nsed 's/ngx/blue/g'&nbsp; backend.yml | kubectl apply -f -\nsed 's/ngx/black/g' backend.yml | kubectl apply -f -\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/ae/1d/ae54615a90c3e32b9cee98bdc61abe1d.png?wh=1054x426\" alt=\"图片\"></p><h2>使用 Gateway API</h2><p>完成以上的准备工作，下面就要开始实际使用Gateway API了。</p><p>让我们先从最简单的路由开始，只使用域名规则，创建一个HTTPRoute对象。</p><pre><code class=\"language-plain\">apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n&nbsp; name: ngx-host-route\nspec:\n&nbsp; parentRefs:\n&nbsp; - name: kong-gtw\n&nbsp; hostnames:\n&nbsp; - \"gtw.test\"\n&nbsp; rules:\n&nbsp; - backendRefs:\n&nbsp; &nbsp; - name: red-svc\n&nbsp; &nbsp; &nbsp; port: 80\n</code></pre><p>HTTPRoute对象和Ingress很相似，但要简洁一些，具体的内部字段含义和用法可以参考文档或者使用 <code>kubectl explain</code>，我就不浪费时间细解释了。</p><p>这里使用 <code>parentRefs</code> 指定了路由使用的Gateway对象，用 <code>hostnames</code> 指定一个或多个域名，用 <code>backendRefs</code> 指定后端Service。合起来看，就是要求Gateway把域名 gtw.test 的流量都转发到 red-svc。</p><p><code>kubectl apply</code> 创建这个路由对象后，可以用 <code>curl</code> 向 kong-gateway-proxy 发送请求来验证。</p><pre><code class=\"language-plain\">curl -i $(minikube ip):31198 -H 'host: gtw.test'\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/a6/74/a6866b7fafff761be9b3bc2a0386ae74.png?wh=1474x904\" alt=\"图片\"></p><p>从截图里可以看到，因为我们指定了域名 gtw.test，匹配了路由规则，所以Gateway就把请求转发给了red-svc。</p><p>然后我们再来编写两个路由规则，分别使用路径匹配和头字段匹配，转发到green-svc和blue-svc。</p><pre><code class=\"language-plain\">apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n&nbsp; name: ngx-path-route\nspec:\n&nbsp; parentRefs:\n&nbsp; - name: kong-gtw\n&nbsp; hostnames:\n&nbsp; - \"gtw.ops\"\n\n&nbsp; rules:\n&nbsp; - matches:\n&nbsp; &nbsp; - path:\n&nbsp; &nbsp; &nbsp; &nbsp; type: PathPrefix\n&nbsp; &nbsp; &nbsp; &nbsp; value: /hello\n&nbsp; &nbsp; backendRefs:\n&nbsp; &nbsp; - name: green-svc\n&nbsp; &nbsp; &nbsp; port: 80\n\n---\n\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n&nbsp; name: ngx-header-route\nspec:\n&nbsp; parentRefs:\n&nbsp; - name: kong-gtw\n&nbsp; hostnames:\n&nbsp; - \"gtw.dev\"\n\n&nbsp; rules:\n&nbsp; - matches:\n&nbsp; &nbsp; - headers:\n&nbsp; &nbsp; &nbsp; - type: Exact\n&nbsp; &nbsp; &nbsp; &nbsp; name: area\n&nbsp; &nbsp; &nbsp; &nbsp; value: north\n&nbsp; &nbsp; backendRefs:\n&nbsp; &nbsp; - name: blue-svc\n&nbsp; &nbsp; &nbsp; port: 80\n</code></pre><p>和第一个路由相比，它们多了 <code>matches</code> 字段，可以在里面详细指定或组合各种匹配条件，支持精确匹配、前缀匹配、正则匹配等等。</p><p>使用 <code>curl</code> 测试的效果如图：</p><pre><code class=\"language-plain\">curl -i $(minikube ip):31198/hello -H 'host: gtw.ops'\ncurl -i $(minikube ip):31198 -H 'host: gtw.dev' -H 'area: north'\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/16/6a/161bc93c0a8cc931ac61916f9c34d56a.png?wh=1602x900\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/67/9e/678326c131b61a15be63669586b8209e.png?wh=1886x898\" alt=\"图片\"></p><p>Gateway API不仅支持路由转发，它还能够轻松实现流量拆分，比如常见的金丝雀部署和蓝绿部署，只需要调整 <code>backendRefs</code> 字段即可。</p><p>这个YAML定义了两个HTTPRoute。</p><pre><code class=\"language-plain\">apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n&nbsp; name: ngx-canary-route\nspec:\n&nbsp; parentRefs:\n&nbsp; - name: kong-gtw\n&nbsp; hostnames:\n&nbsp; - \"canary.test\"\n\n&nbsp; rules:\n\n&nbsp; - backendRefs:\n&nbsp; &nbsp; - name: blue-svc\n&nbsp; &nbsp; &nbsp; port: 80\n\n&nbsp; - matches:\n&nbsp; &nbsp; - headers:\n&nbsp; &nbsp; &nbsp; - name: traffic\n&nbsp; &nbsp; &nbsp; &nbsp; value: canary\n&nbsp; &nbsp; - path:\n&nbsp; &nbsp; &nbsp; &nbsp; type: Exact\n&nbsp; &nbsp; &nbsp; &nbsp; value: /login\n&nbsp; &nbsp; backendRefs:\n&nbsp; &nbsp; - name: green-svc\n&nbsp; &nbsp; &nbsp; port: 80\n\n---\n\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n&nbsp; name: ngx-blue-green-route\nspec:\n&nbsp; parentRefs:\n&nbsp; - name: kong-gtw\n&nbsp; hostnames:\n&nbsp; - \"blue-green.test\"\n&nbsp; rules:\n\n&nbsp; - backendRefs:\n\n&nbsp; &nbsp; - name: blue-svc\n&nbsp; &nbsp; &nbsp; port: 80\n&nbsp; &nbsp; &nbsp; weight: 70\n\n&nbsp; &nbsp; - name: green-svc\n&nbsp; &nbsp; &nbsp; port: 80\n&nbsp; &nbsp; &nbsp; weight: 30\n</code></pre><p><code>ngx-canary-route</code> 里有两条规则，默认的后端服务是blue-svc，另一个加了匹配条件，只有访问特定的地址、使用特定的头字段才会转到后端服务green-svc。</p><p><code>ngx-blue-green-route</code> 里也是两个后端服务，blue-svc和green-svc，但使用 weight 字段指定了不同的权重，这样在部署的时候就可以随意调节流量比例。</p><p>最后我们再来看一下Gateway API的filter特性，它可以对应到Kong Gateway的插件机制，实现对流量的附加处理，比如速率限制、改写数据、身份验证等等，不过目前标准的filter还不多，所以有的时候还是要依赖CRD资源定义Plugin。</p><p>下面的YAML添加了响应头和限速，其实这两个功能已经在之前讲Kong Ingress Controller的加餐里介绍过了，但现在改成了Gateway API，你可以对比看一下两者的区别。</p><pre><code class=\"language-plain\">apiVersion: configuration.konghq.com/v1\nkind: KongPlugin\nmetadata:\n&nbsp; name: kong-rate-limiting-plugin\n\nplugin: rate-limiting\nconfig:\n&nbsp; minute: 2\n\n---\n\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n&nbsp; name: ngx-filter-route\n\n&nbsp; annotations:\n&nbsp; &nbsp; konghq.com/plugins: |\n&nbsp; &nbsp; &nbsp; &nbsp; kong-rate-limiting-plugin\n\nspec:\n&nbsp; parentRefs:\n&nbsp; - name: kong-gtw\n&nbsp; hostnames:\n&nbsp; - \"filter.test\"\n\n&nbsp; rules:\n\n&nbsp; - backendRefs:\n&nbsp; &nbsp; - name: black-svc\n&nbsp; &nbsp; &nbsp; port: 80\n\n&nbsp; &nbsp; filters:\n&nbsp; &nbsp; - type: ResponseHeaderModifier\n&nbsp; &nbsp; &nbsp; responseHeaderModifier:\n&nbsp; &nbsp; &nbsp; &nbsp; add:\n&nbsp; &nbsp; &nbsp; &nbsp; - name: A-New-Header\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: k8s-gtw-api\n</code></pre><p>同样的，发送 <code>curl</code> 请求，就可以看到新增加的响应头和限速信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/91/07/9113b394a6284757faed5a98ecde8407.png?wh=1522x1144\" alt=\"图片\"></p><h2>小结</h2><p>好了，今天我介绍了Kubernetes的最新成果：Gateway API，它是Ingress的继任者，功能更强大、用法更灵活，也是Kubernetes社区今后的重点发展方向，值得我们投入精力去研究。</p><p><strong>简单小结一下今天的内容要点：</strong></p><ol>\n<li>Gateway API已经正式生产可用，目前包括3个成熟的对象，分别是Gateway Class、Gateway和HTTPRoute。</li>\n<li>Gateway API只能运行在较新版本的Kubernetes上，而且不内置在Kubernetes里，需要使用YAML额外安装。</li>\n<li>大多数厂商都在某种程度上支持Gateway API，但只有少数达到了GA程度，这里使用的是Kong Ingress Controller。</li>\n<li>使用Gateway API可以任意配置各种路由规则，如域名、路径、头字段、查询参数、流量权重等，功能非常丰富。</li>\n<li>Gateway API还支持filter功能，可以对流量做各种处理，但功能不如路由那么多。</li>\n</ol><p>另外再提醒一下，你可以在专栏的<a href=\"https://github.com/chronolaw/k8s_study\">GitHub 项目</a>里找到这节课的全部代码，还有更多的示例。</p><p>期待你的学习分享，我们留言区见！</p><p><img src=\"https://static001.geekbang.org/resource/image/60/99/60d040daa2268f53df1d1c62386daf99.jpg?wh=1920x2635\" alt=\"\"></p>","neighbors":{"left":{"article_title":"加餐｜谈谈Kong Ingress Controller","id":612952},"right":[]},"comments":[{"had_liked":false,"id":389542,"user_name":"Geek_07ead6","can_delete":false,"product_type":"c1","uid":1714992,"ip_address":"广东","ucode":"424137ADA9AA23","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoREZlw6JWh1OXYvcKhOToBPCSqVr33Vhc0gmW9jNT3JHtW7NtaiaiaNJicjjxyVia7Oec3Qq1bzLGreQ/132","comment_is_top":false,"comment_ctime":1712807979,"is_pvip":false,"replies":[{"id":141725,"content":"现在的gateway api一般都是在Ingress controller里实现的，关系图可以参考之前pod那讲，里面有。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1712885197,"ip_address":"北京","comment_id":389542,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"老师，不是说Gateway Class、Gateway 和 HTTPRoute是代替原来的ingress、ingressclass、ingressController这三个东西的吗？为啥上面又多了kong ingress controller的部署，kong ingress controller不只是原来ingressController的一个实现吗。没看懂新的里面GateWay和kong ingress controller的关系是啥，老师能加张图说一下Gateway Class、Gateway、HTTPRoute、kong ingress controller这四者的关系吗？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641682,"discussion_content":"现在的gateway api一般都是在Ingress controller里实现的，关系图可以参考之前pod那讲，里面有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712885197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394018,"user_name":"sgcls","can_delete":false,"product_type":"c1","uid":1255198,"ip_address":"广东","ucode":"F359E943BF6D14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erRCf8vWbWibajdSaMtCM1OzPQ6uPhblgL4zXJvKoaQYVmialqFqr0NIdD6Dlm1F5icOBxiaXvUcQs4BA/132","comment_is_top":false,"comment_ctime":1725556012,"is_pvip":false,"replies":[{"id":143072,"content":"good","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1725863359,"ip_address":"上海","comment_id":394018,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"Gateway API 与 Ingress 类似的功能模块映射：\nGateway --- Ingress Controller # 流量控制器\nGateway Class --- Ingress Class # 流量控制器类别\nHTTPRoute --- Ingress # 路由规则集\n\n这里 HTTPRoute 与 Ingress 的 Yaml 不同点：\nHTTPRoute 指定了 Controller（parentRefs.0.name -&gt; Gateway 对象），而\nIngress 指定的是 Controller Class （spec.ingressClassName -&gt; Ingress Class 对象）\n\n\n为什么这里会不一致呢？有种割裂感。\n是不是因为 Ingress Class 后面才引入的，所以在 Ingress 里明确设置 ingressClassName 指向 Ingress Class 以支持新特性呢..","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650913,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725863359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387405,"user_name":"六月","can_delete":false,"product_type":"c1","uid":1800818,"ip_address":"广东","ucode":"D94CD05F648A7B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/72/a86c521e.jpg","comment_is_top":false,"comment_ctime":1707201779,"is_pvip":false,"replies":[{"id":141271,"content":"需要较新的版本才能用gateway API。","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1708848090,"ip_address":"北京","comment_id":387405,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"看完本章马上去试了一下😂发现我的集群是1.23.17版本的。。。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637709,"discussion_content":"需要较新的版本才能用gateway API。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708848090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384760,"user_name":"Geek_768d90","can_delete":false,"product_type":"c1","uid":2541626,"ip_address":"新疆","ucode":"A9966695909456","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erLkXxEDm9ib2rtlHbVVO4qlFBWp5AArFpPctzSE0zkiaMiaol1IHVJ35ECC2goY5ibSufFPLp6dOzNmg/132","comment_is_top":false,"comment_ctime":1701477697,"is_pvip":false,"replies":[{"id":140314,"content":"great","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1701727550,"ip_address":"海南","comment_id":384760,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"感谢老师的坚持与付出！我认为学习K8S本身也要遵循CI&#47;CD：不断学习新知识，集成进自己的大脑；不断地在现网中实践，提供更加优化的交付方案。\n我坚信这门课在极客时间一定会是一门精品课！","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632982,"discussion_content":"great","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701727550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"海南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384740,"user_name":"Geek_479239","can_delete":false,"product_type":"c1","uid":2660515,"ip_address":"北京","ucode":"E7BF2AEEAA7F87","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/9LFicnceEOlv9eNwJqjRDHbX87iaJectWs9ibgRLs8jTsDZDsvnTzUI8J1YJ1CiaNWzXiaTnkjscz4gR0wcvw3JfasoO0rg9FliaDsK8FqTQmHyNE/132","comment_is_top":false,"comment_ctime":1701420735,"is_pvip":false,"replies":[{"id":140313,"content":"good","user_name":"作者回复","user_name_real":"编辑","uid":1181974,"ctime":1701727506,"ip_address":"海南","comment_id":384740,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100114501,"comment_content":"居然读到了最新的文章，新公司在用k8s开发，正好学习实战下","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632981,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701727506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"海南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}