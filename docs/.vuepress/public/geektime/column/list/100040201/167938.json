{"id":167938,"title":"02丨数据结构原理：Hash表的时间复杂度为什么是O(1)？","content":"<p>大概十年前，我在阿里巴巴工作的时候，曾经和另一个面试官一起进行一场技术面试，面试过程中我问了一个问题：<strong>Hash表的时间复杂度为什么是O(1)</strong>？候选人没有回答上来。面试结束后我和另一个面试官有了分歧，我觉得这个问题没有回答上来是不可接受的。而他则觉得，这个问题有一点难度，回答不上来不说明什么。</p><p>因为有了这次争执，后来这个问题成了我面试时的必考题。此后十年间，我用这个问题面试了大约上千人，这些面试经历让我更加坚定了一个想法：这个问题就是候选人技术水平的一个分水岭，是证明一个技术人员是否具有必备专业技能和技术悟性的一个门槛。这个槛过不去是不可接受的。</p><p>为什么呢？我很难相信，如果基本的数据结构没有掌握好，如何能开发好一个稍微复杂一点的程序？</p><p>要了解Hash表，需要先从数组说起。</p><h2>数组</h2><p>数组是最常用的数据结构，创建数组必须要内存中一块<strong>连续</strong>的空间，并且数组中必须存放<strong>相同</strong>的数据类型。比如我们创建一个长度为10，数据类型为整型的数组，在内存中的地址是从1000开始，那么它在内存中的存储格式如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/71/c98f1f08afacdb9754e6d18c1d7e0471.png?wh=600*860\" alt=\"\"><br>\n由于每个整型数据占据4个字节的内存空间，因此整个数组的内存空间地址是1000～1039，根据这个，我们就可以轻易算出数组中每个数据的内存下标地址。利用这个特性，我们只要知道了数组下标，也就是数据在数组中的位置，比如下标2，就可以计算得到这个数据在内存中的位置1008，从而对这个位置的数据241进行快速读写访问，时间复杂度为O(1)。</p><!-- [[[read_end]]] --><p>随机快速读写是数组的一个重要特性，但是要随机访问数据，必须知道数据在数组中的下标。如果我们只是知道数据的值，想要在数组中找到这个值，那么就只能遍历整个数组，时间复杂度为O(N)。</p><h2>链表</h2><p>不同于数组必须要连续的内存空间，链表可以使用零散的内存空间存储数据。不过，因为链表在内存中的数据不是连续的，所以链表中的每个数据元素都必须包含一个指向下一个数据元素的内存地址指针。如下图，链表的每个元素包含两部分，一部分是数据，一部分是指向下一个元素的地址指针。最后一个元素指向null，表示链表到此为止。</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/e6/2f85f5f31b5985c46b02919aa4809fe6.png?wh=1122*150\" alt=\"\"><br>\n因为链表是不连续存储的，要想在链表中查找一个数据，只能遍历链表，所以链表的查找复杂度总是O(N)。</p><p>但是正因为链表是不连续存储的，所以在链表中插入或者删除一个数据是非常容易的，只要找到要插入（删除）的位置，修改链表指针就可以了。如图，想在b和c之间插入一个元素x，只需要将b指向c的指针修改为指向x，然后将x的指针指向c就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/04/01/0460a5fc12d7d5227f436a608684ea01.png?wh=688*218\" alt=\"\"><br>\n相比在链表中轻易插入、删除一个元素这种简单的操作，如果我们要想在数组中插入、删除一个数据，就会改变数组连续内存空间的大小，需要重新分配内存空间，这样要复杂得多。</p><h2>Hash表</h2><p>前面说过，对数组中的数据进行快速访问必须要通过数组的下标，时间复杂度为O(1)。如果只知道数据或者数据中的部分内容，想在数组中找到这个数据，还是需要遍历数组，时间复杂度为O(N)。</p><p>事实上，知道部分数据查找完整数据的需求在软件开发中会经常用到，比如知道了商品ID，想要查找完整的商品信息；知道了词条名称，想要查找百科词条中的详细信息等。</p><p>这类场景就需要用到Hash表这种数据结构。Hash表中数据以Key、Value的方式存储，上面例子中，商品ID和词条名称就是Key，商品信息和词条详细信息就是Value。存储的时候将Key、Value写入Hash表，读取的时候，只需要提供Key，就可以快速查找到Value。</p><p>Hash表的物理存储其实是一个数组，如果我们能够根据Key计算出数组下标，那么就可以快速在数组中查找到需要的Key和Value。许多编程语言支持获得任意对象的 HashCode，比如Java 语言中 HashCode 方法包含在根对象 Object 中，其返回值是一个 Int。我们可以利用这个Int类型的HashCode计算数组下标。最简单的方法就是余数法，使用 Hash 表的数组长度对 HashCode 求余， 余数即为 Hash 表数组的下标，使用这个下标就可以直接访问得到 Hash 表中存储的 Key、Value。</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/cb/e2d3191b087d902980595aeb1be79dcb.png?wh=1438*882\" alt=\"\"><br>\n上图这个例子中，Key是字符串abc，Value是字符串hello。我们先计算Key的哈希值，得到101这样一个整型值。然后用101对8取模，这个8是哈希表数组的长度。101对8取模余5，这个5就是数组的下标，这样就可以把(“abc”,“hello”)这样一个Key、Value值存储在下标为5的数组记录中。</p><p>当我们要读取数据的时候，只要给定Key abc，还是用这样一个算法过程，先求取它的HashCode 101，然后再对8取模，因为数组的长度不变，对8取模以后依然是余5，那么我们到数组下标中去找5的这个位置，就可以找到前面存储进去的abc对应的Value值。</p><p>但是如果不同的Key计算出来的数组下标相同怎么办？HashCode101对8取模余数是5，HashCode109对8取模余数还是5，也就是说，不同的Key有可能计算得到相同的数组下标，这就是所谓的Hash冲突，解决Hash冲突常用的方法是链表法。</p><p>事实上，(“abc”,“hello”)这样的Key、Value数据并不会直接存储在Hash表的数组中，因为数组要求存储固定数据类型，主要目的是每个数组元素中要存放固定长度的数据。所以，数组中存储的是Key、Value数据元素的地址指针。一旦发生Hash冲突，只需要将相同下标，不同Key的数据元素添加到这个链表就可以了。查找的时候再遍历这个链表，匹配正确的Key。</p><p>如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/9a/ea89bec385ebfe5c03b306deead03c9a.png?wh=780*448\" alt=\"\"><br>\n因为有Hash冲突的存在，所以“Hash表的时间复杂度为什么是O(1)？”这句话并不严谨，极端情况下，如果所有Key的数组下标都冲突，那么Hash表就退化为一条链表，查询的时间复杂度是O(N)。但是作为一个面试题，“Hash表的时间复杂度为什么是O(1)”是没有问题的。</p><h2>栈</h2><p>数组和链表都被称为线性表，因为里面的数据是按照线性组织存放的，每个数据元素的前面只能有一个（前驱）数据元素，后面也只能有一个（后继）数据元素，所以称为线性表。但是对数组和链表的操作可以是随机的，可以对其上任何元素进行操作，如果对操作方式加以限制，就形成了新的数据结构。</p><p>栈就是在线性表的基础上加了这样的操作限制条件：后面添加的数据，在删除的时候必须先删除，即通常所说的“后进先出”。我们可以把栈可以想象成一个大桶，往桶里面放食物，一层一层放进去，如果要吃的时候，必须从最上面一层吃，吃了几层后，再往里放食物，还是从当前的最上面一层放起。</p><p><img src=\"https://static001.geekbang.org/resource/image/85/81/85752adc1fc26453e2236f0a8b01c081.png?wh=640*592\" alt=\"\"><br>\n栈在线性表的基础上增加了操作限制，具体实现的时候，因为栈不需要随机访问、也不需要在中间添加、删除数据，所以可以用数组实现，也可以用链表实现。那么在顺序表的基础上增加操作限制有什么好处呢？</p><p>我们上篇提到的程序运行过程中，方法的调用需要用栈来管理每个方法的工作区，这样，不管方法如何嵌套调用，栈顶元素始终是当前正在执行的方法的工作区。这样，事情就简单了。而简单，正是我们做软件开发应该努力追求的一个目标。</p><h2>队列</h2><p>队列也是一种操作受限的线性表，栈是后进先出，而队列是先进先出。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/a5/a396ab50312b5faa29c7b93f6ad4b7a5.png?wh=1082*180\" alt=\"\"><br>\n在软件运行期，经常会遇到资源不足的情况：提交任务请求线程池执行，但是线程已经用完了，任务需要放入队列，先进先出排队执行；线程在运行中需要访问数据库，数据库连接有限，已经用完了，线程进入阻塞队列，当有数据库连接释放的时候，从阻塞队列头部唤醒一个线程，出队列获得连接访问数据库。</p><p>我在上面讲堆栈的时候，举了一个大桶放食物的例子，事实上，如果用这种方式存放食物，有可能最底下食物永远都吃不到，最后过期了。</p><p>现实中也是如此，超市在货架上摆放食品的时候，其实是按照队列摆放的，而不是堆栈摆放的。工作人员在上架新食品的时候，总是把新食品摆在后面，使食品成为一个队列，以便让以前上架的食品被尽快卖出。</p><h2>树</h2><p>数组、链表、栈、队列都是线性表，也就是每个数据元素都只有一个前驱，一个后继。而树则是非线性表，树是这样的。</p><p><img src=\"https://static001.geekbang.org/resource/image/88/cd/88906ad45504ae3d195dadc9b7a455cd.png?wh=972*590\" alt=\"\"><br>\n软件开发中，也有很多地方用到树，比如我们要开发一个OA系统，部门的组织结构就是一棵树；我们编写的程序在编译的时候，第一步就是将程序代码生成抽象语法树。传统上树的遍历使用递归的方式，而我个人更喜欢用设计模式中的组合模式进行树的遍历，具体我将会在设计模式部分详细讨论。</p><h2>小结</h2><p>这是一篇关于数据结构的专栏文章，面试中问数据结构是一个非常有意思的话题，很多拥有绚丽简历和多年工作经验的候选人在数据结构的问题上翻了船，这些人有时候会解释说，这些知识都是大学时学过的，工作这些年用不着，记不太清楚了。</p><p>事实上，我很难相信，如果这些基本数据结构没有掌握好，如何能开发好一个稍微复杂一点的程序。但欣慰的是，在这些年的面试过程中，我发现候选者中能够正确回答基本数据结构问题的比例越来越高了，我也越来越坚定用数据结构问题当做是否跨过专业工程师门槛的试金石。作为一个专业软件工程师，不管有多少年经验，说不清楚基础数据结构的工作原理是不能接受的。</p><h2>思考题</h2><p>链表结构虽然简单，但是各种组合变换操作却可以很复杂。关于链表的操作也是面试官最喜欢问的数据结构问题之一，我在面试过程中喜欢问的一个链表问题是：</p><p>有两个单向链表，这两个单向链表有可能在某个元素合并，如下图所示的这样，也可能不合并。现在给定两个链表的头指针，如何快速地判断这两个链表是否合并？如果合并，找到合并的元素，也就是图中的x元素。</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/4c/d77648b14382b8af1353bc6a5876ba4c.png?wh=1484*404\" alt=\"\"><br>\n关于这道题，你的答案是什么呢？</p><p>欢迎你在评论区写下你的思考，我会和你一起交流，也欢迎把这篇文章分享给你朋友或者同事，一起交流一下。</p>","neighbors":{"left":{"article_title":"01丨程序运行原理：程序是如何运行又是如何崩溃的？","id":166581},"right":{"article_title":"03丨Java虚拟机原理：JVM为什么被称为机器（machine）？","id":168945}},"comments":[{"had_liked":false,"id":153213,"user_name":"_funyoo_","can_delete":false,"product_type":"c1","uid":1589568,"ip_address":"","ucode":"096B1A411E55A5","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/40/5489dae0.jpg","comment_is_top":false,"comment_ctime":1574186176,"is_pvip":false,"replies":[{"id":"58885","content":"√<br>方法2 👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574217226,"ip_address":"","comment_id":153213,"utype":1}],"discussion_count":31,"race_medal":0,"score":"315106798784","product_id":100040201,"comment_content":"说说我的思考：<br>方法1：在遍历链表1，看该结点是否在2中存在，若存在，即为合并。<br>遍历的方法：①两个for嵌套 ②根据1建立hash表，遍历2时在1中查找<br><br>方法2：计算两个链表的长度，谁长谁先“往前走”，待长链表未查看长度等于短链表是，两两元素比较，遍历完未出现相同时，则没有合并<br><br>方法3：直接比较两个链表的最后一个元素，相等即合并","like_count":74,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475084,"discussion_content":"√\n方法2 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574217226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","nickname":"Citizen Z","note":"","ucode":"9CA547640A8629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54008,"discussion_content":"方法2，计算长度用什么手段，假如链表不维护长度属性，那么计算长度的时间复杂度是 O(n)，遍历两个链表就是2O(n)，然后加上第三次对比查找的时间，从算法结构来看不太划算。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574250613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1125104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","nickname":"Citizen Z","note":"","ucode":"9CA547640A8629","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211923,"discussion_content":"很好的课程，收益颇多，感谢极客时间平台！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584892803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54008,"ip_address":""},"score":211923,"extra":""},{"author":{"id":1665242,"avatar":"","nickname":"ylchen.xd","note":"","ucode":"8D9EDAAC1E28ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1125104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","nickname":"Citizen Z","note":"","ucode":"9CA547640A8629","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318828,"discussion_content":"第三次对比查找的时间复杂度依然是O(n), 因为两个链表可以同步移动。对比方法1的O(n^2)依然是优势，n越大肯定越划算的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603859532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54008,"ip_address":""},"score":318828,"extra":""}]},{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163043,"discussion_content":"根据第二个方法的扩展，直接从两个连表的最后一个地址往前进行比较，直到出现不一致的为止","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581043836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1625006,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cb/ae/738a29d4.jpg","nickname":"Leona","note":"","ucode":"979CCCECE2DFCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213411,"discussion_content":"单向链表","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585071401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163043,"ip_address":""},"score":213411,"extra":""}]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159143,"discussion_content":"方法三很好。\n只有一个边界值有问题，就是a，b的头指针都指向null，这里应该认为是未合并，但方法三会告诉你是合并的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580654367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000060,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","nickname":"🄽🄸🅇🅄🅂","note":"","ucode":"853763C229A5AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55496,"discussion_content":"老哥，第三种方法很棒，不过感觉遇到极端情况的时候就不靠谱了，如果两个链表在x处相交，之后又分开成两个链表，两个链表最后一个元素又相交。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574382133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1636689,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f9/51/8a80796f.jpg","nickname":"追梦的阿征","note":"","ucode":"4DDACCC5F4D08A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000060,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","nickname":"🄽🄸🅇🅄🅂","note":"","ucode":"853763C229A5AA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57096,"discussion_content":"我觉得只要相交之后就不会出现再次分叉的情况，因为链表只有一个后继元素，如果分叉的话，就说明某一个节点有两个后继元素了","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1574567210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55496,"ip_address":""},"score":57096,"extra":""},{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000060,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","nickname":"🄽🄸🅇🅄🅂","note":"","ucode":"853763C229A5AA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211925,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584892823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55496,"ip_address":""},"score":211925,"extra":""}]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53895,"discussion_content":"如果要找到 合并的第一个元素，那么方法3就不适用了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574230745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211926,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584892828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53895,"ip_address":""},"score":211926,"extra":""}]},{"author":{"id":1197685,"avatar":"https://static001.geekbang.org/account/avatar/00/12/46/75/9f80409f.jpg","nickname":"追梦","note":"","ucode":"634A19055525B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364119,"discussion_content":"如果不需要求合并的第一个节点，方法三最优；如果需要求合并的第一个节点方法二最优；如果链表本身维护了长度信息，方法二最优","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617368505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114352,"avatar":"https://static001.geekbang.org/account/avatar/00/11/00/f0/fe94061e.jpg","nickname":"假装在养🐷","note":"","ucode":"D0AB9CD03E0D5B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573472,"discussion_content":"两个链表的元素一致，也不能表示就是由合并的吧，还是要看元素的地址是否一致吧？否则，将链表A复制一份，看上去每个元素的值都重复，但是两个独立的链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653454659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1025006,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/ee/636415d8.jpg","nickname":"永昌","note":"","ucode":"A572DDE33DFAD9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551910,"discussion_content":"使用一个map，同时记录两个链表的地址，如果有发现相同地址，就可以返回结果了，平均时间复杂度要好一点，但是会增加空间复杂度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645171451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369240,"discussion_content":"方法二怎么计算两个链表长度？遍及吗？\n方法三并没有找到x元素。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618983830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182890,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0c/aa/ec0bb23f.jpg","nickname":"阳光雨露","note":"","ucode":"3121AEF235F0BF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356685,"discussion_content":"单链表，如果不知道长度的情况下呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615646830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1682698,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ad/0a/4ced2bcb.jpg","nickname":"小雷","note":"","ucode":"D326F0871DA62A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350022,"discussion_content":"第二种方法是天上掉下来的解法吗 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613662392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2418763,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e8/4b/8ddf36b0.jpg","nickname":"程同学","note":"","ucode":"622B71D5A2DA5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343365,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611024536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1516197,"avatar":"https://static001.geekbang.org/account/avatar/00/17/22/a5/58942799.jpg","nickname":"延陵","note":"","ucode":"ACA1E529101D2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304076,"discussion_content":"分别 next 获取两条链表的每一个节点 next 值，当 value 相同的一个值在两个链表中所对应的上一个节点 next 不同，则说明在相同节点处分叉，存在两条不同的 head ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599462772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","nickname":"有米","note":"","ucode":"C9A10B7A67BC12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295831,"discussion_content":"判断能不能合并应该是看next指针是否相同吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596358594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015930,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/7a/02fdf1a2.jpg","nickname":"FreezeSoul","note":"","ucode":"0B67142C4EA3D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213351,"discussion_content":"答案受教了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585064628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211924,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584892816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211922,"discussion_content":"很好的课程，收益颇多，感谢极客时间平台！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584892794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1059618,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2b/22/67ba356b.jpg","nickname":"大男孩","note":"","ucode":"AE15AA6E0EF449","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174153,"discussion_content":"方法二厉害，但比较节点中的元素无法真正确定合并（单链元素重复时），应当比较节点的地址（指针）信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581876428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021530,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/96/5a/846a09f7.jpg","nickname":"pony","note":"","ucode":"B72FA864CDD286","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57364,"discussion_content":"方法3正解，最直观","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574601130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2025783,"avatar":"","nickname":"宋扬春","note":"","ucode":"2259FF9D6D4741","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1021530,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/96/5a/846a09f7.jpg","nickname":"pony","note":"","ucode":"B72FA864CDD286","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276583,"discussion_content":"方法三没有返回x元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590907873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57364,"ip_address":""},"score":276583,"extra":""}]},{"author":{"id":1657924,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/IWOnxcOM4TPExuPS4gTJ9mJQD0eW1EGicqe6qOwcUiaqfrw23tZ6T9VWTiaSqiblSlqnTW4MVAxsYYF0ibcCW6PI88w/132","nickname":"tongyang","note":"","ucode":"2A33FE56CC15EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57124,"discussion_content":"方法2没理解待未查看长度等于短链表时 是啥意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574572501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1033075,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/73/40a905ca.jpg","nickname":"alberich","note":"","ucode":"0537EFDB25F8C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1657924,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/IWOnxcOM4TPExuPS4gTJ9mJQD0eW1EGicqe6qOwcUiaqfrw23tZ6T9VWTiaSqiblSlqnTW4MVAxsYYF0ibcCW6PI88w/132","nickname":"tongyang","note":"","ucode":"2A33FE56CC15EE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553287,"discussion_content":"1.遍历2条链，获得2条链的长度\n2.再开始遍历长链，待长链剩余的长度与短链相等时开始比较2链元素的地址\n3.如果后续出现地址相同的2元素则表示2链合并，该元素即为x","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645806609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57124,"ip_address":""},"score":553287,"extra":""}]},{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53746,"discussion_content":"第二种是正经解法😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574212838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211927,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584892837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53746,"ip_address":""},"score":211927,"extra":""}]}]},{"had_liked":false,"id":156604,"user_name":"Geek_9c3134","can_delete":false,"product_type":"c1","uid":1141689,"ip_address":"","ucode":"479BC6B4CF22FA","user_header":"https://static001.geekbang.org/account/avatar/00/11/6b/b9/9b0630b1.jpg","comment_is_top":false,"comment_ctime":1574921265,"is_pvip":false,"replies":[{"id":"60290","content":"那就继续问下去~~<br><br>Hash表数组长度不足怎么办？<br><br>多线程并发修改Hash表怎么办？如何保证线程安全？JDK的ConcurrentHashMap是如何解决的？<br><br>如何使Hash表中的数据分布更加均匀，减少Hash聚集？<br><br>余数Hash算法应用于分布式缓存路由的时候有什么问题？如何解决？一致性Hash算法原理是什么？<br><br>用你熟悉的编程语言20分钟写一个一致性Hash算法实现。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1575070559,"ip_address":"","comment_id":156604,"utype":1}],"discussion_count":7,"race_medal":0,"score":"233503155249","product_id":100040201,"comment_content":"老师 你这问题我问了别人  发现只回答到了数组下标  没有人讲到内存  还说我的问题太简单了","like_count":54,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476166,"discussion_content":"那就继续问下去~~\n\nHash表数组长度不足怎么办？\n\n多线程并发修改Hash表怎么办？如何保证线程安全？JDK的ConcurrentHashMap是如何解决的？\n\n如何使Hash表中的数据分布更加均匀，减少Hash聚集？\n\n余数Hash算法应用于分布式缓存路由的时候有什么问题？如何解决？一致性Hash算法原理是什么？\n\n用你熟悉的编程语言20分钟写一个一致性Hash算法实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575070559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361387,"discussion_content":"hash表的问题太多了。我一般前边的简单问完了，再问下，链表会不会长？长的情况说明什么？该怎么办？答上红黑树的，一般接着会问，什么情况转为红黑树？为什么是这个情况转为红黑树？hash既可以增加数据，又可以删除数据，如果数据被逐步清除，是否会从红黑树退化为链表，什么情况退化？ 这些都是对工程的一些理解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1616657647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130666,"avatar":"https://static001.geekbang.org/account/avatar/00/11/40/aa/49bbb007.jpg","nickname":"нáпの゛","note":"","ucode":"834FA877EFBAF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220502,"discussion_content":"都回答上恭喜面试通过。感觉文章里还是点到为止，要是老师回复这些更深层次的思考能在文章体现就好了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585885129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","nickname":"程序员二师兄","note":"","ucode":"C9E3B5B3358BDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284928,"discussion_content":"对老师评论回复的问题感到害怕，面试怕是过不了了，面对面试官这样的穷追猛打，感觉买了老师的面试专栏也搞不定呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592670699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249479,"avatar":"https://static001.geekbang.org/account/avatar/00/13/10/c7/e766861a.jpg","nickname":"张良","note":"","ucode":"9E91B0C0082735","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267904,"discussion_content":"现在的面试就说一个问题一直问到你不回","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589707549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159147,"discussion_content":"如果这些问题被面试者都能给出一个比较满意的答案，那说明什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580654619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1360111,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK4biaeBuuqvR3SB4H8atcmreszjIPRZgNeVXFMMPbVZht7yqx01PE0CJPOmyL4jLAiaCdib9lAkPpjw/132","nickname":"zhycareer","note":"","ucode":"903F9AB1961FA1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73638,"discussion_content":"厉害了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575564045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153428,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1574234407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"78883645735","product_id":100040201,"comment_content":"思路特别清晰，但是都是点到为止呀，感觉差点啥，哈哈，可能后面的文章会具体介绍，更加详细。","like_count":18},{"had_liked":false,"id":153531,"user_name":"　扬帆丶启航　","can_delete":false,"product_type":"c1","uid":1235282,"ip_address":"","ucode":"4079D0889CD86C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/52/73351eab.jpg","comment_is_top":false,"comment_ctime":1574254170,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"74588698202","product_id":100040201,"comment_content":"计算两个链表的长度，用长的链表减去短的链表，计算出差值，长的链表先向后移动差值的个数，然后两个链表再同时移动，判断一下个节点的地址是否相同。","like_count":18,"discussions":[{"author":{"id":2820632,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/0a/18/cdfd70ad.jpg","nickname":"LetMeCode","note":"","ucode":"AD6D729D42BB44","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580478,"discussion_content":"计算链表长度就需要遍历1次了吧。 看下力扣题解第二种解法就行。分用2个指针分别从两个链表的头结点,遍历到其尾结点后再从另外个链表上遍历，如果能相交，则会有一次相等，如果不想交，则遍历都对方链表的尾结点结束后还是没相交过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658202630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110662,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg","nickname":"Hank_Yan","note":"","ucode":"86899B561C502B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294781,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595997800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178156,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/2c/9a0c45e6.jpg","nickname":"微凉","note":"","ucode":"F6BD0AE11AE224","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62731,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574859787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482571,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9f/4b/93f3e8f8.jpg","nickname":"小二","note":"","ucode":"38636D40BF4820","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54216,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574269012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153263,"user_name":"breezeQian","can_delete":false,"product_type":"c1","uid":1066220,"ip_address":"","ucode":"29A6CC6B245ED9","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/ec/0c24c4f5.jpg","comment_is_top":false,"comment_ctime":1574209514,"is_pvip":false,"replies":[{"id":"58884","content":"√","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574217208,"ip_address":"","comment_id":153263,"utype":1}],"discussion_count":3,"race_medal":0,"score":"57408784362","product_id":100040201,"comment_content":"步骤一：将长度短的链表的元素构造成哈希表，key是指针，value是节点值。<br>步骤二：遍历较长链表找出合并的节点","like_count":13,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475101,"discussion_content":"√","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574217208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","nickname":"程序员二师兄","note":"","ucode":"C9E3B5B3358BDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284927,"discussion_content":"思路一致，认同+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592670567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1057611,"avatar":"https://static001.geekbang.org/account/avatar/00/10/23/4b/5578cbd1.jpg","nickname":"IsaacGao","note":"","ucode":"95C640D185A060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":176023,"discussion_content":"如果不遍历一次链表，好像是没办法知道其长度的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582015746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156080,"user_name":"Geek_ac779f","can_delete":false,"product_type":"c1","uid":1625384,"ip_address":"","ucode":"295C18027325D9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Yofo8cTYBLlos9KXpEQW3YBgu2WN8bDIOBUKiciar7mFY4fxJz1Dz6reHRCy9icN3YAd7lqnpT4QReGvibYZS8VpnQ/132","comment_is_top":false,"comment_ctime":1574817848,"is_pvip":false,"replies":[{"id":"59976","content":"程序运行过程中，内存不断被申请、释放，内存的空闲空间呈碎片化，本身就是不连续的。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574835424,"ip_address":"","comment_id":156080,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27344621624","product_id":100040201,"comment_content":"老师，为什么有些数据结构的内存空间不要求是连续的？都是连续的内存空间不好吗。既然连续和不连续的内存空间都可以实现这些数据结构，使用不连续的内存空间实现有什么好处呢，利用率更高吗。为什么利用率更高呢，不都是以字节为基本单位吗","like_count":6,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475979,"discussion_content":"程序运行过程中，内存不断被申请、释放，内存的空闲空间呈碎片化，本身就是不连续的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574835424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625384,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Yofo8cTYBLlos9KXpEQW3YBgu2WN8bDIOBUKiciar7mFY4fxJz1Dz6reHRCy9icN3YAd7lqnpT4QReGvibYZS8VpnQ/132","nickname":"Geek_ac779f","note":"","ucode":"295C18027325D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64209,"discussion_content":"想象到了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574942131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153412,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1574232229,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27344036005","product_id":100040201,"comment_content":"思考题：第一步：分别遍历针对两个链表A、B（先不考虑长度差）。第二步：如果A链表先走到了末尾那么把A链表的指针指向B链表的第一个节点，继续遍历B链表；B链表的原始指针继续做遍历不变，走到末尾后，将B链表的指针指向A链表的第一个节点，继续遍历A链表。第三步：两个链表继续做遍历，如果分别指向的节点数值（地址）相同，那么这两个链表就是合并链表，这个节点就为合并的第一个节点。<br><br>思想：通过指针的变换指向，很好滴解决的长度差的问题。消除两个链表的长度差带来的影响，","like_count":6,"discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53970,"discussion_content":"这个方法的时间复杂度为O(n)，因为每个链表最多被遍历两次。空间复杂度为O(1)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574243041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153201,"user_name":"晶晶","can_delete":false,"product_type":"c1","uid":1522900,"ip_address":"","ucode":"D3B4D68D96018F","user_header":"https://static001.geekbang.org/account/avatar/00/17/3c/d4/f42afcda.jpg","comment_is_top":false,"comment_ctime":1574180101,"is_pvip":false,"replies":[{"id":"58851","content":"🌹","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574210794,"ip_address":"","comment_id":153201,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23049016581","product_id":100040201,"comment_content":"是我听过的课程里面觉得最让我思路清晰的课程~所以先打卡沙发一下☺","like_count":5,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475080,"discussion_content":"🌹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574210794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1661704,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","nickname":"丁丁历险记","note":"","ucode":"A43829E454C067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53700,"discussion_content":"个人观点，赞美有时候是个坏习惯，能在极客开客的，不会差的。\n更多的经历，需要投入到分析讨论技术上来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574210462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208710,"user_name":"Anne","can_delete":false,"product_type":"c1","uid":1344945,"ip_address":"","ucode":"AC57F43BEDD65C","user_header":"https://static001.geekbang.org/account/avatar/00/14/85/b1/fe357d1a.jpg","comment_is_top":false,"comment_ctime":1587426128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14472328016","product_id":100040201,"comment_content":"暴力法：双重循环，针对链表1的每个元素，对链表2的每个元素进行遍历，比较是否相等，第一个相等的元素就是相交点<br>使用栈：将两个链表的元素分别放入2个栈中，分别弹出栈顶元素，进行比较，如果栈顶元素相同则相交，相交之后第一个不相同元素的前一个元素就是相交点<br>判断两个链表的长度：如果长度不同，比如一个是n，一个m，较长的链表先走n-m步，然后两个链表一起遍历，相同的元素即为交点。如果长度相同，一起遍历。","like_count":3},{"had_liked":false,"id":249279,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1600566398,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"10190500990","product_id":100040201,"comment_content":"看到题目，我也回答不上来，为什么 Hash 表的访问时间复杂度是 O(1)，后来看了专栏才知道（想起来），Hash 表的底层实现其实是数组。然后老师在留言里面提到的 Hash 表高阶问题，更是问的我一头大汗。<br><br>即使是简单的数据结构，也能问出来好问题。<br><br>课后思考题，单向链表合并，其实是 LeetCode 的 160 题，Intersection of Two Linked Lists。<br><br>官方给出了三个解题思路：<br><br>1. Brute Force 暴力解法，双重循环遍历两个链表，时间复杂度 O(mn)，空间复杂度 O(1)<br>2. Hash Table 哈希表，将一个链表转为 Hash 表，然后遍历另一个链表，时间复杂度 O(m+n)，空间复杂度 O(m) 或 O(n)<br>3. Two Pointers 双指针，同时遍历两个链表，遍历到一条链表终点之后，续到另一条链表头部，比较两个指针，如果相等，则为交点<br><br>因为这一篇以 Hash 表为题，所以第二个解法比较容易想到。<br><br>public class Solution {<br>    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {<br>        &#47;&#47; boundary check<br>        if (headA == null || headB == null) {<br>            return null;<br>        }<br>        ListNode pA = headA;<br>        ListNode pB = headB;<br>        &#47;&#47; if a &amp; b have different len,<br>        &#47;&#47; then we will stop the loop after second iteration<br>        while (pA != pB) {<br>            &#47;&#47; for the end of first iteration,<br>            &#47;&#47; we just reset the pointer to the head of another linkedlist<br>            pA = pA == null ? headB : pA.next;<br>            pB = pB == null ? headA : pB.next;<br>        }<br>        return pA;<br>    }<br>}","like_count":2},{"had_liked":false,"id":209366,"user_name":"王杰","can_delete":false,"product_type":"c1","uid":1944186,"ip_address":"","ucode":"53CC01032E4A25","user_header":"","comment_is_top":false,"comment_ctime":1587541493,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10177476085","product_id":100040201,"comment_content":"其实这个问题可以归纳为两链表是否具有相同的元素地址。具体：两层for循环，查找相同的指针地址","like_count":2,"discussions":[{"author":{"id":2025783,"avatar":"","nickname":"宋扬春","note":"","ucode":"2259FF9D6D4741","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276582,"discussion_content":"都不考虑时间和空间复杂度的？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590907824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157210,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1575083148,"is_pvip":true,"replies":[{"id":"60307","content":"是的，你描述的算法过程更合理。<br><br>文中只是想表达这个插入节点，修改指针的逻辑，文中描述不作为算法过程。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1575099390,"ip_address":"","comment_id":157210,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10165017740","product_id":100040201,"comment_content":"老师，文中这段话“想在 b 和 c 之间插入一个元素 x，只需要将 b 指向 c 的指针修改为指向 x，然后将 x 的指针指向 c 就可以了”感觉反过来说更合理一些，如果按以上顺序代码实现会出现指针丢失内存泄漏的情况吧。","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476363,"discussion_content":"是的，你描述的算法过程更合理。\n\n文中只是想表达这个插入节点，修改指针的逻辑，文中描述不作为算法过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575099390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159155,"discussion_content":"用个中间指针存下c嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580655001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153487,"user_name":"郭刚","can_delete":false,"product_type":"c1","uid":1292032,"ip_address":"","ucode":"22CB8ECE8E3DCA","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/00/12149f4e.jpg","comment_is_top":false,"comment_ctime":1574244868,"is_pvip":false,"replies":[{"id":"59007","content":"√","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574292305,"ip_address":"","comment_id":153487,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10164179460","product_id":100040201,"comment_content":"类似Oracle中的hash join的算法","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475185,"discussion_content":"√","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574292305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159152,"discussion_content":"根号是对号的意思吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580654831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234348,"user_name":"碧雪天虹","can_delete":false,"product_type":"c1","uid":1258359,"ip_address":"","ucode":"313CC048C7E341","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/77/0c593044.jpg","comment_is_top":false,"comment_ctime":1594651054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889618350","product_id":100040201,"comment_content":"把两个链表都入栈, 然后从栈顶开始同时出栈, 如果某一轮出栈两个元素不同, 那么前一轮的就是x元素","like_count":1},{"had_liked":false,"id":205328,"user_name":"小狼","can_delete":false,"product_type":"c1","uid":1033425,"ip_address":"","ucode":"FEAC7864FC1D20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/d1/209abdd6.jpg","comment_is_top":false,"comment_ctime":1586593898,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5881561194","product_id":100040201,"comment_content":"“但是正因为链表是不连续存储的，所以在链表中插入或者删除一个数据是非常容易的，只要找到要插入（删除）的位置，修改链表指针就可以了” 这句话的归因“但是正因为链表是不连续存储的”不严谨，插入或者删除一个数据非常容易并不是因为链表是不连续存储的，而是因为本质上链表指针的设计，有了这些指针，即便链表的存储是连续的，也丝毫不影响插入或者删除一个数据的快捷性，也即链表中插入或删除数据方便跟链表的存储分配是否连续没有因果关系","like_count":1},{"had_liked":false,"id":175338,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1580657404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875624700","product_id":100040201,"comment_content":"之前只给了伪代码，感觉不过瘾，同时也验证自己的思路是否正确，就实现了下，请老师和同学拍砖。<br>https:&#47;&#47;github.com&#47;ToddSAP&#47;Geektime&#47;blob&#47;master&#47;src&#47;backendinterview38&#47;course2&#47;LinkedListMergedTest.java","like_count":1},{"had_liked":false,"id":155754,"user_name":"恺撒之剑","can_delete":false,"product_type":"c1","uid":1145624,"ip_address":"","ucode":"18F55D253647E6","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/18/6e44e6e0.jpg","comment_is_top":false,"comment_ctime":1574749268,"is_pvip":false,"replies":[{"id":"59835","content":"已改正，谢谢~","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574759492,"ip_address":"","comment_id":155754,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869716564","product_id":100040201,"comment_content":"课程中的数组示意图，长度为10的整数数组，地址从1000开始，下标为9的数组对应的起始地址应该为1036，而不是1039","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475859,"discussion_content":"已改正，谢谢~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574759492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154151,"user_name":"小烽","can_delete":false,"product_type":"c1","uid":1114972,"ip_address":"","ucode":"E40BB9B46FB347","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq36dSapVA92lPpicBALBsecgwN1uIJQUfqwa6eTz2BuibebH11W4DAmeJeV5aedBY2KIcKLMTIl67A/132","comment_is_top":false,"comment_ctime":1574385473,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869352769","product_id":100040201,"comment_content":"我的思考去下：能想到的就是遍历，结合前面几位的方法，做个比较。假设长度分别为m和n，m大。<br>方法一：先去遍历m 链表到m-n,然后同时遍历两个链表，比较大小，时间复杂度是O(m)<br><br>方法二：取一条链表的值放入hash 表，另一个链表进行遍历，在没有hash 冲突的情况下，时间复杂度应该是O(m+n)<br><br>方法三：从链表末端开始比较，时间复杂度应该也是O(m+n)<br><br>不知道理解的对不对。","like_count":1,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159158,"discussion_content":"可以做到O(min(m,n))","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580655071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153542,"user_name":"小太白52度","can_delete":false,"product_type":"c1","uid":1603347,"ip_address":"","ucode":"1E8C1D1C4D1AF7","user_header":"https://static001.geekbang.org/account/avatar/00/18/77/13/a424f771.jpg","comment_is_top":false,"comment_ctime":1574256500,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869223796","product_id":100040201,"comment_content":"1.将两个单链表顺序颠倒，即由尾指向头；<br>2.将两个新链表由头开始一一比较，直到两个元素不想等；<br>3.若第一元素即不等，则两个链表不合并，否则最后一个相等元素即为合并处的元素。","like_count":1,"discussions":[{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54954,"discussion_content":"单向链表无法找到前继节点哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574329136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153503,"user_name":"Geek_60eace","can_delete":false,"product_type":"c1","uid":1748509,"ip_address":"","ucode":"C0107E63B40C5A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/1d/4e193dae.jpg","comment_is_top":false,"comment_ctime":1574248700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869215996","product_id":100040201,"comment_content":"获取2个列表的所有指针，进行交集运算，抛出第一个指针就是开始合并的地方","like_count":1},{"had_liked":false,"id":153482,"user_name":"远心","can_delete":false,"product_type":"c1","uid":1206787,"ip_address":"","ucode":"1157202C315655","user_header":"https://static001.geekbang.org/account/avatar/00/12/6a/03/cb597311.jpg","comment_is_top":false,"comment_ctime":1574243694,"is_pvip":false,"replies":[{"id":"59008","content":"思路很赞👍<br><br>你这里利用了LinkedList的特性，按照题意，应该无法直接得到两个链表的长度。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574293004,"ip_address":"","comment_id":153482,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869210990","product_id":100040201,"comment_content":"实现了同时遍历两个单向链表的方法，欢迎拍砖：https:&#47;&#47;github.com&#47;Huan-Rong&#47;geektime-backend-technology-basics&#47;blob&#47;master&#47;sources&#47;2-the-time-complexity-of-hash-table&#47;src&#47;main&#47;java&#47;site&#47;blbc&#47;MergeDetect.java","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475182,"discussion_content":"思路很赞👍\n\n你这里利用了LinkedList的特性，按照题意，应该无法直接得到两个链表的长度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574293004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206787,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/03/cb597311.jpg","nickname":"远心","note":"","ucode":"1157202C315655","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54408,"discussion_content":"谢谢老师，我再想想不使用 LinkedList 特性的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574298613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153405,"user_name":"幸福来敲门","can_delete":false,"product_type":"c1","uid":1670147,"ip_address":"","ucode":"A9CF2FDA8315A5","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/03/2941dea7.jpg","comment_is_top":false,"comment_ctime":1574230903,"is_pvip":false,"replies":[{"id":"58971","content":"谢谢指正，应该用十进制<br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574234576,"ip_address":"","comment_id":153405,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5869198199","product_id":100040201,"comment_content":"由于每个整型数据占据 4 个字节的内存空间，因此整个数组的内存空间地址是 0x1000～0x1039，根据这个，我们就可以轻易算出数组中每个数据的内存下标地址。利用这个特性，我们只要知道了数组下标，也就是数据在数组中的位置，比如下标 2，就可以计算得到这个数据在内存中的位置 0x1008。<br><br>请问这个内存16进制地址是怎么得出来的？ 0x1000～0x1039 <br><br>","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475154,"discussion_content":"谢谢指正，应该用十进制\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574234576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1458421,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqW6sdNZ1OF8n5Wsfr7Vr8sBY4vOD8iaj31icqPgyk8NdALibhzKXwdIDmoMJfJznWf8b0NGjcGWKRNg/132","nickname":"Geek__kkkkkkkk","note":"","ucode":"A6C8683A4C3628","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53933,"discussion_content":"老师，长度为40在十六进制中不是要写成十六进制的写法吗，40是十进制写法吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574237231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1458421,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqW6sdNZ1OF8n5Wsfr7Vr8sBY4vOD8iaj31icqPgyk8NdALibhzKXwdIDmoMJfJznWf8b0NGjcGWKRNg/132","nickname":"Geek__kkkkkkkk","note":"","ucode":"A6C8683A4C3628","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54302,"discussion_content":"嗯嗯，应该用十进制写法，谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574295059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53933,"ip_address":""},"score":54302,"extra":""}]}]},{"had_liked":false,"id":153390,"user_name":"小祺","can_delete":false,"product_type":"c1","uid":1193548,"ip_address":"","ucode":"2819BCA9E71C9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/4c/46c43cce.jpg","comment_is_top":false,"comment_ctime":1574229170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869196466","product_id":100040201,"comment_content":"0x1000～0x1036写成了0x1000～0x1039","like_count":1},{"had_liked":false,"id":153275,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1574210334,"is_pvip":false,"replies":[{"id":"58883","content":"√","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1574217162,"ip_address":"","comment_id":153275,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869177630","product_id":100040201,"comment_content":"基于单向链表的特性，  为链一的地址建立hash  然后便利链表2  存在就返回，指到null 了就没有合并。<br><br>下面写伪码实现 手机上输入的，就不整理了<br>p1  = &amp;p1_head<br>while  p1<br>hsets[p1] =*p1<br>p1 = *p1 箭头 <br>next<br><br>p2 = &amp;p2_head<br>while(p2)<br>if  isset hsets  p2   return   <br>p2  = *p2 箭头next<br>","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475106,"discussion_content":"√","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574217162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159161,"discussion_content":"一个思路，不过p1,p2可以在一个while里搞定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580655271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358858,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1523058,"ip_address":"湖南","ucode":"4890249B2A9C7C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/NeRCyul5wpibzQ9gXY8J9icHnDm3JOoW9Lr1NNxok2ZfcXQrK2ECe7J9GARdziaUspicTNbgJzx3pYoYbtyYBfGkWg/132","comment_is_top":false,"comment_ctime":1664937066,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1664937066","product_id":100040201,"comment_content":"整合评论区两位的留言：<br>暴力法：双重循环，针对链表1的每个元素，对链表2的每个元素进行遍历，比较是否相等，第一个相等的元素就是相交点；<br>使用hash：对其中一个链表建立hash表，遍历另一个链表时在hash表中查找，若存在则为合并且第一个发现存在的元素即为相交点；<br>使用栈：将两个链表的元素分别放入2个栈中，分别弹出栈顶元素，进行比较，如果栈顶元素相同则相交，相交之后第一个不相同元素的前一个元素就是相交点<br>判断两个链表的长度：如果长度不同，比如一个是n，一个m，较长的链表先走n-m步，然后两个链表一起遍历，相同的元素即为交点。如果长度相同，一起遍历。","like_count":0},{"had_liked":false,"id":358031,"user_name":"路在哪","can_delete":false,"product_type":"c1","uid":1816609,"ip_address":"四川","ucode":"A4822AD07AD102","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b8/21/f692bdb0.jpg","comment_is_top":false,"comment_ctime":1663838894,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663838894","product_id":100040201,"comment_content":"思考题：创建一个hashmap，先遍历a链表，把每个节点放到hashmap中，然后遍历b链表，判断hashmap中有没有b中的节点，这样应该行吧","like_count":0},{"had_liked":false,"id":351593,"user_name":"Jack Xin","can_delete":false,"product_type":"c1","uid":1425444,"ip_address":"","ucode":"BEC98A1F437239","user_header":"https://static001.geekbang.org/account/avatar/00/15/c0/24/01699070.jpg","comment_is_top":false,"comment_ctime":1657971039,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657971039","product_id":100040201,"comment_content":"思考题思路：可以将其中一个链表翻转，如果能从一个链表的头节点遍历到另一个链表的头节点就说明有合并。但是感觉这个思路时间复杂度没有降低多少……","like_count":0},{"had_liked":false,"id":348942,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1655605145,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655605145","product_id":100040201,"comment_content":"思考题：<br>1.随机挑选一个链表进行反转<br>2.将反转后的链表的尾节点指向 第一个链表的头结点。<br>3.问题就转化成了链表的经典问题，判断链表是否有环，有的话找出链表相交的节点","like_count":0},{"had_liked":false,"id":299441,"user_name":"米兰的小铁匠","can_delete":false,"product_type":"c1","uid":1146923,"ip_address":"","ucode":"E52E05954BF39D","user_header":"https://static001.geekbang.org/account/avatar/00/11/80/2b/ef1581b5.jpg","comment_is_top":false,"comment_ctime":1624628452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624628452","product_id":100040201,"comment_content":"思考总结：<br>本文从Hash表的时间复杂度立题，分析Hash表的实现基础<br>1、先从数组说起，因为数组用一块连续的内存空间，所以随机访问较快（下标），插入和删除慢<br>2、紧接着，链表不是连续存储的，更适合插入、删除等场景，查询则需要重新遍历，链表种类有很多：双向、循环等等<br>3、最终说到Hash表——数组+链表实现（其实有些链表过长会转成红黑树）<br>4、根据Key计算Hash再取余就的得到数组下标，对于Hash冲突的自然会演变成链表，而一些实现中链表到达一定长度会转变成红黑树，一些实现中会进行扩容重新分配。<br>5、最后说明栈（先进先出）、队列（后进先出）、树（二叉树、红黑树、B+树等等）<br>6、补充几个专业词汇吧：装载因子、散列冲突、散列函数<br>7、可以顺便复习下LinkedHashMap，也是面试常考题","like_count":0},{"had_liked":false,"id":281466,"user_name":"曹翔","can_delete":false,"product_type":"c1","uid":1114878,"ip_address":"","ucode":"B4D8B42DFB535C","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/fe/d539b96b.jpg","comment_is_top":false,"comment_ctime":1614757667,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614757667","product_id":100040201,"comment_content":"1.傻遍历<br>2.长减短，在节点处开始遍历比对","like_count":0},{"had_liked":false,"id":264495,"user_name":"meijing0114","can_delete":false,"product_type":"c1","uid":1012416,"ip_address":"","ucode":"B349D33E2F3ECC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/c0/b09911a0.jpg","comment_is_top":false,"comment_ctime":1606479149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606479149","product_id":100040201,"comment_content":"点到为止","like_count":0},{"had_liked":false,"id":239903,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1596688263,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596688263","product_id":100040201,"comment_content":"其实每一种数据结构都是为了更好更方便的去存储数据和查询数据。hash table这种结构最终目的是为了避免全量IO。类似还有各种树，为了减小时间复杂度。","like_count":0},{"had_liked":false,"id":233550,"user_name":"着迷","can_delete":false,"product_type":"c1","uid":1716801,"ip_address":"","ucode":"429F1D4015A195","user_header":"https://static001.geekbang.org/account/avatar/00/1a/32/41/c1a7840b.jpg","comment_is_top":false,"comment_ctime":1594351801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594351801","product_id":100040201,"comment_content":"方法1：两层for循环比较，时间复杂度为O(N2)<br>方法2：利用hash表时间复杂度为O（1）的特性，将较短链表存入hash表，遍历另一个链表，查找是否存在相同节点。时间复杂度为O（n） ","like_count":0},{"had_liked":false,"id":230772,"user_name":"liyao","can_delete":false,"product_type":"c1","uid":1213546,"ip_address":"","ucode":"878EC6F7AA4B29","user_header":"","comment_is_top":false,"comment_ctime":1593487777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593487777","product_id":100040201,"comment_content":"有个借助于字典类型的实现，把链表的节点地址作为key  内容作为value，两个链表往一个字典里扔，冲突的就是合并点。","like_count":0},{"had_liked":false,"id":224387,"user_name":"ghost","can_delete":false,"product_type":"c1","uid":1144815,"ip_address":"","ucode":"6D970E42CFD972","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/ef/999b00b1.jpg","comment_is_top":false,"comment_ctime":1591361157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591361157","product_id":100040201,"comment_content":"作为装数据的集合容器，数据结构根据在内容空间上的分配的不同方式开始自由演进和生长，先是有足够的空间，我们可以把相同类型的元素整块的放进来。这时候大家都排着队一个挨着一个，所以比较好找到谁在哪。有点像我们在学校的一个班级。大家都有自己的班号。过了一段时间由于空间上的的碎片，我们还想把在不同地方的数据链接起来，以方便不用考虑整块的内容，我们采用了远程的对暗号的方式，大家在不同的地方，但是每个人只知道自己的上级和自己的下级，这样打破了对空间的限制。类比我们看到的战争片中地下工作者的上下级关系。今儿在线性表的关系上，我们有了一些业务上的需要，做了一些增删上的限制。对先进后出和先出先出进一步演变出栈和队列。","like_count":0},{"had_liked":false,"id":215293,"user_name":"一路前行","can_delete":false,"product_type":"c1","uid":1288985,"ip_address":"","ucode":"32D3C715690783","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcFhGY0NV4kFzOSXWDHR2lrI2UbUP4Y016GOnpTH7dqSbicqJarX0pHxMsfLopRiacKEPXLx7IHHqg/132","comment_is_top":false,"comment_ctime":1588949634,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588949634","product_id":100040201,"comment_content":"伪代码：<br>def find_fisrt(head1,head2):<br>     start1 = head1<br>     start2 = head2<br>    while start1!=start2:<br>           start1 = start1 if start1.next else head2<br>           start2= start2 if start2.next else head1<br>   return start1.val<br><br><br>","like_count":0},{"had_liked":false,"id":205688,"user_name":"古朋半子","can_delete":false,"product_type":"c1","uid":1106143,"ip_address":"","ucode":"2E904AB6728F1F","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/df/6fe04947.jpg","comment_is_top":false,"comment_ctime":1586702385,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586702385","product_id":100040201,"comment_content":"两个链表分别压入两个栈，比较栈顶元素，第一个不相同的上一个为相交点","like_count":0,"discussions":[{"author":{"id":1780383,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEJ8h4x6vRmjYgvdeXle4iazib9cCYR4skiaj6xk17KuquGFXliag266MXZsTx1h2hICloE9EMAbcLIA/132","nickname":"极爷","note":"","ucode":"24BE33FFA7331F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286961,"discussion_content":"胡胖子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593333985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205325,"user_name":"小狼","can_delete":false,"product_type":"c1","uid":1033425,"ip_address":"","ucode":"FEAC7864FC1D20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/d1/209abdd6.jpg","comment_is_top":false,"comment_ctime":1586593556,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586593556","product_id":100040201,"comment_content":"思考题：<br>两个链表倒序依次比较：<br>1. 如果第一个元素不等，则说明未合并<br>2. 如果第一个元素比较相等，则依次进行下去，遇到第一个不相等的数据时，上一个相等的元素即是图中的 x<br><br>前提是：两个链表的合并就如文中所示的场景，不能出现多段合并的情形（一段相同，一段不同，又一段相同的情形）","like_count":0},{"had_liked":false,"id":197272,"user_name":"MrCubic","can_delete":false,"product_type":"c1","uid":1143176,"ip_address":"","ucode":"E0B78720596CAB","user_header":"https://static001.geekbang.org/account/avatar/00/11/71/88/933904e6.jpg","comment_is_top":false,"comment_ctime":1585366270,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585366270","product_id":100040201,"comment_content":"思路清晰，感觉帮我复习了一遍","like_count":0},{"had_liked":false,"id":193470,"user_name":"G7-华仔","can_delete":false,"product_type":"c1","uid":1426131,"ip_address":"","ucode":"C137DE32EA2CF5","user_header":"https://static001.geekbang.org/account/avatar/00/15/c2/d3/4d14c230.jpg","comment_is_top":false,"comment_ctime":1584897491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584897491","product_id":100040201,"comment_content":"为避免最坏情况，假定已知两个链表的长度，以及尾节点地址。长度相差大，优先比较尾节点，不同则结束不用合并。","like_count":0},{"had_liked":false,"id":183609,"user_name":"好好先生","can_delete":false,"product_type":"c1","uid":1528286,"ip_address":"","ucode":"794650E28C633A","user_header":"https://static001.geekbang.org/account/avatar/00/17/51/de/990fd4f2.jpg","comment_is_top":false,"comment_ctime":1583077238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583077238","product_id":100040201,"comment_content":"这一题最近刚做过，我觉得这个跟链表判断有没有环是类似的，把第一条链节点的地址存入一个set，把第二条链的节点的地址一一用contains（）方法进行判断。","like_count":0},{"had_liked":false,"id":179020,"user_name":"大男孩","can_delete":false,"product_type":"c1","uid":1059618,"ip_address":"","ucode":"AE15AA6E0EF449","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/22/67ba356b.jpg","comment_is_top":false,"comment_ctime":1581874863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581874863","product_id":100040201,"comment_content":"借助哈希表:<br>短链中节点地址作为key放入哈希表，遍历长链表看哈希表中是否有重复，有则直接定位合并起始节点，无则无合并。<br>时间换空间:<br>将短链表反转，看长链表长度是否变化，有变化说明有合并，原长度和与此时的长链表及合并（重合）长度有数量关系从而直接定位倒数第几节点。","like_count":0},{"had_liked":false,"id":176887,"user_name":"duang_duang","can_delete":false,"product_type":"c1","uid":1392130,"ip_address":"","ucode":"77AE4ADD4BF3F3","user_header":"https://static001.geekbang.org/account/avatar/00/15/3e/02/45e25bab.jpg","comment_is_top":false,"comment_ctime":1581215731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581215731","product_id":100040201,"comment_content":"思考题：<br>如果合并的定义是：两个链表从某个结点开始之后一直到最后一个结点“一致”的话。那我认为将两个链表反转，然后从前往后遍历即可，这样是否合并以及开始合并的结点都很容易找出。","like_count":0},{"had_liked":false,"id":175318,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1580653597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580653597","product_id":100040201,"comment_content":"同时遍历两个单链表，首先将单链表A的第一个元素对象地址放到一个散列表中，然后在遍历单链表B之前检查B的元素对象地址是否在散列表中，如果找到，则有合并，如果不在，则放入散列表，然后再遍历A，以此类推，直到某个单链表遍历结束，则结果是无合并。<br>伪代码：<br>while (a!=null &amp;&amp; b!=null) {<br>    if (hashMap.get(a)!=null) {<br>        System.out.println(&quot;合并&quot;);<br>    } else {<br>        hashMap.put(a, a);<br>        a = a.next;<br>    }<br>    if (hashMap.get(b)!=null) {<br>        System.out.println(&quot;合并&quot;);<br>    } else {<br>        hashMap.put(b, b);<br>        b = b.next;<br>    }<br>}<br>System.out.println(&quot;无合并&quot;);","like_count":0},{"had_liked":false,"id":174393,"user_name":"杨光","can_delete":false,"product_type":"c1","uid":1800308,"ip_address":"","ucode":"13F750DDD9E44E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/78/74/b04ee2af.jpg","comment_is_top":false,"comment_ctime":1580190617,"is_pvip":false,"replies":[{"id":"67836","content":"链表A和B的长度不一样的~","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1580270449,"ip_address":"","comment_id":174393,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580190617","product_id":100040201,"comment_content":"刚刚做过这题，C语言实现<br><br>&#47;**<br> * Definition for singly-linked list.<br> * struct ListNode {<br> *     int val;<br> *     struct ListNode *next;<br> * };<br> *&#47;<br>struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {<br>    if(headA == NULL || headB == NULL) return NULL;<br>    struct ListNode *pA = headA, *pB = headB;<br>    while(pA != pB) {<br>        pA = pA == NULL ? headB : pA-&gt;next;<br>        pB = pB == NULL ? headA : pB-&gt;next;<br>    }<br>    return pA;<br>}","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482390,"discussion_content":"链表A和B的长度不一样的~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580270449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172294,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1579145763,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1579145763","product_id":100040201,"comment_content":"指针指向的是下个节点key的内存地址，也就是下个节点key的hashcode，我们只需要计算出两个链表的next指针指向的key的内存地址是一样的就知道两个链表要合并了，就是hashcode相等。","like_count":0},{"had_liked":false,"id":171621,"user_name":"simon","can_delete":false,"product_type":"c1","uid":1019953,"ip_address":"","ucode":"7475194DF80B2F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/31/15dead09.jpg","comment_is_top":false,"comment_ctime":1578980008,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578980008","product_id":100040201,"comment_content":"用两个指针 一个走两步一个走一步  知道相遇就是重合节点","like_count":0,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159169,"discussion_content":"这不是检测链表是否有环","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580655509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161837,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1576373853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576373853","product_id":100040201,"comment_content":"hash的意思就是散列，对数据每个元素求hash，hash的结果存储在一维数组中，数据存储在链表中，hash是链表的头。查询时先对数据求hash，定位在数组中的地址，这个时间复杂度为o(1)，从链表中查询时间复杂度也是o(1)，所以hash表的时间复杂度是o(1)","like_count":0},{"had_liked":false,"id":159120,"user_name":"刘东才","can_delete":false,"product_type":"c1","uid":1602782,"ip_address":"","ucode":"632FA0E2879BCC","user_header":"https://static001.geekbang.org/account/avatar/00/18/74/de/01d6106a.jpg","comment_is_top":false,"comment_ctime":1575540656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575540656","product_id":100040201,"comment_content":"数据结构程序员应该都是知道的，但是在日常编码过程中真的很难遇到需要这些知识的地方","like_count":0},{"had_liked":false,"id":159061,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575528819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575528819","product_id":100040201,"comment_content":"思考题<br>我的解法是从两个节点向链表尾部进发，记下走过的节点数目，然后把节点数多的那个先走几步直到两个节点到尾部数目相同，这时比较两个节点是否相等，如果相等程序结束，如果不相等，分别前进一步再比较，直到结尾。","like_count":0},{"had_liked":false,"id":156016,"user_name":"熊四","can_delete":false,"product_type":"c1","uid":1256644,"ip_address":"","ucode":"AA6DE13F594375","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2l1tkzbYy4RaicYFB3Eiazgos6ejkN19BcOFy9jt5O799eG3zWqsNkI9kvWUO5WAFdCF5u2duP6zRKJa6y3apTMA/132","comment_is_top":false,"comment_ctime":1574812906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574812906","product_id":100040201,"comment_content":"将两个链表随便一个进行入栈操作，接着每次弹出一个和另外一个链表比较，","like_count":0},{"had_liked":false,"id":155875,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1574771262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574771262","product_id":100040201,"comment_content":"我听明白了老师","like_count":0},{"had_liked":false,"id":155634,"user_name":"greensky01","can_delete":false,"product_type":"c1","uid":1002581,"ip_address":"","ucode":"9C1B0EBFC603D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/55/879a4443.jpg","comment_is_top":false,"comment_ctime":1574730941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574730941","product_id":100040201,"comment_content":"关于hash表复杂度是O(1)这个题，我觉得还是不太妥，不如直接问复杂度是怎样的。因为前者存在误导。","like_count":0},{"had_liked":false,"id":153978,"user_name":"恐惧决定边界","can_delete":false,"product_type":"c1","uid":1361776,"ip_address":"","ucode":"A5FF46740E4877","user_header":"https://static001.geekbang.org/account/avatar/00/14/c7/70/608af3e4.jpg","comment_is_top":false,"comment_ctime":1574340878,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574340878","product_id":100040201,"comment_content":"建立一个hash表，同时遍历两个链表，在不断往后遍历的过程中，与hash表中元素对比，存在则是交点元素，不存在就将元素添加进表中并继续遍历。","like_count":0,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159217,"discussion_content":"手动🤝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580657459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153738,"user_name":"黄海峰","can_delete":false,"product_type":"c1","uid":1275357,"ip_address":"","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1574301283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574301283","product_id":100040201,"comment_content":"有点难想象，阿里大厂有面试官觉得这个问题难。。。","like_count":0},{"had_liked":false,"id":153678,"user_name":"木风","can_delete":false,"product_type":"c1","uid":1339677,"ip_address":"","ucode":"3BAA80C2F1FB68","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/1d/8d1d27b2.jpg","comment_is_top":false,"comment_ctime":1574296527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574296527","product_id":100040201,"comment_content":"把两链表值放入数组，从最末端往前找","like_count":0},{"had_liked":false,"id":153588,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1574263609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574263609","product_id":100040201,"comment_content":"遍历找出相同的节点。","like_count":0},{"had_liked":false,"id":153499,"user_name":"握不住手中沙","can_delete":false,"product_type":"c1","uid":1097132,"ip_address":"","ucode":"F194E47C4D42C9","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/ac/49494ed8.jpg","comment_is_top":false,"comment_ctime":1574248086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574248086","product_id":100040201,"comment_content":"思考题：<br>方法一：遍历其中一个链表将链表元素放入Hash表中，然后再遍历另一个链表的元素是否在Hash表中出现；<br>方法二：比较两个链表的长度Len1，Len2，然后用双指针的方式，首先从较长链表的头部先走（Len1-Len2）步，然后两个指针同步向后查找，若两个指针指向相等则说明两个链表已经合并，否则不是合并状态；","like_count":0},{"had_liked":false,"id":153364,"user_name":"BrokenSea1023","can_delete":false,"product_type":"c1","uid":1747915,"ip_address":"","ucode":"D8119EA39F6C69","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ab/cb/b96998c7.jpg","comment_is_top":false,"comment_ctime":1574223274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574223274","product_id":100040201,"comment_content":"虽然目前能力不足以让我给出方法，但是看到评论里的这些思路还是对我产生了极大的帮助！","like_count":0},{"had_liked":false,"id":153328,"user_name":"我是超人","can_delete":false,"product_type":"c1","uid":1635059,"ip_address":"","ucode":"D8A3DF8EBDEB56","user_header":"https://static001.geekbang.org/account/avatar/00/18/f2/f3/ebbba875.jpg","comment_is_top":false,"comment_ctime":1574217904,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1574217904","product_id":100040201,"comment_content":"首先遍历第一个链表，将各个结点存放到一个hash表里，接着遍历第二个链表，遍历时查看当前结点是否在hash表里存在，如果存在那么说明两个链表在此结点处合并，如果第二个链表都遍历完了还没有找到，那么说明这两个链表没有合并，整体时间复杂度是O（M+N），M和N分别是两个链表的长度。","like_count":0,"discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53897,"discussion_content":"这样做的话 时间复杂度是线性的。但是空间复杂度可以继续优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574230803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1466682,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/3a/a259c187.jpg","nickname":"山猫","note":"","ucode":"004F622AEDA906","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53894,"discussion_content":"我也是这样想的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574230526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153326,"user_name":"WhatAKitty","can_delete":false,"product_type":"c1","uid":1135707,"ip_address":"","ucode":"911C089450926B","user_header":"https://static001.geekbang.org/account/avatar/00/11/54/5b/1a14d829.jpg","comment_is_top":false,"comment_ctime":1574217553,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1574217553","product_id":100040201,"comment_content":"思考题解法：<br>两链表同时移动，并反转指针，如果发现中一个节点的下一节点与当前节点匹配，则说明该节点为交汇节点。","like_count":0,"discussions":[{"author":{"id":1135707,"avatar":"https://static001.geekbang.org/account/avatar/00/11/54/5b/1a14d829.jpg","nickname":"WhatAKitty","note":"","ucode":"911C089450926B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53916,"discussion_content":"对的，两个两边移动的同时都反转指针，不管两链表长短，如果存在交汇，则长链表的指针必定会碰到已被反转的节点。那么这个节点就是交汇点。时间复杂度可以直接看为O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574234498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53899,"discussion_content":"请问对于反转指针，是说对于两个链表分别反转吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574230879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153279,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1574210471,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1574210471","product_id":100040201,"comment_content":"Hash时间复杂度问题，在当下hashmap被问泛滥的今天，感觉回答上来，基本没有难度，绝大部分都可以，只是有的应聘者不知道时间复杂度是什么，😄","like_count":0,"discussions":[{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53847,"discussion_content":"深挖细节当然绝大部分不行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574224642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206751,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","nickname":"Healtheon","note":"","ucode":"B564B1FC4456E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53758,"discussion_content":"每个时代都有每个时代的要求，如果深度 挖掘HashMap 的各种问题，还是能够难倒一大波人的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574213944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153278,"user_name":"niuniu","can_delete":false,"product_type":"c1","uid":1254477,"ip_address":"","ucode":"F63047EB77448A","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/4d/29a93491.jpg","comment_is_top":false,"comment_ctime":1574210454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574210454","product_id":100040201,"comment_content":"数据结构起需要一门反复学习的技术，每次都能温故而知新，也是一门可大可小的学科，李老师用一篇短文就能说个大概，而高德纳老爷子用了整个计算机编程艺术第二卷只讲了“查找”。推荐极客时间王争的数据结构课程。 关于题目，我觉得可以首先遍历一个链表，把结果保存在hash表中，然后再遍历第二个链表，每次都检查元素在hash里有无冲突，有则表示是合并的节点。","like_count":0},{"had_liked":false,"id":153277,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1574210398,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574210398","product_id":100040201,"comment_content":"关于思考题的思路：一直比较当前指针，如果某个链表的内容小就移向下一个指针，这样一直判断是否有相等的元素。伪代码：<br><br>while（true）｛<br>if （c1 == c2）｛<br>     return c1；<br>｝<br>if  （c1 &gt; c2) {<br>     c2 = l2.next;<br>     if (c2 == null) break;<br>｝else {<br>     c1 = l1.next;<br>     if (c1 == null) break;<br>｝<br><br>return -1；<br>｝<br><br>并没有考虑合并还有可能分开的情况。<br><br>另外链表指针指向最后应该最容易，但是指向最后本身也有了自己全遍历的花销","like_count":0,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159226,"discussion_content":"合并后没可能分开。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580657700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}