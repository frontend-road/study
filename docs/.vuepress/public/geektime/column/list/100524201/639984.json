{"id":639984,"title":"14｜二叉查找树（BST）：查找速度你最行","content":"<p>你好，我是王健伟。</p><p>今天我要和你分享的主题是“二叉查找树”。</p><p>我们知道，二叉树是用来保存数据的。那么在需要的时候，这些保存在二叉树中的数据，要怎么才能被快速地找到和取出呢？这就需要在保存数据的时候遵循一定的规律。</p><p>遵循这种保存数据的规律所构成的二叉树，被称为“二叉查找树”。我们先从它的基本概念说起，再去了解它的实现方式。</p><h2>基本概念及定义</h2><p>二叉查找树也叫二叉搜索树<span class=\"reference\">（BST，Binary Search Tree）</span>，存在的意义在于实现快速查找，同时，它也支持快速插入和删除。</p><p>要使二叉树成为一棵二叉查找树，那么<strong>树中任意一个节点，左子树中每个节点的值都要小于该节点的值。而右子树中每个节点的值都要大于该节点的值</strong>。当然，左、右子树本身也是一棵二叉查找树。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/7c/290fb6f0beec50329cf303683d64a57c.jpg?wh=2284x878\" alt=\"\" title=\"图1&nbsp; 几棵典型二叉查找树\"></p><p>如果对二叉树查找树进行中序遍历，得到的结果就是一个有序序列，也就是说内部存储的数据是已经排好序的，所以它也叫做二叉排序树<span class=\"reference\">（Binary Sort Tree）</span>。图1中的二叉查找树按中序遍历序列，第一棵为“3，4，5，6，9，11”，第二棵为“8，11，12，17，19，23”，第三棵为“8，10 ，13，15，22”。</p><p>下面，看一看二叉查找树的类模板定义代码，分为每个节点的定义，以及二叉查找树的定义两个部分。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">//树中每个节点的定义\ntemplate &lt;typename T&gt; //T代表数据元素的类型\nstruct BinaryTreeNode\n{\n\tT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data;&nbsp; &nbsp;\n\tBinaryTreeNode* leftChild,&nbsp; &nbsp;//左子节点指针\n\t\t\t\t&nbsp; * rightChild;&nbsp; //右子节点指针\n};\n\t\n//二叉查找树的定义\ntemplate &lt;typename T&gt;\nclass BinarySearchTree\n{\npublic:\n\tBinarySearchTree()&nbsp; //构造函数\n\t{\n\t\troot = nullptr;\n\t}\n\t~BinarySearchTree() //析构函数\n\t{\n\t\tReleaseNode(root);\n\t}\n\t\t\n\t//二叉树中序遍历代码（排序），方便测试时显示节点数据\n\tvoid inOrder()\n\t{\n\t\tinOrder(root);\n\t}\n\tvoid inOrder(BinaryTreeNode&lt;T&gt;* tNode)\n\t{\n\t\tif (tNode != nullptr)\n\t\t{\n\t\t\t//左根右顺序\n\t\t\tinOrder(tNode-&gt;leftChild);\n\t\t\tcout &lt;&lt; tNode-&gt;data &lt;&lt; \" \";\n\t\t\tinOrder(tNode-&gt;rightChild);&nbsp;\n\t\t}\n\t}\nprivate:\n\tvoid ReleaseNode(BinaryTreeNode&lt;T&gt;* pnode)\n\t{\n\t\tif (pnode != nullptr)\n\t\t{\t\t\t\t\n\t\t\tReleaseNode(pnode-&gt;leftChild);&nbsp;\n\t\t\tReleaseNode(pnode-&gt;rightChild);\n\t\t}\n\t\tdelete pnode;\n\t}\n\nprivate:\n\tBinaryTreeNode&lt;T&gt;* root; //树根指针\t\n};\t\n</code></pre><h2>二叉查找树的常见操作</h2><p>创建好二叉查找树，就可以进行一些常规的操作了。二叉查找树最常见的操作包括数据插入、查找以及删除操作。我们一个一个来说。</p><h3><strong>数据插入操作</strong></h3><p>在BinarySearchTree类模板的定义中，加入如下代码。</p><pre><code class=\"language-plain\">//插入元素\nvoid InsertElem(const T&amp; e)&nbsp; //不可以指定插入位置，程序内部会自动确定插入位置\n{\n\tInsertElem(root, e);\n}\n\nvoid InsertElem(BinaryTreeNode&lt;T&gt;*&amp; tNode, const T&amp; e) //注意第一个参数类型\n{\t\n\tif (tNode == nullptr) //空树\n\t{\n\t\ttNode = new BinaryTreeNode&lt;T&gt;;\n\t\ttNode-&gt;data = e;\n\t\ttNode-&gt;leftChild = nullptr;\n\t\ttNode-&gt;rightChild = nullptr;\n\t\treturn;\n\t}\n\t\n\tif (e &gt; tNode-&gt;data)\n\t{\n\t\tInsertElem(tNode-&gt;rightChild,e);\n\t}\n\telse if (e &lt; tNode-&gt;data)\n\t{\n\t\tInsertElem(tNode-&gt;leftChild,e);\n\t}\nelse\n\t{\n\t\t//要插入的数据与当前树中某节点数据相同，则不允许插入\n\t\t//什么也不做\n\t}\n\treturn;\n}\n</code></pre><p>在main主函数中加入如下代码进行测试。</p><pre><code class=\"language-plain\">BinarySearchTree&lt;int&gt; mybtr;\nint array[] = { 23,17,11,19,8,12 };\nint acount = sizeof(array) / sizeof(int);\nfor (int i = 0; i &lt; acount; ++i)\n\tmybtr.InsertElem(array[i]);\nmybtr.inOrder(); //中序遍历\n</code></pre><p>执行结果为：<br>\n<img src=\"https://static001.geekbang.org/resource/image/40/98/40bd63f75e05e60e57a7fc3d7f497098.jpg?wh=2792x168\" alt=\"\"></p><h3>数据查找操作</h3><p>如果是递归算法来实现，那么在BinarySearchTree类模板的定义中，要加入下面的代码。</p><pre><code class=\"language-plain\">//查找某个节点\nBinaryTreeNode&lt;T&gt;* SearchElem(const T&amp; e)\n{\n\treturn SearchElem(root, e);\n}\nBinaryTreeNode&lt;T&gt;* SearchElem(BinaryTreeNode&lt;T&gt;* tNode, const T&amp; e)\n{\n\tif (tNode == nullptr)\n\t\treturn nullptr;\n\t\n\tif (tNode-&gt;data == e)&nbsp;&nbsp;\n\t\treturn tNode;\n\t\t\n\tif (e &lt; tNode-&gt;data)\n\t\treturn SearchElem(tNode-&gt;leftChild,e); //在左子树上做查找\n\telse\n\t\treturn SearchElem(tNode-&gt;rightChild,e); //在右子树上左查找\n}\n</code></pre><p>在main主函数中，继续增加代码测试节点查找操作。</p><pre><code class=\"language-plain\">int val = 19;\ncout &lt;&lt; endl; //换行\nBinaryTreeNode&lt;int&gt;* tmpp;\ntmpp = mybtr.SearchElem(val);\nif (tmpp != nullptr)\n{\n\tcout &lt;&lt; \"找到了值为：\" &lt;&lt; val &lt;&lt; \"的节点。\" &lt;&lt; endl;\n}\nelse\n{\n\tcout &lt;&lt; \"没找到值为：\" &lt;&lt; val &lt;&lt; \"的节点!!\" &lt;&lt; endl;\n}\n</code></pre><p>新增代码的执行结果为：<br>\n<img src=\"https://static001.geekbang.org/resource/image/1b/dc/1b9f15a9423a5a0242c1ffb94b84efdc.jpg?wh=2792x170\" alt=\"\"></p><p>注意，查找操作也可以通过非递归算法来实现，效率更高一些，同样也需要用到while循环，代码不复杂，这里给出相关代码参考。</p><pre><code class=\"language-plain\">BinaryTreeNode&lt;T&gt;* SearchElem(BinaryTreeNode&lt;T&gt;* tNode, const T&amp; e)\n{\n\tif (tNode == nullptr)\n\t\treturn nullptr;\n\t\t\n\tBinaryTreeNode&lt;T&gt;* tmpnode = tNode;\n\twhile (tmpnode)\n\t{\n\t\tif (tmpnode-&gt;data == e)\n\t\t\treturn tmpnode;\n\t\tif (tmpnode-&gt;data &gt; e)\n\t\t\ttmpnode = tmpnode-&gt;leftChild;\n\t\telse\n\t\t\ttmpnode = tmpnode-&gt;rightChild;\n\t}\n\treturn nullptr;\n}\n</code></pre><h3><strong>数据删除操作</strong></h3><p>二叉查找树的删除操作相对要更复杂一些，针对所要删除的节点的子节点个数不同，有几种情况需要处理。</p><p>第一种情况，如果<strong>要删除的节点左子树和右子树都为空</strong><span class=\"reference\">（叶节点）</span>，那就这样操作：</p><ol>\n<li>直接把这个节点删除。</li>\n<li>指向该被删除节点的父节点的相应孩子指针，将其设置为空。</li>\n</ol><p>第二种情况，如果<strong>要删除的节点的左子树为空或者右子树为空</strong>，那么就需要：</p><ol>\n<li>把这个节点删除。</li>\n<li>更新指向该被删除节点的父节点的相应孩子指针，让该指针指向要删除节点的非空的子节点即可。</li>\n</ol><p>第三种情况最为复杂，如果<strong>要删除的节点左子树和右子树都不为空</strong>，那么就需要：</p><ol>\n<li>找到这个要删除节点的左子树的最右下节点。当然，也可以找这个要删除节点右子树的最左下节点。</li>\n<li>将该节点的值替换到要删除的节点上。</li>\n<li>接着把刚刚找到的那个最右下节点删除。</li>\n</ol><p>在BinarySearchTree类模板的定义中，加入如下代码。</p><pre><code class=\"language-plain\">//删除某个节点\nvoid DeleteElem(const T&amp; e)\n{\n\treturn DeleteElem(root, e);\n}\nvoid DeleteElem(BinaryTreeNode&lt;T&gt;*&amp; tNode, const T&amp; e)&nbsp; //注意第一个参数类型\n{\n\tif (tNode == nullptr)\n\t\treturn;\n\t\n\tif (e &gt; tNode-&gt;data)\n\t{\n\t\tDeleteElem(tNode-&gt;rightChild,e);\n\t}\n\telse if (e &lt; tNode-&gt;data)\n\t{\n\t\tDeleteElem(tNode-&gt;leftChild,e);\n\t}\n\telse\n\t{\n\t\t//找到了节点，执行删除操作：\n\t\tif (tNode-&gt;leftChild == nullptr &amp;&amp; tNode-&gt;rightChild == nullptr) //要删除的节点左子树和右子树都为空（叶节点）\n\t\t{\n\t\t\t//即将被删除节点的左孩子和右孩子都为空\n\t\t\tBinaryTreeNode&lt;T&gt;* tmpnode = tNode;\n\t\t\ttNode = nullptr; //这实际上就是让指向该节点的父节点指向空\n\t\t\tdelete tmpnode;\n\t\t}\n\t\telse if (tNode-&gt;leftChild == nullptr) //其实这个else if代码可以和上个if代码合并，这里为了看的更清晰就不合并了\n\t\t{\n\t\t\t//即将被删除节点的左孩子为空（但右孩子不为空）\n\t\t\tBinaryTreeNode&lt;T&gt;* tmpnode = tNode;\n\t\t\ttNode = tNode-&gt;rightChild;\n\t\t\tdelete tmpnode;\n\t\t}\n\t\telse if (tNode-&gt;rightChild == nullptr)\n\t\t{\n\t\t\t//即将被删除节点的右孩子为空（但左孩子不为空）\n\t\t\tBinaryTreeNode&lt;T&gt;* tmpnode = tNode;\n\t\t\ttNode = tNode-&gt;leftChild;\n\t\t\tdelete tmpnode;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 即将被删除节点的左右孩子都不为空\n\t\t\t//(1)找到这个要删除节点的左子树的最右下节点\n\t\t\tBinaryTreeNode&lt;T&gt;* tmpparentnode = tNode;&nbsp; //tmpparentnode代表要删除节点的父节点\n\t\t\tBinaryTreeNode&lt;T&gt;* tmpnode = tNode-&gt;leftChild; //保存要删除节点左子树的最右下节点\n\t\t\twhile (tmpnode-&gt;rightChild)\n\t\t\t{\n\t\t\t\ttmpparentnode = tmpnode;\n\t\t\t\ttmpnode = tmpnode-&gt;rightChild;\n\t\t\t} //end while\n\t\t\ttNode-&gt;data = tmpnode-&gt;data;\n\t\t\t\n\t\t\t//此时，tmpnode指向要删除节点左子树的最右下节点（也就是真正要删除的节点），tmpparentnode指向真正要删除的节点的父节点。\t\n\t\t\t//(2)删除tmpnode所指向的节点（该节点是真正要删除的节点）\n\t\t\tif (tmpparentnode == tNode)\n\t\t\t{\n\t\t\t\t//此条件成立，表示上面while循环一次都没执行，也就是意味着要删除节点左子树没有右孩子（但可能有左孩子）\n\t\t\t\ttNode-&gt;leftChild = tmpnode-&gt;leftChild;&nbsp; &nbsp; //让要删除节点的左孩子&nbsp; 指向&nbsp; 真正要删除节点的左孩子的左孩子\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//此条件成立，表示上面while循环至少执行一次，这意味着要删除节点的左子树有1到多个右孩子，但这个右孩子不可能再有右孩子【因为tmpnode指向的是最后一个右孩子】（最多只能有左孩子）\n\t\t\t\ttmpparentnode-&gt;rightChild = tmpnode-&gt;leftChild; //tmpnode不可能有右孩子，最多只可能有左孩子\n\t\t\t}\n\t\t\t//(3)把最右下节点删除\n\t\t\tdelete tmpnode;\n\t\t} //end if\n\t}\n}\n</code></pre><p>上述代码可能有些复杂不好理解，我们对应几个例子来看一下。</p><ul>\n<li><strong>情况一，要删除的节点左右子树为空</strong></li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/31/53/31593bb40ab04416440200c68a539853.jpg?wh=2284x878\" alt=\"\" title=\"图2 在二叉查找树中删除值为19的叶节点\"></p><ul>\n<li><strong>情况二，要删除的节点的左子树或右子树为空</strong></li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/f3/1f/f30c3f46a57474875270aa3a25e56c1f.jpg?wh=2284x1009\" alt=\"\" title=\"图3 在二叉查找树中删除值为11的节点（左子树为空）\"></p><p><img src=\"https://static001.geekbang.org/resource/image/89/ca/891954c460b51867b85de7c5ef0faeca.jpg?wh=2284x1009\" alt=\"\" title=\"图4 在二叉查找树中删除值为57的节点（右子树为空）\"></p><ul>\n<li><strong>情况三，要删除的节点左子树和右子树都不为空</strong></li>\n</ul><p>这种情况相对复杂，我们举两个例子。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/af/d5447a6e65fc6e79c48ba587f2d381af.jpg?wh=2284x1009\" alt=\"\" title=\"图5 在二叉查找树中删除值为70的节点（左子树和右子树都存在）\"></p><p>在图5中，我们将要删除的节点临时取名为节点A，它的值是70，但节点A的左子树下并没有右节点，图里我用的是一个虚圆框中间带X符号表示，我们将节点A的左孩子节点临时取名为节点B，再把它的值67替换成节点A的值，再把节点A的左孩子节点B删除，同时让原本要被删除的节点A的leftChild指针指向真正被删除节点B的左孩子，也就是值为63的节点。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/5b/7bee3c418yy2e1ca173573d9cc38625b.jpg?wh=2284x1291\" alt=\"\" title=\"图6&nbsp; 在二叉查找树中删除值为76的节点（左子树和右子树都存在）\"></p><p>在图6中，我们将要删除的节点临时取名为节点A，它的值是76，再将节点A的左子节点临时取名为节点B，它的值为70。我们发现，节点B一直往右下看有若干个右节点，比如值为73、75的节点。一直沿着节点B的右孩子不断往右下找，找到最后一个右下节点，并把它临时取名节点C，值为75。用节点C的值75替换掉节点A的值。再把节点C删除，同时让节点C的父节点<span class=\"reference\">（值为73）</span>的rightChild指向节点C的左孩子<span class=\"reference\">（值为74的节点）</span>。</p><p>话说回来，在main主函数中，可以继续增加如下代码测试节点删除操作。</p><pre><code class=\"language-plain\">mybtr.DeleteElem(val);\nmybtr.inOrder();\n</code></pre><p>上述的DeleteElem()实现代码中，在“找到了节点，执行删除操作”这个分支中，前三个if…else分支其实是可以合并的，而最后一个else<span class=\"reference\">（即将被删除节点的左右孩子都不为空）</span>中的代码也可以换一种写法以便于理解，修改后的完整DeleteElem()代码如下。</p><pre><code class=\"language-plain\">void DeleteElem(BinaryTreeNode&lt;T&gt;*&amp; tNode, const T&amp; e)&nbsp; //注意第一个参数类型\n{\n\tif (tNode == nullptr)\n\t\treturn;\n\t\n\tif (e &gt; tNode-&gt;data)\n\t{\n\t\tDeleteElem(tNode-&gt;rightChild, e);\n\t}\n\telse if (e &lt; tNode-&gt;data)\n\t{\n\t\tDeleteElem(tNode-&gt;leftChild, e);\n\t}\n\telse\n\t{\n\t\t//找到了节点，执行删除操作：\n\t\tif (tNode-&gt;leftChild != nullptr &amp;&amp; tNode-&gt;rightChild != nullptr)\n\t\t{\n\t\t\tBinaryTreeNode&lt;T&gt;* tmpnode = tNode-&gt;leftChild; //保存要删除节点左子树的最右下节点\n\t\t\twhile (tmpnode-&gt;rightChild)\n\t\t\t{\n\t\t\t\ttmpnode = tmpnode-&gt;rightChild;\n\t\t\t} //end while\n\t\t\ttNode-&gt;data = tmpnode-&gt;data;\n\t\t\tDeleteElem(tNode-&gt;leftChild, tmpnode-&gt;data); //递归调用，因为上述是要删除节点左子树（下的最右节点），所以这里第一个参数是leftChild\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBinaryTreeNode&lt;T&gt;* tmpnode = tNode;\n\t\t\tif (tNode-&gt;leftChild == nullptr)\n\t\t\t\ttNode = tNode-&gt;rightChild;\n\t\t\telse\n\t\t\t\ttNode = tNode-&gt;leftChild;\n\t\t\tdelete tmpnode;\n\t\t}\n\t}\n}\n</code></pre><p>你可以看到，代码可以有多种写法，只要能够实现功能，就不必拘泥于某一种。删除操作同样也可以通过非递归算法来实现，代码会相对难理解一些，你可以尝试自行实现。</p><p>二叉查找树的插入、删除等操作的实现方法可以有很多种，甚至有人并不真正对节点进行删除操作，只是做删除标记，这种做法你有兴趣可以自己尝试。所以写代码时，你也并不需要局限于我的写法，它们实现的难易程度不同，只要保证操作后得到的结果仍旧是一棵二叉查找树即可。</p><h3>其他操作</h3><p>接下来，我再为你补充一些二叉查找树的其他常用操作。</p><ul>\n<li><strong>查找值最大</strong><strong>、</strong><strong>最小的节点</strong></li>\n</ul><p>在BinarySearchTree类模板的定义中，加入下面的代码。</p><pre><code class=\"language-plain\">//查找值最大节点\nBinaryTreeNode&lt;T&gt;* SearchMaxValuePoint()\n{\n\treturn SearchMaxValuePoint(root);\n}\n\nBinaryTreeNode&lt;T&gt;* SearchMaxValuePoint(BinaryTreeNode&lt;T&gt;* tNode)\n{\n\tif (tNode == nullptr) //空树\n\t\treturn nullptr;\n\t\n\t//从根节点开始往右侧找即可\n\tBinaryTreeNode&lt;T&gt;* tmpnode = tNode;\t\n\twhile (tmpnode-&gt;rightChild != nullptr)\n\t\ttmpnode = tmpnode-&gt;rightChild;\n\treturn tmpnode;\n}\n\n//查找值最小节点\nBinaryTreeNode&lt;T&gt;* SearchMinValuePoint()\n{\n\treturn SearchMinValuePoint(root);\n}\nBinaryTreeNode&lt;T&gt;* SearchMinValuePoint(BinaryTreeNode&lt;T&gt;* tNode)\n{\n\tif (tNode == nullptr) //空树\n\t\treturn nullptr;\n\t\n\t//从根节点开始往左侧找即可\n\tBinaryTreeNode&lt;T&gt;* tmpnode = tNode;\n\twhile (tmpnode-&gt;leftChild != nullptr)\n\t\ttmpnode = tmpnode-&gt;leftChild;\n\treturn tmpnode;\n}\n</code></pre><ul>\n<li><strong>找出中序遍历序列中当前节点的前趋和后继节点</strong></li>\n</ul><p>解决这个问题的方法有很多，书写的程序代码也各不相同。如果每个节点要有一个指向父节点的指针，那么解决起来可能更容易一些，如果没有指向父节点的指针，那么一般就要从根节点开始找起。</p><p>但不管怎样，一定要把握住两个原则。</p><ol>\n<li>当前节点的前趋节点一定是比当前节点值小的，也是再往前的一系列节点中最大的。</li>\n<li>当前节点的后继节点一定是比当前节点值大的，也是再往后的一系列节点中节点值最小的。</li>\n</ol><p>下面的代码有优化和合并的空间，但为了看得更清晰，我就不进行合并了，你可以自行优化。</p><pre><code class=\"language-plain\">//找按中序遍历的二叉查找树中当前节点的前趋节点\nBinaryTreeNode&lt;T&gt;* GetPriorPoint_IO(BinaryTreeNode&lt;T&gt;* findnode)\n{\n\tif (findnode == nullptr)\n\t\treturn nullptr;\n\t/*\n\t//以下代码后来考虑了一下，没必要存在\n\t//(1)所以如果当前结点有左孩子, 那么找左子树中值最大的节点\n\tif (findnode-&gt;leftChild != nullptr)\n\t\treturn SearchMaxValuePoint(findnode-&gt;leftChild);\n\t*/\n\t\n\tBinaryTreeNode&lt;T&gt;* prevnode = nullptr;\n\tBinaryTreeNode&lt;T&gt;* currnode = root;&nbsp; //当前节点，从根开始找\n\twhile (currnode != nullptr)\n\t{\n\t\tif(currnode-&gt;data &lt; findnode-&gt;data) //当前节点小\n\t\t{\n\t\t\t//(1)从一系列比当前要找的值小的节点中找一个值最大的当前趋节点\n\t\t\t//当前节点值比要找的&nbsp; 节点值小，所以当前节点认为有可能是前趋\n\t\t\tif(prevnode == nullptr)\n\t\t\t{\n\t\t\t\t//如果前趋节点还为空，那不妨把当前节点认为就是前趋\n\t\t\t\tprevnode = currnode;\n\t\t\t}\n\t\t\telse //prevnode不为空\n\t\t\t{\n\t\t\t\n\t\t\t\t//既然是找前趋，那自然是找到比要找的值小的 一系列节点中 值最大的\n\t\t\t\tif(prevnode-&gt;data &lt; currnode-&gt;data)\n\t\t\t\t{\n\t\t\t\t\tprevnode = currnode; //前趋自然是找一堆 比当前值小的 值中 最大的一个。\n\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\t//(2)继续逼近要找的节点，一直到找到要找的节点，找到要找的节点后，要找的节点的左节点仍旧可能是前趋\n\t\t\tcurrnode = currnode-&gt;rightChild;&nbsp; //当前节点小，所以往当前节点的右子树转\n\t\t}\n\t\t\n\t\telse if(currnode-&gt;data &gt; findnode-&gt;data) //当前节点值比要找的值大，所以当前节点肯定不会是要找的值的前趋\n\t\t{&nbsp;\n\t\t\t//当前节点大，所以往当前节点的左子树转\n\t\t\tcurrnode = currnode-&gt;leftChild;\n\t\t}\n\t\t\n\t\telse //(currnode-&gt;data == findnode-&gt;data) ，这个else其实可以和上个else合并，但为了清晰，就不合并了\n\t\t{\n\t\t\t//当前节点值&nbsp; 就是要找的节点值，那么 前趋也可能在当前节点的左子树中，所以往左子树转继续找看有没有更合适的前趋\n\t\t\tcurrnode = currnode-&gt;leftChild;&nbsp;\n\t\t}\n\t} //end while\n\t\n\treturn prevnode;\n}\n\n</code></pre><pre><code class=\"language-plain\">//找按中序遍历的二叉查找树中当前节点的后继节点\nBinaryTreeNode&lt;T&gt;* GetNextPoint_IO(BinaryTreeNode&lt;T&gt;* findnode)\n{\n\tif (findnode == nullptr)\n\t\treturn nullptr;\n\t\n\tBinaryTreeNode&lt;T&gt;* nextnode = nullptr;\n\tBinaryTreeNode&lt;T&gt;* currnode = root;&nbsp; //当前节点，从根开始找\n\twhile (currnode != nullptr)\n\t{\n\t\tif (currnode-&gt;data &gt; findnode-&gt;data) //当前节点大\n\t\t{\n\t\t\t//(1)从一系列比当前要找的值大的节点中找一个值最小的当后继节点\n\t\t\t//当前节点值比要找的&nbsp; 节点值大，所以当前节点认为有可能是后继\n\t\t\tif (nextnode == nullptr)\n\t\t\t{\n\t\t\t\t//如果后继节点还为空，那不防把当前节点认为就是后继\n\t\t\t\tnextnode = currnode;\n\t\t\t}\n\t\t\telse //nextnode不为空\n\t\t\t{\n\t\t\t\t//既然是找后继，那自然是找到比要找的值大的 一系列节点中 值最小的\n\t\t\t\tif (nextnode-&gt;data &gt; currnode-&gt;data)\n\t\t\t\t{\n\t\t\t\t\tnextnode = currnode; //后继自然是找一堆 比当前值大的 值中 最小的一个。\n\t\t\t\t}\n\t\t\t}\n\t\t\t//(2)继续逼近要找的节点，一直到找到要找的节点，找到要找的节点后，要找的节点的右节点仍旧可能是后继\n\t\t\tcurrnode = currnode-&gt;leftChild;&nbsp; //当前节点大，所以往当前节点的左子树转\n\t\t}\n\n\t\telse if (currnode-&gt;data &lt; findnode-&gt;data) //当前节点值比要找的值小，所以当前节点肯定不会是要找的值的后继\n\t\t{\n\t\t\t//当前节点小，所以往当前节点的右子树转\n\t\t\tcurrnode = currnode-&gt;rightChild;\n\t\t}\n\t\t\t\n\t\telse //(currnode-&gt;data == findnode-&gt;data)&nbsp;\n\t\t{\n\t\t\t//当前节点值&nbsp; 就是要找的节点值，那么 后继也可能在当前节点的右子树中，所以往右子树转继续找看有没有更合适的后继\n\t\t\tcurrnode = currnode-&gt;rightChild;\n\t\t}\n\t} //end while\n\treturn nextnode;\n}\n</code></pre><h2>二叉查找树的实际应用</h2><p>在上面的范例中，二叉查找树中保存的都是数字，而在实际的开发中，二叉查找树中保存的都是一个结构对象。一般都是<strong>利用结构对象中某个字段作为键<span class=\"reference\">（key）</span>来创建二叉查找树</strong>。利用这个键就可以迅速找到这个结构对象，从而取得该对象中的其他数据，这些其他数据叫卫星数据。</p><p>换句话说，传递给BinaryTreeNode类模板的数据元素类型T，一般是下面这样的一个结构，而不是int类型。</p><pre><code class=\"language-plain\">template &lt;typename KEY&gt; //KEY代表键(key)的类型，比如可以是一个int类型\nstruct ObjType\n{\n\tKEY&nbsp; key;&nbsp; &nbsp;//关键字\n\t//.....其他各种必要的数据字段\n\t//.....\n};\n</code></pre><p>后续定义一个二叉查找树对象。</p><pre><code class=\"language-plain\">BinarySearchTree&lt; ObjType&lt;int&gt; &gt; mybtr2;\n</code></pre><p>当然，可能需要对代码做出相应的调整或扩展，相信你可以自行完成。</p><h2>二叉查找树如何存储重复节点</h2><p>在前面的范例中，当要插入的数据<span class=\"reference\">（键）</span>与当前树中某节点的数据相同，那么就不允许插入了。但如果希望能够插入，该怎样做呢？一般有两种解决办法。</p><p>第一种，<strong>扩充二叉查找树的每个节点</strong>。例如把每个节点扩充成一种链表或动态数组的形式。这样，每个节点就可以存储多个key值相同的数据。</p><p>第二种，插入数据时，遇到相同的节点数据，就<strong>将该数据当做大于当前已经存在的节点的数据来处理，放入当前已经存在的节点的rightChild</strong><strong>，</strong>当做小于当前已经存在的节点的数据来处理，放入已经存在的节点的leftChild也可以。当然，这需要对插入元素的代码做出调整。</p><p>当查找某个节点时，即便遇到了值相同的节点，也不能停止查找，而是要继续在右子树<span class=\"reference\">（或左子树）</span>中查找，一直到寻找到的节点是叶子为止。当删除某个节点时，就要查到所有要删除的节点，然后逐个删除。</p><h2>二叉查找树时间复杂度分析</h2><p>我们前面说过，二叉查找树的意义在于实现快速查找。无论对二叉查找树做何种操作，首先把进行操作的节点找到才是最重要的。因此，这里的时间复杂度分析主要针对的是节点的查找操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/37/e5e1b7020c0c8006bec89141aa483f37.jpg?wh=2284x1147\" alt=\"\" title=\"图7 相同的中序遍历序列构造出的两种不同的二叉查找树\"></p><p>先说<strong>查找长度</strong>。在查找操作中，需要对比的节点次数就是查找长度，它反映了查找操作的时间复杂度。</p><p>图7的左侧是一棵满二叉树，如果要查找50这个节点，则需要分别与60、40、50这三个节点做对比，这意味着50这个节点的查找长度为3。而图7右侧这棵失衡的二叉树<span class=\"reference\">（斜树）</span>，要查找50这个节点，则需要分别与90、80、70、60、50这5个节点做对比，这意味着50这个节点的查找长度为5。</p><p>我们再引申到<strong>平均查找长度ASL</strong><span class=\"reference\">（Average Search Length）</span>。它可以用来衡量整个二叉查找树的查找效率。</p><ul>\n<li>\n<p>图7左侧图，查找节点60，查找长度为1，如果查找40、80这两个节点，查找长度为2，如果查找30、50、70、90这四个节点，查找长度为3。又因为图中有7个节点，所以所有节点的平均查找长度ASL = （1*1 + 2*2 + 3*4）/ 7 = 2.42。</p>\n</li>\n<li>\n<p>图7右侧图，同理，ASL = （1*1 + 2*1 + 3*1 +4*1 + 5*1 + 6*1 + 7*1）/ 7 = 4。</p>\n</li>\n</ul><p>可以看到，虽然图中2棵二叉查找树存储的数据相同，但<strong>左侧的查找效率<strong><strong>显然</strong></strong>更高</strong>。</p><p>刚刚是查找节点成功时的平均查找长度，那么查找节点失败时的平均查找长度该如何计算呢？我们将图中的二叉树变为扩展二叉树。</p><p><img src=\"https://static001.geekbang.org/resource/image/3a/08/3a8085b7c98de7a8c039da37b5932a08.jpg?wh=2284x1314\" alt=\"\" title=\"图8 相同的中序遍历序列构造出的两种不同的二叉查找树的扩展二叉树\"></p><p>可以看到，如果查找失败，则最终的查找位置会停留在带有#标记的扩展节点上。</p><ul>\n<li>图8左侧图，带有#标记的扩展节点一共是8个，也就是说查找节点时需要对比的3次节点值的情形是8种。所以查找节点失败时的平均查找长度ASL = （3*8）/ 8 = 3。</li>\n<li>图8右侧图，带有#标记的扩展节点一共是8个，同理，查找节点时需要对比1次节点值的情形是1种，需要对比2次节点值的情形是1种，以此类推。所以查找节点失败时的平均查找长度ASL = （1*1+2*1+3*1+4*1+5*1+6*1+7*2）/8 = 4.375。</li>\n</ul><p>显然，即便是查找节点失败时的平均查找长度，图7左侧二叉查找树的查找效率也是更高的。</p><p>不难看出，<strong>查找长度与树的高度是成正比的</strong>，也就是说，二叉查找树的查找效率主要取决于树的高度。在查找操作中，需要对比的节点次数一定不会超过该树的高度。</p><ul>\n<li>\n<p>如果是一棵满二叉树或者完全二叉树，那么根据二叉树的性质五，该二叉树的高度为⌊$log_{2}^{n}$⌋ +1。换句话说，对于有n个节点的二叉树，它的最小高度是⌊$log_{2}^{n}$⌋ +1，这意味着查找操作最好情况时间复杂度为O($log_{2}^{n}$)<span class=\"reference\">（n代表该二叉树的节点数量）</span>。</p>\n</li>\n<li>\n<p>如果一棵二叉树的高度和节点数相同，也就是一棵斜树，其高度为n，这意味着查找操作最坏情况时间复杂度为O(n), 看起来已经是一个链表了。</p>\n</li>\n</ul><p>那么为了提高查找效率，应该尽可能地让二叉查找树的高度变得最小<span class=\"reference\">（尽可能接近⌊$log_{2}^{n}$⌋ +1）</span>。也就是说，在创建二叉查找树时，应该尽可能让该二叉查找树保持左右节点的平衡，从而引出平衡二叉树的概念。所谓平衡二叉树，就是该树上任意节点的左子树和右子树深度之差不超过1。</p><h2>小结</h2><p>这节课，我们从二叉查找树的概念入手，了解了它的常见操作、具体应用以及优化方向。接下来我从代码记忆以及应用层面分别做个总结。</p><p>代码方面，我们实现了数据的插入、查找、删除操作，以及一些常见的找节点操作。插入操作需要我们首先找到正确的插入位置，之后的查找操作代码和它有一定的类似之处，可以通过对比的方式去记忆。其中，只有删除操作相对复杂，建议你结合配图理解后再去记忆。</p><p>应用方面，一方面，和我们初学二叉树时的例子不同，二叉树通常会保存一个结构对象。那么我们就可以<strong>利用结构对象中某个字段作为键<span class=\"reference\">（key）</span>来创建二叉查找树</strong>，再利用这个键迅速找到结构对象，从而取得该对象中的其他数据。</p><p>另一方面，我们既然无法避免存储重复节点，那也可以选择<strong>扩充二叉查找树的每个节点</strong>，将其扩充成一种链表或动态数组的形式或<strong>将数据当做大于当前已经存在的节点的数据来处理，放入当前已经存在的节点的rightChild</strong>。</p><p>回归到二叉查找树的初衷，既然要提升查找速度，就需要让二叉查找树的高度尽量变小，保持左右节点的平衡。</p><p>平衡，又是如何做到的？它真的有这么重要吗？下节课，我们就一起聊一聊“平衡”这件事。</p><h2>归纳思考</h2><p>请尝试用非递归算法来实现插入操作。提示：考虑用while循环，代码相对繁琐一些但并不复杂。</p><p>欢迎你在留言区分享自己的成果，如果觉得有所收获，也可以把课程分享给更多的朋友一起交流学习。我们下节课见。</p>","neighbors":{"left":{"article_title":"13｜线索二叉树：如何线索化二叉树以提升访问速度？","id":638954},"right":{"article_title":"15｜平衡二叉树（AVL）：平衡如此重要，怎么做到的？","id":641043}},"comments":[{"had_liked":false,"id":377859,"user_name":"鲁米","can_delete":false,"product_type":"c1","uid":1574008,"ip_address":"北京","ucode":"F8F23431723F25","user_header":"https://static001.geekbang.org/account/avatar/00/18/04/78/37b46ba6.jpg","comment_is_top":false,"comment_ctime":1689382730,"is_pvip":false,"replies":[{"id":137809,"content":"建议把老师的代码调试起来看看程序是如何处理的","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1689821680,"ip_address":"广东","comment_id":377859,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"这咋都没留言了？老师删除代码怎样理解边界值？比如说 根结点的删除，最左&#47;右下节点的删除。","like_count":1,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623773,"discussion_content":"建议把老师的代码调试起来看看程序是如何处理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689821681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437884,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f0/bc/65543e09.jpg","nickname":"铁甲依然在","note":"","ucode":"7487E704441849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630713,"discussion_content":"是为了找出共同点，统一删除叶子节点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698808713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}