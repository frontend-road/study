{"id":384772,"title":"17 | 划分土地（中）：如何实现内存页面初始化？","content":"<p>你好，我是LMOS。</p><p>上节课，我们确定了用分页方式管理内存，并且一起动手设计了表示内存页、内存区相关的内存管理数据结构。不过，虽然内存管理相关的数据结构已经定义好了，但是我们还没有在内存中建立对应的<strong>实例变量</strong>。</p><p>我们都知道，在代码中实际操作的数据结构必须在内存中有相应的变量，这节课我们就去建立对应的实例变量，并初始化它们。</p><h2>初始化</h2><p>前面的课里，我们在hal层初始化中，初始化了从二级引导器中获取的内存布局信息，也就是那个<strong>e820map_t数组</strong>，并把这个数组转换成了phymmarge_t结构数组，还对它做了排序。</p><p>但是，我们Cosmos物理内存管理器剩下的部分还没有完成初始化，下面我们就去实现它。</p><p>Cosmos的物理内存管理器，我们依然要放在Cosmos的hal层。</p><p>因为物理内存还和硬件平台相关，所以我们要在cosmos/hal/x86/目录下建立一个memmgrinit.c文件，在这个文件中写入一个Cosmos物理内存管理器初始化的大总管——init_memmgr函数，并在init_halmm函数中调用它，代码如下所示。</p><pre><code>//cosmos/hal/x86/halmm.c中\n//hal层的内存初始化函数\nvoid init_halmm()\n{\n    init_phymmarge();\n    init_memmgr();\n    return;\n}\n//Cosmos物理内存管理器初始化\nvoid init_memmgr()\n{\n    //初始化内存页结构msadsc_t\n    //初始化内存区结构memarea_t\n    return;\n}\n</code></pre><p>根据前面我们对内存管理相关数据结构的设计，你应该不难想到，在init_memmgr函数中应该要完成<strong>内存页结构msadsc_t和内存区结构memarea_t的初始化</strong>，下面就分别搞定这两件事。</p><!-- [[[read_end]]] --><h3>内存页结构初始化</h3><p>内存页结构的初始化，其实就是初始化msadsc_t结构对应的变量。因为一个msadsc_t结构体变量代表一个物理内存页，而物理内存由多个页组成，所以最终会形成一个msadsc_t结构体数组。</p><p>这会让我们的工作变得简单，我们只需要找一个内存地址，作为msadsc_t结构体数组的开始地址，当然这个内存地址必须是可用的，而且之后内存空间足以存放msadsc_t结构体数组。</p><p>然后，我们要扫描phymmarge_t结构体数组中的信息，只要它的类型是可用内存，就建立一个msadsc_t结构体，并把其中的开始地址作为第一个页面地址。</p><p>接着，要给这个开始地址加上0x1000，如此循环，直到其结束地址。</p><p>当这个phymmarge_t结构体的地址区间，它对应的所有msadsc_t结构体都建立完成之后，就开始下一个phymmarge_t结构体。依次类推，最后，我们就能建好所有可用物理内存页面对应的msadsc_t结构体。</p><p>下面，我们去cosmos/hal/x86/目录下建立一个msadsc.c文件。在这里写下完成这些功能的代码，如下所示。</p><pre><code>void write_one_msadsc(msadsc_t *msap, u64_t phyadr)\n{\n    //对msadsc_t结构做基本的初始化，比如链表、锁、标志位\n    msadsc_t_init(msap);\n    //这是把一个64位的变量地址转换成phyadrflgs_t*类型方便取得其中的地址位段\n    phyadrflgs_t *tmp = (phyadrflgs_t *)(&amp;phyadr);\n    //把页的物理地址写入到msadsc_t结构中\n    msap-&gt;md_phyadrs.paf_padrs = tmp-&gt;paf_padrs;\n    return;\n}\n\nu64_t init_msadsc_core(machbstart_t *mbsp, msadsc_t *msavstart, u64_t msanr)\n{\n    //获取phymmarge_t结构数组开始地址\n    phymmarge_t *pmagep = (phymmarge_t *)phyadr_to_viradr((adr_t)mbsp-&gt;mb_e820expadr);\n    u64_t mdindx = 0;\n    //扫描phymmarge_t结构数组\n    for (u64_t i = 0; i &lt; mbsp-&gt;mb_e820exnr; i++)\n    {\n        //判断phymmarge_t结构的类型是不是可用内存\n        if (PMR_T_OSAPUSERRAM == pmagep[i].pmr_type)\n        {\n            //遍历phymmarge_t结构的地址区间\n            for (u64_t start = pmagep[i].pmr_saddr; start &lt; pmagep[i].pmr_end; start += 4096)\n            {\n                //每次加上4KB-1比较是否小于等于phymmarge_t结构的结束地址\n                if ((start + 4096 - 1) &lt;= pmagep[i].pmr_end)\n                {\n                    //与当前地址为参数写入第mdindx个msadsc结构\n                    write_one_msadsc(&amp;msavstart[mdindx], start);\n                    mdindx++;\n                }\n            }\n        }\n    }\n    return mdindx;\n}\n\nvoid init_msadsc()\n{\n    u64_t coremdnr = 0, msadscnr = 0;\n    msadsc_t *msadscvp = NULL;\n    machbstart_t *mbsp = &amp;kmachbsp;\n    //计算msadsc_t结构数组的开始地址和数组元素个数\n    if (ret_msadsc_vadrandsz(mbsp, &amp;msadscvp, &amp;msadscnr) == FALSE)\n    {\n        system_error(&quot;init_msadsc ret_msadsc_vadrandsz err\\n&quot;);\n    }\n    //开始真正初始化msadsc_t结构数组\n    coremdnr = init_msadsc_core(mbsp, msadscvp, msadscnr);\n    if (coremdnr != msadscnr)\n    {\n        system_error(&quot;init_msadsc init_msadsc_core err\\n&quot;);\n    }\n    //将msadsc_t结构数组的开始的物理地址写入kmachbsp结构中 \n    mbsp-&gt;mb_memmappadr = viradr_to_phyadr((adr_t)msadscvp);\n    //将msadsc_t结构数组的元素个数写入kmachbsp结构中 \n    mbsp-&gt;mb_memmapnr = coremdnr;\n    //将msadsc_t结构数组的大小写入kmachbsp结构中 \n    mbsp-&gt;mb_memmapsz = coremdnr * sizeof(msadsc_t);\n    //计算下一个空闲内存的开始地址 \n    mbsp-&gt;mb_nextwtpadr = PAGE_ALIGN(mbsp-&gt;mb_memmappadr + mbsp-&gt;mb_memmapsz);\n    return;\n}\n</code></pre><p>上面的代码量很少，逻辑也很简单，再配合注释，相信你看得懂。其中的ret_msadsc_vadrandsz函数也是遍历phymmarge_t结构数组，计算出有多大的可用内存空间，可以分成多少个页面，需要多少个msadsc_t结构。</p><h3>内存区结构初始化</h3><p>前面我们将整个物理地址空间在逻辑上分成了三个区，分别是<strong>：硬件区、内核区、用户区</strong>，这就要求我们要在内存中建立三个memarea_t结构体的实例变量。</p><p>就像建立msadsc_t结构数组一样，我们只需要在内存中找个空闲空间，存放这三个memarea_t结构体就行。相比建立msadsc_t结构数组这更为简单，因为memarea_t结构体是顶层结构，并不依赖其它数据结构，只是对其本身进行初始化就好了。</p><p>但是由于它自身包含了其它数据结构，在初始化它时，要对其中的其它数据结构进行初始化，所以要小心一些。</p><p>下面我们去cosmos/hal/x86/目录下建立一个memarea.c文件，写下完成这些功能的代码，如下所示。</p><pre><code>void bafhlst_t_init(bafhlst_t *initp, u32_t stus, uint_t oder, uint_t oderpnr)\n{\n    //初始化bafhlst_t结构体的基本数据\n    knl_spinlock_init(&amp;initp-&gt;af_lock);\n    initp-&gt;af_stus = stus;\n    initp-&gt;af_oder = oder;\n    initp-&gt;af_oderpnr = oderpnr;\n    initp-&gt;af_fobjnr = 0;\n    initp-&gt;af_mobjnr = 0;\n    initp-&gt;af_alcindx = 0;\n    initp-&gt;af_freindx = 0;\n    list_init(&amp;initp-&gt;af_frelst);\n    list_init(&amp;initp-&gt;af_alclst);\n    list_init(&amp;initp-&gt;af_ovelst);\n    return;\n}\n\nvoid memdivmer_t_init(memdivmer_t *initp)\n{\n    //初始化medivmer_t结构体的基本数据\n    knl_spinlock_init(&amp;initp-&gt;dm_lock);\n    initp-&gt;dm_stus = 0;\n    initp-&gt;dm_divnr = 0;\n    initp-&gt;dm_mernr = 0;\n    //循环初始化memdivmer_t结构体中dm_mdmlielst数组中的每个bafhlst_t结构的基本数据\n    for (uint_t li = 0; li &lt; MDIVMER_ARR_LMAX; li++)\n    {\n        bafhlst_t_init(&amp;initp-&gt;dm_mdmlielst[li], BAFH_STUS_DIVM, li, (1UL &lt;&lt; li));\n    }\n    bafhlst_t_init(&amp;initp-&gt;dm_onemsalst, BAFH_STUS_ONEM, 0, 1UL);\n    return;\n}\n\nvoid memarea_t_init(memarea_t *initp)\n{\n    //初始化memarea_t结构体的基本数据\n    list_init(&amp;initp-&gt;ma_list);\n    knl_spinlock_init(&amp;initp-&gt;ma_lock);\n    initp-&gt;ma_stus = 0;\n    initp-&gt;ma_flgs = 0;\n    initp-&gt;ma_type = MA_TYPE_INIT;\n    initp-&gt;ma_maxpages = 0;\n    initp-&gt;ma_allocpages = 0;\n    initp-&gt;ma_freepages = 0;\n    initp-&gt;ma_resvpages = 0;\n    initp-&gt;ma_horizline = 0;\n    initp-&gt;ma_logicstart = 0;\n    initp-&gt;ma_logicend = 0;\n    initp-&gt;ma_logicsz = 0;\n    //初始化memarea_t结构体中的memdivmer_t结构体\n    memdivmer_t_init(&amp;initp-&gt;ma_mdmdata);\n    initp-&gt;ma_privp = NULL;\n    return;\n}\n\nbool_t init_memarea_core(machbstart_t *mbsp)\n{\n    //获取memarea_t结构开始地址\n    u64_t phymarea = mbsp-&gt;mb_nextwtpadr;\n    //检查内存空间够不够放下MEMAREA_MAX个memarea_t结构实例变量\n    if (initchkadr_is_ok(mbsp, phymarea, (sizeof(memarea_t) * MEMAREA_MAX)) != 0)\n    {\n        return FALSE;\n    }\n    memarea_t *virmarea = (memarea_t *)phyadr_to_viradr((adr_t)phymarea);\n    for (uint_t mai = 0; mai &lt; MEMAREA_MAX; mai++)\n    {   //循环初始化每个memarea_t结构实例变量\n        memarea_t_init(&amp;virmarea[mai]);\n    }\n    //设置硬件区的类型和空间大小\n    virmarea[0].ma_type = MA_TYPE_HWAD;\n    virmarea[0].ma_logicstart = MA_HWAD_LSTART;\n    virmarea[0].ma_logicend = MA_HWAD_LEND;\n    virmarea[0].ma_logicsz = MA_HWAD_LSZ;\n    //设置内核区的类型和空间大小\n    virmarea[1].ma_type = MA_TYPE_KRNL;\n    virmarea[1].ma_logicstart = MA_KRNL_LSTART;\n    virmarea[1].ma_logicend = MA_KRNL_LEND;\n    virmarea[1].ma_logicsz = MA_KRNL_LSZ;\n    //设置应用区的类型和空间大小\n    virmarea[2].ma_type = MA_TYPE_PROC;\n    virmarea[2].ma_logicstart = MA_PROC_LSTART;\n    virmarea[2].ma_logicend = MA_PROC_LEND;\n    virmarea[2].ma_logicsz = MA_PROC_LSZ;\n    //将memarea_t结构的开始的物理地址写入kmachbsp结构中 \n    mbsp-&gt;mb_memznpadr = phymarea;\n    //将memarea_t结构的个数写入kmachbsp结构中 \n    mbsp-&gt;mb_memznnr = MEMAREA_MAX;\n    //将所有memarea_t结构的大小写入kmachbsp结构中 \n    mbsp-&gt;mb_memznsz = sizeof(memarea_t) * MEMAREA_MAX;\n    //计算下一个空闲内存的开始地址 \n    mbsp-&gt;mb_nextwtpadr = PAGE_ALIGN(phymarea + sizeof(memarea_t) * MEMAREA_MAX);\n    return TRUE;\n}\n//初始化内存区\nvoid init_memarea()\n{\n    //真正初始化内存区\n    if (init_memarea_core(&amp;kmachbsp) == FALSE)\n    {\n        system_error(&quot;init_memarea_core fail&quot;);\n    }\n    return;\n}\n</code></pre><p>由于这些数据结构很大，所以代码有点长，但是重要的代码我都做了详细注释。</p><p>在init_memarea_core函数的开始，我们调用了memarea_t_init函数，对MEMAREA_MAX个memarea_t结构进行了基本的初始化。</p><p>然后，在memarea_t_init函数中又调用了memdivmer_t_init函数，而在memdivmer_t_init函数中又调用了bafhlst_t_init函数，这保证了那些被包含的数据结构得到了初始化。</p><p>最后，我们给三个区分别设置了类型和地址空间。</p><h3>处理初始内存占用问题</h3><p>我们初始化了内存页和内存区对应的数据结构，已经可以组织好内存页面了。现在看似已经万事俱备了，其实这有个重大的问题，你知道是什么吗？我给你分析一下。</p><p>目前我们的内存中已经有很多数据了，有Cosmos内核本身的执行文件，有字体文件，有MMU页表，有打包的内核映像文件，还有刚刚建立的内存页和内存区的数据结构，这些数据都要占用实际的物理内存。</p><p>再回头看看我们建立内存页结构msadsc_t，所有的都是空闲状态，而它们每一个都表示一个实际的物理内存页。</p><p>假如在这种情况下，对调用内存分配接口进行内存分配，<strong>它按既定的分配算法查找空闲的msadsc_t结构，那它一定会找到内核占用的内存页所对应的msadsc_t结构，并把这个内存页分配出去，然后得到这个页面的程序对其进行改写。这样内核数据就会被覆盖，这种情况是我们绝对不能允许的。</strong></p><p>所以，我们要把这些已经占用的内存页面所对应的msadsc_t结构标记出来，标记成<strong>已分配</strong>，这样内存分配算法就不会找到它们了。</p><p>要解决这个问题，我们只要给出被占用内存的起始地址和结束地址，然后从起始地址开始查找对应的msadsc_t结构，再把它标记为已经分配，最后直到查找到结束地址为止。</p><p>下面我们在msadsc.c文件中来实现这个方案，代码如下。</p><pre><code>//搜索一段内存地址空间所对应的msadsc_t结构\nu64_t search_segment_occupymsadsc(msadsc_t *msastart, u64_t msanr, u64_t ocpystat, u64_t ocpyend)\n{\n    u64_t mphyadr = 0, fsmsnr = 0;\n    msadsc_t *fstatmp = NULL;\n    for (u64_t mnr = 0; mnr &lt; msanr; mnr++)\n    {\n        if ((msastart[mnr].md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE) == ocpystat)\n        {\n            //找出开始地址对应的第一个msadsc_t结构，就跳转到step1\n            fstatmp = &amp;msastart[mnr];\n            goto step1;\n        }\n    }\nstep1:\n    fsmsnr = 0;\n    if (NULL == fstatmp)\n    {\n        return 0;\n    }\n    for (u64_t tmpadr = ocpystat; tmpadr &lt; ocpyend; tmpadr += PAGESIZE, fsmsnr++)\n    {\n        //从开始地址对应的第一个msadsc_t结构开始设置，直到结束地址对应的最后一个masdsc_t结构\n        mphyadr = fstatmp[fsmsnr].md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;\n        if (mphyadr != tmpadr)\n        {\n            return 0;\n        }\n        if (MF_MOCTY_FREE != fstatmp[fsmsnr].md_indxflgs.mf_mocty ||\n            0 != fstatmp[fsmsnr].md_indxflgs.mf_uindx ||\n            PAF_NO_ALLOC != fstatmp[fsmsnr].md_phyadrs.paf_alloc)\n        {\n            return 0;\n        }\n        //设置msadsc_t结构为已经分配，已经分配给内核\n        fstatmp[fsmsnr].md_indxflgs.mf_mocty = MF_MOCTY_KRNL;\n        fstatmp[fsmsnr].md_indxflgs.mf_uindx++;\n        fstatmp[fsmsnr].md_phyadrs.paf_alloc = PAF_ALLOC;\n    }\n    //进行一些数据的正确性检查\n    u64_t ocpysz = ocpyend - ocpystat;\n    if ((ocpysz &amp; 0xfff) != 0)\n    {\n        if (((ocpysz &gt;&gt; PSHRSIZE) + 1) != fsmsnr)\n        {\n            return 0;\n        }\n        return fsmsnr;\n    }\n    if ((ocpysz &gt;&gt; PSHRSIZE) != fsmsnr)\n    {\n        return 0;\n    }\n    return fsmsnr;\n}\n\n\nbool_t search_krloccupymsadsc_core(machbstart_t *mbsp)\n{\n    u64_t retschmnr = 0;\n    msadsc_t *msadstat = (msadsc_t *)phyadr_to_viradr((adr_t)mbsp-&gt;mb_memmappadr);\n    u64_t msanr = mbsp-&gt;mb_memmapnr;\n    //搜索BIOS中断表占用的内存页所对应msadsc_t结构\n    retschmnr = search_segment_occupymsadsc(msadstat, msanr, 0, 0x1000);\n    if (0 == retschmnr)\n    {\n        return FALSE;\n    }\n    //搜索内核栈占用的内存页所对应msadsc_t结构\n    retschmnr = search_segment_occupymsadsc(msadstat, msanr, mbsp-&gt;mb_krlinitstack &amp; (~(0xfffUL)), mbsp-&gt;mb_krlinitstack);\n    if (0 == retschmnr)\n    {\n        return FALSE;\n    }\n    //搜索内核占用的内存页所对应msadsc_t结构\n    retschmnr = search_segment_occupymsadsc(msadstat, msanr, mbsp-&gt;mb_krlimgpadr, mbsp-&gt;mb_nextwtpadr);\n    if (0 == retschmnr)\n    {\n        return FALSE;\n    }\n    //搜索内核映像文件占用的内存页所对应msadsc_t结构\n    retschmnr = search_segment_occupymsadsc(msadstat, msanr, mbsp-&gt;mb_imgpadr, mbsp-&gt;mb_imgpadr + mbsp-&gt;mb_imgsz);\n    if (0 == retschmnr)\n    {\n        return FALSE;\n    }\n    return TRUE;\n}\n//初始化搜索内核占用的内存页面\nvoid init_search_krloccupymm(machbstart_t *mbsp)\n{\n    //实际初始化搜索内核占用的内存页面\n    if (search_krloccupymsadsc_core(mbsp) == FALSE)\n    {\n        system_error(&quot;search_krloccupymsadsc_core fail\\n&quot;);\n    }\n    return;\n}\n</code></pre><p>这三个函数逻辑很简单，由init_search_krloccupymm函数入口，search_krloccupymsadsc_core函数驱动，由search_segment_occupymsadsc函数完成实际的工作。</p><p>由于初始化阶段各种数据占用的开始、结束地址和大小，这些信息都保存在machbstart_t类型的kmachbsp变量中，所以函数与machbstart_t类型的指针为参数。</p><p>其实phymmarge_t、msadsc_t、memarea_t这些结构的实例变量和MMU页表，它们所占用的内存空间已经涵盖在了内核自身占用的内存空间。</p><p>好了，这个问题我们已经完美解决，只要在初始化内存页结构和内存区结构之后调用init_search_krloccupymm函数即可。</p><h3>合并内存页到内存区</h3><p>我们做了这么多前期工作，依然没有让内存页和内存区联系起来，即让msadsc_t结构挂载到内存区对应的数组中。只有这样，我们才能提高内存管理器的分配速度。</p><p>让我们来着手干这件事情，这件事情有点复杂，但是我给你梳理以后就会清晰很多。整体上可以分成两步。</p><p>1.<strong>确定内存页属于哪个区</strong>，即标定一系列msadsc_t结构是属于哪个memarea_t结构的。<br>\n2.<strong>把特定的内存页合并</strong>，然后挂载到特定的内存区下的memdivmer_t结构中的dm_mdmlielst数组中。</p><p>我们先来做第一件事，这件事比较简单，我们只要遍历每个memarea_t结构，遍历过程中根据特定的memarea_t结构，然后去扫描整个msadsc_t结构数组，最后依次对比msadsc_t的物理地址，看它是否落在memarea_t结构的地址区间中。</p><p>如果是，就把这个memarea_t结构的类型值写入msadsc_t结构中，这样就一个一个打上了标签，遍历memarea_t结构结束之后，每个msadsc_t结构就只归属于某一个memarea_t结构了。</p><p>我们在memarea.c文件中写几个函数，来实现前面这个步骤，代码如下所示。</p><pre><code>//给msadsc_t结构打上标签\nuint_t merlove_setallmarflgs_onmemarea(memarea_t *mareap, msadsc_t *mstat, uint_t msanr)\n{\n    u32_t muindx = 0;\n    msadflgs_t *mdfp = NULL;\n    //获取内存区类型\n    switch (mareap-&gt;ma_type){\n    case MA_TYPE_HWAD:\n        muindx = MF_MARTY_HWD &lt;&lt; 5;//硬件区标签\n        mdfp = (msadflgs_t *)(&amp;muindx);\n        break;\n    case MA_TYPE_KRNL:\n        muindx = MF_MARTY_KRL &lt;&lt; 5;//内核区标签\n        mdfp = (msadflgs_t *)(&amp;muindx);\n        break;\n    case MA_TYPE_PROC:\n        muindx = MF_MARTY_PRC &lt;&lt; 5;//应用区标签\n        mdfp = (msadflgs_t *)(&amp;muindx);\n        break;\n    }\n    u64_t phyadr = 0;\n    uint_t retnr = 0;\n    //扫描所有的msadsc_t结构\n    for (uint_t mix = 0; mix &lt; msanr; mix++)\n    {\n        if (MF_MARTY_INIT == mstat[mix].md_indxflgs.mf_marty)\n        {    //获取msadsc_t结构对应的地址\n            phyadr = mstat[mix].md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;\n            //和内存区的地址区间比较 \n            if (phyadr &gt;= mareap-&gt;ma_logicstart &amp;&amp; ((phyadr + PAGESIZE) - 1) &lt;= mareap-&gt;ma_logicend)\n            {\n                //设置msadsc_t结构的标签\n                mstat[mix].md_indxflgs.mf_marty = mdfp-&gt;mf_marty;\n                retnr++;\n            }\n        }\n    }\n    return retnr;\n}\n\nbool_t merlove_mem_core(machbstart_t *mbsp)\n{\n    //获取msadsc_t结构的首地址\n    msadsc_t *mstatp = (msadsc_t *)phyadr_to_viradr((adr_t)mbsp-&gt;mb_memmappadr);\n    //获取msadsc_t结构的个数\n    uint_t msanr = (uint_t)mbsp-&gt;mb_memmapnr, maxp = 0;\n    //获取memarea_t结构的首地址\n    memarea_t *marea = (memarea_t *)phyadr_to_viradr((adr_t)mbsp-&gt;mb_memznpadr);\n    uint_t sretf = ~0UL, tretf = ~0UL;\n    //遍历每个memarea_t结构\n    for (uint_t mi = 0; mi &lt; (uint_t)mbsp-&gt;mb_memznnr; mi++)\n    {\n        //针对其中一个memarea_t结构给msadsc_t结构打上标签\n        sretf = merlove_setallmarflgs_onmemarea(&amp;marea[mi], mstatp, msanr);\n        if ((~0UL) == sretf)\n        {\n            return FALSE;\n        }\n    }\n     //遍历每个memarea_t结构\n    for (uint_t maidx = 0; maidx &lt; (uint_t)mbsp-&gt;mb_memznnr; maidx++)\n    {\n        //针对其中一个memarea_t结构对msadsc_t结构进行合并\n        if (merlove_mem_onmemarea(&amp;marea[maidx], mstatp, msanr) == FALSE)\n        {\n            return FALSE;\n        }\n        maxp += marea[maidx].ma_maxpages;\n    }\n    return TRUE;\n}\n//初始化页面合并\nvoid init_merlove_mem()\n{\n    if (merlove_mem_core(&amp;kmachbsp) == FALSE)\n    {\n        system_error(&quot;merlove_mem_core fail\\n&quot;);\n    }\n    return;\n}\n</code></pre><p>我们一下子写了三个函数，它们的作用且听我一一道来。从init_merlove_mem函数开始，但是它并不实际干活，作为入口函数，它调用的merlove_mem_core函数才是真正干活的。</p><p>这个merlove_mem_core函数有两个遍历内存区，第一次遍历是为了完成上述第一步：确定内存页属于哪个区。</p><p>当确定内存页属于哪个区之后，就来到了第二次遍历memarea_t结构，合并其中的msadsc_t结构，并把它们挂载到其中的memdivmer_t结构下的dm_mdmlielst数组中。</p><p>这个操作就稍微有点复杂了。<strong>第一，它要保证其中所有的msadsc_t结构挂载到dm_mdmlielst数组中合适的bafhlst_t结构中。</strong></p><p><strong>第二，它要保证多个msadsc_t结构有最大的连续性。</strong></p><p>举个例子，比如一个内存区中有12个页面，其中10个页面是连续的地址为0～0x9000，还有两个页面其中一个地址为0xb000，另一个地址为0xe000。</p><p>这样的情况下，需要多个页面保持最大的连续性，还有在m_mdmlielst数组中找到合适的bafhlst_t结构。</p><p>那么：0～0x7000这8个页面就要挂载到m_mdmlielst数组中第3个bafhlst_t结构中；0x8000～0x9000这2个页面要挂载到m_mdmlielst数组中第1个bafhlst_t结构中，而0xb000和0xe000这2个页面都要挂载到m_mdmlielst数组中第0个bafhlst_t结构中。</p><p>从上述代码可以看出，遍历每个内存区，然后针对其中每一个内存区进行msadsc_t结构的合并操作，完成这个操作的是<strong>merlove_mem_onmemarea</strong>，我们这就去写好这个函数，代码如下所示。</p><pre><code>bool_t continumsadsc_add_bafhlst(memarea_t *mareap, bafhlst_t *bafhp, msadsc_t *fstat, msadsc_t *fend, uint_t fmnr)\n{\n    fstat-&gt;md_indxflgs.mf_olkty = MF_OLKTY_ODER;\n    //开始的msadsc_t结构指向最后的msadsc_t结构 \n    fstat-&gt;md_odlink = fend;\n    fend-&gt;md_indxflgs.mf_olkty = MF_OLKTY_BAFH;\n    //最后的msadsc_t结构指向它属于的bafhlst_t结构 \n    fend-&gt;md_odlink = bafhp;\n    //把多个地址连续的msadsc_t结构的的开始的那个msadsc_t结构挂载到bafhlst_t结构的af_frelst中\n    list_add(&amp;fstat-&gt;md_list, &amp;bafhp-&gt;af_frelst);\n    //更新bafhlst_t的统计数据\n    bafhp-&gt;af_fobjnr++;\n    bafhp-&gt;af_mobjnr++;\n    //更新内存区的统计数据\n    mareap-&gt;ma_maxpages += fmnr;\n    mareap-&gt;ma_freepages += fmnr;\n    mareap-&gt;ma_allmsadscnr += fmnr;\n    return TRUE;\n}\n\nbool_t continumsadsc_mareabafh_core(memarea_t *mareap, msadsc_t **rfstat, msadsc_t **rfend, uint_t *rfmnr)\n{\n    uint_t retval = *rfmnr, tmpmnr = 0;\n    msadsc_t *mstat = *rfstat, *mend = *rfend;\n    //根据地址连续的msadsc_t结构的数量查找合适bafhlst_t结构\n    bafhlst_t *bafhp = find_continumsa_inbafhlst(mareap, retval);\n    //判断bafhlst_t结构状态和类型对不对\n    if ((BAFH_STUS_DIVP == bafhp-&gt;af_stus || BAFH_STUS_DIVM == bafhp-&gt;af_stus) &amp;&amp; MA_TYPE_PROC != mareap-&gt;ma_type)\n    {\n        //看地址连续的msadsc_t结构的数量是不是正好是bafhp-&gt;af_oderpnr\n        tmpmnr = retval - bafhp-&gt;af_oderpnr;\n        //根据地址连续的msadsc_t结构挂载到bafhlst_t结构中\n        if (continumsadsc_add_bafhlst(mareap, bafhp, mstat, &amp;mstat[bafhp-&gt;af_oderpnr - 1], bafhp-&gt;af_oderpnr) == FALSE)\n        {\n            return FALSE;\n        }\n        //如果地址连续的msadsc_t结构的数量正好是bafhp-&gt;af_oderpnr则完成，否则返回再次进入此函数 \n        if (tmpmnr == 0)\n        {\n            *rfmnr = tmpmnr;\n            *rfend = NULL;\n            return TRUE;\n        }\n        //挂载bafhp-&gt;af_oderpnr地址连续的msadsc_t结构到bafhlst_t中\n        *rfstat = &amp;mstat[bafhp-&gt;af_oderpnr];\n        //还剩多少个地址连续的msadsc_t结构\n        *rfmnr = tmpmnr;\n        return TRUE;\n    }\n    return FALSE;\n}\n\nbool_t merlove_continumsadsc_mareabafh(memarea_t *mareap, msadsc_t *mstat, msadsc_t *mend, uint_t mnr)\n{\n    uint_t mnridx = mnr;\n    msadsc_t *fstat = mstat, *fend = mend;\n    //如果mnridx &gt; 0并且NULL != fend就循环调用continumsadsc_mareabafh_core函数，而mnridx和fend由这个函数控制\n    for (; (mnridx &gt; 0 &amp;&amp; NULL != fend);)\n    {\n    //为一段地址连续的msadsc_t结构寻找合适m_mdmlielst数组中的bafhlst_t结构\n        continumsadsc_mareabafh_core(mareap, &amp;fstat, &amp;fend, &amp;mnridx)\n    }\n    return TRUE;\n}\n\n\nbool_t merlove_scan_continumsadsc(memarea_t *mareap, msadsc_t *fmstat, uint_t *fntmsanr, uint_t fmsanr,\n                                         msadsc_t **retmsastatp, msadsc_t **retmsaendp, uint_t *retfmnr)\n{\n    u32_t muindx = 0;\n    msadflgs_t *mdfp = NULL;\n\n    msadsc_t *msastat = fmstat;\n    uint_t retfindmnr = 0;\n    bool_t rets = FALSE;\n    uint_t tmidx = *fntmsanr;\n    //从外层函数的fntmnr变量开始遍历所有msadsc_t结构\n    for (; tmidx &lt; fmsanr; tmidx++)\n    {\n    //一个msadsc_t结构是否属于这个内存区，是否空闲\n        if (msastat[tmidx].md_indxflgs.mf_marty == mdfp-&gt;mf_marty &amp;&amp;\n            0 == msastat[tmidx].md_indxflgs.mf_uindx &amp;&amp;\n            MF_MOCTY_FREE == msastat[tmidx].md_indxflgs.mf_mocty &amp;&amp;\n            PAF_NO_ALLOC == msastat[tmidx].md_phyadrs.paf_alloc)\n        {\n        //返回从这个msadsc_t结构开始到下一个非空闲、地址非连续的msadsc_t结构对应的msadsc_t结构索引号到retfindmnr变量中\n            rets = scan_len_msadsc(&amp;msastat[tmidx], mdfp, fmsanr, &amp;retfindmnr);\n            //下一轮开始的msadsc_t结构索引\n            *fntmsanr = tmidx + retfindmnr + 1;\n            //当前地址连续msadsc_t结构的开始地址\n            *retmsastatp = &amp;msastat[tmidx];\n            //当前地址连续msadsc_t结构的结束地址\n            *retmsaendp = &amp;msastat[tmidx + retfindmnr];\n            //当前有多少个地址连续msadsc_t结构\n            *retfmnr = retfindmnr + 1;\n            return TRUE;\n        }\n    }\n    return FALSE;\n}\n\nbool_t merlove_mem_onmemarea(memarea_t *mareap, msadsc_t *mstat, uint_t msanr)\n{\n    msadsc_t *retstatmsap = NULL, *retendmsap = NULL, *fntmsap = mstat;\n    uint_t retfindmnr = 0;\n    uint_t fntmnr = 0;\n    bool_t retscan = FALSE;\n    \n    for (; fntmnr &lt; msanr;)\n    {\n        //获取最多且地址连续的msadsc_t结构体的开始、结束地址、一共多少个msadsc_t结构体，下一次循环的fntmnr\n        retscan = merlove_scan_continumsadsc(mareap, fntmsap, &amp;fntmnr, msanr, &amp;retstatmsap, &amp;retendmsap, &amp;retfindmnr);\n        if (NULL != retstatmsap &amp;&amp; NULL != retendmsap)\n        {\n        //把一组连续的msadsc_t结构体挂载到合适的m_mdmlielst数组中的bafhlst_t结构中\n        merlove_continumsadsc_mareabafh(mareap, retstatmsap, retendmsap, retfindmnr)\n        }\n    }\n    return TRUE;\n}\n</code></pre><p>为了节约篇幅，我删除了大量检查错误的代码，你可以在我提供的<a href=\"https://gitee.com/lmos/cosmos/blob/master/lesson16~18/Cosmos/hal/x86/memarea.c#L694\">源代码</a>里自行查看。</p><p>上述代码中，整体上分为两步。</p><p>第一步，通过merlove_scan_continumsadsc函数，返回最多且地址连续的msadsc_t结构体的开始、结束地址、一共多少个msadsc_t结构体，下一轮开始的msadsc_t结构体的索引号。</p><p>第二步，根据第一步获取的信息调用merlove_continumsadsc_mareabafh函数，把第一步返回那一组连续的msadsc_t结构体，挂载到合适的m_mdmlielst数组中的bafhlst_t结构中。详细的逻辑已经在注释中说明。</p><p>好，内存页已经按照规定的方式组织起来了，这表示物理内存管理器的初始化工作已经进入尾声。</p><h3>初始化汇总</h3><p>别急！先别急着写内存分配相关的代码。到目前为止，我们一起写了这么多的内存初始化相关的代码，但是我们没有调用它们。</p><p>根据前面内存管理数据结构的关系，很显然，<strong>它们的调用次序很重要，谁先谁后都有严格的规定，这关乎内存管理初始化的成败。</strong>所以，现在我们就在先前的init_memmgr函数中去调用它们，代码如下所示。</p><pre><code>void init_memmgr()\n{\n    //初始化内存页结构\n    init_msadsc();\n    //初始化内存区结构\n    init_memarea();\n    //处理内存占用\n    init_search_krloccupymm(&amp;kmachbsp);\n    //合并内存页到内存区中\n    init_merlove_mem();\n    init_memmgrob();\n    return;\n}\n</code></pre><p>上述代码中，init_msadsc、init_memarea函数是可以交换次序的，它们俩互不影响，但它们俩必须最先开始调用，而后面的函数要依赖它们生成的数据结构。</p><p>但是init_search_krloccupymm函数必须要在init_merlove_mem函数之前被调用，因为init_merlove_mem函数在合并页面时，必须先知道哪些页面被占用了。</p><p>等一等，init_memmgrob是什么函数，这个我们还没写呢。下面我们就来现实它。</p><p>不知道你发现没有，我们的phymmarge_t结构体的地址和数量、msadsc_t结构体的地址和数据、memarea_t结构体的地址和数量都保存在了kmachbsp变量中，这个变量其实不是用来管理内存的，而且它里面放的是<strong>物理地址</strong>。</p><p>但内核使用的是虚拟地址，每次都要转换极不方便，所以我们要设计一个专用的数据结构，用于内存管理。我们来定义一下这个结构，代码如下。</p><pre><code>//cosmos/include/halinc/halglobal.c\nHAL_DEFGLOB_VARIABLE(memmgrob_t,memmgrob);\n\ntypedef struct s_MEMMGROB\n{\n    list_h_t mo_list;\n    spinlock_t mo_lock;        //保护自身自旋锁\n    uint_t mo_stus;            //状态\n    uint_t mo_flgs;            //标志\n    u64_t mo_memsz;            //内存大小\n    u64_t mo_maxpages;         //内存最大页面数\n    u64_t mo_freepages;        //内存最大空闲页面数\n    u64_t mo_alocpages;        //内存最大分配页面数\n    u64_t mo_resvpages;        //内存保留页面数\n    u64_t mo_horizline;        //内存分配水位线\n    phymmarge_t* mo_pmagestat; //内存空间布局结构指针\n    u64_t mo_pmagenr;\n    msadsc_t* mo_msadscstat;   //内存页面结构指针\n    u64_t mo_msanr;\n    memarea_t* mo_mareastat;   //内存区结构指针 \n    u64_t mo_mareanr;\n}memmgrob_t;\n\n//cosmos/hal/x86/memmgrinit.c\n\nvoid memmgrob_t_init(memmgrob_t *initp)\n{\n    list_init(&amp;initp-&gt;mo_list);\n    knl_spinlock_init(&amp;initp-&gt;mo_lock);\n    initp-&gt;mo_stus = 0;\n    initp-&gt;mo_flgs = 0;\n    initp-&gt;mo_memsz = 0;\n    initp-&gt;mo_maxpages = 0;\n    initp-&gt;mo_freepages = 0;\n    initp-&gt;mo_alocpages = 0;\n    initp-&gt;mo_resvpages = 0;\n    initp-&gt;mo_horizline = 0;\n    initp-&gt;mo_pmagestat = NULL;\n    initp-&gt;mo_pmagenr = 0;\n    initp-&gt;mo_msadscstat = NULL;\n    initp-&gt;mo_msanr = 0;\n    initp-&gt;mo_mareastat = NULL;\n    initp-&gt;mo_mareanr = 0;\n    return;\n}\n\nvoid init_memmgrob()\n{\n    machbstart_t *mbsp = &amp;kmachbsp;\n    memmgrob_t *mobp = &amp;memmgrob;\n    memmgrob_t_init(mobp);\n    mobp-&gt;mo_pmagestat = (phymmarge_t *)phyadr_to_viradr((adr_t)mbsp-&gt;mb_e820expadr);\n    mobp-&gt;mo_pmagenr = mbsp-&gt;mb_e820exnr;\n    mobp-&gt;mo_msadscstat = (msadsc_t *)phyadr_to_viradr((adr_t)mbsp-&gt;mb_memmappadr);\n    mobp-&gt;mo_msanr = mbsp-&gt;mb_memmapnr;\n    mobp-&gt;mo_mareastat = (memarea_t *)phyadr_to_viradr((adr_t)mbsp-&gt;mb_memznpadr);\n    mobp-&gt;mo_mareanr = mbsp-&gt;mb_memznnr;\n    mobp-&gt;mo_memsz = mbsp-&gt;mb_memmapnr &lt;&lt; PSHRSIZE;\n    mobp-&gt;mo_maxpages = mbsp-&gt;mb_memmapnr;\n    uint_t aidx = 0;\n    for (uint_t i = 0; i &lt; mobp-&gt;mo_msanr; i++)\n    {\n        if (1 == mobp-&gt;mo_msadscstat[i].md_indxflgs.mf_uindx &amp;&amp;\n            MF_MOCTY_KRNL == mobp-&gt;mo_msadscstat[i].md_indxflgs.mf_mocty &amp;&amp;\n            PAF_ALLOC == mobp-&gt;mo_msadscstat[i].md_phyadrs.paf_alloc)\n        {\n            aidx++;\n        }\n    }\n    mobp-&gt;mo_alocpages = aidx;\n    mobp-&gt;mo_freepages = mobp-&gt;mo_maxpages - mobp-&gt;mo_alocpages;\n    return;\n}\n</code></pre><p>这些代码非常容易理解，我们就不再讨论了，无非是将内存管理核心数据结构的地址和数量放在其中，并计算了一些统计信息，这没有任何难度，相信你会轻松理解。</p><h2>重点回顾</h2><p>今天课程的重点工作是初始化我们设计的内存管理数据结构，在内存中建立它们的实例变量，我来为你梳理一下重点。</p><p>首先，我们从初始化msadsc_t结构开始，在内存中建立msadsc_t结构的实例变量，每个物理内存页面一个msadsc_t结构的实例变量。</p><p>然后是初始化memarea_t结构，在msadsc_t结构的实例变量之后，每个内存区一个memarea_t结构实例变量。</p><p>接着标记哪些msadsc_t结构对应的物理内存被内核占用了，这些被标记msadsc_t结构是不能纳入内存管理结构中去的。</p><p>最后，把所有的空闲msadsc_t结构按最大地址连续的形式组织起来，挂载到memarea_t结构下的memdivmer_t结构中，对应的dm_mdmlielst数组中。</p><p>不知道你是否想过，随着物理内存不断增加，msadsc_t结构实例变量本身占用的内存空间就会增加，那你有办法降低msadsc_t结构实例变量占用的内存空间吗？期待你的实现。</p><h2>思考题</h2><p>请问在4GB的物理内存的情况下，msadsc_t结构实例变量本身占用多大的内存空间？</p><p>欢迎你在留言区跟我交流互动，也希望你能把这节课分享给你的同事、朋友。</p><p>好，我是LMOS，我们下节课见！</p>","neighbors":{"left":{"article_title":"16 | 划分土地（上）：如何划分与组织内存？","id":384366},"right":{"article_title":"18 | 划分土地（下）：如何实现内存页的分配与释放？","id":385628}},"comments":[{"had_liked":false,"id":297996,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1623865363,"is_pvip":false,"replies":[{"id":"108172","content":"大神 6666","user_name":"作者回复","comment_id":297996,"uid":"1345199","ip_address":"","utype":1,"ctime":1623897353,"user_name_real":"LMOS"}],"discussion_count":5,"race_medal":0,"score":"78933276691","product_id":100078401,"comment_content":"一、稍微整理了一下流程：<br>init_hal-&gt;init_halmm-&gt;init_memmgr<br>&#47;&#47;每个页对应一个msadsc_t 结构体，循环填充msadsc_t 结构体数组<br>-&gt;init_msadsc<br>&#47;&#47;初始化三类memarea_t，硬件区、内核区、用户区<br>-&gt;init_memarea<br>&#47;&#47;对已使用的页打上标记，包括：BIOS中断表、内核栈、内核、内核映像<br>-&gt;init_search_krloccupymm(&amp;kmachbsp);    <br>&#47;&#47;将页面按地址范围，分配给内存区<br>&#47;&#47;然后按顺序依次查找最长连续的页面，根据连续页面的长度，<br>&#47;&#47;将这些页面的msadsc_t挂载到memdivmer_t 结构下的bafhlst_t数组dm_mdmlielst中<br>-&gt;init_merlove_mem();<br>&#47;&#47;物理地址转为虚拟地址，便于以后使用<br>-&gt;init_memmgrob();<br><br>二、对于最后的问题，用了虚拟机进行测试，但无论内存大小，总有56K内存没能找到【有知道的小伙伴，麻烦帮忙解答一下】：<br>1、4G内存情况如下：<br>理论内存：0x1 0000 0000 = 4,194,304K<br>可用内存：0xfff8fc00 = 4,193,855K<br>预留区域：0x52400  = 329K<br>硬件使用：0x10000  = 64K<br>没能找到：0xE000 = 56K<br><br>msadsc_t结构体大小为40，使用内存总计为：<br>4,193,855K&#47;4K*40=41,938,520=接近40M<br><br>2、2G内存情况如下<br>理论内存：0x8000 0000 =2,097,152K<br>可用内存：0x7ff8fc00 = 2,096,703K<br>预留区域：0x52400  = 329K<br>硬件使用：0x10000  = 64K<br>没能找到：0xE000 = 56K<br><br>msadsc_t结构体大小为40，使用内存总计为：<br>2,096,703K&#47;4K*40=20,967,030=接近20M<br><br>3、1G内存情况如下<br>理论内存：0x4000 0000= 1,048,576K<br>可用内存：0x3ff8fc00 = 1,048,127K<br>预留区域：0x52400  = 329K<br>硬件使用：0x10000  = 64K<br>没能找到：0xE000 = 56K<br><br>msadsc_t结构体大小为40，使用内存总计为：<br>1,048,127K&#47;4K*40=10,481,270=接近10M<br><br>三、如果想节约msadsc_t内存的话，感觉有几种方案：<br>1、最简单的方法，就是大内存时采用更大的分页，但应用在申请内存时，同样会有更多内存浪费<br>2、也可以用更复杂的页面管理机制，比如相同属性的连续页面不要用多个单独msadsc_t表示，而用一个msadsc_t表示并标明其范围，并通过skiplist等数据结构加速查询。但无论是申请内存还是归还内存时，性能会有所下降，感觉得不偿失。<br>3、页面分组情况较少的时候，可以通过每个组建立一个链表记录哪些页面属于某个链表，而msadsc_t中只记录地址等少量信息，不适合复杂系统。","like_count":19,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521985,"discussion_content":"大神 6666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623897353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2617162,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ef/4a/88ca7e9f.jpg","nickname":"初一","note":"","ucode":"30490F28547175","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382584,"discussion_content":"每次学完都一头雾水，看一下大佬的总结，知识结构才稍微清晰些，非常感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625641358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2064750,"avatar":"","nickname":"springXu","note":"","ucode":"F5DB0B963C894F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379474,"discussion_content":"这份作业是满分级的。 哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623919274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","nickname":"neohope","note":"","ucode":"C0268F6E7E2B6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379427,"discussion_content":"老师才是大神(=^▽^=)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623900603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1067704,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/b8/0eb3dcf2.jpg","nickname":"一元硬币","note":"","ucode":"1E7360BE0B282E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1043475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","nickname":"neohope","note":"","ucode":"C0268F6E7E2B6E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379462,"discussion_content":"你们都是大神啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623914413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379427,"ip_address":""},"score":379462,"extra":""}]}]},{"had_liked":false,"id":310295,"user_name":"黄光华","can_delete":false,"product_type":"c1","uid":1555050,"ip_address":"","ucode":"66865B43F2D132","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/6a/5a0bb648.jpg","comment_is_top":false,"comment_ctime":1630579353,"is_pvip":false,"replies":[{"id":"112431","content":"好的 ","user_name":"作者回复","comment_id":310295,"uid":"1345199","ip_address":"","utype":1,"ctime":1630631798,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"74645023385","product_id":100078401,"comment_content":"老师，我觉得这个类、变量的命名可读性，还是非常非常重要的<br>这个项目是您手写的，每一个命名什么意思，你了然于胸<br>但是我们都是新手，很多变量命名真的太简略了，有很多命名就算琢磨也不一定能知道是什么意思。<br>真心建议命名可读性还是要增强一下哈~~","like_count":18,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526188,"discussion_content":"好的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630631798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319871,"user_name":"朱炜敏","can_delete":false,"product_type":"c1","uid":2753464,"ip_address":"","ucode":"1CD07468FA1D4B","user_header":"https://static001.geekbang.org/account/avatar/00/2a/03/b8/72294f1e.jpg","comment_is_top":false,"comment_ctime":1635993400,"is_pvip":false,"replies":[{"id":"116090","content":"还有内核 的其它数据   但32位下 只能使用2.8GB","user_name":"作者回复","comment_id":319871,"uid":"1345199","ip_address":"","utype":1,"ctime":1636140233,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"10225927992","product_id":100078401,"comment_content":"老师，初始化这些数据结构的过程跟行为，让我想到了自己在电脑上装上4G内存条后，上电后发现系统反馈的可用内存一般只有3.8G左右。<br>是不是类似的，消失的几百兆内存里，存放的就是这些页管理的数据结构？","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529795,"discussion_content":"还有内核 的其它数据   但32位下 只能使用2.8GB","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636140233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297847,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1623811435,"is_pvip":false,"replies":[{"id":"108174","content":"是的 ","user_name":"作者回复","comment_id":297847,"uid":"1345199","ip_address":"","utype":1,"ctime":1623897407,"user_name_real":"LMOS"}],"discussion_count":3,"race_medal":0,"score":"10213746027","product_id":100078401,"comment_content":"胡乱一猜~<br><br>msadsc_t  占用内存 = 4GB&#47;4KB(页大小) * sizeof(msadsc_t )","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521948,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623897407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1474356,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI3F4IdQuDZrhN8ThibP85eCiaSWTYpTrcC6QB9EoAkw3IIj6otMibb1CgrS1uzITAnJmGLXQ2tgIkAQ/132","nickname":"cugphoenix","note":"","ucode":"80101AF04C00D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379383,"discussion_content":"sizeof(msadsc_t) = 40B，这么算下来应该需要40MB？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623854746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1474356,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI3F4IdQuDZrhN8ThibP85eCiaSWTYpTrcC6QB9EoAkw3IIj6otMibb1CgrS1uzITAnJmGLXQ2tgIkAQ/132","nickname":"cugphoenix","note":"","ucode":"80101AF04C00D3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379385,"discussion_content":"所以后面才需要多级页表啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623855607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379383,"ip_address":""},"score":379385,"extra":""}]}]},{"had_liked":false,"id":321472,"user_name":"浮生尽歇","can_delete":false,"product_type":"c1","uid":2617322,"ip_address":"","ucode":"3BA0FFF71E515C","user_header":"https://static001.geekbang.org/account/avatar/00/27/ef/ea/ab7612da.jpg","comment_is_top":false,"comment_ctime":1636893969,"is_pvip":false,"replies":[{"id":"116759","content":"KPrint","user_name":"作者回复","comment_id":321472,"uid":"1345199","ip_address":"","utype":1,"ctime":1636940549,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"5931861265","product_id":100078401,"comment_content":"怎么调试内核呢？","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530299,"discussion_content":"KPrint","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636940549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312809,"user_name":"杨军","can_delete":false,"product_type":"c1","uid":1988156,"ip_address":"","ucode":"AF881224E54C14","user_header":"https://static001.geekbang.org/account/avatar/00/1e/56/3c/f9ff3ed8.jpg","comment_is_top":false,"comment_ctime":1632035007,"is_pvip":false,"replies":[{"id":"113389","content":"哈哈 ","user_name":"作者回复","comment_id":312809,"uid":"1345199","ip_address":"","utype":1,"ctime":1632215484,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"5927002303","product_id":100078401,"comment_content":"这一讲的内容、概念很多，尤其是内存页合并到内存区的代码不好理解，建议大家把16讲的内存页面组织结构图放在手边，对照代码多看几次慢慢就有感觉了，加油，过了内存管理这道坎，就看见胜利的曙光了","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527119,"discussion_content":"哈哈 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632215484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303904,"user_name":"Geek_a5edac","can_delete":false,"product_type":"c1","uid":1954784,"ip_address":"","ucode":"A47341B4DB9C8E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/d4MHbXBwovYHW7xA18j88ibw1wS2R1JCoH5oLJIMUTdXe07dyVeTNWNzqWUKT7nPg21oClPhy1rSZPFiaibHeUFBA/132","comment_is_top":false,"comment_ctime":1627070124,"is_pvip":false,"replies":[{"id":"110007","content":"不需要搞懂的，不要陷入名词概念之中","user_name":"作者回复","comment_id":303904,"uid":"1345199","ip_address":"","utype":1,"ctime":1627097858,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"5922037420","product_id":100078401,"comment_content":"代码的命名，不太好懂，能说下命名规则么，一些看很久才知道是哪些缩写","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523873,"discussion_content":"不需要搞懂的，不要陷入名词概念之中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627097858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349618,"user_name":"小李飞刀","can_delete":false,"product_type":"c1","uid":3027260,"ip_address":"","ucode":"4CDF743FC51D15","user_header":"https://static001.geekbang.org/account/avatar/00/2e/31/3c/d23f3fa5.jpg","comment_is_top":false,"comment_ctime":1656149146,"is_pvip":true,"replies":[{"id":"128066","content":"哈哈","user_name":"作者回复","comment_id":349618,"uid":"1345199","ip_address":"","utype":1,"ctime":1658390664,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1656149146","product_id":100078401,"comment_content":"大佬的这个变量命名是真的把我看懵了。。。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580859,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658390665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349199,"user_name":"卖薪沽酒","can_delete":false,"product_type":"c1","uid":2465726,"ip_address":"","ucode":"7F04A84EDBA856","user_header":"https://static001.geekbang.org/account/avatar/00/25/9f/be/14b2ad2e.jpg","comment_is_top":false,"comment_ctime":1655794953,"is_pvip":false,"replies":[{"id":"128069","content":"因为用户区总是一次分配一个页面","user_name":"作者回复","comment_id":349199,"uid":"1345199","ip_address":"","utype":1,"ctime":1658390776,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1655794953","product_id":100078401,"comment_content":"&#47;&#47;根据地址连续的msadsc_t结构的数量查找合适bafhlst_t结构<br>bafhlst_t *find_continumsa_inbafhlst(memarea_t *mareap, uint_t fmnr)<br>{<br>\tbafhlst_t *retbafhp = NULL;<br>\tuint_t in = 0;<br>\tif (NULL == mareap || 0 == fmnr)\t\t\t&#47;&#47; 检查判断<br>\t{<br>\t\treturn NULL;<br>\t}<br><br>\tif (MA_TYPE_PROC == mareap-&gt;ma_type)\t\t&#47;&#47;TODO 如果是用户区， 直接返回第一个？， 这里不太懂<br>\t{<br>\t\treturn &amp;mareap-&gt;ma_mdmdata.dm_onemsalst;<br>\t}<br>\tif (MA_TYPE_SHAR == mareap-&gt;ma_type)\t\t&#47;&#47; 如果是共享区, 直接返回null<br>\t{<br>\t\treturn NULL;<br>\t}<br><br>这里的用户区为啥直接返回的是第一个， 不用做类似内核区的判断","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580863,"discussion_content":"因为用户区总是一次分配一个页面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658390776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1140762,"avatar":"https://static001.geekbang.org/account/avatar/00/11/68/1a/d9a35bc7.jpg","nickname":"Ziggy_aa","note":"","ucode":"B8921BF0C11DDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580201,"discussion_content":"我也发现了这个点。后续的挂载函数可以看到，如果是用户区，页就被单独一个一个的被加入到 dm_onemsalst 中，而不是按组进行分割。我的猜想是，用户区的页面一般是 lazy allocated，用到一个页面分配一个页面。所以就不用像内核区一样分组了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657972201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349194,"user_name":"卖薪沽酒","can_delete":false,"product_type":"c1","uid":2465726,"ip_address":"","ucode":"7F04A84EDBA856","user_header":"https://static001.geekbang.org/account/avatar/00/25/9f/be/14b2ad2e.jpg","comment_is_top":false,"comment_ctime":1655792087,"is_pvip":false,"replies":[{"id":"128070","content":"栈是向下伸长的","user_name":"作者回复","comment_id":349194,"uid":"1345199","ip_address":"","utype":1,"ctime":1658390852,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1655792087","product_id":100078401,"comment_content":"&#47;&#47; mbsp-&gt;mb_krlinitstack &amp; (~(0xfffUL)) 取得是高 52位，低12位全部之置为0，<br>\t&#47;&#47; TODO mbsp-&gt;mb_krlinitstack 作为结束地址的<br>\tretschmnr = search_segment_occupymsadsc(msadstat, msanr, mbsp-&gt;mb_krlinitstack &amp; (~(0xfffUL)), mbsp-&gt;mb_krlinitstack);=========================================================这里的结束地址为啥不是 mb_krlinitstack + 栈的大小的， 这里不太懂， ","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580864,"discussion_content":"栈是向下伸长的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658390852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341806,"user_name":"艾恩凝","can_delete":false,"product_type":"c1","uid":2950704,"ip_address":"","ucode":"F2B81BF4F0106A","user_header":"https://static001.geekbang.org/account/avatar/00/2d/06/30/c26ea06a.jpg","comment_is_top":false,"comment_ctime":1649838503,"is_pvip":false,"replies":[{"id":"125076","content":"哈哈","user_name":"作者回复","comment_id":341806,"uid":"1345199","ip_address":"","utype":1,"ctime":1650249378,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1649838503","product_id":100078401,"comment_content":"打卡，函数一步步的分析到位，函数搞清逻辑，花了三个下午，再花一个晚上的时间整理一下，参数命名是真的影响阅读，只能联系上下文了","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564451,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650249378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334211,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1644813689,"is_pvip":false,"replies":[{"id":"122178","content":"代码难度有点点大","user_name":"作者回复","comment_id":334211,"uid":"1345199","ip_address":"","utype":1,"ctime":1644976712,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":4,"score":"1644813689","product_id":100078401,"comment_content":"大家都能看懂代码?","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551288,"discussion_content":"代码难度有点点大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644976712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332592,"user_name":"秋宇雨","can_delete":false,"product_type":"c1","uid":2894821,"ip_address":"","ucode":"0BCE446A0EA7A8","user_header":"https://static001.geekbang.org/account/avatar/00/2c/2b/e5/e276fc41.jpg","comment_is_top":false,"comment_ctime":1643357419,"is_pvip":false,"replies":[{"id":"121508","content":"攻略：关注下这些代码要实现的功能是啥。还是死磕不出来的展开说说，大家一起讨论解决。","user_name":"编辑回复","comment_id":332592,"uid":"1501385","ip_address":"","utype":2,"ctime":1643363300,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1643357419","product_id":100078401,"comment_content":"u1s1，代码命名真心看晕了","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548779,"discussion_content":"攻略：关注下这些代码要实现的功能是啥。还是死磕不出来的展开说说，大家一起讨论解决。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643363300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332377,"user_name":"任国宁","can_delete":false,"product_type":"c1","uid":1960963,"ip_address":"","ucode":"FE47D8DB5FA4C7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoXoqDLvF3l8OzIwDBVlbgZ2FtbPFoncicFjQPqMFkKqdG5BnRVIxxrN40zUhTkynsd6yLhqqYiblAQ/132","comment_is_top":false,"comment_ctime":1643190278,"is_pvip":false,"replies":[{"id":"121791","content":"启动初始化用2MB页是为了简化开发","user_name":"作者回复","comment_id":332377,"uid":"1345199","ip_address":"","utype":1,"ctime":1644286942,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1643190278","product_id":100078401,"comment_content":"hi，有一个疑问，在启动初始化的时候mmu设置的每页2MB大小，到内核怎么变成4KB了，而且看源码里copy 页表数据的代码也是2MB","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549879,"discussion_content":"启动初始化用2MB页是为了简化开发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644286942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323871,"user_name":"PAWCOOK","can_delete":false,"product_type":"c1","uid":2679422,"ip_address":"","ucode":"699230E475966A","user_header":"https://static001.geekbang.org/account/avatar/00/28/e2/7e/ffde572d.jpg","comment_is_top":false,"comment_ctime":1638189726,"is_pvip":false,"replies":[{"id":"117622","content":"要处理 因为后期要有用的","user_name":"作者回复","comment_id":323871,"uid":"1345199","ip_address":"","utype":1,"ctime":1638323076,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1638189726","product_id":100078401,"comment_content":"请问BIOS中断表占用的内存有必要处理吗？我们不是已经设置好了自己的中断门描述符吗？而且，只处理BIOS中断表占用的空间有什么用呢，BIOS中断服务程序不也占用了内存吗","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534947,"discussion_content":"要处理 因为后期要有用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638323076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323838,"user_name":"PAWCOOK","can_delete":false,"product_type":"c1","uid":2679422,"ip_address":"","ucode":"699230E475966A","user_header":"https://static001.geekbang.org/account/avatar/00/28/e2/7e/ffde572d.jpg","comment_is_top":false,"comment_ctime":1638178093,"is_pvip":false,"replies":[{"id":"117623","content":"嗯嗯  有的是物理地址 而有些不是","user_name":"作者回复","comment_id":323838,"uid":"1345199","ip_address":"","utype":1,"ctime":1638323115,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1638178093","product_id":100078401,"comment_content":"kmachbsp 变量的地址是虚拟地址表示的（因为它是长模式下的全局变量），而其中保存的信息却是物理地址。请问这样理解是对的吗？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534948,"discussion_content":"嗯嗯  有的是物理地址 而有些不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638323115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323080,"user_name":"琥珀·","can_delete":false,"product_type":"c1","uid":1162136,"ip_address":"","ucode":"7DB119EB3D4F8F","user_header":"https://static001.geekbang.org/account/avatar/00/11/bb/98/db72a54a.jpg","comment_is_top":false,"comment_ctime":1637722150,"is_pvip":false,"replies":[{"id":"117354","content":"放在内核后面，初始化时指定了 ","user_name":"作者回复","comment_id":323080,"uid":"1345199","ip_address":"","utype":1,"ctime":1637917072,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1637722150","product_id":100078401,"comment_content":"扫描 phymmarge_t 结构体数组中的信息，只要它的类型是可用内存，就建立一个 msadsc_t 结构体，并把其中的开始地址作为第一个页面地址。<br><br>这里已经把其中的开始地址作为第一个页面地址，那msadsc_t这个结构体存放在哪里呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533620,"discussion_content":"放在内核后面，初始化时指定了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637917072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319043,"user_name":"Geek_260041","can_delete":false,"product_type":"c1","uid":2822865,"ip_address":"","ucode":"9BF0B7892AC3A7","user_header":"","comment_is_top":false,"comment_ctime":1635522118,"is_pvip":false,"replies":[{"id":"115789","content":"代码是这样的逻辑 第三个区分配不到 就会到第二个区。。。 ","user_name":"作者回复","comment_id":319043,"uid":"1345199","ip_address":"","utype":1,"ctime":1635813370,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"1635522118","product_id":100078401,"comment_content":"老师请问，合并内存页到内存区这里，uint_t merlove_setallmarflgs_onmemarea(memarea_t *mareap, msadsc_t *mstat, uint_t msanr)这个函数里，在最后for循环时，为什么要使用页信息结构(msadsc_t)里分配的物理地址去和某个区段逻辑地址去比较啊，这样第一个区(硬件区)还可以正常分配，第二个区(内核区)就直接会把所有页都分配到内核区了吧，第三个区就完全分配不到一个页了","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529471,"discussion_content":"代码是这样的逻辑 第三个区分配不到 就会到第二个区。。。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635813370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317202,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1634708044,"is_pvip":true,"replies":[{"id":"114905","content":"内存这部分比较难，有什么地方不懂可以具体提问的。","user_name":"编辑回复","comment_id":317202,"uid":"1501385","ip_address":"","utype":2,"ctime":1634725742,"user_name_real":"赵宇新"}],"discussion_count":2,"race_medal":0,"score":"1634708044","product_id":100078401,"comment_content":"一点也看不懂啊😪","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528712,"discussion_content":"内存这部分比较难，有什么地方不懂可以具体提问的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634725742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070692,"avatar":"https://static001.geekbang.org/account/avatar/00/10/56/64/7d80093c.jpg","nickname":"黄争辉","note":"","ucode":"970DD0C5D876FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535196,"discussion_content":"难受啊，提问都提不出来。弱弱问一个，什么是挂载？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638366359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310813,"user_name":"沈畅","can_delete":false,"product_type":"c1","uid":1077953,"ip_address":"","ucode":"7404E41356B36B","user_header":"https://static001.geekbang.org/account/avatar/00/10/72/c1/59509397.jpg","comment_is_top":false,"comment_ctime":1630920693,"is_pvip":true,"replies":[{"id":"112670","content":"当然有更高效的方法 只是这很简单","user_name":"作者回复","comment_id":310813,"uid":"1345199","ip_address":"","utype":1,"ctime":1630974722,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"1630920693","product_id":100078401,"comment_content":"每个分区都要遍历一次所有的页面结构是不是有点不合理？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526364,"discussion_content":"当然有更高效的方法 只是这很简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630974722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310297,"user_name":"黄光华","can_delete":false,"product_type":"c1","uid":1555050,"ip_address":"","ucode":"66865B43F2D132","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/6a/5a0bb648.jpg","comment_is_top":false,"comment_ctime":1630579548,"is_pvip":false,"replies":[{"id":"112430","content":"Linux对于Page结构的处理并不是","user_name":"作者回复","comment_id":310297,"uid":"1345199","ip_address":"","utype":1,"ctime":1630631763,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"1630579548","product_id":100078401,"comment_content":"对于“降低 msadsc_t 结构实例变量占用的内存空间”，Linux的做法是多级分页，并且“懒加载”用到时才生成 msadsc_t实例","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526190,"discussion_content":"Linux对于Page结构的处理并不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630631763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306695,"user_name":"Geek_a05da2","can_delete":false,"product_type":"c1","uid":2638950,"ip_address":"","ucode":"70444CA91EB5D0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/o92rdt9FicOicBojTEBWb1tnmuN5CFxFrhpibnXBTasU3kObs9lOXNAUGNtR24c2HLc2unibjBewCUE2zAd2aTbTjA/132","comment_is_top":false,"comment_ctime":1628671935,"is_pvip":false,"replies":[{"id":"111161","content":"不能直接加载hd.img 要把这个转换成hd.vdi","user_name":"作者回复","comment_id":306695,"uid":"1345199","ip_address":"","utype":1,"ctime":1628824440,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"1628671935","product_id":100078401,"comment_content":"加载  hd.img 显示  virtualbox 请提供日志文件 VBox.log和图像文件 VBox.png.请问下解决方案，谢谢","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524876,"discussion_content":"不能直接加载hd.img 要把这个转换成hd.vdi","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628824440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301740,"user_name":"Feen","can_delete":false,"product_type":"c1","uid":2646145,"ip_address":"","ucode":"E6CDC442B7213F","user_header":"https://static001.geekbang.org/account/avatar/00/28/60/81/38b00111.jpg","comment_is_top":false,"comment_ctime":1625826771,"is_pvip":false,"replies":[{"id":"109285","content":"是的 ","user_name":"作者回复","comment_id":301740,"uid":"1345199","ip_address":"","utype":1,"ctime":1626057004,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"1625826771","product_id":100078401,"comment_content":"基本的比例就是每1GB要占用10M的空间，还好不算太大。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523077,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626057004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301619,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1625790335,"is_pvip":false,"replies":[{"id":"109183","content":"一个页面大小 啊 ","user_name":"作者回复","comment_id":301619,"uid":"1345199","ip_address":"","utype":1,"ctime":1625802095,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"1625790335","product_id":100078401,"comment_content":"接着，要给这个开始地址加上 0x1000，如此循环，直到其结束地址。<br>+0x1000是啥作用？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523043,"discussion_content":"一个页面大小 啊 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625802095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300362,"user_name":"有手也不行","can_delete":false,"product_type":"c1","uid":2098652,"ip_address":"","ucode":"D55D23A2C4517E","user_header":"https://static001.geekbang.org/account/avatar/00/20/05/dc/b501933a.jpg","comment_is_top":false,"comment_ctime":1625127872,"is_pvip":false,"replies":[{"id":"108873","content":"对dm_onemsalst结构进行初始化啊","user_name":"作者回复","comment_id":300362,"uid":"1345199","ip_address":"","utype":1,"ctime":1625132700,"user_name_real":"LMOS"}],"discussion_count":1,"race_medal":0,"score":"1625127872","product_id":100078401,"comment_content":"老师你好，请问内存区结构初始化里面的memdivmer_t_init函数的最后一行为什么要执行<br>bafhlst_t_init(&amp;initp-&gt;dm_onemsalst, BAFH_STUS_ONEM, 0, 1UL);<br>bafhlst_t结构体里面dm_onemsalst属性有什么作用吗","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522716,"discussion_content":"对dm_onemsalst结构进行初始化啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625132700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}