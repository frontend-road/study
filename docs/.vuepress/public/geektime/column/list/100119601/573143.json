{"id":573143,"title":"加餐02｜留言区心愿单：Fiber协调引擎","content":"<p>你好，我是宋一玮，欢迎回到React应用开发的学习。</p><p>之前提到过，我们会在专栏的留言区选取一些具有代表性的问题，放到加餐里统一讲解。</p><p>上次的加餐01我们介绍了“真·子组件”，以及JSX语法糖在React 17版本以后发生的变化。这节加餐我们有且只有一个主题，就是目前留言区呼声最高的，Fiber协调引擎。</p><p>首先还是要说明一下，在React 18.2.0中，Fiber的源代码有3万多行（以 <code>wc -l packages/react-reconciler/src/*[^new].js</code> 命令统计），要想搞清它的每一行代码都是干什么的，一节加餐是远远不够的。</p><p>这节加餐会从原理入手，介绍Fiber内的部分重要模型和一些关键流程，并尽量跟前面课程中学到的React各种概念串联起来，这包括React元素、渲染过程、虚拟DOM、生命周期、Hooks。不求面面俱到，为的是帮助你加深对React框架的理解。</p><p>另外请注意，Fiber协调引擎是React的内部实现，无论是否学习它，都不会影响你对React框架的使用。</p><h2>什么是Fiber协调引擎？</h2><p>正如第6节课讲到的：</p><blockquote>\n<p>React组件会渲染出一棵元素树……每次有props、state等数据变动时，组件会渲染出新的元素树，React框架会与之前的树做Diffing对比，将元素的变动最终体现在浏览器页面的DOM中。这一过程就称为<strong>协调（Reconciliation）</strong>。</p>\n<blockquote>\n<p>在React的早期版本，协调是一个<strong>同步过程</strong>，这意味着当虚拟DOM足够复杂，或者元素渲染时产生的各种计算足够重，协调过程本身就可能超过16ms，严重的会导致页面卡顿。而从React v16开始，协调从之前的同步改成了<strong>异步过程</strong>，这主要得益于新的<strong>Fiber协调引擎</strong>。</p>\n</blockquote>\n</blockquote><!-- [[[read_end]]] --><p>Fiber协调引擎做的事情基本上贯穿了React应用的整个生命周期，包括并不限于：</p><ul>\n<li>创建各类FiberNode并组建Fiber树；</li>\n<li>调度并执行各类工作（Work），如渲染函数组件、挂载或是更新Hooks、实例化或更新类组件等；</li>\n<li>比对新旧Fiber，触发DOM变更；</li>\n<li>获取context数据；</li>\n<li>错误处理；</li>\n<li>性能监控。</li>\n</ul><p>Fiber协调引擎的源代码集中在 <code>react-reconciler</code> 这个包里，在Github上的地址是： <a href=\"https://github.com/facebook/react/tree/v18.2.0/packages/react-reconciler\">https://github.com/facebook/react/tree/v18.2.0/packages/react-reconciler</a></p><h2>Fiber中的重要概念和模型</h2><p>在协调过程中存在着各种动作，如调用生命周期方法或Hooks，这在Fiber协调引擎中被称作是<strong>工作</strong>（Work）。Fiber中最基本的模型是<strong>FiberNode，用于描述一个组件需要做<strong><strong>的</strong></strong>或者已完成的工作，每个组件可能对应一个或多个FiberNode</strong>。这与一个组件渲染可能会产生一个或多个React元素是一致的。</p><p>实际上，每个 <code>FiberNode</code> 的数据都来自于元素树中的一个元素，元素与 <code>FiberNode</code> 是一一对应的。与元素树不同的是，元素树每次渲染都会被重建，而 <code>FiberNode</code> 会被复用，<code>FiberNode</code> 的属性会被更新。</p><p>下面是 <code>FiberNode</code> 的数据结构，为了方便理解，我把关键的属性进行了分组，并省略了一些我认为不太关键的属性：</p><pre><code class=\"language-typescript\">type Fiber = {\n  // ---- Fiber类型 ----\n\n  /** 工作类型，枚举值包括：函数组件、类组件、HTML元素、Fragment等 */\n  tag: WorkTag,\n  /** 就是那个子元素列表用的key属性 */\n  key: null | string,\n  /** 对应React元素ReactElmement.type属性 */\n  elementType: any,\n  /** 函数组件对应的函数或类组件对应的类 */\n  type: any,\n\n  // ---- Fiber Tree树形结构 ----\n\n  /** 指向父FiberNode的指针 */\n  return: Fiber | null,\n  /** 指向子FiberNode的指针 */\n  child: Fiber | null,\n  /** 指向平级FiberNode的指针 */\n  sibling: Fiber | null,\n  \n  // ---- Fiber数据 ----\n\n  /** 经本次渲染更新的props值 */  \n  pendingProps: any,\n  /** 上一次渲染的props值 */\n  memoizedProps: any,\n  /** 上一次渲染的state值，或是本次更新中的state值 */\n  memoizedState: any,\n  /** 各种state更新、回调、副作用回调和DOM更新的队列 */\n  updateQueue: mixed,\n  /** 为类组件保存对实例对象的引用，或为HTML元素保存对真实DOM的引用 */\n  stateNode: any,\n\n  // ---- Effect副作用 ----\n\n  /** 副作用种类的位域，可同时标记多种副作用，如Placement、Update、Callback等 */\n  flags: Flags,\n  /** 指向下一个具有副作用的Fiber的引用，在React 18中貌似已被弃用 */\n  nextEffect: Fiber | null,\n\n  // ---- 异步性/并发性 ----\n  \n  /** 当前Fiber与成对的进行中Fiber的双向引用 */\n  alternate: Fiber | null,\n  /** 标记Lane车道模型中车道的位域，表示调度的优先级 */\n  lanes: Lanes\n};\n</code></pre><p>其他需要关注的，还有与Hooks相关的模型，这包括了 <code>Hook</code> 和 <code>Effect</code> ：</p><pre><code class=\"language-typescript\">type Hook = {\n&nbsp; memoizedState: any,\n&nbsp; baseState: any,\n&nbsp; baseQueue: Update&lt;any, any&gt; | null,\n&nbsp; queue: any,\n&nbsp; next: Hook | null,\n};\n\ntype Effect = {\n&nbsp; tag: HookFlags,\n&nbsp; create: () =&gt; (() =&gt; void) | void,\n&nbsp; destroy: (() =&gt; void) | void,\n&nbsp; deps: Array | null,\n&nbsp; next: Effect,\n};\n</code></pre><p>此外，还有 <code>Dispatcher</code>。基本每个Hook都有 <code>mount</code> 和 <code>update</code> 两个 <code>dispatcher</code>，如 <code>useEffect</code> 有 <code>mountEffect</code> 和 <code>updateEffect</code> ；少数Hooks还有额外的<code>rerender</code> 的 <code>dispatcher</code>，如 <code>useState</code>有<code>rerenderState</code> 。</p><h2>协调过程是怎样的？</h2><p>当第一次渲染，React元素树被创建出来后，Fiber协调引擎会从 <code>HostRoot</code> 这个特殊的元素开始，遍历元素树，创建对应的 <code>FiberNode</code> 。</p><p><code>FiberNode</code> 与 <code>FiberNode</code> 之间，并没有按照传统的parent-children方式建立树形结构。而是在父节点和它的第一个子节点间，利用<code>child</code> 和 <code>return</code> 属性建立了双向链表。节点与它的平级节点间，利用 <code>sibling</code> 属性建立了单向链表，同时平级节点的 <code>return</code> 属性，也都被设置成和单向链表起点的节点 <code>return</code> 一样的值引用。</p><p>如图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c6/60/c6d3d4806b9a80344a4431fc8245a460.jpg?wh=1142x670\" alt=\"\"></p><p>这样做的好处是，可以在协调引擎进行工作的过程中，<strong>避免递归遍历Fiber树，而仅仅用两层循环来完成深度优先遍历</strong><strong>，</strong>这个用于遍历Fiber树的循环被称作workLoop。</p><p>以下是workLoop的示意代码，为了便于理解，我对源码中的 <code>performUnitOfWork</code> 、 <code>beginWork</code>、<code>completeUnitOfWork</code>、<code>completeWork</code> 做了合并和简化，就是里面的 <code>workWork</code> （WARCRAFT梗）：</p><pre><code class=\"language-javascript\">let workInProgress;\n\nfunction workLoop() {\n  while (workInProgress &amp;&amp; !shouldYield()) {\n    const child = workWork(workInProgress);\n    if (child) {\n      workInProgress = child;\n      continue;\n    }\n    \n    let completedWork = workInProgress;\n    do {\n      if (completedWork.sibling) {\n        workInProgress = completedWork.sibling;\n        break;\n      }\n      completedWork = completedWork.return;\n    } while (completedWork);\n  }\n}\n</code></pre><p>更狠的一点是，这个循环<strong>随时可以跑，随时可以停</strong>。这意味着 <code>workLoop</code> 既可以同步跑，也可以异步跑，当 <code>workLoop</code> 发现进行中的Fiber工作耗时过长时，可以根据一个 <code>shouldYield()</code> 标记决定是否暂停工作，释放计算资源给更紧急的任务，等完成后再恢复工作。</p><p>当组件内更新state或有context更新时，React会进入渲染阶段（Render Phase）。这一阶段是异步的，Fiber协调引擎会启动<code>workLoop</code> ，从Fiber树的根部开始遍历，快速跳过已处理的节点；对有变化的节点，引擎会为 <code>Current</code><strong>（当前）节点</strong>克隆一个 <code>WorkInProgress</code><strong>（进行中）节点</strong>，将这两个FiberNode的 <code>alternate</code> 属性分别指向对方，并把更新都记录在<code>WorkInProgress</code> 节点上。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/30/d0/303937fc145e64f0242bcd65c2d96bd0.jpg?wh=1142x550\" alt=\"\"></p><p>你可以理解成同时存在两棵Fiber树，<strong>一棵 <code>Current</code> 树，对应着目前已经渲染到页面上的内容</strong>；<strong>另一棵是 <code>WorkInProgress</code> 树，记录着即将发生的修改</strong>。</p><p>函数组件的Hooks也是在渲染阶段执行的。除了<code>useContext</code> ，Hooks在挂载后，都会形成一个由 <code>Hook.next</code> 属性连接的单向链表，而这个链表会挂在 <code>FiberNode.memoizedState</code> 属性上。</p><p>在此基础上，<code>useEffect</code> 这样会产生副作用的Hooks，会额外创建与 <code>Hook</code> 对象一一对应的 <code>Effect</code> 对象，赋值给 <code>Hook.memoizedState</code> 属性。此外，也会在 <code>FiberNode.updateQueue</code> 属性上，维护一个由 <code>Effect.next</code> 属性连接的单向链表，并把这个 <code>Effect</code> 对象加入到链表末尾。</p><p>当Fiber树所有节点都完成工作后，<code>WorkInProgress</code> 节点会被改称为 <code>FinishedWork</code><strong>（已完成）节点</strong>，<code>WorkInProgress</code> 树也会被改称为 <code>FinishedWork</code><strong>树</strong>。这时React会进入提交阶段（Commit Phase），这一阶段主要是同步执行的。Fiber协调引擎会把<code>FinishedWork</code> 节点上记录的所有修改，按一定顺序提交并体现在页面上。</p><p>提交阶段又分成如下3个先后同步执行的子阶段：</p><ul>\n<li>\n<p><strong>变更前（Before Mutation）子阶段</strong>。这个子阶段会调用类组件的getSnapshotBeforeUpdate方法。</p>\n</li>\n<li>\n<p><strong>变更（Mutation）子阶段</strong>。这个子阶段会更新真实DOM树。</p>\n<ul>\n<li>递归提交与删除相关的副作用，包括移除ref、移除真实DOM、执行类组件的 <code>componentWillUnmount</code>  。</li>\n<li>递归提交添加、重新排序真实DOM等副作用。</li>\n<li>依次执行 <code>FiberNode</code> 上 <code>useLayoutEffect</code> 的清除函数。</li>\n<li>引擎用 <code>FinishedWork</code> 树替换 <code>Current</code> 树，供下次渲染阶段使用。</li>\n</ul>\n</li>\n<li>\n<p><strong>布局（Layout）子阶段</strong>。这个子阶段真实DOM树已经完成了变更，会调用 <code>useLayoutEffect</code> 的副作用回调函数，和类组件的 <code>componentDidMount</code> 方法。</p>\n</li>\n</ul><p>在提交阶段中，引擎还会多次异步或同步调用 <code>flushPassiveEffects()</code> 。这个函数会先后两轮按深度优先遍历Fiber树上每个节点：</p><ul>\n<li>第一轮：如果节点的 <code>updateQueue</code> 链表中有待执行的、由 <code>useEffect</code> 定义的副作用，则顺序执行它们的<strong>清除函数</strong>；</li>\n<li>第二轮：如果节点的 <code>updateQueue</code> 链表中有待执行的、由 <code>useEffect</code> 定义的副作用，则顺序执行它们的<strong>副作用回调函数</strong>，并保存清除函数，供下一轮提交阶段执行。</li>\n</ul><p>这个<code>flushPassiveEffects()</code> 函数真正的执行时机，是在上述提交阶段的三个同步子阶段之后，下一次渲染阶段之前。引擎会保证在下一次渲染之前，执行完所有待执行的副作用。</p><p>你也许会好奇，协调引擎的Diffing算法在哪里？其实从渲染到提交阶段，到处都在利用memoizedProps和memoizedState与新的props、state做比较，以减少不必要的工作，进而提高性能。</p><p>以上学习了Fiber协调引擎的工作流程，再回来看看 <code>oh-my-kanban</code> 的Fiber树，是不是能更进一步理解 <code>oh-my-kanban</code> 的生命周期了？</p><p><img src=\"https://static001.geekbang.org/resource/image/89/f6/892b4a21cb0a4d59a94a65e247b68af6.jpg?wh=1142x672\" alt=\"\"></p><p>好了，Fiber协调引擎我们暂时就讲到这里。</p><p>如果你还有其他想听的话题，或者在课程学习中有什么疑问，欢迎在留言区告诉我。下节课再见！</p>","comments":[{"had_liked":false,"id":358517,"user_name":"学习前端-react","can_delete":false,"product_type":"c1","uid":1331001,"ip_address":"北京","ucode":"6C873AF98F3498","user_header":"https://static001.geekbang.org/account/avatar/00/14/4f/39/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1664381694,"is_pvip":false,"replies":[{"id":130587,"content":"你好，学习前端-react，感谢你的认可。Fiber协调引擎能讲的东西确实很多，这节短短的加餐很难讲全。加餐主要的目的，还是希望能用Fiber协调引擎的基本原理把前面学到的React概念、API串联起来，帮大家更好地掌握React开发。\n\n加餐心愿单依然开放，欢迎接着提 ：）","user_name":"作者回复","user_name_real":"编辑","uid":1033973,"ctime":1665242151,"ip_address":"北京","comment_id":358517,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"感谢宋老师的精彩加餐。目前看下来一餐可能不太够，有点囫囵吞枣的感觉。\n","like_count":2,"discussions":[{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589694,"discussion_content":"你好，学习前端-react，感谢你的认可。Fiber协调引擎能讲的东西确实很多，这节短短的加餐很难讲全。加餐主要的目的，还是希望能用Fiber协调引擎的基本原理把前面学到的React概念、API串联起来，帮大家更好地掌握React开发。\n\n加餐心愿单依然开放，欢迎接着提 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665242151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358112,"user_name":"joel","can_delete":false,"product_type":"c1","uid":1550366,"ip_address":"北京","ucode":"46E91C3F3F1414","user_header":"https://static001.geekbang.org/account/avatar/00/17/a8/1e/4ec85e24.jpg","comment_is_top":false,"comment_ctime":1663916210,"is_pvip":false,"replies":[{"id":130404,"content":"你好，joel，只要你有收获我就不辛苦（握手）。最近专栏编辑跟我有讨论过连载完结时的一些策划，里面有可能有视频。","user_name":"作者回复","user_name_real":"编辑","uid":1033973,"ctime":1664213724,"ip_address":"北京","comment_id":358112,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"要是有视频就更好，老师辛苦了","like_count":2,"discussions":[{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588921,"discussion_content":"你好，joel，只要你有收获我就不辛苦（握手）。最近专栏编辑跟我有讨论过连载完结时的一些策划，里面有可能有视频。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664213725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358302,"user_name":"乐雨","can_delete":false,"product_type":"c1","uid":1228003,"ip_address":"北京","ucode":"FE7D7CCFDC1989","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/e3/6267bf06.jpg","comment_is_top":false,"comment_ctime":1664182111,"is_pvip":false,"replies":[{"id":130443,"content":"你好，乐雨，感谢你的留言，这篇加餐主要关注了React源码中packages&#47;react-reconciler的内容，确实没有讲到 packages&#47;scheduler，即任务优先级和调度相关的内容。Scheduler也是React内部的重要模块，之后有机会再为大家介绍。","user_name":"作者回复","user_name_real":"编辑","uid":1033973,"ctime":1664371574,"ip_address":"北京","comment_id":358302,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"没有讲到任务优先级和饥饿问题的处理","like_count":1,"discussions":[{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589057,"discussion_content":"你好，乐雨，感谢你的留言，这篇加餐主要关注了React源码中packages/react-reconciler的内容，确实没有讲到 packages/scheduler，即任务优先级和调度相关的内容。Scheduler也是React内部的重要模块，之后有机会再为大家介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664371575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1376519,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/07/1dbe5690.jpg","nickname":"我最棒","note":"","ucode":"7F7D2E64707017","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651394,"discussion_content":"fiber的优先级调度是怎么实现的，老师可以讲讲吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726818235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358518,"user_name":"学习前端-react","can_delete":false,"product_type":"c1","uid":1331001,"ip_address":"北京","ucode":"6C873AF98F3498","user_header":"https://static001.geekbang.org/account/avatar/00/14/4f/39/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1664381698,"is_pvip":false,"replies":[{"id":130586,"content":"你好，学习前端-react，从结果来看，你的说法是ok的。\n\n在reconciler内部，修改state会把更新加入到更新队列里，并标记fiber待更新，在完成高优先级的工作以后，scheduler（另一个包）会从队列中拿出更新工作，放到下一轮render阶段，并做diffing。\n\n所以整体而言修改state是异步的，这也使得React也有足够空间可以调整工作的优先级，合并多个state修改、做批处理。","user_name":"作者回复","user_name_real":"编辑","uid":1033973,"ctime":1665237007,"ip_address":"北京","comment_id":358518,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"请问：修改state 是生成fiber 并 diffing的过程？","like_count":0,"discussions":[{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589684,"discussion_content":"你好，学习前端-react，从结果来看，你的说法是ok的。\n\n在reconciler内部，修改state会把更新加入到更新队列里，并标记fiber待更新，在完成高优先级的工作以后，scheduler（另一个包）会从队列中拿出更新工作，放到下一轮render阶段，并做diffing。\n\n所以整体而言修改state是异步的，这也使得React也有足够空间可以调整工作的优先级，合并多个state修改、做批处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665237007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389248,"user_name":"silence_wh","can_delete":false,"product_type":"c1","uid":1016299,"ip_address":"浙江","ucode":"95FB5D6C02EC89","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/eb/04c16c3e.jpg","comment_is_top":false,"comment_ctime":1711959352,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"推荐一篇帮助理解 React 工作流程的文章：https:&#47;&#47;pomb.us&#47;build-your-own-react&#47;","like_count":0},{"had_liked":false,"id":368832,"user_name":"潮汐","can_delete":false,"product_type":"c1","uid":1042208,"ip_address":"广东","ucode":"F5E4F6DF9CEA9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/20/70a95f94.jpg","comment_is_top":false,"comment_ctime":1676790282,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"这篇加餐结合正文课程第6、8节和文中的图，对渲染、协调有更深的理解。与6、8节正文的图形成互相诠释说明，值得反复对比理解！","like_count":0}]}