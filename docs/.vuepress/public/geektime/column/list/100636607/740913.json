{"id":740913,"title":"第 6 章 使用 Go 语言实现 HTTP/1.1 客户端","content":"\n    \n    <p>本章我们将使用 Go 语言来实现第 4 章和第 5 章介绍的一些功能。使用 Go 语言的目的是向读者展示创建向 API 服务器发送请求的客户端的方法。另外，笔者也希望读者能通过代码加深对知识的理解。即使一些功能不会用于 API\n        客户端，我们也能通过再次阅读第 4 章和第 5\n        章的内容来进一步理解。笔者在学习软件方面的论文和难度较高的算法时，都会一并阅读代码，或者使用自己擅长的语言再次进行实现，以此来巩固知识。理解得不透彻，就无法编写代码，通过实际编写代码，能够确认自己的理解是否正确。</p>\n    <p>第 3 章仅介绍了向用于测试的服务器发送请求的客户端代码，而在 HTTP/1.1\n        中，即使从客户端的角度来看语义（通信内容及含义）没有发生变化，很多时候语法（通信协议）也发生了变化。为了能在一些项目中实际连接客户端来确认运行情况，笔者先来介绍一下服务器的代码。</p>\n    <h2 id=\"nav_point_160\">6.1　Keep-Alive</h2>\n    <p>即使不对 Go 语言的 HTTP API 进行任何设置，Keep-Alive 也是默认有效的。在通信正常结束后，会话仍会继续。不过，文档中明确记载了客户端必须在读取完 <code>response.Body</code>\n        后将其关闭。由于这是将套接字管道按时间分割来共享的结构，所以如果不声明主体已经读取完毕，程序就无法判断何时开始下一个任务，也就无法重复使用套接字。如果之前的 HTTP\n        访问失败，<code>response.Body()</code> 中会存储 <code>nil</code>；而在访问成功的情况下，即使是 <code>Content-Length:0</code>\n        这种主体为空的情况，<code>io.Reader</code> 的主体也一定会保存到 <code>response.Body()</code> 中。因此，在未发生错误时，有必要像代码清单 6-1 那样读取完毕。</p><!-- [[[read_end]]] -->\n    <p>本章介绍的示例代码都是 HTTP 下层的详细的控制代码，所以我们无法使用，但只要是普通的 HTTP 客户端，就完全可以使用第 3 章介绍的代码。<code>defer</code> 是函数结束时调用的后处理。</p>\n    <p><strong>代码清单 6-1　将服务器响应读取完毕</strong></p>\n    <pre class=\"code-rows\"><code>resp, err := http.Get(\"http://...\")\nif err != nil {\n    // 发生错误\n    panic(err)\n}\n// 跳出后关闭\ndefer resp.Body.Close()\n// 使用 ioutil.ReadAll 将服务器响应读取完毕\nbody, err := ioutil.ReadAll(resp.Body)</code></pre>\n    <h2 id=\"nav_point_161\">6.2　TLS</h2>\n    <p>在使用 Go 语言的情况下，如代码清单 6-2 所示，将 URL 变为 <code>https://</code>，即可实现使用标准库的 TLS 通信。Go 语言的标准库使用的不是 <code>openssl</code>\n        之类的库，而是采用模型编写的代码。</p>\n    <p><strong>代码清单 6-2　在使用 Go 语言的情况下，仅修改指定的 URL 即可支持 TLS</strong></p>\n    <pre class=\"code-rows\"><code>resp, err := client.Get(\"https://××××.com\")</code></pre>\n    <p>本节将介绍如何自己创建证书，并对服务器进行设置，以进行 TLS 通信。</p>\n    <h3 id=\"nav_point_162\">6.2.1　创建证书</h3>\n    <p>默认使用系统持有的证书来确认证书。为了能在测试环境中使用，我们也可以使用自己创建的证书 <span class=\"comment-number\">1</span>。</p>\n    \n    <p>创建单个证书的基本流程如下所示。</p>\n    <blockquote>\n        <ul>\n            <li>使用 OpenSSL 命令创建私人密钥文件</li>\n            <li>创建证书签名请求文件</li>\n            <li>在证书签名请求文件中签名，完成证书的创建</li>\n        </ul>\n    </blockquote>\n    <p>在一般情况下，前两步由需要证书的人来完成，签名则由认证机构有偿完成。这次我们只是试着创建一下证书，所以签名也由自己进行。笔者在第 4\n        章中介绍过，自己签名的证书可以用来隐藏通信线路，但这种做法无法保证服务器的身份。在各个计算机中安装证书时，我们可以手动告诉计算机该证书值得信赖。</p>\n    <p>这里要创建的证书如图 6-1 所示。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00406.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 6-1　证书的结构</strong></p>\n    <p>首先，复制 <code>openssl.cnf</code> 文件并修改设置。由于有些项目无法仅通过命令行进行设置，所以需要编辑设置文件。<code>openssl.cnf</code> 文件的原型在\n        <code>/etc/local/openssl/openssl.cnf</code>、<code>/etc/ssl/openssl.cnf</code> 和\n        <code>C:\\OpenSSL\\bin\\openssl.cnf</code> 中（代码清单 6-3）。我们在末尾加上创建认证机构、服务器和客户端这 3 种证书所需的设置。</p>\n    <p><strong>代码清单 6-3　设置文件的原型</strong></p>\n    <pre class=\"code-rows\"><code>[CA]\nbasicConstraints=critical,CA:TRUE,pathlen:0\nkeyUsage=digitalSignature,keyCertSign,cRLSign\n\n[Server]\nbasicConstraints=CA:FALSE\nkeyUsage=digitalSignature,dataEncipherment\nextendedKeyUsage=serverAuth\n\n[Client]\nbasicConstraints=CA:FALSE\nkeyUsage=digitalSignature,dataEncipherment\nextendedKeyUsage=clientAuth</code></pre>\n    <p>代码清单 6-4 中预先设置了一些被频繁询问的项目。</p>\n    <p><strong>代码清单 6-4　预先设置一些被频繁询问的项目</strong></p>\n    <pre class=\"code-rows\"><code>[req_distinguished_name]\n# 默认的国家代码\n-countryName_default         = JP\n# 默认的县/ 州\nstateOrProvinceName_default = Tokyo\n# 默认的城市名称\nlocalityName_default        = Itabashi\n# 默认的组织名称\n0.organizationName_default  = ××××.com\n# 默认的管理员的邮箱地址\nemailAddress_default        = webmaster@××××.com</code></pre>\n    <p>在 Erlang 的 <code>ssl</code> 模块等环境中，如果注册的证书中的 <code>basicConstraints</code> 不是\n        <code>CA:TRUE</code>，环境就不会运行。另外，有些实现还引用了 <code>keyUsage</code>。我们需要通过设置文件来指定这些内容。OpenSSL\n        的设置是由各种节（section）组成的，因为并不是所有的节都要用到，所以我们可以使用 <code>-extensions</code> 选项来指定需要的节，以此来切换设置。</p>\n    <p>首先，按照以下步骤来创建自己签名的根认证机构证书。以下内容操作一次即可。</p>\n    <pre class=\"code-rows\"><code># 创建 2048 位的 RSA 私人密钥文件\n$ openssl genrsa -out ca.key 2048\n\n# 创建证书签名请求（CSR）文件\n$ openssl req -new -sha256 -key ca.key -out ca.csr -config openssl.cnf\n\n# 使用自己的私人密钥签名，创建证书\n$ openssl x509 -in ca.csr -days 365 -req -signkey ca.key -sha256 -out ca.crt\n-extfile ./openssl.cnf -extensions CA</code></pre>\n    <p>除 RSA 之外，椭圆曲线加密算法中的 ECDSA 等算法也支持私人密钥，但椭圆曲线加密算法很少用于证书，RSA 2048 位是目前的事实标准。另外，虽然有办法用一个命令来创建私人密钥文件和证书签名请求文件，如 AWS IAM\n        等，但有的环境不接收使用该方法创建的证书，因此，本书中会分开创建私人密钥文件和证书签名请求文件。</p>\n    <p>在创建证书签名请求文件时，需要用到所在地信息（国家、城市名称）和组织信息（组织名称、部门名称、组织的常用名称和\n        URL）等。这些信息会写入证书中，以供用户确认证书的持有者。另外，<code>Challenge password</code> 是废除证书时使用的密码，自己签名的证书不需要该密码，不过有的认证机构需要用到该密码。</p>\n    <p>另外，下面的命令用来确认各个项目中创建的文件。</p>\n    <pre class=\"code-rows\"><code># 确认私人密钥文件\n$ openssl rsa -in ca.key -text\n\n# 确认证书签名请求（CSR）文件\n$ openssl req -in ca.csr -text\n\n# 确认证书文件\n$ openssl x509 -in ca.crt -text</code></pre>\n    <p>接下来，我们按照以下步骤创建服务器的证书。有多少台服务器就执行多少次操作。前面将组织名称等设为了 <code>Common Name</code>，这里可以使用 FQDN（Fully Qualified Domain\n        Name，完全合格域名）。</p>\n    <pre class=\"code-rows\"><code># 创建 2048 位的 RSA 私人密钥文件\n$ openssl genrsa -out server.key 2048\n\n# 创建证书签名请求（CSR）文件\n$ openssl req -new -nodes -sha256 -key server.key -out server.csr -config openssl.\ncnf\n\n# 使用自己的私人密钥签名，创建证书\n$ openssl x509 -req -days 365 -in server.csr -sha256 -out server.crt -CA ca.crt\n-CAkey ca.key -CAcreateserial -extfile ./openssl.cnf -extensions Server</code></pre>\n    <p>与认证机构不同，在服务器的证书中，在 <code>Common Name</code> 中需要准确输入主机名，否则客户端就会认为连接的是其他服务器，从而切断连接。这就是域名认证。这里请输入\n        <code>localhost</code>。证书无法共用，因此我们要给每个服务器创建一个证书。</p>\n    <p>与创建根认证机构证书时不同，这里的第 2 行代码设置了 <code>-nodes</code>。如果不这样设置，每次启动服务器时都要提供密码。还有一处不同是，<code>-CA</code>\n        之后的设置内容用来传递认证机构使用的私人密钥和证书，以及设置 <code>-CAcreateserial</code> 选项。另外，<code>-extensions</code> 用来读取服务器的设置内容。</p>\n    <p>这样我们就完成了所有的准备工作。生成的文件名如表 6-1 所示。</p>\n    <p><strong>表 6-1　文件名一览表</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>文件</p>\n                </th>\n                <th>\n                    <p>用于 CA</p>\n                </th>\n                <th>\n                    <p>用于服务器</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p>私人密钥</p>\n                </td>\n                <td>\n                    <p>ca.key</p>\n                </td>\n                <td>\n                    <p>server.key</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>证书签名请求</p>\n                </td>\n                <td>\n                    <p>ca.csr</p>\n                </td>\n                <td>\n                    <p>server.csr</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>证书</p>\n                </td>\n                <td>\n                    <p>ca.crt</p>\n                </td>\n                <td>\n                    <p>server.crt</p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <p>实际上，服务器使用的是私人密钥文件和证书文件。在证书创建完成之后，证书签名请求文件就没有用了。</p>\n    <h3 id=\"nav_point_163\">6.2.2　HTTPS 服务器和注册证书</h3>\n    <p>为了测试 HTTPS 连接，我们准备一个 HTTPS 服务器，如代码清单 6-5 所示。</p>\n    <p><strong>代码清单 6-5　用于测试的 HTTPS 服务器</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"net/http/httputil\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    dump, err := httputil.DumpRequest(r, true)\n    if err != nil {\n        http.Error(w, fmt.Sprint(err), http.StatusInternalServerError)\n        return\n    }\n    fmt.Println(string(dump))\n    fmt.Fprintf(w, \"&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;\\n\")\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    log.Println(\"start http listening :18443\")\n    err := http.ListenAndServeTLS(\":18443\", \"server.crt\", \"server.key\", nil)\n    log.Println(err)\n}</code></pre>\n    <p>代码与 HTTP 的代码几乎没有差别，只是最后的 <code>ListenAndServe</code> 改为了 <code>ListenAndServeTLS</code>\n        函数。该函数的参数接收前面创建的证书文件和私人密钥文件的文件名。</p>\n    <p>我们来运行一下代码。</p>\n    <pre class=\"code-rows\"><code>$ curl https://localhost:18443\n\ncurl: (60) SSL certificate problem: unable to get local issuer certificate</code></pre>\n    <p>这里发生了错误，原因是 curl 命令无法找到证书。为了让其找到证书，可以仅使用 curl 来解决，或者将证书注册到操作系统中。最简单的方法是将前面创建的认证机构的证书作为 命令行参数进行传递，具体如下所示。</p>\n    <pre class=\"code-rows\"><code>$ curl --cacert ca.crt https://localhost:18443</code></pre>\n    <p>在使用 curl 命令查看的证书列表中添加前面创建的证书也能解决上述问题。只要注册一次，就无须通过选项指定证书了。根据 curl 命令的编译方法的不同，处理方法也有所不同。我们来查看一下版本信息。</p>\n    <pre class=\"code-rows\"><code>$ curl --version\ncurl 7.43.0 (x86_64-apple-darwin15.0) libcurl/7.43.0 SecureTransport zlib/1.2.5\n︙</code></pre>\n    <p><code>libcurl</code> 后面是实现 TLS 时使用的库名。</p>\n    <blockquote>\n        <p><code>OpenSSL</code></p>\n        <p>OpenSSL（可移植库）。</p>\n        <p><code>Schannel</code></p>\n        <p>Windows 安全管理系统。</p>\n        <p><code>SecureTransport</code></p>\n        <p>macOS 安全管理系统。</p>\n        <p><code>NSS</code></p>\n        <p>一些 Linux 发行版中使用的安全管理系统。</p>\n    </blockquote>\n    <p>在使用 <code>Schannel</code> 和 <code>SecureTransport</code> 时，可以使用系统提供的功能来注册证书：Windows 中可以使用控制面板的网络选项，macOS\n        中可以使用名为钥匙串访问（keychain access）的应用程序。在使用 <code>NSS</code> 的情况下，可以使用命令行工具 <code>p11-kit-nss-trust</code> 来注册证书。</p>\n    <p>另外，<code>OpenSSL</code> 会将证书添加到默认使用的证书 bundle 文件中。执行下面的命令即可查看搜索目录。</p>\n    <pre class=\"code-rows\"><code>$ openssl version -d\nOPENSSLDIR: \"/opt/local/etc/openssl\"</code></pre>\n    <p>在使用 macOS 的情况下，可以通过在 <code>cert.pem</code> 文件的末尾添加前面创建的认证机构的证书 <code>ca.crt</code> 的内容来访问。在使用 Linux（Ubuntu\n        16.04）的情况下，要将 <code>ca.crt</code> 复制到搜索目录中的 <code>certs</code> 目录中。不过，在 Node.js 和 Python 的 <code>requests</code>\n        包等环境中，由于自己持有根证书列表，所以无法使用该方法。由于这些环境也会读取证书文件等，所以可以通过自己将证书添加列表中来应对。curl 的网站上提供了原始的证书 bundle 文件。</p>\n    <p>除此之外，也可以使用 <code>--insecure/-k</code> 选项 <span class=\"comment-number\">2</span>，不对主机进行确认，仅对 HTTPS 的通信线路进行加密。这是最后的手段。</p>\n    \n    <h3 id=\"nav_point_164\">6.2.3　使用 Go 语言实现客户端</h3>\n    <p>使用 Go 语言实现客户端的代码非常简单，如代码清单 6-6 所示。</p>\n    <p><strong>代码清单 6-6　使用 Go 语言实现客户端</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"net/http/httputil\"\n)\n\nfunc main() {\n    resp, err := http.Get(\"https://localhost:18443\")\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n    dump, err := httputil.DumpResponse(resp, true)\n    if err != nil {\n        panic(err)\n    }\n    log.Println(string(dump))\n}</code></pre>\n    <p>这里使用的 API 与前面的代码相同，只是将 URL 改为了 <code>https://</code> 而已。该代码能够运行吗？由于 Go\n        语言默认使用系统中注册的根证书，所以如果按上一节介绍的方法将证书注册到操作系统中，代码就可以正常运行，否则就不会运行。</p>\n    <p>代码清单 6-7 的代码直接通过应用程序来处理未注册到系统中的证书，并进行 HTTPS 通信。</p>\n    <p><strong>代码清单 6-7　使用未注册到系统中的证书进行通信</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"crypto/tls\"\n    \"crypto/x509\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n    \"net/http/httputil\"\n)\n\nfunc main() {\n    // 读取证书\n    cert, err := ioutil.ReadFile(\"ca.crt\")\n    if err != nil {\n        panic(err)\n    }\n    certPool := x509.NewCertPool()\n    certPool.AppendCertsFromPEM(cert)\n    tlsConfig := &amp;tls.Config{\n        RootCAs: certPool,\n    }\n    tlsConfig.BuildNameToCertificate()\n\n    // 创建客户端\n    client := &amp;http.Client{\n        Transport: &amp;http.Transport{\n            TLSClientConfig: tlsConfig,\n        },\n    }\n\n    // 进行通信\n    resp, err := client.Get(\"https://localhost:18443\")\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n    dump, err := httputil.DumpResponse(resp, true)\n    if err != nil {\n        panic(err)\n    }\n    log.Println(string(dump))\n}</code></pre>\n    <p>这里出现了两个不太常见的术语，笔者来介绍一下。<code>x509</code> 是 ISO 制定的证书格式。<code>PEM</code> 是对采用 Base64\n        编码的二进制数据添加页眉和页脚的数据结构。用视频和声音文件方面的术语来讲，就是容器（container）。在本章的示例代码中，私人密钥文件、证书签名请求文件和证书文件的扩展名分别是\n        <code>.key</code>、<code>.csr</code> 和 <code>.crt</code>，但作为文件容器，它们使用的都是 PEM，因此有些网站的讲解中会使用 <code>.pem</code> 来代替\n        <code>.key</code>、<code>.csr</code> 和 <code>.crt</code>。PEM 定义在 RFC 2459 中，其结构如代码清单 6-8 所示。</p>\n    <p><strong>代码清单 6-8　PEM</strong></p>\n    <pre class=\"code-rows\"><code>------BEGIN CERTIFICATE REQUEST-----\n    MIIC4DCCAcgCAQAwgZoxCzAJBgNVBAYTAkpBMQ4wDAYDVQQIDAVUb2t5bzERMA8G\n    A1UEBwwISXRhYmFzaGkxGTAXBgNVBAoMEEV4YW1wbGUgQ28uLEx0ZC4xFjAUBgNV\n    ︙\n    H3di7oDHNvKSj1/0oZuzgPFyJAthdsJGZb0gjmnUTTAc1+N9E3QdZS9l5wcpLgfV\n    7S27ED4qFoC4lL3B9ktZEwKJbUE=\n------END CERTIFICATE REQUEST-----</code></pre>\n    <p>Go 语言也提供了允许安全性较低的 TLS 连接的选项。在上面的代码中，<code>tlsConfig</code> 的初始化可以不采用传递证书池的方法，而是按照代码清单 6-9 的方式进行设置。</p>\n    <p><strong>代码清单 6-9　不确认证书的设置方式</strong></p>\n    <pre class=\"code-rows\"><code>tlsConfig := &amp;tls.Config{\n    InsecureSkipVerify: true,\n}</code></pre>\n    <h3 id=\"nav_point_165\">6.2.4　客户端证书</h3>\n    <p>利用客户端证书的<strong>客户端认证</strong>与普通的 TLS 功能相反，服务器向客户端请求证书，在验证通过之后才能进行通信。</p>\n    <p>我们先来修改服务器代码，将客户端认证设置为必须执行的内容。</p>\n    <p>第 3 章介绍了客户端 API 分为简单 API、使用 <code>http.Client</code> 的详细 API 和使用 <code>http.Request</code>\n        的详细请求等几种。由于本书重点介绍的是客户端，所以服务器仅使用了简单 API，但服务器的代码中也有详细 API，比如使用 <code>http.Server</code> 进行服务器设置、使用\n        <code>http.ServeMux</code> 请求 Handler 处理的详细 API。TLS 的连接设置需要用到 <code>http.Server</code> 结构体，不过这里不涉及\n        <code>http.ServeMux</code>，使用代码清单 6-10 的代码即可创建 <code>http.Server</code> 来请求客户端证书。</p>\n    <p><strong>代码清单 6-10　请求客户端证书</strong></p>\n    <pre class=\"code-rows\"><code>import (\n    \"crypto/tls\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"net/http/httputil\"\n)\n\n// 由于 handle 没有变化，所以这里省略\n\nfunc main() {\n    server := &amp;http.Server{\n        TLSConfig: &amp;tls.Config{\n            ClientAuth: tls.RequireAndVerifyClientCert,\n            MinVersion: tls.VersionTLS12,\n        },\n        Addr: \":18443\",\n    }\n    http.HandleFunc(\"/\", handler)\n    log.Println(\"start http listening :18443\")\n    err := server.ListenAndServeTLS(\"server.crt\", \"server.key\")\n    log.Println(err)\n}</code></pre>\n    <p>在这种状态下，运行前面创建的 HTTPS 客户端代码，来确认连接是否被拒绝。</p>\n    <pre class=\"code-rows\"><code>$ go run main.go\npanic: Get https://localhost:18443: dial tcp [::1]:18443: getsockopt: connection refused</code></pre>\n    <p>在初始化服务器时，对 <code>TLSConfig</code> 成员变量进行了设置。由于该设置使用的是 <code>tls.Config</code> 结构体，所以在使用系统证书之外的证书时，可以使用上一节介绍的方法。\n    </p>\n    <p><code>ClientAuth</code> 成员变量可以设置为以下任意一种类型，客户端证书所涉及的动作会根据设置而发生变化。</p>\n    <blockquote>\n        <p><code>NoClientCert</code></p>\n        <p>不请求客户端证书（默认）。</p>\n        <p><code>RequestClientCert</code></p>\n        <p>请求客户端证书。</p>\n        <p><code>RequireAnyClientCert</code></p>\n        <p>请求任意客户端证书。</p>\n        <p><code>VerifyClientIfGiven</code></p>\n        <p>如果客户端提供了证书，服务器就会验证客户端证书。</p>\n        <p><code>RequireAndVerifyClientCert</code></p>\n        <p>请求并验证客户端证书。</p>\n    </blockquote>\n    <p>上面的示例代码中设置了最严格的条件。接下来，我们创建客户端证书。</p>\n    <pre class=\"code-rows\"><code># 创建 2048 位的 RSA 私人密钥文件\n$ openssl genrsa -out client.key 2048\n\n# 创建证书签名请求（CSR）文件\n$ openssl req -new -nodes -sha256 -key client.key -out client.csr -config openssl.\ncnf\n\n# 使用自己的私人密钥签名，创建证书\n$ openssl x509 -req -days 365 -in client.csr -sha256 -out client.crt -CA ca.crt\n-CAkey ca.key -CAcreateserial -extfile ./openssl.cnf -extensions Client</code></pre>\n    <p>代码清单 6-11 是使用客户端证书的 Go 语言代码。具体来说就是，加载证书和私人密钥，并设置 <code>tls.Config</code> 的 <code>Certificates</code> 成员，创建持有该设置的\n        <code>http.Transport</code> 结构体，并将其传递给 <code>http.Client</code>。拥有证书和私人密钥的客户端在接到服务器的请求时会发送证书。</p>\n    <p><strong>代码清单 6-11　使用客户端证书</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"crypto/tls\"\n    \"log\"\n    \"net/http\"\n    \"net/http/httputil\"\n)\n\nfunc main() {\n    cert, err := tls.LoadX509KeyPair(\"client.crt\", \"client.key\")\n    if err != nil {\n        panic(err)\n    }\n\n    client := &amp;http.Client{\n        Transport: &amp;http.Transport{\n            TLSClientConfig: &amp;tls.Config{\n                Certificates: []tls.Certificate,\n            },\n        },\n    }\n    // 以下和前面的代码一样\n}</code></pre>\n    <h2 id=\"nav_point_166\">6.3　协议升级</h2>\n    <p>协议升级的目的是在通信中途进行非 HTTP 通信。虽然标准的 <code>net/http</code> 包提供了许多功能，但升级后通信方式就不再是 HTTP 了，服务器和客户端会直接发送和接收套接字。</p>\n    <p>升级的协议原本也需要像 HTTP 一样有详细的发送和接收数据的规范，但本书的示例代码仅实现了进行简单的发送和接收的协议。</p>\n    <h3 id=\"nav_point_167\">6.3.1　服务器代码</h3>\n    <p>服务器也需要进行特殊的通信，因此我们要创建 Handler。请不要忘记在 <code>main()</code> 中注册 Handler。如果包含代码清单 6-12 的首部，则服务器返回\n        <code>101 Switching Protocols</code>，并进行之前的通信。该 MyProtocol 协议通过换行来互相发送数字，进行不符合 HTTP 规范的通信。</p>\n    <p><strong>代码清单 6-12　开始通信时的首部示例</strong></p>\n    <pre class=\"code-rows\"><code>Upgrade: MyProtocol\nConnection: Upgrade</code></pre>\n    <p>代码清单 6-13 是服务器代码，比第 3 章中介绍的代码要长很多。</p>\n    <p><strong>代码清单 6-13　执行协议升级的服务器代码</strong></p>\n    <pre class=\"code-rows\"><code>func handlerUpgrade(w http.ResponseWriter, r *http.Request) {\n    // 该端点只接收变更\n    if r.Header.Get(\"Connection\") != \"Upgrade\" || r.Header.Get(\"Upgrade\") !=\n\"MyProtocol\" {\n        w.WriteHeader(400)\n        return\n    }\n    fmt.Println(\"Upgrade to MyProtocol\")\n\n    // 获取底层套接字\n    hijacker := w.(http.Hijacker)\n    conn, readWriter, err := hijacker.Hijack()\n    if err != nil {\n        panic(err)\n        return\n    }\n    defer conn.Close()\n\n    // 发送表示协议变更的响应\n    response := http.Response{\n        StatusCode: 101,\n        Header:     make(http.Header),\n    }\n    response.Header.Set(\"Upgrade\", \"MyProtocol\")\n    response.Header.Set(\"Connection\", \"Upgrade\")\n    response.Write(conn)\n\n    // 开始通信\n    for i := 1; i &lt;= 10; i++ {\n        fmt.Fprintf(readWriter, \"%d\\n\", i)\n        fmt.Println(\"-&gt;\", i)\n        readWriter.Flush() // Trigger \"chunked\" encoding and send a chunk...\n        recv, err := readWriter.ReadBytes('\\n')\n        if err == io.EOF {\n            break\n        }\n        fmt.Printf(\"&lt;- %s\", string(recv))\n        time.Sleep(500 * time.Millisecond)\n    }\n}</code></pre>\n    <p>代码中有两个关键点。首先，将 <code>http.ResponseWriter</code> 转换为 <code>http.Hijacker</code>，劫持 HTTP\n        请求。这样一来，<code>http.ResponseWriter</code> 就不再发送任何消息，也不再发送首部和状态码。而底层套接字变得可直接操作，程序员负责关闭套接字。</p>\n    <p>另一个关键点是创建 <code>http.Response</code>，使用 <code>response.Write()</code> 手动向套接字写入响应。在直接读写套接字时，虽然可以使用\n        <code>conn.Write()</code> 直接写入 HTTP 响应，但如果使用该辅助方法，就不用手动将输出格式调整为 HTTP 了，这样就可以在保持连接的情况下返回 HTTP 响应。</p>\n    <p>劫持时的第二个响应是对底层套接字进行包装的 <code>bufio.ReadWriter</code>。它是用于读写数据的接口，为 <code>io.Reader</code> 追加了便于读取数据的\n        <code>bufio.Reader</code> 功能和便于写入数据的 <code>bufio.Writer</code> 功能。劫持该接口，就可以获取内部使用的对象，我们可以直接使用这个对象。这里使用了\n        <code>ReadBytes()</code> 方法一直读取到指定字符（<code>'\\n'</code>），然后将这些数据汇总并返回。</p>\n    <p><code>bufio.ReadWriter</code> 还提供了许多用来写入的方法，但没有指定格式进行输出的功能。如果要指定格式进行输出，可以使用 <code>fmt</code> 包，像其他编程语言一样执行\n        <code>printf</code> 输出。</p>\n    <h3 id=\"nav_point_168\">6.3.2　客户端代码</h3>\n    <p>执行协议升级的客户端代码如代码清单 6-14 所示。客户端代码也直接处理套接字。与服务器代码相比，客户端代码是从更底层的操作开始的。由于没有服务器那样的劫持结构，所以客户端需要在通信开始时处理套接字。尽管如此，代码清单\n        6-14 中的代码行数也比用 C 语言实现相同内容时少一半。</p>\n    <p><strong>代码清单 6-14　执行协议升级的客户端代码</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"bufio\"\n    \"bytes\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"net\"\n    \"net/http\"\n    \"time\"\n)\n\nfunc main() {\n    // 打开 TCP 套接字\n    dialer := &amp;net.Dialer{\n        Timeout:   30 * time.Second,\n        KeepAlive: 30 * time.Second,\n    }\n    conn, err := dialer.Dial(\"tcp\", \"localhost:18888\")\n    if err != nil {\n        panic(err)\n    }\n    defer conn.Close()\n    reader := bufio.NewReader(conn)\n\n    // 创建请求，并将其直接写入套接字中\n    request, _ := http.NewRequest(\"GET\", \"http://localhost:18888/upgrade\", nil)\n    request.Header.Set(\"Connection\", \"Upgrade\")\n    request.Header.Set(\"Upgrade\", \"MyProtocol\")\n    err = request.Write(conn)\n    if err != nil {\n        panic(err)\n    }\n\n    // 从套接字直接读取数据，解析响应\n    resp, err := http.ReadResponse(reader, request)\n    if err != nil {\n        panic(err)\n    }\n    log.Println(\"Status:\", resp.Status)\n    log.Println(\"Headers:\", resp.Header)\n\n    // 开始通信\n    counter := 10\n    for {\n        data, err := reader.ReadBytes('\\n')\n        if err == io.EOF {\n            break\n        }\n        fmt.Println(\"&lt;-\", string(bytes.TrimSpace(data)))\n        fmt.Fprintf(conn, \"%d\\n\", counter)\n        fmt.Println(\"-&gt;\", counter)\n        counter--\n    }\n}</code></pre>\n    <p>首先，使用 <code>net.Dialer</code> 结构体打开 TCP 套接字。然后，与服务器的操作一样，创建请求，并使用 <code>request.Write</code>\n        直接将请求写入套接字中。请求中包含服务器期待的升级信息的首部。之后，使用 <code>http.ReadResponse</code> 函数读取响应，并创建 <code>http.Response</code>\n        结构体。在使用 Go 语言直接处理套接字的情况下，客户端也可以使用高级协议轻松地进行读写。</p>\n    <p>与服务器代码相同，这里也使用了 <code>bufio.Reader</code> 的 <code>ReadBytes()</code> 方法。套接字通信的底层接口\n        <code>net.Conn</code>、<code>os.File</code> 和启动外部进程之后执行的 <code>StdinPipe()</code> 等持有各处返回的 <code>io.Reader</code>\n        接口的对象可以像代码清单 6-15 这样，使用 <code>bufio.Reader</code> 进行简单的包装，添加便捷的方法。</p>\n    <p><strong>代码清单 6-15　创建 bufio.Reader 来强化方法</strong></p>\n    <pre class=\"code-rows\"><code>reader := bufio.NewReader(conn)</code></pre>\n    <h2 id=\"nav_point_169\">6.4　Chunk</h2>\n    <p>Go 语言最初就已经在 <code>net/http</code> 包的各个功能中加入了对 Chunk 的支持。在使用第 3 章介绍的 API 的情况下，如果只是进行简单的数据的发送和接收，则无须关注通信是否是以 Chunk\n        形式进行的。代码清单 6-16 中的代码可以用来接收 Chunk 形式的服务器响应。不过，由于是否使用了 Chunk 形式进行通信这一点完全被隐藏了起来，所以外部无法得知。</p>\n    <p><strong>代码清单 6-16　使用该代码也可以处理 Chunk 形式的响应</strong></p>\n    <pre class=\"code-rows\"><code>resp, _ := http.Get(\"http://localhost:18888\")\ndefer resp.Body.Close()\nbody, _ := ioutil.ReadAll(resp.Body)</code></pre>\n    <p>当使用 <code>http.Post</code> 发送大小超过 2048 字节的文件时，如果没有设置 <code>Request.ContentLength</code> 而直接发送文件，文件就会自动以 Chunk\n        形式上传。</p>\n    <p>如果调用 <code>ioutil.ReadAll()</code>，就会在读取结束之前发生阻塞。如果每秒分 10 次接收数据，客户端就会在 10 秒之后一并返回通信结果。一般情况下，这么做不会出现什么问题。本节将介绍如何使用\n        Go 语言实现以下内容。</p>\n    <blockquote>\n        <ul>\n            <li>服务器采用 Chunk 形式发送数据</li>\n            <li>客户端依次接收数据（简易版）</li>\n            <li>客户端依次接收数据（完整版）</li>\n            <li>从客户端发送数据</li>\n        </ul>\n    </blockquote>\n    <h3 id=\"nav_point_170\">6.4.1　服务器发送数据</h3>\n    <p>服务器采用 Chunk 形式发送数据的方法非常简单。将 <code>http.ResponseWriter</code> 转换为 <code>http.Flusher</code> 接口，就可以使用隐藏的\n        <code>Flush()</code> 方法。</p>\n    <p>如代码清单 6-17 所示，在使用 <code>ResponseWriter</code> 写入数据后发送 <code>Flush()</code> 方法，就可以将前面写入的内容提前发送给客户端。</p>\n    <p><strong>代码清单 6-17　服务器采用 Chunk 形式发送数据</strong></p>\n    <pre class=\"code-rows\"><code>func handlerChunkedResponse(w http.ResponseWriter, r *http.Request) {\n    flusher, ok := w.(http.Flusher)\n    if !ok {\n        panic(\"expected http.ResponseWriter to be an http.Flusher\")\n    }\n    for i := 1; i &lt;= 10; i++ {\n        fmt.Fprintf(w, \"Chunk #%d\\n\", i)\n        flusher.Flush()\n        time.Sleep(500 * time.Millisecond)\n    }\n    flusher.Flush()\n}\n\n// 在 main 中注册 Handler，以采用/chunked 路径按 Chunk 形式发送数据\nhttp.HandleFunc(\"/chunked\", handlerChunkedResponse)</code></pre>\n    <p>代码清单 6-17 中的代码每 0.5 秒就会给客户端返回一次文本。前面的代码都是在写入操作结束之后将所有的消息返回给客户端的，如果每写入一次数据就调用一次\n        <code>Flush()</code>，客户端就可以在各个循环中接收结果。先发送数据大小再发送主体的 Chunk 发送方法由 Go 语言执行。我们使用 curl 命令来试验一下。</p>\n    <pre class=\"code-rows\"><code>$ curl http://localhost:18888/chunked\nChunk #1\nChunk #2\nChunk #3</code></pre>\n    <p>请注释掉循环中的 <code>Flush()</code>，并确认动作的变化。</p>\n    <h3 id=\"nav_point_171\">6.4.2　客户端依次接收数据（简易版）</h3>\n    <p>直接使用第 3 章介绍的 API 一边确认服务器发送的内容的分隔符，一边接收数据，也可以处理 Chunk。在解析 XML 和 JSON 的同时进行读取非常麻烦，但如果在数据末尾加上特定的分隔符，代码写起来就十分简单了。代码清单\n        6-18 的代码是以使用换行符从服务器发送数据为前提的。</p>\n    <p><strong>代码清单 6-18　客户端依次接收数据</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"bufio\"\n    \"bytes\"\n    \"io\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    resp, err := http.Get(\"http://localhost:18888/chunked\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer resp.Body.Close()\n    reader := bufio.NewReader(resp.Body)\n    for {\n        line, err := reader.ReadBytes('\\n')\n        if err == io.EOF {\n            break\n        }\n        log.Println(string(bytes.TrimSpace(line)))\n    }\n}</code></pre>\n    <p>代码清单 6-18 中的代码使用 <code>bufio.Reader</code> 的 <code>ReadBytes()</code> 来读取到分隔符为止的内容。如果服务器每秒发送一行，则\n        <code>ReadBytes()</code> 方法在收到响应之前会发生阻塞。</p>\n    <p>该结构可以让服务器在任何时候都能返回响应。使用该方法的前提是，使用者以正确的格式发送数据。如果末尾存在分隔符之外的内容，处理就会发生阻塞。</p>\n    <h3 id=\"nav_point_172\">6.4.3　客户端依次接收数据（完整版）</h3>\n    <p>在协议升级的实现中，使用 TCP 套接字可以支持任意的协议。我们也可以使用相同的方法来直接处理 Chunk。</p>\n    <p>Chunk 的功能非常简单。</p>\n    <blockquote>\n        <ul>\n            <li>以十六进制数的形式发送 Chunk 长度</li>\n            <li>发送指定长度的数据</li>\n            <li>当发送的 Chunk 长度为 0 时，服务器的响应结束</li>\n        </ul>\n    </blockquote>\n    <p>使用底层套接字直接读取 Chunk 的代码如代码清单 6-19 所示。</p>\n    <p><strong>代码清单 6-19　使用底层套接字直接读取 Chunk</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"bufio\"\n    \"io\"\n    \"log\"\n    \"net\"\n    \"net/http\"\n    \"strconv\"\n    \"time\"\n)\n\nfunc main() {\n    // 打开 TCP 套接字\n    dialer := &amp;net.Dialer{\n        Timeout:   30 * time.Second,\n        KeepAlive: 30 * time.Second,\n    }\n    conn, err := dialer.Dial(\"tcp\", \"localhost:18888\")\n    if err != nil {\n        panic(err)\n    }\n    defer conn.Close()\n\n    // 发送请求\n    request, err := http.NewRequest(\"GET\", \"http://localhost:18888/chunked\", nil)\n    err = request.Write(conn)\n    if err != nil {\n        panic(err)\n    }\n    // 读取\n    reader := bufio.NewReader(conn)\n    // 读取首部\n    resp, err := http.ReadResponse(reader, request)\n    if err != nil {\n        panic(err)\n    }\n    if resp.TransferEncoding[0] != \"chunked\" {\n        panic(\"wrong transfer encoding\")\n    }\n    for {\n        // 获取 Chunk 长度\n        sizeStr, err := reader.ReadBytes('\\n')\n        if err == io.EOF {\n            break\n        }\n        // 传递用十六进制数表示的 Chunk 长度，Chunk 长度为 0 时关闭\n        size, err := strconv.ParseInt(string(sizeStr[:len(sizeStr)-2]), 16, 64)\n        if size == 0 {\n            break\n        }\n        if err != nil {\n            panic(err)\n        }\n        // 按指定长度开辟缓冲区，读取数据\n        line := make([]byte, int(size))\n        reader.Read(line)\n        reader.Discard(2)\n        log.Println(\" \", string(line))\n    }\n}</code></pre>\n    <p>在循环的过程中获取 Chunk 长度，在其他情况下，将十六进制的 Chunk 长度转换为 <code>int</code> 类型。如果 Chunk 长度为 0，则跳出循环，在其他情况下，开辟与所获取的 Chunk\n        长度相应的缓冲区，读取数据并输出到控制台。</p>\n    <h2 id=\"nav_point_173\">6.5　远程过程调用</h2>\n    <p>Go 语言的 <code>net/rpc</code> 包中提供了用于实现<strong>远程过程调用</strong>（RPC）的框架。在创建对象并进行注册后，就可以从外部进行访问。Go 语言默认使用序列化格式 gob\n        来进行服务器和客户端之间的通信，但我们也可以指定编解码器来切换通信方式。标准库中也提供了 JSON-RPC 的编解码器。</p>\n    <p><code>net/rpc</code> 中公开的方法需要满足以下条件。</p>\n    <blockquote>\n        <ul>\n            <li>方法所属的结构体类型是公开的</li>\n            <li>方法是公开的</li>\n            <li>方法接收的两个参数都是公开的嵌入类型</li>\n            <li>方法的第二个参数是指针</li>\n            <li>方法持有 <code>error</code> 类型的返回值</li>\n        </ul>\n        <p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00380.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　在 Go 语言中，名称以大写字母开头的类型是“公开的”。</p>\n    </blockquote>\n    <p>代码清单 6-20 和代码清单 6-21 分别是 JSON-RPC 服务器和 JSON-RPC 客户端的代码。</p>\n    <p><strong>代码清单 6-20　JSON-RPC 服务器</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net\"\n    \"net/http\"\n    \"net/rpc\"\n    \"net/rpc/jsonrpc\"\n)\n\n// 方法所属的结构体\ntype Calculator int\n\n// 使用远程过程调用从外部调用的方法\nfunc (c *Calculator) Multiply(args Args, result *int) error {\n    log.Printf(\"Multiply called: %d, %d\\n\", args.A, args.B)\n    *result = args.A * args.B\n    return nil\n}\n\n// 从外部调用时的参数\ntype Args struct {\n    A, B int\n}\n\nfunc main() {\n    calculator := new(Calculator)\n    server := rpc.NewServer()\n    server.Register(calculator)\n    http.Handle(rpc.DefaultRPCPath, server)\n    log.Println(\"start http listening :18888\")\n    listener, err := net.Listen(\"tcp\", \":18888\")\n    if err != nil {\n        panic(err)\n    }\n    for {\n        conn, err := listener.Accept()\n        if err != nil {\n            panic(err)\n        }\n        go server.ServeCodec(jsonrpc.NewServerCodec(conn))\n    }\n}</code></pre>\n    <p>在服务器代码中创建 <code>net.rpc.Server</code>，添加执行该处理的结构体，并将其注册为 HTTP Handler。之后，每当客户端进行连接时，就会创建 JSON-RPC\n        的编解码器，并将其注册到服务器中。</p>\n    <p>客户端代码非常简单。由于在调用 <code>jsonrpc.Dial</code> 函数时会返回设置了编解码器的客户端，所以我们可以使用 <code>Call</code> 方法来调用服务器的方法。</p>\n    <p><strong>代码清单 6-21　JSON-RPC 客户端</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net/rpc/jsonrpc\"\n)\n\n// 参数\ntype Args struct {\n    A, B int\n}\n\nfunc main() {\n    client, err := jsonrpc.Dial(\"tcp\", \"localhost:18888\")\n    if err != nil {\n        panic(err)\n    }\n    var result int\n    args := &amp;Args\n    err = client.Call(\"Calculator.Multiply\", args, &amp;result)\n    if err != nil {\n        panic(err)\n    }\n    log.Printf(\"4 x 5 = %d\\n\", result)\n}</code></pre>\n    <p>不过，虽然 Go 语言将远程过程调用相关的功能作为标准 API 提供，但质量并不是很高。Go 语言也没有提供可以同时简单地指定等待方的路径和编解码器的 API，只是提供了默认使用某个路径和编解码器的方法。默认路径是\n        <code>/_goRPC_</code>，方法名固定为<strong>结构体名 . 方法名</strong>，它的可移植性也不是很好。</p>\n    <p>另外，还有一些可以实现远程过程调用的方法，比如 Go 语言的 Web 应用程序框架 Gorilla Web 工具套件提供了 <code>PRC</code> 包。还存在用于该 Gorilla 的第三方包，如\n        <code>XML-RPC</code> 包。</p>\n    <p><code>zenrpc</code> 包也可以自动公开结构体的方法并实现远程过程调用，不过它还具有 Service Mapping Description（SMD）功能，可以生成返回远程过程调用的方法或参数信息的\n        JSON。虽然还未看到具体实现，但我们可以根据该信息生成客户端，或事先进行错误检查。</p>\n    <h2 id=\"nav_point_174\">6.6　本章小结</h2>\n    <p>本章我们使用 Go 语言实现了第 4 章和第 5 章介绍的各种功能，还介绍了 TLS 的相关内容，以及用于实现 TLS 通信的准备工作。TLS 是 HTTP/2 的基础，非常重要。此外，为了便于读者理解，笔者还介绍了协议升级和\n        Chunk 等在实际工作中不怎么会用到的内容。</p>\n    <p>有些内容虽然在第 5 章提到过，但当时并未介绍其实现，比如 WebDAV。Go 语言的标准库中虽然有 WebDAV 服务器，但没有客户端的\n        API。如果是不涉及属性访问的单纯的上传和下载操作，那么在客户端方面，我们只要对前面的知识加以延伸就可以了。另外，笔者也没有介绍 Geo-IP。这不是客户端的实现，而是服务器的实现，在许多情况下需要用到 Web\n        服务器的插件等。</p>\n\n    <br style=\"page-break-after:always\" />\n    ","neighbors":{"left":{"article_title":"第 5 章 HTTP/1.1 的语义：HTTP 的扩展功能(2)","id":740912},"right":{"article_title":"第 7 章 HTTP/2 和 HTTP/3 的语法：重新定义协议(1)","id":740914}},"comments":[]}