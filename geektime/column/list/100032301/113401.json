{"id":113401,"title":"07 | 消息积压了该如何处理？","content":"<p>你好，我是李玥。这节课我们来聊一聊关于消息积压的问题。</p><p>据我了解，在使用消息队列遇到的问题中，消息积压这个问题，应该是最常遇到的问题了，并且，这个问题还不太好解决。</p><p>我们都知道，消息积压的直接原因，一定是系统中的某个部分出现了性能问题，来不及处理上游发送的消息，才会导致消息积压。</p><p>所以，我们先来分析下，在使用消息队列时，如何来优化代码的性能，避免出现消息积压。然后再来看看，如果你的线上系统出现了消息积压，该如何进行紧急处理，最大程度地避免消息积压对业务的影响。</p><h2>优化性能来避免消息积压</h2><p>在使用消息队列的系统中，对于性能的优化，主要体现在生产者和消费者这一收一发两部分的业务逻辑中。对于消息队列本身的性能，你作为使用者，不需要太关注。为什么这么说呢？</p><p>主要原因是，对于绝大多数使用消息队列的业务来说，消息队列本身的处理能力要远大于业务系统的处理能力。主流消息队列的单个节点，消息收发的性能可以达到每秒钟处理几万至几十万条消息的水平，还可以通过水平扩展Broker的实例数成倍地提升处理能力。</p><p>而一般的业务系统需要处理的业务逻辑远比消息队列要复杂，单个节点每秒钟可以处理几百到几千次请求，已经可以算是性能非常好的了。所以，对于消息队列的性能优化，我们更关注的是，<strong>在消息的收发两端，我们的业务代码怎么和消息队列配合，达到一个最佳的性能。</strong></p><!-- [[[read_end]]] --><h4>1. 发送端性能优化</h4><p>发送端业务代码的处理性能，实际上和消息队列的关系不大，因为一般发送端都是先执行自己的业务逻辑，最后再发送消息。<strong>如果说，你的代码发送消息的性能上不去，你需要优先检查一下，是不是发消息之前的业务逻辑耗时太多导致的。</strong></p><p>对于发送消息的业务逻辑，只需要注意设置合适的并发和批量大小，就可以达到很好的发送性能。为什么这么说呢？</p><p>我们之前的课程中讲过Producer发送消息的过程，Producer发消息给Broker，Broker收到消息后返回确认响应，这是一次完整的交互。假设这一次交互的平均时延是1ms，我们把这1ms的时间分解开，它包括了下面这些步骤的耗时：</p><ul>\n<li>发送端准备数据、序列化消息、构造请求等逻辑的时间，也就是发送端在发送网络请求之前的耗时；</li>\n<li>发送消息和返回响应在网络传输中的耗时；</li>\n<li>Broker处理消息的时延。</li>\n</ul><p>如果是单线程发送，每次只发送1条消息，那么每秒只能发送 1000ms / 1ms * 1条/ms = 1000条 消息，这种情况下并不能发挥出消息队列的全部实力。</p><p>无论是增加每次发送消息的批量大小，还是增加并发，都能成倍地提升发送性能。至于到底是选择批量发送还是增加并发，主要取决于发送端程序的业务性质。简单来说，只要能够满足你的性能要求，怎么实现方便就怎么实现。</p><p>比如说，你的消息发送端是一个微服务，主要接受RPC请求处理在线业务。很自然的，微服务在处理每次请求的时候，就在当前线程直接发送消息就可以了，因为所有RPC框架都是多线程支持多并发的，自然也就实现了并行发送消息。并且在线业务比较在意的是请求响应时延，选择批量发送必然会影响RPC服务的时延。这种情况，比较明智的方式就是通过并发来提升发送性能。</p><p>如果你的系统是一个离线分析系统，离线系统在性能上的需求是什么呢？它不关心时延，更注重整个系统的吞吐量。发送端的数据都是来自于数据库，这种情况就更适合批量发送，你可以批量从数据库读取数据，然后批量来发送消息，同样用少量的并发就可以获得非常高的吞吐量。</p><h4>2. 消费端性能优化</h4><p>使用消息队列的时候，大部分的性能问题都出现在消费端，如果消费的速度跟不上发送端生产消息的速度，就会造成消息积压。如果这种性能倒挂的问题只是暂时的，那问题不大，只要消费端的性能恢复之后，超过发送端的性能，那积压的消息是可以逐渐被消化掉的。</p><p>要是消费速度一直比生产速度慢，时间长了，整个系统就会出现问题，要么，消息队列的存储被填满无法提供服务，要么消息丢失，这对于整个系统来说都是严重故障。</p><p>所以，我们在设计系统的时候，<strong>一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行。</strong></p><p>消费端的性能优化除了优化消费业务逻辑以外，也可以通过水平扩容，增加消费端的并发数来提升总体的消费性能。特别需要注意的一点是，<strong>在扩容Consumer的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保Consumer的实例数和分区数量是相等的。</strong>如果Consumer的实例数量超过分区数量，这样的扩容实际上是没有效果的。原因我们之前讲过，因为对于消费者来说，在每个分区上实际上只能支持单线程消费。</p><p>我见到过很多消费程序，他们是这样来解决消费慢的问题的：</p><p><img src=\"https://static001.geekbang.org/resource/image/46/3e/463b28bda587249e74c1f3a5d33a193e.jpg?wh=3501*1050\" alt=\"\"></p><p>它收消息处理的业务逻辑可能比较慢，也很难再优化了，为了避免消息积压，在收到消息的OnMessage方法中，不处理任何业务逻辑，把这个消息放到一个内存队列里面就返回了。然后它可以启动很多的业务线程，这些业务线程里面是真正处理消息的业务逻辑，这些线程从内存队列里取消息处理，这样它就解决了单个Consumer不能并行消费的问题。</p><p>这个方法是不是很完美地实现了并发消费？请注意，这是一个非常常见的错误方法！ 为什么错误？因为会丢消息。如果收消息的节点发生宕机，在内存队列中还没来及处理的这些消息就会丢失。关于“消息丢失”问题，你可以回顾一下我们的专栏文章《<a href=\"time://article?id=111488\">05 | 如何确保消息不会丢失？</a>》。</p><h2>消息积压了该如何处理？</h2><p>还有一种消息积压的情况是，日常系统正常运转的时候，没有积压或者只有少量积压很快就消费掉了，但是某一个时刻，突然就开始积压消息并且积压持续上涨。这种情况下需要你在短时间内找到消息积压的原因，迅速解决问题才不至于影响业务。</p><p>导致突然积压的原因肯定是多种多样的，不同的系统、不同的情况有不同的原因，不能一概而论。但是，我们排查消息积压原因，是有一些相对固定而且比较有效的方法的。</p><p>能导致积压突然增加，最粗粒度的原因，只有两种：要么是发送变快了，要么是消费变慢了。</p><p>大部分消息队列都内置了监控的功能，只要通过监控数据，很容易确定是哪种原因。如果是单位时间发送的消息增多，比如说是赶上大促或者抢购，短时间内不太可能优化消费端的代码来提升消费性能，唯一的方法是通过扩容消费端的实例数来提升总体的消费能力。</p><p>如果短时间内没有足够的服务器资源进行扩容，没办法的办法是，将系统降级，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务。</p><p>还有一种不太常见的情况，你通过监控发现，无论是发送消息的速度还是消费消息的速度和原来都没什么变化，这时候你需要检查一下你的消费端，是不是消费失败导致的一条消息反复消费这种情况比较多，这种情况也会拖慢整个系统的消费速度。</p><p>如果监控到消费变慢了，你需要检查你的消费实例，分析一下是什么原因导致消费变慢。优先检查一下日志是否有大量的消费错误，如果没有错误的话，可以通过打印堆栈信息，看一下你的消费线程是不是卡在什么地方不动了，比如触发了死锁或者卡在等待某些资源上了。</p><h2>小结</h2><p>这节课我们主要讨论了2个问题，一个是如何在消息队列的收发两端优化系统性能，提前预防消息积压。另外一个问题是，当系统发生消息积压了之后，该如何处理。</p><p>优化消息收发性能，预防消息积压的方法有两种，增加批量或者是增加并发，在发送端这两种方法都可以使用，在消费端需要注意的是，增加并发需要同步扩容分区数量，否则是起不到效果的。</p><p>对于系统发生消息积压的情况，需要先解决积压，再分析原因，毕竟保证系统的可用性是首先要解决的问题。快速解决积压的方法就是通过水平扩容增加Consumer的实例数量。</p><h2>思考题</h2><p>课后请你思考一下，在消费端是否可以通过批量消费的方式来提升消费性能？在什么样场景下，适合使用这种方法？或者说，这种方法有什么局限性？欢迎在留言区与我分享讨论。</p><p>感谢阅读，如果你觉得这篇文章对你有一些启发，也欢迎把它分享给你的朋友。</p>","comments":[{"had_liked":false,"id":121122,"user_name":"大白给小白讲故事","can_delete":false,"product_type":"c1","uid":1258557,"ip_address":"","ucode":"4538C24B67B513","user_header":"https://static001.geekbang.org/account/avatar/00/13/34/3d/51762e76.jpg","comment_is_top":false,"comment_ctime":1565061464,"is_pvip":false,"replies":[{"id":44629,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138836,"ip_address":"","comment_id":121122,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"1、要求消费端能够批量处理或者开启多线程进行单条处理\n2、批量消费一旦某一条数据消费失败会导致整批数据重复消费\n3、对实时性要求不能太高，批量消费需要Broker积累到一定消费数据才会发送到Consumer","like_count":94},{"had_liked":false,"id":121005,"user_name":"iLeGeND","can_delete":false,"product_type":"c1","uid":1055475,"ip_address":"","ucode":"4055A628A6E97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","comment_is_top":false,"comment_ctime":1565049400,"is_pvip":false,"replies":[{"id":44476,"content":"消息积压是正常现象，积压越来越多就需要处理了。\n\n就像一个水库，日常蓄水是正常的，但下游泄洪能力太差，导致水库水位一直不停的上涨，这个就不正常了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565055112,"ip_address":"","comment_id":121005,"utype":1}],"discussion_count":10,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师好，我一直理解，消息积压不是一种正常的现象吗？来不及处理的消息先在消息队列中存着，缓解下游系统的压力，让上下游系统在时间上解偶，，听了今天的课，感觉理解的不太一样，希望老师解答一下","like_count":65,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461637,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736650,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyuuhxu0HH4cIKCClCqx0LTurCCYWmNcFwfTWV5te5afsibp2yuDmC9mibEHx0Xy8QlvqvMWWcAib8g/132","nickname":"我的喵","note":"","ucode":"A7435BDBDD2587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570664,"discussion_content":"第3点不太认同，批量消费模式假如设置每次批量消费10条，如果没有10条，只有5条，肯定不会说等有10条了再消费","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1651848871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251835,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oiboHpgukqib2ASXeU0H7W1ibgRMqyrNE5KaWicicPEDy0ia8YdoneZAtvW0EFIiaqZJp2OS4dnweOgXaJ5EjJicicEqic5A/132","nickname":"覃钰栋","note":"","ucode":"19080C463658EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1736650,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyuuhxu0HH4cIKCClCqx0LTurCCYWmNcFwfTWV5te5afsibp2yuDmC9mibEHx0Xy8QlvqvMWWcAib8g/132","nickname":"我的喵","note":"","ucode":"A7435BDBDD2587","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607664,"discussion_content":"加超时时间，有些埋点数据上报、日志数据，可以用这种方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678079878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":570664,"ip_address":"广东","group_id":0},"score":607664,"extra":""}]},{"author":{"id":1166968,"avatar":"","nickname":"fisherhe","note":"","ucode":"7B5F692546279D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607085,"discussion_content":"关于第三条，我补充一点，有些消息队列可以设置batchsize以及waitTime，如果超过了waittime，那么即便没有满足batchsize也会broker中的消息推给consumer.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1677592378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1501593,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJ5Hnw1tL9EWGdzhibCw89hibKjibwcyUBCSJsQWaxxfGu5AkBibibV0anaKqw3nf3ZP0UWy5BaEYyw2Q/132","nickname":"smilekaka","note":"","ucode":"C01D8020019FDC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1166968,"avatar":"","nickname":"fisherhe","note":"","ucode":"7B5F692546279D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647155,"discussion_content":"对的，大多数是这样， rocketmq 也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1719561450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":607085,"ip_address":"江苏","group_id":0},"score":647155,"extra":""}]},{"author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327136,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605753189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121124,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1565061671,"is_pvip":false,"replies":[{"id":44628,"content":"非常好！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138815,"ip_address":"","comment_id":121124,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"尝试回答下课后习题，老师有空帮忙看下哦\n消费端进行批量操作，感觉和上面的先将消息放在内存队列中，然后在并发消费消息，如果机器宕机，这些批量消息都会丢失，如果在数据库层面，批量操作在大事务，会导致锁的竞争，并且也会导致主备的不一致。如果是一些不重要的消息如对日志进行备份，就可以使用批量操作之类的提高消费性能，因为一些日志消息丢失也是可以接受的。","like_count":27,"discussions":[{"author":{"id":1010680,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","nickname":"大魔王汪汪","note":"","ucode":"4B205CB52FC95F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4004,"discussion_content":"看业务特点，有的业务是对于延迟敏感的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1565055037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461570,"discussion_content":"消息积压是正常现象，积压越来越多就需要处理了。\n\n就像一个水库，日常蓄水是正常的，但下游泄洪能力太差，导致水库水位一直不停的上涨，这个就不正常了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565055112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625530,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/ba/3a348f2d.jpg","nickname":"YueShi","note":"","ucode":"8F7AFAE4641A7D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594460,"discussion_content":"积压等于内存泄露，持续不停的内存泄露","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669045385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573912,"discussion_content":"可以设置一个阈值，比如兔子mq 可以设置占用磁盘多少，就不做处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653727804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1137330,"avatar":"","nickname":"ken","note":"","ucode":"606DA1C78E67F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387864,"discussion_content":"老师的回答很经典  正好回答了 最近zhengzhou 发生的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628477901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2552742,"avatar":"https://static001.geekbang.org/account/avatar/00/26/f3/a6/1dd784f6.jpg","nickname":"里河","note":"","ucode":"0A05A5F7A19EFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370011,"discussion_content":"所以这个度要怎么评估，比如，消息队列一直维持着最大容量70%平衡，可以容忍么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619250429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1612933,"avatar":"","nickname":"Thomas Yang","note":"","ucode":"29249144F708D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348207,"discussion_content":"产能过剩，内需不足😎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612467375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332138,"discussion_content":"涨完了可以下去就行，关键是怕一直涨。但蛋疼的地方就在于：一旦发现积压了，你在初期，根本不知道是会下去、还是会一直涨。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607073253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2633118,"avatar":"https://static001.geekbang.org/account/avatar/00/28/2d/9e/46d546af.jpg","nickname":"坚持","note":"","ucode":"23A42D7CCF8ACC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391684,"discussion_content":"设置一个阈值就行了，超过了这个阈值就介入，正常的系统是有一个正常的压力区间的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630573969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332138,"ip_address":"","group_id":0},"score":391684,"extra":""}]},{"author":{"id":1505221,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f7/c5/ffe52e87.jpg","nickname":"阿拉西恩木","note":"","ucode":"A3A62175137D3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308987,"discussion_content":"最怕的就是越积越多 那真的爆炸","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601150063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121164,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1565068945,"is_pvip":false,"replies":[{"id":44625,"content":"总结的非常好！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138728,"ip_address":"","comment_id":121164,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"1.无法提升消费业务效率（仅受消费业务自身逻辑影响），但可以提高mq中堆积消息消费的整体吞吐量（批推比单推mq耗时较短）。\n2.数据增量同步，监控信息采集。（非核心业务的稳定大数据流操作）。\n3.批处理意味数据积累和大数据传输，这会让单次消费的最长时延变长。同时批量操作为了保证当前批量操作一致性，在个别失败的情况下会引发批量操作重试。","like_count":24,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461659,"discussion_content":"总结的非常好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184425,"user_name":"SunshineBoy","can_delete":false,"product_type":"c1","uid":1160644,"ip_address":"","ucode":"FC54CD1815CCBA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/c4/9148b40d.jpg","comment_is_top":false,"comment_ctime":1583312526,"is_pvip":false,"replies":[{"id":71367,"content":"你可以简单计算一下，消费并行度：单实例平均消费tps * 消费并行度 &gt; 生产消息的总tps\n\n消费并行度 = min（consumer实例数，分区数量）","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1583372945,"ip_address":"","comment_id":184425,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"如何判断增加多少consumer消费实例的个数？","like_count":15,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486009,"discussion_content":"你可以简单计算一下，消费并行度：单实例平均消费tps * 消费并行度 &amp;gt; 生产消息的总tps\n\n消费并行度 = min（consumer实例数，分区数量）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583372945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124587,"user_name":"lecy_L","can_delete":false,"product_type":"c1","uid":1127659,"ip_address":"","ucode":"7C96DDBB3D1F7E","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","comment_is_top":false,"comment_ctime":1565925245,"is_pvip":false,"replies":[{"id":45890,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566120923,"ip_address":"","comment_id":124587,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"消息积压处理：\n1、发送端优化，增加批量和线程并发两种方式处理\n2、消费端优化，优化业务逻辑代码、水平扩容增加并发并同步扩容分区数量\n查看消息积压的方法：\n1、消息队列内置监控，查看发送端发送消息与消费端消费消息的速度变化\n2、查看日志是否有大量的消费错误\n3、打印堆栈信息，查看消费线程卡点信息","like_count":13,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486009,"discussion_content":"你可以简单计算一下，消费并行度：单实例平均消费tps * 消费并行度 &amp;gt; 生产消息的总tps\n\n消费并行度 = min（consumer实例数，分区数量）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583372945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121320,"user_name":"亚洲舞王.尼古拉斯赵四","can_delete":false,"product_type":"c1","uid":1443078,"ip_address":"","ucode":"7159F5D7232696","user_header":"https://static001.geekbang.org/account/avatar/00/16/05/06/f5979d65.jpg","comment_is_top":false,"comment_ctime":1565099401,"is_pvip":false,"replies":[{"id":44600,"content":"是这样的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565137459,"ip_address":"","comment_id":121320,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"如果使用了批量消费的方式，那么就需要批量确认，如果一次消费十条消息，除了第七条消费失败了，其他的都处理成功了，但是这中情况下broker只能将消费的游标修改成消息7，而之后的消息虽然处理成功了，但是也只能使用类似于拉回重传的方式再次消费，浪费性能，而且这种批量消费对于消费者的并发我觉得不是很友好，可能消费者1来了取走了十条消息在处理，这时候消费者2过来了也想取十条消息，但是他需要等待消费者1进行ack才可以取走消息，不知道说的对不对，请老师指正","like_count":13,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461739,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565137459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2062402,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOnpl8fRB9r2vED2s8j7Arwbn2K6M6HUBWNjgoqV4uqe94fTGK4WGpOJLeRxXcBXk3dp23eQR0AQ/132","nickname":"吴钩","note":"","ucode":"0EB50E8144BCDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627601,"discussion_content":"一个partition不是只对应一个消费者么，怎么会有两个？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694332485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130213,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1567404698,"is_pvip":false,"replies":[{"id":48729,"content":"理论上是可以的，但你要注意，像RocketMQ，采用默认配置的时候，onMessage方法结束后，如果没抛异常，默认就会自动确认了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567492854,"ip_address":"","comment_id":130213,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，如果onMessage方法中，收到消息后不确认，等真正处理完消息再确认，就可以了吧，这样就可以用内存队列了","like_count":10,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465859,"discussion_content":"理论上是可以的，但你要注意，像RocketMQ，采用默认配置的时候，onMessage方法结束后，如果没抛异常，默认就会自动确认了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567492854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369270,"discussion_content":"rocketmq的push模式默认是跑批批量自动确认","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618993249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205813,"user_name":"涛涛","can_delete":false,"product_type":"c1","uid":1180810,"ip_address":"","ucode":"747C4B1F20A2D3","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/8a/ff94bd60.jpg","comment_is_top":false,"comment_ctime":1586742708,"is_pvip":false,"replies":[{"id":77018,"content":"不会的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1586830990,"ip_address":"","comment_id":205813,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"临时扩容消息分区，已堆积的消息会转移到新分区上吗？","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465859,"discussion_content":"理论上是可以的，但你要注意，像RocketMQ，采用默认配置的时候，onMessage方法结束后，如果没抛异常，默认就会自动确认了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567492854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369270,"discussion_content":"rocketmq的push模式默认是跑批批量自动确认","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618993249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186029,"user_name":"传志","can_delete":false,"product_type":"c1","uid":1097943,"ip_address":"","ucode":"2B0F67BCFCB3D5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJB6qS9nxicvToSX4fTrDNv7OVBtsrfr6VwLjPLcwZS8ibicczM15qVx473KgrYQg0TIFeibXD0RgK6WQ/132","comment_is_top":false,"comment_ctime":1583744254,"is_pvip":false,"replies":[{"id":71954,"content":"生产端发送慢不会引起消息积压的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1583821700,"ip_address":"","comment_id":186029,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师想问下，为什么生产端性能问题怎么会引起消息堆积呀","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491591,"discussion_content":"不会的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586830990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":531975,"discussion_content":"在消费端需要注意的是，增加并发需要同步扩容分区数量，否则是起不到效果的。\n------------------------\n老师，咨询下 业内的最佳做法，一般是直接在原topic上直接扩容分区，还是直接新建一个更多分区的topic，然后消息转达到新的topic去处理呀？\n\n感谢老师的回答\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637486933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":491591,"ip_address":"","group_id":0},"score":531975,"extra":"{\"user_type\":1}"},{"author":{"id":2105473,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9D0cO7m8UIB3CsLUzoAGCiaHqziaCED9BmicDHOVicSyrpNIsaxTicboiaicHI8nC4dTib8l1LO7Qaty7cQ/132","nickname":"Geek_fe60a8","note":"","ucode":"6D03D11EEF0C96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550873,"discussion_content":"后者肯定要好一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644765047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531975,"ip_address":"","group_id":0},"score":550873,"extra":""}]},{"author":{"id":1101234,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/b2/807137b9.jpg","nickname":"北方易初","note":"","ucode":"C57FDBD37F43E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560403,"discussion_content":"用 kafka 提供的 kafka-reassign-partitions.sh 脚本可以手动得将堆积的消息转到新增加的分区上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649315915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121122,"user_name":"大白给小白讲故事","can_delete":false,"product_type":"c1","uid":1258557,"ip_address":"","ucode":"4538C24B67B513","user_header":"https://static001.geekbang.org/account/avatar/00/13/34/3d/51762e76.jpg","comment_is_top":false,"comment_ctime":1565061464,"is_pvip":false,"replies":[{"id":44629,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138836,"ip_address":"","comment_id":121122,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"1、要求消费端能够批量处理或者开启多线程进行单条处理\n2、批量消费一旦某一条数据消费失败会导致整批数据重复消费\n3、对实时性要求不能太高，批量消费需要Broker积累到一定消费数据才会发送到Consumer","like_count":94,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461637,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736650,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyuuhxu0HH4cIKCClCqx0LTurCCYWmNcFwfTWV5te5afsibp2yuDmC9mibEHx0Xy8QlvqvMWWcAib8g/132","nickname":"我的喵","note":"","ucode":"A7435BDBDD2587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570664,"discussion_content":"第3点不太认同，批量消费模式假如设置每次批量消费10条，如果没有10条，只有5条，肯定不会说等有10条了再消费","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1651848871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251835,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oiboHpgukqib2ASXeU0H7W1ibgRMqyrNE5KaWicicPEDy0ia8YdoneZAtvW0EFIiaqZJp2OS4dnweOgXaJ5EjJicicEqic5A/132","nickname":"覃钰栋","note":"","ucode":"19080C463658EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1736650,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyuuhxu0HH4cIKCClCqx0LTurCCYWmNcFwfTWV5te5afsibp2yuDmC9mibEHx0Xy8QlvqvMWWcAib8g/132","nickname":"我的喵","note":"","ucode":"A7435BDBDD2587","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607664,"discussion_content":"加超时时间，有些埋点数据上报、日志数据，可以用这种方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678079878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":570664,"ip_address":"广东","group_id":0},"score":607664,"extra":""}]},{"author":{"id":1166968,"avatar":"","nickname":"fisherhe","note":"","ucode":"7B5F692546279D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607085,"discussion_content":"关于第三条，我补充一点，有些消息队列可以设置batchsize以及waitTime，如果超过了waittime，那么即便没有满足batchsize也会broker中的消息推给consumer.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1677592378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1501593,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJ5Hnw1tL9EWGdzhibCw89hibKjibwcyUBCSJsQWaxxfGu5AkBibibV0anaKqw3nf3ZP0UWy5BaEYyw2Q/132","nickname":"smilekaka","note":"","ucode":"C01D8020019FDC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1166968,"avatar":"","nickname":"fisherhe","note":"","ucode":"7B5F692546279D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647155,"discussion_content":"对的，大多数是这样， rocketmq 也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1719561450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":607085,"ip_address":"江苏","group_id":0},"score":647155,"extra":""}]},{"author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327136,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605753189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121005,"user_name":"iLeGeND","can_delete":false,"product_type":"c1","uid":1055475,"ip_address":"","ucode":"4055A628A6E97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","comment_is_top":false,"comment_ctime":1565049400,"is_pvip":false,"replies":[{"id":44476,"content":"消息积压是正常现象，积压越来越多就需要处理了。\n\n就像一个水库，日常蓄水是正常的，但下游泄洪能力太差，导致水库水位一直不停的上涨，这个就不正常了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565055112,"ip_address":"","comment_id":121005,"utype":1}],"discussion_count":10,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师好，我一直理解，消息积压不是一种正常的现象吗？来不及处理的消息先在消息队列中存着，缓解下游系统的压力，让上下游系统在时间上解偶，，听了今天的课，感觉理解的不太一样，希望老师解答一下","like_count":65,"discussions":[{"author":{"id":1010680,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","nickname":"大魔王汪汪","note":"","ucode":"4B205CB52FC95F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4004,"discussion_content":"看业务特点，有的业务是对于延迟敏感的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1565055037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461570,"discussion_content":"消息积压是正常现象，积压越来越多就需要处理了。\n\n就像一个水库，日常蓄水是正常的，但下游泄洪能力太差，导致水库水位一直不停的上涨，这个就不正常了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565055112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625530,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/ba/3a348f2d.jpg","nickname":"YueShi","note":"","ucode":"8F7AFAE4641A7D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594460,"discussion_content":"积压等于内存泄露，持续不停的内存泄露","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669045385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573912,"discussion_content":"可以设置一个阈值，比如兔子mq 可以设置占用磁盘多少，就不做处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653727804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1137330,"avatar":"","nickname":"ken","note":"","ucode":"606DA1C78E67F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387864,"discussion_content":"老师的回答很经典  正好回答了 最近zhengzhou 发生的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628477901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2552742,"avatar":"https://static001.geekbang.org/account/avatar/00/26/f3/a6/1dd784f6.jpg","nickname":"里河","note":"","ucode":"0A05A5F7A19EFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370011,"discussion_content":"所以这个度要怎么评估，比如，消息队列一直维持着最大容量70%平衡，可以容忍么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619250429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1612933,"avatar":"","nickname":"Thomas Yang","note":"","ucode":"29249144F708D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348207,"discussion_content":"产能过剩，内需不足😎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612467375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332138,"discussion_content":"涨完了可以下去就行，关键是怕一直涨。但蛋疼的地方就在于：一旦发现积压了，你在初期，根本不知道是会下去、还是会一直涨。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607073253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2633118,"avatar":"https://static001.geekbang.org/account/avatar/00/28/2d/9e/46d546af.jpg","nickname":"坚持","note":"","ucode":"23A42D7CCF8ACC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391684,"discussion_content":"设置一个阈值就行了，超过了这个阈值就介入，正常的系统是有一个正常的压力区间的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630573969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332138,"ip_address":"","group_id":0},"score":391684,"extra":""}]},{"author":{"id":1505221,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f7/c5/ffe52e87.jpg","nickname":"阿拉西恩木","note":"","ucode":"A3A62175137D3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308987,"discussion_content":"最怕的就是越积越多 那真的爆炸","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601150063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121124,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1565061671,"is_pvip":false,"replies":[{"id":44628,"content":"非常好！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138815,"ip_address":"","comment_id":121124,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"尝试回答下课后习题，老师有空帮忙看下哦\n消费端进行批量操作，感觉和上面的先将消息放在内存队列中，然后在并发消费消息，如果机器宕机，这些批量消息都会丢失，如果在数据库层面，批量操作在大事务，会导致锁的竞争，并且也会导致主备的不一致。如果是一些不重要的消息如对日志进行备份，就可以使用批量操作之类的提高消费性能，因为一些日志消息丢失也是可以接受的。","like_count":27,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461639,"discussion_content":"非常好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408000,"discussion_content":"我们是仿照reactor线程池来做的 就是消费者线程始终只有一个 保证每个分区订阅到一个线程。但是消费者线程拉取批量消息后 是扔到线程池里当场消化掉 再计算偏移量一起提交。\n\n这里有两个问题：\n1. 如果当中有几个消息始终无法消费 那么消费就会被卡住 这个和单线程的场景本质上是一样的 处理方式就是记录下来 直接跳过。或者像rocketmq一样 搞个死信队列\n2. 起用线程池后 会因为单个线程处理快慢 导致消费者线程上报offset速率不稳定。 这个问题很常见  我们是对于时延久的消息 会单独记录下来 事后做回放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635165996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1386315,"avatar":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","nickname":"Rover","note":"","ucode":"7575EC91F45B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357931,"discussion_content":"批量消费，是否可在全部消费成功后提交offset","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615898119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1386315,"avatar":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","nickname":"Rover","note":"","ucode":"7575EC91F45B99","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547127,"discussion_content":"1）、如果你一批消息并不是全部失败，而是中间失败了几条这种怎么办？比如十条消息，你失败了第3 7 9条，你该怎么办？可能下一步就是筛选出失败的 转发到另外一个队列做重试消费。。\n2）还有为了加快消费，消费端开多线程并发消费这一批消息，也能显著提升效率，对吧。。，但是一旦开了多线程又回到第一个问题\n好，主角来了，没错。。rocketmq 就是这么办的。。client 默认实现多线程消费，且 client自动处理消费失败的与broker的配合实现重试消费\n总结： 业务优先考虑rocketmq","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642554639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":357931,"ip_address":"","group_id":0},"score":547127,"extra":""}]}]},{"had_liked":false,"id":121164,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1565068945,"is_pvip":false,"replies":[{"id":44625,"content":"总结的非常好！","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138728,"ip_address":"","comment_id":121164,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"1.无法提升消费业务效率（仅受消费业务自身逻辑影响），但可以提高mq中堆积消息消费的整体吞吐量（批推比单推mq耗时较短）。\n2.数据增量同步，监控信息采集。（非核心业务的稳定大数据流操作）。\n3.批处理意味数据积累和大数据传输，这会让单次消费的最长时延变长。同时批量操作为了保证当前批量操作一致性，在个别失败的情况下会引发批量操作重试。","like_count":24,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461639,"discussion_content":"非常好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408000,"discussion_content":"我们是仿照reactor线程池来做的 就是消费者线程始终只有一个 保证每个分区订阅到一个线程。但是消费者线程拉取批量消息后 是扔到线程池里当场消化掉 再计算偏移量一起提交。\n\n这里有两个问题：\n1. 如果当中有几个消息始终无法消费 那么消费就会被卡住 这个和单线程的场景本质上是一样的 处理方式就是记录下来 直接跳过。或者像rocketmq一样 搞个死信队列\n2. 起用线程池后 会因为单个线程处理快慢 导致消费者线程上报offset速率不稳定。 这个问题很常见  我们是对于时延久的消息 会单独记录下来 事后做回放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635165996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1386315,"avatar":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","nickname":"Rover","note":"","ucode":"7575EC91F45B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357931,"discussion_content":"批量消费，是否可在全部消费成功后提交offset","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615898119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1386315,"avatar":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","nickname":"Rover","note":"","ucode":"7575EC91F45B99","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547127,"discussion_content":"1）、如果你一批消息并不是全部失败，而是中间失败了几条这种怎么办？比如十条消息，你失败了第3 7 9条，你该怎么办？可能下一步就是筛选出失败的 转发到另外一个队列做重试消费。。\n2）还有为了加快消费，消费端开多线程并发消费这一批消息，也能显著提升效率，对吧。。，但是一旦开了多线程又回到第一个问题\n好，主角来了，没错。。rocketmq 就是这么办的。。client 默认实现多线程消费，且 client自动处理消费失败的与broker的配合实现重试消费\n总结： 业务优先考虑rocketmq","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642554639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":357931,"ip_address":"","group_id":0},"score":547127,"extra":""}]}]},{"had_liked":false,"id":184425,"user_name":"SunshineBoy","can_delete":false,"product_type":"c1","uid":1160644,"ip_address":"","ucode":"FC54CD1815CCBA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/c4/9148b40d.jpg","comment_is_top":false,"comment_ctime":1583312526,"is_pvip":false,"replies":[{"id":71367,"content":"你可以简单计算一下，消费并行度：单实例平均消费tps * 消费并行度 &gt; 生产消息的总tps\n\n消费并行度 = min（consumer实例数，分区数量）","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1583372945,"ip_address":"","comment_id":184425,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"如何判断增加多少consumer消费实例的个数？","like_count":15,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461659,"discussion_content":"总结的非常好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124587,"user_name":"lecy_L","can_delete":false,"product_type":"c1","uid":1127659,"ip_address":"","ucode":"7C96DDBB3D1F7E","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","comment_is_top":false,"comment_ctime":1565925245,"is_pvip":false,"replies":[{"id":45890,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566120923,"ip_address":"","comment_id":124587,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"消息积压处理：\n1、发送端优化，增加批量和线程并发两种方式处理\n2、消费端优化，优化业务逻辑代码、水平扩容增加并发并同步扩容分区数量\n查看消息积压的方法：\n1、消息队列内置监控，查看发送端发送消息与消费端消费消息的速度变化\n2、查看日志是否有大量的消费错误\n3、打印堆栈信息，查看消费线程卡点信息","like_count":13,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463236,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566120923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408003,"discussion_content":"使用kafka的同学要注意 随意的同时扩容分区 消费者 会造成线程STW。因为消费者平衡用的是协议来做 这点在2.1之前一直是这样。所以如果消费者数量特别多 那么高峰期扩容并不是个好的选择  我们的处理方式是做消息转发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635166125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2026074,"avatar":"","nickname":"尼古拉斯","note":"","ucode":"82EE35B505C09A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352638,"discussion_content":"消息挤压了需要考虑优化发送端么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614784579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121320,"user_name":"亚洲舞王.尼古拉斯赵四","can_delete":false,"product_type":"c1","uid":1443078,"ip_address":"","ucode":"7159F5D7232696","user_header":"https://static001.geekbang.org/account/avatar/00/16/05/06/f5979d65.jpg","comment_is_top":false,"comment_ctime":1565099401,"is_pvip":false,"replies":[{"id":44600,"content":"是这样的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565137459,"ip_address":"","comment_id":121320,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"如果使用了批量消费的方式，那么就需要批量确认，如果一次消费十条消息，除了第七条消费失败了，其他的都处理成功了，但是这中情况下broker只能将消费的游标修改成消息7，而之后的消息虽然处理成功了，但是也只能使用类似于拉回重传的方式再次消费，浪费性能，而且这种批量消费对于消费者的并发我觉得不是很友好，可能消费者1来了取走了十条消息在处理，这时候消费者2过来了也想取十条消息，但是他需要等待消费者1进行ack才可以取走消息，不知道说的对不对，请老师指正","like_count":13,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463236,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566120923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408003,"discussion_content":"使用kafka的同学要注意 随意的同时扩容分区 消费者 会造成线程STW。因为消费者平衡用的是协议来做 这点在2.1之前一直是这样。所以如果消费者数量特别多 那么高峰期扩容并不是个好的选择  我们的处理方式是做消息转发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635166125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2026074,"avatar":"","nickname":"尼古拉斯","note":"","ucode":"82EE35B505C09A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352638,"discussion_content":"消息挤压了需要考虑优化发送端么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614784579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130213,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1567404698,"is_pvip":false,"replies":[{"id":48729,"content":"理论上是可以的，但你要注意，像RocketMQ，采用默认配置的时候，onMessage方法结束后，如果没抛异常，默认就会自动确认了。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567492854,"ip_address":"","comment_id":130213,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，如果onMessage方法中，收到消息后不确认，等真正处理完消息再确认，就可以了吧，这样就可以用内存队列了","like_count":10,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461739,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565137459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2062402,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOnpl8fRB9r2vED2s8j7Arwbn2K6M6HUBWNjgoqV4uqe94fTGK4WGpOJLeRxXcBXk3dp23eQR0AQ/132","nickname":"吴钩","note":"","ucode":"0EB50E8144BCDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627601,"discussion_content":"一个partition不是只对应一个消费者么，怎么会有两个？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694332485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205813,"user_name":"涛涛","can_delete":false,"product_type":"c1","uid":1180810,"ip_address":"","ucode":"747C4B1F20A2D3","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/8a/ff94bd60.jpg","comment_is_top":false,"comment_ctime":1586742708,"is_pvip":false,"replies":[{"id":77018,"content":"不会的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1586830990,"ip_address":"","comment_id":205813,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"临时扩容消息分区，已堆积的消息会转移到新分区上吗？","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491591,"discussion_content":"不会的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586830990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":531975,"discussion_content":"在消费端需要注意的是，增加并发需要同步扩容分区数量，否则是起不到效果的。\n------------------------\n老师，咨询下 业内的最佳做法，一般是直接在原topic上直接扩容分区，还是直接新建一个更多分区的topic，然后消息转达到新的topic去处理呀？\n\n感谢老师的回答\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637486933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":491591,"ip_address":"","group_id":0},"score":531975,"extra":"{\"user_type\":1}"},{"author":{"id":2105473,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9D0cO7m8UIB3CsLUzoAGCiaHqziaCED9BmicDHOVicSyrpNIsaxTicboiaicHI8nC4dTib8l1LO7Qaty7cQ/132","nickname":"Geek_fe60a8","note":"","ucode":"6D03D11EEF0C96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550873,"discussion_content":"后者肯定要好一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644765047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531975,"ip_address":"","group_id":0},"score":550873,"extra":""}]},{"author":{"id":1101234,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/b2/807137b9.jpg","nickname":"北方易初","note":"","ucode":"C57FDBD37F43E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560403,"discussion_content":"用 kafka 提供的 kafka-reassign-partitions.sh 脚本可以手动得将堆积的消息转到新增加的分区上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649315915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186029,"user_name":"传志","can_delete":false,"product_type":"c1","uid":1097943,"ip_address":"","ucode":"2B0F67BCFCB3D5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJB6qS9nxicvToSX4fTrDNv7OVBtsrfr6VwLjPLcwZS8ibicczM15qVx473KgrYQg0TIFeibXD0RgK6WQ/132","comment_is_top":false,"comment_ctime":1583744254,"is_pvip":false,"replies":[{"id":71954,"content":"生产端发送慢不会引起消息积压的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1583821700,"ip_address":"","comment_id":186029,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师想问下，为什么生产端性能问题怎么会引起消息堆积呀","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486592,"discussion_content":"生产端发送慢不会引起消息积压的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583821700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127863,"user_name":"grey927","can_delete":false,"product_type":"c1","uid":1202782,"ip_address":"","ucode":"833E02ED835B4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","comment_is_top":false,"comment_ctime":1566802041,"is_pvip":false,"replies":[{"id":47523,"content":"可以使用一个自增的原子变量，比如Java中的AtomicLong。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868569,"ip_address":"","comment_id":127863,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"发送端如果多线程，如何实现之前您在《确保消息不会丢失》这篇文章中说的：\n发送端 把发送消息标识为每次增加1的效果？","like_count":6},{"had_liked":false,"id":125320,"user_name":"快快","can_delete":false,"product_type":"c1","uid":1003730,"ip_address":"","ucode":"684A0C7FF8DC61","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/d2/ace2a48e.jpg","comment_is_top":false,"comment_ctime":1566146847,"is_pvip":false,"replies":[{"id":46021,"content":"不仅是扩容时候，只要是consumer和partition有一方的数量变化，都会触发reblance。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566175478,"ip_address":"","comment_id":125320,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，kafka扩容时会发出reblance吧","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464685,"discussion_content":"可以使用一个自增的原子变量，比如Java中的AtomicLong。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2309764,"avatar":"","nickname":"wjxfosu","note":"","ucode":"3AA85051804493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375903,"discussion_content":"AtomicLong会用完吧？！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621864598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122820,"user_name":"Stenvien","can_delete":false,"product_type":"c1","uid":1083774,"ip_address":"","ucode":"8B8E33D517D1AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/7e/f41ca6b5.jpg","comment_is_top":false,"comment_ctime":1565534853,"is_pvip":false,"replies":[{"id":45106,"content":"有的消息中间件提供了“死信队列”的功能，它会自动把这种反复消费都失败的消息丢到一个特殊的死信队列中，避免一条消息卡主队列的情况。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565574971,"ip_address":"","comment_id":122820,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"如果消费者消费异常，即使多次消费也无法成功处理（如消息格式异常），导致一直无法成功ack此条消息，这种场景一般要怎么处理？\n\n我想到有2种：\n1. 不做任何处理，消费者会一直卡在此消息的处理上，那么后面的所有消息都没机会处理了，只能靠监控发现消费延迟，发出告警，人工修复。这种处理方式会导致一条有问题的消息就影响了整个业务 \n2. 数据库存储此异常的消息，并发告警，人工修复，仍然ack此消息，继续消费后面的消息。但是，若对消息的处理顺序有依赖，若没有成功处理此异常消息，消费的后面的消息的处理可能会有问题\n\n是否有更好的处理方式？","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463525,"discussion_content":"不仅是扩容时候，只要是consumer和partition有一方的数量变化，都会触发reblance。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566175478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122780,"user_name":"我瑟瑟的方法","can_delete":false,"product_type":"c1","uid":1065819,"ip_address":"","ucode":"1364CD531E1B72","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg","comment_is_top":false,"comment_ctime":1565520156,"is_pvip":false,"replies":[{"id":45104,"content":"是的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565574830,"ip_address":"","comment_id":122780,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。\n\n——&#47;&#47;&#47;&#47;&#47;——-\n老师这一步怎么保证啊，需要业务consumer团队联系消息中间件团队一起运维配合吗？","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462400,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565574830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122080,"user_name":"guoguo 👻","can_delete":false,"product_type":"c1","uid":1025664,"ip_address":"","ucode":"874B0A1E0F7DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/80/6ff7ea5f.jpg","comment_is_top":false,"comment_ctime":1565280870,"is_pvip":false,"replies":[{"id":44892,"content":"一次取一批消息，等这一批消息都成功了，再提交最后一条消息的位置作为新的消费位置。如果其中任何一条失败，则认为整批都失败。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565326173,"ip_address":"","comment_id":122080,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"只能在消费端开多个线程并行消费。\n\n题目所说的批量消费是什么意思，多次取消息，放在内存里，批量消费？消息不会丢么？","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462088,"discussion_content":"一次取一批消息，等这一批消息都成功了，再提交最后一条消息的位置作为新的消费位置。如果其中任何一条失败，则认为整批都失败。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565326173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206822,"user_name":"Get it","can_delete":false,"product_type":"c1","uid":1966532,"ip_address":"","ucode":"B86704EB135F03","user_header":"","comment_is_top":false,"comment_ctime":1586941308,"is_pvip":false,"replies":[{"id":77855,"content":"有些消息队列有针对这个问题的解决方案，比如RocketMQ有死信队列，对于多次消费的失败的消息，扔到死信队列中，避免坏消息卡住队列。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1587353318,"ip_address":"","comment_id":206822,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，你好\n想请问下在消费端 一般通过先处理业务逻辑再确认消息以保证消息不丢失\n但是如果业务逻辑有未知风险会持续抛出异常导致消息一直无法消费导致积压一般如何解决呢","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491915,"discussion_content":"有些消息队列有针对这个问题的解决方案，比如RocketMQ有死信队列，对于多次消费的失败的消息，扔到死信队列中，避免坏消息卡住队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587353318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202828,"user_name":"睡在床板下","can_delete":false,"product_type":"c1","uid":1267832,"ip_address":"","ucode":"69BF52FF9C8A0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/58/78/fe19274b.jpg","comment_is_top":false,"comment_ctime":1586074773,"is_pvip":false,"replies":[{"id":76060,"content":"一般来说，队列（分区）数量最好和消费者的实例数保持一致，这样能达到最佳的消费性能。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1586223755,"ip_address":"","comment_id":202828,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，像rabbitmq 消费无法扩充分区，那么只能扩充消费者吗？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490696,"discussion_content":"一般来说，队列（分区）数量最好和消费者的实例数保持一致，这样能达到最佳的消费性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586223755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126157,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566342807,"is_pvip":false,"replies":[{"id":46515,"content":"第一个问题，主流的消息队列都有实现，区别是，Kafka它是自动异步批量发送，而其它消息队列会提供一个类似batchSend(Msg [] messages)的批量发送的方法，由使用者决定是否批量发送以及批量大小。\n\n第二个问题我们后面的课程会有专门的讲解。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566351794,"ip_address":"","comment_id":126157,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"1：请教几个小问题\n1-1：目前那些消息队列产品实现了批量消费？\n1-2：批量消费的实现原理是怎用的？类似文中的例子直接放入一个内存队列中，然后再开启多线程批量消费嘛？\n\n2：课后思考\n2-1：在消费端是否可以通过批量消费的方式来提升消费性能？\n可以\n2-2：在什么样场景下，适合使用这种方法？\n不担心重复消费，网络环境比较稳定，消费者端机器比较稳定\n2-3：这种方法有什么局限性？\n首先，使用的消息队列产品支持批量消费\n然后，一次取多条消息，性能节省在连接建立上，消息量大在传输时会多耗一点，且消息者只能消费完一批消息，才能返回确认，会耽误点时间取下一批消息\n最后，如果一批消息的消费过程中有一个失败了，假如一次消费1000条消息，消费第1000条时失败了，则整批消息都算失败了，那会重试，则前面999条消息都会重复消费，如果都有幂等控制也没什么，不过这种情况会使单台消息消费成功的时间加长许多。\n\n3：本节小结\n3-1：消息积压怎么产生的？\n要么生产者太快了，要么消费者太慢了，这是相对的，但无论如何根本就是消费者的消费速度＜生产者的生产速度。\n3-2：消息积压咋弄？\n3-2-1：就让他积压，不管\n3-2-2：有时为了缓解消费者的压力，还会故意让他积压\n3-2-3：优化消费者逻辑，比如：将慢逻辑移出去，再将消息倒一道手\n3-2-4：扩容，消费者扩容，broker也扩容，保持同一个主题下的分区和消费者实例一一对应，充分发挥消费者的性能\n3-2-5：某些情况可以使消费者侧批量消费消息的方式，来提高性能\n","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463854,"discussion_content":"第一个问题，主流的消息队列都有实现，区别是，Kafka它是自动异步批量发送，而其它消息队列会提供一个类似batchSend(Msg [] messages)的批量发送的方法，由使用者决定是否批量发送以及批量大小。\n\n第二个问题我们后面的课程会有专门的讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566351794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121180,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1565071680,"is_pvip":true,"replies":[{"id":44624,"content":"一般的做法是，每条数据对应一条消息，然后把一批消息一起发送。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138654,"ip_address":"","comment_id":121180,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"“你可以批量从数据库读取数据，然后批量来发送消息，同样用少量的并发就可以获得非常高的吞吐量。”老师我想问下这里生产端批量读取的数据是分多条消息发送，还是作为一条消息发送的，这里有点不太理解这个过程\n","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461667,"discussion_content":"一般的做法是，每条数据对应一条消息，然后把一批消息一起发送。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121048,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1565053024,"is_pvip":false,"replies":[{"id":44477,"content":"一般的业务在乎数据的一致性，建议还是单条去更新数据库。至于数据库连接数的问题，一般都是用数据库的连接池来解决。\n\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565055233,"ip_address":"","comment_id":121048,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"我从数据库方面的现状去解释不知道是否合理啊，错误之处还望老师指点；消费者可以通过批量，不过前提是不能超过内存库&#47;数据库的最大连接数，否则消费者一次性发送给内存库&#47;数据库的请求数过多反而失去了它的意义。\n消息队列的目的就是减轻一次性对内存库&#47;数据库的访问数，从而倒是数据库出问题；如果消费者的批量上限没有超过数据库最大的连接数那么可以，反之则不行。不止是否理解正确","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461593,"discussion_content":"一般的业务在乎数据的一致性，建议还是单条去更新数据库。至于数据库连接数的问题，一般都是用数据库的连接池来解决。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565055233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127863,"user_name":"grey927","can_delete":false,"product_type":"c1","uid":1202782,"ip_address":"","ucode":"833E02ED835B4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","comment_is_top":false,"comment_ctime":1566802041,"is_pvip":false,"replies":[{"id":47523,"content":"可以使用一个自增的原子变量，比如Java中的AtomicLong。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868569,"ip_address":"","comment_id":127863,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"发送端如果多线程，如何实现之前您在《确保消息不会丢失》这篇文章中说的：\n发送端 把发送消息标识为每次增加1的效果？","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464685,"discussion_content":"可以使用一个自增的原子变量，比如Java中的AtomicLong。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2309764,"avatar":"","nickname":"wjxfosu","note":"","ucode":"3AA85051804493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375903,"discussion_content":"AtomicLong会用完吧？！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621864598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125320,"user_name":"快快","can_delete":false,"product_type":"c1","uid":1003730,"ip_address":"","ucode":"684A0C7FF8DC61","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/d2/ace2a48e.jpg","comment_is_top":false,"comment_ctime":1566146847,"is_pvip":false,"replies":[{"id":46021,"content":"不仅是扩容时候，只要是consumer和partition有一方的数量变化，都会触发reblance。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566175478,"ip_address":"","comment_id":125320,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，kafka扩容时会发出reblance吧","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463525,"discussion_content":"不仅是扩容时候，只要是consumer和partition有一方的数量变化，都会触发reblance。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566175478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122820,"user_name":"Stenvien","can_delete":false,"product_type":"c1","uid":1083774,"ip_address":"","ucode":"8B8E33D517D1AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/7e/f41ca6b5.jpg","comment_is_top":false,"comment_ctime":1565534853,"is_pvip":false,"replies":[{"id":45106,"content":"有的消息中间件提供了“死信队列”的功能，它会自动把这种反复消费都失败的消息丢到一个特殊的死信队列中，避免一条消息卡主队列的情况。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565574971,"ip_address":"","comment_id":122820,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"如果消费者消费异常，即使多次消费也无法成功处理（如消息格式异常），导致一直无法成功ack此条消息，这种场景一般要怎么处理？\n\n我想到有2种：\n1. 不做任何处理，消费者会一直卡在此消息的处理上，那么后面的所有消息都没机会处理了，只能靠监控发现消费延迟，发出告警，人工修复。这种处理方式会导致一条有问题的消息就影响了整个业务 \n2. 数据库存储此异常的消息，并发告警，人工修复，仍然ack此消息，继续消费后面的消息。但是，若对消息的处理顺序有依赖，若没有成功处理此异常消息，消费的后面的消息的处理可能会有问题\n\n是否有更好的处理方式？","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462417,"discussion_content":"有的消息中间件提供了“死信队列”的功能，它会自动把这种反复消费都失败的消息丢到一个特殊的死信队列中，避免一条消息卡主队列的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565574971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122780,"user_name":"我瑟瑟的方法","can_delete":false,"product_type":"c1","uid":1065819,"ip_address":"","ucode":"1364CD531E1B72","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg","comment_is_top":false,"comment_ctime":1565520156,"is_pvip":false,"replies":[{"id":45104,"content":"是的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565574830,"ip_address":"","comment_id":122780,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。\n\n——&#47;&#47;&#47;&#47;&#47;——-\n老师这一步怎么保证啊，需要业务consumer团队联系消息中间件团队一起运维配合吗？","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462417,"discussion_content":"有的消息中间件提供了“死信队列”的功能，它会自动把这种反复消费都失败的消息丢到一个特殊的死信队列中，避免一条消息卡主队列的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565574971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122080,"user_name":"guoguo 👻","can_delete":false,"product_type":"c1","uid":1025664,"ip_address":"","ucode":"874B0A1E0F7DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/80/6ff7ea5f.jpg","comment_is_top":false,"comment_ctime":1565280870,"is_pvip":false,"replies":[{"id":44892,"content":"一次取一批消息，等这一批消息都成功了，再提交最后一条消息的位置作为新的消费位置。如果其中任何一条失败，则认为整批都失败。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565326173,"ip_address":"","comment_id":122080,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"只能在消费端开多个线程并行消费。\n\n题目所说的批量消费是什么意思，多次取消息，放在内存里，批量消费？消息不会丢么？","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462400,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565574830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206822,"user_name":"Get it","can_delete":false,"product_type":"c1","uid":1966532,"ip_address":"","ucode":"B86704EB135F03","user_header":"","comment_is_top":false,"comment_ctime":1586941308,"is_pvip":false,"replies":[{"id":77855,"content":"有些消息队列有针对这个问题的解决方案，比如RocketMQ有死信队列，对于多次消费的失败的消息，扔到死信队列中，避免坏消息卡住队列。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1587353318,"ip_address":"","comment_id":206822,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，你好\n想请问下在消费端 一般通过先处理业务逻辑再确认消息以保证消息不丢失\n但是如果业务逻辑有未知风险会持续抛出异常导致消息一直无法消费导致积压一般如何解决呢","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462088,"discussion_content":"一次取一批消息，等这一批消息都成功了，再提交最后一条消息的位置作为新的消费位置。如果其中任何一条失败，则认为整批都失败。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565326173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202828,"user_name":"睡在床板下","can_delete":false,"product_type":"c1","uid":1267832,"ip_address":"","ucode":"69BF52FF9C8A0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/58/78/fe19274b.jpg","comment_is_top":false,"comment_ctime":1586074773,"is_pvip":false,"replies":[{"id":76060,"content":"一般来说，队列（分区）数量最好和消费者的实例数保持一致，这样能达到最佳的消费性能。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1586223755,"ip_address":"","comment_id":202828,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，像rabbitmq 消费无法扩充分区，那么只能扩充消费者吗？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491915,"discussion_content":"有些消息队列有针对这个问题的解决方案，比如RocketMQ有死信队列，对于多次消费的失败的消息，扔到死信队列中，避免坏消息卡住队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587353318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126157,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566342807,"is_pvip":false,"replies":[{"id":46515,"content":"第一个问题，主流的消息队列都有实现，区别是，Kafka它是自动异步批量发送，而其它消息队列会提供一个类似batchSend(Msg [] messages)的批量发送的方法，由使用者决定是否批量发送以及批量大小。\n\n第二个问题我们后面的课程会有专门的讲解。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566351794,"ip_address":"","comment_id":126157,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"1：请教几个小问题\n1-1：目前那些消息队列产品实现了批量消费？\n1-2：批量消费的实现原理是怎用的？类似文中的例子直接放入一个内存队列中，然后再开启多线程批量消费嘛？\n\n2：课后思考\n2-1：在消费端是否可以通过批量消费的方式来提升消费性能？\n可以\n2-2：在什么样场景下，适合使用这种方法？\n不担心重复消费，网络环境比较稳定，消费者端机器比较稳定\n2-3：这种方法有什么局限性？\n首先，使用的消息队列产品支持批量消费\n然后，一次取多条消息，性能节省在连接建立上，消息量大在传输时会多耗一点，且消息者只能消费完一批消息，才能返回确认，会耽误点时间取下一批消息\n最后，如果一批消息的消费过程中有一个失败了，假如一次消费1000条消息，消费第1000条时失败了，则整批消息都算失败了，那会重试，则前面999条消息都会重复消费，如果都有幂等控制也没什么，不过这种情况会使单台消息消费成功的时间加长许多。\n\n3：本节小结\n3-1：消息积压怎么产生的？\n要么生产者太快了，要么消费者太慢了，这是相对的，但无论如何根本就是消费者的消费速度＜生产者的生产速度。\n3-2：消息积压咋弄？\n3-2-1：就让他积压，不管\n3-2-2：有时为了缓解消费者的压力，还会故意让他积压\n3-2-3：优化消费者逻辑，比如：将慢逻辑移出去，再将消息倒一道手\n3-2-4：扩容，消费者扩容，broker也扩容，保持同一个主题下的分区和消费者实例一一对应，充分发挥消费者的性能\n3-2-5：某些情况可以使消费者侧批量消费消息的方式，来提高性能\n","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490696,"discussion_content":"一般来说，队列（分区）数量最好和消费者的实例数保持一致，这样能达到最佳的消费性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586223755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121180,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1565071680,"is_pvip":true,"replies":[{"id":44624,"content":"一般的做法是，每条数据对应一条消息，然后把一批消息一起发送。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138654,"ip_address":"","comment_id":121180,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"“你可以批量从数据库读取数据，然后批量来发送消息，同样用少量的并发就可以获得非常高的吞吐量。”老师我想问下这里生产端批量读取的数据是分多条消息发送，还是作为一条消息发送的，这里有点不太理解这个过程\n","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463854,"discussion_content":"第一个问题，主流的消息队列都有实现，区别是，Kafka它是自动异步批量发送，而其它消息队列会提供一个类似batchSend(Msg [] messages)的批量发送的方法，由使用者决定是否批量发送以及批量大小。\n\n第二个问题我们后面的课程会有专门的讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566351794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121048,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1565053024,"is_pvip":false,"replies":[{"id":44477,"content":"一般的业务在乎数据的一致性，建议还是单条去更新数据库。至于数据库连接数的问题，一般都是用数据库的连接池来解决。\n\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565055233,"ip_address":"","comment_id":121048,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"我从数据库方面的现状去解释不知道是否合理啊，错误之处还望老师指点；消费者可以通过批量，不过前提是不能超过内存库&#47;数据库的最大连接数，否则消费者一次性发送给内存库&#47;数据库的请求数过多反而失去了它的意义。\n消息队列的目的就是减轻一次性对内存库&#47;数据库的访问数，从而倒是数据库出问题；如果消费者的批量上限没有超过数据库最大的连接数那么可以，反之则不行。不止是否理解正确","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461667,"discussion_content":"一般的做法是，每条数据对应一条消息，然后把一批消息一起发送。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215635,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1589038996,"is_pvip":true,"replies":[{"id":79940,"content":"一般来说consumer都是无状态的节点，一般的容灾手段都是：故障检测-&gt;自动拉起。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589170895,"ip_address":"","comment_id":215635,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"consumer挂了，导致的积压有什么容灾手段呢？","like_count":1},{"had_liked":false,"id":215497,"user_name":"lupguo","can_delete":false,"product_type":"c1","uid":1009098,"ip_address":"","ucode":"1B55A01DF78647","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/ca/38dcd55a.jpg","comment_is_top":false,"comment_ctime":1589002368,"is_pvip":false,"replies":[{"id":79938,"content":"是这样的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589170757,"ip_address":"","comment_id":215497,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"消费端可以通过批量来提升消费性能，相当于一次葱消费队列接受一批消息，直接ack一批消息，可以减少往返rtt。\n使用场景应该是适合接受数据可丢，且后续支持批量写数据的场景，比如批量连续的日志文件记录类似的场合。\n不知道这样理解是否正确","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494503,"discussion_content":"一般来说consumer都是无状态的节点，一般的容灾手段都是：故障检测-&amp;gt;自动拉起。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589170895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208813,"user_name":"Echo","can_delete":false,"product_type":"c1","uid":1409357,"ip_address":"","ucode":"F04C6BC4E288A7","user_header":"https://static001.geekbang.org/account/avatar/00/15/81/4d/5f892de2.jpg","comment_is_top":false,"comment_ctime":1587441636,"is_pvip":false,"replies":[{"id":78321,"content":"积压是不会导致丢消息的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1587691428,"ip_address":"","comment_id":208813,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，积压在什么情况下会导致丢消息？谢谢老师","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494458,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589170757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153418,"user_name":"攀攀","can_delete":false,"product_type":"c1","uid":1159647,"ip_address":"","ucode":"217AFD7620D24E","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/df/e7f5ea7f.jpg","comment_is_top":false,"comment_ctime":1574232926,"is_pvip":false,"replies":[{"id":59496,"content":"是的，这个方法理论上是没问题的。实现起来稍微有点儿复杂，只要能正确的实现出来是可以解决问题的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574643132,"ip_address":"","comment_id":153418,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师好  消费端 比如kafka增加机器 不能起到增加消费能力的作用  如果按照多线程来进行消费 在一定量处理完毕之后进行统一的位点提交 这么做可以避免重启后消息丢失的问题  是不是就可以解决消费端的能力扩容问题了","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492633,"discussion_content":"积压是不会导致丢消息的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587691428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127846,"user_name":"小小小丶盘子","can_delete":false,"product_type":"c1","uid":1308056,"ip_address":"","ucode":"FCD4520F1EF872","user_header":"https://static001.geekbang.org/account/avatar/00/13/f5/98/45374bb9.jpg","comment_is_top":false,"comment_ctime":1566799858,"is_pvip":false,"replies":[{"id":47521,"content":"在onMessage方法结束后，如果没有抛异常，就自动ACK了。而这个时候，消息只是在内存队列中，并没有被真正处理完。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868501,"ip_address":"","comment_id":127846,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"内存队列会丢消息我不明白，不是有 ACK机制吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475156,"discussion_content":"是的，这个方法理论上是没问题的。实现起来稍微有点儿复杂，只要能正确的实现出来是可以解决问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574643132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":120528,"discussion_content":"多线程消费的话，如果消费顺序要求强一致，那么线程间的通信要做的很好才行吧。而且还要看场景的，比如redo log入库，入库顺序要严格保证，那么入库要同步，多线程实现下来和单线程没啥区别，还徒增复杂性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578279637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1159647,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b1/df/e7f5ea7f.jpg","nickname":"攀攀","note":"","ucode":"217AFD7620D24E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601304,"discussion_content":"是的，我们的场景是消费订单，采用hash主键的方式来保障单线程内的消费顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675211184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":120528,"ip_address":"北京","group_id":0},"score":601304,"extra":""}]}]},{"had_liked":false,"id":121181,"user_name":"二雷","can_delete":false,"product_type":"c1","uid":1044483,"ip_address":"","ucode":"2E5F304CE7DA18","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f0/03/e80481e6.jpg","comment_is_top":false,"comment_ctime":1565071926,"is_pvip":true,"replies":[{"id":44622,"content":"没问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138600,"ip_address":"","comment_id":121181,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"批量消费应该是与消息处理是需要实时与否有关。如果需要实时处理，如订单相关的，就不能批量，但是发送提醒邮件之类的，就可以。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464675,"discussion_content":"在onMessage方法结束后，如果没有抛异常，就自动ACK了。而这个时候，消息只是在内存队列中，并没有被真正处理完。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047329,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/a89aca0a.jpg","nickname":"未来小娃","note":"","ucode":"477D166EBB6B70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128719,"discussion_content":"但是如果消息队列是需要手动ack的话用内存队列是没问题的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578661968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179506,"user_name":"SKang","can_delete":false,"product_type":"c1","uid":1803753,"ip_address":"","ucode":"AF3311B3A51841","user_header":"https://static001.geekbang.org/account/avatar/00/1b/85/e9/3854e59a.jpg","comment_is_top":false,"comment_ctime":1582017193,"is_pvip":false,"replies":[{"id":69996,"content":"参考一下Kafka的官方文档中关于监控一节：https:&#47;&#47;kafka.apache.org&#47;documentation&#47;#monitoring","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582246910,"ip_address":"","comment_id":179506,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"各位好 怎样监控Kafka 的 发送端 和 消费端 的速度","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461668,"discussion_content":"没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179095,"user_name":"SKang","can_delete":false,"product_type":"c1","uid":1803753,"ip_address":"","ucode":"AF3311B3A51841","user_header":"https://static001.geekbang.org/account/avatar/00/1b/85/e9/3854e59a.jpg","comment_is_top":false,"comment_ctime":1581912828,"is_pvip":false,"replies":[{"id":69908,"content":"可以通过是否有积压来判断，如果消息大量积压，那一定是消费慢了。如果没有消息没有积压，整体流程还很慢，那问题大概率出现在发送端。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582177152,"ip_address":"","comment_id":179095,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师您好 有可以通过Kafka相关命令的发送端快 还是消费端性能快。 还是只能在两端定位性能","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484286,"discussion_content":"参考一下Kafka的官方文档中关于监控一节：https://kafka.apache.org/documentation/#monitoring","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582246910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151457,"user_name":"瓦特","can_delete":false,"product_type":"c1","uid":1300360,"ip_address":"","ucode":"365A781FF1FB7B","user_header":"https://static001.geekbang.org/account/avatar/00/13/d7/88/58b8ce42.jpg","comment_is_top":false,"comment_ctime":1573723161,"is_pvip":false,"replies":[{"id":58289,"content":"队列的数量一般是在创建主题的时候指定的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573779486,"ip_address":"","comment_id":151457,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。------------请问在不同主题下，队列数量怎么 设置尼，是某个参数么","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484086,"discussion_content":"可以通过是否有积压来判断，如果消息大量积压，那一定是消费慢了。如果没有消息没有积压，整体流程还很慢，那问题大概率出现在发送端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582177152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1803753,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/85/e9/3854e59a.jpg","nickname":"SKang","note":"","ucode":"AF3311B3A51841","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178610,"discussion_content":"谢谢啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582180820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143064,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571625532,"is_pvip":false,"replies":[{"id":55375,"content":"这里面说的不是consumer group，就是consumer的实例数。关于consumer group的概念，你可以看一下下节课的热点问题解答，里面会有详细的解释。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571706909,"ip_address":"","comment_id":143064,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"下面这句话不太理解，老师这里说的consumor实际上是consumor组，因为每个consumor组是互不影响的，这在一定程度上提升了并发性，所以为何当consumor组超过队列的时候没有意义呢？  \n比如，队列a，Consumor组A，Comsumor组B，它们两个可以并发的消费队列a，这提升了性能才对啊。\n\n“在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。”","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471369,"discussion_content":"这里面说的不是consumer group，就是consumer的实例数。关于consumer group的概念，你可以看一下下节课的热点问题解答，里面会有详细的解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571706909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327141,"discussion_content":"队列为了保持消费顺序，只能等到ack之后下一条消息才能继续被消费，所以即使有一个消费者组（里面多个消费者）在一个队列上也只能是单线程的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605753647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":120530,"discussion_content":"划重点：主题中分区（也叫队列）只能同时被一个线程(consumer实例)消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578279846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215635,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1589038996,"is_pvip":true,"replies":[{"id":79940,"content":"一般来说consumer都是无状态的节点，一般的容灾手段都是：故障检测-&gt;自动拉起。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589170895,"ip_address":"","comment_id":215635,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"consumer挂了，导致的积压有什么容灾手段呢？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494503,"discussion_content":"一般来说consumer都是无状态的节点，一般的容灾手段都是：故障检测-&amp;gt;自动拉起。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589170895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215497,"user_name":"lupguo","can_delete":false,"product_type":"c1","uid":1009098,"ip_address":"","ucode":"1B55A01DF78647","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/ca/38dcd55a.jpg","comment_is_top":false,"comment_ctime":1589002368,"is_pvip":false,"replies":[{"id":79938,"content":"是这样的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589170757,"ip_address":"","comment_id":215497,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"消费端可以通过批量来提升消费性能，相当于一次葱消费队列接受一批消息，直接ack一批消息，可以减少往返rtt。\n使用场景应该是适合接受数据可丢，且后续支持批量写数据的场景，比如批量连续的日志文件记录类似的场合。\n不知道这样理解是否正确","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494458,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589170757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208813,"user_name":"Echo","can_delete":false,"product_type":"c1","uid":1409357,"ip_address":"","ucode":"F04C6BC4E288A7","user_header":"https://static001.geekbang.org/account/avatar/00/15/81/4d/5f892de2.jpg","comment_is_top":false,"comment_ctime":1587441636,"is_pvip":false,"replies":[{"id":78321,"content":"积压是不会导致丢消息的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1587691428,"ip_address":"","comment_id":208813,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师，积压在什么情况下会导致丢消息？谢谢老师","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492633,"discussion_content":"积压是不会导致丢消息的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587691428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153418,"user_name":"攀攀","can_delete":false,"product_type":"c1","uid":1159647,"ip_address":"","ucode":"217AFD7620D24E","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/df/e7f5ea7f.jpg","comment_is_top":false,"comment_ctime":1574232926,"is_pvip":false,"replies":[{"id":59496,"content":"是的，这个方法理论上是没问题的。实现起来稍微有点儿复杂，只要能正确的实现出来是可以解决问题的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574643132,"ip_address":"","comment_id":153418,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师好  消费端 比如kafka增加机器 不能起到增加消费能力的作用  如果按照多线程来进行消费 在一定量处理完毕之后进行统一的位点提交 这么做可以避免重启后消息丢失的问题  是不是就可以解决消费端的能力扩容问题了","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475156,"discussion_content":"是的，这个方法理论上是没问题的。实现起来稍微有点儿复杂，只要能正确的实现出来是可以解决问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574643132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":120528,"discussion_content":"多线程消费的话，如果消费顺序要求强一致，那么线程间的通信要做的很好才行吧。而且还要看场景的，比如redo log入库，入库顺序要严格保证，那么入库要同步，多线程实现下来和单线程没啥区别，还徒增复杂性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578279637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1159647,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b1/df/e7f5ea7f.jpg","nickname":"攀攀","note":"","ucode":"217AFD7620D24E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601304,"discussion_content":"是的，我们的场景是消费订单，采用hash主键的方式来保障单线程内的消费顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675211184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":120528,"ip_address":"北京","group_id":0},"score":601304,"extra":""}]}]},{"had_liked":false,"id":127846,"user_name":"小小小丶盘子","can_delete":false,"product_type":"c1","uid":1308056,"ip_address":"","ucode":"FCD4520F1EF872","user_header":"https://static001.geekbang.org/account/avatar/00/13/f5/98/45374bb9.jpg","comment_is_top":false,"comment_ctime":1566799858,"is_pvip":false,"replies":[{"id":47521,"content":"在onMessage方法结束后，如果没有抛异常，就自动ACK了。而这个时候，消息只是在内存队列中，并没有被真正处理完。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566868501,"ip_address":"","comment_id":127846,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"内存队列会丢消息我不明白，不是有 ACK机制吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464675,"discussion_content":"在onMessage方法结束后，如果没有抛异常，就自动ACK了。而这个时候，消息只是在内存队列中，并没有被真正处理完。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566868501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047329,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/a89aca0a.jpg","nickname":"未来小娃","note":"","ucode":"477D166EBB6B70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128719,"discussion_content":"但是如果消息队列是需要手动ack的话用内存队列是没问题的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578661968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121181,"user_name":"二雷","can_delete":false,"product_type":"c1","uid":1044483,"ip_address":"","ucode":"2E5F304CE7DA18","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f0/03/e80481e6.jpg","comment_is_top":false,"comment_ctime":1565071926,"is_pvip":true,"replies":[{"id":44622,"content":"没问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138600,"ip_address":"","comment_id":121181,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"批量消费应该是与消息处理是需要实时与否有关。如果需要实时处理，如订单相关的，就不能批量，但是发送提醒邮件之类的，就可以。","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461668,"discussion_content":"没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179506,"user_name":"SKang","can_delete":false,"product_type":"c1","uid":1803753,"ip_address":"","ucode":"AF3311B3A51841","user_header":"https://static001.geekbang.org/account/avatar/00/1b/85/e9/3854e59a.jpg","comment_is_top":false,"comment_ctime":1582017193,"is_pvip":false,"replies":[{"id":69996,"content":"参考一下Kafka的官方文档中关于监控一节：https:&#47;&#47;kafka.apache.org&#47;documentation&#47;#monitoring","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582246910,"ip_address":"","comment_id":179506,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"各位好 怎样监控Kafka 的 发送端 和 消费端 的速度","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484286,"discussion_content":"参考一下Kafka的官方文档中关于监控一节：https://kafka.apache.org/documentation/#monitoring","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582246910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179095,"user_name":"SKang","can_delete":false,"product_type":"c1","uid":1803753,"ip_address":"","ucode":"AF3311B3A51841","user_header":"https://static001.geekbang.org/account/avatar/00/1b/85/e9/3854e59a.jpg","comment_is_top":false,"comment_ctime":1581912828,"is_pvip":false,"replies":[{"id":69908,"content":"可以通过是否有积压来判断，如果消息大量积压，那一定是消费慢了。如果没有消息没有积压，整体流程还很慢，那问题大概率出现在发送端。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582177152,"ip_address":"","comment_id":179095,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"老师您好 有可以通过Kafka相关命令的发送端快 还是消费端性能快。 还是只能在两端定位性能","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484086,"discussion_content":"可以通过是否有积压来判断，如果消息大量积压，那一定是消费慢了。如果没有消息没有积压，整体流程还很慢，那问题大概率出现在发送端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582177152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1803753,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/85/e9/3854e59a.jpg","nickname":"SKang","note":"","ucode":"AF3311B3A51841","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178610,"discussion_content":"谢谢啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582180820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151457,"user_name":"瓦特","can_delete":false,"product_type":"c1","uid":1300360,"ip_address":"","ucode":"365A781FF1FB7B","user_header":"https://static001.geekbang.org/account/avatar/00/13/d7/88/58b8ce42.jpg","comment_is_top":false,"comment_ctime":1573723161,"is_pvip":false,"replies":[{"id":58289,"content":"队列的数量一般是在创建主题的时候指定的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1573779486,"ip_address":"","comment_id":151457,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。------------请问在不同主题下，队列数量怎么 设置尼，是某个参数么","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474479,"discussion_content":"队列的数量一般是在创建主题的时候指定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573779486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143064,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571625532,"is_pvip":false,"replies":[{"id":55375,"content":"这里面说的不是consumer group，就是consumer的实例数。关于consumer group的概念，你可以看一下下节课的热点问题解答，里面会有详细的解释。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1571706909,"ip_address":"","comment_id":143064,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"下面这句话不太理解，老师这里说的consumor实际上是consumor组，因为每个consumor组是互不影响的，这在一定程度上提升了并发性，所以为何当consumor组超过队列的时候没有意义呢？  \n比如，队列a，Consumor组A，Comsumor组B，它们两个可以并发的消费队列a，这提升了性能才对啊。\n\n“在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。”","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474479,"discussion_content":"队列的数量一般是在创建主题的时候指定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573779486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125596,"user_name":"小蚂蚁","can_delete":false,"product_type":"c1","uid":1205280,"ip_address":"","ucode":"0798478DDAD206","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/20/8522121f.jpg","comment_is_top":false,"comment_ctime":1566208888,"is_pvip":false,"replies":[{"id":46223,"content":"关于基础概念这块儿，你可以再看一下08答疑，里面会有更详细的解释。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566264851,"ip_address":"","comment_id":125596,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，不好意思，我不明白为什么在每个分区上实际上只能支持单线程消费。","like_count":0},{"had_liked":false,"id":121977,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1565261202,"is_pvip":false,"replies":[{"id":44794,"content":"是的","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565274296,"ip_address":"","comment_id":121977,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"关于批量发送有点疑惑想请老师解答。在批量消费中如果某条消息消费失败那么重试是会将整批消息进行重发吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463625,"discussion_content":"关于基础概念这块儿，你可以再看一下08答疑，里面会有更详细的解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566264851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238961,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/b1/5c63be67.jpg","nickname":"易水寒","note":"","ucode":"F5D8127ED4754E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6338,"discussion_content":"同一个消费者组内是一个分区只有一个消费者可以处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566840814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121656,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1565179778,"is_pvip":false,"replies":[{"id":44700,"content":"后面我们会有一节课专题讲这个问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565183608,"ip_address":"","comment_id":121656,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"请教下老师，序列化消息，采用何种序列化方式，有讲究吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462038,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565274296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121639,"user_name":"笨笨","can_delete":false,"product_type":"c1","uid":1621350,"ip_address":"","ucode":"E5D5100851E5EB","user_header":"https://static001.geekbang.org/account/avatar/00/18/bd/66/5238f23d.jpg","comment_is_top":false,"comment_ctime":1565172805,"is_pvip":false,"replies":[{"id":44699,"content":"和普通的程序一样啊，如果是java开发的，直接用jstack打印就行。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565183549,"ip_address":"","comment_id":121639,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"如何打印消息队列中的堆栈信息呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461888,"discussion_content":"和普通的程序一样啊，如果是java开发的，直接用jstack打印就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565183549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121334,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1565101797,"is_pvip":true,"replies":[{"id":44599,"content":"如何保证消息的顺序性问题我会在08答疑中来说一下。\n\n高可用也就是集群的原理，后面的课程会有安排。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565137399,"ip_address":"","comment_id":121334,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"希望老师可以加餐，谈谈“如何保证消息的顺序性问题”及“如何保证消息队列高可用”，谢谢！","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461746,"discussion_content":"如何保证消息的顺序性问题我会在08答疑中来说一下。\n\n高可用也就是集群的原理，后面的课程会有安排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565137399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121198,"user_name":"不能扮演天使","can_delete":false,"product_type":"c1","uid":1046172,"ip_address":"","ucode":"9922330BFF7FFB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/9c/b457a937.jpg","comment_is_top":false,"comment_ctime":1565075561,"is_pvip":false,"replies":[{"id":44616,"content":"你理解的很到位。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138488,"ip_address":"","comment_id":121198,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师好，消费者批量获取数据，如果是自动ack,那么offset是这一批数据的最大的offset，但是如果业务处理数据失败但是offset已经提交，那么对业务来说这批数据消费是有问题的，还有情况就是重复消费的问题，如果是处理完业务再ack的过程中失败了，那么下次会拉取重复数据，重复数据可以幂等性解决，主要还是看对消息丢失的容忍度，望老师批正","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461676,"discussion_content":"你理解的很到位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121185,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1565072725,"is_pvip":true,"replies":[{"id":44621,"content":"我们说的场景中，消息还是存在Broker中来保证不丢的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138581,"ip_address":"","comment_id":121185,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"对于思考题：我认为批量消费提升消费性能也是可以解决消息堆积的问题，只是针对的场景比较有限，需要权衡考虑业务特定再决定。适用场景是那些允许消息丢失(文中内存队列的例子)，消息延时(批量消费必然需先批量存储导致延时)，比如海量日志收集等场景。局限性：批量消费可能会影响数据的一致性(多线程对同一数据进行操作的场景)，一条消息消费不成功，要重试批量消息。这里说的批量消费应该是批量存储在broker中吧，有可能内存队列的场景吗？不知道理解的对不对，老师有空看看","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461676,"discussion_content":"你理解的很到位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121075,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1565054639,"is_pvip":false,"replies":null,"discussion_count":8,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"批量消费有意义的场景要求：1.要么消费端对消息的处理支持批量处理，比如批量入库 2. 要么消费端支持多线程&#47;协程并发处理，业务上也允许消息无序。3. 或者网络带宽在考虑因素内，需要减少消息的overhead。\n批量消费的局限性：1. 需要一个整体ack的机制，一旦一条靠前的消息消费失败，可能会引起很多消息重试。2. 多线程下批量消费速度受限于最慢的那个线程。\n但其实以上局限并没有影响主流MQ的实现了批量功能。\n","like_count":69,"discussions":[{"author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327135,"discussion_content":"只是批量将消息拉到消费端吧，这时候消息应该还是有序的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605753156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293241,"discussion_content":"业务上有序无序关系不大，批处理是批量拉取消费，单线程消费的话完全可以保证有序性，多线程才存在是否有序的情况，老师课中举过例子了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595490423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003233,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4e/e1/436a7576.jpg","nickname":"皮皮厮","note":"","ucode":"18EFAA3BFCDC26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214940,"discussion_content":"66666 i c u again","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585247077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3021110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cjichzNjhghHD9DJEXCBrh1PqmmlfBwC84NKbn9obLYEGCBDiaqufEArL26Qy0YiaibVbhcnYON7oqh7v6HgCjmk3g/132","nickname":"Geek_eca226","note":"","ucode":"E738A5618F3218","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580820,"discussion_content":"感觉像ack滑动窗口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658385875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636760,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f9/98/e5c6641a.jpg","nickname":"刘洋","note":"","ucode":"F111308ED42AB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389453,"discussion_content":"额，，消息 overhead 是啥意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629280894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125834,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","nickname":"fomy","note":"","ucode":"CD87EA03B1F327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5474,"discussion_content":"为什么多线程消费情况下会受限于最慢的线程呢？不是各自消费自己的消息吗？\n还有ack机制不回来不是只会影响该消息消费的线程而已吗？它不回来就只是卡住这个线程吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566292047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1125834,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","nickname":"fomy","note":"","ucode":"CD87EA03B1F327","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":120495,"discussion_content":"批次中有一条消息消费未完成，那么整个批次都不能返回消费结果给MQ，特别是消息间有顺序要求的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578278120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5474,"ip_address":"","group_id":0},"score":120495,"extra":""}]},{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4080,"discussion_content":"老哥，稳啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565097879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157998,"user_name":"严青","can_delete":false,"product_type":"c1","uid":1316494,"ip_address":"","ucode":"5C9015E78F71BE","user_header":"https://static001.geekbang.org/account/avatar/00/14/16/8e/d401d48c.jpg","comment_is_top":false,"comment_ctime":1575296052,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"我没读过这篇文章之前我看过别人面试的解决消息积压的方法：\n（1）临时扩容，增加消费端，用硬件提升消费速度。\n（2）服务降级，关闭一些非核心业务，减少消息生产。\n（3）通过日志分析，监控等找到挤压原因，消息队列三部分，上游生产者是否异常生产大量数据，中游消息队列存储层是否出现问题，下游消费速度是否变慢，就能确定哪个环节出了问题\n（4）根据排查解决异常部分。\n（5）等待积压的消息被消费，恢复到正常状态，撤掉扩容服务器。\n到此，问题解决","like_count":48},{"had_liked":false,"id":121993,"user_name":"C J J","can_delete":false,"product_type":"c1","uid":1002287,"ip_address":"","ucode":"603AA1417BD0DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/2f/186918b4.jpg","comment_is_top":false,"comment_ctime":1565266319,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"一、如何预防消息积压？\n1、发送端提高并发及批量大小；\n2、消费端增加实例且同步宽容分区；\n\n二、如何处理消息积压？\n1、消费端扩容；\n2、服务降级；\n3、异常监控。","like_count":25,"discussions":[{"author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327135,"discussion_content":"只是批量将消息拉到消费端吧，这时候消息应该还是有序的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605753156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293241,"discussion_content":"业务上有序无序关系不大，批处理是批量拉取消费，单线程消费的话完全可以保证有序性，多线程才存在是否有序的情况，老师课中举过例子了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595490423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003233,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4e/e1/436a7576.jpg","nickname":"皮皮厮","note":"","ucode":"18EFAA3BFCDC26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214940,"discussion_content":"66666 i c u again","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585247077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3021110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cjichzNjhghHD9DJEXCBrh1PqmmlfBwC84NKbn9obLYEGCBDiaqufEArL26Qy0YiaibVbhcnYON7oqh7v6HgCjmk3g/132","nickname":"Geek_eca226","note":"","ucode":"E738A5618F3218","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580820,"discussion_content":"感觉像ack滑动窗口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658385875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636760,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f9/98/e5c6641a.jpg","nickname":"刘洋","note":"","ucode":"F111308ED42AB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389453,"discussion_content":"额，，消息 overhead 是啥意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629280894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125834,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","nickname":"fomy","note":"","ucode":"CD87EA03B1F327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5474,"discussion_content":"为什么多线程消费情况下会受限于最慢的线程呢？不是各自消费自己的消息吗？\n还有ack机制不回来不是只会影响该消息消费的线程而已吗？它不回来就只是卡住这个线程吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566292047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1125834,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","nickname":"fomy","note":"","ucode":"CD87EA03B1F327","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":120495,"discussion_content":"批次中有一条消息消费未完成，那么整个批次都不能返回消费结果给MQ，特别是消息间有顺序要求的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578278120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5474,"ip_address":"","group_id":0},"score":120495,"extra":""}]},{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4080,"discussion_content":"老哥，稳啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565097879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125596,"user_name":"小蚂蚁","can_delete":false,"product_type":"c1","uid":1205280,"ip_address":"","ucode":"0798478DDAD206","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/20/8522121f.jpg","comment_is_top":false,"comment_ctime":1566208888,"is_pvip":false,"replies":[{"id":46223,"content":"关于基础概念这块儿，你可以再看一下08答疑，里面会有更详细的解释。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1566264851,"ip_address":"","comment_id":125596,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师，不好意思，我不明白为什么在每个分区上实际上只能支持单线程消费。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463625,"discussion_content":"关于基础概念这块儿，你可以再看一下08答疑，里面会有更详细的解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566264851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238961,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/b1/5c63be67.jpg","nickname":"易水寒","note":"","ucode":"F5D8127ED4754E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6338,"discussion_content":"同一个消费者组内是一个分区只有一个消费者可以处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566840814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121977,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1565261202,"is_pvip":false,"replies":[{"id":44794,"content":"是的","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565274296,"ip_address":"","comment_id":121977,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"关于批量发送有点疑惑想请老师解答。在批量消费中如果某条消息消费失败那么重试是会将整批消息进行重发吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462038,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565274296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121656,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1565179778,"is_pvip":false,"replies":[{"id":44700,"content":"后面我们会有一节课专题讲这个问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565183608,"ip_address":"","comment_id":121656,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"请教下老师，序列化消息，采用何种序列化方式，有讲究吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461893,"discussion_content":"后面我们会有一节课专题讲这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565183608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121639,"user_name":"笨笨","can_delete":false,"product_type":"c1","uid":1621350,"ip_address":"","ucode":"E5D5100851E5EB","user_header":"https://static001.geekbang.org/account/avatar/00/18/bd/66/5238f23d.jpg","comment_is_top":false,"comment_ctime":1565172805,"is_pvip":false,"replies":[{"id":44699,"content":"和普通的程序一样啊，如果是java开发的，直接用jstack打印就行。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565183549,"ip_address":"","comment_id":121639,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"如何打印消息队列中的堆栈信息呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461893,"discussion_content":"后面我们会有一节课专题讲这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565183608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121334,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1565101797,"is_pvip":true,"replies":[{"id":44599,"content":"如何保证消息的顺序性问题我会在08答疑中来说一下。\n\n高可用也就是集群的原理，后面的课程会有安排。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565137399,"ip_address":"","comment_id":121334,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"希望老师可以加餐，谈谈“如何保证消息的顺序性问题”及“如何保证消息队列高可用”，谢谢！","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461888,"discussion_content":"和普通的程序一样啊，如果是java开发的，直接用jstack打印就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565183549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121198,"user_name":"不能扮演天使","can_delete":false,"product_type":"c1","uid":1046172,"ip_address":"","ucode":"9922330BFF7FFB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/9c/b457a937.jpg","comment_is_top":false,"comment_ctime":1565075561,"is_pvip":false,"replies":[{"id":44616,"content":"你理解的很到位。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138488,"ip_address":"","comment_id":121198,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师好，消费者批量获取数据，如果是自动ack,那么offset是这一批数据的最大的offset，但是如果业务处理数据失败但是offset已经提交，那么对业务来说这批数据消费是有问题的，还有情况就是重复消费的问题，如果是处理完业务再ack的过程中失败了，那么下次会拉取重复数据，重复数据可以幂等性解决，主要还是看对消息丢失的容忍度，望老师批正","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461746,"discussion_content":"如何保证消息的顺序性问题我会在08答疑中来说一下。\n\n高可用也就是集群的原理，后面的课程会有安排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565137399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121185,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1565072725,"is_pvip":true,"replies":[{"id":44621,"content":"我们说的场景中，消息还是存在Broker中来保证不丢的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1565138581,"ip_address":"","comment_id":121185,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"对于思考题：我认为批量消费提升消费性能也是可以解决消息堆积的问题，只是针对的场景比较有限，需要权衡考虑业务特定再决定。适用场景是那些允许消息丢失(文中内存队列的例子)，消息延时(批量消费必然需先批量存储导致延时)，比如海量日志收集等场景。局限性：批量消费可能会影响数据的一致性(多线程对同一数据进行操作的场景)，一条消息消费不成功，要重试批量消息。这里说的批量消费应该是批量存储在broker中吧，有可能内存队列的场景吗？不知道理解的对不对，老师有空看看","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461670,"discussion_content":"我们说的场景中，消息还是存在Broker中来保证不丢的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121075,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1565054639,"is_pvip":false,"replies":null,"discussion_count":8,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"批量消费有意义的场景要求：1.要么消费端对消息的处理支持批量处理，比如批量入库 2. 要么消费端支持多线程&#47;协程并发处理，业务上也允许消息无序。3. 或者网络带宽在考虑因素内，需要减少消息的overhead。\n批量消费的局限性：1. 需要一个整体ack的机制，一旦一条靠前的消息消费失败，可能会引起很多消息重试。2. 多线程下批量消费速度受限于最慢的那个线程。\n但其实以上局限并没有影响主流MQ的实现了批量功能。\n","like_count":69,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461670,"discussion_content":"我们说的场景中，消息还是存在Broker中来保证不丢的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565138581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157998,"user_name":"严青","can_delete":false,"product_type":"c1","uid":1316494,"ip_address":"","ucode":"5C9015E78F71BE","user_header":"https://static001.geekbang.org/account/avatar/00/14/16/8e/d401d48c.jpg","comment_is_top":false,"comment_ctime":1575296052,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"我没读过这篇文章之前我看过别人面试的解决消息积压的方法：\n（1）临时扩容，增加消费端，用硬件提升消费速度。\n（2）服务降级，关闭一些非核心业务，减少消息生产。\n（3）通过日志分析，监控等找到挤压原因，消息队列三部分，上游生产者是否异常生产大量数据，中游消息队列存储层是否出现问题，下游消费速度是否变慢，就能确定哪个环节出了问题\n（4）根据排查解决异常部分。\n（5）等待积压的消息被消费，恢复到正常状态，撤掉扩容服务器。\n到此，问题解决","like_count":48},{"had_liked":false,"id":121993,"user_name":"C J J","can_delete":false,"product_type":"c1","uid":1002287,"ip_address":"","ucode":"603AA1417BD0DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/2f/186918b4.jpg","comment_is_top":false,"comment_ctime":1565266319,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"一、如何预防消息积压？\n1、发送端提高并发及批量大小；\n2、消费端增加实例且同步宽容分区；\n\n二、如何处理消息积压？\n1、消费端扩容；\n2、服务降级；\n3、异常监控。","like_count":25,"discussions":[{"author":{"id":1999133,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/81/1d/eabc99ff.jpg","nickname":"希陌","note":"","ucode":"3A988C55C3FF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606193,"discussion_content":"第一点其实应该是预防发送端消息积压，因为单个发送端的处理速度肯定不会比MQ快，预防多个发送端发送过多消息，应该是服务降级，限流等策略，开源节流嘛。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1677026021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","nickname":"悟空WuKong","note":"","ucode":"49AFD2B048C1BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207824,"discussion_content":"精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584516355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131481,"user_name":"天涯煮酒","can_delete":false,"product_type":"c1","uid":1241127,"ip_address":"","ucode":"EF9516EC878E4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/27/8b72141c.jpg","comment_is_top":false,"comment_ctime":1567762911,"is_pvip":false,"replies":null,"discussion_count":3,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"一开始不理解为啥Producer发得慢了会导致消息积压，明明是发得少了Broker端的消息应该更少啊\n\n后来想到前面章节有提到消息事务，Producer首先会开启事务并发送一个半消息，再执行业务逻辑，最后提交事务，如果发得慢了会导致半消息在Broker中的时间增长，导致积压","like_count":7},{"had_liked":false,"id":122165,"user_name":"13761642169","can_delete":false,"product_type":"c1","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1565312697,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"消息本来就有限流或者削峰填谷，这个也是使用消息队列的作用，老师您讲的不严谨。","like_count":3,"discussions":[{"author":{"id":1614410,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","nickname":"老杨在努力","note":"","ucode":"AA541B3BAD53A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39040,"discussion_content":"不是这个原因，半消息对于消费端是看不到的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571883206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2309764,"avatar":"","nickname":"wjxfosu","note":"","ucode":"3AA85051804493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1614410,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","nickname":"老杨在努力","note":"","ucode":"AA541B3BAD53A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375970,"discussion_content":"应该有半消息队列吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621908685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":39040,"ip_address":"","group_id":0},"score":375970,"extra":""}]},{"author":{"id":1801058,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7b/62/ec94cee4.jpg","nickname":"小彭","note":"","ucode":"8DCC27EC5AF263","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550519,"discussion_content":"老师在下面的评论说了，producer 发送慢不会导致消息积压的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644575142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121257,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1565088383,"is_pvip":false,"replies":null,"discussion_count":5,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"消费端通过丢入队列，并使用多线程来提高并发，老师讲到可能丢消息，但也要是某种条件成立，比如开启了自动提交，如果改为手动提交完全可以避免丢消息，只是可能出现重复消费问题，至少不会丢","like_count":3,"discussions":[{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234326,"discussion_content":"老师主要讲的是 消息积压太多，导致的问题。  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586962705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268145,"user_name":"蔫巴的小白菜","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1608084082,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"消息堆积，通过扩容broker的分区数，这点我有不同的见解，增加分区数量，势必会引发consumer端rebalance发生，如果消息不是分区内顺序性的，没有问题，但是如果是顺序消息，那么rebalance之后，消息的顺序性难以保证，这样对于消费端，可能就会出现问题，针对此方式，在重写分区策论时一定要注意，是否可以满足扩容的需求，不然就会出现，消息堆积问题解决了，但是出现业务错误，有点得不偿失。","like_count":2},{"had_liked":false,"id":121114,"user_name":"猿人谷","can_delete":false,"product_type":"c1","uid":1100149,"ip_address":"","ucode":"85106C7FB14C43","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","comment_is_top":false,"comment_ctime":1565060549,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"在消费端需要注意的是，增加并发需要同步扩容分区数量，否则是起不到效果的。\n这一点非常需要注意，其实有些公司在这个地方用错了。","like_count":2},{"had_liked":false,"id":312189,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1631676644,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"问题：在消费端是否可以通过批量消费的方式来提升消费性能？在什么样场景下，适合使用这种方法？或者说，这种方法有什么局限性？\n\n回答：\n1 消息顺序无关（否则消费会乱序）。\n2 批量消息内部需要消息唯一标识（否则消费者处理消息无法幂等判定一批消息重复处理情况）。","like_count":1},{"had_liked":false,"id":270883,"user_name":"周翔在山麓（Xiang Zhou）","can_delete":false,"product_type":"c1","uid":1609289,"ip_address":"","ucode":"E126273356E5B6","user_header":"https://static001.geekbang.org/account/avatar/00/18/8e/49/10ef002d.jpg","comment_is_top":false,"comment_ctime":1609311363,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"用内存队列解决消息积压的案例中, 如果把内存队列换成数据库, 还会有问题吗?","like_count":1},{"had_liked":false,"id":198892,"user_name":"远鹏","can_delete":false,"product_type":"c1","uid":1110723,"ip_address":"","ucode":"37B06413D88BEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/c3/f18e4507.jpg","comment_is_top":false,"comment_ctime":1585472247,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"pulsar支持在broker层限制消息生产速率以及消费速率，是一个很不错的特性","like_count":1},{"had_liked":false,"id":123150,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1487186,"ip_address":"","ucode":"BFD9FA881B750B","user_header":"https://static001.geekbang.org/account/avatar/00/16/b1/52/40540f9e.jpg","comment_is_top":false,"comment_ctime":1565616080,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"还遇到一种消息积压的情况，mq那边hash算法有问题，大量消息被分配到某一个队列上了","like_count":1},{"had_liked":false,"id":121003,"user_name":"mini希","can_delete":false,"product_type":"c1","uid":1043539,"ip_address":"","ucode":"54DFFE0CE0C7EF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/53/dcec6fdc.jpg","comment_is_top":false,"comment_ctime":1565049101,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":6,"product_id":100032301,"comment_content":"消费端逻辑比较复杂，或者需要对一段时间内的数据进行关联分析的情况，可以批量消费","like_count":1,"discussions":[{"author":{"id":1386315,"avatar":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","nickname":"Rover","note":"","ucode":"7575EC91F45B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357941,"discussion_content":"如果是线程池线程提交的话则会出现offset空档的情况。如果使用countdownlatch阻塞等待，则可能会出现重复消费情况，以及不可避免地其他消费者等待该消费者ack的情形","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615899056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609530,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/l4nngwyggBGqeMXC0micwO8bM1hSttgQXa1Y5frJSqWa8NibDhia5icwPcHM5wOpV3hfsf0UicDY0ypFqnQ3iarG0T1w/132","nickname":"Trident","note":"","ucode":"53E6788CF33398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175665,"discussion_content":"我也是同样认为的，只要自己手动提交，最起码不会丢消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581988789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1635388,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f4/3c/60bf7a17.jpg","nickname":"快乐的平头哥","note":"","ucode":"D7D2FA5DA6D8BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39609,"discussion_content":"意思是 当前业务结点挂了 —队列中的数据没了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571966765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049208,"avatar":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","nickname":"james","note":"","ucode":"5701899403917C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5669,"discussion_content":"手动在哪提交呢 只能是主线程吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566433007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049208,"avatar":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","nickname":"james","note":"","ucode":"5701899403917C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5668,"discussion_content":"手动在哪提交呢 只能是主线程吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566433007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131481,"user_name":"天涯煮酒","can_delete":false,"product_type":"c1","uid":1241127,"ip_address":"","ucode":"EF9516EC878E4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/27/8b72141c.jpg","comment_is_top":false,"comment_ctime":1567762911,"is_pvip":false,"replies":null,"discussion_count":3,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"一开始不理解为啥Producer发得慢了会导致消息积压，明明是发得少了Broker端的消息应该更少啊\n\n后来想到前面章节有提到消息事务，Producer首先会开启事务并发送一个半消息，再执行业务逻辑，最后提交事务，如果发得慢了会导致半消息在Broker中的时间增长，导致积压","like_count":7,"discussions":[{"author":{"id":1614410,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","nickname":"老杨在努力","note":"","ucode":"AA541B3BAD53A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39040,"discussion_content":"不是这个原因，半消息对于消费端是看不到的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571883206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2309764,"avatar":"","nickname":"wjxfosu","note":"","ucode":"3AA85051804493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1614410,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","nickname":"老杨在努力","note":"","ucode":"AA541B3BAD53A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375970,"discussion_content":"应该有半消息队列吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621908685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":39040,"ip_address":"","group_id":0},"score":375970,"extra":""}]},{"author":{"id":1801058,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7b/62/ec94cee4.jpg","nickname":"小彭","note":"","ucode":"8DCC27EC5AF263","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550519,"discussion_content":"老师在下面的评论说了，producer 发送慢不会导致消息积压的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644575142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122165,"user_name":"13761642169","can_delete":false,"product_type":"c1","uid":1232334,"ip_address":"","ucode":"68137695FC2120","user_header":"","comment_is_top":false,"comment_ctime":1565312697,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"消息本来就有限流或者削峰填谷，这个也是使用消息队列的作用，老师您讲的不严谨。","like_count":3,"discussions":[{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234326,"discussion_content":"老师主要讲的是 消息积压太多，导致的问题。  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586962705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121257,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1565088383,"is_pvip":false,"replies":null,"discussion_count":5,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"消费端通过丢入队列，并使用多线程来提高并发，老师讲到可能丢消息，但也要是某种条件成立，比如开启了自动提交，如果改为手动提交完全可以避免丢消息，只是可能出现重复消费问题，至少不会丢","like_count":3,"discussions":[{"author":{"id":1386315,"avatar":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","nickname":"Rover","note":"","ucode":"7575EC91F45B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357941,"discussion_content":"如果是线程池线程提交的话则会出现offset空档的情况。如果使用countdownlatch阻塞等待，则可能会出现重复消费情况，以及不可避免地其他消费者等待该消费者ack的情形","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615899056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609530,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/l4nngwyggBGqeMXC0micwO8bM1hSttgQXa1Y5frJSqWa8NibDhia5icwPcHM5wOpV3hfsf0UicDY0ypFqnQ3iarG0T1w/132","nickname":"Trident","note":"","ucode":"53E6788CF33398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175665,"discussion_content":"我也是同样认为的，只要自己手动提交，最起码不会丢消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581988789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1635388,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f4/3c/60bf7a17.jpg","nickname":"快乐的平头哥","note":"","ucode":"D7D2FA5DA6D8BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39609,"discussion_content":"意思是 当前业务结点挂了 —队列中的数据没了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571966765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049208,"avatar":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","nickname":"james","note":"","ucode":"5701899403917C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5669,"discussion_content":"手动在哪提交呢 只能是主线程吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566433007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049208,"avatar":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","nickname":"james","note":"","ucode":"5701899403917C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5668,"discussion_content":"手动在哪提交呢 只能是主线程吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566433007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268145,"user_name":"蔫巴的小白菜","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1608084082,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"消息堆积，通过扩容broker的分区数，这点我有不同的见解，增加分区数量，势必会引发consumer端rebalance发生，如果消息不是分区内顺序性的，没有问题，但是如果是顺序消息，那么rebalance之后，消息的顺序性难以保证，这样对于消费端，可能就会出现问题，针对此方式，在重写分区策论时一定要注意，是否可以满足扩容的需求，不然就会出现，消息堆积问题解决了，但是出现业务错误，有点得不偿失。","like_count":2},{"had_liked":false,"id":121114,"user_name":"猿人谷","can_delete":false,"product_type":"c1","uid":1100149,"ip_address":"","ucode":"85106C7FB14C43","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","comment_is_top":false,"comment_ctime":1565060549,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"在消费端需要注意的是，增加并发需要同步扩容分区数量，否则是起不到效果的。\n这一点非常需要注意，其实有些公司在这个地方用错了。","like_count":2},{"had_liked":false,"id":312189,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1631676644,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"问题：在消费端是否可以通过批量消费的方式来提升消费性能？在什么样场景下，适合使用这种方法？或者说，这种方法有什么局限性？\n\n回答：\n1 消息顺序无关（否则消费会乱序）。\n2 批量消息内部需要消息唯一标识（否则消费者处理消息无法幂等判定一批消息重复处理情况）。","like_count":1},{"had_liked":false,"id":270883,"user_name":"周翔在山麓（Xiang Zhou）","can_delete":false,"product_type":"c1","uid":1609289,"ip_address":"","ucode":"E126273356E5B6","user_header":"https://static001.geekbang.org/account/avatar/00/18/8e/49/10ef002d.jpg","comment_is_top":false,"comment_ctime":1609311363,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"用内存队列解决消息积压的案例中, 如果把内存队列换成数据库, 还会有问题吗?","like_count":1},{"had_liked":false,"id":198892,"user_name":"远鹏","can_delete":false,"product_type":"c1","uid":1110723,"ip_address":"","ucode":"37B06413D88BEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/c3/f18e4507.jpg","comment_is_top":false,"comment_ctime":1585472247,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"pulsar支持在broker层限制消息生产速率以及消费速率，是一个很不错的特性","like_count":1},{"had_liked":false,"id":123150,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1487186,"ip_address":"","ucode":"BFD9FA881B750B","user_header":"https://static001.geekbang.org/account/avatar/00/16/b1/52/40540f9e.jpg","comment_is_top":false,"comment_ctime":1565616080,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100032301,"comment_content":"还遇到一种消息积压的情况，mq那边hash算法有问题，大量消息被分配到某一个队列上了","like_count":1},{"had_liked":false,"id":121003,"user_name":"mini希","can_delete":false,"product_type":"c1","uid":1043539,"ip_address":"","ucode":"54DFFE0CE0C7EF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/53/dcec6fdc.jpg","comment_is_top":false,"comment_ctime":1565049101,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":6,"product_id":100032301,"comment_content":"消费端逻辑比较复杂，或者需要对一段时间内的数据进行关联分析的情况，可以批量消费","like_count":1},{"had_liked":false,"id":387504,"user_name":"颜如玉","can_delete":false,"product_type":"c1","uid":2856239,"ip_address":"四川","ucode":"C55FDAE3559054","user_header":"https://static001.geekbang.org/account/avatar/00/2b/95/2f/d88950a1.jpg","comment_is_top":false,"comment_ctime":1707659338,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"能接受乱序消费","like_count":0},{"had_liked":false,"id":369825,"user_name":"Pecan","can_delete":false,"product_type":"c1","uid":2020819,"ip_address":"浙江","ucode":"8C79F7EB11F415","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d5/d3/1e85a3c4.jpg","comment_is_top":false,"comment_ctime":1678007475,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"如果收消息的节点发生宕机，在内存队列中还没来及处理的这些消息就会丢失。\n\n如果这个场景放在redis中存储，是否可以实现单个consumer并行消费？\n放到redis中再返回ack，也不会存在节点宕机内存队列中消息丢失，redis通过持久化方式来解决节点宕机的问题","like_count":0},{"had_liked":false,"id":369215,"user_name":"小红帽","can_delete":false,"product_type":"c1","uid":1135290,"ip_address":"广东","ucode":"876000FB67C980","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/ba/440c0157.jpg","comment_is_top":false,"comment_ctime":1677227764,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"消费端批量消费的问题，因为一个分区只能一个消费端消费，如果消费端里面开启了多线程，会有丢失数据的风险。\n如果消息可以无序消费，丢失一点数据也可以，且业务上需要加快消费者的速度（比如手游等用户频繁产生事件的这种业务），这种场景应该可以使用。","like_count":0},{"had_liked":false,"id":365775,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"上海","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1672992383,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"没啥不能批量消费没法提高效率，没搞明白。我在消费者端使用线程池消费不就提高效率了吗","like_count":0},{"had_liked":false,"id":364225,"user_name":"否极泰来","can_delete":false,"product_type":"c1","uid":1439355,"ip_address":"北京","ucode":"C249173266251A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","comment_is_top":false,"comment_ctime":1670671290,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"在消费端是否可以通过批量消费的方式来提升消费性能？在什么样场景下，适合使用这种方法？或者说，这种方法有什么局限性？\n\n可以支持批量消费来提升性能，例如之前发的消息是 单个消息，生产者在创建消息的时候，可以发一个消息数组 作为一个消息，这样消费者就能批量消费消息\n\n但是最终还是要解决消费者性能的，较好的方法是：新增更多的队列，让消费者支持水平扩展比较合理","like_count":0},{"had_liked":false,"id":363667,"user_name":"Geek_18449e","can_delete":false,"product_type":"c1","uid":3233057,"ip_address":"浙江","ucode":"550BC7FCA937DC","user_header":"","comment_is_top":false,"comment_ctime":1669966150,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"有个疑问?\n一个消费者 对应 一个队列\n在push模式下, 并发消费与同步消费有啥区别吗？","like_count":0},{"had_liked":false,"id":349395,"user_name":"ChenW","can_delete":false,"product_type":"c1","uid":1803265,"ip_address":"","ucode":"CADEB0EBA8F54C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/84/01/a5add189.jpg","comment_is_top":false,"comment_ctime":1655945802,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"消息积压考虑发送端、消费端性能，主要是消费端的消费速度跟不上发送端速度导致；\n发送端优化可以批量和并发，消费端水平扩容同时应该增加消息队列（分区）因为每个分区支支持单线程消费；\n消费端不能使用内存缓存消息，会丢消息；\n若突发消息积压，多排查是否因为重复消息某条消息，或卡到某个资源导致。","like_count":0},{"had_liked":false,"id":347578,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1654165778,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"1.看日志是否有错误\n2.jstack 堆栈信息 看线程阻塞问题","like_count":0},{"had_liked":false,"id":344971,"user_name":"哈喽","can_delete":false,"product_type":"c1","uid":1309296,"ip_address":"","ucode":"86FDD5BFFAC1BE","user_header":"https://static001.geekbang.org/account/avatar/00/13/fa/70/f297240c.jpg","comment_is_top":false,"comment_ctime":1651906607,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"对于消息积压的实际落地方案，我想到了几种（自己猜想，没有经过实际生产验证），这些想法正确么，在实际生产场景中，具体应该怎么落地呢？\n对于已经挤压的消息来说，单单对消费者扩容肯定是不行的，还需要对分区进行扩容，那么就有两种做法，第一个，对原有topic的分区扩容，新产生的数据按照新的分区数量存储，消费端也按照新的分区数消费，但是对于部分分区来说，有积压的数据，消费下去的时间较慢；第二种方法是新建一个topic，新的topic分区扩容，消费老的topic时，不做任何业务处理，然后将老topic的数据转移到新的topic，消费者只消费新的topic，但是这样仍然会存在积压数据量过大从而导致转移topic都处理不及的问题；第三个方案，直接修改消费偏移量，从最新的消息开始消费，然后开启一个其他的消费组，从积压的偏移量处开始消费。","like_count":0},{"had_liked":false,"id":341035,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649304703,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"在消费端是否可以通过批量消费的方式来提升消费性能？在什么样场景下，适合使用这种方法？或者说，这种方法有什么局限性？\n\n批量消费可以减轻队列中消息积压的可能性，一次消费多条数据；存在的弊端就是，一次消费多条的时候，如何给服务端确认机制，全部消费成功后再确认。那如果有部分成功，部分失败，就不好回给服务端到底是成功还是失败。使用的场景，就是部分消费失败也没有关系。比如老师之前讲到的，在物联网场景，定时上报温度数据，如果有些温度数据没有被正常消费也不影响多大的业务，这种是可以的。","like_count":0},{"had_liked":false,"id":387504,"user_name":"颜如玉","can_delete":false,"product_type":"c1","uid":2856239,"ip_address":"四川","ucode":"C55FDAE3559054","user_header":"https://static001.geekbang.org/account/avatar/00/2b/95/2f/d88950a1.jpg","comment_is_top":false,"comment_ctime":1707659338,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"能接受乱序消费","like_count":0},{"had_liked":false,"id":369825,"user_name":"Pecan","can_delete":false,"product_type":"c1","uid":2020819,"ip_address":"浙江","ucode":"8C79F7EB11F415","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d5/d3/1e85a3c4.jpg","comment_is_top":false,"comment_ctime":1678007475,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"如果收消息的节点发生宕机，在内存队列中还没来及处理的这些消息就会丢失。\n\n如果这个场景放在redis中存储，是否可以实现单个consumer并行消费？\n放到redis中再返回ack，也不会存在节点宕机内存队列中消息丢失，redis通过持久化方式来解决节点宕机的问题","like_count":0},{"had_liked":false,"id":369215,"user_name":"小红帽","can_delete":false,"product_type":"c1","uid":1135290,"ip_address":"广东","ucode":"876000FB67C980","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/ba/440c0157.jpg","comment_is_top":false,"comment_ctime":1677227764,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"消费端批量消费的问题，因为一个分区只能一个消费端消费，如果消费端里面开启了多线程，会有丢失数据的风险。\n如果消息可以无序消费，丢失一点数据也可以，且业务上需要加快消费者的速度（比如手游等用户频繁产生事件的这种业务），这种场景应该可以使用。","like_count":0},{"had_liked":false,"id":365775,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"上海","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1672992383,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"没啥不能批量消费没法提高效率，没搞明白。我在消费者端使用线程池消费不就提高效率了吗","like_count":0},{"had_liked":false,"id":364225,"user_name":"否极泰来","can_delete":false,"product_type":"c1","uid":1439355,"ip_address":"北京","ucode":"C249173266251A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","comment_is_top":false,"comment_ctime":1670671290,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"在消费端是否可以通过批量消费的方式来提升消费性能？在什么样场景下，适合使用这种方法？或者说，这种方法有什么局限性？\n\n可以支持批量消费来提升性能，例如之前发的消息是 单个消息，生产者在创建消息的时候，可以发一个消息数组 作为一个消息，这样消费者就能批量消费消息\n\n但是最终还是要解决消费者性能的，较好的方法是：新增更多的队列，让消费者支持水平扩展比较合理","like_count":0},{"had_liked":false,"id":363667,"user_name":"Geek_18449e","can_delete":false,"product_type":"c1","uid":3233057,"ip_address":"浙江","ucode":"550BC7FCA937DC","user_header":"","comment_is_top":false,"comment_ctime":1669966150,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"有个疑问?\n一个消费者 对应 一个队列\n在push模式下, 并发消费与同步消费有啥区别吗？","like_count":0},{"had_liked":false,"id":349395,"user_name":"ChenW","can_delete":false,"product_type":"c1","uid":1803265,"ip_address":"","ucode":"CADEB0EBA8F54C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/84/01/a5add189.jpg","comment_is_top":false,"comment_ctime":1655945802,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"消息积压考虑发送端、消费端性能，主要是消费端的消费速度跟不上发送端速度导致；\n发送端优化可以批量和并发，消费端水平扩容同时应该增加消息队列（分区）因为每个分区支支持单线程消费；\n消费端不能使用内存缓存消息，会丢消息；\n若突发消息积压，多排查是否因为重复消息某条消息，或卡到某个资源导致。","like_count":0},{"had_liked":false,"id":347578,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1654165778,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"1.看日志是否有错误\n2.jstack 堆栈信息 看线程阻塞问题","like_count":0},{"had_liked":false,"id":344971,"user_name":"哈喽","can_delete":false,"product_type":"c1","uid":1309296,"ip_address":"","ucode":"86FDD5BFFAC1BE","user_header":"https://static001.geekbang.org/account/avatar/00/13/fa/70/f297240c.jpg","comment_is_top":false,"comment_ctime":1651906607,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"对于消息积压的实际落地方案，我想到了几种（自己猜想，没有经过实际生产验证），这些想法正确么，在实际生产场景中，具体应该怎么落地呢？\n对于已经挤压的消息来说，单单对消费者扩容肯定是不行的，还需要对分区进行扩容，那么就有两种做法，第一个，对原有topic的分区扩容，新产生的数据按照新的分区数量存储，消费端也按照新的分区数消费，但是对于部分分区来说，有积压的数据，消费下去的时间较慢；第二种方法是新建一个topic，新的topic分区扩容，消费老的topic时，不做任何业务处理，然后将老topic的数据转移到新的topic，消费者只消费新的topic，但是这样仍然会存在积压数据量过大从而导致转移topic都处理不及的问题；第三个方案，直接修改消费偏移量，从最新的消息开始消费，然后开启一个其他的消费组，从积压的偏移量处开始消费。","like_count":0},{"had_liked":false,"id":341035,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649304703,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100032301,"comment_content":"在消费端是否可以通过批量消费的方式来提升消费性能？在什么样场景下，适合使用这种方法？或者说，这种方法有什么局限性？\n\n批量消费可以减轻队列中消息积压的可能性，一次消费多条数据；存在的弊端就是，一次消费多条的时候，如何给服务端确认机制，全部消费成功后再确认。那如果有部分成功，部分失败，就不好回给服务端到底是成功还是失败。使用的场景，就是部分消费失败也没有关系。比如老师之前讲到的，在物联网场景，定时上报温度数据，如果有些温度数据没有被正常消费也不影响多大的业务，这种是可以的。","like_count":0},{"had_liked":false,"id":340705,"user_name":"再见理想","can_delete":false,"product_type":"c1","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1649062887,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"生产者可以通过并发或批量消息的方式提升生产者的发送效率。\n消费者可以通过扩充实例或优化处理性能来增加消费速度。\n从而减少数据积压。","like_count":0},{"had_liked":false,"id":336100,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1645929078,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":8,"product_id":100032301,"comment_content":"消息积压是一种正常现象，本身MQ就是为了这种场景服务的，但是如果消息持续积压是有问题的。一般而言有几个思路解决\n（1）消费端异常分析：看是否有某个消息消费导致不断重试\n（2）消费端异常分析：看是否消费端依赖的下游是否有问题，耗时很慢等等，可以考虑降级或修复\n（3）发送端异常分析：看整体业务逻辑，是否存在不合理的请求放大，从而导致不合理的消息积压\n（4）消费端都没什么问题，则可以扩容，而不是一上来就扩容","like_count":0},{"had_liked":false,"id":334753,"user_name":"Geek_783504","can_delete":false,"product_type":"c1","uid":2743789,"ip_address":"","ucode":"549D3F0549743C","user_header":"https://static001.geekbang.org/account/avatar/00/29/dd/ed/f6c5432b.jpg","comment_is_top":false,"comment_ctime":1645104179,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"批量消费，一次性拉去一些消息，对消息进行处理。但是如果这批消息中存在处理失败的消息，就需要对整段消息进行重新处理，对实时性要求不高的场景下可以使用。","like_count":0},{"had_liked":false,"id":334691,"user_name":"贾博岩","can_delete":false,"product_type":"c1","uid":1295126,"ip_address":"","ucode":"52E748E772C2D2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erw2xoaJngrKibcGm7kHgpoTuoIZHvSQu0nhvib9ibEib4X4orXjbjUlCMr4CRLp7om0XU7NS61MTfkLA/132","comment_is_top":false,"comment_ctime":1645079782,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"消费端其实可以将收到的消息落到数据库里后，启动异步线程进行处理，来增加消费端从消息队列拿数据的效率。","like_count":0},{"had_liked":false,"id":331065,"user_name":"J 杰~","can_delete":false,"product_type":"c1","uid":2883490,"ip_address":"","ucode":"7202987553A19D","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ff/a2/56e24200.jpg","comment_is_top":false,"comment_ctime":1642406634,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"有点疑问。消息积压一般是指broker处的消息积压吧，提升生产者并发或批量不是更加导致积压吗？","like_count":0},{"had_liked":false,"id":325168,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638847231,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"1.批量消费应该是批量拉取，在业务服务中的消费应该还是得一条一条来，可以开多个协程去做\n2.类似于非核心业务吧，日志采集？\n3.批处理应该会导致单次拉取时间变长。\n4.如果要保证单次操作的一致性，那么如果失败一次就得全部重新消费","like_count":0},{"had_liked":false,"id":324191,"user_name":"Z.G","can_delete":false,"product_type":"c1","uid":1641331,"ip_address":"","ucode":"AF2D041F9CBDF1","user_header":"https://static001.geekbang.org/account/avatar/00/19/0b/73/a04b5d3f.jpg","comment_is_top":false,"comment_ctime":1638331092,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师好，我有个困惑还请帮忙答疑解惑。\n请问消息队列中的消息何时会被删除呢？如果消费时只是记录各个消费组的消费位置，而不删除消息，那是不是消息队列的存储被填满的问题一定会出现？还有假如在中途新加入一个新的消费组，它会从头去消费第一个消息吗？","like_count":0},{"had_liked":false,"id":318154,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1635166010,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"我们是仿照reactor线程池来做的 就是消费者线程始终只有一个 保证每个分区订阅到一个线程。但是消费者线程拉取批量消息后 是扔到线程池里当场消化掉 再计算偏移量一起提交。\n\n这里有两个问题：\n1. 如果当中有几个消息始终无法消费 那么消费就会被卡住 这个和单线程的场景本质上是一样的 处理方式就是记录下来 直接跳过。或者像rocketmq一样 搞个死信队列\n2. 起用线程池后 会因为单个线程处理快慢 导致消费者线程上报offset速率不稳定。 这个问题很常见 我们是对于时延久的消息 会单独记录下来 事后做回放。","like_count":0},{"had_liked":false,"id":312912,"user_name":"Keith","can_delete":false,"product_type":"c1","uid":1193337,"ip_address":"","ucode":"B40774090714D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","comment_is_top":false,"comment_ctime":1632117932,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"关于思考题, 可以通过批量消费的方式来提升消费性能:","like_count":0},{"had_liked":false,"id":310960,"user_name":"李焕之","can_delete":false,"product_type":"c1","uid":1368198,"ip_address":"","ucode":"ECD77D132411BB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJbCmibL1XtPQmCJxUPg8rHLNgBZbor9UxAN3nOLhehicGkUcWGlq2Zic3XgHX1GLeXYJA0H3OPcNKPw/132","comment_is_top":false,"comment_ctime":1631001738,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"批量消费在提高性能的同时，会带来以下问题：1、有时延  2、容易丢失 3、会乱序。对时延要求不高，允许偶尔丢失，以及对顺序没有严格要求的场景下可以使用。","like_count":0},{"had_liked":false,"id":340705,"user_name":"再见理想","can_delete":false,"product_type":"c1","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1649062887,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"生产者可以通过并发或批量消息的方式提升生产者的发送效率。\n消费者可以通过扩充实例或优化处理性能来增加消费速度。\n从而减少数据积压。","like_count":0},{"had_liked":false,"id":336100,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1645929078,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":8,"product_id":100032301,"comment_content":"消息积压是一种正常现象，本身MQ就是为了这种场景服务的，但是如果消息持续积压是有问题的。一般而言有几个思路解决\n（1）消费端异常分析：看是否有某个消息消费导致不断重试\n（2）消费端异常分析：看是否消费端依赖的下游是否有问题，耗时很慢等等，可以考虑降级或修复\n（3）发送端异常分析：看整体业务逻辑，是否存在不合理的请求放大，从而导致不合理的消息积压\n（4）消费端都没什么问题，则可以扩容，而不是一上来就扩容","like_count":0},{"had_liked":false,"id":334753,"user_name":"Geek_783504","can_delete":false,"product_type":"c1","uid":2743789,"ip_address":"","ucode":"549D3F0549743C","user_header":"https://static001.geekbang.org/account/avatar/00/29/dd/ed/f6c5432b.jpg","comment_is_top":false,"comment_ctime":1645104179,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"批量消费，一次性拉去一些消息，对消息进行处理。但是如果这批消息中存在处理失败的消息，就需要对整段消息进行重新处理，对实时性要求不高的场景下可以使用。","like_count":0},{"had_liked":false,"id":334691,"user_name":"贾博岩","can_delete":false,"product_type":"c1","uid":1295126,"ip_address":"","ucode":"52E748E772C2D2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erw2xoaJngrKibcGm7kHgpoTuoIZHvSQu0nhvib9ibEib4X4orXjbjUlCMr4CRLp7om0XU7NS61MTfkLA/132","comment_is_top":false,"comment_ctime":1645079782,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"消费端其实可以将收到的消息落到数据库里后，启动异步线程进行处理，来增加消费端从消息队列拿数据的效率。","like_count":0},{"had_liked":false,"id":331065,"user_name":"J 杰~","can_delete":false,"product_type":"c1","uid":2883490,"ip_address":"","ucode":"7202987553A19D","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ff/a2/56e24200.jpg","comment_is_top":false,"comment_ctime":1642406634,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"有点疑问。消息积压一般是指broker处的消息积压吧，提升生产者并发或批量不是更加导致积压吗？","like_count":0},{"had_liked":false,"id":325168,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638847231,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"1.批量消费应该是批量拉取，在业务服务中的消费应该还是得一条一条来，可以开多个协程去做\n2.类似于非核心业务吧，日志采集？\n3.批处理应该会导致单次拉取时间变长。\n4.如果要保证单次操作的一致性，那么如果失败一次就得全部重新消费","like_count":0},{"had_liked":false,"id":324191,"user_name":"Z.G","can_delete":false,"product_type":"c1","uid":1641331,"ip_address":"","ucode":"AF2D041F9CBDF1","user_header":"https://static001.geekbang.org/account/avatar/00/19/0b/73/a04b5d3f.jpg","comment_is_top":false,"comment_ctime":1638331092,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"老师好，我有个困惑还请帮忙答疑解惑。\n请问消息队列中的消息何时会被删除呢？如果消费时只是记录各个消费组的消费位置，而不删除消息，那是不是消息队列的存储被填满的问题一定会出现？还有假如在中途新加入一个新的消费组，它会从头去消费第一个消息吗？","like_count":0},{"had_liked":false,"id":318154,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1635166010,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"我们是仿照reactor线程池来做的 就是消费者线程始终只有一个 保证每个分区订阅到一个线程。但是消费者线程拉取批量消息后 是扔到线程池里当场消化掉 再计算偏移量一起提交。\n\n这里有两个问题：\n1. 如果当中有几个消息始终无法消费 那么消费就会被卡住 这个和单线程的场景本质上是一样的 处理方式就是记录下来 直接跳过。或者像rocketmq一样 搞个死信队列\n2. 起用线程池后 会因为单个线程处理快慢 导致消费者线程上报offset速率不稳定。 这个问题很常见 我们是对于时延久的消息 会单独记录下来 事后做回放。","like_count":0},{"had_liked":false,"id":312912,"user_name":"Keith","can_delete":false,"product_type":"c1","uid":1193337,"ip_address":"","ucode":"B40774090714D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","comment_is_top":false,"comment_ctime":1632117932,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"关于思考题, 可以通过批量消费的方式来提升消费性能:","like_count":0},{"had_liked":false,"id":310960,"user_name":"李焕之","can_delete":false,"product_type":"c1","uid":1368198,"ip_address":"","ucode":"ECD77D132411BB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJbCmibL1XtPQmCJxUPg8rHLNgBZbor9UxAN3nOLhehicGkUcWGlq2Zic3XgHX1GLeXYJA0H3OPcNKPw/132","comment_is_top":false,"comment_ctime":1631001738,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100032301,"comment_content":"批量消费在提高性能的同时，会带来以下问题：1、有时延  2、容易丢失 3、会乱序。对时延要求不高，允许偶尔丢失，以及对顺序没有严格要求的场景下可以使用。","like_count":0},{"had_liked":false,"id":302333,"user_name":"小鱼","can_delete":false,"product_type":"c1","uid":1248115,"ip_address":"","ucode":"022B6D5D69DB68","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/73/44fe2df9.jpg","comment_is_top":false,"comment_ctime":1626168545,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"有一个问题，目前的消息本质上不都是发布订阅的模式吗？假如一个订单消息，会被100个下游服务订阅（也就是100个消费者）。那么假设一个订阅者挂了，这样的话这个消息会堆积吗？","like_count":0},{"had_liked":false,"id":301285,"user_name":"董俊俊","can_delete":false,"product_type":"c1","uid":1297887,"ip_address":"","ucode":"732300A779660B","user_header":"https://static001.geekbang.org/account/avatar/00/13/cd/df/c520d418.jpg","comment_is_top":false,"comment_ctime":1625621811,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师，如果开启多个消费者处理消息积压，如何保证消息顺序呀？","like_count":0},{"had_liked":false,"id":296519,"user_name":"xuwen_chen","can_delete":false,"product_type":"c1","uid":1840097,"ip_address":"","ucode":"03C766DEA69DF1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJq1QledRhFicNMRYDJ1ibCveUqlrtIYhDCvAicOmmnia3GPrjjepDZhibXMJ0iabTsibVC2KMZtoIG4A9icg/132","comment_is_top":false,"comment_ctime":1623028754,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师，请问消息堆积和生产者发送速率有什么关系呢，为什么说优化生产者发送性能能解决消息堆积问题","like_count":0},{"had_liked":false,"id":296052,"user_name":"非洲黑猴子","can_delete":false,"product_type":"c1","uid":2639724,"ip_address":"","ucode":"F5FEAC07D562E0","user_header":"https://static001.geekbang.org/account/avatar/00/28/47/6c/78184d19.jpg","comment_is_top":false,"comment_ctime":1622719131,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":9,"product_id":100032301,"comment_content":"如果批量消息存在内存中，还是有丢消息的风险，要先落地磁盘或DB，才能ack，然后再做批量处理，但这似乎就影响性能了，而且中间某个消息保存失败也会影响整体一批数据。对于丢消息不敏感的业务，兴许能这么做","like_count":0},{"had_liked":false,"id":291866,"user_name":"骑着单车去流浪","can_delete":false,"product_type":"c1","uid":1646661,"ip_address":"","ucode":"292B3231848F18","user_header":"https://static001.geekbang.org/account/avatar/00/19/20/45/47de66d5.jpg","comment_is_top":false,"comment_ctime":1620557676,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"增加多个消费者，那又怎么保证消息的顺序呢","like_count":0},{"had_liked":false,"id":286884,"user_name":"风无痕","can_delete":false,"product_type":"c1","uid":1205958,"ip_address":"","ucode":"C9C2E05A229043","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/c6/df252212.jpg","comment_is_top":false,"comment_ctime":1617669223,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师 问个问题  消息挤压 通过水平扩展消费端，消费端一般跟分区是一一对应，增加了消费端，是不是分区也要跟着调整一一对应，然后生产端也要重新映射？","like_count":0},{"had_liked":false,"id":286577,"user_name":"浩仔是程序员","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1617384003,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师你好，如果我想保证topic的有序性，那topic就只能有一个队列是吗？这样子有什么方案提前消费性能吗？","like_count":0},{"had_liked":false,"id":283730,"user_name":"Rover","can_delete":false,"product_type":"c1","uid":1386315,"ip_address":"","ucode":"7575EC91F45B99","user_header":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","comment_is_top":false,"comment_ctime":1615898721,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"\n曾经在使用Kafka时，因为序列化不一致和schema变动导致一直卡在一条消息上报错，而这个报错是consume方法之前抛出的，无法去catch。最终请求运维删除该条消息（测试环境）和修改消费端schema去匹配生产者。\n请问老师这种情况一般应该如何处理呢？","like_count":0},{"had_liked":false,"id":278382,"user_name":"晨曦","can_delete":false,"product_type":"c1","uid":2003953,"ip_address":"","ucode":"99802B94C40092","user_header":"https://static001.geekbang.org/account/avatar/00/1e/93/f1/2a867832.jpg","comment_is_top":false,"comment_ctime":1612923639,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"思考题： 批量消费考虑在一些延迟要求较低，或者业务逻辑本身需要一段时间的数据的情况下。 局限性是，需要考虑服务宕机丢数据的情况，还需要考虑批量处理数据的有序性。","like_count":0},{"had_liked":false,"id":276878,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1612165182,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"可以使用批量消费的手段提升性能,但是需要消费端具有良好的事务回滚机制,或者说整体系统不介意丢失部分数据,所以一些日志类型的场景很适合利用批量消费来增加吞吐量","like_count":0},{"had_liked":false,"id":302333,"user_name":"小鱼","can_delete":false,"product_type":"c1","uid":1248115,"ip_address":"","ucode":"022B6D5D69DB68","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/73/44fe2df9.jpg","comment_is_top":false,"comment_ctime":1626168545,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"有一个问题，目前的消息本质上不都是发布订阅的模式吗？假如一个订单消息，会被100个下游服务订阅（也就是100个消费者）。那么假设一个订阅者挂了，这样的话这个消息会堆积吗？","like_count":0},{"had_liked":false,"id":301285,"user_name":"董俊俊","can_delete":false,"product_type":"c1","uid":1297887,"ip_address":"","ucode":"732300A779660B","user_header":"https://static001.geekbang.org/account/avatar/00/13/cd/df/c520d418.jpg","comment_is_top":false,"comment_ctime":1625621811,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师，如果开启多个消费者处理消息积压，如何保证消息顺序呀？","like_count":0},{"had_liked":false,"id":296519,"user_name":"xuwen_chen","can_delete":false,"product_type":"c1","uid":1840097,"ip_address":"","ucode":"03C766DEA69DF1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJq1QledRhFicNMRYDJ1ibCveUqlrtIYhDCvAicOmmnia3GPrjjepDZhibXMJ0iabTsibVC2KMZtoIG4A9icg/132","comment_is_top":false,"comment_ctime":1623028754,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师，请问消息堆积和生产者发送速率有什么关系呢，为什么说优化生产者发送性能能解决消息堆积问题","like_count":0},{"had_liked":false,"id":296052,"user_name":"非洲黑猴子","can_delete":false,"product_type":"c1","uid":2639724,"ip_address":"","ucode":"F5FEAC07D562E0","user_header":"https://static001.geekbang.org/account/avatar/00/28/47/6c/78184d19.jpg","comment_is_top":false,"comment_ctime":1622719131,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":9,"product_id":100032301,"comment_content":"如果批量消息存在内存中，还是有丢消息的风险，要先落地磁盘或DB，才能ack，然后再做批量处理，但这似乎就影响性能了，而且中间某个消息保存失败也会影响整体一批数据。对于丢消息不敏感的业务，兴许能这么做","like_count":0},{"had_liked":false,"id":291866,"user_name":"骑着单车去流浪","can_delete":false,"product_type":"c1","uid":1646661,"ip_address":"","ucode":"292B3231848F18","user_header":"https://static001.geekbang.org/account/avatar/00/19/20/45/47de66d5.jpg","comment_is_top":false,"comment_ctime":1620557676,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"增加多个消费者，那又怎么保证消息的顺序呢","like_count":0},{"had_liked":false,"id":286884,"user_name":"风无痕","can_delete":false,"product_type":"c1","uid":1205958,"ip_address":"","ucode":"C9C2E05A229043","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/c6/df252212.jpg","comment_is_top":false,"comment_ctime":1617669223,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师 问个问题  消息挤压 通过水平扩展消费端，消费端一般跟分区是一一对应，增加了消费端，是不是分区也要跟着调整一一对应，然后生产端也要重新映射？","like_count":0},{"had_liked":false,"id":286577,"user_name":"浩仔是程序员","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1617384003,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"老师你好，如果我想保证topic的有序性，那topic就只能有一个队列是吗？这样子有什么方案提前消费性能吗？","like_count":0},{"had_liked":false,"id":283730,"user_name":"Rover","can_delete":false,"product_type":"c1","uid":1386315,"ip_address":"","ucode":"7575EC91F45B99","user_header":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","comment_is_top":false,"comment_ctime":1615898721,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"\n曾经在使用Kafka时，因为序列化不一致和schema变动导致一直卡在一条消息上报错，而这个报错是consume方法之前抛出的，无法去catch。最终请求运维删除该条消息（测试环境）和修改消费端schema去匹配生产者。\n请问老师这种情况一般应该如何处理呢？","like_count":0},{"had_liked":false,"id":278382,"user_name":"晨曦","can_delete":false,"product_type":"c1","uid":2003953,"ip_address":"","ucode":"99802B94C40092","user_header":"https://static001.geekbang.org/account/avatar/00/1e/93/f1/2a867832.jpg","comment_is_top":false,"comment_ctime":1612923639,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"思考题： 批量消费考虑在一些延迟要求较低，或者业务逻辑本身需要一段时间的数据的情况下。 局限性是，需要考虑服务宕机丢数据的情况，还需要考虑批量处理数据的有序性。","like_count":0},{"had_liked":false,"id":276878,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1612165182,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":9,"product_id":100032301,"comment_content":"可以使用批量消费的手段提升性能,但是需要消费端具有良好的事务回滚机制,或者说整体系统不介意丢失部分数据,所以一些日志类型的场景很适合利用批量消费来增加吞吐量","like_count":0},{"had_liked":false,"id":261673,"user_name":"明月朔风","can_delete":false,"product_type":"c1","uid":1638570,"ip_address":"","ucode":"C9CAF7B14C38FA","user_header":"https://static001.geekbang.org/account/avatar/00/19/00/aa/1f5fceda.jpg","comment_is_top":false,"comment_ctime":1605487790,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"如果生产者已经发送完成，这时候扩容消费者或者添加分区，无法达到加速的作用，这时候能怎么处理那？","like_count":0},{"had_liked":false,"id":257621,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1604044479,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"解决消息挤压的方法有增加批量和增加并发，在发送端这两个都可以使用，在消费端在增加并发的同时，还要同步扩容分区数量。\n之后再分析消息堆积的具体遇原因，去解决。","like_count":0},{"had_liked":false,"id":250834,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1601257286,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"疑问：\n1.消费端的消费效率应该是受消息队列存储分片数(rockemq就是queue)和 Consumer 实例共同决定的。单独扩展Consumer 的实例感觉无法高效提高消费能力。\n\n个人理解的解决方式:\n2.资产条件允许,业务条件不允许的话。将当前topic中的数据快速转发到一个分片更多的topic中，然后增加 Consumer 实例快速消费。\n3.资产条件不允许,业务条件允许的话。将当前积压的数据找个地方先直接存下，其他topic之类的。保证当下的业务能正常运行。然后后台再慢慢去消费这些堆积的数据。","like_count":0},{"had_liked":false,"id":249386,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1600618078,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"批量消费，支持的业务场景不能是实时业务计算的，可以是离线业务日志分析，能有多线程支持批量消费，对事务性要求不要的。容许时效性和准确性瑕疵，可以使用批量消费。","like_count":0},{"had_liked":false,"id":247569,"user_name":"二少","can_delete":false,"product_type":"c1","uid":1442885,"ip_address":"","ucode":"190983809CD3EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/45/0c474d47.jpg","comment_is_top":false,"comment_ctime":1599743633,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"思考题：\n批量消费一旦某一条数据消费失败会导致整批数据重复消费吗？\n后面有位朋友说，如果某条消息消费失败了，只有它后面的消息会被重新消费，老师的回复也是肯定的。\n到底谁说得对？","like_count":0},{"had_liked":false,"id":245839,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1599092432,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"李sir，对于举的例子：单consumer直接将消息丢到内存队列不等业务处理完成直接返回，对于消息可靠性要求不高的场景如机房测温，也不失一种简单可行的办法","like_count":0},{"had_liked":false,"id":233622,"user_name":"网名还没想好","can_delete":false,"product_type":"c1","uid":1555732,"ip_address":"","ucode":"533BC9CF0A1BB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/bd/14/29e8cb77.jpg","comment_is_top":false,"comment_ctime":1594368635,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"请教一下，这里不太明白“在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。”，在rabbitmq里同样routing key的多个队列都是同时收到消息的，扩展多个队列好像没用吧…我咋感觉应该是反过来，consumer数量应当大于queue的数量","like_count":0},{"had_liked":false,"id":231277,"user_name":"快乐的平头哥","can_delete":false,"product_type":"c1","uid":1635388,"ip_address":"","ucode":"D7D2FA5DA6D8BF","user_header":"https://static001.geekbang.org/account/avatar/00/18/f4/3c/60bf7a17.jpg","comment_is_top":false,"comment_ctime":1593621303,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"rocketmq 不需要扩消费实例也可以 如果是并发消费模式 直接调大线程池 就ok了 。即便是顺序消费 依然可以通过调线程池","like_count":0},{"had_liked":false,"id":223265,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1591031762,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师 问一下发送端批量发送消息 那么这个消息的顺序怎么保证串行呢?","like_count":0},{"had_liked":false,"id":184184,"user_name":"LiYanbin","can_delete":false,"product_type":"c1","uid":1129976,"ip_address":"","ucode":"2F50493F818909","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/f8/b13674e6.jpg","comment_is_top":false,"comment_ctime":1583244152,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"忍不住想称赞一句，基础篇的七篇文章，读下来，收获颇丰，讲的太好啦:)","like_count":0},{"had_liked":false,"id":261673,"user_name":"明月朔风","can_delete":false,"product_type":"c1","uid":1638570,"ip_address":"","ucode":"C9CAF7B14C38FA","user_header":"https://static001.geekbang.org/account/avatar/00/19/00/aa/1f5fceda.jpg","comment_is_top":false,"comment_ctime":1605487790,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"如果生产者已经发送完成，这时候扩容消费者或者添加分区，无法达到加速的作用，这时候能怎么处理那？","like_count":0},{"had_liked":false,"id":257621,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1604044479,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"解决消息挤压的方法有增加批量和增加并发，在发送端这两个都可以使用，在消费端在增加并发的同时，还要同步扩容分区数量。\n之后再分析消息堆积的具体遇原因，去解决。","like_count":0},{"had_liked":false,"id":250834,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1601257286,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"疑问：\n1.消费端的消费效率应该是受消息队列存储分片数(rockemq就是queue)和 Consumer 实例共同决定的。单独扩展Consumer 的实例感觉无法高效提高消费能力。\n\n个人理解的解决方式:\n2.资产条件允许,业务条件不允许的话。将当前topic中的数据快速转发到一个分片更多的topic中，然后增加 Consumer 实例快速消费。\n3.资产条件不允许,业务条件允许的话。将当前积压的数据找个地方先直接存下，其他topic之类的。保证当下的业务能正常运行。然后后台再慢慢去消费这些堆积的数据。","like_count":0},{"had_liked":false,"id":249386,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1600618078,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"批量消费，支持的业务场景不能是实时业务计算的，可以是离线业务日志分析，能有多线程支持批量消费，对事务性要求不要的。容许时效性和准确性瑕疵，可以使用批量消费。","like_count":0},{"had_liked":false,"id":247569,"user_name":"二少","can_delete":false,"product_type":"c1","uid":1442885,"ip_address":"","ucode":"190983809CD3EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/45/0c474d47.jpg","comment_is_top":false,"comment_ctime":1599743633,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"思考题：\n批量消费一旦某一条数据消费失败会导致整批数据重复消费吗？\n后面有位朋友说，如果某条消息消费失败了，只有它后面的消息会被重新消费，老师的回复也是肯定的。\n到底谁说得对？","like_count":0},{"had_liked":false,"id":245839,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1599092432,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"李sir，对于举的例子：单consumer直接将消息丢到内存队列不等业务处理完成直接返回，对于消息可靠性要求不高的场景如机房测温，也不失一种简单可行的办法","like_count":0},{"had_liked":false,"id":233622,"user_name":"网名还没想好","can_delete":false,"product_type":"c1","uid":1555732,"ip_address":"","ucode":"533BC9CF0A1BB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/bd/14/29e8cb77.jpg","comment_is_top":false,"comment_ctime":1594368635,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"请教一下，这里不太明白“在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。”，在rabbitmq里同样routing key的多个队列都是同时收到消息的，扩展多个队列好像没用吧…我咋感觉应该是反过来，consumer数量应当大于queue的数量","like_count":0},{"had_liked":false,"id":231277,"user_name":"快乐的平头哥","can_delete":false,"product_type":"c1","uid":1635388,"ip_address":"","ucode":"D7D2FA5DA6D8BF","user_header":"https://static001.geekbang.org/account/avatar/00/18/f4/3c/60bf7a17.jpg","comment_is_top":false,"comment_ctime":1593621303,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"rocketmq 不需要扩消费实例也可以 如果是并发消费模式 直接调大线程池 就ok了 。即便是顺序消费 依然可以通过调线程池","like_count":0},{"had_liked":false,"id":223265,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1591031762,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"老师 问一下发送端批量发送消息 那么这个消息的顺序怎么保证串行呢?","like_count":0},{"had_liked":false,"id":184184,"user_name":"LiYanbin","can_delete":false,"product_type":"c1","uid":1129976,"ip_address":"","ucode":"2F50493F818909","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/f8/b13674e6.jpg","comment_is_top":false,"comment_ctime":1583244152,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100032301,"comment_content":"忍不住想称赞一句，基础篇的七篇文章，读下来，收获颇丰，讲的太好啦:)","like_count":0},{"had_liked":false,"id":170673,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/a89aca0a.jpg","comment_is_top":false,"comment_ctime":1578662171,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"其实还有一种处理消息积压的方法，设置消费速度，让消费者慢慢消费。当然这种也有局限性，那就是业务对延迟不敏感，实时性要求高的业务就不适合了。所以，很多时候还是看场景，做好权衡和取舍","like_count":0},{"had_liked":false,"id":169127,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1578277986,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"批量消费的问题有三点：\n1. 单个消息的消费。批量消费往往配合多线程消费，最好没有大量的临界资源，否则性能将不如单个消息消费，因为批量消费增加了消息管理成本，例如消费线程间上下文切换、临界资源锁定和解锁等。\n2.消费顺序的保证。如果场景对消费顺序强要求，那么不太适合多线程批量消费，因为无法保证线程间的消费顺序。\n3.消费失败的处理成本。某一条消息的消费失败不能影响其他消息的消费，如发短信就比较适合，而资金流水日志入库就不适合(要保证顺序)。","like_count":0},{"had_liked":false,"id":157934,"user_name":"唯我天棋","can_delete":false,"product_type":"c1","uid":1015960,"ip_address":"","ucode":"B925246C92727A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/98/5591d99d.jpg","comment_is_top":false,"comment_ctime":1575285356,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"可以，在消费消息量特别大，且消费速度特别快的情况下。需要控制批量数量，太大，太小都不好。","like_count":0},{"had_liked":false,"id":134784,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1568934748,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"因为一个分区只能一个消费者消费！所以如果要实现并发消费需要该消费者向消息队列连续取n次！并确认n次！在战队队列数据收到确认消息后，消息队列的消息消费指针就移动了n次！认为这些消息都被消费了！所以如果这个时候客户端出现异常！这些消息就丢了！所以这种情况适合老师文中提到的日志系统！可以容忍部分日志丢失的情况！","like_count":0},{"had_liked":false,"id":130893,"user_name":"dykw","can_delete":false,"product_type":"c1","uid":1412912,"ip_address":"","ucode":"513D787379E158","user_header":"https://static001.geekbang.org/account/avatar/00/15/8f/30/ae34a463.jpg","comment_is_top":false,"comment_ctime":1567566514,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":" 对时效性不是很在意的可以使用，如果类似支付消息这种不适合，需要实时进行处理，如果等累积到一定数量处理，那么消息就滞后了，会导致实际支付，但是数据库却没显示为支付；这种批量消费的方式也需要注意消息的丢失问题","like_count":0},{"had_liked":false,"id":125941,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1566278406,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"rabbitmq和rocketmq有什么常用的监控工具吗？","like_count":0},{"had_liked":false,"id":124656,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1565938839,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"Consumer 的水平扩展能力也很重要","like_count":0},{"had_liked":false,"id":123132,"user_name":"Angus Wang","can_delete":false,"product_type":"c1","uid":1211596,"ip_address":"","ucode":"CFAABDAEE954DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7c/cc/6ce2355a.jpg","comment_is_top":false,"comment_ctime":1565612480,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"讲的太好了！","like_count":0},{"had_liked":false,"id":122779,"user_name":"我瑟瑟的方法","can_delete":false,"product_type":"c1","uid":1065819,"ip_address":"","ucode":"1364CD531E1B72","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg","comment_is_top":false,"comment_ctime":1565520059,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。\n\n——————-\n老师。这一步该怎么保证？需要业务团队消费方","like_count":0},{"had_liked":false,"id":122216,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1565317434,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"批量消费的问题，文中指出使用内存队列会导致丢消息，再参考之前关于消息丢失和消息重复的两节课课，我有一个初步的想法，还是把消息放在broker中，消费者端实现幂等的消费操作，在每次消费完成后返回给broker确认消息。\n用请求确认机制保证消息的可靠性，同时使消费操作幂等来保证不重复消费","like_count":0},{"had_liked":false,"id":170673,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/a89aca0a.jpg","comment_is_top":false,"comment_ctime":1578662171,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"其实还有一种处理消息积压的方法，设置消费速度，让消费者慢慢消费。当然这种也有局限性，那就是业务对延迟不敏感，实时性要求高的业务就不适合了。所以，很多时候还是看场景，做好权衡和取舍","like_count":0},{"had_liked":false,"id":169127,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1578277986,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"批量消费的问题有三点：\n1. 单个消息的消费。批量消费往往配合多线程消费，最好没有大量的临界资源，否则性能将不如单个消息消费，因为批量消费增加了消息管理成本，例如消费线程间上下文切换、临界资源锁定和解锁等。\n2.消费顺序的保证。如果场景对消费顺序强要求，那么不太适合多线程批量消费，因为无法保证线程间的消费顺序。\n3.消费失败的处理成本。某一条消息的消费失败不能影响其他消息的消费，如发短信就比较适合，而资金流水日志入库就不适合(要保证顺序)。","like_count":0},{"had_liked":false,"id":157934,"user_name":"唯我天棋","can_delete":false,"product_type":"c1","uid":1015960,"ip_address":"","ucode":"B925246C92727A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/98/5591d99d.jpg","comment_is_top":false,"comment_ctime":1575285356,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"可以，在消费消息量特别大，且消费速度特别快的情况下。需要控制批量数量，太大，太小都不好。","like_count":0},{"had_liked":false,"id":134784,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1568934748,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"因为一个分区只能一个消费者消费！所以如果要实现并发消费需要该消费者向消息队列连续取n次！并确认n次！在战队队列数据收到确认消息后，消息队列的消息消费指针就移动了n次！认为这些消息都被消费了！所以如果这个时候客户端出现异常！这些消息就丢了！所以这种情况适合老师文中提到的日志系统！可以容忍部分日志丢失的情况！","like_count":0},{"had_liked":false,"id":130893,"user_name":"dykw","can_delete":false,"product_type":"c1","uid":1412912,"ip_address":"","ucode":"513D787379E158","user_header":"https://static001.geekbang.org/account/avatar/00/15/8f/30/ae34a463.jpg","comment_is_top":false,"comment_ctime":1567566514,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":" 对时效性不是很在意的可以使用，如果类似支付消息这种不适合，需要实时进行处理，如果等累积到一定数量处理，那么消息就滞后了，会导致实际支付，但是数据库却没显示为支付；这种批量消费的方式也需要注意消息的丢失问题","like_count":0},{"had_liked":false,"id":125941,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1566278406,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"rabbitmq和rocketmq有什么常用的监控工具吗？","like_count":0},{"had_liked":false,"id":124656,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1565938839,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"Consumer 的水平扩展能力也很重要","like_count":0},{"had_liked":false,"id":123132,"user_name":"Angus Wang","can_delete":false,"product_type":"c1","uid":1211596,"ip_address":"","ucode":"CFAABDAEE954DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7c/cc/6ce2355a.jpg","comment_is_top":false,"comment_ctime":1565612480,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"讲的太好了！","like_count":0},{"had_liked":false,"id":122779,"user_name":"我瑟瑟的方法","can_delete":false,"product_type":"c1","uid":1065819,"ip_address":"","ucode":"1364CD531E1B72","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg","comment_is_top":false,"comment_ctime":1565520059,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。\n\n——————-\n老师。这一步该怎么保证？需要业务团队消费方","like_count":0},{"had_liked":false,"id":122216,"user_name":"DeathKnightH","can_delete":false,"product_type":"c1","uid":1058526,"ip_address":"","ucode":"632E00A01247A3","user_header":"","comment_is_top":false,"comment_ctime":1565317434,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":11,"product_id":100032301,"comment_content":"批量消费的问题，文中指出使用内存队列会导致丢消息，再参考之前关于消息丢失和消息重复的两节课课，我有一个初步的想法，还是把消息放在broker中，消费者端实现幂等的消费操作，在每次消费完成后返回给broker确认消息。\n用请求确认机制保证消息的可靠性，同时使消费操作幂等来保证不重复消费","like_count":0},{"had_liked":false,"id":121184,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1565072694,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"打卡8","like_count":0},{"had_liked":false,"id":121145,"user_name":"啥也不会","can_delete":false,"product_type":"c1","uid":1040584,"ip_address":"","ucode":"2E0F593B237C59","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/c8/4ad13219.jpg","comment_is_top":false,"comment_ctime":1565063757,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"日常打卡","like_count":0},{"had_liked":false,"id":121118,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1565060983,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"批量消费的局限性，我补充一点\n因为是批量消费，所以系统的延迟肯定是会加大的。","like_count":0},{"had_liked":false,"id":121079,"user_name":"大魔王汪汪","can_delete":false,"product_type":"c1","uid":1010680,"ip_address":"","ucode":"4B205CB52FC95F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","comment_is_top":false,"comment_ctime":1565054994,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"可以通过设置批量消费提升性能，需要业务对于顺序不敏感","like_count":0},{"had_liked":false,"id":121071,"user_name":"佳明","can_delete":false,"product_type":"c1","uid":1100299,"ip_address":"","ucode":"0BAAD556725638","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/0b/cafcc9d0.jpg","comment_is_top":false,"comment_ctime":1565054367,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"如果是接受一些不重要的消息，允许消息丢失比如日志类的可以在消费端批量消费提高系统吞吐量。\n","like_count":0},{"had_liked":false,"id":121058,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1565053620,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"批量消费可以适用于离线分析场景，没有很高的即时性，批量消费可能会导致消息没有消费成功，也会ack，导致丢失","like_count":0},{"had_liked":false,"id":121052,"user_name":"陈泽坛","can_delete":false,"product_type":"c1","uid":1394861,"ip_address":"","ucode":"C81B402868E9E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/ad/8be724da.jpg","comment_is_top":false,"comment_ctime":1565053085,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":121033,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1565052258,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":12,"product_id":100032301,"comment_content":"能看出老师的经验很丰富，给出的解决方案实战性很强，最为重要的是给出了错误的避坑指南。","like_count":0},{"had_liked":false,"id":120993,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1565046314,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"我觉着批量消费的话，需要消费端从消息队列堆积一定量的消息后再集中处理，而堆积的消息需要有地方存储，而这样的话就像文中举的那个例子一样可能会丢消息。所以批量消费消息适用于可以容忍消息适量丢失的场景。","like_count":0},{"had_liked":false,"id":121184,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1565072694,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"打卡8","like_count":0},{"had_liked":false,"id":121145,"user_name":"啥也不会","can_delete":false,"product_type":"c1","uid":1040584,"ip_address":"","ucode":"2E0F593B237C59","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/c8/4ad13219.jpg","comment_is_top":false,"comment_ctime":1565063757,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"日常打卡","like_count":0},{"had_liked":false,"id":121118,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1565060983,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"批量消费的局限性，我补充一点\n因为是批量消费，所以系统的延迟肯定是会加大的。","like_count":0},{"had_liked":false,"id":121079,"user_name":"大魔王汪汪","can_delete":false,"product_type":"c1","uid":1010680,"ip_address":"","ucode":"4B205CB52FC95F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","comment_is_top":false,"comment_ctime":1565054994,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"可以通过设置批量消费提升性能，需要业务对于顺序不敏感","like_count":0},{"had_liked":false,"id":121071,"user_name":"佳明","can_delete":false,"product_type":"c1","uid":1100299,"ip_address":"","ucode":"0BAAD556725638","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/0b/cafcc9d0.jpg","comment_is_top":false,"comment_ctime":1565054367,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"如果是接受一些不重要的消息，允许消息丢失比如日志类的可以在消费端批量消费提高系统吞吐量。\n","like_count":0},{"had_liked":false,"id":121058,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1565053620,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"批量消费可以适用于离线分析场景，没有很高的即时性，批量消费可能会导致消息没有消费成功，也会ack，导致丢失","like_count":0},{"had_liked":false,"id":121052,"user_name":"陈泽坛","can_delete":false,"product_type":"c1","uid":1394861,"ip_address":"","ucode":"C81B402868E9E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/ad/8be724da.jpg","comment_is_top":false,"comment_ctime":1565053085,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":121033,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1565052258,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":12,"product_id":100032301,"comment_content":"能看出老师的经验很丰富，给出的解决方案实战性很强，最为重要的是给出了错误的避坑指南。","like_count":0},{"had_liked":false,"id":120993,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1565046314,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":12,"product_id":100032301,"comment_content":"我觉着批量消费的话，需要消费端从消息队列堆积一定量的消息后再集中处理，而堆积的消息需要有地方存储，而这样的话就像文中举的那个例子一样可能会丢消息。所以批量消费消息适用于可以容忍消息适量丢失的场景。","like_count":0}]}