{"id":75794,"title":"42 | 动态规划实战：如何实现搜索引擎中的拼写纠错功能？","content":"<p>在<a href=\"https://time.geekbang.org/column/article/72414\">Trie树</a>那节我们讲过，利用Trie树，可以实现搜索引擎的关键词提示功能，这样可以节省用户输入搜索关键词的时间。实际上，搜索引擎在用户体验方面的优化还有很多，比如你可能经常会用的拼写纠错功能。</p><p>当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。作为一名软件开发工程师，你是否想过，这个功能是怎么实现的呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/6d/c18a9c785206754f9f1ff74c1b8f6c6d.png?wh=1560*466\" alt=\"\"></p><h2>如何量化两个字符串的相似度？</h2><p>计算机只认识数字，所以要解答开篇的问题，我们就要先来看，如何量化两个字符串之间的相似程度呢？有一个非常著名的量化方法，那就是编辑距离（Edit Distance）。</p><p>顾名思义，<strong>编辑距离</strong>指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是0。</p><p>根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有<strong>莱文斯坦距离</strong>（Levenshtein distance）和<strong>最长公共子串长度</strong>（Longest common substring length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。</p><!-- [[[read_end]]] --><p>而且，莱文斯坦距离和最长公共子串长度，从两个截然相反的角度，分析字符串的相似程度。莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。</p><p>关于这两个计算方法，我举个例子给你说明一下。这里面，两个字符串mitcmu和mtacnu的莱文斯坦距离是3，最长公共子串长度是4。</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/0f/f0e72008ce8451609abed7e368ac420f.jpg?wh=1142*518\" alt=\"\"></p><p>了解了编辑距离的概念之后，我们来看，如何快速计算两个字符串之间的编辑距离？</p><h2>如何编程计算莱文斯坦距离？</h2><p>之前我反复强调过，思考过程比结论更重要，所以，我现在就给你展示一下，解决这个问题，我的完整的思考过程。</p><p>这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。整个求解过程，涉及多个决策阶段，我们需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理。所以，这个问题符合<strong>多阶段决策最优解模型</strong>。</p><p>我们前面讲了，贪心、回溯、动态规划可以解决的问题，都可以抽象成这样一个模型。要解决这个问题，我们可以先看一看，用最简单的回溯算法，该如何来解决。</p><p>回溯是一个递归处理的过程。如果a[i]与b[j]匹配，我们递归考察a[i+1]和b[j+1]。如果a[i]与b[j]不匹配，那我们有多种处理方式可选：</p><ul>\n<li>\n<p>可以删除a[i]，然后递归考察a[i+1]和b[j]；</p>\n</li>\n<li>\n<p>可以删除b[j]，然后递归考察a[i]和b[j+1]；</p>\n</li>\n<li>\n<p>可以在a[i]前面添加一个跟b[j]相同的字符，然后递归考察a[i]和b[j+1];</p>\n</li>\n<li>\n<p>可以在b[j]前面添加一个跟a[i]相同的字符，然后递归考察a[i+1]和b[j]；</p>\n</li>\n<li>\n<p>可以将a[i]替换成b[j]，或者将b[j]替换成a[i]，然后递归考察a[i+1]和b[j+1]。</p>\n</li>\n</ul><p>我们将上面的回溯算法的处理思路，翻译成代码，就是下面这个样子：</p><pre><code>private char[] a = &quot;mitcmu&quot;.toCharArray();\nprivate char[] b = &quot;mtacnu&quot;.toCharArray();\nprivate int n = 6;\nprivate int m = 6;\nprivate int minDist = Integer.MAX_VALUE; // 存储结果\n// 调用方式 lwstBT(0, 0, 0);\npublic lwstBT(int i, int j, int edist) {\n  if (i == n || j == m) {\n    if (i &lt; n) edist += (n-i);\n    if (j &lt; m) edist += (m - j);\n    if (edist &lt; minDist) minDist = edist;\n    return;\n  }\n  if (a[i] == b[j]) { // 两个字符匹配\n    lwstBT(i+1, j+1, edist);\n  } else { // 两个字符不匹配\n    lwstBT(i + 1, j, edist + 1); // 删除a[i]或者b[j]前添加一个字符\n    lwstBT(i, j + 1, edist + 1); // 删除b[j]或者a[i]前添加一个字符\n    lwstBT(i + 1, j + 1, edist + 1); // 将a[i]和b[j]替换为相同字符\n  }\n}\n</code></pre><p>根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/86/89/864f25506eb3db427377bde7bb4c9589.jpg?wh=1142*820\" alt=\"\"></p><p>在递归树中，每个节点代表一个状态，状态包含三个变量(i, j, edist)，其中，edist表示处理到a[i]和b[j]时，已经执行的编辑操作的次数。</p><p>在递归树中，(i, j)两个变量重复的节点很多，比如(3, 2)和(2, 3)。对于(i, j)相同的节点，我们只需要保留edist最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从(i, j, edist)变成了(i, j, min_edist)，其中min_edist表示处理到a[i]和b[j]，已经执行的最少编辑次数。</p><p>看到这里，你有没有觉得，这个问题跟上两节讲的动态规划例子非常相似？不过，这个问题的状态转移方式，要比之前两节课中讲到的例子都要复杂很多。上一节我们讲的矩阵最短路径问题中，到达状态(i, j)只能通过(i-1, j)或(i, j-1)两个状态转移过来，而今天这个问题，状态(i, j)可能从(i-1, j)，(i, j-1)，(i-1, j-1)三个状态中的任意一个转移过来。</p><p><img src=\"https://static001.geekbang.org/resource/image/11/89/11ffcba9b3c722c5487de7df5a0d6c89.jpg?wh=1142*446\" alt=\"\"></p><p>基于刚刚的分析，我们可以尝试着将把状态转移的过程，用公式写出来。这就是我们前面讲的状态转移方程。</p><pre><code>如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：\nmin(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)\n\n如果：a[i]==b[j]，那么：min_edist(i, j)就等于：\nmin(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))\n\n其中，min表示求三数中的最小值。     \n</code></pre><p>了解了状态与状态之间的递推关系，我们画出一个二维的状态表，按行依次来填充状态表中的每个值。</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/2d/ab44eb53fad2601c19f73604747d652d.jpg?wh=1142*771\" alt=\"\"></p><p>我们现在既有状态转移方程，又理清了完整的填表过程，代码实现就非常简单了。我将代码贴在下面，你可以对比着文字解释，一起看下。</p><pre><code>public int lwstDP(char[] a, int n, char[] b, int m) {\n  int[][] minDist = new int[n][m];\n  for (int j = 0; j &lt; m; ++j) { // 初始化第0行:a[0..0]与b[0..j]的编辑距离\n    if (a[0] == b[j]) minDist[0][j] = j;\n    else if (j != 0) minDist[0][j] = minDist[0][j-1]+1;\n    else minDist[0][j] = 1;\n  }\n  for (int i = 0; i &lt; n; ++i) { // 初始化第0列:a[0..i]与b[0..0]的编辑距离\n    if (a[i] == b[0]) minDist[i][0] = i;\n    else if (i != 0) minDist[i][0] = minDist[i-1][0]+1;\n    else minDist[i][0] = 1;\n  }\n  for (int i = 1; i &lt; n; ++i) { // 按行填表\n    for (int j = 1; j &lt; m; ++j) {\n      if (a[i] == b[j]) minDist[i][j] = min(\n          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]);\n      else minDist[i][j] = min(\n          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]+1);\n    }\n  }\n  return minDist[n-1][m-1];\n}\n\nprivate int min(int x, int y, int z) {\n  int minv = Integer.MAX_VALUE;\n  if (x &lt; minv) minv = x;\n  if (y &lt; minv) minv = y;\n  if (z &lt; minv) minv = z;\n  return minv;\n}\n</code></pre><p>你可能会说，我虽然能看懂你讲的思路，但是遇到新的问题的时候，我还是会感觉到无从下手。这种感觉是非常正常的。关于复杂算法问题的解决思路，我还有一些经验、小技巧，可以分享给你。</p><p>当我们拿到一个问题的时候，<strong>我们可以先不思考，计算机会如何实现这个问题，而是单纯考虑“人脑”会如何去解决这个问题</strong>。人脑比较倾向于思考具象化的、摸得着看得见的东西，不适合思考过于抽象的问题。所以，我们需要把抽象问题具象化。那如何具象化呢？我们可以实例化几个测试数据，通过人脑去分析具体实例的解，然后总结规律，再尝试套用学过的算法，看是否能够解决。</p><p>除此之外，我还有一个非常有效、但也算不上技巧的东西，我也反复强调过，那就是<strong>多练</strong>。实际上，等你做多了题目之后，自然就会有感觉，看到问题，立马就能想到能否用动态规划解决，然后直接就可以寻找最优子结构，写出动态规划方程，然后将状态转移方程翻译成代码。</p><h2>如何编程计算最长公共子串长度？</h2><p>前面我们讲到，最长公共子串作为编辑距离中的一种，只允许增加、删除字符两种编辑操作。从名字上，你可能觉得它看起来跟编辑距离没什么关系。实际上，从本质上来说，它表征的也是两个字符串之间的相似程度。</p><p>这个问题的解决思路，跟莱文斯坦距离的解决思路非常相似，也可以用动态规划解决。我刚刚已经详细讲解了莱文斯坦距离的动态规划解决思路，所以，针对这个问题，我直接定义状态，然后写状态转移方程。</p><p>每个状态还是包括三个变量(i, j, max_lcs)，max_lcs表示a[0...i]和b[0...j]的最长公共子串长度。那(i, j)这个状态都是由哪些状态转移过来的呢？</p><p>我们先来看回溯的处理思路。我们从a[0]和b[0]开始，依次考察两个字符串中的字符是否匹配。</p><ul>\n<li>\n<p>如果a[i]与b[j]互相匹配，我们将最大公共子串长度加一，并且继续考察a[i+1]和b[j+1]。</p>\n</li>\n<li>\n<p>如果a[i]与b[j]不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：</p>\n</li>\n<li>\n<p>删除a[i]，或者在b[j]前面加上一个字符a[i]，然后继续考察a[i+1]和b[j]；</p>\n</li>\n<li>\n<p>删除b[j]，或者在a[i]前面加上一个字符b[j]，然后继续考察a[i]和b[j+1]。</p>\n</li>\n</ul><p>反过来也就是说，如果我们要求a[0...i]和b[0...j]的最长公共长度max_lcs(i, j)，我们只有可能通过下面三个状态转移过来：</p><ul>\n<li>\n<p>(i-1, j-1, max_lcs)，其中max_lcs表示a[0...i-1]和b[0...j-1]的最长公共子串长度；</p>\n</li>\n<li>\n<p>(i-1, j, max_lcs)，其中max_lcs表示a[0...i-1]和b[0...j]的最长公共子串长度；</p>\n</li>\n<li>\n<p>(i, j-1, max_lcs)，其中max_lcs表示a[0...i]和b[0...j-1]的最长公共子串长度。</p>\n</li>\n</ul><p>如果我们把这个转移过程，用状态转移方程写出来，就是下面这个样子：</p><pre><code>如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：\nmax(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；\n\n如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：\nmax(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))；\n\n其中max表示求三数中的最大值。\n</code></pre><p>有了状态转移方程，代码实现就简单多了。我把代码贴到了下面，你可以对比着文字一块儿看。</p><pre><code>public int lcs(char[] a, int n, char[] b, int m) {\n  int[][] maxlcs = new int[n][m];\n  for (int j = 0; j &lt; m; ++j) {//初始化第0行：a[0..0]与b[0..j]的maxlcs\n    if (a[0] == b[j]) maxlcs[0][j] = 1;\n    else if (j != 0) maxlcs[0][j] = maxlcs[0][j-1];\n    else maxlcs[0][j] = 0;\n  }\n  for (int i = 0; i &lt; n; ++i) {//初始化第0列：a[0..i]与b[0..0]的maxlcs\n    if (a[i] == b[0]) maxlcs[i][0] = 1;\n    else if (i != 0) maxlcs[i][0] = maxlcs[i-1][0];\n    else maxlcs[i][0] = 0;\n  }\n  for (int i = 1; i &lt; n; ++i) { // 填表\n    for (int j = 1; j &lt; m; ++j) {\n      if (a[i] == b[j]) maxlcs[i][j] = max(\n          maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]+1);\n      else maxlcs[i][j] = max(\n          maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]);\n    }\n  }\n  return maxlcs[n-1][m-1];\n}\n\nprivate int max(int x, int y, int z) {\n  int maxv = Integer.MIN_VALUE;\n  if (x &gt; maxv) maxv = x;\n  if (y &gt; maxv) maxv = y;\n  if (z &gt; maxv) maxv = z;\n  return maxv;\n}\n</code></pre><h2>解答开篇</h2><p>今天的内容到此就讲完了，我们来看下开篇的问题。</p><p>当用户在搜索框内，输入一个拼写错误的单词时，我们就拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户。</p><p>这就是拼写纠错最基本的原理。不过，真正用于商用的搜索引擎，拼写纠错功能显然不会就这么简单。一方面，单纯利用编辑距离来纠错，效果并不一定好；另一方面，词库中的数据量可能很大，搜索引擎每天要支持海量的搜索，所以对纠错的性能要求很高。</p><p>针对纠错效果不好的问题，我们有很多种优化思路，我这里介绍几种。</p><ul>\n<li>\n<p>我们并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。</p>\n</li>\n<li>\n<p>我们还可以用多种编辑距离计算方法，比如今天讲到的两种，然后分别编辑距离最小的TOP 10，然后求交集，用交集的结果，再继续优化处理。</p>\n</li>\n<li>\n<p>我们还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最常被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。这样纠错的效果非常好。</p>\n</li>\n<li>\n<p>我们还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，我们首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。</p>\n</li>\n</ul><p>针对纠错性能方面，我们也有相应的优化方式。我讲两种分治的优化思路。</p><ul>\n<li>\n<p>如果纠错功能的TPS不高，我们可以部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，我们通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词。</p>\n</li>\n<li>\n<p>如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，我们可以将纠错的词库，分割到很多台机器。当有一个纠错请求的时候，我们就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并行处理，分别得到编辑距离最小的单词，然后再比对合并，最终决定出一个最优的纠错单词。</p>\n</li>\n</ul><p>真正的搜索引擎的拼写纠错优化，肯定不止我讲的这么简单，但是万变不离其宗。掌握了核心原理，就是掌握了解决问题的方法，剩下就靠你自己的灵活运用和实战操练了。</p><h2>内容小结</h2><p>动态规划的三节内容到此就全部讲完了，不知道你掌握得如何呢？</p><p>动态规划的理论尽管并不复杂，总结起来就是“一个模型三个特征”。但是，要想灵活应用并不简单。要想能真正理解、掌握动态规划，你只有多练习。</p><p>这三节中，加上课后思考题，总共有8个动态规划问题。这8个问题都非常经典，是我精心筛选出来的。很多动态规划问题其实都可以抽象成这几个问题模型，所以，你一定要多看几遍，多思考一下，争取真正搞懂它们。</p><p>只要弄懂了这几个问题，一般的动态规划问题，你应该都可以应付。对于动态规划这个知识点，你就算是入门了，再学习更加复杂的就会简单很多。</p><h2>课后思考</h2><p>我们有一个数字序列包含n个不同的数字，如何求出这个序列中的最长递增子序列长度？比如2, 9, 3, 6, 5, 1, 7这样一组数字序列，它的最长递增子序列就是2, 3, 5, 7，所以最长递增子序列的长度是4。</p><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","comments":[{"had_liked":false,"id":56718,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1546527626,"is_pvip":false,"replies":[{"id":"20477","content":"👍好厉害","user_name":"作者回复","comment_id":56718,"uid":"1190123","ip_address":"","utype":1,"ctime":1546565917,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"800410444682","product_id":100017301,"comment_content":"补充一下，中文纠错很多时候是通过拼音进行的，比如 &quot;刘得花&quot;-&gt;&quot;liudehua&quot;-&gt;&quot;刘德华&quot;.  拼音检索方法也有很多，比如可以把热门词汇的拼音字母组织成Trie树，每个热词的结尾汉字的最后一个拼音字母就是叶子，整体性能就是O(n)的，n为query的拼音总长度.  除了拼音外也有根据字形（二维文字版的编辑距离？）甚至语义等做的纠错策略。<br>传统搜索引擎中的查询词智能提示、纠错、同义词、近义词、同好词、相关搜索、知识图谱等系列功能统称为用户的意图识别模块。","like_count":186,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435192,"discussion_content":"👍好厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546565917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2654225,"avatar":"","nickname":"Geek_6923ae","note":"","ucode":"9D906E2DA64250","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378831,"discussion_content":"看到字形我就想到五笔，或者类似于五笔的，其它对字形识别更高效的编码方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623423437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240321,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/01/997432f3.jpg","nickname":"喜笑延开","note":"","ucode":"DBF645D2129460","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365041,"discussion_content":"大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617692587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56038,"user_name":"ext4","can_delete":false,"product_type":"c1","uid":1180826,"ip_address":"","ucode":"FC881AECAC1974","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/9a/f2c0a206.jpg","comment_is_top":false,"comment_ctime":1546389324,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"525532399436","product_id":100017301,"comment_content":"Trie树和编辑距离，很多年前我去Google面试的时候都被考过。还记得Trie树是问我怎么存储美国的10位电话号码，可以最快速查找一个号码是否是空号，我答上来了；不过关于编辑距离我当时没想出来用dp。","like_count":122,"discussions":[{"author":{"id":1136329,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/c9/7b3cd3e0.jpg","nickname":"马振","note":"","ucode":"94234F533219C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80967,"discussion_content":"编辑距离这个问题让王老师复杂化了，源串和目的串都修改会复杂化逻辑；本质上都修改也可以也可以简化为仅仅修改源串的，这样能很大程度简化逻辑。\n假设源串和目的串分别有一个指针在尾部，均向前移动，此时源串字符仅仅有三种处理：\n删除字符：执行源字符的删除，源字符指针移动，但是两个指针指向的字符不一定相等，所以需要继续递归，编辑次数加一\n替换或插入:执行源字符的替换和插入，此时插入或替换后的字符就是目的串指针对应的字符，所以一定会实现两个指针指向的字符不一定相等，所以均移动，编辑次数加一\n\n    static char[] origin = &#34;mitcmu&#34;.toCharArray();\n    static char[] dest = &#34;mtacnu&#34;.toCharArray();\n    static int minEditNum = Integer.MAX_VALUE;\n\n    // 回溯法---解决两个字符串的编辑距离\n    // 倒序比较，o:源字符串长度-1 d:目的字符串长的-1；\n    // 调用方式：lwst(0,0,0);\n    public static void lwst(int o, int d, int editNum){\n        if(o>=origin.length-1 || d>=dest.length-1){\n            if(editNum < minEditNum){\n                minEditNum = editNum;\n            }\n            minEditNum = minEditNum+Math.abs(o-d);\n            System.out.println(minEditNum);\n            return;\n        }\n        if(origin[o] == dest[d]){\n            lwst(o+1, d+1, editNum);\n        }else{\n            // 源插入 或者 源替换,此时执行后的结果一定是origin[o] == dest[d]\n            lwst(o+1, d+1, editNum+1);\n            // 源删除，此时结果不一定满足origin[o] == dest[d]，但是源肯定要前进一位\n            lwst(o+1, d, editNum+1);\n        }\n    }\n\n    // 状态转移方程---解决两个字符串的编辑距离\n    // 倒序比较，o:源字符串长度-1 d:目的字符串长的-1\n    // 调用方式：System.out.println(lwstNew(origin.length-1, dest.length-1));\n    public static int lwstNew(int o, int d){\n        // 如果源或目的已经到边界，此时只能插入。\n        if( o < 0 || d < 0){\n            return Math.abs(o-d);\n        }\n        // 字符相等此时直接移动指针，编辑次数无变化\n        if(origin[d] == dest[o]){\n            return lwstNew(o-1, d-1);\n        }else{\n            // 执行源字符的替换或插入，编辑次数加一，此时一定实现origin[d] == dest[o]，所以均移动\n            int replaceOrInsert = lwstNew(o-1,d-1) + 1;\n            // 执行源字符的删除，编辑次数加一，但是不确保origin[d] == dest[o-1]，所以需要继续递归\n            int delete = lwstNew(o-1, d) + 1;\n            return Math.min(replaceOrInsert, delete);\n        }\n    }","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1576208153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1136329,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/c9/7b3cd3e0.jpg","nickname":"马振","note":"","ucode":"94234F533219C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327215,"discussion_content":"赞！思路不错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605769921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80967,"ip_address":""},"score":327215,"extra":""}]},{"author":{"id":1136329,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/c9/7b3cd3e0.jpg","nickname":"马振","note":"","ucode":"94234F533219C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":170128,"discussion_content":"上面代码有两个问题，1 删除的时候可以删除原 也可以删除目的 2上面没有对重复运算做处理，导致leetcode中会超时，所以下面给出新的代码：\n\n\tint[][] result;\n    public int minDistance1(String origin, String dest) {\n    \tif(origin == null || dest == null){\n    \t\treturn -1;\n    \t}\n    \t// 缓存，避免重复计算，row：origin剩余的待处理长度， col:des剩余长度， value：最小修改次数\n    \tresult = new int[origin.length()+1][dest.length()+1];\n    \tfor(int i=0; i<origin.length()+1; i++){\n    \t\tfor(int j=0; j<dest.length()+1; j++){\n    \t\t\tresult[i][j] = Integer.MAX_VALUE;\n    \t\t}\n    \t}\n    \t\n    \treturn getMin(0, 0, origin, dest);\n    }\n\t\n\tprivate int getMin(int pointO, int pointD, String origin, String dest) {\n\t\tif(pointO == origin.length() || pointD == dest.length()){\n\t\t\treturn Math.max(origin.length()-pointO, dest.length()-pointD);\n\t\t}\n\t\tint leftO = origin.length() - pointO, leftD = dest.length() - pointD;\n\t\t// 成立则说明数据已经计算，直接返回，避免重复计算\n\t\tif(result[leftO][leftD] != Integer.MAX_VALUE){\n\t\t\treturn result[leftO][leftD];\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tif(origin.charAt(pointO) == dest.charAt(pointD)){\n\t\t\tres =  getMin(pointO+1, pointD+1, origin, dest);\n\t\t}else{\n\t\t\tint deleteO = getMin(pointO+1, pointD, origin, dest) + 1;\n\t\t\tint deleteD = getMin(pointO, pointD+1, origin, dest) + 1;\n\t\t\tint updateOrAdd = getMin(pointO+1, pointD+1, origin, dest) + 1;\n\t\t\tres =  Math.min(Math.min(deleteO, deleteD), updateOrAdd);\n\t\t}\n\t\tresult[leftO][leftD] = res;\n\t\treturn res;\n\t}","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1581671227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747918,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ab/ce/a4d03c2c.jpg","nickname":"张德雷","note":"","ucode":"788BEC93FB7971","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343400,"discussion_content":"这个应该用布隆过滤器就可以解决是否为空号，编辑距离这种算法适合用于纠错或者查找相关性较好。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611032371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1865908,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/78/b4/af163d12.jpg","nickname":"雨天的七毫米","note":"","ucode":"963BBAFE8EF97B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189716,"discussion_content":"哈哈，你看这个题 https://leetcode.com/problems/longest-common-subsequence/ 就是了，我还画了状态转移图。https://i.imgur.com/ggyWX4Z.png","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582898114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1866485,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","nickname":"简单猫","note":"","ucode":"EA027D4C344E25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548669,"discussion_content":"查手机空号可以用 布隆算法\n10为手机号\n申请的十倍大小的bit\n然后对所有手机号做不同的hash\n对应的位置为0代表一定不存在","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643300670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625340,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","nickname":"骑着驴读着书的谢小夕","note":"","ucode":"56F0A469B630A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349450,"discussion_content":"源的插入，等价于目标的删除会 比较好理解一些。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613217182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1983108,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/42/84/27d9db87.jpg","nickname":"zss","note":"","ucode":"F1F6D8821D91F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291095,"discussion_content":"大。。。大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594705299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061079,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqoIAXhIA308CK9HLE7KribIJ1Vbjjw6Uo4AgJsgtWv5cb1G0pVbQGpibRP6LV8uGTNf9jB984bZ9Qw/132","nickname":"bine","note":"","ucode":"2A0CCBF4CDD2C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282705,"discussion_content":"求如何查找手机号是否为空号 的思路 ？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592052955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56436,"user_name":"blacknhole","can_delete":false,"product_type":"c1","uid":1098286,"ip_address":"","ucode":"271682FFE28F25","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","comment_is_top":false,"comment_ctime":1546443418,"is_pvip":false,"replies":[{"id":"20493","content":"👍你说的没错 不仅这一节 前面两节课都是这样。递归树是根据回溯算法代码实现写的。但是动规代码用你讲到的另一种思路理解更容易。我当时写的时候 也想能不能统一。最后发现不好统一。你可以分割开来看 或者 把它们当作两种状态表示方法来看 不影响理解","user_name":"作者回复","comment_id":56436,"uid":"1190123","ip_address":"","utype":1,"ctime":1546567140,"user_name_real":"gg"}],"discussion_count":17,"race_medal":0,"score":"229179710106","product_id":100017301,"comment_content":"有个疑问：<br>以下内容涉及“如何编程计算莱文斯坦距离？”一节。<br><br>（1）文中对递归树中的状态三元组(i, j, edist)的解释是，“状态包含三个变量 (i, j, edist)，其中，edist表示处理到 a[i] 和 b[j] 时，已经执行的编辑操作的次数。”这里的“处理到a[i]和b[j]时”，其实是在说将要处理但还并未处理a[i]和b[j]。edist并不包括对a[i]和[j]的编辑操作。递归树图片后紧接着的图片中，(i, j, min_edist)的min_edist也并不包括对a[i]和[j]的编辑操作。<br><br>（2）而二维状态表图片中每格的值和动态规划的实现代码中minDist[i][j]两者均代表：到处理完a[i]和b[j]之后为止，已经执行的编辑操作的最少次数。根据这个意思，可知状态转移方程中的min_edist(i, j)也是包括对a[i]和[j]的编辑操作的。如果按照（1）中的意思，状态转移方程中的min_edist(i, j)就不应该包括对a[i]和[j]的编辑操作，也不应该判断a[i]和b[j]是否相等，而应该判断的是a[i - 1]和b[j - 1]是否相等；并且动态规划的实现代码中循环终止条件就不应是小于n或m，而应是小于等于n或m。<br><br>为什么会有（1）与（2）这样的在文章前后表达上的不一致？","like_count":53,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435034,"discussion_content":"👍你说的没错 不仅这一节 前面两节课都是这样。递归树是根据回溯算法代码实现写的。但是动规代码用你讲到的另一种思路理解更容易。我当时写的时候 也想能不能统一。最后发现不好统一。你可以分割开来看 或者 把它们当作两种状态表示方法来看 不影响理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546567140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20213,"discussion_content":"纠结中，不知道怎么合理的推导出状态转移方程，明明根据递归树到状态转移图的时候还能明白，但是写出的状态转移方程怎么也想不明白了","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1569290432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327228,"discussion_content":"同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605771870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20213,"ip_address":""},"score":327228,"extra":""}]},{"author":{"id":1050777,"avatar":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","nickname":"小时候可鲜啦","note":"","ucode":"C88B3EDF758230","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303089,"discussion_content":"我觉得层主说得很在理，老师的写法反而不好理解，核心是edist表示的含义：\n1、处理到 a[i] 和 b[j] 时，已经执行的编辑操作的次数。”这里的“处理到a[i]和b[j]时”，其实是在说将要处理但还并未处理a[i]和b[j]。edist并不包括对a[i]和[j]的编辑操作。\n2、处理完 a[i] 和 b[j] 时，执行的编辑操作的次数。包括对a[i]和[j]的编辑操作。\n我认为正确的处理方式应该时\n在1的情况下：\n如果：a[i-1]!=b[j-1]，那么：min_edist(i, j)就等于：min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)\n如果：a[i-1]==b[j-1]，那么：min_edist(i, j)就等于：min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))\n在2的情况下：\n如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)\n如果：a[i]==b[j]，那么：min_edist(i, j)就等于：min(min_edist(i-1,j), min_edist(i,j-1)，min_edist(i-1,j-1))\n请老师指正","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1599134788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1050777,"avatar":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","nickname":"小时候可鲜啦","note":"","ucode":"C88B3EDF758230","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327234,"discussion_content":"赞。同疑惑，跟我的理解一致。请老师，或者哪位解答下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605772206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303089,"ip_address":""},"score":327234,"extra":""},{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1050777,"avatar":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","nickname":"小时候可鲜啦","note":"","ucode":"C88B3EDF758230","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335050,"discussion_content":"所以到底是哪种情况？min_edist(i, j)所表示的到底是啥？是否包含(i,j)这一次的编辑距离","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608080772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303089,"ip_address":""},"score":335050,"extra":""},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1050777,"avatar":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","nickname":"小时候可鲜啦","note":"","ucode":"C88B3EDF758230","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345580,"discussion_content":"我也不知道最后一条前面两项为啥要+1，但运行code确实+1才能得到正确结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611748019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303089,"ip_address":""},"score":345580,"extra":""}]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86320,"discussion_content":"即使是说 min[i,j] 是对  i 或 j 字符编辑后的最小次数\n那 a[i] ==b[j] 时，本次不需要编辑，应该是直接等于 上一个转移的 min值啊\n为啥 有两个情况 要+1 ？\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576593832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327242,"discussion_content":"同问。除非是上面评论中a[i-1]==b[i-1], 统计到i-1的第2中情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605773251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":86320,"ip_address":""},"score":327242,"extra":""}]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327227,"discussion_content":"同样在纠结为什么不判断a[i - 1]和b[j - 1]。同以为第一个问题为准，以为后面的都是作者笔误写错了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605771825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1985537,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/4c/01/72203f00.jpg","nickname":"邵光泽","note":"","ucode":"45088A0F5DF384","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586626,"discussion_content":"妈呀，幸亏看到这篇评论。。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662381653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2474580,"avatar":"https://static001.geekbang.org/account/avatar/00/25/c2/54/77dac43b.jpg","nickname":"UltramanTiga","note":"","ucode":"245D8768E5CCDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580081,"discussion_content":"所以是公式写错了吧？文中单独列出来的公式，既不符合1，也不符合2。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657865474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1516753,"avatar":"https://static001.geekbang.org/account/avatar/00/17/24/d1/a3933e71.jpg","nickname":"wang.yu","note":"","ucode":"871A0D7B4AECA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551158,"discussion_content":"这位朋友的留言解答了我得疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644913420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014781,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/fd/26cfeaf5.jpg","nickname":"SS","note":"","ucode":"14CB1ECAC0AD6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530856,"discussion_content":"的确，这块确实让人难以理解，希望能有更好的表述","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637159903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249616,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/wiaQmkQdIh84RibSLrDkIA3HtibAR4IibpnP3VEmiaLzvpiaibXJQEb2LLUrCD4dM7DjvOFD65IbdZm2Mn68O71FxiaAow/132","nickname":"超级蛋蛋饭","note":"","ucode":"AD2BECE789B365","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320545,"discussion_content":"看了你说的一下子就懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604394905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234797,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d7/6d/9db752ce.jpg","nickname":"peng","note":"","ucode":"900E11E9B4D4F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4486,"discussion_content":"同样在纠结为什么不判断a[i - 1]和b[j - 1]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565462480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108103,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e8/87/89561ed0.jpg","nickname":"Peng","note":"","ucode":"D15A78DD1AC18C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2581,"discussion_content":"同被这个地方困惑了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563777248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78759,"user_name":"G.S.K","can_delete":false,"product_type":"c1","uid":1222966,"ip_address":"","ucode":"88217F9289EB48","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/36/d054c979.jpg","comment_is_top":false,"comment_ctime":1553233039,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"203416695951","product_id":100017301,"comment_content":"动态规划问题的思路总结：第一步：如果待解决的问题为func（n），自己可以假设func（n-1）、func（n-2）……func（1）都已经解出，然后就是如何利用这些结果来推导出func（n），经过这么分析就可以得出推导方程。第二步：设计dp数组来保存func（n）（一维数组、二维数组等）。第三步：从0开始遍历，按照状态转移方程计算出func（n）保存到dp数组<br>举例，以下这些leetcode动态规划相关的题都可以直接套用这个解题思路<br><br>一维dp数组的题目<br>322. Coin Change<br>121. Best Time to Buy and Sell Stock<br>53. Maximum Subarray<br>300. Longest Increasing Subsequence<br>152. Maximum Product Subarray<br><br>二维dp数组的题目<br>152. Maximum Product Subarray<br>120. Triangle","like_count":47,"discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577916,"discussion_content":"顶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656411281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228518,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","nickname":"Edward Lee","note":"","ucode":"156223F1D7E94A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23486,"discussion_content":"做完了 leetcode 121. Best Time to Buy and Sell Stock 感觉不是 DP 类型的题目","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569825601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63611,"user_name":"再前进一点","can_delete":false,"product_type":"c1","uid":1015860,"ip_address":"","ucode":"1F4491037FEBA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/34/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1548415867,"is_pvip":false,"discussion_count":31,"race_medal":0,"score":"156167238523","product_id":100017301,"comment_content":"老师，能帮忙解释下这个公式吗，有一点费解， a[i]==b[j] 时，为什么是：<br>min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1)) 而不是<br>min(min_edist(i-1,j), min_edist(i,j-1)，min_edist(i-1,j-1))<br>为什么要 + 1 啊<br>","like_count":36,"discussions":[{"author":{"id":1227093,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ2nslShe7r4atUhX70usmgRdg56Apkc7MByBZmT293mmBgh9KVMibsV8pNQ2KWuTTNqkicfB2TJvicw/132","nickname":"SylvainHuang","note":"","ucode":"34373F93943DB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54883,"discussion_content":"在状态表中,min_edist[i-1][j] 表示此时经过min_edist[i-1][j] 次编辑,a[0:i-1]和b[0:j]是相同的,此时要从min_edist[i-1][j] 状态计算min_edist[i][j] 实际上就是要在b[0:j]后面添加一个等于a[i]的字符或者将a[i]删除掉,经过这样的一次编辑之后,新的字符串才会相等,所以不论a[i]是否等于b[j], 从该状态转移都要+1.min_edist[i][j-1]同理","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1574321719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1227093,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ2nslShe7r4atUhX70usmgRdg56Apkc7MByBZmT293mmBgh9KVMibsV8pNQ2KWuTTNqkicfB2TJvicw/132","nickname":"SylvainHuang","note":"","ucode":"34373F93943DB6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327627,"discussion_content":"赞。高手，豁然开朗。简单易懂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605876707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54883,"ip_address":""},"score":327627,"extra":""}]},{"author":{"id":1180695,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/17/d49cbc5a.jpg","nickname":"爱的天空","note":"","ucode":"154231ACD08907","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109929,"discussion_content":"感谢上面得评论，终于理解了。 如果 a[i]=a[j], 那么从 (i-1, j-1) 到(i,j)，不需要做任何操作，因此编辑距离不需要 + 1， 但是从 (i-1, j) 到 (i, j), j 这个位置得字符已经和 i-1 相等了（相当于被 i-1 这个位置占了），所以不能再和 i 这个位置得字符比较了，要使得 i 和 j 位置得字符相等，只能是删掉 i 这个字符了或者是在 j 后面再加一个和 i 一样得字符。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1577714823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690377,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaSKMpyJEgOicOgEHLJUOMk8cCFuice5ytHyoC2KXOSBk1sv7ia0lMy1hSWpNaWGmxlXwdg3umcYS9w/132","nickname":"HiAliens","note":"","ucode":"70544FC1AB28FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198112,"discussion_content":"在状态表图示表示和代码实现中，min_edist[i][j] 表示的含义为：将a[i],a[j]这两个元素处理好，需要的最少操作次数，于回溯算法中的含义略有差别！！请注意！！\n可以这么理解： 处理到a[i],b[j]这俩元素时，a[0：i-1], b[0：j-1]这俩数组一定是处理好了【需要注意的是“i”不一定等于“j”，什么意思呢，a、b两个数组的指针走的路程不一定相等。】，只有这两个数组处理好了，才会进行处理a[i],a[j]这两个元素。那么，“状态 (i, j) 可能从 (i-1, j)，(i, j-1)，(i-1, j-1) 三个状态中的任意一个转移过来。” 这句话中的三个状态翻译成代码，或者说用min_edist[i][j]表示，为min_edist这个二维数组中三个点：“min_edist(i-1,j), min_edist(i,j-1)，min_edist(i-1,j-1)”。从“min_edist(i-1,j), min_edist(i,j-1)” 到 “min_edist(i,j)”肯定执行了一步操作（无论是什么操作）“i-1”，“j-1”才能变成“i”，“j”【这里可能会有人不太明白，回到实际中的字符串，如何实现添加、删除、替换操作呢？从代码实现可以看出，没有这些操作，都是通过对索引的自增一来模拟实现的！！】，因此，不论a[i],b[j]这俩元素是否相同，minDist[i][j] = min(  minDist[i-1][j]+1, minDist[i][j-1]+1, “待定”）。\n下面是对“待定”的分析，即a[i] == b[j]时，“待定” = minDist[i-1][j-1]，即a[i] ！= b[j]时，“待定” = minDist[i-1][j-1]+1：\n若a[i] == b[j]，不需要采取任何操作，直接i，j同时增加1，变为a[i+1] ， b[j+1]，故minDist[i][j] = minDist[i+1][j+1]；\n若a[i] ！= b[j]，想要到达a[i+1] ， b[j+1]的状态，必须采取某个操作（无论什么），故minDist[i][j] = minDist[i+1][j+1]+1","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1583474024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1151921,"avatar":"https://static001.geekbang.org/account/avatar/00/11/93/b1/4de3aa61.jpg","nickname":"13714567600","note":"","ucode":"8D23FD727C8E79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1690377,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaSKMpyJEgOicOgEHLJUOMk8cCFuice5ytHyoC2KXOSBk1sv7ia0lMy1hSWpNaWGmxlXwdg3umcYS9w/132","nickname":"HiAliens","note":"","ucode":"70544FC1AB28FE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240565,"discussion_content":"按照你的分析，不应该是a[i-1] == b[j-1]时，minDist[i][j]  = minDist[i-1][j-1]吗？？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587374724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198112,"ip_address":""},"score":240565,"extra":""},{"author":{"id":1206544,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","nickname":"懒猫","note":"","ucode":"B4B567A11B491D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1151921,"avatar":"https://static001.geekbang.org/account/avatar/00/11/93/b1/4de3aa61.jpg","nickname":"13714567600","note":"","ucode":"8D23FD727C8E79","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272731,"discussion_content":"无论a[i]与b[j]是否相等，楼主说的minDist[i][j] = min( minDist[i-1][j]+1, minDist[i][j-1]+1, “待定”）应该是没有异议的，那么如果a[i] != b[j]的话，这里的待定是minDist[i-1][j-1]+1，因为不管a[i-1]与b[j-1]是否相等，现在到了比较a[i]与b[j]的时刻了，而a[i] != b[j]，必须得做出一步操作，或者说这里是必然存在差异，所以这个待定是minDist[i-1][j-1]+1也应该也没有异议。再看如果a[i] == b[j]呢，无论a[i-1]与b[j-1]是否相等，【由[i-1, j-1]走到[i, j]时不用更改a或b里的任何字符，因为a[i] == b[j]】，所以此时的待定就是 minDist[i-1][j-1]","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590335516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":240565,"ip_address":""},"score":272731,"extra":""},{"author":{"id":1647570,"avatar":"https://static001.geekbang.org/account/avatar/00/19/23/d2/6ccb3d6c.jpg","nickname":"hope","note":"","ucode":"8CABACA63DF653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1206544,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","nickname":"懒猫","note":"","ucode":"B4B567A11B491D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273602,"discussion_content":"“因为不管a[i-1]与b[j-1]是否相等，现在到了比较a[i]与b[j]的时刻了，而a[i] != b[j]，必须得做出一步操作”这一步操作是替换","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590476345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272731,"ip_address":""},"score":273602,"extra":""}]},{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20209,"discussion_content":"感觉这里的状态转移方程是怎么推导出来的，老师都没有讲清楚，直接就是说由这个关系就能得到状态转移方程，但是，怎么看，也看不出来是如何推导出来的，逻辑上不通顺","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1569290213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327584,"discussion_content":"同感","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605866929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20209,"ip_address":""},"score":327584,"extra":""}]},{"author":{"id":1237347,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/63/e1150a18.jpg","nickname":"Alex","note":"","ucode":"CDA48B3A9DE1EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1840,"discussion_content":"举个例子，比如字符串a=aBc和b=aDc，当判断到a[2]和b[2]相等时，aB和aDc的距离即min_edist(i-1,j)已知，那aBc与aDc的距离就是在a字符串这个基础上添加一个c，所以是min_edist(i-1,j)+1","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1562944143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1596027,"avatar":"","nickname":"Costar","note":"","ucode":"995C4BA715A151","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237347,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/63/e1150a18.jpg","nickname":"Alex","note":"","ucode":"CDA48B3A9DE1EA","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":3948,"discussion_content":"相等字符不一定是在最优解里面，+1相当于放弃当前相等的字符，编辑距离自然要+1咯","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565000064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1840,"ip_address":""},"score":3948,"extra":""}]},{"author":{"id":1249701,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/a5/08b45b94.jpg","nickname":"醉人","note":"","ucode":"572AF7E0E8A6E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93027,"discussion_content":"//因为minDist[i-1][j-1],minDist[i-1][j-1]+1是或者的关系，所以完整式子是这样的，王峥老师的省略了一个而已，你可以找两个字符串试下，mttcmuu和mtacnu应为3，去掉+1后变为2了\nif (a[i] == b[j]) minDist[i][j] = min(\n                        minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1],minDist[i-1][j-1]+1);\n                else minDist[i][j] = min(\n                        minDist[i-1][j]+1, minDist[i][j-1]+1, (minDist[i-1][j-1])+1,(minDist[i-1][j-1]+1)+1);","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576900011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1166723,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cd/83/452fb1aa.jpg","nickname":"youkabeng","note":"","ucode":"C6134674437052","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1249701,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/a5/08b45b94.jpg","nickname":"醉人","note":"","ucode":"572AF7E0E8A6E4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243378,"discussion_content":"从[i-1][j-1]到[i][j]其实有两种方式，一是经过替换，编辑距离+1，二是两个字符相等，编辑距离不变。只不过求最小值的时候，[i-1][j-1]显然小于[i-1][j-1] + 1, 所以我也觉得是老师省略了一种情况，补上之后就很容易理解了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587536685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":93027,"ip_address":""},"score":243378,"extra":""}]},{"author":{"id":1267791,"avatar":"https://static001.geekbang.org/account/avatar/00/13/58/4f/c6ea7d80.jpg","nickname":"GEEKBANG_1689643","note":"","ucode":"5BDDBD838971D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375246,"discussion_content":"min_edist[i][j] 表示要使word1[0:i]和word2[0:j]相等，需要修改的最少次数\n可能由三种情况转换来\n1.min_edist[i][j-1]，此时需要在word2[j-1]后面加一个word1[i]，故+1\n2.min_edist[i-1][j] ,此时需要在word1[i-1]后面加一个word2[j]，故+1\n3.min_edist[i-1][j-1]，此时word[i]若等于word[j],则不需要+1，若相等，则需要+1","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621528690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1034622,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c9/7e/94b00caa.jpg","nickname":"良","note":"","ucode":"1C619FFC612F64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1267791,"avatar":"https://static001.geekbang.org/account/avatar/00/13/58/4f/c6ea7d80.jpg","nickname":"GEEKBANG_1689643","note":"","ucode":"5BDDBD838971D8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376340,"discussion_content":"这样从最后一次理解，比较简单明了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622086875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375246,"ip_address":""},"score":376340,"extra":""}]},{"author":{"id":2042637,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2b/0d/96cacd9e.jpg","nickname":"浩天","note":"","ucode":"4CCC4D75145221","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295360,"discussion_content":"我是这么理解的\n如果从（i-1，j）转移过来，说明经过编辑（添加或删除），a串从头到i-1这个位置和b串从头到j这个位置是相等的，现在a【i】==b【j】，那么a串从头到i，和b串从头到j，不就不相等了嘛（相当于a串最后两位是重复的），那么又要编辑一次，要么删除a串最后一位，要么在b串最后一位之前再补一位。\n如果从(i-1，j-1)转移过来，a串从头到i-1和b串从头到j-1相同，如果a【i】==b【j】，则不需要编辑，两个字符串依然相同","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596174591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2042637,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2b/0d/96cacd9e.jpg","nickname":"浩天","note":"","ucode":"4CCC4D75145221","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334732,"discussion_content":"如果从(i-1, j)阶段到达(i, j)阶段，说明字符串a[i-1]被删了或者b[j]前的位置加了与a[i-1]相同的字符，这两个操作算作一次编辑，都会让我们继续往下考察a[i]和b[j]，即进入(i, j)阶段。但话说回来，虽然经过这么一次编辑能使得a串从头到i-1位置和b串从头到j这个位置相等，但这一次的编辑操作不应该是算在了(i-1, j)阶段完成的么？也就是说minEdist(i-1, j)中包含了这一次对a[i-1]和b[i]考察后的编辑操作。那么在进入到(i, j)阶段判断a[i]==b[j]时，应当直接取minEdist(i-1, j)就行了啊，为毛还要在minEdist(i-1, j)后+1？？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607953898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295360,"ip_address":""},"score":334732,"extra":""}]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195637,"discussion_content":"从递归树看，好像很多转换不满足这个递推公式？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583293453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2161988,"avatar":"https://static001.geekbang.org/account/avatar/00/20/fd/44/022f56e3.jpg","nickname":"目标🎯大数据","note":"","ucode":"6681C68E9814F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":575132,"discussion_content":"因为递归树是回溯算法，其本身就会包含许多重复子问题，这些重复子问题中i和j一致，但距离不一致，递推公式就是对这些重复子问题进行合并，从而求出最小的距离。因此要看满不满足递推公式，不应该看递归树，而应该看二维数组的那张图。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654605654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":195637,"ip_address":""},"score":575132,"extra":""}]},{"author":{"id":1661456,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epYAmnyHBCVY7YicTF3IXa39mvVTuyum9yicPyFG5amXuo6R2QOTicX0iaXLicH8CTktC7XHruv81ichgkg/132","nickname":"Geek_b25f99","note":"","ucode":"6F7BEAB2C31528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42724,"discussion_content":"i-1处的字符相等也是由那三个状态转移的，删除a中的那个字符，所以编辑次数得加一，或者删除b中的那个字符，所以编辑次数也得加一，或者i-1处本来就相等，所以编辑次数不加一","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572761458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053390,"avatar":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","nickname":"Jason","note":"","ucode":"ABB3F1A63E102A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1452,"discussion_content":"我也有同样的疑惑，已经思考了一周了，没有理解为什么a[i]==b[j] 时，min(min_edist(i-1,j)+1,min_edist(i,j-1)+1,min_edist(i-1,j-1)) 而不是min(min_edist(i-1,j), min_edist(i,j-1)，min_edist(i-1,j-1))","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1562637838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1053390,"avatar":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","nickname":"Jason","note":"","ucode":"ABB3F1A63E102A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334733,"discussion_content":"哈哈哈 我也思考一周了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607954643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1452,"ip_address":""},"score":334733,"extra":""}]},{"author":{"id":1712470,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/21/56/91669d26.jpg","nickname":"mawei","note":"","ucode":"07DACA0F8BA65D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":144978,"discussion_content":"这个地方感觉这么理解：\ni-1, j: 表示上一步操作两个字符串变化不同步，出现不相等情况\ni，j+1: 同上\ni-1，j-1: 表示上一步操作同步，字符相同\n\n则：\na[i]=a[j]\ni-1,j: 则需要编辑，例如删除一个不相同字符\ni-1,j-1: 则不需要\n\n总体感觉这一块不同模拟机器思考，不然容易转不出来\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579534855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1712470,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/21/56/91669d26.jpg","nickname":"mawei","note":"","ucode":"07DACA0F8BA65D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327588,"discussion_content":"我也是这么想的。不过文中是从(i,j)往下流转, 出现3个分支。何以推出，(i,j)也是3个状态流转过来？进入(i,j)的分支","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605867939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":144978,"ip_address":""},"score":327588,"extra":""},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1712470,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/21/56/91669d26.jpg","nickname":"mawei","note":"","ucode":"07DACA0F8BA65D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327625,"discussion_content":"我的理解：因根据前面的回溯算法增加、删除、替换操作对应的从(i,j)跳转到(i+1,j)各种状态，再根据递归树的重复子问题，判断(i,j)状态可以由（删除或增加)(i-1,j)、(删除或增加)(i,j-1)、(i-1,j-1)替换这些节点转换过来，则依次对应的编辑距离+1、+1、+0。故得到上述方程。\n        - (i-1,j)表示两个i-1和j-1不相等，如果相等肯定进入到(i,j)状态。故此时编辑距离minEd(i-1,j)上+1。执行的是删除或者插入操作\n        - (i,j-1)同上。执行的是删除或插入操作\n        - (i-1,j-1)表示上一步采取替换操作或者a[i-1]==b[j-1]。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605876373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":144978,"ip_address":""},"score":327625,"extra":""}]},{"author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128411,"discussion_content":"我觉得应该是因为字符长度的问题\n比如说a[]=mccccc,b[]=mc，a的后面元素不管有几个等于b[1]，因为b[1]在前面已经匹配过了，所以距离都是+1；\n但是如果a[]=mac,b[]=mc，从状态(1,1)，距离1，到(2,1)，距离1就是没变。但是这个时候，b[1]也就是c没有被用过，距离实际上是从(1,0)到(2,1);\n所以，即使a[i]==b[j]了，有可能这个b[j]已经和前面匹配过了，只是因为b这个字符串到结尾了所以j没有+1，之后的距离只能+1；而如果b[j]没有匹配过，则(i-1,j)这个状态相当于(i-1,j-1)的状态。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578636497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1348788,"avatar":"https://static001.geekbang.org/account/avatar/00/14/94/b4/bbca0fb9.jpg","nickname":"安景学","note":"","ucode":"0244CCB76234D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369580,"discussion_content":"我也很晕，试着理解\nmin(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1)) 而不是\nmin(min_edist(i-1,j), min_edist(i,j-1)，min_edist(i-1,j-1))\n\n因为从i-1,j 到i,j 这个操作，意味着是删除了一个字母（看开头），那就一定会加一。\n从i,j-1到i,j 类似，一定是删除而不是替换。新增等同于删除。\n从i-1,j-1到i,j，两个都变，意味着不需操作或者换字符，这个就要看i，j是否相同了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619085277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136329,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/c9/7b3cd3e0.jpg","nickname":"马振","note":"","ucode":"94234F533219C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80968,"discussion_content":"编辑距离这个问题让王老师复杂化了，源串和目的串都修改会复杂化逻辑；本质上都修改也可以也可以简化为仅仅修改源串的，这样能很大程度简化逻辑。\n假设源串和目的串分别有一个指针在尾部，均向前移动，此时源串字符仅仅有三种处理：\n删除字符：执行源字符的删除，源字符指针移动，但是两个指针指向的字符不一定相等，所以需要继续递归，编辑次数加一\n替换或插入:执行源字符的替换和插入，此时插入或替换后的字符就是目的串指针对应的字符，所以一定会实现两个指针指向的字符不一定相等，所以均移动，编辑次数加一\n\n    static char[] origin = &#34;mitcmu&#34;.toCharArray();\n    static char[] dest = &#34;mtacnu&#34;.toCharArray();\n    static int minEditNum = Integer.MAX_VALUE;\n\n    // 回溯法---解决两个字符串的编辑距离\n    // 倒序比较，o:源字符串长度-1 d:目的字符串长的-1；\n    // 调用方式：lwst(0,0,0);\n    public static void lwst(int o, int d, int editNum){\n        if(o>=origin.length-1 || d>=dest.length-1){\n            if(editNum < minEditNum){\n                minEditNum = editNum;\n            }\n            minEditNum = minEditNum+Math.abs(o-d);\n            System.out.println(minEditNum);\n            return;\n        }\n        if(origin[o] == dest[d]){\n            lwst(o+1, d+1, editNum);\n        }else{\n            // 源插入 或者 源替换,此时执行后的结果一定是origin[o] == dest[d]\n            lwst(o+1, d+1, editNum+1);\n            // 源删除，此时结果不一定满足origin[o] == dest[d]，但是源肯定要前进一位\n            lwst(o+1, d, editNum+1);\n        }\n    }\n\n    // 状态转移方程---解决两个字符串的编辑距离\n    // 倒序比较，o:源字符串长度-1 d:目的字符串长的-1\n    // 调用方式：System.out.println(lwstNew(origin.length-1, dest.length-1));\n    public static int lwstNew(int o, int d){\n        // 如果源或目的已经到边界，此时只能插入。\n        if( o < 0 || d < 0){\n            return Math.abs(o-d);\n        }\n        // 字符相等此时直接移动指针，编辑次数无变化\n        if(origin[d] == dest[o]){\n            return lwstNew(o-1, d-1);\n        }else{\n            // 执行源字符的替换或插入，编辑次数加一，此时一定实现origin[d] == dest[o]，所以均移动\n            int replaceOrInsert = lwstNew(o-1,d-1) + 1;\n            // 执行源字符的删除，编辑次数加一，但是不确保origin[d] == dest[o-1]，所以需要继续递归\n            int delete = lwstNew(o-1, d) + 1;\n            return Math.min(replaceOrInsert, delete);\n        }\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576208180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44893,"discussion_content":"我也是,还好有人解释!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572971480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1389604,"avatar":"https://static001.geekbang.org/account/avatar/00/15/34/24/34ca1d23.jpg","nickname":"阿信","note":"","ucode":"50616ED68A5B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38827,"discussion_content":"突然理解了，下面分享下我的思考过程：突然想起老师说的那句话&#34;不要想机器会怎么解决，要想如果是你你会怎么解决&#34;，因为人脑不擅长太抽象的问题，善于解决实际看得到的问题，过于思考递归过程，很容易绕进去出不来。【关键是关注状态转移的过程】\n状态(i,j)可以由(i-1,j,+1)、(i,j-1,+1)、(i-1,j-1)、(i-1,j-1,+1)四个状态转移过来，(i-1,j,+1)、(i,j-1,+1)好理解跳过，当a[i]!=b[j]时，到(i-1,j-1)后，因为还有a[i]!=b[j]，还需要再编辑一次才能到(i,j)，所以(i,j)=min((i-1,j,+1)、(i,j-1,+1)、(i-1,j-1,+1))。当a[i]==b[j]时，到(i-1,j-1)后，因为已经a[i]==b[j]，不需要再编辑，所以(i,j)=min((i-1,j,+1)、(i,j-1,+1)、(i-1,j-1))。可能表达的不清楚，见谅哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571839081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1389604,"avatar":"https://static001.geekbang.org/account/avatar/00/15/34/24/34ca1d23.jpg","nickname":"阿信","note":"","ucode":"50616ED68A5B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38494,"discussion_content":"这里逻辑看不懂+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571795798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61428,"user_name":"Jack_Cui","can_delete":false,"product_type":"c1","uid":1246643,"ip_address":"","ucode":"A2C44AB026245A","user_header":"https://static001.geekbang.org/account/avatar/00/13/05/b3/a8a835cf.jpg","comment_is_top":false,"comment_ctime":1547695365,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"143281616133","product_id":100017301,"comment_content":"老师 最长公共子串要求的是连续的 对于编辑距离应该是最长公关子序列吧","like_count":33,"discussions":[{"author":{"id":1309592,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fb/98/6f238b8e.jpg","nickname":"半个柚子","note":"","ucode":"CF5D1190D970A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182437,"discussion_content":"你说的对","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582424883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1616622,"avatar":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","nickname":"ɴɪᴋᴇʀ","note":"","ucode":"DB7D92CBB5FD15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308406,"discussion_content":"说的不对，是最长公共子序列，哈哈哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600940599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56111,"user_name":"天使之剑","can_delete":false,"product_type":"c1","uid":1306842,"ip_address":"","ucode":"69B2D109AE282F","user_header":"https://static001.geekbang.org/account/avatar/00/13/f0/da/74bbb9e6.jpg","comment_is_top":false,"comment_ctime":1546393340,"is_pvip":false,"replies":[{"id":"20187","content":"是的 你理解的没错","user_name":"作者回复","comment_id":56111,"uid":"1190123","ip_address":"","utype":1,"ctime":1546394378,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"126100444924","product_id":100017301,"comment_content":"是不是可以这么理解，如果要列出所有可能的情况的通常用回溯算法，而求最佳的情况回溯和dp都可以用，但是有重复子问题的话，可以用dp降低时间复杂度","like_count":29,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434932,"discussion_content":"是的 你理解的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546394378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57873,"user_name":"郭霖","can_delete":false,"product_type":"c1","uid":1114433,"ip_address":"","ucode":"C2ADA402806514","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/41/72237894.jpg","comment_is_top":false,"comment_ctime":1546933465,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"117511050457","product_id":100017301,"comment_content":"思考题java版解答：<br>public int longestIncreaseSubArrayDP(int[] array) {<br>    if (array.length &lt; 2) return array.length;<br>    int[] state = new int[array.length];<br>    state[0] = 1;<br>    for (int i = 1; i &lt; state.length; i++) {<br>        int max = 0;<br>        for (int j = 0; j &lt; i; j++) {<br>            if (array[j] &lt; array[i]) {<br>                if (state[j] &gt; max) max = state[j];<br>            }<br>        }<br>        state[i] = max + 1;<br>    }<br>    int result = 0;<br>    for (int i = 0; i &lt; state.length; i++) {<br>        if (state[i] &gt; result) result = state[i];<br>    }<br>    return result;<br>}","like_count":27,"discussions":[{"author":{"id":1237213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e0/dd/4828e0bd.jpg","nickname":"安东","note":"","ucode":"BCB12BA1F477DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49400,"discussion_content":"是第一行代码的作者嘛🌝","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1573575070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1082519,"avatar":"https://static001.geekbang.org/account/avatar/00/10/84/97/7996d374.jpg","nickname":"Chitty💋","note":"","ucode":"F976F31A1074F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e0/dd/4828e0bd.jpg","nickname":"安东","note":"","ucode":"BCB12BA1F477DC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300969,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598346668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49400,"ip_address":""},"score":300969,"extra":""}]},{"author":{"id":1625340,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","nickname":"骑着驴读着书的谢小夕","note":"","ucode":"56F0A469B630A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349463,"discussion_content":"递推公式：对于  0 <= j < i ，\nf(i) = max{\nf(j)+ 1, if arr[j] < arr[i],\nf(j),  else \n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613222795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105251,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/63/65ab43a3.jpg","nickname":"猩猩","note":"","ucode":"CB7493A91176D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570523,"discussion_content":"换个思路，貌似时间复杂度会低一点，为o(n * m)，m为最长递增序列长度\n\npublic static int maxIncrSeq(int[] a, int n) {\n        //下标表示最大递增序列长度-1，值表示序列长度为N的最小数字\n        int[] state = new int[n + 1];\n        state[0] = a[0];\n        int max = 0;\n        for (int i = 1; i &lt; n; i++) {\n            for (int j = max; j &gt;= 0; j--) {\n                if (a[i] &gt; state[j]) {\n                    if (j == max) {\n                        state[++max] = a[i];\n                        break;\n                    } else if (a[i] &lt; state[j + 1]) {\n                        state[j + 1] = a[i];//更新序列长度最小值\n                    }\n                }\n            }\n        }\n        //打印验证\n        for (int i = 0; i &lt; n; i++) {\n            System.out.print(state[i] + &#34; &#34;);\n        }\n        return max+1;\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651804986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276520,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/68/d6b53fbb.jpg","nickname":"rains","note":"","ucode":"540BB449B0D52F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394599,"discussion_content":"  if (array[j] < array[i])  这个判断，不表示array[i]可以放在array[j]开头的最长字串后面，应该是跟array[j]开头最长字串的最后一个数字进行比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631952516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625340,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","nickname":"骑着驴读着书的谢小夕","note":"","ucode":"56F0A469B630A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349458,"discussion_content":"最后一个循环，难道不是取 state 的最后一个值？ 似乎state 数组 本来就是递增的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613221442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2648448,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ermRFNREtjXkqiaMDcXiaRykckh2QPs7bTdSDLmIN6n960E17Lib8ibfF81H5KicArrbBiczhBKibNRgO59w/132","nickname":"Geek_f3c8e6","note":"","ucode":"AE45C47859BBE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1625340,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","nickname":"骑着驴读着书的谢小夕","note":"","ucode":"56F0A469B630A2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382861,"discussion_content":"如果按你说的，state[i]含义是[0..i]的最长递增子序列。但是作者的本意是，state[i]是最长递增子序列，且，这个子序列必须包含arr[i]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625746336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":349458,"ip_address":""},"score":382861,"extra":""}]},{"author":{"id":1696661,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKylFSbosgp8oVOZcApL2TdUlFRnbrwaMpvOMnKx3h4MicuTDKKkYAw9P68uAEk0H7KdDBGyJic8pZQ/132","nickname":"yrq110","note":"","ucode":"B84001E6A4FD6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61170,"discussion_content":"for (int i = 1; i < state.length; i++) { 这一行的循环边界应该改成array.length","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574774792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1696661,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKylFSbosgp8oVOZcApL2TdUlFRnbrwaMpvOMnKx3h4MicuTDKKkYAw9P68uAEk0H7KdDBGyJic8pZQ/132","nickname":"yrq110","note":"","ucode":"B84001E6A4FD6B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87585,"discussion_content":"不用，那样 反而不对了。。。\n这里state存储的是 以当前a[i]元素为最大值的子序列长度，没毛病的！\n\n做法是 找i之前的 ，比他小的其他元素的对应的子序列长度state的最大值，然后一步转移过来 ，也就是当前的最长的递增子序列长度。。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576674275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":61170,"ip_address":""},"score":87585,"extra":""}]}]},{"had_liked":false,"id":79164,"user_name":"G.S.K","can_delete":false,"product_type":"c1","uid":1222966,"ip_address":"","ucode":"88217F9289EB48","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/36/d054c979.jpg","comment_is_top":false,"comment_ctime":1553393523,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"100337641331","product_id":100017301,"comment_content":"第二遍学习，看留言有同学不理解状态转移表的填充过程，现总结一下状态转移表的填充详细过程和对应的字符编辑操作，望老师指正：<br>1 minDist[i][j]表示处理完a[i]和b[j]时（a[0...i]已全部转换到b[0...j]），需要的最小编辑次数<br>2 a[i]和b[j]不相等时，状态转移公式为：minDist[i][j]=min(minDist(i-1,j)+1, minDist(i,j-1)+1，minDist(i-1,j-1))<br>   1) 如果minDist[i][j]=minDist(i-1,j)+1，现分析一下这个状态转移的具体过程。minDist(i-1,j)表示a[0...i-1]已全部转换到b[0...j]，如何编辑字符才能从minDist(i-1,j)到达minDist[i][j]这个状态呢？要么将a[i]这个字符删除，要么在b[j]后边添加一个跟a[i]相同的字符（这里编辑的操作跟老师讲的回溯法的操作是不一样的）<br>   2）如果minDist[i][j]=minDist(i-1,j-1)，现分析一下这个状态转移的具体过程。如何编辑字符才能从minDist(i-1,j-1)到达minDist[i][j]这个状态呢？？将a[i]替换为b[j]或者将b[j]替换为a[i]即可<br>  3) 如果minDist[i][j]=minDist(i,j-1)+1，跟上边第一种情况类似<br>3 a[i]和b[j]相等时比较简单，不需要做字符的编辑","like_count":23,"discussions":[{"author":{"id":1019138,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","nickname":"liu_liu","note":"","ucode":"24283806A07759","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46392,"discussion_content":"a[i]和b[j]不相等时，状态转移公式为：minDist[i][j]=min(minDist(i-1,j)+1, minDist(i,j-1)+1，minDist(i-1,j-1))\n\n-----\n\n这里写错了吧。应该是minDist[i][j]=min(minDist(i-1,j)+1, minDist(i,j-1)+1，minDist(i-1,j-1) + 1)\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573144126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250205,"avatar":"https://static001.geekbang.org/account/avatar/00/13/13/9d/d91dc762.jpg","nickname":"喜欢吃鱼","note":"","ucode":"02F41572F53E3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22001,"discussion_content":"a[i]和b[i]相等时不需要做字符的编辑，能解释下这里面min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))的前两项为什么要+1么？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569559443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1267621,"avatar":"https://static001.geekbang.org/account/avatar/00/13/57/a5/4d8f6e7d.jpg","nickname":"咕小咚","note":"","ucode":"1B6AF9766AB081","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250205,"avatar":"https://static001.geekbang.org/account/avatar/00/13/13/9d/d91dc762.jpg","nickname":"喜欢吃鱼","note":"","ucode":"02F41572F53E3C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136732,"discussion_content":"(i-1,j)和(i,j-1)这两种状态其实是不需要区分a[i]和b[j]是否相等的，因为由这两种状态到达(i,j)必定是由删除或新增操作导致的,必做了一次编辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579159958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":22001,"ip_address":""},"score":136732,"extra":""}]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327708,"discussion_content":"mark。这个理解解释，和文字表达都到位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605923135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1267621,"avatar":"https://static001.geekbang.org/account/avatar/00/13/57/a5/4d8f6e7d.jpg","nickname":"咕小咚","note":"","ucode":"1B6AF9766AB081","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136727,"discussion_content":"感谢，懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579159694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019138,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","nickname":"liu_liu","note":"","ucode":"24283806A07759","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46388,"discussion_content":"跟上面的1)，3)情况是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573143346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56673,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1546520519,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"83150899143","product_id":100017301,"comment_content":"思考题的解法还是很精妙的<br>递推公式:<br>a[0...i] 的最长子序列为: a[i] 之前所有比它小的元素中子序列长度最大的 + 1<br><br>代码实现: <br>```<br>#include&lt;iostream&gt;<br><br>using namespace std;<br><br>&#47;&#47; 动态规划求 a 的最上升长子序列长度<br>#include&lt;iostream&gt;<br><br>using namespace std;<br><br>&#47;&#47; 动态规划求 a 的最上升长子序列长度<br>int longestSubsequence(int *a, int n) {<br>\t&#47;&#47; 创建一个数组, 索引 i 对应考察元素的下标, 存储 arr[0...i] 的最长上升子序列大小<br>\tint *lss_lengths = new int[n];<br>\t&#47;&#47; 第一个元素哨兵处理<br>\tlss_lengths[0] = 1;<br>\t&#47;&#47; 动态规划求解最长子序列<br>\tint i, j, max;<br>\tfor (i = 1; i &lt; n; i++) {<br>\t\t&#47;&#47; 计算 arr[0...i] 的最长上升子序列<br>\t\t&#47;&#47; 递推公式: lss_lengths[i] = max(condition: j &lt; i &amp;&amp; a[j] &lt; a[i] value: lss_lengths[j] + 1)<br>\t\tmax = 1;<br>\t\tfor (j = 0; j &lt; i; j++) {<br>\t\t\tif (a[i] &gt; a[j] &amp;&amp; lss_lengths[j] &gt;= max) {<br>\t\t\t\tmax = lss_lengths[j] + 1;<br>\t\t\t}<br>\t\t}<br>\t\tlss_lengths[i] = max;<br>\t}<br>\tint lss_length = lss_lengths[n - 1];<br>\tdelete[]lss_lengths;<br>\treturn lss_length;<br>}<br><br>void main() {<br>\tconst int n = 7;<br>\tint arr[n] = { 2, 9, 3, 6, 5, 1, 7 };;<br>\tcout &lt;&lt; longestSubsequence(arr, n) &lt;&lt; endl;<br>\tgetchar();<br>}","like_count":19,"discussions":[{"author":{"id":1249088,"avatar":"","nickname":"FW_Infra_Core_4","note":"","ucode":"E7199321CCB3AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6991,"discussion_content":"最后应该遍历lss_lengths，输出最大值","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1567242553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461687,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLoxyegHarElcAbXdl9FaOMXcOibOOEgWgFMiakL2q7guxcqMqkUQBib1zldFS56hr61Y8zhlO3Rs8Hg/132","nickname":"Geek__f5e47e0e2519","note":"","ucode":"FE1EBAF59233CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389218,"discussion_content":"for (j = 0; j < i; j++) { 这块倒着来是不是更合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629182435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337636,"discussion_content":"不用遍历，本来第n个元素里面存放的就是[0..n]整个序列当中的升序序列的最长长度，函数结尾已经直接返回了对应的值\nint lss_length = lss_lengths[n - 1];\ndelete[]lss_lengths;\nreturn lss_length;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608995663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1252586,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/ea/70e1ef53.jpg","nickname":"不将就。","note":"","ucode":"FCD26AE0DB1D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":383980,"discussion_content":"需要遍历的，例如{2,3,4,1}，不遍历的话输出的是1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626327989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337636,"ip_address":""},"score":383980,"extra":""}]}]},{"had_liked":false,"id":240753,"user_name":"Henry Liao","can_delete":false,"product_type":"c1","uid":1635174,"ip_address":"","ucode":"EA8407D15E2CC6","user_header":"https://static001.geekbang.org/account/avatar/00/18/f3/66/5d7ba082.jpg","comment_is_top":false,"comment_ctime":1597053047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48841693303","product_id":100017301,"comment_content":"8个经典动态规划问题：<br>购物车凑单满减<br>升级版“杨辉三角”，求从最高层移动到最底层的最短路径长度<br>背包问题<br>矩阵中移动的最短路径长度<br>解决硬币找零问题<br>编辑距离问题：莱文斯距离<br>编辑距离问题：最长公共子串长度<br>求一个序列中最长递增子序列长度","like_count":11},{"had_liked":false,"id":135950,"user_name":"saber","can_delete":false,"product_type":"c1","uid":1193468,"ip_address":"","ucode":"D02F8D129DB41C","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","comment_is_top":false,"comment_ctime":1569313063,"is_pvip":false,"replies":[{"id":"52306","content":"你这个问题太多了 我写篇文章给你 你关注：小争哥","user_name":"作者回复","comment_id":135950,"uid":"1190123","ip_address":"","utype":1,"ctime":1569448365,"user_name_real":"王争"}],"discussion_count":15,"race_medal":0,"score":"44518986023","product_id":100017301,"comment_content":"老师我有个疑问（急），希望老师能够帮忙回答下，这也是大部分留言中没能解决的疑问。<br>在莱文斯坦距离讲解时，那里的状态方程是怎么直接写出来的？这一点是我最不能理解的，当然在问该问题之前，我已经尽我所能的尝试理解老师的文章，并且把留言也都翻了一遍。老师请看我下面的陈述：<br><br>一：按照老师文章的讲解顺序，先分析了如何用回溯方法，然后绘制了递归树，从递归树中又分析出了具有重复的子结构，接着又画出了状态简图（递归树下面的图，不知道怎么表达），从这幅简图中清晰的看出来状态的转移方式，接下来重点来了！！！文章接着就写出来状态转移方程（不理解的地方）！我在留言中发现，老师对这点的解释是说「状态转移方程与递归树无关，递归树仅仅表达了问题具有重复子结构」，如果按照老师的说法，不根据递归树分析出状态转移过程，那该怎么直接写出状态转移方程（要能够合理的推断出来，而不是靠经验，否则还是无法掌握动态规划）？目前来看，我在文章中没有发现具有这样的逻辑推断。我之前的理解是说，我们其实可以在递归树中分析出状态转移方程如何写，然后这样就形成了一个闭环，由回溯-&gt;递归树-&gt;状态转移方程。希望在这里老师能够给出一个合理的解释？<br><br>二：抛开上面的一些问题，咱们单独看莱问斯坦距离状态转移公式，先假设，按照递归树和递归树下面的图可以知道状态转移的过程（这是一个前提假设）。在留言中的第 4 条「blacknhole」这位同学的留言中，我也有相同的疑问，(i , j, min_edist) 到底表达的是什么状态？（处理完 a[i] b[j] 后的最小距离？ or 刚要处理 a[i] b[j]  时对应的最小距离？），<br><br>接下来按照二种不同的表达来看看状态方程如何推断出来：<br><br>1、 如果表达的含义是 「处理完 a[i] b[j] 后的最小距离」<br><br>那么其实从回溯算法中可以知道（因为 i j 的前一个状态已经处理完了，比如 min_edist(i-1,j) 就代表了前一个状态。）<br><br>if (a[i] != b[j]) <br><br>​\tmin_edist(i, j) =1+ min( min_edist(i-1, j),  min_edist(i, j-1), min_edist(i-1,j-1))<br><br>if (a[i] == b[j] )<br><br>​\tmin_edist(i, j) = min( min_edist(i-1, j),  min_edist(i, j-1), min_edist(i-1,j-1))<br><br>2、如果表达的含义是「刚要处理 a[i] b[j]  时对应的最小距离」<br><br>那么我们可以这么想，当前 i,j min_edist 表示还没有处理过 i,j 时对应的状态，因此我们需要考虑之前的状态是怎么传递到这里来的<br><br>min_edist(i, j) = <br><br>min(min_edist(i-1,j)+1, min_edist(i, j-1)+1, min_edist(i-1, j-1) + (a[i-1] == b[j-1]? 0 : 1))<br><br><br><br>从上面的两种推断发现，我觉的都是比较合理的，但是没有一种的结果与老师给的状态转移方程是一致的（这一点比较疑惑）？所以对于老师的状态转移方程肯定不是从递归树中直接推导出来的，那么请问老师这个状态转移方程该怎么合理的推断出来（我觉得这个问题不是靠多做题解决的，必须要知道推理逻辑才能彻底掌握动态规划）？<br><br><br><br>三：接下来还有一个问题（前提假设是老师的状态方程是正确的，具体逻辑还不能理解）<br><br>那么如果根据状态状态方程，来填充状态表的第 0 行 第 0列呢（留言中也有许多这方面的疑问）？按照我的理解，既然状态转移方程我们知道了，那么其实从状态转移方程中就可以直接填充表格了，比如填充第 0 行时，因为从状态转移方程中我们发现有 i - 1,j-1 因此当计算第 0 行时，带有 i-1 项的就可以省略了，因此状态转移方程就剩下 (i, j-1) 项了。然后其实就不用分 a[i] b[j] 是否相等了，但是回头看老师的代码，却不明白为什么还要分 a[i] b[j] 相等不相等。希望老师能够解释一下！<br><br><br><br>综上：如果老师觉得我描述的问题不清楚，那么希望老师看看这篇文章的其他问题留言，总结一下大家到底哪里不理解，并且对不理解的地方从新更新下当前文章，具体解释一下，比如老师在留言中说过「不能从递归树中直接推导出状态转移方程，两者没有联系」，那么希望老师在文章的对应地方直接表明这句话，并且在加上额外的说明，比如如何推断出状态转移方程，这样整篇文章才能让更多的人从本质上理解动态规划！<br><br><br><br>最后希望老师能够认真给出我上面几个问题的解答，谢谢老师！","like_count":11,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468398,"discussion_content":"你这个问题太多了 我写篇文章给你 你关注：小争哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569448365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1950487,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/c3/17/dc7b3246.jpg","nickname":"哎呦喂","note":"","ucode":"06C7FBEF976741","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284822,"discussion_content":"各位兄弟，我看了leetcode题解，恍然大悟，确实，递推公式不能根据递归树来推断，不论i -1还是j-1等等，都是子问题，子问题都已经求解了的！按照递归树的话，都没有对子问题求解，也就不是正确的递推公式了，链接在这https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/   ","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1592651528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334290,"discussion_content":"对于层主的问题我发表一些自己的实际看法，第一个问题：状态转移方程我自己尝试下来觉得与递归树关系不是太大，文中画递归树仅仅是让刚学习动态规划的人知道会有重复子问题的情况。然而实际实际写状态转移方程我觉得还是先写出回溯算法的实现最好，像文中先用回溯算法写了出来，然后我们在回溯算法中代码逻辑中可以很清晰的得到到(i,j)这一阶段可以从(i,-1,j)(i,j-1)(i-1,j-1)这三个阶段过来。既然能从几个阶段过来，那么肯定有个最优阶段，所以取最优的。所以凭这个思考方法能大概的写出状态转移方程，和递归树半毛钱关系都没。第二个问题：可以看前几楼的评论，综合下来看作者对minEdist(i,j)的意思是要把这一阶段的处理结果也要加上，而(i,j,minEdist)表示处理到这阶段时最优的结果且还不包含这一阶段的处理结果。所以状态转移方程a[i]==b[j]的时我认为是min_edist(i, j) = min( min_edist(i-1, j), min_edist(i, j-1), min_edist(i-1,j-1))，显然作者应该是写错了吧？（不过作者估计已经没时间再来看大家的问题了）。第三个问题：状态表我感觉好鸡肋，我觉得状态表有用的地方仅仅是能够解释了为什么需要初始化[i][0]和[0][j]，当然这里是出于教学目的还是有些必要介绍的。理解后实际写代码解题过程时基本不需要画表格了吧。。。。。。。。最后，我觉得可以在leetcode上看看相关的题解，因为那边也有介绍编辑距离题目的题解，在某些方面从其他角度讲的也是不错的，虽然两边教学都并不完美，但是两边都看看之后，把两边理解到的知识点相互互补一下，就能对这道题有了整体的认识了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607785580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272007,"discussion_content":"上一讲讲过：最优子结构 —> 状态转移方程。\n\n第0行第0列，你把它理解为要删除或者要添加多少个字符才能与首个字符相等。所以要区分a[i]是否等于b[0]。\n\n我也不知道我的理解对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590238014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228476,"discussion_content":"1.转移公式：\nif (a[i] != b[j])\n​ min_edist(i, j) =1+ min( min_edist(i-1, j), min_edist(i, j-1), min_edist(i-1,j-1))\n\nif (a[i] == b[j] )\n​ min_edist(i, j) = min( min_edist(i-1, j), min_edist(i, j-1), min_edist(i-1,j-1))\n\n使用这个转移公式是错误的，这种递推公式在出现重复字符的时候会出错，例如，比较 &#34;zzz&#34; 和 &#34;zzzz&#34;,它构建的状态表如下：\n   z  z  z  z\nz  0  1  2  3\nz  1  0  0  0\nz  2  0  0  0\n很显然，这个状态表是错误的\n\n2.转移公式：\nmin_edist(i, j) =\nmin(min_edist(i-1,j)+1, min_edist(i, j-1)+1, min_edist(i-1, j-1) + (a[i-1] == b[j-1]? 0 : 1))\n\n很明显，争哥给出的例子的状态表不是这个意思，因为它在初始化第一行和第一列的时候就和这个转移公式不符。\n你依然可以使用 &#34;zzz&#34; 和 &#34;zzzz&#34; 做一下比较，你会发现它是错的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586534969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":272001,"discussion_content":"if (a[i] == b[j] )\nmin_edist(i, j) = min( min_edist(i-1, j), min_edist(i, j-1), min_edist(i-1,j-1))\n\n这个是错的，i-1这个位置和j-1这个位置已经被使用过了，所以单独从i-1或j-1移动过来要对距离加1。\n当两个都移动一位之后，在a[i] == b[j] 的情况下，距离是不变的；要怎么表达那个意思呢，你自己脑补一下。\n所以min_edist(i, j) = min( min_edist(i-1, j)+1, min_edist(i, j-1)+1, min_edist(i-1,j-1))\n不知道我的这个理解有没有什么问题\n\n还有，我发现当a[i] == b[j] 的时候，min_edist(i, j) = min_edist(i-1,j-1)，这个可以从前面回溯算法那里看到，但不知道为什么老师给出来的三个求最小（三个求最小满足状态方程）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590237257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":228476,"ip_address":""},"score":272001,"extra":""},{"author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272239,"discussion_content":"我的这个评论是错误的，在评论完之后我又想了一下，发现我的公式是错误的。\n老师给出的公式是完全正确的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590260583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272001,"ip_address":""},"score":272239,"extra":""}]},{"author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228040,"discussion_content":"哥们儿，我的想法和你一模一样，你现在想明白了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586523448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":254447,"discussion_content":"在那以后我再也没有研究这个 一直在等着小争哥😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588327537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":228040,"ip_address":""},"score":254447,"extra":""},{"author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254727,"discussion_content":"哈哈哈，总之就是那个公式没错，但是理解起来要费很多脑细胞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588341870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":254447,"ip_address":""},"score":254727,"extra":""},{"author":{"id":1950487,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/c3/17/dc7b3246.jpg","nickname":"哎呦喂","note":"","ucode":"06C7FBEF976741","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284806,"discussion_content":"现在我的想法也一样，但是在假设是已决策得状态，a[i] == b[i]时, 使用min(min_edist[i-1][j], min_edist[i][j-1],min_edist[i-1][j-1])这个公式确实解不出，leetcode上试过了，不行。不知道为什么，很费解。然后，a[i] == b[i]时, 使用mid_edist[i][j] = min_edist[i-1][j-1], 也是正确，leetcode亲测 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592645693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":254447,"ip_address":""},"score":284806,"extra":""}]},{"author":{"id":1687754,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/ca/180c1345.jpg","nickname":"skeletao","note":"","ucode":"F970D9F7E9DC0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165767,"discussion_content":"答案如何？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581324407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1687754,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/ca/180c1345.jpg","nickname":"skeletao","note":"","ucode":"F970D9F7E9DC0E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166797,"discussion_content":"小争哥可能忘了这事","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581428536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165767,"ip_address":""},"score":166797,"extra":""}]},{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20551,"discussion_content":"还有文中关于莱问斯坦距离和公共子序列的代码问题，在初始化 0 行和 0 列时，为什么不是根据状态转移方程来初始化？ 如果不是根据状态转移方程来初始化的，那么为什么要像文中的代码那样来初始化？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569328426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1181473,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/21/b3394aa2.jpg","nickname":"Robot","note":"","ucode":"7215462D5AC0FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271463,"discussion_content":"参考这个吧，跟你的想法是一致的，还是的弄清楚edist[i][j]的真正含义。https://zh.wikipedia.org/zh-cn/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590141717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20551,"ip_address":""},"score":271463,"extra":""}]}]},{"had_liked":false,"id":57048,"user_name":"Ricky","can_delete":false,"product_type":"c1","uid":1238256,"ip_address":"","ucode":"0B29C730CAD29C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/f0/82281239.jpg","comment_is_top":false,"comment_ctime":1546607415,"is_pvip":false,"replies":[{"id":"21843","content":"我的讲解并不是为了指导做题。所以，我讲解的时候，从为什么要动态规划讲起，所以废话比较多。实际上，你理解理论之后，解动态规划题目的时候，一般可以直接写最优子结构，也就是状态转移方程，不需要再从回溯解法开始。。。<br>","user_name":"作者回复","comment_id":57048,"uid":"1190123","ip_address":"","utype":1,"ctime":1547708363,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"44496280375","product_id":100017301,"comment_content":"老师，您好，您这节内容讲的很清晰透彻，我以前做动态规划问题是直接寻找状态转移方程，基本只能处理一些简单的动态规划问题，没有形成系统的解题思路，听了您这一节后，我觉得将回溯简单思路逐步转化为动规思路让我受益匪浅，但是当我试着将这套思路应用于求解最长递增子序列时却感觉回溯更麻烦，不知能否指点一二","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435378,"discussion_content":"我的讲解并不是为了指导做题。所以，我讲解的时候，从为什么要动态规划讲起，所以废话比较多。实际上，你理解理论之后，解动态规划题目的时候，一般可以直接写最优子结构，也就是状态转移方程，不需要再从回溯解法开始。。。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64895,"user_name":"王者归来","can_delete":false,"product_type":"c1","uid":1349051,"ip_address":"","ucode":"7518431E647410","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Dyic3CxSFwI4wsNTia2UzqaQL2pENLp8rRkNgBaCzr82BSMibegfnfYQbTCYOMXicZymXAqIk8zf1neUFeicmyxnFXw/132","comment_is_top":false,"comment_ctime":1548943430,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"40203649094","product_id":100017301,"comment_content":"老师，第一行初始化值，如何理解？<br>if (a[0] == b[j]) minDist[0][j] = j;<br>else if (j != 0) minDist[0][j] = minDist[0][j-1]+1;<br>else minDist[0][j] = 1;","like_count":9,"discussions":[{"author":{"id":1348568,"avatar":"https://static001.geekbang.org/account/avatar/00/14/93/d8/8bab3fb5.jpg","nickname":"Yocn","note":"","ucode":"35BDF12EA130C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32856,"discussion_content":"开始也不理解，这是看了下面的一条评论。\n对第一行初始化，相当于求解a[0]和b在所有位置的最小编辑距离，那么对于b第一个位置，如果和a[0]相同则为0，不同则为1。对于第j个位置的元素，如果和a[0]相同，直接等于j就行，为什么呢？因为直接把前面j-1个位置的元素删除就行，对应的编辑距离就是j（因为下标是从0开始的）；如果和a[0]不同，那么就等于前一个位置的编辑距离+1。同理，第一列是类似的。\n翻译成代码如下，简化后等价于文章里面的初始化代码：\n\n        for (int j = 0; j < y; j++) {\n            if (j == 0) {\n                if (a[0] == b[j]) {//a[0] == b[0]\n                    minDist[0][j] = 0;\n                } else {\n                    minDist[0][j] = 1;\n                }\n            } else {\n                if (a[0] == b[j]) {\n                    minDist[0][j] = j;\n                } else {\n                    minDist[0][j] = minDist[0][j - 1] + 1;\n                }\n            }\n        }\n\n-----------------------------------\n                        ↓等价于↓\n-----------------------------------\n\n        for (int j = 0; j < y; j++) {\n            if (a[0] == b[j]) {\n                minDist[0][j] = j;\n            } else if (j != 0) {\n                minDist[0][j] = minDist[0][j - 1] + 1;\n            } else {\n                minDist[0][j] = 1;\n            }\n        }\n\n","likes_number":22,"is_delete":false,"is_hidden":false,"ctime":1571064010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1100439,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ca/97/5042c207.jpg","nickname":"king","note":"","ucode":"FFC090D0EF1F80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1348568,"avatar":"https://static001.geekbang.org/account/avatar/00/14/93/d8/8bab3fb5.jpg","nickname":"Yocn","note":"","ucode":"35BDF12EA130C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349538,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613296823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":32856,"ip_address":""},"score":349538,"extra":""}]},{"author":{"id":1647570,"avatar":"https://static001.geekbang.org/account/avatar/00/19/23/d2/6ccb3d6c.jpg","nickname":"hope","note":"","ucode":"8CABACA63DF653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273616,"discussion_content":"第一个if语句的状况是：a[0]=a,b[0-j]=都是a，a和a做判断，a和aa做判断，然后这样判断下去；\n第二个if语句：a[0] != b[j] 且j!=0,如果此时比较的两个不相等，那么肯定需要编辑操作，也就是删除，增加或者替换中的一个操作，不管哪个操作都需要+1；j != 0实际上是为了防止j -1越界，for循环从j = 0开始的\n最后的语句：其实就是a[0]  != b[0]，所以肯定是1","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590477311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1800886,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/7a/b6/f54bbfaa.jpg","nickname":"花郎世纪","note":"","ucode":"301DF9B6375E08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177599,"discussion_content":"初始化的时候，b中所有元素是针对a[0]的，按照莱文斯坦距离定义，如果遍历b时在第i个位置找不到，那么距离便是i-1时距离+1。转化成代码就是老师的样子了，这里的else是对应在位置0处，a[0]和b[0]不相等情况的距离，值为1。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582116076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62596,"user_name":"沉睡的木木夕","can_delete":false,"product_type":"c1","uid":1036362,"ip_address":"","ucode":"2C6B23B34C44E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/4a/7e3d158d.jpg","comment_is_top":false,"comment_ctime":1548118744,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"35907857112","product_id":100017301,"comment_content":"那个状态转移表是怎么填充的？我来回看了几遍还是不知道里面的值怎么来的，感觉跟前面分析的扯不上任何关系","like_count":8,"discussions":[{"author":{"id":1005661,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","nickname":"爱新觉罗老流氓","note":"","ucode":"B13AC4DA358C15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229543,"discussion_content":"找四个小方格组成一个正方形填表。即 (i,j) 这个格子根据 a[i] 和 b[j] 是否相等，然后和 (i-1,j), (i,j-1),(i-1,j-1) 三个填好的格子的距离里最小的距离值运算，这个运算就是 +1或不加，a[i] 和 b[j] 相等就不加；a[i] 和 b[j] 不相等就去那三个格子最小值+1.\n\n不过我觉得初始化的 第4行 第0列 的值初始化错了。第0行初始化为 0,1,2,3,4,5 （横着看）没问题。但是第0列我觉得是初始化为 0,1,2,3,3,4（竖着看），而专栏给的图是 0,1,2,3,4,5 （竖着看）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586663555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e0/dd/4828e0bd.jpg","nickname":"安东","note":"","ucode":"BCB12BA1F477DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49399,"discussion_content":"根据上面的规律，比较对应下标的数字，然后选择最小的填就可以了呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573574957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119671,"user_name":"柳志焕","can_delete":false,"product_type":"c1","uid":1235940,"ip_address":"","ucode":"42375930DC2AA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/e4/a1b45d79.jpg","comment_is_top":false,"comment_ctime":1564649638,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31629420710","product_id":100017301,"comment_content":"思考题就是 leetcode 300 题：https:&#47;&#47;leetcode-cn.com&#47;problems&#47;longest-increasing-subsequence&#47;submissions&#47;<br><br>public int minSubsequence(int[] array) {<br>        if(array.length &lt;2) return array.length;<br>        int[] dp = new int[array.length];<br>        &#47;&#47; dp[i] 是以 array[i] 结尾的最长子序列<br>        Arrays.fill(dp,1);<br>        for(int i = 0; i&lt; array.length; i++) {<br>            for(int j = 0; j&lt; i; j++) {<br>                if(array[i] &gt; array[j]) {<br>                    dp[i] = Math.max(dp[i],dp[j] +1);<br>                }<br>            }<br>        }<br>        int res = 0;<br>        for(int i = 0; i&lt; dp.length; i++) {<br>            res = Math.max(res,dp[i]);<br>        }<br>        return res;<br>    }","like_count":7,"discussions":[{"author":{"id":1005661,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","nickname":"爱新觉罗老流氓","note":"","ucode":"B13AC4DA358C15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258639,"discussion_content":" if(array[i] > array[j])  这个判断确定能判断出递增吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588697337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2704810,"avatar":"","nickname":"rookielink","note":"","ucode":"23B6E9F2D1D34D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1005661,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","nickname":"爱新觉罗老流氓","note":"","ucode":"B13AC4DA358C15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541496,"discussion_content":"……递增不是单靠这句判断的，这是一个状态累积的过程，j位置存储的是他的最大的升序长度，如果i位置比该位置大，则用i此时为值和j存储值+1比较，取更大的那一个","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640411374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":258639,"ip_address":""},"score":541496,"extra":""}]}]},{"had_liked":false,"id":56561,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1546490363,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31611261435","product_id":100017301,"comment_content":"思考题解答：<br>状态转移公式：maxLen[i] = max(maxLen[j]+(1 if j&lt;i else 0)) for any j &lt; i<br>python代码：<br>def maxOrderedSeq(seq):<br>    maxLen = [1] * len(seq) # 初始化为1<br>    <br>    for i in range(1, len(seq)): # i从1开始<br>        for j in range(i-1,-1,-1): # j从i-1到0<br>            if seq[j] &lt;= seq[i]:<br>                maxLen[i] = maxLen[j] + 1<br>                break # 满足则退出<br>        if maxLen[i] == 1: # 比前面所有元素小<br>            maxLen[i] = maxLen[i-1]<br>            <br>    print(maxLen)<br>            <br># usage<br>seq = [2, 9, 3, 6, 5, 1, 7]<br>maxOrderedSeq(seq)","like_count":7,"discussions":[{"author":{"id":1227093,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ2nslShe7r4atUhX70usmgRdg56Apkc7MByBZmT293mmBgh9KVMibsV8pNQ2KWuTTNqkicfB2TJvicw/132","nickname":"SylvainHuang","note":"","ucode":"34373F93943DB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54947,"discussion_content":"代码存在问题:\n        if maxLen[i] == 1: # 比前面所有元素小\n            maxLen[i] = maxLen[i-1] \n当前值比前面所有值都小的时候,maxLen[i] = maxLen[i-1] 没有问题,但是会重置增序梳理额的最大值为此值,如示例中的1,后面如果是2-5的话,其实是不应该添加的,但是由于重置了,他们比1大,所以都会添加进去,从而使最大长度增加","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574328089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1348185,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/jTy0rkRfPkgKYbGWjPVALx478Emy9ue5OdDGicnFrOD1LJ7oLLs8pRQzO5oNBGZwL6WRyKGjbnl9AVARRACVWJQ/132","nickname":"Geek_99da8a","note":"","ucode":"2B59DAC0D254E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376792,"discussion_content":"这个代码，对于这个序列seq = [7,8,9,1,2,3,4,5,6]，得出来的结果不对吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622347486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56324,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1546421824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31611192896","product_id":100017301,"comment_content":"选这个专栏的初衷就是为了学习动态规划，作者对这部分内容的讲解我还是比较满意的。两个月前，闲来无事刷了几天LeetCode，遇到一道字符串模式匹配的题，不是结果错误就是复杂度不达标，怎么也搞不定。看了论坛里给出的高赞解答，清一色采用了动态规划的解题方法，当时没有算法基础，真的是看不懂啊，遂放弃。现在经过几节课的学习理出一些思路来，收获颇丰，理论看得比较明白了，程序照着文中的例子也能写个大概，但感觉掌握得还是不牢靠，还需要多加练习。谢谢作者！","like_count":7},{"had_liked":false,"id":79175,"user_name":"G.S.K","can_delete":false,"product_type":"c1","uid":1222966,"ip_address":"","ucode":"88217F9289EB48","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/36/d054c979.jpg","comment_is_top":false,"comment_ctime":1553395494,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"27323199270","product_id":100017301,"comment_content":"莱温斯坦距离状态表，初始化第0行和第0列代码逻辑有点复杂，可以简化一下，修改状态表为如下形式<br>\t∅\tm\tt\ta\tc\tn\tu<br>∅\t0\t1\t2\t3\t4\t5\t6<br>m\t1\t0\t1\t2\t3\t4\t5<br>i\t2\t1\t\t\t\t\t<br>t\t3\t2\t\t\t\t\t<br>c\t4\t3\t\t\t\t\t<br>m\t5\t4\t\t\t\t\t<br>u\t6\t5\t\t\t\t\t<br>代码就可以简化了<br>int[][] minDist = new int[n+1][m+1]<br>  for (int j = 0; j &lt;= m; ++j) { 初始化第0行<br>    minDist[0][j] = j;<br>  }<br>  for (int i = 0; i &lt;= n; ++i) { 初始化第0列<br>    minDist[i][0] = i;<br>  }<br>最终return minDist[n][m];","like_count":6,"discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42601,"discussion_content":"你这么写只是针对例子的输入，你换其他的字符串试试？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572706662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36860,"discussion_content":"你这个没判断，就是当a[0]==b[0]和a[0]!=b[0]的时候初始化逻辑有些问题，要区分下这种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571452120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206544,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","nickname":"懒猫","note":"","ucode":"B4B567A11B491D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232,"discussion_content":"如果按照这样理解，假如将b换成abcdef，完全不同的一个字符串，老师的第0行的填充结果是[1,2,3,4,5,6]，而你的是还是[0,1,2,3,4,5]，0行0列的代码我没理解，但貌似觉得你的也欠妥。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561344895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71477,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1551350967,"is_pvip":false,"replies":[{"id":"25741","content":"(i-1,j)这个状态转移到(i, j)这个状态，minDist要加一<br>(i, j)同上<br>(i-1, j-1)这个状态转移到(i, j)这个状态，minDist保持不变，因为a[i]==b[j]","user_name":"作者回复","comment_id":71477,"uid":"1190123","ip_address":"","utype":1,"ctime":1551405632,"user_name_real":"gg"}],"discussion_count":8,"race_medal":0,"score":"23026187447","product_id":100017301,"comment_content":"if (a[i] == b[j]) minDist[i][j] = min(<br>minDist[i-1][j]+1,minDist[i][j-1]+1,minDist[i-1][j-1])不明白的是为什么minDist[i-1][j]或者mindist[i][j-1] 要+1呢？<br>","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441174,"discussion_content":"(i-1,j)这个状态转移到(i, j)这个状态，minDist要加一\n(i, j)同上\n(i-1, j-1)这个状态转移到(i, j)这个状态，minDist保持不变，因为a[i]==b[j]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551405632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053390,"avatar":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","nickname":"Jason","note":"","ucode":"ABB3F1A63E102A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1481,"discussion_content":"老师好，对于您的解释有几点疑问:\n1，我理解的minDist[i][j]应该指的是已经处理完了a[i]、b[j]后的最小编辑距离\n2，minDist[i-1][j]，minDist[i][j-1]，minDist[i-1][j-1]也应该是处理完了a[i-1]、b[j]，a[i]、b[j-1]，a[i-1]、b[j-1]后的最小编辑距离\n3，minDist[i][j]的值可能由minDist[i-1][j], minDist[i][j-1], minDist[i-1][j-1]三个值中的任意一个转移过来。\n4，如果a[i]=b[j]，不会增加编辑距离，所以，minDist[i][j] = min( minDist[i-1][j], minDist[i][j-1], minDist[i-1][j-1] )才对。\n\n我知道您的公式肯定是对的，但是我反复思考，实在没懂我的理解到底错在哪里，麻烦老师指点。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1562654192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1108788,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/34/cd310e69.jpg","nickname":"行走的","note":"","ucode":"04772A8A1FF2B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1053390,"avatar":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","nickname":"Jason","note":"","ucode":"ABB3F1A63E102A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37965,"discussion_content":"同样的疑问，老师没有讲清楚，就直接说状态+1，怎么就状态+1了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571707107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1481,"ip_address":""},"score":37965,"extra":""},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1053390,"avatar":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","nickname":"Jason","note":"","ucode":"ABB3F1A63E102A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44899,"discussion_content":"老师开新课程了.不会理人了..","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572972002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1481,"ip_address":""},"score":44899,"extra":""}]},{"author":{"id":1108788,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/34/cd310e69.jpg","nickname":"行走的","note":"","ucode":"04772A8A1FF2B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38061,"discussion_content":"有一点点理解了，对于a（i）!=b(j)时，无论前三种状态如何，到目前状态都需要编辑一次，所以都+1，对于a(i)=b(j)时，minDist[i-1][j]和minDist[i][j-1]都要经过编辑一次才到达目前状态的，所以这两者+1。而minDist[i-1][j-1]可能需要编辑一次+1，也可能不需要编辑+0，到达的目前状态，就取二者最小的+0不需要编辑的情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571719282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334954,"discussion_content":"哎，看了好久都没有一个解释的合理的。。总之有一点，(i-1,j)和(i, j-1)这两个阶段要达到(i,j)阶段，必定是要做一次编辑的。。现在的问题的重点是：这一次编辑该算在前一阶段还是后一阶段上？换句话说就是minEdist(i,j)究竟是表达的什么意思？是(i,j)阶段已经包含了这一阶段的编辑，还是不包含？？？如果minEdist(i, j)表示包含了(i,j)这阶段的编辑，那么minEdist(i-1,j)和minEdist(i, j-1)同样是包含了前一阶段的编辑（也就是说那两个+1的操作已经包含在里面了，不需要再在这两个值后面+1了），那么这两个值应当是接入(i,j)阶段时的初始状态，在(i,j)阶段判断a[i]==b[j]的时候，还要minEdist(i-1, j)+1和minEdist(i,j-1)+1干啥？没必要+1了啊。。所以minEdist(i,j)的表达的意思是什么？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608035460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010957,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6d/0d/e3fa096f.jpg","nickname":"拓","note":"","ucode":"AC1940ECC25436","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136077,"discussion_content":"我是这样理解的，不知道对不对：if a[i] == b[j] ; min_edist(i,j-1) +1 --->min_edist(i,j)。表示i已经被考察过了，要i维持不动，要继续对(j-1)考察并往下一步值j，\n必然意味对b[j]进行了删除操作, (操作后的b[j]已经不是操作前的那个b[j]而是操作前的b[j+1])）\n或者在a[i]前面进行了插入b[j]的操作 (操作后的a[i]已经变成了b[j]而不是操作前的那个a[i]，操作前的那个a[i]已经变成了操作后的a[i+1]).\n\n条件里面a[i] == b[j] 表示的都是操作后的的含义。\n\n同理类似,min_edist(i,j-1) --->min_edist(i,j) 也是要+1的，无论a[i]是否等于b[j]。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579105683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20381,"discussion_content":"同上，我也没有理解老师的状态转移方程如何写出来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569307612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64786,"user_name":"俊杰","can_delete":false,"product_type":"c1","uid":1026117,"ip_address":"","ucode":"2BE07E558435AD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/45/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1548911725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23023748205","product_id":100017301,"comment_content":"为什么到后面留言这么少？<br><br>在编辑距离里面， 状态转移方程，第二种case ,是不是可以改为：<br><br>如果：a[i]==b[j]，那么：min_edist(i, j) 就等于：min_edist(i-1,j-1)  <br><br>a[i]==b[j]  <br>a[0..i]  和 b[0..j] 的编辑距离就等价于   a[0..i-1]  和 b[0..j-1]的编辑距离<br>    ","like_count":5},{"had_liked":false,"id":219960,"user_name":"John","can_delete":false,"product_type":"c1","uid":1020861,"ip_address":"","ucode":"E4ADF8488953FB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/bd/f3977ebb.jpg","comment_is_top":false,"comment_ctime":1590126162,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18769995346","product_id":100017301,"comment_content":"总结一下8个问题 (若有遗漏 请大家补充):<br>1. 杨辉三角: 我们现在对它进行一些改造。每个位置的数字可以随意填写，经过某个数字只能到达下面一层相邻的两个数字。假设你站在第一层，往下移动，我们把移动到最底层所经过的所有数字之和，定义为路径的长度。请你编程求出从最高层移动到最底层的最短路径长度。<br>2. 1111问题: 淘宝的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”。假设你女朋友的购物车中有 n 个（n&gt;100）想买的商品，她希望从里面选几个，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件（200 元），这样就可以极大限度地“薅羊毛”。作为程序员的你，能不能编个代码来帮她搞定呢？<br>3. 01背包问题: 对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？<br>4. 01背包问题升级版: 对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？<br>5. 我们今天来看一个新的硬币找零问题。假设我们有几种不同币值的硬币 v1，v2，……，vn（单位是元）。如果我们要支付 w 元，求最少需要多少个硬币。比如，我们有 3 种不同的硬币，1 元、3 元、5 元，我们要支付 9 元，最少需要 3 个硬币（3 个 3 元的硬币）。<br>6. 假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？<br>7. 如何量化两个字符串的相似度？当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。作为一名软件开发工程师，你是否想过，这个功能是怎么实现的呢？ 两个字符串的相似度: 莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）<br>8. 我们有一个数字序列包含 n 个不同的数字，如何求出这个序列中的最长递增子序列长度？比如 2, 9, 3, 6, 5, 1, 7 这样一组数字序列，它的最长递增子序列就是 2, 3, 5, 7，所以最长递增子序列的长度是 4。","like_count":4,"discussions":[{"author":{"id":1543384,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d8/a74d59a3.jpg","nickname":"子微","note":"","ucode":"95A15B841AAE61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311781,"discussion_content":"跟着老师的步伐，边学边把几道题目用python都写了一下，后面注意到回溯打印最优解选择元素的序列，也添加上去，互相交流学习：\nhttps://github.com/binkesi/Data-structure-and-algorithm/tree/master/python/dynamic_programming","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602488264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73053,"user_name":"菜菜","can_delete":false,"product_type":"c1","uid":1243536,"ip_address":"","ucode":"888AC33663B774","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/90/f90903e5.jpg","comment_is_top":false,"comment_ctime":1551785963,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"18731655147","product_id":100017301,"comment_content":"老师，为什么当a[i]==b[j]时，minDist[i][j]不能直接等于minDist[i-1][j-1],而要等于min(minDist[i-1][j]+1,minDist[i][j-1]+1,minDist[i-1][j-1])","like_count":4,"discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220015,"discussion_content":"因为到a[i]和b[j]时，只能从3种情况过来，(i, j - 1)、(i - 1, j)、(i - 1, j - 1)，a[i] 无论是否等于 b[j]，前面两种情况到达a[i], a[j]时都是肯定要+1的，因为两种情况要么是i不变，要么是j不变，能到这两种情况说明a[i-1]肯定不等于b[j-1]。而a[i] == a[j]时，minDist[i-1][j-1] 已经算出了(i-1, j-1)的最短编辑距离，所以不需要+1，反之就需要加1了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585831150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301946,"discussion_content":"你这答非所问啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598714009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":220015,"ip_address":""},"score":301946,"extra":""},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301976,"discussion_content":"不要🦐bb\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598744691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301946,"ip_address":""},"score":301976,"extra":""},{"author":{"id":1292087,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","nickname":"Veitor","note":"","ucode":"3397AC6D239195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334956,"discussion_content":"(i, j-1)和(i-1,j)到达(i,j)是要+1，但主要的问题还是minDist(i, j)中是否包含了对(i,j)这次的编辑，如果是的话，那么minDist(i-1,j)和minDist(i,j-1)所表达的值中已经包含了+1，怎么还需要在后面+1呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608035824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":220015,"ip_address":""},"score":334956,"extra":""}]}]},{"had_liked":false,"id":269081,"user_name":"Veitor","can_delete":false,"product_type":"c1","uid":1292087,"ip_address":"","ucode":"3397AC6D239195","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/37/0290ff6e.jpg","comment_is_top":false,"comment_ctime":1608517136,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14493419024","product_id":100017301,"comment_content":"这个a[i]==b[j]时，min_edist(i,j)=min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))的问题我思考了两个礼拜终于想通了，这里跟同样疑惑的同学解答一下，看看我的思考方式能不能解开你们的疑惑。（下面单纯以(i-1,j)阶段举例，就不说(i,j-1)阶段了）<br><br>首先我认为回溯代码的实现比较容易理解，也基本是我们一开始就能写出来的。回溯代码中关键的一段逻辑if(a[i]==b[j]){}else{}，会让我们得出(i,j)阶段可以通过(i,j-1),(i-1,j),(i-1,j-1)三个阶段过来的结 论，然后通过画状态树可以看出存在重复子问题，所以我们只需要在某个阶段中选出一个最小值min_edist(i,j)出来，最后来到了我们的疑惑所在点：a[i]==b[j]时，为什么min_edist(i,j)=min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))<br><br>最初我的思考方式是：根据【回溯代码】实现看（因为我们最先写出的是这个算法的实现，所以肯定先从这个算法逻辑思考出发），min_edist(i, j)表示的是已经包含了(i,j)阶段这次编辑，所以a[i]!=b[j]时，这+1次的编辑次数应该算在(i,j)阶段上，所以同理，(i-1,j)阶段的编辑次数要算在(i-1,j)阶段上，但是a[i]==a[j]情况下，(i,j)阶段其实不需要+1，那就直接取上一阶段的值min_edist(i-1, j)，状态转移方程应当是min_edist(i,j)=min(min_edist(i-1,j), min_edist(i,j-1)，min_edist(i-1,j-1))啊。所以这样的思考方式让我一直认为作者文中的公式是不是写错了？还是min_edist(i,j)中就不包含(i,j)这次编辑？但怎么想逻辑都还是不对，我觉得我这种思考方式没问题啊。（不知大家是不是也和我这么想的？）<br><br>经过我 日思夜想的，终于想通了，换个角度思考。为什么状态转移方程中需要加上那个1？不应当算在了前一个阶段吗？<br><br>我们就假设i=5,j=2，则代表一个5长度的a字符串与一个2长度的b字符串相互转换的话（可以是a传变成长度为2的b串，也可以是b串变成长度为5的a串），需要做编辑次数c次。也就是说对其中一个字符串做了c次编辑后，两个字符串就一毛一样了（一样的长度一样的字符）。<br>如果我们在这个a串后加一个字符串得到i=6，j=2的两个字符串，那我们要求现在的a和b串的编辑距离该怎么求？还是用【回溯代码】逻辑套用的话，容易产生上面我最初的错误的思考结 论（即a[i]==b[j]时直接取前一阶段的编辑距离）。问题出在哪了？问题就出在了过度关注了【回溯代码】下面一个if了，而我们却漏掉了思考【回溯代码】中if(i==n || j==m)这个重要的逻辑片段，这个片段的作用是当其中一个字符串考 察结束后，就把另一个字符串没考 察完的长度加到编辑次数上。所以回过来看，(i-1,j)的编辑距离不正是c吗？其中肯定有一个字符串考 察完了，且也把另一个字符串没考 察长度的加上了，得到的这个编辑距离c。那么在其中一个字符串后面再加一个字符意味着什么？意味着在(i,j)这次中，没考 察的长度又要+1了，所以这个+1是必定的。而与当前a[i]是否等于b[j]无关，这个+1可以看作是未考 察的字符。<br><br>所以最后大家应该知道了为什么a[i]==b[j]时，(i-1,j)的编辑距离后还要+1了吧","like_count":3,"discussions":[{"author":{"id":2474580,"avatar":"https://static001.geekbang.org/account/avatar/00/25/c2/54/77dac43b.jpg","nickname":"UltramanTiga","note":"","ucode":"245D8768E5CCDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580108,"discussion_content":"。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657874669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1281744,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJl2pb1hghtz4FhLvdnDaPRxiccoMWbpty0z4ZicRL7rqticwyH5tHAtXcNLs96jRQtpVD5hvF6XPwYg/132","nickname":"Anonymity","note":"","ucode":"6A86DEE0AEFE10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367247,"discussion_content":"牛bility","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618305176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1890452,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJiartmgOY37cyzpYRicGBy7ZSnzZzmozxqaXE7Xm1aA3ubicDhMOIsfgibicFicvKA0NJ61YdicgXTdHpOw/132","nickname":"hxloongs","note":"","ucode":"8CFAF37C0DB1F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351557,"discussion_content":"感谢大佬解惑，+1问题，我在这里卡了老半天了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614323402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126832,"user_name":"Zessay","can_delete":false,"product_type":"c1","uid":1206779,"ip_address":"","ucode":"F507246046B4A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/p6AJdaO6KcicsrJPZSIExSHrmyqm9zY1eAEeia8Z9pa4wZPSJteS5meM73qnvBmYDpHicdyetXsesoyblnn53Yn0Q/132","comment_is_top":false,"comment_ctime":1566487243,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14451389131","product_id":100017301,"comment_content":"说一下自己对首行首列初始化的理解。对第一行初始化，相当于求解a[0]和b在所有位置的最小编辑距离，那么对于b第一个位置，如果和a[0]相同则为0，不同则为1。对于第j个位置的元素，如果和a[0]相同，直接等于j就行，为什么呢？因为直接把前面j-1个位置的元素删除就行，对应的编辑距离就是j（因为下标是从0开始的）；如果和a[0]不同，那么就等于前一个位置的编辑距离+1。同理，第一列是类似的","like_count":3,"discussions":[{"author":{"id":1005661,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","nickname":"爱新觉罗老流氓","note":"","ucode":"B13AC4DA358C15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246622,"discussion_content":"是的，结合莱文斯坦距离的约定，a[0] 和 b[j] 对比，相当于删除 b[j] 前面的 j 个元素，所需的编辑次数就是 j。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587743832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1348568,"avatar":"https://static001.geekbang.org/account/avatar/00/14/93/d8/8bab3fb5.jpg","nickname":"Yocn","note":"","ucode":"35BDF12EA130C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32858,"discussion_content":"翻译成代码如下，简化后等价于文章里面的初始化代码：\n\n        for (int j = 0; j < y; j++) {\n            if (j == 0) {\n                if (a[0] == b[j]) {//a[0] == b[0]\n                    minDist[0][j] = 0;\n                } else {\n                    minDist[0][j] = 1;\n                }\n            } else {\n                if (a[0] == b[j]) {\n                    minDist[0][j] = j;\n                } else {\n                    minDist[0][j] = minDist[0][j - 1] + 1;\n                }\n            }\n        }\n\n-----------------------------------\n                        ↓等价于↓\n-----------------------------------\n\n        for (int j = 0; j < y; j++) {\n            if (a[0] == b[j]) {\n                minDist[0][j] = j;\n            } else if (j != 0) {\n                minDist[0][j] = minDist[0][j - 1] + 1;\n            } else {\n                minDist[0][j] = 1;\n            }\n        }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571064061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59062,"user_name":"Dylan","can_delete":false,"product_type":"c1","uid":1040236,"ip_address":"","ucode":"58064D0C9F9F5F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/df/6c/5af32271.jpg","comment_is_top":false,"comment_ctime":1547290948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14432192836","product_id":100017301,"comment_content":"以前遇到DP问题，都是一上来假设第i个状态已经搞定，去想下一步的状态方程，加上作者前面的回溯和递归分析，可以让整个想DP的思维更圆满～","like_count":3},{"had_liked":false,"id":56123,"user_name":"slvher","can_delete":false,"product_type":"c1","uid":1018964,"ip_address":"","ucode":"F4ED6980C8248B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/54/deb19880.jpg","comment_is_top":false,"comment_ctime":1546394385,"is_pvip":false,"replies":[{"id":"20243","content":"是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546417839,"ip_address":"","comment_id":56123,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14431296273","product_id":100017301,"comment_content":"本文举例的 LCS 问题不要求字符连续，通常是指 longest common subsequence 吧？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434938,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546417839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98307,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1558952952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10148887544","product_id":100017301,"comment_content":"if a[i] == b[j]:  <br>        return max(lcs_dp(i-1,j),lcs_dp(i,j-1),lcs_dp(i-1,j-1)+1)<br>最长公共子串长度的状态转移公式中，对a[i] == b[j]的情况，lcs_dp(i-1,j)和lcs_dp(i,j-1)为什么不加1，这个问题，主要是考虑到aba和a，这种最长公共子串长度为1的特殊情况，通过这个特殊的例子，就可以明白为什么lcs_dp(i-1,j)和lcs_dp(i,j-1)不加1了~~~","like_count":2},{"had_liked":false,"id":58712,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1547180805,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10137115397","product_id":100017301,"comment_content":"要自己思考这个问题，感觉真不容易，因为思路错误，走了不少弯路，花了5天的休息时间，终于解出来了，写出来了，感觉是容易了，但这个思考的过程，感觉自己收获不少，尝试了很多种的解法，然后都一一的否决！<br><br><br>这是我写的递归求解，<br><br>public int recursionCount4(int[] arrays, int index) {<br><br>    if (index == 0) {<br>      return 1;<br>    }<br>    int max = 0;<br>    &#47;&#47;此问题的解，递归的核心就是在之前的序列中找到最大递增子序列加1<br>    &#47;&#47;所以需要遍历此此之前的全部数据项<br>    for (int i = 0; i &lt; index; i++) {<br>      &#47;&#47;递归求解每项的最递增序列<br>      int value = recursionCount4(arrays, i);<br>      if (arrays[i] &lt; arrays[index]) {<br>        if (value &gt; max) {<br>          max = value;<br>        }<br>      }<br>    }<br><br>    return max + 1;<br>  }<br><br><br><br>public void countDynamic(int[] arrays) {<br>    int length = arrays.length;<br><br>    int[] status = new int[length];<br><br>    status[0] = 1;<br><br>    int commMax = 0;<br><br>    for (int i = 1; i &lt; length; i++) {<br>      int max = 0;<br>      for (int j = 0; j &lt; i; j++) {<br>        if (arrays[j] &lt; arrays[i]) {<br>          if (status[j] &gt; max) {<br>            max = status[j];<br>          }<br>        }<br>      }<br>      status[i] = max + 1;<br><br>      if (status[i] &gt; commMax) {<br>        commMax = status[i];<br>      }<br>    }<br><br>    System.out.println(&quot;最大递增序列为 ：&quot; + commMax);<br>    int maxComp = commMax;<br>    System.out.println(&quot;递增:&quot; + Arrays.toString(status));<br><br>    for (int i = length - 1; i &gt;= 0; i--) {<br>      if (status[i] == maxComp) {<br>        System.out.print(&quot;--&gt;&quot; + arrays[i]);<br>        maxComp = maxComp - 1;<br>      }<br>    }<br>  }<br><br><br>","like_count":2,"discussions":[{"author":{"id":1062266,"avatar":"https://static001.geekbang.org/account/avatar/00/10/35/7a/abb7bfe3.jpg","nickname":"stan","note":"","ucode":"B48CDD63645B84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159624,"discussion_content":"递归求解貌似不对，for 循环里的逻辑应该是 length = arrays[index] > arrays[i] ? value +1 ：value,  然后再比较 length 和 max 的关系，不能直接返回 max +1 吧 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580716771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56703,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1546523997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10136458589","product_id":100017301,"comment_content":"初始化第零行没看懂代码啥意思","like_count":2},{"had_liked":false,"id":283914,"user_name":"文过饰非","can_delete":false,"product_type":"c1","uid":1782167,"ip_address":"","ucode":"F85FDB49F7DB39","user_header":"https://static001.geekbang.org/account/avatar/00/1b/31/97/524bf2b2.jpg","comment_is_top":false,"comment_ctime":1615982151,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5910949447","product_id":100017301,"comment_content":"看到好多同学不太理解状态转移方程是怎么想到的，所以提供下个人的见解~<br>状态转移方程其实就是：罗列当前可以做出的选择-&gt;从当前状态经由选择转移到另一状态-&gt;重复该过程直到抵达终止条件。所以动态规划问题最关键的两点就是“状态”和“选择”。<br>老师文中提到了回溯方法，回溯其实就是暴力枚举。把所有的可能都罗列出来，一一计算比较得出最优解。暴力枚举可以非常直观的看出状态转移方程。文中即: <br> if (a[i] == b[j]) { &#47;&#47; 两个字符匹配<br>    lwstBT(i+1, j+1, edist);<br>  } else { &#47;&#47; 两个字符不匹配<br>    lwstBT(i + 1, j, edist + 1); &#47;&#47; 删除a[i]或者b[j]前添加一个字符<br>    lwstBT(i, j + 1, edist + 1); &#47;&#47; 删除b[j]或者a[i]前添加一个字符<br>    lwstBT(i + 1, j + 1, edist + 1); &#47;&#47; 将a[i]和b[j]替换为相同字符<br>  }<br>代码中i和j的值就是当前状态，也就是目前进行比较的进度，而if…else语句就是在当前状态下可以做的选择。计算机其实并不聪明，它并不知道该选择哪条路，所以只能全部走一遍然后告诉你结果。于是我们将当前可以做的选择都选一遍，表现在代码上就是递归的调用和传入的i和j的变化，这就是状态的转移。<br>现在的问题是我们是如何通过回溯法得到迭代（填表格）法的？<br>老师在递归那一章里提到过解决重叠子问题的方法就是使用备忘录，记录已求解问题的答案。所以在暴力枚举和迭代法之间还有一个中间解法:递归+备忘录。我们可以稍微修改下回溯算法的逻辑(由于我只对C++比较熟悉，所以以C++编写):<br>&#47;&#47; vector是C++容器，可以理解为二维数组，用作备忘录<br>&#47;&#47; dp数组的初始值均被初始化为-1<br>int lwstBT(vector&lt;vector&lt;int&gt;&gt;&amp; dp, string a, string b, int i, int j) <br>{<br>    if (i == n &amp;&amp; j == m)  &#47;&#47; 主串、模式串均抵达结尾<br>        return 0;<br>    if (i == n)  &#47;&#47; 主串抵达结尾<br>        return n - i;<br>    if (j == m)  &#47;&#47; 模式串抵达结尾<br>        return m - j;<br>    <br>    if (dp[i][j] != -1)  &#47;&#47; 如果当前i和j的值所对应的状态已经求解过<br>        return dp[i][j];  &#47;&#47; 直接返回结果，去除重叠子问题<br><br>    if (a[i] == b[j])  &#47;&#47; 当前状态：i和j所对应两个字符匹配<br>        dp[i][j] = lwstBT(dp, a, b, i+1,  j+1);  &#47;&#47; 做出选择, 记录到备忘录中<br>    else  &#47;&#47; 当前状态：i和j所对应两个字符不匹配<br>    {<br>        int sum = lwstBT(dp, a, b, i + 1, j);   &#47;&#47; 做出选择，删除a[i]或者b[j]前添加一个字符<br>        sum = max(sum, lwstBT(dp, a, b, i,  j + 1);  &#47;&#47; 做出选择，删除b[j]或者a[i]前添加一个字符, 取较大值<br>        sum = max(sum, lwstBT(dp, a, b, i + 1, j + 1));  &#47;&#47; 做出选择，将a[i]和b[j]替换为相同字符，取较大值<br>        dp[i][j] = sum;  &#47;&#47; 记录到备忘录中<br>    }<br>    return dp[i][j];  &#47;&#47; 返回当前结果<br>}<br>修改后的代码也是在穷举所有可能的情况，只是通过备忘录消除了重叠子问题。现在从终止条件反推，可以发现，备忘录的填充是从终止条件开始的，也就是递归上升的过程中填充好的。上升到最上层，即i i = 0, j = 0时，dp[i][j]的值就是最终的答案。噫，你会发现递归执行整个过程都是在填充dp这张二维表格，所以，现在我们直接通过迭代循环模拟递归执行的顺序，自底向上开始填充dp数组就行。这就是迭代法填充表格的方式。值得注意的一点是：迭代法一开始填充的0行0列的值就是在填充终止条件的值，即所有i == n、j == m时的值。","like_count":1,"discussions":[{"author":{"id":1782167,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/31/97/524bf2b2.jpg","nickname":"文过饰非","note":"","ucode":"F85FDB49F7DB39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358644,"discussion_content":"文中的max()应该替换成min()取较小值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616027400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258237,"user_name":"星夜","can_delete":false,"product_type":"c1","uid":1128491,"ip_address":"","ucode":"3B46C09D994CEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","comment_is_top":false,"comment_ctime":1604333653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5899300949","product_id":100017301,"comment_content":"思考题：<br>public int longestSubSequence(int[] nums) {<br>    &#47;&#47; dp[i]表示以下标i结尾字符串的最长递增子序列长度<br>    int[] dp = new int[nums.length];<br>    dp[0] = 1;<br><br>    &#47;&#47; 递推公式：last&lt;cur<br>    &#47;&#47; nums[cur] &gt; nums[last]时, f(cur)=max(f(cur),f(last)+1)<br>    &#47;&#47; nums[cur] &lt;= nums[last]时, f(cur)=max(f(cur),f(cur-1))<br>    for (int i = 1; i &lt; nums.length; i++) {<br>        for (int j = 0; j &lt; i; j++) {<br>            if (nums[i] &gt; nums[j]) {<br>                dp[i] = Math.max(dp[i], dp[j] + 1);<br>            } else {<br>                dp[i] = Math.max(dp[i], dp[i - 1]);<br>            }<br>        }<br>    }<br><br>    return dp[nums.length - 1];<br>}","like_count":1},{"had_liked":false,"id":227019,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1592268717,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5887236013","product_id":100017301,"comment_content":"关于最长公共子序列状态转移方程的理解：<br><br>先看递归代码的思路：<br>if a[i] != b[j]，下一步(i+1, j) or (i, j+1)，max_lcs不变<br>else 下一步(i+1, j+1) max_lcs+1<br><br>和前面的编辑距离思路一样，状态转移方程不是看a[i]?=b[j]来决定下一步走法，而是三种走法都会尝试。然后看前一步的走法（前一个状态-&gt;当前状态）是否增加max_lcs，这个是和递归代码的重要区别<br><br>如果前一步是这么走的 (i-1, j) -&gt; (i, j)，那么max_lcs不变。<br>如果前一步是这么走的 (i, j-1) -&gt; (i, j)，max_lcs也不变。<br>如果前一步是这么走的 (i-1, j-1) -&gt; (i, j)，max_lcs肯定+1<br><br>你会问同样的问题，如果a[i] == b[j] 不是还应该给max_lcs+1吗？这个不同担心，因为下一步(i, j)-&gt;(i+1, j+1)会把这个给补上的。<br><br>但是！因为【状态转移方程会把每一种走法都试一遍】，所以就算a[i] != b[j]，下一步也会(i, j) -&gt; (i+1, j+1) 走一下，那么在下一步里岂不是明明不相等却把max_lcs+1了吗？所以当a[i] != b[j]的时候，要【提前】把这个+1给抵消掉，因此也就有了状态转移方程：<br><br>if a[i] == b[j]<br>  max_lcs = max(max_lcs(i-1, j), max_lcs(i, j-1), max(i-1, j-1)+1)<br>else<br>  max_lcs = max(max_lcs(i-1, j), max_lcs(i, j-1), max(i-1, j-1))","like_count":1,"discussions":[{"author":{"id":1796438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","nickname":"youyou.L","note":"","ucode":"B3DB0D0700EEAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339635,"discussion_content":"看了两遍都没看懂公式max_lcs = max(max_lcs(i-1, j), max_lcs(i, j-1), max(i-1, j-1)+1)\n，看到这里被启发了。\n这里要具体分析每一种情况才能明白，是代码刚好覆盖到正确的情况，关键是思考回溯不会走到的状态，dp怎么处理才合适。\n第一种 (i,j-1) -> (i,j)有可能+1有可能+0，当b[j-1] = b[j]时+0，因为每个字符只能计算一次长度；当b[j-1] != b[j]时+1。那为什么状态方程直接+0呢，因为+1的情况会被(i-1,j-1)  -> (i,j)覆盖掉，不管a[i-1] =? b[j-1]，dp都会走到(i,j)并且mac_lcs+1，把(i,j-1)->(i,j)可能+1的情况覆盖了，所以(i,j-1) -> (i,j)干脆全都+0，若是+1的情况会被(i-1,j-1)覆盖，若是+0的情况正好合适。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609749716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175789,"user_name":"朱坤","can_delete":false,"product_type":"c1","uid":1098637,"ip_address":"","ucode":"65224DA2456EAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/8d/214ad614.jpg","comment_is_top":false,"comment_ctime":1580827717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875795013","product_id":100017301,"comment_content":"课后题解题思路： 在第一层时，将2放入序列，在第二层时，考察数字9，可以选择将9加入，也可不加入，此时得到2个序列 [ [2], [2, 9] ]，在第三层时，每个序列可以选择将是否将3放入序列，即得到 [ [2], [2, 3], [2, 9]]，以此遍历考察每个数字，最终得到 [ [ 2 ],<br>  [ 2, 7 ],<br>  [ 2, 5 ],<br>  [ 2, 5, 7 ],<br>  [ 2, 6 ],<br>  [ 2, 6, 7 ],<br>  [ 2, 3 ],<br>  [ 2, 3, 7 ],<br>  [ 2, 3, 5 ],<br>  [ 2, 3, 5, 7 ],<br>  [ 2, 3, 6 ],<br>  [ 2, 3, 6, 7 ],<br>  [ 2, 9 ] ]， 从中选出最大的子序列。<br><br>JS 实现代码：<br><br>function main() {<br>    const numbers = [2, 9, 3, 6, 5, 1, 7];<br><br>    const series = numbers.reduce((acc, num, i) =&gt; {<br>        if (i == 0) {<br>            return [ [num] ]<br>        }<br>        const current = [];<br>        acc.forEach(series =&gt; {<br>            current.push(series); &#47;&#47; 不加入当前数字<br>            if (series[series.length - 1] &lt; num) {  &#47;&#47; 加入当前数字<br>                current.push([...series, num]);<br>            }<br>        })<br>        return current;<br>    }, [])<br><br>    let maxIndex = 0;<br><br>    for(let i =0; i&lt;series.length; i++) {<br>        if (series[maxIndex].length &lt; series[i].length) {<br>            maxIndex = i;<br>        }<br>    }<br>    console.log(`最大子序列为: ${series[maxIndex]}, 长度为: ${series[maxIndex].length}`)<br>}<br><br>main();<br>","like_count":1},{"had_liked":false,"id":159700,"user_name":"常文龙","can_delete":false,"product_type":"c1","uid":1204525,"ip_address":"","ucode":"4A126159D24766","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/2d/5ca0a3da.jpg","comment_is_top":false,"comment_ctime":1575731878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870699174","product_id":100017301,"comment_content":"O(n)的时间复杂度解决思考题 最长递增子序列（不要求连续 lcs）<br>定义dp[i]为以A[i]为结尾的lcs<br>递推式：<br>  求dp[i]，需要从i的位置往前找索引j，满足A[j]小于A[i]，则dp[i]=dp[j]+1<br><br>此题就转化为：寻找数组A中位置i之前的第一个小于A[i]的元素  <br><br>可以使用单调栈来解决上述问题","like_count":1},{"had_liked":false,"id":144161,"user_name":"阿信","can_delete":false,"product_type":"c1","uid":1389604,"ip_address":"","ucode":"50616ED68A5B40","user_header":"https://static001.geekbang.org/account/avatar/00/15/34/24/34ca1d23.jpg","comment_is_top":false,"comment_ctime":1571873218,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5866840514","product_id":100017301,"comment_content":"下面分享下我的思考过程：老师说的那句话&quot;不要想机器会怎么解决，要想如果是你你会怎么解决&quot;，因为人脑不擅长太抽象的问题，善于解决实际看得到的问题，过于思考递归过程，很容易绕进去出不来。【关键是关注状态转移的过程】<br>状态(i,j)可以由(i-1,j,+1)、(i,j-1,+1)、(i-1,j-1)、(i-1,j-1,+1)四个状态转移过来，(i-1,j,+1)、(i,j-1,+1)好理解跳过，当a[i]!=b[j]时，到(i-1,j-1)后，因为还有a[i]!=b[j]，还需要再编辑一次才能到(i,j)，所以(i,j)=min((i-1,j,+1)、(i,j-1,+1)、(i-1,j-1,+1))。当a[i]==b[j]时，到(i-1,j-1)后，因为已经a[i]==b[j]，不需要再编辑，所以(i,j)=min((i-1,j,+1)、(i,j-1,+1)、(i-1,j-1))。","like_count":1,"discussions":[{"author":{"id":1661456,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epYAmnyHBCVY7YicTF3IXa39mvVTuyum9yicPyFG5amXuo6R2QOTicX0iaXLicH8CTktC7XHruv81ichgkg/132","nickname":"Geek_b25f99","note":"","ucode":"6F7BEAB2C31528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42740,"discussion_content":"(i-1,j,+1)、(i,j-1,+1)好理解跳过？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572763858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141264,"user_name":"嘉一","can_delete":false,"product_type":"c1","uid":1196864,"ip_address":"","ucode":"8D16BD0B75B019","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","comment_is_top":false,"comment_ctime":1571133099,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5866100395","product_id":100017301,"comment_content":"课后习题（ts版本）：<br>class SortClazz {<br>        public static getMaxSupLength(arr: number[]): number{<br>            if(arr.length === 0){<br>                return 0;<br>            }<br>            let maxLengthArr = [1];<br>            for(let i = 1, leng = arr.length; i &lt; leng; ++i){<br>                if(arr[i] &gt;= arr[i - 1]){<br>                    maxLengthArr[i] = maxLengthArr[i - 1] + 1;<br>                }else{<br>                    maxLengthArr[i] = maxLengthArr[i - 1];<br>                }<br>            }<br>            return maxLengthArr[maxLengthArr.length - 1];<br>        }<br>    }","like_count":1,"discussions":[{"author":{"id":1258236,"avatar":"https://static001.geekbang.org/account/avatar/00/13/32/fc/5d901185.jpg","nickname":"vic","note":"","ucode":"6C59A40DF9310A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211737,"discussion_content":"这个解法又问题，文末的数组带入后，结果是3，很明显是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584885559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108788,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/34/cd310e69.jpg","nickname":"行走的","note":"","ucode":"04772A8A1FF2B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38433,"discussion_content":"这个解答思路清晰！容易理解！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571789759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124914,"user_name":"Geek_18b741","can_delete":false,"product_type":"c1","uid":1368496,"ip_address":"","ucode":"097BA0C2F44150","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlztvlBgajZMEph8AvkP2pfoqNCGtYSalIKgrCbCg0MWDZJgJwqVRfWA6cgIoZicL6dKibfK0zjsWg/132","comment_is_top":false,"comment_ctime":1566014299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860981595","product_id":100017301,"comment_content":"矩阵最短路径长度的目标是要找到最小的长度，所以在每个状态只保留最小的长度。<br>莱文斯坦问题的目标是要找到最小的编辑距离，所以在每个状态只保留最小的编辑距离。<br>0-1背包问题目标是求最大的重量，为什么不只保留最大的重量就可以呢？因为0-1背包问题的限制条件也是重量。它要求总重量不能超过w。所以每一步决策之后的重量都有可能是一个结果。所以不能剪裁，需要保留。","like_count":1},{"had_liked":false,"id":122959,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1565579763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860547059","product_id":100017301,"comment_content":"学到这里，感觉面试算法就两种，好想不好写，好写但是不好想，动态规划就属于好写不好想的那种","like_count":1},{"had_liked":false,"id":112542,"user_name":"寻路人","can_delete":false,"product_type":"c1","uid":1195917,"ip_address":"","ucode":"1711F740D4D60A","user_header":"https://static001.geekbang.org/account/avatar/00/12/3f/8d/a89be8f9.jpg","comment_is_top":false,"comment_ctime":1562754718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5857722014","product_id":100017301,"comment_content":"一直没有搞懂a[i]=b[j]的时候，为什么min_dest最小值有dest[i-1][j-1]+1这种情况，应该只有a[i-1]=b[j-1]的时候才会出现这种情况","like_count":1},{"had_liked":false,"id":97994,"user_name":"Zix","can_delete":false,"product_type":"c1","uid":1025719,"ip_address":"","ucode":"48BB6A7F1352CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/b7/e0c9be64.jpg","comment_is_top":false,"comment_ctime":1558864318,"is_pvip":false,"replies":[{"id":"35626","content":"当然不可以了，改写之后完全不对呢，你对比一下前后两个公式。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559176053,"ip_address":"","comment_id":97994,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853831614","product_id":100017301,"comment_content":"老师状态转移方程，当a[i] = b[j] 的时候，能否把 minDist[i][j] = min(minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]); 改写为 minDist[i][j] = minDist[i-1][j-1]; ？请求老师解答","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451504,"discussion_content":"当然不可以了，改写之后完全不对呢，你对比一下前后两个公式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559176053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60612,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1547518961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5842486257","product_id":100017301,"comment_content":"我自己想不到递推的方法，我写了一个笨方法，GO语言版本的全遍历：<br>package main<br><br>import &quot;fmt&quot;<br><br>func Backtrack(input []int) ([]int, int) {<br>\tsliceLen := len(input)<br>\tmaxCount := 0<br>\tmaxSlice := make([]int, 0, sliceLen)<br><br>\tfor i := 0; i &lt; sliceLen; i++ {<br>\t\tfor j := i + 1; j &lt; sliceLen; j++ {<br>\t\t\tm := i<br>\t\t\tn := j<br>\t\t\tcount := 0<br>\t\t\ttemp := make([]int, 0, sliceLen)<br>\t\t\ttemp = append(temp, input[m])<br>\t\t\tfor n &lt; sliceLen {<br>\t\t\t\tif input[m] &lt; input[n] {<br>\t\t\t\t\tcount++<br>\t\t\t\t\ttemp = append(temp, input[n])<br>\t\t\t\t\tm = n<br>\t\t\t\t}<br>\t\t\t\tn = n + 1<br>\t\t\t}<br><br>\t\t\tif count &gt; maxCount {<br>\t\t\t\tmaxCount = count + 1<br>\t\t\t\tmaxSlice = make([]int, 0, sliceLen)<br>\t\t\t\tmaxSlice = append(maxSlice, temp...)<br><br>\t\t\t}<br>\t\t}<br>\t}<br><br>\treturn maxSlice, maxCount<br><br>}<br><br>func main() {<br>\ta := []int{3, 5, 8, 9, 1, 7}<br>\tmaxSlice, maxCount := Backtrack(a)<br>\tfmt.Printf(&quot;%v,%v\\n&quot;, maxSlice, maxCount)<br>\treturn<br>}<br>","like_count":1},{"had_liked":false,"id":60610,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1547518820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5842486116","product_id":100017301,"comment_content":"老师你好，我说的是42节留言里面同学对思考题的回答，他们的递推公式不管用。比如拿[3,5,8,9,1,7]验证下就知道","like_count":1},{"had_liked":false,"id":57973,"user_name":"梅坊帝卿","can_delete":false,"product_type":"c1","uid":1240270,"ip_address":"","ucode":"702F019BA3356C","user_header":"","comment_is_top":false,"comment_ctime":1546953787,"is_pvip":false,"replies":[{"id":"20938","content":"光讲状态转移方程 新手是没法很好的理解的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547001083,"ip_address":"","comment_id":57973,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5841921083","product_id":100017301,"comment_content":"通过思考题再次发现 找到状态转移方程是多么重要 其他基本都是套路 迭代取极值 到结束","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435855,"discussion_content":"光讲状态转移方程 新手是没法很好的理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547001083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57745,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1546878990,"is_pvip":false,"replies":[{"id":"21858","content":"你说的没错。不过单纯讲如何找状态转移方程，如何根据状态转移方程写代码，这是面试流了。。。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547709605,"ip_address":"","comment_id":57745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5841846286","product_id":100017301,"comment_content":"我怎么感觉，分析完问题后，能不能写出代码的关联点是能不能通过前面的分析写出状态转移方程，跟着老师学的越多，越感觉自己是以前真的是个码农，根本算不上程序员。虽然我才真正做java一年，还是半路出家的，跟着老师学到好多东西，哈哈","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435735,"discussion_content":"你说的没错。不过单纯讲如何找状态转移方程，如何根据状态转移方程写代码，这是面试流了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547709605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57029,"user_name":"强哥","can_delete":false,"product_type":"c1","uid":1206726,"ip_address":"","ucode":"3B8DC780FE4EF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/c6/513df085.jpg","comment_is_top":false,"comment_ctime":1546605141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5841572437","product_id":100017301,"comment_content":"递归树那张图，最右侧的叶子节点的数字有问题。","like_count":1},{"had_liked":false,"id":56286,"user_name":"SevenHe","can_delete":false,"product_type":"c1","uid":1245161,"ip_address":"","ucode":"7C69539BE3E42F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/e9/276b9753.jpg","comment_is_top":false,"comment_ctime":1546416168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5841383464","product_id":100017301,"comment_content":"思考题还有一个比较tricky的做法，用二分查找维护最长子序列（并不一定是目标子序列，只是与之等长），时间复杂度更低，从O(n^2)降到O(nlogn)","like_count":1},{"had_liked":false,"id":56172,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1546399690,"is_pvip":false,"replies":[{"id":"20242","content":"嗯嗯","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546417831,"ip_address":"","comment_id":56172,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5841366986","product_id":100017301,"comment_content":"可以在 a[i] 前面添加一个跟 b[j] 相同的字符，然后递归考察 a[i+1] 和 b[j];<br>这里的a[i+1] 和 b[j]  不应该是a[i+1] 和 b[j+1]吗<br>如果在a[i] 前面添加一个字符b[j]，就说明a[i] 与b[j]的相等<br>那a[i+1] 和 b[j] 再去比较就可能出现不等的情况，<br>而是a[i+1] 和 b[j+1] 继续比较下一个字符 ","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434949,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546417831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359767,"user_name":"一支小闲鱼","can_delete":false,"product_type":"c1","uid":1618640,"ip_address":"北京","ucode":"96C6D03E69A716","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJmCRpUZlm5jaNbpHAk50CWkZwymo599zaThKat1y45JIvV2VU4srpZWCWYttBUGcCDLwtiaodOntQ/132","comment_is_top":false,"comment_ctime":1665847653,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1665847653","product_id":100017301,"comment_content":"思考题思路： 遍历2 最长字段为1 记录 f[1] = 2 ，9 f[2] = 9 , 3 f[2] = 2, 6 f[3] = 6 5时 f[3] = 5 ，<br>使用一个数组记录当前长度和最小值， i表示当前值， j表示当前最长子串结尾最小值， <br>如果 i &gt; f[j-1] f[j] = i 否则 i &gt; f[j-2] &amp;&amp; i &lt; f[j-1] f[j-1] = i","like_count":0},{"had_liked":false,"id":348357,"user_name":"H.H","can_delete":false,"product_type":"c1","uid":2668479,"ip_address":"","ucode":"3C0BB1E2A3EC51","user_header":"https://static001.geekbang.org/account/avatar/00/28/b7/bf/815f0ec6.jpg","comment_is_top":false,"comment_ctime":1655018056,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655018056","product_id":100017301,"comment_content":"已经不知道用的什么方法了<br>def max_asc_list_len(l_list:list):<br>    sub_list = [[l_list[0]]]<br>    <br>    for i in range(1,len(l_list)):<br>        min_li_0 = sub_list[0][0]<br>        for li in sub_list:<br>            min_li_0 = min(min_li_0,li[0])<br>            if l_list[i] &gt; li[-1]:<br>                li.append(l_list[i])<br>            else:<br>                if len(li) == 1:<br>                    li[0] = l_list[i]<br>                else:<br>                    li[-1] = l_list[i] if l_list[i] &gt; li[-2] else li[-1]<br>        <br>        if l_list[i] &lt; min_li_0:<br>            sub_list.append([l_list[i]])<br><br>    max_len = 0<br>    for sub in sub_list:<br>        max_len = max(max_len,len(sub))<br>    return max_len","like_count":0},{"had_liked":false,"id":344069,"user_name":"scarlett🦌","can_delete":false,"product_type":"c1","uid":1304906,"ip_address":"","ucode":"C725D8EC73E3D7","user_header":"https://static001.geekbang.org/account/avatar/00/13/e9/4a/db2252f6.jpg","comment_is_top":false,"comment_ctime":1651220794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651220794","product_id":100017301,"comment_content":"我没理解初始化状态表的部分，为啥相等是i ，相等不应该是min_dist【i-1】[0]吗","like_count":0},{"had_liked":false,"id":333880,"user_name":"pwx","can_delete":false,"product_type":"c1","uid":2766400,"ip_address":"","ucode":"D55B7559742C82","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/VbKKaljzqIW78zG5qxc0X3PbFDxaA4kbyTibIDsKD3p6aaTmPSuib4l1RdOI6jZxYSpHowzeibt3EsyEh6CvQKFSw/132","comment_is_top":false,"comment_ctime":1644569731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644569731","product_id":100017301,"comment_content":"基础篇完结撒花，虽然还没完全吃透，但是还是一件值得庆祝的事情<br>","like_count":0},{"had_liked":false,"id":330145,"user_name":"布小丁","can_delete":false,"product_type":"c1","uid":2577268,"ip_address":"","ucode":"3EDD7C5A0E4C8C","user_header":"https://static001.geekbang.org/account/avatar/00/27/53/74/17c18b44.jpg","comment_is_top":false,"comment_ctime":1641814288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641814288","product_id":100017301,"comment_content":"最后一节基础课终于看完了，因为平时要上班，看完一节我也会做一些题巩固，所以耗费了半年时间才学完，作为前端开发掌握这些应该已经够了，完结撒花！！","like_count":0},{"had_liked":false,"id":324831,"user_name":"黑色秀气","can_delete":false,"product_type":"c1","uid":1158897,"ip_address":"","ucode":"E7B791C84FB382","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/f1/8ee312d4.jpg","comment_is_top":false,"comment_ctime":1638674474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638674474","product_id":100017301,"comment_content":"看文中 直接操作 target 字符串，虽然删除 b[j] 等效于 在 a[i] 中插入 b[j]，但是思路是不符合题意的？<br><br>「可以删除 b[j]，然后递归考察 a[i]和 b[j+1]；」<br>「可以在 b[j]前面添加一个跟 a[i]相同的字符，然后递归考察 a[i+1]和 b[j]；」","like_count":0},{"had_liked":false,"id":324469,"user_name":"leo","can_delete":false,"product_type":"c1","uid":1073657,"ip_address":"","ucode":"614A2F77A6B553","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/1mQHJjAyFjypbiaheQ9hDWRoictrVn2VggIZiaPLm50UiatHu9NqExMicScs9f7zYicbTQPliatTT18hr4csibRh4ARYbA/132","comment_is_top":false,"comment_ctime":1638448752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638448752","product_id":100017301,"comment_content":"思考题：<br>public int lengthOfLIS(int[] nums) {<br>      int[] dp = new int[nums.length];<br>      int max = 1;<br>      for (int i = 0; i &lt; nums.length; i++) {<br>        dp[i] = 1;<br>        for (int j = 0; j &lt; i; j++) {<br>          if (nums[i] &gt; nums[j]) dp[i] = Math.max(dp[j] + 1, dp[i]);<br>        }<br>        max = Math.max(max, dp[i]);<br>      }<br>      return max;<br>    }","like_count":0},{"had_liked":false,"id":314955,"user_name":"扁扁圆圆","can_delete":false,"product_type":"c1","uid":1116671,"ip_address":"","ucode":"CE9B07D930BF78","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ZwLEEpglswe8uzYj4W6ZVxx0W0OdicjicFzkha4O99wZWGRXqOTF1LO8SsJaBicCXugIQhn8BQicVoTcDJic82RbwDg/132","comment_is_top":false,"comment_ctime":1633611490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633611490","product_id":100017301,"comment_content":"满减那个问题，改造下，如果是n个商品，每满200减20，最终要把这n个商品全买了，怎么组合这n个商品，得到最大数量（假设这个数是max）的大于等于200的组合，就是拆开max个子订单，可以优惠max*20元。这个问题，能用动态规划解决吗？我自己推理了半天，感觉不能，也想不到其他解决办法","like_count":0},{"had_liked":false,"id":314212,"user_name":"Geek_4051d2","can_delete":false,"product_type":"c1","uid":2660938,"ip_address":"","ucode":"F439D59087C990","user_header":"","comment_is_top":false,"comment_ctime":1632901505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632901505","product_id":100017301,"comment_content":"思考题，状态转移方程f(x) = f(x-1)+1, x&gt; x-1; f(x) = f(x-1) x&lt;=x-1","like_count":0},{"had_liked":false,"id":303953,"user_name":"小Y","can_delete":false,"product_type":"c1","uid":1739621,"ip_address":"","ucode":"24A43BB71805F8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8b/65/0f1f9a10.jpg","comment_is_top":false,"comment_ctime":1627119857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627119857","product_id":100017301,"comment_content":"终于学到了这里，但是发现现实中好多问题 还是头皮发麻，傻傻分不清楚，我的妈呀，还需要练习。。。<br><br>最长公共子串<br>最长公共子序列<br>最长无重复子串<br>最长重复子序列<br>无重复子串<br>重复子串<br>最长回文子串<br>最长上升子序列 ","like_count":0},{"had_liked":false,"id":299405,"user_name":"Geek_6ab543","can_delete":false,"product_type":"c1","uid":1463375,"ip_address":"","ucode":"28B5F1C24CFDB4","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcv7bwuNrRfTax8PbT7MONAZVUHwenpbibQppk8YwxMUJXGQ8bICEAcTqFGzwJF93Tmntao1qCq7Q/132","comment_is_top":false,"comment_ctime":1624612118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624612118","product_id":100017301,"comment_content":"思路一样，但貌似不用那么复杂吧。。。<br>int fun(String a, String b) {<br>        &#47;&#47; dp[i][j] 表示字符串a[0...i]和b[0...j]的最大公共子串长度<br>        &#47;&#47; 状态转移方程：a[i]==b[j] -&gt; dp[i][j] = dp[i-1][j-1] + 1;<br>        &#47;&#47; a[i] != b[j] -&gt; max(dp[i-1][j], dp[i][j-1])<br>        int n1 = a.length(), n2 = b.length();<br>        int[][] dp = new int[n1][n2];<br>        &#47;&#47; 初始化0值<br>        dp[0][0] = a.charAt(0) == b.charAt(0) ? 1 : 0;<br>        for (int i=1; i&lt;n1; i++) {<br>            dp[i][0] = Math.max(dp[i-1][0], a.charAt(i) == b.charAt(0) ? 1 : 0);<br>        }<br>        for (int i=1; i&lt;n2; i++) {<br>            dp[0][i] = Math.max(dp[0][i-1], a.charAt(0) == b.charAt(i) ? 1 : 0);<br>        }<br><br>        &#47;&#47; 推进下去<br>        for (int i = 1; i &lt; n1; i++) {<br>            for (int j = 1; j &lt; n2; j++) {<br>                if (a.charAt(i) == b.charAt(j)) {<br>                    dp[i][j] = dp[i - 1][j - 1] + 1;<br>                } else {<br>                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);<br>                }<br>            }<br>        }<br>        return dp[n1-1][n2-1];<br>    }","like_count":0},{"had_liked":false,"id":299236,"user_name":"o my love","can_delete":false,"product_type":"c1","uid":1243331,"ip_address":"","ucode":"307601ACAC5DCC","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/c3/1d557354.jpg","comment_is_top":false,"comment_ctime":1624522729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624522729","product_id":100017301,"comment_content":"莱文斯坦可以在空间0(n)，实现吗","like_count":0},{"had_liked":false,"id":298110,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623916045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623916045","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":296781,"user_name":"徐改","can_delete":false,"product_type":"c1","uid":1298380,"ip_address":"","ucode":"82276A584AC602","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","comment_is_top":false,"comment_ctime":1623158238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623158238","product_id":100017301,"comment_content":"Golang版，回溯暴力法求出最长递增子串：<br>var maxSequence = &quot;&quot;<br>&#47;&#47; 调用方式 maxSeq(0, &quot;2936517&quot;, &quot;2&quot;)<br>func longestIncreaseSubString(k int, numStr string, maxNumSeq string) {<br>\tif k == len(numStr) - 1 {<br>\t\tif len(maxNumSeq) &gt;= len(maxSequence) {<br>\t\t\tmaxSequence = maxNumSeq<br>\t\t}<br>\t}<br>\tfor i := k + 1; i &lt; len(numStr); i++ {<br>\t\tright, _ := strconv.Atoi(string(numStr[i]))<br>\t\tleft, _ := strconv.Atoi(string(numStr[k]))<br>\t\tif right &gt; left {<br>\t\t\tlongestIncreaseSubString(i, numStr, maxNumSeq + string(numStr[i]))<br>\t\t}<br>\t}<br>}<br><br>func TestLongestIncreaseSubString(t *testing.T) {<br>\tnumStr := &quot;2936517&quot;<br>\tmaxNumSeq := &quot;&quot;<br>\tfor i := 0; i &lt; len(numStr); i++ {<br>\t\tmaxNumSeq = string(numStr[i])<br>\t\tlongestIncreaseSubString(i, numStr, maxNumSeq)<br>\t}<br>\tfmt.Println(maxSequence)<br>}","like_count":0},{"had_liked":false,"id":287785,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1618149298,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618149298","product_id":100017301,"comment_content":"课后思考题<br><br>        if(nums.length == 0) return 0;<br>        int[] dp = new int[nums.length];<br>        &#47;&#47;每个元素和自身<br>        Arrays.fill(dp, 1);<br>        for (int i =0; i&lt; nums.length; i++){<br>            for (int j =0; j&lt; i; j++){<br>                if(nums[j] &lt; nums[i]) {<br>                    dp[i] = Math.max(dp[i], dp[j] + 1);<br>                }<br>            }<br>        }<br><br>        return Arrays.stream(db).max().getAsInt();","like_count":0},{"had_liked":false,"id":285325,"user_name":"左耳朵东","can_delete":false,"product_type":"c1","uid":1160678,"ip_address":"","ucode":"60134ACF12BB52","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","comment_is_top":false,"comment_ctime":1616741233,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616741233","product_id":100017301,"comment_content":"这是个分阶段决策最优解模型，那就用分阶段的思路来理解。<br>问这样一个问题，怎么能到达状态 (i,j)？<br>应该先把它所有可能的前一阶段的状态都找出来，分别计算它们到状态 (i,j) 的编辑距离，从中选择一个最短的作为 min_dist(i,j)。","like_count":0,"discussions":[{"author":{"id":1160678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","nickname":"左耳朵东","note":"","ucode":"60134ACF12BB52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361776,"discussion_content":"具体来说，首先，要想到达状态 (i,j) 有且仅有三种途径：\n1、先计算到 (i-1,j) 的最短距离，假设是 m，再计算从 (i-1,j) 到 (i,j) 的距离，这时删掉字符 a[i] 就行，所以是 m+1;\n2、先计算到 (i,j-1) 的最短距离，假设是 n，再计算从 (i,j-1) 到 (i,j) 的距离，这时删掉字符 b[j] 就行，所以是 n+1;\n3、先计算到 (i-1,j-1) 的最短距离，假设是 c，再计算从 (i-1,j-1) 到 (i,j) 的距离，这时分两种情况：\n i) 如果 a[i]!=b[j]，把 a[i] 替换成 b[j] 或者把 b[j] 替换成 a[i] 就行，所以是 c+1;\n ii) 如果 a[i]==b[j]，不需要做任何编辑，所以是 c。\n\n最后从这三种途径中挑选编辑距离最小的一种做为 (i,j) 的最终结果，也就是：\nmin_dist(i,j) = min(min_dist(i-1,j)+1, min_dist(i,j-1)+1, min_dist(i-1,j-1)+int(a[i]!=b[j]))\n\n或者写成更好理解的形式：\nif a[i]!=b[j]:\n min_dist(i,j) = min(min_dist(i-1,j)+1, min_dist(i,j-1)+1, min_dist(i-1,j-1)+1)\nelse:\n min_dist(i,j) = min(min_dist(i-1,j)+1, min_dist(i,j-1)+1, min_dist(i-1,j-1))","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616750812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281862,"user_name":"爬坡的蚂蚁","can_delete":false,"product_type":"c1","uid":1463578,"ip_address":"","ucode":"FBA950CDCE6723","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/1a/c5f033a0.jpg","comment_is_top":false,"comment_ctime":1614928982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614928982","product_id":100017301,"comment_content":"课后思考题思路：<br>将数字序列排序，得到一个新的数字序列；<br>然后求出新的数字序列与旧数字序列的最长公共子串长度；<br>这个长度就是递增子序列长度","like_count":0},{"had_liked":false,"id":278714,"user_name":"骑着驴读着书的谢小夕","can_delete":false,"product_type":"c1","uid":1625340,"ip_address":"","ucode":"56F0A469B630A2","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","comment_is_top":false,"comment_ctime":1613223646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613223646","product_id":100017301,"comment_content":"思考题： <br><br>递推公式：对于 0 &lt;= j &lt; i ，<br><br>```<br>f(i) = max{<br>    f(j)+ 1, if arr[j] &lt; arr[i],<br>    f(j), else<br>}<br>```<br><br><br>public int longestIncreaseSubArrayDP(int[] array) {<br>    if (array.length &lt; 2) return array.length;<br>    int[] state = new int[array.length];<br>    state[0] = 1;<br>    for (int i = 1; i &lt; state.length; i++) {<br>        int max = 0;<br>\t\t<br>\t\t int max1 = 0;<br>\t\tbool bIsFind = false;<br>        for (int j = 0; j &lt; i; j++) {<br>            if (state[j] &gt; max1) max1 = state[j]; &#47;&#47;  历史最大值<br>\t\t\t<br>            if (array[j] &lt; array[i]) { &#47;&#47; i 可以加入当前队列<br>\t\t\t\tif (state[j] &gt; max) max = state[j]; &#47;&#47;  取 当前 最大的组合值<br>\t\t\t\tbIsFind = true;<br>            }<br>        }<br>\t\t<br>\t\tint tmpMax = 0;<br>\t\tif(bIsFind)<br>\t\t\ttmpMax = max + 1;  &#47;&#47; 加入一种新的组合<br>\t\telse<br>\t\t\ttmpMax = max1;    &#47;&#47; 继承前面的最大序列的值<br>\t\tstate[i] = tmpMax;<br>    }<br>\t<br>\t&#47;&#47; 取最大值即可<br>    return state[state.length - 1];<br>}","like_count":0},{"had_liked":false,"id":275617,"user_name":"石小","can_delete":false,"product_type":"c1","uid":1781893,"ip_address":"","ucode":"4258C686F289A6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","comment_is_top":false,"comment_ctime":1611623214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611623214","product_id":100017301,"comment_content":"https:&#47;&#47;www.cs.usfca.edu&#47;~galles&#47;visualization&#47;Algorithms.html 这个链接学习算法特别多，编辑看到的话麻烦置下顶","like_count":0},{"had_liked":false,"id":272720,"user_name":"morse","can_delete":false,"product_type":"c1","uid":1001529,"ip_address":"","ucode":"E22E5FA291B9AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/39/4e95e7b9.jpg","comment_is_top":false,"comment_ctime":1610252639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610252639","product_id":100017301,"comment_content":"<br>&#47;&#47; 回溯解决方法<br>&#47;&#47; nums: 给定数字序列<br>&#47;&#47; 返回值: 最大子序列长度<br>func GetMaxSub1(nums []int) int {<br>\tlength := len(nums)<br>\treturn g1(nums, length, 0, 1)<br>}<br><br>func g1(nums []int, numsLength, beginIndex, subLength int) int {<br>\tif beginIndex &gt;= numsLength {<br>\t\treturn subLength<br>\t}<br><br>\tvalue := subLength<br><br>\tfor i := beginIndex + 1; i &lt; len(nums); i++ {<br>\t\tif nums[i] &gt; nums[beginIndex] {<br>\t\t\tv := g1(nums, numsLength, i, subLength+1)<br>\t\t\tif v &gt; value {<br>\t\t\t\tvalue = v<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn value<br>}<br><br>&#47;&#47; 动态规划解决方法<br>&#47;&#47; nums: 给定数字序列<br>&#47;&#47; 返回值: 最大子序列长度<br>func GetMaxSub2(nums []int) int {<br>\tlength := len(nums)<br>\tstatus := make([]int, length)<br>\tfor i := range status {<br>\t\tstatus[i] = 1<br>\t}<br><br>\tfor i := 0; i &lt; length; i++ {<br><br>\t\t&#47;&#47; 因为是找递增序列, 所以只需要比较当前元素之后的值<br>\t\t&#47;&#47; 而比当前值小元素, 对应status中的值保持不变<br>\t\tfor j := i + 1; j &lt; length; j++ {<br>\t\t\tif nums[i] &lt; nums[j] &amp;&amp; status[i] == status[j] { &#47;&#47; status[i] == status[j] 保证必须在一个层级才能下钻<br>\t\t\t\tstatus[j]++<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\t&#47;&#47; 取status中最大的值<br>\tmax := math.MinInt64<br>\tfor i := range status {<br>\t\tif status[i] &gt; max {<br>\t\t\tmax = status[i]<br>\t\t}<br>\t}<br>\treturn max<br>}","like_count":0},{"had_liked":false,"id":269112,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1608529884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608529884","product_id":100017301,"comment_content":"根据上节的思路：可以很方便写出递归的解法。<br><br><br>    static char[]a = &quot;mitcmu&quot;.toCharArray();<br>    static char[]b = &quot;mtacnu&quot;.toCharArray();<br>    static int n = a.length;<br>    static int m = b.length;<br>    &#47;**<br>     * 递归方程解法<br>     * @param i<br>     * @param j<br>     * @return<br>     * 调用：dplwst(n-1,m-1)<br>     *&#47;<br>    public static int dplwst(int i,int j){<br>        if(i==0 &amp;&amp; j==0){<br>            return a[0]==b[0]?0:1;<br>        }<br><br>        if(i==0){<br>            return dplwst(0,j-1)+1;<br>        }<br><br>        if(j==0){<br>            return dplwst(i-1,0)+1;<br>        }<br><br>        if(a[i]==b[j]){<br>            return min(dplwst(i-1,j)+1,dplwst(i,j-1)+1,dplwst(i-1,j-1));<br>        }else{<br>            return min(dplwst(i-1,j)+1,dplwst(i,j-1)+1,dplwst(i-1,j-1)+1);<br>        }<br>    }","like_count":0},{"had_liked":false,"id":266628,"user_name":"毛启圣","can_delete":false,"product_type":"c1","uid":1330056,"ip_address":"","ucode":"233DA95ED28C11","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/88/272b4562.jpg","comment_is_top":false,"comment_ctime":1607420509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607420509","product_id":100017301,"comment_content":" 排序 + 最大公用子串","like_count":0},{"had_liked":false,"id":264219,"user_name":"杨","can_delete":false,"product_type":"c1","uid":1971269,"ip_address":"","ucode":"7EFEFE285975C6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/oltLEqTrmHm2aJP99BK6tHu5h7hp4aj08wR5Wt6H31iadFduDAVvjYKmhQ2nvGbLV3lkVdiat2GRasgWXoJeTibUg/132","comment_is_top":false,"comment_ctime":1606382840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606382840","product_id":100017301,"comment_content":"func minDistance(word1 string, word2 string) int {<br>\tla,lb=len(word1),len(word2)<br>\tmin=math.MaxInt32<br>\tm=map[string]bool{}<br>\tsearch(0,0,0,word1,word2)<br>\treturn min<br>}<br><br>func search(ai, bi ,count int,a,b string)  {<br>\tfmt.Println(ai,&quot;_&quot;, bi,&quot;_&quot; ,count)<br>\tif m[strconv.Itoa(ai)+&quot;_&quot;+strconv.Itoa(bi)+&quot;_&quot;+strconv.Itoa(count)]{<br>\t\treturn<br>\t}<br>\tm[strconv.Itoa(ai)+&quot;_&quot;+strconv.Itoa(bi)+&quot;_&quot;+strconv.Itoa(count)]=true<br>\tif ai&gt;=la{<br>\t\tcount=count+lb-bi<br>\t\tif min&gt;count{<br>\t\t\tmin=count<br>\t\t}<br>\t\treturn<br>\t}<br>\tif bi&gt;=lb{<br>\t\tcount=count+la-ai<br>\t\tif min&gt;count{<br>\t\t\tmin=count<br>\t\t}<br>\t\treturn<br>\t}<br>\tif a[ai]==b[bi]{<br>\t\tsearch(ai+1,bi+1,count,a,b)<br>\t}else{<br>\t\t&#47;&#47;移除bi<br>\t\tsearch(ai,bi+1,count+1,a,b)<br>\t\t&#47;&#47;移除ai<br>\t\tsearch(ai+1,bi,count+1,a,b)<br>\t\t&#47;&#47;aibi替换<br>\t\tsearch(ai+1,bi+1,count+1,a,b)<br>\t}<br>}<br>老师 在力扣还是超时了","like_count":0},{"had_liked":false,"id":262302,"user_name":"拉布拉多","can_delete":false,"product_type":"c1","uid":1204353,"ip_address":"","ucode":"637A88D9F29F57","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","comment_is_top":false,"comment_ctime":1605687480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605687480","product_id":100017301,"comment_content":"min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))--?为什么是这个？相等时，不应该是min(min_edist(i-1,j), min_edist(i,j-1)，min_edist(i-1,j-1))吗？不然怎么和前面的分析和代码一致？","like_count":0},{"had_liked":false,"id":261479,"user_name":"橙子橙","can_delete":false,"product_type":"c1","uid":2249227,"ip_address":"","ucode":"CD51367A14D955","user_header":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","comment_is_top":false,"comment_ctime":1605351083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605351083","product_id":100017301,"comment_content":"&#47;* dp[i][j] 标示word1中前i串 变换到 word2中前j的串 所需的最短操作数.<br>     * 增: dp[i][j] = dp[i][j-1] + 1    &#47;&#47;向右走, word1没变的情况下还和word2下一个串一样了, 只能增<br>     * 删: dp[i][j] = dp[i-1][j] + 1    &#47;&#47;向下走, word1下一个串和word2一样了, 只能是删<br>     * 改: dp[i][j] = dp[i-1][j-1] + 1  &#47;&#47;斜着走, word1和word2串同时到下一个位置且一样了, 只能是本来就相同&#47;修改<br>     * *&#47;","like_count":0},{"had_liked":false,"id":253456,"user_name":"zsx","can_delete":false,"product_type":"c1","uid":1344470,"ip_address":"","ucode":"6DB843FDEE959B","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/d6/cd06e7b3.jpg","comment_is_top":false,"comment_ctime":1602744010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602744010","product_id":100017301,"comment_content":"老师好，我想问下在求解最长公共子串长度的状态转移方程式中  <br>如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；<br>这里的 max_lcs(i-1, j) 和 max_lcs(i, j-1) 不用+1 吗","like_count":0},{"had_liked":false,"id":252418,"user_name":"子微","can_delete":false,"product_type":"c1","uid":1543384,"ip_address":"","ucode":"95A15B841AAE61","user_header":"https://static001.geekbang.org/account/avatar/00/17/8c/d8/a74d59a3.jpg","comment_is_top":false,"comment_ctime":1602296358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602296358","product_id":100017301,"comment_content":"思考题python版：<br>def longest_up(ser):<br>    dp = [1] * len(ser)<br>    for i in range(1, len(ser)):<br>        for k in range(i):<br>            if ser[i] &gt; ser[k]:<br>                dp[i] = max(dp[i], dp[k]+1)<br>    return max(dp)<br>关键就是dp的元素是“以ser[i]结尾的最长上升子序列的长度”，想到这一点题目就迎刃而解。","like_count":0},{"had_liked":false,"id":248838,"user_name":"哈哈哈","can_delete":false,"product_type":"c1","uid":1250922,"ip_address":"","ucode":"8AC20A1C9C7DF8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","comment_is_top":false,"comment_ctime":1600329722,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600329722","product_id":100017301,"comment_content":"课后作业：<br><br>&#47;&#47; 回溯探索<br>var maxDist = math.MinInt64<br>var maxSeq []int<br>func LISBackTrace(a []int, i, j,  n, dist int, seq []int) {<br>\tif i == n {<br>\t\tif dist &gt; maxDist {<br>\t\t\tmaxDist = dist<br>\t\t\tmaxSeq = seq<br>\t\t}<br>\t\treturn<br>\t}<br><br>\tif j == -1 || a[i] &gt; a[j] {<br>\t\tnSeq := append(seq, a[i])<br>\t\tLISBackTrace(a, i+1, i, n, dist+1, nSeq)<br>\t}<br>\tLISBackTrace(a, i+1, j, n, dist, seq)<br>}<br><br>&#47;&#47; 动态规划解法<br>func LISDP(a []int, n int) int {<br>\tif n &lt; 0 || len(a) &lt;= 0 {<br>\t\treturn 0<br>\t}<br><br>\tif n == 1 {<br>\t\treturn 1<br>\t}<br><br>\t&#47;&#47; 递推数组<br>\tmaxlis := make([]int, n)<br>\t&#47;&#47; 选择路径记录<br>\toptRecord := make([]int, n)<br><br>\tmaxlis[0] = 1<br>\toptRecord[0] = -1<br><br>\tfor i := 1; i &lt; n; i++ {<br>\t\tv := 0<br>\t\tpre := -1<br>\t\tfor k := 0; k &lt; i; k++ {<br>\t\t\tif a[i] &gt; a[k] &amp;&amp; maxlis[k] &gt; v {<br>\t\t\t\t&#47;&#47;v = ch24.Max(v, maxlis[k])<br>\t\t\t\tv = maxlis[k]<br>\t\t\t\tpre = k<br>\t\t\t}<br>\t\t}<br>\t\tmaxlis[i] = v + 1<br>\t\toptRecord[i] = pre<br>\t}<br><br>\tvar k = 0<br>\tfor i := 1 ; i &lt; n; i++ {<br>\t\tif maxlis[i] &gt; maxlis[k] {<br>\t\t\tk = i<br>\t\t}<br>\t\t&#47;&#47;maxDist = ch24.Max(maxlis[i-1], maxlis[i])<br>\t}<br><br>\tpath := make([]int, 0, n)<br>\tfor t := k; t &gt;= 0;  {<br>\t\tpath = append(path, a[t])<br>\t\tt = optRecord[t]<br>\t}<br><br>\tfor i := len(path)-1; i &gt;= 0; i-- {<br>\t\tfmt.Print(path[i], &quot; &quot;)<br>\t}<br>\tfmt.Println()<br><br>\treturn maxlis[k]<br>}","like_count":0},{"had_liked":false,"id":247255,"user_name":"TANMIYOO","can_delete":false,"product_type":"c1","uid":1375256,"ip_address":"","ucode":"BC3556131D4D61","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/18/8e69f7cf.jpg","comment_is_top":false,"comment_ctime":1599641786,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599641786","product_id":100017301,"comment_content":"练习题:<br>状态转移方程   f(i)= if(a[i-1]&lt;a[i]){ f(i-1)+1 } else {f(i-1)}<br>public int maxLength(int[] array) {<br>        if (array.length &lt; 2) {<br>            return array.length;<br>        }<br>        int[] state = new int[array.length];<br>        state[0] = 1;<br>        for (int i = 1; i &lt; array.length; i++) {<br>            if (array[i - 1] &lt; array[i]) {<br>                state[i] = state[i - 1] + 1;<br>            } else {<br>                state[i] = state[i - 1];<br>            }<br>        }<br>        int result = 0;<br>        for (int i = 0; i &lt; state.length; i++) {<br>            if (state[i] &gt; result) {<br>                result = state[i];<br>            }<br>        }<br>        return result;<br>    }","like_count":0},{"had_liked":false,"id":245988,"user_name":"小时候可鲜啦","can_delete":false,"product_type":"c1","uid":1050777,"ip_address":"","ucode":"C88B3EDF758230","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","comment_is_top":false,"comment_ctime":1599125795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599125795","product_id":100017301,"comment_content":"在最长公共子串长度的状态转移方程中，文中写道：如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；","like_count":0},{"had_liked":false,"id":235728,"user_name":"Tom.G","can_delete":false,"product_type":"c1","uid":1206034,"ip_address":"","ucode":"7929B45C1A51F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/12/5c6eb568.jpg","comment_is_top":false,"comment_ctime":1595164472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595164472","product_id":100017301,"comment_content":"老师，初始化0行0列是怎么推导来的，没想明白，望指点，谢谢！","like_count":0},{"had_liked":false,"id":226666,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1592183014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592183014","product_id":100017301,"comment_content":"对于最小编辑距离的状态转移方程想了一个礼拜，总结了一下，希望王老师看看对不对：<br><br>递归代码的思路是，根据当前(i, j)是什么情况，决定编辑距离是否+1，以及下一步怎么走。<br>因此就有了<br>if a[i] == b[j]， 下一步(i+1, j+1) ，编辑距离不变<br>else (i+1, j) or (i, j+1) or (i+1, j+1) 三种走法，编辑距离+1<br><br>状态转移方程的思路不一样，它不是看a[i] ?= b[j] 来决定下一步走法，而是三种走法都会尝试。然后看前一步的走法（前一个状态-&gt;当前状态）是否增加编辑距离，这个是和递归代码的重要区别。<br><br>如果前一步是这么走的 (i-1, j) -&gt; (i, j) 那么编辑距离肯定+1。<br>同理如果前一步是这么走的 (i, j-1) -&gt; (i, j) ，编辑距离也肯定 +1。<br><br>你会问如果a[i]  != b[j] 不是会漏掉给编辑距离+1吗？这个不用担心，后一步的三种走法里的前两种 (i+1, j), (i, j+1) 会把这个编辑距离的+1给补上。<br>再来讲第三种走法，如果后一步采用第三种走法 (i+1, j+1)，能不能根据走法来把编辑距离+1呢？这个还真不能。因为这种走法有两种可能，a[i] == b[j] 编辑距离不变，a[i] != b[j] 做了替换编辑距离+1。<br>所以对于(i+1, j+1)这种走法要特殊处理一下，如果 a[i] != b[j] 那么要把编辑距离+1给提前补上。<br><br>因此就有了状态转移方程<br><br>if a[i] == b[j]<br>  minEdist = min(minEdist(i-1, j) +1, minEdist(i, j-1) +1, minEdist(i-1, j-1))<br>else<br>  minEdist = min(minEdist(i-1, j) +1, minEdist(i, j-1) +1, minEdist(i-1, j-1) + 1)<br><br>","like_count":0},{"had_liked":false,"id":222723,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1590899139,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1590899139","product_id":100017301,"comment_content":"在回溯法计算莱温斯坦距离的时候，一开始我没有想到，在字符不等的时候，需要分成 3 种情况，以为计算其中一种，或者之多两种即可，思考不够周全，或者说缺乏经验。<br><br>lwstBT(i + 1, j, edist + 1); &#47;&#47; 删除 a[i] 或者 b[j] 前添加一个字符<br>lwstBT(i, j + 1, edist + 1); &#47;&#47; 删除 b[j] 或者 a[i] 前添加一个字符<br>lwstBT(i + 1, j + 1, edist + 1); &#47;&#47; 将 a[i] 和 b[j] 替换为相同字符<br><br>如果这里没有想明白，后面的状态转移方程，或者说动态规划，也就无从谈起了。<br><br>计算莱温斯坦距离的状态转移表，一开始没看明白，而一旦结合状态转移方程看懂了，填表过程就显得比较简单了。<br><br>在计算最长公共子串的时候，一开始没有想清楚，为什么在 a[i] == a[j] 的时候，求最大值并没有给 maxlcs[i-1][j] 和 maxlcs[i][j-1] 加 1。<br><br>if (a[i] == b[j]) maxlcs[i][j] = max(maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]+1);<br><br>后来写两个字符串，然后在纸上画一下表格也就清楚了。","like_count":0},{"had_liked":false,"id":221558,"user_name":"MickeyW","can_delete":false,"product_type":"c1","uid":1376714,"ip_address":"","ucode":"4D2AEB20A34E1C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEK4rOhXRjMHbgRVtogiaEt93ia2lQDwtgxic5YBicHNIJFK9k0LibxTwLjSH1NzjEsUTiciawsCvaASZB7Ag/132","comment_is_top":false,"comment_ctime":1590540062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590540062","product_id":100017301,"comment_content":"最长递增子序列<br>&#47;**<br> * @param {number[]} nums<br> * @return {number}<br> * dp[i]: nums中前i 个最长上升子序列长度<br> * for j in range(0,i) dp[i] = max(dp[j]+1,  dp[i]) if nums[i] &lt; nums[j]<br> *&#47;<br>var lengthOfLIS = function(nums) {<br>    if(nums.length === 0) return 0;<br>    let dp = new Array(nums.length).fill(1)<br>    for(let i = 0; i &lt; nums.length; i++) {<br>        for (let j = 0; j &lt; i; j++) {<br>            if(nums[j] &lt; nums[i]) <br>                dp[i] = Math.max(dp[i], dp[j] +1)<br>        }<br>    }<br>    const res = dp.sort((a,b) =&gt; a - b)<br>    return res[nums.length - 1];<br>};","like_count":0},{"had_liked":false,"id":221245,"user_name":"Join","can_delete":false,"product_type":"c1","uid":1014873,"ip_address":"","ucode":"20F51EFFD8FEDE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/59/dc9bbb21.jpg","comment_is_top":false,"comment_ctime":1590455361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590455361","product_id":100017301,"comment_content":"哇塞，开心啊，看懂了老师写的DP了。","like_count":0},{"had_liked":false,"id":220232,"user_name":"7","can_delete":false,"product_type":"c1","uid":1114093,"ip_address":"","ucode":"10A6E57A027D42","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","comment_is_top":false,"comment_ctime":1590210095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590210095","product_id":100017301,"comment_content":"我看到有一个同学提问：老师状态转移方程，当a[i] = b[j] 的时候，能否把 minDist[i][j] = min(minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]); 改写为 minDist[i][j] = minDist[i-1][j-1]; ？请求老师解答<br>作者回复: 当然不可以了，改写之后完全不对呢，你对比一下前后两个公式。<br><br>我的问题跟他一样，改写之后可以正常运行，状态表也是一样。我能理解这个 minDist[i][j] 要根据状态方程来进行推导。但是如果在 a[i] = b[j] 的时候，他肯定等于 minDist[i-1][j-1] 的值；这个推断我是根据回溯算法得到的。在回溯中，如果两个相等，距离没有产生变化。求老师解答一下。他不对在哪里？<br>我使用过 <br>mitcmumaa<br>mtacnumb<br><br>mccccc<br>mc<br><br>zzzz<br>zzz<br>计算都是正确的，且两种状态表都是一致的。<br>","like_count":0},{"had_liked":false,"id":220081,"user_name":"郭星","can_delete":false,"product_type":"c1","uid":1182219,"ip_address":"","ucode":"8A0F5DF80E0C61","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/0b/985d3800.jpg","comment_is_top":false,"comment_ctime":1590151549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590151549","product_id":100017301,"comment_content":"对于最长公共子串 状态转移公式中<br>当 a[i]==b[j]，那么：max_lcs(i, j)就等于：max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；<br>我认为max_lcs [i][j]的状态来源于 max_lcs[i-1][j],max_lcs[i][j-1],max_lcs[i-1][j-1] 这三种状态,当从这三种状态 转移为 max_lcs[i][j] 时由于 a[i]==b[j] 所以,三种状态都需要加1,然后获取最大的状态值 ;<br>对应的公式应该为: <br>当 a[i]==b[j]时<br>max_lcs(i, j) = max(max_lcs[i-1][j-1],max_lcs[i-1][j],max_lcs[i][j-1]) +1 ;","like_count":0},{"had_liked":false,"id":219271,"user_name":"jxon-H","can_delete":false,"product_type":"c1","uid":1897700,"ip_address":"","ucode":"D491FAB6A07A4A","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/e4/e7471344.jpg","comment_is_top":false,"comment_ctime":1589981037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589981037","product_id":100017301,"comment_content":"有个疑问，为什么只用只选择一个量化去纠正错误字串？如果先算相似度最高的，再算根据莱文斯坦距离最小的来选择字串，直觉上觉得会更接近正确的字串。还是我的这种想法是错的，还是有时间复杂度和空间复杂度的考量？请小争哥指正。<br>","like_count":0},{"had_liked":false,"id":218047,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1589703841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589703841","product_id":100017301,"comment_content":"状态：用一个一维数组记录每个数字以自己结尾的最长递增序列长度<br>状态转移函数：当前数字的最长递增序列长度是比自己小的数字对应的最长长度+1","like_count":0},{"had_liked":false,"id":217711,"user_name":"宁悦","can_delete":false,"product_type":"c1","uid":1901403,"ip_address":"","ucode":"68844C314FEEF8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/03/5b/3cdbc9fa.jpg","comment_is_top":false,"comment_ctime":1589594809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589594809","product_id":100017301,"comment_content":"看了三天的动态规划，终于对它有了一些了解，不再那么神秘，觉得一开始的时候写不出来转移方程，就回溯暴力解题，然后在优化找到转移方程，练的多了也许就一眼能看出来了。","like_count":0},{"had_liked":false,"id":208595,"user_name":"13714567600","can_delete":false,"product_type":"c1","uid":1151921,"ip_address":"","ucode":"8D23FD727C8E79","user_header":"https://static001.geekbang.org/account/avatar/00/11/93/b1/4de3aa61.jpg","comment_is_top":false,"comment_ctime":1587388182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587388182","product_id":100017301,"comment_content":"如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)如果：a[i]==b[j]，那么：min_edist(i, j)就等于：min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))<br> 这一段和状态图根本就对不上","like_count":0},{"had_liked":false,"id":205523,"user_name":"爱新觉罗老流氓","can_delete":false,"product_type":"c1","uid":1005661,"ip_address":"","ucode":"B13AC4DA358C15","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","comment_is_top":false,"comment_ctime":1586663594,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586663594","product_id":100017301,"comment_content":"我觉得初始化的 第4行 第0列 的值初始化错了。第0行初始化为 0,1,2,3,4,5 （横着看）没问题。但是第0列我觉得是初始化为 0,1,2,3,3,4（竖着看），而专栏给的图是 0,1,2,3,4,5 （竖着看）<br><br>是吗？","like_count":0,"discussions":[{"author":{"id":1005661,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","nickname":"爱新觉罗老流氓","note":"","ucode":"B13AC4DA358C15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229570,"discussion_content":"如果是 0,1,2,3,3,4 ，也仍然并没有影响后面其他行列的推导","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586666217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201664,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585817898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585817898","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":186375,"user_name":"shelldon","can_delete":false,"product_type":"c1","uid":1054598,"ip_address":"","ucode":"BF8FE102D6DD1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/86/416f772e.jpg","comment_is_top":false,"comment_ctime":1583831611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583831611","product_id":100017301,"comment_content":"1 0-1背包问题<br>2 0-1背包问题升级版<br>3 #0120 https:&#47;&#47;leetcode-cn.com&#47;problems&#47;triangle&#47;<br>4 #0064 https:&#47;&#47;leetcode-cn.com&#47;problems&#47;minimum-path-sum&#47;<br>5 #0322 https:&#47;&#47;leetcode-cn.com&#47;problems&#47;coin-change&#47;<br>6 #0072 https:&#47;&#47;leetcode-cn.com&#47;problems&#47;edit-distance&#47;<br>7 #1143 https:&#47;&#47;leetcode-cn.com&#47;problems&#47;longest-common-subsequence&#47;<br>8 #0674 https:&#47;&#47;leetcode-cn.com&#47;problems&#47;longest-continuous-increasing-subsequence&#47;","like_count":0},{"had_liked":false,"id":185290,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1583553810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583553810","product_id":100017301,"comment_content":"老师，同学们请问一下最长公共子串这里，为什么maxlcs[i-1][j]、maxlcs[i][j-1]不需要+1呢<br>if (a[i] == b[j]) <br>maxlcs[i][j] = max( maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]+1);","like_count":0},{"had_liked":false,"id":185154,"user_name":"一","can_delete":false,"product_type":"c1","uid":1603640,"ip_address":"","ucode":"BCC6241C4CC6D1","user_header":"https://static001.geekbang.org/account/avatar/00/18/78/38/da3959cc.jpg","comment_is_top":false,"comment_ctime":1583499902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583499902","product_id":100017301,"comment_content":"时间复杂度n*m","like_count":0},{"had_liked":false,"id":185056,"user_name":"HiAliens","can_delete":false,"product_type":"c1","uid":1690377,"ip_address":"","ucode":"70544FC1AB28FE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaSKMpyJEgOicOgEHLJUOMk8cCFuice5ytHyoC2KXOSBk1sv7ia0lMy1hSWpNaWGmxlXwdg3umcYS9w/132","comment_is_top":false,"comment_ctime":1583474008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583474008","product_id":100017301,"comment_content":"在状态表图示表示和代码实现中，min_edist[i][j] 表示的含义为：将a[i],a[j]这两个元素处理好，需要的最少操作次数，于回溯算法中的含义略有差别！！请注意！！<br>可以这么理解： 处理到a[i],b[j]这俩元素时，a[0：i-1], b[0：j-1]这俩数组一定是处理好了【需要注意的是“i”不一定等于“j”，什么意思呢，a、b两个数组的指针走的路程不一定相等。】，只有这两个数组处理好了，才会进行处理a[i],a[j]这两个元素。那么，“状态 (i, j) 可能从 (i-1, j)，(i, j-1)，(i-1, j-1) 三个状态中的任意一个转移过来。” 这句话中的三个状态翻译成代码，或者说用min_edist[i][j]表示，为min_edist这个二维数组中三个点：“min_edist(i-1,j), min_edist(i,j-1)，min_edist(i-1,j-1)”。从“min_edist(i-1,j), min_edist(i,j-1)” 到 “min_edist(i,j)”肯定执行了一步操作（无论是什么操作）“i-1”，“j-1”才能变成“i”，“j”【这里可能会有人不太明白，回到实际中的字符串，如何实现添加、删除、替换操作呢？从代码实现可以看出，没有这些操作，都是通过对索引的自增一来模拟实现的！！】，因此，不论a[i],b[j]这俩元素是否相同，minDist[i][j] = min(  minDist[i-1][j]+1, minDist[i][j-1]+1, “待定”）。<br>下面是对“待定”的分析，即a[i] == b[j]时，“待定” = minDist[i-1][j-1]，即a[i] ！= b[j]时，“待定” = minDist[i-1][j-1]+1：<br>若a[i] == b[j]，不需要采取任何操作，直接i，j同时增加1，变为a[i+1] ， b[j+1]，故minDist[i][j] = minDist[i+1][j+1]；<br>若a[i] ！= b[j]，想要到达a[i+1] ， b[j+1]的状态，必须采取某个操作（无论什么），故minDist[i][j] = minDist[i+1][j+1]+1","like_count":0},{"had_liked":false,"id":183617,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1583078391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583078391","product_id":100017301,"comment_content":"&#39;&#39;&#39;<br>求最大递增子序列算法：<br>(1)用一个辅助数组，数组中记录每个元素的前序元素，即在序列中位于该元素之前且小于该元素的元素，初始化所有元素的前序元素都为空；<br>(2)依次扫描序列中的每个元素<br>(3)把扫描到的当前元素都和序列中位于该元素之前的那些元素做比较，如果大于该元素的则忽略，小于该元素的则记录下来。<br>(4)从所有小于当前元素的元素中，取前序元素最多的那个元素记录下来，并将其前序元素及其本向都取过来作为当前元素的前序元素<br>(5)当所有元素扫描完成后，取前序元素最多的那个元素的所有前序元素加上其本身，即为最大递增子序列。<br>&#39;&#39;&#39;<br><br># 求最大递增子序列<br>def getIncSeq(seq):<br>#BEGIN<br><br>    # 记录各元素的前序元素<br>    preseq = {}<br>    maxinclen = 0 #最长递增子序列长度<br>    maxsub = None #具有最多前序元素的那个元素<br><br>    # 依次扫描序列中的各个元素<br>    for i in range(len(seq)):<br><br>        curr = seq[i]<br>        preseq.setdefault(curr,[])<br>        pre = None<br>        maxprelen = 0<br>    <br>        for j in range(i):<br>            if seq[j] &lt; curr:<br>                if len(preseq[seq[j]]) + 1 &gt; maxprelen:<br>                    maxprelen = len(preseq[seq[j]]) + 1<br>                    pre = seq[j]<br>        #end for j<br><br>        #把前序元素最多的那个元素及其前序元素一起合并到当前元素的前序元素集合中<br>        if pre is not None:<br>            preseq.setdefault(pre, [])<br>            preseq[curr] += preseq[pre]<br>            preseq[curr].append(pre)<br><br>        if len(preseq[curr]) &gt; maxinclen:<br>            maxinclen = len(preseq[curr])<br>            maxsub = curr<br>    #end for i<br><br>    # 返回递增子序列<br>    preseq[maxsub].append(maxsub)<br>    return preseq[maxsub]<br>#END<br><br># 主程序<br>def main():<br>#BEGIN<br>    print(&#39;序列：2，9，3，6，5，1，7&#39;)<br>    print(&#39;最长递增子序列：&#39;, &#39;,&#39;.join([str(x) for x in getIncSeq([2,9,3,6,5,1,7])]))<br><br>#END<br><br>if __name__ == &#39;__main__&#39;:<br>    main()<br>","like_count":0},{"had_liked":false,"id":180468,"user_name":"john-jy","can_delete":false,"product_type":"c1","uid":1116514,"ip_address":"","ucode":"6B5884409B52C9","user_header":"","comment_is_top":false,"comment_ctime":1582289169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582289169","product_id":100017301,"comment_content":"应该叫最长公共子序列吧","like_count":0},{"had_liked":false,"id":180418,"user_name":"pzy","can_delete":false,"product_type":"c1","uid":1415941,"ip_address":"","ucode":"55ED628BC11ABB","user_header":"https://static001.geekbang.org/account/avatar/00/15/9b/05/4f07d80d.jpg","comment_is_top":false,"comment_ctime":1582277221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582277221","product_id":100017301,"comment_content":"解题思路：<br>状态定义：<br><br>dp[i]dp[i] 的值代表 nums 前 ii 个数字的最长子序列长度。<br>转移方程： 设 j∈[0,i)j∈[0,i)，考虑每轮计算新 dp[i]dp[i] 时，遍历 [0,i)[0,i) 列表区间，做以下判断：<br><br>当 nums[i] &gt; nums[j]nums[i]&gt;nums[j] 时： nums[i]nums[i] 可以接在 nums[j]nums[j] 之后（此题要求严格递增），此情况下最长上升子序列长度为 dp[j] + 1dp[j]+1 ；<br>当 nums[i] &lt;= nums[j]nums[i]&lt;=nums[j] 时： nums[i]nums[i] 无法接在 nums[j]nums[j] 之后，此情况上升子序列不成立，跳过。<br>上述所有 1. 情况 下计算出的 dp[j] + 1dp[j]+1 的最大值，为直到 ii 的最长上升子序列长度（即 dp[i]dp[i] ）。实现方式为遍历 jj 时，每轮执行 dp[i] = max(dp[i], dp[j] + 1)dp[i]=max(dp[i],dp[j]+1)。<br>转移方程： dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)。<br><br><br>class Solution {<br>    public int lengthOfLIS(int[] nums) {<br>                if(nums.length == 0) return 0;<br>        int[] dp = new int[nums.length];<br>        int res = 0;<br>        Arrays.fill(dp, 1);<br>        for(int i = 0; i &lt; nums.length; i++) {<br>            for(int j = 0; j &lt; i; j++) {<br>                if(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1);<br>            }<br>            res = Math.max(res, dp[i]);<br>        }<br>        return res;<br>    }<br>}","like_count":0},{"had_liked":false,"id":178454,"user_name":"W.G.Ma","can_delete":false,"product_type":"c1","uid":1349798,"ip_address":"","ucode":"3518F2058023F4","user_header":"https://static001.geekbang.org/account/avatar/00/14/98/a6/41394d63.jpg","comment_is_top":false,"comment_ctime":1581692291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581692291","product_id":100017301,"comment_content":"最长公共子串状态方程可以改为<br>如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：max（max_lcs(i-1, j), max_lcs(i, j-1))；<br>","like_count":0},{"had_liked":false,"id":175650,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1580789683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580789683","product_id":100017301,"comment_content":"\tpublic int lengthOfLIS(int[] nums) {<br>\t\tint[] dp = new int[nums.length];<br>\t\tint len = 0;<br>\t\tfor (int x : nums) {<br>\t\t\tint index = Arrays.binarySearch(dp, 0, len, x);<br>\t\t\t<br>\t\t\tif (index &lt; 0) {<br>\t\t\t\tindex = -index - 1;<br>\t\t\t\t&#47;&#47;System.out.println(index);<br>\t\t\t}<br>\t\t\tdp[index] = x;<br>\t\t\t<br>\t\t\tif (index == len) {<br>\t\t\t\tlen++;<br>\t\t\t}<br><br>\t\t}<br><br>\t\treturn len;<br>\t}<br><br>","like_count":0},{"had_liked":false,"id":175037,"user_name":"晚空城旧心","can_delete":false,"product_type":"c1","uid":1472863,"ip_address":"","ucode":"5C6D22728C9380","user_header":"https://static001.geekbang.org/account/avatar/00/16/79/5f/8c9d0643.jpg","comment_is_top":false,"comment_ctime":1580534191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580534191","product_id":100017301,"comment_content":"思考题：<br><br>func lengthOfLIS(_ nums: [Int]) -&gt; Int {<br>    guard nums.count &gt; 0 else {<br>        return 0<br>    }<br>    <br>    var counts = [Int](repeating: 1, count: nums.count)<br>    var maxLen = 1<br>    <br>    for i in 1..&lt;nums.count {<br>        for j in 0..&lt;i {<br>            if nums[i] &gt; nums[j] {<br>                &#47;&#47; 累计当前位置之前的最大递增子序列<br>                counts[i] = max(counts[j] + 1, counts[i])<br>            }<br>            maxLen = max(counts[i], maxLen)<br>        }<br>    }<br>    print(counts)<br>    return maxLen<br>}<br><br>print(lengthOfLIS([1,3,6,7,9,4,10,5,6]))<br>print(lengthOfLIS([10,9,2,5,3,7,101,18]))","like_count":0},{"had_liked":false,"id":174944,"user_name":"晚空城旧心","can_delete":false,"product_type":"c1","uid":1472863,"ip_address":"","ucode":"5C6D22728C9380","user_header":"https://static001.geekbang.org/account/avatar/00/16/79/5f/8c9d0643.jpg","comment_is_top":false,"comment_ctime":1580470048,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580470048","product_id":100017301,"comment_content":"&#47;*<br> 我们有一个数字序列包含 n 个不同的数字，如何求出这个序列中的最长递增子序列长度？<br> <br> 比如 2, 9, 3, 6, 5, 1, 7 这样一组数字序列，它的最长递增子序列就是 2, 3, 5, 7，所以最长递增子序列的长度是 4。<br> *&#47;<br>func longestIncreasingSubsequence(_ data: [Int]) -&gt; Int {<br>    guard data.count &gt; 0 else {<br>        return 0<br>    }<br>    var counts = [Int](repeating: 0, count: data.count)<br>    counts[0] = 1 &#47;&#47; 初始化第一个数<br>    <br>    &#47;*<br>        如果当前数比前一个数小，递减<br>        max(i) = max(i - 1)<br>        <br>        如果当前数比前一个数大，递增<br>        max(i) = max(i - 1) + 1<br>     *&#47;<br>    for i in 1..&lt;data.count { &#47;&#47; 从 index = 1 开始遍历<br>        if data[i - 1] &lt; data[i] {<br>            counts[i] = counts[i - 1] + 1<br>        } else {<br>            counts[i] = counts[i - 1]<br>        }<br>    }<br>    print(counts)<br>    return counts[data.count - 1]<br>}<br><br>print(longestIncreasingSubsequence([2, 9, 3, 6, 5, 1, 7]))","like_count":0},{"had_liked":false,"id":170388,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1578583955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578583955","product_id":100017301,"comment_content":"如果：a[i]==b[j]，那么：max_lcs(i, j) 就等于：<br>max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；这个是不是应该三个子项都+1了","like_count":0},{"had_liked":false,"id":168599,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1578119450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578119450","product_id":100017301,"comment_content":"对于课后思考题，可以定义以索引 i 结尾的最长递增子序列长度为f(i),则f(0)=1,如果num[i]&gt;num[i-1],f(i)=f(i-1)+1,否则f(i)=1,然后遍历结果就可以找到最大值","like_count":0},{"had_liked":false,"id":168521,"user_name":"JasonZhi","can_delete":false,"product_type":"c1","uid":1282818,"ip_address":"","ucode":"6C23DCD592636D","user_header":"https://static001.geekbang.org/account/avatar/00/13/93/02/fcab58d1.jpg","comment_is_top":false,"comment_ctime":1578103617,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578103617","product_id":100017301,"comment_content":"看了评论，说说我对莱文斯坦距离公式的理解。<br>状态(i,j)，表示到i,j为止，最少的编辑次数。对于状态(i,j)，如果由(i-1,j)转移过来，表示删除字符串a中的1个字符或者字符串b增加1个字符。如果由(i,j-1)转移过来，表示删除字符串b中的1字符或者字符串a增加1个字符。两种情况都需要增加1次的编辑次数。如果由(i-1,j-1)转移过来，需要区分情况，若a[i]==b[j]，则不需要加1编辑次数，若a[i]!=b[j]，则需要加1编辑次数。","like_count":0},{"had_liked":false,"id":167599,"user_name":"Sid","can_delete":false,"product_type":"c1","uid":1115041,"ip_address":"","ucode":"0461B574B2736B","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a1/e6a0f60b.jpg","comment_is_top":false,"comment_ctime":1577873952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577873952","product_id":100017301,"comment_content":"从回溯推状态转移方程比直接硬想状态转移方程容易多了。我一直理解的是回溯是什么条件就直接翻译成状态转移方程就行了，我一直按照这个套路来写dp的。<br>比如莱文斯坦距离，回溯时的逻辑是if (a[i] == b[j]) { &#47;&#47; 两个字符匹配 lwstBT(i+1, j+1, edist); } ，根据回溯推导dp的状态转移方程时，直接取minDist[i-1][j-1])，测试案例也能通。为什么文章里还有minDist[i-1][j])+1 和 minDist[i][j-1])+1，这两个只应该针对a[i]!=b[j] 啊 。难道从回溯直接翻译成动态方程的套路有问题？？？","like_count":0},{"had_liked":false,"id":166524,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1577464670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577464670","product_id":100017301,"comment_content":"(i-1, j-1, max_lcs)，其中 max_lcs 表示 a[0…i-1] 和 b[0…j-1] 的最长公共子串长度；这个是不是应该写(i-1, j-1, max_lcs+1)","like_count":0},{"had_liked":false,"id":163250,"user_name":"阿信","can_delete":false,"product_type":"c1","uid":1389604,"ip_address":"","ucode":"50616ED68A5B40","user_header":"https://static001.geekbang.org/account/avatar/00/15/34/24/34ca1d23.jpg","comment_is_top":false,"comment_ctime":1576675772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576675772","product_id":100017301,"comment_content":"知道min_dist(i,j)表示a[0:i]==b[0:j]所需要的最少编辑次数后，就非常好理解推理出来的状态转移方程了","like_count":0},{"had_liked":false,"id":163042,"user_name":"Swing","can_delete":false,"product_type":"c1","uid":1330065,"ip_address":"","ucode":"55FCA9ECEFBBEB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","comment_is_top":false,"comment_ctime":1576645127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576645127","product_id":100017301,"comment_content":"20191216下午 开始看动态规划，前两节 花了一整天，<br>最后一节 实战 又花了一整天，而且 是强行理解 说服自己。。但还是有一些疑惑 没搞懂。。。<br>难受。。。<br>我的理解如下：<br>----<br>1、莱温斯坦距离的操作有三种：删除、增加、修改（这里 为了方便理解，只对 a串 编辑，不动 b串）<br>对于 每一个状态 即 一对 i，j字符，都要用 三种操作来源对应的操作 来对 当前a串操作，看是否 有真正的编辑操作（即 编辑次数 是否需要+1），然后将 三个累计编辑操作 比较，求最小值，<br>就是上面的状态转移方程的来源；<br><br>但是，在 第0行 和 第0列的 处理上，感觉一开始 就判断 a[0] 和 b[j] 是不对的，感觉应该是下面这样<br>for (int j = 0; j &lt; m; ++j) {<br>  &#47;&#47; 初始化第0行:a[0]与b[0..j]的编辑距离<br>   if (j != 0) minDist[0][j] = minDist[0][j-1]+1;<br>   else minDist[0][j] = a[0] == b[j]? 0 : 1;<br>}<br><br>2、最长公共子串长度的操作，和上面的分析类似，但是这里的操作，不是上面的删、增、改<br>而是：双进位，单i进位，单j进位<br>任一对字符 a[i] ,b[j] 来源于 上述三来源，也依据三来源 对当前a串 操作，然后累计 公共子串长度（多少对儿同序相同字符）<br>推出的状态转移方程 也就是 上面的结果<br>但是，第0行 第0列 依旧和老师的理解不一致。。。<br><br><br>","like_count":0},{"had_liked":false,"id":161450,"user_name":"马振","can_delete":false,"product_type":"c1","uid":1136329,"ip_address":"","ucode":"94234F533219C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/c9/7b3cd3e0.jpg","comment_is_top":false,"comment_ctime":1576208126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576208126","product_id":100017301,"comment_content":"编辑距离这个问题让王老师复杂化了，源串和目的串都修改会复杂化逻辑；本质上都修改也可以也可以简化为仅仅修改源串的，这样能很大程度简化逻辑。<br>假设源串和目的串分别有一个指针在尾部，均向前移动，此时源串字符仅仅有三种处理：<br>删除字符：执行源字符的删除，源字符指针移动，但是两个指针指向的字符不一定相等，所以需要继续递归，编辑次数加一<br>替换或插入:执行源字符的替换和插入，此时插入或替换后的字符就是目的串指针对应的字符，所以一定会实现两个指针指向的字符不一定相等，所以均移动，编辑次数加一<br><br>    static char[] origin = &quot;mitcmu&quot;.toCharArray();<br>    static char[] dest = &quot;mtacnu&quot;.toCharArray();<br>    static int minEditNum = Integer.MAX_VALUE;<br><br>    &#47;&#47; 回溯法---解决两个字符串的编辑距离<br>    &#47;&#47; 倒序比较，o:源字符串长度-1 d:目的字符串长的-1；<br>    &#47;&#47; 调用方式：lwst(0,0,0);<br>    public static void lwst(int o, int d, int editNum){<br>        if(o&gt;=origin.length-1 || d&gt;=dest.length-1){<br>            if(editNum &lt; minEditNum){<br>                minEditNum = editNum;<br>            }<br>            minEditNum = minEditNum+Math.abs(o-d);<br>            System.out.println(minEditNum);<br>            return;<br>        }<br>        if(origin[o] == dest[d]){<br>            lwst(o+1, d+1, editNum);<br>        }else{<br>            &#47;&#47; 源插入 或者 源替换,此时执行后的结果一定是origin[o] == dest[d]<br>            lwst(o+1, d+1, editNum+1);<br>            &#47;&#47; 源删除，此时结果不一定满足origin[o] == dest[d]，但是源肯定要前进一位<br>            lwst(o+1, d, editNum+1);<br>        }<br>    }<br><br>    &#47;&#47; 状态转移方程---解决两个字符串的编辑距离<br>    &#47;&#47; 倒序比较，o:源字符串长度-1 d:目的字符串长的-1<br>    &#47;&#47; 调用方式：System.out.println(lwstNew(origin.length-1, dest.length-1));<br>    public static int lwstNew(int o, int d){<br>        &#47;&#47; 如果源或目的已经到边界，此时只能插入。<br>        if( o &lt; 0 || d &lt; 0){<br>            return Math.abs(o-d);<br>        }<br>        &#47;&#47; 字符相等此时直接移动指针，编辑次数无变化<br>        if(origin[d] == dest[o]){<br>            return lwstNew(o-1, d-1);<br>        }else{<br>            &#47;&#47; 执行源字符的替换或插入，编辑次数加一，此时一定实现origin[d] == dest[o]，所以均移动<br>            int replaceOrInsert = lwstNew(o-1,d-1) + 1;<br>            &#47;&#47; 执行源字符的删除，编辑次数加一，但是不确保origin[d] == dest[o-1]，所以需要继续递归<br>            int delete = lwstNew(o-1, d) + 1;<br>            return Math.min(replaceOrInsert, delete);<br>        }<br>    }","like_count":0},{"had_liked":false,"id":154281,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1574403452,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574403452","product_id":100017301,"comment_content":"莱文斯坦距离初始化第一行&#47;列的个人理解:<br>找到一行&#47;列中第一个与[0,0]匹配的字符,让他的填充值与上一个节点相同即可,后续与[0,0]相同的不用再管.<br>举例:<br>mncdf abmmc 假设第一个字符串为列,第二个字符串为行,这两个字符串初始化时 [0,0]为1(修改其中一个字符a-&gt;m,距离为1),[1,0]为2(删掉一个字符a再修改一个字符b-&gt;m,距离为2),[2,0]还为2(删掉两个字符ab,距离为2),[3,0]的时候为3(删掉3个字符abm,距离为3)<br>在判断条件上对老师的代码做了一些修改   <br> public int lwstDP(char[] a, int n, char[] b, int m) {<br>        int[][] minDist = new int[n][m];<br>        minDist[0][0] = a[0]==b[0]?0:1;<br>        boolean flag1 = minDist[0][0]==1;&#47;&#47;flag1,flag2均为哨兵,判断与[0,0]相同的第一个字符出现的时机<br>        for (int j = 1; j &lt; m; ++j) { &#47;&#47; 初始化第0行:a[0..0]与b[0..j]的编辑距离<br>            &#47;&#47;第一次出现与[0,0]相同的字符,不改变<br>            if(flag1 &amp;&amp; a[0]==b[j]){<br>                minDist[0][j] = minDist[0][j-1];<br>                flag1=false;<br>                continue;<br>            }<br>            minDist[0][j] = minDist[0][j-1]+1;<br>        }<br>        boolean flag2 = minDist[0][0]==1;<br>        for (int i = 1; i &lt; n; ++i) { &#47;&#47; 初始化第0列:a[0..i]与b[0..0]的编辑距离<br>            &#47;&#47;第一次出现与[0,0]相同的字符,不改变<br>            if(flag2 &amp;&amp; a[i]==b[0]){<br>                minDist[i][0] = minDist[i-1][0];<br>                flag2=false;<br>                continue;<br>            }<br>            minDist[i][0] = minDist[i-1][0]+1;<br>        }<br>        for (int i = 1; i &lt; n; ++i) { &#47;&#47; 按行填表<br>            for (int j = 1; j &lt; m; ++j) {<br>                if (a[i] == b[j]) minDist[i][j] = min(<br>                        minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]);<br>                else minDist[i][j] = min(<br>                        minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]+1);<br>            }<br>        }<br>        return minDist[n-1][m-1];<br>    }<br>    private static int min(int x, int y, int z) {<br>        int minv = Integer.MAX_VALUE;<br>        if (x &lt; minv) minv = x;<br>        if (y &lt; minv) minv = y;<br>        if (z &lt; minv) minv = z;<br>        return minv;<br>    }<br><br>编辑距离(莱文斯坦距离)对应的leecode题目:https:&#47;&#47;leetcode-cn.com&#47;problems&#47;edit-distance&#47;submissions&#47;","like_count":0},{"had_liked":false,"id":153910,"user_name":"SylvainHuang","can_delete":false,"product_type":"c1","uid":1227093,"ip_address":"","ucode":"34373F93943DB6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ2nslShe7r4atUhX70usmgRdg56Apkc7MByBZmT293mmBgh9KVMibsV8pNQ2KWuTTNqkicfB2TJvicw/132","comment_is_top":false,"comment_ctime":1574329378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574329378","product_id":100017301,"comment_content":"# 思考题思路:<br># 1.每个数字都有两种状态,加入和不加入<br># 2.对应的结果状态有两个属性,一个是数组长度和递增子序列的最大值<br># python实现如下:<br>def f(seq):<br>    MAX_INT = 2 ** 31 - 1<br>    # status的下标为递增数列长度,值为当前序列的最大值<br>    status = [MAX_INT] * (len(seq) + 1) # 初始化为最大值<br>    status[0] = -2 ** 31   # 将长度为0的初始化为最小值,任何数都可以添加<br>    max_length = 0  # 记录当前最长子串长度<br>    for i in range(len(seq)): <br>        for j in range(len(status)-2, -1, -1): # 从倒数第二个开始遍历,更改j+1的值<br>            if status[j] &lt; seq[i]:  # 如果seq[i]的值比子序列最大值大,则添加<br>                status[j + 1] = min(seq[i], status[j+1]) # 更新序列最大值<br>                max_length = max(max_length, j+1) # 更新最大长度<br>    return max_length<br><br>m = [2,9,3,6,5,1,7]<br>print(f(m))","like_count":0},{"had_liked":false,"id":150271,"user_name":"Monica","can_delete":false,"product_type":"c1","uid":1686257,"ip_address":"","ucode":"B09BC6EEBD81BD","user_header":"https://static001.geekbang.org/account/avatar/00/19/ba/f1/b01034e3.jpg","comment_is_top":false,"comment_ctime":1573488458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573488458","product_id":100017301,"comment_content":"import numpy as np<br>class LwstDP():<br>    def lswtDistance(self, strA, strB):<br>        self.strA = strA<br>        self.strB = strB<br>        self.lenA = len(strA)<br>        self.lenB = len(strB)<br>        self.distanceMat = np.zeros((self.lenA + 1, self.lenB + 1))<br>        return self.computeDistance()<br><br>    def computeDistance(self):<br>        # 初始化<br>        for j in range(self.lenB+1):<br>            self.distanceMat[0][j] = j<br>        for i in range(self.lenA+1):<br>            self.distanceMat[i][0] = i<br><br>        for i in range(1, self.lenA+1):<br>            for j in range(1, self.lenB+1):<br>                if self.strA[i - 1] == self.strB[j - 1]:<br>                    self.distanceMat[i][j] = self.distanceMat[i - 1][j - 1]<br>                else:<br>                    self.distanceMat[i][j] = min(<br>                        self.distanceMat[i - 1][j],<br>                        self.distanceMat[i][j - 1],<br>                        self.distanceMat[i - 1][j - 1]) + 1<br>        return self.distanceMat[self.lenA][self.lenB]<br><br>def should_return_3_when_compare(lwstBT):<br>    strA = &quot;mtacnu&quot;<br>    strB = &quot;mitcmu&quot;<br>    dist = lwstBT.lswtDistance(strA, strB)<br>    assert 3 == dist<br><br>def main():<br>    myLwstDP = LwstDP()<br>    should_return_3_when_compare(myLwstDP)<br><br>main()<br>    strB = &quot;mitcmu&quot;<br>    dist = lwstBT.lswtDistance(strA, strB)<br>    assert 3 == dist","like_count":0},{"had_liked":false,"id":150185,"user_name":"Monica","can_delete":false,"product_type":"c1","uid":1686257,"ip_address":"","ucode":"B09BC6EEBD81BD","user_header":"https://static001.geekbang.org/account/avatar/00/19/ba/f1/b01034e3.jpg","comment_is_top":false,"comment_ctime":1573475519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573475519","product_id":100017301,"comment_content":"看不明白转移方程呢？感觉很奇怪，和认知不同，老师没有把这里讲清楚","like_count":0},{"had_liked":false,"id":143207,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1571648618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571648618","product_id":100017301,"comment_content":"路过打卡！","like_count":0},{"had_liked":false,"id":142359,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1571359543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571359543","product_id":100017301,"comment_content":"还真是这样，   我虽然能看懂你讲的思路，但是遇到新的问题的时候，我还是会感觉到无从下手。","like_count":0},{"had_liked":false,"id":139982,"user_name":"package","can_delete":false,"product_type":"c1","uid":1372328,"ip_address":"","ucode":"A0FF0B21D18DCF","user_header":"https://static001.geekbang.org/account/avatar/00/14/f0/a8/df689349.jpg","comment_is_top":false,"comment_ctime":1570779913,"is_pvip":false,"replies":[{"id":"54157","content":"为啥是这个公式呢？你先讲讲你的理解","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570831781,"ip_address":"","comment_id":139982,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1570779913","product_id":100017301,"comment_content":"老师，你好，计算最长公共子串长度，状态转移方程中，当a[i]=b[j]时，为何不是max(max_lcs(i-1, j-1)+1, max_lcs(i-1, j)+1, max_lcs(i, j-1)+1)这个呢？这个一直想不明白，求助~","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470199,"discussion_content":"为啥是这个公式呢？你先讲讲你的理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570831781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244845,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","nickname":"放飞心情","note":"","ucode":"75A2192D91D86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388689,"discussion_content":"同样的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628913508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1372328,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f0/a8/df689349.jpg","nickname":"package","note":"","ucode":"A0FF0B21D18DCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30859,"discussion_content":"我的理解是这样的，以a[i-1]!=b[j]为例，采取删除a[i-1]或者在b[j]前添加a[i-1]的操作，此时，若a[i]=b[j]，max_lcs(i,j)=max_lcs(i-1,j)+1，若a[i]!=b[j]，max_lcs(i,j)=max_lcs(i-1,j)。\n从而，认为状态转移方程是max(max_lcs(i-1, j-1)+1, max_lcs(i-1, j)+1, max_lcs(i, j-1)+1)。\n\n这一块，想不明白了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570865648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138837,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1570465190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570465190","product_id":100017301,"comment_content":"边做 leetcode 边学习，终于把基础篇看完了，打个卡，收获太多了<br>至于动态规划，是真的难，难就难在 dp 的状态定位。通过回溯来判断是否存在重复，若存在重复则能够通过动态规划解决就真的是非常妙<br>在 leetcode 做了 8 题，感觉还没出来 : (<br><br>最少编辑距离：https:&#47;&#47;leetcode.com&#47;problems&#47;edit-distance<br>课后习题：https:&#47;&#47;leetcode.com&#47;problems&#47;longest-increasing-subsequence","like_count":0},{"had_liked":false,"id":138066,"user_name":"scarlett","can_delete":false,"product_type":"c1","uid":1104937,"ip_address":"","ucode":"F30414146C709F","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/29/33d0d7ff.jpg","comment_is_top":false,"comment_ctime":1570006049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570006049","product_id":100017301,"comment_content":"看了两遍动态规划，思考题研究了一下午，得出以下思路。<br>用状态转移法，对于第i个数，最长子序列是第0--i个数中所有最长子序列中最大的值加1。以下是代码：<br>private int[] b = new int[]{9,2,4,8,7,3};<br>    int m = b.length;<br>public void getSubSeriallen() {<br>        int[] status = new int[m];<br>        status[0] = 1;<br>        for(int i = 1; i &lt; m; i++) {<br>            for(int j = i - 1; j &gt;=0; j--) {<br>                if(b[i] &gt; b[j] &amp;&amp; status[j] &gt; status[i]) {<br>                    status[i] = status[j] + 1;<br>                }<br>            }<br>            &#47;&#47;表示左边序列没有找到比b[i]小的数，从1开始记<br>            if(status[i] == 0)<br>                status[i] = 1;<br>        }<br><br>        for(int i = 0; i &lt; m; i++) {<br>            System.out.print(status[i] + &quot; &quot;);<br><br>        }<br>    }<br><br>请老师指正。","like_count":0},{"had_liked":false,"id":134224,"user_name":"Roger","can_delete":false,"product_type":"c1","uid":1519362,"ip_address":"","ucode":"4CDEEA3B1C074B","user_header":"https://static001.geekbang.org/account/avatar/00/17/2f/02/e7289586.jpg","comment_is_top":false,"comment_ctime":1568777610,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568777610","product_id":100017301,"comment_content":"这里代码如果有不能理解的地方，一定是因为第五个评论提出的原因，即理解那个递推伪代码时，要把(i,j,edist)理解为已经处理完a[i],b[j]需要的编辑距离，这样逻辑才不会错，如果理解为还未处理a[i]、b[j]已经编辑的距离，那么怎么理解都会觉得作者是错的。也希望作者能在文中标注下，要不然真的会让一部分人困扰。","like_count":0,"discussions":[{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20426,"discussion_content":"你好请问，如果理解成 a[i] b[j] 已经处理完，请大佬解释下莱文斯坦状态方程该怎么理解？按理说，a[i] b[j] 理解为处理完的状态，那么 (i-1,j) ，(i,j-1) 和 (i-1,j-1)三个状态也是表示处理完的，那么从这三个状态转移到 (i,j)状态时，那就应该是下面的转移方程吧:\nif (a[i] != b[j])\n1 + min(min_edist(i-1,j), min_edist(i,j-1), min_edist(i-1,j-1))\n上面外部的 1 表示不相等，那么此时最短编辑距离就是前面三个状态的最小距离在加上 1\nif (a[i] == b[j])\nmin(min_edist(i-1, j), min_edist(i,j-1), min_edist(i-1,j-1))\n这个解释是，当前相等，那么此时 ij 最小编辑距离就是前面三个状态的最小编辑距离之一\n\n你看看是不是这样才对！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569314024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129909,"user_name":"Geek_86533a","can_delete":false,"product_type":"c1","uid":1610333,"ip_address":"","ucode":"6961C429E8953A","user_header":"","comment_is_top":false,"comment_ctime":1567324219,"is_pvip":false,"replies":[{"id":"48495","content":"要再用一个数组记录下~这个在留言区讲起来有点麻烦了~","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567379070,"ip_address":"","comment_id":129909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567324219","product_id":100017301,"comment_content":"老师，想请教一下，如果不是想返回最长公共子串长度，而是返回最长公共子串应该怎么做呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465712,"discussion_content":"要再用一个数组记录下~这个在留言区讲起来有点麻烦了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567379070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127406,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1566699756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566699756","product_id":100017301,"comment_content":"基本看懂了。基础篇终于学完了。感觉最后这几节的算法思想将学习难度提升了一个档次。","like_count":0},{"had_liked":false,"id":125259,"user_name":"未来的胡先森","can_delete":false,"product_type":"c1","uid":1234682,"ip_address":"","ucode":"AFF193AC0E2E6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/fa/1f5bf642.jpg","comment_is_top":false,"comment_ctime":1566132870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566132870","product_id":100017301,"comment_content":"更正一下上一回答：int distLeft = matrix[row][0], distUp = matrix[0][col];<br>这样初始化是否更为合适","like_count":0},{"had_liked":false,"id":124917,"user_name":"Geek_18b741","can_delete":false,"product_type":"c1","uid":1368496,"ip_address":"","ucode":"097BA0C2F44150","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlztvlBgajZMEph8AvkP2pfoqNCGtYSalIKgrCbCg0MWDZJgJwqVRfWA6cgIoZicL6dKibfK0zjsWg/132","comment_is_top":false,"comment_ctime":1566014892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566014892","product_id":100017301,"comment_content":"课后题自己没做出来。看了网上的解决，自己写了文章。https:&#47;&#47;blog.csdn.net&#47;flying_all&#47;article&#47;details&#47;99630162欢迎阅读。","like_count":0},{"had_liked":false,"id":123323,"user_name":"Bayes","can_delete":false,"product_type":"c1","uid":1539608,"ip_address":"","ucode":"2F83B2EFCE6B5D","user_header":"https://static001.geekbang.org/account/avatar/00/17/7e/18/c3ed4650.jpg","comment_is_top":false,"comment_ctime":1565658749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565658749","product_id":100017301,"comment_content":"思考题：<br>首先我们想想它是不是可以用动态规划思想来解决。<br>一个模型：“多阶段决策最优解模型”。找最长递增序列，我们可以这样想，假设我们已经找到了数组前面n个数的最长递增序列了，那么第n+1个数该不该加入到已经找到的最长递增序列呢？我们只需要比较最长递增序列里的最后一个数，如果它大于递增序列的最后一个数，那么我们就把它加入，但是如果它小于这最后一个数，我们不能简单排除，还需要和倒数第二个数比较，如果它比倒数第二个数大，我们就用它替换最后一个数。因为我们需要保证序列是最长的同时，就要保证最后一个数是尽可能小的，换句话说，递增数列的最后一个数可以是动态优化的。<br><br>我们用三个特征去证明前面的想法是不是对的。<br>最优子结构：因为第n个数该不该加入递增数列中，只需要考虑第前面的数组成的递增数列就可以了。<br>无后效性：我们计算由前面n个数组成的递增数列是不受后面的数影响的，且继续推到后面阶段的时候也不需要考虑前面的递增数列是怎么推到出来的。<br>重复子问题：这个暂时想不出，望赐教。","like_count":0},{"had_liked":false,"id":122763,"user_name":"Geek_86533a","can_delete":false,"product_type":"c1","uid":1610333,"ip_address":"","ucode":"6961C429E8953A","user_header":"","comment_is_top":false,"comment_ctime":1565515213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565515213","product_id":100017301,"comment_content":"找硬币：<br>class Solution:<br>    def coinChange(self, coins, amount):<br>        <br>        dp = [amount+1] * (amount+1)<br>        dp[0] = 0<br>        <br>        for i in range(1, amount+1):<br>            for coin in coins:<br>                if i &gt;= coin:<br>                    dp[i] = min(dp[i-coin]+1, dp[i])<br>        if dp[-1] == amount+1:<br>            dp[-1] = -1<br>        return dp[-1]","like_count":0},{"had_liked":false,"id":120071,"user_name":"windcaller","can_delete":false,"product_type":"c1","uid":1514157,"ip_address":"","ucode":"1CA3E849805770","user_header":"https://static001.geekbang.org/account/avatar/00/17/1a/ad/faf1bf19.jpg","comment_is_top":false,"comment_ctime":1564772438,"is_pvip":false,"replies":[{"id":"44228","content":"没怎么看懂你说的意思呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564960663,"ip_address":"","comment_id":120071,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564772438","product_id":100017301,"comment_content":"莱文斯坦那个图是不是画错了   mitcmu   mtacnu  改动的不都是一个字符串么?怎么还删除了  mitcmu中的i？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461193,"discussion_content":"没怎么看懂你说的意思呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564960663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119209,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1564537163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564537163","product_id":100017301,"comment_content":"思考题比较有意思，用到了不太常用的数学归纳法。通常数学归纳法n+1项只和临近的n，n-1项有关，这个思考题n+1项和前面所有n项有关（可以优化，但是数量级不变）。","like_count":0},{"had_liked":false,"id":118840,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1564451412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564451412","product_id":100017301,"comment_content":"思考题思路<br>维护两个递增子序列，一个是全局最长且最后一个元素最小，一个以最后一个元素结尾最长。","like_count":0},{"had_liked":false,"id":118563,"user_name":"白色纯度","can_delete":false,"product_type":"c1","uid":1563854,"ip_address":"","ucode":"7ABC830EE468A1","user_header":"https://static001.geekbang.org/account/avatar/00/17/dc/ce/03fdeb60.jpg","comment_is_top":false,"comment_ctime":1564388899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564388899","product_id":100017301,"comment_content":"python的小伙伴可以看看这篇博客，https:&#47;&#47;blog.csdn.net&#47;weixin_42564710&#47;article&#47;details&#47;97034924<br>博主也写过最大公共子串的博客。","like_count":0},{"had_liked":false,"id":112521,"user_name":"寻路人","can_delete":false,"product_type":"c1","uid":1195917,"ip_address":"","ucode":"1711F740D4D60A","user_header":"https://static001.geekbang.org/account/avatar/00/12/3f/8d/a89be8f9.jpg","comment_is_top":false,"comment_ctime":1562750766,"is_pvip":false,"replies":[{"id":"41573","content":"图和dp公式要分开看，这个当时写的时候可能么有写太好，容易导致误解。图只是为了展示重复子问题用的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563234162,"ip_address":"","comment_id":112521,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562750766","product_id":100017301,"comment_content":"如果：a[i]!=b[j]，那么：min_edist(i, j) 就等于：<br>min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)<br><br>如果：a[i]==b[j]，那么：min_edist(i, j) 就等于：<br>min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))<br><br>其中，min 表示求三数中的最小值。     <br><br>按照这个公式我就没有搞明白：<br><br>mitcmu 和 mtacnu  (0,0,0)  =&gt; (1,1,0)  <br>a[1] = i, b[1] = t  <br>a[1] != b[1]  <br>所以min_dist(1,1) = 0 + 1 = 1 ; <br>那上面说的(1,1,0) 这个0又是何解呢？<br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457778,"discussion_content":"图和dp公式要分开看，这个当时写的时候可能么有写太好，容易导致误解。图只是为了展示重复子问题用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563234162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109319,"user_name":"windcaller","can_delete":false,"product_type":"c1","uid":1514157,"ip_address":"","ucode":"1CA3E849805770","user_header":"https://static001.geekbang.org/account/avatar/00/17/1a/ad/faf1bf19.jpg","comment_is_top":false,"comment_ctime":1561998972,"is_pvip":false,"replies":[{"id":"39581","content":"minDist(i-1, j-1)不一定是三个中最小的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562024226,"ip_address":"","comment_id":109319,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561998972","product_id":100017301,"comment_content":"莱文斯坦距离方程<br>如果：a[i]==b[j]，那么为什么是<br>min(minDist(i-1,j)+1,minDist(i,j-1)+1,minDist(i-1,j-1));<br>而不是 minDist(i-1,j-1)","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456351,"discussion_content":"minDist(i-1, j-1)不一定是三个中最小的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562024226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115041,"avatar":"https://static001.geekbang.org/account/avatar/00/11/03/a1/e6a0f60b.jpg","nickname":"Sid","note":"","ucode":"0461B574B2736B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":112605,"discussion_content":"我也是这么理解的，从回溯逻辑直接翻译过来就是只有minDist(i-1,j-1)，而且测试案例都能通过。懵逼了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577874117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108877,"user_name":"Knight²º¹⁸","can_delete":false,"product_type":"c1","uid":1089754,"ip_address":"","ucode":"BDCB830B6A730F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg","comment_is_top":false,"comment_ctime":1561906791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561906791","product_id":100017301,"comment_content":"动态规划就是数学归纳法嘛","like_count":0},{"had_liked":false,"id":108209,"user_name":"吉页","can_delete":false,"product_type":"c1","uid":1244817,"ip_address":"","ucode":"8E25056FB25012","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/91/0ee2741a.jpg","comment_is_top":false,"comment_ctime":1561697694,"is_pvip":false,"replies":[{"id":"39586","content":"我试了下，运行结果是3呢，你说了0，是咋出来的这个结果啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562025572,"ip_address":"","comment_id":108209,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561697694","product_id":100017301,"comment_content":"老师，莱文斯坦距离的回溯算法中终止条件最后一个if写错了吗？我运行回溯代码结果答案是0","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455872,"discussion_content":"我试了下，运行结果是3呢，你说了0，是咋出来的这个结果啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562025572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103928,"user_name":"小刚z","can_delete":false,"product_type":"c1","uid":1109323,"ip_address":"","ucode":"7453F096F6631C","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/4b/0ddfa9ad.jpg","comment_is_top":false,"comment_ctime":1560567325,"is_pvip":false,"replies":[{"id":"37648","content":"不的，不需要连续的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560641977,"ip_address":"","comment_id":103928,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560567325","product_id":100017301,"comment_content":"求最长公共子串的时候当a[i] == a[j] 的时候 maxlcs[i-1][j]与maxlcs[i][j-1]没有加1，而是maxlcs[i-1][j-1]加一，最长公共子串是不是必须是连续的子串相同才是公共子串","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454060,"discussion_content":"不的，不需要连续的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560641977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99091,"user_name":"HomeyLiu","can_delete":false,"product_type":"c1","uid":1330141,"ip_address":"","ucode":"EF4CCB92C369B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","comment_is_top":false,"comment_ctime":1559141300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559141300","product_id":100017301,"comment_content":"public int lwstDP(char[] a, int n, char[] b, int m) {<br>  int[][] minDist = new int[n][m];<br>  for (int j = 0; j &lt; m; ++j) { &#47;&#47; 初始化第 0 行:a[0..0] 与 b[0..j] 的编辑距离<br>    if (a[0] == b[j]) minDist[0][j] = j;<br>    else if (j != 0) minDist[0][j] = minDist[0][j-1]+1;<br>    else minDist[0][j] = 1;<br>  }<br>  for (int i = 0; i &lt; n; ++i) { &#47;&#47; 初始化第 0 列:a[0..i] 与 b[0..0] 的编辑距离<br>    if (a[i] == b[0]) minDist[i][0] = i;<br>    else if (i != 0) minDist[i][0] = minDist[i-1][0]+1;<br>    else minDist[i][0] = 1;<br>  }<br>  for (int i = 1; i &lt; n; ++i) { &#47;&#47; 按行填表<br>    for (int j = 1; j &lt; m; ++j) {<br>      if (a[i] == b[j]) minDist[i][j] = min(<br>          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]);<br>      else minDist[i][j] = min(<br>          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]+1);<br>    }<br>  }<br>  return minDist[n-1][m-1];<br>}<br><br>private int min(int x, int y, int z) {<br>  int minv = Integer.MAX_VALUE;<br>  if (x &lt; minv) minv = x;<br>  if (y &lt; minv) minv = y;<br>  if (z &lt; minv) minv = z;<br>  return minv;<br>}<br><br><br>初始化第0行和第0列的代码有问题。 <br>  if (a[i] == b[0]) minDist[i][0] = i;<br>和<br> if (a[0] == b[j]) minDist[0][j] = j;<br>有问题。<br>想象一下，AAAAA和ABBBB的情况就知道了。<br><br>应该是<br>if(i=0){<br>\tif(b[0]==a[i]){<br>\t\tminDist[i][0] = minDist[i-1][0];<br>\t}else{<br>\t\tminDist[i][0] = minDist[i-1][0] + 1;<br>\t}<br>}else{<br><br>\tif(b[0]==a[i]){<br>\t\tminDist[0][0] = 0;<br>\t}else{<br>\t\tminDist[i][0] = 1;<br>\t}<br><br>}<br>","like_count":0},{"had_liked":false,"id":99090,"user_name":"HomeyLiu","can_delete":false,"product_type":"c1","uid":1330141,"ip_address":"","ucode":"EF4CCB92C369B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","comment_is_top":false,"comment_ctime":1559141288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559141288","product_id":100017301,"comment_content":"public int lwstDP(char[] a, int n, char[] b, int m) {<br>  int[][] minDist = new int[n][m];<br>  for (int j = 0; j &lt; m; ++j) { &#47;&#47; 初始化第 0 行:a[0..0] 与 b[0..j] 的编辑距离<br>    if (a[0] == b[j]) minDist[0][j] = j;<br>    else if (j != 0) minDist[0][j] = minDist[0][j-1]+1;<br>    else minDist[0][j] = 1;<br>  }<br>  for (int i = 0; i &lt; n; ++i) { &#47;&#47; 初始化第 0 列:a[0..i] 与 b[0..0] 的编辑距离<br>    if (a[i] == b[0]) minDist[i][0] = i;<br>    else if (i != 0) minDist[i][0] = minDist[i-1][0]+1;<br>    else minDist[i][0] = 1;<br>  }<br>  for (int i = 1; i &lt; n; ++i) { &#47;&#47; 按行填表<br>    for (int j = 1; j &lt; m; ++j) {<br>      if (a[i] == b[j]) minDist[i][j] = min(<br>          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]);<br>      else minDist[i][j] = min(<br>          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]+1);<br>    }<br>  }<br>  return minDist[n-1][m-1];<br>}<br><br>private int min(int x, int y, int z) {<br>  int minv = Integer.MAX_VALUE;<br>  if (x &lt; minv) minv = x;<br>  if (y &lt; minv) minv = y;<br>  if (z &lt; minv) minv = z;<br>  return minv;<br>}<br><br><br>初始化第0行和第0列的代码有问题。 <br>  if (a[i] == b[0]) minDist[i][0] = i;<br>和<br> if (a[0] == b[j]) minDist[0][j] = j;<br>有问题。<br>想象一下，AAAAA和ABBBB的情况就知道了。<br><br>应该是<br>if(i=0){<br>\tif(b[0]==a[i]){<br>\t\tminDist[i][0] = minDist[i-1][0];<br>\t}else{<br>\t\tminDist[i][0] = minDist[i-1][0] + 1;<br>\t}<br>}else{<br><br>\tif(b[0]==a[i]){<br>\t\tminDist[0][0] = 0;<br>\t}else{<br>\t\tminDist[i][0] = 1;<br>\t}<br><br>}<br>","like_count":0},{"had_liked":false,"id":99089,"user_name":"HomeyLiu","can_delete":false,"product_type":"c1","uid":1330141,"ip_address":"","ucode":"EF4CCB92C369B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","comment_is_top":false,"comment_ctime":1559141284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559141284","product_id":100017301,"comment_content":"public int lwstDP(char[] a, int n, char[] b, int m) {<br>  int[][] minDist = new int[n][m];<br>  for (int j = 0; j &lt; m; ++j) { &#47;&#47; 初始化第 0 行:a[0..0] 与 b[0..j] 的编辑距离<br>    if (a[0] == b[j]) minDist[0][j] = j;<br>    else if (j != 0) minDist[0][j] = minDist[0][j-1]+1;<br>    else minDist[0][j] = 1;<br>  }<br>  for (int i = 0; i &lt; n; ++i) { &#47;&#47; 初始化第 0 列:a[0..i] 与 b[0..0] 的编辑距离<br>    if (a[i] == b[0]) minDist[i][0] = i;<br>    else if (i != 0) minDist[i][0] = minDist[i-1][0]+1;<br>    else minDist[i][0] = 1;<br>  }<br>  for (int i = 1; i &lt; n; ++i) { &#47;&#47; 按行填表<br>    for (int j = 1; j &lt; m; ++j) {<br>      if (a[i] == b[j]) minDist[i][j] = min(<br>          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]);<br>      else minDist[i][j] = min(<br>          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]+1);<br>    }<br>  }<br>  return minDist[n-1][m-1];<br>}<br><br>private int min(int x, int y, int z) {<br>  int minv = Integer.MAX_VALUE;<br>  if (x &lt; minv) minv = x;<br>  if (y &lt; minv) minv = y;<br>  if (z &lt; minv) minv = z;<br>  return minv;<br>}<br><br><br>初始化第0行和第0列的代码有问题。 <br>  if (a[i] == b[0]) minDist[i][0] = i;<br>和<br> if (a[0] == b[j]) minDist[0][j] = j;<br>有问题。<br>想象一下，AAAAA和ABBBB的情况就知道了。<br><br>应该是<br>if(i=0){<br>\tif(b[0]==a[i]){<br>\t\tminDist[i][0] = minDist[i-1][0];<br>\t}else{<br>\t\tminDist[i][0] = minDist[i-1][0] + 1;<br>\t}<br>}else{<br><br>\tif(b[0]==a[i]){<br>\t\tminDist[0][0] = 0;<br>\t}else{<br>\t\tminDist[i][0] = 1;<br>\t}<br><br>}<br>","like_count":0},{"had_liked":false,"id":98508,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1559014046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559014046","product_id":100017301,"comment_content":"##最长递增子序列<br>input_arr = [2,9,3,6,5,1,7]<br>states_las = {0:[2]}<br>def las_dp(i):<br>    if states_las.get(i) != None:<br>        return states_las[i]<br>    prev_arr = las_dp(i-1)<br>    len_prev = len(prev_arr)<br>    if input_arr[i] &lt; prev_arr[len_prev-1] and input_arr[i] &gt; prev_arr[len_prev-2]:<br>        tmp_arr = [prev_arr[k] for k in range(len_prev-1)]<br>        tmp_arr.append(input_arr[i])<br>        states_las[i] = tmp_arr<br>        return states_las[i]<br>    elif input_arr[i] &gt;= prev_arr[len_prev-1]:<br>        tmp_arr = [prev_arr[k] for k in range(len_prev)]<br>        tmp_arr.append(input_arr[i])<br>        states_las[i] = tmp_arr<br>        return states_las[i]<br>    else:<br>        tmp_arr = [prev_arr[k] for k in range(len_prev)]<br>        states_las[i] = tmp_arr<br>        return states_las[i]","like_count":0},{"had_liked":false,"id":98296,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1558950475,"is_pvip":false,"replies":[{"id":"35203","content":"是1的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559006159,"ip_address":"","comment_id":98296,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558950475","product_id":100017301,"comment_content":"有个问题请教一下，aba和a这两个字符串的最长公共子串长度是1还是2呢？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451635,"discussion_content":"是1的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559006159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97167,"user_name":"somenzz","can_delete":false,"product_type":"c1","uid":1187197,"ip_address":"","ucode":"EA59A170DF8910","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","comment_is_top":false,"comment_ctime":1558601068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558601068","product_id":100017301,"comment_content":"def max_increase_list(nums:list) -&gt; int:<br>    &#39;&#39;&#39;<br>    给定一组数据，返回最长递增子序列的长度<br>    &#39;&#39;&#39;<br>    <br>    length = len(nums)<br>    table = [[1]*length for _ in range(length)]<br>    <br>    for i in range(length):<br>        for j in range(i,length):<br>            # print(i,j)<br>            if nums[i] == nums[j]:<br>                table[i][j] = table[i-1][j]<br>            elif nums[i] &lt; nums[j]: <br>                table[i][j] = table[i][i]+1<br>            else : <br>                table[i][j] = table[i][i]<br>    <br>    return table[length-1][length-1]","like_count":0},{"had_liked":false,"id":96410,"user_name":"浪迹天涯","can_delete":false,"product_type":"c1","uid":1473437,"ip_address":"","ucode":"F331CFE4A4D056","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKxvOIEwZaSSR1S2JicuhMtQw7ecGicH13Cib1nWcxy5FgF05246o6WTRUarEISEjm7IRnUBa4KKqMiaw/132","comment_is_top":false,"comment_ctime":1558413924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558413924","product_id":100017301,"comment_content":"自己用Golang做的递归法和动态规划法<br><br>&#47;&#47;我们有一个数字序列包含 n 个不同的数字，如何求出这个序列中的最长递增子序列长度？比如 2, 9, 3, 6, 5, 1, 7 这样一组数字序列，<br>&#47;&#47;它的最长递增子序列就是 2, 3, 5, 7，所以最长递增子序列的长度是 4。<br>&#47;&#47;递归法<br>func maxIncrementSubSeqRecursion(input []int, n int) int{<br><br>\tif n == 0 {<br>\t\treturn 1<br>\t}<br><br>\tmax := 0<br>\tlonglength := 0<br>\tfor i:=n-1;i&gt;=0;i--{<br>\t\t&#47;&#47;fmt.Println(&quot;i:&quot;,i)<br>\t\tif input[n] &gt; input[i] {<br>\t\t\t&#47;&#47;fmt.Printf(&quot;input[%d] &gt; input[%d] === %d &gt; %d\\n&quot;,n,i,input[n],input[i])<br>\t\t\tlonglength = maxIncrementSubSeqRecursion(input,i)+1<br>\t\t}else{<br>\t\t\tlonglength = maxIncrementSubSeqRecursion(input,i)<br>\t\t}<br>\t\t&#47;&#47;fmt.Println(&quot;longlength:&quot;,longlength)<br>\t\t&#47;&#47;fmt.Println(&quot;max:&quot;,max)<br>\t\tif longlength &gt; max {<br>\t\t\tmax = longlength<br>\t\t}<br>\t}<br><br>\treturn max<br>}<br><br>&#47;&#47;我们有一个数字序列包含 n 个不同的数字，如何求出这个序列中的最长递增子序列长度？比如 2, 9, 3, 6, 5, 1, 7 这样一组数字序列，<br>&#47;&#47;它的最长递增子序列就是 2, 3, 5, 7，所以最长递增子序列的长度是 4。<br>&#47;&#47;思路：状态转移二维数组，行和列都是 2，9，3，6，5，1，7，数组值存放的是当前最长递增子序列长度<br>&#47;*<br>\t2\t9\t3\t6\t5\t1\t7<br>2\t1\t2\t2\t2\t2\t1\t2<br>9\t\t2\t2\t2\t2\t2\t2<br>3\t\t\t2\t3\t3\t2\t3<br>6\t\t\t\t3\t3\t3\t4<br>5\t\t\t\t\t3\t3\t4<br>1\t\t\t\t\t\t3\t4<br>7\t\t\t\t\t\t\t4<br>看上述矩阵，从i=0即从2开始，2遇到2，则最长为1，2遇到9，递增，则最长为2<br>如果遇到 3 9 4 这种情况，那么有两种分支，3 9 和 3 4，优先选 9和4中较小的<br>\t2\t3\t9\t4\t6\t5\t1\t7<br>2\t1\t2\t3\t3\t3\t3\t3\t3<br>3\t\t2\t3\t3\t3\t3\t3\t3<br>9\t\t\t3\t3\t3\t3\t3\t3<br>4\t\t\t\t3\t4\t4\t4\t5<br>6\t\t\t\t\t4\t4\t4\t5<br>5\t\t\t\t\t\t4\t4\t5<br>1\t\t\t\t\t\t\t4\t5<br>7\t\t\t\t\t\t\t\t5<br>*&#47;<br>&#47;&#47;动态规划法<br>func maxIncrementSubSeqDP(input []int) int{<br><br>\tlength := len(input)<br><br>\tvar state [][]int<br><br>\tfor i := 0;i&lt;length;i++ {<br>\t\ts := make([]int,length)<br>\t\tstate = append(state,s)<br>\t}<br><br>\tstate[0][0] = 1<br><br><br>\tfor i:=0;i&lt;length;i++{<br>\t\tif i == 0{<br>\t\t\tstate[i][i] = 1<br>\t\t}else{<br>\t\t\t&#47;&#47;从第二行开始,斜对角线元素的当前最大递增子串长度等于上一层到本位置长度延续下来，<br>\t\t\t&#47;&#47; 例如 input[2]=&gt;9 , 那么 state[2][2] = state[2-1][2]<br>\t\t\tstate[i][i] = state[i-1][i]<br>\t\t}<br><br>\t\tmax := input[i]<br>\t\tfor j:=i+1;j&lt;length;j++{<br>\t\t\tif input[j] &gt; max{ &#47;&#47;i行从左到右按照j下标遍历，如果右侧input[j]大于之前的最大值，则state[i][j]表示的长度+1<br>\t\t\t\tmax = input[j]<br>\t\t\t\tstate[i][j] = state[i][j-1]+1<br>\t\t\t}else{\t&#47;&#47;如果不满足上述条件，说明之后的都无法满足递增条件，则维持当前最大长度，及当前最大值，等待下一个判断是否能超过<br>\t\t\t\tstate[i][j] = state[i][j-1]<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\t&#47;&#47;fmt.Println(state)<br><br>\treturn state[length-1][length-1]<br>}<br>","like_count":0},{"had_liked":false,"id":91017,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1556789841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556789841","product_id":100017301,"comment_content":"三篇大作每一篇都看了三遍，照着敲了代码，每个都对着老师讲的分析认真看，又到网上搜了好几篇文章加深理解，总算入门了。以前压根没看过dp这种东西，真的太费劲了","like_count":0},{"had_liked":false,"id":88388,"user_name":"小新村小学扛霸子","can_delete":false,"product_type":"c1","uid":1250309,"ip_address":"","ucode":"BECFAB70A68C9F","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/05/5f46ffa6.jpg","comment_is_top":false,"comment_ctime":1555915410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555915410","product_id":100017301,"comment_content":"如果：a[i]==b[j]，那么：min_edist(i, j) 来源也是三种，这个想了半天。<br>起初我也以为min_edist(i, j) 直接等于min_edist(i-1, j-1)就行了，还看了留言区的同学的评论。 <br><br>","like_count":0},{"had_liked":false,"id":82367,"user_name":"不成熟的萌","can_delete":false,"product_type":"c1","uid":1244537,"ip_address":"","ucode":"4F5059446D062D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/79/d42c4c68.jpg","comment_is_top":false,"comment_ctime":1554194202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554194202","product_id":100017301,"comment_content":"关于莱文斯坦距离那一块，自己想给出点建议。在初始化那里，我们需要考虑A[0]和B[i]的距离，当时我觉得很麻烦，不想考虑这块。即我们的状态转移表示从A的第0个字符和B的第0个字符开始进行推。初始化的过程要稍微动下脑。<br>自己在leetcode上看了一些答案，想提供一个懒人方法。就是我们从A的-1个字符和B的-1个字符开始进行推。那么对于状态转移表的初始化来说就比较方便。我们多构建一行和一列。多一个空字符的比较。<br>```cpp<br>for(int i = 0; i &lt; N+1; ++i)<br>    dp[i][0] = i;<br>for(int j = 0; j &lt; M+1; ++j)<br>    dp[0][j] = j;<br>```<br>","like_count":0},{"had_liked":false,"id":79336,"user_name":"JKnight","can_delete":false,"product_type":"c1","uid":1330419,"ip_address":"","ucode":"709D7A51135EDE","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/f3/6f18cdae.jpg","comment_is_top":false,"comment_ctime":1553437171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553437171","product_id":100017301,"comment_content":"其实可以对原数组排序得到新数组，然后就转变成了这篇介绍的问题，对比原数组找最长公共序列（苦思冥想一个小时没想到，搜索了一下恍然大悟……","like_count":0},{"had_liked":false,"id":77644,"user_name":"晓杉","can_delete":false,"product_type":"c1","uid":1209336,"ip_address":"","ucode":"19E634BB61A165","user_header":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","comment_is_top":false,"comment_ctime":1552977342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552977342","product_id":100017301,"comment_content":"&#47;&#47;回溯方法：调用calMaxIncrease(-1, -1, 0)<br>public static void calMaxIncrease(int i, int preIndex, int len) {<br>        if (i == 6) {<br>            if (len &gt; maxLen) {<br>                maxLen = len;<br>            }<br>            return;<br>        }<br>        calMaxIncrease(i + 1, preIndex, len);&#47;&#47;不放i+1<br>        if (preIndex == -1 || arr[i + 1] &gt; arr[preIndex]) {&#47;&#47; 可以放i+1<br>            calMaxIncrease(i + 1, i + 1, len + 1);<br>        }<br>    }","like_count":0},{"had_liked":false,"id":77643,"user_name":"晓杉","can_delete":false,"product_type":"c1","uid":1209336,"ip_address":"","ucode":"19E634BB61A165","user_header":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","comment_is_top":false,"comment_ctime":1552977254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552977254","product_id":100017301,"comment_content":"回溯法实现<br>public static void calMaxIncrease(int i, int preIndex, int len) {<br>        if (i == 6) {<br>            if (len &gt; maxLen) {<br>                maxLen = len;<br>            }<br>            return;<br>        }<br>        calMaxIncrease(i + 1, preIndex, len);&#47;&#47;不放i+1<br>        if (preIndex == -1 || arr[i + 1] &gt; arr[preIndex]) {&#47;&#47; 可以放i+1<br>            calMaxIncrease(i + 1, i + 1, len + 1);<br>        }<br>    }","like_count":0},{"had_liked":false,"id":76438,"user_name":"攻玉","can_delete":false,"product_type":"c1","uid":1256489,"ip_address":"","ucode":"191BA2197377B8","user_header":"https://static001.geekbang.org/account/avatar/00/13/2c/29/2380837c.jpg","comment_is_top":false,"comment_ctime":1552612067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552612067","product_id":100017301,"comment_content":"Python :<br>def lengthOfLIS( nums):<br>    if nums == None or len(nums) == 0: return 0<br>    dp , n = {} , len(nums)<br>    for i in range(n): # i 位置的数与[0,i]位置之间的数比较，如果大于进逻辑<br>        dp[i] = 1<br>        for j in range(i):<br>            if nums[j] &lt; nums[i] : # 等于dp[i]或者dp[j] + 1（j对应的值比i小）的最大值<br>                dp[i] = max(dp[i]  ,  dp[j] + 1 )  # 关键!<br>                print(i,j , dp)<br>    print(dp)<br>    print(&quot;最长公共子序列:&quot;,max(dp.values()) )<br>    return max(dp.values()) <br><br>li = [2, 11, 4, 12, 6, 1]  # 最长子序列 : [2,4,6]<br>lengthOfLIS(li)<br><br>https:&#47;&#47;segmentfault.com&#47;a&#47;1190000012748540","like_count":0},{"had_liked":false,"id":75543,"user_name":"张xy","can_delete":false,"product_type":"c1","uid":1380405,"ip_address":"","ucode":"0FCA2A2288B386","user_header":"https://static001.geekbang.org/account/avatar/00/15/10/35/a9a25568.jpg","comment_is_top":false,"comment_ctime":1552429484,"is_pvip":false,"replies":[{"id":"27869","content":"你对比下公式看下吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552615953,"ip_address":"","comment_id":75543,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552429484","product_id":100017301,"comment_content":"状态转移表里，第4行4列为什么会是3？m与n 不相等且左上都是3难道不应该是4吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442932,"discussion_content":"你对比下公式看下吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552615953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74784,"user_name":"我去买橘子","can_delete":false,"product_type":"c1","uid":1112646,"ip_address":"","ucode":"EC4D00301141E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/46/4da3659f.jpg","comment_is_top":false,"comment_ctime":1552298197,"is_pvip":false,"replies":[{"id":"27716","content":"回溯那个图跟dp公式有区别的。回溯只是为了解释重复子问题用的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552532333,"ip_address":"","comment_id":74784,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552298197","product_id":100017301,"comment_content":"如果：a[i]!=b[j]，那么：min_edist(i, j) 就等于：<br>min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)，在计算计算莱文斯坦距离的递归树中(0,0,0)到(1,1,0)的时候，a[1]!=b[1]，此时min_edist(i,j)为0，而不是按公式得到的1，是我哪里理解错了吗？希望老师回答<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442679,"discussion_content":"回溯那个图跟dp公式有区别的。回溯只是为了解释重复子问题用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552532333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72978,"user_name":"睡觉不看表","can_delete":false,"product_type":"c1","uid":1088175,"ip_address":"","ucode":"FD05AA7D01B4ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/af/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1551769533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551769533","product_id":100017301,"comment_content":"刚好在leetcode刷到了习题（300），直接贴代码吧<br><br>def length_of_lis(nums)<br>    n = nums.length<br>    return 0 if n == 0<br>    dp = Array.new(n, 1)<br>    <br>    1.upto(n-1) do |i|<br>        # 每个位置往前找，如果对应的数字比当前小，就比较之前的dp，取最大值<br>        0.upto(i-1) do |j|<br>            if nums[i] &gt; nums[j]<br>                dp[i] = [ dp[i], dp[j] + 1 ].max<br>            end<br>        end<br>    end<br>    <br>    dp.max<br>end","like_count":0},{"had_liked":false,"id":71514,"user_name":"youngitachi","can_delete":false,"product_type":"c1","uid":1214582,"ip_address":"","ucode":"88717CA8B8ED64","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/76/c69b7fe5.jpg","comment_is_top":false,"comment_ctime":1551360086,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1551360086","product_id":100017301,"comment_content":"这篇看得很过瘾，讲得比较清楚。赞一个！","like_count":0},{"had_liked":false,"id":71055,"user_name":"黄均鹏","can_delete":false,"product_type":"c1","uid":1131636,"ip_address":"","ucode":"27F852817B9B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/74/f98299ee.jpg","comment_is_top":false,"comment_ctime":1551255620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551255620","product_id":100017301,"comment_content":"每一格数据只能来源于left和top，把最优解逐渐压缩至第一行。觉得动态规划比红黑树简单多了，至少这个看到老师的图解后能清晰写出代码","like_count":0},{"had_liked":false,"id":70836,"user_name":"Zix","can_delete":false,"product_type":"c1","uid":1025719,"ip_address":"","ucode":"48BB6A7F1352CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/b7/e0c9be64.jpg","comment_is_top":false,"comment_ctime":1551192337,"is_pvip":false,"replies":[{"id":"25392","content":"那个是初始化值，不是推导出来的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551232239,"ip_address":"","comment_id":70836,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551192337","product_id":100017301,"comment_content":"莱文斯坦距离动态规划方法，状态表的第0行和第0列看不懂是如何计算来的，请求解答？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440853,"discussion_content":"那个是初始化值，不是推导出来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551232239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67268,"user_name":"沉睡的木木夕","can_delete":false,"product_type":"c1","uid":1036362,"ip_address":"","ucode":"2C6B23B34C44E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/4a/7e3d158d.jpg","comment_is_top":false,"comment_ctime":1550118354,"is_pvip":false,"replies":[{"id":"24760","content":"填充表应该没错。分析过程和填表是没太大关系。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550810601,"ip_address":"","comment_id":67268,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550118354","product_id":100017301,"comment_content":"莱温斯坦距离的状态填充表到底是如何填充的？我今天回过头重新阅读理解，还是没弄懂啊，分析过程我也懂了，但是这个填充表感觉真的跟之前之前的分析没任何关系，或者在我看来这个填充表就是错的，老师望解答一下啊？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439123,"discussion_content":"填充表应该没错。分析过程和填表是没太大关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550810601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64194,"user_name":"pngyul","can_delete":false,"product_type":"c1","uid":1234462,"ip_address":"","ucode":"E3A7949DB08438","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/1e/859c1baa.jpg","comment_is_top":false,"comment_ctime":1548691135,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1548691135","product_id":100017301,"comment_content":"如果：a[i]==b[j]，那么：min_edist(i, j) 就等于：<br>min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))<br><br>老师，这里 当 a[i]==b[j]，min_edist(i-1,j-1)+1 不是也可以得到吗","like_count":0,"discussions":[{"author":{"id":1244845,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","nickname":"放飞心情","note":"","ucode":"75A2192D91D86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388687,"discussion_content":"如果：a[i]==b[j]，min_edist(i-1,j-1)到min_edist(i, j)编辑次数为0，所以不+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628913074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074968,"avatar":"https://static001.geekbang.org/account/avatar/00/10/67/18/79167fa2.jpg","nickname":"Tom","note":"","ucode":"5940DF3B4782DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5109,"discussion_content":"这个我也没搞懂， 希望老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565949930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62078,"user_name":"酷比少年","can_delete":false,"product_type":"c1","uid":1248713,"ip_address":"","ucode":"2F65ECBBE91A77","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/c9/b2987082.jpg","comment_is_top":false,"comment_ctime":1547903398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547903398","product_id":100017301,"comment_content":"#include&lt;iostream&gt;<br>#include&lt;vector&gt;<br>#include&lt;algorithm&gt;<br>using namespace std;<br>class Solution{<br>public:<br>\t&#47;&#47;动态规划求解<br>\t&#47;&#47;a[0...i]最长上升子序列为：<br>\t&#47;&#47;a[i]之前所有小于它的元素子序列长度的最大值 + 1<br>\tint maxOrderedSeqDP(const vector&lt;int&gt; seq){<br>\t\t&#47;&#47;创建一个数组，索引i对应考察元素的下标，存储a[0...i]最长上升子序列大小<br>\t\t&#47;&#47;初始化为1（因为最小的长度为1）<br>\t\tvector&lt;int&gt; lss_lengths(seq.size(), 1);<br>\t\tfor (int i = 1; i &lt; seq.size(); ++i){<br>\t\t\tfor (int j = 0; j &lt; i; ++j){<br>\t\t\t\tif (seq[i] &gt; seq[j]){<br>\t\t\t\t\tlss_lengths[i] = max(lss_lengths[j] + 1, lss_lengths[i]);<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t\t&#47;&#47;在数组里找到最大的数，即为最长上升子序列的大小<br>\t\tint max_lss = 1;<br>\t\tfor (int i = 0; i &lt; lss_lengths.size(); ++i){<br>\t\t\tmax_lss = max_lss &gt; lss_lengths[i] ? max_lss : lss_lengths[i];<br>\t\t}<br>\t\treturn max_lss;<br>\t}<br><br>};<br><br>int main(){<br>\tSolution s;<br>\tvector&lt;int&gt; seq = { 2, 9, 3, 6, 5, 1, 7 };<br>\tint maxSeqLen1 = s.maxOrderedSeqDP(seq);<br>\tcout &lt;&lt; &quot;maxSeqLen1: &quot; &lt;&lt; maxSeqLen1 &lt;&lt; endl;<br>\tsystem(&quot;pause&quot;);<br>\treturn 0;<br>}","like_count":0},{"had_liked":false,"id":60591,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1547516920,"is_pvip":false,"replies":[{"id":"21575","content":"同学，你说的是42节的内容吗？","user_name":"编辑回复","user_name_real":"王锦","uid":"1058895","ctime":1547518540,"ip_address":"","comment_id":60591,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1547516920","product_id":100017301,"comment_content":"重要提醒：经过我的验证，maxLen[i] = max(maxLen[j]+(1 if j&lt;i else 0)) for any j &lt; i 这个递推公式是错误的！！！","like_count":0,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436552,"discussion_content":"同学，你说的是42节的内容吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547518540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60274,"user_name":"GrubbyLu","can_delete":false,"product_type":"c1","uid":1063483,"ip_address":"","ucode":"1B471210A668EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/3a/3b/3a6efa8f.jpg","comment_is_top":false,"comment_ctime":1547453830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547453830","product_id":100017301,"comment_content":"王老师问一下，莱文斯坦代码中第0行初始化的代码<br>if (a[0] == b[j]) minDist0][j] = j;<br>是不是应该为<br>if (a[0] == b[j]) minDist0][j] = minDist0][j-1]<br><br>还有最长公共子串中第0行初始化的代码<br>if (a[0] == b[j]) maxlcs[0][j] = 1<br>是不是应该为<br>if (a[0] == b[j]) maxlcs[0][j] = maxlcs[0][j-1]  + 1<br><br>是您写错了呢？还是我理解错了，麻烦指正下，多谢","like_count":0},{"had_liked":false,"id":60015,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1547437092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547437092","product_id":100017301,"comment_content":"哦～我好像得到的是局部最优解","like_count":0},{"had_liked":false,"id":60010,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1547436752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547436752","product_id":100017301,"comment_content":"感觉思考题可以用贪心算法求解，因为比较特殊，都是整数。我只要每次维护一个i指针和，i-1指针到i指针的增量即可，j指针继续遍历，如果和i-1指针形成有序，然后对比增量即可。","like_count":0},{"had_liked":false,"id":59304,"user_name":"。。。","can_delete":false,"product_type":"c1","uid":1267092,"ip_address":"","ucode":"F4D90A500B66D3","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/94/cefb8a05.jpg","comment_is_top":false,"comment_ctime":1547348704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547348704","product_id":100017301,"comment_content":"思考题<br>public int recursionCount02(int[] arrays, int index) {<br>if (index == 0) {<br>return 1;<br>}<br>int max = 0;<br>for (int i = 0; i &lt; index; i++) {<br>&#47;&#47; 取到 index 到 i 的最大值<br>int value = recursionCount(arrays, i);<br>if (arrays[i] &lt; arrays[index]) {<br>if (value + 1 &gt; max) {<br>max = value + 1;<br>}<br>} else {<br>if (value &gt; max) {<br>max = value;<br>}<br>}<br>}<br>return max;<br>}<br><br>dp<br>public int dynamicP(int[] array) {<br>int[] status = new int[array.length];<br><br>status[0] = 1;<br>for (int i = 1; i &lt; array.length; i++) {<br>int max = 0;<br>for (int j = 0; j &lt; i; j++) {<br>if (array[i] &gt; array[j]) {<br>if (status[j] + 1 &gt; max) {<br>max = status[j] + 1;<br>}<br>} else {<br>if (status[j] &gt; max) {<br>max = status[j];<br>}<br>}<br>}<br>status[i] = max;<br>}<br>return status[status.length - 1];<br>}<br><br>@Test<br>public void test03() {<br>int[] array = new int[]{2, 3, 4, 6, 8, 1};<br>System.out.println(recursionCount02(array, array.length - 1));<br>System.out.println(dynamicP(array));<br>}","like_count":0},{"had_liked":false,"id":59197,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1547328448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547328448","product_id":100017301,"comment_content":"“根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。”<br>👍","like_count":0},{"had_liked":false,"id":57268,"user_name":"Lily","can_delete":false,"product_type":"c1","uid":1235419,"ip_address":"","ucode":"BD67400B87A167","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/db/2ccc8a64.jpg","comment_is_top":false,"comment_ctime":1546702139,"is_pvip":false,"replies":[{"id":"20713","content":"多谢🙏 我改下 不好意思","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546825803,"ip_address":"","comment_id":57268,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546702139","product_id":100017301,"comment_content":"这门课程真的很赞，篇篇干货，简洁明晰；计算莱文斯坦距离的递归树的图右下角有处笔误：（3,2,3)应是(3,2,2)吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435499,"discussion_content":"多谢🙏 我改下 不好意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546825803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57241,"user_name":"煦暖","can_delete":false,"product_type":"c1","uid":1245418,"ip_address":"","ucode":"96D0B236C4148A","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg","comment_is_top":false,"comment_ctime":1546696580,"is_pvip":false,"replies":[{"id":"20720","content":"应该是MIN的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546826405,"ip_address":"","comment_id":57241,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546696580","product_id":100017301,"comment_content":"计算最长公共子串长度的代码中，max函数：<br>原文中的“int maxv = Integer.MIN_VALUE;”应该是MAX。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435480,"discussion_content":"应该是MIN的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546826405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57176,"user_name":"想当上帝的司机","can_delete":false,"product_type":"c1","uid":1239378,"ip_address":"","ucode":"D8251388854911","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/52/f07e9001.jpg","comment_is_top":false,"comment_ctime":1546672465,"is_pvip":false,"replies":[{"id":"20721","content":"顺序不能变的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546826611,"ip_address":"","comment_id":57176,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546672465","product_id":100017301,"comment_content":"最长的1，3，5，7，9 五位吧 或者我理解错题目了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435445,"discussion_content":"顺序不能变的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546826611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57131,"user_name":"微秒","can_delete":false,"product_type":"c1","uid":1249195,"ip_address":"","ucode":"65A2E8B565B191","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg","comment_is_top":false,"comment_ctime":1546656251,"is_pvip":false,"replies":[{"id":"21845","content":"不，状态转移方程是倒着推的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547708422,"ip_address":"","comment_id":57131,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546656251","product_id":100017301,"comment_content":"状态方程中的条件如果：a[i]!=b[j]，那么：min_edist(i, j) 就等于，这里应该是a[i-1]!=b[j-1]吧？？？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435419,"discussion_content":"不，状态转移方程是倒着推的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56697,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1546523552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546523552","product_id":100017301,"comment_content":"填表的那个图没看明白","like_count":0},{"had_liked":false,"id":56688,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1546522863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546522863","product_id":100017301,"comment_content":"怎么来确定哪个替换哪个，删除哪一个，哪个上面添加另一个","like_count":0},{"had_liked":false,"id":56530,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1546483141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546483141","product_id":100017301,"comment_content":"动态规划看得迷迷糊糊,脑壳晕 对于思考题 我还是想到了一种方法 就是针对序列中每个元素 都有两种状态 考察或者不考擦 然后得出不同的状态 然后再继续递归考察后面的元素 即可找出最长的递增序列长度","like_count":0},{"had_liked":false,"id":56410,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1546439574,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1546439574","product_id":100017301,"comment_content":"突然发现动态规划好美啊～希望周五还是不定期惊喜～好让我有时间多看一遍～多看一遍啊😷","like_count":0},{"had_liked":false,"id":56252,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1546411884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546411884","product_id":100017301,"comment_content":"for (int j = 0; j &lt; m; ++j) {&#47;&#47; 初始化第 0 行：a[0\\.\\.0] 与 b[0\\.\\.j] 的 maxlcs<br>    if (a[0] == b[j]) maxlcs[0][j] = 1;<br>    else if (j != 0) maxlcs[0][j] = maxlcs[0][j-1];<br>    else maxlcs[0][j] = 0;<br>  }<br><br> if (a[0] == b[j]) maxlcs[0][j] = 1;<br>这里每次都是1，不是应该累加吗，如果要多次相同，应该累加多次","like_count":0},{"had_liked":false,"id":56234,"user_name":"lianlian","can_delete":false,"product_type":"c1","uid":1298468,"ip_address":"","ucode":"79B48B38259097","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOc0n02eNKflX5ey4TYl1NBfb0kicc20AgayEAGDYylalqHnLTeqMnaJ2iaZsLVmqEo0T0YViadU9Ig/132","comment_is_top":false,"comment_ctime":1546409616,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1546409616","product_id":100017301,"comment_content":"老师好，第一题，最小编辑距离，在讲回溯法的时候，有两个地方是不是写反了。在a[i]前面添加一个跟b[j]相同的字符，然后递归考察a[i]和b[j+1]吧，在b[j]前面添加一个跟a[i]相同的字符，然后递归考察a[i+1]和b[i]吧？<br>第二题，当a[i] == b[j]时，可以是max_lcs[i, j] = max_lcs[i-1, j-1] + 1, 当a[i] != b[j]时，max_lcs[i, j] = max(max_lcs[i-1, j], max_lcs[i, j-1])呢？","like_count":0,"discussions":[{"author":{"id":1180695,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/17/d49cbc5a.jpg","nickname":"爱的天空","note":"","ucode":"154231ACD08907","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110033,"discussion_content":"a[i] 前面添加一个跟 b[j] 相同的字符，那 a[i] 的位置是不是变成了 a[i+1], 所以是 a[i + 1] 与 b[j] 对比啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577716550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}