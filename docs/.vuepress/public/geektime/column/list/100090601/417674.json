{"id":417674,"title":"01｜net/http：使用标准库搭建Server并不是那么简单","content":"<p>你好，我是轩脉刃。欢迎加入我的课程，和我一起从0开始构建Web框架。</p><p>之前我简单介绍了整个课程的设计思路，也是搭建Web框架的学习路径，我们会先基于标准库搭建起Server，然后一步一步增加控制器、路由、中间件，最后完善封装和重启，在整章学完后，你就能建立起一套自己的Web框架了。</p><p>其实你熟悉Golang的话就会知道，用官方提供的 net/http 标准库搭建一个Web Server，是一件非常简单的事。我在面试的时候也发现，不少同学，在怎么搭怎么用的问题上，回答的非常溜，但是再追问一句为什么这个 Server 这么设计，涉及的 net/http 实现原理是什么? 一概不知。</p><p>这其实是非常危险的。<strong>实际工作中，我们会因为不了解底层原理，想当然的认为它的使用方式</strong>，直接导致在代码编写、应用调优的时候出现各种问题。</p><p>所以今天，我想带着你从最底层的 HTTP 协议开始，搞清楚Web Server本质，通过 net/http 代码库梳理 HTTP 服务的主流程脉络，先知其所以然，再搭建框架的Server结构。</p><p>之后，我们会基于今天分析的整个 HTTP 服务主流程原理继续开发。所以这节课你掌握的程度，对于后续内容的理解至关重要。</p><h2>Web Server 的本质</h2><!-- [[[read_end]]] --><p>既然要搭 Web Server，那我也先简单介绍一下，维基百科上是这么解释的，Web Server 是一个通过 HTTP 协议处理Web请求的计算机系统。这句话乍听有点绕口，我给你解释下。</p><p>HTTP 协议，在 OSI 网络体系结构中，是基于TCP/IP之上第七层应用层的协议，全称叫做超文本传输协议。啥意思？就是说HTTP协议传输的都是文本字符，只是这些字符是有规则排列的。这些字符的排列规则，就是一种约定，也就是协议。这个协议还有一个专门的描述文档，就是<a href=\"https://datatracker.ietf.org/doc/html/rfc2616\">RFC 2616</a>。</p><p>对于 HTTP 协议，无论是请求还是响应，传输的消息体都可以分为两个部分：HTTP头部和 HTTP Body体。头部描述的一般是和业务无关但与传输相关的信息，比如请求地址、编码格式、缓存时长等；Body 里面主要描述的是与业务相关的信息。<img src=\"https://static001.geekbang.org/resource/image/cb/e0/cbbafb7ac6128b6e6f8bde0c983c7ae0.jpg?wh=1920x1080\" alt=\"\"></p><p>Web Server 的本质，实际上就是<strong>接收、解析</strong> HTTP 请求传输的文本字符，理解这些文本字符的指令，然后进行<strong>计算</strong>，再将返回值<strong>组织成</strong> HTTP 响应的文本字符，通过 TCP 网络<strong>传输回去</strong>。</p><p>理解了Web Server 干的事情，我们接下来继续看看在语言层面怎么实现。</p><h2>一定要用标准库吗</h2><p>对 Web Server 来说，Golang 提供了 net 库和 net/http 库，分别对应OSI的 TCP 层和 HTTP 层，它们两个负责的就是 HTTP 的接收和解析。</p><p>一般我们会使用 net/http 库解析 HTTP 消息体。但是可能会有人问，如果我想实现 Web 服务，可不可以不用 net/http 库呢？比如我直接用 net 库，逐字读取消息体，然后自己解析获取的传输字符。</p><p>答案是可以的，如果你有兼容其它协议、追求极致性能的需求，而且你有把握能按照 HTTP 的RFC 标准进行解析，那完全可以自己封装一个HTTP库。</p><p>其实在一些大厂中确实是这么做的，每当有一些通用的协议需求，比如一个服务既要支持 HTTP，又要支持 Protocol Buffers，又或者想要支持自定义的协议，那么他们就可能抛弃 HTTP 库，甚至抛弃 net 库，直接自己进行网络事件驱动，解析 HTTP 协议。</p><p>有个开源库，叫 <a href=\"https://github.com/valyala/fasthttp\">FastHTTP</a>，它就是抛弃标准库 net/http 来实现的。作者为了追求极高的HTTP性能，自己封装了网络事件驱动，解析了HTTP协议。你感兴趣的话，可以去看看。</p><p>但是现在绝大部分的 Web 框架，都是基于 net/http 标准库的。我认为原因主要有两点：</p><ul>\n<li>第一是<strong>相信官方开源的力量</strong>。自己实现HTTP协议的解析，不一定会比标准库实现得更好，即使当前标准库有一些不足之处，我们也都相信，随着开源贡献者越来越多，标准库也会最终达到完美。</li>\n<li>第二是<strong>Web 服务架构的变化</strong>。随着容器化、Kubernetes 等技术的兴起，业界逐渐达成共识，单机并发性能并不是评判 Web 服务优劣的唯一标准了，易用性、扩展性也是底层库需要考量的。</li>\n</ul><p>所以总体来说，net/http 标准库，作为官方开源库，其易用性和扩展性都经过开源社区和Golang官方的认证，是我们目前构建Web Server首选的HTTP协议库。</p><p>用net/http来创建一个 HTTP 服务，其实很简单，下面是<a href=\"https://pkg.go.dev/net/http@go1.15.5\">官方文档</a>里的例子。我做了些注释，帮你理解。</p><pre><code class=\"language-go\">// 创建一个Foo路由和处理函数\nhttp.Handle(\"/foo\", fooHandler)\n\n// 创建一个bar路由和处理函数\nhttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n})\n\n// 监听8080端口\nlog.Fatal(http.ListenAndServe(\":8080\", nil))\n</code></pre><p>是不是代码足够简单？一共就5行，但往前继续推进之前，我想先问你几个问题，<strong>这五行代码做了什么，为什么就能启动一个 HTTP 服务，具体的逻辑是什么样的</strong>？</p><p>要回答这些问题，你就要深入理解 net/http 标准库。要不然，只会简单调用，却不知道原理，后面哪里出了问题，或者你想调优，就无从下手了。</p><p>所以，我们先来看看 net/http 标准库，从代码层面搞清楚整个 HTTP 服务的主流程原理，最后再基于原理讲实现。</p><h2>net/http 标准库怎么学</h2><p>想要在 net/http 标准库纷繁复杂的代码层级和调用中，弄清楚主流程不是一件容易事。要快速熟悉一个标准库，就得找准方法。</p><p><strong>这里我教给你一个快速掌握代码库的技巧：库函数 &gt; 结构定义 &gt; 结构函数</strong>。</p><p>简单来说，就是当你在阅读一个代码库的时候，不应该从上到下阅读整个代码文档，而应该先阅读整个代码库提供的对外库函数（function），再读这个库提供的结构（struct/class），最后再阅读每个结构函数（method）。<img src=\"https://static001.geekbang.org/resource/image/81/79/8150f242d1f0ee96f44793112c4dcf79.jpg?wh=1920x1080\" alt=\"\"></p><p>为什么要这么学呢？因为这种阅读思路和代码库作者的思路是一致的。</p><p>首先搞清楚这个库要提供什么功能（提供什么样的对外函数），然后为了提供这些功能，我要把整个库分为几个核心模块（结构），最后每个核心模块，我应该提供什么样的能力（具体的结构函数）来满足我的需求。</p><h3>库函数（功能）</h3><p>按照这个思路，我们来阅读 net/http 库，先看提供的对外库函数是为了实现哪些功能。这里顺带补充说明一下，我们课程对应的Golang源码的版本是1.15.5，你可以在<a href=\"https://github.com/gohade/coredemo/blob/geekbang/01/go.mod\">01分支的coredemo/go.mod</a>里看到。</p><p>你直接通过  <code>go doc net/http | grep \"^func\"</code> 命令行能查询出 net/http 库所有的对外库函数：</p><pre><code>func CanonicalHeaderKey(s string) string\nfunc DetectContentType(data []byte) string\nfunc Error(w ResponseWriter, error string, code int)\nfunc Get(url string) (resp *Response, err error)\nfunc Handle(pattern string, handler Handler)\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request))\nfunc Head(url string) (resp *Response, err error)\nfunc ListenAndServe(addr string, handler Handler) error\nfunc ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error\nfunc MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser\nfunc NewRequest(method, url string, body io.Reader) (*Request, error)\nfunc NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error)\nfunc NotFound(w ResponseWriter, r *Request)\nfunc ParseHTTPVersion(vers string) (major, minor int, ok bool)\nfunc ParseTime(text string) (t time.Time, err error)\nfunc Post(url, contentType string, body io.Reader) (resp *Response, err error)\nfunc PostForm(url string, data url.Values) (resp *Response, err error)\nfunc ProxyFromEnvironment(req *Request) (*url.URL, error)\nfunc ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)\nfunc ReadRequest(b *bufio.Reader) (*Request, error)\nfunc ReadResponse(r *bufio.Reader, req *Request) (*Response, error)\nfunc Redirect(w ResponseWriter, r *Request, url string, code int)\nfunc Serve(l net.Listener, handler Handler) error\nfunc ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, ...)\nfunc ServeFile(w ResponseWriter, r *Request, name string)\nfunc ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error\nfunc SetCookie(w ResponseWriter, cookie *Cookie)\nfunc StatusText(code int) string\n</code></pre><p>在这个库提供的方法中，我们去掉一些 New 和 Set 开头的函数，因为你从命名上可以看出，这些函数是对某个对象或者属性的设置。</p><p>剩下的函数大致可以分成三类：</p><ul>\n<li>为服务端提供创建 HTTP 服务的函数，名字中一般包含 Serve 字样，比如 Serve、ServeFile、ListenAndServe等。</li>\n<li>为客户端提供调用 HTTP 服务的类库，以 HTTP 的 method 同名，比如 Get、Post、Head等。</li>\n<li>提供中转代理的一些函数，比如ProxyURL、ProxyFromEnvironment 等。</li>\n</ul><p>我们现在研究的是，如何创建一个 HTTP 服务，所以关注包含 Serve 字样的函数就可以了。</p><pre><code class=\"language-go\">// 通过监听的URL地址和控制器函数来创建HTTP服务\nfunc ListenAndServe(addr string, handler Handler) error{}\n// 通过监听的URL地址和控制器函数来创建HTTPS服务\nfunc ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error{}\n// 通过net.Listener结构和控制器函数来创建HTTP服务\nfunc Serve(l net.Listener, handler Handler) error{}\n// 通过net.Listener结构和控制器函数来创建HTTPS服务\nfunc ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error{}\n</code></pre><h3>结构定义（模块）</h3><p>然后，我们过一遍这个库提供的所有struct，看看核心模块有哪些，同样使用 go doc:</p><pre><code class=\"language-go\">&nbsp;go doc net/http | grep \"^type\"|grep struct\n</code></pre><p>你可以看到整个库最核心的几个结构：</p><pre><code class=\"language-go\">type Client struct{ ... }\ntype Cookie struct{ ... }\ntype ProtocolError struct{ ... }\ntype PushOptions struct{ ... }\ntype Request struct{ ... } \ntype Response struct{ ... }\ntype ServeMux struct{ ... }\ntype Server struct{ ... }\ntype Transport struct{ ... }\n</code></pre><p>看结构的名字或者go doc查看结构说明文档，能逐渐了解它们的功能：</p><ul>\n<li>Client 负责构建HTTP客户端；</li>\n<li>Server 负责构建HTTP服务端；</li>\n<li>ServerMux 负责HTTP服务端路由；</li>\n<li>Transport、Request、Response、Cookie负责客户端和服务端传输对应的不同模块。</li>\n</ul><p>现在通过库方法（function）和结构体（struct），我们对整个库的结构和功能有大致印象了。整个库承担了两部分功能，一部分是构建HTTP客户端，一部分是构建HTTP服务端。</p><p>构建的HTTP服务端除了提供真实服务之外，也能提供代理中转服务，它们分别由 Client 和 Server 两个数据结构负责。除了这两个最重要的数据结构之外，HTTP 协议的每个部分，比如请求、返回、传输设置等都有具体的数据结构负责。</p><h3>结构函数（能力）</h3><p>下面从具体的需求出发，我们来阅读具体的结构函数（method）。</p><p>我们当前的需求是创建 HTTP 服务，开头我举了一个最简单的例子：</p><pre><code class=\"language-go\">// 创建一个Foo路由和处理函数\nhttp.Handle(\"/foo\", fooHandler)\n\n// 创建一个bar路由和处理函数\nhttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n})\n\n// 监听8080端口\nlog.Fatal(http.ListenAndServe(\":8080\", nil))\n</code></pre><p>我们跟着 http.ListenAndServe 这个函数来理一下 net/http 创建服务的主流程逻辑。</p><p>阅读具体的代码逻辑用 <code>go doc</code> 命令明显就不够了，你需要两个东西：</p><p>一个是可以灵活进行代码跳转的 IDE，VS Code 和 GoLand 都是非常好的工具。以我们现在要查看的 http.ListenAndServe 这个函数为例，我们可以从上面的例子代码中，直接通过IDE跳转到这个函数的源码中阅读，有一个能灵活跳转的IDE工具是非常必要的。</p><p>另一个是可以方便记录代码流程的笔记，这里我的个人方法是使用思维导图。</p><p>具体方法是<strong>将要分析的代码从入口处一层层记录下来，每个函数，我们只记录其核心代码，然后对每个核心代码一层层解析</strong>。记得把思维导图的结构设置为右侧分布，这样更直观。</p><p>比如下面这张图，就是我解析部分HTTP库服务端画的<a href=\"https://github.com/gohade/geekbang/tree/main/01\">代码分析图</a>。</p><p><img src=\"https://static001.geekbang.org/resource/image/3a/cd/3ab5c45e113ddf4cc3bdb0e09c85c7cd.png?wh=2464x1192\" alt=\"\"></p><p>这张图看上去层级复杂，不过不用担心，对照着思维导图，我带你一层一层阅读，讲解每一层的逻辑，带你看清楚代码背后的设计思路。</p><p>我们先顺着 http.ListenAndServe 的脉络读。</p><p><strong>第一层</strong>，http.ListenAndServe 本质是通过创建一个 Server 数据结构，调用 <code>server.ListenAndServe</code> 对外提供服务，这一层完全是比较简单的封装，目的是，将Server结构创建服务的方法 ListenAndServe ，直接作为库函数对外提供，增加库的易用性。</p><p><img src=\"https://static001.geekbang.org/resource/image/4e/01/4eeaace11e29989b3bfc2344ca8e4001.png?wh=810x582\" alt=\"\"></p><p>进入到<strong>第二层</strong>，创建服务的方法 ListenAndServe 先定义了监听信息 <code>net.Listen</code>，然后调用 Serve 函数。</p><p>而在<strong>第三层</strong> Serve 函数中，用了一个 for 循环，通过 <code>l.Accept</code>不断接收从客户端传进来的请求连接。当接收到了一个新的请求连接的时候，通过 <code>srv.NewConn</code>创建了一个连接结构（<code>http.conn</code>），并创建一个 Goroutine 为这个请求连接对应服务（<code>c.serve</code>）。</p><p>从第四层开始，后面就是单个连接的服务逻辑了。</p><p><img src=\"https://static001.geekbang.org/resource/image/79/72/798e88645b4d77a3da302a6c6d719472.jpeg?wh=1026x860\" alt=\"\"></p><p>在<strong>第四层</strong>，<code>c.serve</code>函数先判断本次  HTTP 请求是否需要升级为 HTTPs，接着创建读文本的reader和写文本的buffer，再进一步读取本次请求数据，然后<strong>第五层</strong>调用最关键的方法 <code>serverHandler{c.server}.ServeHTTP(w,&nbsp;w.req)</code> ，来处理这次请求。</p><p>这个关键方法是为了实现自定义的路由和业务逻辑，调用写法是比较有意思的：</p><pre><code class=\"language-go\">serverHandler{c.server}.ServeHTTP(w,&nbsp;w.req)\n</code></pre><p>serverHandler结构体，是标准库封装的，代表“请求对应的处理逻辑”，它只包含了一个指向总入口服务server的指针。</p><p>这个结构将总入口的服务结构Server和每个连接的处理逻辑巧妙联系在一起了，你可以看接着的<strong>第六层</strong>逻辑：</p><pre><code class=\"language-go\">// serverHandler 结构代表请求对应的处理逻辑\ntype serverHandler struct {\n\tsrv *Server\n}\n\n// 具体处理逻辑的处理函数\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n\thandler := sh.srv.Handler\n\tif handler == nil {\n\t\thandler = DefaultServeMux\n\t}\n\t...\n\thandler.ServeHTTP(rw, req)\n}\n</code></pre><p>如果入口服务server结构已经设置了 Handler，就调用这个Handler来处理此次请求，反之则使用库自带的 DefaultServerMux。</p><p>这里的serverHandler设计，能同时保证这个库的扩展性和易用性：你可以很方便使用默认方法处理请求，但是一旦有需求，也能自己扩展出方法处理请求。</p><p>那么DefaultServeMux 是怎么寻找 Handler 的呢，这就是思维导图的最后一部分<strong>第七层</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/34/fe/344fc7d6f2d1aca635ef1284185621fe.png?wh=2268x418\" alt=\"\"></p><p><code>DefaultServeMux.Handle</code> 是一个非常简单的 map 实现，key 是路径（pattern），value 是这个 pattern 对应的处理函数（handler）。它是通过 <code>mux.match</code>(path) 寻找对应 Handler，也就是从 DefaultServeMux 内部的 map 中直接根据 key 寻找到 value 的。</p><p>这种根据 map 直接查找路由的方式是不是可以满足我们的路由需求呢？我们会在第三讲路由中详细解说。</p><p>好，HTTP库 Server 的代码流程我们就梳理完成了，整个逻辑线大致是：</p><pre><code class=\"language-plain\">创建服务 -&gt; 监听请求 -&gt; 创建连接 -&gt; 处理请求\n</code></pre><p>如果你觉得层次比较多，对照着思维导图多看几遍就顺畅了。这里我也给你整理了一下逻辑线各层的关键结论：</p><ul>\n<li>第一层，标准库创建HTTP服务是通过创建一个 Server 数据结构完成的；</li>\n<li>第二层，Server 数据结构在for循环中不断监听每一个连接；</li>\n<li>第三层，每个连接默认开启一个 Goroutine 为其服务；</li>\n<li>第四、五层，serverHandler 结构代表请求对应的处理逻辑，并且通过这个结构进行具体业务逻辑处理；</li>\n<li>第六层，Server 数据结构如果没有设置处理函数 Handler，默认使用 DefaultServerMux处理请求；</li>\n<li>第七层，DefaultServerMux 是使用 map 结构来存储和查找路由规则。</li>\n</ul><p>如果你对上面几点关键结论还有疑惑的，可以再去看一遍思维导图。阅读核心逻辑代码是会有点枯燥，但是<strong>这条逻辑线是HTTP服务启动最核心的主流程逻辑</strong>，后面我们会基于这个流程继续开发，你要掌握到能背下来的程度。千万不要觉得要背诵了，压力太大，其实对照着思维导图，顺几遍逻辑，理解了再记忆就很容易。</p><h2>创建框架的Server结构</h2><p>现在原理弄清楚了，该下手搭 HTTP 服务了。</p><p>刚刚咱也分析了主流程代码，其中第一层的关键结论就是：net/http 标准库创建服务，实质上就是通过创建 Server 数据结构来完成的。所以接下来，我们就来创建一个 Server 数据结构。</p><p>通过 <code>go doc net/http.Server</code> 我们可以看到 Server 的结构：</p><pre><code class=\"language-go\">type Server struct {\n    // 请求监听地址\n\tAddr string\n    // 请求核心处理函数\n\tHandler Handler \n\t...\n}\n</code></pre><p>其中最核心的是 Handler这个字段，从主流程中我们知道（第六层关键结论），当 Handler 这个字段设置为空的时候，它会默认使用 DefaultServerMux 这个路由器来填充这个值，但是我们一般都会使用自己定义的路由来替换这个默认路由。</p><p>所以在框架代码中，我们要创建一个自己的核心路由结构，实现 Handler。</p><p>先来理一下目录结构，我们在<a href=\"https://github.com/gohade/coredemo/tree/geekbang/01\">GitHub</a>上创建一个项目coredemo，这个项目是这门课程所有的代码集合，包含要实现的框架和使用框架的示例业务代码。</p><p><strong>所有的框架代码都存放在framework文件夹中，而所有的示例业务代码都存放在framework文件夹之外</strong>。这里为了后面称呼方便，我们就把framework文件夹叫框架文件夹，而把外层称为业务文件夹。</p><p>当然 GitHub 上的这个coredemo是我在写课程的时候为了演示创建的，推荐你跟着一步一步写。成品在<a href=\"https://github.com/gohade/hade\">hade项目</a>里，你可以先看看，在最后发布的时候，我们会将整个项目进行发布。在一个新的业务中，如果要使用到我们自己写好的框架，可以直接通过引用 “import 项目地址/framework” 来引入，在最后一部分做实战项目的时候我们会具体演示。</p><p>好，下面我们来一步步实现这个项目。</p><p>创建一个framework文件夹，新建core.go，在里面写入。</p><pre><code class=\"language-go\">package framework\n\nimport \"net/http\"\n\n// 框架核心结构\ntype Core struct {\n}\n\n// 初始化框架核心结构\nfunc NewCore() *Core {\n\treturn &amp;Core{}\n}\n\n// 框架核心结构实现Handler接口\nfunc (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n\t// TODO\n}\n\n</code></pre><p>而在业务文件夹中创建main.go，其中的main函数就变成这样：</p><pre><code class=\"language-go\">func main() {\n\tserver := &amp;http.Server{\n        // 自定义的请求核心处理函数\n\t\tHandler: framework.NewCore(),\n        // 请求监听地址\n\t\tAddr:&nbsp; &nbsp; \":8080\",\n\t}\n\tserver.ListenAndServe()\n}\n\n</code></pre><p>整理下这段代码，我们通过自己创建了 Server 数据结构，并且在数据结构中创建了自定义的Handler（Core数据结构）和监听地址，实现了一个 HTTP 服务。这个服务的具体业务逻辑都集中在我们自定义的Core结构中，后续我们要做的事情就是不断丰富这个Core数据结构的功能逻辑。</p><p>后续每节课学完之后，我都会把代码放在对应的GitHub的分支中。你跟着课程敲完代码过程中有不了解的地方，可以对比参考分支。</p><p>本节课我们完成的代码分支是：<a href=\"https://github.com/gohade/coredemo/tree/geekbang/01\">geekbang/01</a> ，代码结构我也截了图：<img src=\"https://static001.geekbang.org/resource/image/2c/d2/2c481d0c93efede365a7e079c4eb49d2.png?wh=734x396\" alt=\"\"></p><h2>小结</h2><p>今天我以 net/http 标准库为例，分享了快速熟悉代码库的技巧，<strong>库函数 &gt; 结构定义 &gt; 结构函数。</strong>在阅读代码库时，从功能出发，先读对外库函数，再细读这个库提供的结构，搞清楚功能和对应结构之后，最后基于实际需求看每个结构函数。</p><p>读每个结构函数的时候，我们使用思维导图梳理了net/http 创建 HTTP 服务的主流程逻辑，基于主流程原理，创建了一个属于我们框架的 Server 结构，你可以再回顾一下这张图。</p><p><img src=\"https://static001.geekbang.org/resource/image/3a/cd/3ab5c45e113ddf4cc3bdb0e09c85c7cd.png?wh=2464x1192\" alt=\"\"></p><p>主流程的链条比较长，但是你先理顺逻辑，记住几个关键的节点，再结合思维导图，就能记住整个主流程逻辑了，之后所有关于 HTTP 的细节和问题，我们都会基于这个主流程逻辑来思考和回答。</p><h2>思考题</h2><p>今天我用思维导图梳理了最核心的 HTTP 服务启动的主流程逻辑，知易行难，你不妨用这个思路做做下面这道思考题，尝试绘制出属于你自己的思维导图。</p><p>HTTP 库提供 FileServer 来封装对文件读取的 HTTP 服务。实现代码也非常简单：</p><pre><code class=\"language-go\">fs := http.FileServer(http.Dir(\"/home/bob/static\"))\nhttp.Handle(\"/static/\", http.StripPrefix(\"/static\", fs))\n</code></pre><p>请问它的主流程逻辑是什么？你认为其中最关键的节点是什么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有帮助，也欢迎你把今天的内容分享给你身边的朋友，邀请他一起学习。</p>","neighbors":{"left":{"article_title":"开篇词｜为什么我们要从零开发框架？","id":417657},"right":{"article_title":"02｜Context：请求控制器，让每个请求都在掌控之中","id":418283}},"comments":[{"had_liked":false,"id":312748,"user_name":"程旭","can_delete":false,"product_type":"c1","uid":2043208,"ip_address":"","ucode":"D02F98AC07E1D3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/2d/48/bc2648c4.jpg","comment_is_top":false,"comment_ctime":1631965184,"is_pvip":false,"replies":[{"id":"113375","content":"你好，你的逻辑是正确的，不过可能过多关注分支细节。在使用思维导图的时候，如果对于比较复杂的逻辑，我们需要分析哪些是关键节点，哪些是非关键节点。<br><br>比如FileServer, 其关键点有两个：<br><br>1  fileHandler 我们能和ListenAndServe 连接起来，它提供了ServeHTTP的方法， 这个是请求处理的入口函数<br><br>2 FileServer 最本质的函数是封装了io.CopyN，基本逻辑是：<br><br>如果是读取文件夹，则遍历文件夹内所有文件，将文件名直接输出返回值。<br>如果是读取文件，则设置文件的阅读指针（如果需要多次读取文件，创建goroutine，且为每个goroutine创建阅读指针），使用io.CopyN读取文件内容输出返回值。","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1632163702,"ip_address":"","comment_id":312748,"utype":1}],"discussion_count":3,"race_medal":0,"score":"87531311104","product_id":100090601,"comment_content":"1. http.FileServer 创建 FileHandler 数据结构<br>2. FileHandler 结构体中包含 FileSystem 接口，FileSystem 接口包含Open 方法<br>3. http.Dir 的 Open 方法 实现  FileSystem 接口 的 Open 方法<br>4. http.Dir 的 Open 方法对表示字符串的文件路径进行判断：<br>    （1）先判断 分隔符是否为 &quot;&#47;&quot;且该字符串中是否包含分隔符，若不满足 返回 nil 和 error信息 &quot;http: invalid character in file path&quot;<br>    （2）将 http.Dir 从 Dir 类型转换为 string 类型，判断该是否为空，若为空，将 dir 赋值为 &quot;.&quot;<br>    （3）使用 path.Clean ，filepath.FromSlash 和 filepath.Join 方法获得路径全名<br>    （4）使用 os.Open 方法打开文件，如果打开失败，返回错误信息，如果成功以读模式打开文件","like_count":21,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527099,"discussion_content":"你好，你的逻辑是正确的，不过可能过多关注分支细节。在使用思维导图的时候，如果对于比较复杂的逻辑，我们需要分析哪些是关键节点，哪些是非关键节点。\n\n比如FileServer, 其关键点有两个：\n\n1  fileHandler 我们能和ListenAndServe 连接起来，它提供了ServeHTTP的方法， 这个是请求处理的入口函数\n\n2 FileServer 最本质的函数是封装了io.CopyN，基本逻辑是：\n\n如果是读取文件夹，则遍历文件夹内所有文件，将文件名直接输出返回值。\n如果是读取文件，则设置文件的阅读指针（如果需要多次读取文件，创建goroutine，且为每个goroutine创建阅读指针），使用io.CopyN读取文件内容输出返回值。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1632163702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"discussion":{"id":534372,"discussion_content":"确实没想到老师还会看第一章的评论 让我有每天在评论下面交作业的动力了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638174843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":527099,"ip_address":""},"score":534372,"extra":""}]},{"author":{"id":2043208,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2d/48/bc2648c4.jpg","nickname":"程旭","note":"","ucode":"D02F98AC07E1D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397468,"discussion_content":"多谢作者指导，写的时候总感觉自己有点跑偏。\n不过这次源码阅读有个意外收获，我发现 Rune 类型 是通过 RuneSelf 这个常量来做Rune类型的判断，RuneSelf 的值设置为 0x80 ，小于 0x80 则为单个字符。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1632625428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311984,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1631584593,"is_pvip":false,"replies":[{"id":"113071","content":"恩，我平时阅读源码就是这样阅读的。经验之谈。感谢支持。","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1631599822,"ip_address":"","comment_id":311984,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53171192145","product_id":100090601,"comment_content":"很赞， 读源码的 思路和 思维导图 很值得学习","like_count":13,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526820,"discussion_content":"恩，我平时阅读源码就是这样阅读的。经验之谈。感谢支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631599822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311982,"user_name":"Middleware","can_delete":false,"product_type":"c1","uid":1072015,"ip_address":"","ucode":"C0028293ECDD47","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/8f/4b0ab5db.jpg","comment_is_top":false,"comment_ctime":1631583765,"is_pvip":true,"replies":[{"id":"113123","content":"你好，在后面有一章会专门介绍目录的章节，叫《如何系统设计框架的整体目录》。每一个章节，我都有存放源码在github项目的对应分支，如果希望跟着上手敲一遍，可以跟着文章敲完代码，跟着对应分支对一遍。https:&#47;&#47;github.com&#47;gohade&#47;coredemo&#47;tree&#47;geekbang&#47;01<br><br>谢谢支持，另外为你的ID middleware 点个赞。","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1631670625,"ip_address":"","comment_id":311982,"utype":1}],"discussion_count":3,"race_medal":0,"score":"40286289429","product_id":100090601,"comment_content":"目录有点不清晰，从零开始，那么是不是应该给出建立合适的文件目录结构，命名。我们也能跟着上手敲一遍。比如这个 framework .目录是如何命名。希望老师真的能手把手","like_count":9,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526819,"discussion_content":"你好，在后面有一章会专门介绍目录的章节，叫《如何系统设计框架的整体目录》。每一个章节，我都有存放源码在github项目的对应分支，如果希望跟着上手敲一遍，可以跟着文章敲完代码，跟着对应分支对一遍。https://github.com/gohade/coredemo/tree/geekbang/01\n\n谢谢支持，另外为你的ID middleware 点个赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631670625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1072015,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/8f/4b0ab5db.jpg","nickname":"Middleware","note":"","ucode":"C0028293ECDD47","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393993,"discussion_content":"Nice ，感谢老师的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631681179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242122,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/0a/cf728857.jpg","nickname":"YourSweetHeart","note":"","ucode":"38843F447B03F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393858,"discussion_content":"强子nb","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631619458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312326,"user_name":"好家庭","can_delete":false,"product_type":"c1","uid":1727613,"ip_address":"","ucode":"29A192102E0095","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyibojtJCnzAE7E8sMqgiaiaAHl3FuzcXcicQnjnT5huUFMxGUMzV5NGuqzzHHr8dBzCs3xfuhwcOnPw/132","comment_is_top":false,"comment_ctime":1631752242,"is_pvip":false,"replies":[{"id":"113373","content":"http服务在启动的时候，会默认开启keep-alive机制。keep-alive机制就是一个连接在一个请求结束之后，并不关闭当前连接，在下个请求的时候也能使用这个连接。这个for循环就是为keep-alive机制服务的。在服务一个连接的时候，处理完一个请求，并不关闭这个连接，而是循环等待下个请求。<br><br>那要关闭keep-alive怎么办呢？你也可以在for循环中的w.conn.server.doKeepAlives 看到，它判断如果服务端的 disableKeepAlives 不是0，则设置了关闭keep-alive，则就不进行for循环了。","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1632162839,"ip_address":"","comment_id":312326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27401556018","product_id":100090601,"comment_content":"老师，请问 go c.serve(connCtx) 里面为什么还有一个循环？c值得是一个connection，我理解不是每个连接处理一次就好了吗，为啥还有一个for循环呢？<br>···<br>&#47; Serve a new connection.<br>func (c *conn) serve(ctx context.Context) {<br>\tc.remoteAddr = c.rwc.RemoteAddr().String()<br>\tctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())<br>\tdefer func() {<br>\t\tif err := recover(); err != nil &amp;&amp; err != ErrAbortHandler {<br>\t\t\tconst size = 64 &lt;&lt; 10<br>\t\t\tbuf := make([]byte, size)<br>\t\t\tbuf = buf[:runtime.Stack(buf, false)]<br>\t\t\tc.server.logf(&quot;http: panic serving %v: %v\\n%s&quot;, c.remoteAddr, err, buf)<br>\t\t}<br>\t\tif !c.hijacked() {<br>\t\t\tc.close()<br>\t\t\tc.setState(c.rwc, StateClosed)<br>\t\t}<br>\t}()<br><br>\t...<br><br>\tfor {<br>\t\tw, err := c.readRequest(ctx)<br>\t\tif c.r.remain != c.server.initialReadLimitSize() {<br>\t\t\t&#47;&#47; If we read any bytes off the wire, we&#39;re active.<br>\t\t\tc.setState(c.rwc, StateActive)<br>\t\t}<br>\t\tif err != nil {<br>\t\t\tconst errorHeaders = &quot;\\r\\nContent-Type: text&#47;plain; charset=utf-8\\r\\nConnection: close\\r\\n\\r\\n&quot;<br><br>...<br>\t\t}<br>...<br>```","like_count":7,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526937,"discussion_content":"http服务在启动的时候，会默认开启keep-alive机制。keep-alive机制就是一个连接在一个请求结束之后，并不关闭当前连接，在下个请求的时候也能使用这个连接。这个for循环就是为keep-alive机制服务的。在服务一个连接的时候，处理完一个请求，并不关闭这个连接，而是循环等待下个请求。\n\n那要关闭keep-alive怎么办呢？你也可以在for循环中的w.conn.server.doKeepAlives 看到，它判断如果服务端的 disableKeepAlives 不是0，则设置了关闭keep-alive，则就不进行for循环了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632162839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312632,"user_name":"Groot","can_delete":false,"product_type":"c1","uid":1001257,"ip_address":"","ucode":"D3919AFA300C79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/29/425a2030.jpg","comment_is_top":false,"comment_ctime":1631902124,"is_pvip":false,"replies":[{"id":"113322","content":"你好，非常感谢支持。非常高兴本篇能让你有一些收获。后续文章是介绍写框架的过程的。感谢。","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1632016676,"ip_address":"","comment_id":312632,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18811771308","product_id":100090601,"comment_content":"一篇文章值回票价，感觉后续的文章都是在做慈善 😂<br><br>受益匪浅，感谢分享 👍","like_count":4,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527055,"discussion_content":"你好，非常感谢支持。非常高兴本篇能让你有一些收获。后续文章是介绍写框架的过程的。感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632016676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/29/425a2030.jpg","nickname":"Groot","note":"","ucode":"D3919AFA300C79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397981,"discussion_content":"这个专栏看到 05 节就果断放弃了，后面写的代码实在令人不敢恭维，还不如去看 Github 上优秀的框架源码\n\n这节介绍的看源码的方法挺不错，可以直接用起来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632710308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312577,"user_name":"布丁老厮","can_delete":false,"product_type":"c1","uid":1363166,"ip_address":"","ucode":"72B86A2BE251E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/cc/de/59a530dc.jpg","comment_is_top":false,"comment_ctime":1631872363,"is_pvip":false,"replies":[{"id":"113374","content":"是的，确实是顺序错误，已经联系编辑进行修改了。感谢提醒。","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1632163116,"ip_address":"","comment_id":312577,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14516774251","product_id":100090601,"comment_content":"老师，HTTP 库 Server 的代码流程是不是应该为：创建服务 -&gt; 监听请求 -&gt; 创建连接 -&gt; 处理请求 要更准确一点？因为net.Listen是在srv.newConn之前进行的。","like_count":3,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527033,"discussion_content":"是的，确实是顺序错误，已经联系编辑进行修改了。感谢提醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632163116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313136,"user_name":"ghostwritten","can_delete":false,"product_type":"c1","uid":1308196,"ip_address":"","ucode":"AE512F2E24A1A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/24/5a9277f1.jpg","comment_is_top":false,"comment_ctime":1632293979,"is_pvip":false,"replies":[{"id":"113506","content":"👍坚持一起仗剑走天涯","user_name":"作者回复","user_name_real":"多少","uid":"2547771","ctime":1632414754,"ip_address":"","comment_id":313136,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10222228571","product_id":100090601,"comment_content":"打卡第二天：<br>https:&#47;&#47;github.com&#47;gohade&#47;coredemo&#47;blob&#47;geekbang&#47;01&#47;go.mod<br>https:&#47;&#47;datatracker.ietf.org&#47;doc&#47;html&#47;rfc2616<br>https:&#47;&#47;github.com&#47;valyala&#47;fasthttp<br>https:&#47;&#47;pkg.go.dev&#47;net&#47;http@go1.15.5<br><br>Web Server 第一个go架构：net&#47;http<br>熟悉库技巧：库函数 &gt; 结构定义 &gt; 结构函数<br>查看库命令：<br>go doc net&#47;http | grep &quot;^func<br>go doc net&#47;http | grep &quot;^type&quot;|grep struct<br><br>结构函数如下：<br>&#47;&#47; 创建一个Foo路由和处理函数<br>http.Handle(&quot;&#47;foo&quot;, fooHandler)<br><br>&#47;&#47; 创建一个bar路由和处理函数<br>http.HandleFunc(&quot;&#47;bar&quot;, func(w http.ResponseWriter, r *http.Request) {<br>  fmt.Fprintf(w, &quot;Hello, %q&quot;, html.EscapeString(r.URL.Path))<br>})<br><br>&#47;&#47; 监听8080端口<br>log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))<br><br>画源代码分析图，学会脑图构思是关键（略）<br>流程：<br> - 第一层，标准库创建 HTTP 服务是通过创建一个 Server 数据结构完成的；<br> - 第二层，Server 数据结构在 for 循环中不断监听每一个连接；<br> - 第三层，每个连接默认开启一个 Goroutine 为其服务；<br> - 第四、五层，serverHandler 结构代表请求对应的处理逻辑，并且通过这个结构进行具体业务逻辑处理；<br> - 第六层，Server 数据结构如果没有设置处理函数 Handler，默认使用 `DefaultServerMux` 处理请求；<br> - 第七层，`DefaultServerMux` 是使用 map 结构来存储和查找路由规则。<br><br><br>创建框架的 Server 结构<br>1.创建一个 coredemo&#47;framework&#47;core.go,实现具体业务逻辑<br>&#47;&#47; 框架核心结构<br>type Core struct {<br>}<br><br>&#47;&#47; 初始化框架核心结构<br>func NewCore() *Core {<br>  return &amp;Core{}<br>}<br><br>&#47;&#47; 框架核心结构实现Handler接口<br>func (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {<br>  &#47;&#47; TODO<br>}<br><br>2.创建一个 coredemo&#47;main.go,创建服务的方法 `ListenAndServe` 先定义了监听信息 `net.Listen`，然后调用 `Serve` 函数,实现对外提供服务<br><br>","like_count":2,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527246,"discussion_content":"👍坚持一起仗剑走天涯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632414754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312229,"user_name":"逗逼章鱼","can_delete":false,"product_type":"c1","uid":1197314,"ip_address":"","ucode":"5E8A5E1CC375B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJfTnE46bP9zFU0MJicYZmKYTPhm97YjgSEmNVKr3ic1BY3CL8ibPUFCBVTqyoHQPpBcbe9GRKEN1CyA/132","comment_is_top":false,"comment_ctime":1631694842,"is_pvip":false,"replies":[{"id":"113372","content":"是的，主要在于第六层的ServeHTTP，不同的handler实现的ServeHTTP是不一样的。","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1632162014,"ip_address":"","comment_id":312229,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10221629434","product_id":100090601,"comment_content":"FileServer 的主要流程前面五层应该都一样，第六层开始不一样，FileServer --&gt; fileHandler --&gt; fileHandler里实现的 ServeHTTP --&gt; serveFile 。","like_count":2,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526903,"discussion_content":"是的，主要在于第六层的ServeHTTP，不同的handler实现的ServeHTTP是不一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632162014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356975,"user_name":"无隅","can_delete":false,"product_type":"c1","uid":1058801,"ip_address":"广东","ucode":"756E8D6E915FF0","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/f1/e4fc57a3.jpg","comment_is_top":false,"comment_ctime":1662775744,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662775744","product_id":100090601,"comment_content":"算法有时要写服务端程序，搜go看到这门课，意外的惊喜～","like_count":1},{"had_liked":false,"id":356937,"user_name":"小马🐎","can_delete":false,"product_type":"c1","uid":1107540,"ip_address":"上海","ucode":"8CA466A4004BDB","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/54/86056001.jpg","comment_is_top":false,"comment_ctime":1662711690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662711690","product_id":100090601,"comment_content":"代码中NewCore返回是一个自定义的core结构体 如何和封装好的server里面的handler成为了同一个类型？不报错的嘛？还请指教下！","like_count":0},{"had_liked":false,"id":331984,"user_name":"老兵","can_delete":false,"product_type":"c1","uid":1471109,"ip_address":"","ucode":"F004F8EC90E5B0","user_header":"https://static001.geekbang.org/account/avatar/00/16/72/85/c337e9a1.jpg","comment_is_top":false,"comment_ctime":1642940730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642940730","product_id":100090601,"comment_content":"1. 使用go doc net&#47;http.FileServer | grep &#39;^func&#39; 得到结果 func FileServer(root FileSystem) Handler<br>2. 使用fs作为handler传递给http.Handle 作为参数，这样可以更加route的map，得到fs作为静态文件的handler方法。<br>3. FileServer方法中创建一个fileHandler的结构，文件路径作为root被传入fileHandler的结构中。与此同时handler都需要实现ServeHTTP的方法。<br>4. fileHanlder.ServeHTTP 方法中在使用&quot;upath := r.URL.Path&quot;得到upath后，将这个路径作为文件路径调用serveFile方法，这个方法根据请求文件进行Open操作。<br>5. 最后将文件读取的内容作为参数调用serveContent方法，方法中对io操作进行处理，最后io.CopyN将content赋值到w（ResponseWriter）中，也就是response","like_count":0},{"had_liked":false,"id":325547,"user_name":"Geek_8ed998","can_delete":false,"product_type":"c1","uid":1793879,"ip_address":"","ucode":"1C164836354665","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLJHTX1IwEl1Eh1CCO2ejL2gKe08Vxib61UZz9l5WGA81ObK0Nk5MCZ3ic6IWcW5kyX0DtwBNMEMl2Q/132","comment_is_top":false,"comment_ctime":1639019898,"is_pvip":false,"replies":[{"id":"118657","content":"这个是gomod的机制，如果你的项目在gomod中命名为coredemo， 那么coredemo&#47;framework就会去你的项目下的framework目录查询，当然你这里也能写成.&#47;framework。但是别人用到你的库的时候就会出现错误","user_name":"作者回复","user_name_real":"编辑","uid":"1069186","ctime":1639608183,"ip_address":"","comment_id":325547,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639019898","product_id":100090601,"comment_content":"老师为啥你代码里mani.go里面import 是&quot;coredemo&#47;framework&quot; ，而我这里按你一样的目录结构要写成&quot;.&#47;framework&quot;才能找到包","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539091,"discussion_content":"这个是gomod的机制，如果你的项目在gomod中命名为coredemo， 那么coredemo/framework就会去你的项目下的framework目录查询，当然你这里也能写成./framework。但是别人用到你的库的时候就会出现错误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639608184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323831,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638176864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638176864","product_id":100090601,"comment_content":"找到了 dirList 打印文件目录 ","like_count":0},{"had_liked":false,"id":323830,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638176811,"is_pvip":false,"replies":[{"id":"119258","content":"赞","user_name":"作者回复","user_name_real":"编辑","uid":"1069186","ctime":1640223307,"ip_address":"","comment_id":323830,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638176811","product_id":100090601,"comment_content":"1. dir 是一个自定义类型 本质是字符串 实现了 FileSystem 接口<br>2. 通过http.StripPrefix(&quot;&#47;static&quot;, fs) 返回一个处理请求，里面的逻辑大概看了下 应该是把前缀static 删除之后重新构建一下path<br>3. 最终还是通过 ServeHttp处理请求，代码中还处理了 “&#47;” 如果前缀没有&#47; 还贴心的帮忙补充一个<br>4. 调用 serveFile （还包含重定向代码到 index.HTML 这个不是重点），调用Open函数打开文件<br>最后关闭文件<br><br>如果是读取文件夹，则遍历文件夹内所有文件，将文件名直接输出返回值。 关于这段话我其实具体细节代码没看太明白  = =难受","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540964,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640223307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320257,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1636180455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636180455","product_id":100090601,"comment_content":"打卡第一题，跟着老师学习完然后有机会可以和老师交流。","like_count":0},{"had_liked":false,"id":317732,"user_name":"盘胧","can_delete":false,"product_type":"c1","uid":1650748,"ip_address":"","ucode":"5386CC4C92ECC2","user_header":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","comment_is_top":false,"comment_ctime":1634907225,"is_pvip":false,"replies":[{"id":"115346","content":"servehttp是net&#47;http提供服务的关键字","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1635204045,"ip_address":"","comment_id":317732,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1634907225","product_id":100090601,"comment_content":"老师  为什么这个实现的实例方法 一定要叫  func (c *Core) ServeHTTP    我不小心写错了， 系统会报错提示呢","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528945,"discussion_content":"servehttp是net/http提供服务的关键字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635204045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1320293,"avatar":"https://static001.geekbang.org/account/avatar/00/14/25/65/f04c6cfa.jpg","nickname":"yesterday","note":"","ucode":"681CDE1288BFD6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547409,"discussion_content":"因为要实现Handler接口。\n定义是\ntype Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642661910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317338,"user_name":".","can_delete":false,"product_type":"c1","uid":2770944,"ip_address":"","ucode":"6ABCCB846DE6F3","user_header":"https://static001.geekbang.org/account/avatar/00/2a/48/00/dd8c0dc1.jpg","comment_is_top":false,"comment_ctime":1634745009,"is_pvip":false,"replies":[{"id":"115348","content":"是的，感谢回复","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1635204163,"ip_address":"","comment_id":317338,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634745009","product_id":100090601,"comment_content":"- http.FileServer<br><br>  1. 通过http.Dir返回FileSystem<br><br>  2. 创建fileHandler结构体<br><br>  3. 通过http.StripPrefix返回HandlerFunc<br><br>  4. 在HandlerFunc中通过请求的url来判断该请求是否存在<br><br>    4.1. 请求存在，则使用ServeHTTP<br><br>    4.2. 请求不存在，则返回404","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528775,"discussion_content":"是的，感谢回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635204163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317175,"user_name":"winkyi","can_delete":false,"product_type":"c1","uid":1227277,"ip_address":"","ucode":"91FBA510324439","user_header":"https://static001.geekbang.org/account/avatar/00/12/ba/0d/5b7c8ff9.jpg","comment_is_top":false,"comment_ctime":1634700110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634700110","product_id":100090601,"comment_content":"&#47;&#47; 具体处理逻辑的处理函数<br>func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {<br>  handler := sh.srv.Handler<br>  if handler == nil {<br>    handler = DefaultServeMux<br>  }<br>  ...<br>  handler.ServeHTTP(rw, req)<br>}<br><br>老师好，到第六层的这个方法有点不明白,同样是命名为ServeHTTP的接口,怎么和main函数中定义的Handle和HandleFunc方法进行关联。","like_count":0},{"had_liked":false,"id":316499,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1634357073,"is_pvip":true,"replies":[{"id":"114836","content":"是的，最终还是调用servehttp","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1634693506,"ip_address":"","comment_id":316499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634357073","product_id":100090601,"comment_content":"FileServer调用如下过程：<br>1 handler = DefaultServeMux <br>2 调用handler.ServeHTTP<br> 2.1  调用h := mux.Handler(r) ，其中 h是http.HandlerFunc类型，是http.StripPrefix的返回函数。<br> 2.2 调用h.ServeHTTP(w, r)，执行http.HandlerFunc的ServeHTTP。<br>   2.2.1 调用f(w, r)，是http.HandlerFunc.ServeHTTP的内部，此时的f==http.StripPrefix的返回函数。<br>   2.2.1.1 调用FileServer.ServeHTTP。<br>","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528395,"discussion_content":"是的，最终还是调用servehttp","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634693506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313524,"user_name":"eviltion","can_delete":false,"product_type":"c1","uid":1515445,"ip_address":"","ucode":"022DE8510B825E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/mWicFKgbjL299CQPEhoFdSAphVb4UpibkhF8loRxryBRt3H7ZGkibibhaKANTxvSiatic4PLCy2MsbEMH1hc76YefPUw/132","comment_is_top":false,"comment_ctime":1632474039,"is_pvip":true,"replies":[{"id":"113604","content":"你好，错误提示是说Core数据结构没有实现ServeHTTP 方法（missing ServeHTTP method）<br><br>我们可以写一个空实现的ServeHTTP方法在core.go中。<br><br>func (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {<br>\t&#47;&#47; TODO<br>}<br><br>参考 https:&#47;&#47;github.com&#47;gohade&#47;coredemo&#47;blob&#47;geekbang&#47;01&#47;framework&#47;core.go","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1632619948,"ip_address":"","comment_id":313524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632474039","product_id":100090601,"comment_content":".\\main.go:10:3: cannot use framework.NewCore() (type *framework.Core) as type http.Handler in field value:<br>        *framework.Core does not implement http.Handler (missing ServeHTTP method)<br>老师帮忙看下，demo 启动报这个错，什么原因那","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527377,"discussion_content":"你好，错误提示是说Core数据结构没有实现ServeHTTP 方法（missing ServeHTTP method）\n\n我们可以写一个空实现的ServeHTTP方法在core.go中。\n\nfunc (c *Core) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n\t// TODO\n}\n\n参考 https://github.com/gohade/coredemo/blob/geekbang/01/framework/core.go","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632619948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313327,"user_name":"Derek","can_delete":false,"product_type":"c1","uid":1146983,"ip_address":"","ucode":"A4D5DED1E00F60","user_header":"https://static001.geekbang.org/account/avatar/00/11/80/67/4e381da5.jpg","comment_is_top":false,"comment_ctime":1632378871,"is_pvip":false,"replies":[{"id":"113510","content":"你可以看下在 server.go 中有句话：<br>serverHandler{c.server}.ServeHTTP(w, w.req)<br><br>这里的c.server 如果没有设置的话，有可能是nil<br><br>然后server.go中的<br><br>func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {<br>\thandler := sh.srv.Handler<br>\tif handler == nil {<br>\t\thandler = DefaultServeMux<br>\t}<br>\tif req.RequestURI == &quot;*&quot; &amp;&amp; req.Method == &quot;OPTIONS&quot; {<br>\t\thandler = globalOptionsHandler{}<br>\t}<br>\thandler.ServeHTTP(rw, req)<br>}<br><br>这里如果sh.srv.Handler 就会默认为 DefaultServeMux，就和 ServeHTTP 的串联上了<br><br>","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1632438268,"ip_address":"","comment_id":313327,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632378871","product_id":100090601,"comment_content":"老师，关于“如果入口服务 server 结构已经设置了 Handler，就调用这个 Handler 来处理此次请求，反之则使用库自带的 DefaultServerMux“这句话：<br>DefaultServeMux 是怎么寻找 Handler 这一层代码的啊？，第七层我没看到DefaultServeMux直接调用Handle方法啊? <br>```go<br>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {<br>\tif r.RequestURI == &quot;*&quot; {<br>\t\tif r.ProtoAtLeast(1, 1) {<br>\t\t\tw.Header().Set(&quot;Connection&quot;, &quot;close&quot;)<br>\t\t}<br>\t\tw.WriteHeader(StatusBadRequest)<br>\t\treturn<br>\t}<br>\th, _ := mux.Handler(r)<br>\th.ServeHTTP(w, r)<br>}<br>```<br>这里调用的是Handler，后面跟下去也没有用到Handle方法啊? <br>","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527315,"discussion_content":"你可以看下在 server.go 中有句话：\nserverHandler{c.server}.ServeHTTP(w, w.req)\n\n这里的c.server 如果没有设置的话，有可能是nil\n\n然后server.go中的\n\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n\thandler := sh.srv.Handler\n\tif handler == nil {\n\t\thandler = DefaultServeMux\n\t}\n\tif req.RequestURI == &amp;quot;*&amp;quot; &amp;amp;&amp;amp; req.Method == &amp;quot;OPTIONS&amp;quot; {\n\t\thandler = globalOptionsHandler{}\n\t}\n\thandler.ServeHTTP(rw, req)\n}\n\n这里如果sh.srv.Handler 就会默认为 DefaultServeMux，就和 ServeHTTP 的串联上了\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632438268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313318,"user_name":"jeffery","can_delete":false,"product_type":"c1","uid":1219972,"ip_address":"","ucode":"35E2DAA386FB86","user_header":"https://static001.geekbang.org/account/avatar/00/12/9d/84/171b2221.jpg","comment_is_top":false,"comment_ctime":1632375852,"is_pvip":false,"replies":[{"id":"113505","content":"👍","user_name":"作者回复","user_name_real":"多少","uid":"2547771","ctime":1632414696,"ip_address":"","comment_id":313318,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632375852","product_id":100090601,"comment_content":"net&#47;http 原理分析的透彻<br><br>第一层，标准库创建 HTTP 服务是通过创建一个 Server 数据结构完成的；<br>第二层，Server 数据结构在 for 循环中不断监听每一个连接；<br>第三层，每个连接默认开启一个 Goroutine 为其服务；<br>第四、五层，serverHandler 结构代表请求对应的处理逻辑，并且通过这个结构进行具体业务逻辑处理；<br>第六层，Server 数据结构如果没有设置处理函数 Handler，默认使用 DefaultServerMux 处理请求；<br>第七层，DefaultServerMux 是使用 map 结构来存储和查找路由规则。","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527313,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632414696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312793,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1632022508,"is_pvip":true,"replies":[{"id":"113377","content":"是的，特别是复杂的逻辑，思维导图分析源码的方法是非常好用的方法，画完图之后也就对逻辑了解了。","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1632163851,"ip_address":"","comment_id":312793,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1632022508","product_id":100090601,"comment_content":"思维导图是个好东西，平时用 ide 点着一个个封装的函数、结构，跳着跳着脑子就乱了、懵了~","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527114,"discussion_content":"是的，特别是复杂的逻辑，思维导图分析源码的方法是非常好用的方法，画完图之后也就对逻辑了解了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632163851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312097,"user_name":"Ethan Liu","can_delete":false,"product_type":"c1","uid":1070043,"ip_address":"","ucode":"231F944F7CD56A","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","comment_is_top":false,"comment_ctime":1631624269,"is_pvip":true,"replies":[{"id":"113250","content":"用xmind或者wps","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1631917212,"ip_address":"","comment_id":312097,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1631624269","product_id":100090601,"comment_content":"老师，思维导图用什么工具？","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526864,"discussion_content":"用xmind或者wps","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631917212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272477,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6a/9d/65bc01f9.jpg","nickname":"peterszhou","note":"","ucode":"DE068869801A28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394209,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631786462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312003,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1631588851,"is_pvip":true,"replies":[{"id":"113119","content":"你好，课程是基于1.15版本的golang进行分析的，可以看github上的go.mod中go的版本号","user_name":"作者回复","user_name_real":"叶剑峰","uid":"1069186","ctime":1631670228,"ip_address":"","comment_id":312003,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631588851","product_id":100090601,"comment_content":"老师，这个课程源码分析的源码，基于哪个版本的golang？","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526826,"discussion_content":"你好，课程是基于1.15版本的golang进行分析的，可以看github上的go.mod中go的版本号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631670228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}