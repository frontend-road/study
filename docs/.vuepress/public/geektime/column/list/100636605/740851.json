{"id":740851,"title":"第 12 章 数据模型与描述符","content":"<h1 id=\"nav_point_190\">第 12 章　数据模型与描述符</h1>\n<p>在 Python 中，<strong>数据模型</strong>（data model）是个非常重要的概念。我们已经知道，Python 里万物皆对象，任何数据都通过对象来表达。而在用对象建模数据时，肯定不能毫无章法，一定需要一套严格的规则。</p>\n<p>我们常说的数据模型（或者叫对象模型）就是这套规则。假如把 Python 语言看作一个框架，数据模型就是这个框架的说明书。数据模型描述了框架如何工作，创建怎样的对象才能更好地融入 Python 这个框架。</p>\n<p>也许你还不清楚，数据模型究竟如何影响我们的代码。为此，我们从一个最简单的问题开始：当用 <code>print</code> 打印某个对象时，应该输出什么？</p>\n<p>假设我定义了一个表示人的对象 <code>Person</code>：</p>\n<pre class=\"code-rows\"><code>class Person:\n    \"\"\"人\n\n    :param name: 姓名\n    :param age: 年龄\n    :param favorite_color: 最喜欢的颜色\n    \"\"\"\n\n    def __init__(self, name, age, favorite_color):\n        self.name = name\n        self.age = age\n        self.favorite_color = favorite_color</code></pre>\n<p>当我用 <code>print</code> 打印一个 <code>Person</code> 对象时，输出如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; p = Person('piglei', 18, 'black')\n&gt;&gt;&gt; print(p)\n&lt;__main__.Person object at 0x10d1e4250&gt;</code></pre>\n<p>可以看到，打印 <code>Person</code> 对象会输出类名（<code>Person</code>）加上一长串内存地址（<code>0x10d1e4250</code>）。不过，这只是普通对象的默认行为。当你在 <code>Person</code> 类里定义 <code>__str__</code> 方法后，事情就会发生变化：</p>\n<pre class=\"code-rows\"><code>class Person:\n    ...\n\n    def __str__(self):\n        return self.name</code></pre>\n<p>再试着打印一次对象，输出如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; print(p)\npiglei\n&gt;&gt;&gt; str(d) ➊\n'piglei'\n&gt;&gt;&gt; \"I'm {}\".format(p)\n\"I'm piglei\"</code></pre>\n<blockquote>\n<p>❶ 除了 <code>print()</code> 以外，<code>str()</code> 与 <code>.format()</code> 函数同样也会触发 <code>__str__</code> 方法</p>\n</blockquote>\n<p>上面展示的 <code>__str__</code> 就是 Python 数据模型里最基础的一部分。当对象需要当作字符串使用时，我们可以用 <code>__str__</code> 方法来定义对象的字符串化结果。</p>\n<p>虽然从本章标题看来，数据模型似乎是一个新话题，但其实在之前的章节里，我们已经运用过非常多与数据模型有关的知识。表 12-1 整理了其中一部分。</p><!-- [[[read_end]]] -->\n<p><strong>表 12-1　本书前 11 章中出现过的数据模型有关内容</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>位置</p></th>\n<th><p>方法名</p></th>\n<th><p>相关操作</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>第 3 章</p></td>\n<td><p><code>__getitem++</code></p></td>\n<td><p><code>obj[key]</code></p></td>\n<td><p>定义按索引读取行为</p></td>\n</tr>\n<tr>\n<td><p>第 3 章</p></td>\n<td><p><code>__setitem++</code></p></td>\n<td><p><code>obj[key] = value</code></p></td>\n<td><p>定义按索引写入行为</p></td>\n</tr>\n<tr>\n<td><p>第 3 章</p></td>\n<td><p><code>__delitem++</code></p></td>\n<td><p><code>del obj[key]</code></p></td>\n<td><p>定义按索引删除行为</p></td>\n</tr>\n<tr>\n<td><p>第 4 章</p></td>\n<td><p><code>__len__</code></p></td>\n<td><p><code>len(obj)</code></p></td>\n<td><p>定义对象的长度</p></td>\n</tr>\n<tr>\n<td><p>第 4 章</p></td>\n<td><p><code>__bool__</code></p></td>\n<td><p><code>bool(obj)</code></p></td>\n<td><p>定义对象的布尔值真假</p></td>\n</tr>\n<tr>\n<td><p>第 4 章</p></td>\n<td><p><code>__eq__</code></p></td>\n<td><p><code>obj == another_obj</code></p></td>\n<td><p>定义 <code>==</code> 运算时的行为</p></td>\n</tr>\n<tr>\n<td><p>第 5 章</p></td>\n<td><p><code>__enter__</code>、<code>__exit__</code></p></td>\n<td><p><code>with obj:</code></p></td>\n<td><p>定义对象作为上下文管理器时的行为</p></td>\n</tr>\n<tr>\n<td><p>第 6 章</p></td>\n<td><p><code>__iter__</code>、<code>__next__</code></p></td>\n<td><p><code>for _ in obj</code></p></td>\n<td><p>定义对象被迭代时的行为</p></td>\n</tr>\n<tr>\n<td><p>第 8 章</p></td>\n<td><p><code>__call__</code></p></td>\n<td><p><code>obj()</code></p></td>\n<td><p>定义被调用时的行为</p></td>\n</tr>\n<tr>\n<td><p>第 8 章</p></td>\n<td><p><code>__new__</code></p></td>\n<td><p><code>obj_class()</code></p></td>\n<td><p>定义创建实例时的行为</p></td>\n</tr>\n</tbody>\n</table>\n<p>从表 12-1 中可以发现，所有与数据模型有关的方法，基本都以双下划线开头和结尾，它们通常被称为<strong>魔法方法</strong>（magic method）。</p>\n<p>在本章中，除了这些已经学过的魔法方法外，我将介绍一些与 Python 数据模型相关的实用知识。比如，如何用 <code>dataclass</code> 来快速创建一个数据类、如何通过 <code>__get__</code> 与 <code>__set__</code> 来定义一个描述符对象等。</p>\n<p>在本章的案例故事里，我将介绍如何巧妙地利用数据模型来解决真实需求。</p>\n<p>要写出 Pythonic 的代码，恰当地使用数据模型是关键之一。接下来我们进入正题。</p>\n<h2 id=\"nav_point_191\">12.1　基础知识</h2>\n<h3 id=\"nav_point_192\">12.1.1　字符串魔法方法</h3>\n<p>在本章一开始，我演示了如何使用 <code>__str__</code> 方法来自定义对象的字符串表示形式。但其实除了 <code>__str__</code> 以外，还有两个与字符串有关的魔法方法，一起来看看吧。</p>\n<ol>\n<li><p><strong><code>__repr__</code></strong></p>\n<p>当你需要把一个 Python 对象用字符串表现出来时，实际上可分为两种场景。第一种场景是非正式的，比如用 <code>print()</code> 打印到屏幕、用 <code>str()</code> 转换为字符串。这种场景下的字符串注重可读性，格式应当对用户友好，由类型的 <code>__str__</code> 方法所驱动。</p>\n<p>第二种场景则更为正式，它一般发生在调试程序时。在调试程序时，你常常需要快速获知对象的详细内容，最好一下子就看到所有属性的值。该场景下的字符串注重内容的完整性，由类型的 <code>__repr__</code> 方法所驱动。</p>\n<p>要模拟第二种场景，最快的办法是在命令行里输入一个 <code>Person</code> 对象，然后直接按回车键：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; p = Person('piglei', 18, 'black')\n&gt;&gt;&gt; str(p) ➊\n'piglei'\n&gt;&gt;&gt; p ➋\n&lt;__main__.Person object at 0x10d993250&gt;\n&gt;&gt;&gt; repr(p) ➌\n'&lt;__main__.Person object at 0x10d993250&gt;'</code></pre>\n<blockquote>\n<p>❶ 接着前面的例子，<code>Person</code> 类已定义了 <code>__str__</code> 方法</p>\n<p>❷ 直接输入对象后，你仍然能看到包含一长串内存地址的字符串</p>\n<p>❸ 和 <code>str()</code> 类似，<code>repr()</code> 可以用来获取第二种场景的字符串</p>\n</blockquote>\n<p>要让对象在调试场景提供更多有用的信息，我们需要实现 <code>__repr__</code> 方法。</p>\n<p>当你在 <code>__repr__</code> 方法里组装结果时，一般会尽可能地涵盖当前对象的所有信息，假如其他人能通过复制 <code>repr()</code> 的字符串结果直接创建一个同样的对象，就再好不过了。</p>\n<p>下面，我试着给 <code>Person</code> 加上 <code>__repr__</code> 方法：</p>\n<pre class=\"code-rows\"><code>class Person:\n    ...\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return '(name=, age=, favorite_color=)'.format( ➊\n            cls_name=self.__class__.__name__, ➋\n            name=self.name,\n            age=self.age,\n            color=self.favorite_color,\n        )</code></pre>\n<blockquote>\n<p>❶ 在字符串模板里，我使用了 <code></code> 这样的语法，变量名后的 <code>!r</code> 表示在渲染字符串模板时，程序会优先使用 <code>repr()</code> 而非 <code>str()</code> 的结果。这么做以后，<code>self.name</code> 这种字符串类型在渲染时会包含左右引号，省去了手动添加的麻烦</p>\n<p>❷ 类名不直接写成 <code>Person</code> 以便更好地兼容子类</p>\n</blockquote>\n<p>再来试试看效果如何：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; p = Person('piglei', 18, 'black')\n&gt;&gt;&gt; print(p)\npiglei\n&gt;&gt;&gt; p\nPerson(name='piglei', age=18, favorite_color='black')</code></pre>\n<p>当对象定义了 <code>__repr__</code> 方法后，它便可以在任何需要的时候，快速提供一种详尽的字符串展现形式，为程度调试提供帮助。</p>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00372.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　假如一个类型没定义 <code>__str__</code> 方法，只定义了 <code>__repr__</code>，那么 <code>__repr__</code> 的结果会用于所有需要字符串的场景。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong><code>__format__</code></strong></p>\n<p>如前面所说，当你直接把某个对象作为 <code>.format()</code> 的参数，用于渲染字符串模板时，默认会使用 <code>str()</code> 化的字符串结果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; p = Person('piglei', 18, 'black')\n&gt;&gt;&gt; \"I'm {}\".format(p)\n\"I'm piglei\"</code></pre>\n<p>但是，Python 里的字符串格式化语法，其实不光只有上面这种最简单的写法。通过定义 <code>__format__</code> 魔法方法，你可以为一种对象定义多种字符串表现形式。</p>\n<p>继续拿 <code>Person</code> 举例：</p>\n<pre class=\"code-rows\"><code>class Person:\n    ...\n\n    def __format__(self, format_spec):\n        \"\"\"定义对象在字符串格式化时的行为\n\n        :param format_spec: 需要的格式，默认为 ''\n        \"\"\"\n        if format_spec == 'verbose':\n            return f'()[]'\n        elif format_spec == 'simple':\n            return f'()'\n        return self.name</code></pre>\n<p>上面的代码给 <code>Person</code> 类增加了 <code>__format__</code> 方法，并在里面实现了不同的字符串表现形式。</p>\n<p>接下来，我们可以在字符串模板里使用 <code></code> 语法，来触发这些不同的字符串格式：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; print(''.format(p=p)) ➊\npiglei(18)[black]\n&gt;&gt;&gt; print(f'') ➋\npiglei(18)[black]\n&gt;&gt;&gt; print(f'') ➌\npiglei(18)\n&gt;&gt;&gt; print(f'')\npiglei</code></pre>\n<blockquote>\n<p>❶ 此时传递的 <code>format_spec</code> 为 <code>verbose</code></p>\n<p>❷ 模板语法同样适用于 <code>f-string</code></p>\n<p>❸ 使用不同的格式</p>\n</blockquote>\n<p>假如你的对象需要提供不同的字符串表现形式，那么可以使用 <code>__format__</code> 方法。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_193\">12.1.2　比较运算符重载</h3>\n<p>比较运算符是指专门用来对比两个对象的运算符，比如 <code>==</code>、<code>!=</code>、<code>&gt;</code> 等。在 Python 中，你可以通过魔法方法来重载它们的行为，比如在第 4 章中，我们就通过 <code>__eq__</code> 方法重载过 <code>==</code> 行为。</p>\n<p>包含 <code>__eq__</code> 在内，与比较运算符相关的魔法方法共 6 个，如表 12-2 所示。</p>\n<p><strong>表 12-2　所有用于重载比较运算符的魔法方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>方法名</p></th>\n<th><p>相关运算</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>__lt__</code></p></td>\n<td><p><code>obj &lt; other</code></p></td>\n<td><p>小于（less than）</p></td>\n</tr>\n<tr>\n<td><p><code>__le__</code></p></td>\n<td><p><code>obj &lt;= other</code></p></td>\n<td><p>小于等于（less than or equal）</p></td>\n</tr>\n<tr>\n<td><p><code>__eq__</code></p></td>\n<td><p><code>obj == other</code></p></td>\n<td><p>等于（equal）</p></td>\n</tr>\n<tr>\n<td><p><code>__ne__</code></p></td>\n<td><p><code>obj != other</code></p></td>\n<td><p>不等于（not equal）</p></td>\n</tr>\n<tr>\n<td><p><code>__gt__</code></p></td>\n<td><p><code>obj &gt; other</code></p></td>\n<td><p>大于（greater than）</p></td>\n</tr>\n<tr>\n<td><p><code>__ge__</code></p></td>\n<td><p><code>obj &gt;= other</code></p></td>\n<td><p>大于等于（greater than or equal）</p></td>\n</tr>\n</tbody>\n</table>\n<p>一般来说，我们没必要重载比较运算符。但在合适的场景下，重载运算符可以让对象变得更好用，代码变得更直观，是一种非常有用的技巧。</p>\n<p>举个例子，假如我有一个用来表示正方形的类 <code>Square</code>，它的代码如下：</p>\n<pre class=\"code-rows\"><code>class Square:\n    \"\"\"正方形\n\n    :param length: 边长\n    \"\"\"\n\n    def __init__(self, length):\n        self.length = length\n\n    def area(self):\n        return self.length ** 2</code></pre>\n<p>虽然 <code>Square</code> 看上去挺好，但用起来特别不方便。具体来说，假如我有两个边长一样的正方形 <code>x</code> 和 <code>y</code>，在进行等于运算 <code>x == y</code> 时，会返回下面的结果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; x = Square(4)\n&gt;&gt;&gt; y = Square(4)\n&gt;&gt;&gt; x == y\nFalse</code></pre>\n<p>看到了吗？虽然两个正方形边长相同，但在 Python 看来，它们其实是不相等的。因为在默认情况下，对两个用户定义对象进行 <code>==</code> 运算，其实是在对比它俩在内存里的地址（通过 <code>id()</code> 函数获取）。因此，两个不同对象的 <code>==</code> 运算结果肯定是 <code>False</code>。</p>\n<p>通过在 <code>Square</code> 类上实现比较运算符魔法方法，我们就能解决上面的问题。我们可以给 <code>Square</code> 类加上一系列规则，比如边长相等的正方形就是相等，边长更长的正方形更大。这样一来，<code>Square</code> 类可以变得更好用。</p>\n<p>增加魔法方法后的代码如下：</p>\n<pre class=\"code-rows\"><code>class Square:\n    \"\"\"正方形\n\n    :param length: 边长\n    \"\"\"\n\n    def __init__(self, length):\n        self.length = length\n\n    def area(self):\n        return self.length ** 2\n\n    def __eq__(self, other):\n        # 在判断两个对象是否相等时，先检验 other 是否同为当前类型\n        if isinstance(other, self.__class__):\n            return self.length == other.length\n        return False\n\n    def __ne__(self, other):\n        # “不等”运算的结果一般会直接对“等于”取反\n        return not (self == other)\n\n    def __lt__(self, other):\n        if isinstance(other, self.__class__):\n            return self.length &lt; other.length\n        # 如果对象不支持某种运算，可以返回 NotImplemented 值\n        return NotImplemented\n\n    def __le__(self, other):\n        return self.__lt__(other) or self.__eq__(other)\n\n    def __gt__(self, other):\n        if isinstance(other, self.__class__):\n            return self.length &gt; other.length\n        return NotImplemented\n\n    def __ge__(self, other):\n        return self.__gt__(other) or self.__eq__(other)</code></pre>\n<p>代码怪长的，不过先别在意，我们看看效果：</p>\n<pre class=\"code-rows\"><code># 边长相等，正方形就相等\n&gt;&gt;&gt; Square(4) == Square(4)\nTrue\n# 边长不同，正方形不同\n&gt;&gt;&gt; Square(5) == Square(4)\nFalse\n# 测试“不等”运算\n&gt;&gt;&gt; Square(5) != Square(4)\nTrue\n# 边长更大，正方形就更大\n&gt;&gt;&gt; Square(5) &gt; Square(4)\nTrue\n...</code></pre>\n<p>通过重载这些魔法方法，<code>Square</code> 类确实变得更好用了。当我们有多个正方形对象时，可以任意对它们进行比较运算，运算结果全都符合预期。</p>\n<p>但上面的代码有一个显而易见的缺点——代码量太大了，而且魔法方法之间还有冗余的嫌疑。比如，明明已经实现了“等于”运算，那为什么“不等”运算还得手动去写呢？Python 就不能自动对“等于”取反吗？</p>\n<p>好消息是，Python 开发者早就意识到了这个问题，并提供了解决方案。利用接下来介绍的这个工具，我们可以把重载比较描述符的工作量减少一大半。</p>\n<h4>使用 <code>@total_ordering</code></h4>\n<p><code>@total_ordering</code> 是 <code>functools</code> 内置模块下的一个装饰器。它的功能是让重载比较运算符变得更简单。</p>\n<p>如果使用 <code>@total_ordering</code> 装饰一个类，那么在重载类的比较运算符时，你只要先实现 <code>__eq__</code> 方法，然后在 <code>__lt__</code>、<code>__le__</code>、<code>__gt__</code>、<code>__ge__</code> 四个方法里随意挑一个实现即可，<code>@total_ordering</code> 会帮你自动补全剩下的所有方法。</p>\n<p>使用 <code>@total_ordering</code>，前面的 <code>Square</code> 类可以简化成下面这样：</p>\n<pre class=\"code-rows\"><code>from functools import total_ordering\n\n\n@total_ordering\nclass Square:\n    \"\"\"正方形\n\n    :param length: 边长\n    \"\"\"\n\n    def __init__(self, length):\n        self.length = length\n\n    def area(self):\n        return self.length ** 2\n\n    def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            return self.length == other.length\n        return False\n\n    def __lt__(self, other):\n        if isinstance(other, self.__class__):\n            return self.length &lt; other.length\n        return NotImplemented</code></pre>\n<p>虽然功能与之前一致，但在 <code>@total_ordering</code> 的帮助下，代码变短了一大半。</p>\n<h3 id=\"nav_point_194\">12.1.3　描述符</h3>\n<p>在所有 Python 对象协议里，描述符可能是其中应用最广却又最鲜为人知的协议之一。你也许从来没听说过描述符，但肯定早就使用过它。这是因为所有的方法、类方法、静态方法以及属性等诸多 Python 内置对象，都是基于描述符协议实现的。</p>\n<p>在日常工作中，描述符的使用并不算频繁。但假如你要开发一些框架类工具，就会发现描述符非常有用。接下来我们通过开发一个小功能，来看看描述符究竟能如何帮助我们。</p>\n<ol>\n<li><p><strong>无描述符时，实现属性校验功能</strong></p>\n<p>在下面的代码里，我实现了一个 <code>Person</code> 类：</p>\n<pre class=\"code-rows\"><code>class Person:\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age</code></pre>\n<p><code>Person</code> 是个特别简单的数据类，没有任何约束，因此人们很容易创建出一些不合理的数据，比如年龄为 1000、年龄不是合法数字的 <code>Person</code> 对象等。为了确保对象数据的合法性，我需要给 <code>Person</code> 的年龄属性加上一些正确性校验。</p>\n<p>使用 <code>@property</code> 把 <code>age</code> 定义为 <code>property</code> 对象后，我可以很方便地增加校验逻辑：</p>\n<pre class=\"code-rows\"><code>class Person:\n    ...\n\n    @property\n    def age(self):\n        return self._age\n\n    @age.setter\n    def age(self, value):\n        \"\"\"设置年龄，只允许 0～150 之间的数值\"\"\"\n        try:\n            value = int(value)\n        except (TypeError, ValueError):\n            raise ValueError('value is not a valid integer!')\n\n        if not (0 &lt; value &lt; 150):\n            raise ValueError('value must between 0 and 150!')\n        self._age = value</code></pre>\n<p>通过在 <code>age</code> 属性的 <code>setter</code> 方法里增加校验，我最终实现了想要的效果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; p = Person('piglei', 'invalid_age') ➊\n...\nValueError: value is not a valid integer!\n&gt;&gt;&gt; p = Person('piglei', '200') ➋\n...\nValueError: value must between 0 and 150!\n\n&gt;&gt;&gt; p = Person('piglei', 18) ➌\n&gt;&gt;&gt; p.age\n18</code></pre>\n<blockquote>\n<p>❶ <code>age</code> 值不能转换为整型</p>\n<p>❷ <code>age</code> 值不在合法的年龄范围内</p>\n<p>❸ <code>age</code> 值符合要求，对象创建成功</p>\n</blockquote>\n<p>粗看上去，上面使用 <code>@property</code> 的方案还挺不错的，但实际上有许多不如人意的地方。</p>\n<p>使用属性对象最大的缺点是：很难复用。假如我现在开发了一个长方形类 <code>Rectangle</code>，想对长方形的边长做一些与 <code>Person.age</code> 类似的整型校验，那么我根本无法很好地复用上面的校验逻辑，只能手动为长方形的边长创建多个 <code>@property</code> 对象，然后在每个 <code>setter</code> 方法里做重复工作：</p>\n<pre class=\"code-rows\"><code>class Rectangle:\n\n    @property\n    def width(self): ...\n\n    @width.setter\n    def width(self): ...\n\n    @property\n    def height(self): ...\n\n    @height.setter\n    def height(self): ...</code></pre>\n<p>如果非得基于 <code>@property</code> 来实现复用，我也可以继续用<strong>类装饰器</strong>（class decorator）或<strong>元类</strong>（metaclass）在创建类时介入处理，把普通属性自动替换为 <code>property</code> 对象来达到复用目的。但是，这种方案不但实现起来复杂，使用起来也不方便。</p>\n<p>而使用描述符，我们可以更轻松地实现这类需求。不过在用描述符实现字段校验前，我们先了解一下描述符的基本工作原理。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>描述符简介</strong></p>\n<p><strong>描述符</strong>（descriptor）是 Python 对象模型里的一种特殊协议，它主要和 4 个魔法方法有关： <code>__get__</code>、<code>__set__</code>、<code>__delete__</code> 和 <code>__set_name__</code>。</p>\n<p>从定义上来说，除了最后一个方法 <code>__set_name__</code> 以外，任何一个实现了 <code>__get__</code>、<code>__set__</code> 或 <code>__delete__</code> 的类，都可以称为描述符类，它的实例则叫作描述符对象。</p>\n<p>描述符之所以叫这个名字，是因为它“描述”了 Python 获取与设置一个类（实例）成员的整个过程。我们通过简单的代码示例，来看看描述符的几个魔法方法究竟有什么用。</p>\n<p>从最常用的 <code>__get__</code> 方法开始：</p>\n<pre class=\"code-rows\"><code>class InfoDescriptor:\n    \"\"\"打印帮助信息的描述符\"\"\"\n\n    def __get__(self, instance, owner=None):\n        print(f'Calling __get__, instance: , owner: ')\n        if not instance:\n            print('Calling without instance...')\n            return self\n        return 'informative descriptor'</code></pre>\n<p>上面的 <code>InfoDescriptor</code> 是一个实现了 <code>__get__</code> 方法的描述符类。</p>\n<p>要使用一个描述符，最常见的方式是把它的实例对象设置为其他类（常被称为 <code>owner</code> 类）的属性：</p>\n<pre class=\"code-rows\"><code>class Foo:\n    bar = InfoDescriptor()</code></pre>\n<p>描述符的 <code>__get__</code> 方法，会在访问 <code>owner</code> 类或 <code>owner</code> 类实例的对应属性时被触发。<code>__get__</code> 方法里的两个参数的含义如下。</p>\n<ul>\n<li><code>owner</code>：描述符对象所绑定的类。</li>\n<li><code>instance</code>：假如用实例来访问描述符属性，该参数值为实例对象；如果通过类来访问，该值为 <code>None</code>。</li>\n</ul>\n<p>下面，我们试着通过 <code>Foo</code> 类访问 <code>bar</code> 属性：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; Foo.bar\nCalling __get__, instance: None, owner: &lt;class '__main__.Foo'&gt;\nCalling without instance... ➊\n&lt;__main__.InfoDescriptor object at 0x105b0adc0&gt;</code></pre>\n<blockquote>\n<p>❶ 触发描述符的 <code>__get__</code> 方法，因为 <code>instance</code> 为 <code>None</code>，所以 <code>__get__</code> 返回了描述符对象本身</p>\n</blockquote>\n<p>再试试通过 <code>Foo</code> 实例访问 <code>bar</code> 属性：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; Foo().bar\nCalling __get__, instance: &lt;__main__.Foo object at 0x105b48280&gt;, owner: &lt;class '__main__.Foo'&gt;\n'informative descriptor' ➊</code></pre>\n<blockquote>\n<p>❶ 同样触发了 <code>__get__</code> 方法，但 <code>instance</code> 参数变成了当前绑定的 <code>Foo</code> 实例，因此最后返回了我在 <code>__get__</code> 里定义的字符串</p>\n</blockquote>\n<p>与 <code>__get__</code> 方法相对应的是 <code>__set__</code> 方法，它可以用来自定义设置某个实例属性时的行为。</p>\n<p>下面的代码给 <code>InfoDescriptor</code> 增加了 <code>__set__</code> 方法：</p>\n<pre class=\"code-rows\"><code>class InfoDescriptor:\n    ...\n\n    def __set__(self, instance, value):\n        print(f'Calling __set__, instance: , value: ')</code></pre>\n<p><code>__set__</code> 方法的后两个参数的含义如下。</p>\n<ul>\n<li><code>instance</code>：属性当前绑定的实例对象。</li>\n<li><code>value</code>：待设置的属性值。</li>\n</ul>\n<p>当我尝试修改 <code>Foo</code> 实例的 <code>bar</code> 属性时，描述符的 <code>__set__</code> 方法就会被触发：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; f = Foo()\n&gt;&gt;&gt; f.bar = 42\nCalling __set__, instance: &lt;__main__.Foo object at 0x106543340&gt;, value: 42</code></pre>\n<p>值得一提的是，描述符的 <code>__set__</code> 仅对实例起作用，对类不起作用。这和 <code>__get__</code> 方法不一样，<code>__get__</code> 会同时影响描述符所绑定的类和类实例。当你通过类设置描述符属性值时，不会触发任何特殊逻辑，整个描述符对象会被覆盖：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; Foo.bar = None ➊\n&gt;&gt;&gt; f = Foo()\n&gt;&gt;&gt; f.bar = 42 ➋</code></pre>\n<blockquote>\n<p>❶ 使用 <code>None</code> 覆盖类的描述符对象</p>\n<p>❷ 当描述符对象不存在后，设置实例属性就不会触发任何描述符逻辑了</p>\n</blockquote>\n<p>除了 <code>__get__</code> 与 <code>__set__</code> 外，描述符协议还有一个 <code>__delete__</code> 方法，它用来控制实例属性被删除时的行为。在下面的代码里，我给 <code>InfoDescriptor</code> 类增加了 <code>__delete__</code> 方法：</p>\n<pre class=\"code-rows\"><code>class InfoDescriptor:\n    ...\n\n    def __delete__(self, instance):\n        raise RuntimeError('Deletion not supported!')</code></pre>\n<p>试试看效果如何：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; f = Foo()\n&gt;&gt;&gt; del f.bar\n...\nRuntimeError: Deletion not supported!</code></pre>\n<p>除了上面的三个方法以外，描述符还有一个 <code>__set_name__</code> 方法，不过我们暂先略过它。下面我们试着运用描述符来实现前面的年龄字段。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>用描述符实现属性校验功能</strong></p>\n<p>前面我用 <code>property()</code> 为 <code>Person</code> 类的 <code>age</code> 字段增加了校验功能，但这种方式的可复用性很差。下面我们试着用描述符来完成同样的功能。</p>\n<p>为了提供更高的可复用性，这次我在年龄字段的基础上抽象出了一个支持校验功能的整型描述符类型：<code>IntegerField</code>。它的代码如下：</p>\n<pre class=\"code-rows\"><code>class IntegerField:\n    \"\"\"整型字段，只允许一定范围内的整型值\n\n    :param min_value: 允许的最小值\n    :param max_value: 允许的最大值\n    \"\"\"\n\n    def __init__(self, min_value, max_value):\n        self.min_value = min_value\n        self.max_value = max_value\n\n    def __get__(self, instance, owner=None):\n        # 当不是通过实例访问时，直接返回描述符对象\n        if not instance:\n            return self\n        # 返回保存在实例字典里的值\n        return instance.__dict__['_integer_field']\n\n    def __set__(self, instance, value):\n        # 校验后将值保存在实例字典里\n        value = self._validate_value(value)\n        instance.__dict__['_integer_field'] = value\n\n    def _validate_value(self, value):\n        \"\"\"校验值是否为符合要求的整数\"\"\"\n        try:\n            value = int(value)\n        except (TypeError, ValueError):\n            raise ValueError('value is not a valid integer!')\n\n        if not (self.min_value &lt;= value &lt;= self.max_value):\n            raise ValueError(\n                f'value must between  and !'\n            )\n        return value</code></pre>\n<p><code>IntegerField</code> 最核心的逻辑，就是在设置属性值时先做有效性校验，然后再保存数据。</p>\n<p>除了我已介绍过的描述符基本方法外，上面的代码里还有一个值得注意的细节，那就是描述符保存数据的方式。</p>\n<p>在 <code>__set__</code> 方法里，我使用了 <code>instance.dict['_integer_field'] = value</code> 这样的语句来保存整型数字的值。也许你想问：为什么不直接写 <code>self._integer_field = value</code>，把值存放在描述符对象 <code>self</code> 里呢？</p>\n<p>这是因为每个描述符对象都是 <code>owner</code> 类的属性，而不是类实例的属性。也就是说，所有从 <code>owner</code> 类派生出的实例，其实都共享了同一个描述符对象。假如把值存入描述符对象里，不同实例间的值就会发生冲突，互相覆盖。</p>\n<p>所以，为了避免覆盖问题，我把值放在了每个实例各自的 <code>__dict__</code> 字典里。</p>\n<p>下面是使用了描述符的 <code>Person</code> 类：</p>\n<pre class=\"code-rows\"><code>class Person:\n    age = IntegerField(min_value=0, max_value=150)\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age</code></pre>\n<p>通过把 <code>age</code> 类属性定义为 <code>IntegerField</code> 描述符，我实现了与之前的 <code>property()</code> 方案完全一样的效果。不过，虽然 <code>IntegerField</code> 能满足 <code>Person</code> 类的需求，但它其实有一个严重的问题。</p>\n<p>由于 <code>IntegerField</code> 往实例里存值时使用了固定的字段名 <code>_integer_field</code>，因此它其实只支持一个类里最多使用一个描述符对象，否则不同属性值会发生冲突，举个例子：</p>\n<pre class=\"code-rows\"><code>class Rectangle:\n    width = IntegerField(min_value=1, max_value=10)\n    height = IntegerField(min_value=1, max_value=5)</code></pre>\n<p>上面 <code>Rectangle</code> 类的 <code>width</code> 和 <code>height</code> 都使用了 <code>IntegerField</code> 描述符，但这两个字段的值会因为前面所说的原因而互相覆盖：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; r = Rectangle(1, 1)\n&gt;&gt;&gt; r.width = 5\n&gt;&gt;&gt; r.width\n5\n&gt;&gt;&gt; r.height ➊\n5</code></pre>\n<blockquote>\n<p>❶ 修改 <code>width</code> 后，<code>height</code> 也变了</p>\n</blockquote>\n<p>要解决这个问题，最佳方案是使用 <code>__set_name__</code> 方法。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 <code>__set_name__</code> 方法</strong></p>\n<p><code>__set_name__(self, owner, name)</code> 是 Python 在 3.6 版本以后，为描述符协议增加的新方法，它所接收的两个参数的含义如下。</p>\n<ul>\n<li><code>owner</code>：描述符对象当前绑定的类。</li>\n<li><code>name</code>：描述符所绑定的属性名称。</li>\n</ul>\n<p><code>__set_name__</code> 方法的触发时机是在 <code>owner</code> 类被创建时。</p>\n<p>通过给 <code>IntegerField</code> 类增加 <code>__set_name__</code> 方法，我们可以方便地解决前面的数据冲突问题：</p>\n<pre class=\"code-rows\"><code>class IntegerField:\n\n    def __init__(self, min_value, max_value):\n        self.min_value = min_value\n        self.max_value = max_value\n\n    def __set_name__(self, owner, name):\n        # 将绑定属性名保存在描述符对象中\n        # 对于 age = IntegerField(...) 来说，此处的 name 就是“age”\n        self._name = name\n\n    def __get__(self, instance, owner=None):\n        if not instance:\n            return self\n        # 在数据存取时，使用动态的 self._name\n        return instance.__dict__[self._name]\n\n    def __set__(self, instance, value):\n        value = self._validate_value(value)\n        instance.__dict__[self._name] = value\n\n    def _validate_value(self, value):\n        \"\"\"校验值是否为符合要求的整数\"\"\"\n        # ...</code></pre>\n<p>试试看效果如何：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; r = Rectangle(1, 1)\n&gt;&gt;&gt; r.width = 3\n&gt;&gt;&gt; r.height ➊\n1\n&gt;&gt;&gt; r.width = 100\n...\nValueError: width must between 1 and 10!</code></pre>\n<blockquote>\n<p>❶ 不同字段间不会互相影响</p>\n</blockquote>\n<p>使用描述符，我们最终实现了一个可复用的 <code>IntegerField</code> 类，它使用起来非常方便——无须继承任何父类、声明任何元类，直接将类属性定义为描述符对象即可。</p>\n<blockquote>\n<p><strong>数据描述符与非数据描述符</strong></p>\n<p>按实现方法的不同，描述符可分为两大类。</p>\n<p>(1) 非数据描述符：只实现了 <code>__get__</code> 方法的描述符。</p>\n<p>(2) 数据描述符：实现了 <code>__set__</code> 或 <code>__delete__</code> 其中任何一个方法的描述符。</p>\n<p>这两类描述符的区别主要体现在所绑定实例的属性存取优先级上。</p>\n<p>对于非数据描述符来说，你可以直接用 <code>instance.attr = ...</code> 来在实例级别重写描述符属性 <code>attr</code>，让其读取逻辑不再受描述符的 <code>__get__</code> 方法管控。</p>\n<p>而对于数据描述符来说，你无法做到同样的事情。数据描述符所定义的属性存储逻辑拥有极高的优先级，无法轻易在实例层面被重写。</p>\n<p>所有的 Python 实例方法、类方法、静态方法，都是非数据描述符，你可以轻易覆盖它们。而 <code>property()</code> 是数据描述符，你无法直接通过重写修改它的行为。</p>\n<p>拿一段具体的代码举例。下面定义了两个包含 <code>color</code> 成员的鸭子类，一个使用属性对象，另一个使用静态方法：</p>\n<pre class=\"code-rows\"><code>class DuckWithProperty:\n    @property\n    def color(self):\n        return 'gray'\n\nclass DuckWithStaticMethod:\n    @staticmethod\n    def color(self):\n        return 'gray'</code></pre>\n<p>因为属性对象是数据描述符，所以无法被随意重写：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d = DuckWithProperty()\n&gt;&gt;&gt; d.color = 'yellow'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: can't set attribute</code></pre>\n<p>而静态方法属于非数据描述符，可以被任意重写：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; d = DuckWithStaticMethod()\n&gt;&gt;&gt; d.color = 'yellow' ➊\n&gt;&gt;&gt; d.color\n'yellow'</code></pre>\n<blockquote>\n<p>❶ 直接把静态方法替换成一个普通字符串属性</p>\n</blockquote>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"nav_point_195\">12.2　案例故事</h2>\n<p>2017 年 3 月，我在任天堂的 Switch 游戏主机上，玩到了一个令我大开眼界的游戏：《塞尔达传说：荒野之息》（下面简称《荒野之息》）。</p>\n<p>《荒野之息》是一款开放世界冒险游戏。简单来说，它讲述了一个名为林克（Link）的角色在沉睡 100 年以后突然醒来，然后拯救整个海拉尔大陆的故事。</p>\n<p>不过，作为一本 Python 书的作者，我突然在书中提起一个电子游戏，并不是因为它是我最喜欢的游戏之一，而是因为《荒野之息》里的一个设计，与我们在讲的数据模型之间有奇妙的联系。</p>\n<p>在《荒野之息》的新手村里，有一个难倒许多玩家的任务。在任务中，你扮演游戏主角林克，需要前往一座冰雪覆盖的高山顶峰。雪山上的温度特别低，假如你什么都不准备，直接往山顶上跑，林克马上就会进入一个“寒冷”的负面状态，生命值不断降低，直至死亡。</p>\n<p>要完成这个任务，有多种方式。</p>\n<p>比如，你可以在山脚下找到一口铁锅，然后烹制一些放了辣椒的食物。吃了带辣椒的食物后，林克便会进入“温暖”状态，就能无视寒冷一口气跑上雪山顶。或者，你可以去山脚下找到一座老旧的木房子，从那儿拿到一件厚棉袄穿在身上。当角色的体温升高后，在雪山上同样可以畅行无阻。</p>\n<p>到达雪山顶端的方式，绝不止上面这两种。比如你还可以找到一些树枝，然后将它们作为火把点燃。举着火把取暖的林克，也能轻松冲上雪山。</p>\n<p>《荒野之息》与其他游戏的不同之处在于，它不限定你完成某件事的方式，而是构造出了一个精巧的规则体系。当你熟悉了规则以后，就能用任何你能想到的方式完成同一件事。</p>\n<p>假如我们把 Python 比作一个类似于《荒野之息》的电子游戏，<strong>数据模型</strong>就是我们的游戏规则。当你在 Python 世界里玩耍，依据游戏规则创造出自己的类型、对象以后，这些东西会在整个 Python 世界的规则下，与其他事物发生奇妙的连锁反应，迸发出一些令人意想不到的火花。</p>\n<p>下面的故事就是一个例子。</p>\n<h3 id=\"nav_point_196\">处理旅游数据的三种方案</h3>\n<p>一个普通的工作日，在一家经营出境旅游的公司办公室里，商务同事小 Y 兴冲冲地跑到我的工位前，一脸激动地跟我说道：“R 哥，跟你说件好事儿。我昨天去 XX 公司出差，和对方谈拢了商务合作，打通了两家公司的客户数据。利用这些数据，我感觉可以做一波精准营销。”</p>\n<p>说完，小 Y 打开笔记本电脑，从电脑桌面上的文件夹里翻出两个 Excel 表格文件。</p>\n<p>“在这两个文件里，分别存着最近去过泰国普吉岛和新西兰旅游的旅客信息，姓名、电话号码和旅游时间都有。”小 Y 看着我，稍作停顿后继续说“看着这堆数据，我突然有个大胆的想法。我觉得，那些去过普吉岛的人，肯定对新西兰旅游也特别感兴趣。只要 R 哥你能从这两份数据里，找出那些<strong>去过普吉岛但没去过新西兰的人</strong>，我再让销售人员向他们推销一些新西兰精品旅游路线，肯定能卖疯！”</p>\n<p>虽然听上去并没什么逻辑，但我看着小 Y 一脸认真的样子，一时竟找不到什么理由来反驳他，于是接下了这个任务。五分钟后，我从小 Y 那拿到了两份数据文件：新西兰旅客信息 .xlsx 和普吉岛旅客信息 .xlsx。</p>\n<p>将文件转换为 JSON 格式后，里面的内容大致如下：</p>\n<pre class=\"code-rows\"><code># 去过普吉岛的人员数据\nusers_visited_phuket = [\n    {\n        \"first_name\": \"Sirena\",\n        \"last_name\": \"Gross\",\n        \"phone_number\": \"650-568-0388\",\n        \"date_visited\": \"2018-03-14\",\n    },\n    ...\n]\n\n# 去过新西兰的人员数据\nusers_visited_nz = [\n    {\n        \"first_name\": \"Justin\",\n        \"last_name\": \"Malcom\",\n        \"phone_number\": \"267-282-1964\",\n        \"date_visited\": \"2011-03-13\",\n    },\n    ...\n]</code></pre>\n<p>每条旅游数据里都包含旅客的 <code>last_name</code>（姓）、<code>first_name</code>（名）、<code>phone_number</code>（电话号码）和 <code>date_visited</code>（旅游时间）四个字段。</p>\n<p>有了规范的数据和明确的需求，接下来编写代码。</p>\n<ol>\n<li><p><strong>第一次蛮力尝试</strong></p>\n<p>因为在我拿到的旅客数据里，并没有“旅客 ID”之类的唯一标识符，所以我其实无法精确地找出重复旅客，只能用“姓名 + 电话号码”来判断两位旅客是不是同一个人。</p>\n<p>很快，我就写出了第一版代码：</p>\n<pre class=\"code-rows\"><code>def find_potential_customers_v1():\n    \"\"\"找到去过普吉岛但是没去过新西兰的人\n\n    :return: 通过 Generator 返回符合条件的旅客记录\n    \"\"\"\n    for puket_record in users_visited_puket:\n        is_potential = True\n        for nz_record in users_visited_nz:\n            if (\n                puket_record['first_name'] == nz_record['first_name']\n                and puket_record['last_name'] == nz_record['last_name']\n                and puket_record['phone_number'] == nz_record['phone_number']\n            ):\n                is_potential = False\n                break\n\n        if is_potential:\n            yield puket_record</code></pre>\n<p>为了找到符合要求的旅客，<code>find_potential_customers_v1</code> 函数先遍历了所有的普吉岛旅客记录，然后在循环内逐个检索新西兰旅客记录。假如找不到任何匹配，函数就会把它当作“潜在客户”返回。</p>\n<p>虽然这段代码能完成任务，但相信不用我说你也能发现，它有非常严重的性能问题。对于每条普吉岛旅客记录，我们都需要轮询所有的新西兰旅客记录，尝试找到匹配项。</p>\n<p>如果从时间复杂度上来看，上面函数的时间复杂度是可怕的 <code>O(n*m)</code><span class=\"comment-number\">1</span>，执行耗时将随着旅客记录条数的增加呈指数型增长。</p>\n<p>为了能更高效完成任务，我们需要提升查找匹配记录的效率。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用集合优化函数</strong></p>\n<p>在第 3 章中，我们了解到 Python 里的集合是基于哈希表实现的，判断一个东西是否在集合里，速度非常快，平均时间复杂度是 <code>O(1)</code>。</p>\n<p>因此，对于上面的函数来说，我们其实可以先将所有的新西兰旅客记录转换成一个集合，之后查找匹配时，程序就不需要再遍历所有记录，直接做一次集合成员判断就行。这样函数的性能可以得到极大提升，时间复杂度会直接线性下降：<code>O(n+m)</code>。</p>\n<p>下面是修改后的函数代码：</p>\n<pre class=\"code-rows\"><code>def find_potential_customers_v2():\n    \"\"\" 找到去过普吉岛但是没去过新西兰的人，性能改进版\"\"\"\n    # 首先，遍历所有新西兰旅客记录，创建查找索引\n    nz_records_idx = {\n        (rec['first_name'], rec['last_name'], rec['phone_number'])\n        for rec in users_visited_nz\n    }\n\n    for rec in users_visited_puket:\n        key = (rec['first_name'], rec['last_name'], rec['phone_number'])\n        if key not in nz_records_idx:\n            yield rec</code></pre>\n<p>引入集合后，新函数的性能有了突破性的增长，足够满足需求。</p>\n<p>不过，盯着上面的集合代码看了两分钟以后，我隐隐觉得，这个需求似乎还有一种更直接、更有趣的解决方案。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>对问题的重新思考</strong></p>\n<p>我重新梳理一遍整件事情，看看能不能找到一些新点子。</p>\n<p>首先，有两份旅客记录数据 A 和 B，A 里存放了所有普吉岛旅客记录，<code>B</code> 里存放着所有新西兰旅客记录。随后我定义了一个判断记录相等的规则：“姓名与电话号码一致”。最后基于这个规则，我找到了<strong>在 A 里出现，但在 B 里没有</strong>的旅客记录。</p>\n<p>有趣的地方来了，如果把 A 和 B 看作两个集合，上面的事情不就是在求 A 和 B 的差集吗？如图 12-1 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00395.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 12-1　集合求差集</strong></p>\n<p>而在 Python 中，假如你有两个集合，就可以直接用 <code>A - B</code> 这样的数学运算来计算二者之间的差集：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; A = \n&gt;&gt;&gt; B = \n# 产生新集合：所有在 A 里但是不在 B 里的元素\n&gt;&gt;&gt; A - B\n</code></pre>\n<p>所以，计算“去过普吉岛但没去过新西兰的人”，其实就是一次集合的差值运算。但在我们熟悉的集合运算里，成员都是简单的数据类型，比如整型、字符串等，而这次我们的数据类型明显更复杂。</p>\n<p>究竟要怎么做，才能把问题套入集合的游戏规则里呢？</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>利用集合的游戏规则</strong></p>\n<p>要用集合来解决我们的问题，第一步是建模一个用来表示旅客记录的新类型，暂且叫它 <code>VisitRecord</code> 吧：</p>\n<pre class=\"code-rows\"><code>class VisitRecord:\n    \"\"\"旅客记录\n\n    :param first_name: 名\n    :param last_name: 姓\n    :param phone_number: 电话号码\n    :param date_visited: 旅游时间\n    \"\"\"\n\n    def __init__(self, first_name, last_name, phone_number, date_visited):\n        self.first_name = first_name\n        self.last_name = last_name\n        self.phone_number = phone_number\n        self.date_visited = date_visited</code></pre>\n<p>默认情况下，Python 的用户自定义类型都是可哈希的。因此，<code>VisitRecord</code> 对象可以直接放进集合里，但行为可能会和你预想中的有些不同：</p>\n<pre class=\"code-rows\"><code># 初始化两个属性完全一致的 VisitRecord 对象\n&gt;&gt;&gt; v1 = VisitRecord('a', 'b', phone_number='100-100-1000', date_visited='2000-01-01')\n&gt;&gt;&gt; v2 = VisitRecord('a', 'b', phone_number='100-100-1000', date_visited='2000-01-01')\n\n# 往集合里放入一个对象\n&gt;&gt;&gt; s = set()\n&gt;&gt;&gt; s.add(v1)\n&gt;&gt;&gt; s\n{&lt;__main__.VisitRecord object at 0x1076063a0&gt;}\n\n# 放入第二个属性完全一致的对象后，集合并没有起到去重作用\n&gt;&gt;&gt; s.add(v2)\n&gt;&gt;&gt; s\n{&lt;__main__.VisitRecord object at 0x1076063a0&gt;, &lt;__main__.VisitRecord object at 0x1076062e0&gt;}\n\n# 对比两个对象，结果并不相等\n&gt;&gt;&gt; v1 == v2\nFalse</code></pre>\n<p>出现上面这样的结果其实并不奇怪。因为对于任何自定义类型来说，当你对两个对象进行相等比较时，Python 只会判断它们是不是指向内存里的同一个地址。换句话说，任何对象都只和它自身相等。</p>\n<p>因此，为了让集合能正确处理 <code>VisitRecord</code> 类型，我们首先要重写类型的 <code>__eq__</code> 魔法方法，让 Python 在对比两个 <code>VisitRecord</code> 对象时，不再关注对象 ID，只关心记录的姓名与电话号码。</p>\n<p>在 <code>VisitRecord</code> 类里增加以下方法：</p>\n<pre class=\"code-rows\"><code>def __eq__(self, other):\n    if isinstance(other, self.__class__):\n        return self.comparable_fields == other.comparable_fields\n    return False\n\n@property\ndef comparable_fields(self):\n    \"\"\"获取用于对比对象的字段值\"\"\"\n    return (self.first_name, self.last_name, self.phone_number)</code></pre>\n<p>完成这一步后，<code>VisitRecord</code> 的相等运算就重写成了我们所需要的逻辑：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; v1 = VisitRecord('a', 'b', phone_number='100-100-1000', date_visited='2000-01-01')\n&gt;&gt;&gt; v2 = VisitRecord('a', 'b', phone_number='100-100-1000', date_visited='2000-01-01')\n&gt;&gt;&gt; v1 == v2\nTrue</code></pre>\n<p>但要达到计算差集的目的，仅重写 <code>__eq__</code> 是不够的。如果我现在试着把一个新的 <code>VisitRecord</code> 对象塞进集合，程序马上会报错：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; set().add(v1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'VisitRecord'</code></pre>\n<p>发生什么事了？<code>VisitRecord</code> 类型突然从可哈希变成了不可哈希！要弄清楚原因，得先从哈希表的工作原理讲起。</p>\n<p>当 Python 把一个对象放入哈希表数据结构（如集合、字典）中时，它会先使用 <code>hash()</code> 函数计算出对象的哈希值，然后利用该值在表里找到对象应在的位置，之后完成保存。而当 Python 需要获知哈希表里是否包含某个对象时，同样也会先计算出对象的哈希值，之后直接定位到哈希表里的对应位置，再和表里的内容进行精确比较。</p>\n<p>也就是说，无论是往集合里存入对象，还是判断某对象是否在集合里，对象的哈希值都会作为一个重要的前置索引被使用。</p>\n<p>在我重写 <code>__eq__</code> 前，对象的哈希值其实是对象的 ID（值经过一些转换，和 <code>id()</code> 调用结果并非完全一样）。但当 <code>__eq__</code> 方法被重写后，假如程序仍然使用对象 ID 作为哈希值，那么一个严重的悖论就会出现：<strong>即便两个不同的 <code>VisitRecord</code>对象在逻辑上相等，但它们的哈希值不一样，这在原理上和哈希表结构相冲突</strong>。</p>\n<p>因为对于哈希表来说，两个相等的对象，其哈希值也必须一样，否则一切算法逻辑都不再成立。所以，Python 才会在发现重写了 <code>__eq__</code> 方法的类型后，直接将其变为不可哈希，以此强制要求你为其设计新的哈希值算法。</p>\n<p>幸运的是，只要简单地重写 <code>VisitRecord</code> 的 <code>__hash__</code> 方法，我们就能解决这个问题：</p>\n<pre class=\"code-rows\"><code>def __hash__(self):\n    return hash(self.comparable_fields)</code></pre>\n<p>因为 <code>.comparable_fields</code> 属性返回了由姓名、电话号码构成的元组，而元组本身就是可哈希类型，所以我可以直接把元组的哈希值当作 <code>VisitRecord</code> 的哈希值使用。</p>\n<p>完成 <code>VisitRecord</code> 建模，做完所有的准备工作后，剩下的事情便顺水推舟了。基于集合差值运算的新版函数，只要一行核心代码就能完成操作：</p>\n<pre class=\"code-rows\"><code>class VisitRecord:\n    \"\"\"旅客记录\n\n    - 当两条旅客记录的姓名与电话号码相同时，判定二者相等。\n    \"\"\"\n\n    def __init__(self, first_name, last_name, phone_number, date_visited):\n        self.first_name = first_name\n        self.last_name = last_name\n        self.phone_number = phone_number\n        self.date_visited = date_visited\n\n    def __hash__(self):\n        return hash(self.comparable_fields)\n\n    def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            return self.comparable_fields == other.comparable_fields\n        return False\n\n    @property\n    def comparable_fields(self):\n        \"\"\"获取用于比较对象的字段值\"\"\"\n        return (self.first_name, self.last_name, self.phone_number)\n\ndef find_potential_customers_v3():\n    # 转换为 VisitRecord 对象后计算集合差值\n    return set(VisitRecord(**r) for r in users_visited_puket) - set(\n        VisitRecord(**r) for r in users_visited_nz\n    )</code></pre>\n<blockquote>\n<p><strong>哈希值必须独一无二吗？</strong></p>\n<p>看了上面的哈希值算法，也许你会有一个疑问：一个对象的哈希值必须独一无二吗？</p>\n<p>答案是“不需要”。对于两个不同的对象，它们的哈希值最好不同，但即便哈希值一样也没关系。有个术语专门用来描述这种情况：<strong>哈希冲突</strong>（hash collision）。一个正常的哈希表，一定会处理好哈希冲突，同一个哈希值确实可能会指向多个对象。</p>\n<p>因此，当 Python 通过哈希值在表里搜索时，并不会完全依赖哈希值，而一定会再做一次精准的相等比较运算 <code>==</code>（使用 <code>__eq__</code>），这样才能最终保证程序的正确性。</p>\n<p>话虽如此，一个设计优秀的哈希算法，应该尽量做到让不同对象拥有不同哈希值，减少哈希冲突的可能性，这样才能让哈希表的性能最大化，让内容存取的时间复杂度保持在 <code>O(1)</code>。</p>\n</blockquote>\n<p>故事到这儿还没有结束。</p>\n<p>如果让我评价一下上面这份代码，非让我说：“它比‘使用集合优化函数’阶段的简单‘预计算集合 + 循环检查’方案更好”，我还真开不了口。上面的代码很复杂，而且用到了许多高级方法，完全称不上是一段多么务实的好代码，它最大的用途其实是阐述了集合与哈希算法的工作原理。</p>\n<p>基本没有人会在实际工作中写出上面这种代码来解决这么一个简单问题。但是，有了下面这个模块的帮助，事情也许会有一些变化。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 <code>dataclasses</code></strong></p>\n<p><code>dataclasses</code> 是 Python 在 3.7 版本后新增的一个内置模块。它最主要的用途是利用类型注解语法来快速定义像上面的 <code>VisitRecord</code> 一样的数据类。</p>\n<p>使用 <code>dataclasses</code> 可以极大地简化 <code>VisitRecord</code> 类，代码最终会变成下面这样：</p>\n<pre class=\"code-rows\"><code>from dataclasses import dataclass, field\n\n@dataclass(frozen=True)\nclass VisitRecordDC:\n    first_name: str ➊\n    last_name: str\n    phone_number: str\n    date_visited: str = field(compare=False) ➋\n　\n　\ndef find_potential_customers_v4():\n    return set(VisitRecordDC(**r) for r in users_visited_puket) - set(\n        VisitRecordDC(**r) for r in users_visited_nz\n    )</code></pre>\n<blockquote>\n<p>❶ 要定义一个 <code>dataclass</code> 字段，只需提供字段名和类型注解即可</p>\n<p>❷ 因为旅游时间 <code>date_visited</code> 不用于比较运算，所以需要指定 <code>compare=False</code> 跳过该字段</p>\n</blockquote>\n<p>通过 <code>@dataclass</code> 来定义一个数据类，我完全不用再手动实现 <code>__init__</code> 方法，也不用重写任何 <code>__eq__</code> 与 <code>hash</code> 方法，所有的逻辑都会由 <code>@dataclass</code> 自动完成。</p>\n<p>在上面的代码里，尤其需要说明的是 <code>@dataclass(frozen=True)</code> 语句里的 <code>frozen</code> 参数。在默认情况下，由 <code>@dataclass</code> 创建的数据类都是可修改的，不支持任何哈希操作。因此你必须指定 <code>frozen=True</code>，显式地将当前类变为不可变类型，这样才能正常计算对象的哈希值。</p>\n<p>最后，在集合运算和数据类的帮助下，不用干任何脏活累活，总共不到十行代码就能完成所有的工作。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>小结</strong></p>\n<p>问题解决后，我们简单做一下总结。在处理这个问题时，我一共使用了三种方案：</p>\n<p>(1) 使用普通的两层循环筛选符合规则的结果集；</p>\n<p>(2) 利用哈希表结构（<code>set</code> 对象）创建索引，提升处理效率；</p>\n<p>(3) 将数据转换为自定义对象，直接使用集合进行运算。</p>\n<p>方案 (1) 的性能问题太大，不做过多讨论。</p>\n<p>方案 (2) 其实是个非常务实的问题解决办法，它代码不多，容易理解，并且由于不需要创建任何自定义对象，所以它在性能与内存占用上甚至略优于方案 (3)。</p>\n<p>但我之所以继续推导出了方案 (3)，是因为我觉得它非常有趣：它有效地利用了 Python 世界的规则，创造性地达成了目的。这条规则可具体化为：“Python 拥有集合类型，集合间可以通过运算符 <code>-</code> 进行差值运算”。</p>\n<p>希望你可以从这个故事里体会到用数据模型与规则来解决实际问题的美妙。</p>\n</li>\n</ol>\n\n<h2 id=\"nav_point_197\">12.3　编程建议</h2>\n<h3 id=\"nav_point_198\">12.3.1　认识 <code>__hash__</code> 的危险性</h3>\n<p>在案例故事里，我展示了如何通过重写 <code>__hash__</code> 方法来重写对象的哈希值，并以此改变对象在存入哈希表时的行为。但是，在设计 <code>__hash__</code> 方法时，不是任何东西都适用于计算哈希值，而必须遵守一个原则。</p>\n<p>我们通过下面这个类来看看究竟是什么原则：</p>\n<pre class=\"code-rows\"><code>class HashByValue:\n    \"\"\"根据 value 属性计算哈希值\"\"\"\n\n    def __init__(self, value):\n        self.value = value\n\n    def __hash__(self):\n        return hash(self.value)</code></pre>\n<p><code>HashByValue</code> 类重写了默认的对象哈希方法，总是使用 <code>value</code> 属性的哈希值来当作对象哈希值。但是，假如一个 <code>HashByValue</code> 对象的 <code>value</code> 属性在对象生命周期里发生变化，就会产生古怪的现象。</p>\n<p>先看看下面这段代码：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; h = HashByValue(3)\n&gt;&gt;&gt; s = set()\n&gt;&gt;&gt; s.add(h)\n&gt;&gt;&gt; s\n{&lt;__main__.HashByValue object at 0x108416dc0&gt;}\n&gt;&gt;&gt; h in s\nTrue</code></pre>\n<p>在上面这段代码里，我创建了一个 <code>HashByValue</code> 对象，并把它放进了一个空集合里。看上去一切都很正常，但是假如我稍微修改一下对象的 <code>value</code> 属性：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; h.value = 4\n&gt;&gt;&gt; h in s\nFalse</code></pre>\n<p>当 <code>h</code> 的 <code>value</code> 变成 <code>4</code> 以后，<code>h</code> 从集合里消失了！</p>\n<p>因为 <code>value</code> 取值变了，<code>h</code> 对象的哈希值也随之改变。而当哈希值改变后，Python 就无法通过新的哈希值从集合里找到原本存在的对象了。</p>\n<p>所以，设计哈希算法的原则是：在一个对象的生命周期里，它的哈希值必须保持不变，否则就会出现各种奇怪的事情。这也是 Python 把所有可变类型（列表、字典）设置为“不可哈希”的原因。</p>\n<p>每当你想要重写 <code>__hash__</code> 方法时，一定要保证方法产生的哈希值是稳定的，不会随着对象状态而改变。要做到这点，要么你的对象不可变，不允许任何修改——就像定义 <code>dataclass</code> 时指定的 <code>frozen=True</code>；要么至少应该保证，被卷入哈希值计算的条件不会改变。</p>\n<h3 id=\"nav_point_199\">12.3.2　数据模型不是“躺赢”之道</h3>\n<p>在谈论 Python 的数据模型时，有个观点常会被我们提起：数据模型是写出 Pythonic 代码的关键，自定义数据模型的代码更地道。</p>\n<p>在大多数情况下，这个观点是有道理的。举个例子，下面的 <code>Events</code> 类是个用来装事件的容器类型，我给它定义了“是否为空”“按索引值获取事件”等方法：</p>\n<pre class=\"code-rows\"><code>class Events:\n    def __init__(self, events):\n        self.events = events\n\n    def is_empty(self):\n        return not bool(self.events)\n\n    def list_events_by_range(self, start, end):\n        return self.events[start:end]</code></pre>\n<p>使用 <code>Events</code> 类：</p>\n<pre class=\"code-rows\"><code>events = Events(\n    [\n        'computer started',\n        'os launched',\n        'docker started',\n        'os stopped',\n    ]\n)\n\n# 判断有内容后，打印第二个和第三个对象\nif not events.is_empty():\n    print(events.list_events_by_range(1, 3))</code></pre>\n<p>上面的代码散发着浓浓的传统面向对象气味。我给 <code>Events</code> 类型支持的操作起了一些直观的名字，然后将它们定义成普通方法，之后通过这些方法来使用对象。</p>\n<p>不过，<code>Events</code> 类的这两个操作，其实可以精确匹配 Python 数据模型里的概念。假如应用一丁点儿数据模型知识，我们可以把 <code>Events</code> 类改造得更符合 Python 风格：</p>\n<pre class=\"code-rows\"><code>class Events:\n    def __init__(self, events):\n        self.events = events\n\n    def __len__(self):\n        \"\"\"自定义长度，将会用来做布尔判断\"\"\"\n        return len(self.events)\n\n    def __getitem__(self, index):\n        \"\"\"自定义切片方法\"\"\"\n        # 直接将 slice 切片对象透传给 events 处理\n        return self.events[index]</code></pre>\n<p>使用新的 <code>Events</code> 类：</p>\n<pre class=\"code-rows\"><code># 判断是否有内容，打印第二个和第三个对象\nif events:\n    print(events[1:3])</code></pre>\n<p>相比旧代码，新的 <code>Events</code> 类提供了更简洁的 API，也更符合 Python 对象的使用习惯。</p>\n<p>正如 <code>Events</code> 类所展示的，许多基于 Python 数据模型设计出来的类型更地道，API 也更好用。但我想补充的是：不要把数据模型当成写代码时的万能药，把所有脚都塞进数据模型这双靴子里。</p>\n<p>举个例子，假如你有一个用来处理用户对象的规则类型 <code>UserRule</code>，它支持唯一的公开方法 <code>apply()</code>。那么，你是不是应该把 <code>apply</code> 改成 <code>__call__</code> 呢？这样一来，<code>UserRule</code> 对象会直接变为可调用，它的使用方式也会从 <code>rule.apply(...)</code> 变成 <code>rule(...)</code>，看上去似乎更短也更简单。</p>\n<p>不过我倒觉得，把 <code>UserRule</code> 往数据模型里套未必是个好主意。显式调用 <code>apply</code> 方法，实际上比隐式的可调用对象更好、更清晰。</p>\n<p>恰当地使用数据模型，确实能让我们写出更符合 Python 习惯的代码，设计出更地道的 API。但也得注意不要过度，有时，“聪明”的代码反而不如“笨”代码，平铺直叙的“笨”代码或许更能表达出设计者的意图，更容易让人理解。</p>\n<h3 id=\"nav_point_200\">12.3.3　不要依赖 <code>__del__</code> 方法</h3>\n<p>我经常见到人们把 <code>__del__</code> 当成一种自动化的资源回收方法来用。比如，一个请求其他服务的 <code>Client</code> 对象会在初始化时创建一个连接池。那么写代码的人极有可能会重写对象的 <code>__del__</code> 方法，把关闭连接池的逻辑放在方法里。</p>\n<p>但上面这种做法实际上很危险。因为 <code>__del__</code> 方法其实没那么可靠，下面我来告诉你为什么。</p>\n<p>对于 <code>__del__</code> 方法，人们经常会做一种望文生义的简单化理解。那就是如果 <code>Foo</code> 类定义了 <code>__del__</code> 方法，那么当我调用 <code>del</code> 语句，删除一个 <code>Foo</code> 类型对象时，它的 <code>__del__</code> 方法就一定会被触发。</p>\n<p>举例来说，下面的 <code>Foo</code> 类就定义了 <code>__del__</code> 方法：</p>\n<pre class=\"code-rows\"><code>class Foo:\n    def __del__(self):\n        print(f'cleaning up ...')</code></pre>\n<p>试着初始化一个 <code>foo</code> 对象，然后删除它：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; foo = Foo()\n&gt;&gt;&gt; del foo\ncleaning up &lt;__main__.Foo object at 0x10ac288b0&gt;...</code></pre>\n<p><code>foo</code> 对象的 <code>__del__</code> 方法的确被触发了。但是，假如我稍微做一些调整，情况就会发生改变：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; foo = Foo()\n&gt;&gt;&gt; l = [foo, ]\n&gt;&gt;&gt; del foo</code></pre>\n<p>这一次，我在删除 <code>foo</code> 之前，先把它放进了一个列表里。这时 <code>del foo</code> 语句就没有产生任何效果，只有当我继续用 <code>del l</code> 删除列表对象时，<code>foo</code> 对象的 <code>__del__</code> 才会被触发：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; del l\ncleaning up &lt;__main__.Foo object at 0x101cce610&gt;...</code></pre>\n<p>现在你应该明白了，一个对象的 <code>__del__</code> 方法，并非在使用 <code>del</code> 语句时被触发，而是在它被作为垃圾回收时触发。<code>del</code> 语句无法直接回收任何东西，它只是简单地删掉了指向当前对象的一个引用（变量名）而已。</p>\n<p>换句话说，<code>del</code> 让对象的引用计数减 1，但只有当引用计数降为 0 时，它才会马上被 Python 解释器回收。因此，在 <code>foo</code> 仍然被列表 <code>l</code> 引用时，删除 <code>foo</code> 的其中一个引用是不会触发 <code>__del__</code> 的。</p>\n<p>总而言之，垃圾回收机制是一门编程语言的实现细节。我所说的引用计数这套逻辑，也只针对 CPython 目前的版本有效。对于未来的 CPython 版本，或者 Python 语言的其他实现来说，它们完全有可能采用一些截然不同的垃圾回收策略。因此，<code>__del__</code> 方法的触发机制实际上是一个谜，它可能在任何时机触发，也可能很长时间都不触发。</p>\n<p>正因为如此，依赖 <code>__del__</code> 方法来做一些清理资源、释放锁、关闭连接池之类的关键工作，其实非常危险。因为你创建的任何对象，完全有可能因为某些原因一直都不被作为垃圾回收。这时，网络连接会不断增长，锁也一直无法被释放，最后整个程序会在某一刻轰然崩塌。</p>\n<p>如果你要给对象定义资源清理逻辑，请避免使用 <code>__del__</code>。你可以要求使用方显式调用清理方法，或者实现一个上下文管理器协议——用 <code>with</code> 语句来自动清理（参考 Python 的文件对象），这些方式全都比 <code>__del__</code> 好得多。</p>\n<h2 id=\"nav_point_201\">12.4　总结</h2>\n<p>在本章中，我们学习了不少与 Python 数据模型有关的知识。</p>\n<p>了解 Python 的一些数据模型知识，可以让你更容易写出符合 Python 风格的代码，设计出更好用的框架和工具。有时，数据模型甚至能助你事半功倍。</p>\n<p>以下是本章要点知识总结。</p>\n<p>(1) 字符串相关协议</p>\n<ul>\n<li>使用 <code>__str__</code> 方法，可以定义对象的字符串值（被 <code>str()</code> 触发）</li>\n<li>使用 <code>__repr__</code> 方法，可以定义对象对调试友好的详细字符串值（被 <code>repr()</code> 触发）</li>\n<li>如果对象只定义了 <code>__repr__</code> 方法，它同时会用于替代 <code>__str__</code></li>\n<li>使用 <code>__format__</code> 方法，可以在对象被用于字符串模板渲染时，提供多种字符串值（被 <code>.format()</code> 触发）</li>\n</ul>\n<p>(2) 比较运算符重载</p>\n<ul>\n<li>通过重载与比较运算符有关的 6 个魔法方法，你可以让对象支持 <code>==</code>、<code>&gt;=</code> 等比较运算</li>\n<li>使用 <code>functools.total_ordering</code> 可以极大地减少重载比较运算符的工作量</li>\n</ul>\n<p>(3) 描述符协议</p>\n<ul>\n<li>使用描述符协议，你可以轻松实现可复用的属性对象</li>\n<li>实现了 <code>__get__</code>、<code>__set__</code> 、<code>__delete__</code> 其中任何一个方法的类都是描述符类</li>\n<li>要在描述符里保存实例级别的数据，你需要将其存放在 <code>instance.dict</code> 里，而不是直接放在描述符对象上</li>\n<li>使用 <code>__set_name__</code> 方法能让描述符对象知道自己被绑定了什么名字</li>\n</ul>\n<p>(4) 数据类与自定义哈希运算</p>\n<ul>\n<li>要让自定义类支持集合运算，你需要实现 <code>__eq__</code> 与 <code>__hash__</code> 两个方法</li>\n<li>如果两个对象相等，它们的哈希值也必须相等，否则会破坏哈希表的正确性</li>\n<li>不同对象的哈希值可以一样，哈希冲突并不会破坏程序正确性，但会影响效率</li>\n<li>使用 <code>dataclasses</code> 模块，你可以快速创建一个支持哈希操作的数据类</li>\n<li>要让数据类支持哈希操作，你必须指定 <code>frozen=True</code> 参数将其声明为不可变类型</li>\n<li>一个对象的哈希值必须在它的生命周期里保持不变</li>\n</ul>\n<p>(5) 其他建议</p>\n<ul>\n<li>虽然数据模型能帮我们写出更 Pythonic 的代码，但切勿过度推崇</li>\n<li><code>__del__</code> 方法不是在执行 <code>del</code> 语句时被触发，而是在对象被作为垃圾回收时被触发</li>\n<li>不要使用 <code>__del__</code> 来做任何“自动化”的资源回收工作</li>\n</ul>\n\n<br style=\"page-break-after:always\" />","comments":[]}