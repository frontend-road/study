{"id":185174,"title":"基于DDD的微服务设计实例代码详解","content":"<p>你好，我是欧创新。好久不见，今天我带着你期待的案例来了。</p><p>还记得我们在 <a href=\"https://time.geekbang.org/column/article/169881\">[第 18 讲]</a> 中用事件风暴完成的“在线请假考勤”项目的领域建模和微服务设计吗？今天我们就在这个项目的基础上看看，用DDD方法设计和开发出来的微服务代码到底是什么样的？点击 <a href=\"https://github.com/ouchuangxin/leave-sample\">Github</a> 获取完整代码，接下来的内容是我对代码的一个详解，期待能帮助你更好地实践我们这个专栏所学到的知识。</p><h2>项目回顾</h2><p>“在线请假考勤”项目中，请假的核心业务流程是：请假人填写请假单提交审批；根据请假人身份、请假类型和请假天数进行校验并确定审批规则；根据审批规则确定审批人，逐级提交上级审批，逐级核批通过则完成审批，否则审批不通过则退回申请人。</p><p>在 <a href=\"https://time.geekbang.org/column/article/169881\">[第 18 讲]</a> 的微服务设计中，我们已经拆分出了两个微服务：请假和考勤微服务。今天我们就围绕“请假微服务”来进行代码详解。微服务采用的开发语言和数据库分别是：Java、Spring boot 和 PostgreSQL。</p><h2>请假微服务采用的DDD设计思想</h2><p>请假微服务中用到了很多的DDD设计思想和方法，主要包括以下几个：</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/92/5f22ed9bb3d5b6c63f21583469399892.jpg?wh=3175*1729\" alt=\"\"></p><h2>聚合中的对象</h2><p>请假微服务包含请假（leave）、人员（person）和审批规则（rule）三个聚合。leave聚合完成请假申请和审核核心逻辑；person聚合管理人员信息和上下级关系；rule是一个单实体聚合，提供请假审批规则查询。</p><!-- [[[read_end]]] --><p>Leave是请假微服务的核心聚合，它有请假单聚合根leave、审批意见实体ApprovalInfo、请假申请人Applicant和审批人Approver值对象（它们的数据来源于person聚合），还有部分枚举类型，如请假类型LeaveType，请假单状态Status和审批状态类型ApprovalType等值对象。</p><p>下面我们通过代码来了解一下聚合根、实体以及值对象之间的关系。</p><h3>1. 聚合根</h3><p>聚合根leave中有属性、值对象、关联实体和自身的业务行为。Leave实体采用充血模型，有自己的业务行为，具体就是聚合根实体类的方法，如代码中的getDuration和addHistoryApprovalInfo等方法。</p><p>聚合根引用实体和值对象，它可以组合聚合内的多个实体，在聚合根实体类方法中完成复杂的业务行为，这种复杂的业务行为也可以在聚合领域服务里实现。但为了职责和边界清晰，我建议聚合要根据自身的业务行为在实体类方法中实现，而涉及多个实体组合才能实现的业务能力由领域服务完成。</p><p>下面是聚合根leave的实体类方法，它包含属性、对实体和值对象的引用以及自己的业务行为和方法。</p><pre><code>public class Leave {\n    String id;\n    Applicant applicant;\n    Approver approver;\n    LeaveType type;\n    Status status;\n    Date startTime;\n    Date endTime;\n    long duration;\n    int leaderMaxLevel; //审批领导的最高级别\n    ApprovalInfo currentApprovalInfo;\n    List&lt;ApprovalInfo&gt; historyApprovalInfos; \n\n    public long getDuration() {\n        return endTime.getTime() - startTime.getTime();\n    }\n\n    public Leave addHistoryApprovalInfo(ApprovalInfo approvalInfo) {\n        if (null == historyApprovalInfos)\n            historyApprovalInfos = new ArrayList&lt;&gt;();\n        this.historyApprovalInfos.add(approvalInfo);\n        return this;\n    } \n\n    public Leave create(){\n        this.setStatus(Status.APPROVING);\n        this.setStartTime(new Date());\n        return this;\n}\n\n//其它方法\n}\n</code></pre><h3>2. 实体</h3><p>审批意见实体ApprovalInfo被leave聚合根引用，用于记录审批意见，它有自己的属性和值对象，如approver等，业务逻辑相对简单。</p><pre><code>public class ApprovalInfo {\n    String approvalInfoId;\n    Approver approver;\n    ApprovalType approvalType;\n    String msg;\n    long time;\n}\n</code></pre><h3>3. 值对象</h3><p>在Leave聚合有比较多的值对象。</p><p>我们先来看一下审批人值对象Approver。这类值对象除了属性集之外，还可以有简单的数据查询和转换服务。Approver数据来源于person聚合，从person聚合获取审批人返回后，从person实体获取personID、personName和level等属性，重新组合为approver值对象，因此需要数据转换和重新赋值。</p><p>Approver值对象同时被聚合根leave和实体approvalInfo引用。这类值对象的数据来源于其它聚合，不可修改，可重复使用。将这种对象设计为值对象而不是实体，可以提高系统性能，降低数据库实体关联的复杂度，所以我一般建议优先设计为值对象。</p><pre><code>public class Approver {\n    String personId;\n    String personName;\n    int level; //管理级别\n\n    public static Approver fromPerson(Person person){\n        Approver approver = new Approver();\n        approver.setPersonId(person.getPersonId());\n        approver.setPersonName(person.getPersonName());\n        approver.setLevel(person.getRoleLevel());\n        return approver;\n    }\n}\n</code></pre><p>下面是枚举类型的值对象Status的代码。</p><pre><code>public enum Status {\n    APPROVING, APPROVED, REJECTED\n}\n</code></pre><p>这里你要记住一点，由于值对象只做整体替换、不可修改的特性，在值对象中基本不会有修改或新增的方法。</p><h3>4. 领域服务</h3><p>如果一个业务行为由多个实体对象参与完成，我们就将这部分业务逻辑放在领域服务中实现。领域服务与实体方法的区别是：实体方法完成单一实体自身的业务逻辑，是相对简单的原子业务逻辑，而领域服务则是多个实体组合出的相对复杂的业务逻辑。两者都在领域层，实现领域模型的核心业务能力。</p><p>一个聚合可以设计一个领域服务类，管理聚合内所有的领域服务。</p><p>请假聚合的领域服务类是LeaveDomainService。领域服务中会用到很多的DDD设计模式，比如：用工厂模式实现复杂聚合的实体数据初始化，用仓储模式实现领域层与基础层的依赖倒置和用领域事件实现数据的最终一致性等。</p><pre><code>public class LeaveDomainService {\n\n    @Autowired\n    EventPublisher eventPublisher;\n    @Autowired\n    LeaveRepositoryInterface leaveRepositoryInterface;\n    @Autowired\n    LeaveFactory leaveFactory;\n\n    @Transactional\n    public void createLeave(Leave leave, int leaderMaxLevel, Approver approver) {\n            leave.setLeaderMaxLevel(leaderMaxLevel);\n            leave.setApprover(approver);\n            leave.create();\n    leaveRepositoryInterface.save(leaveFactory.createLeavePO(leave));\n    LeaveEvent event = LeaveEvent.create(LeaveEventType.CREATE_EVENT, leave);\n    leaveRepositoryInterface.saveEvent(leaveFactory.createLeaveEventPO(event));\n    eventPublisher.publish(event);\n    }\n\n    @Transactional\n    public void updateLeaveInfo(Leave leave) {\n    LeavePO po = leaveRepositoryInterface.findById(leave.getId());\n        if (null == po) {\n                throw new RuntimeException(&quot;leave does not exist&quot;);\n         }\n     leaveRepositoryInterface.save(leaveFactory.createLeavePO(leave));\n    }\n\n    @Transactional\n    public void submitApproval(Leave leave, Approver approver) {\n       LeaveEvent event;\n       if (ApprovalType.REJECT == leave.getCurrentApprovalInfo().getApprovalType()) {\n       leave.reject(approver);\n       event = LeaveEvent.create(LeaveEventType.REJECT_EVENT, leave);\n       } else {\n             if (approver != null) {\n                 leave.agree(approver);\n                 event = LeaveEvent.create(LeaveEventType.AGREE_EVENT, leave); } else {\n                    leave.finish();\n                    event = LeaveEvent.create(LeaveEventType.APPROVED_EVENT, leave);\n                    }\n           }\n      leave.addHistoryApprovalInfo(leave.getCurrentApprovalInfo());\n      leaveRepositoryInterface.save(leaveFactory.createLeavePO(leave));\n      leaveRepositoryInterface.saveEvent(leaveFactory.createLeaveEventPO(event));\n      eventPublisher.publish(event);\n    }\n\n    public Leave getLeaveInfo(String leaveId) {\n    LeavePO leavePO = leaveRepositoryInterface.findById(leaveId);\n    return leaveFactory.getLeave(leavePO);\n    }\n\n    public List&lt;Leave&gt; queryLeaveInfosByApplicant(String applicantId) {\n        List&lt;LeavePO&gt; leavePOList = leaveRepositoryInterface.queryByApplicantId(applicantId);\n    return leavePOList.stream().map(leavePO -&gt; leaveFactory.getLeave(leavePO)).collect(Collectors.toList());\n    }\n\n    public List&lt;Leave&gt; queryLeaveInfosByApprover(String approverId) {\n    List&lt;LeavePO&gt; leavePOList = leaveRepositoryInterface.queryByApproverId(approverId);\n    return leavePOList.stream().map(leavePO -&gt; leaveFactory.getLeave(leavePO)).collect(Collectors.toList());\n    }\n}\n</code></pre><p><strong>领域服务开发时的注意事项：</strong></p><p>在领域服务或实体方法中，我们应尽量避免调用其它聚合的领域服务或引用其它聚合的实体或值对象，这种操作会增加聚合的耦合度。在微服务架构演进时，如果出现聚合拆分和重组，这种跨聚合的服务调用和对象引用，会变成跨微服务的操作，导致这种跨聚合的领域服务调用和对象引用失效，在聚合分拆时会增加你代码解耦和重构的工作量。</p><p><span class=\"orange\">以下是一段不建议使用的代码。</span>在这段代码里Approver是leave聚合的值对象，它作为对象参数被传到person聚合的findNextApprover领域服务。如果在同一个微服务内，这种方式是没有问题的。但在架构演进时，如果person和leave两个聚合被分拆到不同的微服务中，那么leave中的Approver对象以及它的getPersonId()和fromPersonPO方法在person聚合中就会失效，这时你就需要进行代码重构了。</p><pre><code>public class PersonDomainService {\n\n   public Approver findNextApprover(Approver currentApprover, int leaderMaxLevel) {\n   PersonPO leaderPO = personRepository.findLeaderByPersonId(currentApprover.getPersonId());\n        if (leaderPO.getRoleLevel() &gt; leaderMaxLevel) {\n            return null;\n        } else {\n            return Approver.fromPersonPO(leaderPO);\n        }\n   }\n}\n</code></pre><p>那正确的方式是什么样的呢？在应用服务组合不同聚合的领域服务时，我们可以通过ID或者参数来传数，如单一参数currentApproverId。这样聚合之间就解耦了，下面是修改后的代码，它可以不依赖其它聚合的实体，独立完成业务逻辑。</p><pre><code>public class PersonDomainService {\n   \n   public Person findNextApprover(String currentApproverId, int leaderMaxLevel) {\n   PersonPO leaderPO = personRepository.findLeaderByPersonId(currentApproverId);\n   if (leaderPO.getRoleLevel() &gt; leaderMaxLevel) {\n       return null;\n    } else {\n            return personFactory.createPerson(leaderPO);\n      }\n  }\n}\n</code></pre><h2>领域事件</h2><p>在创建请假单和请假审批过程中会产生领域事件。为了方便管理，我们将聚合内的领域事件相关的代码放在聚合的event目录中。领域事件实体在聚合仓储内完成持久化，但是事件实体的生命周期不受聚合根管理。</p><h3>1. 领域事件基类DomainEvent</h3><p>你可以建立统一的领域事件基类DomainEvent。基类包含：事件ID、时间戳、事件源以及事件相关的业务数据。</p><pre><code>public class DomainEvent {\n    String id;\n    Date timestamp;\n    String source;\n    String data;\n}\n</code></pre><h3>2. 领域事件实体</h3><p>请假领域事件实体LeaveEvent继承基类DomainEvent。可根据需要扩展属性和方法，如leaveEventType。data字段中存储领域事件相关的业务数据，可以是XML或Json等格式。</p><pre><code>public class LeaveEvent extends DomainEvent {\n    LeaveEventType leaveEventType;\n    public static LeaveEvent create(LeaveEventType eventType, Leave leave){\n       LeaveEvent event = new LeaveEvent();\n       event.setId(IdGenerator.nextId());\n       event.setLeaveEventType(eventType);\n       event.setTimestamp(new Date());\n       event.setData(JSON.toJSONString(leave));\n       return event;\n    }\n}\n</code></pre><h3>3. 领域事件的执行逻辑</h3><p>一般来说，领域事件的执行逻辑如下：</p><p>第一步：执行业务逻辑，产生领域事件。</p><p>第二步：完成业务数据持久化。</p><pre><code>leaveRepositoryInterface.save(leaveFactory.createLeavePO(leave));\n</code></pre><p>第三步：完成事件数据持久化。</p><pre><code>leaveRepositoryInterface.saveEvent(leaveFactory.createLeaveEventPO(event));\n</code></pre><p>第四步：完成领域事件发布。</p><pre><code>eventPublisher.publish(event); \n</code></pre><p>以上领域事件处理逻辑代码详见LeaveDomainService中submitApproval领域服务，里面有请假提交审批事件的完整处理逻辑。</p><h3>4. 领域事件数据持久化</h3><p>为了保证事件发布方与事件订阅方数据的最终一致性和数据审计，有些业务场景需要建立数据对账机制。数据对账主要通过对源端和目的端的持久化数据比对，从而发现异常数据并进一步处理，保证数据最终一致性。</p><p>对于需要对账的事件数据，我们需设计领域事件对象的持久化对象PO，完成领域事件数据的持久化，如LeaveEvent事件实体的持久化对象LeaveEventPO。再通过聚合的仓储完成数据持久化：</p><pre><code>leaveRepositoryInterface.saveEvent(leaveFactory.createLeaveEventPO(event))。\n</code></pre><p>事件数据持久化对象LeaveEventPO格式如下：</p><pre><code>public class LeaveEventPO {\n    @Id\n    @GenericGenerator(name = &quot;idGenerator&quot;, strategy = &quot;uuid&quot;) \n    @GeneratedValue(generator = &quot;idGenerator&quot;)\n    int id;\n    @Enumerated(EnumType.STRING)\n    LeaveEventType leaveEventType;\n    Date timestamp;\n    String source;\n    String data;\n}\n</code></pre><h2>仓储模式</h2><p>领域模型中DO实体的数据持久化是必不可少的，DDD采用仓储模式实现数据持久化，使得业务逻辑与基础资源逻辑解耦，实现依赖倒置。持久化时先完成DO与PO对象的转换，然后在仓储服务中完成PO对象的持久化。</p><h3>1. DO与PO对象的转换</h3><p>Leave聚合根的DO实体除了自身的属性外，还会根据领域模型引用多个值对象，如Applicant和Approver等，它们包含多个属性，如：personId、personName和personType等属性。</p><p>在持久化对象PO设计时，你可以将这些值对象属性嵌入PO属性中，或设计一个组合属性字段，以Json串的方式存储在PO中。</p><p>以下是leave的DO的属性定义：</p><pre><code>public class Leave {\n    String id;\n    Applicant applicant;\n    Approver approver;\n    LeaveType type;\n    Status status;\n    Date startTime;\n    Date endTime;\n    long duration;\n    int leaderMaxLevel;\n    ApprovalInfo currentApprovalInfo;\n    List&lt;ApprovalInfo&gt; historyApprovalInfos;\n}\n\npublic class Applicant {\n    String personId;\n    String personName;\n    String personType;\n}\n\npublic class Approver {\n    String personId;\n    String personName;\n    int level;\n}\n</code></pre><p>为了减少数据库表数量以及表与表的复杂关联关系，我们将leave实体和多个值对象放在一个LeavePO中。如果以属性嵌入的方式，Applicant值对象在LeavePO中会展开为：applicantId、applicantName和applicantType三个属性。</p><p>以下为采用属性嵌入方式的持久化对象LeavePO的结构。</p><pre><code>public class LeavePO {\n    @Id\n    @GenericGenerator(name=&quot;idGenerator&quot;, strategy=&quot;uuid&quot;) \n    @GeneratedValue(generator=&quot;idGenerator&quot;)\n    String id;\n    String applicantId;\n    String applicantName;\n    @Enumerated(EnumType.STRING)\n    PersonType applicantType;\n    String approverId;\n    String approverName;\n    @Enumerated(EnumType.STRING)\n    LeaveType leaveType;\n    @Enumerated(EnumType.STRING)\n    Status status;\n    Date startTime;\n    Date endTime;\n    long duration;\n    @Transient\n    List&lt;ApprovalInfoPO&gt; historyApprovalInfoPOList;\n}\n</code></pre><h3>2. 仓储模式</h3><p>为了解耦业务逻辑和基础资源，我们可以在基础层和领域层之间增加一层仓储服务，实现依赖倒置。通过这一层可以实现业务逻辑和基础层资源的依赖分离。在变更基础层数据库的时候，你只要替换仓储实现就可以了，上层核心业务逻辑不会受基础资源变更的影响，从而实现依赖倒置。</p><p>一个聚合一个仓储，实现聚合数据的持久化。领域服务通过仓储接口来访问基础资源，由仓储实现完成数据持久化和初始化。仓储一般包含：仓储接口和仓储实现。</p><p><strong>2.1仓储接口</strong></p><p>仓储接口面向领域服务提供接口。</p><pre><code>public interface LeaveRepositoryInterface {\n   void save(LeavePO leavePO);\n   void saveEvent(LeaveEventPO leaveEventPO);\n   LeavePO findById(String id);\n   List&lt;LeavePO&gt; queryByApplicantId(String applicantId);\n   List&lt;LeavePO&gt; queryByApproverId(String approverId);\n}\n</code></pre><p><strong>2.2仓储实现</strong></p><p>仓储实现完成数据持久化和数据库查询。</p><pre><code>@Repository\npublic class LeaveRepositoryImpl implements LeaveRepositoryInterface {\n\n    @Autowired\n    LeaveDao leaveDao;\n    @Autowired\n    ApprovalInfoDao approvalInfoDao;\n    @Autowired\n    LeaveEventDao leaveEventDao;\n\n    public void save(LeavePO leavePO) { \n        leaveDao.save(leavePO);\n        approvalInfoDao.saveAll(leavePO.getHistoryApprovalInfoPOList());\n    }\n\n    public void saveEvent(LeaveEventPO leaveEventPO){\n        leaveEventDao.save(leaveEventPO);\n    }\n\n    @Override\n    public LeavePO findById(String id) {\n        return leaveDao.findById(id)\n                .orElseThrow(() -&gt; new RuntimeException(&quot;leave not found&quot;));\n    }\n\n    @Override\n    public List&lt;LeavePO&gt; queryByApplicantId(String applicantId) {\n        List&lt;LeavePO&gt; leavePOList = leaveDao.queryByApplicantId(applicantId);\n        leavePOList.stream()\n                .forEach(leavePO -&gt; {\n                    List&lt;ApprovalInfoPO&gt; approvalInfoPOList = approvalInfoDao.queryByLeaveId(leavePO.getId());\n                    leavePO.setHistoryApprovalInfoPOList(approvalInfoPOList);\n                });\n        return leavePOList;\n    }\n\n    @Override\n    public List&lt;LeavePO&gt; queryByApproverId(String approverId) {\n        List&lt;LeavePO&gt; leavePOList = leaveDao.queryByApproverId(approverId);\n        leavePOList.stream()\n                .forEach(leavePO -&gt; {\n                    List&lt;ApprovalInfoPO&gt; approvalInfoPOList = approvalInfoDao.queryByLeaveId(leavePO.getId());\n                    leavePO.setHistoryApprovalInfoPOList(approvalInfoPOList);\n                });\n        return leavePOList;\n    }\n}\n</code></pre><p>这里持久化组件采用了Jpa。</p><pre><code>public interface LeaveDao extends JpaRepository&lt;LeavePO, String&gt; {\n    List&lt;LeavePO&gt; queryByApplicantId(String applicantId);\n    List&lt;LeavePO&gt; queryByApproverId(String approverId);\n}\n</code></pre><p><strong>2.3仓储执行逻辑</strong></p><p>以创建请假单为例，仓储的执行步骤如下。</p><p>第一步：仓储执行之前将聚合内DO会转换为PO，这种转换在工厂服务中完成：</p><pre><code>leaveFactory.createLeavePO(leave)。\n</code></pre><p>第二步：完成对象转换后，领域服务调用仓储接口：</p><pre><code>leaveRepositoryInterface.save。\n</code></pre><p>第三步：由仓储实现完成PO对象持久化。</p><p>代码执行步骤如下：</p><pre><code>public void createLeave(Leave leave, int leaderMaxLevel, Approver approver) {\n  leave.setLeaderMaxLevel(leaderMaxLevel);\n  leave.setApprover(approver);\n  leave.create();\n  leaveRepositoryInterface.save(leaveFactory.createLeavePO(leave));\n}\n</code></pre><h2>工厂模式</h2><p>对于大型的复杂领域模型，聚合内的聚合根、实体和值对象之间的依赖关系比较复杂，这种过于复杂的依赖关系，不适合通过根实体构造器来创建。为了协调这种复杂的领域对象的创建和生命周期管理，在DDD里引入了工厂模式（Factory），在工厂里封装复杂的对象创建过程。</p><p>当聚合根被创建时，聚合内所有依赖的对象将会被同时创建。</p><p>工厂与仓储模式往往结对出现，应用于数据的初始化和持久化两类场景。</p><ul>\n<li>DO对象的初始化：获取持久化对象PO，通过工厂一次构建出聚合根所有依赖的DO对象，完数据初始化。</li>\n<li>DO的对象持久化：将所有依赖的DO对象一次转换为PO对象，完成数据持久化。</li>\n</ul><p>下面代码是leave聚合的工厂类LeaveFactory。其中createLeavePO（leave）方法组织leave聚合的DO对象和值对象完成leavePO对象的构建。getLeave（leave）通过持久化对象PO构建聚合的DO对象和值对象，完成leave聚合DO实体的初始化。</p><pre><code>public class LeaveFactory {\n   \n   public LeavePO createLeavePO(Leave leave) {\n   LeavePO leavePO = new LeavePO();\n   leavePO.setId(UUID.randomUUID().toString());\n   leavePO.setApplicantId(leave.getApplicant().getPersonId());\n   leavePO.setApplicantName(leave.getApplicant().getPersonName());\n   leavePO.setApproverId(leave.getApprover().getPersonId());\n   leavePO.setApproverName(leave.getApprover().getPersonName());\n   leavePO.setStartTime(leave.getStartTime());\n   leavePO.setStatus(leave.getStatus());\n   List&lt;ApprovalInfoPO&gt; historyApprovalInfoPOList = approvalInfoPOListFromDO(leave);\n   leavePO.setHistoryApprovalInfoPOList(historyApprovalInfoPOList);\n   return leavePO;\n}\n\n\n   public Leave getLeave(LeavePO leavePO) {\n   Leave leave = new Leave();\n   Applicant applicant = Applicant.builder()\n       .personId(leavePO.getApplicantId())\n       .personName(leavePO.getApplicantName())\n       .build();\n   leave.setApplicant(applicant);\n   Approver approver = Approver.builder()\n       .personId(leavePO.getApproverId())\n       .personName(leavePO.getApproverName())\n       .build();\n   leave.setApprover(approver);\n   leave.setStartTime(leavePO.getStartTime());\n   leave.setStatus(leavePO.getStatus());\n   List&lt;ApprovalInfo&gt; approvalInfos = getApprovalInfos(leavePO.getHistoryApprovalInfoPOList());\n   leave.setHistoryApprovalInfos(approvalInfos);\n   return leave;\n   }\n\n\n//其它方法\n}\n</code></pre><h2>服务的组合与编排</h2><p>应用层的应用服务完成领域服务的组合与编排。一个聚合的应用服务可以建立一个应用服务类，管理聚合所有的应用服务。比如leave聚合有LeaveApplicationService，person聚合有PersonApplicationService。</p><p>在请假微服务中，有三个聚合：leave、person和rule。我们来看一下应用服务是如何跨聚合来进行服务的组合和编排的。以创建请假单createLeaveInfo应用服务为例，分为这样三个步骤。</p><p>第一步：根据请假单定义的人员类型、请假类型和请假时长从rule聚合中获取请假审批规则。这一步通过approvalRuleDomainService类的getLeaderMaxLevel领域服务来实现。</p><p>第二步：根据请假审批规则，从person聚合中获取请假审批人。这一步通过personDomainService类的findFirstApprover领域服务来实现。</p><p>第三步：根据请假数据和从rule和person聚合获取的数据，创建请假单。这一步通过leaveDomainService类的createLeave领域服务来实现。</p><p>由于领域核心逻辑已经很好地沉淀到了领域层中，领域层的这些核心逻辑可以高度复用。应用服务只需要灵活地组合和编排这些不同聚合的领域服务，就可以很容易地适配前端业务的变化。因此应用层不会积累太多的业务逻辑代码，所以会变得很薄，代码维护起来也会容易得多。</p><p>以下是leave聚合的应用服务类。代码是不是非常得少？</p><pre><code>public class LeaveApplicationService{\n\n    @Autowired\n    LeaveDomainService leaveDomainService;\n    @Autowired\n    PersonDomainService personDomainService;\n    @Autowired\n    ApprovalRuleDomainService approvalRuleDomainService;\n    \n    public void createLeaveInfo(Leave leave){\n    //get approval leader max level by rule\n    int leaderMaxLevel = approvalRuleDomainService.getLeaderMaxLevel(leave.getApplicant().getPersonType(), leave.getType().toString(), leave.getDuration());\n    //find next approver\n    Person approver = personDomainService.findFirstApprover(leave.getApplicant().getPersonId(), leaderMaxLevel);\n    leaveDomainService.createLeave(leave, leaderMaxLevel, Approver.fromPerson(approver));\n    }\n\n    public void updateLeaveInfo(Leave leave){\n    leaveDomainService.updateLeaveInfo(leave);\n    }\n\n    public void submitApproval(Leave leave){\n    //find next approver\n    Person approver = personDomainService.findNextApprover(leave.getApprover().getPersonId(), leave.getLeaderMaxLevel());\n    leaveDomainService.submitApproval(leave, Approver.fromPerson(approver));\n    }\n    \n    public Leave getLeaveInfo(String leaveId){\n        return leaveDomainService.getLeaveInfo(leaveId);\n    }\n\n    public List&lt;Leave&gt; queryLeaveInfosByApplicant(String applicantId){\n    return leaveDomainService.queryLeaveInfosByApplicant(applicantId);\n    }\n\n    public List&lt;Leave&gt; queryLeaveInfosByApprover(String approverId){\n    return leaveDomainService.queryLeaveInfosByApprover(approverId);\n    }\n}\n</code></pre><p><strong>应用服务开发注意事项：</strong></p><p>为了聚合解耦和微服务架构演进，应用服务在对不同聚合领域服务进行编排时，应避免不同聚合的实体对象，在不同聚合的领域服务中引用，这是因为一旦聚合拆分和重组，这些跨聚合的对象将会失效。</p><p>在LeaveApplicationService中，leave实体和Applicant值对象分别作为参数被rule聚合和person聚合的领域服务引用，这样会增加聚合的耦合度。<span class=\"orange\">下面是不推荐使用的代码。</span></p><pre><code>public class LeaveApplicationService{\n\n  public void createLeaveInfo(Leave leave){\n  //get approval leader max level by rule\n  ApprovalRule rule = approvalRuleDomainService.getLeaveApprovalRule(leave);\n  int leaderMaxLevel = approvalRuleDomainService.getLeaderMaxLevel(rule);\n  leave.setLeaderMaxLevel(leaderMaxLevel);\n  //find next approver\n  Approver approver = personDomainService.findFirstApprover(leave.getApplicant(), leaderMaxLevel);\n  leave.setApprover(approver);\n  leaveDomainService.createLeave(leave);\n  }\n}\n</code></pre><p>那如何实现聚合的解耦呢？我们可以将跨聚合调用时的对象传值调整为参数传值。一起来看一下调整后的代码，getLeaderMaxLevel由leave对象传值调整为personType，leaveType和duration参数传值。findFirstApprover中Applicant值对象调整为personId参数传值。</p><pre><code>public class LeaveApplicationService{\n\n  public void createLeaveInfo(Leave leave){\n  //get approval leader max level by rule\n  int leaderMaxLevel = approvalRuleDomainService.getLeaderMaxLevel(leave.getApplicant().getPersonType(), leave.getType().toString(), leave.getDuration());\n  //find next approver\n  Person approver = personDomainService.findFirstApprover(leave.getApplicant().getPersonId(), leaderMaxLevel);\n  leaveDomainService.createLeave(leave, leaderMaxLevel, Approver.fromPerson(approver));\n  }\n}\n</code></pre><p>在微服务演进和聚合重组时，就不需要进行聚合解耦和代码重构了。</p><h2>微服务聚合拆分时的代码演进</h2><p>如果请假微服务未来需要演进为人员和请假两个微服务，我们可以基于请假leave和人员person两个聚合来进行拆分。由于两个聚合已经完全解耦，领域逻辑非常稳定，在微服务聚合代码拆分时，聚合领域层的代码基本不需要调整。调整主要集中在微服务的应用服务中。</p><p>我们以应用服务createLeaveInfo为例，当一个微服务拆分为两个微服务时，看看代码需要做什么样的调整？</p><h3>1. 微服务拆分前</h3><p>createLeaveInfo应用服务的代码如下：</p><pre><code>public void createLeaveInfo(Leave leave){\n    \n    //get approval leader max level by rule\n    int leaderMaxLevel = approvalRuleDomainService.getLeaderMaxLevel(leave.getApplicant().getPersonType(), leave.getType().toString(), leave.getDuration());\n    //find next approver\n    Person approver = personDomainService.findFirstApprover(leave.getApplicant().getPersonId(), leaderMaxLevel);\n    leaveDomainService.createLeave(leave, leaderMaxLevel, Approver.fromPerson(approver));\n}\n</code></pre><h3>2. 微服务拆分后</h3><p>leave和person两个聚合随微服务拆分后，createLeaveInfo应用服务中下面的代码将会变成跨微服务调用。</p><pre><code>Person approver = personDomainService.findFirstApprover(leave.getApplicant().getPersonId(), leaderMaxLevel);\n</code></pre><p>由于跨微服务的调用是在应用层完成的，我们只需要调整createLeaveInfo应用服务代码，将原来微服务内的服务调用personDomainService.findFirstApprover修改为跨微服务的服务调用：personFeignService. findFirstApprover。</p><p>同时新增ApproverAssembler组装器和PersonResponse的DTO对象，以便将person微服务返回的person DTO对象转换为approver值对象。</p><pre><code>// PersonResponse为调用微服务返回结果的封装\n//通过personFeignService调用Person微服务用户接口层的findFirstApprover facade接口\nPersonResponse approverResponse = personFeignService. findFirstApprover(leave.getApplicant().getPersonId(), leaderMaxLevel);\nApprover approver = ApproverAssembler.toDO(approverResponse);\n</code></pre><p>在原来的person聚合中，由于findFirstApprover领域服务已经逐层封装为用户接口层的Facade接口，所以person微服务不需要做任何代码调整，只需将PersonApi的findFirstApprover Facade服务，发布到API网关即可。</p><p>如果拆分前person聚合的findFirstApprover领域服务，没有被封装为Facade接口，我们只需要在person微服务中按照以下步骤调整即可。</p><p>第一步：将person聚合PersonDomainService类中的领域服务findFirstApprover封装为应用服务findFirstApprover。</p><pre><code>@Service\npublic class PersonApplicationService {\n\n  @Autowired\n  PersonDomainService personDomainService;\n  \n  public Person findFirstApprover(String applicantId, int leaderMaxLevel) {\n  return personDomainService.findFirstApprover(applicantId, leaderMaxLevel);\n  }\n}\n</code></pre><p>第二步：将应用服务封装为Facade服务，并发布到API网关。</p><pre><code>@RestController\n@RequestMapping(&quot;/person&quot;)\n@Slf4j\npublic class PersonApi {\n  \n  @Autowired\n  @GetMapping(&quot;/findFirstApprover&quot;)\n  public Response findFirstApprover(@RequestParam String applicantId, @RequestParam int leaderMaxLevel) {\n  Person person = personApplicationService.findFirstApprover(applicantId, leaderMaxLevel);\n          return Response.ok(PersonAssembler.toDTO(person));\n  }\n}\n</code></pre><h2>服务接口的提供</h2><p>用户接口层是前端应用与微服务应用层的桥梁，通过Facade接口封装应用服务，适配前端并提供灵活的服务，完成DO和DTO相互转换。</p><p>当应用服务接收到前端请求数据时，组装器会将DTO转换为DO。当应用服务向前端返回数据时，组装器会将DO转换为DTO。</p><h3>1. facade接口</h3><p>facade接口可以是一个门面接口实现类，也可以是门面接口加一个门面接口实现类。项目可以根据前端的复杂度进行选择，由于请假微服务前端功能相对简单，我们就直接用一个门面接口实现类来实现就可以了。</p><pre><code>public class LeaveApi {   \n  @PostMapping\n  public Response createLeaveInfo(LeaveDTO leaveDTO){\n          Leave leave = LeaveAssembler.toDO(leaveDTO);\n          leaveApplicationService.createLeaveInfo(leave);\n          return Response.ok();\n  }\n  \n  @PostMapping(&quot;/query/applicant/{applicantId}&quot;)\n  public Response queryByApplicant(@PathVariable String applicantId){\n  List&lt;Leave&gt; leaveList = leaveApplicationService.queryLeaveInfosByApplicant(applicantId);\n  List&lt;LeaveDTO&gt; leaveDTOList = leaveList.stream().map(leave -&gt; LeaveAssembler.toDTO(leave)).collect(Collectors.toList());\n          return Response.ok(leaveDTOList);\n  }\n\n//其它方法\n}\n</code></pre><h3>2. DTO数据组装</h3><p>组装类（Assembler）：负责将应用服务返回的多个DO对象组装为前端DTO对象，或将前端请求的DTO对象转换为多个DO对象，供应用服务作为参数使用。组装类中不应有业务逻辑，主要负责格式转换、字段映射等。Assembler往往与DTO同时存在。LeaveAssembler完成请假DO和DTO数据相互转换。</p><pre><code>public class LeaveAssembler {\n\n    public static LeaveDTO toDTO(Leave leave){\n        LeaveDTO dto = new LeaveDTO();\n        dto.setLeaveId(leave.getId());\n        dto.setLeaveType(leave.getType().toString());\n        dto.setStatus(leave.getStatus().toString());\n        dto.setStartTime(DateUtil.formatDateTime(leave.getStartTime()));\n        dto.setEndTime(DateUtil.formatDateTime(leave.getEndTime()));\n        dto.setCurrentApprovalInfoDTO(ApprovalInfoAssembler.toDTO(leave.getCurrentApprovalInfo()));\n        List&lt;ApprovalInfoDTO&gt; historyApprovalInfoDTOList = leave.getHistoryApprovalInfos()\n                .stream()\n                .map(historyApprovalInfo -&gt; ApprovalInfoAssembler.toDTO(leave.getCurrentApprovalInfo()))\n                .collect(Collectors.toList());\n        dto.setHistoryApprovalInfoDTOList(historyApprovalInfoDTOList);\n        dto.setDuration(leave.getDuration());\n        return dto;\n    }\n\n    public static Leave toDO(LeaveDTO dto){\n        Leave leave = new Leave();\n        leave.setId(dto.getLeaveId());\n        leave.setApplicant(ApplicantAssembler.toDO(dto.getApplicantDTO()));\n        leave.setApprover(ApproverAssembler.toDO(dto.getApproverDTO()));\n        leave.setCurrentApprovalInfo(ApprovalInfoAssembler.toDO(dto.getCurrentApprovalInfoDTO()));\n        List&lt;ApprovalInfo&gt; historyApprovalInfoDTOList = dto.getHistoryApprovalInfoDTOList()\n                .stream()\n                .map(historyApprovalInfoDTO -&gt; ApprovalInfoAssembler.toDO(historyApprovalInfoDTO))\n                .collect(Collectors.toList());\n        leave.setHistoryApprovalInfos(historyApprovalInfoDTOList);\n        return leave;\n    }\n}\n</code></pre><p>DTO类：包括requestDTO和responseDTO两部分。</p><p>DTO应尽量根据前端展示数据的需求来定义，避免过多地暴露后端业务逻辑。尤其对于多渠道场景，可以根据渠道属性和要求，为每个渠道前端应用定义个性化的DTO。由于请假微服务相对简单，我们可以用leaveDTO代码做个示例。</p><pre><code>@Data\npublic class LeaveDTO {\n    String leaveId;\n    ApplicantDTO applicantDTO;\n    ApproverDTO approverDTO;\n    String leaveType;\n    ApprovalInfoDTO currentApprovalInfoDTO;\n    List&lt;ApprovalInfoDTO&gt; historyApprovalInfoDTOList;\n    String startTime;\n    String endTime;\n    long duration;\n    String status;\n}\n</code></pre><h2>总结</h2><p>今天我们了解了用DDD开发出来的微服务代码到底是什么样的。你可以将这些核心设计思想逐步引入到项目中去，慢慢充实自己的DDD知识体系。我还想再重点强调的是：由于架构的演进，微服务与生俱来就需要考虑聚合的未来重组。因此微服务的设计和开发要做到未雨绸缪，而这最关键的就是解耦了。</p><p><strong>聚合与聚合的解耦：</strong>当多个聚合在同一个微服务时，很多传统架构开发人员会下意识地引用其他聚合的实体和值对象，或者调用其它聚合的领域服务。因为这些聚合的代码在同一个微服务内，运行时不会有问题，开发效率似乎也更高，但这样会不自觉地增加聚合之间的耦合。在微服务架构演进时，如果聚合被分别拆分到不同的微服务中，原来微服务内的关系就会变成跨微服务的关系，原来微服务内的对象引用或服务调用将会失效。最终你还是免不了要花大量的精力去做聚合解耦。虽然前期领域建模和边界划分得很好，但可能会因为开发稍不注意，而导致解耦工作前功尽弃。</p><p><strong>微服务内各层的解耦：</strong>微服务内有四层，在应用层和领域层组成核心业务领域的两端，有两个缓冲区或数据转换区。前端与应用层通过组装器实现DTO和DO的转换，这种适配方式可以更容易地响应前端需求的变化，隐藏核心业务逻辑的实现，保证核心业务逻辑的稳定，实现核心业务逻辑与前端应用的解耦。而领域层与基础层通过仓储和工厂模式实现DO和PO的转换，实现应用逻辑与基础资源逻辑的解耦。</p><p>最后我想说，DDD知识体系虽大，但你可以根据企业的项目场景和成本要求，逐步引入适合自己的DDD方法和技术，建立适合自己的DDD开发模式和方法体系。</p><p>这一期的加餐到这就结束了，希望你能对照完整代码认真阅读今天的内容，有什么疑问，欢迎在留言区与我交流！</p>","comments":[{"had_liked":false,"id":167902,"user_name":"冬青","can_delete":false,"product_type":"c1","uid":1356014,"ip_address":"","ucode":"14576781B499FB","user_header":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","comment_is_top":true,"comment_ctime":1577960460,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"9.2233721543968993e+18","product_id":100037301,"comment_content":"偶是编辑，这篇加餐比较长～作者会抽周末的时间把音频讲解为大家补上。感谢等待！","like_count":28,"discussions":[{"author":{"id":1049994,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/8a/e7c5a7e2.jpg","nickname":"sky","note":"","ucode":"C0859057592720","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560823,"discussion_content":"编缉好美","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649465908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302004,"user_name":"常文龙","can_delete":false,"product_type":"c1","uid":1204525,"ip_address":"","ucode":"4A126159D24766","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/2d/5ca0a3da.jpg","comment_is_top":false,"comment_ctime":1626014893,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"96115295405","product_id":100037301,"comment_content":"看了很多同道中人提了类似的疑问，分享一下自己的灵魂问题的回答：<br>Q1.一个逻辑，貌似放在应用层、领域服务层、甚至聚合根本身都可以，到底什么是准绳？<br>A1.<br>（1）首先，分层的本质是为了复用和内聚，切不可成为作茧自缚的存在。<br>（2）其次，其实每层的定位，老师也说了，应用层是做跨聚合操作的，领域服务层是做聚合内的跨实体操作，而聚合根是自身能触达的对象的。<br>其实后两者有点含糊，因为聚合根理论上是聚合内四通八达的对象，但领域服务也是。从大家的共识看来，大家都更喜欢纯getter&#47;setter的“容器模型”，而不是一个有“行为”的对象。这点其实老师在案例和回复也默认了，觉得很简单的才放进聚合根（案例里聚合根也就组合了几个setter，搞搞当前时间而已）。<br>（3）那么，假如觉得放在哪都行，说明他很可能根本就是一个聚合根的“DB基操”，譬如查询、更新请假单这两个操作，压根就是查库、写库。这时候自然是越底层越好（因为越底层将来就越有复用的可能），因此就放在领域服务层了。<br><br>Q2：文中一直提到，一旦拆分，引用会失效。<br>A2：<br>（1）可能是因为我一开始就接触了dubbo之类的rpc框架，我没觉得有什么失效的，毕竟对于dubbo而言，不用考虑是否走网络，将来拆分，大不了为领域对象做个jar包就完事了。<br>（2）但按照老师说的，的确有一个好处，就是面向抽象，对于调用方来说，不用new大对象了，也不用担心自己set少了东西会导致问题。说白了，就是把关键的信息传过来得了。<br><br>Q3:仓储到底解决了什么问题？比起DAO有什么区别？<br>A3:<br>（1）首先，从老师的案例看来，仓储是依赖了DAO的。而且可以看出，仓储最大的特点，是一个add方法背后偷偷处理了N个表，而不是一个纯纯的小表。<br>（2）那么更深的灵魂问题来了，从仓储的定位是抽象存储，为何DO转PO这件事会发生在领域服务层（案例里，领域服务调用的factory方法）？按我的理解，至少仓储应该接受、返回DO才对。这点我目前不能理解，还是希望得到老师的回答。<br>（3）其实大部分互联网公司，尤其java栈都不存在换数据库的担忧，至少SQL大部分时候是标准的、JDBC也是抽象了数据库驱动的。因此，DAO这种读写库的模式已经很够用了。<br><br>Q4：DDD到底给我什么意义，解决了目前什么困境？<br>A4：目前来看，DDD有两个深刻的意义，是我过去没领会到的。<br>（1）提醒了我，世界上有 领域驱动 vs. 数据驱动 两种套路（不说我都没意识到，这自上而下，自下而上的结果可能大不相同）<br>（2）给了我一个划分“领域、聚合”两种范围，“实体（聚合根）、值对象、事件、命令”这个世界观，以及对应的需求分析方法论。<br><br>Q5:值对象的价值在哪？<br>A5:<br>（1）值对象本是Martin发现基于引用的编程语言在相等比较、写操作的时候互相干扰的问题而特地发明的概念，要求大家不能在值对象做局部写，而只能整个替换。然而实际上大家往往会通过克隆对象避免误写，通过简单的重写equal解决比较，犯不着新增概念。<br>（2）但我觉的值对象目前有一个更实在好处，就是当两个割裂的模型发生关联的时候，可以作为“快照”或者“实例”的表达。譬如案例中的人员在请假聚合里，表现为“请假人”、“审批者”，这时候只留下人员的名称和id，其他不留。这也意味着，这个人员改名了，在请假单里也是旧的名字（希望这是真实需求吧）。<br>","like_count":23,"discussions":[{"author":{"id":1184868,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKM5opSMdO81Et9ib3ibJ38KEywA9pecR3L83OqPuC4bwL9gr0wPzUKpiaFokKZ7GiaIib9aCFVR0E5gPA/132","nickname":"淡忘7788","note":"","ucode":"FE25781681F90D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567214,"discussion_content":"仓储层 不仅仅是数据库还有缓存等第三方组件的初级","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650858551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262685,"user_name":"Din","can_delete":false,"product_type":"c1","uid":1013276,"ip_address":"","ucode":"02B38F4C612882","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/1c/e709be94.jpg","comment_is_top":false,"comment_ctime":1605801825,"is_pvip":false,"replies":[{"id":"96534","content":"你这个问题很好！记得去年thoughtworks的梅雪松老师提过一个方案，你可以通过以下链接看一下https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;87074950。<br>方案的核心是Aggregate&lt;T&gt;容器，T是聚合根的类型。Repository以Aggregate&lt;T&gt;为核心，当Repository查询或保存聚合时，返回的不是聚合本身，而是聚合容器Aggregate&lt;T&gt;。Aggregate&lt;T&gt;保留了聚合的历史快照，因此在Repository保存聚合时，就可以与快照进行对比，找到需要修改的实体和字段，然后完成持久化工作。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1606958638,"ip_address":"","comment_id":262685,"utype":1}],"discussion_count":5,"race_medal":0,"score":"61735343969","product_id":100037301,"comment_content":"老师，您好！请教一个关于repository使用的问题<br><br>在DDD的原则里，repository操作的都是聚合根，repository的作用就是把内存中的聚合根持久化，或者把持久化的数据还原为内存中的聚合根。repository中一般也只有getById，save,remove几个方法。<br><br>例如取消订单的场景，我其实只需要更新order的状态等少数几个字段，但是如果调用repository的save方法，就会把订单其他字段以及订单明细数据都更新一次，这样就会造成性能影响，以及数据冲突的问题。<br><br>针对这个问题，我想到两种解决方案：<br>1. 在repository增加只更新部分字段的方法，例如只更新订单状态和取消时间 saveOrderCancelInfo（），但这样会对repository有一定的污染，并且感觉saveOrderCancelInfo掺杂了业务逻辑<br>2. 在repository的save方法中，通过技术手段，找出聚合根对象被修改的数据，然后只对这些数据字段做更改。<br><br>老师，您有什么建议呢？","like_count":14,"discussions":[{"author":{"id":1013276,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/76/1c/e709be94.jpg","nickname":"Din","note":"","ucode":"02B38F4C612882","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331714,"discussion_content":"谢谢老师回复！\n\n前段时间我在github上发现了梅雪松老师的开源项目，试用了一下，有些问题，已经反馈给作者了😄\n\n看来还是第二种方案更适合，只不过如果用mybatis,需要自己实现类似hibernate的dirty check的功能","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1606959529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3051709,"avatar":"","nickname":"张阿辛","note":"","ucode":"3CA174F251F35F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1013276,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/76/1c/e709be94.jpg","nickname":"Din","note":"","ucode":"02B38F4C612882","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580524,"discussion_content":"有什么问题?我也想了解一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658230398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":331714,"ip_address":""},"score":580524,"extra":""}]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509926,"discussion_content":"你这个问题很好！记得去年thoughtworks的梅雪松老师提过一个方案，你可以通过以下链接看一下https://zhuanlan.zhihu.com/p/87074950。\n方案的核心是Aggregate&amp;lt;T&amp;gt;容器，T是聚合根的类型。Repository以Aggregate&amp;lt;T&amp;gt;为核心，当Repository查询或保存聚合时，返回的不是聚合本身，而是聚合容器Aggregate&amp;lt;T&amp;gt;。Aggregate&amp;lt;T&amp;gt;保留了聚合的历史快照，因此在Repository保存聚合时，就可以与快照进行对比，找到需要修改的实体和字段，然后完成持久化工作。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606958638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180447,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/1f/1280ed77.jpg","nickname":"笑忘书","note":"","ucode":"FA21EFA971E03D","race_medal":3,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559243,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648653028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/3d/1189e48a.jpg","nickname":"微思","note":"","ucode":"853C48AA183A7B","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402976,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633969216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196402,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1585278445,"is_pvip":false,"replies":[{"id":"74428","content":"如果实在团队不好处理，那你先以聚合为单位划好边界，在聚合内可以抛弃聚合根之类的这些概念，聚合内都是领域服务，毕竟微服务的演进是以聚合为单位演进的，聚合内高内聚，聚合之间松耦合。其它的DDD的一些设计要求尽量要遵循。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585283875,"ip_address":"","comment_id":196402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35945016813","product_id":100037301,"comment_content":"欧老师，有个关于充血模型的问题跟您探讨一下。<br>我研究DDD也有一段时间了，在某几个项目里面也推动团队采用DDD的设计思想，实体采用了充血模型（entity和po分开），在项目真正运行的过程中发现了几个问题：<br>1、由于我们的项目规模比较大，数据结构比较复杂，变动也比较频繁。每次有数据结构调整的时候改动的工作量比较大，导致团队成员比较抵触。<br>2、实体是充血模型的话，可以看成实体本身是有状态的。但是在一些逻辑比较复杂的场景下感觉操作起来会有点儿复杂。<br>最终实际的结果就是，整个团队这个充血模型用的有点儿不伦不类了。我的想法是这样的：按照DDD的设计思想，我个人觉得关键点是领域的边界，至于要不要用充血模型感觉不是那么重要（尤其是在团队整体的思想和能力达不到这么高的要求下），不知道您在实际的工作中是怎么平衡这个的。","like_count":8,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489287,"discussion_content":"如果实在团队不好处理，那你先以聚合为单位划好边界，在聚合内可以抛弃聚合根之类的这些概念，聚合内都是领域服务，毕竟微服务的演进是以聚合为单位演进的，聚合内高内聚，聚合之间松耦合。其它的DDD的一些设计要求尽量要遵循。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585283875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169336,"user_name":"CN....","can_delete":false,"product_type":"c1","uid":1228489,"ip_address":"","ucode":"2C265A33D4C642","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/c9/505bfb99.jpg","comment_is_top":false,"comment_ctime":1578317561,"is_pvip":false,"replies":[{"id":"65763","content":"1、这个主要是考虑业务数据，事件数据持久化和发送消息队列同时能够成功，避免出现数据不一致的情况。当然也可以只在业务数据和事件数据持久化增加事务，如果消息队列发送不成功，还可以从事件表中获取数据再次发送。<br>2、消息订阅方一般在应用层监听和接受事件数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578386526,"ip_address":"","comment_id":169336,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31643088633","product_id":100037301,"comment_content":"老师好，浏览代码有两点疑惑<br>1，我们通常会认为加了事务注解就尽量避免除数据库外的其他调用，但是代码中在领域服务中的方法中发送mq，而且是在有事务注解的方法中，这里是基于什么考虑<br>2，消费mq的逻辑应该属于那一层<br>谢谢","like_count":7,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480513,"discussion_content":"1、这个主要是考虑业务数据，事件数据持久化和发送消息队列同时能够成功，避免出现数据不一致的情况。当然也可以只在业务数据和事件数据持久化增加事务，如果消息队列发送不成功，还可以从事件表中获取数据再次发送。\n2、消息订阅方一般在应用层监听和接受事件数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578386526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1050411,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/2b/d111e75d.jpg","nickname":"Lion","note":"","ucode":"21AA6AE4A90789","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":583795,"discussion_content":"这块要保证幂等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660387869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":480513,"ip_address":"河北"},"score":583795,"extra":""}]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":121682,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578322057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168431,"user_name":"盲僧","can_delete":false,"product_type":"c1","uid":1617432,"ip_address":"","ucode":"8E29CF9A3045D0","user_header":"https://static001.geekbang.org/account/avatar/00/18/ae/18/b649c2c0.jpg","comment_is_top":false,"comment_ctime":1578065349,"is_pvip":false,"replies":[{"id":"65509","content":"😄","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578232898,"ip_address":"","comment_id":168431,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27347869125","product_id":100037301,"comment_content":"太棒了，这个案例太精彩","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480218,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578232898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284388,"user_name":"淮小麦","can_delete":false,"product_type":"c1","uid":1205780,"ip_address":"","ucode":"06645F42DA2DA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/14/e264cf23.jpg","comment_is_top":false,"comment_ctime":1616223729,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23091060209","product_id":100037301,"comment_content":"老师你好，实战中发现一个问题，实际业务一个采购订单，里面采购产品明细可能有几百条，目前设计是采购订单为聚合根，产品明细为聚合内的一个实体，产品明细列表被订单实体引用，现在需要删除一个订单中的一条采购产品明细，需要把订单和几百条明细查询出来，重建订单实体，然后遍历产品明细列表删除对应明细，再保存数据库？这样就会多了很多不必要的查询，也重建了很多不必要的实体对象，这种情况要如何优雅解决呢？","like_count":5,"discussions":[{"author":{"id":1122533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/20/e5/f66d6144.jpg","nickname":"九先生","note":"","ucode":"A63A333299D485","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384770,"discussion_content":"在我看来你们这个产品明细有自己的生命周期，不是随着采购单的结束而结束，也可以把产品明细作为一个聚合根","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626746235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303165,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1096652,"ip_address":"","ucode":"E79CEA70430449","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","comment_is_top":false,"comment_ctime":1626626484,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18806495668","product_id":100037301,"comment_content":"最近看了很多DDD的资料，老师这个代码还是靠谱的👍","like_count":4},{"had_liked":false,"id":244686,"user_name":"川川","can_delete":false,"product_type":"c1","uid":1382517,"ip_address":"","ucode":"DA092CAC7F294D","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/75/68487e89.jpg","comment_is_top":false,"comment_ctime":1598617859,"is_pvip":false,"replies":[{"id":"90662","content":"你说的这种情况我当时考虑到了，也确实跟原则有冲突。<br>从代码完整性来讲，如果person聚合和leave聚合被拆分在不同的微服务中，那么从person聚合返回的数据应该是DTO类型的。在leave微服务中我们需要将这个person微服务返回的DTO的数据转换成DO对象，其实在转换时，我们是可以直接将person DTO组装成Approver这个DO对象的，这个转换的过程稍微有点复杂。由于当前person聚合和leave聚合是在同一个微服务中，为了避免带来误解，所以在代码里面并没有体现这种解耦处理方式。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1599466656,"ip_address":"","comment_id":244686,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18778487043","product_id":100037301,"comment_content":"老师你好 我看你在文章有个疑惑的点，我看你在文章里面提到“应避免不同聚合的实体对象，在不同聚合的领域服务中引用，这是因为一旦聚合拆分和重组，这些跨聚合的对象将会失效” 但是我看Approver实体的fromPerson方法就是用person聚合的尸体作为参数传递，这个是不是有违背原则呢。 ","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504664,"discussion_content":"你说的这种情况我当时考虑到了，也确实跟原则有冲突。\n从代码完整性来讲，如果person聚合和leave聚合被拆分在不同的微服务中，那么从person聚合返回的数据应该是DTO类型的。在leave微服务中我们需要将这个person微服务返回的DTO的数据转换成DO对象，其实在转换时，我们是可以直接将person DTO组装成Approver这个DO对象的，这个转换的过程稍微有点复杂。由于当前person聚合和leave聚合是在同一个微服务中，为了避免带来误解，所以在代码里面并没有体现这种解耦处理方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599466656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230406,"user_name":"涛涛","can_delete":false,"product_type":"c1","uid":1180810,"ip_address":"","ucode":"747C4B1F20A2D3","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/8a/ff94bd60.jpg","comment_is_top":false,"comment_ctime":1593363452,"is_pvip":false,"replies":[{"id":"85215","content":"1、在应用层和领域层之间业务逻辑和依赖相对固定，为了避免开发的复杂度，因此没有采用面向接口的编程方式。但是面向前端和基础资源时，由于外部变化相对较大，为了适配和解耦，因此采用了面向接口的方式。<br>2、你说的父单和子单，是不是指订单和订单明细？一般来说订单和订单明细是在一个聚合里面的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593497092,"ip_address":"","comment_id":230406,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18773232636","product_id":100037301,"comment_content":"老师您好，有两个疑问？<br>1.applicationService,domianService并没有实现接口，是故意这样设计的吗？<br>2.订单父单和子单设计成一个聚合好，还是2个聚合好？","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499870,"discussion_content":"1、在应用层和领域层之间业务逻辑和依赖相对固定，为了避免开发的复杂度，因此没有采用面向接口的编程方式。但是面向前端和基础资源时，由于外部变化相对较大，为了适配和解耦，因此采用了面向接口的方式。\n2、你说的父单和子单，是不是指订单和订单明细？一般来说订单和订单明细是在一个聚合里面的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593497092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1612933,"avatar":"","nickname":"Thomas Yang","note":"","ucode":"29249144F708D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583062,"discussion_content":"你说的是拆单的情况吧？我的想法一个父单聚合，一个子单聚合，父单聚合里直接包含所有子单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659891582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167896,"user_name":"阿玛铭","can_delete":false,"product_type":"c1","uid":1100703,"ip_address":"","ucode":"DBF948D82ACBE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","comment_is_top":false,"comment_ctime":1577959411,"is_pvip":false,"replies":[{"id":"65171","content":"😄，舍不得跟大家告别。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577960394,"ip_address":"","comment_id":167896,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18757828595","product_id":100037301,"comment_content":"欧老师的回马枪猝不及防","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480048,"discussion_content":"😄，舍不得跟大家告别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577960394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247800,"user_name":"Jupiter","can_delete":false,"product_type":"c1","uid":2125382,"ip_address":"","ucode":"072E5C34CDE8AC","user_header":"https://static001.geekbang.org/account/avatar/00/20/6e/46/a612177a.jpg","comment_is_top":false,"comment_ctime":1599865845,"is_pvip":false,"replies":[{"id":"91183","content":"VO实际上是前端应用的对象，跟后端微服务关系不大，如果DTO与VO之间是一对一关系的话，DTO实际上就是VO的一种数据形式，就不需要再进行转换了。<br>其实引入PO、DO、DTO、VO这几个对象主要是为了各层解耦，保证领域模型和逻辑的稳定。如果各层对象是一一对应的话，我们没必要增加转换的过程，毕竟对象之间的转换会影响应用性能。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1600047081,"ip_address":"","comment_id":247800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14484767733","product_id":100037301,"comment_content":"受益匪浅啊，感谢欧老师的课，理论和实践并存，而且值得多刷几遍去深刻理解DDD的思想。我现在的项目中能感觉有一点DDD的影子，但是我打算在我Master的作业上用一下DDD去构建一个推荐系统应用，可能会因为用DDD而用DDD，但是因为是课程设计，所以想多实践一下。有一个小问题是关于DDD里面的对象的，在前面的课程中，您提到有VO, 我现在在开发的时候 前端传给后端的对象 我使用DTO, 但是后端返回给前端的对象，我直接VO，没有中间DTO转化成VO的操作，请问这样也是可以的吧？谢谢老师。期待老师还有新的专栏分享。","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505496,"discussion_content":"VO实际上是前端应用的对象，跟后端微服务关系不大，如果DTO与VO之间是一对一关系的话，DTO实际上就是VO的一种数据形式，就不需要再进行转换了。\n其实引入PO、DO、DTO、VO这几个对象主要是为了各层解耦，保证领域模型和逻辑的稳定。如果各层对象是一一对应的话，我们没必要增加转换的过程，毕竟对象之间的转换会影响应用性能。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600047081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230480,"user_name":"史月Shi Yue","can_delete":false,"product_type":"c1","uid":1071252,"ip_address":"","ucode":"83DF94258CB92F","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/94/e83d3e91.jpg","comment_is_top":false,"comment_ctime":1593397927,"is_pvip":false,"replies":[{"id":"85214","content":"为了避免开发复杂度，在应用层和领域层之间没有采用面向接口编程的方式。<br>面向接口编程主要用在了用户接口层和基础层，主要是为了前端应用和基础资源的解耦，也是为了核心业务逻辑与外部的适配。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593496726,"ip_address":"","comment_id":230480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14478299815","product_id":100037301,"comment_content":"老师，LeaveApplicationService在依赖LeaveDomainService的时候，依赖的应该是接口吧，看代码里注入的是类，这样就不是面向接口编程了啊","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499908,"discussion_content":"为了避免开发复杂度，在应用层和领域层之间没有采用面向接口编程的方式。\n面向接口编程主要用在了用户接口层和基础层，主要是为了前端应用和基础资源的解耦，也是为了核心业务逻辑与外部的适配。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593496726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287286,"user_name":"卓坤鉴","can_delete":false,"product_type":"c1","uid":1864788,"ip_address":"","ucode":"EBD8DD74631928","user_header":"https://static001.geekbang.org/account/avatar/00/1c/74/54/9dbb1a02.jpg","comment_is_top":false,"comment_ctime":1617868886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10207803478","product_id":100037301,"comment_content":"老师您好，我一直对于您文中对于基础层的依赖倒置不太理解，您的demo中的基础层的util、client、common作为基础设施，一直都需要被其它层（应用层、领域层、接口层）所直接调用的。请问这里是怎么样将基础层与其他层解耦的，怎么做到依赖倒置的","like_count":2},{"had_liked":false,"id":278149,"user_name":"Md3zed","can_delete":false,"product_type":"c1","uid":1717785,"ip_address":"","ucode":"83EAD89468ED7B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/CccT5NgKlZRlTL8f4BsIDqfJ8tRkHPyaR3SXnfgU7acxo2OO7vGzNWjfQBuFnbPPzVYH8Lh49f1jyicuuRSndcA/132","comment_is_top":false,"comment_ctime":1612775696,"is_pvip":false,"replies":[{"id":"101030","content":"是的，你说的没错，DDD是一种设计方法，不要为了DDD而DDD，我前面章节里面也多次强调。这个案例相对简单，直接用CRUD可能更方便。为什么显得复杂？我主要是想在这个案例里面尽量把DDD的一些设计思想体现出来。具体到实际项目落地的时候，你可以根据具体场景选择合适的方法来完成设计，最终以相对较小的代价解决实际问题为宜。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612851364,"ip_address":"","comment_id":278149,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10202710288","product_id":100037301,"comment_content":"这样搞的太复杂了，感觉就是把简单的事情复杂化了。<br>DDD核心就是那几个概念的理解，微服务不一定要DDD才行，DDD只是帮助我们做领域划分，避免业务的变化导致服务的不稳定；DDD是想解决ORM的CRUD的问题，避免干尸式的“贫血”模型，它本质是一种面向对象分析和设计方法，它把业务模型转换为对象模型，通过业务模型绑定系统模型来控制业务变化带来的复杂度从而保持系统的稳定性、可扩展性、可维护性。而示例代码在这方面感觉完全为分层而分层，为DDD而DDD，可维护性，可理解性都比较差。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515297,"discussion_content":"是的，你说的没错，DDD是一种设计方法，不要为了DDD而DDD，我前面章节里面也多次强调。这个案例相对简单，直接用CRUD可能更方便。为什么显得复杂？我主要是想在这个案例里面尽量把DDD的一些设计思想体现出来。具体到实际项目落地的时候，你可以根据具体场景选择合适的方法来完成设计，最终以相对较小的代价解决实际问题为宜。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612851364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1717785,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/CccT5NgKlZRlTL8f4BsIDqfJ8tRkHPyaR3SXnfgU7acxo2OO7vGzNWjfQBuFnbPPzVYH8Lh49f1jyicuuRSndcA/132","nickname":"Md3zed","note":"","ucode":"83EAD89468ED7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349018,"discussion_content":"所以这个代码案例并不合适，像请假考勤这种需要一个工作流的通用域来支撑的。建议搞个合适的例子，实战，实战，实战到最后的一个demo也有点充数的感觉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612851835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264463,"user_name":"波锅","can_delete":false,"product_type":"c1","uid":2306289,"ip_address":"","ucode":"139559B32EACD4","user_header":"https://static001.geekbang.org/account/avatar/00/23/30/f1/62f0388c.jpg","comment_is_top":false,"comment_ctime":1606471452,"is_pvip":false,"replies":[{"id":"96479","content":"有一部分实体采用了充血模型的，但是有些实体本身业务逻辑简单，没有太多复杂的逻辑，所有就不会有复杂的方法，所以看着以为是贫血模型。<br>事件发布可以放在应用层也可以在领域层实现，比较复杂的领域事件发布逻辑建议构建事件领域服务，然后在应用服务中与业务相关的领域服务组合。<br>简单的事件发布逻辑直接在领域服务中直接完成发布也是可以的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1606897303,"ip_address":"","comment_id":264463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10196406044","product_id":100037301,"comment_content":"怎么跟前面写的不一样，实体不应该是充血模型么？在实体中完成存储操作。还有事件不应该在应用层么？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510572,"discussion_content":"有一部分实体采用了充血模型的，但是有些实体本身业务逻辑简单，没有太多复杂的逻辑，所有就不会有复杂的方法，所以看着以为是贫血模型。\n事件发布可以放在应用层也可以在领域层实现，比较复杂的领域事件发布逻辑建议构建事件领域服务，然后在应用服务中与业务相关的领域服务组合。\n简单的事件发布逻辑直接在领域服务中直接完成发布也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606897303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233242,"user_name":"睡吧，娃","can_delete":false,"product_type":"c1","uid":1201401,"ip_address":"","ucode":"8F8238E25A163A","user_header":"https://static001.geekbang.org/account/avatar/00/12/54/f9/12591c6f.jpg","comment_is_top":false,"comment_ctime":1594267018,"is_pvip":false,"replies":[{"id":"86053","content":"1、一般数据的持久化或者初始化都会在聚合的工厂和仓储组合来完成，它可以通过领域服务或者和聚合根的方法来实现，一般建议在领域服务中完成。<br>2、是这样的，所以在设计的时候要权衡，尽量降低转换带来的开销。如果复杂查询可以不经过领域层，直接在应用服务中完成复杂查询。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1594276214,"ip_address":"","comment_id":233242,"utype":1}],"discussion_count":3,"race_medal":1,"score":"10184201610","product_id":100037301,"comment_content":"老师好，我有几个问题麻烦帮忙解答一下<br>1、实体里实现具体业务，假如需要数据持久化或从基础层获取数据，我是否可以在实体里面调用仓储。或者说这类情况写到领域服务里面去减轻实体或者聚合根的业务的负担。<br>2、假如获取商品列表领域服务 从仓储会获取po的集合列表， 是否需要将集合里每个po转换成聚合跟对应的Do，然后DO的集合再转换成DTO 如果是的话，这样子会造成一定的开销，但是如果不这样 分层就会被破坏<br>谢谢","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500955,"discussion_content":"1、一般数据的持久化或者初始化都会在聚合的工厂和仓储组合来完成，它可以通过领域服务或者和聚合根的方法来实现，一般建议在领域服务中完成。\n2、是这样的，所以在设计的时候要权衡，尽量降低转换带来的开销。如果复杂查询可以不经过领域层，直接在应用服务中完成复杂查询。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594276214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2411361,"avatar":"","nickname":"齐斌","note":"","ucode":"1BFCD51E2F27BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343662,"discussion_content":"复杂查询可以不经过领域层，直接在应用服务中完成复杂查询是什么意思啊？数据库访问不是都写在领域层么?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611127613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1158550,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ad/96/249d1643.jpg","nickname":"moonfeeling","note":"","ucode":"85A2EAFF2ABA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2411361,"avatar":"","nickname":"齐斌","note":"","ucode":"1BFCD51E2F27BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542940,"discussion_content":"所有层都可以依赖基础层的接口，所以应用层可以直接实现数据查询和持久化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640911060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343662,"ip_address":""},"score":542940,"extra":""}]}]},{"had_liked":false,"id":232992,"user_name":"","can_delete":false,"product_type":"c1","uid":1924055,"ip_address":"","ucode":"","user_header":"","comment_is_top":false,"comment_ctime":1594184758,"is_pvip":false,"replies":[{"id":"85983","content":"聚合的持久化都是通过聚合根方法或领域服务来实现，在持久化时，它们会调用仓储接口，然后后仓储实现中的逻辑来完成持久化。<br>充血模型与贫血模型的关键差异：<br>在充血模型中，业务逻辑都在领域实体对象中实现，实体本身不仅包含了属性，还包含了它的业务行为。DDD领域模型中实体是一个具有业务行为和逻辑的对象。<br>而在贫血模型中领域对象大多只有setter和getter方法，业务逻辑统一放在业务逻辑层实现，而不是在领域对象中实现。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1594189749,"ip_address":"","comment_id":232992,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10184119350","product_id":100037301,"comment_content":"充血模型，是不是在实体里做数据的持久化。比如Leave导入了leaveRepositoryInterface，是不是为了持久数据？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500840,"discussion_content":"聚合的持久化都是通过聚合根方法或领域服务来实现，在持久化时，它们会调用仓储接口，然后后仓储实现中的逻辑来完成持久化。\n充血模型与贫血模型的关键差异：\n在充血模型中，业务逻辑都在领域实体对象中实现，实体本身不仅包含了属性，还包含了它的业务行为。DDD领域模型中实体是一个具有业务行为和逻辑的对象。\n而在贫血模型中领域对象大多只有setter和getter方法，业务逻辑统一放在业务逻辑层实现，而不是在领域对象中实现。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594189749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1158550,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ad/96/249d1643.jpg","nickname":"moonfeeling","note":"","ucode":"85A2EAFF2ABA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542043,"discussion_content":"Leave导入了leaveRepositoryInterface？实体怎么导入仓储接口呢？一般都是领域服务注入仓储接口吧？有清楚的大神解释下实体怎么注入仓储接口吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640651712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214630,"user_name":"Geek_778d19","can_delete":false,"product_type":"c1","uid":1441946,"ip_address":"","ucode":"E06B32A65F7C2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLOcteX7Gjxf2EK7lwjIToKYFu9LMC1ibY2XPK5022k03BHooFo8oHrIkAB68Q0O7enqjhO1FmVlbw/132","comment_is_top":false,"comment_ctime":1588775417,"is_pvip":false,"replies":[{"id":"79520","content":"理论上，聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，只作为实体实现与聚合根自身行为相关的业务逻辑。而将跨多个实体的复杂领域逻辑放在领域服务中实现。简单聚合的跨实体领域逻辑，可以考虑在聚合根方法中实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588822923,"ip_address":"","comment_id":214630,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10178710009","product_id":100037301,"comment_content":"聚合根与领域服务在职责上有些重叠了，在实现的时候如何选择？","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494146,"discussion_content":"理论上，聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，只作为实体实现与聚合根自身行为相关的业务逻辑。而将跨多个实体的复杂领域逻辑放在领域服务中实现。简单聚合的跨实体领域逻辑，可以考虑在聚合根方法中实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588822923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212520,"user_name":"Geek_821c96","can_delete":false,"product_type":"c1","uid":1092407,"ip_address":"","ucode":"B07B528F2E12C6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ab/37/455d6a8d.jpg","comment_is_top":false,"comment_ctime":1588140755,"is_pvip":false,"replies":[{"id":"79542","content":"1、如果需要依赖倒置，实现各层的解耦，是可以面向接口编程的，但是同一微服务内没必要搞得这么复杂。所有只有在需要适配前端应用或后端基础资源的时候才用到面向接口的编程，比如用户接口层的Facade和基础层的仓储。<br>2、3，DDD的核心思想就是划分边界和解耦，这个边界有利于未来微服务架构的演进。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588837227,"ip_address":"","comment_id":212520,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10178075347","product_id":100037301,"comment_content":"老师您好，我最近看了您的课程收益良多，您的每一讲我都看完了。看完之后了我也有一些疑惑，希望能得到您的指点：1.我看到仅仓储层出现了接口定义，在其它层是不是最好不要使用接口定义了？<br>2.战术上感觉跟之前的事务基本的架构分层模式的区别主要是：最外层分包结构叫法不太一样但跟之前的controller,service,dao没有太大区别、实体类中多了一些业务逻辑方法、多了事件处理；<br>3.感觉DDD最主要还是对边界的严格控制上，具体怎么分包并无太大区别。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493533,"discussion_content":"1、如果需要依赖倒置，实现各层的解耦，是可以面向接口编程的，但是同一微服务内没必要搞得这么复杂。所有只有在需要适配前端应用或后端基础资源的时候才用到面向接口的编程，比如用户接口层的Facade和基础层的仓储。\n2、3，DDD的核心思想就是划分边界和解耦，这个边界有利于未来微服务架构的演进。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588837227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195220,"user_name":"成章","can_delete":false,"product_type":"c1","uid":1929644,"ip_address":"","ucode":"82D6E87A79A7B0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/71/ac/c87546f5.jpg","comment_is_top":false,"comment_ctime":1585147542,"is_pvip":false,"replies":[{"id":"74328","content":"理论上仓储都应该放到基础层的。我将它们放到领域层的聚合目录下主要是基于以下考虑，一个聚合会有一个仓储，以后微服务的演进基本上会以聚合为单位进行重组或者拆分，所以在代码拆分的时候以聚合目录进行整体迁移就可以了，这样在代码上不会花太多的时间。<br>如果基础设计没有接口，可以考虑自己加一层，做接口的主要目的是，隔离应用逻辑和基础资源逻辑，接口不变，应用逻辑就不会受影响。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585222624,"ip_address":"","comment_id":195220,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175082134","product_id":100037301,"comment_content":"老师你好，我有一点不懂，我看仓储的代码在domain文件里，按之前依赖倒置后的结构，是不是应该放在infer文件里才对。<br>我之前就有个疑问，按照依赖倒置原则来做，确实可以把仓储接口放领域，然后依赖接口使得基础设施反过来依赖领域。但是很多基础设施的东西是没有接口，或者接口不在领域层，怎么实现依赖倒置呢。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489002,"discussion_content":"理论上仓储都应该放到基础层的。我将它们放到领域层的聚合目录下主要是基于以下考虑，一个聚合会有一个仓储，以后微服务的演进基本上会以聚合为单位进行重组或者拆分，所以在代码拆分的时候以聚合目录进行整体迁移就可以了，这样在代码上不会花太多的时间。\n如果基础设计没有接口，可以考虑自己加一层，做接口的主要目的是，隔离应用逻辑和基础资源逻辑，接口不变，应用逻辑就不会受影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585222624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167912,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1577961867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167896459","product_id":100037301,"comment_content":"这篇文章刚下班，还没来得及看，等会下班到家再一饱眼福。","like_count":2},{"had_liked":false,"id":356259,"user_name":"王维","can_delete":false,"product_type":"c1","uid":1091684,"ip_address":"湖南","ucode":"836E6CDB1A56BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/a8/64/965e0d9b.jpg","comment_is_top":false,"comment_ctime":1662090339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5957057635","product_id":100037301,"comment_content":"欧老师你好，我看了您写的请假代码，发现一个问题，领域类Leave的LeaveType属性没有赋值，不论是在LeaveDomainService，还是在LeaveFactory,LeaceAssemble都没有发现有赋值的语句，应该是一个bug,同样还有ApprovalInfoPO的approvalInfold属性，也没有赋值，望回复，谢谢！","like_count":1},{"had_liked":false,"id":308335,"user_name":"warrior","can_delete":false,"product_type":"c1","uid":1341216,"ip_address":"","ucode":"A0C7BEF5B3DC89","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK7CENSOKQLib0HGXV6KoY8NVD8vk9YdicdTwpJjJTucBkVCHKibhMepOFLxOnuNPhSkxrzd264gw9Jw/132","comment_is_top":false,"comment_ctime":1629539984,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5924507280","product_id":100037301,"comment_content":"组装类（Assembler）在interfaces层, 为什么能跨过Application层, 访问domian object?","like_count":1,"discussions":[{"author":{"id":1612933,"avatar":"","nickname":"Thomas Yang","note":"","ucode":"29249144F708D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583063,"discussion_content":"感觉应该在application层合适一点，而且有时候不是直接能dto转do的，比如下单dto要经过很多逻辑最后才能出来do","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659891995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290964,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1619880621,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5914847917","product_id":100037301,"comment_content":"老师，不知道还能不能看见，有几个疑问：<br>1.rule 目前看到的更多是配置，作为聚合的意义是啥？为了后续演进吗？<br>2.ApprovalRule.getByLeave的入参是Leave，是不是rule聚合和leave聚合实体耦合在一起了？<br>3.LeaveDomainService.updateLeaveInfo入参Leave是从LeaveApi.updateLeaveInfo一路带过来的，参数中有List&lt;ApprovalInfoDTO&gt; historyApprovalInfoDTOList，<br>历史审批数据存储层是不是已经有了？还需要前端全量带到后端，再转化成Leave实体，进而转换成LeavePO做持久化吗？是不是不用传？","like_count":1},{"had_liked":false,"id":277089,"user_name":"乌龟","can_delete":false,"product_type":"c1","uid":1128641,"ip_address":"","ucode":"E75B6CA6DD36CD","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/c1/7a947bcc.jpg","comment_is_top":false,"comment_ctime":1612257236,"is_pvip":false,"replies":[{"id":"101037","content":"借书实际上是一个动作，在设计的时候它应该就是一个服务。如果在设计时，有图书聚合、用户聚合和图书证聚合。如果将这个三个聚合放在同一个微服务的话，那么借书就可以是这个微服务应用层的一个借书的应用服务。如果将图书聚合、用户聚合和图书证聚合分别设计为三个不同的微服务，你可以单独设计一个BFF微服务，在BFF微服务中设计一个借书的应用服务，然后这个借书的服务会组合调用三个微服务的服务；如果不设计BFF微服务，你也可以在三个微服务中的某一个微服务，比如图书微服务的借书应用服务中来组合这三个微服务的服务，完成跨三个微服务的服务组合和编排。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612852468,"ip_address":"","comment_id":277089,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5907224532","product_id":100037301,"comment_content":"老师，有个问题请教下，比如图书馆管理系统，有图书域（Book）、用户域（User）和图书证域（LibraryCard），借书这个动作是放在哪里合适呢，因为借书 这三个域都有用到，<br>1.读取用户，判断状态<br>2.从用户中获取图书证，判断是否超过可借书本上限<br>3.更新书本的借阅者<br><br>请老师帮忙指教，谢谢","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514927,"discussion_content":"借书实际上是一个动作，在设计的时候它应该就是一个服务。如果在设计时，有图书聚合、用户聚合和图书证聚合。如果将这个三个聚合放在同一个微服务的话，那么借书就可以是这个微服务应用层的一个借书的应用服务。如果将图书聚合、用户聚合和图书证聚合分别设计为三个不同的微服务，你可以单独设计一个BFF微服务，在BFF微服务中设计一个借书的应用服务，然后这个借书的服务会组合调用三个微服务的服务；如果不设计BFF微服务，你也可以在三个微服务中的某一个微服务，比如图书微服务的借书应用服务中来组合这三个微服务的服务，完成跨三个微服务的服务组合和编排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612852468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271851,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1609841267,"is_pvip":true,"replies":[{"id":"98683","content":"应用层会有一些前端校验以及接收领域事件等工作，有些工作还是不太适合放在领域层去做的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1609983818,"ip_address":"","comment_id":271851,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5904808563","product_id":100037301,"comment_content":"老师，如果只有一个聚合，应用层还有意义吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513067,"discussion_content":"应用层会有一些前端校验以及接收领域事件等工作，有些工作还是不太适合放在领域层去做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609983818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247158,"user_name":"沈","can_delete":false,"product_type":"c1","uid":2168079,"ip_address":"","ucode":"53B56F4384D90E","user_header":"https://static001.geekbang.org/account/avatar/00/21/15/0f/4e1a9d92.jpg","comment_is_top":false,"comment_ctime":1599620075,"is_pvip":false,"replies":[{"id":"90937","content":"mybatis用在DDD的时候确实有些不太适应的地方。你试试将所有放在领域层的mybatis的逻辑移到基础资源层，然后在业务逻辑处理时，在调用仓储接口时将领域层DO转换成PO对象，然后作为参数传输到基础层的仓储实现中。在基础层基于PO对象完成mybatis的mapper相关处理逻辑。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1599791846,"ip_address":"","comment_id":247158,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5894587371","product_id":100037301,"comment_content":"老师，您好，我们按照DDD模式，实际使用中，是将一个微服务模块拆分为四个字module，这是仓储放在基础层，这就遇到基础层不能依赖领域层的问题了，理论上mybatis-plus的mapper接口不能引入领域的domain，这个时候改如何去解决呢？谢谢解答","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505330,"discussion_content":"mybatis用在DDD的时候确实有些不太适应的地方。你试试将所有放在领域层的mybatis的逻辑移到基础资源层，然后在业务逻辑处理时，在调用仓储接口时将领域层DO转换成PO对象，然后作为参数传输到基础层的仓储实现中。在基础层基于PO对象完成mybatis的mapper相关处理逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599791846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077124,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6f/84/8aab0142.jpg","nickname":"tom","note":"","ucode":"95930B56E52975","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552241,"discussion_content":"PO和DO就重复了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645367372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232216,"user_name":"Reason","can_delete":false,"product_type":"c1","uid":1512618,"ip_address":"","ucode":"719EA4D5E5BC5A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epuvKVmiaiaYDRFVRX3rGwSS4T1jibEKibqZYQjxob03ibdmguKzRsftAssCTDVWrdXL7ojNagaIdjIvzA/132","comment_is_top":false,"comment_ctime":1593923294,"is_pvip":false,"replies":[{"id":"85704","content":"也可以，这样DO到PO转换的工厂类就要放到repository目录里面了。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593932738,"ip_address":"","comment_id":232216,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5888890590","product_id":100037301,"comment_content":"repository返回和接受的对象用domain obj是不是要比用po更好一些？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500567,"discussion_content":"也可以，这样DO到PO转换的工厂类就要放到repository目录里面了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593932738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1033074,"avatar":"","nickname":"两条鱼","note":"","ucode":"9694CD308AA0D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":564714,"discussion_content":"但是infra层是不能引用到DO对象的，repository目录里也就无法编写DO到PO转换的工厂类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650300612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":500567,"ip_address":""},"score":564714,"extra":""}]}]},{"had_liked":false,"id":223616,"user_name":"王佳山","can_delete":false,"product_type":"c1","uid":1786944,"ip_address":"","ucode":"771D318F150F8C","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoxUFAanq6rz2MqHXtn7vAvyIe0ljoqCtX3gnqZujLk7x90llHedHqCpHCnbYJeZmPX06Y6OFlibpQ/132","comment_is_top":false,"comment_ctime":1591144933,"is_pvip":false,"replies":[{"id":"82479","content":"不清楚你说的管理页面是什么哈。只要能够构建出领域模型都是可以用DDD的哦。<br>但是一般来说，复杂的查询不建议放在领域层去解决。你可以采用CQRS，也就是常说的读写分离的模式，或者直接在应用层完成复杂查询。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591254653,"ip_address":"","comment_id":223616,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5886112229","product_id":100037301,"comment_content":"老师！有两个问题，哈哈<br>1 ddd一般应用在复杂业务中，但是复杂业务也会有管理页面，类似这样的需要还能用ddd吗，如果不用，是不是就只共用dao那一层，还是共用仓储层？<br>2 在 dto，do，po转换的时候遇到需要查询数据库的时候怎么办，要引用仓储层吗，感觉不好。还是尽量放在领域层解决？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497190,"discussion_content":"不清楚你说的管理页面是什么哈。只要能够构建出领域模型都是可以用DDD的哦。\n但是一般来说，复杂的查询不建议放在领域层去解决。你可以采用CQRS，也就是常说的读写分离的模式，或者直接在应用层完成复杂查询。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591254653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1158550,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ad/96/249d1643.jpg","nickname":"moonfeeling","note":"","ucode":"85A2EAFF2ABA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542944,"discussion_content":"依赖倒置，引用的是仓储层的接口，仓储层之上所有层都可以引用基础层的接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640911787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278924,"discussion_content":"可以读写分离，也可以放在应用层，复杂查询不建议放领域层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591258147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1786944,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoxUFAanq6rz2MqHXtn7vAvyIe0ljoqCtX3gnqZujLk7x90llHedHqCpHCnbYJeZmPX06Y6OFlibpQ/132","nickname":"王佳山","note":"","ucode":"771D318F150F8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278912,"discussion_content":"管理页面就是有些系统需要运营人员去操作的功能。主要就是分页显示，搜索什么的。\n还有个问题就是缓存，放在哪层好点？感觉都可以放。\nmq，锁也是，不知道哪层会好点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591255432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216751,"user_name":"Geek_tony","can_delete":false,"product_type":"c1","uid":2002183,"ip_address":"","ucode":"2995FBA965A9CF","user_header":"https://static001.geekbang.org/account/avatar/00/1e/8d/07/e7346b20.jpg","comment_is_top":false,"comment_ctime":1589336530,"is_pvip":false,"replies":[{"id":"80273","content":"1、DDD更强调面向对象的设计方式，实体对象采用充血模型，需要实现自己的业务行为，所以在从C语言转移到Java的时候，要注意这一点。你可以选择从0开始搭建，但是需要注意避免遗漏原来的功能。<br>2、可以这样做，设计的时候要注意公共对象的设计，保证高内聚低耦合。有些对象同时出现在多个聚合，在某个聚合是聚合根，在其它聚合可以设计成值对象。<br>3、敏捷和传统模式都可以，根据你的团队文化、规模和公司对应的要求来选择适合的模式吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589423634,"ip_address":"","comment_id":216751,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884303826","product_id":100037301,"comment_content":"老师你好，目前我主要接手一个单体系统向微服务改造。该系统是银行现金管理系统，用c语言实现的，我想应用ddd思想指导，但目前遇到的瓶颈问题如下：<br>1.开发语言的转换，改造后的系统是java语言，那我需要熟悉原系统的c语言实现吗？还是直接从0到1搭建，和领域专家（项目经理）战略建模，划分子领域限界上下文，领域模型等等。<br>2.由于该系统之前的设计已经根据功能模块划分成了账户管理，信息服务，流动性管理，收付款管理等模块，相对来说职责分工明确，模块内高内聚，模块间低耦合。那我是不是可以认为这些模块分别对应一个微服务，只需要在每个模块内提取实体，值对象，聚合就可以了？<br>3.对于这种单体向微服务改造的系统，用传统的瀑布模型生命周期管理可以吗，需要注意什么","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494934,"discussion_content":"1、DDD更强调面向对象的设计方式，实体对象采用充血模型，需要实现自己的业务行为，所以在从C语言转移到Java的时候，要注意这一点。你可以选择从0开始搭建，但是需要注意避免遗漏原来的功能。\n2、可以这样做，设计的时候要注意公共对象的设计，保证高内聚低耦合。有些对象同时出现在多个聚合，在某个聚合是聚合根，在其它聚合可以设计成值对象。\n3、敏捷和传统模式都可以，根据你的团队文化、规模和公司对应的要求来选择适合的模式吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589423634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208936,"user_name":"hzeu","can_delete":false,"product_type":"c1","uid":1072300,"ip_address":"","ucode":"03F45B573F8037","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/ac/e84e3864.jpg","comment_is_top":false,"comment_ctime":1587467358,"is_pvip":false,"replies":[{"id":"78114","content":"复杂的，多表关联的不建议放到领域模型里面。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587506728,"ip_address":"","comment_id":208936,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882434654","product_id":100037301,"comment_content":"老师 您好 我在查询这块有个疑问：比如分页查询这种逻辑适合在领域模型里设计吗？还是考虑使用CQRS来做？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492678,"discussion_content":"复杂的，多表关联的不建议放到领域模型里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587506728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208478,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1587367570,"is_pvip":false,"replies":[{"id":"78026","content":"先加载完整的聚合是指的为聚合所有实体的属性赋值吗？<br>感觉你这里属性不能为空是一种业务规则吧，如果规则不能统一的话，建议分别用两个服务区实现。或者在用户接口层DTO转DO的时候，将缺失的属性按照默认值来补齐后，再提交到应用服务和领域服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587438552,"ip_address":"","comment_id":208478,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882334866","product_id":100037301,"comment_content":"老师，前端有可能只展示部分数据，更新的时候也只更新部分数据；这时候dto转bo可能会将某些属性变为空值而违反bo的业务逻辑；这种情况是前后端一开始就约定好；还是在domainservice中接受前端dto,service中先加载完整的聚合，再调用更新方法？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492475,"discussion_content":"先加载完整的聚合是指的为聚合所有实体的属性赋值吗？\n感觉你这里属性不能为空是一种业务规则吧，如果规则不能统一的话，建议分别用两个服务区实现。或者在用户接口层DTO转DO的时候，将缺失的属性按照默认值来补齐后，再提交到应用服务和领域服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587438552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208289,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1587315869,"is_pvip":false,"replies":[{"id":"78034","content":"微服务内部的聚合之间的通讯不建议走消息中间件，这是微服务内部的逻辑，如果发布到微服务外的消息中间件，那微服务自己就需要订阅自己的消息了，这样实现起来会比较复杂。<br>如果同时存在微服务内和微服务外订阅者，建议则先通过事件总线分发到内部订阅者，然后将事件数据保存到事件库（表），再异步发送到消息中间件。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587438814,"ip_address":"","comment_id":208289,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882283165","product_id":100037301,"comment_content":"老师，有疑问的地方还是在领域事件这块儿；微服务内部各聚合之间使用eventbus没问题；如果不仅仅通知微服务内部的其它聚合，还要跨微服务通知)，这种情形是否就统一发布到消息代理上(rabbitmq等)更合适；即使内部的聚合也不用eventbus。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492404,"discussion_content":"微服务内部的聚合之间的通讯不建议走消息中间件，这是微服务内部的逻辑，如果发布到微服务外的消息中间件，那微服务自己就需要订阅自己的消息了，这样实现起来会比较复杂。\n如果同时存在微服务内和微服务外订阅者，建议则先通过事件总线分发到内部订阅者，然后将事件数据保存到事件库（表），再异步发送到消息中间件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587438814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202004,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1585886619,"is_pvip":false,"replies":[{"id":"75498","content":"谢谢！你可以用工厂模式，复杂聚合的数据初始化和数据转换都可以用工厂模式，统一交给工厂处理。在加餐里面有例子。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585890886,"ip_address":"","comment_id":202004,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5880853915","product_id":100037301,"comment_content":"老师每个评论都回答了，真的太用心了。另外结合我最近学习的设计思想及设计模式来问一个问题：DDD实体不应该暴露不该set get方法，但是为了从PO转换DO方便，不得不这样处理？<br>   最近学习到了建造者模式，通过Builder的方式来将PO的属性转换为DO，这样DO就不用暴露不必要的set get方法，但是操作起来，面对复杂嵌套的DO对象，多少还是很麻烦。<br> <br>想听听老师的建议","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490478,"discussion_content":"谢谢！你可以用工厂模式，复杂聚合的数据初始化和数据转换都可以用工厂模式，统一交给工厂处理。在加餐里面有例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585890886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220565,"discussion_content":"但是这样会让领域对象暴露不必要的setter getter方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585897688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190963,"user_name":"李金尧","can_delete":false,"product_type":"c1","uid":1816483,"ip_address":"","ucode":"C6C29C16284B79","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/orTaVwTib3ribOibhLGJDAUiaMeH3UYFF9yDysdaTXdMIxrtWacibjsIAhOovIqmz1fEBMCiaWWZzS4aB4XXqUmL1VYw/132","comment_is_top":false,"comment_ctime":1584713594,"is_pvip":true,"replies":[{"id":"73355","content":"谢谢","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584747642,"ip_address":"","comment_id":190963,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879680890","product_id":100037301,"comment_content":"认真拜读了一遍，感觉受益良多，感谢老师的分享<br>","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488089,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584747642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185143,"user_name":"克制的民工","can_delete":false,"product_type":"c1","uid":1886437,"ip_address":"","ucode":"48E0231F469DA5","user_header":"https://static001.geekbang.org/account/avatar/00/1c/c8/e5/c0e8c78d.jpg","comment_is_top":false,"comment_ctime":1583494859,"is_pvip":false,"replies":[{"id":"71820","content":"Facade接口就是restful api，facade接口发布到API网关，供前端调用。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583721676,"ip_address":"","comment_id":185143,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5878462155","product_id":100037301,"comment_content":"这一讲精彩！要好好消化一下。<br>再请教一个问题：前后端如果采用restful接口，请问restful api和facade 接口是什么关系？在facade 接口的基础上再封装restful api吗？在DDM分层架构中，restful api属于那一层呢。谢谢","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486266,"discussion_content":"Facade接口就是restful api，facade接口发布到API网关，供前端调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583721676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185084,"user_name":"沉迷学习Zzz","can_delete":false,"product_type":"c1","uid":1812757,"ip_address":"","ucode":"4ED0EB6BD4A2B5","user_header":"","comment_is_top":false,"comment_ctime":1583480108,"is_pvip":false,"replies":[{"id":"71821","content":"我在目录结构那一章讲了。仓储实现理论上是基础层的内容。放领域层的主要目的是考虑到以后微服务的演进代码拆包和打包的便利性。因为一个聚合一个仓储，如果聚合需要进行重新拆分和组合，你就可以将聚合目录内所有代码作为一个包打包重新组合。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583722003,"ip_address":"","comment_id":185084,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5878447404","product_id":100037301,"comment_content":"老师，我看了下你的示例，不是说领域层和持久化数据库之间加了一个仓储层吗，为什么仓储的实现还是放在领域层呢，不应该放在基础设施层吗","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486244,"discussion_content":"我在目录结构那一章讲了。仓储实现理论上是基础层的内容。放领域层的主要目的是考虑到以后微服务的演进代码拆包和打包的便利性。因为一个聚合一个仓储，如果聚合需要进行重新拆分和组合，你就可以将聚合目录内所有代码作为一个包打包重新组合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583722003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181756,"user_name":"修冶","can_delete":false,"product_type":"c1","uid":1030560,"ip_address":"","ucode":"F00114F4E345E0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b9/a0/ed4c3eae.jpg","comment_is_top":false,"comment_ctime":1582628846,"is_pvip":false,"replies":[{"id":"70419","content":"数据库相关的操作不要放在领域层，放在仓储的实现里面比较合适。这样才能解耦领域逻辑和数据库逻辑。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582642275,"ip_address":"","comment_id":181756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877596142","product_id":100037301,"comment_content":"老师你好，Dao相关的操作能放到实体对象里吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485108,"discussion_content":"数据库相关的操作不要放在领域层，放在仓储的实现里面比较合适。这样才能解耦领域逻辑和数据库逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582642275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169480,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1578362741,"is_pvip":false,"replies":[{"id":"65764","content":"基于聚合根的查询不太适合进行复杂的查询。<br>对于复杂的查询你可以通过应用服务，在仓储实现中直接用SQL查询也是可以的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578387019,"ip_address":"","comment_id":169480,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5873330037","product_id":100037301,"comment_content":"有个问题我还是想问问欧老师，在工作中我遇到这样的一个场景，KA商品推广实体，很多场景都可以用领域服务实现，但是有个场景是查询KA商品推广列表，列表上还要有每个KA商品的推广效果数据（点击量，曝光量，交易额，商详页UV），这个推广效果数据放在领域服务中去查询总感觉不合适，老师有什么好的建议","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480574,"discussion_content":"基于聚合根的查询不太适合进行复杂的查询。\n对于复杂的查询你可以通过应用服务，在仓储实现中直接用SQL查询也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578387019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123036,"discussion_content":"多谢老师耐心回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578387345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169230,"user_name":"切糕","can_delete":false,"product_type":"c1","uid":1185409,"ip_address":"","ucode":"DCD3C14CAC4ED3","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/81/77f84354.jpg","comment_is_top":false,"comment_ctime":1578298056,"is_pvip":false,"replies":[{"id":"65614","content":"这个领域服务的事务控制主要是保证写业务表和事件表以及发布到消息队列，这三步能够保持数据一致。聚合之间或微服务之间可以在应用服务采用事务机制。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578305044,"ip_address":"","comment_id":169230,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5873265352","product_id":100037301,"comment_content":"老师，有个问题请教下：<br>应用层负责领域服务的组织和编排，我看示例代码的事务控制在领域服务层，多个领域服务如何确保事务的一致性。<br>示例：<br>public void createLeaveInfo(Leave leave){<br>        &#47;&#47;get approval leader max level by rule<br>        int leaderMaxLevel = approvalRuleDomainService.getLeaderMaxLevel(leave.getApplicant().getPersonType(), leave.getType().toString(), leave.getDuration());<br>        &#47;&#47;find next approver<br>        Person approver = personDomainService.findFirstApprover(leave.getApplicant().getPersonId(), leaderMaxLevel);<br>        leaveDomainService.createLeave(leave, leaderMaxLevel, Approver.fromPerson(approver));<br>    }","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480470,"discussion_content":"这个领域服务的事务控制主要是保证写业务表和事件表以及发布到消息队列，这三步能够保持数据一致。聚合之间或微服务之间可以在应用服务采用事务机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578305044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268355,"discussion_content":"这是在同一个微服务和同一个数据库的操作，应该对性能影响不大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589764824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1221835,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a4/cb/407d9a81.jpg","nickname":".benxiaohai52","note":"","ucode":"8F748310484724","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245480,"discussion_content":"是不是分布式事务啊？这样会引起性能问题啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587661537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168789,"user_name":"陈四丰","can_delete":false,"product_type":"c1","uid":1610789,"ip_address":"","ucode":"A4463BFD52FB4F","user_header":"https://static001.geekbang.org/account/avatar/00/18/94/25/3bf277e5.jpg","comment_is_top":false,"comment_ctime":1578174693,"is_pvip":true,"replies":[{"id":"65463","content":"如果按照领域建模的方式来设计微服务的话，我们可以很容易的对对象进行聚合以及实体归类，所以也很容易的实现数据之间的解耦，没有特殊考虑的话，建议一个微服务一个数据库。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578207010,"ip_address":"","comment_id":168789,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5873141989","product_id":100037301,"comment_content":"感谢欧老师的加餐，受益匪浅。<br><br>实际操作中，我产生了一个疑问。是不是每个微服务都要有自己单独的数据库？比如本节案例：“请假”和“考勤”是两个微服务，那么就应该有两个独立的数据库去对应。(database: leave和checking)？<br><br>多谢指教!!!","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480338,"discussion_content":"如果按照领域建模的方式来设计微服务的话，我们可以很容易的对对象进行聚合以及实体归类，所以也很容易的实现数据之间的解耦，没有特殊考虑的话，建议一个微服务一个数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578207010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610789,"avatar":"https://static001.geekbang.org/account/avatar/00/18/94/25/3bf277e5.jpg","nickname":"陈四丰","note":"","ucode":"A4463BFD52FB4F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119202,"discussion_content":"多谢回复！\n\n如果checking需要调用很多leave数据呢？有没有什么好的隔离方式？\n\n另外有个关于“内容统一查询的中台服务(通用域)”的疑问：\n1，要调用几乎所有微服务的搜索API吗？\n2，或者把所有数据都同步到一个搜索数据库(ElasticSearch)，然后重新设计搜索API?\n\n多谢指点！！！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578221627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1610789,"avatar":"https://static001.geekbang.org/account/avatar/00/18/94/25/3bf277e5.jpg","nickname":"陈四丰","note":"","ucode":"A4463BFD52FB4F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":120210,"discussion_content":"微服务化后马上就会面临复杂查询的问题。这个需要提前规划好，小的项目可以将不同的微服务的数据加工后归集到ES里，提供统一查询；或者在产生领域事件的时候将数据冗余到下游微服务。企业级的复杂查询可以通过数据中台方式来解决。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578268144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":119202,"ip_address":""},"score":120210,"extra":""}]}]},{"had_liked":false,"id":167934,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1577966194,"is_pvip":false,"replies":[{"id":"65305","content":"DDD的主要目标是为了边界划分和解耦，而实现这个目标有很多的手段。目标只有一个，而手段会有很多个，只要能达到这个目标，可以选择适合自己的手段，咱们的主要区别可能在手段上有差异。<br>有机会向你学习哈。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578032434,"ip_address":"","comment_id":167934,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5872933490","product_id":100037301,"comment_content":"1.感谢栏主的demo。劳烦了。<br><br>2.毕竟是用于大概了解ddd的demo，各中实现比较简单，并没有很讲究设计原则。如果有下一个专栏再探讨。<br><br>3.认真看完栏主代码实现，跟自己的实现规范差别还是挺多的。各有利弊就不多赘述了。<br><br>4.期待下次相见。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480057,"discussion_content":"DDD的主要目标是为了边界划分和解耦，而实现这个目标有很多的手段。目标只有一个，而手段会有很多个，只要能达到这个目标，可以选择适合自己的手段，咱们的主要区别可能在手段上有差异。\n有机会向你学习哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578032434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115768,"discussion_content":"1.是的栏主，对于这套ddd的架构模型，整体方向跟栏主是一致的。我指的差异主要也是一些权衡的东西。比如应用层，在栏主这是做所有跨聚合的代码，而接入层只做外放接口的事。而我把跨聚合的业务放在了接入层，把可重用，带事务或者需要走异步的逻辑下沉到应用层实现。这样应用层的每个接口都是有“特殊职责的”。  而这样划分，主要是我认为跨聚合调用也当在接入层实现，而接入层调应用层可以，应用层调接入层不行，所以由接入层承接这份跨聚合调用的职责，而应用层就成为按需下沉代码时用的分层。\n\n2.关于接入层承接跨聚合调用：当一个微服务有多个聚合时，很顺手就会相互调用应用层的接口（内部方法嘛）。但这是不合理的，应该调用其他聚合在接入层外放的接口。如此一来语义比较明确，且后续重新划分聚合时成本比较低。 但这就会有应用层调接入层的场景，这矛盾了，所以我就把对外部聚合的调用也归入接入层。\n\n3.一路都是自己研究的ddd，摸着石头过河，在栏主这里才终于有面镜子两相取证，受益匪浅。但篇幅有限，且内容也不只是ddd，所以总归还是浅了。于是就期待栏主的下一篇专栏了。毕竟于个人，代码质量就是名片，能有所精进，甚是欢喜。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578034030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358459,"user_name":"默光","can_delete":false,"product_type":"c1","uid":1583724,"ip_address":"上海","ucode":"68034FCBDB5B61","user_header":"https://static001.geekbang.org/account/avatar/00/18/2a/6c/ac2d9782.jpg","comment_is_top":false,"comment_ctime":1664333103,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1664333103","product_id":100037301,"comment_content":"老师你好，我想问一下怎样基于DDD对已有的微服务进行改造，现有微服务存在以下几个点问题：<br>（1）微服务拆分不合理，太细，不易管理<br>（2）微服务之间存在不合理的调用，数据和业务逻辑纠缠太深<br>主要想咨询一下几个问题：<br>（1）基于DDD的对现有微服务改造，应该要注意什么？可以分为几个阶段进行吗？<br>（2）针对拆分不合理，直接合并阻碍很大，该怎么弄？<br>（3）针对不合理的微服务调用，往往改一个，就会牵扯到其他的功能，这个该怎样保证影响范围<br>（4）DDD在其中可以起到哪些作用？","like_count":0},{"had_liked":false,"id":358161,"user_name":"斯文败类","can_delete":false,"product_type":"c1","uid":2063718,"ip_address":"浙江","ucode":"38F2FDEB946137","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7d/66/0c46587d.jpg","comment_is_top":false,"comment_ctime":1663984573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663984573","product_id":100037301,"comment_content":"领域层中不应该调用仓储层吧，应该放在应用层去调用","like_count":0},{"had_liked":false,"id":356936,"user_name":"欧阳","can_delete":false,"product_type":"c1","uid":1523905,"ip_address":"广东","ucode":"9B764F70D93BAD","user_header":"https://static001.geekbang.org/account/avatar/00/17/40/c1/de2e1a23.jpg","comment_is_top":false,"comment_ctime":1662710806,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662710806","product_id":100037301,"comment_content":"老师好，咨询一下：domain层当中需要用到配置信息的话，该如何使用？在domain层的实体或者值对象当中直接使用配置类的话，会导致实体或者值对象当中依赖了配置类。","like_count":0},{"had_liked":false,"id":349520,"user_name":"Self-devourer","can_delete":false,"product_type":"c1","uid":1179187,"ip_address":"","ucode":"DB453751F3927E","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/33/4031f9c2.jpg","comment_is_top":false,"comment_ctime":1656038877,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656038877","product_id":100037301,"comment_content":"老师,可不可以再加上CQRS的实例代码?","like_count":0},{"had_liked":false,"id":341651,"user_name":"还是那个我","can_delete":false,"product_type":"c1","uid":2946064,"ip_address":"","ucode":"86F70FA2A66E52","user_header":"https://static001.geekbang.org/account/avatar/00/2c/f4/10/75cd13ea.jpg","comment_is_top":false,"comment_ctime":1649752424,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649752424","product_id":100037301,"comment_content":"有这个代码工程吗，有的话发出来了，对照工程理解的更透彻","like_count":0},{"had_liked":false,"id":340656,"user_name":"唧唧鸡","can_delete":false,"product_type":"c1","uid":2958638,"ip_address":"","ucode":"9F97BC2255A3B5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/5Cd5DiaVksY0szIkygsbKYxicycoEzLdKhPJRiaZPkQ6NrHw7AuVn3fmwb6YtlrIYae8PAvbicrdmLRq5aExYO67OA/132","comment_is_top":false,"comment_ctime":1648999284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648999284","product_id":100037301,"comment_content":"老师，能提供这节课的代码demo吗，直接下载下来看，更容易理解透彻呢","like_count":0},{"had_liked":false,"id":336777,"user_name":"老任物联网杂谈","can_delete":false,"product_type":"c1","uid":1029883,"ip_address":"","ucode":"97527F2005CE64","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b6/fb/ee6ff97e.jpg","comment_is_top":false,"comment_ctime":1646362422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646362422","product_id":100037301,"comment_content":"老师你好，代码中有处地方好像违反了领域层和基础设施层的依赖关系，在领域事件类LeaveEvent中直接引用了基础设施层的工具类IdGenerator。<br>1.这种情况是不是需要在Leave聚合创建一个IdGeneratorFacade接口来达到依赖倒置<br>2.像这种各个聚合或者应用服务都需要的基础设施，Facade应该放在哪合适","like_count":0},{"had_liked":false,"id":327905,"user_name":"Geek_c502b3","can_delete":false,"product_type":"c1","uid":2857590,"ip_address":"","ucode":"E5EAB371046B5D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog1N6gwmOc4J8kicsl0ofBDhR20haEvvVicc8sia7XTDEMnay1kV5zqp4qgWcIShFibHb9Q/132","comment_is_top":false,"comment_ctime":1640352896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640352896","product_id":100037301,"comment_content":"老师你好，希望您能回复我，我在项目中遇见一个问题：<br>1，这是一个单体服务项目，项目代码是java分层，业务上有个流程的概念类似oa，目前每个流程节点service中拆分的领域服务，相互解耦<br>2，在串流程时的场景，A流转到B，B流转到C, 但是B节点一定是依赖A的数据，我只能调用A的网关服务来查找数据，写入到B节点，B-&gt;C同理<br>3，这样单体项目既做服务，又做业务，service层上面没有更高一层进行编排结构，导致了各业务存在耦合<br><br>所以：就感觉自己用了DDD思想，但是又出现了各种传统服务耦合，有什么好办法解决一下吗？","like_count":0},{"had_liked":false,"id":322869,"user_name":"信仰","can_delete":false,"product_type":"c1","uid":2833225,"ip_address":"","ucode":"00FD50962AC5D2","user_header":"https://static001.geekbang.org/account/avatar/00/2b/3b/49/83712608.jpg","comment_is_top":false,"comment_ctime":1637638377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637638377","product_id":100037301,"comment_content":"请教一下，与设备打交道的，比如tcp,串口通讯，放在哪一层比较号","like_count":0},{"had_liked":false,"id":317918,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1104180,"ip_address":"","ucode":"C2F4E624810E3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/34/165e862f.jpg","comment_is_top":false,"comment_ctime":1635054137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635054137","product_id":100037301,"comment_content":"领域服务怎么没有注解@Services了<br>在应用层怎么使用领域服务","like_count":0},{"had_liked":false,"id":311212,"user_name":"H、ai","can_delete":false,"product_type":"c1","uid":2148422,"ip_address":"","ucode":"793C30D04FE2C1","user_header":"https://static001.geekbang.org/account/avatar/00/20/c8/46/a92b8787.jpg","comment_is_top":false,"comment_ctime":1631106779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631106779","product_id":100037301,"comment_content":"老师，您好，有完整的示例代码么 git仓库","like_count":0},{"had_liked":false,"id":311112,"user_name":"郑印","can_delete":false,"product_type":"c1","uid":1005282,"ip_address":"","ucode":"181B0FDE5E1532","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/e2/2dcab30d.jpg","comment_is_top":false,"comment_ctime":1631073258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631073258","product_id":100037301,"comment_content":"结合DDD所学，写了一个以电商消息系统的DDD案例，一起学习。https:&#47;&#47;gitee.com&#47;izhengyin&#47;ddd-message","like_count":0},{"had_liked":false,"id":311108,"user_name":"郑印","can_delete":false,"product_type":"c1","uid":1005282,"ip_address":"","ucode":"181B0FDE5E1532","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/e2/2dcab30d.jpg","comment_is_top":false,"comment_ctime":1631073111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631073111","product_id":100037301,"comment_content":"https:&#47;&#47;gitee.com&#47;izhengyin&#47;ddd-message","like_count":0},{"had_liked":false,"id":303466,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1096652,"ip_address":"","ucode":"E79CEA70430449","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","comment_is_top":false,"comment_ctime":1626802567,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626802567","product_id":100037301,"comment_content":"值对象的实现巧妙地避免了关联查询，但是怎么应对关联表的修改呢？比如一个Person的level之类的信息变动了，在ApprovalInfo表里面就反映不出来了，这不是个问题吗？","like_count":0},{"had_liked":false,"id":303198,"user_name":"西瓜Hans","can_delete":false,"product_type":"c1","uid":2690689,"ip_address":"","ucode":"0FD8B59A4188E2","user_header":"https://static001.geekbang.org/account/avatar/00/29/0e/81/ea804784.jpg","comment_is_top":false,"comment_ctime":1626661871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626661871","product_id":100037301,"comment_content":"    PO对象放在domainService里，这肯定是不行的啊！不然怎么依赖倒置。正确的应该是基础层返回领域对象DO吧","like_count":0},{"had_liked":false,"id":300366,"user_name":"小菜变大鸟","can_delete":false,"product_type":"c1","uid":1484729,"ip_address":"","ucode":"A41998D3CC44E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/a7/b9/a08e9ab9.jpg","comment_is_top":false,"comment_ctime":1625128859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625128859","product_id":100037301,"comment_content":"老师好，DDD之中有以下四种领域模型<br>1，失血模型<br>2，贫血模型<br>3，充血模型<br>4，胀血模型<br><br>我看看demo实际是第二种贫血模型，因为真正的充血模型对dao层的访问应该是在DO之中的；但是demo中都是通过领域服务来直接调用repository来实现，这种实际上属于贫血模型<br><br>其次，在目前基于spring容器的开发中，repository一般是单例，但是领域模型的DO一般不是。如果要做到真正的充血模型就会存在DO每次实例化都要初始化repository实例的问题，不太优雅。这种有更好的办法来实现吗？<br><br>最后，老师文中只说了贫血模型和充血模型，但是在我看来貌似是将贫血和充血混在一起了，这点不知道老师怎么看呢？","like_count":0},{"had_liked":false,"id":297865,"user_name":"Hplus","can_delete":false,"product_type":"c1","uid":1872697,"ip_address":"","ucode":"DC32CBC3E9C11D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/93/39/f642023f.jpg","comment_is_top":false,"comment_ctime":1623824678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623824678","product_id":100037301,"comment_content":"看到这里结合代码，很多东西一下子清楚了，谢谢老师！","like_count":0},{"had_liked":false,"id":296498,"user_name":"唐江","can_delete":false,"product_type":"c1","uid":1878120,"ip_address":"","ucode":"867C9808CF7760","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJpJXWFP3dNle88WnTkRTsEQkPJmOhepibiaTfhEtMRrbdg5EAWm4EzurA61oKxvCK2ZjMmy1QvmChw/132","comment_is_top":false,"comment_ctime":1623021872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623021872","product_id":100037301,"comment_content":"Approver 这个值对象里面 引用了Person实体，虽然是一个静态方法，但是他们不是一个聚合呢，是不不太好，是否可以把这个转换方法 提出到聚合外？","like_count":0},{"had_liked":false,"id":296195,"user_name":"秋天的透明雨🌧️","can_delete":false,"product_type":"c1","uid":1110437,"ip_address":"","ucode":"9363B49BFA6C14","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/a5/6cc9f728.jpg","comment_is_top":false,"comment_ctime":1622799854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622799854","product_id":100037301,"comment_content":"老师你好，学习了本课程之后，立即应用在项目实践中，但在实践过程中遇到一些问题，求解惑。<br>1. 一个微服务内有两个聚合，聚合1和聚合2<br>2. 聚合1的接口A，返回entity1；聚合2的接口B，返回entity2，其中entity1和entity2相互独立，没有关联关系<br>3. 客户端想要的返回结果是entity1和entity2的组合<br><br>问题：<br>1. 按照之前的理解，使用application层的服务分别调用聚合1和聚合2的领域服务，组合结果返回给interfaces层，这个”组合结果“既不属于聚合1也不属于聚合2，请问这个”组合结果“应该定义在哪里？<br>2. 这种场景是否可以跳过application层，interfaces层分别直接调用聚合1和聚合2的领域服务，将得到的结果转换成DTO，返回给客户端？此时就没有application层服务的调用了<br>3. 出现这种场景合理吗？还是域的粒度划分的太细了，应该将聚合1和聚合2合并成一个聚合？","like_count":0},{"had_liked":false,"id":295979,"user_name":"秋天的透明雨🌧️","can_delete":false,"product_type":"c1","uid":1110437,"ip_address":"","ucode":"9363B49BFA6C14","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/a5/6cc9f728.jpg","comment_is_top":false,"comment_ctime":1622689712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622689712","product_id":100037301,"comment_content":"老师好，是否可以将valueobject包提到entity包之外，和entity包处在平级目录","like_count":0},{"had_liked":false,"id":287280,"user_name":"壁虎漫步","can_delete":false,"product_type":"c1","uid":1116858,"ip_address":"","ucode":"304A3133FDC908","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/ba/73efd686.jpg","comment_is_top":false,"comment_ctime":1617867050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617867050","product_id":100037301,"comment_content":"请问如果项目里面的一些定时任务，放在哪个包合适？","like_count":0},{"had_liked":false,"id":277481,"user_name":"而立","can_delete":false,"product_type":"c1","uid":1047589,"ip_address":"","ucode":"E3274C04BB6E83","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/25/20ccf994.jpg","comment_is_top":false,"comment_ctime":1612428312,"is_pvip":false,"replies":[{"id":"101034","content":"谢谢！牛年快乐，牛转乾坤。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612851897,"ip_address":"","comment_id":277481,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612428312","product_id":100037301,"comment_content":"这个实例简直是良药，豁然开朗。老师真优秀！！！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515066,"discussion_content":"谢谢！牛年快乐，牛转乾坤。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612851897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272382,"user_name":"wangzhanhua","can_delete":false,"product_type":"c1","uid":1237481,"ip_address":"","ucode":"E8F4C487265C0E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/RiabvhfPfRTSIw1K7I3vqINgOdOia2PF6uqbRNu5pGByW5CDXiaVLa7Q0bouVDZzhDFb3wYlLjgT0t8GIgM9LziaLA/132","comment_is_top":false,"comment_ctime":1610073094,"is_pvip":false,"replies":[{"id":"99168","content":"你是说聚合之间或者微服务之间的服务或数据调用吗？不用消息队列的话，就只能采用事务机制了。但是这样可能会带来性能损耗，也会增加聚合和微服务的耦合。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1610693815,"ip_address":"","comment_id":272382,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610073094","product_id":100037301,"comment_content":"我不想和具体的数据和消息队列耦合,这该如何做呢？请老师指点","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513259,"discussion_content":"你是说聚合之间或者微服务之间的服务或数据调用吗？不用消息队列的话，就只能采用事务机制了。但是这样可能会带来性能损耗，也会增加聚合和微服务的耦合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610693815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271825,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1609826201,"is_pvip":true,"replies":[{"id":"98685","content":"这个API工程主要做什么呢？是做不同的前端接口和数据适配吗？是不是主要承担BFF的功能？其实BFF微服务的功能和你说的比较类似，比你说的API工程多了服务组合和编排的功能。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1609984771,"ip_address":"","comment_id":271825,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1609826201","product_id":100037301,"comment_content":"老师，如果我还弄一个api工程，这个工程里是不是只要放dto和facade的api 两个类就可以了？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513056,"discussion_content":"这个API工程主要做什么呢？是做不同的前端接口和数据适配吗？是不是主要承担BFF的功能？其实BFF微服务的功能和你说的比较类似，比你说的API工程多了服务组合和编排的功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609984771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350796,"discussion_content":"老师，请教下，BFF和网关合在在一起是否合理，对于一般应用，分开的话，网关里面就没啥内容，大多数场景都是透传接口参数而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614007477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266570,"user_name":"herry","can_delete":false,"product_type":"c1","uid":1314057,"ip_address":"","ucode":"81F4A983F41FFC","user_header":"https://static001.geekbang.org/account/avatar/00/14/0d/09/54dac89c.jpg","comment_is_top":false,"comment_ctime":1607396755,"is_pvip":false,"replies":[{"id":"97308","content":"在代码结构那一章应该有说明。主要是基于以下考虑：<br>按照DDD分层架构，仓储本应该属于基础层。但为了在微服务架构演进时，保证聚合代码重组的便利，我将仓储相关代码也放到了领域层的聚合目录中。<br>这是因为聚合和仓储总是一对一的关系，将领域模型和仓储的代码组合在一起后，就是一个包含了领域层领域逻辑和基础层数据处理逻辑的聚合代码单元。一旦领域模型发生了变化，当聚合需要在不同的限界上下文或微服务之间进行代码重组时，我们就可以以聚合代码包为单元，进行整体拆分或者迁移，轻松实现微服务架构演进。<br>虽然领域相关的业务逻辑代码和基础资源处理相关的代码都在一个聚合代码目录下，但是聚合的核心业务逻辑仍然是通过调用仓储接口来访问基础资源的仓储实现处理逻辑，所以这样不会影响业务逻辑与基础资源逻辑的依赖倒置设计。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608020978,"ip_address":"","comment_id":266570,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1607396755","product_id":100037301,"comment_content":"请教个问题， 看到代码里LeaveDao放在了domain层，这个类负责持久化，是否放在infrastructure更为合适?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511317,"discussion_content":"在代码结构那一章应该有说明。主要是基于以下考虑：\n按照DDD分层架构，仓储本应该属于基础层。但为了在微服务架构演进时，保证聚合代码重组的便利，我将仓储相关代码也放到了领域层的聚合目录中。\n这是因为聚合和仓储总是一对一的关系，将领域模型和仓储的代码组合在一起后，就是一个包含了领域层领域逻辑和基础层数据处理逻辑的聚合代码单元。一旦领域模型发生了变化，当聚合需要在不同的限界上下文或微服务之间进行代码重组时，我们就可以以聚合代码包为单元，进行整体拆分或者迁移，轻松实现微服务架构演进。\n虽然领域相关的业务逻辑代码和基础资源处理相关的代码都在一个聚合代码目录下，但是聚合的核心业务逻辑仍然是通过调用仓储接口来访问基础资源的仓储实现处理逻辑，所以这样不会影响业务逻辑与基础资源逻辑的依赖倒置设计。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608020978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1183730,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0f/f2/e935c719.jpg","nickname":"ajianzheng","note":"","ucode":"91AE5DB544A820","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352420,"discussion_content":"聚合和仓储并不是一对一的关系吧？正是因为不是一对一的关系，所以才抽象repository(acl)层来隔离具体实现。根据依赖倒置原则，domain层只需要包含repository就够了，具体实现应该放到infrastructure，通过注入的方式实现解耦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614733304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266546,"user_name":"云峰","can_delete":false,"product_type":"c1","uid":1149240,"ip_address":"","ucode":"97673EEEBC314E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLrEa19I3aQkQ0e5jRhavmgBV7abRKuw1nbMFr8uk30j7ogsH1yZXKZ9AT3yNX6XliaP4AicpXtuodA/132","comment_is_top":false,"comment_ctime":1607391105,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1607391105","product_id":100037301,"comment_content":"老师我有问题：1 聚合根、实体这些都是充血模型，所以不会是spring bean吧？2 老师有说到聚合根可以调用repository层，这一层在使用mybatis时是spring bean，是要强行注入bean来使用吗？  正确的编排应该是怎样的","like_count":0,"discussions":[{"author":{"id":1484729,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a7/b9/a08e9ab9.jpg","nickname":"小菜变大鸟","note":"","ucode":"A41998D3CC44E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395391,"discussion_content":"demo实际是贫血模型，不是真正的充血模型，并没有解决你说的第一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632298307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1896757,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhpCNoXf1fPTyvg2ArPbiafiba5L65OicIxIpSsF6zyjYicYgnbmgXJOQJl3375GIgDqOCqdqY8naqWg/132","nickname":"Geek_cd784b","note":"","ucode":"F45E6E7111D48A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351113,"discussion_content":"我看代码中聚合根并没有调用repository，repository 服务是在领域服务中调用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614156683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266068,"user_name":"Sans","can_delete":false,"product_type":"c1","uid":1629525,"ip_address":"","ucode":"946ACE3B30C883","user_header":"https://static001.geekbang.org/account/avatar/00/18/dd/55/be29ee8d.jpg","comment_is_top":false,"comment_ctime":1607157537,"is_pvip":false,"replies":[{"id":"97304","content":"1、落库的话统一调用仓储接口来实现。一般会放在聚合根的方法或者领域服务中，以确保所有数据修改都会按照聚合统一的逻辑来确保数据一致性。<br>2、一个实体的聚合，其实这个实体就是聚合根。聚合根就是一个根实体。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608020212,"ip_address":"","comment_id":266068,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1607157537","product_id":100037301,"comment_content":"欧老师您好，看完您的课程之后有几个疑惑点，希望您解答<br>1. 充血模型本身包含业务行为，是否落库这种行为也应该存在于实体当中。那么由于实体并不是由spring管理的单例对象，该如何实现依赖注入<br>2. 对于比较简单的业务行为，只涉及某一个实体，是否可以省略掉聚合根？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511140,"discussion_content":"1、落库的话统一调用仓储接口来实现。一般会放在聚合根的方法或者领域服务中，以确保所有数据修改都会按照聚合统一的逻辑来确保数据一致性。\n2、一个实体的聚合，其实这个实体就是聚合根。聚合根就是一个根实体。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608020212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484729,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a7/b9/a08e9ab9.jpg","nickname":"小菜变大鸟","note":"","ucode":"A41998D3CC44E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395389,"discussion_content":"我在评论中也留下了第一点的疑惑，欧老师的回答感觉并没有解决这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632298142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264287,"user_name":"楼锋","can_delete":false,"product_type":"c1","uid":1442226,"ip_address":"","ucode":"DC4FC89074FC2E","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/b2/a1acdaaa.jpg","comment_is_top":false,"comment_ctime":1606405835,"is_pvip":false,"replies":[{"id":"96481","content":"赞！","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1606897400,"ip_address":"","comment_id":264287,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606405835","product_id":100037301,"comment_content":"这个章节太棒了","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510498,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606897400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262177,"user_name":"瀚囧","can_delete":false,"product_type":"c1","uid":2286912,"ip_address":"","ucode":"030FD0A2EF482F","user_header":"","comment_is_top":false,"comment_ctime":1605658399,"is_pvip":false,"replies":[{"id":"95255","content":"如果分布式事务不可避免的话，那只能采用数据强一致性了。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605756324,"ip_address":"","comment_id":262177,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605658399","product_id":100037301,"comment_content":"看了代码收益匪浅。有个关于事件的问题，app层一定要基于事件解耦合吗，是不是也可以直接调用grpc服务进行服务聚合，完成某些复杂业务场景","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509719,"discussion_content":"如果分布式事务不可避免的话，那只能采用数据强一致性了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605756324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260307,"user_name":"drawping","can_delete":false,"product_type":"c1","uid":1007204,"ip_address":"","ucode":"A5F0E179CBA217","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/64/1becc599.jpg","comment_is_top":false,"comment_ctime":1604980891,"is_pvip":false,"replies":[{"id":"94615","content":"1、商品明细的快照建议在用户下单时，以值对象的形式，从商品微服务冗余到订单微服务中，这样在获取订单的同时，可以获取到商品明细的快照数据。<br>2、验证下单商品数量这种操作需要跨微服务了，建议放在BFF层微服务或者订单微服务的应用层的应用服务来校验，这体现的是一种跨微服务的服务组合的操作。完成校验后即可调用订单微服务领域层的领域服务，完成订单业务逻辑。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605065645,"ip_address":"","comment_id":260307,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604980891","product_id":100037301,"comment_content":"老师好,电商场景, 按我的理解是拆分订单微服务 &#47; 商品(库存)微服务,  但提供给App客户端的下单接口很多情况下只是 商品id(多个) &#47; 下单数量 &#47; 收货信息等字段. <br>1. 订单微服务需要获取的商品明细(快照), 这些数据是在哪一层拼接好通过DTO传到应用服务的?<br>2. 验证下单数量是否大于当前可用库存数量或者验证用户是否符合购买指定商品放在哪一层实现的?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509162,"discussion_content":"1、商品明细的快照建议在用户下单时，以值对象的形式，从商品微服务冗余到订单微服务中，这样在获取订单的同时，可以获取到商品明细的快照数据。\n2、验证下单商品数量这种操作需要跨微服务了，建议放在BFF层微服务或者订单微服务的应用层的应用服务来校验，这体现的是一种跨微服务的服务组合的操作。完成校验后即可调用订单微服务领域层的领域服务，完成订单业务逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605065645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256504,"user_name":"医大懒虫","can_delete":false,"product_type":"c1","uid":2254307,"ip_address":"","ucode":"68FBD2C70A2B61","user_header":"https://static001.geekbang.org/account/avatar/00/22/65/e3/11fa058d.jpg","comment_is_top":false,"comment_ctime":1603641079,"is_pvip":false,"replies":[{"id":"93387","content":"很好，酣畅淋漓，呵呵。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1603677104,"ip_address":"","comment_id":256504,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603641079","product_id":100037301,"comment_content":"这章太好了","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508036,"discussion_content":"很好，酣畅淋漓，呵呵。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603677104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255496,"user_name":"Geek_eb67e6","can_delete":false,"product_type":"c1","uid":1693966,"ip_address":"","ucode":"6AF8F93172DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEL92icPXhRmPXjOAk1mcTY56Gy3q2JgFOicLkb6ibyiavS61UkZicicAiaOiaP5nDnTlnkDqic9PfJ3ZJUQEJg/132","comment_is_top":false,"comment_ctime":1603358370,"is_pvip":false,"replies":[{"id":"93179","content":"大概看了一下介绍，这个工具应该可以用来做DO和PO的转换，但是不知道某些细节处理方面是否能够完全匹配。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1603434854,"ip_address":"","comment_id":255496,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603358370","product_id":100037301,"comment_content":"老师你好！想问下在工厂里可以使用MapStruct来简化PO和Entity的数据初始化和持久化的转换吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507733,"discussion_content":"大概看了一下介绍，这个工具应该可以用来做DO和PO的转换，但是不知道某些细节处理方面是否能够完全匹配。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603434854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252782,"user_name":"Geek9338","can_delete":false,"product_type":"c1","uid":2201418,"ip_address":"","ucode":"5573C1198EFA52","user_header":"","comment_is_top":false,"comment_ctime":1602486463,"is_pvip":false,"replies":[{"id":"92362","content":"订阅方是在考勤微服务内，所以你在请假微服务内看不到事件订阅相关的处理逻辑。<br>同一个项目的微服务内不同聚合之间采用事件总线方式，不同项目的微服务之间采用消息队列模式。在订阅方微服务中，你只需要在订阅处理逻辑中订阅你需要的队列中的主题就可以了。发布和订阅逻辑，具体你可以了解一下kafka等消息中间件的实现逻辑。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1602491095,"ip_address":"","comment_id":252782,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1602486463","product_id":100037301,"comment_content":"老师您好，请问一下发布领域事件怎么没有订阅方啊？同一个项目和不同项目都怎么订阅事件啊？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506871,"discussion_content":"订阅方是在考勤微服务内，所以你在请假微服务内看不到事件订阅相关的处理逻辑。\n同一个项目的微服务内不同聚合之间采用事件总线方式，不同项目的微服务之间采用消息队列模式。在订阅方微服务中，你只需要在订阅处理逻辑中订阅你需要的队列中的主题就可以了。发布和订阅逻辑，具体你可以了解一下kafka等消息中间件的实现逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602491095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2201418,"avatar":"","nickname":"Geek9338","note":"","ucode":"5573C1198EFA52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311948,"discussion_content":"如果采用事件总线来监听，订阅方不就依赖发布方了吗？最起码依赖事件对象了啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602550517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247906,"user_name":"guoguo 👻","can_delete":false,"product_type":"c1","uid":1025664,"ip_address":"","ucode":"874B0A1E0F7DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/80/6ff7ea5f.jpg","comment_is_top":false,"comment_ctime":1599913203,"is_pvip":false,"replies":[{"id":"91181","content":"请假人第一次提交的时候，确实是需要提交全量信息的。在逐级提交时，只需要提交部分信息，我们可以根据需要再定义一个对应的应用服务，完成逐级提交的功能。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1600046420,"ip_address":"","comment_id":247906,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599913203","product_id":100037301,"comment_content":"看了源码，有一个疑问<br>leaveApplicationService.submitApproval(leave)<br>这个方法<br><br>对用户操作而言，只是进行了一次审批提交。但传入的对象，却是整个请假单信息。<br>请假单信息还包含了申请人信息、审批人信息、请假单其他信息等。<br>而后在处理 审批提交的时候，是把整个请假单信息全量更新了一把：<br>LeaveApi.submitApproval --&gt; leaveApplicationService.submitApproval --&gt; leaveDomainService.submitApproval --&gt; leaveRepositoryInterface.save<br><br>完全依赖于前端提交的信息，其实审批阶段是不应该可以更改 请假单的基本信息和其他信息的，但这个全量操作是否有问题？<br><br>第一，容易引起数据随意篡改<br>第二，没必要的全量查询和全量更新<br><br>审批是不是 只传入 请假单ID、和 审批相关信息就可以了","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505524,"discussion_content":"请假人第一次提交的时候，确实是需要提交全量信息的。在逐级提交时，只需要提交部分信息，我们可以根据需要再定义一个对应的应用服务，完成逐级提交的功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600046420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246561,"user_name":"Labin","can_delete":false,"product_type":"c1","uid":2155890,"ip_address":"","ucode":"13659DF0F364C1","user_header":"https://static001.geekbang.org/account/avatar/00/20/e5/72/211a4768.jpg","comment_is_top":false,"comment_ctime":1599403726,"is_pvip":false,"replies":[{"id":"90665","content":"dto的属性需要根据具体的前后端数据交互要求来按需设计。如果前端应用对审批历史记录进行了修改，就需要将修改后的审批记录数据传输到应用层和领域层。现有代码中只是作为一个示例，没有严格区分前端应用场景，直接将leave聚合中所有的实体组装成了一个DTO，所以里面就包含了historyApprovalInfoDTOList 。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1599467737,"ip_address":"","comment_id":246561,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599403726","product_id":100037301,"comment_content":"1. 我看实例代码，api接口 ddd.leave.interfaces.facade.LeaveApi#createLeaveInfo，参数dto里面包含了历史的审批消息historyApprovalInfoDTOList，这些历史消息也是需要前端传吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505183,"discussion_content":"dto的属性需要根据具体的前后端数据交互要求来按需设计。如果前端应用对审批历史记录进行了修改，就需要将修改后的审批记录数据传输到应用层和领域层。现有代码中只是作为一个示例，没有严格区分前端应用场景，直接将leave聚合中所有的实体组装成了一个DTO，所以里面就包含了historyApprovalInfoDTOList 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599467737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243509,"user_name":"nirvana","can_delete":false,"product_type":"c1","uid":1046905,"ip_address":"","ucode":"D891D8CC115FF0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/79/267562eb.jpg","comment_is_top":false,"comment_ctime":1598159642,"is_pvip":false,"replies":[{"id":"89768","content":"领域服务跟领域层的聚合是一起的，从用户接口层到应用层、领域层和基础层它们是作为一个微服务部署单元存在的。领域服务需要依赖聚合的实体和方法，它是不能够独立部署的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1598232889,"ip_address":"","comment_id":243509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598159642","product_id":100037301,"comment_content":"老师，您好，我想咨询个问题，领域服务可以单独作为一个工程部署，通过接口对外提供服务能力吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504308,"discussion_content":"领域服务跟领域层的聚合是一起的，从用户接口层到应用层、领域层和基础层它们是作为一个微服务部署单元存在的。领域服务需要依赖聚合的实体和方法，它是不能够独立部署的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598232889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239695,"user_name":"hlsc","can_delete":false,"product_type":"c1","uid":1769078,"ip_address":"","ucode":"900036083DDC8C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/fe/76/63206b92.jpg","comment_is_top":false,"comment_ctime":1596618942,"is_pvip":false,"replies":[{"id":"88572","content":"在前端向后端进行数据提交时，前端所有的数据都在一个json串里面，这里就对应了DTO，所以前端所有请求数据都在DTO里面。DTO会转化成应用层和领域层所需的DO，在持久化时再转化为PO。JPA和Mybatis在持久化时的逻辑存在不同，我感觉JPA在持久化时应该也是做了判断的，只不过在JPA内部已经封装好了。其实审批记录的去重也可以在应用逻辑中做吧。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1596675218,"ip_address":"","comment_id":239695,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596618942","product_id":100037301,"comment_content":"老师，您好<br>在审批的时候，会将历史的审批意见也通过DTO传过来，最终通过JPA直接saveAll来持久化审批意见，但是这样，如果我用mybatis来做的话，我需要在仓储层来判断审批记录是否存在，如果不存在的我才会持久化，这样不是比较消耗性能吗？为什么需要将所有的审批流程都放在DTO里面传过来呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503189,"discussion_content":"在前端向后端进行数据提交时，前端所有的数据都在一个json串里面，这里就对应了DTO，所以前端所有请求数据都在DTO里面。DTO会转化成应用层和领域层所需的DO，在持久化时再转化为PO。JPA和Mybatis在持久化时的逻辑存在不同，我感觉JPA在持久化时应该也是做了判断的，只不过在JPA内部已经封装好了。其实审批记录的去重也可以在应用逻辑中做吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596675218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237617,"user_name":"Zz","can_delete":false,"product_type":"c1","uid":1296301,"ip_address":"","ucode":"958A5938569EAB","user_header":"https://static001.geekbang.org/account/avatar/00/13/c7/ad/ecb2b27a.jpg","comment_is_top":false,"comment_ctime":1595902013,"is_pvip":false,"replies":[{"id":"87860","content":"没有诊所方面的行业经验，我试着分析一下哈。<br>如果只定义member-service和 clinic-service两个上下文的话，会员的预约单，挂号单与会员这个聚合在一起可能会比较好。<br>member-service属于会员管理上下文，包括会员、预约、挂号三个不同的聚合。<br>clinic-service属于诊疗上下文，包括医师、诊疗单两个聚合。诊疗单聚合根会包含医师和会员等值对象。<br>其中预约和挂号聚合根实体应该包括会员的基本信息这个值对象，这两个聚合根不知道还需不需要关联医师相关的内容，如果需要的话，可以增加医师值对象。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1595987503,"ip_address":"","comment_id":237617,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1595902013","product_id":100037301,"comment_content":"感谢老师，学完很有收获，目前在我的项目中用DDD来落地微服务。我们业务是给诊所做系统的。我们拆了几个微服务，比如有member-service 和clinic-service。我目前有一个疑惑，就是会员的预约单，挂号单，诊疗单应该放在member-service还是放在clinic-service 里？老师有好的意见吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502482,"discussion_content":"没有诊所方面的行业经验，我试着分析一下哈。\n如果只定义member-service和 clinic-service两个上下文的话，会员的预约单，挂号单与会员这个聚合在一起可能会比较好。\nmember-service属于会员管理上下文，包括会员、预约、挂号三个不同的聚合。\nclinic-service属于诊疗上下文，包括医师、诊疗单两个聚合。诊疗单聚合根会包含医师和会员等值对象。\n其中预约和挂号聚合根实体应该包括会员的基本信息这个值对象，这两个聚合根不知道还需不需要关联医师相关的内容，如果需要的话，可以增加医师值对象。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595987503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1296301,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c7/ad/ecb2b27a.jpg","nickname":"Zz","note":"","ucode":"958A5938569EAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295683,"discussion_content":"明白，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596287445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237278,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1595766510,"is_pvip":false,"replies":[{"id":"88570","content":"leave类里面的autowired是多余代码行，已删除了。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1596674806,"ip_address":"","comment_id":237278,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595766510","product_id":100037301,"comment_content":"第一个类leave就有问题，根本没法autowired其他进来的，类需要spring管理才行，很明显领域模型应该不能是单例的，多例prototype也不行，你得让spring管理，这种类一般都是new出来的，依赖的spring容器内的实例应该通过applicatiinvgetbean得到","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502362,"discussion_content":"leave类里面的autowired是多余代码行，已删除了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596674806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236454,"user_name":"bjy_Yue","can_delete":false,"product_type":"c1","uid":1748467,"ip_address":"","ucode":"60ACB4265AF613","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoc67GT5qpNNWM8yJX9psrTOmaItm3USo0kqbduoCRxvB4FkLRRGNovpPmgxuXQEtk5On3m4sAJnw/132","comment_is_top":false,"comment_ctime":1595419009,"is_pvip":false,"replies":[{"id":"87571","content":"看到了，以github上的为准。文稿中的那段代码是多余的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1595643336,"ip_address":"","comment_id":236454,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595419009","product_id":100037301,"comment_content":"老师好，<br>Leava类中注入了LeaveRepositoryInterface leaveRepositoryInterface;<br>这样Leave就得添加@Compoent注解，但是github的代码里面没有注入，到底哪个对呢？<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502071,"discussion_content":"看到了，以github上的为准。文稿中的那段代码是多余的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595643336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231687,"user_name":"枫zzzzz","can_delete":false,"product_type":"c1","uid":1370304,"ip_address":"","ucode":"0CD6F332407936","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLNgTWpN9vEUMZ77xTkiaPibX8E22c2L5GTmkgyP4cajbNiap5zEp28HicvA8eOCQqYo7YDsAhuafict2Q/132","comment_is_top":false,"comment_ctime":1593748190,"is_pvip":false,"replies":[{"id":"85557","content":"其实你可以这样设计。商品这个实体集中在商品聚合中维护。其它需要用到商品数据的若干业务聚合可以将商品设计为值对象。这些值对象只有必须的商品数据，它们的数据来源商品聚合。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593768580,"ip_address":"","comment_id":231687,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593748190","product_id":100037301,"comment_content":"老师，问一个问题，在DDD设计中，如果一个po在两个项目（系统）中都要用到的话，是把这个po在两个项目中各copy一份，还是抽出来打成公共jar包依赖呢？最常见的场景：比如一个商品，我在运营管理系统中要用到，在商城系统里面也要用到","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500409,"discussion_content":"其实你可以这样设计。商品这个实体集中在商品聚合中维护。其它需要用到商品数据的若干业务聚合可以将商品设计为值对象。这些值对象只有必须的商品数据，它们的数据来源商品聚合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593768580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229719,"user_name":"徐德颂","can_delete":false,"product_type":"c1","uid":1824501,"ip_address":"","ucode":"10B82A38994639","user_header":"https://static001.geekbang.org/account/avatar/00/1b/d6/f5/9b86c627.jpg","comment_is_top":false,"comment_ctime":1593128840,"is_pvip":false,"replies":[{"id":"85227","content":"事件发布的位置相对灵活，可以放在应用层发布，也可以在领域服务或聚合根的方法里发布。<br>如果放在应用层发布，就需要有两个领域服务，一个实现领域逻辑，一个实现事件发布逻辑，然后通过应用服务来组合。如果领域逻辑和事件发布逻辑是一个连续的相对固定的处理逻辑，就可以放在同一个领域服务里面来完成业务逻辑处理和事件发布。<br>但是一般来说事件订阅放在应用层比较合适，事件处理逻辑由领域服务来实现。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593499293,"ip_address":"","comment_id":229719,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1593128840","product_id":100037301,"comment_content":"老师我想请问下，之前13章有提到事件发布与订阅尽量放到应用层统一管理，您代码实例中事件是直接在LeaveDomainService 中 submitApproval 领域服务中发布。如果事件的发布放在应用层，那么领域层执行完业务逻辑发布事件会需要调用应用层？那么在什么情况下事件发布可以放在领域层？什么情况下放在应用层？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499608,"discussion_content":"事件发布的位置相对灵活，可以放在应用层发布，也可以在领域服务或聚合根的方法里发布。\n如果放在应用层发布，就需要有两个领域服务，一个实现领域逻辑，一个实现事件发布逻辑，然后通过应用服务来组合。如果领域逻辑和事件发布逻辑是一个连续的相对固定的处理逻辑，就可以放在同一个领域服务里面来完成业务逻辑处理和事件发布。\n但是一般来说事件订阅放在应用层比较合适，事件处理逻辑由领域服务来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593499293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1824501,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/d6/f5/9b86c627.jpg","nickname":"徐德颂","note":"","ucode":"10B82A38994639","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289866,"discussion_content":"明白了，谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594255017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223157,"user_name":"风之子","can_delete":false,"product_type":"c1","uid":1367215,"ip_address":"","ucode":"74F1B02BCE6E20","user_header":"https://static001.geekbang.org/account/avatar/00/14/dc/af/f45f791f.jpg","comment_is_top":false,"comment_ctime":1591010854,"is_pvip":false,"replies":[{"id":"82486","content":"没有哈。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591255917,"ip_address":"","comment_id":223157,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591010854","product_id":100037301,"comment_content":"没有增加数据的脚本或者单元测试吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497031,"discussion_content":"没有哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591255917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222947,"user_name":"匿名对象","can_delete":false,"product_type":"c1","uid":1252826,"ip_address":"","ucode":"FC90F8842D38A9","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/da/f2748c85.jpg","comment_is_top":false,"comment_ctime":1590972372,"is_pvip":true,"replies":[{"id":"82492","content":"微服务四层代码是在一个工程里面的。如果你有maven父工程的话，那这四层的代码就在一个子工程里面。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591257068,"ip_address":"","comment_id":222947,"utype":1}],"discussion_count":1,"race_medal":3,"score":"1590972372","product_id":100037301,"comment_content":"这里的微服务的四层 和平常开发时用到的通过maven模块分层有哪些区别，假如这里的服务提供用dubbo来做(不熟悉spring cloud)，会是什么样？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496969,"discussion_content":"微服务四层代码是在一个工程里面的。如果你有maven父工程的话，那这四层的代码就在一个子工程里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591257068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222463,"user_name":"滴八哥","can_delete":false,"product_type":"c1","uid":2024278,"ip_address":"","ucode":"09594011B07BB9","user_header":"","comment_is_top":false,"comment_ctime":1590811633,"is_pvip":false,"replies":[{"id":"82048","content":"现在似乎还没有这么先进的工具吧。<br>聚合会根据限界上下文边界来进行组合，一般不建议对聚合进行过度拆分哈。聚合之间虽然解耦的工作做得很好，但是聚合独立为微服务的拆分的工作并不是没有的。<br>你的想法很好，但是一个领域模型的多个聚合是在一个微服务部署包内，似乎目前很难在运行时不做任何改动就可以直接做到聚合独立为微服务来运行。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590828684,"ip_address":"","comment_id":222463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590811633","product_id":100037301,"comment_content":"欧老师，那是不是我们每个聚合在开发阶段都可以作为单独微服务来开发，然后通过配置中心来动态配置哪几个聚合要合并要一个微服务里。<br>当编排程序检查到某个聚合访问量激增，则自动拆分成微服务，流量下来时再自动合并到其他微服务中。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496809,"discussion_content":"现在似乎还没有这么先进的工具吧。\n聚合会根据限界上下文边界来进行组合，一般不建议对聚合进行过度拆分哈。聚合之间虽然解耦的工作做得很好，但是聚合独立为微服务的拆分的工作并不是没有的。\n你的想法很好，但是一个领域模型的多个聚合是在一个微服务部署包内，似乎目前很难在运行时不做任何改动就可以直接做到聚合独立为微服务来运行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590828684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221852,"user_name":"匿名对象","can_delete":false,"product_type":"c1","uid":1252826,"ip_address":"","ucode":"FC90F8842D38A9","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/da/f2748c85.jpg","comment_is_top":false,"comment_ctime":1590622956,"is_pvip":true,"replies":[{"id":"81963","content":"这些代码就是在一个微服务项目里面的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590743248,"ip_address":"","comment_id":221852,"utype":1}],"discussion_count":1,"race_medal":3,"score":"1590622956","product_id":100037301,"comment_content":"老师，DDD的分层在demo中只是把代码分层了，并没有把项目分层(maven)，这是为何？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496590,"discussion_content":"这些代码就是在一个微服务项目里面的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590743248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219843,"user_name":"Coding","can_delete":false,"product_type":"c1","uid":1124243,"ip_address":"","ucode":"BFBA2D0782AF3A","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/93/ade2062d.jpg","comment_is_top":false,"comment_ctime":1590109885,"is_pvip":false,"replies":[{"id":"81166","content":"在领域层可以定义异常处理逻辑的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590116949,"ip_address":"","comment_id":219843,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590109885","product_id":100037301,"comment_content":"领域层的异常怎么处理呢，是否需要自定义异常，我看老师的样例中直接抛出RuntimeException，有一些困惑","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495957,"discussion_content":"在领域层可以定义异常处理逻辑的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590116949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219544,"user_name":"AYOU","can_delete":false,"product_type":"c1","uid":1048845,"ip_address":"","ucode":"BEF18C1DB4B621","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/0d/75b3cb10.jpg","comment_is_top":false,"comment_ctime":1590039674,"is_pvip":false,"replies":[{"id":"81086","content":"由于查询一般没有太多的业务逻辑和规则控制，所以一般复杂的查询都会放在应用层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590050426,"ip_address":"","comment_id":219544,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590039674","product_id":100037301,"comment_content":"老师好，一些查询业务如果多出一些查询参数，如果吧这些参数放在一个对象里，这个对象应该放在哪一层呀？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495847,"discussion_content":"由于查询一般没有太多的业务逻辑和规则控制，所以一般复杂的查询都会放在应用层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590050426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218838,"user_name":"Martin","can_delete":false,"product_type":"c1","uid":2003217,"ip_address":"","ucode":"58A3B6397E8636","user_header":"https://static001.geekbang.org/account/avatar/00/1e/91/11/86b31c15.jpg","comment_is_top":false,"comment_ctime":1589884891,"is_pvip":false,"replies":[{"id":"81091","content":"在同一个聚合内部如果approvalInfo已经构建，直接这么使用就可以了approvalInfo.editApprovalInfo()。如果是跨聚合之间的调用，先根据leave的ID找到leave聚合根，然后根据leave聚合根找到approvalInfo，然后调用editApprovalInfo()就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590052710,"ip_address":"","comment_id":218838,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589884891","product_id":100037301,"comment_content":"Leave请假实体引用了ApprovalInfo审批意见实体，假如ApprovalInfo中有一个方法是修改审批意见editApprovalInfo。<br>那么我要在领域层里完成“修改审批意见并修改请假状态”，我就得这么写：<br>if(leave.approvalInfo != null){<br>    leave.approvalInfo.editApprovalInfo()<br>    leave.Status = Status.APPROVING<br>}<br>——————<br>1、调用对象里面的对象的方法，这种写法在常规代码里就很少见<br>2、如果嵌套较深，我得层层判空，很麻烦<br>这样的代码就很难看，不知道是否有好的方案去规避这个问题呢，还是说我这样写也是可以的？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495594,"discussion_content":"在同一个聚合内部如果approvalInfo已经构建，直接这么使用就可以了approvalInfo.editApprovalInfo()。如果是跨聚合之间的调用，先根据leave的ID找到leave聚合根，然后根据leave聚合根找到approvalInfo，然后调用editApprovalInfo()就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590052710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218044,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1004462,"ip_address":"","ucode":"8F7DE6E7B3D74F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/ae/a08024b2.jpg","comment_is_top":false,"comment_ctime":1589703026,"is_pvip":false,"replies":[{"id":"80662","content":"这一段代码是从DO转PO的过程，先从DO中获取数据，然后将数据赋值给PO的属性，这段代码应该没有问题的。<br>leavePO.setStartTime(leave.getStartTime());<br>你是说 getLeave(LeavePO leavePO) 这个方法里面吗？<br>它是从PO到DO的转换过程，你说的对，是应该这样的。leave.setStartTime(leavePO.getStartTime());","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589724385,"ip_address":"","comment_id":218044,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589703026","product_id":100037301,"comment_content":"请教下老师 LeaveFactory 代码的第 25 行 leave.setStartTime(leave.getStartTime()); 是否应该写成  leave.setStartTime(leavePO.getStartTime());  呢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495334,"discussion_content":"这一段代码是从DO转PO的过程，先从DO中获取数据，然后将数据赋值给PO的属性，这段代码应该没有问题的。\nleavePO.setStartTime(leave.getStartTime());\n你是说 getLeave(LeavePO leavePO) 这个方法里面吗？\n它是从PO到DO的转换过程，你说的对，是应该这样的。leave.setStartTime(leavePO.getStartTime());","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589724385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216783,"user_name":"loongwin","can_delete":false,"product_type":"c1","uid":1924270,"ip_address":"","ucode":"5E3226071822A0","user_header":"","comment_is_top":false,"comment_ctime":1589341518,"is_pvip":false,"replies":[{"id":"80200","content":"要用DTO的，微服务之间用DTO。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589346677,"ip_address":"","comment_id":216783,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589341518","product_id":100037301,"comment_content":"老师好,LoginApplicationService调用另一个微服务authService.login(person),用的person是DO,DO可以跨微服务使用么?还是用DTO比较好呢?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494946,"discussion_content":"要用DTO的，微服务之间用DTO。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589346677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216322,"user_name":"hugeo","can_delete":false,"product_type":"c1","uid":1042824,"ip_address":"","ucode":"438F289EDD21CD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/88/941e488a.jpg","comment_is_top":false,"comment_ctime":1589242546,"is_pvip":false,"replies":[{"id":"80276","content":"是的，依赖原则是外层依赖内层。不能从领域层去调应用层的服务，所以只能放在应用层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589424210,"ip_address":"","comment_id":216322,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589242546","product_id":100037301,"comment_content":"老师。采用同线程的事件总线。事件消费时要调用应用层的业务逻辑。那handler类放在应用层吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494774,"discussion_content":"是的，依赖原则是外层依赖内层。不能从领域层去调应用层的服务，所以只能放在应用层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589424210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215648,"user_name":"hugeo","can_delete":false,"product_type":"c1","uid":1042824,"ip_address":"","ucode":"438F289EDD21CD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/88/941e488a.jpg","comment_is_top":false,"comment_ctime":1589043126,"is_pvip":false,"replies":[{"id":"80277","content":"在工厂里从DO转换为PO时，从系统自动获取时间然后赋值给PO就可以吧。比如在这段代码里面。<br>public class LeaveFactory {<br><br>    public LeavePO createLeavePO(Leave leave) {<br>        LeavePO leavePO = new LeavePO();<br>        leavePO.setId(UUID.randomUUID().toString());<br>        leavePO.setApplicantId(leave.getApplicant().getPersonId());<br>        leavePO.setApplicantName(leave.getApplicant().getPersonName());<br>        leavePO.setApproverId(leave.getApprover().getPersonId());<br>        leavePO.setApproverName(leave.getApprover().getPersonName());<br>        leavePO.setStartTime(leave.getStartTime());<br>        leavePO.setStatus(leave.getStatus());<br>        List&lt;ApprovalInfoPO&gt; historyApprovalInfoPOList = approvalInfoPOListFromDO(leave);<br>        leavePO.setHistoryApprovalInfoPOList(historyApprovalInfoPOList);<br>        return leavePO;<br>    }<br>}","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589424549,"ip_address":"","comment_id":215648,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589043126","product_id":100037301,"comment_content":"老师，请问一下PO对象保存后才自生成的id，创建时间，更新时间字段，以什么方式赋值给实体比较好","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494507,"discussion_content":"在工厂里从DO转换为PO时，从系统自动获取时间然后赋值给PO就可以吧。比如在这段代码里面。\npublic class LeaveFactory {\n\n    public LeavePO createLeavePO(Leave leave) {\n        LeavePO leavePO = new LeavePO();\n        leavePO.setId(UUID.randomUUID().toString());\n        leavePO.setApplicantId(leave.getApplicant().getPersonId());\n        leavePO.setApplicantName(leave.getApplicant().getPersonName());\n        leavePO.setApproverId(leave.getApprover().getPersonId());\n        leavePO.setApproverName(leave.getApprover().getPersonName());\n        leavePO.setStartTime(leave.getStartTime());\n        leavePO.setStatus(leave.getStatus());\n        List&amp;lt;ApprovalInfoPO&amp;gt; historyApprovalInfoPOList = approvalInfoPOListFromDO(leave);\n        leavePO.setHistoryApprovalInfoPOList(historyApprovalInfoPOList);\n        return leavePO;\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589424549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214500,"user_name":"Geek_a91670","can_delete":false,"product_type":"c1","uid":1705156,"ip_address":"","ucode":"6CAA9FF890F8EA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/04/c4/ef4bd241.jpg","comment_is_top":false,"comment_ctime":1588758684,"is_pvip":false,"replies":[{"id":"79522","content":"它是要控制聚合内事务数据和业务数据保存到数据库时能保证事务一致性。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588823060,"ip_address":"","comment_id":214500,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588758684","product_id":100037301,"comment_content":"看代码示例: 事务控制是在domain-service 处理的?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494081,"discussion_content":"它是要控制聚合内事务数据和业务数据保存到数据库时能保证事务一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588823060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210073,"user_name":".benxiaohai52","can_delete":false,"product_type":"c1","uid":1221835,"ip_address":"","ucode":"8F748310484724","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/cb/407d9a81.jpg","comment_is_top":false,"comment_ctime":1587661426,"is_pvip":false,"replies":[{"id":"80290","content":"1、这个审批功能比较简单，只是改了状态和修改审批人，没有用到工作流之类，所以逻辑相对简单。<br>2、应用服务主要是做编排，尽量将具体的业务逻辑往领域层下沉。所以将这些涉及到实体的操作放到了领域服务中。<br>3、在JPA中这些get方法默认就有了，不需要单独的代码来实现。<br>4、是的，工厂主要处理复杂聚合的实体创建数据初始化和实体数据的持久化操作。<br>最后一个问题，这里面应该会有人员管理和学员学习记录两个聚合吧，人员的数据当然可以改，但只能从人员管理聚合中改，在人员管理聚合完成姓名修改后，你就可以将正确的数据用来整体替换掉原来错误的人员数据了。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589426447,"ip_address":"","comment_id":210073,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587661426","product_id":100037301,"comment_content":"1、审批这个功能能不能加到代码中啊，有很多不解，一句话说不清楚<br>2、leave.setLeaderMaxLevel(leaderMaxLevel);<br>        leave.setApprover(approver);这段代码为何在LeaveDomainService.createLeave里而不在LeaveApplicationService.createLeaveInfo里。<br>3、leave.getCurrentApprovalInfo()没有这个方法，但在LeaveDomainService.submitApproval里却调用这个方法了。<br>4、工厂主要是处理聚合内的所有对象还有仓储的PO吗？<br>5、值对象不允许修改，但我们业务很奇特，举个例子，学员学习记录，学员信息按理说应该是值对像吧，但有时候人事在录数据的时候把人家名子搞错了，我在系统里面不能存着错误的姓名吧，关键是业务要求必须修正。如果只存ID吧，根据姓名查询时无法查询啊，因为是在不同的服务中。如果采用数据库日志同步方式，学习记录中存的是JSON，不太好同步啊，你有什么好的方案吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492935,"discussion_content":"1、这个审批功能比较简单，只是改了状态和修改审批人，没有用到工作流之类，所以逻辑相对简单。\n2、应用服务主要是做编排，尽量将具体的业务逻辑往领域层下沉。所以将这些涉及到实体的操作放到了领域服务中。\n3、在JPA中这些get方法默认就有了，不需要单独的代码来实现。\n4、是的，工厂主要处理复杂聚合的实体创建数据初始化和实体数据的持久化操作。\n最后一个问题，这里面应该会有人员管理和学员学习记录两个聚合吧，人员的数据当然可以改，但只能从人员管理聚合中改，在人员管理聚合完成姓名修改后，你就可以将正确的数据用来整体替换掉原来错误的人员数据了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589426447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204783,"user_name":"Lilian","can_delete":false,"product_type":"c1","uid":1094841,"ip_address":"","ucode":"860DC19654853A","user_header":"https://static001.geekbang.org/account/avatar/00/10/b4/b9/62ea56f6.jpg","comment_is_top":false,"comment_ctime":1586465838,"is_pvip":false,"replies":[{"id":"76560","content":"所以将这些实体数据的初始化和转换统一放到工厂里实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586488853,"ip_address":"","comment_id":204783,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586465838","product_id":100037301,"comment_content":"createLeavePO，getLeave这种实现方式，实践中，常常出现，增加字段某处更新遗漏","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491288,"discussion_content":"所以将这些实体数据的初始化和转换统一放到工厂里实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586488853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204782,"user_name":"Lilian","can_delete":false,"product_type":"c1","uid":1094841,"ip_address":"","ucode":"860DC19654853A","user_header":"https://static001.geekbang.org/account/avatar/00/10/b4/b9/62ea56f6.jpg","comment_is_top":false,"comment_ctime":1586464690,"is_pvip":false,"replies":[{"id":"76558","content":"有这种情况，Create对象的只是局部赋值。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586488553,"ip_address":"","comment_id":204782,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586464690","product_id":100037301,"comment_content":"Leave的Create方法疑惑，按示例，Create作为对象方法，既然是先有有对象了，是否导致创建对象未调用Create?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491287,"discussion_content":"有这种情况，Create对象的只是局部赋值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586488553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203522,"user_name":"Tmac Zhou","can_delete":false,"product_type":"c1","uid":1335460,"ip_address":"","ucode":"9DF58D283523CA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a4/f9ae0c70.jpg","comment_is_top":false,"comment_ctime":1586226641,"is_pvip":false,"replies":[{"id":"76073","content":"在用领域事件的时候，往往在同一个服务里会有几个主要的操作。<br>1、往业务表里写入变更的业务数据。<br>2、往事件表里写入事件数据。<br>如果采用基于数据库日志捕获的方式发送事件数据的话，你只需要保证1、2的事务就行了。<br>如果直接送MQ。你在这个服务里面将往数据库里面写入变更业务数据的操作和送MQ两个动作放在一个事务就可以了，送MQ成功就算成功，一般都不关心订阅方的处理结果。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586230406,"ip_address":"","comment_id":203522,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1586226641","product_id":100037301,"comment_content":"您好，在微服务中避免不了使用消息中间件的业务场景，想请教一下，如何保证修改数据和发送MQ在同一个事务里面？ 提前谢谢您的解答。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490881,"discussion_content":"在用领域事件的时候，往往在同一个服务里会有几个主要的操作。\n1、往业务表里写入变更的业务数据。\n2、往事件表里写入事件数据。\n如果采用基于数据库日志捕获的方式发送事件数据的话，你只需要保证1、2的事务就行了。\n如果直接送MQ。你在这个服务里面将往数据库里面写入变更业务数据的操作和送MQ两个动作放在一个事务就可以了，送MQ成功就算成功，一般都不关心订阅方的处理结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586230406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1335460,"avatar":"https://static001.geekbang.org/account/avatar/00/14/60/a4/f9ae0c70.jpg","nickname":"Tmac Zhou","note":"","ucode":"9DF58D283523CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269101,"discussion_content":"但是往往 写入变更数据的操作 是在DB commit阶段才知道是否成功，那这样子就会造成 send MQ 已经发送，但是 业务数据变更在commit 阶段就失败了。 还是会有不一致的情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589867098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1981608,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/3c/a8/3b935109.jpg","nickname":"Damon","note":"","ucode":"44AD9E5944671F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1335460,"avatar":"https://static001.geekbang.org/account/avatar/00/14/60/a4/f9ae0c70.jpg","nickname":"Tmac Zhou","note":"","ucode":"9DF58D283523CA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306400,"discussion_content":"这里有两种方案解决这个问题 1.最大通知模式  2.最终一致性       1.event保存消息和业务处理在一个事务内，当事务提交了，在发起event投递到mq，如果失败，重复投递，直到成功。  2. rocketmq 支持的事务消息模式，在本地事务内先发送一条消息到mq，只是半发送（mq的消费者无法消费）。当本地事务成功后，同时通知mq把这个消息改成全发送（消费者可以处理了）。异常情况：本地错误了，mq会定时扫描半提交的消息，到业务系统问询是否真的异常了，如果异常删除消息，如果正常把当前半提交消息改成提交状态。（具体可以参考rocketmmq的事务消息，也可以通过自己实现）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600262823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269101,"ip_address":""},"score":306400,"extra":""}]},{"author":{"id":1981608,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/3c/a8/3b935109.jpg","nickname":"Damon","note":"","ucode":"44AD9E5944671F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306401,"discussion_content":"mq和本地事务从现有开源的方案里，没法做到放在一个本地事务里一起成功或者失败，只能通过以上类似描述的方案进行处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600263178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202256,"user_name":"Siping","can_delete":false,"product_type":"c1","uid":1487971,"ip_address":"","ucode":"48E685333C663D","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/63/21902253.jpg","comment_is_top":false,"comment_ctime":1585945058,"is_pvip":false,"replies":[{"id":"75665","content":"是这样的。三层架构下很多人都采用贫血模型。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586004615,"ip_address":"","comment_id":202256,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585945058","product_id":100037301,"comment_content":"开始以为充血模式是理所当然，最近检视了很多代码，没想到大多数人都只会贫血模式","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490540,"discussion_content":"是这样的。三层架构下很多人都采用贫血模型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586004615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201855,"user_name":"秦伟","can_delete":false,"product_type":"c1","uid":1931692,"ip_address":"","ucode":"D47C1F57500FE1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/VjomKNzfFiaIttqYMxbjAWTG7NL7P2UqC5fbSvg0JW80SLnoR2oH1G4U2eibmxbR4wPpoqZdDnjC8GqgShDOBRzA/132","comment_is_top":false,"comment_ctime":1585845437,"is_pvip":false,"replies":[{"id":"75482","content":"这个是全聚合数据的一次性初始化。<br>你可以单建一个仓储查询服务的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585878034,"ip_address":"","comment_id":201855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585845437","product_id":100037301,"comment_content":"@Override public List queryByApproverId(String approverId) { List leavePOList = leaveDao.queryByApproverId(approverId); leavePOList.stream() .forEach(leavePO -&gt; { List approvalInfoPOList = approvalInfoDao.queryByLeaveId(leavePO.getId()); leavePO.setHistoryApprovalInfoPOList(approvalInfoPOList); }); return leavePOList; }}<br>老师好：<br>1、这个代码每次都要获取HistoryApprovalInfoPOList，性能应该不好吧， <br>2、如果有不需要HistoryApprovalInfoPOList的信息， 我是不是需要重新写一个仓储查询方法","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490438,"discussion_content":"这个是全聚合数据的一次性初始化。\n你可以单建一个仓储查询服务的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585878034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198629,"user_name":"吴贤龙","can_delete":false,"product_type":"c1","uid":1220566,"ip_address":"","ucode":"45085FE86D6030","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","comment_is_top":false,"comment_ctime":1585460789,"is_pvip":false,"replies":[{"id":"74732","content":"是的。还是你心细，是有耦合的问题。如果将Person聚合和leave聚合拆分为不同的微服务，需要在Leave微服务新增一个Person的DO对象，以接受从Person微服务返回的person的DTO对象。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585473689,"ip_address":"","comment_id":198629,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585460789","product_id":100037301,"comment_content":"老师，有个疑惑，同过加餐里提供的源码，发现请假聚合里的一个值对象Approver，他的构造函数直接引用了人员组织聚合的Person，如果是在一个微服务，应该是没问题，但是这么设计，是不是会影响到，微服务进一步细分呢？比如请假聚合和人员聚合划分到不同的微服务？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489731,"discussion_content":"是的。还是你心细，是有耦合的问题。如果将Person聚合和leave聚合拆分为不同的微服务，需要在Leave微服务新增一个Person的DO对象，以接受从Person微服务返回的person的DTO对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585473689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194900,"user_name":"果然如此","can_delete":false,"product_type":"c1","uid":1210003,"ip_address":"","ucode":"C7543BD0A67505","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","comment_is_top":false,"comment_ctime":1585117962,"is_pvip":false,"replies":[{"id":"74162","content":"在领域建模设计的时候会有一个上下文服务地图的检查，如果发现服务循环调用，在这个阶段就应该切断这个链路。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585135922,"ip_address":"","comment_id":194900,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1585117962","product_id":100037301,"comment_content":"您好，我最近快速过了一遍咱们的课程，有个微服务问题请教，如果有两个微服务出现了互相调用导致了循环引用，实际项目有什么好的解决方式？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488927,"discussion_content":"在领域建模设计的时候会有一个上下文服务地图的检查，如果发现服务循环调用，在这个阶段就应该切断这个链路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585135922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210003,"avatar":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","nickname":"果然如此","note":"","ucode":"C7543BD0A67505","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214039,"discussion_content":"有什么的设计架构或原则避免这种情况，而不是在出现了才去切断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585143057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189128,"user_name":"miniluo","can_delete":false,"product_type":"c1","uid":1397339,"ip_address":"","ucode":"5735B6DEE7902B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FheCgo4Ovibo0L1vAGgMdZkzQMm1GUMHMMqQ8aglufXaD2hW9z96DjQicAam723jOCZwXVmiaNiaaq4PLsf4COibZ5A/132","comment_is_top":false,"comment_ctime":1584457987,"is_pvip":false,"replies":[{"id":"73010","content":"谢谢，欢迎多交流。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584510203,"ip_address":"","comment_id":189128,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584457987","product_id":100037301,"comment_content":"最近公司使用sofa来重构已有的业务代码，对比了老师这个，虽然大体上都差不多，但是你这个各层的划分还比较清晰。得到不少的领悟，感谢！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487614,"discussion_content":"谢谢，欢迎多交流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584510203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185593,"user_name":"Geek_88604f","can_delete":false,"product_type":"c1","uid":1501234,"ip_address":"","ucode":"33DD1318E53814","user_header":"","comment_is_top":false,"comment_ctime":1583640290,"is_pvip":false,"replies":[{"id":"71810","content":"实体之间可以引用的，这里的协同主要强调实体之间的业务逻辑，涉及到多实体的业务逻辑组合的事情。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583719093,"ip_address":"","comment_id":185593,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583640290","product_id":100037301,"comment_content":"老师，同一个聚会内的两个实体之间也不能互相引用，只能通过领域服务来协调？这样的话，一个聚合内除了聚合根外，其他的实体都只能引用一些基本的对象，string、timestamp等？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486431,"discussion_content":"实体之间可以引用的，这里的协同主要强调实体之间的业务逻辑，涉及到多实体的业务逻辑组合的事情。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583719093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183760,"user_name":"marker","can_delete":false,"product_type":"c1","uid":1094478,"ip_address":"","ucode":"DDBF1CD83665C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/4e/5f22b09d.jpg","comment_is_top":false,"comment_ctime":1583128702,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583128702","product_id":100037301,"comment_content":"事件存储和业务存储可以用aop封装一下,总体非常好","like_count":0},{"had_liked":false,"id":179383,"user_name":"加载中……","can_delete":false,"product_type":"c1","uid":1366948,"ip_address":"","ucode":"3E59A0A0784D0A","user_header":"https://static001.geekbang.org/account/avatar/00/14/db/a4/191be6ad.jpg","comment_is_top":false,"comment_ctime":1581994325,"is_pvip":false,"replies":[{"id":"69818","content":"持久化的操作应该是PO。通过仓储服务来实现。CRUD用JPA的话，不需要你单独写方法的。持久化的操作都是放在仓储实现里的，不应该放DO里面。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582111500,"ip_address":"","comment_id":179383,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581994325","product_id":100037301,"comment_content":"老师好，针对github上的代码有个疑问想请教下：<br>关于持久化的操作是不是也应该在DO里面(比如Person类) Person.findById()里面再调用repository<br>。我看有些DDD实践是这样描述的，不过这样实现好像会复杂些。<br>我看咱们的github上的代码DO里面没有关于CRUD对应的操作语义，这些都放到DomainService来操作了。<br>问题：这些持久化相关的语义操作 用不用放到DO里面实现呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484237,"discussion_content":"持久化的操作应该是PO。通过仓储服务来实现。CRUD用JPA的话，不需要你单独写方法的。持久化的操作都是放在仓储实现里的，不应该放DO里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582111500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178863,"user_name":"mliu","can_delete":false,"product_type":"c1","uid":1073538,"ip_address":"","ucode":"C7B4CC8DF4AF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/82/d30efc2f.jpg","comment_is_top":false,"comment_ctime":1581842112,"is_pvip":false,"replies":[{"id":"69825","content":"有可能的，所以设计的时候要设计小聚合。太大的话，可能会变成小单体。如果领域服务太大，也可以将比较大的领域服务独立为一个领域服务类。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582112777,"ip_address":"","comment_id":178863,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581842112","product_id":100037301,"comment_content":"老师你好，上面说一个聚合内的业务逻辑都在一个 领域服务类中实现(xxxxDomanService),那如果业务复杂的话，会不会导致这个类比较大，比较臃肿？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483998,"discussion_content":"有可能的，所以设计的时候要设计小聚合。太大的话，可能会变成小单体。如果领域服务太大，也可以将比较大的领域服务独立为一个领域服务类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582112777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178772,"user_name":"蒙面超人","can_delete":false,"product_type":"c1","uid":1107584,"ip_address":"","ucode":"9FE34EC44ABA78","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/80/c13098cc.jpg","comment_is_top":false,"comment_ctime":1581821400,"is_pvip":false,"replies":[{"id":"69830","content":"比较复杂的查询逻辑，建议你不过领域层，直接从应用服务按照传统的查询方式设计就可以了。<br>同一个聚合内持久化并发建议通过数据库SQL<br>来实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582113979,"ip_address":"","comment_id":178772,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581821400","product_id":100037301,"comment_content":"<br><br>感谢老师的分享，在实践过程中遇到些疑问，望解答：<br>1. 类似Leave这样的聚合根（真实业务场景可能会更大一些，大小的控制也比较考验水平），会初始化查询好几张表，性能会下降，这个量不大可以接受。<br>但是 List leaveList = leaveApplicationService.queryLeaveInfosByApplicant(applicantId);<br>这类查询请假集合，针对展示层，经由领域层，聚合控制不好，性能会显著下降。是不是直接由仓储输出DTO更好呢？<br>2. submitApproval 可能产生的并发变更问题，逻辑过程经由 <br>a.加载leave聚合根对象<br>b.判断ApprovalType.REJECT == leave.getCurrentApprovalInfo()状态<br>c.逻辑处理以及持久化<br>leave由于版本比较旧，造成b的判断问题，而产生并发问题。<br>这种如何处理比较好？<br>是sql 额外 控制状态转变的逻辑，还是分布式锁在应用层控制？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483959,"discussion_content":"比较复杂的查询逻辑，建议你不过领域层，直接从应用服务按照传统的查询方式设计就可以了。\n同一个聚合内持久化并发建议通过数据库SQL\n来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582113979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177651,"user_name":"allen","can_delete":false,"product_type":"c1","uid":1429382,"ip_address":"","ucode":"04F8FE4245E505","user_header":"https://static001.geekbang.org/account/avatar/00/15/cf/86/886d7ad3.jpg","comment_is_top":false,"comment_ctime":1581461933,"is_pvip":false,"replies":[{"id":"69019","content":"@repository注解在传统三层结构一般是放在dao那层表示持久化层，属于习惯，没有规范要求，仓储需要注入肯定需要注解，用@Component也可以，习惯上用@Repository表示持久化相关的更合适。<br>do和po的转换放仓储实现里面也是可以的，放这里更接近数据。DO和PO转换因为涉及到比较多的实体操作，所以放到工厂里去了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581508158,"ip_address":"","comment_id":177651,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1581461933","product_id":100037301,"comment_content":"为什么在仓储实现层加注解@Repository呢？这个注解不都是应用在dao上吗？还有就是仓储实现都是对po的操作，do与po的转换是在领域服务层完成吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483497,"discussion_content":"@repository注解在传统三层结构一般是放在dao那层表示持久化层，属于习惯，没有规范要求，仓储需要注入肯定需要注解，用@Component也可以，习惯上用@Repository表示持久化相关的更合适。\ndo和po的转换放仓储实现里面也是可以的，放这里更接近数据。DO和PO转换因为涉及到比较多的实体操作，所以放到工厂里去了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581508158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1055894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/96/0fc7aacf.jpg","nickname":"星云","note":"","ucode":"00325D63F7DE6E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":537149,"discussion_content":"\n看了其他书籍 仓储应该是直接操作领域对象 内部状换为  po。 工厂方法应该只创建领域对象 不应该依赖 po。 仓储是属于领域层 是业务逻辑 是基于dao实现的 因此po不应该出现在仓储的参数里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638970593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":483497,"ip_address":""},"score":537149,"extra":""}]}]},{"had_liked":false,"id":177163,"user_name":"嘉嘉☕","can_delete":false,"product_type":"c1","uid":1059771,"ip_address":"","ucode":"632A5CC4B53BB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","comment_is_top":false,"comment_ctime":1581306801,"is_pvip":false,"replies":[{"id":"68785","content":"是的，逐层封装。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581314880,"ip_address":"","comment_id":177163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581306801","product_id":100037301,"comment_content":"老师, 请问下, <br>对于每一层, 也是需要面向接口编程的吧 ?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483326,"discussion_content":"是的，逐层封装。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581314880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175951,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1580890497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580890497","product_id":100037301,"comment_content":"棒，值得学习-&gt;实践-&gt;再学习","like_count":0},{"had_liked":false,"id":175950,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1580890418,"is_pvip":false,"replies":[{"id":"68997","content":"微服务之间主要通过微服务网关来调用，Facade接口直接发布就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581494966,"ip_address":"","comment_id":175950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580890418","product_id":100037301,"comment_content":"有个疑问，如果是微服务之间调用，为了减少重复编码和统一性，是不是应该把DTO和FeginClient打成jar包发布到仓库，让调用方引用啊？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482967,"discussion_content":"微服务之间主要通过微服务网关来调用，Facade接口直接发布就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581494966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174351,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1580177751,"is_pvip":false,"replies":[{"id":"69004","content":"麻烦告诉一下是哪个类，大概哪个位置。谢谢","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581497381,"ip_address":"","comment_id":174351,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580177751","product_id":100037301,"comment_content":"老师，Leave是个实体类，怎么能用@Autowired注入Bean的","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482375,"discussion_content":"麻烦告诉一下是哪个类，大概哪个位置。谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581497381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1909094,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/21/66/85f247e2.jpg","nickname":"谢作作的男人","note":"","ucode":"4F220EA8AEBFB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287853,"discussion_content":"Leval是一个聚合，不是一个实体","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593568983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173744,"user_name":"若水","can_delete":false,"product_type":"c1","uid":1303418,"ip_address":"","ucode":"575F2A2F579B0B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKeqZb7U4s6SZHXz1Vv2u8iaHibZeZ9Ndgibr2nT9BS6Z4wiao3j8Ya5O8FK1SnxxyagDjvsMYaauWficA/132","comment_is_top":false,"comment_ctime":1579676103,"is_pvip":false,"replies":[{"id":"67330","content":"一般对于有查询和统计要求的值对象，不建议做成json串存储。其实如果这部分数据在处理后，加载到数据平台，也不影响查询使用。这类值对象的修改需要对应的前端操作，所以其它地方修改并不会修改值对象的值，这也是一种正常的需求，它记录业务发生那一刻的数据快照，不会因为外部数据修改而导致无法记录业务产生那一刻的真实数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579678497,"ip_address":"","comment_id":173744,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579676103","product_id":100037301,"comment_content":"老师您好，这样 设计一个组合属性字段，以 Json 串的方式存储在 PO，会存在如下两个问题。①、数据修改，对应记录值不会修改。 ②、这样设计一个大字段存储，引发数据库查询的效率问题。    这两个问题您是怎么看待呢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482191,"discussion_content":"一般对于有查询和统计要求的值对象，不建议做成json串存储。其实如果这部分数据在处理后，加载到数据平台，也不影响查询使用。这类值对象的修改需要对应的前端操作，所以其它地方修改并不会修改值对象的值，这也是一种正常的需求，它记录业务发生那一刻的数据快照，不会因为外部数据修改而导致无法记录业务产生那一刻的真实数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579678497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172391,"user_name":"focus","can_delete":false,"product_type":"c1","uid":1203469,"ip_address":"","ucode":"8F8E958E1F55C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/0d/9a7e588c.jpg","comment_is_top":false,"comment_ctime":1579167187,"is_pvip":false,"replies":[{"id":"66937","content":"是的。这种主要是处理微服务内部不同聚合之间的领域事件。主要是因为在处理新增和修改数据的时候，一个操作是对一个聚合整理的数据进行操作的。这样可以避免聚合之间的数据不一致的情况。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579241431,"ip_address":"","comment_id":172391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579167187","product_id":100037301,"comment_content":"如果是内部事件，与外部服务无关，还需要定义listener，publish发布的是内部事件；这样可以用事件总线，借助guava中的EventBus来实现是吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481724,"discussion_content":"是的。这种主要是处理微服务内部不同聚合之间的领域事件。主要是因为在处理新增和修改数据的时候，一个操作是对一个聚合整理的数据进行操作的。这样可以避免聚合之间的数据不一致的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579241431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172051,"user_name":"切糕","can_delete":false,"product_type":"c1","uid":1185409,"ip_address":"","ucode":"DCD3C14CAC4ED3","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/81/77f84354.jpg","comment_is_top":false,"comment_ctime":1579079533,"is_pvip":false,"replies":[{"id":"66980","content":"我建议你再设计两个聚合：渠道和人员（暂且叫人员吧，你可以根据你的业务场景来命名）聚合。人员聚合主要提供人员的新增和修改，而这个人员数据可以被订单或账单聚合以值对象的方式来引用，在值对象引用时你可以根据业务类型将人员设置为收款人或者付款人。这样人员信息可以在人员聚合集中维护，它可以同时被多个其它的聚合以值对象的形式整体引用。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579251779,"ip_address":"","comment_id":172051,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579079533","product_id":100037301,"comment_content":"老师，您好！我们这边有个比较怪异的场景，想请教下老师：<br>背景介绍：我们主要是做分期账单的业务，整体分为两部分，一部分是订单、一部分是账单。订单中包含渠道、收款人、付款人信息，而这些信息因渠道侧不同字段会有很大差异。后面的账单基本是根据订单生成的，初始账单的“渠道、收款人、付款人”信息是一致的，但后续账单可能会变更收款人信息。<br>目前状况：我们把订单、账单分成两个聚合，这个时候“渠道、收款人、付款人”通过抽象ID维护在订单聚合，但是账单这边也需要“渠道、收款人、付款人”实体，这个时候复用好像又不太对，因为这个实体在订单聚合内，账单聚合操作依赖订单聚合中的实体，感觉很怪。<br>个人见解：<br>1.订单的生命周期主要是为了生成账单，一但账单生成订单的生命周期结束，所以订单中的“渠道、收款人、付款人”以值对象JSON存储下来，而不同渠道的字段不一样，在和不同渠道业务交互的规则中去处理。<br>2.账单聚合中维护“渠道、收款人、付款人”实体对象，因存在变更收款人操作等操作，所以收款人比较适合做实体，而渠道和付款人信息应该是和收款人属于同一级别，所以都认为是实体。<br><br>对这一块还是比较疑惑，希望老师能给些建议。<br><br><br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481604,"discussion_content":"我建议你再设计两个聚合：渠道和人员（暂且叫人员吧，你可以根据你的业务场景来命名）聚合。人员聚合主要提供人员的新增和修改，而这个人员数据可以被订单或账单聚合以值对象的方式来引用，在值对象引用时你可以根据业务类型将人员设置为收款人或者付款人。这样人员信息可以在人员聚合集中维护，它可以同时被多个其它的聚合以值对象的形式整体引用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579251779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171366,"user_name":"Geek_74f563","can_delete":false,"product_type":"c1","uid":1604552,"ip_address":"","ucode":"3821AE3703F1DB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoV7kTQGEFG1wD78a8Y2HNMEoWnuxEJaH3CGrGftzh1vAicrFWsmia4qekZSuuWVh9DjF6mWMGicWhhw/132","comment_is_top":false,"comment_ctime":1578909311,"is_pvip":false,"replies":[{"id":"66528","content":"JPA可以自动创建的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578983307,"ip_address":"","comment_id":171366,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578909311","product_id":100037301,"comment_content":"老师可以把数据库表结构的脚本上传上去吗？ 哈哈","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481318,"discussion_content":"JPA可以自动创建的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578983307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171214,"user_name":"uangguan","can_delete":false,"product_type":"c1","uid":1009220,"ip_address":"","ucode":"6FEDC33B452D4B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/44/f8032c04.jpg","comment_is_top":false,"comment_ctime":1578882608,"is_pvip":false,"replies":[{"id":"66540","content":"你这个想法挺好的。基础层的对象是可以为所有层提供服务的，把PO拿出来主要还是希望将DO和PO的转换统一放在工厂服务中。如果用leave的DO对象做完save的参数，在save仓储实现内，一样还是需要转换的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578984478,"ip_address":"","comment_id":171214,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578882608","product_id":100037301,"comment_content":"老师，LeaveRepositoryInterface接口的save方法，为什么传入的是LeavePO而不是Leave？在LeaveDomainService层里直接调用LeaveRepositoryInterface.save(Leave leave)保存领域实体不是更合理吗？这样在LeaveDomainService层就不需要知道LeavePO的存在了。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481264,"discussion_content":"你这个想法挺好的。基础层的对象是可以为所有层提供服务的，把PO拿出来主要还是希望将DO和PO的转换统一放在工厂服务中。如果用leave的DO对象做完save的参数，在save仓储实现内，一样还是需要转换的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578984478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170916,"user_name":"宋承展","can_delete":false,"product_type":"c1","uid":1028939,"ip_address":"","ucode":"2F463065524523","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/4b/68cc354f.jpg","comment_is_top":false,"comment_ctime":1578757118,"is_pvip":false,"replies":[{"id":"66532","content":"复杂的查询可以不走领域层，你可以定义一个查询应用服务，按照传统三层架构分页查询方式就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578983807,"ip_address":"","comment_id":170916,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578757118","product_id":100037301,"comment_content":"老师好，请教一下在查询列表这种交易中，一般我们会返回翻页通信区给前端，这个翻页通信区，一般放在哪一层的。。。我看在领域服务层里，都是只是返回了实体的list，对于这种翻页通信区，没说明，能否指导一下？谢谢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481163,"discussion_content":"复杂的查询可以不走领域层，你可以定义一个查询应用服务，按照传统三层架构分页查询方式就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578983807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170662,"user_name":"SpEcIAL_ID","can_delete":false,"product_type":"c1","uid":1049630,"ip_address":"","ucode":"74AAE133D3D9BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/1e/8f75595d.jpg","comment_is_top":false,"comment_ctime":1578656910,"is_pvip":false,"replies":[{"id":"66543","content":"过来人😀。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578984590,"ip_address":"","comment_id":170662,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578656910","product_id":100037301,"comment_content":"赞赞赞，很多共鸣，👍🏻👍🏻👍🏻👍🏻","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481060,"discussion_content":"过来人😀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578984590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170161,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1578540814,"is_pvip":false,"replies":[{"id":"66023","content":"实体是DO的一种呀。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578554799,"ip_address":"","comment_id":170161,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578540814","product_id":100037301,"comment_content":"老师，你之前的章节说接口层到应用层参数的转换是dto转do的，但现在看代码怎么是dto直接转实体传给应用层的","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480863,"discussion_content":"实体是DO的一种呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578554799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169493,"user_name":"TopTop","can_delete":false,"product_type":"c1","uid":1201101,"ip_address":"","ucode":"FFC8CAC662A83B","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/cd/e344985b.jpg","comment_is_top":false,"comment_ctime":1578365545,"is_pvip":false,"replies":[{"id":"65759","content":"这个确实有一定的聚合耦合度。但是考虑到如果person和leave聚合拆分，我们还会增加一个person的DTO对象来接受从person返回的对象。如果两者结构能保持一致，拆分后fromPerson也是不需要做出代码调整的。所以为了不增加代码的复杂度，没有考虑这种返回类型的对象解耦。这种转换放应用层也是可以的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578385586,"ip_address":"","comment_id":169493,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1578365545","product_id":100037301,"comment_content":"老师：聚合leave中Apprever中的fromPerson（Person person)这个方法是不是和person聚会耦合了？把这个转换放在应用层是否是更合适？<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480582,"discussion_content":"这个确实有一定的聚合耦合度。但是考虑到如果person和leave聚合拆分，我们还会增加一个person的DTO对象来接受从person返回的对象。如果两者结构能保持一致，拆分后fromPerson也是不需要做出代码调整的。所以为了不增加代码的复杂度，没有考虑这种返回类型的对象解耦。这种转换放应用层也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578385586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123048,"discussion_content":"我也赞同放在应用层去转换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578388249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169476,"user_name":"snailiu","can_delete":false,"product_type":"c1","uid":1603098,"ip_address":"","ucode":"E635FB99C52F08","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZAIgA0XY4aSOrFiaERYJ5mfknCPCv3tuTHR26Id4nwZI6NEpThsiar3ssNmJcGdB9JDnic9NlFjU7A/132","comment_is_top":false,"comment_ctime":1578362238,"is_pvip":false,"replies":[{"id":"65760","content":"这两个服务本质上是根据申请人找出人员的上级关系，它就是人员组织关系的业务职能的呀。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578385879,"ip_address":"","comment_id":169476,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578362238","product_id":100037301,"comment_content":"感觉`PersonDomainService`中的`findNextApprover`和`findFirstApprover`有点不妥，Approver是Leave聚合中的概念，而不是Person聚合中的概念，从两个函数的具体实现来看，也和Approver没有关系，而只是根据personId和maxLeaderLevel获取Person对象。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480572,"discussion_content":"这两个服务本质上是根据申请人找出人员的上级关系，它就是人员组织关系的业务职能的呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578385879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169354,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1578321296,"is_pvip":false,"replies":[{"id":"65762","content":"可否具体说一下是那个地方？","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578386261,"ip_address":"","comment_id":169354,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578321296","product_id":100037301,"comment_content":"欧老师， 源码里是在domainservice依赖注入仓储，而文章里是通过实体注入仓储对象，不一致～","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480522,"discussion_content":"可否具体说一下是那个地方？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578386261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169121,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1578277501,"is_pvip":false,"replies":[{"id":"65757","content":"感谢提醒，已补充。<br>   <br> public void save(LeavePO leavePO) {<br>        &#47;&#47;persist leave entity<br>        leaveDao.save(leavePO);<br>        &#47;&#47;set leave_id for approvalInfoPO after save leavePO<br>        leavePO.getHistoryApprovalInfoPOList().stream().forEach(approvalInfoPO -&gt; approvalInfoPO.setLeaveId(leavePO.getId()));<br>        approvalInfoDao.saveAll(leavePO.getHistoryApprovalInfoPOList());<br>    }","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578385068,"ip_address":"","comment_id":169121,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578277501","product_id":100037301,"comment_content":"我看了github上的代码，有点问题，对于LeavePO和List《ApprovalInfoPO》这样的一对多关联持久化问题。代码中没有看到approvqlInfoPO.setLeaveId（），因为必须先保存LeavePO才会有leaveId。因此持久化Leave操作不能简单使用LeaveRepositoryImpl.save方法","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480430,"discussion_content":"感谢提醒，已补充。\n   \n public void save(LeavePO leavePO) {\n        //persist leave entity\n        leaveDao.save(leavePO);\n        //set leave_id for approvalInfoPO after save leavePO\n        leavePO.getHistoryApprovalInfoPOList().stream().forEach(approvalInfoPO -&amp;gt; approvalInfoPO.setLeaveId(leavePO.getId()));\n        approvalInfoDao.saveAll(leavePO.getHistoryApprovalInfoPOList());\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578385068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168231,"user_name":"hk","can_delete":false,"product_type":"c1","uid":1057377,"ip_address":"","ucode":"92996CA0BCDD66","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/61/580bb3c3.jpg","comment_is_top":false,"comment_ctime":1578035142,"is_pvip":false,"replies":[{"id":"65328","content":"看你用什么样的持久化组件。有的可以根据PO自动创建。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578050236,"ip_address":"","comment_id":168231,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1578035142","product_id":100037301,"comment_content":"老师你好，问个小白问题：创表SQL需要我们自己生成出来是么？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480168,"discussion_content":"看你用什么样的持久化组件。有的可以根据PO自动创建。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578050236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144725,"avatar":"https://static001.geekbang.org/account/avatar/00/11/77/95/9d32e68c.jpg","nickname":"风絮1994","note":"","ucode":"FEB562DECA5E77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218168,"discussion_content":"老师有创建表的sql吗？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585627626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168106,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1578014327,"is_pvip":false,"replies":[{"id":"65286","content":"因为聚合数据要作为整体来修改和创建，持久化的工作统一放到工厂服务里去实现了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578020888,"ip_address":"","comment_id":168106,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578014327","product_id":100037301,"comment_content":"老师为什么我看代码里面Leave这个实体类没采用直接依赖仓储层的方式呢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480139,"discussion_content":"因为聚合数据要作为整体来修改和创建，持久化的工作统一放到工厂服务里去实现了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578020888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168057,"user_name":"y3","can_delete":false,"product_type":"c1","uid":1128084,"ip_address":"","ucode":"C93F8EC2AAACF6","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/94/5aecb0ef.jpg","comment_is_top":false,"comment_ctime":1578009127,"is_pvip":false,"replies":[{"id":"65300","content":"😄，久等了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578029736,"ip_address":"","comment_id":168057,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578009127","product_id":100037301,"comment_content":"期待已久的ddd demo项目终于出炉了，感谢欧老师！😄","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480122,"discussion_content":"😄，久等了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578029736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168017,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1577977312,"is_pvip":true,"replies":[{"id":"65303","content":"是的，DDD不是一个人的事情。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578031638,"ip_address":"","comment_id":168017,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577977312","product_id":100037301,"comment_content":"感谢老师的长篇分享，对其中一句深表赞同，不自觉的调用其他聚合的东西，不自觉有两种，一种是老师说的图一时快，另一种比较难受，就是不知道ddd或者固执己见，达不成一致，统一思想开发风格很重要！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480100,"discussion_content":"是的，DDD不是一个人的事情。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578031638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167945,"user_name":"和光同尘","can_delete":false,"product_type":"c1","uid":1595467,"ip_address":"","ucode":"A3195757E45CD5","user_header":"https://static001.geekbang.org/account/avatar/00/18/58/4b/8b044dd3.jpg","comment_is_top":false,"comment_ctime":1577967333,"is_pvip":false,"replies":[{"id":"65289","content":"可以基于源端持久化和目的端持久化数据来比对，发现异常数据。处理方式有很多，发现问题后可以重传或者人工处理。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578021033,"ip_address":"","comment_id":167945,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577967333","product_id":100037301,"comment_content":"请问数据对账机制，是如何知道有数据缺损，不一致的？再者，发现不一致的数据如何纠正。3Q","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480062,"discussion_content":"可以基于源端持久化和目的端持久化数据来比对，发现异常数据。处理方式有很多，发现问题后可以重传或者人工处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578021033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167922,"user_name":"深山小书童","can_delete":false,"product_type":"c1","uid":1079593,"ip_address":"","ucode":"6B5DD3B3D84534","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/29/a90cf777.jpg","comment_is_top":false,"comment_ctime":1577963570,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577963570","product_id":100037301,"comment_content":"终于等到了，欧老师威武","like_count":0},{"had_liked":false,"id":167915,"user_name":"二康","can_delete":false,"product_type":"c1","uid":1097497,"ip_address":"","ucode":"45E85D80DE4544","user_header":"https://static001.geekbang.org/account/avatar/00/10/bf/19/24cc3e7c.jpg","comment_is_top":false,"comment_ctime":1577962869,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577962869","product_id":100037301,"comment_content":"谢谢老师","like_count":0},{"had_liked":false,"id":167908,"user_name":"阿神","can_delete":false,"product_type":"c1","uid":1014761,"ip_address":"","ucode":"E34BA27C101E9F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/e9/5955aa73.jpg","comment_is_top":false,"comment_ctime":1577961072,"is_pvip":false,"replies":[{"id":"65306","content":"谢谢😄","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578032461,"ip_address":"","comment_id":167908,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577961072","product_id":100037301,"comment_content":"代码简洁易懂，很赞","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480051,"discussion_content":"谢谢😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578032461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}