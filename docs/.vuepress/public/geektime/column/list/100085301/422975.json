{"id":422975,"title":"16｜数据结构：Vec<T>、&[T]、Box<[T]> ，你真的了解集合容器么？","content":"<p>你好，我是陈天。今天来学集合容器。</p><p>现在我们接触到了越来越多的数据结构，我把 Rust 中主要的数据结构从原生类型、容器类型和系统相关类型几个维度整理一下，你可以数数自己掌握了哪些。<br>\n<img src=\"https://static001.geekbang.org/resource/image/d9/4c/d9c1d7ce878b5ef17eb1c8c69e17404c.jpg?wh=2364x1718\" alt=\"\"><br>\n可以看到，容器占据了数据结构的半壁江山。</p><p>提到容器，很可能你首先会想到的就是数组、列表这些可以遍历的容器，但其实<strong>只要把某种特定的数据封装在某个数据结构中</strong>，这个数据结构就是一个容器。比如 Option&lt;T&gt;，它是一个包裹了 T 存在或不存在的容器，而Cow 是一个封装了内部数据 B 或被借用或拥有所有权的容器。</p><p>对于容器的两小类，到目前为止，像 Cow 这样，为特定目的而产生的容器我们已经介绍了不少，包括 Box、Rc、Arc、RefCell、还没讲到的 Option 和 Result 等。</p><p>今天我们来详细讲讲另一类，集合容器。</p><h2>集合容器</h2><p>集合容器，顾名思义，就是把一系列拥有相同类型的数据放在一起，统一处理，比如：</p><ul>\n<li>我们熟悉的字符串 String、数组 [T; n]、列表 Vec&lt;T&gt;和哈希表 HashMap&lt;K, V&gt;等；</li>\n<li>虽然到处在使用，但还并不熟悉的切片 slice；</li>\n<li>在其他语言中使用过，但在 Rust 中还没有用过的循环缓冲区 VecDeque&lt;T&gt;、双向列表 LinkedList&lt;T&gt; 等。</li>\n</ul><!-- [[[read_end]]] --><p>这些集合容器有很多共性，比如可以被遍历、可以进行 map-reduce 操作、可以从一种类型转换成另一种类型等等。</p><p>我们会选取两类典型的集合容器：切片和哈希表，深入解读，理解了这两类容器，其它的集合容器设计思路都差不多，并不难学习。今天先介绍切片以及和切片相关的容器，下一讲我们学习哈希表。</p><h2>切片究竟是什么？</h2><p>在 Rust 里，切片是描述一组属于同一类型、长度不确定的、在内存中连续存放的数据结构，用 [T] 来表述。因为长度不确定，所以切片是个 DST（Dynamically Sized Type）。</p><p>切片一般只出现在数据结构的定义中，不能直接访问，在使用中主要用以下形式：</p><ul>\n<li>&amp;[T]：表示一个只读的切片引用。</li>\n<li>&amp;mut [T]：表示一个可写的切片引用。</li>\n<li>Box&lt;[T]&gt;：一个在堆上分配的切片。</li>\n</ul><p>怎么理解切片呢？我打个比方，<strong>切片之于具体的数据结构，就像数据库中的视图之于表</strong>。你可以把它看成一种工具，让我们可以统一访问行为相同、结构类似但有些许差异的类型。</p><p>来看下面的<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=73d5c0dd98f17a31a8e9bf914eb5ea2f\">代码</a>，辅助理解：</p><pre><code class=\"language-rust\">fn main() {\n    let arr = [1, 2, 3, 4, 5];\n    let vec = vec![1, 2, 3, 4, 5];\n    let s1 = &amp;arr[..2];\n    let s2 = &amp;vec[..2];\n    println!(\"s1: {:?}, s2: {:?}\", s1, s2);\n\n    // &amp;[T] 和 &amp;[T] 是否相等取决于长度和内容是否相等\n    assert_eq!(s1, s2);\n    // &amp;[T] 可以和 Vec&lt;T&gt;/[T;n] 比较，也会看长度和内容\n    assert_eq!(&amp;arr[..], vec);\n    assert_eq!(&amp;vec[..], arr);\n}\n</code></pre><p>对于 array 和 vector，虽然是不同的数据结构，一个放在栈上，一个放在堆上，但它们的切片是类似的；而且对于相同内容数据的相同切片，比如 &amp;arr[1…3] 和 &amp;vec[1…3]，这两者是等价的。除此之外，切片和对应的数据结构也可以直接比较，这是因为它们之间实现了 PartialEq trait（<a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-PartialEq%3C%26%27_%20%5BU%5D%3E\">源码参考资料</a>）。</p><p>下图比较清晰地呈现了切片和数据之间的关系：<img src=\"https://static001.geekbang.org/resource/image/79/b2/798cd47df85772e243b6af4ba17f18b2.jpg?wh=2364x1422\" alt=\"\"></p><p>另外在 Rust 下，切片日常中都是使用引用 &amp;[T]，所以很多同学容易搞不清楚 &amp;[T] 和 &amp;Vec&lt;T&gt; 的区别。我画了张图，帮助你更好地理解它们的关系：<img src=\"https://static001.geekbang.org/resource/image/91/b7/91b4f63c619bf35cf2e5fc22c6d486b7.jpg?wh=2364x1422\" alt=\"\"></p><p>在使用的时候，支持切片的具体数据类型，你可以根据需要，解引用转换成切片类型。比如 Vec&lt;T&gt; 和 [T; n] 会转化成为 &amp;[T]，这是因为 Vec&lt;T&gt; 实现了 Deref trait，而 array 内建了到 &amp;[T] 的解引用。我们可以写一段代码验证这一行为（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=984d9ee43c82f3774798f16c9176761e\">代码</a>）：</p><pre><code class=\"language-rust\">use std::fmt;\nfn main() {\n    let v = vec![1, 2, 3, 4];\n\n    // Vec 实现了 Deref，&amp;Vec&lt;T&gt; 会被自动解引用为 &amp;[T]，符合接口定义\n    print_slice(&amp;v);\n    // 直接是 &amp;[T]，符合接口定义\n    print_slice(&amp;v[..]);\n\n    // &amp;Vec&lt;T&gt; 支持 AsRef&lt;[T]&gt;\n    print_slice1(&amp;v);\n    // &amp;[T] 支持 AsRef&lt;[T]&gt;\n    print_slice1(&amp;v[..]);\n    // Vec&lt;T&gt; 也支持 AsRef&lt;[T]&gt;\n    print_slice1(v);\n\n    let arr = [1, 2, 3, 4];\n    // 数组虽没有实现 Deref，但它的解引用就是 &amp;[T]\n    print_slice(&amp;arr);\n    print_slice(&amp;arr[..]);\n    print_slice1(&amp;arr);\n    print_slice1(&amp;arr[..]);\n    print_slice1(arr);\n}\n\n// 注意下面的泛型函数的使用\nfn print_slice&lt;T: fmt::Debug&gt;(s: &amp;[T]) {\n    println!(\"{:?}\", s);\n}\n\nfn print_slice1&lt;T, U&gt;(s: T)\nwhere\n    T: AsRef&lt;[U]&gt;,\n    U: fmt::Debug,\n{\n    println!(\"{:?}\", s.as_ref());\n}\n</code></pre><p>这也就意味着，通过解引用，这几个和切片有关的数据结构都会获得切片的所有能力，包括：binary_search、chunks、concat、contains、start_with、end_with、group_by、iter、join、sort、split、swap 等一系列丰富的功能，感兴趣的同学可以看<a href=\"https://doc.rust-lang.org/std/primitive.slice.html\">切片的文档</a>。</p><h2>切片和迭代器 Iterator</h2><p>迭代器可以说是切片的孪生兄弟。<strong>切片是集合数据的视图，而迭代器定义了对集合数据的各种各样的访问操作</strong>。</p><p>通过切片的 <a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.iter\">iter() 方法</a>，我们可以生成一个迭代器，对切片进行迭代。</p><p>在<a href=\"https://time.geekbang.org/column/article/420021\">第12讲</a>Rust类型推导已经见过了 iterator trait（用 <code>collect</code> 方法把过滤出来的数据形成新列表）。iterator trait 有大量的方法，但绝大多数情况下，我们只需要定义它的关联类型 Item 和 next() 方法。</p><ul>\n<li>Item 定义了每次我们从迭代器中取出的数据类型；</li>\n<li>next() 是从迭代器里取下一个值的方法。当一个迭代器的 next() 方法返回 None 时，表明迭代器中没有数据了。</li>\n</ul><pre><code class=\"language-rust\">#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub trait Iterator {\n    type Item;\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n    // 大量缺省的方法，包括 size_hint, count, chain, zip, map, \n    // filter, for_each, skip, take_while, flat_map, flatten\n    // collect, partition 等\n\t\t... \n}\n</code></pre><p>看一个例子，对 Vec&lt;T&gt; 使用 iter() 方法，并进行各种 map / filter / take 操作。在函数式编程语言中，这样的写法很常见，代码的可读性很强。Rust 也支持这种写法（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=64917cb8aae8e8476a8fdf21c81d6810\">代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    // 这里 Vec&lt;T&gt; 在调用 iter() 时被解引用成 &amp;[T]，所以可以访问 iter()\n    let result = vec![1, 2, 3, 4]\n        .iter()\n        .map(|v| v * v)\n        .filter(|v| *v &lt; 16)\n        .take(1)\n        .collect::&lt;Vec&lt;_&gt;&gt;();\n\n    println!(\"{:?}\", result);\n}\n</code></pre><p>需要注意的是 Rust 下的迭代器是个懒接口（lazy interface），也就是说<strong>这段代码直到运行到 collect 时才真正开始执行，之前的部分不过是在不断地生成新的结构</strong>，来累积处理逻辑而已。你可能好奇，这是怎么做到的呢？</p><p>在 VS Code 里，如果你使用了 rust-analyzer 插件，就可以发现这一奥秘：<br>\n<img src=\"https://static001.geekbang.org/resource/image/49/3b/49b8692d2b03df66c0e4e02390a4153b.png?wh=1658x582\" alt=\"\"></p><p>原来，Iterator 大部分方法都返回一个实现了 Iterator 的数据结构，所以可以这样一路链式下去，在 Rust 标准库中，这些数据结构被称为 <a href=\"https://doc.rust-lang.org/src/core/iter/adapters/mod.rs.html\">Iterator Adapter</a>。比如上面的 map 方法，它返回 Map 结构，而 Map 结构实现了 Iterator（<a href=\"https://doc.rust-lang.org/src/core/iter/adapters/map.rs.html#93-133\">源码</a>）。</p><p>整个过程是这样的（链接均为源码资料）：</p><ul>\n<li>在 collect() 执行的时候，它实际<a href=\"https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#1744-1749\">试图使用 FromIterator 从迭代器中构建一个集合类型</a>，这会不断调用 next() 获取下一个数据；</li>\n<li>此时的 Iterator 是 Take，Take 调自己的 next()，也就是它会<a href=\"https://doc.rust-lang.org/src/core/iter/adapters/take.rs.html#34-41\">调用 Filter 的 next()</a>；</li>\n<li>Filter 的 next() 实际上<a href=\"https://doc.rust-lang.org/src/core/iter/adapters/filter.rs.html#55-57\">调用自己内部的 iter 的 find()</a>，此时内部的 iter 是 Map，find() 会<a href=\"https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2312-2325\">使用 try_fold()</a>，它会<a href=\"https://doc.rust-lang.org/src/core/iter/traits/iterator.rs.html#2382-2406\">继续调用 next()</a>，也就是 Map 的 next()；</li>\n<li>Map 的 next() 会<a href=\"https://doc.rust-lang.org/src/core/iter/adapters/map.rs.html#100-102\">调用其内部的 iter 取 next() 然后执行 map 函数</a>。而此时内部的 iter 来自 Vec&lt;i32&gt;。</li>\n</ul><p>所以，只有在 collect() 时，才触发代码一层层调用下去，并且调用会根据需要随时结束。这段代码中我们使用了 take(1)，整个调用链循环一次，就能满足 take(1) 以及所有中间过程的要求，所以它只会循环一次。</p><p>你可能会有疑惑：这种函数式编程的写法，代码是漂亮了，然而这么多无谓的函数调用，性能肯定很差吧？毕竟，函数式编程语言的一大恶名就是性能差。</p><p>这个你完全不用担心， Rust 大量使用了 inline 等优化技巧，这样非常清晰友好的表达方式，性能和 C 语言的 for 循环差别不大。如果你对性能对比感兴趣，可以去最后的参考资料区看看。</p><p>介绍完是什么，按惯例我们就要上代码实际使用一下了。不过迭代器是非常重要的一个功能，基本上每种语言都有对迭代器的完整支持，所以只要你之前用过，对此应该并不陌生，大部分的方法，你一看就能明白是在做什么。所以这里就不再额外展示，等你遇到具体需求时，可以翻 <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\">Iterator 的文档</a>查阅。</p><p>如果标准库中的功能还不能满足你的需求，你可以看看 <a href=\"https://docs.rs/itertools/0.10.1/itertools/trait.Itertools.html\">itertools</a>，它是和 Python 下 itertools 同名且功能类似的工具，提供了大量额外的 adapter。可以看一个简单的例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b32253334d886a5ccd263f9870fb8a3d\">代码</a>）：</p><pre><code class=\"language-rust\">use itertools::Itertools;\n\nfn main() {\n    let err_str = \"bad happened\";\n    let input = vec![Ok(21), Err(err_str), Ok(7)];\n    let it = input\n        .into_iter()\n        .filter_map_ok(|i| if i &gt; 10 { Some(i * 2) } else { None });\n    // 结果应该是：vec![Ok(42), Err(err_str)]\n    println!(\"{:?}\", it.collect::&lt;Vec&lt;_&gt;&gt;());\n}\n</code></pre><p>在实际开发中，我们可能从一组 Future 中汇聚出一组结果，里面有成功执行的结果，也有失败的错误信息。如果想对成功的结果进一步做 filter/map，那么标准库就无法帮忙了，就需要用 itertools 里的 filter_map_ok()。</p><h2>特殊的切片：&amp;str</h2><p>好，学完了普通的切片 &amp;[T]，我们来看一种特殊的切片：&amp;str。之前讲过，String 是一个特殊的 Vec&lt;u8&gt;，所以在 String 上做切片，也是一个特殊的结构 &amp;str。</p><p>对于 String、&amp;String、&amp;str，很多人也经常分不清它们的区别，我们在之前的一篇加餐中简单聊了这个问题，在上一讲智能指针中，也对比过String和&amp;str。对于&amp;String 和 &amp;str，如果你理解了上文中 &amp;Vec&lt;T&gt; 和 &amp;[T] 的区别，那么它们也是一样的：<img src=\"https://static001.geekbang.org/resource/image/ea/0a/ea816d6fbdd1d14b00bb6ea6c7ef3a0a.jpg?wh=2364x1422\" alt=\"\"></p><p><strong>String 在解引用时，会转换成 &amp;str</strong>。可以用下面的代码验证（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fc4ceb67d2da2e99e11c390f4ce6317d\">代码</a>）：</p><pre><code class=\"language-rust\">use std::fmt;\nfn main() {\n    let s = String::from(\"hello\");\n    // &amp;String 会被解引用成 &amp;str\n    print_slice(&amp;s);\n    // &amp;s[..] 和 s.as_str() 一样，都会得到 &amp;str\n    print_slice(&amp;s[..]);\n\n    // String 支持 AsRef&lt;str&gt;\n    print_slice1(&amp;s);\n    print_slice1(&amp;s[..]);\n    print_slice1(s.clone());\n\n    // String 也实现了 AsRef&lt;[u8]&gt;，所以下面的代码成立\n    // 打印出来是 [104, 101, 108, 108, 111]\n    print_slice2(&amp;s);\n    print_slice2(&amp;s[..]);\n    print_slice2(s);\n}\n\nfn print_slice(s: &amp;str) {\n    println!(\"{:?}\", s);\n}\n\nfn print_slice1&lt;T: AsRef&lt;str&gt;&gt;(s: T) {\n    println!(\"{:?}\", s.as_ref());\n}\n\nfn print_slice2&lt;T, U&gt;(s: T)\nwhere\n    T: AsRef&lt;[U]&gt;,\n    U: fmt::Debug,\n{\n    println!(\"{:?}\", s.as_ref());\n}\n</code></pre><p>有同学会有疑问：那么字符的列表和字符串有什么关系和区别？我们直接写一段代码来看看：</p><pre><code class=\"language-rust\">use std::iter::FromIterator;\n\nfn main() {\n    let arr = ['h', 'e', 'l', 'l', 'o'];\n    let vec = vec!['h', 'e', 'l', 'l', 'o'];\n    let s = String::from(\"hello\");\n    let s1 = &amp;arr[1..3];\n    let s2 = &amp;vec[1..3];\n    // &amp;str 本身就是一个特殊的 slice\n    let s3 = &amp;s[1..3];\n    println!(\"s1: {:?}, s2: {:?}, s3: {:?}\", s1, s2, s3);\n\n    // &amp;[char] 和 &amp;[char] 是否相等取决于长度和内容是否相等\n    assert_eq!(s1, s2);\n    // &amp;[char] 和 &amp;str 不能直接对比，我们把 s3 变成 Vec&lt;char&gt;\n    assert_eq!(s2, s3.chars().collect::&lt;Vec&lt;_&gt;&gt;());\n    // &amp;[char] 可以通过迭代器转换成 String，String 和 &amp;str 可以直接对比\n    assert_eq!(String::from_iter(s2), s3);\n}\n</code></pre><p>可以看到，字符列表可以通过迭代器转换成 String，String 也可以通过 chars() 函数转换成字符列表，如果不转换，二者不能比较。</p><p>下图我把数组、列表、字符串以及它们的切片放在一起比较，可以帮你更好地理解它们的区别：<img src=\"https://static001.geekbang.org/resource/image/e0/93/e05210d20yy4d20bf54e670e958a7a93.jpg?wh=2364x1422\" alt=\"\"></p><h2>切片的引用和堆上的切片，它们是一回事么？</h2><p>开头我们讲过，切片主要有三种使用方式：切片的只读引用 &amp;[T]、切片的可变引用 &amp;mut [T] 以及 Box&lt;[T]&gt;。刚才已经详细学习了只读切片 &amp;[T]，也和其他各种数据结构进行了对比帮助理解，可变切片 &amp;mut [T] 和它类似，不必介绍。</p><p>现在我们来看看 Box&lt;[T]&gt;。</p><p>Box&lt;[T]&gt; 是一个比较有意思的存在，它和 Vec&lt;T&gt; 有一点点差别：Vec&lt;T&gt; 有额外的 capacity，可以增长；<strong>而 Box&lt;[T]&gt; 一旦生成就固定下来，没有 capacity，也无法增长</strong>。</p><p>Box&lt;[T]&gt;和切片的引用&amp;[T] 也很类似：它们都是在栈上有一个包含长度的胖指针，指向存储数据的内存位置。区别是：Box&lt;[T]&gt; 只会指向堆，&amp;[T] 指向的位置可以是栈也可以是堆；此外，Box&lt;[T]&gt; 对数据具有所有权，而 &amp;[T] 只是一个借用。<img src=\"https://static001.geekbang.org/resource/image/a1/eb/a12b61b5e70a9a4625c071576f0717eb.jpg?wh=2364x1532\" alt=\"\"></p><p>那么如何产生 Box&lt;[T]&gt; 呢？目前可用的接口就只有一个：从已有的 Vec&lt;T&gt; 中转换。我们看代码：</p><pre><code class=\"language-rust\">use std::ops::Deref;\n\nfn main() {\n    let mut v1 = vec![1, 2, 3, 4];\n    v1.push(5);\n    println!(\"cap should be 8: {}\", v1.capacity());\n\n    // 从 Vec&lt;T&gt; 转换成 Box&lt;[T]&gt;，此时会丢弃多余的 capacity\n    let b1 = v1.into_boxed_slice();\n    let mut b2 = b1.clone();\n\n    let v2 = b1.into_vec();\n    println!(\"cap should be exactly 5: {}\", v2.capacity());\n\n    assert!(b2.deref() == v2);\n\n    // Box&lt;[T]&gt; 可以更改其内部数据，但无法 push\n    b2[0] = 2;\n    // b2.push(6);\n    println!(\"b2: {:?}\", b2);\n\n    // 注意 Box&lt;[T]&gt; 和 Box&lt;[T; n]&gt; 并不相同\n    let b3 = Box::new([2, 2, 3, 4, 5]);\n    println!(\"b3: {:?}\", b3);\n\n    // b2 和 b3 相等，但 b3.deref() 和 v2 无法比较\n    assert!(b2 == b3);\n    // assert!(b3.deref() == v2);\n}\n</code></pre><p>运行代码可以看到，Vec&lt;T&gt; 可以通过 into_boxed_slice() 转换成 Box&lt;[T]&gt;，Box&lt;[T]&gt; 也可以通过 into_vec() 转换回 Vec&lt;T&gt;。</p><p>这两个转换都是很轻量的转换，只是变换一下结构，不涉及数据的拷贝。区别是，当 Vec&lt;T&gt; 转换成 Box&lt;[T]&gt; 时，没有使用到的容量就会被丢弃，所以整体占用的内存可能会降低。而且Box&lt;[T]&gt; 有一个很好的特性是，不像 Box&lt;[T;n]&gt; 那样在编译时就要确定大小，它可以在运行期生成，以后大小不会再改变。</p><p>所以，<strong>当我们需要在堆上创建固定大小的集合数据，且不希望自动增长，那么，可以先创建 Vec&lt;T&gt;，再转换成 Box&lt;[T]&gt;</strong>。tokio 在提供 broadcast channel 时，就使用了 Box&lt;[T]&gt; 这个特性，你感兴趣的话，可以自己看看<a href=\"https://github.com/tokio-rs/tokio/blob/master/tokio/src/sync/broadcast.rs#L447\">源码</a>。</p><h2>小结</h2><p>我们讨论了切片以及和切片相关的主要数据类型。切片是一个很重要的数据类型，你可以着重理解它存在的意义，以及使用方式。</p><p>今天学完相信你也看到了，围绕着切片有很多数据结构，而<strong>切片将它们抽象成相同的访问方式，实现了在不同数据结构之上的同一抽象</strong>，这种方法很值得我们学习。此外，当我们构建自己的数据结构时，如果它内部也有连续排列的等长的数据结构，可以考虑 AsRef 或者 Deref 到切片。</p><p>下图描述了切片和数组 [T;n]、列表 Vec&lt;T&gt;、切片引用 &amp;[T] /&amp;mut [T]，以及在堆上分配的切片 Box&lt;[T]&gt; 之间的关系。建议你花些时间理解这张图，也可以用相同的方式去总结学到的其他有关联的数据结构。<br>\n<img src=\"https://static001.geekbang.org/resource/image/62/91/62c55a1733d7b674a9e815c45d4a6f91.jpg?wh=2364x1740\" alt=\"\"></p><p>下一讲我们继续学习哈希表……</p><h3>思考题</h3><p>1.在讲 &amp;str 时，里面的 print_slice1 函数，如果写成这样可不可以？你可以尝试一下，然后说明理由。</p><pre><code class=\"language-rust\">// fn print_slice1&lt;T: AsRef&lt;str&gt;&gt;(s: T) {\n//    println!(\"{:?}\", s.as_ref());\n// }\n\nfn print_slice1&lt;T, U&gt;(s: T)\nwhere\n    T: AsRef&lt;U&gt;,\n    U: fmt::Debug,\n{\n    println!(\"{:?}\", s.as_ref());\n}\n</code></pre><p>2.类似 itertools，你可以试着开发一个新的 Iterator trait IteratorExt，为其提供 window_count 函数，使其可以做下图中的动作（<a href=\"https://rxjs.dev/api/operators/windowCount\">来源</a>）：<br>\n<img src=\"https://static001.geekbang.org/resource/image/f3/5b/f30947af9dff50521ccd4ddae42f0d5b.png?wh=1280x634\" alt=\"\"></p><p>感谢你的阅读，如果你觉得有收获，也欢迎你分享给你身边的朋友，邀他一起讨论。你已经完成了Rust学习的第16次打卡啦，我们下节课见。</p><h3>参考资料：Rust 的 Iterator 究竟有多快？</h3><p>当使用 Iterator 提供的这种函数式编程风格的时候，我们往往会担心性能。虽然我告诉你 Rust 大量使用 inline 来优化，但你可能还心存疑惑。</p><p>下面的代码和截图来自一个 Youtube 视频：<a href=\"https://youtu.be/-hGbMp0sBvM?t=913\">Sharing code between iOS &amp; Android with Rust</a>，演讲者通过在使用 Iterator 处理一个很大的图片，比较 Rust / Swift / Kotlin native / C 这几种语言的性能。你也可以看到在处理迭代器时， Rust 代码和 Kotlin 或者 Swift 代码非常类似。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/81/6de6b2d91fe28b0228e748220dbe3281.png?wh=1388x1022\" alt=\"\" title=\"Rust / Kotlin 代码\"></p><p><img src=\"https://static001.geekbang.org/resource/image/73/af/73dd5214bd0d15409006f99ac78fbdaf.png?wh=1390x1022\" alt=\"\" title=\"Swift 代码\"></p><p>运行结果，在函数式编程方式下（C 没有函数式编程支持，所以直接使用了 for 循环），Rust 和 C 几乎相当在1s 左右，C 比 Rust 快 20%，Swift 花了 11.8s，而 Kotlin native 直接超时：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c1/d4/c1e1c1909b761cfa3348115bb417d4d4.png?wh=1430x1072\" alt=\"\"></p><p>所以 Rust 在对函数式编程，尤其是 Iterator 上的优化，还是非常不错的。这里面除了 inline 外，Rust 闭包的优异性能也提供了很多支持（未来我们会讲为什么）。在使用时，你完全不用担心性能。</p>","neighbors":{"left":{"article_title":"15｜数据结构：这些浓眉大眼的结构竟然都是智能指针？","id":422182},"right":{"article_title":"17｜数据结构：软件系统核心部件哈希表，内存如何布局？","id":423923}},"comments":[{"had_liked":false,"id":314130,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1632872835,"is_pvip":false,"replies":[{"id":"113984","content":"如果单线程，可以用 Rc&lt;T&gt;，多线程用 Arc&lt;T&gt;。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633322251,"ip_address":"","comment_id":314130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70352349571","product_id":100085301,"comment_content":"问老师一个工程性上的问题，也困扰了我好久，之前我在用rust开发项目的时候，数据解析性项目，会存在一个字段被多个类，或者函数使用，由于所有权的问题，导致代码中出现了大量的clone函数，后面在做性能分析的时候，发现20%的时间竟然浪费在clone上，求问老师，如何减少clone的调用次数？","like_count":17,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527582,"discussion_content":"如果单线程，可以用 Rc&amp;lt;T&amp;gt;，多线程用 Arc&amp;lt;T&amp;gt;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633322251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314377,"user_name":"lisiur","can_delete":false,"product_type":"c1","uid":1201350,"ip_address":"","ucode":"CEB2DBCE29CAA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","comment_is_top":false,"comment_ctime":1632990506,"is_pvip":false,"replies":[{"id":"113986","content":"嗯。挺不错。第二题可以看看我的参考实现：<br><br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c51bf256df8be1c51c16bbe4885b810a","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633322464,"ip_address":"","comment_id":314377,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27402794282","product_id":100085301,"comment_content":"1. 不可以，但稍微改造下也是可以的<br><br>str 实现了 AsRef&lt;[u8]&gt;，AsRef&lt;OsStr&gt;，AsRef&lt;Path&gt;，AsRef&lt;str&gt;<br><br>如果 T: AsRef&lt;[U]&gt;，编译器可以推断出 str 是 AsRef&lt;[u8]&gt;，即 U 是 u8 类型<br><br>如果 T: AsRef&lt;U&gt;，编译器就懵逼了，因为它有四种选择。<br><br>问题的关键就在于编译器无法推断出 U 的类型，因此如果稍微改造下，其实还是可以通过手动标记来通过编译的：<br><br>```rust<br>use std::fmt;<br><br>fn main() {<br>    let s = String::from(&quot;hello&quot;);<br>    print_slice1::&lt;_, [u8]&gt;(&amp;s); &#47;&#47; [104, 101, 108, 108, 111]<br>    print_slice1::&lt;_, str&gt;(&amp;s);  &#47;&#47; &quot;hello&quot;<br>}<br><br>fn print_slice1&lt;T, U: ?Sized&gt;(s: T)<br>where<br>    T: AsRef&lt;U&gt;,<br>    U: fmt::Debug,<br>{<br>    println!(&quot;{:?}&quot;, s.as_ref());<br>}<br>```<br><br>2. 看了下 rxjs 的定义，第二个参数如果小于第一个参数的话，得到的结果好像没啥意义（反正我个人是没看懂），<br>所以只处理了第二个参数不小于第一个参数的情况。<br><br>```rust<br>struct WindowCountIter&lt;T: Iterator&gt; {<br>    iter: T,<br>    window_size: usize,<br>    start_window_every: usize,<br>}<br><br>impl&lt;T: Iterator&gt; Iterator for WindowCountIter&lt;T&gt; {<br>    type Item = Vec&lt;&lt;T as Iterator&gt;::Item&gt;;<br><br>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>        let mut item = Vec::with_capacity(self.window_size);<br><br>        for _ in 0..self.window_size {<br>            if let Some(v) = self.iter.next() {<br>                item.push(v);<br>            }<br>        }<br><br>        for _ in 0..(self.start_window_every - self.window_size) {<br>            self.iter.next();<br>        }<br><br>        if item.is_empty() {<br>            None<br>        } else {<br>            Some(item)<br>        }<br>    }<br>}<br><br>trait IteratorExt: Iterator {<br>    fn window_count(self, window_size: usize, start_window_every: usize) -&gt; WindowCountIter&lt;Self&gt;<br>    where<br>        Self: Sized,<br>    {<br>        if start_window_every &gt; 0 &amp;&amp; start_window_every &lt; window_size {<br>            panic!(&quot;start_window_every 不能小于 window_size&quot;)<br>        }<br>        WindowCountIter {<br>            iter: self,<br>            window_size,<br>            start_window_every: if start_window_every == 0 {<br>                window_size<br>            } else {<br>                start_window_every<br>            },<br>        }<br>    }<br>}<br><br>impl&lt;T: Iterator&gt; IteratorExt for T {}<br>```","like_count":7,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527665,"discussion_content":"嗯。挺不错。第二题可以看看我的参考实现：\n\nhttps://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=c51bf256df8be1c51c16bbe4885b810a","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633322464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2888176,"avatar":"","nickname":"无下限HENTAI","note":"","ucode":"8D45A12C25861A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554689,"discussion_content":"不知道你那个时候和现在是不是不一样了，对第一题来说，现在如果使用U而不是[U]的话，U后面还必须加上?Sized告诉编译器长度不定，否则编译无法通过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646551263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324178,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1638327086,"is_pvip":false,"replies":[{"id":"118869","content":"👍 很好的思考。一般我都会把题目的答案放在 github repo 下。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639849070,"ip_address":"","comment_id":324178,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18818196270","product_id":100085301,"comment_content":"怎么留言越来越少了……<br>不要放弃啊，我也有被卡好几天的时候，但慢慢地就走出来了。<br>1. 编译器推断不出 U 的类型，因为 T 实现了多个 AsRef trait。可以使用 turbofish 手动指定 U，同时也要注意到对于 str 和 [u8] 来说，U 需要是 ?Sized。<br>2. 一开始我以为 WindowCount 结构体 next 方法返回的是一个新的 Iterator，这个新的 Iterator 里是 count 个 Item。后来我发现这不可能实现啊……我为什么一开始是这么想的呢，是受 slice 的 chunks 方法影响，chunks 方法这不是正好符合题目要求么，但 slice 是有长度信息的，而 Iterator 只能一直 next。后来我偷瞄了老师的实现，发现原来是想用 Vec 来承载每一组数据…… 具体实现代码就不贴了，和老师的差不多。<br><br>但我又回过头来想 rxjs 的 windowCount 好像不是这个意思，它的每一组数据还是一个流。那它怎么实现的呢？<br>我想这可能跟 rxjs 的设计有关，它是把数据 push 到订阅者，而 Iterator 是 pull。<br>rxjs 单独使用 windowCount 是这样的效果：假如数据源是点击事件，count 是 3，一开始还没点击就产生一个 Observable（我们叫它 A），然后我点击第一下，这次点击就被推送到 A 了，点击第二下，也推送到 A，点击第三下，也推送到 A，这时候 A 已经吐 3 个数据了，紧接着就会产生下一个高阶 Observable B，用来承载接下来的三次点击……<br>但这个 Iterator 是个同步模型，而且还没有数据总量的信息，我根本无法判断这次 next 是应该返回 None 还是 Some。<br><br>建议类似题目可以给出多一点的提示……<br>","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539829,"discussion_content":"👍 很好的思考。一般我都会把题目的答案放在 github repo 下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639849070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314318,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1632969839,"is_pvip":false,"replies":[{"id":"113976","content":"FromIterator 目前还没有加入 Rust 的 prelude，2021 edition 才会自动加入：<br><br>The first new feature that Rust 2021 will have is a new prelude that includes TryInto, TryFrom and FromIterator from the Rust standard library.<br><br>对于 trait 方法，如果你要使用，需要先确保在上下文中引入了这个 trait。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633320720,"ip_address":"","comment_id":314318,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14517871727","product_id":100085301,"comment_content":"还有个问题, 为啥需要 import FromIterator 才能使用 String::from_iter呢? String不都已经impl了吗? https:&#47;&#47;doc.rust-lang.org&#47;src&#47;alloc&#47;string.rs.html#1866-1872","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527641,"discussion_content":"FromIterator 目前还没有加入 Rust 的 prelude，2021 edition 才会自动加入：\n\nThe first new feature that Rust 2021 will have is a new prelude that includes TryInto, TryFrom and FromIterator from the Rust standard library.\n\n对于 trait 方法，如果你要使用，需要先确保在上下文中引入了这个 trait。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633320720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399559,"discussion_content":"我猜应该是 std::prelude 里默认没有导出 FromIterator，等2021版发布之后，应该就不需要了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632991401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","nickname":"Marvichov","note":"","ucode":"7482099415C41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399792,"discussion_content":"感谢回复. 听起来有点像header file?\n\n第三方crate的trait对String的实现, 我可以理解要import那个trait, 这样编译器才知道从哪里去找定义 (因为String的源码里面找不到). 相当于对String的extension.\n\n但是, 在String的源码中, String impl了这个trait, 对应的方法不应该变成String的一部分了吗? 我的理解是, 使用String的时候, 这个方法就默认被import了? ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633063784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314315,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1632969358,"is_pvip":false,"replies":[{"id":"113987","content":"对。<br><br>第二题可以看看我的实现：https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c51bf256df8be1c51c16bbe4885b810a<br><br>如果你纠结 lazy，可以看看 slice chunk 的实现：https:&#47;&#47;doc.rust-lang.org&#47;src&#47;core&#47;slice&#47;iter.rs.html#1363","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633322995,"ip_address":"","comment_id":314315,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10222903950","product_id":100085301,"comment_content":"1. 有歧义, U可以是str, 也可以是[u8];<br><br>2. 用vec作弊了: eagerly load window_size大小的element; 没有lazy load<br><br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e6759f0d43bfbbb9f9a4b4aaf4a8ed8b<br><br>没有贴tests; 在link里面有<br><br>```<br>struct WindowCount&lt;T&gt;<br>where<br>    T: Iterator,<br>{<br>    window_size: usize,<br>    start_window_every: usize,<br>    iter: T,<br>}<br><br>impl&lt;T&gt; Iterator for WindowCount&lt;T&gt;<br>where<br>    T: Iterator,<br>{<br>    type Item = &lt;Vec&lt;&lt;T as Iterator&gt;::Item&gt; as IntoIterator&gt;::IntoIter;<br>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>        if self.window_size == 0 {<br>            return None;<br>        }<br><br>        let mut v = Vec::with_capacity(self.window_size);<br>        for _ in 0..self.window_size {<br>            if let Some(item) = self.iter.next() {<br>                v.push(item);<br>            } else {<br>                break;<br>            }<br>        }<br><br>        &#47;&#47; advance steps<br>        for _ in 0..self.start_window_every {<br>            if self.iter.next().is_none() {<br>                break;<br>            }<br>        }<br>        if v.is_empty() {<br>            None<br>        } else {<br>            Some(v.into_iter())<br>        }<br>    }<br>}<br>trait IteratorExt: Iterator {<br>    fn window_count(self, window_size: usize, start_window_every: usize) -&gt; WindowCount&lt;Self&gt;<br>    where<br>        Self::Item: std::fmt::Debug,<br>        Self: Sized,<br>    {<br>        WindowCount {<br>            window_size,<br>            start_window_every,<br>            iter: self,<br>        }<br>    }<br>}<br><br>impl&lt;T: Iterator&gt; IteratorExt for T {}<br>```","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527640,"discussion_content":"对。\n\n第二题可以看看我的实现：https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=c51bf256df8be1c51c16bbe4885b810a\n\n如果你纠结 lazy，可以看看 slice chunk 的实现：https://doc.rust-lang.org/src/core/slice/iter.rs.html#1363","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633322995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1080653,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7d/4d/d98865b2.jpg","nickname":"老实人Honey","note":"","ucode":"EA4AB5C0C33090","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547099,"discussion_content":"你这个写法可以用skip来处理吗\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        let data = (0..self.window_size)\n            .filter_map(|_| self.iter.next())\n            .skip(self.start_window_every as usize)\n            .collect::&lt;Vec&lt;_&gt;&gt;();\n        if data.is_empty() {\n            None\n        } else {\n            Some(data)\n        }\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642522684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314188,"user_name":"阿海","can_delete":false,"product_type":"c1","uid":1281585,"ip_address":"","ucode":"2589431F840C42","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/31/28972804.jpg","comment_is_top":false,"comment_ctime":1632891876,"is_pvip":true,"replies":[{"id":"113979","content":"&amp;T 是引用，*T 是解引用。比如你有一个 b = &amp;mut u32，你可以 *b = 10 来解引用更改 b 指向的内存。<br><br>Rust 大部分情况下都会做自动解引用（使用 . 的时候）。所以你会感觉很少需要用 *。https:&#47;&#47;stackoverflow.com&#47;questions&#47;28519997&#47;what-are-rusts-exact-auto-dereferencing-rules&#47;28552082","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633321408,"ip_address":"","comment_id":314188,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10222826468","product_id":100085301,"comment_content":"老师问个问题，为什么rust解引用是用&amp;T 来表示，而不是用*T","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527603,"discussion_content":"&amp;amp;T 是引用，*T 是解引用。比如你有一个 b = &amp;amp;mut u32，你可以 *b = 10 来解引用更改 b 指向的内存。\n\nRust 大部分情况下都会做自动解引用（使用 . 的时候）。所以你会感觉很少需要用 *。https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/28552082","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633321408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399511,"discussion_content":"rust 解引用是用 * 的，我猜你想问的应该是强制解引用的用法。所谓强制解引用我觉得和c 里的解引用还是不一样的，强制解引用的结果一定还是一个引用，而不是原始值。\n\n可以参考文档里关于强制解引用的说明：https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion\n\n简单解读下就是：\n\n如果 T 实现了 Deref<Target = U>，而且 x 是 T 类型的实例，那么：\n\n1. 在 immutable 的上下文中， *x 等价于 *Deref::deref(&amp;x)  (你看这里还是用 * 来解引用的)\n2. &amp;T 会被强制解引用到 &amp;U （解引用是把值从一个引用类型转换成另一个引用类型）\n3. T 隐式实现了 U 所有 immutable 方法 （因为 immutable 方法的第一个参数是 &amp;self，&amp;self 可以触发强制解引用到 &amp;U，自然就可以使用 U 的 immutable 方法了）\n\n另外强制解引用一般是隐式触发的，目的也是为了方便代码的书写，减少模板代码，算是一个工程上的优化，和真正的解引用还是有挺大区别的。（以上都是个人理解，仅供参考）","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1632980659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534725,"discussion_content":"deref coercion翻译成强制解引用挺有误导性的……至少个人这么感觉……\n我也不知道怎么翻译……\n大概可以叫“解引用转换”\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638263011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314168,"user_name":"给我点阳光就灿烂","can_delete":false,"product_type":"c1","uid":1462209,"ip_address":"","ucode":"F3B0439BE0D062","user_header":"https://static001.geekbang.org/account/avatar/00/16/4f/c1/7f596aba.jpg","comment_is_top":false,"comment_ctime":1632883662,"is_pvip":true,"replies":[{"id":"113990","content":"没有太好的想法。不过，算法上的 O1（HashMap + LinkedList） 和 box&#47;raw 关系不大。<br><br>如果测量的结果是频繁地分配释放是罪魁祸首，那么，可以考虑使用 slab 来预分配 RawLRU 的 entry。<br><br><br>","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633325756,"ip_address":"","comment_id":314168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5927850958","product_id":100085301,"comment_content":"写了一个缓存库，想问一下老师如何优化hashmap的性能，目前为了算法上的O1，使用了box和raw指针，但是会box和rebox又让性能慢了一些。https:&#47;&#47;github.com&#47;al8n&#47;caches-rs","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527596,"discussion_content":"没有太好的想法。不过，算法上的 O1（HashMap + LinkedList） 和 box/raw 关系不大。\n\n如果测量的结果是频繁地分配释放是罪魁祸首，那么，可以考虑使用 slab 来预分配 RawLRU 的 entry。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633325756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356462,"user_name":"Geek_a6c6ce","can_delete":false,"product_type":"c1","uid":3074996,"ip_address":"美国","ucode":"21DC76D3225403","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/TusRVU51UggZGpicXMgH64Cb8jek0wyTOpagtUHNAj0EPbhbEv0FJpFU2K3glbtOdJXiaQ9o6QoEfv5PiaIu7rwng/132","comment_is_top":false,"comment_ctime":1662344299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662344299","product_id":100085301,"comment_content":"咔哒","like_count":0},{"had_liked":false,"id":352538,"user_name":"沈畅","can_delete":false,"product_type":"c1","uid":1077953,"ip_address":"","ucode":"7404E41356B36B","user_header":"https://static001.geekbang.org/account/avatar/00/10/72/c1/59509397.jpg","comment_is_top":false,"comment_ctime":1658749843,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658749843","product_id":100085301,"comment_content":"官方文档 filter里面用了两个 **<br>let a = [0, 1, 2];<br><br>let mut iter = a.iter().filter(|x| **x &gt; 1); &#47;&#47; need two *s!<br><br>assert_eq!(iter.next(), Some(&amp;2));<br>assert_eq!(iter.next(), None);<br><br>为啥 我们只用一个就行？<br>let v = vec![1,2,3,4];<br>    let ret = v.iter()<br>               .map(|v| v*v)<br>               .filter(|v| *v &lt; 16)<br>               .take(5)<br>               .collect::&lt;Vec&lt;_&gt;&gt;();","like_count":0},{"had_liked":false,"id":316603,"user_name":"朱中喜","can_delete":false,"product_type":"c1","uid":2029033,"ip_address":"","ucode":"AEEBDF4BB0E53F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJlLmHNjThjiahjUNav9W5PI1IQCic5PcbM700V9YlAWDibjeeOOlAKGvAv4zU7ic0OQJZ0KKZicvbEKPw/132","comment_is_top":false,"comment_ctime":1634444127,"is_pvip":true,"replies":[{"id":"114686","content":"Box&lt;T&gt; 实现了 Deref 啊：https:&#47;&#47;doc.rust-lang.org&#47;std&#47;boxed&#47;struct.Box.html#impl-Deref。注意你这里 T 是个 slice，所以 b2.deref() 和 v2（Vec）可以比较，因为实现了相应的 eq","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1634539941,"ip_address":"","comment_id":316603,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634444127","product_id":100085301,"comment_content":" let b1 = v1.into_boxed_slice();<br>    let mut b2 = b1.clone();<br>    let v2 = b1.into_vec();<br>    println!(&quot;cap should be exactly 5: {}&quot;, v2.capacity());<br>    assert!(b2.deref() == v2);<br><br>b2的类型是Box([T]), 为何对b2做deref就变成Vec了？在标准库里没找到针对Box slice的Deref实现😭","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528430,"discussion_content":"Box&amp;lt;T&amp;gt; 实现了 Deref 啊：https://doc.rust-lang.org/std/boxed/struct.Box.html#impl-Deref。注意你这里 T 是个 slice，所以 b2.deref() 和 v2（Vec）可以比较，因为实现了相应的 eq","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634539941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314270,"user_name":"D. D","can_delete":false,"product_type":"c1","uid":2186992,"ip_address":"","ucode":"C416E5602C8814","user_header":"https://static001.geekbang.org/account/avatar/00/21/5e/f0/62d8cf9e.jpg","comment_is_top":false,"comment_ctime":1632925353,"is_pvip":true,"replies":[{"id":"113988","content":"1. 对！<br>2. 可以看看我的参考实现：https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c51bf256df8be1c51c16bbe4885b810a","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633323091,"ip_address":"","comment_id":314270,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1632925353","product_id":100085301,"comment_content":"1. 可以为同一个具体类型实现不同的AsRef Trait, 编译器无法从上下文中推断出U的具体类型，所以不能这样写。<br><br>2. 不知道实现的符不符合要求，以及有什么问题。<br>pub struct Window&lt;I&gt; {<br>    iter: I,<br>    count: usize,<br>    start: usize,<br>}<br><br>pub trait IteratorExt: Iterator {<br>    fn window_count(self, count: usize, start: usize) -&gt; Window&lt;Self&gt;<br>    where<br>        Self: Sized,<br>    {<br>        Window {<br>            iter: self,<br>            count,<br>            start,<br>        }<br>    }<br>}<br><br>impl&lt;T: Iterator&gt; IteratorExt for T {}<br><br>impl&lt;I: Iterator&gt; Iterator for Window&lt;I&gt; {<br>    type Item = Vec&lt;&lt;I as Iterator&gt;::Item&gt;;<br><br>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>        if self.count == 0 {<br>            return None;<br>        }<br><br>        for _ in 0..self.start {<br>            self.iter.next()?;<br>        }<br><br>        let mut v = Vec::with_capacity(self.count);<br><br>        for _ in 0..self.count {<br>            v.push(self.iter.next()?);<br>        }<br>        Some(v)<br>    }<br>}<br><br>#[test]<br>fn if_it_works() {<br>    let v1 = vec![&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;];<br><br>    let mut window = v1.iter().window_count(0, 0);<br>    assert_eq!(window.next(), None);<br><br>    let mut window = v1.into_iter().window_count(3, 0);<br>    assert_eq!(window.next(), Some(vec![&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]));<br>    assert_eq!(window.next(), Some(vec![&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]));<br>    assert_eq!(window.next(), Some(vec![&#39;g&#39;, &#39;h&#39;, &#39;i&#39;]));<br>    assert_eq!(window.next(), None);<br><br>    let v2 = vec![&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;];<br>    let mut window = v2.into_iter().window_count(3, 0);<br>    assert_eq!(window.next(), Some(vec![&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]));<br>    assert_eq!(window.next(), Some(vec![&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]));<br>    assert_eq!(window.next(), None);<br><br>    let v3 = vec![1, 2, 3, 4, 5, 6, 7, 8];<br>    let mut window = v3.into_iter().window_count(3, 3);<br>    assert_eq!(window.next(), Some(vec![4, 5, 6]));<br>    assert_eq!(window.next(), None);<br><br>    let v4 = [1, 2, 3, 4, 5, 6, 7, 8];<br>    let mut window = v4.iter().window_count(3, 100);<br>    assert_eq!(window.next(), None);<br>}<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527624,"discussion_content":"1. 对！\n2. 可以看看我的参考实现：https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=c51bf256df8be1c51c16bbe4885b810a","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633323091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2186992,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5e/f0/62d8cf9e.jpg","nickname":"D. D","note":"","ucode":"C416E5602C8814","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399506,"discussion_content":"这样每次next的时候都会跳过start个元素。用Option包裹着start稍微修改了一下😂\npub struct Window<I> {\n    iter: I,\n    count: usize,\n    start: Option<usize>,\n}\n\npub trait IteratorExt: Iterator {\n    fn window_count(self, count: usize, start: usize) -> Window<Self>\n    where\n        Self: Sized,\n    {\n        let start = if start == 0 { None } else { Some(start) };\n\n        Window {\n            iter: self,\n            count,\n            start,\n        }\n    }\n}\n\nimpl<T: Iterator> IteratorExt for T {}\n\nimpl<I: Iterator> Iterator for Window<I> {\n    type Item = Vec<<I as Iterator>::Item>;\n\n    fn next(&amp;mut self) -> Option<Self::Item> {\n        if self.count == 0 {\n            return None;\n        }\n\n        if let Some(start) = self.start.take() {\n            for _ in 0..start {\n                self.iter.next()?;\n            }\n        }\n\n        let mut v = Vec::with_capacity(self.count);\n\n        for _ in 0..self.count {\n            v.push(self.iter.next()?);\n        }\n        Some(v)\n    }\n}\n\nhttps://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fef88e3b1eaf3ff93102141c30c6dae1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632979324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314149,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1632878863,"is_pvip":false,"replies":[{"id":"113983","content":"Rust 也可以使用 for &#47; while &#47; loop，并不见得都需要用函数式编程方式。选择最合适的方式处理就好。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633322211,"ip_address":"","comment_id":314149,"utype":1}],"discussion_count":4,"race_medal":2,"score":"1632878863","product_id":100085301,"comment_content":"漂亮，老师叕解答了我的好多疑惑。现在唯一有点要适应的就是函数数式编程。C++ 和 Go 写多了，一上来就是 for 循环，要适应 Rust 的想法也是个不小的挑战。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527588,"discussion_content":"Rust 也可以使用 for / while / loop，并不见得都需要用函数式编程方式。选择最合适的方式处理就好。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633322211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102367,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d2/1f/2ef2514b.jpg","nickname":"newzai","note":"","ucode":"D5E34D427D65FD","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402271,"discussion_content":"可以经常用clippy进行代码风格检查，慢慢的就会熟悉rust的代码风格了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633851231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2763179,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/29/ab/59a6e437.jpg","nickname":"Kevin","note":"","ucode":"3588850B3370C8","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558338,"discussion_content":"为什么C++和go你不用函数式写法？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648214154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2226242,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f8/42/7f66197c.jpg","nickname":"人来人往@","note":"","ucode":"F0687F6C0CDD13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547806,"discussion_content":"前端er表示觉得这个函数式链式调用很像JS的 比如 [].filter.map.some之类的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642864302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}