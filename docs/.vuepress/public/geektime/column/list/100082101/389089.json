{"id":389089,"title":"05｜跨越现实的障碍（中）：富含知识还是代码坏味道？","content":"<p>你好，我是徐昊。今天我们来聊聊如何有效地分离领域模型中的上下文。</p><p>上节课我们介绍了关联对象，以及如何通过关联对象建模聚合/关联关系，从而在不影响性能的情况下，更好地维持领域模型与软件实现的统一。</p><p>今天，我们来看另一个在关联领域模型与软件实现时经常遇到的问题：上下文过载（Context Overloading）。所谓<strong>上下文过载</strong>，就是指<strong>领域模型中的某个对象会在多个上下文中发挥重要作用，甚至是聚合根</strong>。一来这个对象本身会变得很复杂，造成模型僵化；二来可能会带来潜在的性能问题。</p><p>于是，将过载的上下文进行有效的分离，就成了我们现在需要面对的问题。方法上也有很多不同的选择，我主要介绍<strong>角色对象</strong>（Role Object）和<strong>上下文对象</strong>（Context Object）这两种。这两个方法与我们上节课讲的关联对象一脉相承，都是通过将隐含概念显式建模来解决问题。</p><p>同样地，在看到具体的解决方法之前，我们需要深入了解上下文过载会产生哪些问题。</p><h2>因富含逻辑而产生的过大类</h2><p>为了帮助你理解上下文过载会产生哪些问题，我还是借助极客时间专栏的例子来说明一下。当然，首先我们需要扩展这个领域模型。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/6e/4d4ee511209b887c1efeec251fce366e.jpg?wh=7538x4208\" alt=\"\"></p><p>在这个扩展了的模型中，包含了三个不同的上下文。</p><ol>\n<li>订阅：用户阅读订阅内容的上下文，根据订阅关系判断某些内容是否对用户可见；</li>\n<li>社交：用户维护朋友关系的上下文，通过朋友关系分享动态与信息；</li>\n<li>订单：用户购买订阅专栏的上下文，通过订单与支付，完成对专栏的订阅。</li>\n</ol><!-- [[[read_end]]] --><p>按照这个模型，我们很容易得到与之对应的“富含知识的模型”：</p><pre><code>public class User {\n    private long id;\n    \n    // 社交上下文\n    private List&lt;Friendship&gt; friends;\n    private List&lt;Moments&gt; moments;\n    \n    // 订阅上下文\n    private List&lt;Subscription&gt; subscriptions;\n    \n    // 订单上下文\n    private List&lt;Order&gt; orders;\n    private List&lt;Payment&gt; payments;\n    \n    // 社交上下文\n    public void make(Friendship friend) {\n      ...\n    }\n    \n    public void break(Friendship friend) {\n      ...\n    }\n    \n    // 订单上下文\n    public void placeOrder(Column column) {\n      ...\n    }    \n    \n    // 订阅上下文\n    public boolean canView(Content content) {\n      ...\n    }        \n}\n</code></pre><p>如果对代码坏味道敏感的同学，估计已经发现问题所在了：<strong>一个对象中包含了不同的上下文</strong>，而这恰好是<strong>坏味道过大类</strong>（Large Class）的定义。</p><p>那么过大类会带来什么问题呢？首当其冲是<strong>模型僵硬</strong>。想要理解这个类的行为，就必须理解所有的上下文。而只有理解了所有的上下文，才能判断其中的代码和行为是否合理。</p><p>于是，<strong>上下文的过载就变成了认知的过载</strong>（Cognitive Overloading），<strong>而认知过载就会造成维护的困难</strong>。通俗地讲，就是<strong>“看不懂、改不动”</strong>，代码就变成“祖传代码”了。</p><p>但是我们不要忘了，这是与模型关联的代码啊！<strong>改不动的代码就是改不动的模型</strong>！改不动的僵硬的模型，要怎么参与提炼知识的循环呢？</p><p>当然，过大类还容易滋生重复代码、引入偶然耦合造成意外的缺陷等编码上的问题。不过这些问题与模型僵硬比起来，似乎有点不值一提。</p><p>另一个问题没那么严重，但同样值得重视，这个问题仍然与性能有关。在不同的上下文中，我们需要访问的数据也不尽相同。</p><p>比如在维护朋友关系、发布动态信息时，我们不太可能访问订阅与订单信息。类似的，当我们访问订单信息的时候，也不太可能关注朋友信息。那么，当所有的上下文都汇聚于User时，我们怎么才能获得一个高效的聚合加载策略呢（当然通过关联对象我们能缓解这个问题，具体请看上一课）？</p><p><strong>这里的吊诡之处在于，我们并没有做什么坏事，反而是因为严格遵照“富含知识的模型”的原则，才导致了上下文过载</strong>。</p><p>我们来分析一下。User在不同的上下文中都处在聚合根的位置：</p><ul>\n<li>在订阅上下文中，User是Subscription的聚合根；</li>\n<li>在订单上下文中，User是Payment和Order的聚合根；</li>\n<li>在社交上下文中，User是Friendship和Moments的聚合根。</li>\n</ul><p>根据构建“富含知识模型”的做法，被聚合对象的集合逻辑放置于聚合/聚合根里，而不是散落在外，或是放在其他无关的服务中。这么做可以使得逻辑富集于模型中，同时有利于通过聚合关系管理一组对象与领域概念的映射，保持领域概念与逻辑的完整性。</p><p>那么，每当User在不同的上下文中处于聚合/聚合根位置的时候，与之相关的逻辑都会进入User中，User会不可避免地膨胀。这就是上下文过载。</p><p>又要再说一句题外话了。在使用原味面向对象范型（Vanilla Object Oriented）的时候，不自觉地就会产生过大类，这其实也跟Smalltalk有关。正如我们上节课所讲，Smalltalk是一个面向对象系统，其中还包含一个IDE：<strong>System Browser</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/34/2a/34bc46c542d65c63bb3619bed5c92f2a.gif?wh=458x360\" alt=\"\"></p><p>在Smalltalk中，源代码并不以文本格式作为主要表达形式，而是通过一个图形化的界面，让我们有指导性地、片段式地浏览对应的代码。上图中左起第三个窗口就是自定义的上下文。也就是说，即使对象中存在再多的上下文，也不会影响我们对代码的理解和修改。毕竟上下文再多，我们也不会一次看到多个方法的具体实现代码。</p><p>如果你用过Eclipse IDE开发Java项目的话，那么这里肯定有一个不那么有用的古怪的视图，让你百思不得其解。但如果你对这张图和上面Smalltalk System Browser有点了解的话，就能从布局中看出一些端倪。</p><p><img src=\"https://static001.geekbang.org/resource/image/ce/0d/ced5ec1c086e81f9310a31635f63c40d.jpg?wh=474x332\" alt=\"\"><br>\n这其实是Eclipse对Smalltalk的致敬。毕竟，Eclipse也算是传奇Smalltalk程序员Kent Beck的作品。但当我们以文本作为源代码的主要形式，以类作为源代码的主要组织方式时，仅仅通过视图的切换是无法达成Smalltalk的效果的。于是，过大类的上下文过载就成了一个严重的问题。</p><h2>逻辑汇聚于上下文还是实体？</h2><p>上下文过载问题最根本的症结在于，<strong>逻辑是需要汇聚于实体</strong>（User）<strong>还是上下文</strong>（订阅、社交与订单）。</p><p>原味面向对象范型（也是领域驱动设计的默认风格）的答案是汇聚于实体，但是缺少有效分离不同上下文的方式。而DCI范型（Data-Context-Interaction，数据-上下文-交互）要求汇聚于显式建模的上下文对象（Context Object），或者上下文中的角色对象（Role Object）上。如果按照DCI范型的思路，我们可以如下图这样建立模型：</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/f4/ca9054cb5f3d04bd3ab755f75bf74ef4.jpg?wh=8000x4500\" alt=\"\"></p><p>这其实也很容易理解。<strong>在不同的上下文中，用户是以不同的角色与其他对象发生交互的，而一旦离开了对应的上下文，相关的交互也就不会发生了</strong>。</p><p>这与我们生活中的体验是一致的。上班时，以员工的身份发生的工作活动与交互，下班之后其实可以不用发生了。因为已经脱离了工作这个上下文，不再扮演这个角色了。同样的，在生活中的以其他身份发生的活动与交互，在工作中也不该发生。</p><p>也就是说，在订阅上下文中的读者（Reader），不会以读者的身份与订单上下文中的支付信息发生交互。而买家（Buyer），也不会以买家的身份去社交上下文中去建立朋友关系。</p><p>从DCI的角度看待聚合与聚合根关系，我们可以发现，并不是User聚合了Subscription，而是订阅上下文中的Reader聚合了它。同时，并不是User聚合了Friendship与Moments，而是社交上下文中的Contact聚合了它们。可以说，<strong>User只是恰好在不同的上下文中扮演了这些角色而已</strong>。</p><p>理清了这一层关系，我们也就发现了上下文过载的根源：<strong>实体在不同的上下文中扮演的多个角色，再借由聚合关系，将不同上下文中的逻辑富集于实体之中，就造成了上下文过载。</strong></p><p>明白这一点，解决方案也就呼之欲出了：针对不同上下文中的角色建模，将对应的逻辑富集到角色对象中，再让实体对象去扮演不同的角色，就能解决上下文过载的问题了。</p><p>当然，理想永远是清晰且美好的，在实践中却没有这么简单，主要是<strong>如何在代码中实现这种实体与角色间的扮演关系</strong>。</p><h2>通过角色对象分离不同上下文中的逻辑</h2><p>一个最简单的想法是，将角色抽象成接口：</p><pre><code>//阅读上下文\ninterface Reader {\n    List&lt;Subscription&gt; getSubscriptions();\n    \n    boolean canView(Content content);\n}\n\n\n//订单上下文\ninterface Buyer {\n    List&lt;Order&gt; getOrders();\n  \n    List&lt;Payment&gt; getPayments();\n  \n    void placeOrder(Column column);\n}\n\n\n//社交上下文\ninterface Contact {\n    List&lt;Friendship&gt; friends;\n  \n    List&lt;Moments&gt; moments;\n  \n    void make(Friendship friend);\n  \n    void break(Friendship friend);\n</code></pre><p>然而，这实际上并没有解决什么问题：</p><pre><code>public class User implements Reader, Buyer, Contact {    \n    // 社交上下文\n    public void make(Friendship friend) {\n      ...\n    }\n    \n    public void break(Friendship friend) {\n      ...\n    }\n    \n    // 订单上下文\n    public void placeOrder(Column column) {\n      ...\n    }    \n    \n    // 订阅上下文\n    public boolean canView(Content content) {\n      ...\n    }        \n}\n</code></pre><p>通过实现接口去完成角色扮演，得到的代码其实没什么差别。虽然借助当代IDE，我们可以较容易地判断行为来自哪个上下文，但实际得到的改善极其有限。既然接口不好用的话，另一个思路就是通过<strong>装饰器</strong>（Decorator），我们可以构造一系列角色对象（Role Object）作为User的装饰器：</p><pre><code>public class Reader {\n    private User user;\n    private List&lt;Subscription&gt; subscriptions;\n    \n    public Reader(User user) {\n        ...\n    }\n    \n    // 订阅上下文\n    public boolean canView(Content content) {\n      ...\n    }        \n}\n\n\npublic class Buyer {\n    private User user;\n    \n    private List&lt;Order&gt; orders;\n    private List&lt;Payment&gt; payments;\n    \n    public Buyer(User user) {\n        ...\n    }\n    \n    // 订单上下文\n    public void placeOrder(Column column) {\n      ...\n    }    \n}\n\n\npublic class Contact {\n    private User user;\n    \n    private List&lt;Friendship&gt; friends;\n    private List&lt;Moments&gt; moments;\n    \n    public Contact(User user) {\n        ...\n    }\n    \n    // 社交上下文\n    public void make(Friendship friend) {\n      ...\n    }\n    \n    public void break(Friendship friend) {\n      ...\n    }\n</code></pre><p>我们很容易地将不同上下文中的行为与逻辑富集到对应的角色对象中，并且与领域模型中的概念完全对应起来。然而这里还有最后一个问题，就是<strong>如何构造这些装饰器对象。</strong></p><p>从代码中我们可以看到，除了行为之外，我们将对应的聚合与关联关系也都富集于角色对象里了，而这些被聚合的对象极大可能是被持久化在数据库中的数据。所以，简单的调用构造函数，并不能保证我们能从数据库中有效地读取这些数据：</p><pre><code>User user = repository.findById(....);\n\n\nBuyer buyer = new Buyer(user); // 内存中构造角色对象\nReader reader = new Reader(user); // 并不会从数据库中读取\nContact contact = new Contact(user); // 其上的关联关系\n</code></pre><p>所以，我们需要将构造角色对象的逻辑放置在能够触发技术调用的地方。那么最自然的一个选择，就是Repository对象了。</p><pre><code>public interface UserRepository {\n    User findById(long id); \n    \n    Buyer asBuyer(User user); \n    \n    Reader asReader(User user);\n    \n    Contact asContact(User user);\n}\n\n\npublic class UserRepositoryDB implements UserRepository {\n    public User findById(long id) {\n        return db.executeQuery(...)\n    }\n    \n    public Buyer asBuyer(User user) {\n        return new Buyer(user, db.executeQuery(...));\n    }\n    \n    public Reader asReader(User user) {\n        return new Reader(user, db.executeQuery(...));\n    }\n    \n    public Contact asContact(User user) {\n        return new Contact(user, db.executeQuery(...));\n    }\n}\n</code></pre><p>于是，我们获取角色对象的方法也就可以变成：</p><pre><code>User user = repository.findById(....);\n\n\nBuyer buyer = repository.asBuyer(user);\nReader reader = repository.asReader(user);\nContact Contact = repository.asContact(user);\n</code></pre><p>到此为止，通过角色对象我们得到了还不错的结果——几乎就是完美的方案了。这个方案的优势有以下几点。</p><p>首先，我们<strong>把不同上下文中的逻辑分别富集于不同的角色对象中</strong>。</p><p>当我们需要改动代码时，只需要找到对应上下文中的角色对象，在角色对象中进行修改即可。这一方面解决了认知过载的问题，避免了模型僵化。另一方面，因为角色对象的封装，代码的改变并不会进行传播。</p><p>比如如果我们需要修改订阅上下文中的逻辑，只需找到与订阅上下文相关的角色对象Reader就行了。因为我们只改动了Reader，而User、Buyer、Contact都没有任何变化，所以这个修改没有传播到其他的上下文中。</p><p>与之对比的是，如果没有角色对象，我们就需要在User中修改，那么修改就会被传播到所有的上下文中。</p><p>其次，<strong>从实体对象转化到角色对象经由了显式的方法调用</strong>（asBuyer、asReader、asContact）<strong>，这实际上表示了上下文切换</strong>。</p><p>也就是说，当我们调用asBuyer时，我们的上下文就从无限定上下文，切换到了订单上下文。那么在这个上下文中，我们对影响性能的集合加载就有了更明确的答案（比如订单历史预加载、支付历史延迟加载等等），进一步避免因为性能问题，破坏模型与软件实现的一致性。</p><p>不过你应该注意到了，我刚才说这“几乎是完美的方案”。那是因为我们还可以<strong>在揭示意图与技术解耦上做得更好</strong>。</p><h2>通过上下文对象分离不同上下文中的逻辑</h2><p>如同我们之前在关联对象中讲到的，获取关联集合的方式可能是异构的，也就是不止从数据库中读取这一种方法。如果社交上下文中的朋友关系，是通过服务接口调用，从其他社交平台获取的呢？这个时候，我们将asContact方法置于UserRepositoryDB之内，就显得不那么合适了。</p><p>我们来换个思路。我们可以遵循关联对象的思路，将上下文直接建模出来，并通过接口隔离具体实现：</p><pre><code>interface SubscriptionContext {\n    interface Reader {\n        boolean canView(Content content);    \n    }\n    \n    Reader asReader(User user);\n}\n\n\ninterface SocialContext {\n    interface Contact {\n        void make(Friendship friend);\n        void break(Friendship friend);\n    }\n    \n    Contact asContact(User user);\n}\n\n\ninterface OrderContext {\n    interface Buyer {\n        void placeOrder(Column column);        \n    }\n    \n    Buyer asBuyer(User user);\n</code></pre><p>那么，我们就可以将上下文对象的获取放置在UserRepository上，对它进行改写：</p><pre><code>interface UserRepository {\n    User findUserById(long id);\n    \n    SubscriptionContext inSubscriptionContext();\n    SocialContext inSocialContext();\n    OrderContext inOrderContext();\n}\n\n\npublic class UserRepositoryDB {\n    //通过依赖注入获取不同的上下文对象\n    @Inject private SubscriptionContext subscriptionContext;     \n    \n    @Inject private SocialContext socialContext;\n    \n    @Inject private OrderContext orderContext;\n    \n    ...\n}\n\n最后的使用方式就成了：\n\nUserRepository users = ....;\n\n\nUser user = users.findUserById(...);\n\n\nBuyer buyer = users.inOrderContext().asBuyer(user);\nReader reader = users.inSubscriptionContext().asReader(user);\nContact contact = users.inSocialContext().asContact(user);\n</code></pre><p>现在这就是完美的方案。通过增加上下文对象，我们获得了诸多好处。</p><p>第一，<strong>借由上下文对象的封装，不同上下文中的技术可以是完全异构的</strong>。也就是在不同的上下文中，我们可以使用不同的技术方案。而这些技术的细节，不会暴露给外在的使用者。</p><p>比如订阅上下文可以是数据库的，社交上下文是通过三方API与外界服务整合的，订单上下文则是通过消息系统（Messaging System）与企业内进销存系统整合的。</p><p>第二，<strong>软件实现、模型与统一语言更加紧密地关联在了一起</strong>。</p><p>我们知道界限上下文的名字是统一语言的一部分。在模型中虽然不以实体的形式出现，但总归还是有它的标识（虚线的上下文边界）。如果没有上下文对象，那么它不会是软件实现的一部分，总是觉得不够理想。而有了上下文对象，统一语言、领域模型和软件实现就彻底一致了。这种舒服的滋味实在难以言表啊！</p><p>第三，<strong>我们更加清楚地揭示了领域知识的意图</strong>。特别是在对照这领域模型，参看Repository接口的时候：<br>\n<img src=\"https://static001.geekbang.org/resource/image/ca/f4/ca9054cb5f3d04bd3ab755f75bf74ef4.jpg?wh=8000x4500\" alt=\"\"></p><pre><code>interface UserRepository {\n    User findUserById(long id);\n    \n    SubscriptionContext inSubscriptionContext();\n    SocialContext inSocialContext();\n    OrderContext inOrderContext();\n}\n</code></pre><p>通过这个定义，我们清晰地知道，User在三个不同的上下文中扮演不同的角色。而没有上下文对象的时候，这些信息则没有被披露，会增加理解的成本和负担。</p><h3>上下文间的依赖关系</h3><p>不过这里还有一个问题，<strong>上下文对象在处理复杂问题的时候，还能继续保持简洁和优雅吗？</strong>让我们再来看一个略微复杂的问题。比如我们要做个新业务，将我所订阅的专栏赠送给我的朋友。</p><p>直觉告诉我们，这需要跨越两个不同的上下文，才能构建这个业务。也就是说，在这个业务中，处在订阅上下文中的Reader，也是处在社交上下文中的Contact。单纯从实现它来说，问题也不难解决：</p><pre><code>User user = users.findUserById(...);\nUser friend = users.findUserById(...);\n\n\nContact contact = users.inSocialContext().asContact(user);\n\n\nReader reader = users.inSubscriptionContext().asReader(user);\nSubscription subscription = reader.getSubscriptions(...);\n\n\nif（contact.isFriend(friend)) {\n    reader.transfer(subscription, friend);\n</code></pre><p>这里的问题是，“只有朋友间才能赠送”属于领域逻辑。我们希望它被富集到模型中，而不是在模型外，那么我们要怎么处理呢？答案出乎意料得简单，在上下文对象中加入依赖就好了：</p><pre><code>public class SubscriptionContextDB implements SubscriptionContext {\n    @Inject SocialContext SocialContext; \n    \n    public Reader asReader(User user) {\n        //在这里将依赖的上下文传到角色对象中去就好了\n    }\n}\n</code></pre><p>而实现这个业务代码就成了：</p><pre><code>User user = users.findUserById(...);\nUser friend = users.findUserById(...);\n\n\nReader reader = users.inSubscriptionContext().asReader(user);\nSubscription subscription = reader.getSubscriptions(...);\n\n\nreader.transfer(subscription, friend)\n</code></pre><p>通过显式建模上下文对象，我们不光将业务逻辑富集到领域模型中，而且在跨域多个上下文实现某个业务时，上下文之间的依赖关系还成了实现细节，被封装于上下文对象中了。多么美妙啊！</p><h2>小结</h2><p>我们来简单地总结一下。当我们严格遵照“富含知识的模型”的原则，将聚合关系有关的逻辑富集到领域模型上时，很容易产生上下文过载的问题，其根源在于实体在不同的上下文中扮演了多个角色。</p><p>而上下文过载会导致模型僵化，也就是“看不懂改不动”的代码变成了“看不懂改不动”的模型，这样提炼知识的循环就无法展开了。因而我们需要将上下文从领域对象上剥离，解决办法就是角色对象和上下文对象。</p><p>需要强调的是，虽然仅仅使用角色对象也能解决问题，但是配合上下文对象一起，它们能在揭示意图的同时，使模型、统一语言与软件实现更紧密地关联在了一起，是非常有用的模式。</p><p>编辑小提示：为了方便读者间的交流学习，我们建立了微信读者群。想要加入的同学，戳此加入<a href=\"https://jinshuju.net/f/wjtvTP\">“如何落地业务建模”交流群</a>&gt;&gt;&gt;</p><h2>思考题</h2><p>关联对象、角色对象和上下文对象都属于结构模式（Structural Pattern），帮助我们组织对象中的数据。那么从行为模式（Behavioral Pattern）上看，我们还会遇到什么问题呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/36/6b/362c6b151977aa6e278252e5eb03c26b.jpg?wh=1500x1798\" alt=\"\"></p><p>欢迎把你的思考和想法分享在留言区，我会和你交流。同时呢，我也会把其中一些不错的回答置顶，供大家学习。</p>","neighbors":{"left":{"article_title":"04｜跨越现实的障碍（上）：要性能还是要模型？","id":389082},"right":{"article_title":"06 | 跨越现实的障碍（下）：架构分层就对了吗？","id":389095}},"comments":[{"had_liked":false,"id":303912,"user_name":"Geek_0e3b40","can_delete":false,"product_type":"c1","uid":1908431,"ip_address":"","ucode":"8C5468129A684E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7JkdLdZXNYZeopVSxeI8ml4MptQMCWI7oIHaJpfYuYjlV9Efic7x19lWickckLQzmTuFlgCVmVicZ9A/132","comment_is_top":true,"comment_ctime":1627086869,"is_pvip":false,"replies":[{"id":"110004","content":"keynote","user_name":"作者回复","comment_id":303912,"uid":"2537798","ip_address":"","utype":1,"ctime":1627089722,"user_name_real":"徐八叉"}],"discussion_count":2,"race_medal":0,"score":"9.2233720513667994e+18","product_id":100082101,"comment_content":"想问一下，文中的图是用什么工具画出来的？","like_count":2,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523875,"discussion_content":"keynote","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627089722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1047773,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/dd/0e17bf09.jpg","nickname":"worry","note":"","ucode":"AF2BDAF6F6370E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":558867,"discussion_content":"一个习惯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648516305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":523875,"ip_address":""},"score":558867,"extra":""}]}]},{"had_liked":false,"id":300702,"user_name":"阿鸡","can_delete":false,"product_type":"c1","uid":1589246,"ip_address":"","ucode":"F181422D4EB444","user_header":"https://static001.geekbang.org/account/avatar/00/18/3f/fe/35d1afbd.jpg","comment_is_top":false,"comment_ctime":1625315815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"186308909543","product_id":100082101,"comment_content":"魔鬼都在细节中，尝试去落地DDD的人多多少少都会遇到今天文章中说的问题。<br>从问题出发，一路分析到最终的解决方案，可见老师功力之深。<br>读下来畅快淋漓，爽！","like_count":44},{"had_liked":false,"id":301247,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1625588108,"is_pvip":false,"replies":[{"id":"109094","content":"扮演并不是派生关系 之所以不把角色做成聚合根 因为它们不是独立的对象 不会用reader buyer表 数据上都是user表。所以并不是微信和微信视频号的关系。那是关联而不是扮演。分包除非有arch unit去加测试 否则不如对象约束力强。最后 简单与否在于是否与概念中的模型一致，而不在于代码的写法","user_name":"作者回复","comment_id":301247,"uid":"2537798","ip_address":"","utype":1,"ctime":1625616454,"user_name_real":"徐八叉"}],"discussion_count":3,"race_medal":0,"score":"57460162956","product_id":100082101,"comment_content":"1.徐昊老师的代码看起来很舒服啊。就是喜欢看这种面相意图的的代码，看代码就像在看故事。<br><br>2.关于上下文，徐昊老师的这个写法我是第一次见，很有意思，长见识了。我自己一般是将上下文作为一个《应用层》到《领域层》中间的层级（乐衷于加层），用于区分不同的《领域层》。这样其实上下文就作为分包的边界在代码中体现，也算是模型与实现关联。<br><br>3.对应的仓储层不会在UserRep中收入多个上下文的操作，而是独立的BuyerRep，ReaderRep。这样做其实可以更好的分隔复杂性。但顺着老师对这些模型的定义来看，并不是很合适。因为Buyer，Reader的定义是User的角色，是一种派生。分隔包会弱化这层派生关系。可是，也不只有老师这种定义方式，如果我定义Buyer，Reader都是独立的聚合模型，与User是平级的，它们之间是聚合间平级的关系，而非 data和role的派生关系，那么在包层级上明确分隔就挺合理。拿微信来说，微信用户和微信视频号用户都是用户的派生角色吗？微信视频号用户有自己独立的用户体系，它与微信用户是两个聚合的关联关系，一个微信用户可以关联多个微信视频号用户。定义不同一切就不同。<br><br>4.我认为包结构，模块结构都算是代码的组成部分，所以也可以用来做模型与实现的关联。不知道徐昊老师怎么看？<br><br>5.感觉还是上下文分包比上下文类模型协作风险低些。这么好看的代码（真心的，没有反义），碰上不懂的弟兄，被用错，写废的概率感觉还挺高。放到大型项目，团队协作，这真的挺让人担忧。这又涉及到一个决策点，是模型的简单重要还是模型的准确重要。我认为跳出来，看哪个对当前的团队当前的处境效益较高就哪个重要。如果硬要选一个，我选简单，可读比卓越重要（来自《实现模式》的价值观），可读要有同理心。","like_count":13,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522942,"discussion_content":"扮演并不是派生关系 之所以不把角色做成聚合根 因为它们不是独立的对象 不会用reader buyer表 数据上都是user表。所以并不是微信和微信视频号的关系。那是关联而不是扮演。分包除非有arch unit去加测试 否则不如对象约束力强。最后 简单与否在于是否与概念中的模型一致，而不在于代码的写法","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625616454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246273,"avatar":"https://static001.geekbang.org/account/avatar/00/13/04/41/082e2706.jpg","nickname":"keep_curiosity","note":"","ucode":"794DC1D3FB9214","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384062,"discussion_content":"赞同老师说的：“简单与否在于是否与概念中的模型一致，而不在于代码的写法”。模型的简单和准确有时候不冲突。团队的收益也要从长远看，团队是在成长的，好的代码看多了就会写了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626348246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1766740,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELpFhr06SHLSicj6ZjR68aRuy6q939nGqHUAROuxNc5Cks2d8gylonwyozYT3v3ibrqKmPmWibAjuIHg/132","nickname":"重放","note":"","ucode":"4D0FCF38F9AED3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545340,"discussion_content":"认同你说的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641911921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303114,"user_name":"邓志国","can_delete":false,"product_type":"c1","uid":1043844,"ip_address":"","ucode":"380AE67ED7B9D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/84/0b8e2d25.jpg","comment_is_top":false,"comment_ctime":1626598272,"is_pvip":false,"replies":[{"id":"109693","content":"实现随便耦合 接口看不出来就行 耦合不是坏事 不当耦合才是","user_name":"作者回复","comment_id":303114,"uid":"2537798","ip_address":"","utype":1,"ctime":1626603533,"user_name_real":"徐八叉"}],"discussion_count":4,"race_medal":0,"score":"53166205824","product_id":100082101,"comment_content":"把社交的上下文传递到reader里，是不是让reader耦合了社交呢？","like_count":12,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523554,"discussion_content":"实现随便耦合 接口看不出来就行 耦合不是坏事 不当耦合才是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626603533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550289,"discussion_content":"“实现随便耦合 接口看不出来就行”？这个我也没理解，这样真的可以吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644474195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1766740,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELpFhr06SHLSicj6ZjR68aRuy6q939nGqHUAROuxNc5Cks2d8gylonwyozYT3v3ibrqKmPmWibAjuIHg/132","nickname":"重放","note":"","ucode":"4D0FCF38F9AED3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545341,"discussion_content":"1、实现耦合带来的间接依赖关系会导致各种包冲突 2、随便耦合碰到不懂的同学开发随便依赖随便用代码就乱了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641912019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1056127,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/7f/aabc1b66.jpg","nickname":"hetiu","note":"","ucode":"35D9338C3ABD20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404974,"discussion_content":"实现随便耦合真的合适吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634476520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303136,"user_name":"勿更改任何信息","can_delete":false,"product_type":"c1","uid":2028956,"ip_address":"","ucode":"575185C69C05A3","user_header":"","comment_is_top":false,"comment_ctime":1626607397,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23101443877","product_id":100082101,"comment_content":"最后一个赠送的举例没明白，朋友才能赠送的规则在哪里体现了？","like_count":5,"discussions":[{"author":{"id":1682027,"avatar":"https://static001.geekbang.org/account/avatar/00/19/aa/6b/ab9a072a.jpg","nickname":"对与错","note":"","ucode":"EF55733E3BD78B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391877,"discussion_content":"这里最终的实现应该就是订阅的上下文依赖社交的上下文，只是在聚合根的使用那一层(也就是user)不关注底下的实现细节","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630669011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560487,"discussion_content":"个人觉得依赖正好体现了模型和实现的关联，模型表达的需求是购买的专栏送给朋友，本身就涉及两个上下文了，实现上两个上下文必然就会有所关联。如果从实现的角度来讲，想要避免高耦合，则需要再加一个新的上下文专门用来组合这两个上下文，比如就叫“赠送好友”上下文（狗头），当然这样的话就要同步到领域模型上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649345063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042362,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e7/ba/aceadf0b.jpg","nickname":"RoyLING","note":"","ucode":"8F311F2CFB2DA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386474,"discussion_content":"我也有同样的疑问🤔️如果是移到了transfer里，那订阅上下文里会依赖社交上下文","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627608098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327530,"user_name":"黄大仙","can_delete":false,"product_type":"c1","uid":1610676,"ip_address":"","ucode":"6C79E6991EC3B8","user_header":"https://static001.geekbang.org/account/avatar/00/18/93/b4/22f438d0.jpg","comment_is_top":false,"comment_ctime":1640162906,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14525064794","product_id":100082101,"comment_content":"跌跌撞撞地实践后，回过头来看这篇，如获至宝。<br>通过上下文隔离，把原先的复杂的综合模型，拆到不同的上下文中，保证了上下文内逻辑的纯净。<br>但这里面涉及到一个问题，User 转换为 Buyer 的过程该不该放到领域层中，还是交由基础层自由自在地实现？文中所说的是后者，也就是只声明 interface Buyer，由实现层来实现 class BuyerImpl implements Buyer。<br>感觉这样有点太灵活了，是把双刃剑。领域层声明了它的行为，并完全不声明它的实现。实现层要做很多事情，才能跑起来。如果灵活下放过度，领域层就变成了一个精致地空架子，如果替换基础层的一些设施，需要大量地改动才能迁移过去。","like_count":3},{"had_liked":false,"id":304093,"user_name":"子龙","can_delete":false,"product_type":"c1","uid":1418784,"ip_address":"","ucode":"B7D755021D6296","user_header":"https://static001.geekbang.org/account/avatar/00/15/a6/20/13f6462f.jpg","comment_is_top":false,"comment_ctime":1627231389,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14512133277","product_id":100082101,"comment_content":"如果是微服务设计，请问这几个上下文是不是应该独立成服务，那user表的数据怎么共享呢？","like_count":3,"discussions":[{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560488,"discussion_content":"调用user服务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649345141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303045,"user_name":"卓然","can_delete":false,"product_type":"c1","uid":1202149,"ip_address":"","ucode":"F0E173FD82181B","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/e5/0af7593f.jpg","comment_is_top":false,"comment_ctime":1626536845,"is_pvip":false,"replies":[{"id":"109664","content":"不行 实体是一个 行为不同","user_name":"作者回复","comment_id":303045,"uid":"2537798","ip_address":"","utype":1,"ctime":1626569121,"user_name_real":"徐八叉"}],"discussion_count":1,"race_medal":0,"score":"14511438733","product_id":100082101,"comment_content":"不要user模型，直接建模reader,buyer,contact不行吗?","like_count":3,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523531,"discussion_content":"不行 实体是一个 行为不同","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626569121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301091,"user_name":"赵晏龙","can_delete":false,"product_type":"c1","uid":2673605,"ip_address":"","ucode":"F15730BCA97EE0","user_header":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","comment_is_top":false,"comment_ctime":1625534969,"is_pvip":false,"replies":[{"id":"109060","content":"可以 扮演角色 有不同的实现方法","user_name":"作者回复","comment_id":301091,"uid":"2537798","ip_address":"","utype":1,"ctime":1625538519,"user_name_real":"徐八叉"}],"discussion_count":1,"race_medal":0,"score":"10215469561","product_id":100082101,"comment_content":"到了角色一步，我觉得我遇到的问题基本就解决了，因为我会把【角色】作为【聚合根】使用，可以解释为：在特定上下文中，Buyer、Reader、Contact就是聚合根，User只是一个在它们之间起到关联作用的类，只在【关联关系】相关逻辑上下文中进行使用。我觉得这样建模能够更进一步的将模型解耦。<br>所以我并没有很好的理解，我这样的解决方案是否还存在老师您讲的后面这些问题。","like_count":2,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522893,"discussion_content":"可以 扮演角色 有不同的实现方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625538519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352696,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1658886872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5953854168","product_id":100082101,"comment_content":"基础设施层的划分，不是那么困难的事情，恕我实话实说，这篇文章做的方案过于复杂，写的内容过于繁琐。可以参考下《领域驱动设计》和《实现领域驱动设计》两本书，结合实际才能写出有用的东西。","like_count":1},{"had_liked":false,"id":323138,"user_name":"陈小虎","can_delete":false,"product_type":"c1","uid":1218864,"ip_address":"","ucode":"CB8707CE7F0BB7","user_header":"https://static001.geekbang.org/account/avatar/00/12/99/30/231af749.jpg","comment_is_top":false,"comment_ctime":1637741591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5932708887","product_id":100082101,"comment_content":"就记住了一句话：多么每秒啊！：）","like_count":1},{"had_liked":false,"id":310521,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1630719132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5925686428","product_id":100082101,"comment_content":"“通过上下文对象分离不同上下文中的逻辑” 一节中，UserRepositoryDB 的接口定义是不是缺少了实现UserRepository ，应该是public class UserRepositoryDB implements UserRepository {...}，这样SubscriptionContext 等xxxContext的上下文切换实现都放到UserRepositoryDB 中","like_count":1},{"had_liked":false,"id":300999,"user_name":"威","can_delete":false,"product_type":"c1","uid":1068542,"ip_address":"","ucode":"C921CDCB22B9A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/fe/882eaf0f.jpg","comment_is_top":false,"comment_ctime":1625480380,"is_pvip":false,"replies":[{"id":"109041","content":"我也不喜欢游离于上下文之外的服务 那不过是过程的另一个名字 不够面向对象","user_name":"作者回复","comment_id":300999,"uid":"2537798","ip_address":"","utype":1,"ctime":1625482010,"user_name_real":"徐八叉"}],"discussion_count":4,"race_medal":0,"score":"5920447676","product_id":100082101,"comment_content":"在最后一个赠送课程的例子里，是不是可以用领域服务这概念去包装赠送的逻辑呢，因为从另一个角度看，赠送的业务逻辑，也的确是需要通过多个上下文协作完成，好像放领域服务里也合适","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522870,"discussion_content":"我也不喜欢游离于上下文之外的服务 那不过是过程的另一个名字 不够面向对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625482010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246273,"avatar":"https://static001.geekbang.org/account/avatar/00/13/04/41/082e2706.jpg","nickname":"keep_curiosity","note":"","ucode":"794DC1D3FB9214","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384064,"discussion_content":"如果抛弃领域服务，全部采用注入的方式就可能会出现循环依赖的情况吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626348480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204947,"avatar":"https://static001.geekbang.org/account/avatar/00/12/62/d3/663de972.jpg","nickname":"懵逼猴","note":"","ucode":"BDC748A96AC316","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1246273,"avatar":"https://static001.geekbang.org/account/avatar/00/13/04/41/082e2706.jpg","nickname":"keep_curiosity","note":"","ucode":"794DC1D3FB9214","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570884,"discussion_content":"我感觉也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651983374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384064,"ip_address":""},"score":570884,"extra":""}]},{"author":{"id":1204947,"avatar":"https://static001.geekbang.org/account/avatar/00/12/62/d3/663de972.jpg","nickname":"懵逼猴","note":"","ucode":"BDC748A96AC316","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570885,"discussion_content":"我也想到这个了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651983402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300977,"user_name":"狩月","can_delete":false,"product_type":"c1","uid":1204178,"ip_address":"","ucode":"472CCBFBE77785","user_header":"https://static001.geekbang.org/account/avatar/00/12/5f/d2/a39e5cea.jpg","comment_is_top":false,"comment_ctime":1625474143,"is_pvip":false,"replies":[{"id":"109040","content":"然而模型表达不了规则 怎么也要到代码里","user_name":"作者回复","comment_id":300977,"uid":"2537798","ip_address":"","utype":1,"ctime":1625479772,"user_name_real":"徐八叉"}],"discussion_count":3,"race_medal":0,"score":"5920441439","product_id":100082101,"comment_content":"在实现中加入上下文依赖， 这样是不是隐藏了“必须得是friend才能赠送订阅”这个领域知识？ 毕竟从领域层已经看不到这个逻辑了， 业务逻辑相当于下放了？","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522867,"discussion_content":"然而模型表达不了规则 怎么也要到代码里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625479772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610676,"avatar":"https://static001.geekbang.org/account/avatar/00/18/93/b4/22f438d0.jpg","nickname":"黄大仙","note":"","ucode":"6C79E6991EC3B8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393217,"discussion_content":"确实感觉会下放了好多到实现中，并且强行规定实现得遵循这些逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631301867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1067638,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/76/abb7bfe3.jpg","nickname":"大海浮萍","note":"","ucode":"7A3B9011C639ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384529,"discussion_content":"是放到实体行为中了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626637311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359597,"user_name":"Geek_744031","can_delete":false,"product_type":"c1","uid":2659268,"ip_address":"浙江","ucode":"30152D64E12370","user_header":"","comment_is_top":false,"comment_ctime":1665667233,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1665667233","product_id":100082101,"comment_content":"如果user和角色是聚合， 那么 Subscription 是不是不能暴露给App 层呢， 是不是应该改成<br> User user = users.findUserById(...);<br>User friend = users.findUserById(...);<br>Reader reader = users.inSubscriptionContext().asReader(user);<br>reader.transferMySub(subscription, friend);","like_count":0},{"had_liked":false,"id":358833,"user_name":"JianXu","can_delete":false,"product_type":"c1","uid":1033219,"ip_address":"上海","ucode":"2A61BDBB573BDC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/03/f753fda7.jpg","comment_is_top":false,"comment_ctime":1664873050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664873050","product_id":100082101,"comment_content":"public class UserRepositoryDB implements UserRepository {<br>    public User findById(long id) {<br>        return db.executeQuery(...)<br>    }<br>    <br>    public Buyer asBuyer(User user) {<br>        return new Buyer(user, db.executeQuery(...));<br>    }<br>    …<br>｝<br><br>老师，这个例子里面Buyer的构造函数参数里 db.executeQuery 里的内容是不是去拿Orders 和Payments 两个列表内容从而和User 拼装成Buyer 对象？因为这个时候orders 和 payments 已经不再是user 的成员变量而变成buyer 的成员变量了。","like_count":0},{"had_liked":false,"id":357010,"user_name":"李全党","can_delete":false,"product_type":"c1","uid":2798956,"ip_address":"北京","ucode":"83F45875ABB083","user_header":"https://static001.geekbang.org/account/avatar/00/2a/b5/6c/494696df.jpg","comment_is_top":false,"comment_ctime":1662855903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662855903","product_id":100082101,"comment_content":"user对象创建的时候，是不是要把它的属性全部加载，会不会影响性能","like_count":0},{"had_liked":false,"id":354340,"user_name":"如影相随","can_delete":false,"product_type":"c1","uid":1161747,"ip_address":"陕西","ucode":"48C3B75C30C5EF","user_header":"https://static001.geekbang.org/account/avatar/00/11/ba/13/22d28c56.jpg","comment_is_top":false,"comment_ctime":1660291833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660291833","product_id":100082101,"comment_content":"你好，比如User里面有个属性：isAdult: Boolean表示是否成年，<br>那我们的更新操作放在User合理吗？<br>class User {<br>   private userId：String<br>   ...<br>   private isAdult: Boolean;<br><br>   public void updateAdult(newValue: Boolean) {<br>        this.isAdult = newValue<br>   }<br>}<br>","like_count":0},{"had_liked":false,"id":354281,"user_name":"小乐天天","can_delete":false,"product_type":"c1","uid":1010513,"ip_address":"广东","ucode":"1E3D6AB1C629D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/51/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1660247205,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660247205","product_id":100082101,"comment_content":"这个方案，以后不同的上下文要拆成不同的微服务如何处理？","like_count":0},{"had_liked":false,"id":352135,"user_name":"Geek_1aaf73","can_delete":false,"product_type":"c1","uid":2940060,"ip_address":"","ucode":"DC65D1763AE9D0","user_header":"","comment_is_top":false,"comment_ctime":1658396419,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658396419","product_id":100082101,"comment_content":"这篇文章看懂了，确实很美妙，但是用在微服务里面，有同样的疑问，比如订单中心微服务，聚合根不是订单么？ 请老师帮忙看下这个问题，不知道文章后面会不会有解答。","like_count":0},{"had_liked":false,"id":351845,"user_name":"小尹","can_delete":false,"product_type":"c1","uid":2968597,"ip_address":"","ucode":"E341E87A535AA2","user_header":"https://static001.geekbang.org/account/avatar/00/2d/4c/15/16d851ce.jpg","comment_is_top":false,"comment_ctime":1658225460,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658225460","product_id":100082101,"comment_content":"感觉对象真的是太多了","like_count":0},{"had_liked":false,"id":351468,"user_name":"王毅","can_delete":false,"product_type":"c1","uid":1204208,"ip_address":"","ucode":"D06D1EBC440FC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/5f/f0/0c4b1548.jpg","comment_is_top":false,"comment_ctime":1657810434,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657810434","product_id":100082101,"comment_content":"这个上下文的语法是特定语言，php没有这个语法，怎么做这种领域建模？ 继承？","like_count":0},{"had_liked":false,"id":348323,"user_name":"coley wu","can_delete":false,"product_type":"c1","uid":1082095,"ip_address":"","ucode":"B2C0AD8F970981","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/ef/0badf9dc.jpg","comment_is_top":false,"comment_ctime":1654959277,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654959277","product_id":100082101,"comment_content":"分而治之","like_count":0},{"had_liked":false,"id":345618,"user_name":"hk","can_delete":false,"product_type":"c1","uid":1057377,"ip_address":"","ucode":"92996CA0BCDD66","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/61/580bb3c3.jpg","comment_is_top":false,"comment_ctime":1652433435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652433435","product_id":100082101,"comment_content":"八叉老师你好，有空时麻烦再解惑一下，比如电商领域，买家&#47;卖家，供应商&#47;采购商&#47;分销商等是否都可以采用这种角色扮演来做上下文的隔离吗？打车领域，会员&#47;乘客&#47;司机是否也可以采用这种角色扮演来做上下文的隔离，谢谢！","like_count":0},{"had_liked":false,"id":345471,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1652315533,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652315533","product_id":100082101,"comment_content":"初看感觉DDD很美妙，细品起来，业务是不是被拆的七零八落，跟传统的三层结构比较，纵然应对变化的能力提高了，但是从代码的阅读上来说，需要各个类的去理解业务，总觉得不那么方便，当然，正确的方式应该是从模型去理解业务比较直观，但是对于程序员来说，代码才是他们的统一语言。学会了DDD对于设计者来说增强了他们对业务的掌控，对于程序员来说，有他无他没甚影响，代码该咋写咋写，还要费我脑子给你分解业务，考虑设计的可行性，所以说，从程序员的人性去看，想推动ddd或者其他的建模方法应该挺难的","like_count":0},{"had_liked":false,"id":341204,"user_name":"Geek_0c38c8","can_delete":false,"product_type":"c1","uid":2798485,"ip_address":"","ucode":"3BFA4258449584","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epocEfxaGah7biaH6mEEo55eXqMSDK1ft5O6YyLS24Bo7ZRyHwAM82TOAL9AiaIccVtLeze0O3SYicyA/132","comment_is_top":false,"comment_ctime":1649419478,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649419478","product_id":100082101,"comment_content":"我觉得user关联reader,buyer,contact就可以了，就变成：user.reader.transfer(subscription, friend)","like_count":0},{"had_liked":false,"id":339969,"user_name":"worry","can_delete":false,"product_type":"c1","uid":1047773,"ip_address":"","ucode":"AF2BDAF6F6370E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/dd/0e17bf09.jpg","comment_is_top":false,"comment_ctime":1648516264,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648516264","product_id":100082101,"comment_content":"旧约是在多层架构的前提下，到了新约云原生，上下文之间的通信就变为接口了。确实感觉到了秋裤搁在袜子里的舒服","like_count":0},{"had_liked":false,"id":338422,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1647495685,"is_pvip":true,"replies":[{"id":"123701","content":"没必要","user_name":"作者回复","user_name_real":"编辑","uid":"2537798","ctime":1647498454,"ip_address":"","comment_id":338422,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1647495685","product_id":100082101,"comment_content":"老师 ddd能用在写框架上嘛 比如写个zookeper","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556747,"discussion_content":"没必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647498454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120997,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","nickname":"favorlm","note":"","ucode":"CFD52127AA6E1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573515,"discussion_content":"为什么没必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653470772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332709,"user_name":"四仔","can_delete":false,"product_type":"c1","uid":1047789,"ip_address":"","ucode":"7EACD1EA498B47","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/ed/e066bbf2.jpg","comment_is_top":false,"comment_ctime":1643512056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643512056","product_id":100082101,"comment_content":"asReader的代码没看到🐯","like_count":0},{"had_liked":false,"id":322751,"user_name":"无争就是yk","can_delete":false,"product_type":"c1","uid":1019128,"ip_address":"","ucode":"8739E996ACD746","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/f8/d378c121.jpg","comment_is_top":false,"comment_ctime":1637574720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637574720","product_id":100082101,"comment_content":"还有一个问题，SubscriptionContextDB 将SocialContext 传递给角色对象Reader，这样角色对象就需要持有SocialContext，这个就有点奇怪了，因为Reader本身是由SubscriptionContext 这个上下文对象构造的，结果自己由持有了一个上下文对象。类似这样需要跨多个上下文进行协作的复杂场景，是不是通过增加领域服务这层来解决。","like_count":0},{"had_liked":false,"id":322739,"user_name":"无争就是yk","can_delete":false,"product_type":"c1","uid":1019128,"ip_address":"","ucode":"8739E996ACD746","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/f8/d378c121.jpg","comment_is_top":false,"comment_ctime":1637571602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637571602","product_id":100082101,"comment_content":"最终的聚合对象由UserRepository 来组装会不会太重啊，需要注入很多外部对象或者其他repository到 UserRepository 吧。","like_count":0},{"had_liked":false,"id":322148,"user_name":"果然爸爸","can_delete":false,"product_type":"c1","uid":1467300,"ip_address":"","ucode":"0E5F031A0E6A69","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/a4/e663c4d4.jpg","comment_is_top":false,"comment_ctime":1637206703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637206703","product_id":100082101,"comment_content":"解了很多惑","like_count":0},{"had_liked":false,"id":321612,"user_name":".benxiaohai52","can_delete":false,"product_type":"c1","uid":1221835,"ip_address":"","ucode":"8F748310484724","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/cb/407d9a81.jpg","comment_is_top":false,"comment_ctime":1636966230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636966230","product_id":100082101,"comment_content":"<br>public class SubscriptionContextDB implements SubscriptionContext {<br>    @Inject SocialContext SocialContext; <br>    <br>    public Reader asReader(User user) {<br>        &#47;&#47;在这里将依赖的上下文传到角色对象中去就好了<br>        这块是不是从关联关系表中根据用户唯一编号查询对应关系，只要存在一条以上的记录，则就可以把用户转为读者<br>    }<br>}","like_count":0},{"had_liked":false,"id":321611,"user_name":".benxiaohai52","can_delete":false,"product_type":"c1","uid":1221835,"ip_address":"","ucode":"8F748310484724","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/cb/407d9a81.jpg","comment_is_top":false,"comment_ctime":1636965951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636965951","product_id":100082101,"comment_content":"平时在权限管理中通常给用户分配角色的关联对象是不是应该起个名字叫管理员啊，只有分配了角色的用户才叫管理员","like_count":0},{"had_liked":false,"id":321610,"user_name":".benxiaohai52","can_delete":false,"product_type":"c1","uid":1221835,"ip_address":"","ucode":"8F748310484724","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/cb/407d9a81.jpg","comment_is_top":false,"comment_ctime":1636965852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636965852","product_id":100082101,"comment_content":"1、你描述中即有Reader接口,也有Reader类，所以<br><br>interface SubscriptionContext {<br>    interface Reader {<br>        boolean canView(Content content);    <br>    }<br>    <br>    Reader asReader(User user);<br>}<br><br>你这段代码里面的Reader是指接口还是类啊","like_count":0},{"had_liked":false,"id":319659,"user_name":"此方彼方Francis","can_delete":false,"product_type":"c1","uid":1001390,"ip_address":"","ucode":"73E6C93CF1FE39","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/ae/0a5f7a56.jpg","comment_is_top":false,"comment_ctime":1635904030,"is_pvip":false,"replies":[{"id":"116202","content":"这个不需要讲吧 ","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1636377090,"ip_address":"","comment_id":319659,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635904030","product_id":100082101,"comment_content":"实现随便耦合能展开讲讲吗？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529710,"discussion_content":"这个不需要讲吧 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636377090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319592,"user_name":"金子般的心","can_delete":false,"product_type":"c1","uid":1006897,"ip_address":"","ucode":"8F6F217AF0C0EA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/31/2ccc4675.jpg","comment_is_top":false,"comment_ctime":1635860726,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1635860726","product_id":100082101,"comment_content":"自己走到山重水复之时，作者指出柳暗花明之路，爽！","like_count":0},{"had_liked":false,"id":317954,"user_name":"与非","can_delete":false,"product_type":"c1","uid":1480576,"ip_address":"","ucode":"49D764FE7007D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/97/80/33efb09a.jpg","comment_is_top":false,"comment_ctime":1635070413,"is_pvip":true,"replies":[{"id":"116205","content":"聚合与生命周期相关","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1636377199,"ip_address":"","comment_id":317954,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1635070413","product_id":100082101,"comment_content":"在订单上下文，聚合根不应该不应该是Order吗？在支付上下文中聚合根不应该是Payment.为啥是Buyer呢","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529041,"discussion_content":"聚合与生命周期相关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636377199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2940060,"avatar":"","nickname":"Geek_1aaf73","note":"","ucode":"DC65D1763AE9D0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580899,"discussion_content":"这篇文章看懂了，确实很美妙，但是用在微服务里面，有同样的疑问，比如订单中心微服务，聚合根不是订单么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658396392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316131,"user_name":"Geek_618f9a","can_delete":false,"product_type":"c1","uid":2429792,"ip_address":"","ucode":"6AEE4DD62250FD","user_header":"","comment_is_top":false,"comment_ctime":1634174246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634174246","product_id":100082101,"comment_content":"所谓架构，就是隔离变化点。总结出来 写下，能明确各种点，明确边界，把模糊的变清晰。用设计思路，再加上方法，设计输入输出，模型，时序，之后启动代码，代码质量直线上升","like_count":0},{"had_liked":false,"id":315326,"user_name":"八歌","can_delete":false,"product_type":"c1","uid":1025218,"ip_address":"","ucode":"B54B99716358DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/c2/e8ab13d7.jpg","comment_is_top":false,"comment_ctime":1633833257,"is_pvip":false,"replies":[{"id":"114191","content":"请看题外话","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1633876084,"ip_address":"","comment_id":315326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633833257","product_id":100082101,"comment_content":"自己的想法，不知道对不对：<br><br>1. 关联对象 相当于抽像的规范，而 角色对象 和 上下文对象，是对于关联对象的特殊实现, 本质上，都是关联对象。<br><br>2. 既然本质上都是 关联对象，那么其实本质上并没解决上下文过载（Context Overloading）的问题。<br><br>3. 为什么看起来像解决了？而且还很完美，是关联对象里面又可聚合关联对象，大拆小，就OK了。<br><br>4. 那为什么不统一就叫关联对象？ 如果统一语言只定义技术，那确实可以，关联对象就像以前UML里面的类图一样，一般人看不懂，而 角色对象 和 上下文对象，对于技术人员和非技术人员，就好理解的多。<br><br>5. 技术上，实现方式略有不同，针对不同场景选用<br>\t1.) 关联对象： getXXX() return new XXX(this)<br>\t2.) 角色对象： asYYY() return (YYY)this;<br>\t3.) 上下文对象： @Inject ZZZContext;<br>","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527933,"discussion_content":"请看题外话","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633876084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311586,"user_name":"黄大仙","can_delete":false,"product_type":"c1","uid":1610676,"ip_address":"","ucode":"6C79E6991EC3B8","user_header":"https://static001.geekbang.org/account/avatar/00/18/93/b4/22f438d0.jpg","comment_is_top":false,"comment_ctime":1631324463,"is_pvip":true,"replies":[{"id":"112900","content":"职责太多上下文就没划对","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1631326657,"ip_address":"","comment_id":311586,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1631324463","product_id":100082101,"comment_content":"上下文的接口发展到后面会不会职责太多？<br>这时候所有的实体类的 inXXXContext() 方法全部返回同一个上下文，在选择其转换方法时，就得费劲找了","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526667,"discussion_content":"职责太多上下文就没划对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631326657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610676,"avatar":"https://static001.geekbang.org/account/avatar/00/18/93/b4/22f438d0.jpg","nickname":"黄大仙","note":"","ucode":"6C79E6991EC3B8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393254,"discussion_content":"您的意思是上下文过载出现太多表明划分有问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631328703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310181,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1205777,"ip_address":"","ucode":"EB19F80070FE23","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/11/f7408e3e.jpg","comment_is_top":false,"comment_ctime":1630536795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630536795","product_id":100082101,"comment_content":"统一语言、领域模型和软件实现就彻底一致了。这种舒服的滋味实在难以言表啊！","like_count":0},{"had_liked":false,"id":310096,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1630484155,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1630484155","product_id":100082101,"comment_content":"通俗地讲，就是“看不懂、改不动”，代码就变成“祖传代码”了。<br>老师，这里的代码为什么会看不懂呢？就算是大类，仔细分析分析，我感觉也能看明白的呀","like_count":0,"discussions":[{"author":{"id":1254112,"avatar":"https://static001.geekbang.org/account/avatar/00/13/22/e0/6295a753.jpg","nickname":"Harvey","note":"","ucode":"164D1178DA091A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541452,"discussion_content":"看不懂的意思是需要花时间读懂，而且隔一段时间再读又要花时间，时间就是企业的成本，这也是为什么某些编程语言会成为企业宠儿的原因，就是因为它比其他语言效率高，哪怕只高一点点，放大到几万人的企业就会体现出优势。所以维护一段代码需要10分钟还是需要1整天对企业来讲区别太大了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640368818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2429792,"avatar":"","nickname":"Geek_618f9a","note":"","ucode":"6AEE4DD62250FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403894,"discussion_content":"太内聚，或者说user里的功能变成了很多模块，不同角色就是不同模块，这样就成了高耦合，有啥变化，就不好改动。业务建模，跟面向对象原则是不冲突的。这个课是讲最佳实践的。高耦合，需求变化后，对应这个类的相关算法都要改。 把user外面再套一层角色，就好很多，因为都是user，但角色不同，做的事不互相关联，未来角色需求变化后，改动范围也小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634179181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308927,"user_name":"Marshall","can_delete":false,"product_type":"c1","uid":1197456,"ip_address":"","ucode":"E10A19386B0A9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/90/b2e7437a.jpg","comment_is_top":false,"comment_ctime":1629863132,"is_pvip":false,"replies":[{"id":"111927","content":"道理一样 找到控制生命周期的地方 注入","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1630024543,"ip_address":"","comment_id":308927,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629863132","product_id":100082101,"comment_content":"一个用户实体按上下文用装饰器的方式拆分，确实以前不知道。这里还涉及了接口和注入，如果是python语言因为没有接口，比如flask或者django框架，有什么建议吗？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525685,"discussion_content":"道理一样 找到控制生命周期的地方 注入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630024543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305958,"user_name":"鸭子","can_delete":false,"product_type":"c1","uid":1048496,"ip_address":"","ucode":"A973B86BEC352C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/b0/a3e19c70.jpg","comment_is_top":false,"comment_ctime":1628242978,"is_pvip":false,"replies":[{"id":"110701","content":"依赖的是接口。随便实现个delegation就解开了","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1628247997,"ip_address":"","comment_id":305958,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628242978","product_id":100082101,"comment_content":"public class SubscriptionContextDB implements SubscriptionContext {<br>    @Inject SocialContext SocialContext; <br>    <br>    public Reader asReader(User user) {<br>        &#47;&#47;在这里将依赖的上下文传到角色对象中去就好了<br>    }<br>}<br>这个地方看起来有点隐患，在考虑业务的前提，如果SocialContextDB对象也要同时注入SubscriptionContext对象时就会遇到循环依赖的问题。","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524576,"discussion_content":"依赖的是接口。随便实现个delegation就解开了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628247997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303628,"user_name":"Geek_39fa7f","can_delete":false,"product_type":"c1","uid":1587075,"ip_address":"","ucode":"8C578C1F85132C","user_header":"","comment_is_top":false,"comment_ctime":1626882755,"is_pvip":false,"replies":[{"id":"109905","content":"不同模式","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626914487,"ip_address":"","comment_id":303628,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626882755","product_id":100082101,"comment_content":"所以说上下文基本就替代了关联对象？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523764,"discussion_content":"不同模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626914487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303139,"user_name":"fzhichao","can_delete":false,"product_type":"c1","uid":1360395,"ip_address":"","ucode":"2C45A05EB60803","user_header":"https://static001.geekbang.org/account/avatar/00/14/c2/0b/57b6c3ff.jpg","comment_is_top":false,"comment_ctime":1626611283,"is_pvip":true,"replies":[{"id":"109706","content":"我觉得scala的implicit conversation最自然。ruby include module 表示context也可","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626612869,"ip_address":"","comment_id":303139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626611283","product_id":100082101,"comment_content":"如果别的语言呢，比如ruby 通过module或者rails的concern来拆解，感觉concern是不是同样的意图（asReader 或者 asBuyer）？当然单纯的concern是没有办法强制隔离的（你依然可以把代码混在一起写）也许再加上rails engine 拆开？（subscription、social等）然后通过unit test保证每个组件都是可以单测无依赖的（如果tdd的话，那肯定就可以保证了）","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523561,"discussion_content":"我觉得scala的implicit conversation最自然。ruby include module 表示context也可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626612869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301047,"user_name":"箭和方糖","can_delete":false,"product_type":"c1","uid":1938767,"ip_address":"","ucode":"818AAAFC0FD681","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIibashTHtGDWH5L0NlbuOrA6ZuI4uc1HkMD0hbIt8iaoH8hFf3jpb8jjhsvrRLTIazZP3YoR5WpMpg/132","comment_is_top":false,"comment_ctime":1625495420,"is_pvip":false,"replies":[{"id":"109044","content":"repo里可以注入技术上下文","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1625496183,"ip_address":"","comment_id":301047,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625495420","product_id":100082101,"comment_content":"又是一个特别好的模式解决一个常见的问题，赞👍<br><br>有一个地方不太理解，上下文对象放在UserRepo的好处是什么？可不可以是standalone的？这两个哪个更好","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522884,"discussion_content":"repo里可以注入技术上下文","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625496183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300965,"user_name":"koofrank","can_delete":false,"product_type":"c1","uid":1006226,"ip_address":"","ucode":"3A1C25859E8507","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5a/92/33bbbcac.jpg","comment_is_top":false,"comment_ctime":1625471975,"is_pvip":false,"replies":[{"id":"109039","content":"实现里随便 可参考下一课","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1625479691,"ip_address":"","comment_id":300965,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625471975","product_id":100082101,"comment_content":"&#47;&#47; 订单上下文 public void placeOrder(Column column) { ... }<br><br>这个是不是应该返回一个 Order 呢, 然后 repo 去 save, domain 这一层这个实现里面不可以调用外部吧","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522864,"discussion_content":"实现里随便 可参考下一课","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625479691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300953,"user_name":"koofrank","can_delete":false,"product_type":"c1","uid":1006226,"ip_address":"","ucode":"3A1C25859E8507","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5a/92/33bbbcac.jpg","comment_is_top":false,"comment_ctime":1625465717,"is_pvip":false,"replies":[{"id":"109029","content":"没","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1625469972,"ip_address":"","comment_id":300953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625465717","product_id":100082101,"comment_content":"有没有上述解决方案后的一个大致实现和目录结构呢, 没有看到放在 github 上面","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522862,"discussion_content":"没","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625469972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300950,"user_name":"威","can_delete":false,"product_type":"c1","uid":1068542,"ip_address":"","ucode":"C921CDCB22B9A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/fe/882eaf0f.jpg","comment_is_top":false,"comment_ctime":1625464253,"is_pvip":false,"replies":[{"id":"109030","content":"不太行 因为在统一语言里 你也不会说 什么什么上下文中的user这样","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1625470290,"ip_address":"","comment_id":300950,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1625464253","product_id":100082101,"comment_content":"如果针对不同的上下文，在各自上下文的内部都新建一个名为user的类，不同上下文中的user类的字段和方法不尽相同。这种方式可行吗？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522860,"discussion_content":"不太行 因为在统一语言里 你也不会说 什么什么上下文中的user这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625470290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204178,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5f/d2/a39e5cea.jpg","nickname":"狩月","note":"","ucode":"472CCBFBE77785","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382208,"discussion_content":"那假如在统一语言里也强化上下文的概念呢？不通的上下文很可能是不同业务团队负责的，　他们使用类似的术语但可能并没有意识到自己的上下文存在","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625474258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300936,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1625455713,"is_pvip":false,"replies":[{"id":"108996","content":"没","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1625459256,"ip_address":"","comment_id":300936,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625455713","product_id":100082101,"comment_content":"有代码仓库吗，可以提供一下吗？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522853,"discussion_content":"没","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625459256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300926,"user_name":"冯","can_delete":false,"product_type":"c1","uid":1161601,"ip_address":"","ucode":"7369C8B1A50D29","user_header":"https://static001.geekbang.org/account/avatar/00/11/b9/81/1680ec3f.jpg","comment_is_top":false,"comment_ctime":1625452191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625452191","product_id":100082101,"comment_content":"妙！","like_count":0},{"had_liked":false,"id":300820,"user_name":"lan_cyl","can_delete":false,"product_type":"c1","uid":1023972,"ip_address":"","ucode":"CBBC447BB691F4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/e4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1625395716,"is_pvip":false,"replies":[{"id":"108969","content":"上下文依赖是在实现层面上的 接口层面没有依赖。所以从模型视角 依赖是不存在的","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1625396561,"ip_address":"","comment_id":300820,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1625395716","product_id":100082101,"comment_content":"上下文对象中加入依赖，甚至在Reader中依赖其他的上下文，是不是也不太好？另外在模型中怎么体现这种依赖关系呢？<br>或者是否应该建立新的上下文，例如转赠上下文，来避免上下文之间的耦合呢？<br>","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522824,"discussion_content":"上下文依赖是在实现层面上的 接口层面没有依赖。所以从模型视角 依赖是不存在的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625396561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023972,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/e4/abb7bfe3.jpg","nickname":"lan_cyl","note":"","ucode":"CBBC447BB691F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382145,"discussion_content":"上下文之间的依赖是实现细节上的依赖，这个可以理解\n但是Reader在富集业务逻辑的时候，也依赖了社交上下文，这个就不算是实现上的依赖了吧？难道说Reader也是实现细节吗？‘朋友之间才能转增’的业务逻辑是否应该在模型上反映呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625450620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204178,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5f/d2/a39e5cea.jpg","nickname":"狩月","note":"","ucode":"472CCBFBE77785","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1023972,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/e4/abb7bfe3.jpg","nickname":"lan_cyl","note":"","ucode":"CBBC447BB691F4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382235,"discussion_content":"&#34;将依赖的上下文传到角色对象中&#34;,  这里我理解Reader是依赖了social上下文的， 应该不止是实现细节， 在领域层也是有这个依赖的， 毕竟reader来自另外一个上下文。\n如果这样的话，“朋友之间才能转增”的逻辑可以在Reader里体现的， 只是转增能否成功无法通过transfer方法看出来....我也觉得这里是否应该建立另外一个上下文， 或者使用领域服务？期待老师解答","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625481901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":382145,"ip_address":""},"score":382235,"extra":""}]}]},{"had_liked":false,"id":300799,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1625391540,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625391540","product_id":100082101,"comment_content":"老师在上一节课和这节课中都提到了smalltalk，今天从Github上找到了一个开源多平台的版本，Run起来感受了一下System Browser，看了一下Collections - Arrayed实现，单看每个词都能懂，但是整段代码怎么干的就完全看不懂了。<br><br>有兴趣的同学可以自己下载来去玩一下https:&#47;&#47;github.com&#47;Cuis-Smalltalk&#47;Cuis-Smalltalk-Dev<br><br>integerAt: index<br>\t&quot;Return the integer at the given index&quot;<br>\t| word |<br>\t&lt;primitive: 165&gt;<br>\tword _ self basicAt: index.<br>\tword &lt; 16r3FFFFFFF ifTrue:[^word]. &quot;Avoid LargeInteger computations&quot;<br>\t^word &gt;= 16r80000000\t&quot;Negative?!&quot;<br>\t\tifTrue:[&quot;word - 16r100000000&quot;<br>\t\t\t\t(word bitInvert32 + 1) negated]<br>\t\tifFalse:[word]","like_count":0},{"had_liked":false,"id":300731,"user_name":"四仔","can_delete":false,"product_type":"c1","uid":1047789,"ip_address":"","ucode":"7EACD1EA498B47","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/ed/e066bbf2.jpg","comment_is_top":false,"comment_ctime":1625362085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625362085","product_id":100082101,"comment_content":"讲得真透彻！","like_count":0},{"had_liked":false,"id":300697,"user_name":"超","can_delete":false,"product_type":"c1","uid":1005939,"ip_address":"","ucode":"D574815D4A3496","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/73/e0aa8c84.jpg","comment_is_top":false,"comment_ctime":1625312737,"is_pvip":false,"replies":[{"id":"108938","content":"这篇不就是讲怎么做","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1625313977,"ip_address":"","comment_id":300697,"utype":1}],"discussion_count":6,"race_medal":0,"score":"1625312737","product_id":100082101,"comment_content":"有个疑问，系统一般行为都会跟用户有关，这样建模的话user不就会越来越多内容吗？我还是没法想象具体做系统的时候这个工程怎么实现。","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522798,"discussion_content":"这篇不就是讲怎么做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625313977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/73/e0aa8c84.jpg","nickname":"超","note":"","ucode":"D574815D4A3496","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381955,"discussion_content":"再具体点描述一下我的疑问，还是user和subscription，还是reader，reader不是应该建在subscription上下文里面吗？这里的user.inSubscribtionContext.asReader是我最疑惑的地方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625317409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/73/e0aa8c84.jpg","nickname":"超","note":"","ucode":"D574815D4A3496","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381953,"discussion_content":"抱歉，可能我的表达不清晰，我的意思，如果这样建模，也就是每多一个跟user相关的业务，我都会在user里面多一个xxx Context 的封装吗？特别是 order 和 payment，这里的建模方法给了我一个很不一样的思考方式，一下子转不过来。过往的做法是 user是user，order是order，在不同的上下文里面。也没想过会在user里面封装order的接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625317010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1005939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/73/e0aa8c84.jpg","nickname":"超","note":"","ucode":"D574815D4A3496","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381971,"discussion_content":"user保持不变，通过引入不同的role obejct。隔离不同上下文","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625325750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381953,"ip_address":""},"score":381971,"extra":""},{"author":{"id":1005939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/73/e0aa8c84.jpg","nickname":"超","note":"","ucode":"D574815D4A3496","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":381980,"discussion_content":"辛苦老师这么晚还回信息，😅，我会继续每天等更新然后努力去理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625328926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381971,"ip_address":""},"score":381980,"extra":""}]},{"author":{"id":1589246,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3f/fe/35d1afbd.jpg","nickname":"阿鸡","note":"","ucode":"F181422D4EB444","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381948,"discussion_content":"已经说了 user在不同的上下文中是不同的对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625314509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300657,"user_name":"Oops!","can_delete":false,"product_type":"c1","uid":1479474,"ip_address":"","ucode":"E2678CC12121A7","user_header":"https://static001.geekbang.org/account/avatar/00/16/93/32/e11fcd33.jpg","comment_is_top":false,"comment_ctime":1625291530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625291530","product_id":100082101,"comment_content":"行为可以是实体的功能也可以是领域内的流程，期待下面关于行为模式建模的内容。","like_count":0}]}