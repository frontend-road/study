{"id":740818,"title":"第 16 章 集合(1)","content":"<blockquote>\n<p>我们都像物理学假想中的麦克斯韦妖一样活动。正是在日常经验中，我们可以发现一向冷静的物理学家在两个世纪里对这个卡通形象一直难以忘怀的原因。生物体（organism），顾名思义，时刻在组织（organize）。我们分拣邮件、堆造沙堡、拼凑拼图、复盘棋局、收集邮票、给麦穗脱粒、按字母表顺序排列图书、创造对称形式、创作十四行诗和奏鸣曲，以及整理自己的房间。所有这些活动并不需要巨大的能量，只需保障我们能够发挥智能便可。</p>\n<p style=\"text-align: right\">——James Gleick，《信息简史》<span class=\"comment-number\">1</span></p>\n</blockquote>\n\n<p>&nbsp;</p>\n<p>Rust 标准库包含多个<strong>集合</strong>，这些集合是泛型类型，用于在内存中存储各种数据。在本书中，我们已经用到了一些集合，比如 <code>Vec</code> 和 <code>HashMap</code>。本章将详细介绍这两种类型的方法，以及另外 6 个标准集合。在开始之前，我们先来辨析一下 Rust 的集合与其他语言的集合之间的一些系统性差异。</p>\n<p>首先，移动和借用无处不在。Rust 使用移动来避免对值做深拷贝。这就是 <code>Vec&lt;T&gt;::push(item)</code> 方法会按值而非按引用来获取参数的原因。这样值就会移动到向量中。第 4 章中的示意图展示了这在实践中是如何实现的：将 Rust <code>String</code> 压入 <code>Vec&lt;String&gt;</code> 中会很快，因为 Rust 不必复制字符串的字符数据，并且字符串的所有权始终是明晰的。</p><!-- [[[read_end]]] -->\n<p>其次，Rust 没有失效型错误，也就是当程序仍持有指向集合内部数据的指针时，集合被重新调整大小或发生其他变化而导致的那种悬空指针错误。失效型错误是 C++ 中未定义行为的另一个来源，即使在内存安全的语言中，它们也会偶尔导致 <code>ConcurrentModificationException</code><span class=\"comment-number\">2</span>。Rust 的借用检查器在编译期就可以排除这些错误。</p>\n\n<p>最后，Rust 没有 <code>null</code>，因此在其他语言使用 <code>null</code> 的地方 Rust 会使用 <code>Option</code>。</p>\n<p>除了这些差异，Rust 的集合与你预期的差不多。如果你是一位经验丰富的程序员，而且时间有限，那么可以快速浏览本章，但不要错过 16.5.1 节。</p>\n<h2 id=\"nav_point_280\">16.1　概述</h2>\n<p>表 16-1 展示了 Rust 的 8 个标准集合，它们都是泛型类型。</p>\n<p><strong>表 16-1：标准集合汇总表</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th rowspan=\"2\">集合</th><th rowspan=\"2\">描述</th><th colspan=\"3\">其他语言中类似的集合类型</th></tr><tr><th>C++</th><th>Java</th><th>Python</th></tr><tr><td><code>Vec&lt;T&gt;</code></td><td>可增长数组</td><td><code>vector</code></td><td><code>ArrayList</code></td><td><code>list</code></td></tr><tr><td><code>VecDeque&lt;T&gt;</code></td><td>双端队列（可增长的环形缓冲区）</td><td><code>deque</code></td><td><code>ArrayDeque</code></td><td><code>collections.deque</code></td></tr><tr><td><code>LinkedList&lt;T&gt;</code></td><td>双向链表</td><td><code>list</code></td><td><code>LinkedList</code></td><td>—</td></tr><tr><td><code>BinaryHeap&lt;T&gt; where T: Ord</code></td><td>最大堆</td><td><code>priority_queue</code></td><td><code>PriorityQueue</code></td><td><code>heapq</code></td></tr><tr><td><code>HashMap&lt;K, V&gt; where K: Eq + Hash</code></td><td>键值哈希表</td><td><code>unordered_map</code></td><td><code>HashMap</code></td><td><code>dict</code></td></tr><tr><td><code>BTreeMap&lt;K, V&gt; where K: Ord</code></td><td>有序键值表</td><td><code>map</code></td><td><code>TreeMap</code></td><td>—</td></tr><tr><td><code>HashSet&lt;T&gt; where T: Eq + Hash</code></td><td>无序的、基于哈希的集</td><td><code>unordered_set</code></td><td><code>HashSet</code></td><td><code>set</code></td></tr><tr><td><code>BTreeSet&lt;T&gt; where T: Ord</code></td><td>有序集</td><td><code>set</code></td><td><code>TreeSet</code></td><td>—</td></tr></table>\n\n<p><code>Vec&lt;T&gt;</code>、<code>HashMap&lt;K, V&gt;</code> 和 <code>HashSet&lt;T&gt;</code> 是最常用的集合类型，其余的都各自有其基本应用场景。本章会依次讨论每种集合类型。</p>\n<blockquote>\n<p><code>Vec&lt;T&gt;</code>（普通向量）</p>\n</blockquote>\n<p>可增长的、分配在堆上的 <code>T</code> 类型值数组。本章会用大约一半的篇幅专门介绍 <code>Vec</code> 及其众多实用方法。</p>\n<blockquote>\n<p><code>VecDeque&lt;T&gt;</code>（双端队列向量）</p>\n</blockquote>\n<p>与 <code>Vec&lt;T&gt;</code> 类似，但更适合用作先入先出队列。它支持在列表的前面和后面高效地添加值和移除值，但代价是会让所有其他的操作都稍微变慢一些。</p>\n<blockquote>\n<p><code>BinaryHeap&lt;T&gt;</code>（二叉堆）</p>\n</blockquote>\n<p>优先级队列。<code>BinaryHeap</code> 中的值是精心组织过的，因此始终可以高效地查找和移除其最大值。</p>\n<blockquote>\n<p><code>HashMap&lt;K, V&gt;</code>（哈希 <code>Map</code>）</p>\n</blockquote>\n<p>由键-值对构成的表。通过键查找值很快。其条目会以任意顺序存储。</p>\n<blockquote>\n<p><code>BTreeMap&lt;K, V&gt;</code>（<code>B</code> 树 <code>Map</code>）</p>\n</blockquote>\n<p>与 <code>HashMap&lt;K, V&gt;</code> 类似，但它会根据键来对条目进行排序。<code>BTreeMap&lt;String, i32&gt;</code> 会以 <code>String</code> 的比较顺序来存储其条目。除非需要让条目保持排序状态，否则用 <code>HashMap</code> 更快一些。</p>\n<blockquote>\n<p><code>HashSet&lt;T&gt;</code>（哈希 <code>Set</code>）</p>\n</blockquote>\n<p>由 <code>T</code> 类型的值组成的 <code>Set</code>。它既能很快地添加值和移除值，也能很快地查询给定值是否在此 <code>Set</code> 中。</p>\n<blockquote>\n<p><code>BTreeSet&lt;T&gt;</code>（<code>B</code> 树 <code>Set</code>）</p>\n</blockquote>\n<p>与 <code>HashSet&lt;T&gt;</code> 类似，但它会让元素按值排序。同样，除非需要让数据保持排序状态，否则用 <code>HashSet</code> 更快一些。</p>\n<p>因为 <code>LinkedList</code> 很少使用（对于大多数用例，在性能和接口方面有更好的替代方案），所以这里就不展开讲解了。</p>\n<h2 id=\"nav_point_281\">16.2　<code>Vec&lt;T&gt;</code></h2>\n<p>因为本书中一直在使用 <code>Vec</code>，所以我们假设你对它已经比较熟悉了。有关介绍，请参阅 3.6.2 节。下面我们将详细讲解 <code>Vec</code> 的方法及内部工作原理。</p>\n<p>创建向量的最简单方法是使用 <code>vec!</code> 宏：</p>\n<pre class=\"code-rows\"><code>// 创建一个空向量\nlet mut numbers: Vec&lt;i32&gt; = vec![];\n\n// 使用给定内容创建一个向量\nlet words = vec![\"step\", \"on\", \"no\", \"pets\"];\nlet mut buffer = vec![0u8; 1024];  // 1024个内容为0的字节</code></pre>\n<p>如第 4 章所述，向量具有 3 个字段：长度、容量和指向用于存储元素的堆分配内存的指针。图 16-1 展示了前面的向量在内存中的布局方式。空向量 <code>numbers</code> 最初的容量为 0。直到添加第一个元素之前，不会为其分配堆内存。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00864.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-1：向量的内存布局：<code>words</code> 的每个元素都是一个由指针和长度组成的 <code>&amp;str</code> 值</strong></p>\n<p>与所有集合一样，<code>Vec</code> 也实现了 <code>std::iter::FromIterator</code>，所以可以使用迭代器的 <code>.collect()</code> 方法从任意迭代器创建向量，详情请参阅 15.4.13 节。</p>\n<pre class=\"code-rows\"><code>// 把另一个集合转换成向量\nlet my_vec = my_set.into_iter().collect::&lt;Vec&lt;String&gt;&gt;();</code></pre>\n<h3 id=\"nav_point_282\">16.2.1　访问元素</h3>\n<p>通过索引来获取数组、切片或向量的元素非常简单：</p>\n<pre class=\"code-rows\"><code>// 获取某个元素的引用\nlet first_line = &amp;lines[0];\n\n// 获取某个元素的副本\nlet fifth_number = numbers[4];       // 要求实现了Copy特型\nlet second_line = lines[1].clone();  // 要求实现了Clone特型\n\n// 获取切片的引用\nlet my_ref = &amp;buffer[4..12];\n\n// 获取切片的副本\nlet my_copy = buffer[4..12].to_vec();  // 要求实现了Clone特型</code></pre>\n<p>如果索引超出了范围，则所有这些形式都会引发 panic。</p>\n<p>Rust 对数值类型很挑剔，对向量也不例外。向量的长度和索引都是 <code>usize</code> 类型。试图用 <code>u32</code>、<code>u64</code> 或 <code>isize</code> 作为向量索引会导致出错。可以根据需要使用 <code>n as usize</code> 来转换，详情请参阅 6.14 节。</p>\n<p>下面这些方法可以轻松访问向量或切片的特定元素（请注意，所有的切片方法也都适用于数组和向量）。</p>\n<blockquote>\n<p><code>slice.first()</code>（第一个）</p>\n</blockquote>\n<p>返回对 <code>slice</code> 的第一个元素的引用（如果有的话）。</p>\n<p>返回类型为 <code>Option&lt;&amp;T&gt;</code>，所以如果 <code>slice</code> 为空则返回值为 <code>None</code>，如果不为空则返回 <code>Some(&amp;slice[0])</code>。</p>\n<pre class=\"code-rows\"><code>if let Some(item) = v.first() {\n    println!(\"We got one! {}\", item);\n}</code></pre>\n<blockquote>\n<p><code>slice.last()</code>（最后一个）</p>\n</blockquote>\n<p>与 <code>first</code> 类似，但会返回对最后一个元素的引用。</p>\n<blockquote>\n<p><code>slice.get(index)</code>（获取）</p>\n</blockquote>\n<p>如果其存在，就返回 <code>slice[index]</code> 引用的 <code>Some</code> 值。如果 <code>slice</code> 的元素少于 <code>index+1</code> 个，则返回 <code>None</code>。</p>\n<pre class=\"code-rows\"><code>let slice = [0, 1, 2, 3];\nassert_eq!(slice.get(2), Some(&amp;2));\nassert_eq!(slice.get(4), None);</code></pre>\n<blockquote>\n<p><code>slice.first_mut()</code>（第一个可变）、<code>slice.last_mut()</code>（最后一个可变）和 <code>slice.get_mut(index)</code>（获取可变）</p>\n</blockquote>\n<p>这些方法是前述 <code>slice.first()</code> 等方法的变体，但借入的是可变引用。</p>\n<pre class=\"code-rows\"><code>let mut slice = [0, 1, 2, 3];\n{\n    let last = slice.last_mut().unwrap();   // last的类型是&amp;mut i32\n    assert_eq!(*last, 3);\n    *last = 100;\n}\nassert_eq!(slice, [0, 1, 2, 100]);</code></pre>\n<p>因为按值返回 <code>T</code> 就意味着移动它，所以一些需要就地访问元素的方法通常会按引用返回这些元素。</p>\n<p><code>.to_vec()</code> 方法是一个例外，它会复制这些元素。</p>\n<blockquote>\n<p><code>slice.to_vec()</code>（转向量）</p>\n</blockquote>\n<p>克隆整个切片，返回一个新向量：</p>\n<pre class=\"code-rows\"><code>let v = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nassert_eq!(v.to_vec(),\n           vec![1, 2, 3, 4, 5, 6, 7, 8, 9]);\nassert_eq!(v[0..6].to_vec(),\n           vec![1, 2, 3, 4, 5, 6]);</code></pre>\n<p>此方法只能用在元素可以克隆的情况下，也就是需满足 <code>where T: Clone</code> 限界。</p>\n<h3 id=\"nav_point_283\">16.2.2　迭代</h3>\n<p>向量、数组和切片是可迭代的，要么按值迭代<span class=\"comment-number\">3</span>，要么按引用迭代，但都要遵循 15.2.2 节描述的模式。</p>\n\n<ul>\n<li>遍历 <code>Vec&lt;T&gt;</code> 或数组 <code>[T; N]</code> 会生成 <code>T</code> 类型的条目。这些元素会逐个从向量或数组中移动出来并被消耗掉。</li>\n<li>遍历 <code>&amp;[T; N]</code>、<code>&amp;[T]</code> 或 <code>&amp;Vec&lt;T&gt;</code> 类型的值（对数组、切片或向量的引用）会生成 <code>&amp;T</code> 类型的条目，即对单个元素的引用，这些元素不会移动出来。</li>\n<li>遍历 <code>&amp;mut [T; N]</code>、<code>&amp;mut [T]</code> 或 <code>&amp;mut Vec&lt;T&gt;</code> 类型的值会生成 <code>&amp;mut T</code> 类型的条目。</li>\n</ul>\n<p>数组、切片和向量也有 <code>.iter()</code> 方法和 <code>.iter_mut()</code> 方法（参见 15.2.1 节），以用于创建一个会生成对其元素的引用的迭代器。</p>\n<p>稍后本章将在 16.2.5 节中介绍一些更高级的方法来迭代切片。</p>\n<h3 id=\"nav_point_284\">16.2.3　扩大向量与收缩向量</h3>\n<p>数组、切片或向量的<strong>长度</strong>是它们所包含的元素数量。</p>\n<blockquote>\n<p><code>slice.len()</code>（长度）</p>\n</blockquote>\n<p>返回 <code>slice</code> 的长度，类型为 <code>usize</code>。</p>\n<blockquote>\n<p><code>slice.is_empty()</code>（为空？）</p>\n</blockquote>\n<p>如果 <code>slice</code> 未包含任何元素（<code>slice.len() == 0</code>）则为真。</p>\n<p>本节中的其余方法是关于扩大向量和收缩向量的。但数组和切片中没有这些方法，因为数组和切片一旦创建就无法调整大小。</p>\n<p>向量的所有元素都存储在连续的、分配在堆上的内存块中。向量的<strong>容量</strong>就是该内存块可以容纳的最大元素数量。<code>Vec</code> 通常会替你管理容量，当需要更多空间时它会自动分配更大的缓冲区并将元素移入其中。下面是一些显式管理容量的方法。</p>\n<blockquote>\n<p><code>Vec::with_capacity(n)</code>（自带容量）</p>\n</blockquote>\n<p>创建一个容量为 <code>n</code> 的新的空向量。</p>\n<blockquote>\n<p><code>vec.capacity()</code>（取容量）</p>\n</blockquote>\n<p>返回 <code>vec</code> 的容量，类型为 <code>usize</code>。<code>vec.capacity() &gt;= vec.len()</code> 始终是成立的。</p>\n<blockquote>\n<p><code>vec.reserve(n)</code>（预留）</p>\n</blockquote>\n<p>确保向量至少有足够的备用容量来容纳另外 <code>n</code> 个元素，也就是说，<code>vec.capacity()</code> 至少等于 <code>vec.len() + n</code>。如果已经有足够的空间，就什么也不做。如果没有，则会分配一个更大的缓冲区并将向量的内容移入其中。</p>\n<blockquote>\n<p><code>vec.reserve_exact(n)</code>（精确预留）</p>\n</blockquote>\n<p>与 <code>vec.reserve(n)</code> 类似，但要求 <code>vec</code> 不要为未来的增长分配任何多于 <code>n</code> 的额外容量。调用此方法后，<code>vec.capacity()</code> 应该精确等于 <code>vec.len() + n</code>。</p>\n<blockquote>\n<p><code>vec.shrink_to_fit()</code>（缩小到刚好够）</p>\n</blockquote>\n<p>如果 <code>vec.capacity()</code> 大于 <code>vec.len()</code>，则尝试释放额外的内存。</p>\n<p><code>Vec&lt;T&gt;</code> 还有许多用来添加或移除元素的方法，它们可以改变向量的长度。所有这些方法都可以通过可变引用获取其 <code>self</code> 参数。</p>\n<p>下面这两个方法会在向量的末尾添加或移除单个值。</p>\n<blockquote>\n<p><code>vec.push(value)</code>（推入）</p>\n</blockquote>\n<p>将给定 <code>value</code> 添加到 <code>vec</code> 的末尾。</p>\n<blockquote>\n<p><code>vec.pop()</code>（弹出）</p>\n</blockquote>\n<p>移除并返回最后一个元素。返回类型是 <code>Option&lt;T&gt;</code>。如果弹出的元素是 <code>x</code>，则返回 <code>Some(x)</code>；如果向量已经为空，则返回 <code>None</code>。</p>\n<p>请注意，<code>.push()</code> 会按值而不是按引用接受其参数。同样，<code>.pop()</code> 会返回弹出的值，而不是引用。本节中剩下的大部分方法也是如此。它们可以将值移动进和移动出向量。</p>\n<p>下面这两个方法会在向量的任意位置添加或移除一个值。</p>\n<blockquote>\n<p><code>vec.insert(index, value)</code>（插入）</p>\n</blockquote>\n<p>在 <code>vec[index]</code> 处插入给定的 <code>value</code>，将 <code>vec[index..]</code> 中的所有当前值向右平移一个位置以腾出空间。</p>\n<p>如果 <code>index &gt; vec.len()</code>，则会引发 panic。</p>\n<blockquote>\n<p><code>vec.remove(index)</code>（移除）</p>\n</blockquote>\n<p>移除并返回 <code>vec[index]</code>，将 <code>vec[index+1..]</code> 中的所有当前值向左平移一个位置以填补空白。</p>\n<p>如果 <code>index &gt;= vec.len()</code>，则会引发 panic，因为在这种情况下要移除的 <code>vec[index]</code> 元素并不存在。</p>\n<p>向量越长，这个操作就越慢。如果需要经常执行 <code>vec.remove(0)</code>，请考虑使用 <code>VecDeque</code>（参见 16.3 节）来代替 <code>Vec</code>。</p>\n<p>需要移动的元素越多，<code>.insert()</code> 和 <code>.remove()</code> 的速度就会越慢。</p>\n<p>下面这 4 个方法可以把向量的长度更改为特定值。</p>\n<blockquote>\n<p><code>vec.resize(new_len, value)</code>（调整大小）</p>\n</blockquote>\n<p>将 <code>vec</code> 的长度设置为 <code>new_len</code>。如果该操作会增加 <code>vec</code> 的长度，则以 <code>value</code> 的副本填补新空间。元素类型必须实现 <code>Clone</code> 特型。</p>\n<blockquote>\n<p><code>vec.resize_with(new_len, closure)</code>（以……调整大小）</p>\n</blockquote>\n<p>与 <code>vec.resize</code> 类似，但会调用闭包来构造每个新元素。它能用于不可 <code>Clone</code> 的元素构成的向量。</p>\n<blockquote>\n<p><code>vec.truncate(new_len)</code>（截断）</p>\n</blockquote>\n<p>将 <code>vec</code> 的长度减少到 <code>new_len</code>，丢弃 <code>vec[new_len..]</code> 范围内的任何元素。</p>\n<p>如果 <code>vec.len()</code> 已经小于或等于 <code>new_len</code>，则什么也不会发生。</p>\n<blockquote>\n<p><code>vec.clear()</code>（清空）</p>\n</blockquote>\n<p>从 <code>vec</code> 中移除所有元素。此方法的效果和 <code>vec.truncate(0)</code> 一样。</p>\n<p>下面这 4 个方法可以一次添加或移除多个值。</p>\n<blockquote>\n<p><code>vec.extend(iterable)</code>（扩展）</p>\n</blockquote>\n<p>按顺序在 <code>vec</code> 末尾添加来自给定 <code>iterable</code> 值的所有条目。此方法就像 <code>.push()</code> 的多值版本。<code>iterable</code> 参数可以是实现了 <code>IntoIterator&lt;Item=T&gt;</code> 的任何值。</p>\n<p>此方法非常有用，所以我们为其定义了一个标准特型 <code>Extend</code>，所有标准集合都实现了该特型。不过很遗憾，这会导致 <code>rustdoc</code> 在其生成的 HTML 底部将 <code>.extend()</code> 与其他特型方法混排在一起，因此在需要时很难找到它。我也只能告诉你：请记住它在那里。有关详细信息，请参见 15.4.14 节。</p>\n<blockquote>\n<p><code>vec.split_off(index)</code>（拆分出）</p>\n</blockquote>\n<p>与 <code>vec.truncate(index)</code> 类似，但此方法会返回一个 <code>Vec&lt;T&gt;</code>，其中包含从 <code>vec</code> 末尾移除的那些值。此方法就像是 <code>.pop()</code> 的多值版本。</p>\n<blockquote>\n<p><code>vec.append(&amp;mut vec2)</code>（追加）</p>\n</blockquote>\n<p>这会将 <code>vec2</code> 的所有元素移动到 <code>vec</code> 中，其中 <code>vec2</code> 是 <code>Vec&lt;T&gt;</code> 类型的另一个向量。之后，<code>vec2</code> 会被清空。</p>\n<p>此方法与 <code>vec.extend(vec2)</code> 类似，不同之处在于调用 <code>extend</code> 之后 <code>vec2</code> 仍然存在，其容量也不受影响。</p>\n<blockquote>\n<p><code>vec.drain(range)</code>（抽取）</p>\n</blockquote>\n<p>这将从 <code>vec</code> 中移除 <code>range</code> 范围内的切片 <code>vec[range]</code>，并返回对所移除元素的迭代器，其中 <code>range</code> 是范围值，类似 <code>..</code> 或 <code>0..4</code>。</p>\n<p>还有一些略显古怪的方法可以从向量中选择性地移除一些元素。</p>\n<blockquote>\n<p><code>vec.retain(test)</code>（留下）</p>\n</blockquote>\n<p>移除所有未通过给定测试的元素。<code>test</code> 参数是实现了 <code>FnMut(&amp;T) -&gt; bool</code> 的函数或闭包。针对 <code>vec</code> 的每个元素，此方法都会调用 <code>test(&amp;element)</code>，如果函数或闭包返回了 <code>false</code>，就会从向量中移除并丢弃此元素。</p>\n<p>除了性能上略有差异，此方法和下面的写法很像。</p>\n<pre class=\"code-rows\"><code>vec = vec.into_iter().filter(test).collect();</code></pre>\n<blockquote>\n<p><code>vec.dedup()</code>（去重）</p>\n</blockquote>\n<p>丢弃重复的元素，类似于 Unix shell 实用程序 <code>uniq</code>。此方法会扫描 <code>vec</code> 以查找彼此相等的相邻元素，然后会从这些相等值中保留一个并丢弃多余的值：</p>\n<pre class=\"code-rows\"><code>let mut byte_vec = b\"Misssssssissippi\".to_vec();\nbyte_vec.dedup();\nassert_eq!(&amp;byte_vec, b\"Misisipi\");</code></pre>\n<p>请注意，输出中仍然有两个 <code>'s'</code> 字符。这是因为此方法只会移除<strong>相邻</strong>的重复项。要想消除所有重复项，你有 3 个选择：在调用 <code>.dedup()</code> 之前对向量进行排序、将数据移动到一个 <code>Set</code> 中，或者（为了保持元素的原始顺序）使用如下 <code>.retain()</code> 技巧：</p>\n<pre class=\"code-rows\"><code>let mut byte_vec = b\"Misssssssissippi\".to_vec();\n\nlet mut seen = HashSet::new();\nbyte_vec.retain(|r| seen.insert(*r));\n\nassert_eq!(&amp;byte_vec, b\"Misp\");</code></pre>\n<p>上述代码的工作原理是当 <code>Set</code> 已经包含我们要插入的条目时 <code>.insert()</code> 就会返回 <code>false</code>。</p>\n<blockquote>\n<p><code>vec.dedup_by(same)</code>（根据 <code>same</code> 调用结果去重）</p>\n</blockquote>\n<p>与 <code>vec.dedup()</code> 类似，但此方法会使用函数或闭包 <code>same(&amp;mut elem1, &amp;mut elem2)</code> 而不是 <code>==</code> 运算符来检查两个元素是否应被视为相等。</p>\n<blockquote>\n<p><code>vec.dedup_by_key(key)</code>（根据 <code>key</code> 属性去重）</p>\n</blockquote>\n<p>与 <code>vec.dedup()</code> 类似，但此方法会在 <code>key(&amp;mut elem1) == key(&amp;mut elem2)</code> 时将两个元素视为相等。</p>\n<p>如果 <code>errors</code> 是一个 <code>Vec&lt;Box&lt;dyn Error&gt;&gt;</code>，你可以这样写：</p>\n<pre class=\"code-rows\"><code>// 移除带有相同信息的多余错误（error）\nerrors.dedup_by_key(|err| err.to_string());</code></pre>\n<p>在本节涵盖的所有方法中，只有 <code>.resize()</code> 会克隆值，其他方法都是将值从一个地方移动到另一个地方。</p>\n<h3 id=\"nav_point_285\">16.2.4　联结</h3>\n<p>以下两个方法可用于<strong>数组的数组</strong>，即其元素本身也是数组、切片或向量的数组、切片或向量。</p>\n<blockquote>\n<p><code>slices.concat()</code>（串联）</p>\n</blockquote>\n<p>返回通过串联所有切片组装成的新向量。</p>\n<pre class=\"code-rows\"><code>assert_eq!([[1, 2], [3, 4], [5, 6]].concat(),\n           vec![1, 2, 3, 4, 5, 6]);</code></pre>\n<blockquote>\n<p><code>slices.join(&amp;separator)</code>（联结）</p>\n</blockquote>\n<p>与 <code>concat</code> 类似，只是在这些切片之间插入了值 <code>separator</code> 的副本。</p>\n<pre class=\"code-rows\"><code>assert_eq!([[1, 2], [3, 4], [5, 6]].join(&amp;0),\n           vec![1, 2, 0, 3, 4, 0, 5, 6]);</code></pre>\n<h3 id=\"nav_point_286\">16.2.5　拆分</h3>\n<p>同时获得多个对数组、切片或向量中元素的不可变引用是比较容易的：</p>\n<pre class=\"code-rows\"><code>let v = vec![0, 1, 2, 3];\nlet a = &amp;v[i];\nlet b = &amp;v[j];\n\nlet mid = v.len() / 2;\nlet front_half = &amp;v[..mid];\nlet back_half = &amp;v[mid..];</code></pre>\n<p>但获取多个可变引用就不那么容易了：</p>\n<pre class=\"code-rows\"><code>let mut v = vec![0, 1, 2, 3];\nlet a = &amp;mut v[i];\nlet b = &amp;mut v[j];  // 错误：不能同时把`v`借入为多个可变引用\n\n*a = 6;             // 这里用到了引用`a`和引用`b`，\n*b = 7;             // 所以它们的生命周期必然重叠</code></pre>\n<p>Rust 禁止这样做，因为如果 <code>i == j</code>，那么 <code>a</code> 和 <code>b</code> 就是对同一个整数的两个可变引用，这违反了 Rust 的安全规则。（参见 5.4 节。）</p>\n<p>Rust 有几种方法可以同时借入对数组、切片或向量的两个或多个部分的可变引用。与前面的代码不同，这些方法是安全的，因为根据设计，它们总会把数据拆分成几个<strong>不重叠</strong>的区域。这里的大部分方法在处理非 <code>mut</code> 切片时也很方便，因此每个方法都有 <code>mut</code> 版本和非 <code>mut</code> 版本。</p>\n<p>图 16-2 展示了这些方法。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00865.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-2：对几个拆分型方法的说明（注意：<code>slice.split(|&amp;x|x==0)</code> 输出中的小矩形是由于存在两个相邻的分隔符而生成的空切片，并且 <code>rsplitn</code> 会按从后向前的顺序生成其输出，这与另外几个方法不同）</strong></p>\n<p>这些方法都没有直接修改数组、切片或向量，它们只是返回了对内部数据中各部分的新引用。</p>\n<blockquote>\n<p><code>slice.iter()</code>（迭代器）和 <code>slice.iter_mut()</code>（可变迭代器）</p>\n</blockquote>\n<p>生成对 <code>slice</code> 中每个元素的引用。16.2.2 节介绍过它们。</p>\n<blockquote>\n<p><code>slice.split_at(index)</code>（拆分于）和 <code>slice.split_at_mut(index)</code>（可变拆分于）</p>\n</blockquote>\n<p>将一个切片分成两半，返回一个值对。<code>slice.split_at(index)</code> 等价于 <code>(&amp;slice[..index], &amp;slice[index..])</code>。如果 <code>index</code> 超出了限界，这两个方法就会发生 panic。</p>\n<blockquote>\n<p><code>slice.split_first()</code>（拆分首个）和 <code>slice.split_first_mut()</code>（可变拆分首个）</p>\n</blockquote>\n<p>同样会返回一个值对：对首个元素（<code>slice[0]</code>）的引用和对所有其余元素（<code>slice[1..]</code>）的切片的引用。</p>\n<p><code>.split_first()</code> 的返回类型是 <code>Option&lt;(&amp;T, &amp;[T])&gt;</code>，如果 <code>slice</code> 为空，则结果为 <code>None</code>。</p>\n<blockquote>\n<p><code>slice.split_last()</code>（拆分末尾）和 <code>slice.split_last_mut()</code>（可变拆分末尾）</p>\n</blockquote>\n<p>与 <code>slice.split_first()</code> 和 <code>slice.split_first_mut()</code> 类似，但这两个方法拆分出的是最后一个元素而不是首个元素。</p>\n<p><code>.split_last()</code> 的返回类型是 <code>Option&lt;(&amp;T, &amp;[T])&gt;</code>。</p>\n<blockquote>\n<p><code>slice.split(is_sep)</code>（拆分）和 <code>slice.split_mut(is_sep)</code>（可变拆分）</p>\n</blockquote>\n<p>将 <code>slice</code> 拆分为一个或多个子切片，使用函数或闭包 <code>is_sep</code> 确定拆分位置。这两个方法会返回一个遍历这些子切片的迭代器。</p>\n<p>当你消耗此迭代器时，这些方法会为切片中的每个元素调用 <code>is_sep(&amp;element)</code>。如果 <code>is_sep(&amp;element)</code> 为 <code>true</code>，则认为该元素是分隔符。分隔符不会包含在输出的任何子切片中。</p>\n<p>输出总是至少包含一个子切片，每遇到一个分隔符就额外加一个。如果有多个分隔符彼此相邻，或者有分隔符出现在 <code>slice</code> 的两端，则每对分隔符和两端的分隔符分别会对应输出一个空的子切片。</p>\n<blockquote>\n<p><code>slice.split_inclusive(is_sep)</code>（拆分，含分隔符）和 <code>slice.split_inclusive_mut(is_sep)</code>（可变拆分，含分隔符）</p>\n</blockquote>\n<p>与 <code>split</code> 和 <code>split_mut</code> 类似，但这两个方法会在前一个子切片的结尾包含分隔符而不会排除它。</p>\n<blockquote>\n<p><code>slice.rsplit(is_sep)</code>（右起拆分）和 <code>slice.rsplit_mut(is_sep)</code>（右起可变拆分）</p>\n</blockquote>\n<p>与 <code>split</code> 和 <code>split_mut</code> 类似，但这两个方法会从切片的末尾开始往前拆分。</p>\n<blockquote>\n<p><code>slice.splitn(n, is_sep)</code>（拆分为 <em>n</em> 片）和 <code>slice.splitn_mut(n, is_sep)</code>（可变拆为 <em>n</em> 片）</p>\n</blockquote>\n<p>与 <code>slice.rsplit(is_sep)</code> 和 <code>slice.rsplit_mut(is_sep)</code> 类似，但这两个方法最多会生成 <code>n</code> 个子切片。在找到前 <code>n-1</code> 个切片后，不会再调用 <code>is_sep</code>。最后一个子切片中会包含剩下的所有元素。</p>\n<blockquote>\n<p><code>slice.rsplitn(n, is_sep)</code>（右起拆分为 <em>n</em> 片）和 <code>slice.rsplitn_mut(n, is_sep)</code>（右起可变拆分为 <em>n</em> 片）</p>\n</blockquote>\n<p>与 <code>.splitn()</code> 和 <code>.splitn_mut()</code> 类似，但是在使用这两个方法时，切片会以相反的顺序扫描。也就是说，这两个方法会在切片中的<strong>最后</strong>而不是最前 <code>n-1</code> 个分隔符上进行拆分，并且子切片是从末尾开始向前生成的。</p>\n<blockquote>\n<p><code>slice.chunks(n)</code>（分为长度为 <em>n</em> 的块）和 <code>slice.chunks_mut(n)</code>（分为长度为 <em>n</em> 的可变块）</p>\n</blockquote>\n<p>返回长度为 <code>n</code> 的非重叠子切片上的迭代器。如果 <code>n</code> 不能被 <code>slice.len()</code> 整除，则最后一个块包含的元素将不足 <code>n</code> 个。</p>\n<blockquote>\n<p><code>slice.rchunks(n)</code>（右起分为长度为 <em>n</em> 的块）和 <code>slice.rchunks_mut(n)</code>（右起分为长度为 <em>n</em> 的可变块）</p>\n</blockquote>\n<p>与 <code>slice.chunks</code> 和 <code>slice.chunks_mut</code> 类似，但会从切片的末尾开始向前拆分。</p>\n<blockquote>\n<p><code>slice.chunks_exact(n)</code>（精确分为长度为 <em>n</em> 的块）和 <code>slice.chunks_exact_mut(n)</code>（精确分为长度为 <em>n</em> 的可变块）</p>\n</blockquote>\n<p>返回长度为 <code>n</code> 的非重叠子切片上的迭代器。如果 <code>n</code> 不能被 <code>slice.len()</code> 整除，则最后一个块（少于 <code>n</code> 个元素）可以在其结果的 <code>remainder()</code> 方法中获取。</p>\n<blockquote>\n<p><code>slice.rchunks_exact(n)</code>（右起精确分为长度为 <em>n</em> 的块）和 <code>slice.rchunks_exact_mut(n)</code>（右起精确分为长度为 <em>n</em> 的可变块）</p>\n</blockquote>\n<p>与 <code>slice.chunks_exact</code> 和 <code>slice.chunks_exact_mut</code> 类似，但会从切片的末尾开始拆分。</p>\n<p>还有一个迭代子切片的方法。</p>\n<blockquote>\n<p><code>slice.windows(n)</code>（滑动窗口）</p>\n</blockquote>\n<p>返回一个其行为类似于 <code>slice</code> 中数据的“滑动窗口”的迭代器。这个迭代器会生成一些横跨此 <code>slice</code> 中 <code>n</code> 个连续元素的子切片。它生成的第一个值是 <code>&amp;slice[0..n]</code>，第二个值是 <code>&amp;slice[1..n+1]</code>，以此类推。</p>\n<p>如果 <code>n</code> 大于 <code>slice</code> 的长度，则不会生成任何切片。如果 <code>n</code> 为 <code>0</code>，则此方法会发生 panic。</p>\n<p>如果 <code>days.len() == 31</code>，那么就可以通过调用 <code>days.windows(7)</code> 来生成 <code>days</code> 中所有相隔 7 天的时间段。</p>\n<p>大小为 <code>2</code> 的滑动窗口可用于探究数据序列如何从一个数据点变化到下一个数据点：</p>\n<pre class=\"code-rows\"><code>let changes = daily_high_temperatures\n                  .windows(2)             // 获得两个相邻的最高气温\n                  .map(|w| w[1] - w[0])   // 气温变化了多少？\n                  .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>\n<p>因为各个子切片会重叠，所以此方法并没有返回可变引用的变体。</p>\n<h3 id=\"nav_point_287\">16.2.6　交换</h3>\n<p>下面是交换切片内容的一些便利方法。</p>\n<blockquote>\n<p><code>slice.swap(i, j)</code>（交换元素）</p>\n</blockquote>\n<p>交换 <code>slice[i]</code> 和 <code>slice[j]</code> 这两个元素。</p>\n<blockquote>\n<p><code>slice_a.swap_with_slice(slice_b)</code>（互换内容）</p>\n</blockquote>\n<p>交换 <code>slice_a</code> 和 <code>slice_b</code> 的全部内容。<code>slice_a</code> 和 <code>slice_b</code> 的长度必须相同。</p>\n<p>向量有一个关联方法，该方法可以高效地移除任何元素。</p>\n<blockquote>\n<p><code>vec.swap_remove(i)</code>（交换后移除）</p>\n</blockquote>\n<p>移除并返回 <code>vec[i]</code>。与 <code>vec.remove(i)</code> 类似，但此方法不会将向量中剩余的元素平移过来以填补空缺，而是简单地将 <code>vec</code> 的最后一个元素移动到空缺中。如果不关心向量中剩余条目的顺序，那么此方法会很有用，因为性能更高。</p>\n<h3 id=\"nav_point_288\">16.2.7　填充</h3>\n<p>下面是替换可变切片内容的两种便利方法。</p>\n<blockquote>\n<p><code>slice.fill(value)</code>（填充）</p>\n</blockquote>\n<p>用 <code>value</code> 的克隆体填充切片。</p>\n<blockquote>\n<p><code>slice.fill_with(function)</code>（以 <code>function</code> 回调填充）</p>\n</blockquote>\n<p>使用调用给定函数生成的值来填充切片。这对于实现了 <code>Default</code> 但未实现 <code>Clone</code> 的类型很有用，比如当 <code>T</code> 为不可复制类型时的 <code>Option&lt;T&gt;</code> 或 <code>Vec&lt;T&gt;</code>。</p>\n<h3 id=\"nav_point_289\">16.2.8　排序与搜索</h3>\n<p>下面是切片提供的 3 个排序方法。</p>\n<blockquote>\n<p><code>slice.sort()</code>（排序）</p>\n</blockquote>\n<p>将元素按升序排列。此方法仅当元素类型实现了 <code>Ord</code> 时才存在。</p>\n<blockquote>\n<p><code>slice.sort_by(cmp)</code>（按 <code>cmp</code> 回调排序）</p>\n</blockquote>\n<p>对 <code>slice</code> 中的元素按函数或闭包 <code>cmp</code> 指定的顺序进行排序。<code>cmp</code> 必须实现 <code>Fn(&amp;T, &amp;T) -&gt; std::cmp::Ordering</code>。</p>\n<p>手动实现 <code>cmp</code> 是一件痛苦的事，不过可以把它委托给别的 <code>.cmp()</code> 方法来实现：</p>\n<pre class=\"code-rows\"><code>students.sort_by(|a, b| a.last_name.cmp(&amp;b.last_name));</code></pre>\n<p>如果想按一个字段排序，但当该字段相同时按另一个字段判定先后，则可以先把它们做成元组然后再进行比较。</p>\n<pre class=\"code-rows\"><code>students.sort_by(|a, b| {\n    let a_key = (&amp;a.last_name, &amp;a.first_name);\n    let b_key = (&amp;b.last_name, &amp;b.first_name);\n    a_key.cmp(&amp;b_key)\n});</code></pre>\n<blockquote>\n<p><code>slice.sort_by_key(key)</code>（按 <code>key</code> 回调排序）</p>\n</blockquote>\n<p>使用由函数或闭包型参数 <code>key</code> 给出的排序键对 <code>slice</code> 的元素按递增顺序排序。<code>key</code> 的类型必须实现 <code>Fn(&amp;T) -&gt; K</code>，这里要满足 <code>K: Ord</code>。</p>\n<p>这在 <code>T</code> 包含一个或多个有序字段时会很有用，因此它可以按多种方式排序：</p>\n<pre class=\"code-rows\"><code>// 按平均学分绩点排序，低分在前\nstudents.sort_by_key(|s| s.grade_point_average());</code></pre>\n<p>请注意，在排序过程中不会缓存这些排序键值，因此 <code>key</code> 函数可能会被调用 <em>n</em> 次以上。</p>\n<p>出于技术原因，<code>key(element)</code> 无法返回从元素借来的任何引用。下面这种写法行不通：</p>\n<pre class=\"code-rows\"><code>students.sort_by_key(|s| &amp;s.last_name);  // 错误：无法推断生命周期</code></pre>\n<p>Rust 无法推算出生命周期。但在这些情况下，很容易把 <code>.sort_by()</code> 作为后备方案。</p>\n<p>以上 3 个方法都会执行稳定排序。</p>\n<p>要想以相反的顺序排序，可以将 <code>sort_by</code> 与交换了两个参数的 <code>cmp</code> 闭包一起使用。传入参数 <code>|b, a|</code> 而不是 <code>|a, b|</code> 可以有效地生成相反的顺序。或者，也可以在排序之后调用 <code>.reverse()</code> 方法。</p>\n<blockquote>\n<p><code>slice.reverse()</code>（逆转）</p>\n</blockquote>\n<p>就地逆转切片。</p>\n<p>一旦切片排序完毕，就可以高效地进行搜索了。</p>\n<blockquote>\n<p><code>slice.binary_search(&amp;value)</code>（二分搜索）、<code>slice.binary_search_by(&amp;value, cmp)</code>（按 <code>cmp</code> 回调二分搜索）和 <code>slice.binary_search_by_key(&amp;value, key)</code>（按 <code>key</code> 闭包二分搜索）</p>\n</blockquote>\n<p>以上 3 个方法都会在给定的已排序 <code>slice</code> 中搜索 <code>value</code>。请注意，<code>value</code> 是按引用传递的。</p>\n<p>这些方法的返回类型是 <code>Result&lt;usize, usize&gt;</code>。如果在指定排序顺序中 <code>slice[index]</code> 等于 <code>value</code>，那么这些方法就会返回 <code>Ok(index)</code>。如果找不到这样一个索引，那么这些方法就会返回 <code>Err(insertion_point)</code>，这样当你在 <code>insertion_point</code> 中插入 <code>value</code> 后，向量仍然会保持排好序的状态。</p>\n<p>当然，只有在切片确实已经按指定顺序排序时二分搜索才有效。否则，结果将是没有意义的，因为如果输入无效，则输出也无效。</p>\n<p>由于 <code>f32</code> 和 <code>f64</code> 具有 NaN 值，因此它们无法实现 <code>Ord</code> 并且不能直接用作排序和二分搜索方法的键。要获得适用于浮点数据的类似方法，请使用 <code>ord_subset</code> crate。</p>\n<p>可以用另一个方法在未排过序的向量中搜索。</p>\n<blockquote>\n<p><code>slice.contains(&amp;value)</code>（包含）</p>\n</blockquote>\n<p>如果 <code>slice</code> 中有任何元素等于 <code>value</code>，则返回 <code>true</code>。这会简单地检查切片的每个元素，直到找到匹配项。<code>value</code> 同样是按引用传递的。</p>\n<p>如果要在切片中查找值的位置（类似 JavaScript 中的 <code>array.indexOf(value)</code>），请使用迭代器：</p>\n<pre class=\"code-rows\"><code>slice.iter().position(|x| *x == value)</code></pre>\n<p>这将返回 <code>Option&lt;usize&gt;</code>。</p>\n<h3 id=\"nav_point_290\">16.2.9　比较切片</h3>\n<p>如果类型 <code>T</code> 支持 <code>==</code> 运算符和 <code>!=</code> 运算符（<code>PartialEq</code> 特型，参见 12.2 节），那么数组 <code>[T; N]</code>、切片 <code>[T]</code> 和向量 <code>Vec&lt;T&gt;</code> 也会支持这两个运算符。如果两个切片的长度相同并且对应的元素也相等，那它们就是相等的。数组和向量也是如此。</p>\n<p>如果 <code>T</code> 支持运算符 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code>（<code>PartialOrd</code> 特型，参见 12.3 节），那么 <code>T</code> 的数组、切片和向量也会支持这些运算符。切片之间是按字典序比较的（从左到右逐个比较）。</p>\n<p>下面是执行常见的切片比较的两个便捷方法。</p>\n<blockquote>\n<p><code>slice.starts_with(other)</code>（以 <code>other</code> 开头）</p>\n</blockquote>\n<p>如果 <code>slice</code> 的起始值序列等于 <code>other</code> 切片中的相应元素，则返回 <code>true</code>。</p>\n<pre class=\"code-rows\"><code>assert_eq!([1, 2, 3, 4].starts_with(&amp;[1, 2]), true);\nassert_eq!([1, 2, 3, 4].starts_with(&amp;[2, 3]), false);</code></pre>\n<blockquote>\n<p><code>slice.ends_with(other)</code>（以 <code>other</code> 结尾）</p>\n</blockquote>\n<p>与上一个方法类似，但会检查 <code>slice</code> 的结尾值。</p>\n<pre class=\"code-rows\"><code>assert_eq!([1, 2, 3, 4].ends_with(&amp;[3, 4]), true);</code></pre>\n<h3 id=\"nav_point_291\">16.2.10　随机元素</h3>\n<p>随机数并未内置在 Rust 标准库中，但在 <code>rand</code> crate 中可以找到它们。<code>rand</code> crate 提供了以下两个方法，用于从数组、切片或向量中获取随机输出。</p>\n<blockquote>\n<p><code>slice.choose(&amp;mut rng)</code>（随机选取）</p>\n</blockquote>\n<p>返回对切片中随机元素的引用。与 <code>slice.first()</code> 和 <code>slice.last()</code> 类似，此方法会返回 <code>Option&lt;&amp;T&gt;</code>，只有当切片为空时才返回 <code>None</code>。</p>\n<blockquote>\n<p><code>slice.shuffle(&amp;mut rng)</code>（随机洗牌）</p>\n</blockquote>\n<p>就地随机重排切片中的元素。切片必须通过可变引用传递。</p>\n<p>这两个都是 <code>rand::Rng</code> 特型的方法，所以你需要一个 <code>Rng</code>（random number generator，随机数生成器），以便调用它们。幸运的是，通过调用 <code>rand::thread_rng()</code> 很容易得到一个生成器。要对向量 <code>my_vec</code> 进行洗牌，可以像下面这样写。</p>\n<pre class=\"code-rows\"><code>use rand::seq::SliceRandom;\nuse rand::thread_rng;\n\nmy_vec.shuffle(&amp;mut thread_rng());</code></pre>\n<h3 id=\"nav_point_292\">16.2.11　Rust 中不存在失效型错误</h3>\n<p>大多数主流编程语言有集合和迭代器，它们为排除失效型错误做了一点儿变化：不要在迭代集合时修改它。例如，在 Python 中，与向量等价的是列表：</p>\n<pre class=\"code-rows\"><code>my_list = [1, 3, 5, 7, 9]</code></pre>\n<p>假设我们试图从 <code>my_list</code> 中移除所有大于 4 的值：</p>\n<pre class=\"code-rows\"><code>for index, val in enumerate(my_list):\n    if val &gt; 4:\n        del my_list[index]  # bug：在迭代过程中修改列表\n\nprint(my_list)</code></pre>\n<p>（Python 中的 <code>enumerate</code> 函数相当于 Rust 中的 <code>.enumerate()</code> 方法，参见 15.3.11 节。）</p>\n<p>令人惊讶的是，这个程序打印出了 <code>[1, 3, 7]</code>。但是 7 显然大于 4。为什么失控了？这就是失效型错误：程序在迭代数据时修改了数据，让迭代器<strong>失效</strong>了。在 Java 中，结果将是一个异常。在 C++ 中，这是未定义行为。在 Python 中，虽然此行为有明确定义，但不直观：迭代器会跳过一个元素。这样一来，<code>val</code> 永远不会等于 <code>7</code>，因此也就没有机会删除它了。</p>\n<p>我们试着在 Rust 中重现这个 bug：</p>\n<pre class=\"code-rows\"><code>fn main() {\n    let mut my_vec = vec![1, 3, 5, 7, 9];\n\n    for (index, &amp;val) in my_vec.iter().enumerate() {\n        if val &gt; 4 {\n            my_vec.remove(index);  // 错误：不能把`my_vec`借用为可变的\n        }\n    }\n    println!(\"{:?}\", my_vec);\n}</code></pre>\n<p>当然，Rust 在编译时就会拒绝这个程序。当我们调用 <code>my_vec.iter()</code> 时，它借用了一个共享（非 <code>mut</code>）的向量引用。引用与迭代器的生命周期一样长，直到 <code>for</code> 循环结束。当存在不可变引用时，不能通过调用 <code>my_vec.remove(index)</code> 来修改向量。</p>\n<p>帮你指出错误固然有用，但你还是得想方设法达成自己的目标。最简单的修复方法是写成如下形式：</p>\n<pre class=\"code-rows\"><code>my_vec.retain(|&amp;val| val &lt;= 4);</code></pre>\n<p>或者，也可以像在 Python 或任何其他语言中那样使用 <code>filter</code> 创建一个新向量。</p>\n<h2 id=\"nav_point_293\">16.3　<code>VecDeque&lt;T&gt;</code></h2>\n<p><code>Vec</code> 只支持在末尾高效地添加元素和移除元素。当程序需要一个地方来存储“排队等候”的值时，<code>Vec</code> 可能会很慢。</p>\n<p>Rust 的 <code>std::collections::VecDeque&lt;T&gt;</code> 是一个<strong>双端队列</strong>（deque，double-ended queue 的缩写，发音为 /'dek/）。它支持在首端和尾端进行高效的添加操作和移除操作。</p>\n<blockquote>\n<p><code>deque.push_front(value)</code>（队首推入）</p>\n</blockquote>\n<p>在队列的首端添加一个值。</p>\n<blockquote>\n<p><code>deque.push_back(value)</code>（队尾推入）</p>\n</blockquote>\n<p>在队列的尾端添加一个值。（此方法比 <code>.push_front()</code> 更常用，因为队列通常的习惯是在尾端添加值，在首端移除值，就像人们在排队等候一样。）</p>\n<blockquote>\n<p><code>deque.pop_front()</code>（队首弹出）</p>\n</blockquote>\n<p>移除并返回队列的首端值，如果队列为空则返回一个为 <code>None</code> 的 <code>Option&lt;T&gt;</code>，就像 <code>vec.pop()</code> 那样。</p>\n<blockquote>\n<p><code>deque.pop_back()</code>（队尾弹出）</p>\n</blockquote>\n<p>移除并返回队列的尾端值，同样返回 <code>Option&lt;T&gt;</code>。</p>\n<blockquote>\n<p><code>deque.front()</code>（队首）和 <code>deque.back()</code>（队尾）</p>\n</blockquote>\n<p>与 <code>vec.first()</code> 和 <code>vec.last()</code> 类似，这两个方法会返回对队列首端或尾端元素的引用。返回值是一个 <code>Option&lt;&amp;T&gt;</code>，如果队列为空则为 <code>None</code>。</p>\n<blockquote>\n<p><code>deque.front_mut()</code>（队首，可变版）和 <code>deque.back_mut()</code>（队尾，可变版）</p>\n</blockquote>\n<p>与 <code>vec.first_mut()</code> 和 <code>vec.last_mut()</code> 类似，这两个方法会返回 <code>Option&lt;&amp;mut T&gt;</code>。</p>\n<p><code>VecDeque</code> 的实现是一个环形缓冲区，如图 16-3 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00866.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-3：<code>VecDeque</code> 在内存中的存储情况</strong></p>\n<p>和 <code>Vec</code> 一样，<code>VecDeque</code> 用一块分配在堆上的内存来存储元素。与 <code>Vec</code> 不同，<code>VecDeque</code> 的数据并不总是从该区域的开头开始，它可以“回绕”到末尾。这个双端队列的元素按顺序排列是 <code>['A', 'B', 'C', 'D', 'E']</code>。<code>VecDeque</code> 有两个私有字段，在图 16-3 中被标记为 <code>start</code> 和 <code>stop</code>，用于记住数据在缓冲区中的首端位置和尾端位置。</p>\n<p>从任一端向队列中添加一个值都意味着占用一个未使用的插槽，如图 16-3 中的深灰色色块所示。如果需要，可以回绕或分配更大的内存块。</p>\n<p><code>VecDeque</code> 会管理回绕，因此你不必费心于此。图 16-3 展示了 Rust 如何让 <code>.pop_front()</code> 更快的幕后原理。</p>\n<p>通常，当你需要用到双端队列时，基本上只是需要 <code>.push_back()</code> 和 <code>.pop_front()</code> 这两个方法。用于创建队列的类型关联函数 <code>VecDeque::new()</code> 和 <code>VecDeque::with_capacity(n)</code> 和它们在 <code>Vec</code> 中的对应函数一样。<code>VecDeque</code> 还实现了 <code>Vec</code> 中的许多方法，比如 <code>.len()</code> 和 <code>.is_empty()</code>、<code>.insert(index, value)</code>、<code>.remove(index)</code>、<code>.extend(iterable)</code> 等。</p>\n<p>和向量一样，双端队列可以按值、共享引用或可变引用进行迭代。它们有 3 个迭代器方法，即 <code>.into_iter()</code>、<code>.iter()</code> 和 <code>.iter_mut()</code>。它们可以按通常的方式通过索引来访问：<code>deque[index]</code>。</p>\n<p>因为双端队列不会将自己的元素存储在连续的内存中，所以它们无法继承切片的所有方法。但是，如果你愿意承受移动内容的开销，则可以通过 <code>VecDeque</code> 提供的如下方法来解决此问题。</p>\n<blockquote>\n<p><code>deque.make_contiguous()</code>（变连续）</p>\n</blockquote>\n<p>获取 <code>&amp;mut self</code> 并将 <code>VecDeque</code> 重新排列到连续的内存中，返回 <code>&amp;mut [T]</code>。</p>\n<p><code>Vec</code> 和 <code>VecDeque</code> 紧密相关，为了轻松地在两者之间进行转换，标准库提供了两个特型实现。</p>\n<blockquote>\n<p><code>Vec::from(deque)</code>（来自双端队列）</p>\n</blockquote>\n<p><code>Vec&lt;T&gt;</code> 实现了 <code>From&lt;VecDeque&lt;T&gt;&gt;</code>，因此 <code>Vec::from(deque)</code> 能将双端队列变成向量。这个操作的时间复杂度是 <em>O</em>(<em>n</em>)，因为可能要重新排列元素。</p>\n<blockquote>\n<p><code>VecDeque::from(vec)</code>（来自向量）</p>\n</blockquote>\n<p><code>VecDeque&lt;T&gt;</code> 实现了 <code>From&lt;Vec&lt;T&gt;&gt;</code>，因此 <code>VecDeque::from(vec)</code> 能把向量变成双端队列。这个操作的时间复杂度是 <em>O</em>(1)，因为 Rust 会直接把向量缓冲区转移给 <code>VecDeque</code>，而不会重新分配。</p>\n<p>这个方法使得创建具有指定元素的双端队列变得很容易，哪怕并没有标准的 <code>vec_deque![]</code> 宏。</p>\n<pre class=\"code-rows\"><code>use std::collections::VecDeque;\n\nlet v = VecDeque::from(vec![1, 2, 3, 4]);</code></pre>\n<h2 id=\"nav_point_294\">16.4　<code>BinaryHeap&lt;T&gt;</code></h2>\n<p><code>BinaryHeap</code>（二叉堆）是一种元素组织会保持松散的集合，这样最大值便能总是冒泡到队列的首部。以下是 3 个最常用的 <code>BinaryHeap</code> 方法。</p>\n<blockquote>\n<p><code>heap.push(value)</code>（压入）</p>\n</blockquote>\n<p>向堆中添加一个值。</p>\n<blockquote>\n<p><code>heap.pop()</code>（弹出）</p>\n</blockquote>\n<p>从堆中移除并返回最大值。如果堆为空，则会返回一个为 <code>None</code> 的 <code>Option&lt;T&gt;</code>。</p>\n<blockquote>\n<p><code>heap.peek()</code>（窥视）</p>\n</blockquote>\n<p>返回对堆中最大值的引用。返回类型是 <code>Option&lt;&amp;T&gt;</code>。</p>\n<blockquote>\n<p><code>heap.peek_mut()</code>（窥视，可变版）</p>\n</blockquote>\n<p>返回一个 <code>PeekMut&lt;T&gt;</code>，它会返回对堆中最大值的可变引用，并提供类型关联函数 <code>pop()</code> 以从堆中弹出该值。使用此方法，我们可以根据最大值来决定是否将其从堆中弹出。</p>\n<pre class=\"code-rows\"><code>use std::collections::binary_heap::PeekMut;\n\nif let Some(top) = heap.peek_mut() {\n    if *top &gt; 10 {\n        PeekMut::pop(top);\n    }\n}</code></pre>\n<p><code>BinaryHeap</code> 还支持 <code>Vec</code> 上的部分方法，包括 <code>BinaryHeap::new()</code>、<code>.len()</code>、<code>.is_empty()</code>、<code>.capacity()</code>、<code>.clear()</code> 和 <code>.append(&amp;mut heap2)</code>。</p>\n<p>假设我们用一堆数值填充了 <code>BinaryHeap</code>：</p>\n<pre class=\"code-rows\"><code>use std::collections::BinaryHeap;\n\nlet mut heap = BinaryHeap::from(vec![2, 3, 8, 6, 9, 5, 4]);</code></pre>\n<p>值 <code>9</code> 会位于堆顶：</p>\n<pre class=\"code-rows\"><code>assert_eq!(heap.peek(), Some(&amp;9));\nassert_eq!(heap.pop(), Some(9));</code></pre>\n<p>移除了 <code>9</code> 之后也会稍微重新排列其他元素，以便让 <code>8</code> 位于最前面，以此类推：</p>\n<pre class=\"code-rows\"><code>assert_eq!(heap.pop(), Some(8));\nassert_eq!(heap.pop(), Some(6));\nassert_eq!(heap.pop(), Some(5));\n...</code></pre>\n<p>当然，<code>BinaryHeap</code> 并不局限于数值。它可以包含实现了内置特型 <code>Ord</code> 的任意类型的值。</p>\n<p>这使得 <code>BinaryHeap</code> 可用作工作队列。你可以定义一个基于优先级实现 <code>Ord</code> 的任务结构体，以便高优先级任务比低优先级任务大一些。然后，创建一个 <code>BinaryHeap</code> 来保存所有待处理的任务。它的 <code>.pop()</code> 方法将始终返回最重要的条目，也就是你的程序下一步就应该处理的任务。</p>\n<p>注意：<code>BinaryHeap</code> 是可迭代的，它有一个 <code>.iter()</code> 方法，但此迭代器会以任意顺序而不是从大到小生成堆的元素。要按优先顺序消耗 <code>BinaryHeap</code> 中的值，请使用 <code>while</code> 循环。</p>\n<pre class=\"code-rows\"><code>while let Some(task) = heap.pop() {\n    handle(task);\n}</code></pre>\n","neighbors":{"left":{"article_title":"第 15 章 迭代器(2)","id":740817},"right":{"article_title":"第 16 章 集合(2)","id":740819}},"comments":[]}