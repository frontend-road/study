{"id":8137,"title":"第10讲 | 如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？","content":"<p>我在之前两讲介绍了Java集合框架的典型容器类，它们绝大部分都不是线程安全的，仅有的线程安全实现，比如Vector、Stack，在性能方面也远不尽如人意。幸好Java语言提供了并发包（java.util.concurrent），为高度并发需求提供了更加全面的工具支持。</p>\n<p>今天我要问你的问题是，<span class=\"orange\">如何保证容器是线程安全的？ConcurrentHashMap如何实现高效地线程安全？</span></p>\n<h2>典型回答</h2>\n<p>Java提供了不同层面的线程安全支持。在传统集合框架内部，除了Hashtable等同步容器，还提供了所谓的同步包装器（Synchronized Wrapper），我们可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器（如Collections.synchronizedMap），但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。</p>\n<p>另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：</p>\n<ul>\n<li>\n<p>各种并发容器，比如ConcurrentHashMap、CopyOnWriteArrayList。</p>\n</li>\n<li>\n<p>各种线程安全队列（Queue/Deque），如ArrayBlockingQueue、SynchronousQueue。</p>\n</li>\n<li>\n<p>各种有序容器的线程安全版本等。</p>\n</li>\n</ul>\n<p>具体保证线程安全的方式，包括有从简单的synchronize方式，到基于更加精细化的，比如基于分离锁实现的ConcurrentHashMap等并发实现等。具体选择要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远优于早期的简单同步实现。</p>\n<h2>考点分析</h2>\n<p>谈到线程安全和并发，可以说是Java面试中必考的考点，我上面给出的回答是一个相对宽泛的总结，而且ConcurrentHashMap等并发容器实现也在不断演进，不能一概而论。</p>\n<p>如果要深入思考并回答这个问题及其扩展方面，至少需要：</p>\n<!-- [[[read_end]]] -->\n<ul>\n<li>\n<p>理解基本的线程安全工具。</p>\n</li>\n<li>\n<p>理解传统集合框架并发编程中Map存在的问题，清楚简单同步方式的不足。</p>\n</li>\n<li>\n<p>梳理并发包内，尤其是ConcurrentHashMap采取了哪些方法来提高并发表现。</p>\n</li>\n<li>\n<p>最好能够掌握ConcurrentHashMap自身的演进，目前的很多分析资料还是基于其早期版本。</p>\n</li>\n</ul>\n<p>今天我主要是延续专栏之前两讲的内容，重点解读经常被同时考察的HashMap和ConcurrentHashMap。今天这一讲并不是对并发方面的全面梳理，毕竟这也不是专栏一讲可以介绍完整的，算是个开胃菜吧，类似CAS等更加底层的机制，后面会在Java进阶模块中的并发主题有更加系统的介绍。</p>\n<h2>知识扩展</h2>\n<p>1.为什么需要ConcurrentHashMap？</p>\n<p>Hashtable本身比较低效，因为它的实现基本就是将put、get、size等各种方法加上“synchronized”。简单来说，这就导致了所有并发操作都要竞争同一把锁，一个线程在进行同步操作时，其他线程只能等待，大大降低了并发操作的效率。</p>\n<p>前面已经提过HashMap不是线程安全的，并发情况会导致类似CPU占用100%等一些问题，那么能不能利用Collections提供的同步包装器来解决问题呢？</p>\n<p>看看下面的代码片段，我们发现同步包装器只是利用输入Map构造了另一个同步版本，所有操作虽然不再声明成为synchronized方法，但是还是利用了“this”作为互斥的mutex，没有真正意义上的改进！</p>\n<pre><code>private static class SynchronizedMap&lt;K,V&gt;\n    implements Map&lt;K,V&gt;, Serializable {\n    private final Map&lt;K,V&gt; m;     // Backing Map\n    final Object      mutex;        // Object on which to synchronize\n    // …\n    public int size() {\n        synchronized (mutex) {return m.size();}\n    }\n // … \n}\n\n</code></pre>\n<p>所以，Hashtable或者同步包装版本，都只是适合在非高度并发的场景下。</p>\n<p>2.ConcurrentHashMap分析</p>\n<p>我们再来看看ConcurrentHashMap是如何设计实现的，为什么它能大大提高并发效率。</p>\n<p>首先，我这里强调，<strong>ConcurrentHashMap的设计实现其实一直在演化</strong>，比如在Java 8中就发生了非常大的变化（Java 7其实也有不少更新），所以，我这里将比较分析结构、实现机制等方面，对比不同版本的主要区别。</p>\n<p>早期ConcurrentHashMap，其实现是基于：</p>\n<ul>\n<li>\n<p>分离锁，也就是将内部进行分段（Segment），里面则是HashEntry的数组，和HashMap类似，哈希相同的条目也是以链表形式存放。</p>\n</li>\n<li>\n<p>HashEntry内部使用volatile的value字段来保证可见性，也利用了不可变对象的机制以改进利用Unsafe提供的底层能力，比如volatile access，去直接完成部分操作，以最优化性能，毕竟Unsafe中的很多操作都是JVM intrinsic优化过的。</p>\n</li>\n</ul>\n<p>你可以参考下面这个早期ConcurrentHashMap内部结构的示意图，其核心是利用分段设计，在进行并发操作的时候，只需要锁定相应段，这样就有效避免了类似Hashtable整体同步的问题，大大提高了性能。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/d4/d9/d45bcf9a34da2ef1ef335532b0198bd9.png?wh=881*611\" alt=\"\" /></p>\n<p>在构造的时候，Segment的数量由所谓的concurrencyLevel决定，默认是16，也可以在相应构造函数直接指定。注意，Java需要它是2的幂数值，如果输入是类似15这种非幂值，会被自动调整到16之类2的幂数值。</p>\n<p>具体情况，我们一起看看一些Map基本操作的<a href=\"http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/java/util/concurrent/ConcurrentHashMap.java\">源码</a>，这是JDK 7比较新的get代码。针对具体的优化部分，为方便理解，我直接注释在代码段里，get操作需要保证的是可见性，所以并没有什么同步逻辑。</p>\n<pre><code>public V get(Object key) {\n        Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead\n        HashEntry&lt;K,V&gt;[] tab;\n        int h = hash(key.hashCode());\n       //利用位操作替换普通数学运算\n       long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;\n        // 以Segment为单位，进行定位\n        // 利用Unsafe直接进行volatile access\n        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;\n            (tab = s.table) != null) {\n           //省略\n          }\n        return null;\n    }\n</code></pre>\n<p>而对于put操作，首先是通过二次哈希避免哈希冲突，然后以Unsafe调用方式，直接获取相应的Segment，然后进行线程安全的put操作：</p>\n<pre><code> public V put(K key, V value) {\n        Segment&lt;K,V&gt; s;\n        if (value == null)\n            throw new NullPointerException();\n        // 二次哈希，以保证数据的分散性，避免哈希冲突\n        int hash = hash(key.hashCode());\n        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;\n        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck\n             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment\n            s = ensureSegment(j);\n        return s.put(key, hash, value, false);\n    }\n\n</code></pre>\n<p>其核心逻辑实现在下面的内部方法中：</p>\n<pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n            // scanAndLockForPut会去查找是否有key相同Node\n            // 无论如何，确保获取锁\n            HashEntry&lt;K,V&gt; node = tryLock() ? null :\n                scanAndLockForPut(key, hash, value);\n            V oldValue;\n            try {\n                HashEntry&lt;K,V&gt;[] tab = table;\n                int index = (tab.length - 1) &amp; hash;\n                HashEntry&lt;K,V&gt; first = entryAt(tab, index);\n                for (HashEntry&lt;K,V&gt; e = first;;) {\n                    if (e != null) {\n                        K k;\n                        // 更新已有value...\n                    }\n                    else {\n                        // 放置HashEntry到特定位置，如果超过阈值，进行rehash\n                        // ...\n                    }\n                }\n            } finally {\n                unlock();\n            }\n            return oldValue;\n        }\n\n</code></pre>\n<p>所以，从上面的源码清晰的看出，在进行并发写操作时：</p>\n<ul>\n<li>\n<p>ConcurrentHashMap会获取再入锁，以保证数据一致性，Segment本身就是基于ReentrantLock的扩展实现，所以，在并发修改期间，相应Segment是被锁定的。</p>\n</li>\n<li>\n<p>在最初阶段，进行重复性的扫描，以确定相应key值是否已经在数组里面，进而决定是更新还是放置操作，你可以在代码里看到相应的注释。重复扫描、检测冲突是ConcurrentHashMap的常见技巧。</p>\n</li>\n<li>\n<p>我在专栏上一讲介绍HashMap时，提到了可能发生的扩容问题，在ConcurrentHashMap中同样存在。不过有一个明显区别，就是它进行的不是整体的扩容，而是单独对Segment进行扩容，细节就不介绍了。</p>\n</li>\n</ul>\n<p>另外一个Map的size方法同样需要关注，它的实现涉及分离锁的一个副作用。</p>\n<p>试想，如果不进行同步，简单的计算所有Segment的总值，可能会因为并发put，导致结果不准确，但是直接锁定所有Segment进行计算，就会变得非常昂贵。其实，分离锁也限制了Map的初始化等操作。</p>\n<p>所以，ConcurrentHashMap的实现是通过重试机制（RETRIES_BEFORE_LOCK，指定重试次数2），来试图获得可靠值。如果没有监控到发生变化（通过对比Segment.modCount），就直接返回，否则获取锁进行操作。</p>\n<p>下面我来对比一下，<strong>在Java 8和之后的版本中，ConcurrentHashMap发生了哪些变化呢？</strong></p>\n<ul>\n<li>\n<p>总体结构上，它的内部存储变得和我在专栏上一讲介绍的HashMap结构非常相似，同样是大的桶（bucket）数组，然后内部也是一个个所谓的链表结构（bin），同步的粒度要更细致一些。</p>\n</li>\n<li>\n<p>其内部仍然有Segment定义，但仅仅是为了保证序列化时的兼容性而已，不再有任何结构上的用处。</p>\n</li>\n<li>\n<p>因为不再使用Segment，初始化操作大大简化，修改为lazy-load形式，这样可以有效避免初始开销，解决了老版本很多人抱怨的这一点。</p>\n</li>\n<li>\n<p>数据存储利用volatile来保证可见性。</p>\n</li>\n<li>\n<p>使用CAS等操作，在特定场景进行无锁并发操作。</p>\n</li>\n<li>\n<p>使用Unsafe、LongAdder之类底层手段，进行极端情况的优化。</p>\n</li>\n</ul>\n<p>先看看现在的数据存储内部实现，我们可以发现Key是final的，因为在生命周期中，一个条目的Key发生变化是不可能的；与此同时val，则声明为volatile，以保证可见性。</p>\n<pre><code> static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n        final int hash;\n        final K key;\n        volatile V val;\n        volatile Node&lt;K,V&gt; next;\n        // … \n    }\n</code></pre>\n<p>我这里就不再介绍get方法和构造函数了，相对比较简单，直接看并发的put是如何实现的。</p>\n<pre><code>final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node&lt;K,V&gt;[] tab = table;;) {\n        Node&lt;K,V&gt; f; int n, i, fh; K fk; V fv;\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {\n            // 利用CAS去进行无锁线程安全操作，如果bin是空的\n            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value)))\n                break; \n        }\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else if (onlyIfAbsent // 不加锁，进行检查\n                 &amp;&amp; fh == hash\n                 &amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk)))\n                 &amp;&amp; (fv = f.val) != null)\n            return fv;\n        else {\n            V oldVal = null;\n            synchronized (f) {\n                   // 细粒度的同步修改操作... \n                }\n            }\n            // Bin超过阈值，进行树化\n            if (binCount != 0) {\n                if (binCount &gt;= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n\n</code></pre>\n<p>初始化操作实现在initTable里面，这是一个典型的CAS使用场景，利用volatile的sizeCtl作为互斥手段：如果发现竞争性的初始化，就spin在那里，等待条件恢复；否则利用CAS设置排他标志。如果成功则进行初始化；否则重试。</p>\n<p>请参考下面代码：</p>\n<pre><code>private final Node&lt;K,V&gt;[] initTable() {\n    Node&lt;K,V&gt;[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        // 如果发现冲突，进行spin等待\n        if ((sc = sizeCtl) &lt; 0)\n            Thread.yield(); \n        // CAS成功返回true，则进入真正的初始化逻辑\n        else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;\n                    @SuppressWarnings(&quot;unchecked&quot;)\n                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];\n                    table = tab = nt;\n                    sc = n - (n &gt;&gt;&gt; 2);\n                }\n            } finally {\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n\n</code></pre>\n<p>当bin为空时，同样是没有必要锁定，也是以CAS操作去放置。</p>\n<p>你有没有注意到，在同步逻辑上，它使用的是synchronized，而不是通常建议的ReentrantLock之类，这是为什么呢？现代JDK中，synchronized已经被不断优化，可以不再过分担心性能差异，另外，相比于ReentrantLock，它可以减少内存消耗，这是个非常大的优势。</p>\n<p>与此同时，更多细节实现通过使用Unsafe进行了优化，例如tabAt就是直接利用getObjectAcquire，避免间接调用的开销。</p>\n<pre><code>static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {\n    return (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);\n}\n\n</code></pre>\n<p>再看看，现在是如何实现size操作的。<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/12fc7bf488ec/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java\">阅读代码</a>你会发现，真正的逻辑是在sumCount方法中， 那么sumCount做了什么呢？</p>\n<pre><code>final long sumCount() {\n    CounterCell[] as = counterCells; CounterCell a;\n    long sum = baseCount;\n    if (as != null) {\n        for (int i = 0; i &lt; as.length; ++i) {\n            if ((a = as[i]) != null)\n                sum += a.value;\n        }\n    }\n    return sum;\n}\n\n</code></pre>\n<p>我们发现，虽然思路仍然和以前类似，都是分而治之的进行计数，然后求和处理，但实现却基于一个奇怪的CounterCell。 难道它的数值，就更加准确吗？数据一致性是怎么保证的？</p>\n<pre><code>static final class CounterCell {\n    volatile long value;\n    CounterCell(long x) { value = x; }\n}\n</code></pre>\n<p>其实，对于CounterCell的操作，是基于java.util.concurrent.atomic.LongAdder进行的，是一种JVM利用空间换取更高效率的方法，利用了<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/12fc7bf488ec/src/java.base/share/classes/java/util/concurrent/atomic/Striped64.java\">Striped64</a>内部的复杂逻辑。这个东西非常小众，大多数情况下，建议还是使用AtomicLong，足以满足绝大部分应用的性能需求。</p>\n<p>今天我从线程安全问题开始，概念性的总结了基本容器工具，分析了早期同步容器的问题，进而分析了Java  7和Java  8中ConcurrentHashMap是如何设计实现的，希望ConcurrentHashMap的并发技巧对你在日常开发可以有所帮助。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？留一个道思考题给你，在产品代码中，有没有典型的场景需要使用类似ConcurrentHashMap这样的并发容器呢？</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n","comments":[{"had_liked":false,"id":14843,"user_name":"蔡光明","can_delete":false,"product_type":"c1","uid":1158477,"ip_address":"","ucode":"7EACC0555B4F19","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/4d/e24fc9e4.jpg","comment_is_top":false,"comment_ctime":1530692866,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"851934217474","product_id":100006701,"comment_content":"1.7<br>put加锁<br>通过分段加锁segment，一个hashmap里有若干个segment，每个segment里有若干个桶，桶里存放K-V形式的链表，put数据时通过key哈希得到该元素要添加到的segment，然后对segment进行加锁，然后在哈希，计算得到给元素要添加到的桶，然后遍历桶中的链表，替换或新增节点到桶中<br><br>size<br>分段计算两次，两次结果相同则返回，否则对所以段加锁重新计算<br><br><br>1.8<br>put CAS 加锁<br>1.8中不依赖与segment加锁，segment数量与桶数量一致；<br>首先判断容器是否为空，为空则进行初始化利用volatile的sizeCtl作为互斥手段，如果发现竞争性的初始化，就暂停在那里，等待条件恢复，否则利用CAS设置排他标志（U.compareAndSwapInt(this, SIZECTL, sc, -1)）;否则重试<br>对key hash计算得到该key存放的桶位置，判断该桶是否为空，为空则利用CAS设置新节点<br>否则使用synchronize加锁，遍历桶中数据，替换或新增加点到桶中<br>最后判断是否需要转为红黑树，转换之前判断是否需要扩容<br><br>size<br>利用LongAdd累加计算","like_count":199,"discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304604,"discussion_content":"再指出一点，不是 &#34;利用LongAdd累加计算&#34;（×）而是利用填充分布的cell，逻辑改编自LongAdder和Striped64达到原子操作累加计算大小，而且Put操作是建立在协作扩容的基础上来解决冲突的，动态的修改了大小方便累加计算","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1599624309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1178888,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","nickname":"小鳄鱼","note":"","ucode":"9C30CAFB41A263","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588495,"discussion_content":"我说老师贴出来的代码也没看到LongAdder的痕迹啊，咋说使用了呢？只是逻辑上这样实现了而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663806669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304604,"ip_address":"广东"},"score":588495,"extra":""}]},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37018,"discussion_content":"语序有点乱我改了改不知道对不对:\n首先判断容器是否为空，为空则进行初始化，initTable()利用volatile的sizeCtl作为互斥手段;如果发现竞争性的初始化，就yield在那里，等待条件恢复;\n否则初始化时利用CAS设置排他标志sizeCtl（U.compareAndSwapInt(this, SIZECTL, sc, -1)）;\n否则重试初始化；\n如果容器是不为空但的 bin 是空的，利则用 CAS 去进行无锁线程安全操作：对key hash计算得到该key存放的桶位置，判断该桶是否为空，为空则利用CAS设置新节点；\n否则使用synchronize加锁，遍历桶中数据，替换或新增加点到桶中\n最后判断是否需要转为红黑树，转换之前判断是否需要扩容","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1571482277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1970536,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/11/68/ac0d2b05.jpg","nickname":"柯伟","note":"","ucode":"92BFAA8B85E5E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388590,"discussion_content":"java8及之后版本：ConcurrentHashMap，在put数据时，首先判断容器是否为空，为空则利用CAS进行初始化。不为空则判断存放的桶是否为空，为空则利用CAS设置新节点。不为空则使用Synchronized对该桶加锁，遍历桶中的链表（或树），替换或新增节点到桶中","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628843142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115909,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/05/0e59855d.jpg","nickname":"愤怒的小龙打小鸟","note":"","ucode":"363AF21A33CD2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240959,"discussion_content":"Segments的大小一旦初始化就不变了吗？默认初始化大小是16吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587391964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747918,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ab/ce/a4d03c2c.jpg","nickname":"张德雷","note":"","ucode":"788BEC93FB7971","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180046,"discussion_content":"清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582273238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2744868,"avatar":"","nickname":"麻花","note":"","ucode":"FCCD929A8B47DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1747918,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ab/ce/a4d03c2c.jpg","nickname":"张德雷","note":"","ucode":"788BEC93FB7971","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391998,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630755418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":180046,"ip_address":""},"score":391998,"extra":""}]}]},{"had_liked":false,"id":10164,"user_name":"徐金铎","can_delete":false,"product_type":"c1","uid":1080462,"ip_address":"","ucode":"E13FD19FD27869","user_header":"https://static001.geekbang.org/account/avatar/00/10/7c/8e/73581062.jpg","comment_is_top":false,"comment_ctime":1527319286,"is_pvip":false,"replies":[{"id":"3222","content":"是的","user_name":"作者回复","comment_id":10164,"uid":"1009360","ip_address":"","utype":1,"ctime":1527468754,"user_name_real":"杨晓峰"}],"discussion_count":6,"race_medal":0,"score":"473973721846","product_id":100006701,"comment_content":"需要注意的一点是，1.8以后的锁的颗粒度，是加在链表头上的，这个是个思路上的突破。","like_count":111,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418369,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527468754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","nickname":"王盛武","note":"","ucode":"DE7EF246D3DCE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47207,"discussion_content":"不是头上, 是每一个Node, 不是链表的第1个Node","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573293886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","nickname":"王盛武","note":"","ucode":"DE7EF246D3DCE8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129344,"discussion_content":"你入口就只有头部的node.，锁住入口就可以了，后面根本就没加锁，我怀疑你就没看源码","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1578674562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47207,"ip_address":""},"score":129344,"extra":""}]},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37024,"discussion_content":"请问，这&#34;加在链表头上的  锁的颗粒度&#34;是怎么看出来的？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571483091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129346,"discussion_content":"jdk源代码，进去就能看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578675066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37024,"ip_address":""},"score":129346,"extra":""},{"author":{"id":1306394,"avatar":"","nickname":"Aiome","note":"","ucode":"5D3A810C0FF56B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310425,"discussion_content":"putVal部分代码\nfor (Node<K,V>[] tab = table;;) {\n    Node<K,V> f; int n, i, fh;\n    // 省略一部分代码\n    // 此时f是tab桶中的node也就是第一个元素\n    f = tabAt(tab, i = (n - 1) &amp; hash));\n    // 省略一部分代码\n    // 对f加锁，所以后续线程对这个桶的所有node修改都需要等待\n    synchronized (f) {\n    }\n}","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1601824000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37024,"ip_address":""},"score":310425,"extra":""}]}]},{"had_liked":false,"id":10303,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1068651,"ip_address":"","ucode":"E482059A067C84","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/6b/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1527468321,"is_pvip":false,"replies":[{"id":"3244","content":"正确，互相交流<br>偏向锁，侧重是低竞争场景的优化，去掉可能不必要的同步","user_name":"作者回复","comment_id":10303,"uid":"1009360","ip_address":"","utype":1,"ctime":1527482275,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"220570800417","product_id":100006701,"comment_content":"最近用ConcurrentHashMap的场景是，由于系统是一个公共服务，全程异步处理。最后一环节需要http rest主动响应接入系统，于是为了定制化需求，利用netty写了一版异步http clinet。其在缓存tcp链接时用到了。<br>看到下面有一位朋友说起了自旋锁和偏向锁。<br>自旋锁个人理解的是cas的一种应用方式。并发包中的原子类是典型的应用。<br>偏向锁个人理解的是获取锁的优化。在ReentrantLock中用于实现已获取完锁的的线程重入问题。<br>不知道理解的是否有误差。欢迎指正探讨。谢谢","like_count":52,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418431,"discussion_content":"正确，互相交流\n偏向锁，侧重是低竞争场景的优化，去掉可能不必要的同步","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1527482275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14753,"user_name":"t","can_delete":false,"product_type":"c1","uid":1153833,"ip_address":"","ucode":"84FA886A94B603","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/29/c50118cf.jpg","comment_is_top":false,"comment_ctime":1530631978,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"181919258410","product_id":100006701,"comment_content":"对于我这种菜鸟来说，应该来一期讲讲volatile😭","like_count":43,"discussions":[{"author":{"id":1437425,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/f1/16545faf.jpg","nickname":"学习","note":"","ucode":"CDFB71E0D1508B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395379,"discussion_content":"隔壁的Java并发编程写的很好啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632296684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336544,"discussion_content":"这玩意是真的很难理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608623241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10128,"user_name":"j.c.","can_delete":false,"product_type":"c1","uid":1004961,"ip_address":"","ucode":"909571207BAA63","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/a1/ed52e319.jpg","comment_is_top":false,"comment_ctime":1527304137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"147556192201","product_id":100006701,"comment_content":"期待unsafe和cas的文章","like_count":33},{"had_liked":false,"id":10102,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1527296155,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"130376315035","product_id":100006701,"comment_content":"今天这个纯粹知识盲点，纯赞，源码也得不停看","like_count":30},{"had_liked":false,"id":10244,"user_name":"虞飞","can_delete":false,"product_type":"c1","uid":1053075,"ip_address":"","ucode":"601B864214C4F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/93/8b41390b.jpg","comment_is_top":false,"comment_ctime":1527410325,"is_pvip":true,"replies":[{"id":"3238","content":"目前并发list好像就那一个，我觉得不必拘泥于list，不还有queue之类，看场景需要的真是list吗","user_name":"作者回复","comment_id":10244,"uid":"1009360","ip_address":"","utype":1,"ctime":1527480805,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"83131788949","product_id":100006701,"comment_content":"老师在课程里讲到同步包装类比较低效，不太适合高并发的场景，那想请教一下老师，在list接口的实现类中。在高并发的场景下，选择哪种实现类比较好？因为ArrayList是线程不安全的，同步包装类又很低效，CopyonwriteArrayList又是以快照的形式来实现的，在频繁写入数据的时候，其实也很低效，那这个类型该怎么选择比较好？","like_count":19,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418409,"discussion_content":"目前并发list好像就那一个，我觉得不必拘泥于list，不还有queue之类，看场景需要的真是list吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527480805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10380,"user_name":"Kyle","can_delete":false,"product_type":"c1","uid":1106079,"ip_address":"","ucode":"44198A0BEC5FB2","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/9f/9259a6b9.jpg","comment_is_top":false,"comment_ctime":1527514837,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"48772155093","product_id":100006701,"comment_content":"之前用JavaFX做一个客户端IM工具的时候，我将拉来的未被读取的用户聊天信息用ConcurrentHashMap存储（同时异步存储到Sqlite），Key存放用户id，Value放未读取的聊天消息列表。因为我考虑到存消息和读消息是由两个线程并发处理的，这两个线程共同操作一个ConcurrentHashMap。可能是我没处理好，最后直到我离职了还有消息重复、乱序的问题。请问我这种应用场景有什么问题吗?","like_count":10,"discussions":[{"author":{"id":1466335,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5f/df/3c4881f0.jpg","nickname":"Geek","note":"","ucode":"1B8EB2C26DE4EC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269545,"discussion_content":"个人愚见，你的value放置的是一个list，这个list又是否用的线程安全的集合？用之前是否提前校验了重复性？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589905435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1510177,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0b/21/f1aea35b.jpg","nickname":"let_me_go","note":"","ucode":"A5936F5C5E3D65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361265,"discussion_content":"个人愚见：ConcurrentHashMap存储的k-v是没有顺序的,遍历的时候会发现得到的顺序并不是存入的顺序。ConcurrentLinkedHashMap的k-v是有序的,是按照存入的先后顺序进行存储的,遍历得到的顺序就是存储的顺序,所以这种情况下是不是应该用ConcurrentLinkedHashMap来保证顺序。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616634619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1184256,"avatar":"https://static001.geekbang.org/account/avatar/00/12/12/00/9917dd6c.jpg","nickname":"Duncan","note":"","ucode":"C1CA624885FFC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1510177,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0b/21/f1aea35b.jpg","nickname":"let_me_go","note":"","ucode":"A5936F5C5E3D65","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551193,"discussion_content":"个人愚见，消息的顺序不应该按照写入的顺序排序，应该是用消息本身的时间排序，因为后发的消息可能先到。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1644922020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361265,"ip_address":""},"score":551193,"extra":""}]}]},{"had_liked":false,"id":10283,"user_name":"coder王","can_delete":false,"product_type":"c1","uid":1121990,"ip_address":"","ucode":"21465DC3850BCB","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/c6/6f817e6e.jpg","comment_is_top":false,"comment_ctime":1527437795,"is_pvip":false,"replies":[{"id":"3236","content":"通常是的，前提是JDK版本需要新一点","user_name":"作者回复","comment_id":10283,"uid":"1009360","ip_address":"","utype":1,"ctime":1527480408,"user_name_real":"杨晓峰"}],"discussion_count":3,"race_medal":0,"score":"44477110755","product_id":100006701,"comment_content":"您说的synchronized被改进很多很多了，那么在我们平常使用中，就用这个synchronized完成一些同步操作是不是OK？😁","like_count":10,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418422,"discussion_content":"通常是的，前提是JDK版本需要新一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527480408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605637,"avatar":"https://static001.geekbang.org/account/avatar/00/18/80/05/5e80a2b4.jpg","nickname":"第二次","note":"","ucode":"E0E5F3209D4378","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13496,"discussion_content":"多少版本？1.8可以了嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568680647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2601059,"avatar":"","nickname":"Geek_6f20b8","note":"","ucode":"0D93F9AAF1EAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1605637,"avatar":"https://static001.geekbang.org/account/avatar/00/18/80/05/5e80a2b4.jpg","nickname":"第二次","note":"","ucode":"E0E5F3209D4378","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371171,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619675943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":13496,"ip_address":""},"score":371171,"extra":""}]}]},{"had_liked":false,"id":10500,"user_name":"Leiy","can_delete":false,"product_type":"c1","uid":1009001,"ip_address":"","ucode":"BE812F95D6089E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/69/efb57b83.jpg","comment_is_top":false,"comment_ctime":1527564636,"is_pvip":true,"replies":[{"id":"3354","content":"基本正确，cas只用在部分场景；<br>事后看容易啊，说比做容易，😄","user_name":"作者回复","comment_id":10500,"uid":"1009360","ip_address":"","utype":1,"ctime":1527607302,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"40182270300","product_id":100006701,"comment_content":"我感觉jdk8就相当于把segment分段锁更细粒度了，每个数组元素就是原来一个segment，那并发度就由原来segment数变为数组长度？而且用到了cas乐观锁，所以能支持更高的并发，不知道我这种理解对吗？如果对的话，我就在想，为什么并发大神之前没想到这种，哈哈😄，恳请指正。谢谢","like_count":10,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418505,"discussion_content":"基本正确，cas只用在部分场景；\n事后看容易啊，说比做容易，😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527607302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10086,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1527291733,"is_pvip":false,"replies":[{"id":"3242","content":"本文尽量梳理了相对比较容易理解的部分；扩容细节我觉得是个加分项，不是每个人都会在乎那么深入；窍门，可以考虑画图辅助理解，我是比较笨的类型，除了死磕，不会太多窍门……","user_name":"作者回复","comment_id":10086,"uid":"1009360","ip_address":"","utype":1,"ctime":1527481258,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"35887030101","product_id":100006701,"comment_content":"这期内容太难，分寸不好把握<br>看8的concurenthashmap源码感觉挺困难，网上的博文帮助也不大，尤其是扩容这部分（似乎文章中没提）<br>求问杨大有没有什么窍门，或者有什么启发性的paper或文章？<br>可以泛化成，长期对lock free实现多个状态修改的问题比较困惑，希望得到启发","like_count":8,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418338,"discussion_content":"本文尽量梳理了相对比较容易理解的部分；扩容细节我觉得是个加分项，不是每个人都会在乎那么深入；窍门，可以考虑画图辅助理解，我是比较笨的类型，除了死磕，不会太多窍门……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527481258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14602,"user_name":"Answer","can_delete":false,"product_type":"c1","uid":1159719,"ip_address":"","ucode":"DA68AD6407843C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b2/27/08644c40.jpg","comment_is_top":false,"comment_ctime":1530572820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23005409300","product_id":100006701,"comment_content":"Unsafe？","like_count":5},{"had_liked":false,"id":14524,"user_name":"shawn","can_delete":false,"product_type":"c1","uid":1010221,"ip_address":"","ucode":"8F6A8C7920996E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/2d/ec4ed8ce.jpg","comment_is_top":false,"comment_ctime":1530508880,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23005345360","product_id":100006701,"comment_content":"老师，什么只有bin为空的时候才使用cas，其他地方用synchronized 呢？","like_count":5,"discussions":[{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388311,"discussion_content":"我理解是因为bin为空的时候只需要cas给一个变量赋值就行了，能保证正确性。但是后面有一个链表的时候，就有多个变量值的修改了，需要加锁来保证并发正确。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628690996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529858,"avatar":"https://static001.geekbang.org/account/avatar/00/17/58/02/2b7ccf09.jpg","nickname":"民工597","note":"","ucode":"DB6857E21E9318","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350452,"discussion_content":"创建不是高并发场景吧，cas消耗CPU没法支持很大的并发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613878662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10165,"user_name":"mongo","can_delete":false,"product_type":"c1","uid":1113124,"ip_address":"","ucode":"F39FE783793A17","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/24/7d43d807.jpg","comment_is_top":false,"comment_ctime":1527319317,"is_pvip":false,"replies":[{"id":"3247","content":"我理解是的，判断是个ForwardingNode，resize正在进行；<br>nexttable是扩容时的临时过渡","user_name":"作者回复","comment_id":10165,"uid":"1009360","ip_address":"","utype":1,"ctime":1527483694,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"23002155797","product_id":100006701,"comment_content":"请教老师：putVal方法中，什么情况下会进入else if ((fh=f.hash) == MOVED)分支？是进行扩容的时候吗？nextTable是做什么用的？","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418370,"discussion_content":"我理解是的，判断是个ForwardingNode，resize正在进行；\nnexttable是扩容时的临时过渡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527483694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10152,"user_name":"mongo","can_delete":false,"product_type":"c1","uid":1113124,"ip_address":"","ucode":"F39FE783793A17","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/24/7d43d807.jpg","comment_is_top":false,"comment_ctime":1527310686,"is_pvip":false,"replies":[{"id":"3246","content":"这个有volatile load语义","user_name":"作者回复","comment_id":10152,"uid":"1009360","ip_address":"","utype":1,"ctime":1527483045,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"23002147166","product_id":100006701,"comment_content":"请教老师：putVal方法的第二个if分支，为什么要用tabAt？我的认识里直接数组下标寻址tab[i=(n-1) &amp; hash]也是一个原子操作，不是吗？tabAt里面的getObjectVolatle（）方法跟直接用数组下标tab[i=(n-1) &amp; hash]寻址有什么区别？","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418362,"discussion_content":"这个有volatile load语义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527483045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207774,"discussion_content":"不会的，volatile只修饰tab引用，只保证tab引用的volatile语义，对tab[i] 的访问并没有volatile语义；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584513514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235742,"user_name":"Arthur","can_delete":false,"product_type":"c1","uid":1222441,"ip_address":"","ucode":"FF96EEDEBF7E3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/29/977c3280.jpg","comment_is_top":false,"comment_ctime":1595167938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18775037122","product_id":100006701,"comment_content":"还有关于ConcurrentHashMap的Key和Value为什么不能为null，因为HashMap是非线程安全的，默认单线程环境中使用，如果get(key)为null，可以通过containsKey(key) 方法来判断这个key的value为null，还是不存在这个key，而ConcurrentHashMap，HashTable是线程安全的， 在多线程操作时，因为 【get(key)】和 【containsKey(key)】 两个操作和在一起【不是一个原子性操作】， 可能在执行中间，有其他线程修改了数据，所以无法区分value为null还是不存在key。","like_count":5},{"had_liked":false,"id":11851,"user_name":"Xg huang","can_delete":false,"product_type":"c1","uid":1016995,"ip_address":"","ucode":"9680FA95DE3553","user_header":"","comment_is_top":false,"comment_ctime":1528388249,"is_pvip":false,"replies":[{"id":"3893","content":"这个是在代价可接受情况下，尽量准确，就像含金量90%和99.9%，99.999%，还是有区别的，虽然不是百分百","user_name":"作者回复","comment_id":11851,"uid":"1009360","ip_address":"","utype":1,"ctime":1528434694,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"14413290137","product_id":100006701,"comment_content":"这里有个地方想跟老师交流一下想法, 从文中&quot;所以，ConcurrentHashMap 的实现是通过重试机制（RETRIES_BEFORE_LOCK，指定重试次数 2），来试图获得可靠值。如果没有监控到发生变化（通过对比 Segment.modCount），就直接返回，否则获取锁进行操作。&quot; 可以看出, 在高并发的情况下, &quot;size()&quot; 方法只是返回&quot;近似值&quot;, 而我的问题是: 既然只是一个近似值, 为啥要用这种&quot;重试,分段锁&quot; 的复杂做法去计算这个值? 直接在不加锁的情况下返回segment 的size 岂不是更简单? 我能理解jdk开发者想尽一切努力在高性能地返回最精确的数值, 但这个&quot;精确&quot; 度无法量化啊, 对于调用方来说,这个值依然是不可靠的啊. 所以, 在我看来,这种做法收益很小(可能是我也比较懒吧), 或者有些设计上的要点我没有领悟出来, 希望老师指点一下.","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419029,"discussion_content":"这个是在代价可接受情况下，尽量准确，就像含金量90%和99.9%，99.999%，还是有区别的，虽然不是百分百","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528434694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10260,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1527424913,"is_pvip":false,"replies":[{"id":"3217","content":"好，后面有章节","user_name":"作者回复","comment_id":10260,"uid":"1009360","ip_address":"","utype":1,"ctime":1527467993,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"14412326801","product_id":100006701,"comment_content":"老师麻烦讲讲自旋锁，偏向锁的特点和区别吧，一直不太清楚。","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418415,"discussion_content":"好，后面有章节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527467993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121912,"user_name":"顺哥聊成长","can_delete":false,"product_type":"c1","uid":1023328,"ip_address":"","ucode":"FEF42E951B16F4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/60/45b3184d.jpg","comment_is_top":false,"comment_ctime":1565247944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10155182536","product_id":100006701,"comment_content":"分而治之的思想，再利用一些原子操作，来实现无锁编程，应对高并发。这样理解靠谱吗？","like_count":2},{"had_liked":false,"id":81003,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1553773142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10143707734","product_id":100006701,"comment_content":"我记得concurrentHashMap的size方法是一个嵌套循环：<br>1：遍历所有的segment；<br>2：把所有segment元素累加起来；<br>3：把所有segment的修改次数累加起来;<br>4：判断当次segment修改次数是否大于上次的总修改次数，如果大于，则说明当次还有修改，重新统计，尝试一次，如果不是，说明没有修改，则结束；<br>5：如果尝试次数超过阈值，则对每个segment加锁，重新统计，最后在重试4步骤，只到总修改次数大于上次修改次数，释放锁，然后统计结束。","like_count":2},{"had_liked":false,"id":44058,"user_name":"陈坤","can_delete":false,"product_type":"c1","uid":1044533,"ip_address":"","ucode":"DADE8D9C40B2F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f0/35/a5ded70c.jpg","comment_is_top":false,"comment_ctime":1543366782,"is_pvip":false,"replies":[{"id":"16131","content":"22章有系统介绍","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1543626819,"ip_address":"","comment_id":44058,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10133301374","product_id":100006701,"comment_content":"老师，cas操作有没有什么弊端呢？因为cas也很长一段时间了，根据您的经验，有弊端吗？","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430615,"discussion_content":"22章有系统介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543626819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10762,"user_name":"Levy","can_delete":false,"product_type":"c1","uid":1078941,"ip_address":"","ucode":"6AFCB0EA6CA183","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/9d/6dab9e0e.jpg","comment_is_top":false,"comment_ctime":1527689991,"is_pvip":false,"replies":[{"id":"3461","content":"volatile保证的是数组，不是数组元素","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527760511,"ip_address":"","comment_id":10762,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10117624583","product_id":100006701,"comment_content":"老师你好，tabAt里面的getObjectVolatle（）方法跟直接用数组下标tab[i=(n-1) &amp; hash]寻址有什么区别，这个我也不懂，volitile不是已经保证内存可见性吗？","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418591,"discussion_content":"volatile保证的是数组，不是数组元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527760511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10304,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1527468371,"is_pvip":false,"replies":[{"id":"3235","content":"后面并发部分会详细分析","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527479477,"ip_address":"","comment_id":10304,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10117402963","product_id":100006701,"comment_content":"并发包用的很少，这一节内容的前置知识比较多，对于使用经验少的人来说貌似是有点难了。问题很好，正好可以见识一下各种使用场景，不过留言大部分是针对内容的难点提问，而真正回答问题的还没有出现。","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418432,"discussion_content":"后面并发部分会详细分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527479477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10179,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1527325053,"is_pvip":false,"replies":[{"id":"3219","content":"我列出来的区别不止吧；<br>存在锁升降级的问题，后面有章节介绍","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527468263,"ip_address":"","comment_id":10179,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10117259645","product_id":100006701,"comment_content":"jdk7和8的区别感觉就是加锁不一样了，其他的没看懂。<br>老师，synchronized和lock是不是都是在类字节码种携带自旋锁和偏向锁啊？<br>他两底层区别是啥呢？我知道lock里面维护了一个双向链表","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418375,"discussion_content":"我列出来的区别不止吧；\n存在锁升降级的问题，后面有章节介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527468263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293571,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1621433670,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"5916400966","product_id":100006701,"comment_content":"高并发场景可以用concurrentHashMap","like_count":1},{"had_liked":false,"id":209225,"user_name":"李飞","can_delete":false,"product_type":"c1","uid":1555180,"ip_address":"","ucode":"930458850AA05B","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/ec/2b1c6afc.jpg","comment_is_top":false,"comment_ctime":1587521291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882488587","product_id":100006701,"comment_content":"ConcurrentHashMap的场景应用：在线用户","like_count":1},{"had_liked":false,"id":163425,"user_name":"AAA_叶子","can_delete":false,"product_type":"c1","uid":1325994,"ip_address":"","ucode":"1E93617D308EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/aa/e8dfcd7e.jpg","comment_is_top":false,"comment_ctime":1576719972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871687268","product_id":100006701,"comment_content":"concurrentHashMap put方法 是线程安全的， 但是get方法 不能保证，采用的volatile 修饰的 Node 保证可见性， 对红黑树的节点的get 采用的是加锁机制。","like_count":1},{"had_liked":false,"id":127414,"user_name":"日光倾城","can_delete":false,"product_type":"c1","uid":1120345,"ip_address":"","ucode":"E4329963F660DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/59/daeb0b6c.jpg","comment_is_top":false,"comment_ctime":1566703326,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5861670622","product_id":100006701,"comment_content":"initTable里面的Thread.yield什么场景下会返回呢","like_count":1,"discussions":[{"author":{"id":1180791,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/77/b0dbd680.jpg","nickname":"Comdotwang","note":"","ucode":"505C65CB8E0B92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":125025,"discussion_content":"这个是不是要看调度系统什么时候调度这个进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578468158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251634,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLqcnUABw0V5MIDSmqbibmVWoTxflia2uApNBj2u8MTbMnYPjv1c9xFBOl1AWAVF20QL2GDQmvMEt7w/132","nickname":"提辖鲁","note":"","ucode":"15637B4B6B5054","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180791,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/77/b0dbd680.jpg","nickname":"Comdotwang","note":"","ucode":"505C65CB8E0B92","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128555,"discussion_content":"不会堵塞在这里，只是把时间片让出去，希望别的线程快点初始化完，执行yield的线程好退出循环","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578650014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":125025,"ip_address":""},"score":128555,"extra":""}]}]},{"had_liked":false,"id":123499,"user_name":"朱小山","can_delete":false,"product_type":"c1","uid":1192101,"ip_address":"","ucode":"AB675896337DE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/u0jDPGD68hsYNxhib3dQib4SibS8kic5FPEy0ib3ZxJuapbPsibNzbUoOufHws9rFOZazl5s4OrSXYHibz89IAZcHWMkA/132","comment_is_top":false,"comment_ctime":1565687405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860654701","product_id":100006701,"comment_content":"ConcurrentHashMap <br>jdk 1.7  采用分段锁实现同步，分段锁的锁粒度较小，一定程度保证了性能。一个HashMap分成若干段segment。每个segment含有若干个桶，每个桶存放K_V形式的链表。当PUT操作时候，先hash得到对应的segment，然后对segment加锁。然后再hash计算要添加的桶，然后遍历链表，更新到节点到桶。SIZE会分两步，先计算每个segment的SIZE，然后再计算所有segment的SIZE。<br>jdk 1.8采用了synchronized和CAS实现，锁粒度更精细，性能更强。虽然代码中保存segment，但是没在使用，使用Volatile保证可见性。size 使用atomic包下的AtomicLong类实现累加计算","like_count":1},{"had_liked":false,"id":13825,"user_name":"bazindes","can_delete":false,"product_type":"c1","uid":1145691,"ip_address":"","ucode":"6B0830ECE27B82","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/5b/907744cf.jpg","comment_is_top":false,"comment_ctime":1530006264,"is_pvip":false,"replies":[{"id":"4645","content":"哈，抱歉，我反馈一下，主播也辛苦，不一定是职业码农","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530116847,"ip_address":"","comment_id":13825,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5824973560","product_id":100006701,"comment_content":"老师的内容讲的丰富 深入浅出 希望提高一下朗读人的要求吧 每节课都感觉有读错的 英文读不准就不说了 互斥读成互拆听的实在是别扭","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419774,"discussion_content":"哈，抱歉，我反馈一下，主播也辛苦，不一定是职业码农","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530116847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11385,"user_name":"宁宁","can_delete":false,"product_type":"c1","uid":1083057,"ip_address":"","ucode":"C6BDF1F05A33EB","user_header":"https://static001.geekbang.org/account/avatar/00/10/86/b1/4b5d3a3b.jpg","comment_is_top":false,"comment_ctime":1528108386,"is_pvip":false,"replies":[{"id":"3671","content":"都是有代价的，取个折衷","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528157538,"ip_address":"","comment_id":11385,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823075682","product_id":100006701,"comment_content":"在构造的时候，Segment 的数量由所谓的 concurrentcyLevel 决定，默认是 16！并发数不是越多越好吗？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418817,"discussion_content":"都是有代价的，取个折衷","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528157538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10431,"user_name":"极客cq","can_delete":false,"product_type":"c1","uid":1128186,"ip_address":"","ucode":"3022A53D58562E","user_header":"","comment_is_top":false,"comment_ctime":1527553746,"is_pvip":false,"replies":[{"id":"3364","content":"有一定道理，但seg和buck范围不完全对等","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527608948,"ip_address":"","comment_id":10431,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5822521042","product_id":100006701,"comment_content":"不从实现上只从图形结构上看，ConcurrentHashMap和HashMap一样，不过是将buckets换成了segment，然后加锁方式从整map，下沉到segment（buckets）上，这样简单理解正确么？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418476,"discussion_content":"有一定道理，但seg和buck范围不完全对等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527608948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10122,"user_name":"cuzz.","can_delete":false,"product_type":"c1","uid":1112592,"ip_address":"","ucode":"671A8D1579D44D","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/10/cefb0e21.jpg","comment_is_top":false,"comment_ctime":1527302815,"is_pvip":false,"replies":[{"id":"3240","content":"请问具体哪个方面？并发工具后面会有专门分析","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527480949,"ip_address":"","comment_id":10122,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5822270111","product_id":100006701,"comment_content":"有点不懂。。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418351,"discussion_content":"请问具体哪个方面？并发工具后面会有专门分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527480949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268844,"user_name":"acqierement","can_delete":false,"product_type":"c1","uid":1234980,"ip_address":"","ucode":"AC8DA74B9CB924","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/24/f48a38f4.jpg","comment_is_top":false,"comment_ctime":1608367957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608367957","product_id":100006701,"comment_content":"只能大概有印象，想要自己消化，我还是要课后看源码才行。","like_count":0},{"had_liked":false,"id":214373,"user_name":"hailowell","can_delete":false,"product_type":"c1","uid":1195572,"ip_address":"","ucode":"557DCAB01710AB","user_header":"","comment_is_top":false,"comment_ctime":1588732750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588732750","product_id":100006701,"comment_content":"ConcurrentHashMap的一个使用场景<br>给资源生成一个动态的id，存储真正的路径。用户访问时可以统一请求一个路径 使用这个动态生成的key访问对应的资源。并发情况下 为了一个资源一段时间内只生成一次，用这个类存储映射关系","like_count":0},{"had_liked":false,"id":198530,"user_name":"Swing","can_delete":false,"product_type":"c1","uid":1330065,"ip_address":"","ucode":"55FCA9ECEFBBEB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","comment_is_top":false,"comment_ctime":1585455372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585455372","product_id":100006701,"comment_content":"这一节的concurrentHashMap的优化进程，需要先对锁以及一些unsafe的东东有比较好的理解才行","like_count":0},{"had_liked":false,"id":185368,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1583568746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583568746","product_id":100006701,"comment_content":"在产品代码中，有没有典型的场景需要使用类似 ConcurrentHashMap 这样的并发容器呢？<br>之前为了配合页面两次操作，需要做临时的缓存，一开始忘记考虑多线程用了HashMap，导致一些问题，后来改为ConcurrentHashMap解决的","like_count":0},{"had_liked":false,"id":181811,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1582637960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582637960","product_id":100006701,"comment_content":"另外jdk7中使用unsafe的getObjectVolatile方法，这跟直接声明volatile变量来访问能有什么不同？感觉都能保证可见性？","like_count":0},{"had_liked":false,"id":181810,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1582637712,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582637712","product_id":100006701,"comment_content":"HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。<br><br>这段话不太理解：哪里用到了不可变对象机制呢？还有 intrinsic 优化是怎么回事？","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336549,"discussion_content":"不可变对象机制 => Node链表静态内部类的属性用final修饰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608623551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149567,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1573276649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573276649","product_id":100006701,"comment_content":"&quot;数据存储利用 volatile 来保证可见性。&quot;<br>JDK1.7里的HashEntry的value也是volatile ,  为何这里的volatile也作为差异项呢?","like_count":0},{"had_liked":false,"id":146501,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1572554849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572554849","product_id":100006701,"comment_content":"分段锁通过更细的控制来提高并发度，获取锁是通过重试机制，也就是轮询一个段能否被写入。","like_count":0},{"had_liked":false,"id":143744,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1571787885,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571787885","product_id":100006701,"comment_content":"线程安全指的是什么？","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384590,"discussion_content":"没有一致性、原子性、有序性问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626671962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139316,"user_name":"毅恒","can_delete":false,"product_type":"c1","uid":1635327,"ip_address":"","ucode":"83667DAFB3389E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aeCJlOUAyLVNLUYDw2soQPjiaXUC9X9CzLTE2qrV8wgNrh22ksnGib9sB2V5oQe1LuxXp9KvvzHG1yvCquEGpRxA/132","comment_is_top":false,"comment_ctime":1570609574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570609574","product_id":100006701,"comment_content":"1.如何保证集合是线程安全的<br>避免多个线程同时访问修改集合，通过加锁来实现。<br>2.ConcurrentHashMap如何实现高效地线程安全<br>ConcurrentHashMap将集合的数据分为一段一段，同时每段上有多个桶，在桶上存储链表。当访问集合时，通过key来计算hash值来找到对应的段，为该段加上锁，同时，另一线程就可以访问其他段的数据，这样就可以实现线程安全，同时也比hashtable高效，允许多个线程同时访问集合。","like_count":0},{"had_liked":false,"id":131010,"user_name":"dylan","can_delete":false,"product_type":"c1","uid":1053737,"ip_address":"","ucode":"8A7F72C64F13CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/29/58e2ca3a.jpg","comment_is_top":false,"comment_ctime":1567598196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567598196","product_id":100006701,"comment_content":"tabAt方法貌似调用的是Unsafe类的getObjectVolatile方法，不知是不是老师笔误","like_count":0},{"had_liked":false,"id":106845,"user_name":"李春恒","can_delete":false,"product_type":"c1","uid":1033066,"ip_address":"","ucode":"F2DCA19EC66DC1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c3/6a/3272e095.jpg","comment_is_top":false,"comment_ctime":1561397430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561397430","product_id":100006701,"comment_content":"谢谢老师。","like_count":0},{"had_liked":false,"id":100495,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1559567121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559567121","product_id":100006701,"comment_content":"这章比较难，源码的精髓部分也比较晦涩难懂，需要之后补上","like_count":0},{"had_liked":false,"id":100343,"user_name":"因缺思厅","can_delete":false,"product_type":"c1","uid":1517365,"ip_address":"","ucode":"2B1D9E9CD8784A","user_header":"https://static001.geekbang.org/account/avatar/00/17/27/35/ba972e11.jpg","comment_is_top":false,"comment_ctime":1559531646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559531646","product_id":100006701,"comment_content":"cas，unsave是基础知识么？","like_count":0},{"had_liked":false,"id":94358,"user_name":"张萌vv","can_delete":false,"product_type":"c1","uid":1300801,"ip_address":"","ucode":"68D8A914564309","user_header":"https://static001.geekbang.org/account/avatar/00/13/d9/41/3b698d03.jpg","comment_is_top":false,"comment_ctime":1557795742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557795742","product_id":100006701,"comment_content":"性能测试小工具，m个线程同时消费存储在concurrenthashmap里的n个资源，调整m，绘制消费完n个资源的性能曲线图","like_count":0},{"had_liked":false,"id":85700,"user_name":"流沙和小胖几","can_delete":false,"product_type":"c1","uid":1170612,"ip_address":"","ucode":"6C74B1F8478465","user_header":"","comment_is_top":false,"comment_ctime":1555206334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555206334","product_id":100006701,"comment_content":"如果一讲的内容有相关联的知识模块，可以在文尾加上关联章节的链接诶，这样更符合我们学习轨迹吧","like_count":0},{"had_liked":false,"id":84633,"user_name":"MIAN-勉","can_delete":false,"product_type":"c1","uid":1123554,"ip_address":"","ucode":"AE938038C2E7D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/24/e2/e5110db5.jpg","comment_is_top":false,"comment_ctime":1554888004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554888004","product_id":100006701,"comment_content":"想问一下老师，使用分段锁实现的ConcurrentHashMap，有没有可能发生死锁","like_count":0},{"had_liked":false,"id":77748,"user_name":"Ellie","can_delete":false,"product_type":"c1","uid":1402056,"ip_address":"","ucode":"DCF2FDD56F8F74","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRmN2LQ0g82HwAGkcgO1mL1Pta4RuAWicoKdWc5cqoDFiarBShF09XElzI7mNNJeEtOl4oCL6K1sibg/132","comment_is_top":false,"comment_ctime":1552991900,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1552991900","product_id":100006701,"comment_content":"分布式系统，使用synchronized还是无法实现同步？","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336553,"discussion_content":"synchronized是jvm级别的锁怎么去锁其他jvm进程的东西呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608623731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74630,"user_name":"刘胜","can_delete":false,"product_type":"c1","uid":1251625,"ip_address":"","ucode":"487374D72543E3","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/29/f9490983.jpg","comment_is_top":false,"comment_ctime":1552269738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552269738","product_id":100006701,"comment_content":"concurrenthashmap用来提高效率的，具体代码看起来还是有点难度的对于我是这样。","like_count":0},{"had_liked":false,"id":54871,"user_name":"Aitozi","can_delete":false,"product_type":"c1","uid":1118091,"ip_address":"","ucode":"B8096312BAD560","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/8b/25d118be.jpg","comment_is_top":false,"comment_ctime":1545973669,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1545973669","product_id":100006701,"comment_content":"现代 JDK 中，synchronized 已经被不断优化，可以不再过分担心性能差异，另外，相比于 ReentrantLock，它可以减少内存消耗，这是个非常大的优势。    为什么这个会有内存消耗的优势呢？","like_count":0,"discussions":[{"author":{"id":1099288,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/18/2a9c0ff6.jpg","nickname":"子非鱼","note":"","ucode":"9D351A6EC8A4B6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557784,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647959619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50021,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1544842559,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1544842559","product_id":100006701,"comment_content":"嗯，我的理解并发工具包中的并发处理类和传统的线程安全容器相比，在于加锁的粒度的更加精细化了，比如：HashTable——全段加锁，ConcurrentHashMap——分段加锁，段内同步，段间异步，通过这种方式来提高性能，不知道其他的并发容器类是否还是通过这种思路来保证线程安全和兼顾性能的提高的。<br>有几点小细节请教一下：<br>1：concurrentcyLevel java需要它是2的幂数值，这是为什么？计算key的桶位吗？<br>2：重复扫描、检测冲突是 ConcurrentHashMap 的常见技巧？这个没明白是什么意思？如果是段内看kay是否冲突，不是所有的Map都有的动作吗？<br>线程安全的保证听的最多的就是加锁的机制了，不过锁这个东西一直没有完全弄明白，他到底是个什么东西？就是一种保证线程安全的机制的简称吗？锁，存在各种各样的，能否通俗的讲解一下，他们都有什么特点？为什么有这么多分类？感觉这些东西好绕，广义上讲CAS是否也是一种锁的实现思路，而不是什么不加锁的同步实现方式？","like_count":0,"discussions":[{"author":{"id":1541386,"avatar":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","nickname":"N_H","note":"","ucode":"109B67557AB3CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2034,"discussion_content":"其实可以取深入的看看操作系统，锁的底层应该类似于把内存隔离起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563192514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43823,"user_name":"萧萧","can_delete":false,"product_type":"c1","uid":1120579,"ip_address":"","ucode":"9F1F69C390576D","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/43/51154077.jpg","comment_is_top":false,"comment_ctime":1543304361,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1543304361","product_id":100006701,"comment_content":"请教老师一下， addCount(1L, binCount) 这个函数中， 有一段代码没有完全理解<br><br> if (sc &lt; 0) {<br>            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||<br>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||<br>                    transferIndex &lt;= 0)<br>                break;<br><br>其中， 有两个条件  sc == rs + 1 ||  sc == rs + MAX_RESIZERS 看起来是用来判断是否已经没有线程在执行扩容 以及  是否并发扩容的线程是否已达上限。 <br><br>但是首个扩容线程进入 transfer 函数之前， 是通过  <br>U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2) <br>操作将 sizeCtl 变成负值的 。 <br><br>按理来说 当 sizeCtl 为负时，  应当使用 sc  ==  ( rs&lt;&lt;&lt;RESIZE_STAMP_SHIFT ) +1 和 <br>sc  ==  ( rs&lt;&lt;&lt;RESIZE_STAMP_SHIFT ) + MAX_RESIZERS 来判断才对<br><br>此处疑似 JDK 的一个 bug , 希望老师可以帮助指点","like_count":0,"discussions":[{"author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207779,"discussion_content":"感觉你这是复制的别人的东西，java中没有 <<< ，不过这段内容没问题，就是一个BUG；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584513777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17595,"user_name":"tim","can_delete":false,"product_type":"c1","uid":1101698,"ip_address":"","ucode":"181FF04B823DBD","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/82/a3ea8076.jpg","comment_is_top":false,"comment_ctime":1532766618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532766618","product_id":100006701,"comment_content":"syncMap 还是有改进的，起码加了synchronized 不会导致扩容死锁","like_count":0},{"had_liked":false,"id":11214,"user_name":"鲲鹏飞九万里","can_delete":false,"product_type":"c1","uid":1093920,"ip_address":"","ucode":"82BD0C789DF612","user_header":"https://static001.geekbang.org/account/avatar/00/10/b1/20/8718252f.jpg","comment_is_top":false,"comment_ctime":1527944142,"is_pvip":false,"replies":[{"id":"3593","content":"嗯...哪几个？回头根据反馈补充下","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527986630,"ip_address":"","comment_id":11214,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527944142","product_id":100006701,"comment_content":"好几个词感觉第一次见，大哭😹","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418756,"discussion_content":"嗯...哪几个？回头根据反馈补充下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527986630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11049,"user_name":"牛在天上飞","can_delete":false,"product_type":"c1","uid":1137660,"ip_address":"","ucode":"972DAF20F085ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/5b/fc/5c24080b.jpg","comment_is_top":false,"comment_ctime":1527814295,"is_pvip":false,"replies":[{"id":"3529","content":"马上就有章节介绍了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527839750,"ip_address":"","comment_id":11049,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527814295","product_id":100006701,"comment_content":"老师能解释下可重入锁吗？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418690,"discussion_content":"马上就有章节介绍了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527839750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10938,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1527749862,"is_pvip":false,"replies":[{"id":"3464","content":"那个是Runtime.availableProcessors","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527761103,"ip_address":"","comment_id":10938,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527749862","product_id":100006701,"comment_content":"杨老师，看到ConcurrentHashMap中有定义N CPU,想问问跟CPU什么关系？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418652,"discussion_content":"那个是Runtime.availableProcessors","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527761103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10710,"user_name":"George","can_delete":false,"product_type":"c1","uid":1103468,"ip_address":"","ucode":"6BD24945AC8253","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/6c/874ca8ad.jpg","comment_is_top":false,"comment_ctime":1527663262,"is_pvip":false,"replies":[{"id":"3423","content":"JDK内部的一个基础类sun.misc.Unsafe，如果公共api能解决的问题，不建议使用它，如果是做底层开发可能会用到","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527695618,"ip_address":"","comment_id":10710,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527663262","product_id":100006701,"comment_content":"文中说的UNSAFE是什么意思？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418572,"discussion_content":"JDK内部的一个基础类sun.misc.Unsafe，如果公共api能解决的问题，不建议使用它，如果是做底层开发可能会用到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527695618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10580,"user_name":"Volong","can_delete":false,"product_type":"c1","uid":1111348,"ip_address":"","ucode":"640C825E92D1A1","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/34/45f022b3.jpg","comment_is_top":false,"comment_ctime":1527603087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527603087","product_id":100006701,"comment_content":"第一个示例代码报这个错：&#39;&lt;&gt;&#39; cannot be used with anonymous classes","like_count":0},{"had_liked":false,"id":10316,"user_name":"Ethan","can_delete":false,"product_type":"c1","uid":1061767,"ip_address":"","ucode":"86F679C62B90AA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epTXXDNFFe90dwTK2s5PxeuYn3MOLvfU6YLQ0uxuf9bXI8dWXgib5LRnOwk1uWiaDHqIGibOKyU4x3CQ/132","comment_is_top":false,"comment_ctime":1527471234,"is_pvip":false,"replies":[{"id":"3243","content":"会有，我也记录下","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527481445,"ip_address":"","comment_id":10316,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527471234","product_id":100006701,"comment_content":"请问老师以后会不会有讲线程中断的不同处理呢？这一块一直对我来讲都比较抽象而且不好测试","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418437,"discussion_content":"会有，我也记录下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527481445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10311,"user_name":"lorancechen","can_delete":false,"product_type":"c1","uid":1114303,"ip_address":"","ucode":"2A16CFA4726AE7","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/bf/a44cde46.jpg","comment_is_top":false,"comment_ctime":1527470038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527470038","product_id":100006701,"comment_content":"rpc调用内部，客户端会记录每次请求的unique id，用于匹配返回的数据应该响应哪个请求。高并发情况下，应该使用concurrenthashmap做这种id到回调的记录。","like_count":0},{"had_liked":false,"id":10270,"user_name":"胖","can_delete":false,"product_type":"c1","uid":1044068,"ip_address":"","ucode":"0EA8F5343CB4F4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/64/2646f6ef.jpg","comment_is_top":false,"comment_ctime":1527432405,"is_pvip":false,"replies":[{"id":"3237","content":"自己做同步当然也是个选择","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527480476,"ip_address":"","comment_id":10270,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527432405","product_id":100006701,"comment_content":"如果多线程中已经在上层代码使用了读写锁进行访问控制，底层集合是否就可以使用HashMap，而没有必要使用线程安全的容器了？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418418,"discussion_content":"自己做同步当然也是个选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527480476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10192,"user_name":"李军","can_delete":false,"product_type":"c1","uid":1046761,"ip_address":"","ucode":"74FE3AF37E74CD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/e9/f25cce9e.jpg","comment_is_top":false,"comment_ctime":1527337328,"is_pvip":true,"replies":[{"id":"3254","content":"需要更具体一些，没有一劳永逸的方法，比如，有用机器学习调优jvm运行参数的；<br>jvm比较运行场景太多，SE既可以跑在嵌入式，也可以到高性能服务器，缩小范围才好进行","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527484857,"ip_address":"","comment_id":10192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527337328","product_id":100006701,"comment_content":"可不可以用AI让JVM更智能？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418385,"discussion_content":"需要更具体一些，没有一劳永逸的方法，比如，有用机器学习调优jvm运行参数的；\njvm比较运行场景太多，SE既可以跑在嵌入式，也可以到高性能服务器，缩小范围才好进行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527484857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10150,"user_name":"Strom","can_delete":false,"product_type":"c1","uid":1122857,"ip_address":"","ucode":"BBB11E924F157E","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/29/b39e8f01.jpg","comment_is_top":false,"comment_ctime":1527309668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527309668","product_id":100006701,"comment_content":"有些本地缓存就是基于它实现的。","like_count":0}]}