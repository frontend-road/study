{"id":252598,"title":"14 | 面向对象之封装：怎样的封装才算是高内聚？","content":"<p>你好！我是郑晔。</p><p>上一讲，我讲了你最熟悉的编程范式：结构化编程。结构化编程有效地解决了过去的很多问题，它让程序员们解决问题的规模得以扩大。</p><p>随着程序规模的逐渐膨胀，结构化编程在解决问题上的局限也越发凸显出来。因为在它提供的解决方案中，各模块的依赖关系太强，不能有效地将变化隔离开来。这时候，面向对象编程登上了大舞台，它为我们提供了更好的组织程序的方式。</p><p>在一些从结构化编程起步的程序员的视角里，面向对象就是数据加函数。虽然这种理解不算完全错误，但理解的程度远远不够。结构化编程的思考方式类似于用显微镜看世界，这种思考方式会让人只能看到局部。而想要用好面向对象编程，则需要我们有一个更宏观的视角。</p><p>谈到面向对象，你可能会想到面向对象的三个特点：封装、继承和多态。在接下来的三讲，我们就分别谈谈面向对象的这三个特点。</p><p>也许你会觉得，学面向对象程序设计语言的时候，这些内容都学过，没什么好讲的。但从我接触过的很多程序员写程序的风格来看，大多数人还真的不太理解这三个特点。还记得我们在<a href=\"https://time.geekbang.org/column/article/248650\">第12讲</a>中提到的那个故事吗？小李之所以被老赵批评，主要就是因为他虽然用了面向对象的语言，代码里却没有体现出面向对象程序的特点，没有封装，更遑论继承和多态。</p><!-- [[[read_end]]] --><p>嘴上说得明明白白，代码写得稀里糊涂，这就是大多数人学习面向对象之后的真实情况。所以，虽然看上去很简单，但还是有必要聊聊这些特点。</p><p>这一讲，我们先从封装说起。</p><h2>理解封装</h2><p>我们知道，面向对象是解决更大规模应用开发的一种尝试，它提升了程序员管理程序的尺度。</p><p><strong>封装，则是面向对象的根基</strong>。它把紧密相关的信息放在一起，形成一个单元。如果这个单元是稳定的，我们就可以把这个单元和其他单元继续组合，构成更大的单元。然后，我们再用这个组合出来的新单元继续构建更大的单元。由此，一层一层地逐步向上。</p><p>为了让你更好地理解这个过程，我们先回到面向对象的最初。“面向对象”这个词是由Alan Kay创造的，他是2003年图灵奖的获得者。在他最初的构想中，对象就是一个细胞。当细胞一点一点组织起来，就可以组成身体的各个器官，再一点一点组织起来，就构成了人体。而当你去观察人的时候，就不用再去考虑每个细胞是怎样的。所以，面向对象给了我们一个更宏观的思考方式。</p><p>但是，这一切的前提是，每个对象都要构建好，也就是封装要做好，这就像每个细胞都有细胞壁将它与外界隔离开来，形成了一个完整的个体。</p><p>在Alan Kay关于面向对象的描述中，他强调对象之间只能通过消息来通信。如果按今天程序设计语言的通常做法，发消息就是方法调用，对象之间就是靠方法调用来通信的。但这个方法调用并不是简单地把对象内部的数据通过方法暴露。在Alan Kay的构想中，他甚至想把数据去掉。</p><p>因为，封装的重点在于对象提供了哪些行为，而不是有哪些数据。也就是说，即便我们把对象理解成数据加函数，数据和函数也不是对等的地位。函数是接口，而数据是内部的实现，正如我们一直说的那样，接口是稳定的，实现是易变的。</p><p>理解了这一点，我们来看一个很多人都有的日常编程习惯。他们编写一个类的方法是，把这个类有哪些字段写出来，然后，生成一大堆getter和setter，将这些字段的访问暴露出去。这种做法的错误就在于把数据当成了设计的核心，这一堆的getter和setter，就等于把实现细节暴露了出去。</p><p>一个正确的做法应该是，我们<strong>设计一个类，先要考虑其对象应该提供哪些行为。然后，我们根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。</strong></p><p>请注意，方法的命名，体现的是你的意图，而不是具体怎么做。所以，<strong>getXXX和setXXX绝对不是一个好的命名</strong>。举个例子，设计一个让用户修改密码的功能，有些人直觉的做法可能是这样：</p><pre><code>class User {\n  private String username;\n  private String password;\n  \n  ...\n  \n  // 修改密码\n  public void setPassword(final String password) {\n    this.password = password;\n  }\n}\n</code></pre><p>但我们鼓励的做法是，把意图表现出来：</p><pre><code>class User {\n  private String username;\n  private String password;\n  \n  ...\n  \n  // 修改密码\n  public void changePassword(final String password) {\n    this.password = password;\n  }\n}\n</code></pre><p>这两段代码相比，只是修改密码的方法名变了，但二者更重要的差异是，一个在说做什么，一个在说怎么做。<strong>将意图与实现分离开来</strong>，这是一个优秀设计必须要考虑的问题。</p><p>不过，在真实的项目中，有时确实需要暴露一些数据，所以，等到你确实需要暴露的时候，再去写getter也不迟，你一定要问问自己为什么要加getter。至于setter，首先，大概率是你用错了名字，应该用一个表示意图的名字；其次，setter通常意味着修改，这是我们不鼓励的。</p><p>我后面讲函数式编程时，会讲到不变性，可变的对象会带来很多的问题，到时候我们再来更具体地讨论。所以，设计中更好的做法是设计不变类。</p><h2>减少暴露接口</h2><p>之所以我们需要封装，就是要构建一个内聚的单元。所以，我们要<strong>减少这个单元对外的暴露</strong>。这句话的第一层含义是减少内部实现细节的暴露，它还有第二层含义，<strong>减少对外暴露的接口</strong>。</p><p>一般面向对象程序设计语言都支持public、private这样的修饰符。程序员在日常开发中，经常会很草率地给一个方法加上public，从而不经意间将一些本来应该是内部实现的部分暴露出去。举个例子，一个服务要停下来的时候，你可能要把一些任务都停下来，代码可能会这样写：</p><pre><code>class Service {\n  public void shutdownTimerTask() {\n    // 停止定时器任务\n  }\n  \n  public void shutdownPollTask() {\n    // 停止轮询服务\n  }\n}\n</code></pre><p>别人调用时，可能会这样调用这段代码：</p><pre><code>class Application {\n  private Service service;\n  \n  public void onShutdown() {\n    service.shutdownTimerTask();\n    service.shutdownPollTask();\n  }\n}\n</code></pre><p>突然有一天，你发现，停止轮询任务必须在停止定时器任务之前，你就不得不要求别人改代码。而这一切就是因为我们很草率地给那两个方法加上了public，让别人有机会看到了这两个方法。</p><p>从设计的角度来说，我们必须谨慎地问一下，这个方法真的有必要暴露出去吗？</p><p>就这个例子而言，我们可以仅仅暴露一个方法：</p><pre><code>class Service {\n  private void shutdownTimerTask() {\n    // 停止定时器任务\n  }\n  \n  private void shutdownPollTask() {\n    // 停止轮询服务\n  }\n  \n  public void shutdown() {\n    this.shutdownTimerTask();\n    this.shutdownPollTask();\n  }\n}\n</code></pre><p>我们调用代码也会简单很多：</p><pre><code>class Application {\n  private Service service;\n  \n  public void onShutdown() {\n    service.shutdown();\n  }\n}\n</code></pre><p>尽可能减少接口暴露，这个原则不仅仅适用于类的设计，同样适用于系统设计。在我的职业生涯中，看到了很多团队非常随意地在系统里面添加接口，一个看似不那么复杂的系统里，随随便便就有成百上千个接口。</p><p>如果你想改造系统去掉一些接口时，很有可能会造成线上故障，因为你根本不知道哪个团队在什么时候用到了它。所以，在软件设计中，暴露接口需要非常谨慎。</p><p>关于这一点，你可以有一个统一的原则：<strong>最小化接口暴露</strong>。也就是，每增加一个接口，你都要找到一个合适的理由。</p><h2>不局限于面向对象的封装</h2><p>虽说封装是面向对象的一个重要特征，但是，当理解了封装之后，你同样可以把它运用于非面向对象的程序设计语言中，把代码写得更具模块性。</p><p>比如，我们知道C语言有头文件（.h 文件）和定义文件（.c 文件），在通常的理解中，头文件放的是各种声明：函数声明、结构体等等。很多C程序员甚至有一个函数就在头文件里加一个声明。</p><p>有了今天对于封装的讲解，再来看C语言的头文件，我们可以让它扮演接口的角色，而定义文件就成了实现。根据今天的内容，既然，接口只有相当于public接口的函数才可以放到头文件里，那么，在头文件里声明一个函数时，我们首先要问的就是，它需要成为一个公开的函数吗？</p><p>C语言没有public和private这样的修饰符，但我曾在一些C的项目上加入了自己的定义：</p><pre><code>#define PUBLIC\n#define PRIVATE static\n</code></pre><p>然后，我们规定头文件里只能放公有接口，而在实现文件中的每个函数前面，加上了PUBLIC和PRIVATE，以示区分。这里将PRIVATE定义成了static，是利用了C语言static函数只能在一个文件中可见的特性。</p><p>我们还可以把一个头文件和一个定义文件合在一起，把它们看成一个类，不允许随意在头文件中声明不相关的函数。比如，下面是我在一个头文件里定义了一个点（Point）：</p><pre><code>struct Point;\nstruct Point* makePoint(double x, double y);\ndouble distance(struct Point* x, struct Point* y);\n</code></pre><p>你可能注意到了，Point这个结构体我只给了声明，没有给定义。因为我并不希望给它的用户访问其字段的权限，结构体的具体定义是实现，应该被隐藏起来。对应的定义文件很简单，就不在这里罗列代码了。</p><p>说到这里，你也许发现了，C语言的封装做得更加彻底。如果用Java或C++ 定义Point类的话，必然会给出具体的字段。从某种程度上来说，Java 和 C++的做法削弱了封装性。</p><p>讲到这里，你应该已经感受到面向对象和结构化编程在思考问题上的一些差异了。有了封装，对象就成了一个个可以组合的单元，也形成了一个个可以复用的单元。面向对象编程的思考方式就是组合这些单元，完成不同的功能。同结构化编程相比，这种思考问题的方式站在了一个更宏观的视角上。</p><h2>总结时刻</h2><p>今天，我们学习了面向对象编程，它是一种以对象为编程元素的编程范式。面向对象有三个特点：封装、继承和多态。</p><p>封装，是面向对象的根基。面向对象编程就是要设计出一个一个可以组合，可以复用的单元。然后，组合这些单元完成不同的功能。</p><p>封装的重点在于对象提供了哪些行为，而不是有哪些数据。即便我们把对象理解成数据加函数，数据和函数也不是对等的地位。函数是接口，应该是稳定的；数据是实现，是易变的，应该隐藏起来。</p><p>设计一个类的方法，先要考虑其对象应该提供哪些行为，然后，根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。getter和setter是暴露实现细节的，尽可能不提供，尤其是setter。</p><p>封装，除了要减少内部实现细节的暴露，还要减少对外接口的暴露。一个原则是最小化接口暴露。有了对封装的理解，即便我们用的是C语言这样非面向对象的语言，也可以按照这个思路把程序写得更具模块性。</p><p>理解了封装，下一讲，我们再来看面向对象另外一个特征：继承。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>基于行为进行封装，不要暴露实现细节，最小化接口暴露。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/c3/5e/c3cbdea561b6751a4c56f928c3d5345e.jpg?wh=2284*1184\" alt=\"\"></p><h2>思考题</h2><p>最后，我想请你了解一下迪米特法则（Law of Demeter），结合今天的课程，分享一下你对迪米特法则的理解。欢迎在留言区分享你的想法。</p><p>感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。</p>","comments":[{"had_liked":false,"id":230231,"user_name":"沧浪之水","can_delete":false,"product_type":"c1","uid":1126491,"ip_address":"","ucode":"3819CB439BFB4C","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/5b/ed3b2211.jpg","comment_is_top":false,"comment_ctime":1593317967,"is_pvip":false,"replies":[{"id":"85194","content":"能分清楚面向对象和 Java 语言，这就是一个很好的区分。<br><br>能分清楚传输数据和业务对象，这就是一个很好的区分。","user_name":"作者回复","comment_id":230231,"uid":"1258861","ip_address":"","utype":1,"ctime":1593481605,"user_name_real":"郑晔"}],"discussion_count":3,"race_medal":0,"score":"164802075215","product_id":100052601,"comment_content":"我平时用java语言开发，java语言的特点就是一切皆对象。我自己的理解是，java中对象的概念跟面向对象中对象的概念是不一样的。前者是语言的特性，后者跟作者说的一样，是一种编程范式。在具体的编码实践中，哪些属于对象，哪些不属于对象，应该是程序员掌控的。比如DDD中的领域实体，就是对象,需要仔细设计其行为接口。 至于平时说的一些POJO的对象，可以看成是数据载体，是可以加getter,setter的（没有这些默认的getter,setter,很多第三方的数据转化都很不方便，比如json，sql等）。在使用的时候，不归结为对象就可以了。 ","like_count":39,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499808,"discussion_content":"能分清楚面向对象和 Java 语言，这就是一个很好的区分。\n\n能分清楚传输数据和业务对象，这就是一个很好的区分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593481605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114149,"avatar":"https://static001.geekbang.org/account/avatar/00/11/00/25/13c8b8b4.jpg","nickname":"小鸣","note":"","ucode":"D005A75ECB0D2E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378028,"discussion_content":"pojo这个确实 😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623024686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288708,"discussion_content":"这个说的非常好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593845786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230267,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1593330892,"is_pvip":true,"replies":[{"id":"85011","content":"关于迪米特法则的回答，很赞！","user_name":"作者回复","comment_id":230267,"uid":"1258861","ip_address":"","utype":1,"ctime":1593339700,"user_name_real":"郑晔"}],"discussion_count":3,"race_medal":1,"score":"87492676812","product_id":100052601,"comment_content":"首先，Demeter 不是一个人，而是一个项目，项目主页 http:&#47;&#47;www.ccs.neu.edu&#47;research&#47;demeter&#47;。最早提到迪米特法则的论文出版于 1989 年，Assuring good style for object-oriented programs。还有一本书，1996 年出版，Adaptive Object-Oriented Software: The Demeter Method with Propagation Patterns。没有看过。<br><br>Demeter 是希腊神话中的大地和丰收女神，也叫做德墨忒尔。<br><br>迪米特法则简单的说，分为两个部分：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。其实如果用另一个名字“最小知识原则”可能更容易理解一些，这个也算是程序员的“黑话”吧。<br><br>虽然接触面向对象编程已经很久了，也知道封装、继承和多态，不过写程序的时候，似乎还是习惯“一个对象一张表”的方式，也没有太多的考虑过封装的问题。整个类里面都是 getter、setter 的事情也做过，有点像是用“面向对象的语言写面向过程的代码”。<br><br>软件设计的大部分原则都耳熟能详，但是如何在写代码的时候“落地”，就不是特别清楚了，缺练。","like_count":21,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499820,"discussion_content":"关于迪米特法则的回答，很赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593339700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2404924,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b2/3c/22028324.jpg","nickname":"呆呆狗的兽","note":"","ucode":"B7D445F3BE2E4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380451,"discussion_content":"你说的一张表一个类那是因为orm元数据映射需要pojo载体，实际在写service时就完全可以面向对象结合结构化了，因为java8支持lambada，所以可以用functioninterface简化很多代码，但核心业务的实现步骤，一般都是从上往下写的，这感觉就像是spring框架的ico容器初始化过程那个refresh方法中的代码一样，这个方法完成了ioc容器的初始化流程，所以直接罗列出来所有的流程所需步骤，中间可加上一些控制语句，这其中的代码是属于一个层级的代码，类似于todo清单，一条一条执行，然后每个方法下又藏了很多很多的代码，但那些代码属于实现了，而且是大量使用继承与接口实现等面向对象方式来组织的\n\n写面向对象代码我认为最重要的是一个业务层级的代码所做的事情应该在一起表述，实现就通常不应该与上层的表述代码放在一起，这也延伸到方法名的重要性，，，以及同代码层级归类","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624507242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2763179,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/29/ab/59a6e437.jpg","nickname":"Kevin","note":"","ucode":"3588850B3370C8","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547066,"discussion_content":"就是现在常规的贫血模型，虽然不太符合封装的原则，但胜在简单门槛低，大行其道还是有其道理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642513532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230081,"user_name":"Being","can_delete":false,"product_type":"c1","uid":1152227,"ip_address":"","ucode":"80A8783927B650","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg","comment_is_top":false,"comment_ctime":1593253185,"is_pvip":false,"replies":[{"id":"84909","content":"很好地分享！","user_name":"作者回复","comment_id":230081,"uid":"1258861","ip_address":"","utype":1,"ctime":1593262298,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"57427828033","product_id":100052601,"comment_content":"“迪米特法则”，印象最深的就是“不要和陌生人说话”。今天学习了本节课程，有了些启示，也可以理解为只和陌生人表达确定性意图。<br>每暴露一个公共API就增加一份职责，所以在每次暴露API时就要问自己，这个职责是自己必要的，还是有可能会增加不必要的负担。","like_count":14,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499756,"discussion_content":"很好地分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593262298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229749,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1593136897,"is_pvip":false,"replies":[{"id":"84771","content":"不矛盾，模型和实现的差别。模型关心能力，实现关心怎么做。如果还不会做，先弄明白怎么做，模型考虑的是如何组织这些元素。","user_name":"作者回复","comment_id":229749,"uid":"1258861","ip_address":"","utype":1,"ctime":1593138775,"user_name_real":"郑晔"}],"discussion_count":2,"race_medal":0,"score":"53132744449","product_id":100052601,"comment_content":"经常听说一句话，程序设计应该关注数据结构，设计好了数据结构，工作就完成了一半。<br><br>今天的封装更偏向能力（方法），内部数据甚至可以去掉。不知道这两个原则是否冲突呢?","like_count":13,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499624,"discussion_content":"不矛盾，模型和实现的差别。模型关心能力，实现关心怎么做。如果还不会做，先弄明白怎么做，模型考虑的是如何组织这些元素。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593138775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000417,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/e1/b7be5560.jpg","nickname":"sam","note":"","ucode":"8D48F4B9045947","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286355,"discussion_content":"封装和接口设计属于模型范畴， 数据结构设计属于实现范畴。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593145059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230191,"user_name":"OlafOO","can_delete":false,"product_type":"c1","uid":1019254,"ip_address":"","ucode":"105F8B194ED37B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/76/994a9929.jpg","comment_is_top":false,"comment_ctime":1593307063,"is_pvip":true,"replies":[{"id":"84994","content":"Lombok很好，可以少写很多代码，但必须限制它的使用，像Data和Setter都是不应该用的。Java Bean本来也不是应该用在所有情况下的技术，太多误用了。","user_name":"作者回复","comment_id":230191,"uid":"1258861","ip_address":"","utype":1,"ctime":1593323908,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"23068143543","product_id":100052601,"comment_content":"好奇老师怎么看待Lombok，所有字段生成getter&#47;setter不是一个好的实践，Java Bean的概念是不是也不该被提倡？","like_count":6,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499797,"discussion_content":"Lombok很好，可以少写很多代码，但必须限制它的使用，像Data和Setter都是不应该用的。Java Bean本来也不是应该用在所有情况下的技术，太多误用了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593323908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229783,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1593144511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18773013695","product_id":100052601,"comment_content":"针对本章<br>1.说封装往往会提到复用。但实际编码后，我认为这个提高复用是个假象。因为如果我不封装，将函数和属性分离，函数的实现依赖入参属性。那么站在调用方角度。是使用领域实体打点空参数方法，还是从实体中拿取属性调一个有参数的接口。在复用这件事上，效果是一样的。<br>2.封装是为了屏蔽实现，属性是实现的一部分。调用方只需要知道自己要做什么。不需要关心实体内部有多少属性，以及属性间的交互。（降低调用方的复杂度，也是松耦合和lod的体现）。<br>3.封装可能会导致类的肿大，在接口隔离上会有矛盾。有时我们需要为实体定义多个接口，不同的调用方调用不同的接口，以实现接口隔离。（至于类内部代码行数过多的问题，我没有什么更好的方法，因为复杂性需要收敛在内部。也只能是加一些分隔线或则构建内部类，尽量去为它分割代码）<br><br>课后题：<br><br>1.lod是一个通用的概念，既可以放在类与类，也可以放在模块和系统。<br><br>2.lod是面向关系的，首先，面向外部要尽量减少一级关联的建立。其次，只与一级关联发生关系。比如，放在代码层面。首先要尽量减少一个类中一级关联的类的数量（实例中属性上注入的其他实例，本地方法中创建的实例，这些都算一级关联。而比如注入的实例打点返回一个新的实例，这就是二级关联）。其次只使用注入的实体，创建的实体和自己本身的方法。（说白点就是不要chain，链试调用，链中节点返回的实体都不一样时）<br><br>3.lod是不稳定的。随着软件的发展，关系是不停在变化的，所以要坚守lod，代码实现，模块划分，系统组合都需要随着变动。（相对来说，接口隔离和单一职责就比较稳定，因为关注的都是自身）<br>","like_count":5},{"had_liked":false,"id":229863,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1593167436,"is_pvip":false,"replies":[{"id":"84910","content":"很好的思考。","user_name":"作者回复","comment_id":229863,"uid":"1258861","ip_address":"","utype":1,"ctime":1593262363,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"14478069324","product_id":100052601,"comment_content":"面向对象的基本原则第一个就是封装<br>日常开发中最常用到的封装莫过于函数了，一个函数实现一个最小的功能单元，<br>然后将各个函数与属性组织起来，就成了类<br>一个类又可视为最小的模块。<br>如何更好暴露接口是编码实践中的技能，时刻要思考着这个接口是否需要暴露以及最小化暴露的接口<br>最近我也在思考项目需要重构模块，我发现重构是一种软件进化，在杂乱的代码中理清逻辑，重新组织结构<br>","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499674,"discussion_content":"很好的思考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593262363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229845,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1593161810,"is_pvip":false,"replies":[{"id":"85077","content":"《代码整洁之道》（Clean Code）第二章讲的都是命名的技巧，你可以去看一下。","user_name":"作者回复","comment_id":229845,"uid":"1258861","ip_address":"","utype":1,"ctime":1593408318,"user_name_real":"郑晔"}],"discussion_count":2,"race_medal":0,"score":"14478063698","product_id":100052601,"comment_content":"老师好，后续的文章能不能说下取方法名&#47;变量 的技巧，","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499666,"discussion_content":"《代码整洁之道》（Clean Code）第二章讲的都是命名的技巧，你可以去看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593408318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021539,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","nickname":"捞鱼的搬砖奇","note":"","ucode":"2FD194C4DA26E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287272,"discussion_content":"好的 谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593410243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260254,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1604970363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10194904955","product_id":100052601,"comment_content":"基于行为进行封装，不要暴露实现细节，最小化接口baolu。","like_count":2},{"had_liked":false,"id":236825,"user_name":"倡印","can_delete":false,"product_type":"c1","uid":1455958,"ip_address":"","ucode":"4F53AA5D017D89","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","comment_is_top":false,"comment_ctime":1595558252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890525548","product_id":100052601,"comment_content":"面相对象的设计基础是抽象，实现基础是封装这样应该更好吧","like_count":1},{"had_liked":false,"id":229823,"user_name":"有学识的兔子","can_delete":false,"product_type":"c1","uid":1628867,"ip_address":"","ucode":"D1D654B1562FC9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","comment_is_top":false,"comment_ctime":1593157260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5888124556","product_id":100052601,"comment_content":"前段时间修改一个模块，我试图将第三方接口进行wrap后产生了新接口以private封装该模块内中。在提交给AR做code review时，他建议去掉从类中去掉新接口，理由也很简单，不属于这个类的行为，给出建议以静态局部函数放在CPP里使用。<br>想来AR给建议还是很中肯的，类对外的行为要尽可能清晰不变；另外，在后续重构中，这些静态局部函数也可以考虑划分到合适的类中，且进行封装。","like_count":1},{"had_liked":false,"id":229752,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1593137687,"is_pvip":false,"replies":[{"id":"84784","content":"注意，这里的关键在于，原来的那两个方法变成了私有的。只对外暴露了一个方法，就是 shutdown。","user_name":"作者回复","comment_id":229752,"uid":"1258861","ip_address":"","utype":1,"ctime":1593154451,"user_name_real":"郑晔"}],"discussion_count":3,"race_medal":0,"score":"5888104983","product_id":100052601,"comment_content":"我对于老师举的shutdown的例子有一个问题 如果按照我的想法 我会把两个shutdown方法都暴露出去 caller自己去组合 所以除非方法的实现需要变更 否则callee是不需要去更改的 但是老师说的是把两个方法封装一下 再暴露出一个封装好的方法 那么就好像老师说的 如果这两个方法需要改变顺序 caller就要改 这怎么理解？","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499626,"discussion_content":"注意，这里的关键在于，原来的那两个方法变成了私有的。只对外暴露了一个方法，就是 shutdown。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593154451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286426,"discussion_content":"嗯嗯 我明白 但是我觉得我们暴露了两个方法让使用方自由组合比我们猜测使用方会这样使用从而提供一个这样的方法 如果使用方觉得不合适我们就要改代码 这样不是很灵活","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593171421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1015222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","nickname":"Michael","note":"","ucode":"27EB4A725CE14E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376133,"discussion_content":"调用方只关心方法的意图，至于方法里面是干两件事还是三件事、顺序如何，调用方并不需要关心。老师说的变更，是提供方觉得要变更。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621989753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286426,"ip_address":""},"score":376133,"extra":""}]}]},{"had_liked":false,"id":229724,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1593130908,"is_pvip":true,"replies":[{"id":"84772","content":"多谢补充！","user_name":"作者回复","comment_id":229724,"uid":"1258861","ip_address":"","utype":1,"ctime":1593138796,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"5888098204","product_id":100052601,"comment_content":"&quot;I made up the term &quot;object-oriented,&quot; and I can tell you I did not have C++ in mind.&quot; --Alan Kay<br><br>&quot;Java and C++ make you think that the new ideas are like the old ones. Java is the most distressing thing to hit computing since MS-DOS.&quot; --Alan Kay","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499611,"discussion_content":"多谢补充！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593138796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345633,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1652445852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652445852","product_id":100052601,"comment_content":"基于行为进行封装，不要暴露实现细节，最小化接口bl。--记下来","like_count":1},{"had_liked":false,"id":319132,"user_name":"Tulane","can_delete":false,"product_type":"c1","uid":1242467,"ip_address":"","ucode":"E1F5108B9E738F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/63/53639bb7.jpg","comment_is_top":false,"comment_ctime":1635605585,"is_pvip":false,"replies":[{"id":"115817","content":"一般序列化框架都有相应的 Annotation，查一下用法就好","user_name":"作者回复","comment_id":319132,"uid":"1258861","ip_address":"","utype":1,"ctime":1635856538,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"1635605585","product_id":100052601,"comment_content":"老师，有些时候会不得不暴露一些get方法或是构造器，比如使用json序列化时，这种有什么好办法解决么","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529512,"discussion_content":"一般序列化框架都有相应的 Annotation，查一下用法就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635856538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299196,"user_name":"呆呆狗的兽","can_delete":false,"product_type":"c1","uid":2404924,"ip_address":"","ucode":"B7D445F3BE2E4C","user_header":"https://static001.geekbang.org/account/avatar/00/24/b2/3c/22028324.jpg","comment_is_top":false,"comment_ctime":1624506544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624506544","product_id":100052601,"comment_content":"迪米特原则，最少知道原则，知道什么？知道具体实现，越少知道具体实现，才能在实现发生变化甚至偷天换地时，不影响到其他调用的任何地方。具体做法就是要依靠程序员来做封装，而封装很多时候都是加入中间层（这个中间层可以是加一个类，也可以是一个方法的委托，也可以是函数式）以达到隔离的目的，我们最常用的做法就是类似于在项目中不直接对三方工具类的引入及防腐层的使用，三方工具类的调用在此场景下就看做是实现，很多时候都可以这样去委托式的做设计，即使内部啥也没做，就调了个方法而已....（计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。------某名言）","like_count":1},{"had_liked":false,"id":254785,"user_name":"Janenesome","can_delete":false,"product_type":"c1","uid":1276572,"ip_address":"","ucode":"15D2673CC31D9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/9c/a4bc748d.jpg","comment_is_top":false,"comment_ctime":1603186718,"is_pvip":false,"replies":[{"id":"100658","content":"知道了问题，才好逐步的改进。更具体的代码问题，可以去看《代码之丑》。","user_name":"作者回复","comment_id":254785,"uid":"1258861","ip_address":"","utype":1,"ctime":1612431866,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"1603186718","product_id":100052601,"comment_content":"意图和实现分离，应该更加关注对象提供哪些行为，起一个好的命名，而不是一股脑的 getter\\setter。<br><br>谨慎暴露接口，日常中对 public 的滥用的确是随处可见的。<br><br>迪米特法则：一个类对自己依赖的类知道的越少越好。类似一个黑盒，我只通过一根绳和你产生联系，至于内部的实现以及面积体积多大等等，这些信息不要暴露出来。","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507511,"discussion_content":"知道了问题，才好逐步的改进。更具体的代码问题，可以去看《代码之丑》。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612431866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}