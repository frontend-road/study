{"id":109564,"title":"27 | 单例模式：如何创建单一对象优化系统性能？","content":"<p>你好，我是刘超。</p><p>从这一讲开始，我们将一起探讨设计模式的性能调优。在《Design Patterns: Elements of Reusable Object-Oriented Software》一书中，有23种设计模式的描述，其中，单例设计模式是最常用的设计模式之一。无论是在开源框架，还是在我们的日常开发中，单例模式几乎无处不在。</p><h2>什么是单例模式？</h2><p>它的核心在于，单例模式可以保证一个类仅创建一个实例，并提供一个访问它的全局访问点。</p><p>该模式有三个基本要点：一是这个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p><p>结合这三点，我们来实现一个简单的单例：</p><pre><code>//饿汉模式\npublic final class Singleton {\n    private static Singleton instance=new Singleton();//自行创建实例\n    private Singleton(){}//构造函数\n    public static Singleton getInstance(){//通过该函数向整个系统提供实例\n        return instance;\n    }\n}\n</code></pre><p>由于在一个系统中，一个类经常会被使用在不同的地方，<span class=\"orange\">通过单例模式，我们可以避免多次创建多个实例，从而节约系统资源。</span></p><h2>饿汉模式</h2><p>我们可以发现，以上第一种实现单例的代码中，使用了static修饰了成员变量instance，所以该变量会在类初始化的过程中被收集进类构造器即&lt;clinit&gt;方法中。在多线程场景下，JVM会保证只有一个线程能执行该类的&lt;clinit&gt;方法，其它线程将会被阻塞等待。</p><p>等到唯一的一次&lt;clinit&gt;方法执行完成，其它线程将不会再执行&lt;clinit&gt;方法，转而执行自己的代码。也就是说，static修饰了成员变量instance，在多线程的情况下能保证只实例化一次。</p><!-- [[[read_end]]] --><p>这种方式实现的单例模式，在类初始化阶段就已经在堆内存中开辟了一块内存，用于存放实例化对象，所以也称为饿汉模式。</p><p>饿汉模式实现的单例的优点是，可以保证多线程情况下实例的唯一性，而且getInstance直接返回唯一实例，性能非常高。</p><p>然而，在类成员变量比较多，或变量比较大的情况下，这种模式可能会在没有使用类对象的情况下，一直占用堆内存。试想下，如果一个第三方开源框架中的类都是基于饿汉模式实现的单例，这将会初始化所有单例类，无疑是灾难性的。</p><h2>懒汉模式</h2><p>懒汉模式就是为了避免直接加载类对象时提前创建对象的一种单例设计模式。该模式使用懒加载方式，只有当系统使用到类对象时，才会将实例加载到堆内存中。通过以下代码，我们可以简单地了解下懒加载的实现方式：</p><pre><code>//懒汉模式\npublic final class Singleton {\n    private static Singleton instance= null;//不实例化\n    private Singleton(){}//构造函数\n    public static Singleton getInstance(){//通过该函数向整个系统提供实例\n        if(null == instance){//当instance为null时，则实例化对象，否则直接返回对象\n            instance = new Singleton();//实例化对象\n        }\n        return instance;//返回已存在的对象\n    }\n}\n</code></pre><p>以上代码在单线程下运行是没有问题的，但要运行在多线程下，就会出现实例化多个类对象的情况。这是怎么回事呢？</p><p>当线程A进入到if判断条件后，开始实例化对象，此时instance依然为null；又有线程B进入到if判断条件中，之后也会通过条件判断，进入到方法里面创建一个实例对象。</p><p>所以我们需要对该方法进行加锁，保证多线程情况下仅创建一个实例。这里我们使用Synchronized同步锁来修饰getInstance方法：</p><pre><code>//懒汉模式 + synchronized同步锁\npublic final class Singleton {\n    private static Singleton instance= null;//不实例化\n    private Singleton(){}//构造函数\n    public static synchronized Singleton getInstance(){//加同步锁，通过该函数向整个系统提供实例\n        if(null == instance){//当instance为null时，则实例化对象，否则直接返回对象\n            instance = new Singleton();//实例化对象\n        }\n        return instance;//返回已存在的对象\n    }\n}\n</code></pre><p>但我们前面讲过，同步锁会增加锁竞争，带来系统性能开销，从而导致系统性能下降，因此这种方式也会降低单例模式的性能。</p><p>还有，每次请求获取类对象时，都会通过getInstance()方法获取，除了第一次为null，其它每次请求基本都是不为null的。在没有加同步锁之前，是因为if判断条件为null时，才导致创建了多个实例。基于以上两点，我们可以考虑将同步锁放在if条件里面，这样就可以减少同步锁资源竞争。</p><pre><code>//懒汉模式 + synchronized同步锁\npublic final class Singleton {\n    private static Singleton instance= null;//不实例化\n    private Singleton(){}//构造函数\n    public static Singleton getInstance(){//加同步锁，通过该函数向整个系统提供实例\n        if(null == instance){//当instance为null时，则实例化对象，否则直接返回对象\n          synchronized (Singleton.class){\n              instance = new Singleton();//实例化对象\n          } \n        }\n        return instance;//返回已存在的对象\n    }\n}\n</code></pre><p>看到这里，你是不是觉得这样就可以了呢？答案是依然会创建多个实例。这是因为当多个线程进入到if判断条件里，虽然有同步锁，但是进入到判断条件里面的线程依然会依次获取到锁创建对象，然后再释放同步锁。所以我们还需要在同步锁里面再加一个判断条件：</p><pre><code>//懒汉模式 + synchronized同步锁 + double-check\npublic final class Singleton {\n    private static Singleton instance= null;//不实例化\n    private Singleton(){}//构造函数\n    public static Singleton getInstance(){//加同步锁，通过该函数向整个系统提供实例\n        if(null == instance){//第一次判断，当instance为null时，则实例化对象，否则直接返回对象\n          synchronized (Singleton.class){//同步锁\n             if(null == instance){//第二次判断\n                instance = new Singleton();//实例化对象\n             }\n          } \n        }\n        return instance;//返回已存在的对象\n    }\n}\n</code></pre><p>以上这种方式，通常被称为Double-Check，它可以大大提高支持多线程的懒汉模式的运行性能。那这样做是不是就能保证万无一失了呢？还会有什么问题吗？</p><p>其实这里又跟Happens-Before规则和重排序扯上关系了，这里我们先来简单了解下Happens-Before规则和重排序。</p><p>我们在第二期<a href=\"https://time.geekbang.org/column/article/105756\">加餐</a>中分享过，编译器为了尽可能地减少寄存器的读取、存储次数，会充分复用寄存器的存储值，比如以下代码，如果没有进行重排序优化，正常的执行顺序是步骤1/2/3，而在编译期间进行了重排序优化之后，执行的步骤有可能就变成了步骤1/3/2，这样就能减少一次寄存器的存取次数。</p><pre><code>int a = 1;//步骤1：加载a变量的内存地址到寄存器中，加载1到寄存器中，CPU通过mov指令把1写入到寄存器指定的内存中\nint b = 2;//步骤2 加载b变量的内存地址到寄存器中，加载2到寄存器中，CPU通过mov指令把2写入到寄存器指定的内存中\na = a + 1;//步骤3 重新加载a变量的内存地址到寄存器中，加载1到寄存器中，CPU通过mov指令把1写入到寄存器指定的内存中\n</code></pre><p>在  JMM  中，重排序是十分重要的一环，特别是在并发编程中。如果JVM可以对它们进行任意排序以提高程序性能，也可能会给并发编程带来一系列的问题。例如，我上面讲到的Double-Check的单例问题，假设类中有其它的属性也需要实例化，这个时候，除了要实例化单例类本身，还需要对其它属性也进行实例化：</p><pre><code>//懒汉模式 + synchronized同步锁 + double-check\npublic final class Singleton {\n    private static Singleton instance= null;//不实例化\n    public List&lt;String&gt; list = null;//list属性\n    private Singleton(){\n      list = new ArrayList&lt;String&gt;();\n    }//构造函数\n    public static Singleton getInstance(){//加同步锁，通过该函数向整个系统提供实例\n        if(null == instance){//第一次判断，当instance为null时，则实例化对象，否则直接返回对象\n          synchronized (Singleton.class){//同步锁\n             if(null == instance){//第二次判断\n                instance = new Singleton();//实例化对象\n             }\n          } \n        }\n        return instance;//返回已存在的对象\n    }\n}\n</code></pre><p>在执行instance = new Singleton();代码时，正常情况下，实例过程这样的：</p><ul>\n<li>给 Singleton 分配内存；</li>\n<li>调用 Singleton 的构造函数来初始化成员变量；</li>\n<li>将 Singleton 对象指向分配的内存空间（执行完这步 singleton 就为非 null 了）。</li>\n</ul><p>如果虚拟机发生了重排序优化，这个时候步骤3可能发生在步骤2之前。如果初始化线程刚好完成步骤3，而步骤2没有进行时，则刚好有另一个线程到了第一次判断，这个时候判断为非null，并返回对象使用，这个时候实际没有完成其它属性的构造，因此使用这个属性就很可能会导致异常。在这里，Synchronized只能保证可见性、原子性，无法保证执行的顺序。</p><p>这个时候，就体现出Happens-Before规则的重要性了。通过字面意思，你可能会误以为是前一个操作发生在后一个操作之前。然而真正的意思是，前一个操作的结果可以被后续的操作获取。这条规则规范了编译器对程序的重排序优化。</p><p>我们知道volatile关键字可以保证线程间变量的可见性，简单地说就是当线程A对变量X进行修改后，在线程A后面执行的其它线程就能看到变量X的变动。除此之外，volatile在JDK1.5之后还有一个作用就是阻止局部重排序的发生，也就是说，volatile变量的操作指令都不会被重排序。所以使用volatile修饰instance之后，Double-Check懒汉单例模式就万无一失了。</p><pre><code>//懒汉模式 + synchronized同步锁 + double-check\npublic final class Singleton {\n    private volatile static Singleton instance= null;//不实例化\n    public List&lt;String&gt; list = null;//list属性\n    private Singleton(){\n      list = new ArrayList&lt;String&gt;();\n    }//构造函数\n    public static Singleton getInstance(){//加同步锁，通过该函数向整个系统提供实例\n        if(null == instance){//第一次判断，当instance为null时，则实例化对象，否则直接返回对象\n          synchronized (Singleton.class){//同步锁\n             if(null == instance){//第二次判断\n                instance = new Singleton();//实例化对象\n             }\n          } \n        }\n        return instance;//返回已存在的对象\n    }\n}\n</code></pre><h2>通过内部类实现</h2><p>以上这种同步锁+Double-Check的实现方式相对来说，复杂且加了同步锁，那有没有稍微简单一点儿的可以实现线程安全的懒加载方式呢？</p><p>我们知道，在饿汉模式中，我们使用了static修饰了成员变量instance，所以该变量会在类初始化的过程中被收集进类构造器即&lt;clinit&gt;方法中。在多线程场景下，JVM会保证只有一个线程能执行该类的&lt;clinit&gt;方法，其它线程将会被阻塞等待。这种方式可以保证内存的可见性、顺序性以及原子性。</p><p>如果我们在Singleton类中创建一个内部类来实现成员变量的初始化，则可以避免多线程下重复创建对象的情况发生。这种方式，只有在第一次调用getInstance()方法时，才会加载InnerSingleton类，而只有在加载InnerSingleton类之后，才会实例化创建对象。具体实现如下：</p><pre><code>//懒汉模式 内部类实现\npublic final class Singleton {\n\tpublic List&lt;String&gt; list = null;// list属性\n\n\tprivate Singleton() {//构造函数\n\t\tlist = new ArrayList&lt;String&gt;();\n\t}\n\n\t// 内部类实现\n\tpublic static class InnerSingleton {\n\t\tprivate static Singleton instance=new Singleton();//自行创建实例\n\t}\n\n\tpublic static Singleton getInstance() {\n\t\treturn InnerSingleton.instance;// 返回内部类中的静态变量\n\t}\n}\n</code></pre><h2>总结</h2><p>单例的实现方式其实有很多，但总结起来就两种：饿汉模式和懒汉模式，我们可以根据自己的需求来做选择。</p><p>如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；如果我们是写一些工具类，则优先考虑使用懒汉模式，因为很多项目可能会引用到jar包，但未必会使用到这个工具类，懒汉模式实现的单例可以避免提前被加载到内存中，占用系统资源。</p><h2>思考题</h2><p><span class=\"orange\">除了以上那些实现单例的方式，你还知道其它实现方式吗？</span></p><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","neighbors":{"left":{"article_title":"26 | 答疑课堂：模块四热点问题解答","id":109201},"right":{"article_title":"28 | 原型模式与享元模式：提升系统性能的利器","id":109980}},"comments":[{"had_liked":false,"id":116444,"user_name":"Loubobooo","can_delete":false,"product_type":"c1","uid":1108306,"ip_address":"","ucode":"7B2543A80EBDEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/52/aa3be800.jpg","comment_is_top":false,"comment_ctime":1563851376,"is_pvip":false,"replies":[{"id":"42694","content":"很赞！这是一种懒加载模式的枚举实现。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563931850,"ip_address":"","comment_id":116444,"utype":1}],"discussion_count":7,"race_medal":0,"score":"229197118064","product_id":100028001,"comment_content":"使用枚举来实现单例模式，具体代码如下：public class SinletonExample5 {<br>    private static SinletonExample5 instance = null;<br><br>    &#47;&#47; 私有构造函数<br>    private SinletonExample5(){<br>    }<br><br>    public static SinletonExample5 getInstance(){<br>        return Sinleton.SINLETON.getInstance();<br>    }<br><br>    private enum Sinleton{<br>        SINLETON;<br><br>        private SinletonExample5 singleton;<br><br>        &#47;&#47; JVM保证这个方法只调用一次<br>        Sinleton(){<br>            singleton = new SinletonExample5();<br>        }<br><br>        public SinletonExample5 getInstance(){<br>            return singleton;<br>        }<br>    }<br>}","like_count":54,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459541,"discussion_content":"很赞！这是一种懒加载模式的枚举实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563931850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386507,"discussion_content":"就是内部类吧，换了个写法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627620874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1038574,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg","nickname":"Only now","note":"","ucode":"C617473A03AE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321778,"discussion_content":"与内部类的实现方案没有本质区别 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604631175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304000,"discussion_content":"和静态内部类异曲同工","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599446821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181960,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/08/f3547e77.jpg","nickname":"lobby","note":"","ucode":"8D81722BE36AD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261658,"discussion_content":"老哥的实现好，安全又延迟加载了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588989627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","nickname":"程序员二师兄","note":"","ucode":"C9E3B5B3358BDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258786,"discussion_content":"pretty good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588728093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47647,"discussion_content":"这种方式已经失去了使用枚举的意义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573385501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116291,"user_name":"豆泥丸","can_delete":false,"product_type":"c1","uid":1186828,"ip_address":"","ucode":"D1638AFD21A224","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/0c/b5b2cd51.jpg","comment_is_top":false,"comment_ctime":1563833490,"is_pvip":false,"replies":[{"id":"42688","content":"对的，我们之前序列化优化这一讲中的问答题就是与枚举实现单例相关，《Effective Java》作者也是强烈推荐枚举方式实现单例。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563930924,"ip_address":"","comment_id":116291,"utype":1}],"discussion_count":4,"race_medal":0,"score":"126117885074","product_id":100028001,"comment_content":"最安全的枚举模式，反射和序列化都是单例。","like_count":30,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459467,"discussion_content":"对的，我们之前序列化优化这一讲中的问答题就是与枚举实现单例相关，《Effective Java》作者也是强烈推荐枚举方式实现单例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563930924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1483912,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL4bZibSxNmZ2Ygpib7N4BWYanDZKWdX2epvXmR4G6ryHN9zsG43wUtoXb1ZtF65icTrz4SWdLiclAuicg/132","nickname":"solzs","note":"","ucode":"E8B7569A359235","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568184,"discussion_content":"枚举单例是饿汉实现,反射会报错,java不允许反射创建枚举类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651074051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304001,"discussion_content":"枚举比静态内部类好在哪里？不是一样的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599446911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1483912,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL4bZibSxNmZ2Ygpib7N4BWYanDZKWdX2epvXmR4G6ryHN9zsG43wUtoXb1ZtF65icTrz4SWdLiclAuicg/132","nickname":"solzs","note":"","ucode":"E8B7569A359235","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568183,"discussion_content":"好在反序列化和反射都是安全的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651073995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304001,"ip_address":""},"score":568183,"extra":""}]}]},{"had_liked":false,"id":116732,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1563896911,"is_pvip":false,"replies":[{"id":"42717","content":"虽然有点绕，还是值得表扬的。我们还是鼓励简单易懂的编程风格。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563933151,"ip_address":"","comment_id":116732,"utype":1}],"discussion_count":6,"race_medal":0,"score":"44513569871","product_id":100028001,"comment_content":"1.可能大部分同学都知道，但为了少部分同学，我在老师这个单例上补个点。其它线程空指针异常确实是指令重排导致的，但其原因还有一个。加锁并不能阻止cpu调度线程执行体，所以时间片还是会切的（假设单核），所以其他线程依旧会执行锁外层的if（），并发情况下就可能拿到仅赋值引用，未在内存空间存储数据的实例（null实例），进而空指针。<br>2.给老师的代码补段骚的：<br>&#47;&#47; 懒汉模式 + synchronized 同步锁 + double-check<br>public final class Singleton {<br>    private static validate Singleton instance = null;&#47;&#47; 不实例化<br>    public List&lt;String&gt; list;&#47;&#47;list 属性<br>    private Singleton(){<br>      list = new ArrayList&lt;String&gt;();<br>    }&#47;&#47; 构造函数<br>    public static Singleton getInstance(){&#47;&#47; 加同步锁，通过该函数向整个系统提供实例<br>        Singleton  temp = instance；<br>        if(null == temp){&#47;&#47; 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象<br>          synchronized （Singleton.class）{&#47;&#47; 同步锁<br>             temp = instance；<br>             if(null == temp){&#47;&#47; 第二次判断<br>                temp = new Singleton();&#47;&#47; 实例化对象<br>                instance = temp；<br>             }<br>          } <br>        }<br>        return instance;&#47;&#47; 返回已存在的对象<br>    }<br>}<br>用临时变量做方法内数据承载（相对于validate修饰的属性，可以减少从内存直接拷贝数据的次数），最后用instance接收临时变量时，因为是validate修饰，所以也不会有指令重排。所以前面临时变量的赋值操作已经完成，这样instance就必然是赋值好的实例。（如有错误请老师指出，仅个人理解的骚操作）<br><br>3.极限编程试试就好，业务代码还是尽量优先保证可读性，只有在有性能需求时再采用影响可读性的性能优化。我的这种骚写法和老师的内部类，这种看起来需要想那么一下的东西尽量避免，简单才是王道。","like_count":11,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459663,"discussion_content":"虽然有点绕，还是值得表扬的。我们还是鼓励简单易懂的编程风格。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563933151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1655960,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/s3l1cvljHFoibnZEHaLl4IJ1ryRFI0zYePAVdYfhfcoyr20uEaf1ibZhMHb5aze8Fuib8FnoYbsC0mnggIeYIjVzg/132","nickname":"午月十三","note":"","ucode":"4383EA1DBE959B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368011,"discussion_content":"这种写法是在jdk1.4及之前的版本面对重排序的提供一种写法吧，因为那时候老的内存模型中，volatile没有禁止重排序的语义，但是可惜的是，在那个年代，这种写法还是没办法完美避免这些问题。最终的解决方案还是新内存模型的volatile禁止重排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618539073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304008,"discussion_content":"volatile 关键字，全部写成validate（校验）也是醉了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599447647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099216,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/d0/cf6bbe55.jpg","nickname":"CALL ME","note":"","ucode":"2A5BE26EAC9716","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301356,"discussion_content":"应该return temp吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598499742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232984,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d0/58/ac40120f.jpg","nickname":"biubiubiu","note":"","ucode":"3310E95533D22B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282066,"discussion_content":"腻害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591878337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47649,"discussion_content":"不错的，spring源码中大量这样的代码，很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573385766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116490,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1563857043,"is_pvip":false,"replies":[{"id":"42697","content":"也可以使用枚举实现懒汉模式，可以根据本讲中的使用内部类方式实现懒加载。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563931998,"ip_address":"","comment_id":116490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40218562707","product_id":100028001,"comment_content":"枚举也是一种单例模式，同时是饿汉式。<br>相比Double Check，以内部类方式实现单例模式，代码简洁，性能相近，在我看来是更优的选择。","like_count":9,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459565,"discussion_content":"也可以使用枚举实现懒汉模式，可以根据本讲中的使用内部类方式实现懒加载。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563931998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116325,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1563841519,"is_pvip":false,"replies":[{"id":"42692","content":"对的，枚举是一种语法糖，在Java编译后，枚举类中的枚举会被声明为static，接下来就跟我们文中讲的一样了。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563931720,"ip_address":"","comment_id":116325,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31628612591","product_id":100028001,"comment_content":"枚举底层实现就是静态内部类吧","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459488,"discussion_content":"对的，枚举是一种语法糖，在Java编译后，枚举类中的枚举会被声明为static，接下来就跟我们文中讲的一样了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563931720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116298,"user_name":"我又不乱来","can_delete":false,"product_type":"c1","uid":1221356,"ip_address":"","ucode":"737405E2339A8D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/ec/205fd50c.jpg","comment_is_top":false,"comment_ctime":1563837282,"is_pvip":false,"replies":[{"id":"42693","content":"Spring中的bean的单例虽然是一种单例效果，但实现方式是通过容器缓存实现，严格来说是一种享元模式。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563931801,"ip_address":"","comment_id":116298,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23038673762","product_id":100028001,"comment_content":"枚举天生就是单例，但是不清楚这么实现。<br>注册式单例，spring应该是用的这种。这个也不太清楚，超哥有机会讲一下spring的实现方式和枚举方式实现的单例。谢谢😁","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459472,"discussion_content":"Spring中的bean的单例虽然是一种单例效果，但实现方式是通过容器缓存实现，严格来说是一种享元模式。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563931801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191011,"user_name":"承香墨影","can_delete":false,"product_type":"c1","uid":1023750,"ip_address":"","ucode":"4D6A4D6E1ED29F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","comment_is_top":false,"comment_ctime":1584717366,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18764586550","product_id":100028001,"comment_content":"老师，您好，有个问题想请教您。<br>我在看极客时间《设计模式之美》专栏中有一篇讲单例的文章，其中讲述了在Java的高版本中，已经不需要增加volatile来禁止类重排序。<br>我自己查了一下没有找到相关的资料，我想请问这个说法有依据吗？如果是这样的，能不能推荐一些文章的链接或者资料我们看一下？<br>----<br>原文如下：<br>要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。","like_count":4,"discussions":[{"author":{"id":1926759,"avatar":"","nickname":"赵玉闯","note":"","ucode":"82E85AC08206EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231889,"discussion_content":"我觉得可以啊，因为这样的话，别的线程在读取实例的成员变量的到时候，遇到了读写锁，是不是这个意思。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586836053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438863,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8f/6b3d4370.jpg","nickname":"瑶老板的小弟","note":"","ucode":"EA6CDB3165227F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309153,"discussion_content":"重排序说一种编译器优化方式，DCL中存在的安全问题是创建实例的时候产生的，如果调用构造器的代码编译后不执行重排序，就不会出现安全问题了。详见《Java并发编程的艺术》 3.8节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601198687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145369,"user_name":"ylw66","can_delete":false,"product_type":"c1","uid":1228185,"ip_address":"","ucode":"3FD0A4937793B7","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/99/851b0db6.jpg","comment_is_top":false,"comment_ctime":1572259063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18752128247","product_id":100028001,"comment_content":"👍，看过的讲singleton最好的文章","like_count":4},{"had_liked":false,"id":143520,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571723931,"is_pvip":false,"replies":[{"id":"56522","content":"这个没法调用的哦，静态方法无法调用非静态成员变量。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1572520595,"ip_address":"","comment_id":143520,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18751593115","product_id":100028001,"comment_content":"如果把这个成员变量的static去掉，在多线程情况下就可能创建多个实例，单线程没问题。老师，这么理解没问题吧？<br><br><br>&#47;&#47; 饿汉模式<br>public final class Singleton {<br>    private  Singleton instance=new Singleton();&#47;&#47; 自行创建实例<br>    private Singleton(){}&#47;&#47; 构造函数<br>    public static Singleton getInstance(){&#47;&#47; 通过该函数向整个系统提供实例<br>        return instance;<br>    }<br>}","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471575,"discussion_content":"这个没法调用的哦，静态方法无法调用非静态成员变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572520595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116547,"user_name":"Zed","can_delete":false,"product_type":"c1","uid":1184951,"ip_address":"","ucode":"09947C76F55A46","user_header":"https://static001.geekbang.org/account/avatar/00/12/14/b7/bb6a1fd4.jpg","comment_is_top":false,"comment_ctime":1563867237,"is_pvip":false,"replies":[{"id":"42700","content":"Spring中bean的单例就是使用容器来实现的，便于管理。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563932086,"ip_address":"","comment_id":116547,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18743736421","product_id":100028001,"comment_content":"容器类管理<br><br>class InstanceManager {<br>    private static Map&lt;String, Object&gt; objectMap = new HashMap&lt;&gt;();<br>    private InstanceManager(){}<br>    public static void registerService(String key,Object instance){<br>        if (!objectMap.containsKey(key)){<br>            objectMap.put(key,instance);<br>        }<br>    }<br>    public static Object getService(String key){<br>        return objectMap.get(key);<br>    }<br>}","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459588,"discussion_content":"Spring中bean的单例就是使用容器来实现的，便于管理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563932086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1083504,"avatar":"https://static001.geekbang.org/account/avatar/00/10/88/70/32534e2d.jpg","nickname":"David Mo","note":"","ucode":"66C30A3CD7EDA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2760,"discussion_content":"感觉这个多现场下会有问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563907801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1216848,"avatar":"https://static001.geekbang.org/account/avatar/00/12/91/50/e576a068.jpg","nickname":"刘天若Warner","note":"","ucode":"032639CD670DA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1083504,"avatar":"https://static001.geekbang.org/account/avatar/00/10/88/70/32534e2d.jpg","nickname":"David Mo","note":"","ucode":"66C30A3CD7EDA6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5257,"discussion_content":"哈哈我也觉得","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566119158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2760,"ip_address":""},"score":5257,"extra":""}]}]},{"had_liked":false,"id":116294,"user_name":"我知道了嗯","can_delete":false,"product_type":"c1","uid":1138471,"ip_address":"","ucode":"9186EC1F32C490","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/27/a6873bc9.jpg","comment_is_top":false,"comment_ctime":1563834944,"is_pvip":false,"replies":[{"id":"42691","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563931395,"ip_address":"","comment_id":116294,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14448736832","product_id":100028001,"comment_content":"枚举实现单例","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459470,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563931395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172989,"user_name":"楊威","can_delete":false,"product_type":"c1","uid":1025474,"ip_address":"","ucode":"8BA77716CE8179","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/c2/41fa26df.jpg","comment_is_top":false,"comment_ctime":1579403615,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5874370911","product_id":100028001,"comment_content":"爱是一道光","like_count":1},{"had_liked":false,"id":132555,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1568165418,"is_pvip":false,"replies":[{"id":"51130","content":"可以通过反序列化对象白名单来控制运行反序列哪些对象，这种方式需要重写resolveClass 方法，具体参考09讲：<br><br>极客时间版权所有: https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;99774","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568538655,"ip_address":"","comment_id":132555,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5863132714","product_id":100028001,"comment_content":"老师。枚举单例可以防止反射攻击、序列化攻击。但是，我们要获取的实例化对象怎么防止暴力反射呢？我现在的做法是在实例化对象的私有构造器中加判断，如果暴力反射，直接抛出运行异常。老师有没有好的办法？百思不得其解","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467006,"discussion_content":"可以通过反序列化对象白名单来控制运行反序列哪些对象，这种方式需要重写resolveClass 方法，具体参考09讲：\n\n极客时间版权所有: https://time.geekbang.org/column/article/99774","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568538655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124349,"user_name":"rong","can_delete":false,"product_type":"c1","uid":1128740,"ip_address":"","ucode":"637A27C532D817","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/24/ab14f6cf.jpg","comment_is_top":false,"comment_ctime":1565864430,"is_pvip":false,"replies":[{"id":"45727","content":"对的，已纠正","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565918541,"ip_address":"","comment_id":124349,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5860831726","product_id":100028001,"comment_content":"大佬，请教个问题，“这种方式实现的单例模式，在类加载阶段就已经在堆内存中开辟了一块内存，用于存放实例化对象，所以也称为饿汉模式。”，   饿汉模式下，类加载阶段，不会执行static代码块和成员变量，初始化阶段的时候才会执行。所以，类加载阶段，不会开辟内存吧？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463128,"discussion_content":"对的，已纠正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565918541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118192,"user_name":"一个卖火柴的老男人","can_delete":false,"product_type":"c1","uid":1181265,"ip_address":"","ucode":"1227638C457F49","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/51/1d24ead6.jpg","comment_is_top":false,"comment_ctime":1564286301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859253597","product_id":100028001,"comment_content":"谢谢超哥分享，写了这么多年代码，也看了不少博客也写了不少博客，今天算是彻底搞懂了，很多时候都是觉得似乎懂了，自己做发现还有点模糊，工作忙反正平时都那么写没深究。get到了很多干活。谢谢🙏","like_count":1},{"had_liked":false,"id":116651,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1563885177,"is_pvip":false,"replies":[{"id":"42701","content":"互相学习，共同进步","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563932142,"ip_address":"","comment_id":116651,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858852473","product_id":100028001,"comment_content":"这一节虽然都懂，但是评论区补充的我还是第一次见到，get到了，有收获，哈哈","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459626,"discussion_content":"互相学习，共同进步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563932142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328226,"user_name":"楞伽山人","can_delete":false,"product_type":"c1","uid":1142335,"ip_address":"","ucode":"5859C06DAC790D","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","comment_is_top":false,"comment_ctime":1640613188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640613188","product_id":100028001,"comment_content":"老师你好 对于这段代码有些不理解的地方 这里是已经加了同步锁 <br> 难道 这里面的第3步会经过指令排序排到同步锁外面去么？ 如果不会那加volatile关键字意义何在？<br> synchronized (Singleton.class){&#47;&#47;同步锁<br>             if(null == instance){&#47;&#47;第二次判断 <br>                instance = new Singleton();&#47;&#47;实例化对象<br>             }<br>          } ","like_count":0},{"had_liked":false,"id":290706,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1619695126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619695126","product_id":100028001,"comment_content":"Singleton 类在加载，连接，初始化时，没涉及到静态变量和静态代码块的执行操作。当调用类的静态方法 getInstance() 时，触发 InnerSingleton 类的加载，连接，初始化流程，InnerSingleton 类的静态变量在准备阶段会被分配内存，并初始化为系统初始值，在初始化阶段，会被收录到 clinit 方法执行初始化为用户指定的值。<br><br>是这样么，老师。谢谢！","like_count":0},{"had_liked":false,"id":284625,"user_name":"FileNotfoundException","can_delete":false,"product_type":"c1","uid":1073951,"ip_address":"","ucode":"6C7731071F7C80","user_header":"https://static001.geekbang.org/account/avatar/00/10/63/1f/c9a783da.jpg","comment_is_top":false,"comment_ctime":1616393436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616393436","product_id":100028001,"comment_content":"public class Ceshi {<br><br><br><br>    public  static Ceshi getinstance(){<br>        return text.INSTANCE.getinstance();<br>    }<br><br><br>    enum text{<br>        &#47;**<br>         *<br>         *&#47;<br>        INSTANCE;<br><br>        private Ceshi ceshi=new Ceshi();<br><br><br>        public   Ceshi getinstance(){<br>            return ceshi;<br>        }<br><br>    }<br><br><br><br>    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {<br>        System.out.println(Ceshi.getinstance());<br>        System.out.println(Ceshi.getinstance());<br>        System.out.println(Ceshi.getinstance()==Ceshi.getinstance());<br>        Class&lt;Ceshi&gt; c = Ceshi.class;<br>        Constructor&lt;Ceshi&gt; declaredConstructor = c.getDeclaredConstructor();<br>        declaredConstructor.setAccessible(true);<br>        Ceshi ceshi1 = declaredConstructor.newInstance();<br>        System.out.println(ceshi1);<br>        System.out.println(Ceshi.getinstance()==ceshi1);<br>    }<br>}<br>我使用枚举去创建单例对象 ,但是反射去调用,还是会出现多个对象,请指教是哪里出现问题了,谢谢<br>===============运行结果==================<br>com.skyedu.live.constant.Ceshi@56f4468b<br>com.skyedu.live.constant.Ceshi@56f4468b<br>true<br>com.skyedu.live.constant.Ceshi@6cc4c815<br>false","like_count":0},{"had_liked":false,"id":254203,"user_name":"缘分注定","can_delete":false,"product_type":"c1","uid":1096361,"ip_address":"","ucode":"21E66B4B68B32C","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/a9/7614d645.jpg","comment_is_top":false,"comment_ctime":1603081947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603081947","product_id":100028001,"comment_content":"设计模式 重点中的重点","like_count":0},{"had_liked":false,"id":252835,"user_name":"宋兵乙","can_delete":false,"product_type":"c1","uid":1213454,"ip_address":"","ucode":"400CF70EC70346","user_header":"https://static001.geekbang.org/account/avatar/00/12/84/0e/2d0ec13b.jpg","comment_is_top":false,"comment_ctime":1602497815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602497815","product_id":100028001,"comment_content":"无论懒汉还是饿汉，构造方法都是private，所以只能通过getInstance方法来做类的初始化，那么懒汉和饿汉的本质都一样了，饿汉也需要第一次调用该方法才会初始化，并不会“事先”占用堆内存。不知道理解的对不？","like_count":0},{"had_liked":false,"id":237353,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1616970,"ip_address":"","ucode":"A5735665E303FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UXuSevhia94o9Eky4OfMuSictaldxcqpjGuvRCOcvjIIoVBAENLEZbv2lgwmwC8icK1ZrUcneNtiaeFBV8MT3uzNg/132","comment_is_top":false,"comment_ctime":1595804795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595804795","product_id":100028001,"comment_content":"然而，在类成员变量比较多，或变量比较大的情况下，这种模式可能会在没有使用类对象的情况下，一直占用堆内存。试想下，如果一个第三方开源框架中的类都是基于饿汉模式实现的单例，这将会初始化所有单例类，无疑是灾难性的。<br><br>老师，类不是在使用时才加载的吗？为什么文中说使用第三方框架会初始化所有单例类？<br><br>期待老师的解答","like_count":0},{"had_liked":false,"id":227185,"user_name":"耿嘉艺","can_delete":false,"product_type":"c1","uid":2023401,"ip_address":"","ucode":"727A22BD41E8AF","user_header":"","comment_is_top":false,"comment_ctime":1592308136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592308136","product_id":100028001,"comment_content":"如果声明为private final static Singleton singleton = new Singleton();也可以运行成功，这个是否正确？<br>还有想问下，这个声明加载顺序时怎样的？","like_count":0},{"had_liked":false,"id":219054,"user_name":"程良","can_delete":false,"product_type":"c1","uid":1829158,"ip_address":"","ucode":"5C83059732EBCB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqjLWFD8dvRgM7lia8YLRH8YrOQtN6MCjLjcib7PnA9XAaRKJae1iaX9Ndqiakc62gu6hrViaxiacBELzibQ/132","comment_is_top":false,"comment_ctime":1589937746,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1589937746","product_id":100028001,"comment_content":"synchronized 加锁之后，虽然重排序了，到锁释放不是也要等都执行完了吗？为什么还需要加volicate关键字呢","like_count":0,"discussions":[{"author":{"id":1138821,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","nickname":"与路同飞","note":"","ucode":"2985F1440A1962","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308097,"discussion_content":"Synchronized锁内部是可以重排的，加了volatile就是防止对instance字段操作进行重排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600845466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138821,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","nickname":"与路同飞","note":"","ucode":"2985F1440A1962","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308096,"discussion_content":"说的就是锁还没释放的情况，instance已经赋值，但是对象还没有初始化好。别的线程访问的时候第一个check判断instance不为空，就返回了一个未初始化好的对象，会有问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600845301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199378,"user_name":"10年以后","can_delete":false,"product_type":"c1","uid":1297421,"ip_address":"","ucode":"FE58CA7E5C2AF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/0d/89435926.jpg","comment_is_top":false,"comment_ctime":1585488008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585488008","product_id":100028001,"comment_content":"单例模型","like_count":0},{"had_liked":false,"id":186564,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1583885168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583885168","product_id":100028001,"comment_content":"实现单例模式，关键是如何保证正确地只创建一次。<br>1.利用JVM自身的单线程保证。static变量在cinit中初始化，枚举类成员的初始化<br>2.利用double check+锁+volatile","like_count":0},{"had_liked":false,"id":163616,"user_name":"某、 ","can_delete":false,"product_type":"c1","uid":1221247,"ip_address":"","ucode":"44360946CCAC8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/7f/cf86eef9.jpg","comment_is_top":false,"comment_ctime":1576755884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576755884","product_id":100028001,"comment_content":"用CAS的方式实现单例模式","like_count":0},{"had_liked":false,"id":133234,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1568455509,"is_pvip":false,"replies":[{"id":"51101","content":"可以忽略，这个属性在这里只是用作重排序的问题","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568532388,"ip_address":"","comment_id":133234,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1568455509","product_id":100028001,"comment_content":"老师，您在内部类实现单例的例子的中。在私有构造方法中，手动new了一个ArrayList集合。在后面的方法中并没有使用这个list，这个list实例是干嘛用的","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467311,"discussion_content":"可以忽略，这个属性在这里只是用作重排序的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568532388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132810,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568245235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568245235","product_id":100028001,"comment_content":"不错，以为自己懂了的东西，其实深挖之后发现还有许多自己从未想到的宝贝。<br>感谢，老师及其他同学的分享!<br>内部类实现的懒汉模式，代码简单性能优越也不存在线程安全问题，值得尝试。","like_count":0},{"had_liked":false,"id":129944,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1567331966,"is_pvip":false,"replies":[{"id":"50246","content":"不行，这里指的是加载时是线程安全的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567827788,"ip_address":"","comment_id":129944,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567331966","product_id":100028001,"comment_content":"老师，赵饿汉模式的写法，java 中static变量可以保证线程安全了？什么情况下可以呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465727,"discussion_content":"不行，这里指的是加载时是线程安全的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567827788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123117,"user_name":"路西法","can_delete":false,"product_type":"c1","uid":1078911,"ip_address":"","ucode":"63169B0823C12A","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/7f/0ab2763d.jpg","comment_is_top":false,"comment_ctime":1565609019,"is_pvip":false,"replies":[{"id":"45277","content":"这里的volatile 是用来防止重排序","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565659728,"ip_address":"","comment_id":123117,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1565609019","product_id":100028001,"comment_content":"&#47;&#47; 懒汉模式 + synchronized 同步锁 + double-check<br>public final class Singleton {<br>    private volatile static Singleton instance= null;&#47;&#47; 不实例化<br>    public List&lt;String&gt; list = null;&#47;&#47;list 属性<br>    private Singleton(){<br>      list = new ArrayList&lt;String&gt;();<br>    }&#47;&#47; 构造函数<br>    public static Singleton getInstance(){&#47;&#47; 加同步锁，通过该函数向整个系统提供实例<br>        if(null == instance){&#47;&#47; 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象<br>          synchronized (Singleton.class){&#47;&#47; 同步锁<br>             if(null == instance){&#47;&#47; 第二次判断<br>                instance = new Singleton();&#47;&#47; 实例化对象<br>             }<br>          } <br>        }<br>        return instance;&#47;&#47; 返回已存在的对象<br>    }<br>}<br><br><br><br>这里不需要加 volatile<br><br>synchronized 遵循 happens before 原则，即 在 synchronized 块里的写，对后续其它线程的读是可见的。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462545,"discussion_content":"这里的volatile 是用来防止重排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565659728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":541956,"discussion_content":"我也是这么理解不需要加的 volatile，如果要加说明老师说的第3步会重排到synchronized修饰的代码块外面去 麻烦老师解答一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640613807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":462545,"ip_address":""},"score":541956,"extra":""}]}]},{"had_liked":false,"id":120527,"user_name":"莫观生","can_delete":false,"product_type":"c1","uid":1276562,"ip_address":"","ucode":"DD7BF63D387A98","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/92/f5339feb.jpg","comment_is_top":false,"comment_ctime":1564923650,"is_pvip":false,"replies":[{"id":"53046","content":"即时编译并非运行多次代码才会触发，java将字节码转为机器码时就是即时编译","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569977783,"ip_address":"","comment_id":120527,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1564923650","product_id":100028001,"comment_content":"超哥，jvm要在代码被执行一定次数之后才会触发即时编译，也就是getInstance方法需要触发多次才会触发即时编译导致指令重排，但是getInstance被执行一次后单例对象就已经被初始化了，理论上是不应该出现指令重排的问题？求解惑","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461373,"discussion_content":"即时编译并非运行多次代码才会触发，java将字节码转为机器码时就是即时编译","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569977783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1412994,"avatar":"https://static001.geekbang.org/account/avatar/00/15/8f/82/374f43a1.jpg","nickname":"假装自己不胖","note":"","ucode":"308F1BAA96CDA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5780,"discussion_content":"指令重排不一定要即时编译才能够触发,解释器编译也能触发呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566464082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119244,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1564542577,"is_pvip":false,"replies":[{"id":"44487","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565056631,"ip_address":"","comment_id":119244,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564542577","product_id":100028001,"comment_content":"老师 ，最后实现的懒汉模式有一个地方不太懂。 在类加载的时候，内部类不会跟着一起加载么？<br><br>我之前以为会将内部类一起加载，开辟一块内存。这样其他地方引用该内部类的时候才可以在解析阶段把符号引用转为地址引用。<br><br>但是看老师的例子，应该是在外部调用内部类的时候才真正去加载","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460803,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565056631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116768,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1563924151,"is_pvip":false,"replies":[{"id":"42703","content":"Spring是通过容器管理来实现单例的，也是基于这三个基本点。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563932207,"ip_address":"","comment_id":116768,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1563924151","product_id":100028001,"comment_content":"老师请问您讲的单例模式三个基本要点, 但是我使用spring的框架并里面默认的类不都是单例的吗,但是并没有满足您说的要点, 用tomcat也是, tomcat里面的servlet应该也是单例的吧, 好像也没有满足您说的三个要点, 请问spring和tomcat是咋实现的, 是数据懒汉还是饿汉的实现方式.","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459677,"discussion_content":"Spring是通过容器管理来实现单例的，也是基于这三个基本点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563932207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304012,"discussion_content":"spring和tomcat 里面所谓单例和多例是应用，不是设计模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599448568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116763,"user_name":"colin","can_delete":false,"product_type":"c1","uid":1292206,"ip_address":"","ucode":"7A8849B8AE33E0","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","comment_is_top":false,"comment_ctime":1563921515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563921515","product_id":100028001,"comment_content":"看评论涨知识","like_count":0},{"had_liked":false,"id":116576,"user_name":"码德纽@宝","can_delete":false,"product_type":"c1","uid":1345546,"ip_address":"","ucode":"FA4088B0DD4EBB","user_header":"https://static001.geekbang.org/account/avatar/00/14/88/0a/31e6d5bb.jpg","comment_is_top":false,"comment_ctime":1563873859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563873859","product_id":100028001,"comment_content":"枚举模式，之外还有CAS方式单例模式","like_count":0},{"had_liked":false,"id":116455,"user_name":"OMT","can_delete":false,"product_type":"c1","uid":1084813,"ip_address":"","ucode":"7EC7311F4A55D9","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/8d/91e9afb0.jpg","comment_is_top":false,"comment_ctime":1563852257,"is_pvip":false,"replies":[{"id":"42696","content":"对的，在第9讲中，我们的问答题也是关于枚举实现单例来解决序列化问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563931919,"ip_address":"","comment_id":116455,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563852257","product_id":100028001,"comment_content":"看过其他文章有分析单例反射和序列化问题。<br>枚举单例可以反编译查看。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459547,"discussion_content":"对的，在第9讲中，我们的问答题也是关于枚举实现单例来解决序列化问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563931919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116360,"user_name":"DebugDog","can_delete":false,"product_type":"c1","uid":1027798,"ip_address":"","ucode":"1664D37CE03B9D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","comment_is_top":false,"comment_ctime":1563843974,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1563843974","product_id":100028001,"comment_content":"枚举单例","like_count":0},{"had_liked":false,"id":116344,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1563842657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563842657","product_id":100028001,"comment_content":"666","like_count":0}]}