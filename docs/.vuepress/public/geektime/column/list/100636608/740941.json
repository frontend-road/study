{"id":740941,"title":"3.1 符号表","content":"\n<p>符号表最主要的目的就是将一个<strong>键</strong>和一个<strong>值</strong>联系起来。用例能够将一个键值对<strong>插入</strong>符号表并希望在之后能够从符号表的所有键值对中按照键直接<strong>找到</strong>相对应的值。本章会讲解多种构造这样的数据结构的方法，它们不光能够高效地<strong>插入</strong>和<strong>查找</strong>，还可以进行其他几种方便的操作。要实现符号表，我们首先要定义其背后的数据结构，并指明创建并操作这种数据结构以实现插入、查找等操作所需的算法。</p>\n<p>查找在大多数应用程序中都至关重要，许多编程环境也因此将符号表实现为高级的抽象数据结构，包括 Java——我们会在 3.5 节中讨论 Java 的符号表实现。表 3.1.1 给出的例子是在一些典型的应用场景中可能出现的键和值。我们马上会看到一些参考性的用例，3.5 节的目的就是向你展示如何在程序中有效地使用符号表。本书中我们还会在其他算法中使用符号表。</p>\n<blockquote>\n<p><strong>定义</strong>。符号表是一种存储键值对的数据结构，支持两种操作：<strong>插入</strong>（put），即将一组新的键值对存入表中；<strong>查找</strong>（get），即根据给定的键得到相应的值。</p>\n</blockquote>\n<p><strong>表 3.1.1　典型的符号表应用</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>应用</p></th>\n<th><p>查找的目的</p></th>\n<th><p>键</p></th>\n<th><p>值</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>字典</p></td>\n<td><p>找出单词的释义</p></td>\n<td><p>单词</p></td>\n<td><p>释义</p></td>\n</tr>\n<tr>\n<td><p>图书索引</p></td>\n<td><p>找出相关的页码</p></td>\n<td><p>术语</p></td>\n<td><p>一串页码</p></td>\n</tr>\n<tr>\n<td><p>文件共享</p></td>\n<td><p>找到歌曲的下载地址</p></td>\n<td><p>歌曲名</p></td>\n<td><p>计算机 ID</p></td>\n</tr>\n<tr>\n<td><p>账户管理</p></td>\n<td><p>处理交易</p></td>\n<td><p>账户号码</p></td>\n<td><p>交易详情</p></td>\n</tr>\n<tr>\n<td><p>网络搜索</p></td>\n<td><p>找出相关网页</p></td>\n<td><p>关键字</p></td>\n<td><p>网页名称</p><!-- [[[read_end]]] --></td>\n</tr>\n<tr>\n<td><p>编译器</p></td>\n<td><p>找出符号的类型和值</p></td>\n<td><p>变量名</p></td>\n<td><p>类型和值</p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_118\">3.1.1　API</h3>\n<p>符号表是一种典型的<strong>抽象数据类型</strong>（请见第 1 章）：它代表着一组定义清晰的值以及相应的操作，使得我们能够将类型的实现和使用区分开来。和以前一样，我们要用应用程序编程接口（API）来精确地定义这些操作（如表 3.1.2 所示），为数据类型的实现和用例提供一份“契约”。</p>\n<p><strong>表 3.1.2　一种简单的泛型符号表 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>&nbsp;public class&nbsp;&nbsp;<b>ST</b>&lt;Key, Value&gt;</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST()</code></td><td>创建一张符号表</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;put(Key key, Value val)</code></td><td>将键值对存入表中（若值为空则将键 <code>key</code> 从表中删除）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value&nbsp;&nbsp;get(Key key)</code></td><td>获取键 <code>key</code> 对应的值（若键 <code>key</code> 不存在则返回 <code>null</code>）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;delete(Key key)</code></td><td>从表中删去键 <code>key</code>（及其对应的值）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;contains(Key key)</code></td><td>键 <code>key</code> 在表中是否有对应的值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;isEmpty()</code></td><td>表是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;size()</code></td><td>表中的键值对数量</td></tr>\n<tr><td><code>Iterable&lt;Key&gt;&nbsp;&nbsp;keys()</code></td><td>表中的所有键的集合</td></tr>\n</table>\n\n<p>在查看用例代码之前，为了保证代码的一致、简洁和实用，我们要先说明具体实现中的几个设计决策。</p>\n<h4>3.1.1.1　泛型</h4>\n<p>和排序一样，在设计方法时我们没有指定处理对象的类型，而是使用了泛型。对于符号表，我们通过明确地指定查找时键和值的类型来区分它们的不同角色，而不是像 2.4 节的优先队列那样将键和元素本身混为一谈。在考虑了这份基本的 API 后（例如，这里没有说明键的有序性），我们会用 <code>Comparable</code> 的对象来扩展典型的用例，这也会为数据类型带来许多新的方法。</p>\n<h4>3.1.1.2　重复的键</h4>\n<p>我们的所有实现都遵循以下规则：</p>\n<ul>\n<li>每个键只对应着一个值（表中不允许存在重复的键）；</li>\n<li>当用例代码向表中存入的键值对和表中已有的键（及关联的值）冲突时，新的值会替代旧的值。</li>\n</ul>\n<p>这些规则定义了<strong>关联数组的抽象形式</strong>。你可以将符号表想象成一个数组，键即索引，值即数组的元素。在一个一般的数组中，键就是整型的索引，我们用它来快速访问数组的内容；在一个关联数组（符号表）中，键可以是任意类型，但我们仍然可以用它来快速访问数组的内容。一些编程语言（非 Java）直接支持程序员使用 <code>st[key]</code> 来代替 <code>st.get(key)</code>，<code>st[key]=val</code> 来代替 <code>st.put(key, val)</code>，其中 <code>key</code>（键）和 <code>val</code>（值）都可以是任意类型的对象。</p>\n<h4>3.1.1.3　空（null）键</h4>\n<p>键不能为空。和 Java 中的许多其他机制一样，使用空键会产生一个运行时异常（请见本节答疑的第三条）。</p>\n<h4>3.1.1.4　空（null）值</h4>\n<p>我们还规定不允许有空值。这个规定的直接原因是在我们的 API 定义中，当键不存在时 <code>get()</code> 方法会返回空，这也意味着任何不在表中的键关联的值都是空。这个规定产生了两个（我们所期望的）结果：第一，我们可以用 <code>get()</code> 方法是否返回空来测试给定的键是否存在于符号表中；第二，我们可以将空值作为 <code>put()</code> 方法的第二个参数存入表中来实现删除，也就是 3.1.1.5 节的主要内容。</p>\n<h4>3.1.1.5　删除操作</h4>\n<p>在符号表中，删除的实现可以有两种方法：<strong>延时</strong>删除，也就是将键对应的值置为空，然后在某个时候删去所有值为空的键；或是<strong>即时</strong>删除，也就是立刻从表中删除指定的键。刚才已经说过，<code>put(key, null)</code> 是 <code>delete(key)</code> 的一种简单的（延时型）实现。而实现（即时型）<code>delete()</code> 就是为了替代这种默认的方案。在我们的符号表实现中不会使用默认的方案，而在本书的网站上 <code>put()</code> 实现的开头有这样一句防御性代码：</p>\n<pre class=\"code-rows\"><code>if (val == null) { delete(key); return; }</code></pre>\n<p>这保证了符号表中任何键的值都不为空。为了节省版面我们没有在本书中附上这段代码（我们也不会在调用 <code>put()</code> 时使用 <code>null</code>）。</p>\n<h4>3.1.1.6　便捷方法</h4>\n<p>为了用例代码的清晰，我们在 API 中加入了 <code>contains()</code> 和 <code>isEmpty()</code> 方法，它们的实现如表 3.1.3 所示，只需要一行。</p>\n<p><strong>表 3.1.3　默认实现</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>方法</p></th>\n<th><p>默认实现</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>void delete(Key key)</code></p></td>\n<td><p><code>put(key, null);</code></p></td>\n</tr>\n<tr>\n<td><p><code>boolean contains(key key)</code></p></td>\n<td><p><code>return get(key) != null;</code></p></td>\n</tr>\n<tr>\n<td><p><code>boolean isEmpty()</code></p></td>\n<td><p><code>return size() == 0;</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>为节省篇幅，我们不想重复这些代码，但我们约定它们存在于所有符号表 API 的实现中，用例程序可以自由使用它们。</p>\n<h4>3.1.1.7　迭代</h4>\n<p>为了方便用例处理表中的所有键值，我们有时会在 API 的第一行加上 <code>implementsIterable&lt;Key&gt;</code> 这句话，强制所有实现都必须包含 <code>iterator()</code> 方法来返回一个实现了 <code>hasNext()</code> 和 <code>next()</code> 方法的迭代器，如 1.3 节的栈和队列所述。但是对于符号表我们采用了一个更简单的方法。我们定义了 <code>keys()</code> 方法来返回一个 <code>Iterable&lt;Key&gt;</code> 对象以方便用例遍历所有的键。这么做是为了和以后的有序符号表的所有方法保持一致，使得用例可以遍历表的键集的一个指定的部分。</p>\n<h4>3.1.1.8　键的等价性</h4>\n<p>要确定一个给定的键是否存在于符号表中，首先要确立<strong>对象等价性</strong>的概念。我们在 1.2.5.8 节深入讨论过这一点。在 Java 中，按照约定所有的对象都继承了一个 <code>equals()</code> 方法，Java 也为它的标准数据类型例如 <code>Integer</code>、<code>Double</code> 和 <code>String</code> 以及一些更加复杂的类型，如 <code>File</code> 和 <code>URL</code>，实现了 <code>equals()</code> 方法——当使用这些数据类型时你可以直接使用内置的实现。例如，如果 x 和 y 都是 <code>String</code> 类型，当且仅当 <code>x</code> 和 <code>y</code> 的长度相同且每个位置上的字母都相同时，<code>x.equals(y)</code> 返回 <code>true</code>。而自定义的键则需要如 1.2 节所述重写 <code>equals()</code> 方法。你可以参考我们为 <code>Date</code> 类型（请见 1.2.5.8 节）实现的 <code>equals()</code> 方法为你自己的数据类型实现 <code>equals()</code> 方法。和 2.4.4.5 节中讨论的优先队列一样，最好使用不可变的数据类型作为键，否则表的一致性是无法保证的。</p>\n<h3 id=\"nav_point_119\">3.1.2　有序符号表</h3>\n<p>典型的应用程序中，键都是 <code>Comparable</code> 的对象，因此可以使用 <code>a.compareTo(b)</code> 来比较 <code>a</code> 和 <code>b</code> 两个键。许多符号表的实现都利用了 <code>Comparable</code> 接口带来的键的有序性来更好地实现 <code>put()</code> 和 <code>get()</code> 方法。更重要的是在这些实现中，我们可以认为<strong>符号表都会保持键的有序</strong>并大大扩展它的 API，根据键的相对位置定义更多实用的操作。例如，假设键是时间，你可能会对最早的或是最晚的键或是给定时间段内的所有键等感兴趣。在大多数情况下用实现 <code>put()</code> 和 <code>get()</code> 方法背后的数据结构都不难实现这些操作。于是，对于 <code>Comparable</code> 的键，在本章中我们实现了表 3.1.4 中的 API。</p>\n<p><strong>表 3.1.4　一种有序的泛型符号表的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>&nbsp;public class <b>ST</b>&lt;Key extends Comparable&lt;key&gt;, Value&gt;</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST()</code></td><td>创建一张有序符号表</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void put(Key key, Value val)</code></td><td>将键值对存入表中（若值为空则将键 <code>key</code> 从表中删除）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value get(Key key)</code></td><td>获取键 <code>key</code> 对应的值（若键 <code>key</code> 不存在则返回空）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void delete(Key key)</code></td><td>从表中删去键 <code>key</code>（及其对应的值）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean contains(Key key)</code></td><td>键 <code>key</code> 是否存在于表中</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean isEmpty()</code></td><td>表是否为空</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size()</code></td><td>表中的键值对数量</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key min()</code></td><td>最小的键</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key max()</code></td><td>最大的键</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key floor(Key key)</code></td><td>小于等于 <code>key</code> 的最大键</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key ceiling(Key key)</code></td><td>大于等于 <code>key</code> 的最小键</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rank(Key key)</code></td><td>小于 <code>key</code> 的键的数量</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key select(int k)</code></td><td>排名为 <code>k</code> 的键</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;deleteMin()</code></td><td>删除最小的键</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;deleteMax()</code></td><td>删除最大的键</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;size(Key lo, Key hi)</code></td><td><code>[lo..hi]</code> 之间键的数量</td></tr>\n<tr><td><code>Iterable&lt;Key&gt;&nbsp;&nbsp;keys(Key lo, Key hi)</code></td><td><code>[lo..hi]</code> 之间的所有键，已排序</td></tr>\n<tr><td><code>Iterable&lt;Key&gt;&nbsp;&nbsp;keys()</code></td><td>表中的所有键的集合，已排序</td></tr>\n</table>\n\n<p>只要你见到类的声明中含有泛型变量 <code>Key extends Comparable&lt;Key&gt;</code>，那就说明这段程序是在实现这份 API，其中的代码依赖于 <code>Comparable</code> 的键并且实现了更加丰富的操作。上面所有这些操作一起为用例定义了一个<strong>有序符号表</strong>。</p>\n<h4>3.1.2.1　最大键和最小键</h4>\n<p>对于一组有序的键，最自然的反应就是查询其中的最大键和最小键。我们在 2.4 节讨论优先队列时已经遇到过这些操作。在有序符号表中，我们也有方法删除最大键和最小键（以及它们所关联的值）。有了这些，符号表就具有了类似于 2.4 节中 <code>IndexMinPQ()</code> 的能力。主要的区别在于优先队列中可以存在重复的键但符号表中不行，而且有序符号表支持的操作更多。</p>\n<h4>3.1.2.2　向下取整和向上取整</h4>\n<p>对于给定的键，<strong>向下取整</strong>（floor）操作（找出小于等于该键的最大键）和<strong>向上取整</strong>（ceiling）操作（找出大于等于该键的最小键）有时是很有用的。这两个术语来自于实数的取整函数（对一个实数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00818.gif\" alt=\"x\" inline-img=\"true\" /> 向下取整即为小于等于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00818.gif\" alt=\"x\" inline-img=\"true\" /> 的最大整数，向上取整则为大于等于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00818.gif\" alt=\"x\" inline-img=\"true\" /> 的最小整数）。</p>\n<h4>3.1.2.3　排名和选择</h4>\n<p>检验一个新的键是否插入合适位置的基本操作是<strong>排名</strong>（rank，找出小于指定键的键的数量）和<strong>选择</strong>（select，找出排名为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 的键）。要测试一下你是否完全理解了它们的作用，请确认对于 0 到 <code>size()-1</code> 的所有 <code>i</code> 都有 <code>i==rank(select(i))</code>，且所有的键都满足 <code>key==select(rank(key))</code>。2.5 节中我们在学习排序时已经遇到过对这两种操作的需求了。对于符号表，我们的挑战是在实现插入、删除和查找的同时快速实现这两种操作。</p>\n<p>有序符号表的操作示例如表 3.1.5 所示。</p>\n<p><strong>表 3.1.5　有序符号表的操作示例</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01271.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<h4>3.1.2.4　范围查找</h4>\n<p>给定范围内（在两个给定的键之间）有多少键？是哪些？在很多应用中能够回答这些问题并接受两个参数的 <code>size()</code> 和 <code>keys()</code> 方法都很有用，特别是在大型数据库中。能够处理这类查询是有序符号表在实践中被广泛应用的重要原因之一。</p>\n<h4>3.1.2.5　例外情况</h4>\n<p>当一个方法需要返回一个键但表中却没有合适的键可以返回时，我们约定抛出一个异常（另一种合理的方法是在这种情况下返回空）。例如，在符号表为空时，<code>min()</code>、<code>max()</code>、<code>deleteMin()</code>、<code>deleteMax()</code>、<code>floor()</code> 和 <code>ceiling()</code> 都会抛出异常，当 <code>k&lt;0</code> 或 <code>k&gt;=size()</code> 时 <code>select(k)</code> 也会抛出异常。</p>\n<h4>3.1.2.6　便捷方法</h4>\n<p>在基础 API 中我们已经见过了 <code>contains()</code> 和 <code>isEmpty()</code> 方法，为了用例的清晰我们又在 API 中添加了一些冗余的方法。为了节约版面，除非特别声明，我们约定所有有序符号表 API 的实现都含有如表 3.1.6 所示的方法。</p>\n<p><strong>表 3.1.6　有序符号表中冗余有序性方法的默认实现</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>方法</p></th>\n<th><p>默认的实现</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>void deleteMin()</code></p></td>\n<td><p><code>delete(min());</code></p></td>\n</tr>\n<tr>\n<td><p><code>void deleteMax()</code></p></td>\n<td><p><code>delete(max());</code></p></td>\n</tr>\n<tr>\n<td><p><code>int size(Key lo, Key hi)</code></p></td>\n<td><p></p><pre>if (hi.compareTo(lo) &lt; 0)<br />   return 0;<br />else if (contains(hi))<br />   return rank(hi) - rank(lo) + 1;<br />else<br />   return rank(hi) - rank(lo);</pre></td>\n</tr>\n<tr>\n<td><p><code>Iterable&lt;Key&gt; keys()</code></p></td>\n<td><p><code>return keys(min(), max());</code></p></td>\n</tr>\n</tbody>\n</table>\n<h4>3.1.2.7　（再谈）键的等价性</h4>\n<p>Java 的一条最佳实践就是维护所有 <code>Comparable</code> 类型中 <code>compareTo()</code> 方法和 <code>equals()</code> 方法的一致性。也就是说，任何一种 <code>Comparable</code> 类型的两个值 <code>a</code> 和 <code>b</code> 都要保证 <code>(a.compareTo(b)==0)</code> 和 <code>a.equals(b)</code> 的返回值相同。为了避免任何潜在的二义性，我们不会在有序符号表的实现中使用 <code>equals()</code> 方法。作为替代，我们只会使用 <code>compareTo()</code> 方法来比较两个键，即我们用布尔表达式 <code>a.compareTo(b)==0</code> 来表示“<code>a</code> 和 <code>b</code> 相等吗？”。一般来说，这样的比较都代表着在符号表中的一次成功查找（找到了 <code>b</code>）。和排序算法一样，Java 为许多经常作为键的数据类型提供了标准的 <code>compareTo()</code> 方法，为你自定义的数据类型实现一个 <code>compareTo()</code> 方法也不困难（参见 2.5 节）。</p>\n<h4>3.1.2.8　成本模型</h4>\n<p>无论我们是使用 <code>equals()</code> 方法（对于符号表的键不是 <code>Comparable</code> 对象而言）还是 <code>compareTo()</code> 方法（对于符号表的键是 <code>Comparable</code> 对象而言），我们使用<strong>比较</strong>一词来表示将一个符号表条目和一个被查找的键进行比较操作。在大多数的符号表实现中，这个操作都出现在内循环。在少数的例外中，我们则会统计数组的访问次数。</p>\n<blockquote>\n<p><strong>查找的成本模型</strong>。在学习符号表的实现时，我们会统计<strong>比较</strong>的次数（等价性测试或是键的相互比较）。在内循环不进行比较（极少）的情况下，我们会统计<strong>数组的访问次数</strong>。</p>\n</blockquote>\n<p>符号表实现的重点在于其中使用的数据结构和 <code>get()</code>、<code>put()</code> 方法。在下文中我们不会总是给出其他方法的实现，因为将它们作为练习能够更好地检验你对实现背后的数据结构的理解程度。为了区别不同的实现，我们在特定的符号表实现的类名前加上了描述性前缀。在用例代码中，除非我们想使用一个特定的实现，我们都会使用 <code>ST</code> 表示一个符号表实现。在本章和其他章节中，经过学习和讨论过大量符号表的使用和实现后你会慢慢地理解这些 API 的设计初衷。同时我们也会在答疑和练习中讨论算法设计时的更多选择。</p>\n<h3 id=\"nav_point_120\">3.1.3　用例举例</h3>\n<p>虽然我们会在 3.5 节中详细说明符号表的更多应用，在学习它的实现之前我们还是应该先看看如何使用它。相应地我们这里考察两个用例：一个用来跟踪算法在小规模输入下的行为测试用例，和一个用来寻找更高效的实现的性能测试用例。</p>\n<h4>3.1.3.1　行为测试用例</h4>\n<p>为了在小规模的输入下跟踪算法的行为，我们用以下测试用例测试我们对符号表的所有实现。这段代码会从标准输入接受多个字符串，构造一张符号表来将 <code>i</code> 和第 <code>i</code> 个字符串相关联，然后打印符号表。在本书中我们假设所有的字符串都只有一个字母。一般我们会使用 <code>\"S E A R C H E X A M P L E\"</code>。按照我们的约定，用例会将键 <code>S</code> 和 <code>0</code>，键 <code>R</code> 和 <code>3</code> 关联起来，等等。但 <code>E</code> 的值是 <code>12</code>（而非 <code>1</code> 或者 <code>6</code>），<code>A</code> 的值为 <code>8</code>（而非 <code>2</code>），因为我们的关联型数组意味着每个键的值取决于最近一次 <code>put()</code> 方法的调用。对于符号表的简单实现（无序），用例的输出中键的顺序是不确定的（这和具体实现有关）；对于有序符号表，用例应该将键按顺序打印出来。这是一种<strong>索引</strong>用例，它是我们将在 3.5 节中讨论的一种重要的符号表应用的一个特殊情况。</p>\n<p>测试用例的实现代码如下所示。测试用例的键、值及输出如图 3.1.1 所示。</p>\n<pre class=\"code-rows\"><code>public static void main(String[] args)\n{\n   ST&lt;String, Integer&gt; st;\n   st = new ST&lt;String, Integer&gt;();\n\n   for (int i = 0; !StdIn.isEmpty(); i++)\n   {\n      String key = StdIn.readString();\n      st.put(key, i);\n   }\n\n   for (String s : st.keys())\n      StdOut.println(s + \" \" + st.get(s));\n}</code></pre>\n<p style=\"text-align: center\">简单的符号表测试用例</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01272.gif\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.1.1　测试用例的键、值和输出</strong></p>\n<h4>3.1.3.2　性能测试用例</h4>\n<p><code>FrequencyCounter</code> 用例会从标准输入中得到的一列字符串并记录每个（长度至少达到指定的阈值）字符串的出现次数，然后遍历所有键并找出出现频率最高的键。这是一种<strong>字典</strong>，我们会在 3.5 节中更加详细地讨论这种应用。这个用例回答了一个简单的问题：哪个（不小于指定长度的）单词在一段文字中出现的频率最高？在本章中，我们会用这个用例以及三段文字来进行性能测试：狄更斯的《双城记》中的前五行（tinyTale.txt），《双城记》全书（tale.txt），以及一个知名的叫做 Leipzig Corpora Collection 的数据库（leipzig1M.txt），内容为一百万条随机从网络上抽取的句子。例如，这是 tinyTale.txt 的内容：</p>\n<pre class=\"code-rows\"><code>% more tinyTale.txt\nit was the best of times it was the worst of times\nit was the age of wisdom it was the age of foolishness\nit was the epoch of belief it was the epoch of incredulity\nit was the season of light it was the season of darkness\nit was the spring of hope it was the winter of despair</code></pre>\n<p style=\"text-align: center\">小型测试输入</p>\n<p>这段文字共有 60 个单词，去掉重复的单词还剩 20 个，其中 4 个出现了 10 次（频率最高）。对于这段文字，<code>FrequencyCounter</code> 可能会打印出 it、was、the 或者 of 中的某一个单词（具体会打印出哪一个取决于符号表的具体实现），以及它出现的频率 10。表 3.1.7 总结了大型测试输入流的性质。</p>\n<p><strong>表 3.1.7　大型测试输入流的性质</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><th rowspan=\"2\"></th><th colspan=\"2\">tinyTale.txt</th><th colspan=\"2\">tale.txt</th><th colspan=\"2\">leipzig1M.txt</th></tr>\n<tr><th>单词数</th><th>不同的单词数</th><th>单词数</th><th>不同的单词数</th><th>单词数</th><th>不同的单词数</th></tr>\n<tr><td>所有单词</td><td>60</td><td>20</td><td>135 635</td><td>10 679</td><td>21 191 455</td><td>534 580</td></tr>\n<tr><td>长度大于等于 8 的单词</td><td>3</td><td>3</td><td>14 350</td><td>5 131</td><td>4 239 597</td><td>299 593</td></tr>\n<tr><td>长度大于等于 10 的单词</td><td>2</td><td>2</td><td>4 582</td><td>2 260</td><td>1 610 829</td><td>165 555</td></tr>\n</table>\n\n<p><code>FrequencyCounter</code> 用例实现过程如下所示。</p>\n<blockquote>\n<p><strong>符号表的用例</strong></p>\n<pre class=\"code-rows\"><code>public class FrequencyCounter\n\n{\n\n   public static void main(String[] args)\n\n   {\n\n      int minlen = Integer.parseInt(args[0]);   // 最小键长\n\n      ST&lt;String, Integer&gt; st = new ST&lt;String, Integer&gt;();\n\n      while (!StdIn.isEmpty())\n\n      {  // 构造符号表并统计频率\n\n         String word = StdIn.readString();\n\n         if (word.length() &lt; minlen) continue;  // 忽略较短的单词\n\n         if (!st.contains(word)) st.put(word, 1);\n\n         else                    st.put(word, st.get(word) + 1);\n\n      }\n\n      // 找出出现频率最高的单词\n\n      String max = \" \";\n\n      st.put(max, 0);\n\n      for (String word : st.keys())\n\n         if (st.get(word) &gt; st.get(max))\n\n            max = word;\n\n      StdOut.println(max + \" \" + st.get(max));\n\n   }\n\n}</code></pre>\n<p>这个符号表的用例统计了标准输入中各个单词的出现频率，然后将频率最高的单词打印出来。命令行参数指定了表中的键的最短长度。</p>\n<pre class=\"code-rows\"><code>% java FrequencyCounter 1 &lt; tinyTale.txt\nit 10\n\n% java FrequencyCounter 8 &lt; tale.txt\nbusiness 122\n\n% java FrequencyCounter 10 &lt; leipzig1M.txt\ngovernment 24763</code></pre>\n</blockquote>\n<p>研究符号表处理大型文本的性能要考虑两个方面的因素：首先，每个单词都会被作为键进行搜索，因此处理性能和输入文本的单词总量必然有关；其次，输入的每个单词都会被存入符号表（输入中不重复单词的总数也就是所有键都被插入以后符号表的大小），因此输入流中不同的单词的总数也是相关的。我们需要这两个量来估计 <code>FrequencyCounter</code> 的运行时间（作为开始，请见练习 3.1.6）。我们会在学习了一些算法之后再回头说明一些细节，但你应该对类似这样的符号表应用的需求有一个大致的印象。例如，用 <code>FrequencyCounter</code> 分析 leipzig1M.txt 中长度不小于 8 的单词意味着，在一个含有数十万键值对的符号表中进行上百万次的查找，而互联网中的一台服务器可能需要在含有上百万个键值对的表中处理上亿的交易。</p>\n<p>这个用例和所有这些例子都提出了一个简单的问题：我们的实现能够在一张用多次 <code>get()</code> 和 <code>put()</code> 方法构造出的巨型符号表中进行大量的 <code>get()</code> 操作吗？如果我们的查找操作不多，那么任意实现都能够满足需要。但没有一个高效的符号表作为基础是无法使用 <code>FrequencyCounter</code> 这样的程序来处理大型问题的。<code>FrequencyCounter</code> 是一种极为常见的应用的代表，它的这些特性也是许多其他符号表应用的共性：</p>\n<ul>\n<li>混合使用查找和插入的操作；</li>\n<li>大量的不同键；</li>\n<li>查找操作比插入操作多得多；</li>\n<li>虽然不可预测，但查找和插入操作的使用模式并非随机。</li>\n</ul>\n<p>我们的目标就是实现一种符号表来满足这些能够解决典型的实际问题的用例的需要。</p>\n<p>下面，我们将会学习两种初级的符号表实现并通过 <code>FrequencyCounter</code> 分别评估它们的性能。在之后的几节中，你会学习一些经典的实现，即使对于庞大的输入和符号表它们的性能仍然非常优秀。</p>\n<h3 id=\"nav_point_121\">3.1.4　无序链表中的顺序查找</h3>\n<p>符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对，如算法 3.1 中的代码所示。<code>get()</code> 的实现即为遍历链表，用 <code>equals()</code> 方法比较需被查找的键和每个结点中的键。如果匹配成功我们就返回相应的值，否则我们返回 <code>null</code>。<code>put()</code> 的实现也是遍历链表，用 <code>equals()</code> 方法比较需被查找的键和每个结点中的键。如果匹配成功我们就用第二个参数指定的值更新和该键相关联的值，否则我们就用给定的键值对创建一个新的结点并将其插入到链表的开头。这种方法也被称为<strong>顺序查找</strong>：在查找中我们一个一个地顺序遍历符号表中的所有键并使用 <code>equals()</code> 方法来寻找与被查找的键匹配的键。</p>\n<p>算法 3.1（<code>SequentialSearchST</code>）用链表实现了符号表的基本 API，我们在第 1 章中的基础数据结构中学习过它。这里我们将 <code>size()</code>、<code>keys()</code> 和即时型的 <code>delete()</code> 方法留做练习。这些练习能够巩固并加深你对链表和符号表的基本 API 的理解。</p>\n<p>这种基于链表的实现能够用于和我们的用例类似的、需要大型符号表的应用吗？我们已经说过，分析符号表算法比分析排序算法更困难，因为不同的用例所进行的操作序列各不相同。对于 <code>FrequencyCounter</code>，最常见的情形是虽然查找和插入的使用模式是不可预测的，但它们的使用肯定不是随机的。因此我们主要研究最坏情况下的性能。为了方便，我们使用<strong>命中</strong>表示一次成功的查找，<strong>未命中</strong>表示一次失败的查找。使用基于链表的符号表的索引用例的轨迹如图 3.1.2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01273.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.1.2　使用基于链表的符号表的索引用例的轨迹</strong></p>\n<blockquote>\n<p><strong>算法 3.1　顺序查找（基于无序链表）</strong></p>\n<pre class=\"code-rows\"><code>public class SequentialSearchST&lt;Key, Value&gt;\n\n{\n\n   private Node first;        // 链表首结点\n\n   private class Node\n\n   {  // 链表结点的定义\n\n      Key key;\n\n      Value val;\n\n      Node next;\n\n      public Node(Key key, Value val, Node next)\n\n      {\n\n         this.key  = key;\n\n         this.val  = val;\n\n         this.next = next;\n\n      }\n\n   }\n\n   public Value get(Key key)\n\n   {  // 查找给定的键，返回相关联的值\n\n      for (Node x = first; x != null; x = x.next)\n\n         if (key.equals(x.key))\n\n            return x.val;    // 命中\n\n      return null;           // 未名中\n\n   }\n\n   public void put(Key key, Value val)\n\n   {  // 查找给定的键，找到则更新其值，否则在表中新建结点\n\n      for (Node x = first; x != null; x = x.next)\n\n         if (key.equals(x.key))\n\n         {  x.val = val; return;  }      // 命中，更新\n\n      first = new Node(key, val, first); // 未命中，新建结点\n\n   }\n\n}</code></pre>\n<p>符号表的实现使用了一个私有内部 <code>Node</code> 类来在链表中保存键和值。<code>get()</code> 的实现会顺序地搜索链表查找给定的键（找到则返回相关联的值）。<code>put()</code> 的实现也会顺序地搜索链表查找给定的键，如果找到则更新相关联的值，否则它会用给定的键值对创建一个新的结点并将其插入到链表的开头。<code>size()</code>、<code>keys()</code> 和即时型的 <code>delete()</code> 方法的实现留做练习。</p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>命题 A</strong>。在含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 次比较。命中的查找在最坏情况下需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 次比较。特别地，向一个空表中插入 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个不同的键需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00911.gif\" alt=\"\\sim N^2/2\" inline-img=\"true\" /> 次比较。</p>\n<p><strong>证明</strong>。在表中查找一个不存在的键时，我们会将表中的每个键和给定的键比较。因为不允许出现重复的键，每次插入操作之前我们都需要这样查找一遍。</p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>推论</strong>。向一个空表中插入 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个不同的键需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00911.gif\" alt=\"\\sim N^2/2\" inline-img=\"true\" /> 次比较。</p>\n</blockquote>\n<p>查找一个已经存在的键并不需要线性级别的时间。一种度量方法是查找表中的每个键，并将总时间除以 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />。在查找表中的每个键的可能性都相同的情况下时，这个结果就是一次查找平均所需的比较数。我们将它称为<strong>随机命中</strong>。尽管符号表用例的查找模式不太可能是随机的，这个模型也总能适应得很好。我们很容易就可以得到随机命中所需的平均比较次数为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01274.gif\" alt=\"\\sim N/2\" inline-img=\"true\" />：算法 3.1 中的 <code>get()</code> 方法查找第一个键需要 1 次比较，查找第二个键需要 2 次比较，如此这般，平均比较次数为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01275.gif\" alt=\"(1+2+\\cdots+N)/N=(N+1)/2\\sim N/2\" inline-img=\"true\" />。</p>\n<p>这些分析完全证明了基于链表的实现以及顺序查找是非常低效的，无法满足 <code>FrequencyCounter</code> 处理庞大输入问题的需求。比较的总次数和查找次数与插入次数的乘积成正比。对于《双城记》这个数字大于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01092.gif\" alt=\"10^9\" inline-img=\"true\" />，而对于 Leipzig Corpora 数据库这个数字大于 10<sup>14</sup>。</p>\n<p>按照惯例，为了验证分析结果我们需要进行一些实验。这里我们用 <code>FrequencyCounter</code> 以及命令行参数 8 来分析 tale.txt。这将需要 14 350 次 <code>put()</code>（已经说过，输入中的每个单词都需要一次 <code>put()</code> 操作来更新它的出现频率，<code>contains()</code> 方法的调用是可以避免的，这里忽略了它的成本）。符号表将包含 5737 个键，也就是说大约三分之一的操作都将表增大了，其余操作为查找。为了将性能可视化我们使用了 <code>VisualAccumulator</code>（请见表 1.2.14）将每次 <code>put()</code> 操作转换为两个点：对于第 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01071.gif\" alt=\"i\" inline-img=\"true\" /> 次 <code>put()</code> 操作，我们会在横坐标为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01071.gif\" alt=\"i\" inline-img=\"true\" />，纵坐标为该次操作所进行的比较次数的位置画一个灰点，以及横坐标为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01071.gif\" alt=\"i\" inline-img=\"true\" />，纵坐标为前 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01071.gif\" alt=\"i\" inline-img=\"true\" /> 次 <code>put()</code> 操作累计所需的平均比较次数的位置画一个黑点，如图 3.1.3 所示。和所有科学实验数据一样，这其中包含了很多信息供我们研究（这张图含有 14 350 个灰点和 14 350 个黑点）。这里，我们的主要兴趣在于这张表证实了我们关于 <code>put()</code> 平均需要访问半条链表的猜想。虽然实际的数据比一半稍少，但对这个事实（以及图表曲线的形状）最好的解释应该是应用的特性，而非算法（请见练习 3.1.36）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01276.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.1.3　使用 <code>SequentialSearchST</code>，运行 <code>java FrequencyCounter 8 &lt; tale.txt</code> 的成本</strong></p>\n<p>尽管某个具体用例的性能特点可能是复杂的，但只要使用我们准备的文本或者随机有序输入以及我们在第 1 章中介绍的 DoublingTest 程序，我们还是能够轻松估计出 <code>FrequencyCounter</code> 的性能并测试验证的。我们将这些测试留给练习和接下来将要学习的更加复杂的实现。如果你并不觉得我们需要更快的实现，请一定完成这些练习！（或者用 <code>FrequencyCounter</code> 调用 <code>SequentialSearchST</code> 来处理 leipzig1M.txt ！）</p>\n<h3 id=\"nav_point_122\">3.1.5　有序数组中的二分查找</h3>\n<p>下面我们要学习有序符号表 API 的完整实现。它使用的数据结构是一对平行的数组，一个存储键一个存储值。算法 3.2（<code>BinarySearchST</code>）可以保证数组中 <code>Comparable</code> 类型的键有序，然后使用数组的索引来高效地实现 <code>get()</code> 和其他操作。</p>\n<p>这份实现的核心是 <code>rank()</code> 方法，它返回表中小于给定键的键的数量。对于 <code>get()</code> 方法，只要给定的键存在于表中，<code>rank()</code> 方法就能够精确地告诉我们在哪里能够找到它（如果找不到，那它肯定就<strong>不在</strong>表中了）。</p>\n<p>对于 <code>put()</code> 方法，只要给定的键存在于表中，<code>rank()</code> 方法就能够精确地告诉我们到哪里去更新它的值，以及当键不在表中时将键存储到表的何处。我们将所有更大的键向后移动一格来腾出位置（从后向前移动）并将给定的键值对分别插入到各自数组中的合适位置。结合我们测试用例的轨迹来研究 <code>BinarySearchST</code> 也是学习这种数据结构的好方法。</p>\n<p>这段代码为键和值使用了两个数组（另一种方式请见练习 3.1.12）。和我们在第 1 章中对泛型的栈和队列的实现一样，这段代码也需要创建一个 <code>Key</code> 类型的 <code>Comparable</code> 对象的数组和一个 <code>Value</code> 类型的 <code>Object</code> 对象的数组，并在构造函数中将它们转化回 <code>Key[]</code> 和 <code>Value[]</code>。和以前一样，我们可以动态调整数组，使得用例无需担心数组大小（请注意，你会发现这种方法对于大数组实在是太慢了）。</p>\n<p>使用基于有序数组的符号表实现的索引用例的轨迹如表 3.1.8 所示。</p>\n<p><strong>表 3.1.8　使用基于有序数组的符号表实现的索引用例的轨迹</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01277.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<blockquote>\n<p><strong>算法 3.2　二分查找（基于有序数组）</strong></p>\n<pre class=\"code-rows\"><code>public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;, Value&gt;\n{\n   private Key[] keys;\n   private Value[] vals;\n   private int N;\n   public BinarySearchST(int capacity)\n   {   // 调整数组大小的标准代码请见算法1.1\n       keys = (Key[]) new Comparable[capacity];\n       vals = (Value[]) new Object[capacity];\n   }\n   public int size()\n   {  return N;  }\n   public Value get(Key key)\n   {\n      if (isEmpty()) return null;\n      int i = rank(key);\n      if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) return vals[i];\n      else                                      return null;\n   }\n\n   public int rank(Key key)\n   // 请见算法3.2（续1）\n\n   public void put(Key key, Value val)\n   {  // 查找键，找到则更新值，否则创建新的元素\n      int i = rank(key);\n      if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0)\n      {  vals[i] = val; return;  }\n      for (int j = N; j &gt; i; j--)\n      {  keys[j] = keys[j-1]; vals[j] = vals[j-1];  }\n      keys[i] = key; vals[i] = val;\n      N++;\n   }\n\n   public void delete(Key key)\n   // 该方法的实现请见练习3.1.16\n}</code></pre>\n<p>这段符号表的实现用两个数组来保存键和值。和 1.3 节中基于数组的栈一样，<code>put()</code> 方法会在插入新元素前将所有较大的键向后移动一格。这里省略了调整数组大小部分的代码。</p>\n</blockquote>\n<h4>3.1.5.1　二分查找</h4>\n<p>我们使用有序数组存储键的原因是，第 1 章中作为例子出现的经典二分查找法能够根据数组的索引大大减少每次查找所需的比较次数。我们会使用有序索引数组来标识被查找的键可能存在的子数组的大小范围。在查找时，我们先将被查找的键和子数组的中间键比较。如果被查找的键小于中间键，我们就在左子数组中继续查找，如果大于我们就在右子数组中继续查找，否则中间键就是我们要找的键。算法 3.2（续 1）中实现 <code>rank()</code> 方法的代码使用了刚才讨论的二分查找法。这个实现值得我们仔细研究。作为开始，我们来看看这段等价的递归代码。</p>\n<pre class=\"code-rows\"><code>public int rank(Key key, int lo, int hi)\n{\n   if (hi &lt; lo) return lo;\n   int mid = lo + (hi - lo) / 2;\n   int cmp = key.compareTo(keys[mid]);\n   if     (cmp &lt; 0)\n        return rank(key, lo, mid-1);\n   else if (cmp &gt; 0)\n        return rank(key, mid+1, hi);\n   else return mid;\n}</code></pre>\n<p style=\"text-align: center\">递归的二分查找</p>\n<p>调用这里的 <code>rank(key, 0, N-1)</code> 所进行的比较和调用算法 3.2（续 1）的实现所进行的比较完全相同。但如 1.1 节中讨论的，这个版本更好地暴露了算法的结构。递归的 <code>rank()</code> 保留了以下性质：</p>\n<ul>\n<li>如果表中存在该键，<code>rank()</code> 应该返回该键的位置，也就是表中小于它的键的数量；</li>\n<li>如果表中不存在该键，<code>rank()</code> <strong>还是</strong>应该返回表中小于它的键的数量。</li>\n</ul>\n<p>好好想想算法 3.2（续 1）中非递归的 <code>rank()</code> 为什么能够做到这些（你可以证明两个版本的等价性，或者直接证明非递归版本中的循环在结束时 <code>lo</code> 的值正好等于表中小于被查找的键的键的数量），所有程序员都能从这些思考中有所收获。（<strong>提示</strong>：<code>lo</code> 的初始值为 <code>0</code>，且永远不会变小）</p>\n<blockquote>\n<p><strong>算法 3.2（续 1）基于有序数组的二分查找（迭代）</strong></p>\n<pre class=\"code-rows\"><code>public int rank(Key key)\n{\n   int lo = 0, hi = N-1;\n   while (lo &lt;= hi)\n   {\n      int mid = lo + (hi - lo) / 2;\n      int cmp = key.compareTo(keys[mid]);\n      if      (cmp &lt; 0) hi = mid - 1;\n      else if (cmp &gt; 0) lo = mid + 1;\n      else return mid;\n   }\n   return lo;\n}</code></pre>\n<p>该方法实现了正文所述的经典算法来计算小于给定键的键的数量。它首先将 <code>key</code> 和中间键比较，如果相等则返回其索引；如果小于中间键则在左半部分查找；大于则在右半部分查找。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01278.gif\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p style=\"text-align: center\"><strong>在有序数组中使用二分法查找排名的轨迹</strong></p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>算法 3.2（续 2）基于二分查找的有序符号表的其他操作</strong></p>\n<pre class=\"code-rows\"><code>public Key min()\n{  return keys[0];  }\n\npublic Key max()\n{  return keys[N-1];  }\n\npublic Key select(int k)\n{  return keys[k];  }\n\npublic Key ceiling(Key key)\n{\n   int i = rank(key);\n   return keys[i];\n}\n\npublic Key floor(Key key)\n// 请见练习3.1.17\n\npublic Key delete(Key key)\n// 请见练习3.1.16\n\npublic Iterable&lt;Key&gt; keys(Key lo, Key hi)\n{\n   Queue&lt;Key&gt; q = new Queue&lt;Key&gt;();\n   for (int i = rank(lo); i &lt; rank(hi); i++)\n      q.enqueue(keys[i]);\n   if (contains(hi))\n      q.enqueue(keys[rank(hi)]);\n   return q;\n}</code></pre>\n<p>这些方法，以及练习 3.1.16 和练习 3.1.17，组成了我们对使用二分查找的有序符号表的完整实现。<code>min()</code>、<code>max()</code> 和 <code>select()</code> 方法都很简单，只需按照给定的位置从数组中返回相应的值即可。<code>rank()</code> 方法实现了二分查找，是其他方法的基石。<code>floor()</code> 和 <code>delete()</code> 方法虽然也不难，但稍微复杂一些，在此留做练习。</p>\n</blockquote>\n<h4>3.1.5.2　其他操作</h4>\n<p>因为键被保存在有序数组中，算法 3.2（续 2）中和顺序有关的大多数操作都一目了然。例如，调用 <code>select(k)</code> 就相当于返回 <code>keys[k]</code>。我们将 <code>delete()</code> 和 <code>floor()</code> 留做练习。你应该研究一下 <code>ceiling()</code> 和带两个参数的 <code>keys()</code> 方法的实现，并完成练习来巩固和加深你对有序符号表的 API 及其实现的理解。</p>\n<h3 id=\"nav_point_123\">3.1.6　对二分查找的分析</h3>\n<p><code>rank()</code> 的递归实现还能够让我们立即得到一个结论：二分查找很快，因为递归关系可以说明算法所需比较次数的上界。</p>\n<blockquote>\n<p><strong>命题 B</strong>。在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个键的有序数组中进行二分查找最多需要（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00913.gif\" alt=\"\\lg N+1\" inline-img=\"true\" />）次比较（无论是否成功）。</p>\n<p><strong>证明</strong>。这里的分析和对归并排序的分析（第 2 章的命题 F）类似（但相对简单）。令 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01130.gif\" alt=\"C(N)\" inline-img=\"true\" /> 为在大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的符号表中查找一个键所需进行的比较次数。显然我们有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01279.gif\" alt=\"C(0)=0\" inline-img=\"true\" />，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01280.gif\" alt=\"C(1)=1\" inline-img=\"true\" />，且对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01132.gif\" alt=\"N&gt;0\" inline-img=\"true\" /> 我们可以写出一个和递归方法直接对应的归纳关系式：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01281.gif\" alt=\"C(N)\\leqslant\\lfloor N/2\\rfloor+1\" /></p>\n<p>无论查找会在中间元素的左侧还是右侧继续，子数组的大小都不会超过 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01134.gif\" alt=\"\\lfloor N/2\\rfloor\" inline-img=\"true\" />，我们需要一次比较来检查中间元素和被查找的键是否相等，并决定继续查找左侧还是右侧的子数组。当 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 为 2 的幂减 1 时（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01282.gif\" alt=\"N=2^n-1\" inline-img=\"true\" />），这种递推很容易。首先，因为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01283.gif\" alt=\"\\lfloor N/2\\rfloor=2^-1\" inline-img=\"true\" />，所以我们有：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01284.gif\" alt=\"C(2^n-1)\\leqslant C(2^-1)+1\" /></p>\n<p>用这个公式代换不等式右边的第一项可得：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01285.gif\" alt=\"C(2^n-1)\\leqslant C(2^-1)+1+1\" /></p>\n<p>将上面这一步重复 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01286.gif\" alt=\"k-2\" inline-img=\"true\" /> 次可得：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01287.gif\" alt=\"C(2^n-1)\\leqslant C(2^0)+n\" /></p>\n<p>最后的结果即：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01288.gif\" alt=\"C(N)=C(2^n)\\leqslant n+1&lt;\\lg N+1\" /></p>\n<p>对于一般的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />，确切的结论更加复杂，但不难通过以上论证推广得到（请见练习 3.1.20）。二分查找所需时间必然在对数范围之内。</p>\n</blockquote>\n<p>刚才给出的实现中，<code>ceiling()</code> 只是调用了一次 <code>rank()</code>，而接受两个参数的默认 <code>size()</code> 方法调用了两次 <code>rank()</code>，因此这份证明也保证了这些操作（包括 <code>floor()</code>）所需的时间最多是对数级别的（<code>min()</code>、<code>max()</code> 和 <code>select()</code> 操作所需的时间都是常数级别的）。</p>\n<p>尽管能够保证查找所需的时间是对数级别的，<code>BinarySearchST</code> 仍然无法支持我们用类似 <code>FrequencyCounter</code> 的程序来处理大型问题，因为 <code>put()</code> 方法还是太慢了。二分查找减少了比较的次数但无法减少运行所需时间，因为它无法改变以下事实：在键是随机排列的情况下，构造一个基于有序数组的符号表所需要访问数组的次数是数组长度的平方级别（在实际情况下键的排列虽然不是随机的，但仍然很好地符合这个模型）。<code>BinarySearchST</code> 的操作的成本如表 3.1.9 所示。</p>\n<p><strong>表 3.1.9　BinarySearchST 的操作的成本</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>方法</p></th>\n<th><p>运行所需时间的增长数量级</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>put()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>get()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>delete()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>contains()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>size()</code></p></td>\n<td><p>1</p></td>\n</tr>\n<tr>\n<td><p><code>min()</code></p></td>\n<td><p>1</p></td>\n</tr>\n<tr>\n<td><p><code>max()</code></p></td>\n<td><p>1</p></td>\n</tr>\n<tr>\n<td><p><code>floor()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>ceiling()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>rank()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00917.gif\" alt=\"\\log N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>select()</code></p></td>\n<td><p>1</p></td>\n</tr>\n<tr>\n<td><p><code>deleteMin()</code></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p><code>deleteMax()</code></p></td>\n<td><p>1</p></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>命题 B（续）</strong>。向大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的有序数组中插入一个新的元素在最坏情况下需要访问 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01289.gif\" alt=\"\\sim2N\" inline-img=\"true\" /> 次数组，因此向一个空符号表中插入 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个元素在最坏情况下需要访问 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01290.gif\" alt=\"\\sim N^2\" inline-img=\"true\" /> 次数组。</p>\n<p><strong>证明</strong>。同命题 A。</p>\n</blockquote>\n<p>对于含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00847.gif\" alt=\"10^4\" inline-img=\"true\" /> 个不同键的《双城记》，构建符号表需要访问数组约 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01291.gif\" alt=\"10^8\" inline-img=\"true\" /> 次；而对于含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" /> 个不同键的 Leipzig 项目则需要访问数组 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01292.gif\" alt=\"10^ \" inline-img=\"true\" /> 次。虽然现代计算机可勉强实现，但这样的成本还是过高了。</p>\n<p>回头看看 <code>FrequencyCounter</code> 在参数为 8 时 <code>put()</code> 操作的性能，我们可以看到平均情况下的比较次数（包括访问数组的次数）从 <code>SequentialSearchST</code> 的 2246 次降低到了 <code>BinarySearchST</code> 的 484 次（如图 3.1.4 所示）。这比我们在分析中预测的还要更好，额外的部分可能能够再次通过应用的性质得到解释（请见练习 3.1.36）。这次改进令人印象深刻，但你会看到，我们还能做得更好。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01293.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3.1.4　使用 <code>BinarySearchST</code>，运行 <code>java FrequencyCounter 8 &lt; tale.txt</code> 的成本</strong></p>\n<h3 id=\"nav_point_124\">3.1.7　预览</h3>\n<p>一般情况下二分查找都比顺序查找快得多，它也是众多实际应用程序的最佳选择。对于一个静态表（不允许插入）来说，将其在初始化时就排序是值得的，如第 1 章中的二分查找所示（请见表 1.2.15）。即使查找前所有的键值对已知（这在应用程序中是一种常见的情况），为 <code>BinarySearchST</code> 添加一个能够初始化并将符号表排序的构造函数也是有意义的（请见练习 3.1.12）。当然，二分查找也不适合很多应用。例如，它无法处理 Leipzig Corpora 数据库，因为查找和插入操作是混合进行的，而且符号表也太大了。如我们所强调的那样，现代应用需要<strong>同时</strong>能够支持高效的查找和插入两种操作的符号表实现。也就是说，我们需要在构造庞大的符号表的同时能够任意插入（也许还有删除）键值对，同时也要能够完成查找操作。</p>\n<p>表 3.1.10 给出了本节中介绍的符号表的初级实现的性能特点。表中给出的是总成本中的最高级项（对于二分查找是数组的访问次数，对于其他则是比较次数），即运行时间的增长数量级。</p>\n<p><strong>表 3.1.10　简单的符号表实现的成本总结</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><th rowspan=\"2\">算法（数据结构）</th><th colspan=\"2\">最坏情况下的成本（<i>N</i> 次插入后）</th><th colspan=\"2\">平均情况下的成本（<i>N</i> 次随机插入后）</th><th rowspan=\"2\">是否高效地支持有序性相关的操作</th></tr>\n<tr><th>查找</th><th>插入</th><th>查找</th><th>插入</th></tr>\n<tr><td>顺序查找（无序链表）</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00986.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td><td>否</td></tr>\n<tr><td>二分查找（有序数组）</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00915.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01046.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00915.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" /></td><td>是</td></tr>\n</table>\n\n<p>核心的问题在于我们能否找到能够同时保证查找和插入操作都是对数级别的算法和数据结构。答案是令人兴奋的“可以”！这个答案也正是本章的重点所在。和第 2 章讨论的高效排序算法一样，能够高效地查找和插入的符号表是算法领域对世界最重要的贡献之一，也是我们今天能够享受的丰富计算性基础设施的开发基础。</p>\n<p>我们如何能够实现这个目标呢？要支持高效的插入操作，我们似乎需要一种链式结构。但单链接的链表是无法使用二分查找法的，因为二分查找的高效来自于能够快速通过索引取得任何子数组的中间元素（但得到一条链表的中间元素的唯一方法只能是沿链表遍历）。为了将二分查找的效率和链表的灵活性结合起来，我们需要更加复杂的数据结构。能够同时拥有两者的就是<strong>二叉查找树</strong>，它也是我们下面两节的主题。我们会将<strong>散列表</strong>留到 3.4 节中讨论。</p>\n<p>在本章中我们会学习 6 种符号表的实现，这里我们先给出一个简单的预览。表 3.1.11 包含一系列数据结构以及它们适用和不适用于某个应用场景的原因，按照我们学习它们的先后顺序排列。</p>\n<p><strong>表 3.1.11　符号表的各种实现的优缺点</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>使用的数据结构</p></th>\n<th><p>实现</p></th>\n<th><p>优点</p></th>\n<th><p>缺点</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>链表（顺序查找）</p></td>\n<td><p><code>SequentialSearchST</code></p></td>\n<td><p>适用于小型问题</p></td>\n<td><p>对于大型符号表很慢</p></td>\n</tr>\n<tr>\n<td><p>有序数组（二分查找）</p></td>\n<td><p><code>BinarySearchST</code></p></td>\n<td><p>最优的查找效率和空间需求，能够进行有序性相关的操作</p></td>\n<td><p>插入操作很慢</p></td>\n</tr>\n<tr>\n<td><p>二叉查找树</p></td>\n<td><p><code>BST</code></p></td>\n<td><p>实现简单，能够进行有序性相关的操作</p></td>\n<td><p>没有性能上界的保证链接需要额外的空间</p></td>\n</tr>\n<tr>\n<td><p>平衡二叉查找树</p></td>\n<td><p><code>RedBlackBST</code></p></td>\n<td><p>最优的查找和插入效率，能够进行有序性相关的操作</p></td>\n<td><p>链接需要额外的空间</p></td>\n</tr>\n<tr>\n<td><p>散列表</p></td>\n<td><p><code>SeparateChainHashST</code><br /><code>LinearProbingHashST</code></p></td>\n<td><p>能够快速地查找和插入常见类型的数据</p></td>\n<td><p>需要计算每种类型的数据的散列无法进行有序性相关的操作链接和空结点需要额外的空间</p></td>\n</tr>\n</tbody>\n</table>\n<p>在学习中我们会仔细了解每种算法和实现的各种性质，这里的简单特性是为了帮助你在学习它们的同时能够从全局的高度来理解它们。一句话，我们有若干种高效的符号表实现，它们能够并且已经被应用于无数程序之中了。</p>\n<h3 id=\"nav_point_125\">答疑</h3>\n<p><strong>问</strong>　为什么符号表不像 2.4 节中优先队列那样使用一个 <code>Comparable</code> 的 <code>Item</code> 类型，而是对于键和值使用不同的数据类型？</p>\n<p><strong>答</strong>　这的确是一种可行的办法。这两者代表了将键和值关联起来的两种不同方式——我们可以构造一种将键包含在其中的数据结构来<strong>隐式</strong>关联键值或是显式地将键和值区分开来。对于符号表，我们选择突出关联数组的抽象形式。同时也请注意，符号表的用例在查找时只会指定一个键，而非一个键值对。</p>\n<p><strong>问</strong>　为什么要用 <code>equals()</code> ？为什么不一直使用 <code>compareTo()</code> ？</p>\n<p><strong>答</strong>　并不是所有的数据产生的键值对都能够进行比较，尽管有时候将它们保存在符号表可以。举一个比较极端的例子，你可能会用一幅照片或者一首歌作为键，但没法比较它们，只能知道它们是否相等（也要花点儿工夫）。</p>\n<p><strong>问</strong>　为什么键的值不能为空（<code>null</code>）？</p>\n<p><strong>答</strong>　因为我们会用 <code>Key</code> 调用 <code>compareTo()</code> 或者 <code>equals()</code> 方法，因此我们假设它是一个 <code>Object</code>。但是当 <code>a</code> 为 <code>null</code> 时 <code>a.compareTo(b)</code> 会抛出一个空指针异常。如果能消除这种可能性，用例的代码能够更简单。</p>\n<p><strong>问</strong>　为什么不和排序一样使用一个类似于 <code>less()</code> 的方法？</p>\n<p><strong>答</strong>　在符号表中等价性比较特殊，因此我们还需要一个方法来测试等价性。为了避免增加本质上功能相同的方法，我们使用了 Java 内置的 <code>equals()</code> 和 <code>compareTo()</code>。</p>\n<p><strong>问</strong>　在 <code>BinarySearchST</code> 中的类型转换之前，为什么不将 <code>keys[]</code> 和 <code>vals[]</code> 一样声明为 <code>Object[]</code>（而是 <code>Comparable[]</code>）？</p>\n<p><strong>答</strong>　问得好。如果你这么做，你会得到一个 <code>ClassCastException</code>，因为键只能是 <code>Comparable</code> 的（以保证 <code>keys[]</code> 中的元素都有 <code>compareTo()</code> 方法）。因此将 <code>keys[]</code> 声明为 <code>Comparable[]</code> 是必需的。深入程序语言的设计细节来解释这里的原因可能会有些跑题。在本书所有使用泛型的 <code>Comparable</code> 对象和数组的代码中我们都会照此办理。</p>\n<p><strong>问</strong>　如果我们需要将多个值关联到同一个键怎么办？例如，如果我们在应用程序中用 Date 日期作为键，那不会需要处理重复的键吗？</p>\n<p><strong>答</strong>　可能会，也可能不会。例如，两列火车不可能同时在同一条轨道上到达同一个车站（但它们可以在不同的铁轨上同时到站）。处理这种情形有两个办法：用其他信息来消除重复或者使用 <code>Queue</code> 类型来存储所有有相同键的值。我们会在 3.5 节中详细讨论符号表的应用。</p>\n<p><strong>问</strong>　3.1.7 节中将表预排序的想法看起来是个好主意，为什么把它留作一道练习（请见练习 3.1.12）？</p>\n<p><strong>答</strong>　的确，在某些应用中它确实是最佳的选择。但在一个希望实现快速查找的数据结构中为了“图方便”而加入一个低效的插入方法会变成一个性能陷阱，因为一个普通用例可能会在一张很大的表中混合使用查找和插入操作却发现运行所需的时间是平方级别的。这种陷阱太常见了，因此当你使用他人开发的软件，尤其是接口繁多时，你应该加倍小心。当对象含有大量“便捷”方法而导致到处都是性能陷阱，而用例却可能认为所有的方法都同样高效时，这个问题就非常严重了。Java 的 <code>ArrayList</code> 类就是这样的一个例子（请见练习 3.5.27）。</p>\n<h3 id=\"nav_point_126\">练习</h3>\n<p><strong>3.1.1</strong>　编写一段程序，创建一张符号表并建立字母成绩和数值分数的对应关系，如下表所示。从标准输入读取一系列字母成绩，计算并打印 GPA（字母成绩对应的分数的平均值）。</p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td>A+</td><td>A</td><td>A-</td><td>B+</td><td>B</td><td>B-</td><td>C+</td><td>C</td><td>C-</td><td>D</td><td>F</td></tr>\n<tr><td>4.33</td><td>4.00</td><td>3.67</td><td>3.33</td><td>3.00</td><td>2.67</td><td>2.33</td><td>2.00</td><td>1.67</td><td>1.00</td><td>0.00</td></tr>\n</table>\n\n<p><strong>3.1.2</strong>　开发一个符号表的实现 <code>ArrayST</code>，使用（无序）数组来实现我们的基本 API。</p>\n<p><strong>3.1.3</strong>　开发一个符号表的实现 <code>OrderedSequentialSearchST</code>，使用有序链表来实现我们的有序符号表 API。</p>\n<p><strong>3.1.4</strong>　开发抽象数据类型 <code>Time</code> 和 <code>Event</code> 来处理表 3.1.5 中的例子中的数据。</p>\n<p><strong>3.1.5</strong>　实现 <code>SequentialSearchST</code> 中的 <code>size()</code>、<code>delete()</code> 和 <code>keys()</code> 方法。</p>\n<p><strong>3.1.6</strong>　用输入中的单词总数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01294.gif\" alt=\"W\" inline-img=\"true\" /> 和不同单词总数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01295.gif\" alt=\"D\" inline-img=\"true\" /> 的函数给出 <code>FrequencyCounter</code> 调用的 <code>put()</code> 和 <code>get()</code> 方法的次数。</p>\n<p><strong>3.1.7</strong>　对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01296.gif\" alt=\"N=10\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01297.gif\" alt=\"10^2\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00979.gif\" alt=\"10^3\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00847.gif\" alt=\"10^4\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00848.gif\" alt=\"10^5\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" />，在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个小于 1000 的随机非负整数中 <code>FrequencyCounter</code> 平均能够找到多少个不同的键？</p>\n<p><strong>3.1.8</strong>　在《双城记》中，使用频率最高的长度大于等于 10 的单词是什么？</p>\n<p><strong>3.1.9</strong>　在 <code>FrequencyCounter</code> 中添加追踪 <code>put()</code> 方法的<strong>最后一次调用</strong>的代码。打印出最后插入的那个单词以及在此之前总共从输入中处理了多少个单词。用你的程序处理 tale.txt 中长度分别大于等于 1、8 和 10 的单词。</p>\n<p><strong>3.1.10</strong>　给出用<code>SequentialSearchST</code> 将键<code>E A S Y Q U E S T I O N</code> 插入一个空符号表的过程的轨迹。一共进行了多少次比较？</p>\n<p><strong>3.1.11</strong>　给出用 <code>BinarySearchST</code> 将键 <code>E A S Y Q U E S T I O N</code> 插入一个空符号表的过程的轨迹。一共进行了多少次比较？</p>\n<p><strong>3.1.12</strong>　修改 <code>BinarySearchST</code>，用一个 <code>Item</code> 对象的数组而非两个平行数组来保存键和值。添加一个构造函数，接受一个 <code>Item</code> 的数组为参数并将其归并排序。</p>\n<p><strong>3.1.13</strong>　对于一个会随机混合进行 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00979.gif\" alt=\"10^3\" inline-img=\"true\" /> 次 <code>put()</code> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" /> 次 <code>get()</code> 操作的应用程序，你会使用本节中的哪种符号表的实现？说明理由。</p>\n<p><strong>3.1.14</strong>　对于一个会随机混合进行 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01297.gif\" alt=\"10^6\" inline-img=\"true\" /> 次 <code>put()</code> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00979.gif\" alt=\"10^3\" inline-img=\"true\" /> 次 <code>get()</code> 操作的应用程序，你会使用本节中的哪种符号表的实现？说明理由。</p>\n<p><strong>3.1.15</strong>　假设在一个 <code>BinarySearchST</code> 的用例程序中，查找操作的次数是插入操作的 1000 倍。当分别进行 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00979.gif\" alt=\"10^3\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01092.gif\" alt=\"10^9\" inline-img=\"true\" /> 次查找时，请估计插入操作在总耗时中的比例。</p>\n<p><strong>3.1.16</strong>　为 <code>BinarySearchST</code> 实现 <code>delete()</code> 方法。</p>\n<p><strong>3.1.17</strong>　为 <code>BinarySearchST</code> 实现 <code>floor()</code> 方法。</p>\n<p><strong>3.1.18</strong>　证明 <code>BinarySearchST</code> 中 <code>rank()</code> 方法的实现的正确性。</p>\n<p><strong>3.1.19</strong>　修改 <code>FrequencyCounter</code>，打印出现频率最高的所有单词，而非其中之一。<strong>提示</strong>：请用 <code>Queue</code>。</p>\n<p><strong>3.1.20</strong>　补全命题 B 的证明（证明 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的一般情况）。<strong>提示</strong>：先证明 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01130.gif\" alt=\"C(N)\" inline-img=\"true\" /> 的单调性，即对于所有的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01132.gif\" alt=\"N&gt;0\" inline-img=\"true\" />，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01298.gif\" alt=\"C(N)\\leqslant C(N+1)\" inline-img=\"true\" /></p>\n<h3 id=\"nav_point_127\">提高题</h3>\n<p><strong>3.1.21</strong>　<strong>内存使用</strong>。基于 1.4 节中的假设，对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 对键值比较 <code>BinarySearchST</code> 和 <code>SequentialSearchST</code> 的内存使用情况。不需要记录键值本身占用的内存，只统计它们的引用。对于 <code>BinarySearchST</code>，假设数组大小可以动态调整，数组中被占用的空间比例为 25% ～ 100%。</p>\n<p><strong>3.1.22</strong>　<strong>自组织查找</strong>。自组织查找指的是一种能够将数组元素重新排序使得被访问频率较高的元素更容易被找到的查找算法。请修改你为练习 3.1.2 给出的答案，在每次查找命中时：将被找到的键值对移动到数组的开头，将所有中间的键值对向右移动一格。这个启发式的过程被称为<strong>前移编码</strong>。</p>\n<p><strong>3.1.23</strong>　<strong>二分查找的分析</strong>。请证明对于大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的符号表，一次二分查找所需的最大比较次数正好是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的二进制表示的位数，因为右移一位的操作会将二进制的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 变为二进制的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01299.gif\" alt=\"[N/2]\" inline-img=\"true\" />。</p>\n<p><strong>3.1.24</strong>　<strong>插值法查找</strong>。假设符号表的键支持算术操作（例如，它们可能是 <code>Double</code> 或者 <code>Interger</code> 类型的值）。编写一个二分查找来模拟查字典的行为，例如当单词的首字母在字母表的开头时我们也会在字典的前半部分进行查找。具体来说，设 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01300.gif\" alt=\"k_\" inline-img=\"true\" /> 为符号表的第一个键，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01301.gif\" alt=\"k_\" inline-img=\"true\" /> 为符号表的最后一个键，当要查找 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01302.gif\" alt=\"k_\" inline-img=\"true\" /> 时，先和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01303.gif\" alt=\"\\lfloor(k_x-k_)/(k_-k_)\\rfloor\" inline-img=\"true\" /> 进行比较，而非取中间元素。用 <code>SearchCompare</code> <span class=\"comment-number\">1</span>调用 <code>FrequencyCounter</code> 来比较你的实现和 <code>BinarySearchST</code> 的性能。</p>\n\n<p><strong>3.1.25</strong>　<strong>缓存</strong>。因为默认的 <code>contains()</code> 的实现中调用了 <code>get()</code>，所以 <code>FrequencyCounter</code> 的内循环会将同一个键查找两三遍：</p>\n<pre class=\"code-rows\"><code>if (!st.contains(word)) st.put(word, 1);\nelse                    st.put(word, st.get(word) + 1);</code></pre>\n<p>为了能够提高这样的用例代码的效率，我们可以用一种叫<strong>缓存</strong>的技术手段，即将访问最频繁的键的位置保存在一个变量中。修改 <code>SequentialSearchST</code> 和 <code>BinarySearchST</code> 来实现这个点子。</p>\n<p><strong>3.1.26</strong>　<strong>基于字典的频率统计</strong>。修改 <code>FrequencyCounter</code>，接受一个字典文件作为参数，统计标准输入中出现在字典中的单词的频率，并将单词和频率打印为两张表格，一张按照频率高低排序，一张按照字典顺序排序。</p>\n<p><strong>3.1.27</strong>　<strong>小符号表</strong>。假设一段 <code>BinarySearchST</code> 的用例插入了 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个不同的键并会进行 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01304.gif\" alt=\"S\" inline-img=\"true\" /> 次查找。当构造表的成本和所有查找的总成本相同时，给出 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01304.gif\" alt=\"S\" inline-img=\"true\" /> 的增长数量级。</p>\n<p><strong>3.1.28</strong>　<strong>有序的插入</strong>。修改 <code>BinarySearchST</code>，使得插入一个比当前所有键都大的键只需要常数时间（这样在构造符号表时有序地使用 <code>put()</code> 插入键值对就只需要线性时间了）</p>\n<p><strong>3.1.29</strong>　<strong>测试用例</strong>。编写一段测试代码 TestBinarySearch.java 用来测试正文中 <code>min()</code>、<code>max()</code>、<code>floor()</code>、<code>ceiling()</code>、<code>select()</code>、<code>rank()</code>、<code>deleteMin()</code>、<code>deleteMax()</code> 和 <code>keys()</code> 的实现。可以参考 3.1.3.1 节的索引用例，添加代码使其在适当的情况下接受更多的命令行参数。</p>\n<p><strong>3.1.30</strong>　<strong>验证</strong>。向 <code>BinarySearchST</code> 中加入断言（assert）语句，在每次插入和删除数据后检查算法的有效性和数据结构的完整性。例如，对于每个索引必有 <code>i==rank(select(i))</code> 且数组应该总是有序的。</p>\n<h3 id=\"nav_point_128\">实验题</h3>\n<p><strong>3.1.31</strong>　<strong>性能测试</strong>。编写一段性能测试程序，先用 <code>put()</code> 构造一张符号表，再用 <code>get()</code> 进行访问，使得表中的每个键平均被命中 10 次，且有大致相同次数的未命中访问。键为长度从 2 到 50 不等的随机字符串。重复这样的测试若干遍，记录每遍的运行时间，打印平均运行时间或将它们绘制成图。</p>\n<p><strong>3.1.32</strong>　<strong>练习</strong>。编写一段练习程序，用困难或者极端的但在实际应用中可能出现的情况来测试我们的有序符号表 API。一些简单的例子包括有序的键列、逆序的键列、所有键全部相同或者只含有两种不同的值。</p>\n<p><strong>3.1.33</strong>　<strong>自组织查找</strong>。编写一段程序调用自组织查找的实现（请见练习 3.1.22），用 <code>put()</code> 构造一个大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的符号表，然后根据预先定义好的概率分布进行 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00975.gif\" alt=\"10N\" inline-img=\"true\" /> 次命中查找。对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00846.gif\" alt=\"N=10^3\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00847.gif\" alt=\"10^4\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00848.gif\" alt=\"10^5\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" />，用这段程序比较你在练习 3.1.22 中的实现和 <code>BinarySearchST</code> 的运行时间，在预定义的概率分布中查找命中第 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01071.gif\" alt=\"i\" inline-img=\"true\" /> 小的键的概率为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01305.gif\" alt=\"1/2^\" inline-img=\"true\" />。</p>\n<p><strong>3.1.34</strong>　<strong>Zipf 法则</strong>。用命中第 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01071.gif\" alt=\"i\" inline-img=\"true\" /> 小的键的概率为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01306.gif\" alt=\"1/(i{\\rm H}_N)\" inline-img=\"true\" /> 的分布重新完成上一道练习，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01307.gif\" alt=\"{\\rm H}_N\" inline-img=\"true\" /> 为调和级数（请见表 1.4.6）。这种分布被称为 Zipf 法则。比较前移编码和上一道练习中的在特定分布下的最优安排，该安排将所有键按升序排列（即按照它们的期望频率的降序排列）。</p>\n<p><strong>3.1.35</strong>　<strong>性能验证 I</strong>。用各种不同的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 运行双倍测试，取《双城记》的前 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个单词，验证 <code>FrequencyCounter</code> 在使用 <code>SequentialSearchST</code> 时所需的运行时间是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的平方级别的猜想。</p>\n<p><strong>3.1.36</strong>　<strong>性能验证 II</strong>。解释 <code>FrequencyCounter</code> 在使用 <code>BinarySearchST</code> 时比使用 <code>SequentialSearchST</code> 时的性能提高程度好于预期的原因。</p>\n<p><strong>3.1.37</strong>　<strong><code>put</code>/<code>get</code> 的比例</strong>。当 <code>FrequencyCounter</code> 使用 <code>BinarySearchST</code> 在 100 万个长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 个二进位的随机整数中统计每个值的出现频率时，根据经验判断 <code>BinarySearchST</code> 中 <code>put()</code> 操作和 <code>get()</code> 操作的耗时比，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01212.gif\" alt=\"M=10\" inline-img=\"true\" />、20 和 30。再统计 tale.txt 并评估耗时比，并比较两次的结果。</p>\n<p><strong>3.1.38</strong>　<strong>均摊成本图</strong>。修改 <code>FrequencyCounter</code>、<code>SequentialSearchST</code> 和 <code>BinarySearchST</code>，统计计算中每次 <code>put()</code> 操作的成本并生成类似本节所示的图。</p>\n<p><strong>3.1.39</strong>　<strong>实际耗时</strong>。修改 <code>FrequencyCounter</code>，用 <code>Stopwatch</code> 和 <code>StdDraw</code> 绘图，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00818.gif\" alt=\"x\" inline-img=\"true\" /> 轴为 <code>get()</code> 和 <code>put()</code> 的调用次数之和，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00820.gif\" alt=\"y\" inline-img=\"true\" /> 轴为总运行时间，每次调用时就根据已运行时间画一个点。分别用 <code>SequentialSearchST</code> 和 <code>BinarySearchST</code> 处理《双城记》并讨论运行的结果。<strong>注意</strong>：曲线中突然的跳跃可能是缓存导致的，这已经超出了这个问题的讨论范围。</p>\n<p><strong>3.1.40</strong>　<strong>二分查找的临界点</strong>。找出使用二分查找比顺序查找要快 10 000 倍和 1000 倍的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 值。分析并预测 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的大小并通过实验验证它。</p>\n<p><strong>3.1.41</strong>　<strong>插值查找的临界点</strong>。找出使用插值查找比二分查找要快 1 倍、2 倍和 10 倍的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 值，其中假设所有键为随机的 32 二进位整数（请见练习 3.1.24）。分析并预测 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的大小并通过实验验证它。</p>\n","neighbors":{"left":{"article_title":"2.5 应用","id":740940},"right":{"article_title":"3.2 二叉查找树","id":740942}},"comments":[]}