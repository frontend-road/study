{"id":261113,"title":"24 | 阿里分布式事务中间件Seata解析","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geektime-distributed\">https://gitee.com/geektime-geekbang/geektime-distributed</a></p>","comments":[{"had_liked":false,"id":237160,"user_name":"雨中漫步","can_delete":false,"product_type":"c3","uid":1130927,"ip_address":"","ucode":"022AFC716E3CAA","user_header":"https://static001.geekbang.org/account/avatar/00/11/41/af/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1595694400,"is_pvip":false,"replies":[{"id":87653,"content":"在二阶段回滚的时候，后镜像是用来做数据校验的：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理。\n\n这里有一个参考例子：\nhttps:&#47;&#47;www.cnblogs.com&#47;dalianpai&#47;p&#47;11864659.html","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1595763099,"ip_address":"","comment_id":237160,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"老师，请教下，在AT模式下，创建前置镜像和后置镜像的目的是不是就是为了生成对应的undo log？如果是的话，就有点困惑了，感觉完全没有必要生成后置镜像，直接根据前置镜像生成一条update 语句，在需要回滚时update 回原来的状态就好了，这样可以避免多一次的数据库查询","like_count":6,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502320,"discussion_content":"在二阶段回滚的时候，后镜像是用来做数据校验的：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理。\n\n这里有一个参考例子：\nhttps://www.cnblogs.com/dalianpai/p/11864659.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595763099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270124,"user_name":"Continue","can_delete":false,"product_type":"c3","uid":1315789,"ip_address":"","ucode":"C3C260907F6DF5","user_header":"https://static001.geekbang.org/account/avatar/00/14/13/cd/db3e4640.jpg","comment_is_top":false,"comment_ctime":1608943765,"is_pvip":false,"replies":[{"id":98344,"content":"Seata的源码其实并不复杂，如果碰到你说的那种情况，建议要想办法在测试环境重现问题，然后调试跟踪进去才能定位问题根因。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1609511706,"ip_address":"","comment_id":270124,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"在AT模式下，A调用B,B事务提交成功，A提交事务失败，这时候A已经回滚，但是B的数据没有回滚，哪位遇到过呢","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512525,"discussion_content":"Seata的源码其实并不复杂，如果碰到你说的那种情况，建议要想办法在测试环境重现问题，然后调试跟踪进去才能定位问题根因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609511706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251891,"user_name":"风","can_delete":false,"product_type":"c3","uid":1222352,"ip_address":"","ucode":"BC743389DBA709","user_header":"","comment_is_top":false,"comment_ctime":1601954496,"is_pvip":false,"replies":[{"id":92102,"content":"在Seata AT模式下，如果扣款150的事务也是一个Seata全局事务(假设称为事务B)，并且分布式事务(假设称为事务A)最终决策回滚，那么A&#47;B之间有写隔离，最终A&#47;B都会回滚，具体原理和流程请参考Seata 官方文档中的案例，写隔离部分：\nhttps:&#47;&#47;seata.io&#47;zh-cn&#47;docs&#47;overview&#47;what-is-seata.html\n\n如果如果扣款150的事务不是一个Seata全局事务，那么需要显示添加@GlobalLock标注，将该事务纳入Seata事务管理，这样也具有写隔离性，参考seata全局锁：\nhttps:&#47;&#47;www.cnblogs.com&#47;lay2017&#47;p&#47;12528071.html","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1602077453,"ip_address":"","comment_id":251891,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"\n老师事务隔离怎么做，有一本地账户现在有100元，现在一分布式事务，有三个分支事务，其中排第二分支事务是本地账户充值50元，且此分支事务已提交，这时该账户有一个扣款150的另一事务到来了。此时账户数据库应该是150（分支事务已提交），哪么这个账户扣款事务会隔离不，怎么隔离。如果不隔离，扣款完成后，分布式事务最后分支事务失败引起分布式事务回滚，哪不引起账户不正确？","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506649,"discussion_content":"在Seata AT模式下，如果扣款150的事务也是一个Seata全局事务(假设称为事务B)，并且分布式事务(假设称为事务A)最终决策回滚，那么A/B之间有写隔离，最终A/B都会回滚，具体原理和流程请参考Seata 官方文档中的案例，写隔离部分：\nhttps://seata.io/zh-cn/docs/overview/what-is-seata.html\n\n如果如果扣款150的事务不是一个Seata全局事务，那么需要显示添加@GlobalLock标注，将该事务纳入Seata事务管理，这样也具有写隔离性，参考seata全局锁：\nhttps://www.cnblogs.com/lay2017/p/12528071.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602077453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250538,"user_name":"Continue","can_delete":false,"product_type":"c3","uid":1315789,"ip_address":"","ucode":"C3C260907F6DF5","user_header":"https://static001.geekbang.org/account/avatar/00/14/13/cd/db3e4640.jpg","comment_is_top":false,"comment_ctime":1601121144,"is_pvip":false,"replies":[{"id":91755,"content":"你这个属于一种特例情况，数据量比较大，目前我也没有找到针对你这种情况的优化方案。\n\n因为seata是开源的，代码也不复杂，你这个问题应该跟RM的具体数据库操作方式有关，建议，先通读seata RM的源码。然后，要优化性能，先要测量获得性能数据，看看到底慢在哪里。但是目前seata metrics只有TC支持，RM还不支持，所以你需要自己手动对RM进行埋点，可以考虑prometheus metrcis埋点，或者CAT调用链埋点，找出性能瓶颈在什么地方，然后再考虑优化，必要的时候可能需要自己定制优化一下seata RM的源码。\n\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1601214805,"ip_address":"","comment_id":250538,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"老师，在用seata的AT模式时候，如果使用批量insert或者update500条以上会非常慢，十几秒，知道有哪些优化方案吗","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506230,"discussion_content":"你这个属于一种特例情况，数据量比较大，目前我也没有找到针对你这种情况的优化方案。\n\n因为seata是开源的，代码也不复杂，你这个问题应该跟RM的具体数据库操作方式有关，建议，先通读seata RM的源码。然后，要优化性能，先要测量获得性能数据，看看到底慢在哪里。但是目前seata metrics只有TC支持，RM还不支持，所以你需要自己手动对RM进行埋点，可以考虑prometheus metrcis埋点，或者CAT调用链埋点，找出性能瓶颈在什么地方，然后再考虑优化，必要的时候可能需要自己定制优化一下seata RM的源码。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601214805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1315789,"avatar":"https://static001.geekbang.org/account/avatar/00/14/13/cd/db3e4640.jpg","nickname":"Continue","note":"","ucode":"C3C260907F6DF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312744,"discussion_content":"感谢老师指教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602809399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249143,"user_name":"creed","can_delete":false,"product_type":"c3","uid":1911117,"ip_address":"","ucode":"617CA912AE9CD1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3wia2iaNnpnfRYs5O1OIYWhv7oEXSiaArqc9tIkicKVxBLUCycdBoNvzMfF2GRl89e7oJ2icZNCvdMD5iaibcOVemX5GA/132","comment_is_top":false,"comment_ctime":1600475627,"is_pvip":false,"replies":[{"id":91434,"content":"seata AT模式下，如果rollback失败，应该是不可重试的。\n\n会导致TM中的TransactionTemplate#execute抛出回滚异常。可以配置对应回滚的FailureHandler，其中可以发邮件通知进行人工介入，可参考spring下的GlobalTransactionalInterceptor.java代码。\n\n在seata XA模式下，对于某些回滚错误，是会自动重试的，直到事务超时为止，参考rm-datasource下的ResourceManagerXA.java。\n\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1600527067,"ip_address":"","comment_id":249143,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"老师，我有一个问题。seata at模式下载二阶段回滚失败，有补偿机制吗","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505846,"discussion_content":"seata AT模式下，如果rollback失败，应该是不可重试的。\n\n会导致TM中的TransactionTemplate#execute抛出回滚异常。可以配置对应回滚的FailureHandler，其中可以发邮件通知进行人工介入，可参考spring下的GlobalTransactionalInterceptor.java代码。\n\n在seata XA模式下，对于某些回滚错误，是会自动重试的，直到事务超时为止，参考rm-datasource下的ResourceManagerXA.java。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600527067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1911117,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/3wia2iaNnpnfRYs5O1OIYWhv7oEXSiaArqc9tIkicKVxBLUCycdBoNvzMfF2GRl89e7oJ2icZNCvdMD5iaibcOVemX5GA/132","nickname":"creed","note":"","ucode":"617CA912AE9CD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307284,"discussion_content":"谢谢老师解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600588944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237100,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c3","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1595676917,"is_pvip":false,"replies":[{"id":87619,"content":"可以尝试Cadence分布式工作流方案，解耦更彻底，流程状态更清晰。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1595693242,"ip_address":"","comment_id":237100,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"之前看了1.1的源码，发现tc的failover还不太完善，tcc有些问题没解决，saga用起来不太方便...另外代码也挺乱的，还是需要时间锤炼","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502302,"discussion_content":"可以尝试Cadence分布式工作流方案，解耦更彻底，流程状态更清晰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595693242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","nickname":"Geek_zbvt62","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293902,"discussion_content":"您介绍完我就列入学习计划了哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595723131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235463,"user_name":"飞翔","can_delete":false,"product_type":"c3","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1595046107,"is_pvip":false,"replies":[{"id":87051,"content":"看后面的视频，有例子解释。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1595175484,"ip_address":"","comment_id":235463,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"TC 是有状态的服务那么怎么能让它高可用呀","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501732,"discussion_content":"看后面的视频，有例子解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595175484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1391463,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3b/67/c188d3bc.jpg","nickname":"tingye","note":"","ucode":"54F7A44066DF5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292226,"discussion_content":"把状态数据保存到数据库，应用每次操作都从数据库取状态数据，这样应用就可以实现无状态了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595147225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345230,"user_name":"Geek_50d835","can_delete":false,"product_type":"c3","uid":1300338,"ip_address":"","ucode":"56BCBAD2046934","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLvHL2lXlfNcAjQiaiaRZXbLuWILI1DibVEmVFqoXawA0gjIMUHsAicMttF8XfeY6vI3499ibqZeQ5icrgA/132","comment_is_top":false,"comment_ctime":1652145789,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"2pc的分布式协调器，一般会确认全部事务执行成功才会真正提交事务，数据的一致由数据库来保证。但seata貌似采用了一种乐观模式，如果发生异常通过补偿模式来进行回滚，和2pc相比，它的吞吐量会有所提升，但可能导致的问题是，提交和回滚之间数据已经发生了变化，这就需要额外的策略了，感觉这块儿比较容易出问题。\n另外，就是基于乐观模式，在并发高的时候，比如秒杀活动，可能会导致大量回滚，性能反而不好。","like_count":0},{"had_liked":false,"id":345228,"user_name":"Geek_50d835","can_delete":false,"product_type":"c3","uid":1300338,"ip_address":"","ucode":"56BCBAD2046934","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLvHL2lXlfNcAjQiaiaRZXbLuWILI1DibVEmVFqoXawA0gjIMUHsAicMttF8XfeY6vI3499ibqZeQ5icrgA/132","comment_is_top":false,"comment_ctime":1652145120,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"分布式环境下，在提交或回滚时，怎么保证消息不丢失呢，seata怎么保证这种情况下的一致性呢？","like_count":0},{"had_liked":false,"id":337181,"user_name":"piboye","can_delete":false,"product_type":"c3","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1646663149,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"AT, TCC 都不是强一致吧， 隔离性都是有问题的。 2PC-XA 才是强一致的吧","like_count":0}]}