{"id":399700,"title":"34 | 仓库管理：如何实现文件的六大基本操作？","content":"<p>你好，我是LMOS。</p><p>我们在上一节课中，已经建立了仓库，并对仓库进行了划分，就是文件系统的格式化。有了仓库就需要往里面存取东西，对于我们的仓库来说，就是存取应用程序的文件。</p><p>所以今天我们要给仓库增加一些相关的操作，这些操作主要用于新建、打开、关闭、读写文件，它们也是文件系统的标准功能，自然即使我们这个最小的文件系统，也必须要支持。</p><p>好了，话不多说，我们开始吧。这节课的配套代码，你可以从<a href=\"https://gitee.com/lmos/cosmos/tree/master/lesson34/Cosmos\">这里</a>下载。</p><h2>辅助操作</h2><p>通过上一节课的学习，我们了解了文件系统格式化操作，不难发现文件系统格式化并不复杂，但是它们需要大量的辅助函数。同样的，完成文件相关的操作，我们也需要大量的辅助函数。为了让你更加清楚每个实现细节，这里我们先来实现文件操作相关的辅助函数。</p><h3>操作根目录文件</h3><p>根据我们文件系统的设计，不管是新建、删除、打开一个文件，首先都要找到与该文件对应的rfsdir_t结构。</p><p>在我们的文件系统中，一个文件的rfsdir_t结构就储存在根目录文件中，所以想要读取文件对应的rfsdir_t结构，首先就要获取和释放根目录文件。</p><p>下面我们来实现获取和释放根目录文件的函数，代码如下所示。</p><pre><code>//获取根目录文件\nvoid* get_rootdirfile_blk(device_t* devp)\n{\n    void* retptr = NULL;  \n    rfsdir_t* rtdir = get_rootdir(devp);//获取根目录文件的rfsdir_t结构\n    //分配4KB大小的缓冲区并清零\n    void* buf = new_buf(FSYS_ALCBLKSZ);\n    hal_memset(buf, FSYS_ALCBLKSZ, 0);\n    //读取根目录文件的逻辑储存块到缓冲区中\n    read_rfsdevblk(devp, buf, rtdir-&gt;rdr_blknr)\n    retptr = buf;//设置缓冲区的首地址为返回值\n    goto errl1;\nerrl:\n    del_buf(buf, FSYS_ALCBLKSZ);\nerrl1:\n    del_rootdir(devp, rtdir);//释放根目录文件的rfsdir_t结构\n    return retptr;\n}\n//释放根目录文件\nvoid del_rootdirfile_blk(device_t* devp,void* blkp)\n{\n    //因为逻辑储存块的头512字节的空间中，保存的就是fimgrhd_t结构\n    fimgrhd_t* fmp = (fimgrhd_t*)blkp;\n    //把根目录文件回写到储存设备中去，块号为fimgrhd_t结构自身所在的块号\n    write_rfsdevblk(devp, blkp, fmp-&gt;fmd_sfblk)\n    //释放缓冲区\n    del_buf(blkp, FSYS_ALCBLKSZ); \n    return;\n}\n</code></pre><p>上述代码中，get_rootdir函数的作用就是读取文件系统超级块中rfsdir_t结构到一个缓冲区中，del_rootdir函数则是用来释放这个缓冲区，其代码非常简单，我已经帮你写好了。</p><!-- [[[read_end]]] --><p>获取根目录文件的方法也很容易，根据超级块中的rfsdir_t结构中的信息，读取根目录文件的逻辑储存块就行了。而释放根目录文件，就是把根目录文件的储存块回写到储存设备中去，最后释放对应的缓冲区就可以了。</p><h3>获取文件名</h3><p>下面我们来实现获取文件名，在我们的印象中，一个完整的文件名应该是这样的“/cosmos/drivers/drvrfs.c”，这样的文件名包含了完整目录路径。</p><p>除了第一个“/”是根目录外，其它的“/”只是一个目录路径分隔符。然而，在很多情况下，我们通常需要把目录路径分隔符去除，提取其中的目录名称或者文件名称。为了简化问题，我们对文件系统来点限制，我们的文件名只能是“/xxxx”这种类型的。</p><p>下面我们就来实现去除路径分隔符提取文件名称的函数，代码如下所示。</p><pre><code>//检查文件路径名\nsint_t rfs_chkfilepath(char_t* fname)\n{\n    char_t* chp = fname;\n    //检查文件路径名的第一个字符是否为“/”，不是则返回2\n    if(chp[0] != '/') { return 2; }\n    for(uint_t i = 1; ; i++)\n    {\n        //检查除第1个字符外其它字符中还有没有为“/”的，有就返回3\n        if(chp[i] == '/') { return 3; }\n        //如果这里i大于等于文件名称的最大长度，就返回4\n        if(i &gt;= DR_NM_MAX) { return 4; }\n        //到文件路径字符串的末尾就跳出循环\n        if(chp[i] == 0 &amp;&amp; i &gt; 1) { break; }\n    }\n    //返回0表示正确\n    return 0;\n}\n//提取纯文件名\nsint_t rfs_ret_fname(char_t* buf,char_t* fpath)\n{\n    //检查文件路径名是不是“/xxxx”的形式\n    sint_t stus = rfs_chkfilepath(fpath);\n    //如果不为0就直接返回这个状态值表示错误\n    if(stus != 0) { return stus; }\n    //从路径名字符串的第2个字符开始复制字符到buf中\n    rfs_strcpy(&amp;fpath[1], buf);\n    return 0;\n}\n</code></pre><p>上述代码中，完成获取文件名的是rfs_ret_fname函数，这个函数可以把fpath指向的路径名中的文件名提取出来，放到buf指向的缓冲区中，但在这之前，需要先调用rfs_chkfilepath函数检查路径名是不是“/xxxx”的形式，这是这个功能正常实现的必要条件。</p><h3>判断文件是否存在</h3><p>获取了文件名称，我们还需要实现这样一个功能：判断一个文件是否存在。因为新建和删除文件，要先判断储存设备里是不是存在着这个文件。具体来说，新建文件时，无法新建相同文件名的文件；删除文件时，不能删除不存在的文件。</p><p>我们一起通过后面这个函数还完成这个功能，代码如下所示。</p><pre><code>sint_t rfs_chkfileisindev(device_t* devp,char_t* fname)\n{\n    sint_t rets = 6;\n    sint_t ch = rfs_strlen(fname);//获取文件名的长度，注意不是文件路径名\n    //检查文件名的长度是不是合乎要求\n    if(ch &lt; 1 || ch &gt;= (sint_t)DR_NM_MAX) { return 4; }\n    void* rdblkp = get_rootdirfile_blk(devp);\n    fimgrhd_t* fmp = (fimgrhd_t*)rdblkp;\n    //检查该fimgrhd_t结构的类型是不是FMD_DIR_TYPE，即这个文件是不是目录文件\n    if(fmp-&gt;fmd_type != FMD_DIR_TYPE) { rets = 3; goto err; }\n    //检查根目录文件是不是为空，即没有写入任何数据，所以返回0，表示根目录下没有对应的文件\n    if(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[0].fb_blkstart &amp;&amp;\n fmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) {\n        rets = 0; goto err;\n    }\n    rfsdir_t* dirp = (rfsdir_t*)((uint_t)(fmp) + fmp-&gt;fmd_fileifstbkoff);//指向根目录文件的第一个字节\n    //指向根目录文件的结束地址\n    void* maxchkp = (void*)((uint_t)rdblkp + FSYS_ALCBLKSZ - 1);\n    //当前的rfsdir_t结构的指针比根目录文件的结束地址小，就继续循环    \n    for(;(void*)dirp &lt; maxchkp;) {\n        //如果这个rfsdir_t结构的类型是RDR_FIL_TYPE，说明它对应的是文件而不是目录，所以下面就继续比较其文件名\n        if(dirp-&gt;rdr_type == RDR_FIL_TYPE) {\n            if(rfs_strcmp(dirp-&gt;rdr_name,fname) == 1) {//比较其文件名\n                rets = 1; goto err;\n            }\n        }\n        dirp++;\n    }\n    rets = 0; //到了这里说明没有找到相同的文件\nerr:\n    del_rootdirfile_blk(devp,rdblkp);//释放根目录文件\n    return rets;\n}\n</code></pre><p>上述代码中，rfs_chkfileisindev函数逻辑很简单。首先是检查文件名的长度，接着获取了根目录文件，然后遍历根其中的所有rfsdir_t结构并比较文件名是否相同，相同就返回1，不同就返回其它值，最后释放了根目录文件。</p><p>因为get_rootdirfile_blk函数已经把根目录文件读取到内存里了，所以可以用dirp指针和maxchkp指针操作其中的数据。</p><p>好了，操作根目录文件、获取文件名、判断一个文件是否存在的三大函数就实现了，有了它们，再去实现文件相关的其它操作就方便多了，我们接着探索。</p><h2>文件相关的操作</h2><p>直到现在，我们还没对任何文件进行操作，而我们实现文件系统，就是为了应用程序更好地存放自己的“劳动成果”——文件，因此一个文件系统必须要支持一些文件操作。</p><p>下面我们将依次实现新建、删除、打开、读写以及关闭文件，这几大文件操作，这也是文件系统需要提供的最基本的功能。</p><h3>新建文件</h3><p>在没有文件之前，对任何文件本身的操作都是无效的，所以我们首先就要实现新建文件这个功能。</p><p>在写代码之前，我们还是先来看一看如何新建一个文件，一共可以分成后面这4步。</p><p>1.从文件路径名中提取出纯文件名，检查储存设备上是否已经存在这个文件。<br>\n2.分配一个空闲的逻辑储存块，并在根目录文件的末尾写入这个新建文件对应的rfsdir_t结构。<br>\n3.在一个新的4KB大小的缓冲区中，初始化新建文件对应的fimgrhd_t结构。<br>\n4.把第3步对应的缓冲区里的数据，写入到先前分配的空闲逻辑储存块中。</p><p>下面我们先来写好新建文件的接口函数。</p><pre><code>//新建文件的接口函数\ndrvstus_t rfs_new_file(device_t* devp, char_t* fname, uint_t flg)\n{\n    //在栈中分配一个字符缓冲区并清零\n    char_t fne[DR_NM_MAX];\n    hal_memset((void*)fne, DR_NM_MAX, 0);\n    //从文件路径名中提取出纯文件名\n    if(rfs_ret_fname(fne, fname) != 0) { return DFCERRSTUS; }\n    //检查储存介质上是否已经存在这个新建的文件，如果是则返回错误\n    if(rfs_chkfileisindev(devp, fne) != 0) {return DFCERRSTUS; }\n    //调用实际建立文件的函数\n    return rfs_new_dirfileblk(devp, fne, RDR_FIL_TYPE, 0);\n}\n</code></pre><p>我们在新建文件的接口函数中，就实现了前面第一步，完成了提取文件名和检查文件是否在储存设备中存在的工作。接着我们来实现真正新建文件的函数，就是上述代码中rfs_new_dirfileblk函数，代码如下所示。</p><pre><code>drvstus_t rfs_new_dirfileblk(device_t* devp,char_t* fname,uint_t flgtype,uint_t val)\n{\n    drvstus_t rets = DFCERRSTUS;\n    void* buf = new_buf(FSYS_ALCBLKSZ);//分配一个4KB大小的缓冲区    \n    hal_memset(buf, FSYS_ALCBLKSZ, 0);//清零该缓冲区\n    uint_t fblk = rfs_new_blk(devp);//分配一个新的空闲逻辑储存块\n    void* rdirblk = get_rootdirfile_blk(devp);//获取根目录文件\n    fimgrhd_t* fmp = (fimgrhd_t*)rdirblk;\n    //指向文件当前的写入地址，因为根目录文件已经被读取到内存中了\n    rfsdir_t* wrdirp = (rfsdir_t*)((uint_t)rdirblk + fmp-&gt;fmd_curfinwbkoff);\n    //对文件当前的写入地址进行检查\n    if(((uint_t)wrdirp) &gt;= ((uint_t)rdirblk + FSYS_ALCBLKSZ)) {\n        rets=DFCERRSTUS; goto err;\n    }\n    wrdirp-&gt;rdr_stus = 0;\n    wrdirp-&gt;rdr_type = flgtype;//设为文件类型\n    wrdirp-&gt;rdr_blknr = fblk;//设为刚刚分配的空闲逻辑储存块\n    rfs_strcpy(fname, wrdirp-&gt;rdr_name);//把文件名复制到rfsdir_t结构\n    fmp-&gt;fmd_filesz += (uint_t)(sizeof(rfsdir_t));//增加根目录文件的大小\n    //增加根目录文件当前的写入地址，保证下次不被覆盖\n    fmp-&gt;fmd_curfinwbkoff += (uint_t)(sizeof(rfsdir_t));\n    fimgrhd_t* ffmp = (fimgrhd_t*)buf;//指向新分配的缓冲区\n    fimgrhd_t_init(ffmp);//调用fimgrhd_t结构默认的初始化函数\n    ffmp-&gt;fmd_type = FMD_FIL_TYPE;//因为建立的是文件，所以设为文件类型\n    ffmp-&gt;fmd_sfblk = fblk;//把自身所在的块，设为分配的逻辑储存块\n    ffmp-&gt;fmd_curfwritebk = fblk;//把当前写入的块，设为分配的逻辑储存块\n    ffmp-&gt;fmd_curfinwbkoff = 0x200;//把当前写入块的写入偏移量设为512\n    //把文件储存块数组的第1个元素的开始块，设为刚刚分配的空闲逻辑储存块\n    ffmp-&gt;fmd_fleblk[0].fb_blkstart = fblk;\n    //因为只分配了一个逻辑储存块，所以设为1\n    ffmp-&gt;fmd_fleblk[0].fb_blknr = 1;\n    //把缓冲区中的数据写入到刚刚分配的空闲逻辑储存块中\n    if(write_rfsdevblk(devp, buf, fblk) == DFCERRSTUS) { \t\t\t\n        rets = DFCERRSTUS; goto err;\n    }\n    rets = DFCOKSTUS;\nerr:\n    del_rootdirfile_blk(devp, rdirblk);//释放根目录文件\nerr1:\n    del_buf(buf, FSYS_ALCBLKSZ);//释放缓冲区\n    return rets;\n}\n</code></pre><p>看完上述代码，我想提醒你，在rfs_new_dirfileblk函数中有两点很关键。</p><p>第一，前面反复提到的目录文件中存放的就是<strong>一系列的rfsdir_t结构</strong>。</p><p>第二，fmp和ffmp这两个指针很重要。fmp指针指向的是根目录文件的fimgrhd_t结构，因为要写入一个新的rfsdir_t结构，所以要获取并改写根目录文件的fimgrhd_t结构中的数据。而ffmp指针指向的是新建文件的fimgrhd_t结构，并且初始化了其中的一些数据。最后，该函数把这个缓冲区中的数据写入到分配的空闲逻辑储存块中，同时释放了根目录文件和缓冲区。</p><h3>删除文件</h3><p>新建文件的操作完成了，下面我们来实现删除文件的操作。</p><p>如果只能新建文件而不能删除文件，那么储存设备的空间最终会耗尽，所以文件系统就必须支持删除文件的操作。</p><p>同样的，还是先来了解删除文件的方法。删除文件可以通过后面这4步来实现。</p><p>1.从文件路径名中提取出纯文件名。<br>\n2.获取根目录文件，从根目录文件中查找待删除文件的rfsdir_t结构，然后释放该文件占用的逻辑储存块。<br>\n3.初始化与待删除文件相对应的rfsdir_t结构，并设置rfsdir_t结构的类型为RDR_DEL_TYPE。<br>\n4.释放根目录文件。</p><p>这次我们用三个函数来实现这些步骤，删除文件的接口函数的代码如下。</p><pre><code>//文件删除的接口函数\ndrvstus_t rfs_del_file(device_t* devp, char_t* fname, uint_t flg)\n{\n    if(flg != 0) {\n        return DFCERRSTUS;\n    }\n    return rfs_del_dirfileblk(devp, fname, RDR_FIL_TYPE, 0);\n}\n</code></pre><p>删除文件的接口函数非常之简单，就是判断一下标志，接着调用了rfs_del_dirfileblk函数，下面我们就来写好这个rfs_del_dirfileblk函数。</p><pre><code>drvstus_t rfs_del_dirfileblk(device_t* devp, char_t* fname, uint_t flgtype, uint_t val)\n{\n    if(flgtype != RDR_FIL_TYPE || val != 0) { return DFCERRSTUS; }\n    char_t fne[DR_NM_MAX];\n    hal_memset((void*)fne, DR_NM_MAX, 0);\n    //提取纯文件名\n    if(rfs_ret_fname(fne,fname) != 0) { return DFCERRSTUS; }\n    //调用删除文件的核心函数\n    if(del_dirfileblk_core(devp, fne) != 0) { return DFCERRSTUS; }\n    return DFCOKSTUS;\n}\n</code></pre><p>rfs_del_dirfileblk函数只是提取了文件名，然后调用了一个删除文件的核心函数，这个核心函数就是del_dirfileblk_core函数，它的实现代码如下所示。</p><pre><code>//删除文件的核心函数\nsint_t del_dirfileblk_core(device_t* devp, char_t* fname)\n{\n    sint_t rets = 6;\n    void* rblkp=get_rootdirfile_blk(devp);//获取根目录文件\n    fimgrhd_t* fmp = (fimgrhd_t*)rblkp;\n    if(fmp-&gt;fmd_type!=FMD_DIR_TYPE) { //检查根目录文件的类型\n        rets=4; goto err;\n    }\n    if(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[0].fb_blkstart &amp;&amp; fmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) { //检查根目录文件中有没有数据\n        rets = 3; goto err;\n    }\n    rfsdir_t* dirp = (rfsdir_t*)((uint_t)(fmp) + fmp-&gt;fmd_fileifstbkoff);\n    void* maxchkp = (void*)((uint_t)rblkp + FSYS_ALCBLKSZ-1);\n    for(;(void*)dirp &lt; maxchkp;) {\n        if(dirp-&gt;rdr_type == RDR_FIL_TYPE) {//检查其类型是否为文件类型\n            //如果文件名相同，就执行以下删除动作\n            if(rfs_strcmp(dirp-&gt;rdr_name, fname) == 1) {\n                //释放rfsdir_t结构的rdr_blknr中指向的逻辑储存块\n                rfs_del_blk(devp, dirp-&gt;rdr_blknr);\n                //初始化rfsdir_t结构，实际上是清除其中的数据\n                rfsdir_t_init(dirp);\n                //设置rfsdir_t结构的类型为删除类型，表示它已经删除\n                dirp-&gt;rdr_type = RDR_DEL_TYPE;\n                rets = 0; goto err;\n            }\n        }\n        dirp++;//下一个rfsdir_t\n    }\n    rets=1;\nerr:\n    del_rootdirfile_blk(devp,rblkp);//释放根目录文件\n    return rets;\n}\n</code></pre><p>上述代码中的del_dirfileblk_core函数，它主要是遍历根目录文件中所有的rfsdir_t结构，并比较其文件名，看看删除的文件名称是否相同，相同就释放该rfsdir_t结构的rdr_blknr字段对应的逻辑储存块，清除该rfsdir_t结构中的数据，同时设置该rfsdir_t结构的类型为删除类型。</p><p>你可以这样理解：删除一个文件，就是把这个文件对应的rfsdir_t结构中的数据清空，这样就无法查找到这个文件了。同时，也要释放该文件占用的逻辑储存块。因为没有清空文件数据，所以可以通过反删除软件找回文件。</p><h3>打开文件</h3><p>接下来，我们就要实现打开文件操作了。一个已经存在的文件，要对它进行读写操作，首先就应该打开这个文件。</p><p>在实现这个打开文件操作之前，我们不妨先回忆一下前面课程里提到的<a href=\"https://time.geekbang.org/column/article/395772\">objnode_t结构</a>。</p><p>Cosmos内核上层组件调用设备驱动程序时，都需要建立一个相应的objnode_t结构，把这个I/O包发送给相应的驱动程序，但是objnode_t结构不仅仅是用于驱动程序，它还用于表示进程使用了哪些资源，例如打开了哪些设备或者文件，而每打开一个设备或者文件就建立一个objnode_t结构，放在特定进程的资源表中。</p><p>为了适应文件系统设备驱动程序，在cosmos/include/krlinc/krlobjnode_t.h文件中，需要在objnode_t结构中增加一些东西，代码如下所示。</p><pre><code>#define OBJN_TY_DEV 1//设备类型\n#define OBJN_TY_FIL 2//文件类型\n#define OBJN_TY_NUL 0//默认类型\ntypedef struct s_OBJNODE\n{\n    spinlock_t  on_lock;\n    list_h_t    on_list;\n    sem_t       on_complesem;\n    uint_t      on_flgs;\n    uint_t      on_stus;\n    //……\n    void*       on_fname;//文件路径名指针\n    void*       on_finode;//文件对应的fimgrhd_t结构指针\n    void*       on_extp;//扩展所用\n}objnode_t;\n</code></pre><p>上述代码中objnode_t结构里增加了两个字段，一个是指向文件路径名的指针，表示打开哪个文件。因为要知道一个文件的所有信息，所以增加了指向对应文件的fimgrhd_t结构指针，也就是我们增加的第二个字段。</p><p>现在我们来看看打开一个文件的流程。一共也是4步。</p><p>1.从objnode_t结构的文件路径提取文件名。<br>\n2.获取根目录文件，在该文件中搜索对应的rfsdir_t结构，看看文件是否存在。<br>\n3.分配一个4KB缓存区，把该文件对应的rfsdir_t结构中指向的逻辑储存块读取到缓存区中，然后释放根目录文件。<br>\n4.把缓冲区中的fimgrhd_t结构的地址，保存到objnode_t结构的on_finode域中。</p><p>下面来写两个函数实现这些流程，同样我们需要先写好接口函数，代码如下所示。</p><pre><code>//打开文件的接口函数\ndrvstus_t rfs_open_file(device_t* devp, void* iopack)\n{\n    objnode_t* obp = (objnode_t*)iopack;\n    //检查objnode_t中的文件路径名\n    if(obp-&gt;on_fname == NULL) {\n        return DFCERRSTUS;\n    }\n    //调用打开文件的核心函数\n    void* fmdp = rfs_openfileblk(devp, (char_t*)obp-&gt;on_fname);\n    if(fmdp == NULL) {\n        return DFCERRSTUS;\n    }\n    //把返回的fimgrhd_t结构的地址保存到objnode_t中的on_finode字段中\n    obp-&gt;on_finode = fmdp;\n    return DFCOKSTUS;\n}\n</code></pre><p>接口函数rfs_open_file中只是对参数进行了检查。然后调用了核心函数，这个函数就是rfs_openfileblk，它的代码实现如下所示。</p><pre><code>//打开文件的核心函数\nvoid* rfs_openfileblk(device_t *devp, char_t* fname)\n{\n    char_t fne[DR_NM_MAX]; void* rets = NULL,*buf = NULL;\n    hal_memset((void*)fne,DR_NM_MAX,0);\n    if(rfs_ret_fname(fne, fname) != 0) {//从文件路径名中提取纯文件名\n        return NULL;\n    }\n    void* rblkp = get_rootdirfile_blk(devp); //获取根目录文件\n    fimgrhd_t* fmp = (fimgrhd_t*)rblkp;\n    if(fmp-&gt;fmd_type != FMD_DIR_TYPE) {//判断根目录文件的类型是否合理 \n        rets = NULL; goto err;\n    }\n    //判断根目录文件里有没有数据\n    if(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[0].fb_blkstart &amp;&amp; \nfmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) { \n        rets = NULL; goto err;\n    }\n    rfsdir_t* dirp = (rfsdir_t*)((uint_t)(fmp) + fmp-&gt;fmd_fileifstbkoff); \n    void* maxchkp = (void*)((uint_t)rblkp + FSYS_ALCBLKSZ - 1);\n    for(;(void*)dirp &lt; maxchkp;) {//开始遍历文件对应的rfsdir_t结构\n        if(dirp-&gt;rdr_type == RDR_FIL_TYPE) {\n            //如果文件名相同就跳转到opfblk标号处运行\n            if(rfs_strcmp(dirp-&gt;rdr_name, fne) == 1) {\n                goto opfblk;\n            }\n        }\n        dirp++;\n    }\n    //如果到这里说明没有找到该文件对应的rfsdir_t结构，所以设置返回值为NULL\n    rets = NULL; goto err;\nopfblk:\n    buf = new_buf(FSYS_ALCBLKSZ);//分配4KB大小的缓冲区\n    //读取该文件占用的逻辑储存块\n    if(read_rfsdevblk(devp, buf, dirp-&gt;rdr_blknr) == DFCERRSTUS) {\n        rets = NULL; goto err1;\n    }\n    fimgrhd_t* ffmp = (fimgrhd_t*)buf;\n    if(ffmp-&gt;fmd_type == FMD_NUL_TYPE || ffmp-&gt;fmd_fileifstbkoff != 0x200) {//判断将要打开的文件是否合法\n        rets = NULL; goto err1;\n    }\n    rets = buf; goto err;//设置缓冲区首地址为返回值\nerr1:\n    del_buf(buf, FSYS_ALCBLKSZ); //上面的步骤若出现问题就要释放缓冲区\nerr:\n    del_rootdirfile_blk(devp, rblkp); //释放根目录文件\n    return rets;\n}\n</code></pre><p>结合上面的代码我们能够看到，通过rfs_openfileblk函数中的for循环，可以遍历要打开的文件在根目录文件中对应的rfsdir_t结构，然后把对应文件占用的逻辑储存块读取到缓冲区中，最后返回这个缓冲区的首地址。</p><p>因为这个缓冲区开始的空间中，就存放着其文件对应的fimgrhd_t结构，所以返回fimgrhd_t结构的地址，整个打开文件的流程就结束了。</p><h3>读写文件</h3><p>刚才我们已经实现了打开文件， 而打开一个文件，就是为了对这个文件进行读写。</p><p>其实对文件的读写包含两个操作，一个是从储存设备中读取文件的数据，另一个是把文件的数据写入到储存设备中。</p><p>咱们先来看看如何读取已经打开的文件中的数据，大致的流程如下。</p><p>1.检查objnode_t结构中用于存放文件数据的缓冲区及其大小。<br>\n2.检查imgrhd_t结构中文件相关的信息。<br>\n3.把文件的数据读取到objnode_t结构中指向的缓冲区中。</p><p>通过后面的代码，我们把读文件的接口函数跟核心函数一起实现。</p><pre><code>//读取文件数据的接口函数\ndrvstus_t rfs_read_file(device_t* devp,void* iopack)\n{\n    objnode_t* obp = (objnode_t*)iopack;\n    //检查文件是否已经打开，以及用于存放文件数据的缓冲区和它的大小是否合理\n    if(obp-&gt;on_finode == NULL || obp-&gt;on_buf == NULL || obp-&gt;on_bufsz != FSYS_ALCBLKSZ) { \n        return DFCERRSTUS; \n    }\n    return rfs_readfileblk(devp, (fimgrhd_t*)obp-&gt;on_finode, obp-&gt;on_buf, obp-&gt;on_len);\n}\n//实际读取文件数据的函数\ndrvstus_t rfs_readfileblk(device_t* devp, fimgrhd_t* fmp, void* buf, uint_t len)\n{\n    //检查文件的相关信息是否合理\n    if(fmp-&gt;fmd_sfblk != fmp-&gt;fmd_curfwritebk || fmp-&gt;fmd_curfwritebk != fmp-&gt;fmd_fleblk[0].fb_blkstart) {\n        return DFCERRSTUS;\n    }\n    //检查读取文件数据的长度是否大于（4096-512）\n    if(len &gt; (FSYS_ALCBLKSZ - fmp-&gt;fmd_fileifstbkoff)) {\n        return DFCERRSTUS;\n    }\n    //指向文件数据的开始地址\n    void* wrp = (void*)((uint_t)fmp + fmp-&gt;fmd_fileifstbkoff);\n    //把文件开始处的数据复制len个字节到buf指向的缓冲区中\n    hal_memcpy(wrp, buf, len); \n    return DFCOKSTUS;\n}\n</code></pre><p>上述代码中读取文件数据的函数很简单，关键是要明白前面那个打开文件的函数，因为在那里它已经把文件数据复制到一个缓冲区中了，rfs_readfileblk函数中的参数buf、len都是接口函数rfs_read_file从objnode_t结构中提取出来的，其它的部分我已经通过注释已经说明了。</p><p>好了，我们下面就来实现怎么向文件中写入数据，和读取文件的流程一样，只不过要将要写入的数据复制到打开文件时为其分配的缓冲区中，最后还要把打开文件时为其分配的缓冲区中的数据，写入到相应的逻辑储存块中。</p><p>我们还是把写文件的接口函数和核心函数一起实现，代码如下所示。</p><pre><code>//写入文件数据的接口函数\ndrvstus_t rfs_write_file(device_t* devp, void* iopack)\n{\n    objnode_t* obp = (objnode_t*)iopack;\n    //检查文件是否已经打开，以及用于存放文件数据的缓冲区和它的大小是否合理\n    if(obp-&gt;on_finode == NULL || obp-&gt;on_buf == NULL || obp-&gt;on_bufsz != FSYS_ALCBLKSZ) {\n        return DFCERRSTUS;\n    }\n    return rfs_writefileblk(devp, (fimgrhd_t*)obp-&gt;on_finode, obp-&gt;on_buf, obp-&gt;on_len);\n}\n//实际写入文件数据的函数\ndrvstus_t rfs_writefileblk(device_t* devp, fimgrhd_t* fmp, void* buf, uint_t len)\n{\n    //检查文件的相关信息是否合理\n    if(fmp-&gt;fmd_sfblk != fmp-&gt;fmd_curfwritebk || fmp-&gt;fmd_curfwritebk != fmp-&gt;fmd_fleblk[0].fb_blkstart) {\n        return DFCERRSTUS;\n    }\n    //检查当前将要写入数据的偏移量加上写入数据的长度，是否大于等于4KB\n    if((fmp-&gt;fmd_curfinwbkoff + len) &gt;= FSYS_ALCBLKSZ) {\n        return DFCERRSTUS;\n    }\n    //指向将要写入数据的内存空间\n    void* wrp = (void*)((uint_t)fmp + fmp-&gt;fmd_curfinwbkoff);\n    //把buf缓冲区中的数据复制len个字节到wrp指向的内存空间中去\n    hal_memcpy(buf, wrp, len);\n    fmp-&gt;fmd_filesz += len;//增加文件大小\n    //使fmd_curfinwbkoff指向下一次将要写入数据的位置\n    fmp-&gt;fmd_curfinwbkoff += len;\n    //把文件数据写入到相应的逻辑储存块中，完成数据同步\n    write_rfsdevblk(devp, (void*)fmp, fmp-&gt;fmd_curfwritebk);\n    return DFCOKSTUS;\n}\n</code></pre><p>上述代码中，你要注意的是，<strong>rfs_writefileblk函数永远都是从fimgrhd_t 结构的fmd_curfinwbkoff字段中的偏移量开始写入文件数据的</strong>，比如向空文件中写入2个字节，那么其fmd_curfinwbkoff字段的值就是2，因为第0、1个字节空间已经被占用了，这就是<strong>追加写入数据</strong>的方式。</p><p>rfs_writefileblk函数最后调用write_rfsdevblk函数把文件数据写入到相应的逻辑储存块中，完成数据同步。我们发现只要打开文件了，读写文件还是很简单的，最后还要实现关闭文件的操作。</p><h3>关闭文件</h3><p>有打开文件的操作，就需要有关闭文件的操作，因为打开一个文件，会为此分配一个缓冲区，这些都是系统资源，所以需要一个关闭文件的操作来释放这些资源，以防止系统资源泄漏。</p><p>关闭文件的流程很简单，首先检查文件是否已经打开。然后把文件写入到对应的逻辑储存块中，完成数据的同步。最后释放文件数据占用的缓冲区。下面我们开始写代码实现，我们依然把接口和核心函数放在一起实现，代码如下所示。</p><pre><code>//关闭文件的接口函数\ndrvstus_t rfs_close_file(device_t* devp, void* iopack)\n{\n    objnode_t* obp = (objnode_t*)iopack;\n    //检查文件是否已经打开了\n    if(obp-&gt;on_finode == NULL) { \n        return DFCERRSTUS;\n    }\n    return rfs_closefileblk(devp, obp-&gt;on_finode);\n}\n//关闭文件的核心函数\ndrvstus_t rfs_closefileblk(device_t *devp, void* fblkp)\n{\n    //指向文件的fimgrhd_t结构\n    fimgrhd_t* fmp = (fimgrhd_t*)fblkp;\n    //完成文件数据的同步\n    write_rfsdevblk(devp, fblkp, fmp-&gt;fmd_sfblk);\n    //释放缓冲区\n    del_buf(fblkp, FSYS_ALCBLKSZ);\n    return DFCOKSTUS;\n}\n</code></pre><p>上述代码是非常简单的，但在目前的情况下，rfs_closefileblk函数中是没有必要调用write_rfsdevblk函数的，因为前面在写入文件数据的同时，就已经把文件的数据写入到逻辑储存块中去了。最后释放了先前打开文件时分配的缓冲区，而objnode_t结构不应该在此释放，它是由Cosmos内核上层组件进行释放的。</p><h2>串联整合</h2><p>到目前为止，我们实现了文件相关的操作，并且提供了接口函数，但是我们的文件系统是以设备的形式存在的，所以文件操作的接口，必须要串联整合到文件系统设备驱动程序之中，文件系统才能真正工作。</p><p>下面我们就去整合联串文件系统设备驱动程序。首先来串联整合文件系统的打开文件操作和新建文件操作，代码如下所示。</p><pre><code>drvstus_t rfs_open(device_t* devp, void* iopack)\n{\n    objnode_t* obp=(objnode_t*)iopack;\n    //根据objnode_t结构中的访问标志进行判断\n    if(obp-&gt;on_acsflgs == FSDEV_OPENFLG_OPEFILE) {\n        return rfs_open_file(devp, iopack);\n    }\n    if(obp-&gt;on_acsflgs == FSDEV_OPENFLG_NEWFILE) {\n        return rfs_new_file(devp, obp-&gt;on_fname, 0);\n    }\n    return DFCERRSTUS;\n}\n</code></pre><p>上述代码中rfs_open函数对应于设备驱动程序的打开功能派发函数，但没有相应的新建功能派发函数，于是我们就根据objnode_t结构中访问标志域设置不同的编码，来进行判断。</p><p>接着我们来串联整合关闭文件的操作。这次要简单一些，因为设备驱动程序有对应的关闭功能派发函数，直接调用关闭文件操作的接口函数就可以了，代码如下所示。</p><pre><code>drvstus_t rfs_close(device_t* devp, void* iopack)\n{\n    return rfs_close_file(devp, iopack);\n}\n</code></pre><p>然后是文件读写操作的串联整合，设备驱动程序也有对应的读写功能派发函数，同样也是直接调用文件读写操作的接口函数即可，代码如下所示。</p><pre><code>drvstus_t rfs_read(device_t* devp, void* iopack)\n{\n    //调用读文件操作的接口函数\n    return rfs_read_file(devp, iopack);\n}\ndrvstus_t rfs_write(device_t* devp, void* iopack)\n{\n    //调用写文件操作的接口函数\n    return rfs_write_file(devp, iopack);\n}\n</code></pre><p>最后，来串联整合稍微有点复杂的删除文件操作，这是因为设备驱动程序没有对应的功能派发函数，所以我们需要用到设备驱动程序的控制功能派发函数，代码如下所示。</p><pre><code>drvstus_t rfs_ioctrl(device_t* devp, void* iopack)\n{\n    objnode_t* obp = (objnode_t*)iopack;\n    //根据objnode_t结构中的控制码进行判断\n    if(obp-&gt;on_ioctrd == FSDEV_IOCTRCD_DELFILE)\n    {\n        //调用删除文件操作的接口函数\n        return rfs_del_file(devp, obp-&gt;on_fname, 0);\n    }\n    return DFCERRSTUS;\n}\n</code></pre><p>上述代码中，我们给文件系统设备分配了一个FSDEV_IOCTRCD_DELFILE（一个整数）控制码，Cosmos内核上层组件的代码就可以根据需要，设置objnode_t结构中的控制码就能达到相应的目的了。</p><p>现在，文件相关的操作已经串联整合好了。</p><h2>测试</h2><p>前面实现了文件系统的6种最常用的文件操作，并且已经整合到文件系统设备驱动程序框架代码中去了，可是这些代码究竟对不对，测试运行了才知道。</p><p>下面来写好测试代码。要注意的是，Cosmos下的任何设备驱动程序<strong>都必须要有objnode_t结构才能运行</strong>。所以，在这里我们需要手动建立一个objnode_t结构并设置好其中的字段，模拟一下Cosmos上层组件调用设备驱动程序的过程。</p><p>这一过程我们可以写个test_fsys函数来实现，代码如下所示。</p><pre><code>void test_fsys(device_t *devp)\n{\n    kprint(&quot;开始文件操作测试\\n&quot;);\n    void *rwbuf = new_buf(FSYS_ALCBLKSZ);//分配缓冲区\n    //把缓冲区中的所有字节都置为0xff\n    hal_memset(rwbuf, 0xff, FSYS_ALCBLKSZ);\n    objnode_t *ondp = krlnew_objnode();//新建一个objnode_t结构\n    ondp-&gt;on_acsflgs = FSDEV_OPENFLG_NEWFILE;//设置新建文件标志\n    ondp-&gt;on_fname = &quot;/testfile&quot;;//设置新建文件名\n    ondp-&gt;on_buf = rwbuf;//设置缓冲区\n    ondp-&gt;on_bufsz = FSYS_ALCBLKSZ;//设置缓冲区大小\n    ondp-&gt;on_len = 512;//设置读写多少字节\n    ondp-&gt;on_ioctrd = FSDEV_IOCTRCD_DELFILE;//设置控制码\n    if (rfs_open(devp, ondp) == DFCERRSTUS) {//新建文件\n        hal_sysdie(&quot;新建文件错误&quot;);\n    }\n    ondp-&gt;on_acsflgs = FSDEV_OPENFLG_OPEFILE;//设置打开文件标志\n    if (rfs_open(devp, ondp) == DFCERRSTUS) {//打开文件\n        hal_sysdie(&quot;打开文件错误&quot;);\n    }\n    if (rfs_write(devp, ondp) == DFCERRSTUS) {//把数据写入文件\n        hal_sysdie(&quot;写入文件错误&quot;);\n    }\n    hal_memset(rwbuf, 0, FSYS_ALCBLKSZ);//清零缓冲区\n    if (rfs_read(devp, ondp) == DFCERRSTUS) {//读取文件数据\n        hal_sysdie(&quot;读取文件错误&quot;);\n    }\n    if (rfs_close(devp, ondp) == DFCERRSTUS) {//关闭文件\n        hal_sysdie(&quot;关闭文件错误&quot;);\n    }\n    u8_t *cb = (u8_t *)rwbuf;//指向缓冲区\n    for (uint_t i = 0; i &lt; 512; i++) {//检查缓冲区空间中的头512个字节的数据，是否为0xff\n        if (cb[i] != 0xff) {//如果不等于0xff就死机\n            hal_sysdie(&quot;检查文件内容错误&quot;);\n        }\n        kprint(&quot;testfile文件第[%x]个字节数据:%x\\n&quot;, i, (uint_t)cb[i]);//打印文件内容\n    }\n    if (rfs_ioctrl(devp, ondp) == DFCERRSTUS){//删除文件\n        hal_sysdie(&quot;删除文件错误&quot;);\n    }\n    ondp-&gt;on_acsflgs = FSDEV_OPENFLG_OPEFILE;//再次设置打开文件标志\n    if (rfs_open(devp, ondp) == DFCERRSTUS) {//再次打开文件\n        hal_sysdie(&quot;再次打开文件失败&quot;);\n    }\n    hal_sysdie(&quot;结束文件操作测试&quot;);\n    return;\n}\n</code></pre><p>上述代码虽然有点长，因为我们一下子测试了关于文件的6大操作。每个文件操作失败后都会死机，不会继续向下运行。</p><p>测试逻辑很简单：开始会建立并打开一个文件，接着写入数据，然后读取文件中数据进行比较，看看是不是和之前写入的数据相等，最后删除这个文件并再次打开，看是否会出错。因为文件已经删除了，打开一个已经删除的文件自然要出错，出错就说明测试成功。</p><p>现在我们把test_fsys函数放在rfs_entry函数的最后调用，然后打开终端切换到cosmos目录下执行make vboxtest 命令，最后不出意外的话，你会看到如下图所示的情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/ed/d4/eddb4f92fd55c34113ba55c81e2b95d4.jpg?wh=1044x921\" alt=\"\" title=\"文件操作测试示意图\"></p><p>从图里我们能看到，文件中的数据和最后重新打开已经删除文件时出现的错误，这说明了我们的代码是正确无误的。</p><p>至此 ，测试了文件相关的6大操作的代码，代码质量都是相当高的，都达到了我们的预期，一个简单、有诸多限制但却五脏俱全的文件系统就实现了。</p><h2>重点回顾</h2><p>这节课告一段落，恭喜你坚持到这里。</p><p>文件系统虽然复杂，但我们发现只要做得足够“小”，就能大大降低了实现的难度。虽然降低了实现的难度，但我们的rfs文件系统依然包含了一个正常文件系统所具有的功能特性，现在我来为你梳理一下本节课的重点：</p><p>1.首先是文件系统的辅助操作，因为文件系统的复杂性，所以必须要实现一些如获取与释放根目录文件、获取文件名、判断文件是否存在等基础辅助操作函数。</p><p>2.然后实现了文件系统必须要提供的6大文件操作：<strong>新建文件、删除文件、打开文件、读写文件、关闭文件</strong>。</p><p>3.最后把这些文件操作全部串联整合到文件系统设备驱动程序之中，并且进行了测试，确认代码正确无误。</p><p>今天这节课，我们又实现了Cosmos内核的一个基础组件，即文件系统，不过它是以<strong>设备的形式</strong>存在的，这样做是为了方便以后的扩展和移植。</p><p>现在文件系统是实现了，不过还不够完善。你可能在想，我们文件系统在内存中，一断电数据就全完了。是的，不过你可以尝试写好硬盘驱动，然后把内存中的逻辑储存块写入到硬盘中就行了，期待你的实现。</p><h2>思考题</h2><p>请你想一想，我们这个简单的、小的，却五脏俱全的文件系统有哪些限制？</p><p>欢迎你在留言区记录你的收获或疑问，也鼓励你边学边练，多多动手实践。同时我推荐你把这节课分享给身边的朋友，跟他一起学习进步。</p><p>好，我是LMOS，我们下节课见。</p>","comments":[{"had_liked":false,"id":306105,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":true,"comment_ctime":1628351484,"is_pvip":false,"replies":[{"id":"110840","content":"总结到位 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1628478180,"ip_address":"","comment_id":306105,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720470730998e+18","product_id":100078401,"comment_content":"四、文件系统使用【1、只有一级目录；2、文件管理结构+文件大小&lt;=4K】<br>1、判断文件是否存在<br>计算得到文件名<br>找到根目录文件块<br>跳过管理结构，遍历全部rfsdir_t目录结构，如果有重名的就返回，没有就失败<br><br>2、新建文件<br>A、确认文件并不存在，存在就报错<br>B、找到根目录文件块<br>C、申请一个逻辑块<br>D、跳过管理结构，新增一个rfsdir_t目录结构，并指向新申请的逻辑块<br>E、在逻辑块开始建立新的fimgrhd_t文件管理结构<br><br>3、删除文件<br>A、找到根目录文件快<br>B、跳过管理结构，遍历全部rfsdir_t目录结构，如果没有就失败<br>C、将rfsdir_t标识为删除<br>D、回收逻辑块<br><br>4、打开文件<br>A、找到根目录文件快<br>B、跳过管理结构，遍历全部rfsdir_t目录结构，如果没有就失败<br>C、读取逻辑块，返回<br><br>5、读取文件<br>A、判断文件已打开<br>B、根据文件偏移及读取长度，返回数据<br><br>6、写入文件<br>A、判断文件已打开<br>B、数据追加到缓存中<br>C、缓存写入到设备中<br><br>7、关闭设备<br>A、判断文件已打开<br>B、缓存写入到设备中<br>C、释放缓存","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524631,"discussion_content":"总结到位 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628478180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304102,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1627256555,"is_pvip":false,"replies":[{"id":"110043","content":"哈哈是的，你有能力可以写个硬盘驱动，在rfs这个驱动中，将IO包继续下发给硬盘驱动，让硬盘驱动写入到硬盘，由此，有层层驱动堆叠的IO栈就形成了 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1627262365,"ip_address":"","comment_id":304102,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14512158443","product_id":100078401,"comment_content":"限制1：不可持久化，不支持crash恢复，应加入磁盘块的写入，内存中有一定文件块的缓存，支持日志，防止系统崩溃，文件数据丢失。<br>限制2：缺少抽象层，无法支持多种格式的文件。<br>限制3：小量内存式文件系统，没有使用磁盘，不支持 mount 等骚操作。<br>等等……","like_count":3,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523931,"discussion_content":"哈哈是的，你有能力可以写个硬盘驱动，在rfs这个驱动中，将IO包继续下发给硬盘驱动，让硬盘驱动写入到硬盘，由此，有层层驱动堆叠的IO栈就形成了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627262365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304104,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1627257680,"is_pvip":false,"replies":[{"id":"110042","content":"对，没有实现","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1627262170,"ip_address":"","comment_id":304104,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10217192272","product_id":100078401,"comment_content":"好像还缺少seek操作","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523933,"discussion_content":"对，没有实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627262170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317266,"user_name":"Kinco.","can_delete":false,"product_type":"c1","uid":2436224,"ip_address":"","ucode":"D73F24903CD379","user_header":"https://static001.geekbang.org/account/avatar/00/25/2c/80/20632858.jpg","comment_is_top":false,"comment_ctime":1634727407,"is_pvip":false,"replies":[{"id":"115370","content":"是的 是的","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1635211971,"ip_address":"","comment_id":317266,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5929694703","product_id":100078401,"comment_content":"1. 不支持多种格式的文件；<br>2. 不支持多层目录；<br>3. 不支持seek操作。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528741,"discussion_content":"是的 是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635211971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345515,"user_name":"艾恩凝","can_delete":false,"product_type":"c1","uid":2950704,"ip_address":"","ucode":"F2B81BF4F0106A","user_header":"https://static001.geekbang.org/account/avatar/00/2d/06/30/c26ea06a.jpg","comment_is_top":false,"comment_ctime":1652345127,"is_pvip":false,"replies":[{"id":"126512","content":"是的 支持多级 目录 代码会更加复杂","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1653618325,"ip_address":"","comment_id":345515,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652345127","product_id":100078401,"comment_content":"打卡，果然不支持多级目录，更多的是体会一下，os中的文件操作","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573723,"discussion_content":"是的 支持多级 目录 代码会更加复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653618326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344978,"user_name":"MONKEYG","can_delete":false,"product_type":"c1","uid":2519235,"ip_address":"","ucode":"81C780AA899A9E","user_header":"https://static001.geekbang.org/account/avatar/00/26/70/c3/cc46c55a.jpg","comment_is_top":false,"comment_ctime":1651911045,"is_pvip":false,"replies":[{"id":"125959","content":"没有这个函数啊","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1652065392,"ip_address":"","comment_id":344978,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651911045","product_id":100078401,"comment_content":"我想请问下，这个try_entry是谁在调用的😂😂","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571065,"discussion_content":"没有这个函数啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652065392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335487,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1645536614,"is_pvip":false,"replies":[{"id":"122559","content":"嗯嗯","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1645582160,"ip_address":"","comment_id":335487,"utype":1}],"discussion_count":1,"race_medal":4,"score":"1645536614","product_id":100078401,"comment_content":"文件查询","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552734,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645582161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329664,"user_name":"kocgockohgoh王裒","can_delete":false,"product_type":"c1","uid":2617112,"ip_address":"","ucode":"35EFABDE0D713D","user_header":"https://static001.geekbang.org/account/avatar/00/27/ef/18/6a620733.jpg","comment_is_top":false,"comment_ctime":1641461298,"is_pvip":false,"replies":[{"id":"120233","content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1641779361,"ip_address":"","comment_id":329664,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641461298","product_id":100078401,"comment_content":"请问删除文件的时候 是不是在根目录文件产生空洞啊 新建文件总是从根目录文件末尾操作","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544913,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641779361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305476,"user_name":"al_培龙","can_delete":false,"product_type":"c1","uid":1039597,"ip_address":"","ucode":"C8E9D775D28D91","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dc/ed/3fe13e55.jpg","comment_is_top":false,"comment_ctime":1627986377,"is_pvip":false,"replies":[{"id":"110596","content":"对 对 对  ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1628128270,"ip_address":"","comment_id":305476,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1627986377","product_id":100078401,"comment_content":"好像不支持多级目录吧","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524396,"discussion_content":"对 对 对  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628128270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2308439,"avatar":"https://static001.geekbang.org/account/avatar/00/23/39/57/b1e6b147.jpg","nickname":"灯火阑珊","note":"","ucode":"75FBF8552A92DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537671,"discussion_content":"你是怎么发现的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639134999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}