{"id":171771,"title":"15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？","content":"<p>上几节课中，我们介绍了面向对象相关的知识。从今天起，我们开始学习一些经典的设计原则，其中包括，SOLID、KISS、YAGNI、DRY、LOD等。</p><p>这些设计原则，从字面上理解，都不难。你一看就感觉懂了，一看就感觉掌握了，但真的用到项目中的时候，你会发现，“看懂”和“会用”是两回事，而“用好”更是难上加难。从我之前的工作经历来看，很多同事因为对这些原则理解得不够透彻，导致在使用的时候过于教条主义，拿原则当真理，生搬硬套，适得其反。</p><p>所以，在接下来的讲解中，我不仅会讲解这些原则的定义，还会解释这些原则设计的初衷，能解决哪些问题，有哪些应用场景等，让你知其然知其所以然。在学习的时候，希望你能跟上我的思路，把握住重点，真正做到活学活用。</p><h2>如何理解单一职责原则（SRP）？</h2><p>文章的开头我们提到了SOLID原则，实际上，SOLID原则并非单纯的1个原则，而是由5个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应SOLID中的S、O、L、I、D这5个英文字母。我们今天要学习的是SOLID原则中的第一个原则：单一职责原则。</p><p>单一职责原则的英文是Single Responsibility Principle，缩写为SRP。这个原则的英文描述是这样的：A class or module should have a single responsibility。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。</p><!-- [[[read_end]]] --><p>注意，这个原则描述的对象包含两个，一个是类（class），一个是模块（module）。关于这两个概念，在专栏中，有两种理解方式。一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。</p><p>不管哪种理解方式，单一职责原则在应用到这两个描述对象的时候，道理都是相通的。为了方便你理解，接下来我只从“类”设计的角度，来讲解如何应用这个设计原则。对于“模块”来说，你可以自行引申。</p><p>单一职责原则的定义描述非常简单，也不难理解。一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p><p>我举一个例子来解释一下。比如，一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。为了满足单一职责原则，我们需要将这个类拆分成两个粒度更细、功能更加单一的两个类：订单类和用户类。</p><h2>如何判断类的职责是否足够单一？</h2><p>从刚刚这个例子来看，单一职责原则看似不难应用。那是因为我举的这个例子比较极端，一眼就能看出订单和用户毫不相干。但大部分情况下，类里的方法是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的。在真实的软件开发中，对于一个类是否职责单一的判定，是很难拿捏的。我举一个更加贴近实际的例子来给你解释一下。</p><p>在一个社交产品中，我们用下面的UserInfo类来记录用户的信息。你觉得，UserInfo类的设计是否满足单一职责原则呢？</p><pre><code>public class UserInfo {\n  private long userId;\n  private String username;\n  private String email;\n  private String telephone;\n  private long createTime;\n  private long lastLoginTime;\n  private String avatarUrl;\n  private String provinceOfAddress; // 省\n  private String cityOfAddress; // 市\n  private String regionOfAddress; // 区 \n  private String detailedAddress; // 详细地址\n  // ...省略其他属性和方法...\n}\n</code></pre><p>对于这个问题，有两种不同的观点。一种观点是，UserInfo类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；另一种观点是，地址信息在UserInfo类中，所占的比重比较高，可以继续拆分成独立的UserAddress类，UserInfo只保留除Address之外的其他信息，拆分之后的两个类的职责更加单一。</p><p>哪种观点更对呢？实际上，要从中做出选择，我们不能脱离具体的应用场景。如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那UserInfo现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从UserInfo中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）。</p><p>我们再进一步延伸一下。如果做这个社交产品的公司发展得越来越好，公司内部又开发出了很多其他产品（可以理解为其他App）。公司希望支持统一账号系统，也就是用户一个账号可以在公司内部的所有产品中登录。这个时候，我们就需要继续对UserInfo进行拆分，将跟身份认证相关的信息（比如，email、telephone等）抽取成独立的类。</p><p>从刚刚这个例子，我们可以总结出，不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。</p><p>除此之外，从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。比如，例子中的UserInfo类。如果我们从“用户”这个业务层面来看，UserInfo包含的信息都属于用户，满足职责单一原则。如果我们从更加细分的“用户展示信息”“地址信息”“登录认证信息”等等这些更细粒度的业务层面来看，那UserInfo就应该继续拆分。</p><p>综上所述，评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，<strong>我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构</strong>（后面的章节中我们会讲到）。</p><p>听到这里，你可能会说，这个原则如此含糊不清、模棱两可，到底该如何拿捏才好啊？我这里还有一些小技巧，能够很好地帮你，从侧面上判定一个类的职责是否够单一。而且，我个人觉得，下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：</p><ul>\n<li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</li>\n<li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</li>\n<li>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性；</li>\n<li>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰；</li>\n<li>类中大量的方法都是集中操作类中的某几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将这几个属性和对应的方法拆分出来。</li>\n</ul><p>不过，你可能还会有这样的疑问：在上面的判定原则中，我提到类中的代码行数、函数或者属性过多，就有可能不满足单一职责原则。那多少行代码才算是行数过多呢？多少个函数、属性才称得上过多呢？</p><p>比较初级的工程师经常会问这类问题。实际上，这个问题并不好定量地回答，就像你问大厨“放盐少许”中的“少许”是多少，大厨也很难告诉你一个特别具体的量值。</p><p>如果继续深究一下的话，你可能还会说，一些菜谱确实给出了，做某某菜需要放多少克盐，放多少克油的具体量值啊。我想说的是，那是给家庭主妇用的，那不是给专业的大厨看的。类比一下做饭，如果你是没有太多项目经验的编程初学者，实际上，我也可以给你一个凑活能用、比较宽泛的、可量化的标准，那就是一个类的代码行数最好不能超过200行，函数个数及属性个数都最好不要超过10个。</p><p>实际上， 从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。实际上，等你做多项目了，代码写多了，在开发中慢慢“品尝”，自然就知道什么是“放盐少许”了，这就是所谓的“专业第六感”。</p><h2>类的职责是否设计得越单一越好？</h2><p>为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。我们还是通过一个例子来解释一下。Serialization类实现了一个简单协议的序列化和反序列功能，具体代码如下：</p><pre><code>/**\n * Protocol format: identifier-string;{gson string}\n * For example: UEUEUE;{&quot;a&quot;:&quot;A&quot;,&quot;b&quot;:&quot;B&quot;}\n */\npublic class Serialization {\n  private static final String IDENTIFIER_STRING = &quot;UEUEUE;&quot;;\n  private Gson gson;\n  \n  public Serialization() {\n    this.gson = new Gson();\n  }\n  \n  public String serialize(Map&lt;String, String&gt; object) {\n    StringBuilder textBuilder = new StringBuilder();\n    textBuilder.append(IDENTIFIER_STRING);\n    textBuilder.append(gson.toJson(object));\n    return textBuilder.toString();\n  }\n  \n  public Map&lt;String, String&gt; deserialize(String text) {\n    if (!text.startsWith(IDENTIFIER_STRING)) {\n        return Collections.emptyMap();\n    }\n    String gsonStr = text.substring(IDENTIFIER_STRING.length());\n    return gson.fromJson(gsonStr, Map.class);\n  }\n}\n</code></pre><p>如果我们想让类的职责更加单一，我们对Serialization类进一步拆分，拆分成一个只负责序列化工作的Serializer类和另一个只负责反序列化工作的Deserializer类。拆分后的具体代码如下所示：</p><pre><code>public class Serializer {\n  private static final String IDENTIFIER_STRING = &quot;UEUEUE;&quot;;\n  private Gson gson;\n  \n  public Serializer() {\n    this.gson = new Gson();\n  }\n  \n  public String serialize(Map&lt;String, String&gt; object) {\n    StringBuilder textBuilder = new StringBuilder();\n    textBuilder.append(IDENTIFIER_STRING);\n    textBuilder.append(gson.toJson(object));\n    return textBuilder.toString();\n  }\n}\n\npublic class Deserializer {\n  private static final String IDENTIFIER_STRING = &quot;UEUEUE;&quot;;\n  private Gson gson;\n  \n  public Deserializer() {\n    this.gson = new Gson();\n  }\n  \n  public Map&lt;String, String&gt; deserialize(String text) {\n    if (!text.startsWith(IDENTIFIER_STRING)) {\n        return Collections.emptyMap();\n    }\n    String gsonStr = text.substring(IDENTIFIER_STRING.length());\n    return gson.fromJson(gsonStr, Map.class);\n  }\n}\n</code></pre><p>虽然经过拆分之后，Serializer类和Deserializer类的职责更加单一了，但也随之带来了新的问题。如果我们修改了协议的格式，数据标识从“UEUEUE”改为“DFDFDF”，或者序列化方式从JSON改为了XML，那Serializer类和Deserializer类都需要做相应的修改，代码的内聚性显然没有原来Serialization高了。而且，如果我们仅仅对Serializer类做了协议修改，而忘记了修改Deserializer类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。</p><p>实际上，不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们来一块总结回顾一下，你应该掌握的重点内容。</p><p><strong>1.如何理解单一职责原则（SRP）？</strong></p><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><p><strong>2.如何判断类的职责是否足够单一？</strong></p><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul>\n<li>类中的代码行数、函数或者属性过多；</li>\n<li>类依赖的其他类过多，或者依赖类的其他类过多；</li>\n<li>私有方法过多；</li>\n<li>比较难给类起一个合适的名字；</li>\n<li>类中大量的方法都是集中操作类中的某几个属性。</li>\n</ul><p><strong>3.类的职责是否设计得越单一越好？</strong></p><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><h2>课堂讨论</h2><p>今天课堂讨论的话题有两个：</p><ol>\n<li>对于如何判断一个类是否职责单一，如何判断代码行数过多，你还有哪些其他的方法吗？</li>\n<li>单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":159359,"user_name":"blacknhole","can_delete":false,"product_type":"c1","uid":1098286,"ip_address":"","ucode":"271682FFE28F25","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","comment_is_top":false,"comment_ctime":1575605963,"is_pvip":false,"discussion_count":27,"race_medal":0,"score":"1496224224971","product_id":100039001,"comment_content":"在看文末的“3. 类的职责是否设计得越单一越好？”时，我惊喜地意识到：<br><br>1，内聚和耦合其实是对一个意思（即合在一块）从相反方向的两种阐述。<br><br>2，内聚是从功能相关来谈，主张高内聚。把功能高度相关的内容不必要地分离开，就降低了内聚性，成了低内聚。<br><br>3，耦合是从功能无关来谈，主张低耦合。把功能明显无关的内容随意地结合起来，就增加了耦合性，成了高耦合。","like_count":349,"discussions":[{"author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237906,"discussion_content":"相关的“在一起”，叫内聚，不相关的“在一起”，叫耦合。","likes_number":71,"is_delete":false,"is_hidden":false,"ctime":1587196204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2833619,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","nickname":"探雪","note":"","ucode":"2332650D9C8D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":531550,"discussion_content":"牛逼的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637333244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":237906,"ip_address":""},"score":531550,"extra":"{\"user_type\":1}"}]},{"author":{"id":2628119,"avatar":"https://static001.geekbang.org/account/avatar/00/28/1a/17/9e925f61.jpg","nickname":"雾都","note":"","ucode":"198CDE0F864C77","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381143,"discussion_content":"相关的都放在一起叫高内聚，不放在一起叫低内聚；不相关的放在一起叫高耦合，不相关的不放在一起叫低耦合","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1624929874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1158109,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ab/dd/31942fb9.jpg","nickname":"Canon.Din","note":"","ucode":"2C5448AAF7CF46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2628119,"avatar":"https://static001.geekbang.org/account/avatar/00/28/1a/17/9e925f61.jpg","nickname":"雾都","note":"","ucode":"198CDE0F864C77","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":381236,"discussion_content":"哈哈不绕口, 竟然看到同一天刷这一章的伙伴","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624963143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381143,"ip_address":""},"score":381236,"extra":""},{"author":{"id":2516041,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/1UV7tTtMTM8hyvGl2YaSVczZve3e2aOcrRafvg64WQo7hYRRzGnondFElhGv0RnQZQgn6PycYzal2b5oAwYXtg/132","nickname":"太行山人","note":"","ucode":"66EB8BFD311A45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2628119,"avatar":"https://static001.geekbang.org/account/avatar/00/28/1a/17/9e925f61.jpg","nickname":"雾都","note":"","ucode":"198CDE0F864C77","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":542232,"discussion_content":"对，和我想的一样，同类的在一起叫内聚，不同类的在一起就是耦合了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640687089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381143,"ip_address":""},"score":542232,"extra":""}]},{"author":{"id":1042753,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/p6kkT7nsViayxazIrxx7p0pklPRvet933nEGBupj1phL2zArLStC3MnHFFyBYZ9fDGbPWJxS6WOICkxCCLia7nhw/132","nickname":"Qfxl","note":"","ucode":"4554F28BB10F21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109195,"discussion_content":"想法不错，个人观点补充下耦合描述模块间的关系，内聚则是单一模块","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1577673508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066102,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/76/a86cfd2a.jpg","nickname":"Akira","note":"","ucode":"A0BFD54A95012D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394501,"discussion_content":"分析的很有道理。把序列化反序列化拆开，突然对高内聚和低耦合有加深了点理解。\n拆的越单一不代表越内聚。把相关的功能放一起叫高内聚。把不相关的拆开叫低耦合","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631925874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2708697,"avatar":"","nickname":"李海龙","note":"","ucode":"766E49D0AE1434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574585,"discussion_content":"功能相关的放在一起，是内聚，不相关的放在一起，是耦合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654161115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048314,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/fa/2a046821.jpg","nickname":"人间四月天","note":"","ucode":"11BE219C23EEBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569114,"discussion_content":"一切还是看需求，看功能，看需求变化的原因，单一职责是需求变化的原因只有一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651328057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2882086,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/fa/26/a38f4b5d.jpg","nickname":"jl","note":"","ucode":"3EC1591B396600","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544764,"discussion_content":"你这写的太好了，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641701809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2833619,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","nickname":"探雪","note":"","ucode":"2332650D9C8D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531549,"discussion_content":"自古评论出人才~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637333226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294870,"discussion_content":"很明显你是从内聚要求的“高”和耦合要求的“低”的角度来分析的，还是相当片面的 duck不必","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596020555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294975,"discussion_content":"很明显你说错了，你大可不必这么自信。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1596041389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294870,"ip_address":""},"score":294975,"extra":""}]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294574,"discussion_content":"这个角度刁钻不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595930104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1785231,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3d/8f/b06ec41f.jpg","nickname":"frankieci","note":"","ucode":"0020F03AED7483","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291503,"discussion_content":"说实话，王争讲的不怎么样，讲的都是一些废话，我推荐看goF设计模式书，设计原则是诊断问题的所在用设计模式去解决，体现设计流程，不是把代码一下子粘出来，光说说就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594858894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785231,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3d/8f/b06ec41f.jpg","nickname":"frankieci","note":"","ucode":"0020F03AED7483","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291885,"discussion_content":"说实话，我可不这么认为。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1594986104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291503,"ip_address":""},"score":291885,"extra":""},{"author":{"id":2273754,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/da/5602cb4b.jpg","nickname":"king","note":"","ucode":"1E5BD0E2A789C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785231,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3d/8f/b06ec41f.jpg","nickname":"frankieci","note":"","ucode":"0020F03AED7483","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319100,"discussion_content":"说实话，我可不认为你明白了王争的意思，而你的需求可能是不一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603942508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291503,"ip_address":""},"score":319100,"extra":""},{"author":{"id":1622696,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","nickname":"一格状语","note":"","ucode":"EBA9ED5F97416D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785231,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3d/8f/b06ec41f.jpg","nickname":"frankieci","note":"","ucode":"0020F03AED7483","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339641,"discussion_content":"你给我们讲讲？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609750519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291503,"ip_address":""},"score":339641,"extra":""}]},{"author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80834,"discussion_content":"耦合不单单是功能无关吧\n比如说文中的例子UserInfo还没拆分时，当你只需要地址信息的时候，你都需要使用UserInfo来获取，每个使用地址的地方都是有UserInfo，这算不算是紧耦合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576199099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80950,"discussion_content":"耦合要单单是功能无关，王争老师也就不用说这么多了。我也没说什么“单单是”或类似的意思。\n\n我说的是耦合是：\n\n1，从功能无关的方向来谈“合在一块儿”这个意思；\n\n2，把功能“明显无关”的内容“随意地”结合起来，就会增加耦合性，“明显无关”和“随意地”当然都是基于特定的应用场景、需求背景、业务层面而言的，不然是否明显无关和随意就无法确定。\n\n最后，友善地提醒一句，你的中文阅读理解能力需要加强。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576206453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80834,"ip_address":""},"score":80950,"extra":""},{"author":{"id":1083559,"avatar":"https://static001.geekbang.org/account/avatar/00/10/88/a7/fb383ef7.jpg","nickname":"MaLu","note":"","ucode":"A5E900B6B94FB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227549,"discussion_content":"还是公司业务发展决定的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586500216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80834,"ip_address":""},"score":227549,"extra":""},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269222,"discussion_content":"大可不必","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589880946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80950,"ip_address":""},"score":269222,"extra":""}]}]},{"had_liked":false,"id":159213,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1575562688,"is_pvip":false,"discussion_count":29,"race_medal":0,"score":"405302488512","product_id":100039001,"comment_content":"1.方法就是全凭感觉。感觉不爽，就尝试着是否可以拆分多个类，感觉来了谁也挡不住。没有硬性要求吧，都是凭借经验。比如用户service可能包含用户的登录注册修改密码忘记密码等等，这些操作都需要验证邮箱，这时候你会发现这个类就很乱，就可以把他一分为二，弄个UserService再弄个UserEmailService专门处理用户相关邮件的操作逻辑，让UserService依赖Email的，等等这种，我觉得真的是全凭经验。换句话说，屎一样的代码写多了，写到自己看着都想吐的时候，经验就积累了。<br>2.方法设计上也用到了，比如自上而下的编程方式，先把核心方法定义好在去写具体细节，不要上来就把所有的细节都写到一个大而全的方法里。自上而下的编程方式他不香吗？","like_count":95,"discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73645,"discussion_content":"写好代码并不是很难，但以下几点确实不好做到。\n1.发现自己写的是一坨屎。\n2.愿意花时间去搅屎。\n3.能把屎搅干净。\n\n一部分人并发现不了自己在写一坨屎，更大一部分人知道自己写了一坨屎但不愿意花时间和精力去重构，最后只有极少一部分人能把屎重构清楚。","likes_number":50,"is_delete":false,"is_hidden":false,"ctime":1575565173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1555135,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/bf/41c7dc81.jpg","nickname":"xiaoxiunique","note":"","ucode":"87FFC2ED156593","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73654,"discussion_content":"精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575566592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73645,"ip_address":""},"score":73654,"extra":""},{"author":{"id":1603271,"avatar":"","nickname":"Geek_f3a3d1","note":"","ucode":"E15FA1C3AB3174","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114292,"discussion_content":"大部分不知道自己无知，少部分人知道了自己无知却无动于衷，极少部分人知道了自己的无知并且去努力学习弥补。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1577967502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73645,"ip_address":""},"score":114292,"extra":""},{"author":{"id":1369757,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7WkTI1IicbKvsPJng5vQh5qlrf1smbfl2zb7icHZfzcAk1k4lr8w8IDEAdrqq1NHW5XZMPXiaa1h7Jn1LGOWOCkIA/132","nickname":"早起不吃虫","note":"","ucode":"13CD3B5E1F9435","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540123,"discussion_content":"不是我拉的屎，凭啥我来擦。。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1639965098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73645,"ip_address":""},"score":540123,"extra":""}]},{"author":{"id":1053955,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","nickname":"考休","note":"","ucode":"968DFC00D6D0CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76947,"discussion_content":"用顶级开源软件的标准要求别人，用屎一样的代码标准要求自己","likes_number":23,"is_delete":false,"is_hidden":false,"ctime":1575870996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77215,"discussion_content":"一般而言，我是先在一个方法里面顺序写好具体实现，然后按照一个方法必须处于同一个逻辑层的思想，将写好的一大坨代码抽取为多个方法，然后再针对抽取出的方法继续重复上述工作。直到每个方法都只做一件事情。\n同时，在抽取函数的过程中起一个好名字！！！尽量做到代码即注释。\n最后，按照逻辑层的高低再对这些方法进行排序。从而做到从上而下，顺序读代码，不想了解细节时，不用继续读下去即可。","likes_number":17,"is_delete":false,"is_hidden":false,"ctime":1575896616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":78348,"discussion_content":"先自下而上把代码写完整，然后逐层拆分，相信很多人都是这么做的，只是应该有很多人在写完代码就完了。哈哈","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575988254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77215,"ip_address":""},"score":78348,"extra":""},{"author":{"id":1675380,"avatar":"https://static001.geekbang.org/account/avatar/00/19/90/74/a58acddb.jpg","nickname":"Hawaii","note":"","ucode":"00381E49E771E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":87572,"discussion_content":"同意，函数之间的抽象层次很重要，不同抽象层次的放在一起看起来清晰很多。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576673619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77215,"ip_address":""},"score":87572,"extra":""},{"author":{"id":1401452,"avatar":"https://static001.geekbang.org/account/avatar/00/15/62/6c/98a69882.jpg","nickname":"阿哲","note":"","ucode":"5ADFE1085054B6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":91532,"discussion_content":"感觉在说我，但是没有证据。😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576838563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78348,"ip_address":""},"score":91532,"extra":""}]},{"author":{"id":1043585,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/81/2127e215.jpg","nickname":"梦醒十分","note":"","ucode":"33830A5A73DDF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74747,"discussion_content":"你的思想很危险，记住一句话，大巧若拙，宁拙毋巧。不管你有多少经验，多少感觉，最好还是要多多思考。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575683709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043585,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/81/2127e215.jpg","nickname":"梦醒十分","note":"","ucode":"33830A5A73DDF8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74774,"discussion_content":"思考是肯定的，先凭借经验拆分，然后思考是否合适，不合适进行换档案重构，并不是说拆分完就不管了哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575686318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74747,"ip_address":""},"score":74774,"extra":""},{"author":{"id":1043585,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/81/2127e215.jpg","nickname":"梦醒十分","note":"","ucode":"33830A5A73DDF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74781,"discussion_content":"话有说的不对的地方，望多多海涵!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575686739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74774,"ip_address":""},"score":74781,"extra":""}]},{"author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77218,"discussion_content":"顺序写好，再进行抽取的方式。可以少写很多方法定义，编译器直接生成，很方便。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575896701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476490,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/8a/07ab933c.jpg","nickname":"璀璨星空","note":"","ucode":"CE6324C4261A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371188,"discussion_content":"实不相瞒，现在我看自己写的就是一坨shit","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1619681785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2088626,"avatar":"","nickname":"志江","note":"","ucode":"8A07D53769B3C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1476490,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/8a/07ab933c.jpg","nickname":"璀璨星空","note":"","ucode":"CE6324C4261A52","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381339,"discussion_content":"哈哈, 挺好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625018327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371188,"ip_address":""},"score":381339,"extra":""}]},{"author":{"id":2071327,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9b/1f/9f3379d3.jpg","nickname":"Geek_7f21d2","note":"","ucode":"12204FDAD951BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297535,"discussion_content":"谷歌员工来给你点个赞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596961905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049741,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","nickname":"weineel","note":"","ucode":"6DC6EF4F256A53","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74209,"discussion_content":"我是先写一个大而全的方法，然后拆。这样写的更快，少了设计，多了重构。缺点是没有设计的过程，容易拆的不伦不类。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575639187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1049741,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","nickname":"weineel","note":"","ucode":"6DC6EF4F256A53","race_medal":2,"user_type":1,"is_pvip":true},"discussion":{"id":74576,"discussion_content":"可以尝试下自上而下式的编程","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575646920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74209,"ip_address":""},"score":74576,"extra":""},{"author":{"id":2088626,"avatar":"","nickname":"志江","note":"","ucode":"8A07D53769B3C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381340,"discussion_content":"自上而下的设计好多都不会, 感觉会了这个才算有了基本的软件编程思想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625018430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74576,"ip_address":""},"score":381340,"extra":""}]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74057,"discussion_content":"什么叫自上而下的编程? 是面向原型图编程么? ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575626814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74076,"discussion_content":"先定义方法，后实现细节","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575628414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74057,"ip_address":""},"score":74076,"extra":""},{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77058,"discussion_content":"先把需求定义成interface，再考虑实现。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575885475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74057,"ip_address":""},"score":77058,"extra":""},{"author":{"id":1033096,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","nickname":"如来神掌","note":"","ucode":"45E20FF935BD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278013,"discussion_content":"面向接口编程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591143805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74057,"ip_address":""},"score":278013,"extra":""}]},{"author":{"id":2667912,"avatar":"https://static001.geekbang.org/account/avatar/00/28/b5/88/9b65e31c.jpg","nickname":"Y          X","note":"","ucode":"C9926CA7510F3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399588,"discussion_content":"有点理解接口和抽象类的作用了。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632998371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159338,"user_name":"Luciano李鑫","can_delete":false,"product_type":"c1","uid":1329995,"ip_address":"","ucode":"5FBE5F86FD5B2C","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","comment_is_top":false,"comment_ctime":1575601569,"is_pvip":false,"replies":[{"id":"61135","content":"我推荐持续重构，不推荐等到代码烂到一定程度之后的大刀阔斧的重构。持续重构就像开发一样，是开发的一部分，所以也不存在额外的测试、发布成本之说，你就当成开发来看就行了。后面会讲到重构，你到时候再看下是否还有疑问。","user_name":"作者回复","comment_id":159338,"uid":"1190123","ip_address":"","utype":1,"ctime":1575896920,"user_name_real":"王争"}],"discussion_count":11,"race_medal":0,"score":"263568606625","product_id":100039001,"comment_content":"想请教一下争哥，关于代码代码持续重构的问题，所引出的额外测试、发布成本，和故障风险应该怎样平衡呢。","like_count":61,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477017,"discussion_content":"我推荐持续重构，不推荐等到代码烂到一定程度之后的大刀阔斧的重构。持续重构就像开发一样，是开发的一部分，所以也不存在额外的测试、发布成本之说，你就当成开发来看就行了。后面会讲到重构，你到时候再看下是否还有疑问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1625233,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","nickname":"CoderArthur","note":"","ucode":"5B591914F0F67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":576261,"discussion_content":"有一种情况：发布V1.0，该版支持产品A、B、C。进行V2.0的时候，支持D、E、F产品，同时进行了重构，该重构影响到了A、B、C代码。产品A、 B、C的代码是单独作为project来管理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655380029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":477017,"ip_address":""},"score":576261,"extra":""}]},{"author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74912,"discussion_content":"个人觉得对于有代码洁癖又担心责任的群体，可通过工具支撑，流程完善（代码review等）两方面去解决。这种属于万事开头难，重点要看自动化测试运维基础设施是否完善。公司要是没准备好，自己又没能力推动的情况下，可以在适当时机做一下重构，把重构技巧的锻炼过程放到开源项目上。自动化测试报告工具（jcoco，maven,Grade都有集成，还可以集成到自动化运维平台）。灰度发布、某某发布、自动化测试、持续集成等等就是为了解决版本发布验证困难、增加额外工作量等问题提出来的。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575705399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1329995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","nickname":"Luciano李鑫","note":"","ucode":"5FBE5F86FD5B2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76287,"discussion_content":"的确是需要工具支撑，持续化集成、自动化测试、代码覆盖率测试、灰度发布这些配套设施要完整 才敢对核心业务重构 毕竟很多企业级的项目稳的服务于业务才是其本质。很多设计很大流水或者极其核心的业务都是牵一发而动全身。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575814689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74912,"ip_address":""},"score":76287,"extra":""},{"author":{"id":1117318,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","nickname":"花花大脸猫","note":"","ucode":"8ABDB3F7F4FB0F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":95786,"discussion_content":"其实有时候都太过理想化，换位思考站在资本家的角度，资本家要的结果就是有效率的完成，尤其是有竞争对手的时候，而对于代码持续重构来说，往往会拉长实际的项目周期，在绝大多数场景下，疲于开发的周期而不是代码洁癖（毕竟这只是少数人拥有的想法），而真正这个时候，重构的工作其实是很难展开的，就算后续接入的需求跟之前实际的设计相悖或者已经不满足实际场景，大部分情况下的选择都是继续选择开发，做少许小范围内的优化，当一个周期开发结束之后，这个产品为了稳定，反而是不会进行大量的重构的，所以现实往往是有悖于理想的，毕竟业务先行，业务都活不下去何来的技术重构","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1577026984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74912,"ip_address":""},"score":95786,"extra":""},{"author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1117318,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","nickname":"花花大脸猫","note":"","ucode":"8ABDB3F7F4FB0F","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":96296,"discussion_content":"先不说资本家咋滴，国内大多数程序员都还是面向工资编程，能学到写代码艺术的寥寥无几，亚美利坚以及欧洲能有这么多代码艺术家是建立在以前多年的资本（储蓄）积累的基础上的。我们来这边学习就是为了提升自己的单位产能，并不是为了资本家，虽然资本家也间接因此获益更多了，但做这事是双赢的。但程序员自己的能力提升后，比较苛刻的那种资本家就没法对你说三道四了，这样的程序员是此处不留爷，自有留爷处。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1577056889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":95786,"ip_address":""},"score":96296,"extra":""}]},{"author":{"id":1540413,"avatar":"https://static001.geekbang.org/account/avatar/00/17/81/3d/3c9f1c43.jpg","nickname":"V -Promise゜ 🔝","note":"","ucode":"14A3D2C8E838CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74107,"discussion_content":"选择好重构的时机，一般改动需求修改bug都可以进行重构","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575631106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73983,"discussion_content":"这个问题可以从是否是核心功能来考虑嘛，如果是核心功能，重构的代价应该是值得的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575620141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475866,"avatar":"https://static001.geekbang.org/account/avatar/00/16/85/1a/fc016813.jpg","nickname":"萧潇","note":"","ucode":"1FA83092845507","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384781,"discussion_content":"重构都是主张小步快跑的原则吧 不会一下全推到重来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626749874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063308,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","nickname":"小乙哥","note":"","ucode":"C77E79BEA0C325","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132279,"discussion_content":"那假如是接手的历史烂代码了？怎么持续重构？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578893977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159290,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1575595640,"is_pvip":true,"discussion_count":10,"race_medal":0,"score":"173374287480","product_id":100039001,"comment_content":"懂几个设计模式，只是花拳绣腿。掌握设计原则就才掌握了“道”。<br><br>设计你的系统，使得每个模块负责（响应）只满足一个业务功能需求。<br>Design your systems such that each module is responsible (responds to) the needs of just that one business function. (Robert C. Martin)<br><br>参考：https:&#47;&#47;blog.cleancoder.com&#47;uncle-bob&#47;2014&#47;05&#47;08&#47;SingleReponsibilityPrinciple.html","like_count":40,"discussions":[{"author":{"id":1450519,"avatar":"https://static001.geekbang.org/account/avatar/00/16/22/17/cef62ce2.jpg","nickname":"KKW","note":"","ucode":"E970CE4BE08626","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96656,"discussion_content":"剑圣独孤求败的绝招是什么，没有招，无招胜有招。就算不知道设计模式，如果理解了设计原则，也能写出高内聚，低耦合的好代码，设计模式只是前人把优化过程中常见的问题和解决方法加以总结，方便后人参考而已。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1577084559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1450519,"avatar":"https://static001.geekbang.org/account/avatar/00/16/22/17/cef62ce2.jpg","nickname":"KKW","note":"","ucode":"E970CE4BE08626","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96662,"discussion_content":"大侠，精辟！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577084884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96656,"ip_address":""},"score":96662,"extra":""},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1450519,"avatar":"https://static001.geekbang.org/account/avatar/00/16/22/17/cef62ce2.jpg","nickname":"KKW","note":"","ucode":"E970CE4BE08626","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281658,"discussion_content":"大侠","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591786900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96656,"ip_address":""},"score":281658,"extra":""}]},{"author":{"id":1254367,"avatar":"https://static001.geekbang.org/account/avatar/00/13/23/df/367f2c75.jpg","nickname":"🌀🐑hfy🐣","note":"","ucode":"8A7E4BDC46CB35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122580,"discussion_content":"个人也认为设计模式是六大原则的具体表现","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578362207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291320,"discussion_content":"他这篇文章跟他那本架构整洁之道里讲的一模一样,对单一职责最精确的描述就是一句话:把因为相同原因变化的内容放在一起,因为不同原因变化的内容拆开,单看这句话或者他的书还是太抽象了,还是先看老师的这篇专栏更容易入门","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594779089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004758,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/d6/124e2e93.jpg","nickname":"Calios","note":"","ucode":"B1AA60164DC42A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183138,"discussion_content":"又看到你了，每次都能收获一篇经典参考文章。。。🤣","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582468376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2828609,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/29/41/371c3b77.jpg","nickname":"神经蛙vx qingtian01266","note":"","ucode":"83C047B851E23D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532993,"discussion_content":"赞同。掌握设计模式 = 花拳绣腿，掌握设计原则 = 掌握了“道”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637748751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384026,"discussion_content":"大侠!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626338690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122408,"discussion_content":"收下我的膝盖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578357430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122597,"discussion_content":"把膝盖给uncle bob吧🤣，我只是他的迷弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578362746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":122408,"ip_address":""},"score":122597,"extra":""}]}]},{"had_liked":false,"id":168994,"user_name":"一壶浊酒","can_delete":false,"product_type":"c1","uid":1145530,"ip_address":"","ucode":"5D90F8F8121BBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/ba/8545f2d7.jpg","comment_is_top":false,"comment_ctime":1578234370,"is_pvip":true,"replies":[{"id":"65955","content":"数据库跟业务代码的设计不是强耦合的。不然，对业务代码进行重构，那数据库还得跟着改，谁还敢重构啊。<br><br>不管userinfo是否有address的信息，我们都可以转化成数据库想要的数据格式，再一次性地写入到数据库中。<br><br>userinfo是否包含address的信息？理论上，既然已经拆出来了，职责单一了，就不必要包含了。","user_name":"作者回复","comment_id":168994,"uid":"1190123","ip_address":"","utype":1,"ctime":1578489862,"user_name_real":"王争"}],"discussion_count":4,"race_medal":0,"score":"160492024322","product_id":100039001,"comment_content":"老师您好，有个问题想请教下，就是您举的UserInfo的例子，在抽取了地址相关的信息到新的类的时候，原来的userinfo类中需要再添加一个新的类的属性在里面么？感觉如果根据单一职责原则了话，新的类应该独立出来，UserInfo里应该不包含该类，那在这种情况下数据库的表一般会出现变化么？不然是否会造成一个新增的用户会在保存用户信息的时候对数据库进行两次操作？一次新增用户信息，然后获取了userId再进行一次操作修改地址相关信息？还是说在userinfo中存在新的地址相关类的属性，进行直接新增操作？因为没有这方面的实际经验，所以对这个比较疑惑。老师遇到这种情况一般作何处理","like_count":38,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480396,"discussion_content":"数据库跟业务代码的设计不是强耦合的。不然，对业务代码进行重构，那数据库还得跟着改，谁还敢重构啊。\n\n不管userinfo是否有address的信息，我们都可以转化成数据库想要的数据格式，再一次性地写入到数据库中。\n\nuserinfo是否包含address的信息？理论上，既然已经拆出来了，职责单一了，就不必要包含了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578489862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2128021,"avatar":"https://static001.geekbang.org/account/avatar/00/20/78/95/d3378237.jpg","nickname":"一点","note":"","ucode":"2895B57BAD9D2D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309614,"discussion_content":"新增用户信息的时候，可以调用用户实体类和地址实体类，一并插入数据库中的一张表，这样就无需改动表结构了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601366047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1622696,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","nickname":"一格状语","note":"","ucode":"EBA9ED5F97416D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2128021,"avatar":"https://static001.geekbang.org/account/avatar/00/20/78/95/d3378237.jpg","nickname":"一点","note":"","ucode":"2895B57BAD9D2D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413043,"discussion_content":"是拆BO类吗？Entity不能拆吧！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636370247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309614,"ip_address":""},"score":413043,"extra":""}]},{"author":{"id":1622696,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","nickname":"一格状语","note":"","ucode":"EBA9ED5F97416D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413042,"discussion_content":"拆是拆的UserInfoBO类吗？拆出一个UserAddressBO。UserInfoEntity应该是和表字段一一对应的类，这个不能拆吧。新增的时候，将2个BO转成1个UserInfoEntity，然后插入。不知道是不是这样，如果把Entity都拆成2个类了，那持久层的DML语句不也得跟着变么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636370132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160107,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1575871366,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"113245021062","product_id":100039001,"comment_content":"项目初始阶段也是雄心勃勃，要把系统做出一个快速迭代、维护性高的系统，可是不断的需求变更导致开发任务过重，留给项目整体的思考和重构时间被严重压缩，最终导致项目的技术管理失控，再加上人员变动等原因，项目死亡的概率急剧上升，都是惨痛的教训。<br><br>《三体》中常伟思的父亲经常说的是：要多想。<br><br>共勉！","like_count":27,"discussions":[{"author":{"id":1734795,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/8b/421cb2c4.jpg","nickname":"成活","note":"","ucode":"F8840EE4DC3969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212075,"discussion_content":"是章北海的父亲。。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1584931612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384027,"discussion_content":"停止 胡思乱想!","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626338863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239462,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e9/a6/69907ec1.jpg","nickname":"李伟","note":"","ucode":"F0EF60EB250B20","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409598,"discussion_content":"章北海的父亲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635471941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2319435,"avatar":"https://static001.geekbang.org/account/avatar/00/23/64/4b/f27d43fd.jpg","nickname":"大漠客栈","note":"","ucode":"85DA7470E0ABCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334690,"discussion_content":"我们的项目就是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607937936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207410,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","nickname":"紫日","note":"","ucode":"73A8DEE323AC19","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317194,"discussion_content":"在有限情况下想的越多，之后才有可能更从容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603514006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159247,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1575591854,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"87474937774","product_id":100039001,"comment_content":"回答问题<br>1. 类单一职责判断可以通过评估其对外提供接口是否满足不断变化的业务和需求来确定！问自己，该类是否对其他类是&quot;黑盒&quot;！<br><br>2. 类行数多=属性多+方法多<br>属性多: 要考虑这些属性是不是对类来说是必须的，需要移除么？<br>方法多: 方法间复用情况，方法间有没有写重复代码？<br>如上如果觉得没有可以改进的余地，就可以认为类行数恰当！<br><br>3. 单一职责还可以应用到方法，模块，功能点上！","like_count":21,"discussions":[{"author":{"id":1027203,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/83/4c1a18de.jpg","nickname":"🐻🐻","note":"","ucode":"424120B74390CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290219,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594380324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159219,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1575565937,"is_pvip":false,"replies":[{"id":"61142","content":"哈哈，写注释不是挺好的吗？我后面讲到编程规范的时候会详细讲如何写注释的。","user_name":"作者回复","comment_id":159219,"uid":"1190123","ip_address":"","utype":1,"ctime":1575897742,"user_name_real":"王争"}],"discussion_count":12,"race_medal":0,"score":"61705108081","product_id":100039001,"comment_content":"回答问题：<br>1.不好说，职责单一这东西比较主观。得看自己对抽象出来的类的主观定义是什么。准的捏不住，但还是要把控一下范围的。<br>2.码出高效给出了方法行数不超过50行的一个基准标注。而我实践下来很难写出超过50行的方法，这50行还包括了大量注释。<br><br>3.方法的职责单一，业务领域的能力要单一（边界清晰）。<br><br>提问：<br><br>1.以前不代码规范不行，就逼着自己多思考，多写注释。现在养成了写注释的洁癖，不写就很难受。请问大佬，这怎么办，需要戒掉吗。我除了dao层的crud和数据类的setget外，其余方法都会带上注释。","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476986,"discussion_content":"哈哈，写注释不是挺好的吗？我后面讲到编程规范的时候会详细讲如何写注释的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220185,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/59/63710205.jpg","nickname":"陈胜华","note":"","ucode":"DCD7EED2E5544E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73697,"discussion_content":"能用函数名，变量名解释清楚的，就少用注释吧。很多时候改了代码忘改注释，是很蛋疼的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575590024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1220185,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/59/63710205.jpg","nickname":"陈胜华","note":"","ucode":"DCD7EED2E5544E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73747,"discussion_content":"顶层方法，基本无法用方法名解释清楚的。聚合太多逻辑。  但大量注释，后期其他人维护会成问题，我担心的就是你说的这个。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575593739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73697,"ip_address":""},"score":73747,"extra":""}]},{"author":{"id":1102102,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/16/3b3f03c8.jpg","nickname":"天津古董","note":"","ucode":"2F81F0D0E0864A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73777,"discussion_content":"用函数名代替注释，需要这注释，就说明方法需要拆分了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575595845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570984,"discussion_content":"我发现我也有这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652019697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415598,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/ee/d6ea437d.jpg","nickname":"芳芳 - Claire","note":"","ucode":"E8D67858B23D01","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412065,"discussion_content":"看过clean code里面提到方法名尽量的明确，写代码和写文章有类似之处，读你代码的人，一看方法名就立刻明白你要干什么，可以避免很多的注解，可以试试有没有帮助","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636073871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336234,"discussion_content":"我也有点这毛病","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608536831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73784,"discussion_content":"顶层路由或顶层聚合，你是怎么拆的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575596189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1094597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","nickname":"Liam","note":"","ucode":"1D15D3B64F2606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73719,"discussion_content":"好习惯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575592475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1449072,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/70/e4e02e84.jpg","nickname":"平凡世界","note":"","ucode":"7820CC3BD329A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73702,"discussion_content":"不超过50行? 业务逻辑都这么简单么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575590749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1449072,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/70/e4e02e84.jpg","nickname":"平凡世界","note":"","ucode":"7820CC3BD329A4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73746,"discussion_content":"多思考，多封装。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575593624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73702,"ip_address":""},"score":73746,"extra":""},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532129,"discussion_content":"复杂业务，use  case 不止","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637543142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73746,"ip_address":""},"score":532129,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":165793,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1577323503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48821963759","product_id":100039001,"comment_content":"What<br><br>一个函数、类、模块只负责完成一个职责或者功能。<br><br>How<br><br>关于如何使用这个原则，不同的应用场景、需求背景、业务，对一个类职责是否单一，会有不同的判定结果。<br><br>这个说法其实很模糊，并没有多少实践上的指导意义。<br><br>定义中也存在令人迷惑的点，类由函数构成，模块由类构成（面向对象领域），如果每个函数职责单一，多个职责单一的功能函数组成一个类，那么这个类还算职责单一吗？<br><br>这里的区别在于看待职责单一的抽象维度不同，也称为职责颗粒度。<br><br>比如在函数的维度，在一个 getter 方法，只返回用户名，它是职责单一的；在用户类的维度，它还可以包含返回手机号的 getter 方法。<br><br>类也是有颗粒度的。以文中用户信息类为例，什么时候地址信息应该被作为单独类存在呢？我的结论是存在被复用的场景。<br><br>在初次设计时，可能并没有复用场景，那么都写在一个类里满足业务需求完全没问题。<br><br>但随着需求的发展，类中代码量膨胀，我们就需要根据复用性来对类进行拆分，此时单一职责原则可以作为一个指导思想。<br><br>过度使用单一职责<br><br>在设计时也不要过度使用单一职责原则，它会使得功能点不够内聚，增加维护成本。如果一个类，始终是作为整体被使用，即使它包含多种功能，放一起也可以。<br><br>当我们只想使用类的某一部分功能，又觉得其它功能鸡肋的时候，再考虑拆分也不迟。<br><br>Why<br><br>单一职责原则，是前辈在代码时间中的经验，将某一类经验抽象为这个名字。这个原则主要目的是为了，实现高内聚、低耦合、提高代码的复用性、可读性、可维护性。","like_count":11},{"had_liked":false,"id":159234,"user_name":"Chen","can_delete":false,"product_type":"c1","uid":1503113,"ip_address":"","ucode":"C1128558AB5BC4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/89/8c73a24d.jpg","comment_is_top":false,"comment_ctime":1575589878,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"44525262838","product_id":100039001,"comment_content":"Android里面Activity过于臃肿会让感觉很头大，MVP,MVVM等框架都是为了让Activity变得职责单一。","like_count":10,"discussions":[{"author":{"id":1366402,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIFicK7Bn88Lqte7rURlw3Lf53oAu1jhiciaVlKLib48dlIAOAF03L7tjQcx1ia5AJI26S7HIxwx780Qzw/132","nickname":"操盘手爱德华","note":"","ucode":"CAAF3E6DC9D5FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74897,"discussion_content":"MVP和MVVM不是框架，Activity的臃肿也不是Activity本身的问题。MVP和MVVM也不是为了让Activity职责单一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575702749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1734795,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/8b/421cb2c4.jpg","nickname":"成活","note":"","ucode":"F8840EE4DC3969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1366402,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIFicK7Bn88Lqte7rURlw3Lf53oAu1jhiciaVlKLib48dlIAOAF03L7tjQcx1ia5AJI26S7HIxwx780Qzw/132","nickname":"操盘手爱德华","note":"","ucode":"CAAF3E6DC9D5FD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212082,"discussion_content":"我理解的，MVP和MVVM算是一种约定，或者说架构？后面两句话就不是很理解了，请赐教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584932195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74897,"ip_address":""},"score":212082,"extra":""}]},{"author":{"id":1457464,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3d/38/6f02a4b9.jpg","nickname":"your problem？","note":"","ucode":"6E096E7958CFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73850,"discussion_content":"iOS开发也有同样的问题，Controller过大，各种架构MVC，VIPER实际上也是为了解决这个问题，最近准备研究响应式编程和函数式编程，不知道能不能缓解这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575601301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160234,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1575895853,"is_pvip":false,"replies":[{"id":"61137","content":"一个service当然可以有多个方法了，只要方法都是一个业务领域的，没有明显违背SRP，实际上都是合理的。","user_name":"作者回复","comment_id":160234,"uid":"1190123","ip_address":"","utype":1,"ctime":1575897239,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"40230601517","product_id":100039001,"comment_content":"有个问题，比如有个OrderService中可能提供了各种订单查询、操作等，即一个OrderService有多个方法，是否符合SRP呢？","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477307,"discussion_content":"一个service当然可以有多个方法了，只要方法都是一个业务领域的，没有明显违背SRP，实际上都是合理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005030,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","nickname":"GeekAmI","note":"","ucode":"232C0B6DFB9F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310247,"discussion_content":"按照CQRS原理，操作和查询可以分离出来，甚至可以放到不同的项目里。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601708094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1202160,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/f0/f6155d5f.jpg","nickname":"新生\\","note":"","ucode":"212978C88E242E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005030,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","nickname":"GeekAmI","note":"","ucode":"232C0B6DFB9F56","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573688,"discussion_content":"cqrs是什么呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653604318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310247,"ip_address":""},"score":573688,"extra":""}]}]},{"had_liked":false,"id":159339,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1575601589,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35935339957","product_id":100039001,"comment_content":"因为学习设计模式，前几天刚和朋友在聊，说其实每个类的代码行数和函数的行数最好都需要控制下，能精简就精简，完成我们理解的重构。<br><br>刚好，今天就看到老师说的这个，赶紧分享给朋友，盛赞了这门课，哈哈","like_count":8},{"had_liked":false,"id":159280,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1575594460,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"31640365532","product_id":100039001,"comment_content":"我有个问题，就用户地址的设计来说，后续功能扩大再拆解是不是违反了开闭原则呢？而且后期拆分会比较影响现有业务逻辑吧，这个如何平衡呢？","like_count":7,"discussions":[{"author":{"id":1609964,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","nickname":"拂尘","note":"","ucode":"9563C002E4B06A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74020,"discussion_content":"所以，后面说的是重构吧。。。重构和修改应该不一样吧 ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575624106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437667,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ef/e3/db895077.jpg","nickname":"流放","note":"","ucode":"21E30A37E7F139","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74175,"discussion_content":"这个就是过度设计的把握范畴了吧。刚开始的时候，粗颗粒度是不会说要满足所有设计原则的。在后续业务扩大重构的时候，也是业务更加定型的时候.再去满足，应该是更合理的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575636299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78329,"discussion_content":"持续重构，作为开发的一部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575987889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73986,"discussion_content":"你说的有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575620437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159233,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1575589581,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31640360653","product_id":100039001,"comment_content":"单一职责原则也可以用在服务上的拆分上","like_count":7,"discussions":[{"author":{"id":2319435,"avatar":"https://static001.geekbang.org/account/avatar/00/23/64/4b/f27d43fd.jpg","nickname":"大漠客栈","note":"","ucode":"85DA7470E0ABCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334691,"discussion_content":"共识，而且划分的服务更优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607938013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163930,"user_name":"爱水人家","can_delete":false,"product_type":"c1","uid":1730305,"ip_address":"","ucode":"0C94C6ACBC9CEB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/67/01/44626cb9.jpg","comment_is_top":false,"comment_ctime":1576830281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27346634057","product_id":100039001,"comment_content":"个人感觉码代码就像语文中的写文章，而设计原则就像一条条需要考虑的原则。用好了这些原则我们就可以写出好的文章。文章写多了，心得体会出来了，设计原则就熟门熟路了。<br>感觉在没学这些原则之前，都能感觉到自己码的代码布局有问题。学了之后，更能知道问题在哪里了，需要怎么修改了！","like_count":6},{"had_liked":false,"id":207843,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1587196212,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"23062032692","product_id":100039001,"comment_content":"相关的“在一起”，叫内聚，不相关的“在一起”，叫耦合。","like_count":5},{"had_liked":false,"id":169717,"user_name":"刘学习来学习","can_delete":false,"product_type":"c1","uid":1464013,"ip_address":"","ucode":"5078B1EC8D8A66","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/cd/0add8290.jpg","comment_is_top":false,"comment_ctime":1578411227,"is_pvip":false,"replies":[{"id":"65946","content":"后面facade设计模式会讲到你的问题","user_name":"作者回复","comment_id":169717,"uid":"1190123","ip_address":"","utype":1,"ctime":1578489175,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"23053247707","product_id":100039001,"comment_content":"前段时间需要对外提供sdk,最开始的设计就是根据职责定义了多个client对象供其他系统调用，后来角色不是很友好，最后还是提供了个聚合类，将所有的接口都集中到一起对外提供了,像这种情况,有的时候不知道该参考什么来设计","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480689,"discussion_content":"后面facade设计模式会讲到你的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578489175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159623,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1575708228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18755577412","product_id":100039001,"comment_content":"设计模式_15<br># 作业：<br>单一职责也可以用于方法的编写，在维护多年的项目中，我们会看到一些非常“庞大”的方法，这些方法的功能比它的命名丰富很多，它是一次次地改成了这个样子。本来是一个职责单一的简单方法，由于需求的变化，可能是方法被调用太多(不敢改)，也可能是框架设计(不能改)导致只能在方法内部添加特殊业务的判断条件，这样下来，这个方法就变得难以理解且难以维护。<br><br># 感想<br>同事们也常讨论单一职责的边界, 始终没有一致的结论。今天的内容也坚定了观点，业务的发展一定程序决定了耦合的边界。<br>我们学习前人总结的这些原则，目的是什么呢，我今天的感受是，系统性地降低工作量和出错概率。<br>- 降低工作量：我们要尽量保证，随着需求的增加，工作量的增加是线性的，而不是指数级的。据我了解，维护一些老代码的同学们，一直被产品同事质疑：就这么点功能，要做这么久吗？？？<br>- 降低出错概率：就像文中的序列化的例子，强行把序列化与反序列化方法拆开，会导致使用者需要花更多的时间来做一些同步的工作，如果文档不够清晰，或者阅读文档不够仔细，就会导致出错；有这样代码结构的系统，运行足够长的时间，一定会出更多的错误。","like_count":4},{"had_liked":false,"id":159255,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1575592509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18755461693","product_id":100039001,"comment_content":"打卡✔<br>安装ali规范插件，看到报警告的就按照规范修改，不过这个规范是死的，有时候和实际应用不同，不过大部分规范还是可以遵循的","like_count":4},{"had_liked":false,"id":204856,"user_name":"空也空","can_delete":false,"product_type":"c1","uid":1073533,"ip_address":"","ucode":"56976779192E02","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/7d/1bd071ba.jpg","comment_is_top":false,"comment_ctime":1586482817,"is_pvip":false,"replies":[{"id":"87069","content":"你这个问题确实是个好问题，我想想~","user_name":"作者回复","comment_id":204856,"uid":"1190123","ip_address":"","utype":1,"ctime":1595208143,"user_name_real":"王争"}],"discussion_count":4,"race_medal":0,"score":"14471384705","product_id":100039001,"comment_content":"“私有方法过多”为什么作为一个衡量标准呢？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491307,"discussion_content":"你这个问题确实是个好问题，我想想~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595208143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125119,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/ff/aac2a672.jpg","nickname":"上酒馆复活","note":"","ucode":"CEA9276D376238","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347784,"discussion_content":"老板，想好了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612319743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336235,"discussion_content":"多了看着不爽然后就拆分出来，我就是这样干的，说不出来为什么。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608536957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294581,"discussion_content":"说明这个类内使用，从某些当面说就是内聚性强","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595931442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242653,"user_name":"超越自我","can_delete":false,"product_type":"c1","uid":2130462,"ip_address":"","ucode":"8A55D972EEFADA","user_header":"https://static001.geekbang.org/account/avatar/00/20/82/1e/f3cb3d57.jpg","comment_is_top":false,"comment_ctime":1597805229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10187739821","product_id":100039001,"comment_content":"一生二，二生三，三生万物。万物生发过程必然是一个拆分的过程。拆是为了高纬度的合。类的拆分，微服务的拆分，负载均衡，读写分离，分库分表，分布式系统；细胞分裂，大树开枝散叶，羊群壮大;公司部门划分；百家姓,多民族,一国两制等等。这些拆分的个体都是服务于高纬度的整体。当然这个拆要有度，要遵守自然规律，历史大势，不能违背。度很关键。<br>","like_count":2},{"had_liked":false,"id":234564,"user_name":"润！","can_delete":false,"product_type":"c1","uid":1237696,"ip_address":"","ucode":"13B7C23B5F6B24","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/c0/09cef977.jpg","comment_is_top":false,"comment_ctime":1594720550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10184655142","product_id":100039001,"comment_content":"课程讲得是真的不错，值得购买","like_count":2},{"had_liked":false,"id":228633,"user_name":"Carlos","can_delete":false,"product_type":"c1","uid":1143912,"ip_address":"","ucode":"687CD9CA3E7C9B","user_header":"https://static001.geekbang.org/account/avatar/00/11/74/68/3725546b.jpg","comment_is_top":false,"comment_ctime":1592759002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10182693594","product_id":100039001,"comment_content":"1、判断类职责是否单一，其实有个挺客观的方法就是，如果类的对象在现有系统中任何一个地方出现都会带上，或者隐性带上所有的属性，那么这个类的职责就是单一。以用户类为例，系统中凡是出现用户的地方，都应显示，或者隐性显示出用户姓名、性别、年龄、地址等这些属性，那么这个类职责就是单一的；如果有些场景只强调带上用户账号密码，有些场景只强调带上用户地址信息，如果出现了其他更为详细的信息功能就错误了，那么这个类就需要拆分了。如果设计者依然要站在用户类这个角度将他们组织在一起，首先违背了接口隔离的原则，其次这样的类后期BUG产生几率也高了，因为有好多不相干场景都要来修改同一个类。<br>2、单一职责除了应用到类的设计上外，其实软件系统设计的方方面面都要应用代单一职责，包括模块设计呀，前端组件设计等，所有设计中，如果把多个不相干的东西放到一个，都会带来上面提到的问题，但如果将原本就是一个整体的东西拆分了，也会带来问题，假如以人这个对象来说，客观世界中一个健全的人都包括五官和四肢，如果映射到程序对象中，将他们拆开了，或者少了个部件，首先和客户世界不符了，其次也为后期其他同事的理解和维护带来了困难。","like_count":2},{"had_liked":false,"id":159661,"user_name":"Cris","can_delete":false,"product_type":"c1","uid":1473520,"ip_address":"","ucode":"F8A287134F1078","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/f0/269139d5.jpg","comment_is_top":false,"comment_ctime":1575722406,"is_pvip":false,"replies":[{"id":"61128","content":"这两个没有关系的，你可以看下spring的aop","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1575896384,"ip_address":"","comment_id":159661,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10165656998","product_id":100039001,"comment_content":"老师，我今天听到了一个概念叫面向切片编程(aop)，它和面向对象编程有什么联系呢？想听听老师的理解","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477136,"discussion_content":"这两个没有关系的，你可以看下spring的aop","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99251,"discussion_content":"这个我可以回答你，aop是为了解决oop不能横向扩展问题，aop也是个思想，其实现方式是代理模式","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577197847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119301,"discussion_content":"面相切面。以及面相元编程。也可以说是一种设计模式不在23中之内的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578225784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289751,"user_name":"等等 女皇","can_delete":false,"product_type":"c1","uid":1549661,"ip_address":"","ucode":"81423644144550","user_header":"https://static001.geekbang.org/account/avatar/00/17/a5/5d/22829a03.jpg","comment_is_top":false,"comment_ctime":1619164598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5914131894","product_id":100039001,"comment_content":"1、相关的“在一起”，不相关的”不在一起“。这样职责单一，叫高内聚。 <br><br>2、相关的没有”在一起“，不相关的”在一起“了。导致相互依赖多，直接导致”低内聚，高耦合“。<br><br>3、相关还是不相关，在一起还是不在一起。比如从功能相关来谈，主张高内聚，当然也可以根据功能相关程度强弱来选择继续内聚还是拆开（useinfo、Serializer的例子）。至于耦合，一般内聚做好了，耦合也会降低了。（比如第一点做好了，第二点就不会出现）","like_count":1},{"had_liked":false,"id":229366,"user_name":"杨锋","can_delete":false,"product_type":"c1","uid":1283461,"ip_address":"","ucode":"85A7828A538FB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","comment_is_top":false,"comment_ctime":1592976522,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5887943818","product_id":100039001,"comment_content":"三层架构，每个数据库表对应一个dao,service。其实职责已经很单一了。最大的问题可能就是service层写逻辑的时候会把很多不想干的业务写到一起。然后数据库表的设计也可以细分职责。","like_count":1},{"had_liked":false,"id":167677,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1577892237,"is_pvip":false,"replies":[{"id":"65094","content":"没太看懂你说的😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1577931967,"ip_address":"","comment_id":167677,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5872859533","product_id":100039001,"comment_content":"小争哥, 数据库设计是不是不太适合设计那种抽象类的数据库表结构, 这样我写bo就会就会维护的很大很大","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479940,"discussion_content":"没太看懂你说的😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577931967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033096,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","nickname":"如来神掌","note":"","ucode":"45E20FF935BD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278026,"discussion_content":"同类的可以抽象，通过类型判断，不同类的一定不要抽奖，否则使用时真的很累","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591145017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160468,"user_name":"bboy孙晨杰","can_delete":false,"product_type":"c1","uid":1178683,"ip_address":"","ucode":"D7389FB3368749","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/3b/c6b5b64f.jpg","comment_is_top":false,"comment_ctime":1575957103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870924399","product_id":100039001,"comment_content":"在数据库表设计的时候应该也有用到单一职责的思想吧，每个表只负责某一部分的业务数据，不要过多耦合，方便维护，阅读。","like_count":1},{"had_liked":false,"id":159609,"user_name":"小建","can_delete":false,"product_type":"c1","uid":1647247,"ip_address":"","ucode":"C9781DF8F79112","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/8f/22e9c74b.jpg","comment_is_top":false,"comment_ctime":1575703558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870670854","product_id":100039001,"comment_content":"干货满满","like_count":1},{"had_liked":false,"id":159567,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1575687064,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5870654360","product_id":100039001,"comment_content":"打卡<br>1、单一职责原则定义：一个类或是模块只完成一个职责（或功能）<br>2、如何做到单一职责，有几个方法可以参考<br>1）类中的代码行数和属性太多；<br>2）类依赖的其他类过多；<br>3）类的私有方法过多，考虑是否可能把一些公用的方法放到其他的类中，作为公有方法，提供代码复用性；<br>4）比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；<br>5）类中大量的方法都是集中操作某几个属性，可以考虑把这几个属性和方法抽取出来；<br><br>3、在不同的应用场景和不同的需求背景下，类的单一职责判断是不同。随着需求的变动，功能的增加，原来的类可能就不满足单一职责原则，就需要拆分为颗粒度更小的类；<br><br>4、类的颗粒度拆分也需要适度，把负责单个功能的类拆分为多个类，反而破坏了高内聚的原则（虽然满足了低耦合）。<br><br>5、在需求实现初期，可以写个颗粒度大的类，满足业务需求。当某个类的代码越来越多，负责的职责越来越多，可以查分为更小颗粒度的类。（持续重构的思想）","like_count":1,"discussions":[{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294874,"discussion_content":"第四点我觉得没有满足低耦合，高内聚的同时可能就满足低耦合，所以后者不能得出结论。只有前者是高内聚高耦合的场景才能得出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596021861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159533,"user_name":"郑童文","can_delete":false,"product_type":"c1","uid":1030733,"ip_address":"","ucode":"3D193715CB8549","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg","comment_is_top":false,"comment_ctime":1575672157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870639453","product_id":100039001,"comment_content":"推荐一个很好的免费资料, NEU Program Design Paradigms课程的网站:<br>https:&#47;&#47;course.ccs.neu.edu&#47;cs5010&#47;index.html<br>Lecture部分写得很细致,还有作业","like_count":1},{"had_liked":false,"id":159465,"user_name":"ww yang","can_delete":false,"product_type":"c1","uid":1584617,"ip_address":"","ucode":"AE223861999D07","user_header":"https://static001.geekbang.org/account/avatar/00/18/2d/e9/bdb98e2f.jpg","comment_is_top":false,"comment_ctime":1575630271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870597567","product_id":100039001,"comment_content":"每次学完都很期待下一节课马上来！","like_count":1},{"had_liked":false,"id":159347,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1575603002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870570298","product_id":100039001,"comment_content":"1、如何判断代码行数过多，这个我还是觉得要看感觉，如果自己看着觉得很不爽，那说明应该要拆分或者优化精简了；如果自己看不太出来可以找人review，别人或许能看出来。不过代码行数最好不要太多。<br>3、方法设计，接口设计等等，都可以使用单一职责，每个方法做一件事，如果里面的代码多了或者乱了，就应该试着拆分，接口设计也是同理，做某一个模块的事情，不能多个模块都写在一个接口里面。","like_count":1},{"had_liked":false,"id":159279,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1575594385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870561681","product_id":100039001,"comment_content":"根据不同的场景对某个类或模块单一职责的判断是不同的，不能为了拆分而拆分，造成过度设计，难以维护。","like_count":1},{"had_liked":false,"id":159253,"user_name":"水银","can_delete":false,"product_type":"c1","uid":1045948,"ip_address":"","ucode":"0FD9C79590E484","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/bc/63be02b6.jpg","comment_is_top":false,"comment_ctime":1575592160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870559456","product_id":100039001,"comment_content":"单一职责，感觉不应该用代码行数来判定，确实应该由业务需求场景决定，有些业务场景不复杂，过分强调单一，反而会使代码片段零散在过多的类、方法中，导致调用层级过深，不易阅读和理解，难以维护，万事都有个平衡，适度就好，毕竟代码不是一次成型的建筑物，需要持续的改造、优化。<br><br>单一职责感觉是最基础也是起他设计模式用好的前提，考量单一的时候还有一个原则就是：复用性，如果一块逻辑或业务可以被起他地方利用，也是标志整块逻辑的职责是单一性的。单一职责没有一个确切的标准，很多场景下在一个业务中对于权衡单一指责的考虑纬度、粒度也所有不同。虽然是很简单易懂的指责，但用好确实并不是很容易的事。","like_count":1},{"had_liked":false,"id":357125,"user_name":"Geek_3e9d7d","can_delete":false,"product_type":"c1","uid":3070253,"ip_address":"北京","ucode":"3BDEFFE68BE32F","user_header":"","comment_is_top":false,"comment_ctime":1662977237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662977237","product_id":100039001,"comment_content":"1、对于如何判断一个类是否职责单一，如何判断代码行数过多，你还有哪些其他的方法吗？<br>对于一个类是否职责单一，我的一个经验是在MVC架构中，一般每一层向下调用，如果这一层的类需要向下调用下一层的类过多，可能这个类的职责就有点过多了。比如一个BizService，这个类中的处理逻辑需要用户数据、订单数据、商品数据、地址数据等等那么久需要调用UserRepository、OrderRepository、ItemRepository和AddressRepository，面对这种情况就可以初步判读这个Service的职责过于复杂了<br>2、单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？<br>还可以应用到模块的设计、微服务的设计、数据库垂直拆分的设计中。","like_count":0},{"had_liked":false,"id":356767,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"中国香港","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662564837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662564837","product_id":100039001,"comment_content":"思考题1: 功能是否相近。<br>思考题2: 衍生到模块上。<br><br>本节讲了单一职责：<br><br>   what: 一个类职责要单一，不要设计大而全的类。<br>   why:  单一原则主要是未来代码的可读性性和可维护性和解耦。<br><br>   how: 如何判断类是否单一。<br>      1.代码行数过多。<br>      2. 属性过多，且方法主要集中在某个类上。<br>      3.私有方法过多。<br><br>不过具体情况具体分析，还是要靠经验堆积。","like_count":0},{"had_liked":false,"id":355227,"user_name":"Huyunfu","can_delete":false,"product_type":"c1","uid":1888301,"ip_address":"广东","ucode":"61A3AFC7BD4203","user_header":"","comment_is_top":false,"comment_ctime":1661210001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661210001","product_id":100039001,"comment_content":"单一职责原则，这个我的理解就是要跟函数或类的抽象层级息息相关。抽象层级又通过类、方法的命名来体现。比如你的类取名叫User，那这个类就应该只有与User相关的操作；你的方法名字是queryUser,那么方法就只做查询操作，不要在里面做类似set值的其他操作。有时候即使一个方法里需要做两件事，来达到代码复用的效果，比如查询完结果并做缓存，为了方法复用，我将方法命名为queryDbAndSetCache，我认为这个方法还是符合单一职责的，因为的职责就是“查询并缓存”，这也是一件事，只是抽象层级不一样。","like_count":0},{"had_liked":false,"id":353447,"user_name":"泽韦德","can_delete":false,"product_type":"c1","uid":1103888,"ip_address":"浙江","ucode":"948E7B067A3786","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/10/5173922c.jpg","comment_is_top":false,"comment_ctime":1659444486,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1659444486","product_id":100039001,"comment_content":"1.判断类名与定义的方法是否在同一范围之内，类的属性是否过多，方法数量是否过多，使用依赖查看工具，观察外部依赖是否过多。<br>2.数据库表的设计也要遵循单一职责原则，比如各类范式，也是单一职责原则的体现。","like_count":0},{"had_liked":false,"id":350713,"user_name":"会飞的猪","can_delete":false,"product_type":"c1","uid":2536213,"ip_address":"","ucode":"48E44B47D53A97","user_header":"https://static001.geekbang.org/account/avatar/00/26/b3/15/54f57316.jpg","comment_is_top":false,"comment_ctime":1657113059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657113059","product_id":100039001,"comment_content":"我觉得老师讲的很好，但是如何实践呢？这个需要我们好好思考一下","like_count":0},{"had_liked":false,"id":345472,"user_name":"Morty","can_delete":false,"product_type":"c1","uid":1026658,"ip_address":"","ucode":"C2E532741F99E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/62/78b45741.jpg","comment_is_top":false,"comment_ctime":1652317066,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652317066","product_id":100039001,"comment_content":"其实不止类和模块，所有要封装的都应该遵守这个原则，例如方法&#47;函数","like_count":0},{"had_liked":false,"id":345201,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1652104096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652104096","product_id":100039001,"comment_content":"单一职责是为了实现正交的代码设计，正交的代码设计可以更好的实现内聚，提高代码的稳定性和可复用性。","like_count":0},{"had_liked":false,"id":337179,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1646661922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646661922","product_id":100039001,"comment_content":"1.重构的原则。<br>2.封装的原则。<br>3.如何优化代码的方法。<br>4.如何提高可读性、维护性、高内聚、低耦合。<br>5.类的设计职责是否单一越好？","like_count":0},{"had_liked":false,"id":328176,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1640589128,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640589128","product_id":100039001,"comment_content":"感觉依赖其他太多的类，就会说明类职责不够单一。","like_count":0},{"had_liked":false,"id":324546,"user_name":"WANGX","can_delete":false,"product_type":"c1","uid":1404380,"ip_address":"","ucode":"A4132A93CC2A47","user_header":"https://static001.geekbang.org/account/avatar/00/15/6d/dc/6a91c3d3.jpg","comment_is_top":false,"comment_ctime":1638497183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638497183","product_id":100039001,"comment_content":"1.单一原则：一个类只负责完成一个职责或者功能<br>2.是否满足单一原则需要结合业务场景来分析，设计满足当下业务场景符合单一原则即可，后续持续重构，避免过度设计<br>3.类的职责设计不是越单一越好","like_count":0},{"had_liked":false,"id":320783,"user_name":"二小","can_delete":false,"product_type":"c1","uid":1593919,"ip_address":"","ucode":"5377CB552237B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/3f/c8b40efe.jpg","comment_is_top":false,"comment_ctime":1636510163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636510163","product_id":100039001,"comment_content":"2、可以用在微服务的拆分上","like_count":0},{"had_liked":false,"id":319194,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1635665920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635665920","product_id":100039001,"comment_content":"我有个前同事，一个业务类里面塞了两千多行代码，3M大小，编辑器打开都要加载半天。而且耦合性特别强，你想优化就要重新撸一遍。这种也是很无奈，坑挖的让人无言以对。","like_count":0},{"had_liked":false,"id":316534,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1634372840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634372840","product_id":100039001,"comment_content":"1.判断类的职责是否单一：<br>当一个类的职责单一时，其所有的方法会围绕一个主题展开，比如更新帐户余额，那么其大部分方法名称中都会包含和帐户余额相关的名称，也就是根据方法名称是否包含主题词来判断类的职责是否单一<br><br>2.判断代码行是否过多：<br>(1)当一段代码的嵌套层次过深时，比如有5-6层时，可认为代码行过多；<br>(2)当代码段中出现大量重复的代码行时，且这些重复的代码行之间的区别只是某些局部变量或参数不同时，可认为代码行过多<br>(3)因调试或修改出现大量注释掉的无用代码时，也会造成代码行过多，代码混乱。<br><br>3.单一职责原则应用：<br>单一职责原则除了应用到类的设计上，还可以应用到功能模块的设计，组件的设计，子系统的设计，以及服务的设计等。","like_count":0},{"had_liked":false,"id":316176,"user_name":"Geek3425","can_delete":false,"product_type":"c1","uid":2791308,"ip_address":"","ucode":"C7292D0AF11F43","user_header":"","comment_is_top":false,"comment_ctime":1634192620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634192620","product_id":100039001,"comment_content":"比如新增文档，新增问题，新增标签都是要一个接口，一个方法是实现的，通过传type区分，是不是违反了单一性","like_count":0},{"had_liked":false,"id":314361,"user_name":"Rootrl","can_delete":false,"product_type":"c1","uid":1035390,"ip_address":"","ucode":"50FE3BBA92D417","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/7e/0d050964.jpg","comment_is_top":false,"comment_ctime":1632986064,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632986064","product_id":100039001,"comment_content":"所谓“盐少许”，“专业第六感”。这个可以用德雷福斯模型解释，有新手、高级新手、胜任者、精通者、专家，其中各级解释，大家可以具体去了解下，比如新手只会按指令做事，我们来此学习大概是想从高级新手进到胜任者，或者胜任者进到精通者阶级吧。这里各个阶级的都只能按自己的思维模型做事，而专家就是靠直觉行事的，行为专家是一级级进化来的，以往经验形成了“肌肉记忆”。","like_count":0},{"had_liked":false,"id":311961,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1631576794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631576794","product_id":100039001,"comment_content":"单一职业选择，SRP<br>尽可能使得一个类的功能单一，进而趋于高内聚，低耦合。<br>有些指标参考<br>1.类行数是否过多<br>2.类私有方法是否过多","like_count":0},{"had_liked":false,"id":311877,"user_name":"al-byte","can_delete":false,"product_type":"c1","uid":1466744,"ip_address":"","ucode":"D0298A02E9259D","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/78/e7aa4e04.jpg","comment_is_top":false,"comment_ctime":1631519839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631519839","product_id":100039001,"comment_content":"单一职责在业务处理上也可以应用 这样在业务领域划分和多业务编排时会有更高的复用性","like_count":0},{"had_liked":false,"id":311825,"user_name":"小川","can_delete":false,"product_type":"c1","uid":1242573,"ip_address":"","ucode":"D462222DDBB978","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","comment_is_top":false,"comment_ctime":1631495772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631495772","product_id":100039001,"comment_content":"单一职业真的是万金油的设计。<br><br>1. 突然想到了《金字塔原理》里面的 MECE 选择，按照互不相干的纬度进行分类，每个分类维护自己各自的观点。<br><br>2. 依据我们软件开发的流程，一开始的小公司早期其实都没有产品经理和测试，运维。当软件开发到一定层次的时候，就开始细分产品、开发、测试、运维、风控等岗位，每个岗位各司其职（目的还是维护一个产品，只是纬度不同）。<br><br>3. 一般在大公司，你的手下犯事了，你的领导不会找你的手下，而是直接找你。因为对于领导来说，他需要做的就是通过开发经理去管理下属，所以他的职责更多的是管理开发经理。","like_count":0},{"had_liked":false,"id":308317,"user_name":"小周","can_delete":false,"product_type":"c1","uid":2453498,"ip_address":"","ucode":"7ED7BC27A46C4C","user_header":"https://static001.geekbang.org/account/avatar/00/25/6f/fa/615a0df3.jpg","comment_is_top":false,"comment_ctime":1629532318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629532318","product_id":100039001,"comment_content":"还可以应用到模块划分、以及函数","like_count":0},{"had_liked":false,"id":300986,"user_name":"小帅","can_delete":false,"product_type":"c1","uid":1239663,"ip_address":"","ucode":"4129A7E9427FFC","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/6f/09de5f65.jpg","comment_is_top":false,"comment_ctime":1625476532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625476532","product_id":100039001,"comment_content":"感觉类的设计跟数据库表的设计很像","like_count":0},{"had_liked":false,"id":300127,"user_name":"roman","can_delete":false,"product_type":"c1","uid":2221077,"ip_address":"","ucode":"74F66DCB14DA22","user_header":"https://static001.geekbang.org/account/avatar/00/21/e4/15/80bf9ee3.jpg","comment_is_top":false,"comment_ctime":1625016820,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625016820","product_id":100039001,"comment_content":"学到<br>1、单一指责的概念<br>2、判断类是否足够的“单一”<br>3、单一指责设计的原则","like_count":0},{"had_liked":false,"id":295989,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1622694971,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1622694971","product_id":100039001,"comment_content":"单一职责可以用到方法上，避免设计一个大而全的方法，应该拆分为更细力度的多个方法","like_count":0},{"had_liked":false,"id":294051,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1621730036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621730036","product_id":100039001,"comment_content":"来了来了，三刷！","like_count":0},{"had_liked":false,"id":291936,"user_name":"栾~龟虽寿！","can_delete":false,"product_type":"c1","uid":1504671,"ip_address":"","ucode":"219B38C08979FE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","comment_is_top":false,"comment_ctime":1620615907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620615907","product_id":100039001,"comment_content":"打卡 ，单一，不容易。","like_count":0},{"had_liked":false,"id":290758,"user_name":"Geek_9dbc25","can_delete":false,"product_type":"c1","uid":2242904,"ip_address":"","ucode":"6CB31893173165","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIHxTg3tYriaCXiccCf7xUl9QHibAhCMBKQ2oCicvgcuHCo4ULSguISXeHzxM9a8fFD7icfy3OgXibvUNxw/132","comment_is_top":false,"comment_ctime":1619742356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619742356","product_id":100039001,"comment_content":"1.代码行数，属性是否过多<br>2.依赖的类是否过多<br>3.类中的大量方法都集中在操作某些属性<br>","like_count":0},{"had_liked":false,"id":285111,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1616631181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616631181","product_id":100039001,"comment_content":"我们首先要明确类的职责，才能做好单一职责的设计","like_count":0},{"had_liked":false,"id":284331,"user_name":"夏秋冬","can_delete":false,"product_type":"c1","uid":2526247,"ip_address":"","ucode":"20D62081D9596F","user_header":"https://static001.geekbang.org/account/avatar/00/26/8c/27/5644834e.jpg","comment_is_top":false,"comment_ctime":1616171063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616171063","product_id":100039001,"comment_content":"看了这篇文章后对高内聚和低耦合有了新的理解，可以把代码的臃肿程度视为一条坐标轴；<br><br>左边是低内聚，因过于追求单一职责导致类被拆的过于稀碎，使得类的可维护性降低；<br><br>右边是高耦合，因为过于追求大而全导致类太过臃肿，使得代码的可拓展性降低；<br><br>只有中间合适的设计满足高内聚与低耦合，使得类兼具了可维护性与可拓展性；","like_count":0},{"had_liked":false,"id":283147,"user_name":"秋","can_delete":false,"product_type":"c1","uid":2414484,"ip_address":"","ucode":"14E792376F6A3C","user_header":"https://static001.geekbang.org/account/avatar/00/24/d7/94/202e484b.jpg","comment_is_top":false,"comment_ctime":1615593850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615593850","product_id":100039001,"comment_content":"想请教一下大佬们，平时写业务代码的时候，有时候实体类里面的字段太多，如果要应用这个原则，对应的表是否也要拆分呢？还有因为用的是三层结构，我待过的好几家公司的项目里面都写的是一个实体对应 一个service，有时候因为对某个类的操作很多，就有很多个接口，我遇到过一个service里面有几千行代码，可读性非常差，这样的service怎么拆分呢？","like_count":0},{"had_liked":false,"id":281645,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1614838754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614838754","product_id":100039001,"comment_content":"关于拆分粒度的问题。<br>对于我来说，其实是个大脑内存问题。或者说是概念复杂度问题；而不是代码行数，函数多少问题。<br><br>一般我拆分类或模块的原则是，对于某一层代码，一般人看了能否明白是做什么的就不需要再去拆。<br><br>概念上只要足够清晰或者类内的复杂度都是明了易用的，就不需要拆分。<br><br>拿上面的userinfi的例子来说。所有的地址信息在外部只是展示，那就不需要拆分。为什么呢？因为程序员大脑可以批量认为这些属性通通是器官。可以说仅仅是一个概念就够了。<br><br>但当每个地址信息都需要额外的业务的时候。<br>那开发人员的大脑里就需要处理地址的字段逻辑了。这时候如果不拆的话，每一次处理地址信息的时候，还看着用户信息的话，大脑内存就被占用浪费了。","like_count":0},{"had_liked":false,"id":281589,"user_name":"Geek_f9a021","can_delete":false,"product_type":"c1","uid":2410677,"ip_address":"","ucode":"9973F02EEC650E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItGC2xTpD3HFfoX4XZsMbGozbo65kQLjbUtgtrGD108QQye9rcPUzfLOxniaadoY0fRib1VEeO771Q/132","comment_is_top":false,"comment_ctime":1614820749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614820749","product_id":100039001,"comment_content":"你好 单一职责原则和ddd充血模式是否违背了单一职责呢","like_count":0},{"had_liked":false,"id":280592,"user_name":"张云峥","can_delete":false,"product_type":"c1","uid":2056385,"ip_address":"","ucode":"8FF686816DBD9A","user_header":"https://static001.geekbang.org/account/avatar/00/1f/60/c1/a1437bca.jpg","comment_is_top":false,"comment_ctime":1614257634,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614257634","product_id":100039001,"comment_content":"有一个我实际中比较常用的判断方法，就是如果一个方法的代码行数超过了一个屏幕，那么这个方法就太长了。","like_count":0},{"had_liked":false,"id":280212,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1614135317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614135317","product_id":100039001,"comment_content":"单一职责，在实际应用中可以简单应用为：1.类名不好起，不明确，不符合；2.类使用时找方法麻烦；3.有修改时改动点多，易遗漏","like_count":0},{"had_liked":false,"id":280128,"user_name":"Chloe","can_delete":false,"product_type":"c1","uid":1004953,"ip_address":"","ucode":"C4848ED5B35752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","comment_is_top":false,"comment_ctime":1614088984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614088984","product_id":100039001,"comment_content":"谢谢老师从两个方面把SRP讲的很透彻。非常同意根据应用场景来适度使用SRP原则，我想接下来的设计pattern里面会讲到在重构的过程中，为了拆分类或者模块，怎么样设计能够最大程度的降低重构时候的成本，非常期待 :) ","like_count":0},{"had_liked":false,"id":276676,"user_name":"苗运齐","can_delete":false,"product_type":"c1","uid":1923230,"ip_address":"","ucode":"B33305840A9F84","user_header":"https://static001.geekbang.org/account/avatar/00/1d/58/9e/dc4fb520.jpg","comment_is_top":false,"comment_ctime":1612075053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612075053","product_id":100039001,"comment_content":"单一职责只是手段，高内聚低耦合、可复用、可扩展和可读性才是目标","like_count":0},{"had_liked":false,"id":274908,"user_name":"刘立嘉","can_delete":false,"product_type":"c1","uid":2414637,"ip_address":"","ucode":"1241140EBE7FE3","user_header":"https://static001.geekbang.org/account/avatar/00/24/d8/2d/6ec3760c.jpg","comment_is_top":false,"comment_ctime":1611216231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611216231","product_id":100039001,"comment_content":"高内聚、低耦合的原则，是面向对象设计的基本原则，一个类只是一样东西，一个方法只做一件事情，再通过合理的组合和调用，达到实现最终功能的目的。","like_count":0},{"had_liked":false,"id":274874,"user_name":"咚咚咚咚咚咚","can_delete":false,"product_type":"c1","uid":1649779,"ip_address":"","ucode":"C256D70088F02C","user_header":"https://static001.geekbang.org/account/avatar/00/19/2c/73/e5fe80b8.jpg","comment_is_top":false,"comment_ctime":1611201685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611201685","product_id":100039001,"comment_content":"对于如何判断一个类是否职责单一<br>类似前面说到的拆分名词动词来判断功能职责，比如获取用户数据再发送出去，这简单的理解应该是两个功能了吧，获取和发送，再细分到用户数据由哪些部分组成：头像图片，昵称，性别，年龄。然后图片是链接呢还是需要去拿图片Id去获取临时的图片链接，再然后年龄是需要用出生日期计算的。拆分到这里基本上就已经是比较细的颗粒度了，然后根据写的时候的怎么方便怎么合并和拆分职责。我大概是这样的","like_count":0},{"had_liked":false,"id":272035,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1609915711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609915711","product_id":100039001,"comment_content":"其实怎么写，怎么设计，在一开始的业务上你就要有一个大概的方向，业务明确之后，在去写代码，这样可以写出更好的代码。我在写代码中，其实就是没有去深深的去理解业务，上来框框就是干，导致后面整个类里面的方法杂乱无章，后期也更不想看。","like_count":0},{"had_liked":false,"id":271515,"user_name":"long","can_delete":false,"product_type":"c1","uid":1595158,"ip_address":"","ucode":"8424683A801718","user_header":"https://static001.geekbang.org/account/avatar/00/18/57/16/b7b4fe79.jpg","comment_is_top":false,"comment_ctime":1609676580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609676580","product_id":100039001,"comment_content":"感觉先写一个可以用的类，后续在持续重构还是太依赖测试了，比如是否写了单元测试，是否有集成测试等，必然我好心重构了下代码，然后导致线上 BUG 了就难受，所以一般测试覆盖不好的项目，我都不敢重构这个代码，虽然自己觉得没有问题，但是还是心慌，不知道这种情况下，争哥会如何考虑？","like_count":0},{"had_liked":false,"id":269458,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1608659057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608659057","product_id":100039001,"comment_content":"从维护性和易用性的角度去判断单一原则。","like_count":0},{"had_liked":false,"id":268071,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1608044057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608044057","product_id":100039001,"comment_content":"1、判断一个类是否职责单一<br>    代码行数过多，方法是否过多，且是否与自己的类的业务相关。<br>2、单一职责除了类设计，方法也需要这样设计。不要一个方法名，里面做了很多事情，顶层方法除外，增加可复用性。","like_count":0},{"had_liked":false,"id":267486,"user_name":"Geek_2495de","can_delete":false,"product_type":"c1","uid":1786809,"ip_address":"","ucode":"BCC92B259FF165","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/lHqiahnUnaWY9GOGgIamhbddJUYtopKABFmVwaD68uXgTdaA72HX3yzd6YtqPKEt1YxJuXwYXKsmzGNKXmV75LQ/132","comment_is_top":false,"comment_ctime":1607764937,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607764937","product_id":100039001,"comment_content":"1.  第一个：是否好读。倾向于一个方法内部的逻辑能够条理分明。如果读了很多久，都没理出逻辑来，或者读完整个方法，回过头才能看出逻辑，对我来说，就是代码行数过多。<br>1.  第二个： 是否存在读写不相关两个元素的共存的操作<br>2. 单一职责：方法、类、模块、接口、甚至整个项目都可以用吧~<br>","like_count":0},{"had_liked":false,"id":256050,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603514384,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1603514384","product_id":100039001,"comment_content":"1. 类单一职责判断可以通过评估其对外提供接口是否满足不断变化的业务和需求来确定！<br>问自己，该类是否对其他类是&quot;黑盒&quot;；<br><br>2. 类行数多=属性多+方法多<br>属性多: 要考虑这些属性是不是对类来说是必须的，需要移除么？<br>方法多: 方法间复用情况，方法间有没有写重复代码？<br>如上如果觉得没有可以改进的余地，就可以认为类行数恰当；<br><br>3. 单一职责还可以应用到方法，模块，功能点上。","like_count":0},{"had_liked":false,"id":247059,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1599573738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599573738","product_id":100039001,"comment_content":"打卡，又是慢慢的收获","like_count":0},{"had_liked":false,"id":246348,"user_name":"liliumss","can_delete":false,"product_type":"c1","uid":1333094,"ip_address":"","ucode":"A52AC5042F3115","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","comment_is_top":false,"comment_ctime":1599291425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599291425","product_id":100039001,"comment_content":"可以根据不同调用者在公司组织的关注点不同来切分，比如促销部门关注用户的下单，安全部门关注用户的账号安全，各个业务做到他们自己对应的组件里面去，这样互相之前的变动不会互相影响","like_count":0},{"had_liked":false,"id":246295,"user_name":"冬天里的懒猫","can_delete":false,"product_type":"c1","uid":1042458,"ip_address":"","ucode":"970E5CEF502828","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/1a/cea701bb.jpg","comment_is_top":false,"comment_ctime":1599269760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599269760","product_id":100039001,"comment_content":"为什么并发库里道格列的各种并发工具，如Concurrenthashmap有6千多行","like_count":0},{"had_liked":false,"id":245940,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599115546,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599115546","product_id":100039001,"comment_content":"问题1：<br>1、类的职责设计和定位清晰<br><br>问题2：<br>1、模块的划分","like_count":0},{"had_liked":false,"id":244555,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1598578594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598578594","product_id":100039001,"comment_content":"单一职责所谓的单一是在某一个抽象层面的单一。要知道这个类是否符合单一职责那么首先要看在设计这个类时它的抽象层次是什么？单一职责小到可以在类的方法上大整个架构上。","like_count":0},{"had_liked":false,"id":244368,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1598493920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598493920","product_id":100039001,"comment_content":"自己写完代码就变成了一个失忆的憨憨，测试同学通知我要改bug，我怎么办？<br>单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。同时业务类型和业务的复杂程度决定了类的职责是否单一。这都是心法，没有量化的标准呀，怎么实践？只能把自己当憨憨，把类尽量写得简单。<br>除了把自己当憨憨，作者给出的小技巧更有实操性。","like_count":0},{"had_liked":false,"id":243938,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1598333896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598333896","product_id":100039001,"comment_content":"单一职责思想  服务拆分，数据表设计都可以用上。","like_count":0},{"had_liked":false,"id":243665,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1598243568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598243568","product_id":100039001,"comment_content":"1 文中的行数过多、属性方法过多、无法命名、集中操作某几个函数、依赖的类过多依赖类的其他类过多，我自己觉得，一旦可读性差了，就说明类的职责不够单一。<br>2 函数的设计也需要单一职责原则。","like_count":0},{"had_liked":false,"id":241431,"user_name":"Geek_junjun","can_delete":false,"product_type":"c1","uid":1802621,"ip_address":"","ucode":"DF4C5D80802C7A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIE8EIS5arCmFwaZhazJmhn4Uz69Cmlay6dibibsdoNrnLyrsTsAdITK069usejicIE6aYpHULZ4G1YQ/132","comment_is_top":false,"comment_ctime":1597291594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597291594","product_id":100039001,"comment_content":"有代码度量工具可以辅助判定单一职责，如：单个文件行数超过200报警，单个函数超过50行报警等，如果开发团队能严格要求代码度量工具自动检查代码不能有任何上述报警，其实就能在很大程度上满足单一职责了，即使真的有某个函数小于50行又违背单一职责，实际上危害也不大，发现了顺手改一下就行，发现不了也没什么。","like_count":0},{"had_liked":false,"id":239582,"user_name":"owen","can_delete":false,"product_type":"c1","uid":1902116,"ip_address":"","ucode":"0E79DA9080A085","user_header":"https://static001.geekbang.org/account/avatar/00/1d/06/24/c2ee3b16.jpg","comment_is_top":false,"comment_ctime":1596591552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596591552","product_id":100039001,"comment_content":"看到类不超过200行，属性不超过10个，我就枯萎，设计一个订单类属性都超200行了！对于单一原则当然是把类打成原子压得越平确实越好，方便扩展可读性高各种好处！ 但是间接的开发成本维护成本，也会高很多，如果本身项目不大也没有太大必要分得越细，个人觉得初期也可以写得分得粗些，随着项目的扩大慢慢重构吧！！","like_count":0},{"had_liked":false,"id":239444,"user_name":"Aaron 延亮","can_delete":false,"product_type":"c1","uid":1394147,"ip_address":"","ucode":"48DE83DDF45A61","user_header":"https://static001.geekbang.org/account/avatar/00/15/45/e3/26d1e69c.jpg","comment_is_top":false,"comment_ctime":1596533109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596533109","product_id":100039001,"comment_content":"先学学java再看吧  不然不太容易看懂","like_count":0},{"had_liked":false,"id":236455,"user_name":"hex","can_delete":false,"product_type":"c1","uid":1757301,"ip_address":"","ucode":"B983D40DCD159F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d0/75/3e034f71.jpg","comment_is_top":false,"comment_ctime":1595419152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595419152","product_id":100039001,"comment_content":"单一职责尽量使类的拆分粒度更小,.但是拆分过度会破坏了高内聚.<br>比如微服务也可以按照业务和职责来拆分,不知说的是否对.","like_count":0},{"had_liked":false,"id":231821,"user_name":"Sic Pavis","can_delete":false,"product_type":"c1","uid":1106088,"ip_address":"","ucode":"48B5F0118347C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","comment_is_top":false,"comment_ctime":1593779776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593779776","product_id":100039001,"comment_content":"😂越学越觉得我国的中庸之道博大精深。<br>我没读过《中庸》，以前一听到这个词就感觉是墙头草，没立场。<br><br>现在学很多方法论包括架构，其实感觉其最核心思想就是中庸，在各种取舍间取得平衡。类似于文中，判断一个类是否符合SRP我觉得其实就是一种中庸的思想。","like_count":0},{"had_liked":false,"id":230162,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593299781,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593299781","product_id":100039001,"comment_content":"单一职责，更多的是从业务功能职责划分角度去考虑。<br>前提是做了业务职责功能划分，先有业务职责划分，才能做单一职责判断。<br>业务职责划分可以用DDD的战略设计。","like_count":0},{"had_liked":false,"id":228973,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592873921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592873921","product_id":100039001,"comment_content":"单一职责能够提高类的高内聚低耦合，有利于类的维护和扩展。而同一个类在多种场景下，单一职责不是一定的，避免拆分过细导致类的高内聚被打破。<br><br>不符合单一职责的可能场景有：类的某个属性一直被使用、类的长度方法太长、依赖的类太多不符合高内聚等","like_count":0},{"had_liked":false,"id":225803,"user_name":"MilkBeer","can_delete":false,"product_type":"c1","uid":1232314,"ip_address":"","ucode":"DC4FAC3F2A87EE","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/ba/84422076.jpg","comment_is_top":false,"comment_ctime":1591863403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591863403","product_id":100039001,"comment_content":"单一职责原则是为了能够提高类的内聚性，以让模块或者类之间的耦合降低。所以不能只是简单的为了单一而生搬硬套的去拆分类或者模块。过于拆分反而会让一个类内部没有任何内容，更无需提什么内聚性了。","like_count":0},{"had_liked":false,"id":224510,"user_name":"sorationalist","can_delete":false,"product_type":"c1","uid":2012902,"ip_address":"","ucode":"4E2B3B3234E1C5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b6/e6/b2be4536.jpg","comment_is_top":false,"comment_ctime":1591425226,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1591425226","product_id":100039001,"comment_content":"单一职责，我是按数据库表来划分的，所有这个表的增删改查都放在同一个service，设计到多表操作的，都同层调用，不知这样是否符合单一职责，高内聚低耦合。","like_count":0,"discussions":[{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285824,"discussion_content":"同层调用是指什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592963148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224441,"user_name":"pony","can_delete":false,"product_type":"c1","uid":1021530,"ip_address":"","ucode":"B72FA864CDD286","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/5a/846a09f7.jpg","comment_is_top":false,"comment_ctime":1591402065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591402065","product_id":100039001,"comment_content":"1.类的单一原则判断，也可以根据受变更影响因素的个数来判断<br>2.单一原则也可以使用在函数设计上和网络协议分层设计上，每一层负责独立的功能","like_count":0},{"had_liked":false,"id":220747,"user_name":"朝小树","can_delete":false,"product_type":"c1","uid":1323875,"ip_address":"","ucode":"18DC282DEF16C8","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/63/2d48822a.jpg","comment_is_top":false,"comment_ctime":1590317742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590317742","product_id":100039001,"comment_content":"可能的范围内尽量做到单一职责，如果有A模型，B模型，多对多的关系，此时关系模型归属A还是B还是AB关系呢，每当这时候总会有些纠结。<br>","like_count":0},{"had_liked":false,"id":219354,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1125259,"ip_address":"","ucode":"7BF52ADBFD4F5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/8b/dd02189a.jpg","comment_is_top":false,"comment_ctime":1590014348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590014348","product_id":100039001,"comment_content":"课堂讨论问题：<br>1. 判断类的职责是否单一基本上是凭借经验来，通常来说一个类的代码是不超过1000行的。另外代码行数是否过多是跟某个功能的复杂程度，以及拆分的粒度有关系，不能一概而论。<br>除了通过代码行数来判断以外，还可以通过让别人来Review你的代码方式，询问别人是否能够很容易通过某一个Class文件或者代码块找出所有要实现的功能。<br>2. 单一职责原则除了应用到类的设计上，还可以延申到：功能模块的设计，应用按域拆分，甚至是前后端分离","like_count":0},{"had_liked":false,"id":217899,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1589641104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589641104","product_id":100039001,"comment_content":"如何判断类是否职责单一：<br>- 职责单一的类，准确来说是职责分明，不做过多的事情，也不少做事情。<br>  - 大部分开发人员都是会有一种直觉的，一个类如果负责太多东西或者太少，都会感觉不太好呀：乱，细节太多，阅读困难，觉得不妥，累，心里有点抗拒。<br>  - 这种状态的描述，有一个，有个形容词叫：心智负担重。<br> <br>- 另外个人认为，在判断代码是否设计良好的时候，可以代码能够让人以较少的「负担」来阅读，修改，测试等判断。<br>- 一旦出现这种内心状态的时候，就是我们要重新思考设计的时候<br><br>至于能够应用到那些地方，这太多了：<br>- 架构分层，每一层要有明确的职责<br>- 微服务<br>- 库，模块<br>- 通信协议，接口等的设计<br><br>以上一些粗浅的观点~","like_count":0},{"had_liked":false,"id":217496,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589515481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589515481","product_id":100039001,"comment_content":"如何理解单一职责： 要设计功能职责单一的类，不要涉及大而全的类。单一职责提高高内聚低耦合，提高代码可读性 可维护性 复用性 如何判断类是否单一职责。是否是类分的越细越好：类分的细致会导致内聚性不好","like_count":0},{"had_liked":false,"id":216319,"user_name":"darkleo","can_delete":false,"product_type":"c1","uid":1023395,"ip_address":"","ucode":"126DF780822654","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/a3/a780d006.jpg","comment_is_top":false,"comment_ctime":1589242360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589242360","product_id":100039001,"comment_content":"老师，我想问一下，为什么不把Serialization设计成工具类呢？这个是从什么方面来考虑的呢？","like_count":0},{"had_liked":false,"id":215523,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1589010665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589010665","product_id":100039001,"comment_content":"1. 类的字段有很多，不够具体。<br>2. 比如在设计数据库表的时候，也要考虑表的职责单一，一个表处理一件事情，多表现在表中列存在耦合关系，那这就好违反三大范式，所以需要拆分成多个表。从这个角度看，也是单一职责原则的应用。","like_count":0},{"had_liked":false,"id":214612,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1588773178,"is_pvip":false,"replies":[{"id":"86790","content":"一个接口只有一个方法，这种设计不常见吧，除非框架限制，有特殊要求，才会这么做。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594904026,"ip_address":"","comment_id":214612,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588773178","product_id":100039001,"comment_content":"老师，您好，我工作中遇到的就是面向过程编程，一个接口中只有一个方法，对应一个实现，然后通过dubbo  rpc调用。。。请问如果一个接口中很多个方法，那实现类不就很复杂了么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494140,"discussion_content":"一个接口只有一个方法，这种设计不常见吧，除非框架限制，有特殊要求，才会这么做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594904026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211727,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1587999437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587999437","product_id":100039001,"comment_content":"数表类型不停变更 字段也不停变更 方法实现高度耦合 然后改到吐血","like_count":0},{"had_liked":false,"id":210655,"user_name":"Mr丶JDR","can_delete":false,"product_type":"c1","uid":1194429,"ip_address":"","ucode":"0377C1D0EDABBF","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/bd/344cff8c.jpg","comment_is_top":false,"comment_ctime":1587803315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587803315","product_id":100039001,"comment_content":"20200425 16:28 重新温习设计原则","like_count":0},{"had_liked":false,"id":208347,"user_name":"铁血柔情","can_delete":false,"product_type":"c1","uid":1124220,"ip_address":"","ucode":"F09CACF06B8D05","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/7c/463d4342.jpg","comment_is_top":false,"comment_ctime":1587343501,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1587343501","product_id":100039001,"comment_content":"争哥，一个service实现类有两千行代码，但是确实是这个业务下的功能，请问下怎么做拆分呢？每个方法的代码已经拆分好了，最多七十行。<br>","like_count":0,"discussions":[{"author":{"id":1739390,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8a/7e/bfe37c46.jpg","nickname":"飞鱼","note":"","ucode":"95109E8F7DBE39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386561,"discussion_content":"根据业务规则，划分子流程，按步骤把互相独立的子流程分解。先在本类中抽出来私有方法，再创建一个新的类，把刚刚那个私有方法复制到这个新的类中，然后把新类中这个新方法的访问限制符修改为public。这样逐步替换。如果实在这种方式优化之后，代码还是多的话，那就应该优化业务流程了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627638035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129309,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/5d/15c4817a.jpg","nickname":"xxxxL","note":"","ucode":"F84BB5ACD1241E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305372,"discussion_content":"这么说这个service类就有好多个方法了，看看能不能把一部分方法单独定义一个类出来呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599897999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203757,"user_name":"makermade","can_delete":false,"product_type":"c1","uid":1133194,"ip_address":"","ucode":"03386B90CB8F20","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","comment_is_top":false,"comment_ctime":1586263174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586263174","product_id":100039001,"comment_content":"单一职责，也可以延伸到微服务的拆分上。一个服务，只负责单一核心业务","like_count":0},{"had_liked":false,"id":202600,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586013140,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586013140","product_id":100039001,"comment_content":"单一职责原则，还可以应用到类函数的设计上。也可以应用到相关模块的设计上。","like_count":0},{"had_liked":false,"id":202599,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586013068,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586013068","product_id":100039001,"comment_content":"类的代码函数一般不超过200行？这个似乎一个函数还差不多。哈哈哈","like_count":0},{"had_liked":false,"id":201146,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1585723091,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585723091","product_id":100039001,"comment_content":"想请教一下，所谓的内聚性是什么意思？是指类内各个成员和方法的联系程度吗？","like_count":0},{"had_liked":false,"id":199832,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585496684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585496684","product_id":100039001,"comment_content":"单一职责：一个类或模块只注重于一个职责。<br><br>我以前的写的也是不够单一，把本来可以分开的方法都放到同一个地方。后面不能很好复用，也很难理解。","like_count":0},{"had_liked":false,"id":197697,"user_name":"01Running","can_delete":false,"product_type":"c1","uid":1015862,"ip_address":"","ucode":"2E50E4FD35D3B5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/36/29e4863f.jpg","comment_is_top":false,"comment_ctime":1585392267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585392267","product_id":100039001,"comment_content":"学习总结：<br>* 定义：一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。<br>* 如何判断类的职责是否足够单一？<br>    * UserInfo 里面的地址信息<br>        * 如果只是展示，则放一起<br>        * 如果又有一个电商物流，那可能要把地址信息拆分出来<br>        * 如果又有统一账号系统，那可能要把身份认证相关的信息拆分出来<br>    * 需要根据具体业务场景来判断<br>    * 不过度设计：<br>        * 我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构 !\u0010<br>    * 作者的判断原则：<br>        * 类中的代码行数、函数或者属性过多；<br>        * 类依赖的其他类过多，或者依赖类的其他类过多；<br>        * 私有方法过多；<br>        * 比较难给类起一个合适的名字；<br>        * 类中大量的方法都是集中操作类中的某几个属性。<br>    * 注（不是绝对的！“放盐少许”）：一个类的代码行数最好不能超过 200 行，函数个数及属性个数都最好不要超过 10 个。<br>* 类的职责是否设计得越单一越好？<br>    * 如：序列化和反序列化拆分成两个类：<br>        * 序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来 Serialization 高了。<br>        * 而且，如果我们仅仅对 Serializer 类做了协议修改，而忘记了修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错。<br>    * 单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。<br>* 不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准。   ","like_count":0},{"had_liked":false,"id":197664,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585390499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585390499","product_id":100039001,"comment_content":"单一职责这个还比较简单。","like_count":0},{"had_liked":false,"id":196741,"user_name":"Sissi.C","can_delete":false,"product_type":"c1","uid":1748046,"ip_address":"","ucode":"689AA6A8BE1687","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/4e/08b0644b.jpg","comment_is_top":false,"comment_ctime":1585309274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585309274","product_id":100039001,"comment_content":"听完这节课的例子终于解答了我关于类耦合的疑惑！","like_count":0},{"had_liked":false,"id":196575,"user_name":"Six","can_delete":false,"product_type":"c1","uid":1220617,"ip_address":"","ucode":"E297BB638B2BD9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","comment_is_top":false,"comment_ctime":1585294204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585294204","product_id":100039001,"comment_content":"&quot;类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；&quot; 这句话不太理解，比如UserInfo 依赖UserAddress和Userxxxx等等。依赖的Userxxx类比较多。那这时怎么分类。怎么将分类后的类组合到UserInfo中？","like_count":0},{"had_liked":false,"id":195426,"user_name":"熊猫","can_delete":false,"product_type":"c1","uid":1044216,"ip_address":"","ucode":"1C22CFD1652D9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/f8/bc5faaec.jpg","comment_is_top":false,"comment_ctime":1585187379,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585187379","product_id":100039001,"comment_content":"在微服务设计中， 也应当遵循单一职责原则， 尽量将相关业务内聚在微服务内， 从而实现服务内的高内聚， 降低其他服务的依赖， 对外实现低耦合。  <br><br>当我们遇到某个需求或者某者功能应该在哪个服务进行开发维护时， 可以看一下， 是否符合单一职责的原则。  ","like_count":0},{"had_liked":false,"id":194403,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585058384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585058384","product_id":100039001,"comment_content":"第一个问题，判断这个类是否单一可以思考这个类是否可以单独拿出来给其他项目使用而不必引入其他相关的很多类。代码行数多不多，可以考虑这个函数里面的一些代码是否可以抽出来放在工具类Util中。<br>第二个问题，单一职责也可以用在系统设计上面，比如微服务。在我们产品里面，每个软件负责一块特定的业务场景，这个业务场景都有共性。比如我们的网管服务器，就是用于和外部系统进行信息和协议转换的。比如我们的中心服务器，就是用于做信息缓存功能的，任何系统都是通过中心服务器获取需要的信息。","like_count":0},{"had_liked":false,"id":193815,"user_name":"陈包佳","can_delete":false,"product_type":"c1","uid":1576712,"ip_address":"","ucode":"9DAAC87C75D91F","user_header":"https://static001.geekbang.org/account/avatar/00/18/0f/08/7abf466e.jpg","comment_is_top":false,"comment_ctime":1584969595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584969595","product_id":100039001,"comment_content":"srp原则的学习理解：<br>1.单一职责原则的目的是？<br>将一个粗粒度的类拆分成力度更小，更细的类<br>，增加代码的可读性，可维护性，可扩展性。<br>2. 职责的划分根据应用场景和业务的不同而不同，没有明确的界限，可以先设计粗力度的类，在随着需求的变更细分为更细的力度类。<br>3.判断一个类的职责是否单一的方法？<br>首先判断这个类的属性是否过多，依赖的类较多增加了代码的耦合性，不易于维护，有大部分的方法是处理某些属性，或者私有方法过多可以考虑将私有方法拆分成另一类，并提升访问属性权限，为public，以提高代码的可复用性。<br>3. 累的拆分粒度过于细带来的影响<br>类的拆分力度过细，会降低代码的内聚性，不易于维护。<br>总体来说，单一职责原则要根据业务以及设计经验合理使用，不能，过分追求单一职责，这些设计原则目的还是为了提高代码的可读性，可维护性和可扩展性，实现代码的，高内聚，低耦合。","like_count":0},{"had_liked":false,"id":192288,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584845489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584845489","product_id":100039001,"comment_content":"“单一职责原则”也是微服务系统拆分的标准，软件设计大到一个系统、小到一个类，都需要界限清晰明确，否则可能写出来一团浆糊。","like_count":0},{"had_liked":false,"id":189295,"user_name":"mr.su","can_delete":false,"product_type":"c1","uid":1004716,"ip_address":"","ucode":"8A4B9910960118","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/ac/8b94b8b2.jpg","comment_is_top":false,"comment_ctime":1584496967,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584496967","product_id":100039001,"comment_content":"单一职责原则可以用到接口设计上，一个接口处理一件事情","like_count":0},{"had_liked":false,"id":187698,"user_name":"风清扬笑","can_delete":false,"product_type":"c1","uid":1028152,"ip_address":"","ucode":"C0494B7A97A628","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b0/38/076fa6c1.jpg","comment_is_top":false,"comment_ctime":1584195180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584195180","product_id":100039001,"comment_content":"争哥能不能推荐一点你认为应用了或者部分应用了SOLID原则的一些开源代码、框架或者库，学习下","like_count":0},{"had_liked":false,"id":187025,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1583993819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583993819","product_id":100039001,"comment_content":"组件化开发 ，模块化开发，微服务开发 应该都是单一原则的体现","like_count":0},{"had_liked":false,"id":185558,"user_name":"函数方程(弘宇)","can_delete":false,"product_type":"c1","uid":1695043,"ip_address":"","ucode":"FF32376E9B7C84","user_header":"https://static001.geekbang.org/account/avatar/00/19/dd/43/93f04f89.jpg","comment_is_top":false,"comment_ctime":1583633388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583633388","product_id":100039001,"comment_content":"争哥，问下，之前说UserInfo 类中，如果UserInfo 类中地址address占比比较高，可以将其拆分出来，新建一个userAddress类，那么是否就是说UserInfo类中就不包含address字段信息了。但是如果UserInfo是一个DTO（用于传输数据的类），address字段就不应该从UserInfo类中删除了？","like_count":0},{"had_liked":false,"id":183862,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1583148351,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583148351","product_id":100039001,"comment_content":"【设计模式笔记16】20200301<br>今天主要讲了单一职责原则，大概给出了一些判断方法，不过每个人的经验和理解会不一样，我是这么理解的，一一个旁观者的角度审视代码，这样写是否只做了一件事，是从哪个角度考虑的，当前的代码不符合的话是否是从另外的角度考虑的。看代码就像看文章，把握要点，如果主旨不清晰肯定是有问题。我自己就会遇到你理解这个模块应该只做这些事，但是从另外的角度也可以做其他事，所以沟通很重要。当然也有一些通用的规约，类太长、方法太多、耦合严重等都是一些标准，更多可以参考阿里巴巴Java开发规约，但是我们要明白本质和原因才能真正理解。","like_count":0},{"had_liked":false,"id":182620,"user_name":"小田","can_delete":false,"product_type":"c1","uid":1073342,"ip_address":"","ucode":"59CA02059F71E4","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/be/68ce2fd0.jpg","comment_is_top":false,"comment_ctime":1582816941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582816941","product_id":100039001,"comment_content":"# 要点小结<br>1. 相互关联的属性&#47;方法，置于同一个类中，不要拆；反之，不要将不相关的属性&#47;方法置于一个类中。<br>2. 一个对象如果只被一个类持有，则置于类中；若被多个类持有，则单独封装成类。<br>3. 为了保证不同类之间“低耦合”：避免设计大而全的类，避免将不相关的功能耦合在一起<br>5. 为了保证类的“高内聚”：不要将属于一个类的不同属性拆分得过细","like_count":0},{"had_liked":false,"id":182474,"user_name":"xyz","can_delete":false,"product_type":"c1","uid":1016059,"ip_address":"","ucode":"CA183740FB5C9D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/fb/ffa57759.jpg","comment_is_top":false,"comment_ctime":1582793681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582793681","product_id":100039001,"comment_content":"看到这里的单一原则，想起来Unix文化中的一点：让每个程序只做好一件事情。<br>","like_count":0},{"had_liked":false,"id":180856,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582429965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582429965","product_id":100039001,"comment_content":"喜欢这种提个问题，再追问一个问题的讲解方式，有料；单一职责，高内聚，低耦合；易读、易维护、易复用；","like_count":0},{"had_liked":false,"id":180732,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582376403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582376403","product_id":100039001,"comment_content":"游戏的需求出自于策划，必须持续重构才能跟得上需求变动。单一设计原则是一个非常有用的判断工具，对于已经不可维护的代码，最好就是建立测试用例，小步快跑地重构。","like_count":0},{"had_liked":false,"id":180354,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582266577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582266577","product_id":100039001,"comment_content":"<br>1.如同老师说的,判断单一职责原则是一种主观的问题,我个人也没有什么好方法,只是单纯的觉着这个类合适,这个类不适合再增加或者再减少属性了,就是一个足够合适的单一职责类<br>2.这个原则在描述中写了,适合于类和模块的设计,那么就是在类的基础上,保证模块的功能单一,再往上延伸到实际开发中,就是在项目的微服务中,让每一个微服务所提供的的功能足够单一,组合起来实现一个完整的系统","like_count":0},{"had_liked":false,"id":180018,"user_name":"向往而行","can_delete":false,"product_type":"c1","uid":1141676,"ip_address":"","ucode":"AE01D637B946C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/6b/ac/cc187d8d.jpg","comment_is_top":false,"comment_ctime":1582166423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582166423","product_id":100039001,"comment_content":"单一职责不只是要求不要让一个模块干多件事情，同时也要求不要让它不干事情。","like_count":0},{"had_liked":false,"id":179732,"user_name":"一区","can_delete":false,"product_type":"c1","uid":1793770,"ip_address":"","ucode":"B5142A6276E490","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a2mRI7BYncHCL6QWfibe7g7MWc70fSsqQibu7o9PcHjicYwo5dSnAoUN75HDDRz4GXWJdpWw59yJsMwFv3t7zSiaJQ/132","comment_is_top":false,"comment_ctime":1582085133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582085133","product_id":100039001,"comment_content":"做过一个互联网金融的项目，一个数据表中有一百多个字段，而且都是同等作用的描述属性。觉得单一职责原则和代码的高内聚低耦合原则，用不好就是冲突的","like_count":0},{"had_liked":false,"id":176418,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1581055340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581055340","product_id":100039001,"comment_content":"高内聚，低耦合<br>我是这样理解的<br>对于一些功能类似的方法放在一起，是为了高内聚；<br>对于一些功能不相关的方法不放在一起，是为了低耦合。<br>","like_count":0},{"had_liked":false,"id":175769,"user_name":"Cindy_Yu","can_delete":false,"product_type":"c1","uid":1328604,"ip_address":"","ucode":"EE6869CAC5C1EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/45/dc/a3a231d1.jpg","comment_is_top":false,"comment_ctime":1580825604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580825604","product_id":100039001,"comment_content":"单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？可以用到方法设计和接口设计上。安卓开发的act常常是以页面来划分，一个act上要实现很多内容。这样网络请求的接口，按钮点击事件的响应方法就特别需要符合单一原则。","like_count":0},{"had_liked":false,"id":174137,"user_name":"cbping","can_delete":false,"product_type":"c1","uid":1608798,"ip_address":"","ucode":"16D891E80A352B","user_header":"https://static001.geekbang.org/account/avatar/00/18/8c/5e/8cb6fad1.jpg","comment_is_top":false,"comment_ctime":1580022872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580022872","product_id":100039001,"comment_content":"私有方法，很多时候都是需要复用得功能","like_count":0},{"had_liked":false,"id":172658,"user_name":"北风一叶","can_delete":false,"product_type":"c1","uid":1087302,"ip_address":"","ucode":"30310E66341D2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","comment_is_top":false,"comment_ctime":1579246634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579246634","product_id":100039001,"comment_content":"类的单一职责功能，要从业务的角度划分，根据业务的需求分析是否归为同一个职责，这个并没有统一的定论，也没有什么量化标准。这个东西只能写，写多了就有感觉了。","like_count":0},{"had_liked":false,"id":172591,"user_name":"wakaka","can_delete":false,"product_type":"c1","uid":1471508,"ip_address":"","ucode":"835A7341577D3B","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/14/ea854bfc.jpg","comment_is_top":false,"comment_ctime":1579228858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579228858","product_id":100039001,"comment_content":"职责单一的概念在不同业务场景每个人都有不同的理解，很难有定量标准，但是目标是不变的，都是为了代码的可读性，可维护性，可扩展性。","like_count":0},{"had_liked":false,"id":171687,"user_name":"www","can_delete":false,"product_type":"c1","uid":1275203,"ip_address":"","ucode":"951B364F2CB211","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg","comment_is_top":false,"comment_ctime":1578992015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578992015","product_id":100039001,"comment_content":"在go语言中，不要设计大而全的接口，要设计功能单一的小接口，匿名嵌入到大接口中","like_count":0},{"had_liked":false,"id":170493,"user_name":"wai","can_delete":false,"product_type":"c1","uid":1439529,"ip_address":"","ucode":"29CE3BE148FB79","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/29/60e01017.jpg","comment_is_top":false,"comment_ctime":1578621356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578621356","product_id":100039001,"comment_content":"方法的设计也有遵循单一职责，否则耦合的过于严重，修改方法造成的影响点很大，可读性也很差","like_count":0},{"had_liked":false,"id":169808,"user_name":"未来的胡先森","can_delete":false,"product_type":"c1","uid":1234682,"ip_address":"","ucode":"AFF193AC0E2E6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/fa/1f5bf642.jpg","comment_is_top":false,"comment_ctime":1578449675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578449675","product_id":100039001,"comment_content":"课后思考  2，单一职责在数据库中的应用就是数据库的范式设计，当一张表中存放了过多冗余、非主属性依赖的字段（单个类承载了过多职责），就会出现更新插入删除异常，所以第一第二范式通常是在设计关系型数据库是需要满足的，第三范式结合业务场景满足。<br>同理问题 1 应该也能参照数据库设计来判断是否代码是否规范","like_count":0},{"had_liked":false,"id":169778,"user_name":"顺","can_delete":false,"product_type":"c1","uid":1242973,"ip_address":"","ucode":"20230CA126824A","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/5d/818ec2a7.jpg","comment_is_top":false,"comment_ctime":1578445446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578445446","product_id":100039001,"comment_content":"职责单一不仅用于业务逻辑 界面职责单一也尤其重要 有些公用的界面比如输入用户信息、输入金额等就应只用于获取输入的信息 而不应该由于流程把其它的业务逻辑在公用界面嵌套if...else加入业务逻辑 <br>开发中判断这个类或模块是否职责单一得看场景需求 个人一般做法 就是看这个类或模块是否可以直接或快速拷贝重用 因为有时候由于定制项目 好多业务或功能相同 但又有区别无法做成组件 有时候能提高copy的效率优于过度设计组件。","like_count":0},{"had_liked":false,"id":169167,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1578282719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578282719","product_id":100039001,"comment_content":"单一的好处：高内聚、低耦合、复用<br>判断是否符合单一的<br>1.看代码行数是不是很多（比如成员属性、方法之类的），很多的话就要考虑拆<br>2.看是不是符合高内聚（功能多，聚合在一起）、低耦合。类依赖或者被依赖的类多就要考虑了<br>3.相同功能的私有方法过多，考虑把这些公共的方法提取出来<br>4.用业务来起名字难，名字笼统是因为可能包含了一些功能，比如OrderInfoController、OrderMangeContr、OrderCommonController。<br>5.其它的地方调用的大部分都是这个类的一部分属性，可以将这些抽取出来<br>6.其它类调用的时候，看看是不是有一大堆自己没用的东西<br>7.看这个类对应表，是不是有数据库其它表的字段，如果只是省市区（三个属性左右）就情有可原，但如果有好几张表就过分了<br>一个类的代码行数最好不能超过 200 行，函数个数及属性个数都最好不要超过 10 个（只是用于参考，但不是绝对）<br>不适合拆的：一些情况下分的太细也不是好事。比如一个加密解密类拆成一个加密，一个解密，原来是用MD5加密的，现在改成了AES加密，那么这两个类都需要改，如果不小心忘了一个就得不偿失，这样也增大了代码的维护性难度<br><br><br>讨论：<br>单一涉及原则除了应用在类上，还有在接口上，不要想接口除了主要的功能还帮你去处理一些无关的。比如去查询用户的流水，就不要再去考虑查之前先判断修改钱包的钱。","like_count":0},{"had_liked":false,"id":168806,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1578189641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578189641","product_id":100039001,"comment_content":"单一职责用在模块划分可以作为微服务的一种边界划分的参考","like_count":0},{"had_liked":false,"id":168805,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1578189451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578189451","product_id":100039001,"comment_content":"1.阿里手册一个方法不要超过80行，超过80行就该拆分了。<br>2.单一职责原则，属于相关功能的信息划分在一起，既可以避免拆分过细，又避免了耦合。","like_count":0},{"had_liked":false,"id":167949,"user_name":"LYy","can_delete":false,"product_type":"c1","uid":1102062,"ip_address":"","ucode":"8D5C39B9531E71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ee/f5c5e191.jpg","comment_is_top":false,"comment_ctime":1577968313,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577968313","product_id":100039001,"comment_content":"单一职责原则 可以说是复杂度应对的底层(核心)原则 下到CPU机器码指令 中到代码模块 上到领域架构模型 无一不能用SRP大展拳脚 同时也无一不需要思考权衡”单一”的粒度<br>纵向应用单一职责分模块 横向利用单一职责分层 几乎是所有软件系统中最常见的复杂度控制手段 其实不仅是软件领域 社会分工&#47;分层何尝不也是SRP的体现？(出圈了 哈哈哈)<br>SRP是唯一上升到“道”的高度的设计原则","like_count":0},{"had_liked":false,"id":167804,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1577937430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577937430","product_id":100039001,"comment_content":"比如我设计一个conf表，字段有infoId,pid,type<br>然后就是各种配置表，比如imageInfo表，imageTagInfo表有10几个不同配置表。我根据conf表的type和infoId找到对应的info数据。但是如果我有一些info表之间的逻辑处理，比如image和imageTag，我目前是吧代码逻辑写在conf表的BO里面的。根据单一原则，那这个conf表的BO是不是包含的逻辑太多了","like_count":0},{"had_liked":false,"id":167637,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1577884453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577884453","product_id":100039001,"comment_content":"面向对象编程，每一个实体一个对象。这种编程风格是不是从大的层面看也是单一职责原则。把对象相关的属性和方法进行封装。而面向过程的方式，就是把过程用到的都写到一起。","like_count":0},{"had_liked":false,"id":167183,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1577709551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577709551","product_id":100039001,"comment_content":"单一职责可以用在系统拆分上，也就是模块拆分，把公共的功能或业务拆分到同一个系统上，降低系统之间的耦合，高内聚低耦合，而且系统之间交互最好是MQ，无感知的。","like_count":0},{"had_liked":false,"id":166164,"user_name":"Zhen","can_delete":false,"product_type":"c1","uid":1643029,"ip_address":"","ucode":"4235C791CB4A5D","user_header":"https://static001.geekbang.org/account/avatar/00/19/12/15/874b9d62.jpg","comment_is_top":false,"comment_ctime":1577410127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577410127","product_id":100039001,"comment_content":"相关资料上有这样的关于SRP的描述【1】：“Gather together the things that change for the same reasons. Separate those things that change for different reasons.”<br><br>因相同的原因一起“变化”的功能就放在一起，因不同原因变化的功能就分出来。<br><br>按照内在的&quot;变化&quot;划分，而不是按照表面的“行为”进行划分。<br><br>有些功能要因为相同的原因而变化，就把它们放在一个类或功能模块里；比如前面所举的序列化和反序列功能，如果我们修改了协议的格式，数据标识从“UEUEUE”改为“DFDFDF”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，它们以相同的原因一起变化，所以最好不要拆分。<br><br>【1】https:&#47;&#47;medium.com&#47;better-programming&#47;revisiting-solid-927e6a5202d3<br>","like_count":0},{"had_liked":false,"id":165498,"user_name":"Seeker","can_delete":false,"product_type":"c1","uid":1180644,"ip_address":"","ucode":"C5F22962B8CE0D","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/e4/0cb8dcaf.jpg","comment_is_top":false,"comment_ctime":1577245901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577245901","product_id":100039001,"comment_content":"有可能是写的代码还不是很多的原因，看完这儿之后并没有什么深刻的感悟。<br>我们一般都是看到类实在是太大太长了，就会想着重构一下。但是也仅限于重构成方法，拆成多个类倒是比较少见。这可能我们是一个框架的原因，一些类中的方法一旦定义好了，再拆分改动的话容易引入后向不兼容的问题。<br>这样只能保留原来的方法，最多就是把一些他的逻辑放到另外一个类里，再用组合的方式调用其中的方法。但是感觉也只是好了一点点。","like_count":0},{"had_liked":false,"id":165132,"user_name":"假如年少有为","can_delete":false,"product_type":"c1","uid":1698072,"ip_address":"","ucode":"781E9DF18B95C5","user_header":"https://static001.geekbang.org/account/avatar/00/19/e9/18/d047ff86.jpg","comment_is_top":false,"comment_ctime":1577169343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577169343","product_id":100039001,"comment_content":"在父类定义公共属性","like_count":0},{"had_liked":false,"id":164554,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1577026489,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1577026489","product_id":100039001,"comment_content":"1.第一个话题，对于类职责是否单一通常情况下我也会去了解这个类的使用的业务场景以及抽象的业务对象是否能够匹配当前类的使用业务范围，业务范围的界定其实就是个人的理解了<br>2.第二个话题，方法的单一职责，比如在一个大的业务方法中，其中相关的调用的子业务方法必须处于同一层级，如果不是，那说明当前的方法还有再次提取优化的空间，直至下层的方法都处于同一层级，当然想法比较的完美，实际的情况都是一步一步的进行优化处理的","like_count":0},{"had_liked":false,"id":164473,"user_name":"Arthur.Li","can_delete":false,"product_type":"c1","uid":1005824,"ip_address":"","ucode":"EC2436A5136C13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/00/6d14972a.jpg","comment_is_top":false,"comment_ctime":1577002604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577002604","product_id":100039001,"comment_content":"判断类的职责是否单一<br>* 类中的代码行数、函数或者属性过多；<br>* 类依赖的其他类过多，或者依赖类的其他类过多；<br>* 私有方法过多；<br>* 比较难给类起一个合适的名字；<br>* 类中大量的方法都是集中操作类中的某几个属性。<br><br>不能为了单一职责原则，把很多类拆的太细。这样会影响代码可维护性，降低内聚性。<br><br>&gt; 我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构<br><br>单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？<br>答：最需要单一职责的应该就是方法了吧。因为不注意或者懒省事，好多时候一个方法会做多件事，或者顺便把某个别的也做了，虽然和当前方法有关系。","like_count":0},{"had_liked":false,"id":164124,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1576889240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576889240","product_id":100039001,"comment_content":"「类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分」这句话是否可以理解为：一个功能被散落在多个类中，应该重新整合共同完成该功能的所有类，将完成功能的“同性质”步骤归并到同一个类中。","like_count":0},{"had_liked":false,"id":163313,"user_name":"熊🐻","can_delete":false,"product_type":"c1","uid":1027320,"ip_address":"","ucode":"16779B8E2A8752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/f8/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1576684286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576684286","product_id":100039001,"comment_content":"单一职责：代码块只有一个修改预期，有多个则拆分，没有的话在user类里面耦合商品属性都行。","like_count":0},{"had_liked":false,"id":162325,"user_name":"瑞泉","can_delete":false,"product_type":"c1","uid":1111565,"ip_address":"","ucode":"D38E24A98FDAE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/0d/e16dff4e.jpg","comment_is_top":false,"comment_ctime":1576500395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576500395","product_id":100039001,"comment_content":"如果把地址相关属性抽出来构建一个新对象，那么原user对象中是不是应该增加一个新的地址对象？另外在做概览这种可视化页面，需要调用多个模块的数据是否违背单一原则？","like_count":0},{"had_liked":false,"id":161778,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1576325144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576325144","product_id":100039001,"comment_content":"单一职责（一个萝卜一个坑）、里氏替换（继承复用）、依赖倒置（面向接口编程）、接口隔离（高内聚、低耦合）、迪米特法则（降低类与类之间的耦合）、开闭原则（对扩展开发、对修改关闭）。","like_count":0},{"had_liked":false,"id":161597,"user_name":"Geek_e9b8c4","can_delete":false,"product_type":"c1","uid":1716601,"ip_address":"","ucode":"C29F7344A6EE6B","user_header":"","comment_is_top":false,"comment_ctime":1576243645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576243645","product_id":100039001,"comment_content":" <br>DS：曾经做过有个物流项目，比如有两个方法，1、查询司机订单；2、查询企业订单，这两个方法是都放OrderService 呢，还是分别放在DriverService和CompanyService类里？ 简单的判断就是根据返回的类型来决定。返回订单类型的方法就放在OrderService。现实项目中遇到过很多类似的功能方法，不知道到哪去找！","like_count":0},{"had_liked":false,"id":161592,"user_name":"Geek_e9b8c4","can_delete":false,"product_type":"c1","uid":1716601,"ip_address":"","ucode":"C29F7344A6EE6B","user_header":"","comment_is_top":false,"comment_ctime":1576241169,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576241169","product_id":100039001,"comment_content":"DS:一处修改引起了多处功能性质类似的类的变动 ，或者多个类中的代码有重复，一个思考方向：考虑合并为同一个类","like_count":0,"discussions":[{"author":{"id":1698072,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e9/18/d047ff86.jpg","nickname":"假如年少有为","note":"","ucode":"781E9DF18B95C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98529,"discussion_content":"个人感觉抽取一个公共的父类存放公共属性和方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577169428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161569,"user_name":"Varus","can_delete":false,"product_type":"c1","uid":1715988,"ip_address":"","ucode":"B9CB88C248BD93","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/14/840d0925.jpg","comment_is_top":false,"comment_ctime":1576234483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576234483","product_id":100039001,"comment_content":"1、就是自己感觉自己写的类结构不清晰，自己很容易忘记类中的方法的时候，每当有修改或者新加的功能时，自己都会觉得烦，都不愿意去重新审视自己代码的时候，没有问题，这个职责一定不单一了，重构吧！！！<br>2、单一值择让我想起来今天看到的微服务，面向对象万岁！！！","like_count":0},{"had_liked":false,"id":161343,"user_name":"CDz","can_delete":false,"product_type":"c1","uid":1114779,"ip_address":"","ucode":"A23BEE1C4A5922","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9b/b1a3c60d.jpg","comment_is_top":false,"comment_ctime":1576196225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576196225","product_id":100039001,"comment_content":"单一原则，很多时候其实很难鉴定一个模块、类的单一原则。需要根据当前的业务去做规划。<br>- 持续重构，将重构当做平时开发的一部分，持续的去做<br>- 业务场景的增加，会使得原来单一原则不灵<br> - 比如用户类，开始业务简单可以放置很多信息<br> - 业务复杂后，比如增加电商模块，地址就需要抽离<br> - 更复杂的，多系统后，用户类就会只剩下用户名和密码","like_count":0},{"had_liked":false,"id":161215,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1576149583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576149583","product_id":100039001,"comment_content":"课后讨论1：如何判断一个类是否职责单一， 类职责不单一，要做的事情太多了，不是单一的业务场景。<br>课后讨论2：责任链模式，每一环只做自己该做的，比如Netty不同的Handler","like_count":0},{"had_liked":false,"id":161180,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1429627,"ip_address":"","ucode":"9DFFD6E3960CF7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","comment_is_top":false,"comment_ctime":1576138214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576138214","product_id":100039001,"comment_content":"课后第二个问题 。单一职责 在项目工程里也有指导思想。<br> 类有单一职责，一个模块也有单一职责。<br>基础的功能组件是一个模块，网络，下载，日志等等。 每个模块要保持功能单一。 <br>业务也可以拆分成模块。比如登录模块，订单模块，个人信息模块。 <br>业务组件之间可以相互调用，但是不能依赖。达到代码隔离，业务独立。<br>如果有业务层通用的模块，可以再抽一层通用业务层。被各个业务线依赖。<br> 功能组件可以直接被依赖，达到复用。<br>所以单一职责这个原则 贯穿了整个项目工程的设计和架构。小到一个类的设计，大到一个模块，一个组件的设计，甚至一个工程的设计。","like_count":0},{"had_liked":false,"id":161074,"user_name":"Mr.Strive.Z.H.L","can_delete":false,"product_type":"c1","uid":1030198,"ip_address":"","ucode":"6D97E159E2EECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/36/542c96bf.jpg","comment_is_top":false,"comment_ctime":1576114419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576114419","product_id":100039001,"comment_content":"个人认为最能够体会设计原则的深层含义的方法：<br>将所有代码都写到一个类中，然后再去重构这个类。<br><br>不管是单一原则还是其他原则，核心目的都是为了 高内聚低耦合，代码复用，可读性，可维护性。 设计原则是指导思想，但是上述的核心目的是互相牵制的，一旦过度遵循某个原则，可能导致 代码复用度非常高，但是可读性和可维护性下降。<br>所以，在理解设计原则的基础上，结合真实的业务需求，去设计最符合的当前场景的代码，然后随着需求迭代进行持续重构。<br>","like_count":0},{"had_liked":false,"id":160784,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1576032232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576032232","product_id":100039001,"comment_content":"任何一个软件模块都应该只对某一类行为者负责.","like_count":0},{"had_liked":false,"id":160743,"user_name":"晨间新闻","can_delete":false,"product_type":"c1","uid":1161406,"ip_address":"","ucode":"6F7A55AAD52F16","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/be/2d77d643.jpg","comment_is_top":false,"comment_ctime":1576027922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576027922","product_id":100039001,"comment_content":"老师，请教个问题，项目中，经常一个业务类里面包含了很多的业务逻辑，为了方法的简洁，也在这个业务类中写了很多只被该类调用的private类。<br>那么，想对这个业务类减负，有什么办法么？","like_count":0},{"had_liked":false,"id":160697,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1576023647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576023647","product_id":100039001,"comment_content":"1, 判定是否符合SRP，还可以从以下几点: <br>(1)对外提供的api接口是否功能单一，单个接口只完成一种功能;<br>(2)类中的某个方法代码数量是否太多，很难看懂方法整体逻辑。可以考虑拆分为多个子方法，方便日后代码维护，拓展等等;<br><br>2,单一原则是一种指导思想，让设计的功能简单，逻辑清晰，利于后期维护升级。这样的思想很宽泛，除了类，方法可借鉴。还可以指导项目模块的划分，多个独立的模块聚合成为完整的项目(例如 mapper model api  common等) 。往后需要拆分项目可以按模块拆分即可。<br>而微服务拆分为功能单一服务(例如用户SSO) 进而达到服务高可用，可维护，快速迭代的目的。","like_count":0},{"had_liked":false,"id":160577,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1575978737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575978737","product_id":100039001,"comment_content":"今天课堂讨论的话题有两个：<br>对于如何判断一个类是否职责单一，如何判断代码行数过多，你还有哪些其他的方法吗？<br>答： 如果两个类因为不同的目的引用了同一个给类时，那说明被引用的这个类职责不够单一，可以考虑拆解。<br>单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？<br>答：也可以适用于方法上面，当我们写UT 的时候，如果一个方法需要测试多个不同的功能实现，那么也应该考虑将该方法拆成多个方法","like_count":0},{"had_liked":false,"id":160423,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1575948248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575948248","product_id":100039001,"comment_content":"用户地址和用户信息可以分离，一下子让我顿悟了。之前就一直纠结到底是拆开还是合并。这个专栏让我脱离不规范，不确定，任意妄为的野路子开发。不过我觉得项目刚开始建立，定义的地址一定要明确。社交的地址应该是居住地或者家庭地址，和用户信息放一块。而收获地址是另一个模块，新增一张收获地址表。同时保留用户信息表中的家庭住址。","like_count":0},{"had_liked":false,"id":160279,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1575903944,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575903944","product_id":100039001,"comment_content":"问题1: 某个类是否会由于两个或多个不同的需求而需要改动，如果是，要么是这个类属于脚本类，本来就用于这个；要么就是这个类需要拆分了。<br><br>问题2: 单一职责原则还可以用于微服务架构的设计上，一个微服务就类似于一个类；这个原则还可以用于个人工作和团队管理，对于个人来说，在某段时间不要承担过多的责任。","like_count":0},{"had_liked":false,"id":160277,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575903834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575903834","product_id":100039001,"comment_content":"我的理解是。这个模块或者类 做了太多和本类无关的逻辑操作 就需要拆分了","like_count":0},{"had_liked":false,"id":160225,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1575894592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575894592","product_id":100039001,"comment_content":"总结：单一职责需要根据实际项目进行判断，类的设计是否满足单一职责，没有万能的方式，只有不断的积累，才能把握设计那个度","like_count":0},{"had_liked":false,"id":160191,"user_name":"xdargs","can_delete":false,"product_type":"c1","uid":1063740,"ip_address":"","ucode":"EB8326D3A72DE5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoH9Mlw0kLK0p39vhQpdvkbQP5TX96DB9HMJ1POaTVDpMZg4rjlO3WCAqiaWWMc77ffS3vTo8qWdXA/132","comment_is_top":false,"comment_ctime":1575888796,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575888796","product_id":100039001,"comment_content":"最近简单看过下systemd，很多的争议在违反了less is more的设计哲学，啥都想做导致问题不断和作为linux核心基础模块稳定性不足，这个跟单一原则有共性吧","like_count":0},{"had_liked":false,"id":160173,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1575885348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575885348","product_id":100039001,"comment_content":"课堂讨论Answer:<br><br>1. 对于如何判断一个类是否职责单一，如何判断代码行数过多，你还有哪些其他的方法吗？<br><br>我认为看一个类职责是否单一,类的依赖关系是一个比较重要的量化指标.其次,根据业务的大小不同, 代码行数也可以作为一个量化指标.比如仅涉及序列化的类,它的代码不超过100行是符合SRP的,反之就不符合。<br>再比如电商+社交项目的UserInfo类，它的代码行数不超过200行是没问题的，若超过了，最好拆分成多个更细粒度的类。这里的100， 200行仅是一个说明，其具体行数要根据业务的大小做出改变。<br>2. 单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？<br><br>在个人资产配置中,通常用于投资的钱,和用于消费的钱永远是泾渭分明的,这是单一职责原则的一种体现.","like_count":0},{"had_liked":false,"id":159840,"user_name":"塔兹米","can_delete":false,"product_type":"c1","uid":1425252,"ip_address":"","ucode":"1A58C81EF9B0A4","user_header":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","comment_is_top":false,"comment_ctime":1575808303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575808303","product_id":100039001,"comment_content":"打卡。<br>写的真好！","like_count":0},{"had_liked":false,"id":159815,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1575797047,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575797047","product_id":100039001,"comment_content":"1.现在就是一个方法行数是不是超过100行，如果超过，就要思考是否承担了比较多的职责，或者做了比较多的重复工作（各种对象之间的转换）<br>2.单一职责：小到一个方法，大到一个微服务的边界划定，以及生活工作中一个时刻专注一件事情都是相通的","like_count":0},{"had_liked":false,"id":159798,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1575792863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575792863","product_id":100039001,"comment_content":"原来我写的业务, 大部分都放在大而全的类里面了, 如何判断代码行数过多,更多的四凭借经验吧, 或者说是直觉, 如果写的代码看上去很凌乱, 自己都看不下去了, 那真的到了要优化的时候了, 但是往往自己写的代码很烂, 但是有懒得优化, 导致越来越烂","like_count":0},{"had_liked":false,"id":159706,"user_name":"　扬帆丶启航　","can_delete":false,"product_type":"c1","uid":1235282,"ip_address":"","ucode":"4079D0889CD86C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/52/73351eab.jpg","comment_is_top":false,"comment_ctime":1575732547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575732547","product_id":100039001,"comment_content":"方法写的很混乱，可能是代码行数过多引起的吧","like_count":0},{"had_liked":false,"id":159658,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1575720721,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575720721","product_id":100039001,"comment_content":"1. 看这个类内部定义的属性是否都有关联 <br>2. 可以应用到函数上","like_count":0},{"had_liked":false,"id":159606,"user_name":"操盘手爱德华","can_delete":false,"product_type":"c1","uid":1366402,"ip_address":"","ucode":"CAAF3E6DC9D5FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIFicK7Bn88Lqte7rURlw3Lf53oAu1jhiciaVlKLib48dlIAOAF03L7tjQcx1ia5AJI26S7HIxwx780Qzw/132","comment_is_top":false,"comment_ctime":1575703066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575703066","product_id":100039001,"comment_content":"除了单一职责本身之外，我觉得争哥还想说的是职责是随着项目的变化而发生变化的。职责的边界要根据当前项目的实际情况来看，并不能为了设计而设计，过渡设计不是设计。","like_count":0},{"had_liked":false,"id":159597,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1575701282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575701282","product_id":100039001,"comment_content":"单一职责原则<br>一个类或模块只负责一个职责或者功能<br>根据不同的业务场景设计类<br>凭感觉","like_count":0},{"had_liked":false,"id":159573,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1575690463,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575690463","product_id":100039001,"comment_content":"老师我想问一个问题： 在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。问题是：要拆分成更细的类，会导致一堆代码都得修改，这样做合理吗？","like_count":0,"discussions":[{"author":{"id":1716601,"avatar":"","nickname":"Geek_e9b8c4","note":"","ucode":"C29F7344A6EE6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290825,"discussion_content":"重构必然是要修改代码的，这个跑不了。但不进行重构，后续开发效率等都会受到影响，如果你接手过烂系统应该会更有体会，早改早超生！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594614450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159544,"user_name":"风行者","can_delete":false,"product_type":"c1","uid":1541934,"ip_address":"","ucode":"F058640CF77A35","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/2e/ea54c240.jpg","comment_is_top":false,"comment_ctime":1575678683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575678683","product_id":100039001,"comment_content":"打卡，solid常在心中，设计时形成思维习惯，单一职责原则，类<br>1.是否好取名字<br>2.在感觉功能单一的情况下不过度设计，后期随需求进行重构<br>3 类依赖如果太多，就要停下来想想是否可以拆分<br>4.类方法或行数过多考虑拆分<br>总结下：1好2少，好取名，少依赖，行数少<br>除了应用在类的设计上，还有接口，模块<br>","like_count":0},{"had_liked":false,"id":159526,"user_name":"Panmax","can_delete":false,"product_type":"c1","uid":1004871,"ip_address":"","ucode":"9D65E3B84C5519","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/47/d217c45f.jpg","comment_is_top":false,"comment_ctime":1575647722,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575647722","product_id":100039001,"comment_content":"请问前半句「类依赖的其他类过多」可以理解，后半句「或依赖类的其他类过多」是什么意思，能举个例子吗？","like_count":0,"discussions":[{"author":{"id":1406929,"avatar":"https://static001.geekbang.org/account/avatar/00/15/77/d1/a7a4bc63.jpg","nickname":"心雨Kanade","note":"","ucode":"F641E55F338A3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75833,"discussion_content":"应该是依赖和被依赖的过多的意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575785728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159524,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1575647001,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"1575647001","product_id":100039001,"comment_content":"类依赖的其他类过多，或者依赖类的其他类过多。<br>-------------<br>后半句是什么意思，什么叫“依赖类的其他类过多”，哪位同学帮忙说说。","like_count":0,"discussions":[{"author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74884,"discussion_content":"这句话是说：类A所依赖的其他类过多，或者依赖类A的其他类过多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575700984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75204,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575726761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74884,"ip_address":""},"score":75204,"extra":""}]}]},{"had_liked":false,"id":159508,"user_name":"Y024","can_delete":false,"product_type":"c1","uid":1018056,"ip_address":"","ucode":"397126D2E17997","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/c8/ae476935.jpg","comment_is_top":false,"comment_ctime":1575641647,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1575641647","product_id":100039001,"comment_content":"Day032 15<br>SRP是所有原则中最简单的原则之一，也是最难正确运用的原则之一。一方面我们需要注意把多个职责进行分离；另一方面，如果应用程序的变化方式总是导致多个职责同时变化，那么就不必分离它们。","like_count":0},{"had_liked":false,"id":159468,"user_name":"大帅哥","can_delete":false,"product_type":"c1","uid":1333009,"ip_address":"","ucode":"4B5F9550663778","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUXWqIBiadT4BYND0k3XwORqkW8j4q0GLyaXylG5ibfNnQaAQ26PQIvd4bp9uFrlp9QhV4YXpVfdzg/132","comment_is_top":false,"comment_ctime":1575631023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575631023","product_id":100039001,"comment_content":"1、if else语句多，条件判断多了？<br>2、单一职责除了类设计，模块设计。还有函数、微服务以及系统设计","like_count":0},{"had_liked":false,"id":159452,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1575626609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575626609","product_id":100039001,"comment_content":"简单易懂,适合我这种小学生","like_count":0},{"had_liked":false,"id":159421,"user_name":"L","can_delete":false,"product_type":"c1","uid":1534988,"ip_address":"","ucode":"BBBA0AE1856DD7","user_header":"https://static001.geekbang.org/account/avatar/00/17/6c/0c/9693fba5.jpg","comment_is_top":false,"comment_ctime":1575620361,"is_pvip":false,"replies":[{"id":"61133","content":"使用设计模式跟spring mvc或者其他框架关系不大哈，还是聚焦于你的业务是否需要使用设计模式","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1575896768,"ip_address":"","comment_id":159421,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575620361","product_id":100039001,"comment_content":"你好，我想问下如何在spring mvc下使用设计模式，或者说在框架下如何使用设计模式","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477052,"discussion_content":"使用设计模式跟spring mvc或者其他框架关系不大哈，还是聚焦于你的业务是否需要使用设计模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1534988,"avatar":"https://static001.geekbang.org/account/avatar/00/17/6c/0c/9693fba5.jpg","nickname":"L","note":"","ucode":"BBBA0AE1856DD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77846,"discussion_content":"谢谢哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575946924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159367,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1575607151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575607151","product_id":100039001,"comment_content":"单一职责原则<br><br>What<br>一个类只负责完成一个职责或者功能。<br><br>How<br>不同的应用场景、需求背景、业务，对一个类职责是否单一，会有不同的判定结果。<br><br>总体上可以使用下面的方式进行“粗略”的判断：<br><br>- 类中的代码行数、函数或者属性过多；<br>- 类依赖的其他类过多，或者依赖类的其他类过多；<br>- 私有方法过多；<br>- 比较难给类起一个合适的名字（说明功能混杂）；<br>- 类中大量的方法都几种操作类中的几个属性。<br><br>Why<br>实现高内聚、低耦合、提高代码的复用性、可读性、可维护性。<br><br><br>单一职责原则如果滥用，效果会适得其反，本属于同一类的功能，被过度拆分，反而降低内聚性，可能增添频繁传递数据的负担。并且拆分过细，会导致过多的文件数量，增加整个工程的复杂度。<br>","like_count":0},{"had_liked":false,"id":159343,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1575602603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575602603","product_id":100039001,"comment_content":"1. 仅通过代码行数来判断是否是SRP，太武断；好的做法还是应该把功能放在实际的需求场景、业务场景、成本、紧急程度等众多因素中，去考量引起变化的因素是不是有多个，如果存在多个，就尽量做拆分，要做到：接口一定要SRP，实现类的设计尽量做到只有一个原因引起变化。这个度确实很难掌握，有可能会拆分过细，带来复杂性，增加心智负担<br>2. SPR 除了应用在类的设计上，还可以应用在方法的划分上，每个方法（函数）也尽量做到职责明确，这样有助于代码维护和可读性；此外，还可以应用在系统设计上，比如划分子系统，子系统划分模块，都尽量做到职责明确，最好一件事情，其实微服务也能算是一种 SRP 的实践。","like_count":0},{"had_liked":false,"id":159316,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1575598275,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575598275","product_id":100039001,"comment_content":"1. 想到一个: 这个类是不是能复用，如果可以，那方法和属性的覆盖率是不是很高？还是只用其中几个，就可以判断是否要继续拆分了<br>2. 函数的设计、组件划分、React 的 hook","like_count":0},{"had_liked":false,"id":159310,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1575597771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575597771","product_id":100039001,"comment_content":"可以通过代码是否有“坏”味道来知道类是不是设计的不好，不满足单一职责。品味很重要:)","like_count":0},{"had_liked":false,"id":159307,"user_name":"moqifei","can_delete":false,"product_type":"c1","uid":1358410,"ip_address":"","ucode":"E0A6C858B78A3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGovXf8jNP5ZqHsDKLwajjicbFwpX9on1xiaJDR4CgWaWP2KcfOdneasBfKFo3dO3dwQyGG6WjK40w/132","comment_is_top":false,"comment_ctime":1575597528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575597528","product_id":100039001,"comment_content":"单一职责原则，除了应用到类的设计上，还能延伸系统群设计上，多个子系统交互时，特别容易忽略这个原则。","like_count":0},{"had_liked":false,"id":159306,"user_name":"evolution","can_delete":false,"product_type":"c1","uid":1088402,"ip_address":"","ucode":"105C59822BF75B","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/92/c0863297.jpg","comment_is_top":false,"comment_ctime":1575597282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575597282","product_id":100039001,"comment_content":"记录一下个人粗浅的认知：<br>职责单一：其实就是对某个事物的增删改查。<br>例如上述用户信息例子，当有电商业务时，地址就需要分离出来，单独的对地址增删改查。<br>实战二中的接口鉴权，其实就是客户端token的产生（新增，AuthToken类），url的产生（新增，Url类），服务端token的产生（新增，CredentialStorage类），比对结果的产生（两个token比对，DefaultApiAuthencatorImpl类）","like_count":0},{"had_liked":false,"id":159293,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1575595984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575595984","product_id":100039001,"comment_content":"对于第一个问题，我认为只要定义合理的属性，就能看出这个类是否单一，因为类方法都是对属性的操作。第二个问题，作为一个前端，我们通过代码校验工具eslint强制所有的组件类最多300行代码，否则代码就无法提交，强制约束。","like_count":0},{"had_liked":false,"id":159288,"user_name":"liu_liu","can_delete":false,"product_type":"c1","uid":1019138,"ip_address":"","ucode":"24283806A07759","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","comment_is_top":false,"comment_ctime":1575595367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575595367","product_id":100039001,"comment_content":"1. 通过大致看类中的方法与属性，是否和本身提供的功能相关。<br>2. 还可以用于接口，方法","like_count":0},{"had_liked":false,"id":159278,"user_name":"峰峰","can_delete":false,"product_type":"c1","uid":1262507,"ip_address":"","ucode":"E2207B6E68F255","user_header":"https://static001.geekbang.org/account/avatar/00/13/43/ab/ec100d05.jpg","comment_is_top":false,"comment_ctime":1575594294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575594294","product_id":100039001,"comment_content":"除了在类上使用单一职责原则外，也可以应用在架构设计上。例如，数据库虽然支持像触发器或者存储过程用来处理业务数据，但是数据库最擅长的还是数据的存取；再者，队列的使用，redis虽然可以实现队列的效果，不过redis出色的功能还是缓存的使用，可以使用市面上比较流行的消息队列组件，其更有丰富的特性。因此，还是让专业的软件做专业的事比较好。","like_count":0},{"had_liked":false,"id":159273,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1575593918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575593918","product_id":100039001,"comment_content":"1.判断一个类是否职责单一,一般是根据方法定义，查看其实现的功能和该模块是否一致，如果疑惑，就是可能职责不单一情况。<br>2. 代码行数的话，一般就是读到头疼就不合适了。。<br>3. 单一职责还可以应用到微服务的拆分，和子模块的设计。。<br>提一个问题:<br>现在我有一个虚拟组织的抽象类，子类有班级组织和部门组织，虚拟组织提供了更新组织的功能，<br>外部只需要和虚拟组织类打交道，告诉它更新一个组织<br>(前端界面知道到底是传递部门组织信息还是班级组织信息，会封装更不同的对象)，虚拟组织内部通过传递的不同对象，判断是更新班级还是部门，调用对应的子类。<br>但是现在增加了一个功能，是更新班级的某个状态的时候，在班级内的所有人都要一起更新人的状态。<br>问题是：如果这个方法放到组织内，那么组织就同时操作了人的信息和组织的更新，不符合职责单一，如果放到虚拟组织外层，外层调用又需要理解组织内部的细节，去主动判断到底是更新组织还是班级，如果是班级就触发这一段逻辑。","like_count":0},{"had_liked":false,"id":159272,"user_name":"Xs.Ten","can_delete":false,"product_type":"c1","uid":1128376,"ip_address":"","ucode":"2368B9BDDDEE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/b8/c887a5ea.jpg","comment_is_top":false,"comment_ctime":1575593782,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575593782","product_id":100039001,"comment_content":"我的理解是：<br>        单一职责一般跟业务挂钩。比如设计一个查询个人信息的类，就不要引入查询订单的代码或者是跟个人信息不相关的代码等等。<br>        由此想到：这个跟设计通用的工具类还有一定的区别。设计通用的工具类也是可以满足单一职责：可以细分成屏幕相关的，设备相关的，权限相关的，等等。","like_count":0},{"had_liked":false,"id":159271,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1237655,"ip_address":"","ucode":"088A8DA0A16BDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","comment_is_top":false,"comment_ctime":1575593725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575593725","product_id":100039001,"comment_content":"打卡打卡","like_count":0},{"had_liked":false,"id":159265,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1575593236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575593236","product_id":100039001,"comment_content":"1. 各种设计原则和设计模式最终的目的是提高程序的可读性，可维护性、可扩展性、灵活性。个人理解，在某种业务场景下，如果一个类已经很难满足可维护性、可扩展性，那可能不符合单一职责原则了。对于如何判断代码行数过多是个主观的问题，有的人认为一个函数超过30行，就应该拆。有的人认为是80行。这没有一个具体的评判标准。<br>2. 单一职责原则除了用在类的设计上，个人觉得还有一些场景：如基于贫血模型的分层设计，Controller层只负责客户端与业务层的交互，Service层只负责业务处理，Repository层只负责与存储交互；如微服务场景中某个微服务只完成单一的业务或者非业务功能。","like_count":0},{"had_liked":false,"id":159258,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1575592703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575592703","product_id":100039001,"comment_content":"单一职责原则，除了能用在类设计上，还能用在函数设计上","like_count":0},{"had_liked":false,"id":159257,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1575592600,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1575592600","product_id":100039001,"comment_content":"1: 对于如何判断一个类是否职责单一，如何判断代码行数过多，你还有哪些其他的方法吗？<br>看一个类是不是满足SRP，简单点的能一眼看出来，复杂些的要结合上下文，类的使用场景去分析了，这个还真没法量化。对于代码行数的话，公认的是对于单函数的行数最好不要超过100行，如果超过就要考虑函数分拆了。<br><br>2: 单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？<br>还可以用在函数，接口功能的设计上","like_count":0},{"had_liked":false,"id":159256,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1575592599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575592599","product_id":100039001,"comment_content":"其实现在很多web框架都在尽量拆分的特别细，<br>举例：用户注册需要发验证码或email，注册之前也许还要验证一些什么，这个时候框架会提供一些事件机制来满足。","like_count":0},{"had_liked":false,"id":159235,"user_name":"陈胜华","can_delete":false,"product_type":"c1","uid":1220185,"ip_address":"","ucode":"DCD7EED2E5544E","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/59/63710205.jpg","comment_is_top":false,"comment_ctime":1575590083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575590083","product_id":100039001,"comment_content":"经验很重要，放盐少许不是雏儿能吼得住的","like_count":0},{"had_liked":false,"id":159231,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1575589011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575589011","product_id":100039001,"comment_content":"处理业务逻辑的类与对应的处理数据库逻辑的类算不算是单一设计原则呢？避免代码行数过多，是不是可以看，是否其中包含了与类主体逻辑无关的数据库操作的代码，比如添加虽然可以用一个通用类，但是如果处理的方式不通用，是否可以单独创建一个对应此类的添加编辑删除等方式特殊类","like_count":0},{"had_liked":false,"id":159223,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575579538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575579538","product_id":100039001,"comment_content":"可以从类被用到的地方看类职责，如果一个类的公有属性或者方法被很多地方引用，这些引用相关性还不强，就有必要把这些属性或者方法拆分掉。例如文中的例子的地址和认证信息如果被用到了，他们彼此不同和用户其他属性也不同，这时就有必要拆分，如果没被用到，只作展示，在用户属性的概念下，他们和其他属性就没有不同，拆分的意义就小很多，不过为了让人读代码迅速一点，拆分出一个地址类也是可以的。<br>拆分会让类的职责单一，但是也可能破坏内聚性，还要增加一个类。聚合会让相互关联的概念内聚，但也可能弄出巨无霸的类，自身的函数无限耦合，外部依赖多如牛毛。总之，如何操作都有成本，只有收益大于成本才是值得的。现实世界无限复杂，总会出现拿捏不准的情况，这时，我一般倾向于拆分，因为小一点的类，总归好理解一点。","like_count":0},{"had_liked":false,"id":159359,"user_name":"blacknhole","can_delete":false,"product_type":"c1","uid":1098286,"ip_address":"","ucode":"271682FFE28F25","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","comment_is_top":false,"comment_ctime":1575605963,"is_pvip":false,"discussion_count":27,"race_medal":0,"score":"1496224224971","product_id":100039001,"comment_content":"在看文末的“3. 类的职责是否设计得越单一越好？”时，我惊喜地意识到：<br><br>1，内聚和耦合其实是对一个意思（即合在一块）从相反方向的两种阐述。<br><br>2，内聚是从功能相关来谈，主张高内聚。把功能高度相关的内容不必要地分离开，就降低了内聚性，成了低内聚。<br><br>3，耦合是从功能无关来谈，主张低耦合。把功能明显无关的内容随意地结合起来，就增加了耦合性，成了高耦合。","like_count":349},{"had_liked":false,"id":159213,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1575562688,"is_pvip":false,"discussion_count":29,"race_medal":0,"score":"405302488512","product_id":100039001,"comment_content":"1.方法就是全凭感觉。感觉不爽，就尝试着是否可以拆分多个类，感觉来了谁也挡不住。没有硬性要求吧，都是凭借经验。比如用户service可能包含用户的登录注册修改密码忘记密码等等，这些操作都需要验证邮箱，这时候你会发现这个类就很乱，就可以把他一分为二，弄个UserService再弄个UserEmailService专门处理用户相关邮件的操作逻辑，让UserService依赖Email的，等等这种，我觉得真的是全凭经验。换句话说，屎一样的代码写多了，写到自己看着都想吐的时候，经验就积累了。<br>2.方法设计上也用到了，比如自上而下的编程方式，先把核心方法定义好在去写具体细节，不要上来就把所有的细节都写到一个大而全的方法里。自上而下的编程方式他不香吗？","like_count":95,"discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73645,"discussion_content":"写好代码并不是很难，但以下几点确实不好做到。\n1.发现自己写的是一坨屎。\n2.愿意花时间去搅屎。\n3.能把屎搅干净。\n\n一部分人并发现不了自己在写一坨屎，更大一部分人知道自己写了一坨屎但不愿意花时间和精力去重构，最后只有极少一部分人能把屎重构清楚。","likes_number":50,"is_delete":false,"is_hidden":false,"ctime":1575565173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1555135,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/bf/41c7dc81.jpg","nickname":"xiaoxiunique","note":"","ucode":"87FFC2ED156593","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73654,"discussion_content":"精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575566592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73645,"ip_address":""},"score":73654,"extra":""},{"author":{"id":1603271,"avatar":"","nickname":"Geek_f3a3d1","note":"","ucode":"E15FA1C3AB3174","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114292,"discussion_content":"大部分不知道自己无知，少部分人知道了自己无知却无动于衷，极少部分人知道了自己的无知并且去努力学习弥补。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1577967502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73645,"ip_address":""},"score":114292,"extra":""},{"author":{"id":1369757,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7WkTI1IicbKvsPJng5vQh5qlrf1smbfl2zb7icHZfzcAk1k4lr8w8IDEAdrqq1NHW5XZMPXiaa1h7Jn1LGOWOCkIA/132","nickname":"早起不吃虫","note":"","ucode":"13CD3B5E1F9435","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540123,"discussion_content":"不是我拉的屎，凭啥我来擦。。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1639965098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73645,"ip_address":""},"score":540123,"extra":""}]},{"author":{"id":1053955,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","nickname":"考休","note":"","ucode":"968DFC00D6D0CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76947,"discussion_content":"用顶级开源软件的标准要求别人，用屎一样的代码标准要求自己","likes_number":23,"is_delete":false,"is_hidden":false,"ctime":1575870996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77215,"discussion_content":"一般而言，我是先在一个方法里面顺序写好具体实现，然后按照一个方法必须处于同一个逻辑层的思想，将写好的一大坨代码抽取为多个方法，然后再针对抽取出的方法继续重复上述工作。直到每个方法都只做一件事情。\n同时，在抽取函数的过程中起一个好名字！！！尽量做到代码即注释。\n最后，按照逻辑层的高低再对这些方法进行排序。从而做到从上而下，顺序读代码，不想了解细节时，不用继续读下去即可。","likes_number":17,"is_delete":false,"is_hidden":false,"ctime":1575896616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":78348,"discussion_content":"先自下而上把代码写完整，然后逐层拆分，相信很多人都是这么做的，只是应该有很多人在写完代码就完了。哈哈","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575988254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77215,"ip_address":""},"score":78348,"extra":""},{"author":{"id":1675380,"avatar":"https://static001.geekbang.org/account/avatar/00/19/90/74/a58acddb.jpg","nickname":"Hawaii","note":"","ucode":"00381E49E771E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":87572,"discussion_content":"同意，函数之间的抽象层次很重要，不同抽象层次的放在一起看起来清晰很多。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576673619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77215,"ip_address":""},"score":87572,"extra":""},{"author":{"id":1401452,"avatar":"https://static001.geekbang.org/account/avatar/00/15/62/6c/98a69882.jpg","nickname":"阿哲","note":"","ucode":"5ADFE1085054B6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":91532,"discussion_content":"感觉在说我，但是没有证据。😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576838563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78348,"ip_address":""},"score":91532,"extra":""}]},{"author":{"id":1043585,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/81/2127e215.jpg","nickname":"梦醒十分","note":"","ucode":"33830A5A73DDF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74747,"discussion_content":"你的思想很危险，记住一句话，大巧若拙，宁拙毋巧。不管你有多少经验，多少感觉，最好还是要多多思考。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575683709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043585,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/81/2127e215.jpg","nickname":"梦醒十分","note":"","ucode":"33830A5A73DDF8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74774,"discussion_content":"思考是肯定的，先凭借经验拆分，然后思考是否合适，不合适进行换档案重构，并不是说拆分完就不管了哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575686318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74747,"ip_address":""},"score":74774,"extra":""},{"author":{"id":1043585,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/81/2127e215.jpg","nickname":"梦醒十分","note":"","ucode":"33830A5A73DDF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74781,"discussion_content":"话有说的不对的地方，望多多海涵!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575686739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74774,"ip_address":""},"score":74781,"extra":""}]},{"author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77218,"discussion_content":"顺序写好，再进行抽取的方式。可以少写很多方法定义，编译器直接生成，很方便。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575896701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476490,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/8a/07ab933c.jpg","nickname":"璀璨星空","note":"","ucode":"CE6324C4261A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371188,"discussion_content":"实不相瞒，现在我看自己写的就是一坨shit","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1619681785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2088626,"avatar":"","nickname":"志江","note":"","ucode":"8A07D53769B3C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1476490,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/8a/07ab933c.jpg","nickname":"璀璨星空","note":"","ucode":"CE6324C4261A52","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381339,"discussion_content":"哈哈, 挺好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625018327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371188,"ip_address":""},"score":381339,"extra":""}]},{"author":{"id":2071327,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9b/1f/9f3379d3.jpg","nickname":"Geek_7f21d2","note":"","ucode":"12204FDAD951BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297535,"discussion_content":"谷歌员工来给你点个赞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596961905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049741,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","nickname":"weineel","note":"","ucode":"6DC6EF4F256A53","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74209,"discussion_content":"我是先写一个大而全的方法，然后拆。这样写的更快，少了设计，多了重构。缺点是没有设计的过程，容易拆的不伦不类。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575639187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1049741,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","nickname":"weineel","note":"","ucode":"6DC6EF4F256A53","race_medal":2,"user_type":1,"is_pvip":true},"discussion":{"id":74576,"discussion_content":"可以尝试下自上而下式的编程","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575646920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74209,"ip_address":""},"score":74576,"extra":""},{"author":{"id":2088626,"avatar":"","nickname":"志江","note":"","ucode":"8A07D53769B3C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381340,"discussion_content":"自上而下的设计好多都不会, 感觉会了这个才算有了基本的软件编程思想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625018430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74576,"ip_address":""},"score":381340,"extra":""}]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74057,"discussion_content":"什么叫自上而下的编程? 是面向原型图编程么? ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575626814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74076,"discussion_content":"先定义方法，后实现细节","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575628414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74057,"ip_address":""},"score":74076,"extra":""},{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77058,"discussion_content":"先把需求定义成interface，再考虑实现。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575885475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74057,"ip_address":""},"score":77058,"extra":""},{"author":{"id":1033096,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","nickname":"如来神掌","note":"","ucode":"45E20FF935BD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278013,"discussion_content":"面向接口编程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591143805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74057,"ip_address":""},"score":278013,"extra":""}]},{"author":{"id":2667912,"avatar":"https://static001.geekbang.org/account/avatar/00/28/b5/88/9b65e31c.jpg","nickname":"Y          X","note":"","ucode":"C9926CA7510F3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399588,"discussion_content":"有点理解接口和抽象类的作用了。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632998371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159338,"user_name":"Luciano李鑫","can_delete":false,"product_type":"c1","uid":1329995,"ip_address":"","ucode":"5FBE5F86FD5B2C","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","comment_is_top":false,"comment_ctime":1575601569,"is_pvip":false,"replies":[{"id":"61135","content":"我推荐持续重构，不推荐等到代码烂到一定程度之后的大刀阔斧的重构。持续重构就像开发一样，是开发的一部分，所以也不存在额外的测试、发布成本之说，你就当成开发来看就行了。后面会讲到重构，你到时候再看下是否还有疑问。","user_name":"作者回复","comment_id":159338,"uid":"1190123","ip_address":"","utype":1,"ctime":1575896920,"user_name_real":"王争"}],"discussion_count":11,"race_medal":0,"score":"263568606625","product_id":100039001,"comment_content":"想请教一下争哥，关于代码代码持续重构的问题，所引出的额外测试、发布成本，和故障风险应该怎样平衡呢。","like_count":61,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477017,"discussion_content":"我推荐持续重构，不推荐等到代码烂到一定程度之后的大刀阔斧的重构。持续重构就像开发一样，是开发的一部分，所以也不存在额外的测试、发布成本之说，你就当成开发来看就行了。后面会讲到重构，你到时候再看下是否还有疑问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1625233,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","nickname":"CoderArthur","note":"","ucode":"5B591914F0F67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":576261,"discussion_content":"有一种情况：发布V1.0，该版支持产品A、B、C。进行V2.0的时候，支持D、E、F产品，同时进行了重构，该重构影响到了A、B、C代码。产品A、 B、C的代码是单独作为project来管理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655380029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":477017,"ip_address":""},"score":576261,"extra":""}]},{"author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74912,"discussion_content":"个人觉得对于有代码洁癖又担心责任的群体，可通过工具支撑，流程完善（代码review等）两方面去解决。这种属于万事开头难，重点要看自动化测试运维基础设施是否完善。公司要是没准备好，自己又没能力推动的情况下，可以在适当时机做一下重构，把重构技巧的锻炼过程放到开源项目上。自动化测试报告工具（jcoco，maven,Grade都有集成，还可以集成到自动化运维平台）。灰度发布、某某发布、自动化测试、持续集成等等就是为了解决版本发布验证困难、增加额外工作量等问题提出来的。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575705399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1329995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","nickname":"Luciano李鑫","note":"","ucode":"5FBE5F86FD5B2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76287,"discussion_content":"的确是需要工具支撑，持续化集成、自动化测试、代码覆盖率测试、灰度发布这些配套设施要完整 才敢对核心业务重构 毕竟很多企业级的项目稳的服务于业务才是其本质。很多设计很大流水或者极其核心的业务都是牵一发而动全身。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575814689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74912,"ip_address":""},"score":76287,"extra":""},{"author":{"id":1117318,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","nickname":"花花大脸猫","note":"","ucode":"8ABDB3F7F4FB0F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":95786,"discussion_content":"其实有时候都太过理想化，换位思考站在资本家的角度，资本家要的结果就是有效率的完成，尤其是有竞争对手的时候，而对于代码持续重构来说，往往会拉长实际的项目周期，在绝大多数场景下，疲于开发的周期而不是代码洁癖（毕竟这只是少数人拥有的想法），而真正这个时候，重构的工作其实是很难展开的，就算后续接入的需求跟之前实际的设计相悖或者已经不满足实际场景，大部分情况下的选择都是继续选择开发，做少许小范围内的优化，当一个周期开发结束之后，这个产品为了稳定，反而是不会进行大量的重构的，所以现实往往是有悖于理想的，毕竟业务先行，业务都活不下去何来的技术重构","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1577026984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74912,"ip_address":""},"score":95786,"extra":""},{"author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1117318,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","nickname":"花花大脸猫","note":"","ucode":"8ABDB3F7F4FB0F","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":96296,"discussion_content":"先不说资本家咋滴，国内大多数程序员都还是面向工资编程，能学到写代码艺术的寥寥无几，亚美利坚以及欧洲能有这么多代码艺术家是建立在以前多年的资本（储蓄）积累的基础上的。我们来这边学习就是为了提升自己的单位产能，并不是为了资本家，虽然资本家也间接因此获益更多了，但做这事是双赢的。但程序员自己的能力提升后，比较苛刻的那种资本家就没法对你说三道四了，这样的程序员是此处不留爷，自有留爷处。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1577056889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":95786,"ip_address":""},"score":96296,"extra":""}]},{"author":{"id":1540413,"avatar":"https://static001.geekbang.org/account/avatar/00/17/81/3d/3c9f1c43.jpg","nickname":"V -Promise゜ 🔝","note":"","ucode":"14A3D2C8E838CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74107,"discussion_content":"选择好重构的时机，一般改动需求修改bug都可以进行重构","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575631106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73983,"discussion_content":"这个问题可以从是否是核心功能来考虑嘛，如果是核心功能，重构的代价应该是值得的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575620141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475866,"avatar":"https://static001.geekbang.org/account/avatar/00/16/85/1a/fc016813.jpg","nickname":"萧潇","note":"","ucode":"1FA83092845507","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384781,"discussion_content":"重构都是主张小步快跑的原则吧 不会一下全推到重来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626749874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063308,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","nickname":"小乙哥","note":"","ucode":"C77E79BEA0C325","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132279,"discussion_content":"那假如是接手的历史烂代码了？怎么持续重构？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578893977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159290,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1575595640,"is_pvip":true,"discussion_count":10,"race_medal":0,"score":"173374287480","product_id":100039001,"comment_content":"懂几个设计模式，只是花拳绣腿。掌握设计原则就才掌握了“道”。<br><br>设计你的系统，使得每个模块负责（响应）只满足一个业务功能需求。<br>Design your systems such that each module is responsible (responds to) the needs of just that one business function. (Robert C. Martin)<br><br>参考：https:&#47;&#47;blog.cleancoder.com&#47;uncle-bob&#47;2014&#47;05&#47;08&#47;SingleReponsibilityPrinciple.html","like_count":40,"discussions":[{"author":{"id":1450519,"avatar":"https://static001.geekbang.org/account/avatar/00/16/22/17/cef62ce2.jpg","nickname":"KKW","note":"","ucode":"E970CE4BE08626","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96656,"discussion_content":"剑圣独孤求败的绝招是什么，没有招，无招胜有招。就算不知道设计模式，如果理解了设计原则，也能写出高内聚，低耦合的好代码，设计模式只是前人把优化过程中常见的问题和解决方法加以总结，方便后人参考而已。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1577084559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1450519,"avatar":"https://static001.geekbang.org/account/avatar/00/16/22/17/cef62ce2.jpg","nickname":"KKW","note":"","ucode":"E970CE4BE08626","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96662,"discussion_content":"大侠，精辟！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577084884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96656,"ip_address":""},"score":96662,"extra":""},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1450519,"avatar":"https://static001.geekbang.org/account/avatar/00/16/22/17/cef62ce2.jpg","nickname":"KKW","note":"","ucode":"E970CE4BE08626","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281658,"discussion_content":"大侠","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591786900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96656,"ip_address":""},"score":281658,"extra":""}]},{"author":{"id":1254367,"avatar":"https://static001.geekbang.org/account/avatar/00/13/23/df/367f2c75.jpg","nickname":"🌀🐑hfy🐣","note":"","ucode":"8A7E4BDC46CB35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122580,"discussion_content":"个人也认为设计模式是六大原则的具体表现","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578362207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291320,"discussion_content":"他这篇文章跟他那本架构整洁之道里讲的一模一样,对单一职责最精确的描述就是一句话:把因为相同原因变化的内容放在一起,因为不同原因变化的内容拆开,单看这句话或者他的书还是太抽象了,还是先看老师的这篇专栏更容易入门","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594779089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004758,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/d6/124e2e93.jpg","nickname":"Calios","note":"","ucode":"B1AA60164DC42A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183138,"discussion_content":"又看到你了，每次都能收获一篇经典参考文章。。。🤣","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582468376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2828609,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/29/41/371c3b77.jpg","nickname":"神经蛙vx qingtian01266","note":"","ucode":"83C047B851E23D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532993,"discussion_content":"赞同。掌握设计模式 = 花拳绣腿，掌握设计原则 = 掌握了“道”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637748751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384026,"discussion_content":"大侠!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626338690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122408,"discussion_content":"收下我的膝盖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578357430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122597,"discussion_content":"把膝盖给uncle bob吧🤣，我只是他的迷弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578362746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":122408,"ip_address":""},"score":122597,"extra":""}]}]},{"had_liked":false,"id":168994,"user_name":"一壶浊酒","can_delete":false,"product_type":"c1","uid":1145530,"ip_address":"","ucode":"5D90F8F8121BBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/ba/8545f2d7.jpg","comment_is_top":false,"comment_ctime":1578234370,"is_pvip":true,"replies":[{"id":"65955","content":"数据库跟业务代码的设计不是强耦合的。不然，对业务代码进行重构，那数据库还得跟着改，谁还敢重构啊。<br><br>不管userinfo是否有address的信息，我们都可以转化成数据库想要的数据格式，再一次性地写入到数据库中。<br><br>userinfo是否包含address的信息？理论上，既然已经拆出来了，职责单一了，就不必要包含了。","user_name":"作者回复","comment_id":168994,"uid":"1190123","ip_address":"","utype":1,"ctime":1578489862,"user_name_real":"王争"}],"discussion_count":4,"race_medal":0,"score":"160492024322","product_id":100039001,"comment_content":"老师您好，有个问题想请教下，就是您举的UserInfo的例子，在抽取了地址相关的信息到新的类的时候，原来的userinfo类中需要再添加一个新的类的属性在里面么？感觉如果根据单一职责原则了话，新的类应该独立出来，UserInfo里应该不包含该类，那在这种情况下数据库的表一般会出现变化么？不然是否会造成一个新增的用户会在保存用户信息的时候对数据库进行两次操作？一次新增用户信息，然后获取了userId再进行一次操作修改地址相关信息？还是说在userinfo中存在新的地址相关类的属性，进行直接新增操作？因为没有这方面的实际经验，所以对这个比较疑惑。老师遇到这种情况一般作何处理","like_count":38,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480396,"discussion_content":"数据库跟业务代码的设计不是强耦合的。不然，对业务代码进行重构，那数据库还得跟着改，谁还敢重构啊。\n\n不管userinfo是否有address的信息，我们都可以转化成数据库想要的数据格式，再一次性地写入到数据库中。\n\nuserinfo是否包含address的信息？理论上，既然已经拆出来了，职责单一了，就不必要包含了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578489862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2128021,"avatar":"https://static001.geekbang.org/account/avatar/00/20/78/95/d3378237.jpg","nickname":"一点","note":"","ucode":"2895B57BAD9D2D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309614,"discussion_content":"新增用户信息的时候，可以调用用户实体类和地址实体类，一并插入数据库中的一张表，这样就无需改动表结构了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601366047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1622696,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","nickname":"一格状语","note":"","ucode":"EBA9ED5F97416D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2128021,"avatar":"https://static001.geekbang.org/account/avatar/00/20/78/95/d3378237.jpg","nickname":"一点","note":"","ucode":"2895B57BAD9D2D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413043,"discussion_content":"是拆BO类吗？Entity不能拆吧！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636370247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309614,"ip_address":""},"score":413043,"extra":""}]},{"author":{"id":1622696,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","nickname":"一格状语","note":"","ucode":"EBA9ED5F97416D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413042,"discussion_content":"拆是拆的UserInfoBO类吗？拆出一个UserAddressBO。UserInfoEntity应该是和表字段一一对应的类，这个不能拆吧。新增的时候，将2个BO转成1个UserInfoEntity，然后插入。不知道是不是这样，如果把Entity都拆成2个类了，那持久层的DML语句不也得跟着变么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636370132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160107,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1575871366,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"113245021062","product_id":100039001,"comment_content":"项目初始阶段也是雄心勃勃，要把系统做出一个快速迭代、维护性高的系统，可是不断的需求变更导致开发任务过重，留给项目整体的思考和重构时间被严重压缩，最终导致项目的技术管理失控，再加上人员变动等原因，项目死亡的概率急剧上升，都是惨痛的教训。<br><br>《三体》中常伟思的父亲经常说的是：要多想。<br><br>共勉！","like_count":27,"discussions":[{"author":{"id":1734795,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/8b/421cb2c4.jpg","nickname":"成活","note":"","ucode":"F8840EE4DC3969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212075,"discussion_content":"是章北海的父亲。。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1584931612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384027,"discussion_content":"停止 胡思乱想!","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626338863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239462,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e9/a6/69907ec1.jpg","nickname":"李伟","note":"","ucode":"F0EF60EB250B20","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409598,"discussion_content":"章北海的父亲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635471941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2319435,"avatar":"https://static001.geekbang.org/account/avatar/00/23/64/4b/f27d43fd.jpg","nickname":"大漠客栈","note":"","ucode":"85DA7470E0ABCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334690,"discussion_content":"我们的项目就是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607937936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207410,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","nickname":"紫日","note":"","ucode":"73A8DEE323AC19","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317194,"discussion_content":"在有限情况下想的越多，之后才有可能更从容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603514006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159247,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1575591854,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"87474937774","product_id":100039001,"comment_content":"回答问题<br>1. 类单一职责判断可以通过评估其对外提供接口是否满足不断变化的业务和需求来确定！问自己，该类是否对其他类是&quot;黑盒&quot;！<br><br>2. 类行数多=属性多+方法多<br>属性多: 要考虑这些属性是不是对类来说是必须的，需要移除么？<br>方法多: 方法间复用情况，方法间有没有写重复代码？<br>如上如果觉得没有可以改进的余地，就可以认为类行数恰当！<br><br>3. 单一职责还可以应用到方法，模块，功能点上！","like_count":21,"discussions":[{"author":{"id":1027203,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/83/4c1a18de.jpg","nickname":"🐻🐻","note":"","ucode":"424120B74390CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290219,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594380324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159219,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1575565937,"is_pvip":false,"replies":[{"id":"61142","content":"哈哈，写注释不是挺好的吗？我后面讲到编程规范的时候会详细讲如何写注释的。","user_name":"作者回复","comment_id":159219,"uid":"1190123","ip_address":"","utype":1,"ctime":1575897742,"user_name_real":"王争"}],"discussion_count":12,"race_medal":0,"score":"61705108081","product_id":100039001,"comment_content":"回答问题：<br>1.不好说，职责单一这东西比较主观。得看自己对抽象出来的类的主观定义是什么。准的捏不住，但还是要把控一下范围的。<br>2.码出高效给出了方法行数不超过50行的一个基准标注。而我实践下来很难写出超过50行的方法，这50行还包括了大量注释。<br><br>3.方法的职责单一，业务领域的能力要单一（边界清晰）。<br><br>提问：<br><br>1.以前不代码规范不行，就逼着自己多思考，多写注释。现在养成了写注释的洁癖，不写就很难受。请问大佬，这怎么办，需要戒掉吗。我除了dao层的crud和数据类的setget外，其余方法都会带上注释。","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476986,"discussion_content":"哈哈，写注释不是挺好的吗？我后面讲到编程规范的时候会详细讲如何写注释的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220185,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/59/63710205.jpg","nickname":"陈胜华","note":"","ucode":"DCD7EED2E5544E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73697,"discussion_content":"能用函数名，变量名解释清楚的，就少用注释吧。很多时候改了代码忘改注释，是很蛋疼的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575590024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1220185,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/59/63710205.jpg","nickname":"陈胜华","note":"","ucode":"DCD7EED2E5544E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73747,"discussion_content":"顶层方法，基本无法用方法名解释清楚的。聚合太多逻辑。  但大量注释，后期其他人维护会成问题，我担心的就是你说的这个。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575593739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73697,"ip_address":""},"score":73747,"extra":""}]},{"author":{"id":1102102,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/16/3b3f03c8.jpg","nickname":"天津古董","note":"","ucode":"2F81F0D0E0864A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73777,"discussion_content":"用函数名代替注释，需要这注释，就说明方法需要拆分了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575595845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570984,"discussion_content":"我发现我也有这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652019697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415598,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/ee/d6ea437d.jpg","nickname":"芳芳 - Claire","note":"","ucode":"E8D67858B23D01","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412065,"discussion_content":"看过clean code里面提到方法名尽量的明确，写代码和写文章有类似之处，读你代码的人，一看方法名就立刻明白你要干什么，可以避免很多的注解，可以试试有没有帮助","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636073871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336234,"discussion_content":"我也有点这毛病","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608536831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73784,"discussion_content":"顶层路由或顶层聚合，你是怎么拆的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575596189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1094597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","nickname":"Liam","note":"","ucode":"1D15D3B64F2606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73719,"discussion_content":"好习惯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575592475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1449072,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/70/e4e02e84.jpg","nickname":"平凡世界","note":"","ucode":"7820CC3BD329A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73702,"discussion_content":"不超过50行? 业务逻辑都这么简单么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575590749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1449072,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/70/e4e02e84.jpg","nickname":"平凡世界","note":"","ucode":"7820CC3BD329A4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73746,"discussion_content":"多思考，多封装。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575593624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73702,"ip_address":""},"score":73746,"extra":""},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532129,"discussion_content":"复杂业务，use  case 不止","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637543142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73746,"ip_address":""},"score":532129,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":165793,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1577323503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48821963759","product_id":100039001,"comment_content":"What<br><br>一个函数、类、模块只负责完成一个职责或者功能。<br><br>How<br><br>关于如何使用这个原则，不同的应用场景、需求背景、业务，对一个类职责是否单一，会有不同的判定结果。<br><br>这个说法其实很模糊，并没有多少实践上的指导意义。<br><br>定义中也存在令人迷惑的点，类由函数构成，模块由类构成（面向对象领域），如果每个函数职责单一，多个职责单一的功能函数组成一个类，那么这个类还算职责单一吗？<br><br>这里的区别在于看待职责单一的抽象维度不同，也称为职责颗粒度。<br><br>比如在函数的维度，在一个 getter 方法，只返回用户名，它是职责单一的；在用户类的维度，它还可以包含返回手机号的 getter 方法。<br><br>类也是有颗粒度的。以文中用户信息类为例，什么时候地址信息应该被作为单独类存在呢？我的结论是存在被复用的场景。<br><br>在初次设计时，可能并没有复用场景，那么都写在一个类里满足业务需求完全没问题。<br><br>但随着需求的发展，类中代码量膨胀，我们就需要根据复用性来对类进行拆分，此时单一职责原则可以作为一个指导思想。<br><br>过度使用单一职责<br><br>在设计时也不要过度使用单一职责原则，它会使得功能点不够内聚，增加维护成本。如果一个类，始终是作为整体被使用，即使它包含多种功能，放一起也可以。<br><br>当我们只想使用类的某一部分功能，又觉得其它功能鸡肋的时候，再考虑拆分也不迟。<br><br>Why<br><br>单一职责原则，是前辈在代码时间中的经验，将某一类经验抽象为这个名字。这个原则主要目的是为了，实现高内聚、低耦合、提高代码的复用性、可读性、可维护性。","like_count":11},{"had_liked":false,"id":159234,"user_name":"Chen","can_delete":false,"product_type":"c1","uid":1503113,"ip_address":"","ucode":"C1128558AB5BC4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/89/8c73a24d.jpg","comment_is_top":false,"comment_ctime":1575589878,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"44525262838","product_id":100039001,"comment_content":"Android里面Activity过于臃肿会让感觉很头大，MVP,MVVM等框架都是为了让Activity变得职责单一。","like_count":10,"discussions":[{"author":{"id":1366402,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIFicK7Bn88Lqte7rURlw3Lf53oAu1jhiciaVlKLib48dlIAOAF03L7tjQcx1ia5AJI26S7HIxwx780Qzw/132","nickname":"操盘手爱德华","note":"","ucode":"CAAF3E6DC9D5FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74897,"discussion_content":"MVP和MVVM不是框架，Activity的臃肿也不是Activity本身的问题。MVP和MVVM也不是为了让Activity职责单一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575702749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1734795,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/8b/421cb2c4.jpg","nickname":"成活","note":"","ucode":"F8840EE4DC3969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1366402,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIFicK7Bn88Lqte7rURlw3Lf53oAu1jhiciaVlKLib48dlIAOAF03L7tjQcx1ia5AJI26S7HIxwx780Qzw/132","nickname":"操盘手爱德华","note":"","ucode":"CAAF3E6DC9D5FD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212082,"discussion_content":"我理解的，MVP和MVVM算是一种约定，或者说架构？后面两句话就不是很理解了，请赐教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584932195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74897,"ip_address":""},"score":212082,"extra":""}]},{"author":{"id":1457464,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3d/38/6f02a4b9.jpg","nickname":"your problem？","note":"","ucode":"6E096E7958CFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73850,"discussion_content":"iOS开发也有同样的问题，Controller过大，各种架构MVC，VIPER实际上也是为了解决这个问题，最近准备研究响应式编程和函数式编程，不知道能不能缓解这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575601301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160234,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1575895853,"is_pvip":false,"replies":[{"id":"61137","content":"一个service当然可以有多个方法了，只要方法都是一个业务领域的，没有明显违背SRP，实际上都是合理的。","user_name":"作者回复","comment_id":160234,"uid":"1190123","ip_address":"","utype":1,"ctime":1575897239,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"40230601517","product_id":100039001,"comment_content":"有个问题，比如有个OrderService中可能提供了各种订单查询、操作等，即一个OrderService有多个方法，是否符合SRP呢？","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477307,"discussion_content":"一个service当然可以有多个方法了，只要方法都是一个业务领域的，没有明显违背SRP，实际上都是合理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005030,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","nickname":"GeekAmI","note":"","ucode":"232C0B6DFB9F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310247,"discussion_content":"按照CQRS原理，操作和查询可以分离出来，甚至可以放到不同的项目里。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601708094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1202160,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/f0/f6155d5f.jpg","nickname":"新生\\","note":"","ucode":"212978C88E242E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005030,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","nickname":"GeekAmI","note":"","ucode":"232C0B6DFB9F56","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573688,"discussion_content":"cqrs是什么呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653604318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310247,"ip_address":""},"score":573688,"extra":""}]}]},{"had_liked":false,"id":159339,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1575601589,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35935339957","product_id":100039001,"comment_content":"因为学习设计模式，前几天刚和朋友在聊，说其实每个类的代码行数和函数的行数最好都需要控制下，能精简就精简，完成我们理解的重构。<br><br>刚好，今天就看到老师说的这个，赶紧分享给朋友，盛赞了这门课，哈哈","like_count":8},{"had_liked":false,"id":159280,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1575594460,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"31640365532","product_id":100039001,"comment_content":"我有个问题，就用户地址的设计来说，后续功能扩大再拆解是不是违反了开闭原则呢？而且后期拆分会比较影响现有业务逻辑吧，这个如何平衡呢？","like_count":7,"discussions":[{"author":{"id":1609964,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","nickname":"拂尘","note":"","ucode":"9563C002E4B06A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74020,"discussion_content":"所以，后面说的是重构吧。。。重构和修改应该不一样吧 ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575624106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437667,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ef/e3/db895077.jpg","nickname":"流放","note":"","ucode":"21E30A37E7F139","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74175,"discussion_content":"这个就是过度设计的把握范畴了吧。刚开始的时候，粗颗粒度是不会说要满足所有设计原则的。在后续业务扩大重构的时候，也是业务更加定型的时候.再去满足，应该是更合理的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575636299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78329,"discussion_content":"持续重构，作为开发的一部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575987889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73986,"discussion_content":"你说的有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575620437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159233,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1575589581,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31640360653","product_id":100039001,"comment_content":"单一职责原则也可以用在服务上的拆分上","like_count":7,"discussions":[{"author":{"id":2319435,"avatar":"https://static001.geekbang.org/account/avatar/00/23/64/4b/f27d43fd.jpg","nickname":"大漠客栈","note":"","ucode":"85DA7470E0ABCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334691,"discussion_content":"共识，而且划分的服务更优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607938013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163930,"user_name":"爱水人家","can_delete":false,"product_type":"c1","uid":1730305,"ip_address":"","ucode":"0C94C6ACBC9CEB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/67/01/44626cb9.jpg","comment_is_top":false,"comment_ctime":1576830281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27346634057","product_id":100039001,"comment_content":"个人感觉码代码就像语文中的写文章，而设计原则就像一条条需要考虑的原则。用好了这些原则我们就可以写出好的文章。文章写多了，心得体会出来了，设计原则就熟门熟路了。<br>感觉在没学这些原则之前，都能感觉到自己码的代码布局有问题。学了之后，更能知道问题在哪里了，需要怎么修改了！","like_count":6},{"had_liked":false,"id":207843,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1587196212,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"23062032692","product_id":100039001,"comment_content":"相关的“在一起”，叫内聚，不相关的“在一起”，叫耦合。","like_count":5},{"had_liked":false,"id":169717,"user_name":"刘学习来学习","can_delete":false,"product_type":"c1","uid":1464013,"ip_address":"","ucode":"5078B1EC8D8A66","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/cd/0add8290.jpg","comment_is_top":false,"comment_ctime":1578411227,"is_pvip":false,"replies":[{"id":"65946","content":"后面facade设计模式会讲到你的问题","user_name":"作者回复","comment_id":169717,"uid":"1190123","ip_address":"","utype":1,"ctime":1578489175,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"23053247707","product_id":100039001,"comment_content":"前段时间需要对外提供sdk,最开始的设计就是根据职责定义了多个client对象供其他系统调用，后来角色不是很友好，最后还是提供了个聚合类，将所有的接口都集中到一起对外提供了,像这种情况,有的时候不知道该参考什么来设计","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480689,"discussion_content":"后面facade设计模式会讲到你的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578489175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159623,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1575708228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18755577412","product_id":100039001,"comment_content":"设计模式_15<br># 作业：<br>单一职责也可以用于方法的编写，在维护多年的项目中，我们会看到一些非常“庞大”的方法，这些方法的功能比它的命名丰富很多，它是一次次地改成了这个样子。本来是一个职责单一的简单方法，由于需求的变化，可能是方法被调用太多(不敢改)，也可能是框架设计(不能改)导致只能在方法内部添加特殊业务的判断条件，这样下来，这个方法就变得难以理解且难以维护。<br><br># 感想<br>同事们也常讨论单一职责的边界, 始终没有一致的结论。今天的内容也坚定了观点，业务的发展一定程序决定了耦合的边界。<br>我们学习前人总结的这些原则，目的是什么呢，我今天的感受是，系统性地降低工作量和出错概率。<br>- 降低工作量：我们要尽量保证，随着需求的增加，工作量的增加是线性的，而不是指数级的。据我了解，维护一些老代码的同学们，一直被产品同事质疑：就这么点功能，要做这么久吗？？？<br>- 降低出错概率：就像文中的序列化的例子，强行把序列化与反序列化方法拆开，会导致使用者需要花更多的时间来做一些同步的工作，如果文档不够清晰，或者阅读文档不够仔细，就会导致出错；有这样代码结构的系统，运行足够长的时间，一定会出更多的错误。","like_count":4},{"had_liked":false,"id":159255,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1575592509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18755461693","product_id":100039001,"comment_content":"打卡✔<br>安装ali规范插件，看到报警告的就按照规范修改，不过这个规范是死的，有时候和实际应用不同，不过大部分规范还是可以遵循的","like_count":4},{"had_liked":false,"id":204856,"user_name":"空也空","can_delete":false,"product_type":"c1","uid":1073533,"ip_address":"","ucode":"56976779192E02","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/7d/1bd071ba.jpg","comment_is_top":false,"comment_ctime":1586482817,"is_pvip":false,"replies":[{"id":"87069","content":"你这个问题确实是个好问题，我想想~","user_name":"作者回复","comment_id":204856,"uid":"1190123","ip_address":"","utype":1,"ctime":1595208143,"user_name_real":"王争"}],"discussion_count":4,"race_medal":0,"score":"14471384705","product_id":100039001,"comment_content":"“私有方法过多”为什么作为一个衡量标准呢？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491307,"discussion_content":"你这个问题确实是个好问题，我想想~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595208143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125119,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/ff/aac2a672.jpg","nickname":"上酒馆复活","note":"","ucode":"CEA9276D376238","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347784,"discussion_content":"老板，想好了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612319743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336235,"discussion_content":"多了看着不爽然后就拆分出来，我就是这样干的，说不出来为什么。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608536957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294581,"discussion_content":"说明这个类内使用，从某些当面说就是内聚性强","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595931442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242653,"user_name":"超越自我","can_delete":false,"product_type":"c1","uid":2130462,"ip_address":"","ucode":"8A55D972EEFADA","user_header":"https://static001.geekbang.org/account/avatar/00/20/82/1e/f3cb3d57.jpg","comment_is_top":false,"comment_ctime":1597805229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10187739821","product_id":100039001,"comment_content":"一生二，二生三，三生万物。万物生发过程必然是一个拆分的过程。拆是为了高纬度的合。类的拆分，微服务的拆分，负载均衡，读写分离，分库分表，分布式系统；细胞分裂，大树开枝散叶，羊群壮大;公司部门划分；百家姓,多民族,一国两制等等。这些拆分的个体都是服务于高纬度的整体。当然这个拆要有度，要遵守自然规律，历史大势，不能违背。度很关键。<br>","like_count":2},{"had_liked":false,"id":234564,"user_name":"润！","can_delete":false,"product_type":"c1","uid":1237696,"ip_address":"","ucode":"13B7C23B5F6B24","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/c0/09cef977.jpg","comment_is_top":false,"comment_ctime":1594720550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10184655142","product_id":100039001,"comment_content":"课程讲得是真的不错，值得购买","like_count":2},{"had_liked":false,"id":228633,"user_name":"Carlos","can_delete":false,"product_type":"c1","uid":1143912,"ip_address":"","ucode":"687CD9CA3E7C9B","user_header":"https://static001.geekbang.org/account/avatar/00/11/74/68/3725546b.jpg","comment_is_top":false,"comment_ctime":1592759002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10182693594","product_id":100039001,"comment_content":"1、判断类职责是否单一，其实有个挺客观的方法就是，如果类的对象在现有系统中任何一个地方出现都会带上，或者隐性带上所有的属性，那么这个类的职责就是单一。以用户类为例，系统中凡是出现用户的地方，都应显示，或者隐性显示出用户姓名、性别、年龄、地址等这些属性，那么这个类职责就是单一的；如果有些场景只强调带上用户账号密码，有些场景只强调带上用户地址信息，如果出现了其他更为详细的信息功能就错误了，那么这个类就需要拆分了。如果设计者依然要站在用户类这个角度将他们组织在一起，首先违背了接口隔离的原则，其次这样的类后期BUG产生几率也高了，因为有好多不相干场景都要来修改同一个类。<br>2、单一职责除了应用到类的设计上外，其实软件系统设计的方方面面都要应用代单一职责，包括模块设计呀，前端组件设计等，所有设计中，如果把多个不相干的东西放到一个，都会带来上面提到的问题，但如果将原本就是一个整体的东西拆分了，也会带来问题，假如以人这个对象来说，客观世界中一个健全的人都包括五官和四肢，如果映射到程序对象中，将他们拆开了，或者少了个部件，首先和客户世界不符了，其次也为后期其他同事的理解和维护带来了困难。","like_count":2},{"had_liked":false,"id":159661,"user_name":"Cris","can_delete":false,"product_type":"c1","uid":1473520,"ip_address":"","ucode":"F8A287134F1078","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/f0/269139d5.jpg","comment_is_top":false,"comment_ctime":1575722406,"is_pvip":false,"replies":[{"id":"61128","content":"这两个没有关系的，你可以看下spring的aop","user_name":"作者回复","comment_id":159661,"uid":"1190123","ip_address":"","utype":1,"ctime":1575896384,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"10165656998","product_id":100039001,"comment_content":"老师，我今天听到了一个概念叫面向切片编程(aop)，它和面向对象编程有什么联系呢？想听听老师的理解","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477136,"discussion_content":"这两个没有关系的，你可以看下spring的aop","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99251,"discussion_content":"这个我可以回答你，aop是为了解决oop不能横向扩展问题，aop也是个思想，其实现方式是代理模式","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577197847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119301,"discussion_content":"面相切面。以及面相元编程。也可以说是一种设计模式不在23中之内的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578225784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289751,"user_name":"等等 女皇","can_delete":false,"product_type":"c1","uid":1549661,"ip_address":"","ucode":"81423644144550","user_header":"https://static001.geekbang.org/account/avatar/00/17/a5/5d/22829a03.jpg","comment_is_top":false,"comment_ctime":1619164598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5914131894","product_id":100039001,"comment_content":"1、相关的“在一起”，不相关的”不在一起“。这样职责单一，叫高内聚。 <br><br>2、相关的没有”在一起“，不相关的”在一起“了。导致相互依赖多，直接导致”低内聚，高耦合“。<br><br>3、相关还是不相关，在一起还是不在一起。比如从功能相关来谈，主张高内聚，当然也可以根据功能相关程度强弱来选择继续内聚还是拆开（useinfo、Serializer的例子）。至于耦合，一般内聚做好了，耦合也会降低了。（比如第一点做好了，第二点就不会出现）","like_count":1},{"had_liked":false,"id":229366,"user_name":"杨锋","can_delete":false,"product_type":"c1","uid":1283461,"ip_address":"","ucode":"85A7828A538FB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","comment_is_top":false,"comment_ctime":1592976522,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5887943818","product_id":100039001,"comment_content":"三层架构，每个数据库表对应一个dao,service。其实职责已经很单一了。最大的问题可能就是service层写逻辑的时候会把很多不想干的业务写到一起。然后数据库表的设计也可以细分职责。","like_count":1},{"had_liked":false,"id":167677,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1577892237,"is_pvip":false,"replies":[{"id":"65094","content":"没太看懂你说的😂","user_name":"作者回复","comment_id":167677,"uid":"1190123","ip_address":"","utype":1,"ctime":1577931967,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"5872859533","product_id":100039001,"comment_content":"小争哥, 数据库设计是不是不太适合设计那种抽象类的数据库表结构, 这样我写bo就会就会维护的很大很大","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479940,"discussion_content":"没太看懂你说的😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577931967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033096,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","nickname":"如来神掌","note":"","ucode":"45E20FF935BD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278026,"discussion_content":"同类的可以抽象，通过类型判断，不同类的一定不要抽奖，否则使用时真的很累","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591145017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160468,"user_name":"bboy孙晨杰","can_delete":false,"product_type":"c1","uid":1178683,"ip_address":"","ucode":"D7389FB3368749","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/3b/c6b5b64f.jpg","comment_is_top":false,"comment_ctime":1575957103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870924399","product_id":100039001,"comment_content":"在数据库表设计的时候应该也有用到单一职责的思想吧，每个表只负责某一部分的业务数据，不要过多耦合，方便维护，阅读。","like_count":1},{"had_liked":false,"id":159609,"user_name":"小建","can_delete":false,"product_type":"c1","uid":1647247,"ip_address":"","ucode":"C9781DF8F79112","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/8f/22e9c74b.jpg","comment_is_top":false,"comment_ctime":1575703558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870670854","product_id":100039001,"comment_content":"干货满满","like_count":1},{"had_liked":false,"id":159567,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1575687064,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5870654360","product_id":100039001,"comment_content":"打卡<br>1、单一职责原则定义：一个类或是模块只完成一个职责（或功能）<br>2、如何做到单一职责，有几个方法可以参考<br>1）类中的代码行数和属性太多；<br>2）类依赖的其他类过多；<br>3）类的私有方法过多，考虑是否可能把一些公用的方法放到其他的类中，作为公有方法，提供代码复用性；<br>4）比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；<br>5）类中大量的方法都是集中操作某几个属性，可以考虑把这几个属性和方法抽取出来；<br><br>3、在不同的应用场景和不同的需求背景下，类的单一职责判断是不同。随着需求的变动，功能的增加，原来的类可能就不满足单一职责原则，就需要拆分为颗粒度更小的类；<br><br>4、类的颗粒度拆分也需要适度，把负责单个功能的类拆分为多个类，反而破坏了高内聚的原则（虽然满足了低耦合）。<br><br>5、在需求实现初期，可以写个颗粒度大的类，满足业务需求。当某个类的代码越来越多，负责的职责越来越多，可以查分为更小颗粒度的类。（持续重构的思想）","like_count":1,"discussions":[{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294874,"discussion_content":"第四点我觉得没有满足低耦合，高内聚的同时可能就满足低耦合，所以后者不能得出结论。只有前者是高内聚高耦合的场景才能得出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596021861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159533,"user_name":"郑童文","can_delete":false,"product_type":"c1","uid":1030733,"ip_address":"","ucode":"3D193715CB8549","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg","comment_is_top":false,"comment_ctime":1575672157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870639453","product_id":100039001,"comment_content":"推荐一个很好的免费资料, NEU Program Design Paradigms课程的网站:<br>https:&#47;&#47;course.ccs.neu.edu&#47;cs5010&#47;index.html<br>Lecture部分写得很细致,还有作业","like_count":1},{"had_liked":false,"id":159465,"user_name":"ww yang","can_delete":false,"product_type":"c1","uid":1584617,"ip_address":"","ucode":"AE223861999D07","user_header":"https://static001.geekbang.org/account/avatar/00/18/2d/e9/bdb98e2f.jpg","comment_is_top":false,"comment_ctime":1575630271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870597567","product_id":100039001,"comment_content":"每次学完都很期待下一节课马上来！","like_count":1},{"had_liked":false,"id":159347,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1575603002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870570298","product_id":100039001,"comment_content":"1、如何判断代码行数过多，这个我还是觉得要看感觉，如果自己看着觉得很不爽，那说明应该要拆分或者优化精简了；如果自己看不太出来可以找人review，别人或许能看出来。不过代码行数最好不要太多。<br>3、方法设计，接口设计等等，都可以使用单一职责，每个方法做一件事，如果里面的代码多了或者乱了，就应该试着拆分，接口设计也是同理，做某一个模块的事情，不能多个模块都写在一个接口里面。","like_count":1},{"had_liked":false,"id":159279,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1575594385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870561681","product_id":100039001,"comment_content":"根据不同的场景对某个类或模块单一职责的判断是不同的，不能为了拆分而拆分，造成过度设计，难以维护。","like_count":1},{"had_liked":false,"id":159253,"user_name":"水银","can_delete":false,"product_type":"c1","uid":1045948,"ip_address":"","ucode":"0FD9C79590E484","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/bc/63be02b6.jpg","comment_is_top":false,"comment_ctime":1575592160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870559456","product_id":100039001,"comment_content":"单一职责，感觉不应该用代码行数来判定，确实应该由业务需求场景决定，有些业务场景不复杂，过分强调单一，反而会使代码片段零散在过多的类、方法中，导致调用层级过深，不易阅读和理解，难以维护，万事都有个平衡，适度就好，毕竟代码不是一次成型的建筑物，需要持续的改造、优化。<br><br>单一职责感觉是最基础也是起他设计模式用好的前提，考量单一的时候还有一个原则就是：复用性，如果一块逻辑或业务可以被起他地方利用，也是标志整块逻辑的职责是单一性的。单一职责没有一个确切的标准，很多场景下在一个业务中对于权衡单一指责的考虑纬度、粒度也所有不同。虽然是很简单易懂的指责，但用好确实并不是很容易的事。","like_count":1},{"had_liked":false,"id":357125,"user_name":"Geek_3e9d7d","can_delete":false,"product_type":"c1","uid":3070253,"ip_address":"北京","ucode":"3BDEFFE68BE32F","user_header":"","comment_is_top":false,"comment_ctime":1662977237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662977237","product_id":100039001,"comment_content":"1、对于如何判断一个类是否职责单一，如何判断代码行数过多，你还有哪些其他的方法吗？<br>对于一个类是否职责单一，我的一个经验是在MVC架构中，一般每一层向下调用，如果这一层的类需要向下调用下一层的类过多，可能这个类的职责就有点过多了。比如一个BizService，这个类中的处理逻辑需要用户数据、订单数据、商品数据、地址数据等等那么久需要调用UserRepository、OrderRepository、ItemRepository和AddressRepository，面对这种情况就可以初步判读这个Service的职责过于复杂了<br>2、单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？<br>还可以应用到模块的设计、微服务的设计、数据库垂直拆分的设计中。","like_count":0},{"had_liked":false,"id":356767,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"中国香港","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662564837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662564837","product_id":100039001,"comment_content":"思考题1: 功能是否相近。<br>思考题2: 衍生到模块上。<br><br>本节讲了单一职责：<br><br>   what: 一个类职责要单一，不要设计大而全的类。<br>   why:  单一原则主要是未来代码的可读性性和可维护性和解耦。<br><br>   how: 如何判断类是否单一。<br>      1.代码行数过多。<br>      2. 属性过多，且方法主要集中在某个类上。<br>      3.私有方法过多。<br><br>不过具体情况具体分析，还是要靠经验堆积。","like_count":0},{"had_liked":false,"id":355227,"user_name":"Huyunfu","can_delete":false,"product_type":"c1","uid":1888301,"ip_address":"广东","ucode":"61A3AFC7BD4203","user_header":"","comment_is_top":false,"comment_ctime":1661210001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661210001","product_id":100039001,"comment_content":"单一职责原则，这个我的理解就是要跟函数或类的抽象层级息息相关。抽象层级又通过类、方法的命名来体现。比如你的类取名叫User，那这个类就应该只有与User相关的操作；你的方法名字是queryUser,那么方法就只做查询操作，不要在里面做类似set值的其他操作。有时候即使一个方法里需要做两件事，来达到代码复用的效果，比如查询完结果并做缓存，为了方法复用，我将方法命名为queryDbAndSetCache，我认为这个方法还是符合单一职责的，因为的职责就是“查询并缓存”，这也是一件事，只是抽象层级不一样。","like_count":0},{"had_liked":false,"id":353447,"user_name":"泽韦德","can_delete":false,"product_type":"c1","uid":1103888,"ip_address":"浙江","ucode":"948E7B067A3786","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/10/5173922c.jpg","comment_is_top":false,"comment_ctime":1659444486,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1659444486","product_id":100039001,"comment_content":"1.判断类名与定义的方法是否在同一范围之内，类的属性是否过多，方法数量是否过多，使用依赖查看工具，观察外部依赖是否过多。<br>2.数据库表的设计也要遵循单一职责原则，比如各类范式，也是单一职责原则的体现。","like_count":0},{"had_liked":false,"id":350713,"user_name":"会飞的猪","can_delete":false,"product_type":"c1","uid":2536213,"ip_address":"","ucode":"48E44B47D53A97","user_header":"https://static001.geekbang.org/account/avatar/00/26/b3/15/54f57316.jpg","comment_is_top":false,"comment_ctime":1657113059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657113059","product_id":100039001,"comment_content":"我觉得老师讲的很好，但是如何实践呢？这个需要我们好好思考一下","like_count":0},{"had_liked":false,"id":345472,"user_name":"Morty","can_delete":false,"product_type":"c1","uid":1026658,"ip_address":"","ucode":"C2E532741F99E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/62/78b45741.jpg","comment_is_top":false,"comment_ctime":1652317066,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652317066","product_id":100039001,"comment_content":"其实不止类和模块，所有要封装的都应该遵守这个原则，例如方法&#47;函数","like_count":0},{"had_liked":false,"id":345201,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1652104096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652104096","product_id":100039001,"comment_content":"单一职责是为了实现正交的代码设计，正交的代码设计可以更好的实现内聚，提高代码的稳定性和可复用性。","like_count":0},{"had_liked":false,"id":337179,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1646661922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646661922","product_id":100039001,"comment_content":"1.重构的原则。<br>2.封装的原则。<br>3.如何优化代码的方法。<br>4.如何提高可读性、维护性、高内聚、低耦合。<br>5.类的设计职责是否单一越好？","like_count":0},{"had_liked":false,"id":328176,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1640589128,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640589128","product_id":100039001,"comment_content":"感觉依赖其他太多的类，就会说明类职责不够单一。","like_count":0},{"had_liked":false,"id":324546,"user_name":"WANGX","can_delete":false,"product_type":"c1","uid":1404380,"ip_address":"","ucode":"A4132A93CC2A47","user_header":"https://static001.geekbang.org/account/avatar/00/15/6d/dc/6a91c3d3.jpg","comment_is_top":false,"comment_ctime":1638497183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638497183","product_id":100039001,"comment_content":"1.单一原则：一个类只负责完成一个职责或者功能<br>2.是否满足单一原则需要结合业务场景来分析，设计满足当下业务场景符合单一原则即可，后续持续重构，避免过度设计<br>3.类的职责设计不是越单一越好","like_count":0},{"had_liked":false,"id":320783,"user_name":"二小","can_delete":false,"product_type":"c1","uid":1593919,"ip_address":"","ucode":"5377CB552237B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/3f/c8b40efe.jpg","comment_is_top":false,"comment_ctime":1636510163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636510163","product_id":100039001,"comment_content":"2、可以用在微服务的拆分上","like_count":0},{"had_liked":false,"id":319194,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1635665920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635665920","product_id":100039001,"comment_content":"我有个前同事，一个业务类里面塞了两千多行代码，3M大小，编辑器打开都要加载半天。而且耦合性特别强，你想优化就要重新撸一遍。这种也是很无奈，坑挖的让人无言以对。","like_count":0},{"had_liked":false,"id":316534,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1634372840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634372840","product_id":100039001,"comment_content":"1.判断类的职责是否单一：<br>当一个类的职责单一时，其所有的方法会围绕一个主题展开，比如更新帐户余额，那么其大部分方法名称中都会包含和帐户余额相关的名称，也就是根据方法名称是否包含主题词来判断类的职责是否单一<br><br>2.判断代码行是否过多：<br>(1)当一段代码的嵌套层次过深时，比如有5-6层时，可认为代码行过多；<br>(2)当代码段中出现大量重复的代码行时，且这些重复的代码行之间的区别只是某些局部变量或参数不同时，可认为代码行过多<br>(3)因调试或修改出现大量注释掉的无用代码时，也会造成代码行过多，代码混乱。<br><br>3.单一职责原则应用：<br>单一职责原则除了应用到类的设计上，还可以应用到功能模块的设计，组件的设计，子系统的设计，以及服务的设计等。","like_count":0},{"had_liked":false,"id":316176,"user_name":"Geek3425","can_delete":false,"product_type":"c1","uid":2791308,"ip_address":"","ucode":"C7292D0AF11F43","user_header":"","comment_is_top":false,"comment_ctime":1634192620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634192620","product_id":100039001,"comment_content":"比如新增文档，新增问题，新增标签都是要一个接口，一个方法是实现的，通过传type区分，是不是违反了单一性","like_count":0},{"had_liked":false,"id":314361,"user_name":"Rootrl","can_delete":false,"product_type":"c1","uid":1035390,"ip_address":"","ucode":"50FE3BBA92D417","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/7e/0d050964.jpg","comment_is_top":false,"comment_ctime":1632986064,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632986064","product_id":100039001,"comment_content":"所谓“盐少许”，“专业第六感”。这个可以用德雷福斯模型解释，有新手、高级新手、胜任者、精通者、专家，其中各级解释，大家可以具体去了解下，比如新手只会按指令做事，我们来此学习大概是想从高级新手进到胜任者，或者胜任者进到精通者阶级吧。这里各个阶级的都只能按自己的思维模型做事，而专家就是靠直觉行事的，行为专家是一级级进化来的，以往经验形成了“肌肉记忆”。","like_count":0},{"had_liked":false,"id":311961,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1631576794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631576794","product_id":100039001,"comment_content":"单一职业选择，SRP<br>尽可能使得一个类的功能单一，进而趋于高内聚，低耦合。<br>有些指标参考<br>1.类行数是否过多<br>2.类私有方法是否过多","like_count":0},{"had_liked":false,"id":311877,"user_name":"al-byte","can_delete":false,"product_type":"c1","uid":1466744,"ip_address":"","ucode":"D0298A02E9259D","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/78/e7aa4e04.jpg","comment_is_top":false,"comment_ctime":1631519839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631519839","product_id":100039001,"comment_content":"单一职责在业务处理上也可以应用 这样在业务领域划分和多业务编排时会有更高的复用性","like_count":0},{"had_liked":false,"id":311825,"user_name":"小川","can_delete":false,"product_type":"c1","uid":1242573,"ip_address":"","ucode":"D462222DDBB978","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","comment_is_top":false,"comment_ctime":1631495772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631495772","product_id":100039001,"comment_content":"单一职业真的是万金油的设计。<br><br>1. 突然想到了《金字塔原理》里面的 MECE 选择，按照互不相干的纬度进行分类，每个分类维护自己各自的观点。<br><br>2. 依据我们软件开发的流程，一开始的小公司早期其实都没有产品经理和测试，运维。当软件开发到一定层次的时候，就开始细分产品、开发、测试、运维、风控等岗位，每个岗位各司其职（目的还是维护一个产品，只是纬度不同）。<br><br>3. 一般在大公司，你的手下犯事了，你的领导不会找你的手下，而是直接找你。因为对于领导来说，他需要做的就是通过开发经理去管理下属，所以他的职责更多的是管理开发经理。","like_count":0},{"had_liked":false,"id":308317,"user_name":"小周","can_delete":false,"product_type":"c1","uid":2453498,"ip_address":"","ucode":"7ED7BC27A46C4C","user_header":"https://static001.geekbang.org/account/avatar/00/25/6f/fa/615a0df3.jpg","comment_is_top":false,"comment_ctime":1629532318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629532318","product_id":100039001,"comment_content":"还可以应用到模块划分、以及函数","like_count":0},{"had_liked":false,"id":300986,"user_name":"小帅","can_delete":false,"product_type":"c1","uid":1239663,"ip_address":"","ucode":"4129A7E9427FFC","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/6f/09de5f65.jpg","comment_is_top":false,"comment_ctime":1625476532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625476532","product_id":100039001,"comment_content":"感觉类的设计跟数据库表的设计很像","like_count":0},{"had_liked":false,"id":300127,"user_name":"roman","can_delete":false,"product_type":"c1","uid":2221077,"ip_address":"","ucode":"74F66DCB14DA22","user_header":"https://static001.geekbang.org/account/avatar/00/21/e4/15/80bf9ee3.jpg","comment_is_top":false,"comment_ctime":1625016820,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625016820","product_id":100039001,"comment_content":"学到<br>1、单一指责的概念<br>2、判断类是否足够的“单一”<br>3、单一指责设计的原则","like_count":0},{"had_liked":false,"id":295989,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1622694971,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1622694971","product_id":100039001,"comment_content":"单一职责可以用到方法上，避免设计一个大而全的方法，应该拆分为更细力度的多个方法","like_count":0},{"had_liked":false,"id":294051,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1621730036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621730036","product_id":100039001,"comment_content":"来了来了，三刷！","like_count":0},{"had_liked":false,"id":291936,"user_name":"栾~龟虽寿！","can_delete":false,"product_type":"c1","uid":1504671,"ip_address":"","ucode":"219B38C08979FE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","comment_is_top":false,"comment_ctime":1620615907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620615907","product_id":100039001,"comment_content":"打卡 ，单一，不容易。","like_count":0},{"had_liked":false,"id":290758,"user_name":"Geek_9dbc25","can_delete":false,"product_type":"c1","uid":2242904,"ip_address":"","ucode":"6CB31893173165","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIHxTg3tYriaCXiccCf7xUl9QHibAhCMBKQ2oCicvgcuHCo4ULSguISXeHzxM9a8fFD7icfy3OgXibvUNxw/132","comment_is_top":false,"comment_ctime":1619742356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619742356","product_id":100039001,"comment_content":"1.代码行数，属性是否过多<br>2.依赖的类是否过多<br>3.类中的大量方法都集中在操作某些属性<br>","like_count":0,"discussions":[{"author":{"id":2475056,"avatar":"https://static001.geekbang.org/account/avatar/00/25/c4/30/711b03e5.jpg","nickname":"Geek_Candice","note":"","ucode":"0F2CBCF624F905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393902,"discussion_content":"做什么和怎么做是应该解藕的，使用者并不关心具体的细节。棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631631528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285111,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1616631181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616631181","product_id":100039001,"comment_content":"我们首先要明确类的职责，才能做好单一职责的设计","like_count":0},{"had_liked":false,"id":284331,"user_name":"夏秋冬","can_delete":false,"product_type":"c1","uid":2526247,"ip_address":"","ucode":"20D62081D9596F","user_header":"https://static001.geekbang.org/account/avatar/00/26/8c/27/5644834e.jpg","comment_is_top":false,"comment_ctime":1616171063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616171063","product_id":100039001,"comment_content":"看了这篇文章后对高内聚和低耦合有了新的理解，可以把代码的臃肿程度视为一条坐标轴；<br><br>左边是低内聚，因过于追求单一职责导致类被拆的过于稀碎，使得类的可维护性降低；<br><br>右边是高耦合，因为过于追求大而全导致类太过臃肿，使得代码的可拓展性降低；<br><br>只有中间合适的设计满足高内聚与低耦合，使得类兼具了可维护性与可拓展性；","like_count":0},{"had_liked":false,"id":283147,"user_name":"秋","can_delete":false,"product_type":"c1","uid":2414484,"ip_address":"","ucode":"14E792376F6A3C","user_header":"https://static001.geekbang.org/account/avatar/00/24/d7/94/202e484b.jpg","comment_is_top":false,"comment_ctime":1615593850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615593850","product_id":100039001,"comment_content":"想请教一下大佬们，平时写业务代码的时候，有时候实体类里面的字段太多，如果要应用这个原则，对应的表是否也要拆分呢？还有因为用的是三层结构，我待过的好几家公司的项目里面都写的是一个实体对应 一个service，有时候因为对某个类的操作很多，就有很多个接口，我遇到过一个service里面有几千行代码，可读性非常差，这样的service怎么拆分呢？","like_count":0},{"had_liked":false,"id":281645,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1614838754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614838754","product_id":100039001,"comment_content":"关于拆分粒度的问题。<br>对于我来说，其实是个大脑内存问题。或者说是概念复杂度问题；而不是代码行数，函数多少问题。<br><br>一般我拆分类或模块的原则是，对于某一层代码，一般人看了能否明白是做什么的就不需要再去拆。<br><br>概念上只要足够清晰或者类内的复杂度都是明了易用的，就不需要拆分。<br><br>拿上面的userinfi的例子来说。所有的地址信息在外部只是展示，那就不需要拆分。为什么呢？因为程序员大脑可以批量认为这些属性通通是器官。可以说仅仅是一个概念就够了。<br><br>但当每个地址信息都需要额外的业务的时候。<br>那开发人员的大脑里就需要处理地址的字段逻辑了。这时候如果不拆的话，每一次处理地址信息的时候，还看着用户信息的话，大脑内存就被占用浪费了。","like_count":0},{"had_liked":false,"id":281589,"user_name":"Geek_f9a021","can_delete":false,"product_type":"c1","uid":2410677,"ip_address":"","ucode":"9973F02EEC650E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItGC2xTpD3HFfoX4XZsMbGozbo65kQLjbUtgtrGD108QQye9rcPUzfLOxniaadoY0fRib1VEeO771Q/132","comment_is_top":false,"comment_ctime":1614820749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614820749","product_id":100039001,"comment_content":"你好 单一职责原则和ddd充血模式是否违背了单一职责呢","like_count":0},{"had_liked":false,"id":280592,"user_name":"张云峥","can_delete":false,"product_type":"c1","uid":2056385,"ip_address":"","ucode":"8FF686816DBD9A","user_header":"https://static001.geekbang.org/account/avatar/00/1f/60/c1/a1437bca.jpg","comment_is_top":false,"comment_ctime":1614257634,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614257634","product_id":100039001,"comment_content":"有一个我实际中比较常用的判断方法，就是如果一个方法的代码行数超过了一个屏幕，那么这个方法就太长了。","like_count":0},{"had_liked":false,"id":280212,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1614135317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614135317","product_id":100039001,"comment_content":"单一职责，在实际应用中可以简单应用为：1.类名不好起，不明确，不符合；2.类使用时找方法麻烦；3.有修改时改动点多，易遗漏","like_count":0},{"had_liked":false,"id":280128,"user_name":"Chloe","can_delete":false,"product_type":"c1","uid":1004953,"ip_address":"","ucode":"C4848ED5B35752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","comment_is_top":false,"comment_ctime":1614088984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614088984","product_id":100039001,"comment_content":"谢谢老师从两个方面把SRP讲的很透彻。非常同意根据应用场景来适度使用SRP原则，我想接下来的设计pattern里面会讲到在重构的过程中，为了拆分类或者模块，怎么样设计能够最大程度的降低重构时候的成本，非常期待 :) ","like_count":0},{"had_liked":false,"id":276676,"user_name":"苗运齐","can_delete":false,"product_type":"c1","uid":1923230,"ip_address":"","ucode":"B33305840A9F84","user_header":"https://static001.geekbang.org/account/avatar/00/1d/58/9e/dc4fb520.jpg","comment_is_top":false,"comment_ctime":1612075053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612075053","product_id":100039001,"comment_content":"单一职责只是手段，高内聚低耦合、可复用、可扩展和可读性才是目标","like_count":0},{"had_liked":false,"id":274908,"user_name":"刘立嘉","can_delete":false,"product_type":"c1","uid":2414637,"ip_address":"","ucode":"1241140EBE7FE3","user_header":"https://static001.geekbang.org/account/avatar/00/24/d8/2d/6ec3760c.jpg","comment_is_top":false,"comment_ctime":1611216231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611216231","product_id":100039001,"comment_content":"高内聚、低耦合的原则，是面向对象设计的基本原则，一个类只是一样东西，一个方法只做一件事情，再通过合理的组合和调用，达到实现最终功能的目的。","like_count":0},{"had_liked":false,"id":274874,"user_name":"咚咚咚咚咚咚","can_delete":false,"product_type":"c1","uid":1649779,"ip_address":"","ucode":"C256D70088F02C","user_header":"https://static001.geekbang.org/account/avatar/00/19/2c/73/e5fe80b8.jpg","comment_is_top":false,"comment_ctime":1611201685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611201685","product_id":100039001,"comment_content":"对于如何判断一个类是否职责单一<br>类似前面说到的拆分名词动词来判断功能职责，比如获取用户数据再发送出去，这简单的理解应该是两个功能了吧，获取和发送，再细分到用户数据由哪些部分组成：头像图片，昵称，性别，年龄。然后图片是链接呢还是需要去拿图片Id去获取临时的图片链接，再然后年龄是需要用出生日期计算的。拆分到这里基本上就已经是比较细的颗粒度了，然后根据写的时候的怎么方便怎么合并和拆分职责。我大概是这样的","like_count":0},{"had_liked":false,"id":272035,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1609915711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609915711","product_id":100039001,"comment_content":"其实怎么写，怎么设计，在一开始的业务上你就要有一个大概的方向，业务明确之后，在去写代码，这样可以写出更好的代码。我在写代码中，其实就是没有去深深的去理解业务，上来框框就是干，导致后面整个类里面的方法杂乱无章，后期也更不想看。","like_count":0},{"had_liked":false,"id":271515,"user_name":"long","can_delete":false,"product_type":"c1","uid":1595158,"ip_address":"","ucode":"8424683A801718","user_header":"https://static001.geekbang.org/account/avatar/00/18/57/16/b7b4fe79.jpg","comment_is_top":false,"comment_ctime":1609676580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609676580","product_id":100039001,"comment_content":"感觉先写一个可以用的类，后续在持续重构还是太依赖测试了，比如是否写了单元测试，是否有集成测试等，必然我好心重构了下代码，然后导致线上 BUG 了就难受，所以一般测试覆盖不好的项目，我都不敢重构这个代码，虽然自己觉得没有问题，但是还是心慌，不知道这种情况下，争哥会如何考虑？","like_count":0},{"had_liked":false,"id":269458,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1608659057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608659057","product_id":100039001,"comment_content":"从维护性和易用性的角度去判断单一原则。","like_count":0},{"had_liked":false,"id":268071,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1608044057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608044057","product_id":100039001,"comment_content":"1、判断一个类是否职责单一<br>    代码行数过多，方法是否过多，且是否与自己的类的业务相关。<br>2、单一职责除了类设计，方法也需要这样设计。不要一个方法名，里面做了很多事情，顶层方法除外，增加可复用性。","like_count":0},{"had_liked":false,"id":267486,"user_name":"Geek_2495de","can_delete":false,"product_type":"c1","uid":1786809,"ip_address":"","ucode":"BCC92B259FF165","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/lHqiahnUnaWY9GOGgIamhbddJUYtopKABFmVwaD68uXgTdaA72HX3yzd6YtqPKEt1YxJuXwYXKsmzGNKXmV75LQ/132","comment_is_top":false,"comment_ctime":1607764937,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607764937","product_id":100039001,"comment_content":"1.  第一个：是否好读。倾向于一个方法内部的逻辑能够条理分明。如果读了很多久，都没理出逻辑来，或者读完整个方法，回过头才能看出逻辑，对我来说，就是代码行数过多。<br>1.  第二个： 是否存在读写不相关两个元素的共存的操作<br>2. 单一职责：方法、类、模块、接口、甚至整个项目都可以用吧~<br>","like_count":0},{"had_liked":false,"id":256050,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603514384,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1603514384","product_id":100039001,"comment_content":"1. 类单一职责判断可以通过评估其对外提供接口是否满足不断变化的业务和需求来确定！<br>问自己，该类是否对其他类是&quot;黑盒&quot;；<br><br>2. 类行数多=属性多+方法多<br>属性多: 要考虑这些属性是不是对类来说是必须的，需要移除么？<br>方法多: 方法间复用情况，方法间有没有写重复代码？<br>如上如果觉得没有可以改进的余地，就可以认为类行数恰当；<br><br>3. 单一职责还可以应用到方法，模块，功能点上。","like_count":0},{"had_liked":false,"id":247059,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1599573738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599573738","product_id":100039001,"comment_content":"打卡，又是慢慢的收获","like_count":0},{"had_liked":false,"id":246348,"user_name":"liliumss","can_delete":false,"product_type":"c1","uid":1333094,"ip_address":"","ucode":"A52AC5042F3115","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","comment_is_top":false,"comment_ctime":1599291425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599291425","product_id":100039001,"comment_content":"可以根据不同调用者在公司组织的关注点不同来切分，比如促销部门关注用户的下单，安全部门关注用户的账号安全，各个业务做到他们自己对应的组件里面去，这样互相之前的变动不会互相影响","like_count":0},{"had_liked":false,"id":246295,"user_name":"冬天里的懒猫","can_delete":false,"product_type":"c1","uid":1042458,"ip_address":"","ucode":"970E5CEF502828","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/1a/cea701bb.jpg","comment_is_top":false,"comment_ctime":1599269760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599269760","product_id":100039001,"comment_content":"为什么并发库里道格列的各种并发工具，如Concurrenthashmap有6千多行","like_count":0,"discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259179,"discussion_content":"哈哈，是的。我习惯了各种设计模式搭配functional函数乱飞，解耦拓展的很彻底，有时候会被说过度设计。反正我自己觉得很酷，飘逸优雅，我不改，哈哈哈，但凡有两三个分支到我这里都成了new StrategyContext(xxx).apply()，背后是查表Function<T,R> .apply，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588766011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245940,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599115546,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599115546","product_id":100039001,"comment_content":"问题1：<br>1、类的职责设计和定位清晰<br><br>问题2：<br>1、模块的划分","like_count":0},{"had_liked":false,"id":244555,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1598578594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598578594","product_id":100039001,"comment_content":"单一职责所谓的单一是在某一个抽象层面的单一。要知道这个类是否符合单一职责那么首先要看在设计这个类时它的抽象层次是什么？单一职责小到可以在类的方法上大整个架构上。","like_count":0},{"had_liked":false,"id":244368,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1598493920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598493920","product_id":100039001,"comment_content":"自己写完代码就变成了一个失忆的憨憨，测试同学通知我要改bug，我怎么办？<br>单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。同时业务类型和业务的复杂程度决定了类的职责是否单一。这都是心法，没有量化的标准呀，怎么实践？只能把自己当憨憨，把类尽量写得简单。<br>除了把自己当憨憨，作者给出的小技巧更有实操性。","like_count":0},{"had_liked":false,"id":243938,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1598333896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598333896","product_id":100039001,"comment_content":"单一职责思想  服务拆分，数据表设计都可以用上。","like_count":0},{"had_liked":false,"id":243665,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1598243568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598243568","product_id":100039001,"comment_content":"1 文中的行数过多、属性方法过多、无法命名、集中操作某几个函数、依赖的类过多依赖类的其他类过多，我自己觉得，一旦可读性差了，就说明类的职责不够单一。<br>2 函数的设计也需要单一职责原则。","like_count":0},{"had_liked":false,"id":241431,"user_name":"Geek_junjun","can_delete":false,"product_type":"c1","uid":1802621,"ip_address":"","ucode":"DF4C5D80802C7A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIE8EIS5arCmFwaZhazJmhn4Uz69Cmlay6dibibsdoNrnLyrsTsAdITK069usejicIE6aYpHULZ4G1YQ/132","comment_is_top":false,"comment_ctime":1597291594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597291594","product_id":100039001,"comment_content":"有代码度量工具可以辅助判定单一职责，如：单个文件行数超过200报警，单个函数超过50行报警等，如果开发团队能严格要求代码度量工具自动检查代码不能有任何上述报警，其实就能在很大程度上满足单一职责了，即使真的有某个函数小于50行又违背单一职责，实际上危害也不大，发现了顺手改一下就行，发现不了也没什么。","like_count":0},{"had_liked":false,"id":239582,"user_name":"owen","can_delete":false,"product_type":"c1","uid":1902116,"ip_address":"","ucode":"0E79DA9080A085","user_header":"https://static001.geekbang.org/account/avatar/00/1d/06/24/c2ee3b16.jpg","comment_is_top":false,"comment_ctime":1596591552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596591552","product_id":100039001,"comment_content":"看到类不超过200行，属性不超过10个，我就枯萎，设计一个订单类属性都超200行了！对于单一原则当然是把类打成原子压得越平确实越好，方便扩展可读性高各种好处！ 但是间接的开发成本维护成本，也会高很多，如果本身项目不大也没有太大必要分得越细，个人觉得初期也可以写得分得粗些，随着项目的扩大慢慢重构吧！！","like_count":0},{"had_liked":false,"id":239444,"user_name":"Aaron 延亮","can_delete":false,"product_type":"c1","uid":1394147,"ip_address":"","ucode":"48DE83DDF45A61","user_header":"https://static001.geekbang.org/account/avatar/00/15/45/e3/26d1e69c.jpg","comment_is_top":false,"comment_ctime":1596533109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596533109","product_id":100039001,"comment_content":"先学学java再看吧  不然不太容易看懂","like_count":0},{"had_liked":false,"id":236455,"user_name":"hex","can_delete":false,"product_type":"c1","uid":1757301,"ip_address":"","ucode":"B983D40DCD159F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d0/75/3e034f71.jpg","comment_is_top":false,"comment_ctime":1595419152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595419152","product_id":100039001,"comment_content":"单一职责尽量使类的拆分粒度更小,.但是拆分过度会破坏了高内聚.<br>比如微服务也可以按照业务和职责来拆分,不知说的是否对.","like_count":0},{"had_liked":false,"id":231821,"user_name":"Sic Pavis","can_delete":false,"product_type":"c1","uid":1106088,"ip_address":"","ucode":"48B5F0118347C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","comment_is_top":false,"comment_ctime":1593779776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593779776","product_id":100039001,"comment_content":"😂越学越觉得我国的中庸之道博大精深。<br>我没读过《中庸》，以前一听到这个词就感觉是墙头草，没立场。<br><br>现在学很多方法论包括架构，其实感觉其最核心思想就是中庸，在各种取舍间取得平衡。类似于文中，判断一个类是否符合SRP我觉得其实就是一种中庸的思想。","like_count":0},{"had_liked":false,"id":230162,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593299781,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593299781","product_id":100039001,"comment_content":"单一职责，更多的是从业务功能职责划分角度去考虑。<br>前提是做了业务职责功能划分，先有业务职责划分，才能做单一职责判断。<br>业务职责划分可以用DDD的战略设计。","like_count":0},{"had_liked":false,"id":228973,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592873921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592873921","product_id":100039001,"comment_content":"单一职责能够提高类的高内聚低耦合，有利于类的维护和扩展。而同一个类在多种场景下，单一职责不是一定的，避免拆分过细导致类的高内聚被打破。<br><br>不符合单一职责的可能场景有：类的某个属性一直被使用、类的长度方法太长、依赖的类太多不符合高内聚等","like_count":0},{"had_liked":false,"id":225803,"user_name":"MilkBeer","can_delete":false,"product_type":"c1","uid":1232314,"ip_address":"","ucode":"DC4FAC3F2A87EE","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/ba/84422076.jpg","comment_is_top":false,"comment_ctime":1591863403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591863403","product_id":100039001,"comment_content":"单一职责原则是为了能够提高类的内聚性，以让模块或者类之间的耦合降低。所以不能只是简单的为了单一而生搬硬套的去拆分类或者模块。过于拆分反而会让一个类内部没有任何内容，更无需提什么内聚性了。","like_count":0},{"had_liked":false,"id":224510,"user_name":"sorationalist","can_delete":false,"product_type":"c1","uid":2012902,"ip_address":"","ucode":"4E2B3B3234E1C5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b6/e6/b2be4536.jpg","comment_is_top":false,"comment_ctime":1591425226,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1591425226","product_id":100039001,"comment_content":"单一职责，我是按数据库表来划分的，所有这个表的增删改查都放在同一个service，设计到多表操作的，都同层调用，不知这样是否符合单一职责，高内聚低耦合。","like_count":0},{"had_liked":false,"id":224441,"user_name":"pony","can_delete":false,"product_type":"c1","uid":1021530,"ip_address":"","ucode":"B72FA864CDD286","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/5a/846a09f7.jpg","comment_is_top":false,"comment_ctime":1591402065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591402065","product_id":100039001,"comment_content":"1.类的单一原则判断，也可以根据受变更影响因素的个数来判断<br>2.单一原则也可以使用在函数设计上和网络协议分层设计上，每一层负责独立的功能","like_count":0},{"had_liked":false,"id":220747,"user_name":"朝小树","can_delete":false,"product_type":"c1","uid":1323875,"ip_address":"","ucode":"18DC282DEF16C8","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/63/2d48822a.jpg","comment_is_top":false,"comment_ctime":1590317742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590317742","product_id":100039001,"comment_content":"可能的范围内尽量做到单一职责，如果有A模型，B模型，多对多的关系，此时关系模型归属A还是B还是AB关系呢，每当这时候总会有些纠结。<br>","like_count":0},{"had_liked":false,"id":219354,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1125259,"ip_address":"","ucode":"7BF52ADBFD4F5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/8b/dd02189a.jpg","comment_is_top":false,"comment_ctime":1590014348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590014348","product_id":100039001,"comment_content":"课堂讨论问题：<br>1. 判断类的职责是否单一基本上是凭借经验来，通常来说一个类的代码是不超过1000行的。另外代码行数是否过多是跟某个功能的复杂程度，以及拆分的粒度有关系，不能一概而论。<br>除了通过代码行数来判断以外，还可以通过让别人来Review你的代码方式，询问别人是否能够很容易通过某一个Class文件或者代码块找出所有要实现的功能。<br>2. 单一职责原则除了应用到类的设计上，还可以延申到：功能模块的设计，应用按域拆分，甚至是前后端分离","like_count":0},{"had_liked":false,"id":217899,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1589641104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589641104","product_id":100039001,"comment_content":"如何判断类是否职责单一：<br>- 职责单一的类，准确来说是职责分明，不做过多的事情，也不少做事情。<br>  - 大部分开发人员都是会有一种直觉的，一个类如果负责太多东西或者太少，都会感觉不太好呀：乱，细节太多，阅读困难，觉得不妥，累，心里有点抗拒。<br>  - 这种状态的描述，有一个，有个形容词叫：心智负担重。<br> <br>- 另外个人认为，在判断代码是否设计良好的时候，可以代码能够让人以较少的「负担」来阅读，修改，测试等判断。<br>- 一旦出现这种内心状态的时候，就是我们要重新思考设计的时候<br><br>至于能够应用到那些地方，这太多了：<br>- 架构分层，每一层要有明确的职责<br>- 微服务<br>- 库，模块<br>- 通信协议，接口等的设计<br><br>以上一些粗浅的观点~","like_count":0},{"had_liked":false,"id":217496,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589515481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589515481","product_id":100039001,"comment_content":"如何理解单一职责： 要设计功能职责单一的类，不要涉及大而全的类。单一职责提高高内聚低耦合，提高代码可读性 可维护性 复用性 如何判断类是否单一职责。是否是类分的越细越好：类分的细致会导致内聚性不好","like_count":0},{"had_liked":false,"id":216319,"user_name":"darkleo","can_delete":false,"product_type":"c1","uid":1023395,"ip_address":"","ucode":"126DF780822654","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/a3/a780d006.jpg","comment_is_top":false,"comment_ctime":1589242360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589242360","product_id":100039001,"comment_content":"老师，我想问一下，为什么不把Serialization设计成工具类呢？这个是从什么方面来考虑的呢？","like_count":0,"discussions":[{"author":{"id":1433815,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","nickname":"空白昵称","note":"","ucode":"91F50CA25102AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213033,"discussion_content":"设计模式是术 😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585044366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251429,"avatar":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","nickname":"潇潇雨歇","note":"","ucode":"4BD52BF0F0A084","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1433815,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","nickname":"空白昵称","note":"","ucode":"91F50CA25102AB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213044,"discussion_content":"嘻嘻😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585045641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213033,"ip_address":""},"score":213044,"extra":""}]}]},{"had_liked":false,"id":215523,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1589010665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589010665","product_id":100039001,"comment_content":"1. 类的字段有很多，不够具体。<br>2. 比如在设计数据库表的时候，也要考虑表的职责单一，一个表处理一件事情，多表现在表中列存在耦合关系，那这就好违反三大范式，所以需要拆分成多个表。从这个角度看，也是单一职责原则的应用。","like_count":0},{"had_liked":false,"id":214612,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1588773178,"is_pvip":false,"replies":[{"id":"86790","content":"一个接口只有一个方法，这种设计不常见吧，除非框架限制，有特殊要求，才会这么做。","user_name":"作者回复","comment_id":214612,"uid":"1190123","ip_address":"","utype":1,"ctime":1594904026,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1588773178","product_id":100039001,"comment_content":"老师，您好，我工作中遇到的就是面向过程编程，一个接口中只有一个方法，对应一个实现，然后通过dubbo  rpc调用。。。请问如果一个接口中很多个方法，那实现类不就很复杂了么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494140,"discussion_content":"一个接口只有一个方法，这种设计不常见吧，除非框架限制，有特殊要求，才会这么做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594904026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211727,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1587999437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587999437","product_id":100039001,"comment_content":"数表类型不停变更 字段也不停变更 方法实现高度耦合 然后改到吐血","like_count":0},{"had_liked":false,"id":210655,"user_name":"Mr丶JDR","can_delete":false,"product_type":"c1","uid":1194429,"ip_address":"","ucode":"0377C1D0EDABBF","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/bd/344cff8c.jpg","comment_is_top":false,"comment_ctime":1587803315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587803315","product_id":100039001,"comment_content":"20200425 16:28 重新温习设计原则","like_count":0},{"had_liked":false,"id":208347,"user_name":"铁血柔情","can_delete":false,"product_type":"c1","uid":1124220,"ip_address":"","ucode":"F09CACF06B8D05","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/7c/463d4342.jpg","comment_is_top":false,"comment_ctime":1587343501,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1587343501","product_id":100039001,"comment_content":"争哥，一个service实现类有两千行代码，但是确实是这个业务下的功能，请问下怎么做拆分呢？每个方法的代码已经拆分好了，最多七十行。<br>","like_count":0},{"had_liked":false,"id":203757,"user_name":"makermade","can_delete":false,"product_type":"c1","uid":1133194,"ip_address":"","ucode":"03386B90CB8F20","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","comment_is_top":false,"comment_ctime":1586263174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586263174","product_id":100039001,"comment_content":"单一职责，也可以延伸到微服务的拆分上。一个服务，只负责单一核心业务","like_count":0},{"had_liked":false,"id":202600,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586013140,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586013140","product_id":100039001,"comment_content":"单一职责原则，还可以应用到类函数的设计上。也可以应用到相关模块的设计上。","like_count":0},{"had_liked":false,"id":202599,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586013068,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586013068","product_id":100039001,"comment_content":"类的代码函数一般不超过200行？这个似乎一个函数还差不多。哈哈哈","like_count":0},{"had_liked":false,"id":201146,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1585723091,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585723091","product_id":100039001,"comment_content":"想请教一下，所谓的内聚性是什么意思？是指类内各个成员和方法的联系程度吗？","like_count":0},{"had_liked":false,"id":199832,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585496684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585496684","product_id":100039001,"comment_content":"单一职责：一个类或模块只注重于一个职责。<br><br>我以前的写的也是不够单一，把本来可以分开的方法都放到同一个地方。后面不能很好复用，也很难理解。","like_count":0},{"had_liked":false,"id":197697,"user_name":"01Running","can_delete":false,"product_type":"c1","uid":1015862,"ip_address":"","ucode":"2E50E4FD35D3B5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/36/29e4863f.jpg","comment_is_top":false,"comment_ctime":1585392267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585392267","product_id":100039001,"comment_content":"学习总结：<br>* 定义：一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。<br>* 如何判断类的职责是否足够单一？<br>    * UserInfo 里面的地址信息<br>        * 如果只是展示，则放一起<br>        * 如果又有一个电商物流，那可能要把地址信息拆分出来<br>        * 如果又有统一账号系统，那可能要把身份认证相关的信息拆分出来<br>    * 需要根据具体业务场景来判断<br>    * 不过度设计：<br>        * 我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构 !\u0010<br>    * 作者的判断原则：<br>        * 类中的代码行数、函数或者属性过多；<br>        * 类依赖的其他类过多，或者依赖类的其他类过多；<br>        * 私有方法过多；<br>        * 比较难给类起一个合适的名字；<br>        * 类中大量的方法都是集中操作类中的某几个属性。<br>    * 注（不是绝对的！“放盐少许”）：一个类的代码行数最好不能超过 200 行，函数个数及属性个数都最好不要超过 10 个。<br>* 类的职责是否设计得越单一越好？<br>    * 如：序列化和反序列化拆分成两个类：<br>        * 序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来 Serialization 高了。<br>        * 而且，如果我们仅仅对 Serializer 类做了协议修改，而忘记了修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错。<br>    * 单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。<br>* 不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准。   ","like_count":0},{"had_liked":false,"id":197664,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585390499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585390499","product_id":100039001,"comment_content":"单一职责这个还比较简单。","like_count":0},{"had_liked":false,"id":196741,"user_name":"Sissi.C","can_delete":false,"product_type":"c1","uid":1748046,"ip_address":"","ucode":"689AA6A8BE1687","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/4e/08b0644b.jpg","comment_is_top":false,"comment_ctime":1585309274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585309274","product_id":100039001,"comment_content":"听完这节课的例子终于解答了我关于类耦合的疑惑！","like_count":0},{"had_liked":false,"id":196575,"user_name":"Six","can_delete":false,"product_type":"c1","uid":1220617,"ip_address":"","ucode":"E297BB638B2BD9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","comment_is_top":false,"comment_ctime":1585294204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585294204","product_id":100039001,"comment_content":"&quot;类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；&quot; 这句话不太理解，比如UserInfo 依赖UserAddress和Userxxxx等等。依赖的Userxxx类比较多。那这时怎么分类。怎么将分类后的类组合到UserInfo中？","like_count":0},{"had_liked":false,"id":195426,"user_name":"熊猫","can_delete":false,"product_type":"c1","uid":1044216,"ip_address":"","ucode":"1C22CFD1652D9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/f8/bc5faaec.jpg","comment_is_top":false,"comment_ctime":1585187379,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585187379","product_id":100039001,"comment_content":"在微服务设计中， 也应当遵循单一职责原则， 尽量将相关业务内聚在微服务内， 从而实现服务内的高内聚， 降低其他服务的依赖， 对外实现低耦合。  <br><br>当我们遇到某个需求或者某者功能应该在哪个服务进行开发维护时， 可以看一下， 是否符合单一职责的原则。  ","like_count":0},{"had_liked":false,"id":194403,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585058384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585058384","product_id":100039001,"comment_content":"第一个问题，判断这个类是否单一可以思考这个类是否可以单独拿出来给其他项目使用而不必引入其他相关的很多类。代码行数多不多，可以考虑这个函数里面的一些代码是否可以抽出来放在工具类Util中。<br>第二个问题，单一职责也可以用在系统设计上面，比如微服务。在我们产品里面，每个软件负责一块特定的业务场景，这个业务场景都有共性。比如我们的网管服务器，就是用于和外部系统进行信息和协议转换的。比如我们的中心服务器，就是用于做信息缓存功能的，任何系统都是通过中心服务器获取需要的信息。","like_count":0},{"had_liked":false,"id":193815,"user_name":"陈包佳","can_delete":false,"product_type":"c1","uid":1576712,"ip_address":"","ucode":"9DAAC87C75D91F","user_header":"https://static001.geekbang.org/account/avatar/00/18/0f/08/7abf466e.jpg","comment_is_top":false,"comment_ctime":1584969595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584969595","product_id":100039001,"comment_content":"srp原则的学习理解：<br>1.单一职责原则的目的是？<br>将一个粗粒度的类拆分成力度更小，更细的类<br>，增加代码的可读性，可维护性，可扩展性。<br>2. 职责的划分根据应用场景和业务的不同而不同，没有明确的界限，可以先设计粗力度的类，在随着需求的变更细分为更细的力度类。<br>3.判断一个类的职责是否单一的方法？<br>首先判断这个类的属性是否过多，依赖的类较多增加了代码的耦合性，不易于维护，有大部分的方法是处理某些属性，或者私有方法过多可以考虑将私有方法拆分成另一类，并提升访问属性权限，为public，以提高代码的可复用性。<br>3. 累的拆分粒度过于细带来的影响<br>类的拆分力度过细，会降低代码的内聚性，不易于维护。<br>总体来说，单一职责原则要根据业务以及设计经验合理使用，不能，过分追求单一职责，这些设计原则目的还是为了提高代码的可读性，可维护性和可扩展性，实现代码的，高内聚，低耦合。","like_count":0},{"had_liked":false,"id":192288,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584845489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584845489","product_id":100039001,"comment_content":"“单一职责原则”也是微服务系统拆分的标准，软件设计大到一个系统、小到一个类，都需要界限清晰明确，否则可能写出来一团浆糊。","like_count":0},{"had_liked":false,"id":189295,"user_name":"mr.su","can_delete":false,"product_type":"c1","uid":1004716,"ip_address":"","ucode":"8A4B9910960118","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/ac/8b94b8b2.jpg","comment_is_top":false,"comment_ctime":1584496967,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584496967","product_id":100039001,"comment_content":"单一职责原则可以用到接口设计上，一个接口处理一件事情","like_count":0},{"had_liked":false,"id":187698,"user_name":"风清扬笑","can_delete":false,"product_type":"c1","uid":1028152,"ip_address":"","ucode":"C0494B7A97A628","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b0/38/076fa6c1.jpg","comment_is_top":false,"comment_ctime":1584195180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584195180","product_id":100039001,"comment_content":"争哥能不能推荐一点你认为应用了或者部分应用了SOLID原则的一些开源代码、框架或者库，学习下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510253,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187025,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1583993819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583993819","product_id":100039001,"comment_content":"组件化开发 ，模块化开发，微服务开发 应该都是单一原则的体现","like_count":0},{"had_liked":false,"id":185558,"user_name":"函数方程(弘宇)","can_delete":false,"product_type":"c1","uid":1695043,"ip_address":"","ucode":"FF32376E9B7C84","user_header":"https://static001.geekbang.org/account/avatar/00/19/dd/43/93f04f89.jpg","comment_is_top":false,"comment_ctime":1583633388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583633388","product_id":100039001,"comment_content":"争哥，问下，之前说UserInfo 类中，如果UserInfo 类中地址address占比比较高，可以将其拆分出来，新建一个userAddress类，那么是否就是说UserInfo类中就不包含address字段信息了。但是如果UserInfo是一个DTO（用于传输数据的类），address字段就不应该从UserInfo类中删除了？","like_count":0},{"had_liked":false,"id":183862,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1583148351,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583148351","product_id":100039001,"comment_content":"【设计模式笔记16】20200301<br>今天主要讲了单一职责原则，大概给出了一些判断方法，不过每个人的经验和理解会不一样，我是这么理解的，一一个旁观者的角度审视代码，这样写是否只做了一件事，是从哪个角度考虑的，当前的代码不符合的话是否是从另外的角度考虑的。看代码就像看文章，把握要点，如果主旨不清晰肯定是有问题。我自己就会遇到你理解这个模块应该只做这些事，但是从另外的角度也可以做其他事，所以沟通很重要。当然也有一些通用的规约，类太长、方法太多、耦合严重等都是一些标准，更多可以参考阿里巴巴Java开发规约，但是我们要明白本质和原因才能真正理解。","like_count":0},{"had_liked":false,"id":182620,"user_name":"小田","can_delete":false,"product_type":"c1","uid":1073342,"ip_address":"","ucode":"59CA02059F71E4","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/be/68ce2fd0.jpg","comment_is_top":false,"comment_ctime":1582816941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582816941","product_id":100039001,"comment_content":"# 要点小结<br>1. 相互关联的属性&#47;方法，置于同一个类中，不要拆；反之，不要将不相关的属性&#47;方法置于一个类中。<br>2. 一个对象如果只被一个类持有，则置于类中；若被多个类持有，则单独封装成类。<br>3. 为了保证不同类之间“低耦合”：避免设计大而全的类，避免将不相关的功能耦合在一起<br>5. 为了保证类的“高内聚”：不要将属于一个类的不同属性拆分得过细","like_count":0},{"had_liked":false,"id":182474,"user_name":"xyz","can_delete":false,"product_type":"c1","uid":1016059,"ip_address":"","ucode":"CA183740FB5C9D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/fb/ffa57759.jpg","comment_is_top":false,"comment_ctime":1582793681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582793681","product_id":100039001,"comment_content":"看到这里的单一原则，想起来Unix文化中的一点：让每个程序只做好一件事情。<br>","like_count":0},{"had_liked":false,"id":180856,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582429965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582429965","product_id":100039001,"comment_content":"喜欢这种提个问题，再追问一个问题的讲解方式，有料；单一职责，高内聚，低耦合；易读、易维护、易复用；","like_count":0},{"had_liked":false,"id":180732,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582376403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582376403","product_id":100039001,"comment_content":"游戏的需求出自于策划，必须持续重构才能跟得上需求变动。单一设计原则是一个非常有用的判断工具，对于已经不可维护的代码，最好就是建立测试用例，小步快跑地重构。","like_count":0},{"had_liked":false,"id":180354,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582266577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582266577","product_id":100039001,"comment_content":"<br>1.如同老师说的,判断单一职责原则是一种主观的问题,我个人也没有什么好方法,只是单纯的觉着这个类合适,这个类不适合再增加或者再减少属性了,就是一个足够合适的单一职责类<br>2.这个原则在描述中写了,适合于类和模块的设计,那么就是在类的基础上,保证模块的功能单一,再往上延伸到实际开发中,就是在项目的微服务中,让每一个微服务所提供的的功能足够单一,组合起来实现一个完整的系统","like_count":0},{"had_liked":false,"id":180018,"user_name":"向往而行","can_delete":false,"product_type":"c1","uid":1141676,"ip_address":"","ucode":"AE01D637B946C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/6b/ac/cc187d8d.jpg","comment_is_top":false,"comment_ctime":1582166423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582166423","product_id":100039001,"comment_content":"单一职责不只是要求不要让一个模块干多件事情，同时也要求不要让它不干事情。","like_count":0},{"had_liked":false,"id":179732,"user_name":"一区","can_delete":false,"product_type":"c1","uid":1793770,"ip_address":"","ucode":"B5142A6276E490","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a2mRI7BYncHCL6QWfibe7g7MWc70fSsqQibu7o9PcHjicYwo5dSnAoUN75HDDRz4GXWJdpWw59yJsMwFv3t7zSiaJQ/132","comment_is_top":false,"comment_ctime":1582085133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582085133","product_id":100039001,"comment_content":"做过一个互联网金融的项目，一个数据表中有一百多个字段，而且都是同等作用的描述属性。觉得单一职责原则和代码的高内聚低耦合原则，用不好就是冲突的","like_count":0},{"had_liked":false,"id":176418,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1581055340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581055340","product_id":100039001,"comment_content":"高内聚，低耦合<br>我是这样理解的<br>对于一些功能类似的方法放在一起，是为了高内聚；<br>对于一些功能不相关的方法不放在一起，是为了低耦合。<br>","like_count":0},{"had_liked":false,"id":175769,"user_name":"Cindy_Yu","can_delete":false,"product_type":"c1","uid":1328604,"ip_address":"","ucode":"EE6869CAC5C1EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/45/dc/a3a231d1.jpg","comment_is_top":false,"comment_ctime":1580825604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580825604","product_id":100039001,"comment_content":"单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？可以用到方法设计和接口设计上。安卓开发的act常常是以页面来划分，一个act上要实现很多内容。这样网络请求的接口，按钮点击事件的响应方法就特别需要符合单一原则。","like_count":0},{"had_liked":false,"id":174137,"user_name":"cbping","can_delete":false,"product_type":"c1","uid":1608798,"ip_address":"","ucode":"16D891E80A352B","user_header":"https://static001.geekbang.org/account/avatar/00/18/8c/5e/8cb6fad1.jpg","comment_is_top":false,"comment_ctime":1580022872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580022872","product_id":100039001,"comment_content":"私有方法，很多时候都是需要复用得功能","like_count":0},{"had_liked":false,"id":172658,"user_name":"北风一叶","can_delete":false,"product_type":"c1","uid":1087302,"ip_address":"","ucode":"30310E66341D2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","comment_is_top":false,"comment_ctime":1579246634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579246634","product_id":100039001,"comment_content":"类的单一职责功能，要从业务的角度划分，根据业务的需求分析是否归为同一个职责，这个并没有统一的定论，也没有什么量化标准。这个东西只能写，写多了就有感觉了。","like_count":0},{"had_liked":false,"id":172591,"user_name":"wakaka","can_delete":false,"product_type":"c1","uid":1471508,"ip_address":"","ucode":"835A7341577D3B","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/14/ea854bfc.jpg","comment_is_top":false,"comment_ctime":1579228858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579228858","product_id":100039001,"comment_content":"职责单一的概念在不同业务场景每个人都有不同的理解，很难有定量标准，但是目标是不变的，都是为了代码的可读性，可维护性，可扩展性。","like_count":0},{"had_liked":false,"id":171687,"user_name":"www","can_delete":false,"product_type":"c1","uid":1275203,"ip_address":"","ucode":"951B364F2CB211","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg","comment_is_top":false,"comment_ctime":1578992015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578992015","product_id":100039001,"comment_content":"在go语言中，不要设计大而全的接口，要设计功能单一的小接口，匿名嵌入到大接口中","like_count":0},{"had_liked":false,"id":170493,"user_name":"wai","can_delete":false,"product_type":"c1","uid":1439529,"ip_address":"","ucode":"29CE3BE148FB79","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/29/60e01017.jpg","comment_is_top":false,"comment_ctime":1578621356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578621356","product_id":100039001,"comment_content":"方法的设计也有遵循单一职责，否则耦合的过于严重，修改方法造成的影响点很大，可读性也很差","like_count":0},{"had_liked":false,"id":169808,"user_name":"未来的胡先森","can_delete":false,"product_type":"c1","uid":1234682,"ip_address":"","ucode":"AFF193AC0E2E6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/fa/1f5bf642.jpg","comment_is_top":false,"comment_ctime":1578449675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578449675","product_id":100039001,"comment_content":"课后思考  2，单一职责在数据库中的应用就是数据库的范式设计，当一张表中存放了过多冗余、非主属性依赖的字段（单个类承载了过多职责），就会出现更新插入删除异常，所以第一第二范式通常是在设计关系型数据库是需要满足的，第三范式结合业务场景满足。<br>同理问题 1 应该也能参照数据库设计来判断是否代码是否规范","like_count":0},{"had_liked":false,"id":169778,"user_name":"顺","can_delete":false,"product_type":"c1","uid":1242973,"ip_address":"","ucode":"20230CA126824A","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/5d/818ec2a7.jpg","comment_is_top":false,"comment_ctime":1578445446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578445446","product_id":100039001,"comment_content":"职责单一不仅用于业务逻辑 界面职责单一也尤其重要 有些公用的界面比如输入用户信息、输入金额等就应只用于获取输入的信息 而不应该由于流程把其它的业务逻辑在公用界面嵌套if...else加入业务逻辑 <br>开发中判断这个类或模块是否职责单一得看场景需求 个人一般做法 就是看这个类或模块是否可以直接或快速拷贝重用 因为有时候由于定制项目 好多业务或功能相同 但又有区别无法做成组件 有时候能提高copy的效率优于过度设计组件。","like_count":0},{"had_liked":false,"id":169167,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1578282719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578282719","product_id":100039001,"comment_content":"单一的好处：高内聚、低耦合、复用<br>判断是否符合单一的<br>1.看代码行数是不是很多（比如成员属性、方法之类的），很多的话就要考虑拆<br>2.看是不是符合高内聚（功能多，聚合在一起）、低耦合。类依赖或者被依赖的类多就要考虑了<br>3.相同功能的私有方法过多，考虑把这些公共的方法提取出来<br>4.用业务来起名字难，名字笼统是因为可能包含了一些功能，比如OrderInfoController、OrderMangeContr、OrderCommonController。<br>5.其它的地方调用的大部分都是这个类的一部分属性，可以将这些抽取出来<br>6.其它类调用的时候，看看是不是有一大堆自己没用的东西<br>7.看这个类对应表，是不是有数据库其它表的字段，如果只是省市区（三个属性左右）就情有可原，但如果有好几张表就过分了<br>一个类的代码行数最好不能超过 200 行，函数个数及属性个数都最好不要超过 10 个（只是用于参考，但不是绝对）<br>不适合拆的：一些情况下分的太细也不是好事。比如一个加密解密类拆成一个加密，一个解密，原来是用MD5加密的，现在改成了AES加密，那么这两个类都需要改，如果不小心忘了一个就得不偿失，这样也增大了代码的维护性难度<br><br><br>讨论：<br>单一涉及原则除了应用在类上，还有在接口上，不要想接口除了主要的功能还帮你去处理一些无关的。比如去查询用户的流水，就不要再去考虑查之前先判断修改钱包的钱。","like_count":0},{"had_liked":false,"id":168806,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1578189641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578189641","product_id":100039001,"comment_content":"单一职责用在模块划分可以作为微服务的一种边界划分的参考","like_count":0},{"had_liked":false,"id":168805,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1578189451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578189451","product_id":100039001,"comment_content":"1.阿里手册一个方法不要超过80行，超过80行就该拆分了。<br>2.单一职责原则，属于相关功能的信息划分在一起，既可以避免拆分过细，又避免了耦合。","like_count":0},{"had_liked":false,"id":167949,"user_name":"LYy","can_delete":false,"product_type":"c1","uid":1102062,"ip_address":"","ucode":"8D5C39B9531E71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ee/f5c5e191.jpg","comment_is_top":false,"comment_ctime":1577968313,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577968313","product_id":100039001,"comment_content":"单一职责原则 可以说是复杂度应对的底层(核心)原则 下到CPU机器码指令 中到代码模块 上到领域架构模型 无一不能用SRP大展拳脚 同时也无一不需要思考权衡”单一”的粒度<br>纵向应用单一职责分模块 横向利用单一职责分层 几乎是所有软件系统中最常见的复杂度控制手段 其实不仅是软件领域 社会分工&#47;分层何尝不也是SRP的体现？(出圈了 哈哈哈)<br>SRP是唯一上升到“道”的高度的设计原则","like_count":0},{"had_liked":false,"id":167804,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1577937430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577937430","product_id":100039001,"comment_content":"比如我设计一个conf表，字段有infoId,pid,type<br>然后就是各种配置表，比如imageInfo表，imageTagInfo表有10几个不同配置表。我根据conf表的type和infoId找到对应的info数据。但是如果我有一些info表之间的逻辑处理，比如image和imageTag，我目前是吧代码逻辑写在conf表的BO里面的。根据单一原则，那这个conf表的BO是不是包含的逻辑太多了","like_count":0},{"had_liked":false,"id":167637,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1577884453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577884453","product_id":100039001,"comment_content":"面向对象编程，每一个实体一个对象。这种编程风格是不是从大的层面看也是单一职责原则。把对象相关的属性和方法进行封装。而面向过程的方式，就是把过程用到的都写到一起。","like_count":0},{"had_liked":false,"id":167183,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1577709551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577709551","product_id":100039001,"comment_content":"单一职责可以用在系统拆分上，也就是模块拆分，把公共的功能或业务拆分到同一个系统上，降低系统之间的耦合，高内聚低耦合，而且系统之间交互最好是MQ，无感知的。","like_count":0},{"had_liked":false,"id":166164,"user_name":"Zhen","can_delete":false,"product_type":"c1","uid":1643029,"ip_address":"","ucode":"4235C791CB4A5D","user_header":"https://static001.geekbang.org/account/avatar/00/19/12/15/874b9d62.jpg","comment_is_top":false,"comment_ctime":1577410127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577410127","product_id":100039001,"comment_content":"相关资料上有这样的关于SRP的描述【1】：“Gather together the things that change for the same reasons. Separate those things that change for different reasons.”<br><br>因相同的原因一起“变化”的功能就放在一起，因不同原因变化的功能就分出来。<br><br>按照内在的&quot;变化&quot;划分，而不是按照表面的“行为”进行划分。<br><br>有些功能要因为相同的原因而变化，就把它们放在一个类或功能模块里；比如前面所举的序列化和反序列功能，如果我们修改了协议的格式，数据标识从“UEUEUE”改为“DFDFDF”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，它们以相同的原因一起变化，所以最好不要拆分。<br><br>【1】https:&#47;&#47;medium.com&#47;better-programming&#47;revisiting-solid-927e6a5202d3<br>","like_count":0},{"had_liked":false,"id":165498,"user_name":"Seeker","can_delete":false,"product_type":"c1","uid":1180644,"ip_address":"","ucode":"C5F22962B8CE0D","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/e4/0cb8dcaf.jpg","comment_is_top":false,"comment_ctime":1577245901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577245901","product_id":100039001,"comment_content":"有可能是写的代码还不是很多的原因，看完这儿之后并没有什么深刻的感悟。<br>我们一般都是看到类实在是太大太长了，就会想着重构一下。但是也仅限于重构成方法，拆成多个类倒是比较少见。这可能我们是一个框架的原因，一些类中的方法一旦定义好了，再拆分改动的话容易引入后向不兼容的问题。<br>这样只能保留原来的方法，最多就是把一些他的逻辑放到另外一个类里，再用组合的方式调用其中的方法。但是感觉也只是好了一点点。","like_count":0},{"had_liked":false,"id":165132,"user_name":"假如年少有为","can_delete":false,"product_type":"c1","uid":1698072,"ip_address":"","ucode":"781E9DF18B95C5","user_header":"https://static001.geekbang.org/account/avatar/00/19/e9/18/d047ff86.jpg","comment_is_top":false,"comment_ctime":1577169343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577169343","product_id":100039001,"comment_content":"在父类定义公共属性","like_count":0},{"had_liked":false,"id":164554,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1577026489,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1577026489","product_id":100039001,"comment_content":"1.第一个话题，对于类职责是否单一通常情况下我也会去了解这个类的使用的业务场景以及抽象的业务对象是否能够匹配当前类的使用业务范围，业务范围的界定其实就是个人的理解了<br>2.第二个话题，方法的单一职责，比如在一个大的业务方法中，其中相关的调用的子业务方法必须处于同一层级，如果不是，那说明当前的方法还有再次提取优化的空间，直至下层的方法都处于同一层级，当然想法比较的完美，实际的情况都是一步一步的进行优化处理的","like_count":0},{"had_liked":false,"id":164473,"user_name":"Arthur.Li","can_delete":false,"product_type":"c1","uid":1005824,"ip_address":"","ucode":"EC2436A5136C13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/00/6d14972a.jpg","comment_is_top":false,"comment_ctime":1577002604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577002604","product_id":100039001,"comment_content":"判断类的职责是否单一<br>* 类中的代码行数、函数或者属性过多；<br>* 类依赖的其他类过多，或者依赖类的其他类过多；<br>* 私有方法过多；<br>* 比较难给类起一个合适的名字；<br>* 类中大量的方法都是集中操作类中的某几个属性。<br><br>不能为了单一职责原则，把很多类拆的太细。这样会影响代码可维护性，降低内聚性。<br><br>&gt; 我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构<br><br>单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？<br>答：最需要单一职责的应该就是方法了吧。因为不注意或者懒省事，好多时候一个方法会做多件事，或者顺便把某个别的也做了，虽然和当前方法有关系。","like_count":0},{"had_liked":false,"id":164124,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1576889240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576889240","product_id":100039001,"comment_content":"「类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分」这句话是否可以理解为：一个功能被散落在多个类中，应该重新整合共同完成该功能的所有类，将完成功能的“同性质”步骤归并到同一个类中。","like_count":0},{"had_liked":false,"id":163313,"user_name":"熊🐻","can_delete":false,"product_type":"c1","uid":1027320,"ip_address":"","ucode":"16779B8E2A8752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/f8/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1576684286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576684286","product_id":100039001,"comment_content":"单一职责：代码块只有一个修改预期，有多个则拆分，没有的话在user类里面耦合商品属性都行。","like_count":0},{"had_liked":false,"id":162325,"user_name":"瑞泉","can_delete":false,"product_type":"c1","uid":1111565,"ip_address":"","ucode":"D38E24A98FDAE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/0d/e16dff4e.jpg","comment_is_top":false,"comment_ctime":1576500395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576500395","product_id":100039001,"comment_content":"如果把地址相关属性抽出来构建一个新对象，那么原user对象中是不是应该增加一个新的地址对象？另外在做概览这种可视化页面，需要调用多个模块的数据是否违背单一原则？","like_count":0},{"had_liked":false,"id":161778,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1576325144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576325144","product_id":100039001,"comment_content":"单一职责（一个萝卜一个坑）、里氏替换（继承复用）、依赖倒置（面向接口编程）、接口隔离（高内聚、低耦合）、迪米特法则（降低类与类之间的耦合）、开闭原则（对扩展开发、对修改关闭）。","like_count":0},{"had_liked":false,"id":161597,"user_name":"Geek_e9b8c4","can_delete":false,"product_type":"c1","uid":1716601,"ip_address":"","ucode":"C29F7344A6EE6B","user_header":"","comment_is_top":false,"comment_ctime":1576243645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576243645","product_id":100039001,"comment_content":" <br>DS：曾经做过有个物流项目，比如有两个方法，1、查询司机订单；2、查询企业订单，这两个方法是都放OrderService 呢，还是分别放在DriverService和CompanyService类里？ 简单的判断就是根据返回的类型来决定。返回订单类型的方法就放在OrderService。现实项目中遇到过很多类似的功能方法，不知道到哪去找！","like_count":0},{"had_liked":false,"id":161592,"user_name":"Geek_e9b8c4","can_delete":false,"product_type":"c1","uid":1716601,"ip_address":"","ucode":"C29F7344A6EE6B","user_header":"","comment_is_top":false,"comment_ctime":1576241169,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576241169","product_id":100039001,"comment_content":"DS:一处修改引起了多处功能性质类似的类的变动 ，或者多个类中的代码有重复，一个思考方向：考虑合并为同一个类","like_count":0,"discussions":[{"author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281093,"discussion_content":"那就用懒加载嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591670666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161569,"user_name":"Varus","can_delete":false,"product_type":"c1","uid":1715988,"ip_address":"","ucode":"B9CB88C248BD93","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/14/840d0925.jpg","comment_is_top":false,"comment_ctime":1576234483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576234483","product_id":100039001,"comment_content":"1、就是自己感觉自己写的类结构不清晰，自己很容易忘记类中的方法的时候，每当有修改或者新加的功能时，自己都会觉得烦，都不愿意去重新审视自己代码的时候，没有问题，这个职责一定不单一了，重构吧！！！<br>2、单一值择让我想起来今天看到的微服务，面向对象万岁！！！","like_count":0},{"had_liked":false,"id":161343,"user_name":"CDz","can_delete":false,"product_type":"c1","uid":1114779,"ip_address":"","ucode":"A23BEE1C4A5922","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9b/b1a3c60d.jpg","comment_is_top":false,"comment_ctime":1576196225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576196225","product_id":100039001,"comment_content":"单一原则，很多时候其实很难鉴定一个模块、类的单一原则。需要根据当前的业务去做规划。<br>- 持续重构，将重构当做平时开发的一部分，持续的去做<br>- 业务场景的增加，会使得原来单一原则不灵<br> - 比如用户类，开始业务简单可以放置很多信息<br> - 业务复杂后，比如增加电商模块，地址就需要抽离<br> - 更复杂的，多系统后，用户类就会只剩下用户名和密码","like_count":0},{"had_liked":false,"id":161215,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1576149583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576149583","product_id":100039001,"comment_content":"课后讨论1：如何判断一个类是否职责单一， 类职责不单一，要做的事情太多了，不是单一的业务场景。<br>课后讨论2：责任链模式，每一环只做自己该做的，比如Netty不同的Handler","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493647,"discussion_content":"你可以简单理解为：只有函数，没有属性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594785782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212912,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/f0/695ca05f.jpg","nickname":"Ifdevil","note":"","ucode":"79DB0ADE9AD082","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262781,"discussion_content":"可以理解为不带业务标识，最好还没有线程安全的问题，谁都可以用而又不会改变它，类似单例，所以可以预缓存，拿来即用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589124774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023106,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/82/6073884b.jpg","nickname":"王巍","note":"","ucode":"F65F2E72C98D62","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288491,"discussion_content":"创建之后， 不再改变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593760069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161180,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1429627,"ip_address":"","ucode":"9DFFD6E3960CF7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","comment_is_top":false,"comment_ctime":1576138214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576138214","product_id":100039001,"comment_content":"课后第二个问题 。单一职责 在项目工程里也有指导思想。<br> 类有单一职责，一个模块也有单一职责。<br>基础的功能组件是一个模块，网络，下载，日志等等。 每个模块要保持功能单一。 <br>业务也可以拆分成模块。比如登录模块，订单模块，个人信息模块。 <br>业务组件之间可以相互调用，但是不能依赖。达到代码隔离，业务独立。<br>如果有业务层通用的模块，可以再抽一层通用业务层。被各个业务线依赖。<br> 功能组件可以直接被依赖，达到复用。<br>所以单一职责这个原则 贯穿了整个项目工程的设计和架构。小到一个类的设计，大到一个模块，一个组件的设计，甚至一个工程的设计。","like_count":0},{"had_liked":false,"id":161074,"user_name":"Mr.Strive.Z.H.L","can_delete":false,"product_type":"c1","uid":1030198,"ip_address":"","ucode":"6D97E159E2EECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/36/542c96bf.jpg","comment_is_top":false,"comment_ctime":1576114419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576114419","product_id":100039001,"comment_content":"个人认为最能够体会设计原则的深层含义的方法：<br>将所有代码都写到一个类中，然后再去重构这个类。<br><br>不管是单一原则还是其他原则，核心目的都是为了 高内聚低耦合，代码复用，可读性，可维护性。 设计原则是指导思想，但是上述的核心目的是互相牵制的，一旦过度遵循某个原则，可能导致 代码复用度非常高，但是可读性和可维护性下降。<br>所以，在理解设计原则的基础上，结合真实的业务需求，去设计最符合的当前场景的代码，然后随着需求迭代进行持续重构。<br>","like_count":0},{"had_liked":false,"id":160784,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1576032232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576032232","product_id":100039001,"comment_content":"任何一个软件模块都应该只对某一类行为者负责.","like_count":0},{"had_liked":false,"id":160743,"user_name":"晨间新闻","can_delete":false,"product_type":"c1","uid":1161406,"ip_address":"","ucode":"6F7A55AAD52F16","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/be/2d77d643.jpg","comment_is_top":false,"comment_ctime":1576027922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576027922","product_id":100039001,"comment_content":"老师，请教个问题，项目中，经常一个业务类里面包含了很多的业务逻辑，为了方法的简洁，也在这个业务类中写了很多只被该类调用的private类。<br>那么，想对这个业务类减负，有什么办法么？","like_count":0},{"had_liked":false,"id":160697,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1576023647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576023647","product_id":100039001,"comment_content":"1, 判定是否符合SRP，还可以从以下几点: <br>(1)对外提供的api接口是否功能单一，单个接口只完成一种功能;<br>(2)类中的某个方法代码数量是否太多，很难看懂方法整体逻辑。可以考虑拆分为多个子方法，方便日后代码维护，拓展等等;<br><br>2,单一原则是一种指导思想，让设计的功能简单，逻辑清晰，利于后期维护升级。这样的思想很宽泛，除了类，方法可借鉴。还可以指导项目模块的划分，多个独立的模块聚合成为完整的项目(例如 mapper model api  common等) 。往后需要拆分项目可以按模块拆分即可。<br>而微服务拆分为功能单一服务(例如用户SSO) 进而达到服务高可用，可维护，快速迭代的目的。","like_count":0},{"had_liked":false,"id":160577,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1575978737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575978737","product_id":100039001,"comment_content":"今天课堂讨论的话题有两个：<br>对于如何判断一个类是否职责单一，如何判断代码行数过多，你还有哪些其他的方法吗？<br>答： 如果两个类因为不同的目的引用了同一个给类时，那说明被引用的这个类职责不够单一，可以考虑拆解。<br>单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？<br>答：也可以适用于方法上面，当我们写UT 的时候，如果一个方法需要测试多个不同的功能实现，那么也应该考虑将该方法拆成多个方法","like_count":0},{"had_liked":false,"id":160423,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1575948248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575948248","product_id":100039001,"comment_content":"用户地址和用户信息可以分离，一下子让我顿悟了。之前就一直纠结到底是拆开还是合并。这个专栏让我脱离不规范，不确定，任意妄为的野路子开发。不过我觉得项目刚开始建立，定义的地址一定要明确。社交的地址应该是居住地或者家庭地址，和用户信息放一块。而收获地址是另一个模块，新增一张收获地址表。同时保留用户信息表中的家庭住址。","like_count":0},{"had_liked":false,"id":160279,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1575903944,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575903944","product_id":100039001,"comment_content":"问题1: 某个类是否会由于两个或多个不同的需求而需要改动，如果是，要么是这个类属于脚本类，本来就用于这个；要么就是这个类需要拆分了。<br><br>问题2: 单一职责原则还可以用于微服务架构的设计上，一个微服务就类似于一个类；这个原则还可以用于个人工作和团队管理，对于个人来说，在某段时间不要承担过多的责任。","like_count":0},{"had_liked":false,"id":160277,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575903834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575903834","product_id":100039001,"comment_content":"我的理解是。这个模块或者类 做了太多和本类无关的逻辑操作 就需要拆分了","like_count":0},{"had_liked":false,"id":160225,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1575894592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575894592","product_id":100039001,"comment_content":"总结：单一职责需要根据实际项目进行判断，类的设计是否满足单一职责，没有万能的方式，只有不断的积累，才能把握设计那个度","like_count":0},{"had_liked":false,"id":160191,"user_name":"xdargs","can_delete":false,"product_type":"c1","uid":1063740,"ip_address":"","ucode":"EB8326D3A72DE5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoH9Mlw0kLK0p39vhQpdvkbQP5TX96DB9HMJ1POaTVDpMZg4rjlO3WCAqiaWWMc77ffS3vTo8qWdXA/132","comment_is_top":false,"comment_ctime":1575888796,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575888796","product_id":100039001,"comment_content":"最近简单看过下systemd，很多的争议在违反了less is more的设计哲学，啥都想做导致问题不断和作为linux核心基础模块稳定性不足，这个跟单一原则有共性吧","like_count":0},{"had_liked":false,"id":160173,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1575885348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575885348","product_id":100039001,"comment_content":"课堂讨论Answer:<br><br>1. 对于如何判断一个类是否职责单一，如何判断代码行数过多，你还有哪些其他的方法吗？<br><br>我认为看一个类职责是否单一,类的依赖关系是一个比较重要的量化指标.其次,根据业务的大小不同, 代码行数也可以作为一个量化指标.比如仅涉及序列化的类,它的代码不超过100行是符合SRP的,反之就不符合。<br>再比如电商+社交项目的UserInfo类，它的代码行数不超过200行是没问题的，若超过了，最好拆分成多个更细粒度的类。这里的100， 200行仅是一个说明，其具体行数要根据业务的大小做出改变。<br>2. 单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？<br><br>在个人资产配置中,通常用于投资的钱,和用于消费的钱永远是泾渭分明的,这是单一职责原则的一种体现.","like_count":0},{"had_liked":false,"id":159840,"user_name":"塔兹米","can_delete":false,"product_type":"c1","uid":1425252,"ip_address":"","ucode":"1A58C81EF9B0A4","user_header":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","comment_is_top":false,"comment_ctime":1575808303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575808303","product_id":100039001,"comment_content":"打卡。<br>写的真好！","like_count":0},{"had_liked":false,"id":159815,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1575797047,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575797047","product_id":100039001,"comment_content":"1.现在就是一个方法行数是不是超过100行，如果超过，就要思考是否承担了比较多的职责，或者做了比较多的重复工作（各种对象之间的转换）<br>2.单一职责：小到一个方法，大到一个微服务的边界划定，以及生活工作中一个时刻专注一件事情都是相通的","like_count":0},{"had_liked":false,"id":159798,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1575792863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575792863","product_id":100039001,"comment_content":"原来我写的业务, 大部分都放在大而全的类里面了, 如何判断代码行数过多,更多的四凭借经验吧, 或者说是直觉, 如果写的代码看上去很凌乱, 自己都看不下去了, 那真的到了要优化的时候了, 但是往往自己写的代码很烂, 但是有懒得优化, 导致越来越烂","like_count":0},{"had_liked":false,"id":159706,"user_name":"　扬帆丶启航　","can_delete":false,"product_type":"c1","uid":1235282,"ip_address":"","ucode":"4079D0889CD86C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/52/73351eab.jpg","comment_is_top":false,"comment_ctime":1575732547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575732547","product_id":100039001,"comment_content":"方法写的很混乱，可能是代码行数过多引起的吧","like_count":0},{"had_liked":false,"id":159658,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1575720721,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575720721","product_id":100039001,"comment_content":"1. 看这个类内部定义的属性是否都有关联 <br>2. 可以应用到函数上","like_count":0},{"had_liked":false,"id":159606,"user_name":"操盘手爱德华","can_delete":false,"product_type":"c1","uid":1366402,"ip_address":"","ucode":"CAAF3E6DC9D5FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIFicK7Bn88Lqte7rURlw3Lf53oAu1jhiciaVlKLib48dlIAOAF03L7tjQcx1ia5AJI26S7HIxwx780Qzw/132","comment_is_top":false,"comment_ctime":1575703066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575703066","product_id":100039001,"comment_content":"除了单一职责本身之外，我觉得争哥还想说的是职责是随着项目的变化而发生变化的。职责的边界要根据当前项目的实际情况来看，并不能为了设计而设计，过渡设计不是设计。","like_count":0},{"had_liked":false,"id":159597,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1575701282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575701282","product_id":100039001,"comment_content":"单一职责原则<br>一个类或模块只负责一个职责或者功能<br>根据不同的业务场景设计类<br>凭感觉","like_count":0},{"had_liked":false,"id":159573,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1575690463,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575690463","product_id":100039001,"comment_content":"老师我想问一个问题： 在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。问题是：要拆分成更细的类，会导致一堆代码都得修改，这样做合理吗？","like_count":0,"discussions":[{"author":{"id":1716601,"avatar":"","nickname":"Geek_e9b8c4","note":"","ucode":"C29F7344A6EE6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290825,"discussion_content":"重构必然是要修改代码的，这个跑不了。但不进行重构，后续开发效率等都会受到影响，如果你接手过烂系统应该会更有体会，早改早超生！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594614450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159544,"user_name":"风行者","can_delete":false,"product_type":"c1","uid":1541934,"ip_address":"","ucode":"F058640CF77A35","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/2e/ea54c240.jpg","comment_is_top":false,"comment_ctime":1575678683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575678683","product_id":100039001,"comment_content":"打卡，solid常在心中，设计时形成思维习惯，单一职责原则，类<br>1.是否好取名字<br>2.在感觉功能单一的情况下不过度设计，后期随需求进行重构<br>3 类依赖如果太多，就要停下来想想是否可以拆分<br>4.类方法或行数过多考虑拆分<br>总结下：1好2少，好取名，少依赖，行数少<br>除了应用在类的设计上，还有接口，模块<br>","like_count":0},{"had_liked":false,"id":159526,"user_name":"Panmax","can_delete":false,"product_type":"c1","uid":1004871,"ip_address":"","ucode":"9D65E3B84C5519","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/47/d217c45f.jpg","comment_is_top":false,"comment_ctime":1575647722,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575647722","product_id":100039001,"comment_content":"请问前半句「类依赖的其他类过多」可以理解，后半句「或依赖类的其他类过多」是什么意思，能举个例子吗？","like_count":0,"discussions":[{"author":{"id":1406929,"avatar":"https://static001.geekbang.org/account/avatar/00/15/77/d1/a7a4bc63.jpg","nickname":"心雨Kanade","note":"","ucode":"F641E55F338A3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75833,"discussion_content":"应该是依赖和被依赖的过多的意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575785728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159524,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1575647001,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"1575647001","product_id":100039001,"comment_content":"类依赖的其他类过多，或者依赖类的其他类过多。<br>-------------<br>后半句是什么意思，什么叫“依赖类的其他类过多”，哪位同学帮忙说说。","like_count":0,"discussions":[{"author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74884,"discussion_content":"这句话是说：类A所依赖的其他类过多，或者依赖类A的其他类过多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575700984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1098286,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","nickname":"blacknhole","note":"","ucode":"271682FFE28F25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75204,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575726761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74884,"ip_address":""},"score":75204,"extra":""}]}]},{"had_liked":false,"id":159508,"user_name":"Y024","can_delete":false,"product_type":"c1","uid":1018056,"ip_address":"","ucode":"397126D2E17997","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/c8/ae476935.jpg","comment_is_top":false,"comment_ctime":1575641647,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1575641647","product_id":100039001,"comment_content":"Day032 15<br>SRP是所有原则中最简单的原则之一，也是最难正确运用的原则之一。一方面我们需要注意把多个职责进行分离；另一方面，如果应用程序的变化方式总是导致多个职责同时变化，那么就不必分离它们。","like_count":0},{"had_liked":false,"id":159468,"user_name":"大帅哥","can_delete":false,"product_type":"c1","uid":1333009,"ip_address":"","ucode":"4B5F9550663778","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUXWqIBiadT4BYND0k3XwORqkW8j4q0GLyaXylG5ibfNnQaAQ26PQIvd4bp9uFrlp9QhV4YXpVfdzg/132","comment_is_top":false,"comment_ctime":1575631023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575631023","product_id":100039001,"comment_content":"1、if else语句多，条件判断多了？<br>2、单一职责除了类设计，模块设计。还有函数、微服务以及系统设计","like_count":0},{"had_liked":false,"id":159452,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1575626609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575626609","product_id":100039001,"comment_content":"简单易懂,适合我这种小学生","like_count":0},{"had_liked":false,"id":159421,"user_name":"L","can_delete":false,"product_type":"c1","uid":1534988,"ip_address":"","ucode":"BBBA0AE1856DD7","user_header":"https://static001.geekbang.org/account/avatar/00/17/6c/0c/9693fba5.jpg","comment_is_top":false,"comment_ctime":1575620361,"is_pvip":false,"replies":[{"id":"61133","content":"使用设计模式跟spring mvc或者其他框架关系不大哈，还是聚焦于你的业务是否需要使用设计模式","user_name":"作者回复","comment_id":159421,"uid":"1190123","ip_address":"","utype":1,"ctime":1575896768,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1575620361","product_id":100039001,"comment_content":"你好，我想问下如何在spring mvc下使用设计模式，或者说在框架下如何使用设计模式","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477052,"discussion_content":"使用设计模式跟spring mvc或者其他框架关系不大哈，还是聚焦于你的业务是否需要使用设计模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1534988,"avatar":"https://static001.geekbang.org/account/avatar/00/17/6c/0c/9693fba5.jpg","nickname":"L","note":"","ucode":"BBBA0AE1856DD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77846,"discussion_content":"谢谢哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575946924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159367,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1575607151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575607151","product_id":100039001,"comment_content":"单一职责原则<br><br>What<br>一个类只负责完成一个职责或者功能。<br><br>How<br>不同的应用场景、需求背景、业务，对一个类职责是否单一，会有不同的判定结果。<br><br>总体上可以使用下面的方式进行“粗略”的判断：<br><br>- 类中的代码行数、函数或者属性过多；<br>- 类依赖的其他类过多，或者依赖类的其他类过多；<br>- 私有方法过多；<br>- 比较难给类起一个合适的名字（说明功能混杂）；<br>- 类中大量的方法都几种操作类中的几个属性。<br><br>Why<br>实现高内聚、低耦合、提高代码的复用性、可读性、可维护性。<br><br><br>单一职责原则如果滥用，效果会适得其反，本属于同一类的功能，被过度拆分，反而降低内聚性，可能增添频繁传递数据的负担。并且拆分过细，会导致过多的文件数量，增加整个工程的复杂度。<br>","like_count":0},{"had_liked":false,"id":159343,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1575602603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575602603","product_id":100039001,"comment_content":"1. 仅通过代码行数来判断是否是SRP，太武断；好的做法还是应该把功能放在实际的需求场景、业务场景、成本、紧急程度等众多因素中，去考量引起变化的因素是不是有多个，如果存在多个，就尽量做拆分，要做到：接口一定要SRP，实现类的设计尽量做到只有一个原因引起变化。这个度确实很难掌握，有可能会拆分过细，带来复杂性，增加心智负担<br>2. SPR 除了应用在类的设计上，还可以应用在方法的划分上，每个方法（函数）也尽量做到职责明确，这样有助于代码维护和可读性；此外，还可以应用在系统设计上，比如划分子系统，子系统划分模块，都尽量做到职责明确，最好一件事情，其实微服务也能算是一种 SRP 的实践。","like_count":0},{"had_liked":false,"id":159316,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1575598275,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575598275","product_id":100039001,"comment_content":"1. 想到一个: 这个类是不是能复用，如果可以，那方法和属性的覆盖率是不是很高？还是只用其中几个，就可以判断是否要继续拆分了<br>2. 函数的设计、组件划分、React 的 hook","like_count":0},{"had_liked":false,"id":159310,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1575597771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575597771","product_id":100039001,"comment_content":"可以通过代码是否有“坏”味道来知道类是不是设计的不好，不满足单一职责。品味很重要:)","like_count":0},{"had_liked":false,"id":159307,"user_name":"moqifei","can_delete":false,"product_type":"c1","uid":1358410,"ip_address":"","ucode":"E0A6C858B78A3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGovXf8jNP5ZqHsDKLwajjicbFwpX9on1xiaJDR4CgWaWP2KcfOdneasBfKFo3dO3dwQyGG6WjK40w/132","comment_is_top":false,"comment_ctime":1575597528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575597528","product_id":100039001,"comment_content":"单一职责原则，除了应用到类的设计上，还能延伸系统群设计上，多个子系统交互时，特别容易忽略这个原则。","like_count":0},{"had_liked":false,"id":159306,"user_name":"evolution","can_delete":false,"product_type":"c1","uid":1088402,"ip_address":"","ucode":"105C59822BF75B","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/92/c0863297.jpg","comment_is_top":false,"comment_ctime":1575597282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575597282","product_id":100039001,"comment_content":"记录一下个人粗浅的认知：<br>职责单一：其实就是对某个事物的增删改查。<br>例如上述用户信息例子，当有电商业务时，地址就需要分离出来，单独的对地址增删改查。<br>实战二中的接口鉴权，其实就是客户端token的产生（新增，AuthToken类），url的产生（新增，Url类），服务端token的产生（新增，CredentialStorage类），比对结果的产生（两个token比对，DefaultApiAuthencatorImpl类）","like_count":0},{"had_liked":false,"id":159293,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1575595984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575595984","product_id":100039001,"comment_content":"对于第一个问题，我认为只要定义合理的属性，就能看出这个类是否单一，因为类方法都是对属性的操作。第二个问题，作为一个前端，我们通过代码校验工具eslint强制所有的组件类最多300行代码，否则代码就无法提交，强制约束。","like_count":0},{"had_liked":false,"id":159288,"user_name":"liu_liu","can_delete":false,"product_type":"c1","uid":1019138,"ip_address":"","ucode":"24283806A07759","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","comment_is_top":false,"comment_ctime":1575595367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575595367","product_id":100039001,"comment_content":"1. 通过大致看类中的方法与属性，是否和本身提供的功能相关。<br>2. 还可以用于接口，方法","like_count":0},{"had_liked":false,"id":159278,"user_name":"峰峰","can_delete":false,"product_type":"c1","uid":1262507,"ip_address":"","ucode":"E2207B6E68F255","user_header":"https://static001.geekbang.org/account/avatar/00/13/43/ab/ec100d05.jpg","comment_is_top":false,"comment_ctime":1575594294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575594294","product_id":100039001,"comment_content":"除了在类上使用单一职责原则外，也可以应用在架构设计上。例如，数据库虽然支持像触发器或者存储过程用来处理业务数据，但是数据库最擅长的还是数据的存取；再者，队列的使用，redis虽然可以实现队列的效果，不过redis出色的功能还是缓存的使用，可以使用市面上比较流行的消息队列组件，其更有丰富的特性。因此，还是让专业的软件做专业的事比较好。","like_count":0},{"had_liked":false,"id":159273,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1575593918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575593918","product_id":100039001,"comment_content":"1.判断一个类是否职责单一,一般是根据方法定义，查看其实现的功能和该模块是否一致，如果疑惑，就是可能职责不单一情况。<br>2. 代码行数的话，一般就是读到头疼就不合适了。。<br>3. 单一职责还可以应用到微服务的拆分，和子模块的设计。。<br>提一个问题:<br>现在我有一个虚拟组织的抽象类，子类有班级组织和部门组织，虚拟组织提供了更新组织的功能，<br>外部只需要和虚拟组织类打交道，告诉它更新一个组织<br>(前端界面知道到底是传递部门组织信息还是班级组织信息，会封装更不同的对象)，虚拟组织内部通过传递的不同对象，判断是更新班级还是部门，调用对应的子类。<br>但是现在增加了一个功能，是更新班级的某个状态的时候，在班级内的所有人都要一起更新人的状态。<br>问题是：如果这个方法放到组织内，那么组织就同时操作了人的信息和组织的更新，不符合职责单一，如果放到虚拟组织外层，外层调用又需要理解组织内部的细节，去主动判断到底是更新组织还是班级，如果是班级就触发这一段逻辑。","like_count":0},{"had_liked":false,"id":159272,"user_name":"Xs.Ten","can_delete":false,"product_type":"c1","uid":1128376,"ip_address":"","ucode":"2368B9BDDDEE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/b8/c887a5ea.jpg","comment_is_top":false,"comment_ctime":1575593782,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575593782","product_id":100039001,"comment_content":"我的理解是：<br>        单一职责一般跟业务挂钩。比如设计一个查询个人信息的类，就不要引入查询订单的代码或者是跟个人信息不相关的代码等等。<br>        由此想到：这个跟设计通用的工具类还有一定的区别。设计通用的工具类也是可以满足单一职责：可以细分成屏幕相关的，设备相关的，权限相关的，等等。","like_count":0},{"had_liked":false,"id":159271,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1237655,"ip_address":"","ucode":"088A8DA0A16BDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","comment_is_top":false,"comment_ctime":1575593725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575593725","product_id":100039001,"comment_content":"打卡打卡","like_count":0},{"had_liked":false,"id":159265,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1575593236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575593236","product_id":100039001,"comment_content":"1. 各种设计原则和设计模式最终的目的是提高程序的可读性，可维护性、可扩展性、灵活性。个人理解，在某种业务场景下，如果一个类已经很难满足可维护性、可扩展性，那可能不符合单一职责原则了。对于如何判断代码行数过多是个主观的问题，有的人认为一个函数超过30行，就应该拆。有的人认为是80行。这没有一个具体的评判标准。<br>2. 单一职责原则除了用在类的设计上，个人觉得还有一些场景：如基于贫血模型的分层设计，Controller层只负责客户端与业务层的交互，Service层只负责业务处理，Repository层只负责与存储交互；如微服务场景中某个微服务只完成单一的业务或者非业务功能。","like_count":0},{"had_liked":false,"id":159258,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1575592703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575592703","product_id":100039001,"comment_content":"单一职责原则，除了能用在类设计上，还能用在函数设计上","like_count":0},{"had_liked":false,"id":159257,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1575592600,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1575592600","product_id":100039001,"comment_content":"1: 对于如何判断一个类是否职责单一，如何判断代码行数过多，你还有哪些其他的方法吗？<br>看一个类是不是满足SRP，简单点的能一眼看出来，复杂些的要结合上下文，类的使用场景去分析了，这个还真没法量化。对于代码行数的话，公认的是对于单函数的行数最好不要超过100行，如果超过就要考虑函数分拆了。<br><br>2: 单一职责原则，除了应用到类的设计上，还能延伸到哪些其他设计方面吗？<br>还可以用在函数，接口功能的设计上","like_count":0},{"had_liked":false,"id":159256,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1575592599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575592599","product_id":100039001,"comment_content":"其实现在很多web框架都在尽量拆分的特别细，<br>举例：用户注册需要发验证码或email，注册之前也许还要验证一些什么，这个时候框架会提供一些事件机制来满足。","like_count":0},{"had_liked":false,"id":159235,"user_name":"陈胜华","can_delete":false,"product_type":"c1","uid":1220185,"ip_address":"","ucode":"DCD7EED2E5544E","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/59/63710205.jpg","comment_is_top":false,"comment_ctime":1575590083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575590083","product_id":100039001,"comment_content":"经验很重要，放盐少许不是雏儿能吼得住的","like_count":0},{"had_liked":false,"id":159231,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1575589011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575589011","product_id":100039001,"comment_content":"处理业务逻辑的类与对应的处理数据库逻辑的类算不算是单一设计原则呢？避免代码行数过多，是不是可以看，是否其中包含了与类主体逻辑无关的数据库操作的代码，比如添加虽然可以用一个通用类，但是如果处理的方式不通用，是否可以单独创建一个对应此类的添加编辑删除等方式特殊类","like_count":0},{"had_liked":false,"id":159223,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575579538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575579538","product_id":100039001,"comment_content":"可以从类被用到的地方看类职责，如果一个类的公有属性或者方法被很多地方引用，这些引用相关性还不强，就有必要把这些属性或者方法拆分掉。例如文中的例子的地址和认证信息如果被用到了，他们彼此不同和用户其他属性也不同，这时就有必要拆分，如果没被用到，只作展示，在用户属性的概念下，他们和其他属性就没有不同，拆分的意义就小很多，不过为了让人读代码迅速一点，拆分出一个地址类也是可以的。<br>拆分会让类的职责单一，但是也可能破坏内聚性，还要增加一个类。聚合会让相互关联的概念内聚，但也可能弄出巨无霸的类，自身的函数无限耦合，外部依赖多如牛毛。总之，如何操作都有成本，只有收益大于成本才是值得的。现实世界无限复杂，总会出现拿捏不准的情况，这时，我一般倾向于拆分，因为小一点的类，总归好理解一点。","like_count":0}]}