{"id":548002,"title":"07｜手写CPU（二）：如何实现指令译码模块？","content":"<p>你好，我是LMOS。</p><p>上节课，我们了解了什么是CPU的流水线，并决定采用经典的五级流水线来设计我们的MiniCPU，之后梳理了我们将要设计的MiniCPU架构长什么样，最后完成了流水线的第一步——取指。</p><p>取指阶段把存储器里的指令读出以后，就会传递给后续的译码模块进行处理。那之后指令是如何译码的呢？这就要说到流水线的第二步——译码（代码从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation\">这里</a>下载）。</p><h2>指令是如何翻译的？</h2><p><a href=\"https://time.geekbang.org/column/article/546957\">第五节课</a>我们已经讲过了RISC-V指令架构，明确了我们的MiniCPU选用的是RV32I指令集。其中每条指令都是32位，且分为6种指令格式，不同格式的指令中包含了不一样的指令信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/c8/7b035797137a9e42cc1f6544d6d4dac8.jpg?wh=4005x2200\" alt=\"\"></p><p>如上图所示的6种指令格式，其中R型指令包含了操作码opcode、目标寄存器索引rd、功能码funct3和funct7以及源寄存器索引rs1和rs2。而I型指令则是包含操作码opcode、目标寄存器索引rd、功能码funct3、源寄存器索引rs1以及立即数imm。</p><p>与此类似，后面的S型指令、B型指令、U型指令和J型指令也有特定的操作码、功能码、源寄存器索引、目标寄存器索引和立即数。</p><p>不过指令格式不同，指令译码模块翻译指令的工作机制却是统一的。首先译码电路会翻译出指令中携带的寄存器索引、立即数大小等执行信息。接着，在解决数据可能存在的数据冒险（这个概念后面第九节课会讲）之后，由译码数据通路负责把译码后的指令信息，发送给对应的执行单元去执行。</p><!-- [[[read_end]]] --><h2>译码模块的设计</h2><p>通过上面的分析，你是否对译码模块的设计已经有了头绪？是的，译码模块就是拆解从取指模块传过来的每一条指令。译码时，需要识别出指令的操作码，并根据对应的指令格式提取出指令中包含的信息。</p><p>译码模块具体的Verilog设计代码如下：</p><pre><code class=\"language-verilog\">module decode (\n  input  [31:0] instr,\t\t\t//指令源码\n\n  output  [4:0] rs1_addr,\t\t//源寄存器rs1索引\n  output  [4:0] rs2_addr,\t\t//源寄存器rs2索引\n  output  [4:0] rd_addr,\t\t//目标寄存器rd索引\n  output  [2:0] funct3,\t\t\t//功能码funct3\n  output  [6:0] funct7,\t\t\t//功能码funct7\n  output        branch,\n  output [1:0]  jump,\n  output        mem_read,\n  output        mem_write,\n  output        reg_write,\n  output        to_reg,\n  output [1:0]  result_sel,\n  output        alu_src,\n  output        pc_add,\n  output [6:0]  types,\n  output [1:0]  alu_ctrlop,\n  output        valid_inst,\n  output [31:0] imm\n);\n\nlocalparam DEC_INVALID = 21'b0;\n\nreg [20:0] dec_array;\n\n//---------- decode rs1、rs2 -----------------\nassign rs1_addr = instr[19:15]; \nassign rs2_addr = instr[24:20];\n\n//---------- decode rd -----------------------\nassign rd_addr = instr[11:7]; \n\n//---------- decode funct3、funct7 -----------\nassign funct7 = instr[31:25]; \nassign funct3 = instr[14:12]; \n\n// ----------------------------- decode signals ---------------------------------\n\n//                        20     19-18  17       16        15        14     13-12      11      10     9--------3  2---1      0\n//                        branch jump   memRead  memWrite  regWrite  toReg  resultSel  aluSrc  pcAdd     RISBUJZ  aluctrlop  validInst\nlocalparam DEC_LUI     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b01,     1'b0,   1'b0,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_AUIPC   = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b1,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_JAL     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b0,   1'b0,  7'b0000010, 2'b00,     1'b1};\nlocalparam DEC_JALR    = {1'b0,  2'b11, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_BRANCH  = {1'b1,  2'b00, 1'b0,    1'b0,     1'b0,     1'b0,  2'b00,     1'b0,   1'b0,  7'b0001000, 2'b10,     1'b1};\nlocalparam DEC_LOAD    = {1'b0,  2'b00, 1'b1,    1'b0,     1'b1,     1'b1,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_STORE   = {1'b0,  2'b00, 1'b0,    1'b1,     1'b0,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0010000, 2'b00,     1'b1};\nlocalparam DEC_ALUI    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b01,     1'b1};\nlocalparam DEC_ALUR    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b0,   1'b0,  7'b1000000, 2'b01,     1'b1};\n\nassign  {branch, jump, mem_read, mem_write, reg_write, to_reg, result_sel, alu_src, pc_add, types, alu_ctrlop, valid_inst} = dec_array;\n\nalways @(*) begin\n  case(instr[6:0])\n    `OPCODE_LUI    :   dec_array &lt;= DEC_LUI;   \n    `OPCODE_AUIPC  :   dec_array &lt;= DEC_AUIPC; \n    `OPCODE_JAL    :   dec_array &lt;= DEC_JAL; \n    `OPCODE_JALR   :   dec_array &lt;= DEC_JALR;   \n    `OPCODE_BRANCH :   dec_array &lt;= DEC_BRANCH; \n    `OPCODE_LOAD   :   dec_array &lt;= DEC_LOAD;   \n    `OPCODE_STORE  :   dec_array &lt;= DEC_STORE;  \n    `OPCODE_ALUI   :   dec_array &lt;= DEC_ALUI;  \n    `OPCODE_ALUR   :   dec_array &lt;= DEC_ALUR;  \n    default        :  begin\n                 dec_array &lt;= DEC_INVALID;\n    end\n  endcase\nend\n\n// -------------------- IMM -------------------------\n\nwire [31:0] Iimm = {{21{instr[31]}}, instr[30:20]};\nwire [31:0] Simm = {{21{instr[31]}}, instr[30:25], instr[11:7]};\nwire [31:0] Bimm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\nwire [31:0] Uimm = {instr[31:12], 12'b0};\nwire [31:0] Jimm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};   \n\nassign imm = {32{types[5]}} &amp; Iimm\n           | {32{types[4]}} &amp; Simm\n           | {32{types[3]}} &amp; Bimm\n           | {32{types[2]}} &amp; Uimm\n           | {32{types[1]}} &amp; Jimm;\n\nendmodule\n</code></pre><p>这段代码看起来很长，其实整个代码可以分为三个部分：第28行到37行负责完成指令的源寄存器、目标寄存器、3位操作码和7位操作码的译码，第40行至73行负责完成指令格式类型的识别，第75行至87行负责完成立即数译码。</p><p>首先，我们来看指令中源寄存器、目标寄存器、3位操作码和7位操作码的译码。仔细观察上面提到的6种指令格式，我们可以发现一定的规律：全部的目标寄存器索引 <strong>rd</strong> 都位于指令的第7～11位，源寄存器索引 <strong>rs1</strong> 位于指令的第15～19位，源寄存器索引 <strong>rs2</strong> 位于指令的第20～24位，三位的操作码 <strong>funct3</strong> 位于指令的第12～14位，七位的操作码 <strong>funct7</strong> 位于指令的第25～31位。</p><p>它们的位置分布如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/7a/c1d593a99ac6b08e50yy0c45a930857a.jpg?wh=1920x310\" alt=\"图片\"></p><p>上述这些信号在不同指令格式中的位置比较固定。因此我们就可以根据这些位置特点，直接从指令中截取，从而得到它们相应的信息，具体实现的Verilog代码如下（对应整体代码的27～37行）：</p><pre><code class=\"language-verilog\">//---------- decode rs1、rs2 -----------------\nassign rs1_addr = instr[19:15]; \nassign rs2_addr = instr[24:20];\n\n//---------- decode rd -----------------------\nassign rd_addr = instr[11:7]; \n\n//---------- decode funct3、funct7 -----------\nassign funct7 = instr[31:25]; \nassign funct3 = instr[14:12]; \n</code></pre><p>在所有的指令格式中，还有一段最为特殊的信息码。这段信息码是每条指令都有的，且位置和位宽保持不变。没错，它就是指令的操作码opcode。</p><p>对照RISC-V的官方手册，我为你整理出了RV32I指令集的操作码对照表，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/23/2ea867d9beff30ca1b60fa9e8003ec23.jpg?wh=1920x1286\" alt=\"图片\"></p><p>我们再来回顾一下RISC-V的指令格式，这次我们重点观察指令操作码的位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/c8/7b035797137a9e42cc1f6544d6d4dac8.jpg?wh=4005x2200\" alt=\"\"></p><p>不难发现，所有指令操作码都位于指令的第0～6位。根据这7位的操作码就可以判断出一条指令是什么类型，它对应的是什么指令格式。进而可以产生指令执行信号，为后续的指令执行单元的操作提供依据。</p><p>以下就是指令操作码的译码和产生相关指令控制信号的Verilog代码（对应整体代码的39～72行）：</p><pre><code class=\"language-verilog\">// ----------------------------- decode signals ---------------------------------\n\n//                        20     19-18  17       16        15        14     13-12      11      10     9--------3  2---1      0\n//                        branch jump   memRead  memWrite  regWrite  toReg  resultSel  aluSrc  pcAdd     RISBUJZ  aluctrlop  validInst\nlocalparam DEC_LUI     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b01,     1'b0,   1'b0,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_AUIPC   = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b1,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_JAL     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b0,   1'b0,  7'b0000010, 2'b00,     1'b1};\nlocalparam DEC_JALR    = {1'b0,  2'b11, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_BRANCH  = {1'b1,  2'b00, 1'b0,    1'b0,     1'b0,     1'b0,  2'b00,     1'b0,   1'b0,  7'b0001000, 2'b10,     1'b1};\nlocalparam DEC_LOAD    = {1'b0,  2'b00, 1'b1,    1'b0,     1'b1,     1'b1,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_STORE   = {1'b0,  2'b00, 1'b0,    1'b1,     1'b0,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0010000, 2'b00,     1'b1};\nlocalparam DEC_ALUI    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b01,     1'b1};\nlocalparam DEC_ALUR    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b0,   1'b0,  7'b1000000, 2'b01,     1'b1};\n\nassign  {branch, jump, mem_read, mem_write, reg_write, to_reg, result_sel, alu_src, pc_add, types, alu_ctrlop, valid_inst} = dec_array;\n\nalways @(*) begin\n  case(instr[6:0])\n    `OPCODE_LUI    :   dec_array &lt;= DEC_LUI;   \n    `OPCODE_AUIPC  :   dec_array &lt;= DEC_AUIPC; \n    `OPCODE_JAL    :   dec_array &lt;= DEC_JAL; \n    `OPCODE_JALR   :   dec_array &lt;= DEC_JALR;   \n    `OPCODE_BRANCH :   dec_array &lt;= DEC_BRANCH; \n    `OPCODE_LOAD   :   dec_array &lt;= DEC_LOAD;   \n    `OPCODE_STORE  :   dec_array &lt;= DEC_STORE;  \n    `OPCODE_ALUI   :   dec_array &lt;= DEC_ALUI;  \n    `OPCODE_ALUR   :   dec_array &lt;= DEC_ALUR;  \n    default        :  begin\n                 dec_array &lt;= DEC_INVALID;\n    end\n  endcase\nend\n</code></pre><p>从上面的代码我们可以看到，译码的过程就是先识别指令的低7位操作码instr[6:0]，根据操作码对应的代码标识，产生分支信号branch、跳转信号jump、读存储器信号mem_read……这些译码之后的指令控制信息。然后，把译码得到的信息交到CPU流水线的下一级去执行。</p><p>此外，还有指令中的立即数需要提取。观察上述的6种指令格式你会发现，除了R型指令不包含立即数，其他5种指令类型都包含了立即数。</p><p>前面我已经讲过了怎么去识别指令的类型。那指令里的立即数怎么提取呢？其实这跟提取指令的索引、功能码差不多。</p><p>我们根据不同指令类型中立即数的分布位置，就能直接提取指令的立即数。最后也是根据指令的类型选择性输出I型、S型、B型、U型或者J型指令的立即数即可，具体的代码如下：</p><pre><code class=\"language-verilog\">// -------------------- IMM -------------------------\n\nwire [31:0] Iimm = {{21{instr[31]}}, instr[30:20]};\nwire [31:0] Simm = {{21{instr[31]}}, instr[30:25], instr[11:7]};\nwire [31:0] Bimm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\nwire [31:0] Uimm = {instr[31:12], 12'b0};\nwire [31:0] Jimm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};   \n\nassign imm = {32{types[5]}} &amp; Iimm\n           | {32{types[4]}} &amp; Simm\n           | {32{types[3]}} &amp; Bimm\n           | {32{types[2]}} &amp; Uimm\n           | {32{types[1]}} &amp; Jimm;\n</code></pre><h2>译码控制模块设计</h2><p>前面的译码模块得到的指令信号，可以分为两大类。一类是由指令的操作码经过译码后产生的<strong>指令执行控制信号</strong>，如跳转操作jump信号、存储器读取mem_read信号等；另一类是从指令源码中提取出来的<strong>数据信息</strong>，如立即数、寄存器索引、功能码等。</p><p>为了能对流水线更好地实施控制，这里我们需要把译码后的数据和控制信号分开处理。首先来看译码控制模块的实现：</p><pre><code class=\"language-verilog\">module id_ex_ctrl(\n  input        clk,\n  input        reset,\n  input        in_ex_ctrl_itype,\n  input  [1:0] in_ex_ctrl_alu_ctrlop,\n  input  [1:0] in_ex_ctrl_result_sel,\n  input        in_ex_ctrl_alu_src,\n  input        in_ex_ctrl_pc_add,\n  input        in_ex_ctrl_branch,\n  input  [1:0] in_ex_ctrl_jump,\n  input        in_mem_ctrl_mem_read,\n  input        in_mem_ctrl_mem_write,\n  input  [1:0] in_mem_ctrl_mask_mode,\n  input        in_mem_ctrl_sext,\n  input        in_wb_ctrl_to_reg,\n  input        in_wb_ctrl_reg_write,\n  input        in_noflush,\n  input        flush,\n  input        valid,\n  output       out_ex_ctrl_itype,\n  output [1:0] out_ex_ctrl_alu_ctrlop,\n  output [1:0] out_ex_ctrl_result_sel,\n  output       out_ex_ctrl_alu_src,\n  output       out_ex_ctrl_pc_add,\n  output       out_ex_ctrl_branch,\n  output [1:0] out_ex_ctrl_jump,\n  output       out_mem_ctrl_mem_read,\n  output       out_mem_ctrl_mem_write,\n  output [1:0] out_mem_ctrl_mask_mode,\n  output       out_mem_ctrl_sext,\n  output       out_wb_ctrl_to_reg,\n  output       out_wb_ctrl_reg_write,\n  output       out_noflush\n);\n\n  reg  reg_ex_ctrl_itype; \n  reg [1:0] reg_ex_ctrl_alu_ctrlop; \n  reg [1:0] reg_ex_ctrl_result_sel; \n  reg  reg_ex_ctrl_alu_src; \n  reg  reg_ex_ctrl_pc_add; \n  reg  reg_ex_ctrl_branch; \n  reg [1:0] reg_ex_ctrl_jump; \n  reg  reg_mem_ctrl_mem_read; \n  reg  reg_mem_ctrl_mem_write; \n  reg [1:0] reg_mem_ctrl_mask_mode; \n  reg  reg_mem_ctrl_sext; \n  reg  reg_wb_ctrl_to_reg; \n  reg  reg_wb_ctrl_reg_write; \n  reg  reg_noflush; \n\n  ………………    //由于这里的代码较长，结构相似，这里省略了一部分\n  \n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_noflush &lt;= 1'h0; \n    end else if (flush) begin \n      reg_noflush &lt;= 1'h0; \n    end else if (valid) begin \n      reg_noflush &lt;= in_noflush; \n    end\n  end\nendmodule\n</code></pre><p>上面就是译码控制模块的Verilog设计代码。</p><p>上一节课学习取指模块的时候我们说过，并不是所有从存储器中读取出来的指令，都能够给到执行单元去执行的。比如，当指令发生冲突时，需要对流水线进行冲刷，这时就需要清除流水线中的指令。同样的，译码阶段的指令信号也需要清除。</p><p>译码控制模块就是为了实现这一功能，当指令清除信号flush有效时，把译码模块产生的jump、branch、mem_read、mem_write、reg_write……这些控制信号全部清“0”。否则，就把这些控制信号发送给流水线的下一级进行处理。</p><h2>译码数据通路模块设计</h2><p>和译码模块类似，译码数据通路模块会根据CPU相关控制模块产生的流水线冲刷控制信号，决定要不要把这些数据发送给后续模块。</p><p>其中，译码得到的数据信息包括立即数imm、源寄存器索引rs1和rs2、目标寄存器索引rd以及功能码funct3和funct7。具体的设计代码如下所示：</p><pre><code class=\"language-verilog\">module id_ex(\n  input         clk,\n  input         reset,\n  input  [4:0]  in_rd_addr,\n  input  [6:0]  in_funct7,\n  input  [2:0]  in_funct3,\n  input  [31:0] in_imm,\n  input  [31:0] in_rs2_data,\n  input  [31:0] in_rs1_data,\n  input  [31:0] in_pc,\n  input  [4:0]  in_rs1_addr,\n  input  [4:0]  in_rs2_addr,\n  input         flush,\n  input         valid,\n  output [4:0]  out_rd_addr,\n  output [6:0]  out_funct7,\n  output [2:0]  out_funct3,\n  output [31:0] out_imm,\n  output [31:0] out_rs2_data,\n  output [31:0] out_rs1_data,\n  output [31:0] out_pc,\n  output [4:0]  out_rs1_addr,\n  output [4:0]  out_rs2_addr\n);\n  reg [4:0] reg_rd_addr; \n  reg [6:0] reg_funct7; \n  reg [2:0] reg_funct3; \n  reg [31:0] reg_imm; \n  reg [31:0] reg_rs2_data; \n  reg [31:0] reg_rs1_data; \n  reg [31:0] reg_pc; \n  reg [4:0] reg_rs1_addr; \n  reg [4:0] reg_rs2_addr; \n\n  …………  //由于代码较长，结构相似，这里省略了一部分，完整代码你可以从Gitee上获取\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_rs2_addr &lt;= 5'h0; \n    end else if (flush) begin \n      reg_rs2_addr &lt;= 5'h0; \n    end else if (valid) begin \n      reg_rs2_addr &lt;= in_rs2_addr; \n    end\n  end\n\nendmodule\n</code></pre><p>我们以目标寄存器的索引地址reg_rd_addr信号为例，分析一下它是怎么流通的。当流水线冲刷信号flush有效时，目标寄存器的索引地址reg_rd_addr直接清“0”，否则当信号有效标志valid为“1”时，把目标寄存器的索引地址传递给流水线的下一级。</p><pre><code class=\"language-verilog\">  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_rd_addr &lt;= 5'h0; \n    end else if (flush) begin \n      reg_rd_addr &lt;= 5'h0; \n    end else if (valid) begin \n      reg_rd_addr &lt;= in_rd_addr; \n    end\n  end\n</code></pre><p>类似地，当流水线冲刷信号flush有效时，把译码模块得到的源操作数1、源操作数2、立即数、目标寄存器地址……等等这些数据全部清“0”。否则，就把这些数据发送给流水线的下一级进行处理。</p><h2>重点回顾</h2><p>指令译码是CPU流水线中比较重要的一步，在译码阶段一定不能出错，否则流水线后续的执行就全都乱了。今天我们设计出了指令译码的相关模块，我带你回顾一下这节课的要点。</p><p>首先，我们针对RV32I指令集的6种指令格式，分析了它们各自包含了哪些指令信号。根据这些信息的位置不同，指令译码模块就可以从不同类型的指令格式中，把每条指令包含的信息提取出来。</p><p>之后，根据上面分析的译码思路，我们就可以设计译码模块了。经过观察，<strong>我们发现指令中的操作码、目标寄存器索引、源寄存器索引和功能码，在不同指令格式中的位置比较固定，所以这些信息可以直接从指令中截取得到。</strong></p><p>由于指令的操作码有特殊的指令标识作用，我们可以根据操作码产生指令控制信息，给到CPU流水线的下一级去执行。此外，还可以根据不同指令类型中立即数的分布位置特点，通过截取得到指令的立即数。</p><p>译码得到的指令信号分为两大类：一类是由指令的操作码经过译码后产生的<strong>指令执行控制信号</strong>，另一类是从指令源码中提取出来的<strong>数据信息</strong>。为了让译码后的信息，能更好地分发给流水线后续模块去执行，这里我们把译码后的数据和控制信号分开处理，分别设计了数据通路模块和译码控制模块。</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/6c/c9a820a96faa70f18a77155be538506c.jpg?wh=1920x1324\" alt=\"图片\"></p><h2>思考题</h2><p>在6种指令格式中，S型、J型和B型指令里的立即数是不连续的，这是为什么？</p><p>欢迎你在留言区跟我交流互动，也推荐你把这节课分享给更多朋友，组团一起来跟我折腾CPU!</p>","neighbors":{"left":{"article_title":"06｜手写CPU（一）：迷你CPU架构设计与取指令实现","id":547921},"right":{"article_title":"08｜手写CPU（三）：如何实现指令执行模块？","id":550393}},"comments":[]}