{"id":76207,"title":"43 | 拓扑排序：如何确定代码源文件的编译依赖关系？","content":"<p>从今天开始，我们就进入了专栏的高级篇。相对基础篇，高级篇涉及的知识点，都比较零散，不是太系统。所以，我会围绕一个实际软件开发的问题，在阐述具体解决方法的过程中，将涉及的知识点给你详细讲解出来。</p><p>所以，相较于基础篇“<strong>开篇问题-知识讲解-回答开篇-总结-课后思考</strong>”这样的文章结构，高级篇我稍作了些改变，大致分为这样几个部分：“<strong>问题阐述-算法解析-总结引申-课后思考</strong>”。</p><p>好了，现在，我们就进入高级篇的第一节，如何确定代码源文件的编译依赖关系？</p><p>我们知道，一个完整的项目往往会包含很多代码源文件。编译器在编译整个项目的时候，需要按照依赖关系，依次编译每个源文件。比如，A.cpp依赖B.cpp，那在编译的时候，编译器需要先编译B.cpp，才能编译A.cpp。</p><p>编译器通过分析源文件或者程序员事先写好的编译配置文件（比如Makefile文件），来获取这种局部的依赖关系。<strong><span class=\"orange\">那编译器又该如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？</span></strong></p><p><img src=\"https://static001.geekbang.org/resource/image/52/3b/5247b6639e98419a1963cecd8f12713b.jpg?wh=1142*413\" alt=\"\"></p><h2>算法解析</h2><p>这个问题的解决思路与“图”这种数据结构的一个经典算法“拓扑排序算法”有关。那什么是拓扑排序呢？这个概念很好理解，我们先来看一个生活中的拓扑排序的例子。</p><p>我们在穿衣服的时候都有一定的顺序，我们可以把这种顺序想成，衣服与衣服之间有一定的依赖关系。比如说，你必须先穿袜子才能穿鞋，先穿内裤才能穿秋裤。假设我们现在有八件衣服要穿，它们之间的两两依赖关系我们已经很清楚了，那如何安排一个穿衣序列，能够满足所有的两两之间的依赖关系？</p><!-- [[[read_end]]] --><p>这就是个拓扑排序问题。从这个例子中，你应该能想到，在很多时候，拓扑排序的序列并不是唯一的。你可以看我画的这幅图，我找到了好几种满足这些局部先后关系的穿衣序列。</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/bd/c26d0f472d9a607c0c4eb688c01959bd.jpg?wh=1142*642\" alt=\"\"></p><p>弄懂了这个生活中的例子，开篇的关于编译顺序的问题，你应该也有思路了。开篇问题跟这个问题的模型是一样的，也可以抽象成一个拓扑排序问题。</p><p>拓扑排序的原理非常简单，我们的重点应该放到拓扑排序的实现上面。</p><p>我前面多次讲过，算法是构建在具体的数据结构之上的。针对这个问题，我们先来看下，如何将问题背景抽象成具体的数据结构？</p><p>我们可以把源文件与源文件之间的依赖关系，抽象成一个有向图。每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边。</p><p>如果a先于b执行，也就是说b依赖于a，那么就在顶点a和顶点b之间，构建一条从a指向b的边。而且，这个图不仅要是有向图，还要是一个有向无环图，也就是不能存在像a-&gt;b-&gt;c-&gt;a这样的循环依赖关系。因为图中一旦出现环，拓扑排序就无法工作了。实际上，拓扑排序本身就是基于有向无环图的一个算法。</p><pre><code>public class Graph {\n  private int v; // 顶点的个数\n  private LinkedList&lt;Integer&gt; adj[]; // 邻接表\n\n  public Graph(int v) {\n    this.v = v;\n    adj = new LinkedList[v];\n    for (int i=0; i&lt;v; ++i) {\n      adj[i] = new LinkedList&lt;&gt;();\n    }\n  }\n\n  public void addEdge(int s, int t) { // s先于t，边s-&gt;t\n    adj[s].add(t);\n  }\n}\n</code></pre><p>数据结构定义好了，现在，我们来看，<strong>如何在这个有向无环图上，实现拓扑排序</strong>？</p><p>拓扑排序有两种实现方法，都不难理解。它们分别是<strong>Kahn算法</strong>和<strong>DFS深度优先搜索算法</strong>。我们依次来看下它们都是怎么工作的。</p><h3>1.Kahn算法</h3><p>Kahn算法实际上用的是贪心算法思想，思路非常简单、好懂。</p><p>定义数据结构的时候，如果s需要先于t执行，那就添加一条s指向t的边。所以，如果某个顶点入度为0， 也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。</p><p>我们先从图中，找出一个入度为0的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来），并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减1）。我们循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。</p><p>我把Kahn算法用代码实现了一下，你可以结合着文字描述一块看下。不过，你应该能发现，这段代码实现更有技巧一些，并没有真正删除顶点的操作。代码中有详细的注释，你自己来看，我就不多解释了。</p><pre><code>public void topoSortByKahn() {\n  int[] inDegree = new int[v]; // 统计每个顶点的入度\n  for (int i = 0; i &lt; v; ++i) {\n    for (int j = 0; j &lt; adj[i].size(); ++j) {\n      int w = adj[i].get(j); // i-&gt;w\n      inDegree[w]++;\n    }\n  }\n  LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n  for (int i = 0; i &lt; v; ++i) {\n    if (inDegree[i] == 0) queue.add(i);\n  }\n  while (!queue.isEmpty()) {\n    int i = queue.remove();\n    System.out.print(&quot;-&gt;&quot; + i);\n    for (int j = 0; j &lt; adj[i].size(); ++j) {\n      int k = adj[i].get(j);\n      inDegree[k]--;\n      if (inDegree[k] == 0) queue.add(k);\n    }\n  }\n}\n</code></pre><h3>2.DFS算法</h3><p>图上的深度优先搜索我们前面已经讲过了，实际上，拓扑排序也可以用深度优先搜索来实现。不过这里的名字要稍微改下，更加确切的说法应该是深度优先遍历，遍历图中的所有顶点，而非只是搜索一个顶点到另一个顶点的路径。</p><p>关于这个算法的实现原理，我先把代码贴在下面，下面给你具体解释。</p><pre><code>public void topoSortByDFS() {\n  // 先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s\n  LinkedList&lt;Integer&gt; inverseAdj[] = new LinkedList[v];\n  for (int i = 0; i &lt; v; ++i) { // 申请空间\n    inverseAdj[i] = new LinkedList&lt;&gt;();\n  }\n  for (int i = 0; i &lt; v; ++i) { // 通过邻接表生成逆邻接表\n    for (int j = 0; j &lt; adj[i].size(); ++j) {\n      int w = adj[i].get(j); // i-&gt;w\n      inverseAdj[w].add(i); // w-&gt;i\n    }\n  }\n  boolean[] visited = new boolean[v];\n  for (int i = 0; i &lt; v; ++i) { // 深度优先遍历图\n    if (visited[i] == false) {\n      visited[i] = true;\n      dfs(i, inverseAdj, visited);\n    }\n  }\n}\n\nprivate void dfs(\n    int vertex, LinkedList&lt;Integer&gt; inverseAdj[], boolean[] visited) {\n  for (int i = 0; i &lt; inverseAdj[vertex].size(); ++i) {\n    int w = inverseAdj[vertex].get(i);\n    if (visited[w] == true) continue;\n    visited[w] = true;\n    dfs(w, inverseAdj, visited);\n  } // 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己\n  System.out.print(&quot;-&gt;&quot; + vertex);\n}\n</code></pre><p>这个算法包含两个关键部分。</p><p>第一部分是<strong>通过邻接表构造逆邻接表</strong>。邻接表中，边s-&gt;t表示s先于t执行，也就是t要依赖s。在逆邻接表中，边s-&gt;t表示s依赖于t，s后于t执行。为什么这么转化呢？这个跟我们这个算法的实现思想有关。</p><p>第二部分是这个算法的核心，也就是<strong>递归处理每个顶点</strong>。对于顶点vertex来说，我们先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己。</p><p>到这里，用Kahn算法和DFS算法求拓扑排序的原理和代码实现都讲完了。我们来看下，<strong>这两个算法的时间复杂度分别是多少呢？</strong></p><p>从Kahn代码中可以看出来，每个顶点被访问了一次，每个边也都被访问了一次，所以，Kahn算法的时间复杂度就是O(V+E)（V表示顶点个数，E表示边的个数）。</p><p>DFS算法的时间复杂度我们之前分析过。每个顶点被访问两次，每条边都被访问一次，所以时间复杂度也是O(V+E)。</p><p>注意，这里的图可能不是连通的，有可能是有好几个不连通的子图构成，所以，E并不一定大于V，两者的大小关系不确定。所以，在表示时间复杂度的时候，V、E都要考虑在内。</p><h2>总结引申</h2><p>在基础篇中，关于“图”，我们讲了图的定义和存储、图的广度和深度优先搜索。今天，我们又讲了一个关于图的算法，拓扑排序。</p><p>拓扑排序应用非常广泛，解决的问题的模型也非常一致。凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。除此之外，拓扑排序还能检测图中环的存在。对于Kahn算法来说，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是0的顶点，那就说明，图中存在环。</p><p>关于图中环的检测，我们在<a href=\"https://time.geekbang.org/column/article/41440\">递归</a>那一节讲过一个例子，在查找最终推荐人的时候，可能会因为脏数据，造成存在循环推荐，比如，用户A推荐了用户B，用户B推荐了用户C，用户C又推荐了用户A。如何避免这种脏数据导致的无限递归？这个问题，我当时留给你思考了，现在是时候解答了。</p><p>实际上，这就是环的检测问题。因为我们每次都只是查找一个用户的最终推荐人，所以，我们并不需要动用复杂的拓扑排序算法，而只需要记录已经访问过的用户ID，当用户ID第二次被访问的时候，就说明存在环，也就说明存在脏数据。</p><pre><code>HashSet&lt;Integer&gt; hashTable = new HashSet&lt;&gt;(); // 保存已经访问过的actorId\nlong findRootReferrerId(long actorId) {\n  if (hashTable.contains(actorId)) { // 存在环\n    return;\n  }\n  hashTable.add(actorId);\n  Long referrerId = \n       select referrer_id from [table] where actor_id = actorId;\n  if (referrerId == null) return actorId;\n  return findRootReferrerId(referrerId);\n}\n</code></pre><p>如果把这个问题改一下，我们想要知道，数据库中的所有用户之间的推荐关系了，有没有存在环的情况。这个问题，就需要用到拓扑排序算法了。我们把用户之间的推荐关系，从数据库中加载到内存中，然后构建成今天讲的这种有向图数据结构，再利用拓扑排序，就可以快速检测出是否存在环了。</p><h2>课后思考</h2><ol>\n<li>\n<p>在今天的讲解中，我们用图表示依赖关系的时候，如果a先于b执行，我们就画一条从a到b的有向边；反过来，如果a先于b，我们画一条从b到a的有向边，表示b依赖a，那今天讲的Kahn算法和DFS算法还能否正确工作呢？如果不能，应该如何改造一下呢？</p>\n</li>\n<li>\n<p>我们今天讲了两种拓扑排序算法的实现思路，Kahn算法和DFS深度优先搜索算法，如果换做BFS广度优先搜索算法，还可以实现吗？</p>\n</li>\n</ol><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","comments":[{"had_liked":false,"id":56800,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1546562762,"is_pvip":false,"replies":[{"id":"20463","content":"这个有意思，我们想想。","user_name":"编辑回复","comment_id":56800,"uid":"1000473","ip_address":"","utype":2,"ctime":1546563083,"user_name_real":"郭蕾"}],"discussion_count":9,"race_medal":0,"score":"662971526346","product_id":100017301,"comment_content":"老师，这门专栏快结束了，突然有点新的想法：如果老师在讲解算法的时候，多讲点算法的由来，也就是背景，那就更好了。<br><br>我想，如果能知道某个算法的创造者为什么会发明某个算法，怎么能够发明出某个算法，我想我们会掌握得更牢，学得应该也稍微轻松一点，关键是能跟随发明者回到原点，体会思考的过程<br><br>","like_count":155,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87280,"discussion_content":"是啊，比如 这个 Kahn 卡恩算法。。发明者是 卡恩 吧","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576658537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435241,"discussion_content":"这个有意思，我们想想。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1546563083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2273754,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/da/5602cb4b.jpg","nickname":"king","note":"","ucode":"1E5BD0E2A789C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337892,"discussion_content":"基于问题的研究 ，很大程度是因为在某个场景中遇到了某个问题，而这些问题的结局依赖于具体算法，人们把它解决出来了。然后共有的经验组成了常见的算法。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1609119832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129610,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3c/8a/900ca88a.jpg","nickname":"test","note":"","ucode":"C57A175CBC6547","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":137612,"discussion_content":"看来大家都这么想的，所以算法才没学好，因为第一个算法还没研究明白","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579188424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041640,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","nickname":"mrlay","note":"","ucode":"385A1954ED3317","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565,"discussion_content":"这个算是心里动机的研究吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561708954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1041640,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","nickname":"mrlay","note":"","ucode":"385A1954ED3317","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4672,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565651815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":565,"ip_address":""},"score":4672,"extra":""},{"author":{"id":1000006,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/46/274d8dcc.jpg","nickname":"summer","note":"","ucode":"7DF4E4FD6E9111","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1041640,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","nickname":"mrlay","note":"","ucode":"385A1954ED3317","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85558,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576554841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":565,"ip_address":""},"score":85558,"extra":""}]},{"author":{"id":1689380,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c7/24/19d0683e.jpg","nickname":"crossing","note":"","ucode":"3B66CFFF38BA67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51555,"discussion_content":"比如A星算法名称的由来，为啥叫A星，用名字命名的算法就更好讲发明者的故事了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573897109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1509678,"avatar":"https://static001.geekbang.org/account/avatar/00/17/09/2e/4badf056.jpg","nickname":"余先声","note":"","ucode":"1CCABE478259EF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36818,"discussion_content":"比如牛顿因为被苹果砸头，才发明了万有引力定律这种背景吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571447750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56792,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1546562226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"319374142130","product_id":100017301,"comment_content":"思考题：<br>1. a先于b执行，也就说b依赖于a，b指向a，这样构建有向无环图时，要找到出度为0的顶点，然后删除<br><br>2. BFS也能实现，因为遍历只是实现拓扑排序的一个“辅助手段”，本质上是帮助找到优先执行的顶点","like_count":75},{"had_liked":false,"id":63744,"user_name":"想当架构师","can_delete":false,"product_type":"c1","uid":1336600,"ip_address":"","ucode":"A4D38DEAF89D71","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rnPq7BJygkJTWYSWUfmDs2qsiaYCN018sqDib8POOr6ics2WOJ1r7hHqcpdLJgqEXOFa1HX2WLBvuc2OBDy7IVVqA/132","comment_is_top":false,"comment_ctime":1548484105,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"177642143241","product_id":100017301,"comment_content":"我怎么觉得这个kahn算法其实就是BFS算法","like_count":42,"discussions":[{"author":{"id":1016940,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/6c/effc3a5a.jpg","nickname":"澎湃哥","note":"","ucode":"A8D9A857AAB879","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213406,"discussion_content":"感觉只要用了 queue 就有 BFS 内味了","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1585068892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300477,"discussion_content":"有点像，比bfs要复杂一些，有入度减一这个操作，而且不是把所有邻接点都放入队列，而是选择此时入度为0的邻接点放入队列，所以卡恩算法还是和bfs有一定区别的！","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1598133653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87282,"discussion_content":"em\n你这么一说 还真的挺像。。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576658774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588652,"discussion_content":"很像BFS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663935234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2103542,"avatar":"https://static001.geekbang.org/account/avatar/00/20/18/f6/db57fef1.jpg","nickname":"WSZ","note":"","ucode":"AB092B48C52D47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532333,"discussion_content":"多了一步，入度--操作，我看着就是BFS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637579171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1941034,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/9e/2a/f1d8913f.jpg","nickname":"唯心主义蠢货🍁","note":"","ucode":"836B09E0459953","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290477,"discussion_content":"kahn感觉像是外边有一个点连接所有入度为0的点的BFS，思路确实挺像的诶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594483047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57004,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1546597541,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"126100649125","product_id":100017301,"comment_content":"1.kahn算法找出度为0的节点删除。dfs算法直接用正邻接表即可。<br><br>2. BFS也可以。其实与DFS一样，BFS也是从某个节点开始，找到所有与其相连通的节点。区别在于BFS是一层一层找（递归函数在for循环外），DFS是先一杆子插到底，再回来插第二条路、第三条路等等（递归函数在for循环内）。","like_count":28,"discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329501,"discussion_content":"这个解释赞。基本都是这么个套路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606394597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226193,"discussion_content":"很形象呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586427668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124012,"user_name":"不一样的烟火","can_delete":false,"product_type":"c1","uid":1473251,"ip_address":"","ucode":"6E305F0EE90E8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","comment_is_top":false,"comment_ctime":1565791306,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"104645006410","product_id":100017301,"comment_content":"我常常陷入问题都看不懂的迷思中","like_count":25,"discussions":[{"author":{"id":2449060,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","nickname":"Geek_sz","note":"","ucode":"72E86D7D6554CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573904,"discussion_content":"哈哈哈哈哈哈哈，我也一样，这个批语文老师死得早，谅解一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653725781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2391649,"avatar":"https://static001.geekbang.org/account/avatar/00/24/7e/61/486b1e9d.jpg","nickname":"我叫爱学习","note":"","ucode":"75271AE7A2BC3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337873,"discussion_content":"同样,被算法题搞得题都看不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609115081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57151,"user_name":"Edward","can_delete":false,"product_type":"c1","uid":1088181,"ip_address":"","ucode":"686868F2104EC6","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/b5/50c9c77a.jpg","comment_is_top":false,"comment_ctime":1546662226,"is_pvip":false,"replies":[{"id":"20722","content":"多练习 多思考 多总结 慢慢就好了 都有这么一个过程的 ","user_name":"作者回复","comment_id":57151,"uid":"1190123","ip_address":"","utype":1,"ctime":1546826709,"user_name_real":"gg"}],"discussion_count":4,"race_medal":0,"score":"65971171666","product_id":100017301,"comment_content":"老师你好。我在做一道动态规划题的时候，不借助其他启发性线索时，在纸上演算一遍后，发现自己如果不能直觉地从演算中推演出解答的关键，就会产生强烈的自我怀疑。会有一层对自己智力水平的怀疑，如果没有一定的智商，是不适合做这事情的。请问老师你有什么方法，可以克服这种自我的质疑？","like_count":15,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435431,"discussion_content":"多练习 多思考 多总结 慢慢就好了 都有这么一个过程的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546826709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129610,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3c/8a/900ca88a.jpg","nickname":"test","note":"","ucode":"C57A175CBC6547","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138991,"discussion_content":"我也这样，你这样想的话也是怀疑我的智商了？虽然我的智商确实不高。我们应该相信每个人的潜能，低估自己也会习惯性低估别人。我想到一点，我们学技术可以关注技术和方法本身，把情绪啊智商怀疑啊这些也交给方法。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1579271060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87283,"discussion_content":"42节的老师的讲解。。。\n我现在还怀疑着 其正确性呢。。\n类似的怀疑 和 自我怀疑","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576658919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253109,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1e/f5/fba1adfd.jpg","nickname":"斑斓","note":"","ucode":"57AE303DD189E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114795,"discussion_content":"原来都这样，我就放心了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577977447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56757,"user_name":"farFlight","can_delete":false,"product_type":"c1","uid":1245211,"ip_address":"","ucode":"B0872D3ECBEC38","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbRibsic15KXfGEN3SSjnLhXGyhK2Uyrj5ibBJsKAjicNqtafDaQOLH4xpSJRZD1vmibFPJER1ySmwP9A/132","comment_is_top":false,"comment_ctime":1546556591,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65971066031","product_id":100017301,"comment_content":"老师，我觉得这里BFS和Kahn算法基本可以说是一样的，本身Kahn贪婪算法运用queue实现的过程就是一个典型的BFS范式。采用BFS就应该按照入度一层一层遍历，一层遍历完了的同时把下一层的顶点push进入queue中。","like_count":15,"discussions":[{"author":{"id":1444483,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","nickname":"风","note":"","ucode":"E1CE0825AAF805","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188084,"discussion_content":"我也觉得，kahn好像就是BFS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582794385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164202,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1576910222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35936648590","product_id":100017301,"comment_content":"代码看不明白；但是使用场景是记住了。","like_count":9},{"had_liked":false,"id":160858,"user_name":"Sid","can_delete":false,"product_type":"c1","uid":1115041,"ip_address":"","ucode":"0461B574B2736B","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a1/e6a0f60b.jpg","comment_is_top":false,"comment_ctime":1576047877,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"35935786245","product_id":100017301,"comment_content":"想起了spring Bean的生成，Bean之间循环依赖的检查就是图的深度优先遍历方式检测是否有环:。 假设<br>A-&gt;B-&gt;C-&gt;A,  创建A时依赖B，把A放到正在创建集合中，再去创建B，把B放到正在创建集合中，B依赖C，把C放到正在创建集合中，C依赖A，发现A在正在创建中，说明存在循环依赖，就做个特殊处理暴露出bean。看来处处有算法，用而不知。","like_count":8,"discussions":[{"author":{"id":1068832,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4f/20/c54056a8.jpg","nickname":"路过","note":"","ucode":"DA65555B10D1EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336157,"discussion_content":"bean 的 循环 注入 没有这么复杂 ，用的三级缓存，把 bean的不同阶段 放到不同 集合里面","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608518974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2802184,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoHvFnoNgYmBdKo7Sum0gySwZUREBXBwniaic8hTZHgXxmfeiaPaUia9fvGLq9FJt1dQtEmOyQrwuMlg/132","nickname":"Geek_9f24c4","note":"","ucode":"0E0F23EB79DDAD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1068832,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4f/20/c54056a8.jpg","nickname":"路过","note":"","ucode":"DA65555B10D1EA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565528,"discussion_content":"层主说的是判断是否发生循环依赖 而三级缓存是用于解决循环依赖的。Spring底层判断是否发生了循环依赖 就是依靠层主说的方法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650471620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336157,"ip_address":""},"score":565528,"extra":""}]}]},{"had_liked":false,"id":57625,"user_name":"蓝天","can_delete":false,"product_type":"c1","uid":1239788,"ip_address":"","ucode":"25760853BC1C01","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBzcWHFreCY9PJzANxSKrGTB01oicic2OO1w5CYSIMUGhZyzFia6R93fTSdKrNuiaZT0SUXx4O7Qkgww/132","comment_is_top":false,"comment_ctime":1546853323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27316657099","product_id":100017301,"comment_content":"刚解决完工作中类似的问题 老师的文章就来了，然后才知道那个算法叫kahn","like_count":6},{"had_liked":false,"id":57552,"user_name":"你有资格吗？","can_delete":false,"product_type":"c1","uid":1233534,"ip_address":"","ucode":"4758C5A190BABB","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/7e/bd8c372a.jpg","comment_is_top":false,"comment_ctime":1546831847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27316635623","product_id":100017301,"comment_content":"老师，好像数据结构少了B+树的讲解啊，B+不准备讲吗？","like_count":6},{"had_liked":false,"id":56853,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1546568827,"is_pvip":false,"replies":[{"id":"20525","content":"iPad Paper","user_name":"编辑回复","comment_id":56853,"uid":"1058895","ip_address":"","utype":2,"ctime":1546572753,"user_name_real":"王锦"}],"discussion_count":1,"race_medal":0,"score":"27316372603","product_id":100017301,"comment_content":"老师, 专栏一直跟进到现在了, 每堂课都是对知识的巩固和完善, 额...不过我一直有个小问题想请教一下老师, 那就是老师的图是使用什么工具绘制的, 我觉得非常富有生命力, 记录在笔记里非常 nice ...","like_count":6,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435279,"discussion_content":"iPad Paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546572753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57089,"user_name":"Aaron","can_delete":false,"product_type":"c1","uid":1238769,"ip_address":"","ucode":"0580FCFFAF6D78","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/f1/291ee0e6.jpg","comment_is_top":false,"comment_ctime":1546619498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23021455978","product_id":100017301,"comment_content":"课后思考里“BFS 深度优先搜索算法”是否应该是“BFS 广度优先搜索算法”？BFS: Breadth-first Search<br>","like_count":5},{"had_liked":false,"id":56973,"user_name":"NeverMore","can_delete":false,"product_type":"c1","uid":1228498,"ip_address":"","ucode":"582698D772810D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d2/3d88cb8e.jpg","comment_is_top":false,"comment_ctime":1546590344,"is_pvip":false,"replies":[{"id":"21323","content":"专栏结束的时候吧 也算是一个回顾 现在年底忙 没啥时间写呢","user_name":"作者回复","comment_id":56973,"uid":"1190123","ip_address":"","utype":1,"ctime":1547262470,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"18726459528","product_id":100017301,"comment_content":"1、反过来的话计算的就不是入度了，可以用出度来判断；<br>2、BFS的话，则需要记录上一个节点是哪个，可以实现，但是比DFS要麻烦些。<br>还请老师指点。<br>老师之后能不能给思考题一个答疑？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435342,"discussion_content":"专栏结束的时候吧 也算是一个回顾 现在年底忙 没啥时间写呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547262470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56793,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1546562323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18726431507","product_id":100017301,"comment_content":"如果 a 先于 b，我们画一条从 b 到 a 的有向边，表示 b 依赖 a<br><br>我个人更喜欢这种构建图的方式，觉得这种更符合“惯性思维方式”","like_count":4},{"had_liked":false,"id":185985,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583738264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14468640152","product_id":100017301,"comment_content":"今日学习总结<br>什么是拓扑排序 拓扑排序就是针对有向图这种数据结构 根据两两的依赖关系 最终确定出一个顺序的算法<br>实现方法<br>1. 贪心算法 <br>   主要是依据如果一个顶点的入度如果为0 则说明没有依赖于它的了，然后就把这个顶点进行删除，同时把依赖于它的顶点的出度进行-1 时间复杂度为o(v+e) 因为在建立依赖关系的时候是根据边来创建的假设有v条边 n个顶点  所以才有o(v+n)的事件复杂度<br>  所以针对思考题 第一问 如果反过来了 就无法通过该顶点找到需要减少出度的点<br>2. dfs算法<br>   通过建立一个逆邻接表,表示出 结点w 和依赖于它的结点关系 比如inverseAdj[w] = {a,b,c,d} 这里面的abcd都是依赖于w的,租后通过dfs深度优先算法 递归打印出一条完整的依赖路径，这也体现了dfs适合用来求路径 而bfs适合用来求最短距离 所以关于思考题如果反向反了的话 就无法建立一个逆邻接表o(v+e)<br>如果改造的话 那就只有通过依赖关系构建一个逆邻接表 <br>第二问 <br> Kahn算法相当于就是广度优先遍历方式 只不过条件是 它所有的边当中入度为0的顶点才放入队列","like_count":4},{"had_liked":false,"id":163122,"user_name":"Swing","can_delete":false,"product_type":"c1","uid":1330065,"ip_address":"","ucode":"55FCA9ECEFBBEB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","comment_is_top":false,"comment_ctime":1576659885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166594477","product_id":100017301,"comment_content":"em<br>蓦然发现。。。<br>没有课代表 整理知识点了。。","like_count":2},{"had_liked":false,"id":66402,"user_name":"jueyoq","can_delete":false,"product_type":"c1","uid":1129625,"ip_address":"","ucode":"5CD5A9CF9B5B1C","user_header":"https://static001.geekbang.org/account/avatar/00/11/3c/99/6080d269.jpg","comment_is_top":false,"comment_ctime":1549935482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10139870074","product_id":100017301,"comment_content":"老师什么时候再出课程呀。 按照咱们这销量，可以开始新专栏预告辣","like_count":2},{"had_liked":false,"id":283775,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1615912528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5910879824","product_id":100017301,"comment_content":"嗯，看不懂也要看完。然后在看第二遍，好家伙，加油。","like_count":1},{"had_liked":false,"id":237882,"user_name":"文和.","can_delete":false,"product_type":"c1","uid":1423140,"ip_address":"","ucode":"7E00ECE3D83616","user_header":"https://static001.geekbang.org/account/avatar/00/15/b7/24/c2f5ce58.jpg","comment_is_top":false,"comment_ctime":1595994819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890962115","product_id":100017301,"comment_content":"第一遍就是看懂了.可能没看懂.这是我看的第二遍.代码跟着敲.课后问题.没深入研究.我会看第三遍第四遍.什么时候都看明白了.习题也能都研究明白了.我也许就出关了.","like_count":1},{"had_liked":false,"id":233873,"user_name":"唯心主义蠢货🍁","can_delete":false,"product_type":"c1","uid":1941034,"ip_address":"","ucode":"836B09E0459953","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9e/2a/f1d8913f.jpg","comment_is_top":false,"comment_ctime":1594483187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889450483","product_id":100017301,"comment_content":"1. b 依赖于 a 记为 b -&gt; a，所有第一个访问的点肯定是没有出度的，所有只要找出度为0的<br>2. BFS的话从一个点开始，找所有依赖他的点，这个是没问题的","like_count":1},{"had_liked":false,"id":144182,"user_name":"Geek_18b741","can_delete":false,"product_type":"c1","uid":1368496,"ip_address":"","ucode":"097BA0C2F44150","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlztvlBgajZMEph8AvkP2pfoqNCGtYSalIKgrCbCg0MWDZJgJwqVRfWA6cgIoZicL6dKibfK0zjsWg/132","comment_is_top":false,"comment_ctime":1571876687,"is_pvip":false,"replies":[{"id":"55985","content":"dfs是栈的思想，一进一出就被访问了两次","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572230628,"ip_address":"","comment_id":144182,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866843983","product_id":100017301,"comment_content":"DFS 算法的时间复杂度计算中，为什么每个顶点访问两次？每个顶点进入dfs是一次呀？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471839,"discussion_content":"dfs是栈的思想，一进一出就被访问了两次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572230628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142183,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1571304740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866272036","product_id":100017301,"comment_content":"课后思考<br>1. Kahn 使用逆邻接表再使用原来逻辑即可；DFS 无需再转为逆邻接表了，可直接基于当前的邻接表求解。<br>2. 单纯的 BFS 应该是不能实现，其实 Kahn 就是基于 BFS 的实现。","like_count":1},{"had_liked":false,"id":119196,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1564536191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859503487","product_id":100017301,"comment_content":"思考题2<br>广度优先在拓扑排序中不行，因为如果第一次选中了中间的节点，遍历的顺序就无法保证根部节点在中间节点之前。Kahn 算法是利用了出度信息来保证，根节点在其子节点之前。深度优先是利用了子节点必然比根节点先结束的特点来逆序处理。广度优先没有什么保证。（这里的描述和文中的例子有所不同，是按照出度为0的节点优先的原则）","like_count":1},{"had_liked":false,"id":58004,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1546959426,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5841926722","product_id":100017301,"comment_content":"DFS 算法 ，里面的递归差点就被绕进去了，这个递归终止条件太隐蔽了……不仔细看代码，还以为没有终止条件会死循环……好巧妙，打算我也想不出这样写代码","like_count":1,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87287,"discussion_content":"visited？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576659175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041640,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","nickname":"mrlay","note":"","ucode":"385A1954ED3317","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564,"discussion_content":"套在递归外面的那个循环，我觉得可以优化哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561708916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345663,"user_name":"苏成","can_delete":false,"product_type":"c1","uid":2668694,"ip_address":"","ucode":"80A8E7B243DD73","user_header":"https://static001.geekbang.org/account/avatar/00/28/b8/96/716ba431.jpg","comment_is_top":false,"comment_ctime":1652495998,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1652495998","product_id":100017301,"comment_content":"课后思考题：<br>1.对于Kahn实现方式，我们把出度为0的节点放入对垒，对于DFS甚至不用构造逆邻接矩阵<br>2.感觉 Kahn本质就是BFS，使用队列就和层序遍历很像了","like_count":0},{"had_liked":false,"id":337582,"user_name":"Geek_279849","can_delete":false,"product_type":"c1","uid":2699218,"ip_address":"","ucode":"FC6A3514FC955C","user_header":"","comment_is_top":false,"comment_ctime":1646903248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646903248","product_id":100017301,"comment_content":"如果图中存在环，kahn会输出除环的其他顶点的路径，而dfs不影响，还是会输出所有顶点的路径。","like_count":0},{"had_liked":false,"id":336501,"user_name":"Geek_18d036","can_delete":false,"product_type":"c1","uid":2885747,"ip_address":"","ucode":"B0FB13F4312AD1","user_header":"https://static001.geekbang.org/account/avatar/00/2c/08/73/a09700a5.jpg","comment_is_top":false,"comment_ctime":1646191285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646191285","product_id":100017301,"comment_content":"Android 开机启动优化就是DAG ","like_count":0},{"had_liked":false,"id":333991,"user_name":"Lihoo","can_delete":false,"product_type":"c1","uid":2746186,"ip_address":"","ucode":"54B8F26B6D63C5","user_header":"https://static001.geekbang.org/account/avatar/00/29/e7/4a/8990a97a.jpg","comment_is_top":false,"comment_ctime":1644655265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644655265","product_id":100017301,"comment_content":"DFS的算法好像无法用于判断是否有环，我自己用golang写了一个DFS，可以用于判断是否有环：<br>func (g *DirectedGraph) TopoSortDFS() {<br>\tret := []int{}<br><br>\tinDegree := make([]int, g.v)<br>\tfor i := range g.adj {<br>\t\tfor p := g.adj[i].Front(); p != nil; p = p.Next() {<br>\t\t\tinDegree[p.Value.(int)]++<br>\t\t}<br>\t}<br><br>\tvisited := make([]bool, g.v)<br><br>\tvar recur func(i int)<br>\trecur = func(i int) {<br>\t\tif inDegree[i] != 0 {<br>\t\t\treturn<br>\t\t}<br><br>\t\tif visited[i] {<br>\t\t\treturn<br>\t\t}<br><br>\t\tret = append(ret, i)<br>\t\tvisited[i] = true<br><br>\t\tfor p := g.adj[i].Front(); p != nil; p = p.Next() {<br>\t\t\tnextVertex := p.Value.(int)<br>\t\t\tinDegree[nextVertex]--<br>\t\t\tif inDegree[nextVertex] == 0 {<br>\t\t\t\trecur(nextVertex)<br>\t\t\t}<br>\t\t}<br>\t}<br><br>\tfor i := range g.adj {<br>\t\trecur(i)<br>\t}<br><br>\tfmt.Printf(&quot;topoSort = %+v\\n&quot;, ret)<br>}","like_count":0},{"had_liked":false,"id":300007,"user_name":"Geek_9258fc","can_delete":false,"product_type":"c1","uid":2142284,"ip_address":"","ucode":"BE1C46704B2481","user_header":"","comment_is_top":false,"comment_ctime":1624952820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624952820","product_id":100017301,"comment_content":"老师，DFS算法为什么要构造逆邻接表呢？","like_count":0},{"had_liked":false,"id":297632,"user_name":"佐镜兄","can_delete":false,"product_type":"c1","uid":1062804,"ip_address":"","ucode":"18DB653A028632","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/94/723ec0e9.jpg","comment_is_top":false,"comment_ctime":1623680936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623680936","product_id":100017301,"comment_content":"拓扑排序还可以判断是否有环","like_count":0},{"had_liked":false,"id":279518,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","comment_is_top":false,"comment_ctime":1613810908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613810908","product_id":100017301,"comment_content":"那天我看了快排的发明者荣获IEEE会员的消息,这一节课主要讲了两种算法","like_count":0},{"had_liked":false,"id":264221,"user_name":"拉布拉多","can_delete":false,"product_type":"c1","uid":1204353,"ip_address":"","ucode":"637A88D9F29F57","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","comment_is_top":false,"comment_ctime":1606382897,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606382897","product_id":100017301,"comment_content":"如果w顶点没有逆邻接表拉链，即它是源头，只有出度。这个visit[true]就一直不能设置。如下是我的思路：<br>public void dfsReverseAdj(int vertex, LinkedList&lt;Integer&gt; inverseAdj[], boolean[] visited) {<br>        for (int i = 0; i &lt; inverseAdj[vertex].size(); i++) {<br>            Integer w = inverseAdj[vertex].get(i);<br>            if (visited[w] == true) continue; &#47;&#47; 注意是continue，不是return<br>            dfsReverseAdj(w, inverseAdj, visited);<br>        }<br><br>        &#47;&#47; 打印指定vertex顶点的第一个节点是：vertex深度遍历时，路径上的某个顶点没有入度，只有出度，即此路径的源头。<br>        &#47;&#47; 打印指定vertex顶点的最后一个节点是： vertex的逆邻接表的链表全部递归遍历完成后，此时打印的节点是vertex本身。<br>        &#47;&#47; 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己<br>        visited[vertex] = true;<br>        System.out.print(&quot;--&gt;&quot; + vertex);<br>    }","like_count":0,"discussions":[{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382344,"discussion_content":"应该不会出现你说的情况，code中两个dfs调用的地方之前都会设置true值，也就是每次都是先设置true再进入dfs，源头也如此。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625538928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264218,"user_name":"拉布拉多","can_delete":false,"product_type":"c1","uid":1204353,"ip_address":"","ucode":"637A88D9F29F57","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","comment_is_top":false,"comment_ctime":1606382805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606382805","product_id":100017301,"comment_content":"DFS： 如果w顶点没有逆邻接表拉链，即它是源头，只有出度。这个visit[true]就一直不能设置。如下是我的思路：<br>public void dfsReverseAdj(int vertex, LinkedList&lt;Integer&gt; inverseAdj[], boolean[] visited) {<br>        for (int i = 0; i &lt; inverseAdj[vertex].size(); i++) {<br>            Integer w = inverseAdj[vertex].get(i);<br>            if (visited[w] == true) continue; &#47;&#47; 注意是continue，不是return<br>            dfsReverseAdj(w, inverseAdj, visited);<br>        }<br><br>        &#47;&#47; 打印指定vertex顶点的第一个节点是：vertex深度遍历时，路径上的某个顶点没有入度，只有出度，即此路径的源头。<br>        &#47;&#47; 打印指定vertex顶点的最后一个节点是： vertex的逆邻接表的链表全部递归遍历完成后，此时打印的节点是vertex本身。<br>        &#47;&#47; 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己<br>        visited[vertex] = true;<br>        System.out.print(&quot;--&gt;&quot; + vertex);<br>    }","like_count":0},{"had_liked":false,"id":247798,"user_name":"我是一把火","can_delete":false,"product_type":"c1","uid":2069916,"ip_address":"","ucode":"20E61D44CCD8AC","user_header":"","comment_is_top":false,"comment_ctime":1599863900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599863900","product_id":100017301,"comment_content":"老师您好，请问DFS算法可以通过什么方式进行环检测？","like_count":0},{"had_liked":false,"id":247422,"user_name":"渊จุ๊บ","can_delete":false,"product_type":"c1","uid":1530295,"ip_address":"","ucode":"E3A2C1E89EB576","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/b7/9db9c657.jpg","comment_is_top":false,"comment_ctime":1599705286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599705286","product_id":100017301,"comment_content":"思考题（语言：golang）：<br>1）各对象及其相关方法实现，由于篇幅有限暂不赘述，以下为拓扑排序算法函数：<br>&#47;&#47; 反序Kahn拓扑排序<br>func topoSortByKahnR(adj Graph) {<br>\tv := len(adj)<br>\tcpAdj := NewGraph(v)<br>\t&#47;&#47; 为不影响原图及各顶点对象，做了拷贝操作<br>\tfor i := 0; i &lt; v; i++ {<br>\t\tfor j := 0; j &lt; adj[i].Size(); j++ {<br>\t\t\tw := adj[i].Get(j) &#47;&#47; i -&gt; w<br>\t\t\tcpAdj.AddEdge(i, w) &#47;&#47; copy i -&gt; w<br>\t\t}<br>\t}<br><br>\tqueue := make(Queue, 0)<br>\tfor i := 0; i &lt; v; i++ {<br>\t\tif cpAdj[i].degree == 0 {<br>\t\t\tqueue.Add(i)<br>\t\t}<br>\t}<br><br>\tfor !queue.isEmpty() {<br>\t\ti := queue.poll()<br>\t\tfmt.Println(&quot;-&gt;&quot;, i)<br>\t\tfor j := 0; j &lt; v; j++ {<br>\t\t\tif cpAdj[j].degree != 0 {<br>\t\t\t\tcpAdj[j].Del(i)<br>\t\t\t\tif cpAdj[j].degree == 0 {<br>\t\t\t\t\tqueue.Add(j)<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br>\t}<br>}<br>&#47;&#47; 反序DFS拓扑排序<br>func topoSortByDFSR(adj Graph) {<br>\tv := len(adj)<br>\tinverseAdj := NewGraph(v)<br>\tfor i := 0; i &lt; v; i++ {<br>\t\tfor j := 0; j &lt; adj[i].Size(); j++ {<br>\t\t\tw := adj[i].Get(j) &#47;&#47; i -&gt; w<br>\t\t\tinverseAdj.AddEdge(w, i) &#47;&#47; w -&gt; i<br>\t\t}<br>\t}<br><br>\tvar dfs func(int, Graph, []bool)<br>\tdfs = func(idx int, g Graph, vis []bool) {<br>\t\tfor i := 0; i &lt; v; i++ {<br>\t\t\tif vis[i] {<br>\t\t\t\tcontinue<br>\t\t\t}<br>\t\t\tdegree := g[i].degree<br>\t\t\tg[i].Del(idx)<br>\t\t\tif g[i].degree &lt; degree {<br>\t\t\t\tvis[i] = true<br>\t\t\t\tdfs(i, g, vis)<br>\t\t\t}<br>\t\t}<br>\t\tfmt.Println(&quot;-&gt;&quot;, idx)<br>\t}<br><br>\tvisited := make([]bool, v)<br>\tfor i := 0; i &lt; v; i++ {<br>\t\tif !visited[i] {<br>\t\t\tvisited[i] = true<br>\t\t\tdfs(i, inverseAdj, visited)<br>\t\t}<br>\t}<br>}<br><br>2）Kahn拓扑排序应该就是用BFS结合（出）入度的判断","like_count":0},{"had_liked":false,"id":231216,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1593610358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593610358","product_id":100017301,"comment_content":"今天学习拓扑排序：<br>拓扑排序是基于依赖关系的节点，根据依赖关系而生成的序列。节点和依赖关系往往要生成有向无环图。类似的问题有：穿衣服裤子的先后关系，生成穿衣序列&#47;专业课程与前置课程形成的课程学习序列&#47;代码编译依赖关系形成的编译顺序序列。<br>解决办法有两种：<br>0. 先a后b则 a-&gt;b，数据结构为临接表来描述<br>1. kahn(卡恩）算法<br>   根据邻接表，很容易计算出每个节点的入度。<br>   遍历每个入度，将入度为0的节点，放入队列。<br>   队列不空，循环：<br>取出队首元素，输出他，然后遍历他的邻接节点，将邻接节点入度-1，如果邻接节点恰好为0，将节点放入队列。<br>时间复杂度：求入度：O(v+e),循环输出O(v+e)合起来O(v+e)<br>空间复杂度：入度数组O(v),队列&lt;O(v)   <br>dfs算法：<br> 1. 深度优先搜索是要一通到底的，所以需要将邻接表返过来，改成逆邻接表。方法：遍历邻接表，对i的每个邻接节点j，都将i加到j的逆邻接表中。<br> 2. 图的深度优先搜索不跟树一样：没有根节点，所以要尝试从每个节点都开始一次，自然需要visited数组防止重复。对某个节点深度遍历完之后，再输出。<br><br>显然用于拓扑排序的图是不可以成环的。自然拓扑排序算法可以用于检测图中的环。对于kahn算法，极端化思维：如果所有的节点形成大环，那么没有入度为0的节点，也就不会有任何输出。普通思维：如果存在环，总会到一个位置，没有任何节点入度为0。就会少输出节点。如果输出的节点&lt;总结点，意味着存在环。<br>思考题：如果a-&gt;b掉头，dfs就是着么解的呀。对于kahn算法，需要先输出入度为0，变为先输出出度为0。输出一个出度为0后，需要将它对应的入度节点的出度-1。出度数组好办，怎么实现出度的更新？遍历整个邻接表，如果某节点表内包含刚删除的节点，则该节点出度-1.多了一个搜索流程。如果有更简单的想法，请指正。<br>至于BFS，我认为kahn算法就是BFS","like_count":0},{"had_liked":false,"id":230223,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1593316240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593316240","product_id":100017301,"comment_content":"打卡43","like_count":0},{"had_liked":false,"id":229471,"user_name":"SIYI","can_delete":false,"product_type":"c1","uid":1238567,"ip_address":"","ucode":"FB3C629FF6A2C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/27/1c43bd65.jpg","comment_is_top":false,"comment_ctime":1593008777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593008777","product_id":100017301,"comment_content":"思考题2 尝试写了一下，不知道对不对<br>def topoSortByBFS(graph: dict):<br>    # 统计每个顶点的入度<br>    inDegree = {}<br>    for k, v in graph.items():<br>        inDegree.setdefault(k, 0)<br>        for i in v:<br>            inDegree.setdefault(i, 0)<br>            inDegree[i] += 1<br>    queue = deque()<br>    visited = {}<br>    # 找到入度为0的顶点，这就是起始顶点<br>    for v in inDegree:<br>        if inDegree[v] == 0:<br>            visited[v] = True<br>            queue.append(v)<br>    res = []<br>    # 逐层遍历<br>    while len(queue) &gt; 0:<br>        v = queue.pop()<br>        res.append(v)<br>        for i in graph[v]:<br>            if visited.get(i) is None:<br>                visited[i] = True<br>                queue.append(i)<br>    return res","like_count":0},{"had_liked":false,"id":223607,"user_name":"cool","can_delete":false,"product_type":"c1","uid":1383620,"ip_address":"","ucode":"254220D6E2DAE8","user_header":"https://static001.geekbang.org/account/avatar/00/15/1c/c4/3e593863.jpg","comment_is_top":false,"comment_ctime":1591143881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591143881","product_id":100017301,"comment_content":"你这个DFS 是找的最长路径吧？","like_count":0},{"had_liked":false,"id":222819,"user_name":"Geek_b6e449","can_delete":false,"product_type":"c1","uid":1740368,"ip_address":"","ucode":"8296078ED23637","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhr1LrBZQTnn5PgyuHUtia6j6tiahZyk44BWeB5LQIqMgTDBdibGKVVopbJWbz83ZWvyVPz9fBl69rw/132","comment_is_top":false,"comment_ctime":1590919725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590919725","product_id":100017301,"comment_content":"topoSortByDFS line:16 是不是应该去掉 感觉有bug  比如 裤子依赖裤衩  裤子依赖秋裤 当前的算法这样写的话就有bug","like_count":0},{"had_liked":false,"id":222722,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1590899117,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1590899117","product_id":100017301,"comment_content":"个人感觉 Kahn 算法要比 DFS 算法更容易理解一些，从一开始的计算每个顶点的入度，然后从入度为零的顶点开始遍历（入队列），遍历每个点可达的顶点。不过这种拓扑排序应该是不稳定排序，顶点出现的顺序有可能不同。<br><br>DFS 算法的关键点，我感觉是在于生成了逆邻接矩阵，后面的 DFS 遍历就比较简单明了，其实就是代码注释中的那一句话“先访问 vertex 这个顶点可达的所有顶点，然后在访问自己”。<br><br>对于课后题，看了回复中的提醒，第一题只要从出度为零的点开始遍历即可：<br><br>public void topoSortByKahnOutDegree() {<br>    int[] outDegree = new int[v];<br>    for (int i = 0; i &lt; v; i++) {<br>        for (int j = 0; j &lt; adj[i].size(); j++) {<br>            int k = adj[i].get(j);<br>            outDegree[k]++;<br>        }<br>    }<br><br>    LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();<br>    for (int i = 0; i &lt; v; i++) {<br>        if (outDegree[i] == 0) {<br>            queue.add(i);<br>        }<br>    }<br><br>    while (!queue.isEmpty()) {<br>        int i = queue.remove();<br>        System.out.println(&quot;&lt;-&quot; + i);<br>        for (int j = 0; j &lt; adj[j].size(); j++) {<br>            int k = adj[i].get(j);<br>            outDegree[k]--;<br>            if (outDegree[k] == 0) {<br>                queue.add(k);<br>            }<br>        }<br>    }<br>}<br><br>代码照着专栏里面的仿写了一下，但是有点不敢确定。如果能给出验证的数据就好了，即使不能做到测试驱动，能给一组测试数据也好。有时间的话，自己编一组。<br><br>课后第二题，感觉 BFS 应该也能够实现，但是似乎更加困难一些，因为要记录父节点甚至是祖父节点的路径。<br><br>按照留言里面的线索，去看了 LeetCode 的 207 Course Schedule 和 210 Course Schedule II，直接看了答案，难度不是特别大，但是要注意一些细节的地方。","like_count":0},{"had_liked":false,"id":220361,"user_name":"Geek_py hang","can_delete":false,"product_type":"c1","uid":1915167,"ip_address":"","ucode":"E1DABF14C9176B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/1f/579ae900.jpg","comment_is_top":false,"comment_ctime":1590226359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590226359","product_id":100017301,"comment_content":"如果能在非计算机领域也能用上这样的方式解析问题，效果会很不错👍","like_count":0},{"had_liked":false,"id":218392,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1589795506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589795506","product_id":100017301,"comment_content":" 问题一：<br>针对Kahn算法，有向图的方向正好相反，为了调整方向，建立逆邻接表，用逆邻接表替换原有邻接表进行拓扑排序，其他操作不变。<br>针对DFS算法：由于有向图的方向正好相反(与原有相同比较)，新有向图的邻接表即为老有向图的逆邻接表，直接在新的邻接表上递归调用DFS遍历。<br>问题二：用BFS感觉不太行。BFS会按层输出结点，即便下一层还有结点，也会先输出当层结点，这与拓扑排序只有没有依赖任务的情况下才输出该结点矛盾。","like_count":0},{"had_liked":false,"id":218087,"user_name":"华仔","can_delete":false,"product_type":"c1","uid":1299543,"ip_address":"","ucode":"F794510431C343","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/57/b0a11ae5.jpg","comment_is_top":false,"comment_ctime":1589712034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589712034","product_id":100017301,"comment_content":"我感觉拓扑排序反而使用BFS难以实现，如果只是做一个逐层遍历，并且记录已经访问的节点，在下一层不再访问，最后反向输出所有节点的话，其实有时候可能存在第N+1层向第N层的依赖关系，这种关系会因为第N层的节点已经访问过，在逻辑中会被忽略掉，导致两个节点的依赖关系被忽略导致拓扑排序失败。 ","like_count":0},{"had_liked":false,"id":217514,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1589522776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589522776","product_id":100017301,"comment_content":"今天用这个解决本地化部署的问题, 因为不同的服务有依赖, 哈哈, 真香","like_count":0},{"had_liked":false,"id":215967,"user_name":"鱼丸粗面","can_delete":false,"product_type":"c1","uid":1785016,"ip_address":"","ucode":"B2F3F75B0D1422","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","comment_is_top":false,"comment_ctime":1589160393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589160393","product_id":100017301,"comment_content":"kahn不就是基于广度优先bfs实现的吗？","like_count":0},{"had_liked":false,"id":202183,"user_name":"jianhuang_zou","can_delete":false,"product_type":"c1","uid":1895439,"ip_address":"","ucode":"B43F1D59C67F48","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ec/0f/555aa881.jpg","comment_is_top":false,"comment_ctime":1585917988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585917988","product_id":100017301,"comment_content":"其实对使用算法的语言，java&#47;javaScript&#47;python 的选择真的很难，主要是项目应用需要前两者，但是其实python写代码简单又便捷，，，","like_count":0},{"had_liked":false,"id":202182,"user_name":"jianhuang_zou","can_delete":false,"product_type":"c1","uid":1895439,"ip_address":"","ucode":"B43F1D59C67F48","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ec/0f/555aa881.jpg","comment_is_top":false,"comment_ctime":1585917901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585917901","product_id":100017301,"comment_content":"坚持了三篇真是不容易，虽然不能每篇都听懂，但是还是收获很多~~~","like_count":0},{"had_liked":false,"id":200380,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1585578780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585578780","product_id":100017301,"comment_content":"dfs算法中“if (visited[w] == true) continue;”如何理解呢？","like_count":0},{"had_liked":false,"id":200347,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1585575187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585575187","product_id":100017301,"comment_content":"这个算法的前提是是定点的个数v与邻接表中的节点的值val的最大值maxVal的关系为<br>maxVal&lt;v并且val的值是递增的，例如：<br>v = 5<br>val的值依次为0，1，2，3，4<br>否则的话，下面的程序对于如下的情况就无法解释：<br>例如邻接表中的第一行数据为<br>100 1<br>此时进入到第二层循环的时候<br>w的值为100，而inDegree[100]++相当于下标为100的元素的值为1，于是当执行下面的代码<br>for (int i = 0; i &lt; v; ++i) { <br>if (inDegree[i] == 0) <br>queue.add(i); <br>}<br>v的最大值为5，永远获取不到inDegreee[100]的值","like_count":0},{"had_liked":false,"id":188412,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1584351638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584351638","product_id":100017301,"comment_content":"思考题：<br>1.如果有向边反向，代表依赖关系，则Kahn算法无法工作，改造方法是：把对入度的计算改为对出度的计算，即首先输出出度为0的节点，然后依次把与该节点相邻的节点的出度都减1，重复此过程直到输出所有节点；而DFS算法中，则会输出相反的结果，由于邻接表和逆邻接表正好是相反的，因此改造方法是：在DFS中，把对逆邻接表的的访问改为对邻接表的访问即可。<br>2.采用BFS算法，无法保证在某个结点输出之前，先输出其所有依赖的节点，因为有可能该节点和其所依赖的某个节点，可能在BFS算法中处于同一个层次，因为这两个节点可能都和某个节点相邻，因此，采用BFS算法，有可能会输出不正确的拓扑次序。","like_count":0},{"had_liked":false,"id":169462,"user_name":"分清云淡","can_delete":false,"product_type":"c1","uid":1269873,"ip_address":"","ucode":"7045AE6BF72D31","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","comment_is_top":false,"comment_ctime":1578360406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578360406","product_id":100017301,"comment_content":"在今天的讲解中，我们用图表示依赖关系的时候，如果 a 先于 b 执行，我们就画一条从 a 到 b 的有向边；反过来，如果 a 先于 b，我们画一条从 b 到 a 的有向边，表示 b 依赖 a，那今天讲的 Kahn 算法和 DFS 算法还能否正确工作呢？如果不能，应该如何改造一下呢？<br>^^^写错了","like_count":0},{"had_liked":false,"id":152507,"user_name":"leowu","can_delete":false,"product_type":"c1","uid":1664736,"ip_address":"","ucode":"4FBA5015D0FFB5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELdKezshEZ7tvspWOvPN7A2HYTnfUInEjWtxcSMo1luN7cEHrU2ibTSdYfTcUMLGYSI87KfA8owibZw/132","comment_is_top":false,"comment_ctime":1574037716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574037716","product_id":100017301,"comment_content":"kahn就是BFS算法","like_count":0},{"had_liked":false,"id":141030,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1571104070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571104070","product_id":100017301,"comment_content":"问题1<br>   kahn 算法 改成查找出度为0的数据.  dfs 算法不在需要逆邻接表、而直接用邻接表.<br>问题2<br>  BFS. 也可以，先查找一个入度为0的顶点，BFS 输出结果后.  再查找下一个入度为0的顶点，直至全部被访问.","like_count":0},{"had_liked":false,"id":137390,"user_name":"我的黄金时代","can_delete":false,"product_type":"c1","uid":1062070,"ip_address":"","ucode":"D7825B45B372F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","comment_is_top":false,"comment_ctime":1569728171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569728171","product_id":100017301,"comment_content":"kahn的算法的详细注释有点少啊！","like_count":0},{"had_liked":false,"id":119166,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1564533428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564533428","product_id":100017301,"comment_content":"思考题1<br>当关系反转了，算法1只要把入度改为出度即可。<br>深度优先算法就在原图中进行，而不需要反转邻接表","like_count":0},{"had_liked":false,"id":115711,"user_name":"wordMan","can_delete":false,"product_type":"c1","uid":1335088,"ip_address":"","ucode":"3C8A681EF5E278","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/30/4ae82e16.jpg","comment_is_top":false,"comment_ctime":1563702794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563702794","product_id":100017301,"comment_content":"思考题：<br>1.换方向，那统计入度的时候可以基于对应的逆邻接表","like_count":0},{"had_liked":false,"id":114946,"user_name":"月迷津渡","can_delete":false,"product_type":"c1","uid":1264111,"ip_address":"","ucode":"2B18B2FE3DAC3B","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/ef/02401473.jpg","comment_is_top":false,"comment_ctime":1563437227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563437227","product_id":100017301,"comment_content":"A指向CD节点 B指向CD节点，这种情况下Kahn算法的入度自减一次那段会不会不工作呢，因为入度要减2才能打印剩下节点。","like_count":0},{"had_liked":false,"id":109272,"user_name":"lzh","can_delete":false,"product_type":"c1","uid":1336951,"ip_address":"","ucode":"C3D83DF4230109","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","comment_is_top":false,"comment_ctime":1561991363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561991363","product_id":100017301,"comment_content":"DFS不一定要用逆邻接表吧，用栈也可以吧？算法导论上直接DFS，把遍历完的节点插到链表头，那和用栈一样一样的啊。用栈我个人感觉更直观","like_count":0},{"had_liked":false,"id":102286,"user_name":"ferry","can_delete":false,"product_type":"c1","uid":1255187,"ip_address":"","ucode":"0A848FA96C3AD8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGOSxM1GIHX9Y2JIe7vGQ87rK8xpo5F03KmiaGyXeKnozZsicHeSZrbSlzUVhTOdDlXCkTrcYNIVJg/132","comment_is_top":false,"comment_ctime":1560176710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560176710","product_id":100017301,"comment_content":"其实Kahn不就是广度优先排序得出的结果嘛！","like_count":0},{"had_liked":false,"id":99258,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1559182950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559182950","product_id":100017301,"comment_content":"##BFS实现拓扑排序：从入度为0的顶点开始，进行BFS<br>def topoSort_BFS(n):<br>    #统计每个顶点的入度<br>    inDegree = {k:0 for k in range(n)}<br>    for k,v in graph.items():<br>        for i in v:<br>            inDegree[i] += 1<br>    #记录顶点是否打印<br>    visited = {k:False for k in range(n)}<br>    #队列用于逐层遍历<br>    q = Queue.Queue()<br>    for k,v in inDegree.items():<br>        if v == 0:<br>            q.put(k)<br>    while not q.empty():<br>        vertex = q.get()<br>        if visited[vertex]:<br>            continue<br>        if len(graph.get(vertex)) == 0 and not q.empty():<br>            continue<br>        for tv in graph.get(vertex):<br>            q.put(tv)<br>        visited[vertex] = True<br>        print(vertex,end=&quot;-&gt;&quot;)<br>    print(&quot;end&quot;)","like_count":0},{"had_liked":false,"id":98957,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1559120186,"is_pvip":false,"replies":[{"id":"35628","content":"不是逐层遍历，逐层不行的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559176842,"ip_address":"","comment_id":98957,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559120186","product_id":100017301,"comment_content":"请教个问题，思考题2是否可以基于Kahn算法，稍微改造一下，成为一个BFS的实现？即从入度为0的顶点开始，逐层遍历。。。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451909,"discussion_content":"不是逐层遍历，逐层不行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559176842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82354,"user_name":"草长莺飞","can_delete":false,"product_type":"c1","uid":1243108,"ip_address":"","ucode":"7A281E8DB11BBB","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/e4/c8cfca11.jpg","comment_is_top":false,"comment_ctime":1554191257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554191257","product_id":100017301,"comment_content":"可汗算法里面，需要把入度所有的都存到数组中吗？<br>当我们求出所有节点的入度时，求出入度最大的数，然后依次从0到这个最大数依次打印节点<br>这样的结果也是正确的吧","like_count":0},{"had_liked":false,"id":73451,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1551886652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551886652","product_id":100017301,"comment_content":"https:&#47;&#47;leetcode-cn.com&#47;problems&#47;course-schedule-ii&#47;<br>leetcode原题，大家可以试试","like_count":0},{"had_liked":false,"id":64934,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1548981475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548981475","product_id":100017301,"comment_content":"问题1:khan改为出度为0，深度优先搜索改为先打印<br>问题2:广度优先遍历节点保存到双向链表中，然后逆序输出","like_count":0},{"had_liked":false,"id":64928,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1548980338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548980338","product_id":100017301,"comment_content":"编译过程如果存在两个互相依赖的类呢？","like_count":0},{"had_liked":false,"id":61974,"user_name":"不系之舟","can_delete":false,"product_type":"c1","uid":1240698,"ip_address":"","ucode":"884AB60C6B3979","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/7a/fdb475df.jpg","comment_is_top":false,"comment_ctime":1547869303,"is_pvip":false,"replies":[{"id":"24179","content":"那个比较大而全，所以不经常用。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550479989,"ip_address":"","comment_id":61974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547869303","product_id":100017301,"comment_content":"老师您好，还看到过另一个深度优先遍历的方法，是通过将节点涂不同的颜色判断是否在遍历的时候遇到了环，这种方法看着应该很明了，但是好像很少看到有人这么写程序，不知道是什么原因呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437058,"discussion_content":"那个比较大而全，所以不经常用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550479989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61757,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1547792532,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547792532","product_id":100017301,"comment_content":"思考题：<br>1、思路是找出度为0的节点然后打印出来。kahn算法可以和上面的类似通过构建逆临接表找出入度为0的节点，其余都一样。dfs和讲解中代码一致只是不需要再构建逆邻接表了。<br>2、bfs解的思路感觉就和kahn一样。找入度为0的节点放入queue再取出找到它的邻接节点入度减1，如果减1后等于0再放入queue。依此类推。","like_count":0},{"had_liked":false,"id":59199,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1547329640,"is_pvip":false,"replies":[{"id":"21476","content":"第一层是v 但第二层不是E呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547431537,"ip_address":"","comment_id":59199,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1547329640","product_id":100017301,"comment_content":"kahn算法中统计每个顶点的入度，有两层循环，时间复杂度为什么不是O(V*E)呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436309,"discussion_content":"第一层是v 但第二层不是E呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547431537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87299,"discussion_content":"同样的疑问 \n我是这样理解的，顶点个数 V 肯定是大O的一个关键元素\n关键 E的访问 套在 V的访问里面 有迷惑性。。。。\n但是 理论上所有的边都被访问过，具体的系数忽略，所以 边数 E 也是关键元素，但是 二者不可直接 相乘 ，且 不一定全联通，所以 二者规模不好比较，\n就 勉强写成 O(V+E)了。。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576659743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59198,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1547328943,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1547328943","product_id":100017301,"comment_content":"这个问题有没有可能通过hashmap来做？用每一个事件之前的一个事件作为key, 事件本身作为value，然后遍历一遍","like_count":0,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87301,"discussion_content":"那还是没办法有序输出啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576659797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58047,"user_name":"DreamYe","can_delete":false,"product_type":"c1","uid":1272215,"ip_address":"","ucode":"C8F935594E0EEA","user_header":"https://static001.geekbang.org/account/avatar/00/13/69/97/2044815d.jpg","comment_is_top":false,"comment_ctime":1546967236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546967236","product_id":100017301,"comment_content":"拓扑排序没问题，但是c++编译器需要对cpp文件的编译有顺序要求吗？ 按照我的理解，每一个cpp文件在预处理之后，都是独立的编译单元，然后编译成.o 文件。然后linker把所有的.o 文件链接成可执行文件。 我并不认为有编译依赖关系。可能其他语言有？譬如c#，没有头文件的概念","like_count":0},{"had_liked":false,"id":57636,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1546856084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546856084","product_id":100017301,"comment_content":"逆邻接表上拓扑排序用BFS实现不了.","like_count":0},{"had_liked":false,"id":57312,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1546744054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546744054","product_id":100017301,"comment_content":"我感觉bfs并不能找到节点之间的依赖关系，而且就算找到了入度为0的节点，可队列前面可能是度非0的节点，它们不出队后面的节点也无法出队啊","like_count":0},{"had_liked":false,"id":57247,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1546697696,"is_pvip":false,"replies":[{"id":"20719","content":"i-》w表示存在一条顶点i到顶点w的有向边","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546826262,"ip_address":"","comment_id":57247,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546697696","product_id":100017301,"comment_content":"public void topoSortByDFS() {<br>  &#47;&#47; 先构建逆邻接表，边 s-&gt;t 表示，s 依赖于 t，t 先于 s<br>  LinkedList&lt;Integer&gt; inverseAdj[] = new LinkedList[v];<br>  for (int i = 0; i &lt; v; ++i) { &#47;&#47; 申请空间<br>    inverseAdj[i] = new LinkedList&lt;&gt;();<br>  }<br>  for (int i = 0; i &lt; v; ++i) { &#47;&#47; 通过邻接表生成逆邻接表<br>    for (int j = 0; j &lt; adj[i].size(); ++j) {<br>      int w = adj[i].get(j); &#47;&#47; i-&gt;w<br>      inverseAdj[w].add(i); &#47;&#47; w-&gt;i<br>    }<br>  }<br>  boolean[] visited = new boolean[v];<br>  for (int i = 0; i &lt; v; ++i) { &#47;&#47; 深度优先遍历图<br>    if (visited[i] == false) {<br>      visited[i] = true;<br>      dfs(i, inverseAdj, visited);<br>    }<br>  }<br>}<br><br>private void dfs(<br>    int vertex, LinkedList&lt;Integer&gt; inverseAdj[], boolean[] visited) {<br>  for (int i = 0; i &lt; inverseAdj[vertex].size(); ++i) {<br>    int w = inverseAdj[vertex].get(i);<br>    if (visited[w] == true) continue;<br>    visited[w] = true;<br>    dfs(w, inverseAdj, visited);<br>  } &#47;&#47; 先把 vertex 这个顶点可达的所有顶点都打印出来之后，再打印它自己<br>  System.out.print(&quot;-&gt;&quot; + vertex);<br>}<br><br>&#47;&#47;<br>   int w = adj[i].get(j); &#47;&#47; i-&gt;w  这个W表示什么？<br>  inverseAdj[w].add(i); &#47;&#47; w-&gt;i 为啥是相反的邻接？这个不也是从0-i来存对应的值？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435486,"discussion_content":"i-》w表示存在一条顶点i到顶点w的有向边","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546826262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57245,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1546697417,"is_pvip":false,"replies":[{"id":"20718","content":"遍历每个顶点的链表 每个顶点的链表是独立存储的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546826179,"ip_address":"","comment_id":57245,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546697417","product_id":100017301,"comment_content":"public void topoSortByKahn() {<br>  for (int i = 0; i &lt; v; ++i) {&#47;&#47;<br>    for (int j = 0; j &lt; adj[i].size(); ++j) {<br>      int w = adj[i].get(j); &#47;&#47; i-&gt;w<br> <br>    }<br>  }<br> 为什么要用两层循环遍历，不是直接遍历链表旧可以？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435484,"discussion_content":"遍历每个顶点的链表 每个顶点的链表是独立存储的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546826179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56932,"user_name":"追风者","can_delete":false,"product_type":"c1","uid":1055092,"ip_address":"","ucode":"879BC372A6B605","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","comment_is_top":false,"comment_ctime":1546583213,"is_pvip":false,"replies":[{"id":"21842","content":"最近有点忙，晚点吧：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547708212,"ip_address":"","comment_id":56932,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546583213","product_id":100017301,"comment_content":"王老师，说好的基础篇完了就把课后思考题解析一遍呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435318,"discussion_content":"最近有点忙，晚点吧：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56865,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1546570839,"is_pvip":false,"replies":[{"id":"20540","content":"没结束呢，看看目录","user_name":"编辑回复","user_name_real":"王锦","uid":"1058895","ctime":1546583836,"ip_address":"","comment_id":56865,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1546570839","product_id":100017301,"comment_content":"还有最后两讲就结束了 剩下的时间就是不停的复习加练习了","like_count":0,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435287,"discussion_content":"没结束呢，看看目录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546583836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]}]}