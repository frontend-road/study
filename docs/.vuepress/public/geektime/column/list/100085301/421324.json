{"id":421324,"title":"14｜类型系统：有哪些必须掌握的trait？","content":"<p>你好，我是陈天。</p><p>开发软件系统时，我们弄清楚需求，要对需求进行架构上的分析和设计。在这个过程中，合理地定义和使用 trait，会让代码结构具有很好的扩展性，让系统变得非常灵活。</p><p>之前在 get hands dirty 系列中就粗略见识到了 trait 的巨大威力，使用了 From&lt;T&gt; / TryFrom&lt;T&gt; trait 进行类型间的转换（<a href=\"https://time.geekbang.org/column/article/413634\">第 5 讲</a>），还使用了 Deref trait （<a href=\"https://time.geekbang.org/column/article/414478\">第 6 讲</a>）让类型在不暴露其内部结构代码的同时，让内部结构的方法可以对外使用。</p><p>经过上两讲的学习，相信你现在对trait 的理解就深入了。在实际解决问题的过程中，<strong>用好这些 trait，会让你的代码结构更加清晰，阅读和使用都更加符合 Rust 生态的习惯</strong>。比如数据结构实现了 Debug trait，那么当你想打印数据结构时，就可以用 {:?} 来打印；如果你的数据结构实现了 From&lt;T&gt;，那么，可以直接使用 into() 方法做数据转换。</p><h2>trait</h2><p>Rust 语言的标准库定义了大量的标准 trait，来先来数已经学过的，看看攒了哪些：</p><ul>\n<li>Clone / Copy trait，约定了数据被深拷贝和浅拷贝的行为；</li>\n<li>Read / Write trait，约定了对 I/O 读写的行为；</li>\n<li>Iterator，约定了迭代器的行为；</li>\n<li>Debug，约定了数据如何被以 debug 的方式显示出来的行为；</li>\n<li>Default，约定数据类型的缺省值如何产生的行为；</li>\n<li>From&lt;T&gt; / TryFrom&lt;T&gt;，约定了数据间如何转换的行为。</li>\n</ul><!-- [[[read_end]]] --><p>我们会再学习几类重要的 trait，包括和内存分配释放相关的 trait、用于区别不同类型协助编译器做类型安全检查的标记 trait、进行类型转换的 trait、操作符相关的 trait，以及 Debug/Display/Default。</p><p>在学习这些 trait的过程中，你也可以结合之前讲的内容，有意识地思考一下Rust为什么这么设计，在增进对语言理解的同时，也能写出更加优雅的 Rust 代码。</p><h2>内存相关：Clone / Copy / Drop</h2><p>首先来看内存相关的 Clone/Copy/Drop。这三个 trait 在介绍所有权的时候已经学习过，这里我们再深入研究一下它们的定义和使用场景。</p><h3>Clone trait</h3><p>首先看 Clone：</p><pre><code class=\"language-rust\">pub trait Clone {\n  fn clone(&amp;self) -&gt; Self;\n\n  fn clone_from(&amp;mut self, source: &amp;Self) {\n    *self = source.clone()\n  }\n}\n</code></pre><p>Clone trait 有两个方法， <code>clone()</code> 和  <code>clone_from()</code> ，后者有缺省实现，所以平时我们只需要实现  <code>clone()</code> 方法即可。你也许会疑惑，这个  <code>clone_from()</code> 有什么作用呢？因为看起来  <code>a.clone_from(&amp;b)</code> ，和  <code>a = b.clone()</code> 是等价的。</p><p>其实不是，如果 a 已经存在，在 clone 过程中会分配内存，那么<strong>用  <code>a.clone_from(&amp;b)</code> 可以避免内存分配，提高效率</strong>。</p><p>Clone trait 可以通过派生宏直接实现，这样能简化不少代码。如果在你的数据结构里，每一个字段都已经实现了Clone trait，你可以用  <code>#[derive(Clone)]</code> ，看下面的<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9726c98022668f3249b711719a11bf09\">代码</a>，定义了 Developer 结构和 Language 枚举：</p><pre><code class=\"language-rust\">#[derive(Clone, Debug)]\nstruct Developer {\n  name: String,\n  age: u8,\n  lang: Language\n}\n\n#[allow(dead_code)]\n#[derive(Clone, Debug)]\nenum Language {\n  Rust,\n  TypeScript,\n  Elixir,\n  Haskell\n}\n\nfn main() {\n    let dev = Developer {\n        name: \"Tyr\".to_string(),\n        age: 18,\n        lang: Language::Rust\n    };\n    let dev1 = dev.clone();\n    println!(\"dev: {:?}, addr of dev name: {:p}\", dev, dev.name.as_str());\n    println!(\"dev1: {:?}, addr of dev1 name: {:p}\", dev1, dev1.name.as_str())\n}\n</code></pre><p>如果没有为 Language 实现 Clone 的话，Developer 的派生宏 Clone 将会编译出错。运行这段代码可以看到，对于 name，也就是 String 类型的 Clone，其堆上的内存也被 Clone 了一份，所以 Clone 是深度拷贝，栈内存和堆内存一起拷贝。</p><p>值得注意的是，clone 方法的接口是 &amp;self，这在绝大多数场合下都是适用的，我们在 clone 一个数据时只需要有已有数据的只读引用。但对 Rc&lt;T&gt; 这样在 clone() 时维护引用计数的数据结构，clone() 过程中会改变自己，所以要用 Cell&lt;T&gt; 这样提供内部可变性的结构来进行改变，如果你也有类似的需求，可以参考。</p><h3>Copy trait</h3><p>和 Clone trait 不同的是，Copy trait 没有任何额外的方法，它只是一个标记 trait（marker trait）。它的 trait 定义：</p><pre><code class=\"language-rust\">pub trait Copy: Clone {}\n</code></pre><p>所以看这个定义，如果要实现 Copy trait 的话，必须实现 Clone trait，然后实现一个空的 Copy trait。你是不是有点疑惑：这样不包含任何行为的 trait 有什么用呢？</p><p>这样的 trait <strong>虽然没有任何行为，但它可以用作 trait bound 来进行类型安全检查</strong>，所以我们管它叫<strong>标记 trait</strong>。</p><p>和 Clone 一样，如果数据结构的所有字段都实现了 Copy，也可以用  <code>#[derive(Copy)]</code> 宏来为数据结构实现 Copy。试着为 Developer 和 Language 加上 Copy：</p><pre><code class=\"language-rust\">#[derive(Clone, Copy, Debug)]\nstruct Developer {\n  name: String,\n  age: u8,\n  lang: Language\n}\n\n#[derive(Clone, Copy, Debug)]\nenum Language {\n  Rust,\n  TypeScript,\n  Elixir,\n  Haskell\n}\n</code></pre><p>这个代码会出错。因为 String 类型没有实现 Copy。 因此，Developer 数据结构只能 clone，无法 copy。我们知道，如果类型实现了 Copy，那么在赋值、函数调用的时候，值会被拷贝，否则所有权会被移动。</p><p>所以上面的代码 Developer 类型在做参数传递时，会执行 Move 语义，而 Language 会执行 Copy 语义。</p><p>在讲所有权可变/不可变引用的时候提到，不可变引用实现了 Copy，而可变引用 &amp;mut T 没有实现 Copy。为什么是这样？</p><p>因为如果可变引用实现了 Copy trait，那么生成一个可变引用然后把它赋值给另一个变量时，就会违背所有权规则：同一个作用域下只能有一个可变引用。可见，Rust 标准库在哪些结构可以 Copy、哪些不可以 Copy 上，有着仔细的考量。</p><h3>Drop trait</h3><p>在内存管理中已经详细探讨过 Drop trait。这里我们再看一下它的定义：</p><pre><code class=\"language-rust\">pub trait Drop {\n    fn drop(&amp;mut self);\n}\n</code></pre><p>大部分场景无需为数据结构提供 Drop trait，系统默认会依次对数据结构的每个域做 drop。但有两种情况你可能需要手工实现 Drop。</p><p>第一种是希望在数据结束生命周期的时候做一些事情，比如记日志。</p><p>第二种是需要对资源回收的场景。编译器并不知道你额外使用了哪些资源，也就无法帮助你 drop 它们。比如说锁资源的释放，在 MutexGuard&lt;T&gt; 中实现了 Drop 来释放锁资源：</p><pre><code class=\"language-rust\">impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {\n&nbsp; &nbsp; #[inline]\n&nbsp; &nbsp; fn drop(&amp;mut self) {\n&nbsp; &nbsp; &nbsp; &nbsp; unsafe {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.lock.poison.done(&amp;self.poison);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.lock.inner.raw_unlock();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>需要注意的是，Copy trait 和 Drop trait 是互斥的，两者不能共存，当你尝试为同一种数据类型实现 Copy 时，也实现 Drop，编译器就会报错。这其实很好理解：<strong>Copy是按位做浅拷贝，那么它会默认拷贝的数据没有需要释放的资源；而Drop恰恰是为了释放额外的资源而生的</strong>。</p><p>我们还是写一段代码来辅助理解，在代码中，强行用 Box::into_raw 获得堆内存的指针，放入 RawBuffer 结构中，这样就接管了这块堆内存的释放。</p><p>虽然 RawBuffer 可以实现 Copy trait，但这样一来就无法实现 Drop trait。如果程序非要这么写，会导致内存泄漏，因为该释放的堆内存没有释放。</p><p>但是这个操作不会破坏 Rust 的正确性保证：即便你 Copy 了 N 份 RawBuffer，由于无法实现 Drop trait，RawBuffer 指向的那同一块堆内存不会释放，所以不会出现 use after free 的内存安全问题。（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=76de1040b516b50f671c3abfe71cfb37\">代码</a>）</p><pre><code class=\"language-rust\">use std::{fmt, slice};\n\n// 注意这里，我们实现了 Copy，这是因为 *mut u8/usize 都支持 Copy\n#[derive(Clone, Copy)]\nstruct RawBuffer {\n    // 裸指针用 *const / *mut 来表述，这和引用的 &amp; 不同\n    ptr: *mut u8,\n    len: usize,\n}\n\nimpl From&lt;Vec&lt;u8&gt;&gt; for RawBuffer {\n    fn from(vec: Vec&lt;u8&gt;) -&gt; Self {\n        let slice = vec.into_boxed_slice();\n        Self {\n            len: slice.len(),\n            // into_raw 之后，Box 就不管这块内存的释放了，RawBuffer 需要处理释放\n            ptr: Box::into_raw(slice) as *mut u8,\n        }\n    }\n}\n\n// 如果 RawBuffer 实现了 Drop trait，就可以在所有者退出时释放堆内存\n// 然后，Drop trait 会跟 Copy trait 冲突，要么不实现 Copy，要么不实现 Drop\n// 如果不实现 Drop，那么就会导致内存泄漏，但它不会对正确性有任何破坏\n// 比如不会出现 use after free 这样的问题。\n// 你可以试着把下面注释去掉，看看会出什么问题\n// impl Drop for RawBuffer {\n//     #[inline]\n//     fn drop(&amp;mut self) {\n//         let data = unsafe { Box::from_raw(slice::from_raw_parts_mut(self.ptr, self.len)) };\n//         drop(data)\n//     }\n// }\n\nimpl fmt::Debug for RawBuffer {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        let data = self.as_ref();\n        write!(f, \"{:p}: {:?}\", self.ptr, data)\n    }\n}\n\nimpl AsRef&lt;[u8]&gt; for RawBuffer {\n    fn as_ref(&amp;self) -&gt; &amp;[u8] {\n        unsafe { slice::from_raw_parts(self.ptr, self.len) }\n    }\n}\n\nfn main() {\n    let data = vec![1, 2, 3, 4];\n\n    let buf: RawBuffer = data.into();\n\n    // 因为 buf 允许 Copy，所以这里 Copy 了一份\n    use_buffer(buf);\n\n    // buf 还能用\n    println!(\"buf: {:?}\", buf);\n}\n\nfn use_buffer(buf: RawBuffer) {\n    println!(\"buf to die: {:?}\", buf);\n\n    // 这里不用特意 drop，写出来只是为了说明 Copy 出来的 buf 被 Drop 了\n    drop(buf)\n}\n</code></pre><p>对于代码安全来说，内存泄漏危害大？还是 use after free 危害大呢？肯定是后者。Rust 的底线是内存安全，所以两害相权取其轻。</p><p>实际上，任何编程语言都无法保证不发生人为的内存泄漏，比如程序在运行时，开发者疏忽了，对哈希表只添加不删除，就会造成内存泄漏。但 Rust 会保证即使开发者疏忽了，也不会出现内存安全问题。</p><p>建议你仔细阅读这段代码中的注释，试着把注释掉的 Drop trait 恢复，然后再把代码改得可以编译通过，认真思考一下 Rust 这样做的良苦用心。</p><h2>标记 trait：Sized / Send / Sync / Unpin</h2><p>好，讲完内存相关的主要 trait，来看标记 trait。</p><p>刚才我们已经看到了一个标记 trait：Copy。Rust 还支持其它几种标记 trait：<a href=\"https://doc.rust-lang.org/std/marker/trait.Sized.html\">Sized</a> / <a href=\"https://doc.rust-lang.org/std/marker/trait.Send.html\">Send</a> / <a href=\"https://doc.rust-lang.org/std/marker/trait.Sync.html\">Sync</a> / <a href=\"https://doc.rust-lang.org/std/marker/trait.Unpin.html\">Unpin</a>。</p><p>Sized trait 用于标记有具体大小的类型。在使用泛型参数时，Rust 编译器会自动为泛型参数加上 Sized 约束，比如下面的 Data&lt;T&gt; 和处理 Data&lt;T&gt; 的函数 process_data：</p><pre><code class=\"language-rust\">struct Data&lt;T&gt; {\n    inner: T,\n}\n\nfn process_data&lt;T&gt;(data: Data&lt;T&gt;) {\n    todo!();\n}\n</code></pre><p>它等价于：</p><pre><code class=\"language-rust\">struct Data&lt;T: Sized&gt; {\n    inner: T,\n}\n\nfn process_data&lt;T: Sized&gt;(data: Data&lt;T&gt;) {\n    todo!();\n}\n</code></pre><p>大部分时候，我们都希望能自动添加这样的约束，因为这样定义出的泛型结构，在编译期，大小是固定的，可以作为参数传递给函数。如果没有这个约束，T 是大小不固定的类型， process_data 函数会无法编译。</p><p>但是这个自动添加的约束有时候不太适用，<strong>在少数情况下，需要 T 是可变类型的，怎么办？Rust 提供了 ?Sized 来摆脱这个约束</strong>。</p><p>如果开发者显式定义了<code>T: ?Sized</code>，那么 T 就可以是任意大小。如果你对（<a href=\"https://time.geekbang.org/column/article/420021\">第12讲</a>）之前说的 Cow 还有印象，可能会记得 Cow 中泛型参数 B 的约束是 ?Sized：</p><pre><code class=\"language-rust\">pub enum Cow&lt;'a, B: ?Sized + 'a&gt; where B: ToOwned,\n{\n    // 借用的数据\n    Borrowed(&amp;'a B),\n    // 拥有的数据\n    Owned(&lt;B as ToOwned&gt;::Owned),\n}\n</code></pre><p>这样 B 就可以是 [T] 或者 str 类型，大小都是不固定的。要注意 Borrowed(&amp;'a B) 大小是固定的，因为它内部是对 B 的一个引用，而引用的大小是固定的。</p><h3>Send / Sync</h3><p>说完了 Sized，我们再来看 Send / Sync，定义是：</p><pre><code class=\"language-rust\">pub unsafe auto trait Send {}\npub unsafe auto trait Sync {}\n</code></pre><p>这两个 trait 都是 unsafe auto trait，auto 意味着编译器会在合适的场合，自动为数据结构添加它们的实现，而 unsafe 代表实现的这个 trait 可能会违背 Rust 的内存安全准则，如果开发者手工实现这两个 trait ，要自己为它们的安全性负责。</p><p>Send/Sync 是 Rust 并发安全的基础：</p><ul>\n<li>如果一个类型 T 实现了 Send trait，意味着 T 可以安全地从一个线程移动到另一个线程，也就是说所有权可以在线程间移动。</li>\n<li>如果一个类型 T 实现了 Sync trait，则意味着 &amp;T 可以安全地在多个线程中共享。一个类型 T 满足 Sync trait，当且仅当 &amp;T 满足 Send trait。</li>\n</ul><p>对于 Send/Sync 在线程安全中的作用，可以这么看，<strong>如果一个类型T: Send，那么 T 在某个线程中的独占访问是线程安全的；如果一个类型 T: Sync，那么 T 在线程间的只读共享是安全的</strong>。</p><p>对于我们自己定义的数据结构，如果其内部的所有域都实现了 Send / Sync，那么这个数据结构会被自动添加 Send / Sync 。基本上原生数据结构都支持 Send / Sync，也就是说，绝大多数自定义的数据结构都是满足 Send / Sync 的。标准库中，不支持 Send / Sync 的数据结构主要有：</p><ul>\n<li>裸指针 *const T / *mut T。它们是不安全的，所以既不是 Send 也不是 Sync。</li>\n<li>UnsafeCell&lt;T&gt; 不支持 Sync。也就是说，任何使用了 Cell 或者 RefCell 的数据结构不支持 Sync。</li>\n<li>引用计数 Rc 不支持 Send 也不支持 Sync。所以 Rc 无法跨线程。</li>\n</ul><p>之前介绍过 Rc / RefCell（<a href=\"https://time.geekbang.org/column/article/416722\">第9讲</a>），我们来看看，如果尝试跨线程使用 Rc / RefCell，会发生什么。在 Rust 下，如果想创建一个新的线程，需要使用 <a href=\"https://doc.rust-lang.org/std/thread/fn.spawn.html\">std::thread::spawn</a>：</p><pre><code class=\"language-rust\">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; \nwhere\n    F: FnOnce() -&gt; T,\n    F: Send + 'static,\n    T: Send + 'static,\n</code></pre><p>它的参数是一个闭包（后面会讲），这个闭包需要 Send + 'static：</p><ul>\n<li>'static 意思是闭包捕获的自由变量必须是一个拥有所有权的类型，或者是一个拥有静态生命周期的引用；</li>\n<li>Send 意思是，这些被捕获自由变量的所有权可以从一个线程移动到另一个线程。</li>\n</ul><p>从这个接口上，可以得出结论：如果在线程间传递 Rc，是无法编译通过的，因为 <a href=\"https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-Send\">Rc 的实现不支持 Send 和 Sync</a>。写段代码验证一下（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9892c9cd4baa26dcfcca99e4e4869cc5\">代码</a>）：</p><pre><code class=\"language-rust\">// Rc 既不是 Send，也不是 Sync\nfn rc_is_not_send_and_sync() {\n    let a = Rc::new(1);\n    let b = a.clone();\n    let c = a.clone();\n    thread::spawn(move || {\n        println!(\"c= {:?}\", c);\n    });\n}\n</code></pre><p>果然，这段代码不通过。<br>\n<img src=\"https://static001.geekbang.org/resource/image/13/e6/131b21c05850e8f5070d952a777613e6.jpg?wh=2667x1268\" alt=\"\"></p><p>那么，RefCell&lt;T&gt; 可以在线程间转移所有权么？<a href=\"https://doc.rust-lang.org/std/cell/struct.RefCell.html#impl-Send\">RefCell 实现了 Send，但没有实现 Sync</a>，所以，看起来是可以工作的（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1a820a1bd4eca214956e85a1333e5df0\">代码</a>）：</p><pre><code class=\"language-rust\">fn refcell_is_send() {\n    let a = RefCell::new(1);\n    thread::spawn(move || {\n        println!(\"a= {:?}\", a);\n    });\n}\n</code></pre><p>验证一下发现，这是 OK 的。</p><p>既然 Rc 不能 Send，我们无法跨线程使用 Rc&lt;RefCell&lt;T&gt;&gt; 这样的数据，那么使用<a href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-Send\">支持 Send/Sync 的 Arc</a>呢，使用 Arc&lt;RefCell&lt;T&gt;&gt; 来获得，一个可以在多线程间共享，且可以修改的类型，可以么（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=16b78ecc207cbae4a511a316681ad49e\">代码</a>）？</p><pre><code class=\"language-rust\">// RefCell 现在有多个 Arc 持有它，虽然 Arc 是 Send/Sync，但 RefCell 不是 Sync\nfn refcell_is_not_sync() {\n    let a = Arc::new(RefCell::new(1));\n    let b = a.clone();\n    let c = a.clone();\n    thread::spawn(move || {\n        println!(\"c= {:?}\", c);\n    });\n}\n</code></pre><p>不可以。</p><p>因为 Arc 内部的数据是共享的，需要支持 Sync 的数据结构，但是RefCell 不是 Sync，编译失败。所以在多线程情况下，我们只能使用支持 Send/Sync 的 Arc ，和 Mutex 一起，构造一个可以在多线程间共享且可以修改的类型（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e20084ea53dbd030e3f75ce0b07b6421\">代码</a>）：</p><pre><code class=\"language-rust\">use std::{\n    sync::{Arc, Mutex},\n    thread,\n};\n\n// Arc&lt;Mutex&lt;T&gt;&gt; 可以多线程共享且修改数据\nfn arc_mutext_is_send_sync() {\n    let a = Arc::new(Mutex::new(1));\n    let b = a.clone();\n    let c = a.clone();\n    let handle = thread::spawn(move || {\n        let mut g = c.lock().unwrap();\n        *g += 1;\n    });\n\n    {\n        let mut g = b.lock().unwrap();\n        *g += 1;\n    }\n\n    handle.join().unwrap();\n    println!(\"a= {:?}\", a);\n}\n\nfn main() {\n    arc_mutext_is_send_sync();\n}\n</code></pre><p>这几段代码建议你都好好阅读和运行一下，对于编译出错的情况，仔细看看编译器给出的错误，会帮助你理解好 Send/Sync trait 以及它们如何保证并发安全。</p><p>最后一个标记 trait Unpin，是用于自引用类型的，在后面讲到 Future trait 时，再详细讲这个 trait。</p><h2>类型转换相关：From&lt;T&gt; / Into&lt;T&gt;/AsRef&lt;T&gt; / AsMut&lt;T&gt;</h2><p>好，学完了标记 trait，来看看和类型转换相关的 trait。在软件开发的过程中，我们经常需要在某个上下文中，把一种数据结构转换成另一种数据结构。</p><p>不过转换有很多方式，看下面的代码，你觉得哪种方式更好呢？</p><pre><code class=\"language-rust\">// 第一种方法，为每一种转换提供一个方法\n// 把字符串 s 转换成 Path\nlet v = s.to_path();\n// 把字符串 s 转换成 u64\nlet v = s.to_u64();\n\n// 第二种方法，为 s 和要转换的类型之间实现一个 Into&lt;T&gt; trait\n// v 的类型根据上下文得出\nlet v = s.into();\n// 或者也可以显式地标注 v 的类型\nlet v: u64 = s.into();\n</code></pre><p>第一种方式，在类型 T 的实现里，要为每一种可能的转换提供一个方法；第二种，我们为类型 T 和类型 U 之间的转换实现一个数据转换 trait，这样可以用同一个方法来实现不同的转换。</p><p>显然，第二种方法要更好，因为它符合软件开发的开闭原则（Open-Close Principle），“<strong>软件中的对象（类、模块、函数等等）对扩展是开放的，但是对修改是封闭的</strong>”。</p><p>在第一种方式下，未来每次要添加对新类型的转换，都要重新修改类型 T 的实现，而第二种方式，我们只需要添加一个对于数据转换 trait 的新实现即可。</p><p>基于这个思路，对值类型的转换和对引用类型的转换，Rust 提供了两套不同的 trait：</p><ul>\n<li>值类型到值类型的转换：From&lt;T&gt; / Into&lt;T&gt; / TryFrom&lt;T&gt; / TryInto&lt;T&gt;</li>\n<li>引用类型到引用类型的转换：AsRef&lt;T&gt; / AsMut&lt;T&gt;</li>\n</ul><h3>From&lt;T&gt; / Into&lt;T&gt;</h3><p>先看 <a href=\"https://doc.rust-lang.org/std/convert/trait.From.html\">From&lt;T&gt;</a> 和 <a href=\"https://doc.rust-lang.org/std/convert/trait.Into.html\">Into&lt;T&gt;</a>。这两个 trait 的定义如下：</p><pre><code class=\"language-rust\">pub trait From&lt;T&gt; {\n    fn from(T) -&gt; Self;\n}\n\npub trait Into&lt;T&gt; {\n    fn into(self) -&gt; T;\n}\n</code></pre><p>在实现 From&lt;T&gt; 的时候会自动实现 Into&lt;T&gt;。这是因为：</p><pre><code class=\"language-rust\">// 实现 From 会自动实现 Into\nimpl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {\n    fn into(self) -&gt; U {\n        U::from(self)\n    }\n}\n</code></pre><p>所以大部分情况下，只用实现 From&lt;T&gt;，然后这两种方式都能做数据转换，比如：</p><pre><code class=\"language-rust\">let s = String::from(\"Hello world!\");\nlet s: String = \"Hello world!\".into();\n</code></pre><p>这两种方式是等价的，怎么选呢？From&lt;T&gt; 可以根据上下文做类型推导，使用场景更多；而且因为实现了 From&lt;T&gt; 会自动实现 Into&lt;T&gt;，反之不会。<strong>所以需要的时候，不要去实现 Into&lt;T&gt;，只要实现 From&lt;T&gt; 就好了</strong>。</p><p>此外，From&lt;T&gt; 和 Into&lt;T&gt; 还是自反的：把类型 T 的值转换成类型 T，会直接返回。这是因为标准库有如下的实现：</p><pre><code class=\"language-rust\">// From（以及 Into）是自反的\nimpl&lt;T&gt; From&lt;T&gt; for T {\n    fn from(t: T) -&gt; T {\n        t\n    }\n}\n</code></pre><p>有了 From&lt;T&gt; 和 Into&lt;T&gt;，很多函数的接口就可以变得灵活，比如函数如果接受一个 IpAddr 为参数，我们可以使用 Into&lt;IpAddr&gt; 让更多的类型可以被这个函数使用，看下面的<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f8be081138a8bb2c736e30badcc5ae41\">代码</a>：</p><pre><code class=\"language-rust\">use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n\nfn print(v: impl Into&lt;IpAddr&gt;) {\n    println!(\"{:?}\", v.into());\n}\n\nfn main() {\n    let v4: Ipv4Addr = \"2.2.2.2\".parse().unwrap();\n    let v6: Ipv6Addr = \"::1\".parse().unwrap();\n    \n    // IPAddr 实现了 From&lt;[u8; 4]，转换 IPv4 地址\n    print([1, 1, 1, 1]);\n    // IPAddr 实现了 From&lt;[u16; 8]，转换 IPv6 地址\n    print([0xfe80, 0, 0, 0, 0xaede, 0x48ff, 0xfe00, 0x1122]);\n    // IPAddr 实现了 From&lt;Ipv4Addr&gt;\n    print(v4);\n    // IPAddr 实现了 From&lt;Ipv6Addr&gt;\n    print(v6);\n}\n</code></pre><p>所以，合理地使用 From&lt;T&gt; / Into&lt;T&gt;，可以让代码变得简洁，符合 Rust 可读性强的风格，更符合开闭原则。</p><p>注意，如果你的数据类型在转换过程中有可能出现错误，可以使用 <a href=\"https://doc.rust-lang.org/std/convert/trait.TryFrom.html\">TryFrom&lt;T&gt;</a> 和 <a href=\"https://doc.rust-lang.org/std/convert/trait.TryInto.html\">TryInto&lt;T&gt;</a>，它们的用法和 From&lt;T&gt; / Into&lt;T&gt; 一样，只是 trait 内多了一个关联类型 Error，且返回的结果是 Result&lt;T, Self::Error&gt;。</p><h3>AsRef&lt;T&gt; / AsMut&lt;T&gt;</h3><p>搞明白了 From&lt;T&gt; / Into&lt;T&gt; 后，AsRef&lt;T&gt; 和 AsMut&lt;T&gt; 就很好理解了，用于从引用到引用的转换。还是先看它们的定义：</p><pre><code class=\"language-rust\">pub trait AsRef&lt;T&gt; where T: ?Sized {\n    fn as_ref(&amp;self) -&gt; &amp;T;\n}\n\npub trait AsMut&lt;T&gt; where T: ?Sized {\n    fn as_mut(&amp;mut self) -&gt; &amp;mut T;\n}\n</code></pre><p>在 trait 的定义上，都允许 T 使用大小可变的类型，如 str、[u8] 等。AsMut&lt;T&gt; 除了使用可变引用生成可变引用外，其它都和 AsRef&lt;T&gt; 一样，所以我们重点看 AsRef&lt;T&gt;。</p><p>看标准库中打开文件的接口 <a href=\"https://doc.rust-lang.org/std/fs/struct.File.html#method.open\">std::fs::File::open</a>：</p><pre><code class=\"language-rust\">pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;File&gt;\n</code></pre><p>它的参数 path 是符合 AsRef&lt;Path&gt; 的类型，所以，你可以为这个参数传入 String、&amp;str、PathBuf、Path 等类型。而且，当你使用 path.as_ref() 时，会得到一个 &amp;Path。</p><p>来写一段代码体验一下 AsRef&lt;T&gt; 的使用和实现（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=176092de75680a60821d6523e6340773\">代码</a>）：</p><pre><code class=\"language-rust\">#[allow(dead_code)]\nenum Language {\n    Rust,\n    TypeScript,\n    Elixir,\n    Haskell,\n}\n\nimpl AsRef&lt;str&gt; for Language {\n    fn as_ref(&amp;self) -&gt; &amp;str {\n        match self {\n            Language::Rust =&gt; \"Rust\",\n            Language::TypeScript =&gt; \"TypeScript\",\n            Language::Elixir =&gt; \"Elixir\",\n            Language::Haskell =&gt; \"Haskell\",\n        }\n    }\n}\n\nfn print_ref(v: impl AsRef&lt;str&gt;) {\n    println!(\"{}\", v.as_ref());\n}\n\nfn main() {\n    let lang = Language::Rust;\n    // &amp;str 实现了 AsRef&lt;str&gt;\n    print_ref(\"Hello world!\");\n    // String 实现了 AsRef&lt;str&gt;\n    print_ref(\"Hello world!\".to_string());\n    // 我们自己定义的 enum 也实现了 AsRef&lt;str&gt;\n    print_ref(lang);\n}\n</code></pre><p>现在对在 Rust 下，如何使用 From / Into / AsRef / AsMut 进行类型间转换，有了深入了解，未来我们还会在实战中使用到这些 trait。</p><p>刚才的小例子中要额外说明一下的是，如果你的代码出现 v.as_ref().clone() 这样的语句，也就是说你要对 v 进行引用转换，然后又得到了拥有所有权的值，那么你应该实现 From&lt;T&gt;，然后做 v.into()。</p><h2>操作符相关：Deref / DerefMut</h2><p>操作符相关的 trait ，上一讲我们已经看到了 Add&lt;Rhs&gt; trait，它允许你重载加法运算符。Rust 为所有的运算符都提供了 trait，你可以为自己的类型重载某些操作符。这里用下图简单概括一下，更详细的信息你可以阅读<a href=\"https://doc.rust-lang.org/std/ops/index.html\">官方文档</a>。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/19/a28619aae702e186aa115af94300dc19.jpg?wh=2743x1515\" alt=\"\"></p><p>今天重点要介绍的操作符是 <a href=\"https://doc.rust-lang.org/std/ops/trait.Deref.html\">Deref</a> 和 <a href=\"https://doc.rust-lang.org/std/ops/trait.DerefMut.html\">DerefMut</a>。来看它们的定义：</p><pre><code class=\"language-rust\">pub trait Deref {\n    // 解引用出来的结果类型\n    type Target: ?Sized;\n    fn deref(&amp;self) -&gt; &amp;Self::Target;\n}\n\npub trait DerefMut: Deref {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;\n}\n</code></pre><p>可以看到，DerefMut “继承”了 Deref，只是它额外提供了一个 deref_mut 方法，用来获取可变的解引用。所以这里重点学习 Deref。</p><p>对于普通的引用，解引用很直观，因为它只有一个指向值的地址，从这个地址可以获取到所需要的值，比如下面的例子：</p><pre><code class=\"language-rust\">let mut x = 42;\nlet y = &amp;mut x;\n// 解引用，内部调用 DerefMut（其实现就是 *self）\n*y += 1;\n</code></pre><p>但对智能指针来说，拿什么域来解引用就不那么直观了，我们来看之前学过的 Rc 是怎么实现 Deref 的：</p><pre><code class=\"language-rust\">impl&lt;T: ?Sized&gt; Deref for Rc&lt;T&gt; {\n    type Target = T;\n\n    fn deref(&amp;self) -&gt; &amp;T {\n        &amp;self.inner().value\n    }\n}\n</code></pre><p>可以看到，它最终指向了堆上的 RcBox 内部的 value 的地址，然后如果对其解引用的话，得到了 value 对应的值。以下图为例，最终打印出 v = 1。<br>\n<img src=\"https://static001.geekbang.org/resource/image/50/d1/5068f84af27d696f6a062c5a2f43f4d1.jpg?wh=2755x1487\" alt=\"\"></p><p>从图中还可以看到，Deref 和 DerefMut 是自动调用的，*b 会被展开为 *(b.deref())。</p><p>在 Rust 里，绝大多数智能指针都实现了 Deref，我们也可以为自己的数据结构实现 Deref。看一个例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=084d38d49c6b29d6074a2c4570551601\">代码</a>）：</p><pre><code class=\"language-rust\">use std::ops::{Deref, DerefMut};\n\n#[derive(Debug)]\nstruct Buffer&lt;T&gt;(Vec&lt;T&gt;);\n\nimpl&lt;T&gt; Buffer&lt;T&gt; {\n    pub fn new(v: impl Into&lt;Vec&lt;T&gt;&gt;) -&gt; Self {\n        Self(v.into())\n    }\n}\n\nimpl&lt;T&gt; Deref for Buffer&lt;T&gt; {\n    type Target = [T];\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\n        &amp;self.0\n    }\n}\n\nimpl&lt;T&gt; DerefMut for Buffer&lt;T&gt; {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {\n        &amp;mut self.0\n    }\n}\n\nfn main() {\n    let mut buf = Buffer::new([1, 3, 2, 4]);\n    // 因为实现了 Deref 和 DerefMut，这里 buf 可以直接访问 Vec&lt;T&gt; 的方法\n    // 下面这句相当于：(&amp;mut buf).deref_mut().sort()，也就是 (&amp;mut buf.0).sort()\n    buf.sort();\n    println!(\"buf: {:?}\", buf);\n}\n</code></pre><p>但是在这个例子里，数据结构 Buffer&lt;T&gt; 包裹住了 Vec&lt;T&gt;，但这样一来，原本 Vec&lt;T&gt; 实现了的很多方法，现在使用起来就很不方便，需要用 buf.0 来访问。怎么办？</p><p><strong>可以实现 Deref 和 DerefMut，这样在解引用的时候，直接访问到 buf.0</strong>，省去了代码的啰嗦和数据结构内部字段的隐藏。</p><p>在这段代码里，还有一个值得注意的地方：写 buf.sort() 的时候，并没有做解引用的操作，为什么会相当于访问了 buf.0.sort() 呢？这是因为 sort() 方法第一个参数是 &amp;mut self，此时 Rust 编译器会强制做 Deref/DerefMut 的解引用，所以这相当于 (*(&amp;mut buf)).sort()。</p><h2>其它：Debug / Display / Default</h2><p>现在我们对运算符相关的 trait 有了足够的了解，最后来看看其它一些常用的 trait：<a href=\"https://doc.rust-lang.org/std/fmt/trait.Debug.html\">Debug</a> / <a href=\"https://doc.rust-lang.org/std/fmt/trait.Display.html\">Display</a> / <a href=\"https://doc.rust-lang.org/std/default/trait.Default.html\">Default</a>。</p><p>先看 Debug / Display，它们的定义如下：</p><pre><code class=\"language-rust\">pub trait Debug {\n    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;\n}\n\npub trait Display {\n    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;\n}\n</code></pre><p>可以看到，Debug 和 Display 两个 trait 的签名一样，都接受一个 &amp;self 和一个 &amp;mut Formatter。那为什么要有两个一样的 trait 呢？</p><p>这是因为<strong> Debug 是为开发者调试打印数据结构所设计的，而 Display 是给用户显示数据结构所设计的</strong>。这也是为什么 Debug trait 的实现可以通过派生宏直接生成，而 Display 必须手工实现。在使用的时候，Debug 用 {:?} 来打印，Display 用 {} 打印。</p><p>最后看 Default trait。它的定义如下：</p><pre><code class=\"language-rust\">pub trait Default {\n    fn default() -&gt; Self;\n}\n</code></pre><p>Default trait 用于为类型提供缺省值。它也可以通过 derive 宏 #[derive(Default)] 来生成实现，前提是类型中的每个字段都实现了 Default trait。在初始化一个数据结构时，我们可以部分初始化，然后剩余的部分使用 Default::default()。</p><p>Debug/Display/Default 如何使用，统一看个例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=77bdb7c373ad7762bf0e3c2081c96719\">代码</a>）：</p><pre><code class=\"language-rust\">use std::fmt;\n// struct 可以 derive Default，但我们需要所有字段都实现了 Default\n#[derive(Clone, Debug, Default)]\nstruct Developer {\n    name: String,\n    age: u8,\n    lang: Language,\n}\n\n// enum 不能 derive Default\n#[allow(dead_code)]\n#[derive(Clone, Debug)]\nenum Language {\n    Rust,\n    TypeScript,\n    Elixir,\n    Haskell,\n}\n\n// 手工实现 Default\nimpl Default for Language {\n    fn default() -&gt; Self {\n        Language::Rust\n    }\n}\n\nimpl Developer {\n    pub fn new(name: &amp;str) -&gt; Self {\n        // 用 ..Default::default() 为剩余字段使用缺省值\n        Self {\n            name: name.to_owned(),\n            ..Default::default()\n        }\n    }\n}\n\nimpl fmt::Display for Developer {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(\n            f,\n            \"{}({} years old): {:?} developer\",\n            self.name, self.age, self.lang\n        )\n    }\n}\n\nfn main() {\n    // 使用 T::default()\n    let dev1 = Developer::default();\n    // 使用 Default::default()，但此时类型无法通过上下文推断，需要提供类型\n    let dev2: Developer = Default::default();\n    // 使用 T::new\n    let dev3 = Developer::new(\"Tyr\");\n    println!(\"dev1: {}\\\\ndev2: {}\\\\ndev3: {:?}\", dev1, dev2, dev3);\n}\n</code></pre><p>它们实现起来非常简单，你可以看文中的代码。</p><h2>小结</h2><p>今天介绍了内存管理、类型转换、操作符、数据显示等相关的基本 trait，还介绍了标记 trait，它是一种特殊的 trait，主要是用于协助编译器检查类型安全。<br>\n<img src=\"https://static001.geekbang.org/resource/image/c4/5e/c40e3efef2bec9140c95054547958a5e.jpg?wh=2743x1765\" alt=\"\"></p><p>在我们使用 Rust 开发时，trait 占据了非常核心的地位。<strong>一个设计良好的 trait 可以大大提升整个系统的可用性和扩展性</strong>。</p><p>很多优秀的第三方库，都围绕着 trait 展开它们的能力，比如上一讲提到的 tower-service 中的 <a href=\"https://docs.rs/tower-service/0.3.1/tower_service/trait.Service.html\">Service trait</a>，再比如你日后可能会经常使用到的 parser combinator 库 <a href=\"https://docs.rs/nom/6.2.1/nom/\">nom</a> 的 <a href=\"https://docs.rs/nom/6.2.1/nom/trait.Parser.html\">Parser trait</a>。</p><p>因为 trait 实现了延迟绑定。不知道你是否还记得，之前串讲编程基础概念的时候，就谈到了延迟绑定。在软件开发中，延迟绑定会带来极大的灵活性。</p><p>从数据的角度看，数据结构是具体数据的延迟绑定，泛型结构是具体数据结构的延迟绑定；从代码的角度看，函数是一组实现某个功能的表达式的延迟绑定，泛型函数是函数的延迟绑定。那么 trait 是什么的延迟绑定呢？</p><p><strong>trait 是行为的延迟绑定</strong>。我们可以在不知道具体要处理什么数据结构的前提下，先通过 trait 把系统的很多行为约定好。这也是为什么开头解释标准trait时，频繁用到了“约定……行为”。</p><p>相信通过今天的学习，你能对 trait 有更深刻的认识，在撰写自己的数据类型时，就能根据需要实现这些 trait。</p><h3>思考题</h3><p>1.Vec&lt;T&gt; 可以实现 Copy trait 么？为什么？<br>\n2.在使用 Arc&lt;Mutex&lt;T&gt;&gt; 时，为什么下面这段代码可以直接使用 shared.lock()？</p><pre><code class=\"language-rust\">use std::sync::{Arc, Mutex};\nlet shared = Arc::new(Mutex::new(1));\nlet mut g = shared.lock().unwrap();\n*g += 1;\n</code></pre><p>3.有余力的同学可以尝试一下，为下面的 List&lt;T&gt; 类型实现 Index，使得所有的测试都能通过。这段代码使用了 std::collections::LinkedList，你可以参考<a href=\"https://doc.rust-lang.org/std/collections/linked_list/struct.LinkedList.html\">官方文档</a>阅读它支持的方法（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c7ddd7b647ef42753cc86a2a86e5a753\">代码</a>）：</p><pre><code class=\"language-rust\">use std::{\n    collections::LinkedList,\n    ops::{Deref, DerefMut, Index},\n};\nstruct List&lt;T&gt;(LinkedList&lt;T&gt;);\n\nimpl&lt;T&gt; Deref for List&lt;T&gt; {\n    type Target = LinkedList&lt;T&gt;;\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\n        &amp;self.0\n    }\n}\n\nimpl&lt;T&gt; DerefMut for List&lt;T&gt; {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {\n        &amp;mut self.0\n    }\n}\n\nimpl&lt;T&gt; Default for List&lt;T&gt; {\n    fn default() -&gt; Self {\n        Self(Default::default())\n    }\n}\n\nimpl&lt;T&gt; Index&lt;isize&gt; for List&lt;T&gt; {\n    type Output = T;\n\n    fn index(&amp;self, index: isize) -&gt; &amp;Self::Output {\n        todo!();\n    }\n}\n\n#[test]\nfn it_works() {\n    let mut list: List&lt;u32&gt; = List::default();\n    for i in 0..16 {\n        list.push_back(i);\n    }\n\n    assert_eq!(list[0], 0);\n    assert_eq!(list[5], 5);\n    assert_eq!(list[15], 15);\n    assert_eq!(list[16], 0);\n    assert_eq!(list[-1], 15);\n    assert_eq!(list[128], 0);\n    assert_eq!(list[-128], 0);\n}\n</code></pre><p>今天你已经完成了Rust学习的第14次打卡，坚持学习，如果你觉得有收获，也欢迎分享给身边的朋友，邀TA一起讨论。我们下节课见～</p>","comments":[{"had_liked":false,"id":313647,"user_name":"记事本","can_delete":false,"product_type":"c1","uid":1401568,"ip_address":"","ucode":"FA942636EE0CC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","comment_is_top":false,"comment_ctime":1632579499,"is_pvip":false,"replies":[{"id":"113743","content":"谢谢夸奖！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632798694,"ip_address":"","comment_id":313647,"utype":1}],"discussion_count":1,"race_medal":0,"score":"100416827307","product_id":100085301,"comment_content":"老师，你讲得太通透，太详细了，太负责任了，全网最好的教程了","like_count":24,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527423,"discussion_content":"谢谢夸奖！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632798694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313529,"user_name":"c4f","can_delete":false,"product_type":"c1","uid":2637246,"ip_address":"","ucode":"F0F542BBABCB37","user_header":"https://static001.geekbang.org/account/avatar/00/28/3d/be/98bebd57.jpg","comment_is_top":false,"comment_ctime":1632475498,"is_pvip":false,"replies":[{"id":"113583","content":"很棒！<br><br>对于 3，你可以看我的参考代码：<br><br>```Rust<br>impl&lt;T&gt; Index&lt;isize&gt; for List&lt;T&gt; {<br>    type Output = T;<br><br>    fn index(&amp;self, index: isize) -&gt; &amp;Self::Output {<br>        let len = self.len() as isize;<br>        &#47;&#47; 我们需要先对负数，以及 index 超出范围的数字进行处理<br>        &#47;&#47; 使其落在 0..len 之间<br>        let n = (len + index % len) % len;<br>        let iter = self.iter();<br>        &#47;&#47; 由于 n 一定小于 len 所以这里可以 skip n 取 next<br>        &#47;&#47; 此时一定有值，所以可以放心 unwrap<br>        iter.skip(n as usize).next().unwrap()<br>    }<br>}<br>```<br><br>playground: https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9f354aaed64c4b97f3b80c3be9c4b59a","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632528931,"ip_address":"","comment_id":313529,"utype":1}],"discussion_count":3,"race_medal":0,"score":"61762017642","product_id":100085301,"comment_content":"1. 不行。因为 Vec 和 Copy 都不是用户自己 crate 中定义的，所以根据孤儿原则无法为 Vec 实现 Copy trait<br><br>2. 因为 Arc 实现了 Deref 和 DerefMut trait，解应用可以直接访问内部的 Mutex<br><br>3. 实现的时候遇到了一个问题：对于非法的 index （比如测试用例中的 128）该如何返回，没找到解决方法于是只针对 List&lt;u32&gt; 实现了 Index trait，这样在遇到非法 index 时返回 &amp;0 即可。<br>针对 Vec 测试了一下非法 index 的情形，发现会直接终止进程。具体代码如下<br><br>```rust<br>fn index(&amp;self, index: isize) -&gt; &amp;Self::Output {<br>    &#47;&#47; todo!();<br>    if let Some(idx_abs) = <br>        if index &gt;= 0 {<br>            Some(index as usize)<br>        } else {<br>            self.len().checked_sub(index.abs() as usize)<br>        } {<br>        let mut iter = self.iter();<br>        for _i in 0..idx_abs {<br>            iter.next();<br>        }<br>        iter.next().unwrap_or(&amp;0)<br>    } else {<br>        &amp;0<br>    }<br>}<br>```<br><br>","like_count":15,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527378,"discussion_content":"很棒！\n\n对于 3，你可以看我的参考代码：\n\n```Rust\nimpl&amp;lt;T&amp;gt; Index&amp;lt;isize&amp;gt; for List&amp;lt;T&amp;gt; {\n    type Output = T;\n\n    fn index(&amp;amp;self, index: isize) -&amp;gt; &amp;amp;Self::Output {\n        let len = self.len() as isize;\n        // 我们需要先对负数，以及 index 超出范围的数字进行处理\n        // 使其落在 0..len 之间\n        let n = (len + index % len) % len;\n        let iter = self.iter();\n        // 由于 n 一定小于 len 所以这里可以 skip n 取 next\n        // 此时一定有值，所以可以放心 unwrap\n        iter.skip(n as usize).next().unwrap()\n    }\n}\n```\n\nplayground: https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=9f354aaed64c4b97f3b80c3be9c4b59a","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632528931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1149798,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8b/66/2b55a7ac.jpg","nickname":"周","note":"","ucode":"E4D57FF40B355A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":563919,"discussion_content":"老师，iter.skip().next() 为什么链式可以不需要mut 我换个写法 let b = iter.skip(); b.next().unwrap(),编译器会要求b是mut的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650111599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":527378,"ip_address":""},"score":563919,"extra":""}]},{"author":{"id":1158959,"avatar":"https://static001.geekbang.org/account/avatar/00/11/af/2f/2e0d9d92.jpg","nickname":"阿文","note":"","ucode":"A67F91C7CCE4C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397987,"discussion_content":"还有skip？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632711107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313898,"user_name":"noisyes","can_delete":false,"product_type":"c1","uid":2538540,"ip_address":"","ucode":"94EC310B284AD2","user_header":"https://static001.geekbang.org/account/avatar/00/26/bc/2c/963688bb.jpg","comment_is_top":false,"comment_ctime":1632731123,"is_pvip":false,"replies":[{"id":"113714","content":"就是如果你获得某个类型T 到其它类型的引用 U，然后又把这个引用 U clone 出一个 U 的带所有权的数据。那么为何不直接实现 From&lt;T&gt; for U 呢？","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632792071,"ip_address":"","comment_id":313898,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40287436787","product_id":100085301,"comment_content":"刚才的小例子中要额外说明一下的是，如果你的代码出现 v.as_ref().clone() 这样的语句，也就是说你要对 v 进行引用转换，然后又得到了拥有所有权的值，那么你应该实现 From，然后做 v.into()。  这句话怎么理解呀","like_count":10,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527511,"discussion_content":"就是如果你获得某个类型T 到其它类型的引用 U，然后又把这个引用 U clone 出一个 U 的带所有权的数据。那么为何不直接实现 From&amp;lt;T&amp;gt; for U 呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632792071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321946,"user_name":"彭亚伦","can_delete":false,"product_type":"c1","uid":2425378,"ip_address":"","ucode":"77A32C73A23F72","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/22/19585900.jpg","comment_is_top":false,"comment_ctime":1637114574,"is_pvip":true,"replies":[{"id":"116957","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1637161904,"ip_address":"","comment_id":321946,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14522016462","product_id":100085301,"comment_content":"第3题, 同样使用标准库的2个方法, `checked_rem_euclid`取得合理索引值, `iter().nth()`获得实际值<br>```rust<br>use std::{<br>    collections::LinkedList,<br>    ops::{Deref, DerefMut, Index},<br>};<br>struct List&lt;T&gt;(LinkedList&lt;T&gt;);<br><br>impl&lt;T&gt; Deref for List&lt;T&gt; {<br>    type Target = LinkedList&lt;T&gt;;<br><br>    fn deref(&amp;self) -&gt; &amp;Self::Target {<br>        &amp;self.0<br>    }<br>}<br><br>impl&lt;T&gt; DerefMut for List&lt;T&gt; {<br>    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {<br>        &amp;mut self.0<br>    }<br>}<br><br>impl&lt;T&gt; Default for List&lt;T&gt; {<br>    fn default() -&gt; Self {<br>        Self(Default::default())<br>    }<br>}<br><br>impl&lt;T&gt; Index&lt;isize&gt; for List&lt;T&gt; {<br>    type Output = T;<br><br>    fn index(&amp;self, index: isize) -&gt; &amp;Self::Output {<br>        let len = self.0.len();<br>        &#47;&#47;标准库的checked_rem_euclid方法, 如果len=0 则返回None<br>        &#47;&#47;这里直接把i进行unwrap, 如果链表长度不为0, 则i一定在0..len范围内, 可以放心使用, <br>        &#47;&#47;如果长度为零, 意味这对一个空链表进行索引, 那么我panic应该也是合情合理的吧<br>        let i = (index as usize).checked_rem_euclid(len).unwrap();<br>        &amp;self.0.iter().nth(i).unwrap()<br>    }<br>}<br><br>#[test]<br>fn it_works() {<br>    let mut list: List&lt;u32&gt; = List::default();<br>    for i in 0..16 {<br>        list.push_back(i);<br>    }<br><br>    assert_eq!(list[0], 0);<br>    assert_eq!(list[5], 5);<br>    assert_eq!(list[15], 15);<br>    assert_eq!(list[16], 0);<br>    assert_eq!(list[-1], 15);<br>    assert_eq!(list[128], 0);<br>    assert_eq!(list[-128], 0);<br>}<br>```<br><br>playground 链接:  https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=73b4129f1a6608892691da92d501ba15","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530883,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637161904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532972,"discussion_content":"你的错误在于把 isize 强制转成了 usize。这个过程，比如 -1 就会加 usize::MAX 变成 -1 + usize::MAX。而 size::MAX 刚好是 vec 长度 16 的整数倍，因此这个转变过程并没有改变余数的结果，因而并没有影响测试用例的通过。上面的 demo 中，我把 vec 的长度改成了 15，就可以看到测试失败了。\n\n不过受你启发，我知道了 rem_euclid 这个东西。那么，我想这才是最简洁的实现：\nlet i = index.checked_rem_euclid(self.len() as isize).expect(&#34;divided by 0 or results are overflow&#34;);\nself.iter().nth(i as usize).unwrap()\n\n这里举例说明一下 div/rem 和 div_euclid/rem_enclid 的区别：\n-7 除以 4。\n如果是 div，就是 -1 * 4 - 3 = -7 ，得到商为 -1，余数为 -3。\n而如果是 div_euclid，余数必须为正或者0，就是 -2 * 4 + 1 = -7（-1 个 4 不够把 -7 变成正或者0，所以需要 -2 个 4），这样得到商为 -2，余数为 1。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1637744745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532964,"discussion_content":"然而你的实现是错误的：\nhttps://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=71ad296a7ca319487021937bc5624478\n\n建议老师补充测试用例……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637742120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318606,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1635347252,"is_pvip":false,"replies":[{"id":"116576","content":"1. * 代表解引用，&amp;是获取变量引用（地址）<br>2. trait &quot;继承&quot; 是打引号的继承，只是 trait A &quot;继承&quot; trait B  的方法（和关联类型），是行为的继承，也是一种组合，和面向对象继承的概念是不一样的，它们之间并无数据的继承，也没有类别继承的关系。<br>3. unwrap() 在示例代码中会常常用到，我在之前的内容中介绍过这样会导致 panic，在生产环境中的代码除非你在上下文中确保它不会 panic，否则不宜使用。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636642236,"ip_address":"","comment_id":318606,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10225281844","product_id":100085301,"comment_content":"老师，这里有一些概念没搞清晰。<br>1. * 这个符号，有时表示解引用，有时表示获取变量地址的值，对吗？有点搞混场景了。<br>2. trait继承这里，经常看到一句话，组合优于继承，怎么理解。同时对于实现和继承来说，可能基础不扎实，一直没理解好什么时候继承什么时候实现，学java的时候，那些抽象类和接口也迷糊的很。<br><br>另外这里隐藏了很多东西，看老师代码的时候经常用unwrap，其实生产环境代码是非常危险的。例如今天写hashmap替换里面内容时，最好用containkeys判断一下，如果没有则插入一个空的，再使用get_mut和unwarp，这样就保证安全不会panic了。","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529312,"discussion_content":"1. * 代表解引用，&amp;amp;是获取变量引用（地址）\n2. trait &amp;quot;继承&amp;quot; 是打引号的继承，只是 trait A &amp;quot;继承&amp;quot; trait B  的方法（和关联类型），是行为的继承，也是一种组合，和面向对象继承的概念是不一样的，它们之间并无数据的继承，也没有类别继承的关系。\n3. unwrap() 在示例代码中会常常用到，我在之前的内容中介绍过这样会导致 panic，在生产环境中的代码除非你在上下文中确保它不会 panic，否则不宜使用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636642236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315075,"user_name":"周烨","can_delete":false,"product_type":"c1","uid":1355560,"ip_address":"","ucode":"6DAE79E4966CEF","user_header":"https://static001.geekbang.org/account/avatar/00/14/af/28/cc69ea4b.jpg","comment_is_top":false,"comment_ctime":1633680628,"is_pvip":false,"replies":[{"id":"114161","content":"正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633812197,"ip_address":"","comment_id":315075,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10223615220","product_id":100085301,"comment_content":"1. 不能，因为不能确定T是否实现了Copy trait。<br>2. 因为Arc实现了Deref trait<br>3. ```impl&lt;T&gt; Index&lt;isize&gt; for List&lt;T&gt; {<br>    type Output = T;<br><br>    fn index(&amp;self, index: isize) -&gt; &amp;Self::Output {<br>        let len = self.len() as isize;<br>        let i = if index % len &gt;= 0 {<br>                index % len<br>            } else {<br>                len + index % len<br>            } as usize;<br>        let it = self.iter();<br>        return it.skip(i).next().unwrap();<br>    }<br>}```","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527866,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633812197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1828290,"avatar":"","nickname":"ilookers","note":"","ucode":"CAD6557DAC946D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":549763,"discussion_content":"针对问题1的回答，应该不够准确。比如下面这段代码，已知 Vec&lt;T&gt; 中 T 类型的情况下（比如 u8），编译器会提示错误：`Derive macro generating an impl of the trait Copy`。\n\n```rust\n#[derive(Copy)]\nstruct Buffer(Vec&lt;u8&gt;);\n```\n\n我这么理解的，Vec&lt;T&gt;不能实现 Copy trait 的原因： Vec&lt;T&gt; 是一个分配在堆上的空间，所以不能实现 Copy trait。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644229530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":527866,"ip_address":""},"score":549763,"extra":""}]},{"author":{"id":2254917,"avatar":"https://static001.geekbang.org/account/avatar/00/22/68/45/ddf89612.jpg","nickname":"bestgopher","note":"","ucode":"D89735C8CA9C6E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575001,"discussion_content":"正确？难道不是vec的数据在堆上，或者说实现了Drop，因此不能实现Copy吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654518181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313707,"user_name":"夏洛克Moriaty","can_delete":false,"product_type":"c1","uid":2754785,"ip_address":"","ucode":"49BA020F04AB16","user_header":"https://static001.geekbang.org/account/avatar/00/2a/08/e1/b4748943.jpg","comment_is_top":false,"comment_ctime":1632625686,"is_pvip":false,"replies":[{"id":"113728","content":"区别是：<br><br>let a = &amp;*list;<br>let b = list.deref();<br>&#47;&#47; a == b<br><br>注意看 deref 的返回值。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632797467,"ip_address":"","comment_id":313707,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5927592982","product_id":100085301,"comment_content":"let a = *list;<br>let b  = list.deref();<br><br>老师请问下这两种方式有什么区别，为什么a和b的类型不同？","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527445,"discussion_content":"区别是：\n\nlet a = &amp;amp;*list;\nlet b = list.deref();\n// a == b\n\n注意看 deref 的返回值。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632797467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1401568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","nickname":"记事本","note":"","ucode":"FA942636EE0CC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397599,"discussion_content":"list 等于*list,自动解引用，这是智能指针的语法糖","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632650067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2754785,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/08/e1/b4748943.jpg","nickname":"夏洛克Moriaty","note":"","ucode":"49BA020F04AB16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397979,"discussion_content":"// let a = *list;\nlet a = *(list.deref()); // a在rust底层实际上运行的代码\nlet b = list.deref();\n\n懂了，编译器做的事情真多。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632710032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313692,"user_name":"Taozi","can_delete":false,"product_type":"c1","uid":1021926,"ip_address":"","ucode":"DD6567A31B3E33","user_header":"","comment_is_top":false,"comment_ctime":1632621819,"is_pvip":false,"replies":[{"id":"113729","content":"DerefMut 依赖 Deref，也就是说要实现 DerefMut 必须县实现 Deref，所以 Target 就复用了。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632797523,"ip_address":"","comment_id":313692,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5927589115","product_id":100085301,"comment_content":"第三题里面给List&lt;T&gt;实现DerefMut时，为什么不需要加type Target = LinkedList，那返回的Self::Target是什么。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527442,"discussion_content":"DerefMut 依赖 Deref，也就是说要实现 DerefMut 必须县实现 Deref，所以 Target 就复用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632797523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2754785,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/08/e1/b4748943.jpg","nickname":"夏洛克Moriaty","note":"","ucode":"49BA020F04AB16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397982,"discussion_content":"在 Rust 中，一个 trait 可以“继承”另一个 trait 的关联类型和关联函数。\n\nDerefMut继承了Deref，所以继承了它的关联类型，它的Target就是LinkedList。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632710357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1021926,"avatar":"","nickname":"Taozi","note":"","ucode":"DD6567A31B3E33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2754785,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/08/e1/b4748943.jpg","nickname":"夏洛克Moriaty","note":"","ucode":"49BA020F04AB16","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398030,"discussion_content":"多谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632719289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":397982,"ip_address":""},"score":398030,"extra":""}]}]},{"had_liked":false,"id":313682,"user_name":"0@1","can_delete":false,"product_type":"c1","uid":1549191,"ip_address":"","ucode":"932A4139DB8169","user_header":"https://static001.geekbang.org/account/avatar/00/17/a3/87/eb923eb3.jpg","comment_is_top":false,"comment_ctime":1632620854,"is_pvip":false,"replies":[{"id":"113754","content":"这里没有额外的 secret，forget 和 ManuallyDrop::new() 不同的地方是一个有返回值，一个没有返回值。文档中的例子也是使用这一点的不同来表示它们不同的使用场景的。你可以再仔细看看两个例子调用 forget 和 ManuallyDrop::new() 的位置的不同，想想为什么使用 forget 不能一开始就调用。:) ","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632799689,"ip_address":"","comment_id":313682,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5927588150","product_id":100085301,"comment_content":"老师，想提前问下unsafe相关的问题，这个目前比较困扰我进一步学习Rust.<br>比如这个 std::mem::forget(t), 看了下源码，是直接调用 ManuallyDrop::new(t), 看文档，好像这2个又不是直接等价的。forget的源码如下，多了些属性宏修饰，编译器是不是多加了处理，从而跟直接调用 ManuallyDrop::new(t)起到的效果不一样？<br><br>如果是的话，这些宏的文档在哪里可以看到，类似的这些编译器处理的宏有哪些，他们的文档在哪里，谢谢。<br>Note: 我学rust陆续2年了，看源码时对这些需要编译器额外处理的东西比较困惑，不知道如何去进一步的理解他们, rust中很多隐含规则貌似都有他们的影子。<br>#[inline]<br>#[rustc_const_stable(feature = &quot;const_forget&quot;, since = &quot;1.46.0&quot;)]<br>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]<br>#[cfg_attr(not(test), rustc_diagnostic_item = &quot;mem_forget&quot;)]<br>pub const fn forget&lt;T&gt;(t: T) {<br>    let _ = ManuallyDrop::new(t);<br>}<br><br><br><br><br>","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527435,"discussion_content":"这里没有额外的 secret，forget 和 ManuallyDrop::new() 不同的地方是一个有返回值，一个没有返回值。文档中的例子也是使用这一点的不同来表示它们不同的使用场景的。你可以再仔细看看两个例子调用 forget 和 ManuallyDrop::new() 的位置的不同，想想为什么使用 forget 不能一开始就调用。:) ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632799689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532932,"discussion_content":"例子里说得很清楚啊……\nlet mut v = vec![65, 122];\nlet s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\nmem::forget(v);\nassert_eq!(s, &#34;Az&#34;);\n使用 forget 需要 consume 掉数据，因此必须先构建 s 再 forget v。这样是内存不安全的。如果构建 s 之后 forget(v) 之前 panic 了，会 double free 那一块内存（v 和 s 的 destructor 都会运行）。\n\nlet v = vec![65, 122];\nlet mut v = ManuallyDrop::new(v);\nlet (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\nlet s = unsafe { String::from_raw_parts(ptr, len, cap) };\nassert_eq!(s, &#34;Az&#34;);\n而使用 ManuallyDrop 则先下手为强，完全避免了 v 的 destructor 的执行，所以就算中间 panic 了，也挺多就是内存泄漏而已，不会有 double free 的情况发生。\n\n综上，日常应该偏向使用 ManuallyDrop。至于 forget 独有的应用场景，我不知道。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637734585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344893,"user_name":"flyflypeng","can_delete":false,"product_type":"c1","uid":1224113,"ip_address":"","ucode":"7A40FC08D8ACC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/ad/b1/2e96794c.jpg","comment_is_top":false,"comment_ctime":1651838781,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651838781","product_id":100085301,"comment_content":"老师，我按照最直接的逻辑来处理，很纠结如何才能返回一个T类型的默认值。参考老师的答案，我觉得对于输入的index值映射到0~len-1区间内，不是很符合预期的逻辑，可能对于不再区间范围内的，我们可能会返回错误，或者返回一个默认值<br>impl&lt;T&gt; Index&lt;isize&gt; for List&lt;T&gt; {<br>    type Output = T;<br><br>    fn index(&amp;self, index: isize) -&gt; &amp;Self::Output {<br>        if index &lt; 0 {<br>            &#47;&#47; 返回默认值的引用<br>        }<br><br>        for (i, item) in self.0.iter().enumerate() {<br>            if i == index as usize {<br>                return item;<br>            }<br>        }<br><br>        &#47;&#47;返回默认值引用<br>    }<br>}","like_count":0},{"had_liked":false,"id":344799,"user_name":"flyflypeng","can_delete":false,"product_type":"c1","uid":1224113,"ip_address":"","ucode":"7A40FC08D8ACC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/ad/b1/2e96794c.jpg","comment_is_top":false,"comment_ctime":1651798818,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651798818","product_id":100085301,"comment_content":"老师，我对于文中关于copy和clone的区别还不是很理解？不知道什么时候该用copy trait，什么时候用clone trait？","like_count":0},{"had_liked":false,"id":344111,"user_name":"鹅帮逮","can_delete":false,"product_type":"c1","uid":2755534,"ip_address":"","ucode":"A6DB1BEFDA5D9A","user_header":"https://static001.geekbang.org/account/avatar/00/2a/0b/ce/f0c520d1.jpg","comment_is_top":false,"comment_ctime":1651248262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651248262","product_id":100085301,"comment_content":"所以上面的代码 Developer 类型在做参数传递时，会执行 Move 语义，而 Language 会执行 Copy 语义。<br>这句话怎么理解呢？为什么Language 不执行move","like_count":0},{"had_liked":false,"id":343414,"user_name":"Koco","can_delete":false,"product_type":"c1","uid":2394662,"ip_address":"","ucode":"AEBF53EFBA8BE5","user_header":"https://static001.geekbang.org/account/avatar/00/24/8a/26/2e2f9cfc.jpg","comment_is_top":false,"comment_ctime":1650842588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650842588","product_id":100085301,"comment_content":"into_xxx()会新增一个Into_xxx trait，虽然不优雅，但是没有“修改”已有的模块，应该没有违反开闭原则吧？<br><br>Into的设计体现了声明式编程（declarative programming) 的思想，就像spring的DI一样，声明类型就能得到对应的bean。","like_count":0},{"had_liked":false,"id":343314,"user_name":"Koco","can_delete":false,"product_type":"c1","uid":2394662,"ip_address":"","ucode":"AEBF53EFBA8BE5","user_header":"https://static001.geekbang.org/account/avatar/00/24/8a/26/2e2f9cfc.jpg","comment_is_top":false,"comment_ctime":1650777630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650777630","product_id":100085301,"comment_content":"大部分教程都跟字典似的，罗列知识点，枯燥难啃。这教程讲得太好了，一边学一边忍不住赞叹。高屋建瓴，提纲挈领，深入浅出。不仅有术——结构化的知识，还有道——计算机语言的学习方法。陈老师太牛了。","like_count":1},{"had_liked":false,"id":342402,"user_name":"lwshang","can_delete":false,"product_type":"c1","uid":1483392,"ip_address":"","ucode":"9194A3CB628D40","user_header":"https://static001.geekbang.org/account/avatar/00/16/a2/80/c2086557.jpg","comment_is_top":false,"comment_ctime":1650250260,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1650250260","product_id":100085301,"comment_content":"第三题可以利用无符号整数运算来简化。另外，空列表也需要额外的处理。<br>```rust<br>fn index(&amp;self, index: isize) -&gt; &amp;Self::Output {<br>    let len = self.0.len();<br>    if len == 0 {<br>        panic!(&quot;attempt to index empty list&quot;);<br>    }<br>    let offset = (index as usize) % len;<br>    &#47;&#47; above line guarantees that `offset` is within the range<br>    &#47;&#47; then `.nth(offset)` will always return `Some`<br>    &#47;&#47; so it is safe to `unwrap()`<br>    self.0.iter().nth(offset).unwrap()<br>}<br>```<br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=fa3b1dd7c0f5eb222a29c0856e51b545","like_count":0,"discussions":[{"author":{"id":1544345,"avatar":"https://static001.geekbang.org/account/avatar/00/17/90/99/d03ef0d4.jpg","nickname":"newbmiao","note":"","ucode":"1BDD0341C490FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574048,"discussion_content":"有个问题： (index as usize) % len 并不等价于 （len + index % len）% len","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653812451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339588,"user_name":"欢乐马","can_delete":false,"product_type":"c1","uid":2231216,"ip_address":"","ucode":"F0A951D94B2AED","user_header":"https://static001.geekbang.org/account/avatar/00/22/0b/b0/9d413c8a.jpg","comment_is_top":false,"comment_ctime":1648205199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648205199","product_id":100085301,"comment_content":"非常精彩！个人认为有一个小问题：讲Sized trait时，您提到<br><br>  &quot;在少数情况下，需要 T 是可变类型的，...&quot;<br><br>我理解这里是想说<br><br>  &quot;在少数情况下， 需要允许T是**可变大小**的类型，...&quot;<br><br>对不？ 我个人认为说T是“可变类型的”，显得有点含混：T本身就是范型参数，可&quot;变&quot;为各种具体类型。这里显然不是讲这个，不熟反省的初学者可能会有点困惑。","like_count":0},{"had_liked":false,"id":333876,"user_name":"Isaac.","can_delete":false,"product_type":"c1","uid":1101264,"ip_address":"","ucode":"C4856E35365963","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/d0/8d3dc9ef.jpg","comment_is_top":false,"comment_ctime":1644568494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644568494","product_id":100085301,"comment_content":"Performs copy-assignment from source.<br><br>a.clone_from(&amp;b) is equivalent to a = b.clone() in functionality, but can be overridden to reuse the resources of a to avoid unnecessary allocations.<br><br>老师，官方文档没说 clone_from 默认实现可以避免内存分配，而是可以通过被重写实现。这里如何证明确实有避免内存分配呢","like_count":0},{"had_liked":false,"id":329246,"user_name":"GE","can_delete":false,"product_type":"c1","uid":2773127,"ip_address":"","ucode":"A916BA2792FC0F","user_header":"https://static001.geekbang.org/account/avatar/00/2a/50/87/a6637d48.jpg","comment_is_top":false,"comment_ctime":1641256916,"is_pvip":false,"replies":[{"id":"120744","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642307703,"ip_address":"","comment_id":329246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641256916","product_id":100085301,"comment_content":"1. 不能，但是这里和T关系无关，而是因为Vec本身已经实现了Drop trait，所以和Copy trait是冲突的<br>```<br>&#47;&#47; source code<br>unsafe impl&lt;#[may_dangle] T, A: Allocator&gt; Drop for Vec&lt;T, A&gt;<br>```<br><br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546382,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642307703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325685,"user_name":"james","can_delete":false,"product_type":"c1","uid":1047569,"ip_address":"","ucode":"EF807B11AF0B05","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/11/677b83ba.jpg","comment_is_top":false,"comment_ctime":1639098473,"is_pvip":false,"replies":[{"id":"118822","content":"self.value 不是 &amp;Self.Target 啊，self.value 在拿 Self.Target，也就是说，会做 move。以下代码会报错，如果你把 get_inner(&amp;self) 换成 get_inner(self)，就可以：<br><br>```rust<br>struct Container {<br>    inner: String,<br>}<br><br>impl Container {<br>    pub fn get_inner(&amp;self) -&gt; String {<br>        self.inner<br>    }<br>}<br>```","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639805626,"ip_address":"","comment_id":325685,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639098473","product_id":100085301,"comment_content":"向老师请教一个问题：在如下Deref范例中，既然deref的self变量是&amp;Self类型，那self.value的类型应该就是&amp;Self.Target，但汉服返回时为何还要在self.value前加&amp;呢？<br><br>use std::ops::Deref;<br><br>struct DerefExample&lt;T&gt; {<br>    value: T<br>}<br>impl&lt;T&gt; Deref for DerefExample&lt;T&gt; {<br>    type Target = T;<br><br>    fn deref(&amp;self) -&gt; &amp;Self::Target {<br>        &amp;self.value<br>    }<br>}<br><br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539698,"discussion_content":"self.value 不是 &amp;Self.Target 啊，self.value 在拿 Self.Target，也就是说，会做 move。以下代码会报错，如果你把 get_inner(&amp;self) 换成 get_inner(self)，就可以：\n\n```rust\nstruct Container {\n    inner: String,\n}\n\nimpl Container {\n    pub fn get_inner(&amp;self) -&gt; String {\n        self.inner\n    }\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639805626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323127,"user_name":"作死的卡基","can_delete":false,"product_type":"c1","uid":1236784,"ip_address":"","ucode":"AC4DFF32FA9CC5","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/30/338409a9.jpg","comment_is_top":false,"comment_ctime":1637737033,"is_pvip":false,"replies":[{"id":"118890","content":"首先 Rust 没有类的概念，也没有继承的概念。在 drop 实现的时候，你只需要关心你需要进行的对资源的额外处理（比如维护计数什么的）。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639850693,"ip_address":"","comment_id":323127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637737033","product_id":100085301,"comment_content":"想请教一下老师，比如要自己实现 Drop trait，有没有类似 Java 中子类覆写父类方法的机制，甚至覆写时还能用super.xxx()还能调用父类的被覆写方法。还是只能自己新建一个 trait？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539851,"discussion_content":"首先 Rust 没有类的概念，也没有继承的概念。在 drop 实现的时候，你只需要关心你需要进行的对资源的额外处理（比如维护计数什么的）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639850693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323111,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1637732868,"is_pvip":false,"replies":[{"id":"118894","content":"👍 也可以看看我在 github repo 下的答案","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639850753,"ip_address":"","comment_id":323111,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637732868","product_id":100085301,"comment_content":"impl&lt;T&gt; Index&lt;isize&gt; for List&lt;T&gt; {<br>    type Output = T;<br><br>    fn index(&amp;self, index: isize) -&gt; &amp;Self::Output {<br>        let len = self.len() as isize;<br>        if len == 0 {<br>            panic!(&quot;empty list&quot;);<br>        }<br>        let index = (index % len + len) % len;<br>        self.iter().nth(index as usize).unwrap()<br>    }<br>}<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539855,"discussion_content":"👍 也可以看看我在 github repo 下的答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639850753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322524,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1637463421,"is_pvip":false,"replies":[{"id":"118903","content":"不需要额外的内存分配了","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639851858,"ip_address":"","comment_id":322524,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1637463421","product_id":100085301,"comment_content":"clone_from 这里说提高效率的，没看出来区别到底在哪里，源码里面也是直接 clone的？解释也没看懂，多谢了。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539864,"discussion_content":"不需要额外的内存分配了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639851858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2755534,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/0b/ce/f0c520d1.jpg","nickname":"鹅帮逮","note":"","ucode":"A6DB1BEFDA5D9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568918,"discussion_content":"https://www.jianshu.com/p/9570dec6a0cf","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651248168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532870,"discussion_content":"可以看我补充的笔记……虽然我也不知道理解得对不对……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637723612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322085,"user_name":"三叶虫tlb","can_delete":false,"product_type":"c1","uid":1010499,"ip_address":"","ucode":"A8236974932E6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/43/b6bcab56.jpg","comment_is_top":false,"comment_ctime":1637160906,"is_pvip":false,"replies":[{"id":"118911","content":"对，如果你的 struct 使用的是匿名的字段","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639852267,"ip_address":"","comment_id":322085,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637160906","product_id":100085301,"comment_content":"&amp;self.0，0是指下标第一个属性的意思吗？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539872,"discussion_content":"对，如果你的 struct 使用的是匿名的字段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639852267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532872,"discussion_content":"0 指 tuple/tuple struct 的 第一个字段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637723783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318608,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1635347601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635347601","product_id":100085301,"comment_content":"老师，这一节的内容，建议可以考虑采用嵌套一些json数据结构解析的方式来讲解一下到底那些接口有什么作用，例如对hashmap的多层嵌套，可以通过get_mut来实现修改，不要通过get方法。当然这个只是一个例子哈。","like_count":0},{"had_liked":false,"id":317425,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1634793714,"is_pvip":false,"replies":[{"id":"115238","content":"慢慢来","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635121846,"ip_address":"","comment_id":317425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634793714","product_id":100085301,"comment_content":"打个卡，这一节内容有点多，断断续续多了好几遍才读完","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528811,"discussion_content":"慢慢来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635121846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314532,"user_name":"qgaye","can_delete":false,"product_type":"c1","uid":1702112,"ip_address":"","ucode":"E817609D4ED2D6","user_header":"https://static001.geekbang.org/account/avatar/00/19/f8/e0/d6e3cc8f.jpg","comment_is_top":false,"comment_ctime":1633179850,"is_pvip":false,"replies":[{"id":"113968","content":"请仔细看文章，我写的是是 vec![1, 2, 3, 4]。<br><br>https:&#47;&#47;doc.rust-lang.org&#47;std&#47;macro.vec.html","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633320093,"ip_address":"","comment_id":314532,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633179850","product_id":100085301,"comment_content":"请教老师，为啥 [1, 2, 3, 4] 是 impl Into&lt;Vec&lt;T&gt;&gt; 这个类型呢","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527714,"discussion_content":"请仔细看文章，我写的是是 vec![1, 2, 3, 4]。\n\nhttps://doc.rust-lang.org/std/macro.vec.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633320093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314172,"user_name":"xl000","can_delete":false,"product_type":"c1","uid":1117935,"ip_address":"","ucode":"6FEABE7F7D0DC0","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/ef/030e6d27.jpg","comment_is_top":false,"comment_ctime":1632885513,"is_pvip":false,"replies":[{"id":"113981","content":"嗯，不错。用 let n = (len + index % len) % len; 更简洁些。且对一个长度为 10 的 list，能够正确处理 list[-65536]。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633321979,"ip_address":"","comment_id":314172,"utype":1}],"discussion_count":1,"race_medal":5,"score":"1632885513","product_id":100085301,"comment_content":"```rust<br>impl&lt;T&gt; Index&lt;isize&gt; for List&lt;T&gt; {<br>    type Output = T;<br><br>    fn index(&amp;self, index: isize) -&gt; &amp;Self::Output {<br>        let len = self.len() as isize;<br>        let mut n = if index &lt; 0 { len + index } else { index };<br>        if n &gt;= len || n &lt; 0 {<br>            n = 0;<br>        }<br>        self.iter().nth(n as usize).unwrap()<br>    }<br>}<br>```","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527598,"discussion_content":"嗯，不错。用 let n = (len + index % len) % len; 更简洁些。且对一个长度为 10 的 list，能够正确处理 list[-65536]。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633321979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313645,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1632578974,"is_pvip":false,"replies":[{"id":"113751","content":"没明白你的问题。我是想说，内存泄漏不会导致程序崩溃，不会让程序的行为出现问题；而 use after free 会导致程序出现预期外的行为。从这个角度来讲防止 use after free 这样的安全性问题更重要。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632799198,"ip_address":"","comment_id":313645,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1632578974","product_id":100085301,"comment_content":"&quot;实际上，任何编程语言都无法保证不发生人为的内存泄漏，比如程序在运行时，开发者疏忽了，对哈希表只添加不删除，就会造成内存泄漏。但 Rust 会保证即使开发者疏忽了，也不会出现内存安全问题。&quot;，Rust 可以保证对哈希表只添加，不删除，还不会有内存泄漏吗？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527422,"discussion_content":"没明白你的问题。我是想说，内存泄漏不会导致程序崩溃，不会让程序的行为出现问题；而 use after free 会导致程序出现预期外的行为。从这个角度来讲防止 use after free 这样的安全性问题更重要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632799198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313548,"user_name":"芥末小龙","can_delete":false,"product_type":"c1","uid":1176417,"ip_address":"","ucode":"387D01880867AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/61/8f7fca5b.jpg","comment_is_top":false,"comment_ctime":1632489166,"is_pvip":false,"replies":[{"id":"113750","content":"非常棒！<br><br>2. Arc  实现了 Deref，但没有实现 DerefMut 哦。Arc 是不允许 mut 的。<br>","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632799062,"ip_address":"","comment_id":313548,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1632489166","product_id":100085301,"comment_content":"1.Box、Vec等好像不具备Copy属性类型。所以不行，<br>2.Arc 实现了 Deref 和 DerefMut trait<br>3.直接上第三题，用的笨方法。<br>impl&lt;T&gt; Index&lt;isize&gt; for List&lt;T&gt; {<br>    type Output = T;<br><br>    fn index(&amp;self, index: isize) -&gt; &amp;Self::Output {<br>        match (self.0.len().checked_sub(index.abs() as usize)) &gt; Some(0) {<br>            false =&gt; return self.0.iter().next().unwrap(),<br>            true =&gt; {<br>                let mut i = 0;<br>                let mut iter = self.0.iter();<br>                loop {<br>                    if i == index &amp;&amp; index &gt;= 0 {<br>                        return iter.next().unwrap();<br>                    }<br>                    if index &lt; 0 &amp;&amp; i == index + self.0.len() as isize {<br>                        return iter.next().unwrap();<br>                    }<br>                    iter.next();<br>                    i = i + 1;<br>                }<br>            }<br>        };<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527386,"discussion_content":"非常棒！\n\n2. Arc  实现了 Deref，但没有实现 DerefMut 哦。Arc 是不允许 mut 的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632799062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1401568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","nickname":"记事本","note":"","ucode":"FA942636EE0CC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397155,"discussion_content":"真棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632572190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}