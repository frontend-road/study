{"id":532651,"title":"40 | 如何在编译期遍历数据？","content":"<p>你好，我是吴咏炜。</p><p>你考虑过 <code>tuple</code> 和普通的结构体存在哪些区别吗？</p><p>显然，一个字段没有名字，一个字段有名字——这是一个非常基本的区别。</p><p>其他还有吗？</p><p>有。</p><p>对于 <code>tuple</code>，标准 C++ 里提供了很多机制，允许你：</p><ul>\n<li>知道 <code>tuple</code> 的大小（数据成员数量）</li>\n<li>通过一个编译期的索引值，知道某个数据成员的类型</li>\n<li>通过一个编译期的索引值，对某个数据成员进行访问</li>\n</ul><p>利用这些信息，我们可以额外做很多事情，比如，像<a href=\"https://time.geekbang.org/column/article/523170\">第 38 讲</a>描述的那样，用一个函数模板来输出所有 <code>tuple</code> 类型对象的内容。这些功能是普通结构体所没有的！</p><p>在 C++ 的静态反射到来之前，我们想在结构体里达到类似的功能，只能自己通过一些编程技巧来实现。本讲我们就会介绍一种手工实现静态反射的方法，能够让结构体在用起来跟原来没感觉有区别的情况下，额外提供类似 <code>tuple</code> 的功能，甚至还更多。毕竟，结构体里的字段是有名字的，可以产生更可读的代码。我们还能进一步利用编译期的字符串模板参数技巧（<a href=\"https://time.geekbang.org/column/article/527423\">第 39 讲</a>），使用字段名称这一数据，让下面的代码能通过编译：</p><pre><code class=\"language-cpp\">DEFINE_STRUCT(\n  S1,\n  (int)v1,\n  (bool)v2,\n  (string)msg\n);\n\nDEFINE_STRUCT(\n  S2,\n  (long)v1,\n  (bool)v2\n);\n\nS1 s1{1, false, \"test\"};\nS2 s2;\ncopy_same_name_fields(s1, s2);\n</code></pre><!-- [[[read_end]]] --><p>这段代码做的事情正是你看名字可以想象的，把 <code>s1</code> 中跟 <code>s2</code> 同名的字段复制到 <code>s2</code> 里面去！（注意这不是 <code>memcpy</code>——两个结构体里同名字段的类型可以不同，它们也不需要相邻。）</p><h2>静态反射的定义</h2><p>静态反射的基本原理和实现手法，在罗能的博客文章中已经有了较详细的描述 <span class=\"orange\">[1]</span>。建议你去读一下。我在这里将不再重复其中的一些技术细节，而是强调基本原理，以及我这边实现得不一样的地方。</p><h3>宏基础</h3><p>文件 metamacro.h 中提供了一些基础的宏工具，这边我简单介绍一下其中主要的几个功能，对其实现细节就不进行展开了：</p><ul>\n<li><code>GET_ARG_COUNT</code>：获取宏参数的数量，如 <code>GET_ARG_COUNT(a, b, c)</code> 将得到 <code>3</code></li>\n<li><code>STRING</code>：把参数变成字符串，如 <code>STRING(foo)</code> 将得到 <code>\"foo\"</code></li>\n<li><code>PASTE</code>：把两个参数拼接起来，如 <code>PASTE(Hello, World)</code> 将得到 <code>HelloWorld</code></li>\n<li><code>PAIR</code>：把 <code>(类型)字段名</code> 这样的序列脱去第一层括号，如 <code>PAIR((long)v1)</code> 将得到 <code>long v1</code></li>\n<li><code>STRIP</code>：把 <code>(类型)字段名</code> 这样的序列的类型部分去掉，如 <code>STRIP((long)v1)</code> 将得到 <code>v1</code></li>\n<li><code>REPEAT_ON</code>：这是主要玩重复展开的地方，如 <code>REPEAT_ON(func, a, b, c)</code> 将得到 <code>func(0, a) func(1, b) func(2, c)</code></li>\n</ul><p>我们对 <code>DEFINE_STRUCT</code> 的定义如下所示：</p><pre><code class=\"language-cpp\">#define DEFINE_STRUCT(st, ...)      \\\n  struct st {                       \\\n    template &lt;typename, size_t&gt;     \\\n    struct _field;                  \\\n    static constexpr size_t _size = \\\n      GET_ARG_COUNT(__VA_ARGS__);   \\\n    REPEAT_ON(FIELD, __VA_ARGS__)   \\\n  }\n</code></pre><p>可以看到，宏展开后成了 <code>struct st</code> 的定义（<code>st</code> 是结构体名），里面有三部分：</p><ul>\n<li>首先，我们声明了一个叫 <code>_field</code> 的嵌套类模板，指定它具有两个参数，一个类型，一个是 <code>size_t</code>；</li>\n<li>然后，我们根据参数数量，算出字段数量，赋给静态 constexpr 变量 <code>_size</code>；</li>\n<li>最后，我们利用 <code>REPEAT_ON</code> 宏，有多少个字段就重复多少次，逐项产生字段的定义。</li>\n</ul><p>以我们上面的 <code>S2</code> 为例，宏展开后的结果大致如下（已重新格式化；另注意分号是宏外面手工添加的）：</p><pre><code class=\"language-cpp\">struct S2 {\n  template &lt;typename, size_t&gt;\n  struct _field;\n  static constexpr size_t _size = 2;\n  FIELD(0, (long)v1)\n  FIELD(1, (bool)v2)\n}\n</code></pre><p>下面，我们主要就不再关心宏的问题，而是如何在给定索引值的情况下，合适地产生静态反射所需要的全部信息和方法。</p><p>不过，先提醒一下，如果你把宏放到一个供别人使用的公共库的话，一般所有的宏名称都应该加上前缀，以免跟其他宏发生冲突——毕竟宏是没有作用域的，会污染全局名空间。比如，Boost.Test 里的测试宏叫 <code>BOOST_CHECK</code> 或类似的名字，而不是简单的 <code>CHECK</code>。我这边出于讲解上的简洁，基本不用名空间和前缀，但不等于你在项目里也应该这样做：像 <code>PASTE</code>、<code>STRING</code> 这样的宏还是非常容易产生冲突的。</p><p>如果你使用 MSVC 的话，还有一个额外的问题是 MSVC 的传统预处理方式不符合 C++ 标准，无法正确处理这些宏。你需要启用命令行选项 <code>/Zc:preprocessor</code> 才行 <span class=\"orange\">[2]</span>。</p><h3>字段的定义</h3><p>给定了字段索引、字段类型和字段名称，我们通常需要生成下面这些信息，来方便通过索引使用它们：</p><ul>\n<li>字段名称</li>\n<li>字段类型</li>\n<li>字段值的访问</li>\n</ul><p>我们下面需要考虑的，就是（假设）给定了索引值 <code>0</code>、字段内容 <code>(long)v1</code>，如何来生成字段的定义。</p><p>字段名称看起来最好办：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nstruct _field&lt;T, 0&gt; {\n  static constexpr auto name =\n    STRING(STRIP((long)v1));\n  …\n};\n</code></pre><p>对 <code>(long)v1</code> 进行 <code>STRIP</code> 后，我们得到 <code>v1</code>；再对其 <code>STRING</code> 处理，即得到字符串 <code>\"v1\"</code>。</p><p>字段类型也不复杂。唯一的麻烦是我没找到宏处理的方法从 <code>(long)v1</code> 得到 <code>long</code>。当然，我们并不一定需要采用 <code>(long)v1</code> 这种写法，写成 <code>(long, v1)</code> 这样就没这种麻烦了。只不过，从可读性的角度，字段定义成 <code>(long)v1</code> 更接近 C/C++ 的现有语法，确实比 <code>(long, v1)</code> 看起来要直观得多，也能更自然地处理类型之中带逗号的情况（如 <code>array&lt;int, 4&gt;</code>）。我觉得罗能的这个选择非常棒。</p><p>因此，我们这里采取绕弯的方式，定义为：</p><pre><code class=\"language-cpp\">  using type =\n    decltype(decay_t&lt;T&gt;::STRIP((long)v1));\n</code></pre><p>换句话说：</p><pre><code class=\"language-cpp\">  using type = decltype(S2::v1);\n</code></pre><p>为什么要把 <code>T</code> 作为参数传进来，还要使用 <code>decay_t</code> 呢？因为我们允许 <code>T</code> 是 <code>S2&amp;</code>、<code>const S2&amp;</code>、<code>S2&amp;&amp;</code> 等多种情况（顺便说一句，如果能用 C++20 的话，那 <code>remove_cvref_t</code> 是个更好的选择）。在字段值的访问时我们就需要用上这种灵活性了：</p><pre><code class=\"language-cpp\">  T&amp;&amp; obj_;\n  _field(T&amp;&amp; obj)\n    : obj_(forward&lt;T&gt;(obj)) {}\n  auto value() -&gt; decltype(auto)\n  {\n    return (forward&lt;T&gt;(obj_).v1);\n  }\n</code></pre><p>这里的另外一个小细节是，返回表达式上的括号是必需的。返回值类型为 <code>decltype(auto)</code>，意味着我们使用 <code>decltype(返回表达式)</code> 作为返回值类型：使用 <code>decltype(obj_.v1)</code> 我们会得到 <code>long</code>，而使用 <code>decltype((obj_.v1))</code> 我们才会得到 <code>long&amp;</code>（或 <code>const long&amp;</code> 之类），后者才是我们想要的。</p><p>上一节结尾时的 <code>FIELD</code> 宏，就可以自动帮我们来生成这些定义。它本身被定义为：</p><pre><code class=\"language-cpp\">#define FIELD(i, arg)                        \\\n  PAIR(arg);                                 \\\n  template &lt;typename T&gt;                      \\\n  struct _field&lt;T, i&gt; {                      \\\n    _field(T&amp;&amp; obj)                          \\\n      : obj_(forward&lt;T&gt;(obj)) {}             \\\n    static constexpr auto name =             \\\n      CTS_STRING(STRIP(arg));                \\\n    using type =                             \\\n      decltype(decay_t&lt;T&gt;::STRIP(arg));      \\\n    auto value() -&gt; decltype(auto)           \\\n    {                                        \\\n      return (forward&lt;T&gt;(obj_).STRIP(arg));  \\\n    }                                        \\\n    T&amp;&amp; obj_;                                \\\n  };\n</code></pre><h3>编译期使用字段名称</h3><p>上面的定义在初步使用时已经够用了，但等到你想在编译期对字段名称进行判断时，你就会发现麻烦来了。当然，利用上一讲我们讲述的编译期传参的技巧，我们可以解决问题。但与其如此，不如我们直接往前走一步，利用字符串模板参数，直接把字段名称从<strong>值</strong>变成<strong>类型</strong>：</p><pre><code class=\"language-cpp\">  static constexpr auto name =\n    CTS_STRING(STRIP((long)v1));\n</code></pre><p>这里我们只是简单地把 <code>STRING</code> 变成了 <code>CTS_STRING</code>。这个变化看起来很小，但它会导致下面这些用法上的大改变：</p><ul>\n<li>相等判断可以直接使用 <code>is_same_v</code></li>\n<li>输出的话需要使用宏 <code>CTS_GET_VALUE</code></li>\n<li>函数传参大大简化，不再需要 <code>CARG</code>、<code>CARG_WRAP</code> 那套东西</li>\n</ul><p>这样带来的一个小问题是：如果你使用 MSVC 的话，你必须启用 C++20 才行。</p><h2>静态反射的使用</h2><h3>识别对静态反射的支持</h3><p>很多情况下，我们需要对处理的数据对象是否支持静态反射作分别的处理。使用类型特征很容易就能做到（可参考<a href=\"https://time.geekbang.org/column/article/181636\">第 14 讲</a>）：</p><pre><code class=\"language-cpp\">template &lt;typename T, typename = void&gt;\nstruct is_reflected : false_type {};\n\ntemplate &lt;typename T&gt;\nstruct is_reflected&lt;\n  T, void_t&lt;decltype(T::_size)&gt;&gt;\n  : true_type {};\n\ntemplate &lt;typename T&gt;\nconstexpr static bool is_reflected_v =\n  is_reflected&lt;T&gt;::value;\n</code></pre><h3>结构体的数据遍历：对象打印</h3><p>对于一个支持静态反射的结构体，我们可以做的一个非常基本的操作，就是可以像 <code>tuple</code> 一样来进行简单的遍历。为了方便这个常见操作以及类似遍历操作的实现，我们定义下面的函数模板：</p><pre><code class=\"language-cpp\">template &lt;typename T, typename F,\n          size_t... Is&gt;\nconstexpr void\nfor_each_impl(T&amp;&amp; obj, F&amp;&amp; f,\n              index_sequence&lt;Is...&gt;)\n{\n  using DT = decay_t&lt;T&gt;;\n  (void(forward&lt;F&gt;(f)(\n     DT::template _field&lt;T, Is&gt;::name,\n     typename DT::template _field&lt;T, Is&gt;(\n       forward&lt;T&gt;(obj))\n       .value())),\n   ...);\n}\n\ntemplate &lt;typename T, typename F&gt;\nconstexpr void for_each(T&amp;&amp; obj, F&amp;&amp; f)\n{\n  using DT = decay_t&lt;T&gt;;\n  for_each_impl(\n    forward&lt;T&gt;(obj), forward&lt;F&gt;(f),\n    make_index_sequence&lt;DT::_size&gt;{});\n}\n</code></pre><p>跟之前一样，为了在推导出 <code>T</code> 是 <code>S2&amp;</code> 等情况下访问 <code>S2</code> 的成员，我们需要使用 <code>decay_t</code>。从 <code>for_each</code> 到 <code>for_each_impl</code> 基本只是个转发，但加上了 <code>index_sequence</code> 参数，这也是我们讲编译期编程时一直在使用的技巧了。</p><p>主要工作当然就在 <code>for_each_impl</code> 里。它本质上就是一个折叠表达式的展开，基本形式是：</p><pre><code class=\"language-cpp\">(void(forward&lt;F&gt;(f)(…)), ...)\n</code></pre><p>也就是说，我们逐项调用函数 <code>f</code>（使用了完美转发），并抛弃返回值（使用 <code>void</code>）。</p><p>我们再看一下每次调用函数 <code>f</code> 使用的参数：</p><ul>\n<li>第一项是 <code>DT::template _field&lt;T, Is&gt;::name</code>，表示字段的名称。这里你可能感到陌生的是对成员模板的 <code>template</code> 消歧义符 [3]，其他就应该没啥特别的地方了。从阅读的角度，你基本上可以简单地忽略 <code>::</code> 后面的 <code>template</code> 关键字。</li>\n<li>第二项是 <code>typename DT::template _field&lt;T, Is&gt;(forward&lt;T&gt;(obj)).value()</code>。这个表达式有点长，其中，<code>typename DT::template _field&lt;T, Is&gt;</code> 指定了 <code>_field</code> 成员模板的类型，然后我们把 <code>obj</code> 完美转发到构造函数里，之后你就可以用 <code>value()</code> 来以合适的引用方式来访问字段了。</li>\n</ul><p>所以，对于我们提供给 <code>for_each</code> 的函数，对它的要求也是能接受两个参数：第一个是结构体的字段名，第二个是字段的引用。使用这样一个函数，我们就能对一个结构体进行遍历了。</p><p>只除了一点——我上面那句话不严格。由于字段名使用强类型，更由于每一个字段的类型都可能不同，一个普通函数无法工作。我们一般会使用泛型 lambda 表达式，本质上，它是一个具有 <code>operator()</code> 成员函数模板的函数对象。</p><p>有了这个基本工具之后，我们已经可以像 <code>print_tuple</code> 一样方便地输出任何支持静态反射的结构体了。代码如下所示：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nvoid dump_obj(const T&amp; obj,\n              ostream&amp; os = cout,\n              const char* field_name = \"\",\n              int depth = 0)\n{\n  auto indent = [&amp;os, depth] {\n    for (int i = 0; i &lt; depth; ++i) {\n      os &lt;&lt; \"    \";\n    }\n  };\n\n  if constexpr (is_reflected_v&lt;T&gt;) {\n    indent();\n    os &lt;&lt; field_name\n       &lt;&lt; (*field_name ? \": {\\n\" : \"{\\n\");\n    for_each(\n      obj, [depth, &amp;os](auto field_name,\n                        const auto&amp; value) {\n        dump_obj(value, os,\n                 CTS_GET_VALUE(field_name),\n                 depth + 1);\n      });\n    indent();\n    os &lt;&lt; \"}\" &lt;&lt; (depth == 0 ? \"\\n\" : \",\\n\");\n  } else {\n    indent();\n    os &lt;&lt; field_name &lt;&lt; \": \" &lt;&lt; obj &lt;&lt; \",\\n\";\n  }\n}\n</code></pre><p>仔细看一下，你会发现这个函数的实现相当简单。我们根据 <code>T</code> 类型是否支持静态反射，决定是遍历其所有字段，还是直接调用 <code>&lt;&lt;</code> 运算符来将其输出。如果是遍历的话，我们就会调用 <code>for_each</code>，并在传递给 <code>for_each</code> 的泛型 lambda 里递归调用 <code>dump_obj</code>，把下面一层的值、字段名等信息传递过去。</p><p>对于我们开头的那个 <code>s2</code>，<code>dump_obj</code> 可以给出下面这样的输出：</p><blockquote>\n<p><code>{</code><br>\n<code>    v1: 1,</code><br>\n<code>    v2: false,</code><br>\n<code>}</code></p>\n</blockquote><h3>结构体的元数据遍历：对象字段查找</h3><p>有时候我们并不希望遍历对象的实际数据，而只是遍历对象的数据类型。一种可能的场景就是，通过一个字段的名称，查找字段在结构体里的索引值。</p><p>类似于刚才的 <code>for_each</code>，我们可以定义一个 <code>for_each_meta</code>。其实现如下：</p><pre><code class=\"language-cpp\">template &lt;typename T, typename F,\n          size_t... Is&gt;\nconstexpr void\nfor_each_meta_impl(F&amp;&amp; f,\n                   index_sequence&lt;Is...&gt;)\n{\n  using DT = decay_t&lt;T&gt;;\n  (void(forward&lt;F&gt;(f)(\n     Is, DT::template _field&lt;T, Is&gt;::name)),\n   ...);\n}\n\ntemplate &lt;typename T, typename F&gt;\nconstexpr void for_each_meta(F&amp;&amp; f)\n{\n  for_each_meta_impl&lt;T&gt;(\n    forward&lt;F&gt;(f),\n    make_index_sequence&lt;T::_size&gt;{});\n}\n</code></pre><p>使用这个 <code>for_each_meta</code>，我们就可以实现出刚才说的根据字段名称查找索引值的函数了：</p><pre><code class=\"language-cpp\">template &lt;typename T, typename Name&gt;\nconstexpr size_t\nget_field_index(Name /*name*/)\n{\n  auto result = SIZE_MAX;\n  for_each_meta&lt;T&gt;([&amp;result](size_t index,\n                             auto name) {\n    if constexpr (is_same_v&lt;decltype(name),\n                            Name&gt;) {\n      result = index;\n    }\n  });\n  return result;\n}\n</code></pre><p>这个函数要求传递一个“编译期字符串”的字段名称，然后就会找出这个字段名称对应的字段索引值。如果这个字段不存在的话，就会返回 <code>SIZE_MAX</code>。</p><p>如对于开头的 <code>S1</code>，我们使用 <code>get_field_index&lt;S1&gt;(CTS_STRING(msg))</code> 就能在编译期得到结果 2。</p><h3>两个结构体的同时遍历：对象拷贝</h3><p>遍历一个结构体只能满足部分常见需求。对于像比较、复制这样的操作，我们需要同时遍历两个结构体。这个函数，依据一些业界的惯例，我命名为 <code>zip</code>。</p><p>下面是 <code>zip</code> 的实现：</p><pre><code class=\"language-cpp\">template &lt;typename T, typename U, typename F,\n          size_t... Is&gt;\nconstexpr void zip_impl(T&amp;&amp; obj1,\n                        U&amp;&amp; obj2,\n                        F&amp;&amp; f,\n                        index_sequence&lt;Is...&gt;)\n{\n  using DT = decay_t&lt;T&gt;;\n  using DU = decay_t&lt;U&gt;;\n  static_assert(DT::_size == DU::_size);\n  (void(forward&lt;F&gt;(f)(\n     DT::template _field&lt;T, Is&gt;::name,\n     DU::template _field&lt;U, Is&gt;::name,\n     typename DT::template _field&lt;T, Is&gt;(\n       forward&lt;T&gt;(obj1))\n       .value(),\n     typename DU::template _field&lt;U, Is&gt;(\n       forward&lt;U&gt;(obj2))\n       .value())),\n   ...);\n}\n\ntemplate &lt;typename T, typename U, typename F&gt;\nconstexpr void zip(T&amp;&amp; obj1, U&amp;&amp; obj2, F&amp;&amp; f)\n{\n  using DT = decay_t&lt;T&gt;;\n  using DU = decay_t&lt;U&gt;;\n  static_assert(DT::_size == DU::_size);\n  zip_impl(forward&lt;T&gt;(obj1), forward&lt;U&gt;(obj2),\n           forward&lt;F&gt;(f),\n           make_index_sequence&lt;DT::_size&gt;{});\n}\n</code></pre><p>它结构上也还是 <code>for_each</code> 的一个翻版，没有大的区别。此处，根据我这边的实际需求，我要求两个被遍历的结构体的字段数量必须完全一致。根据你的实际需要，你当然也可以实现成以较小的结构体为准；但按照我的实际项目经验，这种在动态大小场景下的常见做法，在编译期显得比较鸡肋，实际用处不大。</p><p>有了 <code>zip</code> 这样的工具，我们现在可以实现一些较复杂的操作了，比如，可以支持异质同构结构体（成员必须一一对应，但类型可以不同）的逐成员复制。实现代码如下：</p><pre><code class=\"language-cpp\">template &lt;typename T, typename U&gt;\nconstexpr void copy(T&amp;&amp; src, U&amp; dest)\n{\n  if constexpr (is_reflected_v&lt;decay_t&lt;T&gt;&gt; &amp;&amp;\n                is_reflected_v&lt;decay_t&lt;U&gt;&gt;) {\n    zip(forward&lt;T&gt;(src), dest,\n        [](auto /*field_name1*/,\n           auto /*field_name1*/,\n           auto&amp;&amp; value1,\n           auto&amp; value2) {\n          copy(\n            forward&lt;decltype(value1)&gt;(value1),\n            value2);\n        });\n  } else {\n    dest = forward&lt;T&gt;(src);\n  }\n}\n</code></pre><p>为了处理移动，我们对源对象使用完美转发，允许它是一个右值。为了防止误用和简化代码，目标对象必须是一个左值。当两个对象都支持静态反射时，我们使用 <code>zip</code> 来进行逐字段的遍历，对每一项继续进行 <code>copy</code> 的动作；否则，我们尝试普通的赋值操作（不支持的话，即会导致编译失败）。</p><p>对于同一类型结构体的复制，C++ 一般可以默认提供赋值运算符。但如果两个结构体类型不同，那默认的赋值运算符就不工作了。这时候，这个 <code>copy</code> 函数模板就能大显身手了。一种可能的使用场景是，我们可以利用它来实现网络字节序和主机字节序的自动转换。假设我们实现了数据类型 <code>uint32s</code> 和 <code>uint16s</code>，并且这些数据类型支持在跟 <code>uint32_t</code> 和 <code>uint16_t</code> 赋值的时候自动进行转换（这相当容易实现），那我们就可以定义出类似下面的数据结构：</p><pre><code class=\"language-cpp\">DEFINE_STRUCT(\n  msg_host_t,\n  (uint16_t)tag,\n  (uint16_t)length,\n  (uint32_t)value\n);\n\nDEFINE_STRUCT(\n  msg_net_t,\n  (uint16s)tag,\n  (uint16s)length,\n  (uint32s)value\n);\n</code></pre><p>从 <code>msg_host_t</code> 的一个对象 <code>msg_host</code>，转换到一个 <code>msg_net_t</code> 的对象 <code>msg_net</code>，我们现在可以一行代码搞定：</p><pre><code class=\"language-cpp\">copy(msg_host, msg_net);\n</code></pre><p>不仅如此，这样的结构体可以嵌套。如果我们有下面的结构体定义：</p><pre><code class=\"language-cpp\">DEFINE_STRUCT(\n  data_host_t,\n  (msg_host_t)msg,\n  (array&lt;byte, 8&gt;)data\n);\n\nDEFINE_STRUCT(\n  data_net_t,\n  (msg_net_t)msg,\n  (array&lt;byte, 8&gt;)data\n);\n</code></pre><p>这两种类型的对象之间也可以用 <code>copy</code> 来进行复制，编译器会自动产生合适的转换代码。</p><h3>应用：拷贝同名字段</h3><p>利用静态反射，我们可以自动化很多原本需要手工编码的操作。除了上面展示的那些，常用的场景还有序列化、反序列化等。由于序列化和反序列化跟实际应用场景关联比较紧密，代码也比较复杂，我最后就讲一下开头所展示的、按字段名复制结构体的实现。</p><p>按字段名来复制结构体，我们首先需要回答下面两个问题：</p><ul>\n<li>我们按源结构体优先遍历，还是按目标结构体优先遍历</li>\n<li>我们如何解决字段缺失的问题</li>\n</ul><p>在当前的解决方案里，我做出了下面的选择：</p><ul>\n<li>按目标结构体优先遍历（也就是为大结构体往小结构体拷贝而优化；反过来实现也不难、很相似）</li>\n<li>严格指定目标结构体里有、源结构体里没有的字段数量（默认为零），不正确的话，直接编译失败</li>\n</ul><p>在实现 <code>copy_same_name_fields</code> 之前，我们需要一些辅助的工具函数模板。首先是 <code>count_missing_fields</code>，数一下源结构体里缺失的字段数量：</p><pre><code class=\"language-cpp\">template &lt;typename T, typename U&gt;\nconstexpr size_t count_missing_fields()\n{\n  size_t result = 0;\n  for_each_meta&lt;U&gt;([&amp;result](size_t /*index*/,\n                             auto name) {\n    if constexpr (get_field_index&lt;T&gt;(name) ==\n                  SIZE_MAX) {\n      ++result;\n    }\n  });\n  return result;\n}\n</code></pre><p>这里我们用到了前面描述过的 <code>get_field_index</code>，通过两重循环搜索字段名。所有的这些操作全部发生在编译时，所以我们可以不用太担心这个 $O(m \\times n)$ 级别的性能开销。</p><p>在实现 <code>copy_same_name_fields</code> 之前，我们还要做一个小小的处理，标记源结构体里缺失了多少个字段。显然，为了编译期检查，我们需要传递一个模板参数，但我们究竟该用什么类型呢？用 <code>int</code>？还是 <code>size_t</code>？</p><p>都不是，为了类型上更严格，也为了代码可读性更高，我选择使用强枚举类型：</p><pre><code class=\"language-cpp\">enum class missing_fields : size_t {};\n</code></pre><p>它的底层是 <code>size_t</code>，但使用者必须显式地给出 <code>missing_fields{1}</code> 这样的方式来表达缺失了一个字段。我认为这样写更加合适、更加可读。</p><p>现在我们可以最终实现 <code>copy_same_name_fields</code> 了：</p><pre><code class=\"language-cpp\">template &lt;missing_fields MissingFields =\n            missing_fields{0},\n          typename T, typename U&gt;\nconstexpr void\ncopy_same_name_fields(T&amp;&amp; src, U&amp; dest)\n{\n  constexpr size_t actual_missing_fields =\n    count_missing_fields&lt;decay_t&lt;T&gt;, U&gt;();\n  static_assert(size_t(MissingFields) ==\n                actual_missing_fields);\n  for_each(dest, [&amp;src](auto field_name,\n                        auto&amp; value) {\n    using DT = decay_t&lt;T&gt;;\n    constexpr auto field_index =\n      get_field_index&lt;DT&gt;(field_name);\n    if constexpr (field_index != SIZE_MAX) {\n      copy(typename DT::template _field&lt;\n             T, field_index&gt;(\n             forward&lt;T&gt;(src))\n             .value(),\n           value);\n    }\n  });\n}\n</code></pre><p>我在这个函数里做了以下的事情：</p><ol>\n<li>检查指定的缺失字段数量是否和实际的缺失字段数量一致，不一致则静态断言失败</li>\n<li>对目标对象进行逐字段遍历</li>\n<li>对每个字段，根据字段名在源对象中查找是否存在对应的字段，存在的话，则 <code>copy</code> 过去</li>\n</ol><p>很简单吧？这里面的关键，跟上一讲的编译期字符串处理一样，是需要处处保持 constexpr 性。我现在应该已经提供了足够多的例子，让你看到该如何写出这种代码。</p><p>对于开头给出的 <code>copy_same_name_fields(s1, s2)</code>，编译器实际生成的 x86-64 的汇编代码是这样子：</p><pre><code class=\"language-assembly\">movsx   rax, DWORD PTR s1[rip]\nmov     QWORD PTR s2[rip], rax\nmovzx   eax, BYTE PTR s1[rip+4]\nmov     BYTE PTR s2[rip+8], al\n</code></pre><p>Java 之类的语言虽然有着更为强大的反射能力，但它们的反射机制就完全没有生成这样的高效代码的可能性！</p><h2>一些实现细节</h2><p>这一讲的代码有点小复杂，里面有很多容易搞错的小细节，因此我把一个完整的实现和测试放到了 GitHub 上的<a href=\"https://github.com/adah1972/geek_time_cpp\">代码库</a>里。同时，为了方便讲解，我上面给出的代码有一定的简化；而代码库中的实际代码更偏近工程化一些，相比文中的示例有如下的不同：</p><ul>\n<li>静态反射的工具函数模板放在了名空间 <code>sr</code> 中，跟标准库的同名函数模板可以清晰地区分</li>\n<li>为了防止冲突，<code>for_each</code> 等函数加上了 <code>enable_if</code> 进行限制，要求操作的对象必须满足 <code>is_reflected</code></li>\n<li><code>for_each_meta</code> 在调用函数时增加了一个目前没有用到的参数——字段类型</li>\n<li><code>dump_obj</code> 的实现方式有所变化</li>\n<li>测试里添加了对 <code>tuple</code> 行为的模拟，允许某种程度上把结构体当成 <code>tuple</code> 来用</li>\n</ul><p>根据你的实际使用场景，这些代码可能还有进一步的优化空间。不过，作为一个基本的实现参考，我想它们已经很有用了。</p><h2>内容小结</h2><p>本讲通过实现复制两个结构体中的同名字段，讲解了编译期数据遍历和一个重要的实际使用案例。在 C++ 标准中尚未引入正式的静态反射之际，这些技巧会是你的百宝箱中的重要工具。</p><h2>课后思考</h2><p>请阅读示例代码，并考虑一下，如何可以使用这些技巧来扩充更多的数据处理能力，如实现数据结构的序列化？</p><p>期待你的思考，有任何疑问，欢迎在留言区与我讨论！</p><h2>特别致谢</h2><p>罗能阅读了本讲的手稿，并提出了很好的改进意见。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] 罗能, “如何优雅的实现 C++ 编译期静态反射”. <a href=\"https://netcan.github.io/2020/08/01/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0C-%E7%BC%96%E8%AF%91%E6%9C%9F%E9%9D%99%E6%80%81%E5%8F%8D%E5%B0%84/\">https://netcan.github.io/2020/08/01/如何优雅的实现C-编译期静态反射/</a></span></p><p><span class=\"reference\">[2] Microsoft, “<code>/Zc:preprocessor</code> (Enable preprocessor conformance mode)”. <a href=\"https://docs.microsoft.com/en-us/cpp/build/reference/zc-preprocessor\">https://docs.microsoft.com/en-us/cpp/build/reference/zc-preprocessor</a></span></p><p><span class=\"reference\">[3] cppreference.com, “Dependent names &gt; The <code>template</code> disambiguator for dependent names”. <a href=\"https://en.cppreference.com/w/cpp/language/dependent_name#The_template_disambiguator_for_dependent_names\">https://en.cppreference.com/w/cpp/language/dependent_name#The_template_disambiguator_for_dependent_names</a></span></p><p><span class=\"reference\">[3a] cppreference.com, “待决名 &gt; 待决名的 <code>template</code> 消歧义符”. <a href=\"https://zh.cppreference.com/w/cpp/language/dependent_name#.E5.BE.85.E5.86.B3.E5.90.8D.E7.9A.84_template_.E6.B6.88.E6.AD.A7.E4.B9.89.E7.AC.A6\">https://zh.cppreference.com/w/cpp/language/dependent_name#.E5.BE.85.E5.86.B3.E5.90.8D.E7.9A.84_template_.E6.B6.88.E6.AD.A7.E4.B9.89.E7.AC.A6</a></span></p>","neighbors":{"left":{"article_title":"39 | 如何在编译期玩转字符串？","id":527423},"right":{"article_title":"41｜对象传参和返回的最佳实践","id":543067}},"comments":[{"had_liked":false,"id":360107,"user_name":"当初莫相识","can_delete":false,"product_type":"c1","uid":2768765,"ip_address":"江苏","ucode":"313917BB360D48","user_header":"https://static001.geekbang.org/account/avatar/00/2a/3f/7d/f624fa69.jpg","comment_is_top":false,"comment_ctime":1666178159,"is_pvip":false,"replies":[{"id":"131007","content":"这一讲属于高级技巧了，难度是高点。我主要是想分享一点可能用得上的技术。<br><br>另外，即使没看懂，你也可以试试看使用这种方式。毕竟，使用 STL 并不要求你能够写出 STL。","user_name":"作者回复","comment_id":360107,"uid":"1645639","ip_address":"江苏","utype":1,"ctime":1666278946,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1666178159","product_id":100040501,"comment_content":"这些选学的文章，难度太高，我只能草草阅过，段位不够😂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591106,"discussion_content":"这一讲属于高级技巧了，难度是高点。我主要是想分享一点可能用得上的技术。\n\n另外，即使没看懂，你也可以试试看使用这种方式。毕竟，使用 STL 并不要求你能够写出 STL。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666278946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351709,"user_name":"钱虎","can_delete":false,"product_type":"c1","uid":1936980,"ip_address":"","ucode":"D60200C100096C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUCr2XW1bgTTTiaf1UJvNOVjpibGicVSY6icU8uyzx5WTLLbF54nrM0EfzAOE2xmiarCw2w83uHiceka7A/132","comment_is_top":false,"comment_ctime":1658113053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658113053","product_id":100040501,"comment_content":"好","like_count":0}]}