{"id":740870,"title":"第 6 章 Spring 中的 JDBC(2)","content":"<h2 id=\"nav_point_99\">6.3　事务管理</h2>\n<p>说起数据库事务，相信大家一定不会陌生，网上是这么解释它的 <span class=\"comment-number\">11</span>：</p>\n\n<blockquote>\n<p>数据库事务是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p>\n</blockquote>\n<p>我们平时接触的系统一般都需要与数据库打交道，管理好操作中的事务就是一道绕不过去的“坎”。直接使用 JDBC 的话，同样会有很多模板化的代码。Spring Framework 又一次展现出了自己在问题抽象上的能力，为我们提供了一套统一的事务抽象，它有声明式和编程式两种使用方式。本节，就让我们来了解一下 Spring Framework 是如何管理事务的。</p>\n<h3 id=\"nav_point_100\">6.3.1　Spring Framework 的事务抽象</h3>\n<p>在 Java EE 环境中，事务可以是使用 JTA（Java Transaction API）这样的全局事务，也可以是基于 JDBC 连接的本地事务。实际上，大家日常工作中使用的大多是本地事务。随着分布式系统的发展，很多人会聊到分布式事务的话题，这时可以使用两阶段提交，常见的选择是 TCC<span class=\"comment-number\">12</span>。但<strong>如果可以的话，还是建议避免分布式事务，降低系统的复杂度</strong>。如无特殊说明，本书中提到的所有事务均指本地事务。</p>\n\n<p>为了消除不同事务对代码的影响，Spring Framework 对事务管理做了一层抽象：无论是全局事务还是本地事务，无论 JDBC 直接操作 SQL 还是对象关系映射，都能在一个模型中去理解和管理事务。这个抽象的核心是事务管理器，即 <code>TransactionManager</code>，它是一个空接口，通常都会将 <code>PlatformTransactionManager</code> 作为核心接口，其中包含了获取事务、提交事务和回滚事务的方法。它的定义是这样的：</p>\n<pre class=\"code-rows\"><code>public interface PlatformTransactionManager extends TransactionManager {\n    TransactionStatus getTransaction(@Nullable TransactionDefinition definition)throws TransactionException;\n    void commit(TransactionStatus status) throws TransactionException;\n    void rollback(TransactionStatus status) throws TransactionException;\n}</code></pre>\n<p><code>DataSourceTransactionManager</code>、<code>JtaTransactionManager</code> 和 <code>HibernateTransactionManager</code> 这些底层事务管理器都实现了上述接口。对上层业务来说，只要知道能调用 <code>PlatformTransaction-Manager</code> 接口的这几个方法来操作事务就行，事务的差异就这样被屏蔽了。以本地数据源的事务为例，可以像下面这样来配置 <code>DataSourceTransactionManager</code>：</p>\n<pre class=\"code-rows\"><code>&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n    &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n&lt;/bean&gt;</code></pre>\n<p>用来描述事务定义的 <code>TransactionDefinition</code> 接口中包含了几个与事务密切相关的属性：</p>\n<ul>\n<li>传播性</li>\n<li>隔离级别</li>\n<li>超时时间</li>\n<li>是否只读</li>\n</ul>\n<p>“超时时间”和“是否只读”比较容易理解，而“传播性”和“隔离级别”需要再展开说明一下。</p>\n<ol>\n<li><p><strong>传播性</strong></p>\n<p>事务传播性分为 7 个级别，对应的，在 <code>TransactionDefinition</code> 中定义了 7 个常量，具体信息如表 6-7 所示。</p>\n<p><strong>表 6-7　事务传播性的相关定义与说明</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>传播性</th><th>值</th><th>描述</th></tr><tr><td><code>PROPAGATION_REQUIRED</code></td><td><code>0</code></td><td>当前有事务就用当前事务，没有事务就新启动一个事务</td></tr><tr><td><code>PROPAGATION_SUPPORTS</code></td><td><code>1</code></td><td>事务不是必需的，可以有事务，也可以没有</td></tr><tr><td><code>PROPAGATION_MANDATORY</code></td><td><code>2</code></td><td>一定要存在一个事务，不然就报错</td></tr><tr><td><code>PROPAGATION_REQUIRES_NEW</code></td><td><code>3</code></td><td>新启动一个事务，如果当前存在一个事务则将其挂起</td></tr><tr><td><code>PROPAGATION_NOT_SUPPORTED</code></td><td><code>4</code></td><td>不支持事务，以非事务的方式运行</td></tr><tr><td><code>PROPAGATION_NEVER</code></td><td><code>5</code></td><td>不支持事务，如果当前存在一个事务则抛异常</td></tr><tr><td><code>PROPAGATION_NESTED</code></td><td><code>6</code></td><td>如果当前存在一个事务，则在该事务内再启动一个事务</td></tr></table>\n\n<p>默认的事务传播性会使用 <code>PROPAGATION_REQUIRED</code>，正常情况下这就够了。在上面的 7 种情况中，需要再特殊说明一下 <code>PROPAGATION_REQUIRES_NEW</code> 和 <code>PROPAGATION_NESTED</code> 的异同点：它们都会启动两个事务，但前者的两个事务是不相关的，而后者的两个事务存在包含关系。假设使用 <code>PROPAGATION_NESTED</code> 时两个事务分别为事务 A 和事务 B，事务 A 包含事务 B，事务 B 如果回滚了，事务 A 可以不受事务 B 的影响继续提交，但如果事务 A 回滚了，哪怕事务 B 是提交状态也会被回滚。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>事务隔离级别</strong></p>\n<p>数据库的事务有 4 种隔离级别，隔离级别越高，不同事务相互影响的概率就越小，具体就是出现脏读、不可重复读和幻读的情况。这三种情况的具体描述如下。</p>\n<ul>\n<li><strong>脏读</strong>：事务 A 修改了记录 1 的值但未提交事务，这时事务 B 读取了记录 1 尚未提交的值，但后来事务 A 回滚了，事务 B 读到的值并不会存在于数据库中，这就是脏读。</li>\n<li><strong>不可重复读</strong>：事务 A 会读取记录 1 两次，在两次读取之间，事务 B 修改了记录 1 的值并提交了，这时事务 A 第一次与第二次读取到的记录 1 的内容就不一样了，这就是不可重复读。</li>\n<li><strong>幻读</strong>：事务 A 以某种条件操作了数据表中的一批数据，这时事务 B 往表中插入并提交了 1 条记录，正好也符合事务 A 的操作条件，当事务 A 再次以同样的条件操作这批数据时，就会发现操作的数据集变了，这就是幻读。以 <code>SELECT count(*)</code> 为例，发生幻读时，如果两次以同样的条件来执行，结果值就会不同。</li>\n</ul>\n<p>不可重复读与幻读看起来很像，但不可重复读强调的是同一条数据在两次读取之间被修改了，而幻读强调的是数据集发生了数据增加或数据删除的情况。</p>\n<p>同样的，<code>TransactionDefinition</code> 中也对事务隔离级别做了具体的定义，引用了 JDBC <code>Connection</code> 中的常量，具体信息如表 6-8 所示。</p>\n<p><strong>表 6-8　事务隔离级别的相关定义与说明</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>隔离性</th><th>值</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr><tr><td><code>ISOLATION_READ_UNCOMMITTED</code></td><td><code>1</code></td><td>存在</td><td>存在</td><td>存在</td></tr><tr><td><code>ISOLATION_READ_COMMITTED</code></td><td><code>2</code></td><td>不存在</td><td>存在</td><td>存在</td></tr><tr><td><code>ISOLATION_REPEATABLE_READ</code></td><td><code>3</code></td><td>不存在</td><td>不存在</td><td>存在</td></tr><tr><td><code>ISOLATION_SERIALIZABLE</code></td><td><code>4</code></td><td>不存在</td><td>不存在</td><td>不存在</td></tr></table>\n\n<p><code>TransactionDefinition</code> 中的默认隔离级别设置为 <code>-1</code>，使用底层数据源的配置，比如，MySQL 默认的隔离级别是 <code>REPEATABLE_READ</code>，Oracle 默认的隔离级别则是 <code>READ_COMMITTED</code>。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_101\">6.3.2　Spring 事务的基本配置</h3>\n<p>通过 6.3.1 节的介绍，我们知道 Spring Framework 的核心类是 <code>TransactionManager</code>，并且在上下文中需要一个 <code>PlatformTransactionManager</code> Bean，例如，<code>DataSourceTransactionManager</code> 或者 <code>JpaTransactionManager</code>。可以像下面这样来定义一个 <code>PlatformTransactionManager</code>：</p>\n<pre class=\"code-rows\"><code>@Configuration\npublic class TransactionConfiguration {\n    @Bean\n    public DataSourceTransactionManager transactionManager(DataSource dataSource) {\n        return new DataSourceTransactionManager(dataSource);\n    }\n}</code></pre>\n<p>这节的标题没有用 Spring Framework 是有原因的—— Spring Boot 为我们提供了一整套事务的自动配置，这远比自己动手配置方便。主要的自动配置类是 <code>DataSourceTransactionManagerAutoConfiguration</code> 和 <code>TransactionAutoConfiguration</code>。</p>\n<p><code>DataSourceTransactionManagerAutoConfiguration</code> 的作用主要是自动配置 <code>DataSourceTransactionManager</code>，具体代码如下所示：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ JdbcTemplate.class, TransactionManager.class })\n@AutoConfigureOrder(Ordered.LOWEST_PRECEDENCE)\n@EnableConfigurationProperties(DataSourceProperties.class)\npublic class DataSourceTransactionManagerAutoConfiguration {\n    @Configuration(proxyBeanMethods = false)\n    @ConditionalOnSingleCandidate(DataSource.class)\n    static class DataSourceTransactionManagerConfiguration {\n        @Bean\n        @ConditionalOnMissingBean(TransactionManager.class)\n        DataSourceTransactionManager transactionManager(Environment environment, DataSource dataSource,\n            ObjectProvider&lt;TransactionManagerCustomizers&gt; transactionManagerCustomizers) {\n            // 省略具体代码\n        }\n        // 省略部分代码\n    }\n}</code></pre>\n<p>当 Spring 上下文中提供了明确的一个 <code>DataSource</code>（只有一个或者标明了一个主要的 Bean），且没有配置 <code>PlatformTransactionManager</code> 时，Spring Boot 会自动创建一个 <code>DataSourceTransactionManager</code>。这里需要特别说明一下 <code>TransactionManagerCustomizers</code>，它是 Spring Boot 的自动配置留下的扩展点，可以让我们通过创建 <code>TransactionManagerCustomizers</code> 来对自动配置的 <code>DataSourceTransactionManager</code> 进行微调。在 Spring Boot 中类似的 <code>XXXCustomizer</code> 还有很多，比如在 Web 相关章节里会看到的 <code>RestTemplateCustomizer</code>。</p>\n<p><code>TransactionAutoConfiguration</code> 会为事务再提供进一步的配置，它主要做了两件事：第一是创建了编程式事务需要用到的 <code>TransactionTemplate</code>；第二是开启了基于注解的事务支持，这部分是由内部类 <code>EnableTransactionManagementConfiguration</code> 来定义的，具体代码如下：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnBean(TransactionManager.class)\n@ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class)\npublic static class EnableTransactionManagementConfiguration {\n    @Configuration(proxyBeanMethods = false)\n    @EnableTransactionManagement(proxyTargetClass = false)\n    @ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"false\",\n        matchIfMissing = false)\n    public static class JdkDynamicAutoProxyConfiguration {}\n\n    @Configuration(proxyBeanMethods = false)\n    @EnableTransactionManagement(proxyTargetClass = true)\n    @ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"true\",\n        matchIfMissing = true)\n    public static class CglibAutoProxyConfiguration {}\n}</code></pre>\n<p>在配置类上添加 <code>@EnableTransactionManagement</code> 注解就能开启事务支持。Spring Framework 的声明式事务是通过 AOP 来实现的，因此根据 AOP 配置的不同，需要选择是否开启对类的代理。当 <code>spring.aop.proxy-target-class=true</code> 时，可以直接对没有实现接口的类开启声明式事务支持，这也是默认的配置。</p>\n<p>实际上，如果我们去翻看 <code>AopAutoConfiguration</code> 的代码，也能看到其中有类似的自动配置。可见，在 Spring Boot 中基于 CGLIB 的 AOP 就是默认的 AOP 代理方式：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnProperty(prefix = \"spring.aop\", name = \"auto\", havingValue = \"true\", matchIfMissing = true)\npublic class AopAutoConfiguration {\n    @Configuration(proxyBeanMethods = false)\n    @ConditionalOnClass(Advice.class)\n    static class AspectJAutoProxyingConfiguration {\n        @Configuration(proxyBeanMethods = false)\n        @EnableAspectJAutoProxy(proxyTargetClass = false)\n        @ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"false\",\n            matchIfMissing = false)\n        static class JdkDynamicAutoProxyConfiguration {}\n\n        @Configuration(proxyBeanMethods = false)\n        @EnableAspectJAutoProxy(proxyTargetClass = true)\n        @ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"true\",\n            matchIfMissing = true)\n        static class CglibAutoProxyConfiguration {}\n    }\n    // 其他内容省略\n}</code></pre>\n<p><code>TransactionProperties</code> 是事务的属性配置，其中只有两个配置：<code>spring.transaction.default-timeout</code> 用于配置默认超时时间，默认单位为秒；<code>spring.transaction.rollback-on-commit-failure</code> 配置在提交失败时是否回滚。</p>\n<h3 id=\"nav_point_102\">6.3.3　声明式事务</h3>\n<p>通常在没有特殊需求的情况下，我们建议使用 Spring Framework 的声明式事务来管理事务。而且如果有一大堆类需要配置事务，声明式事务也会比编程式事务更方便一些。所以，我们会着重介绍声明式事务的使用方式。</p>\n<ol>\n<li><p><strong>基于注解的方式</strong></p>\n<p>Spring Framework 提供了一个 <code>@Transactional</code> 注解，它可以在类型和方法上 <span class=\"comment-number\">13</span> 标注与事务相关的信息。同时，我们也可以使用 JTA 中的 <code>@Transactional</code> 注解（在 <code>javax.transaction</code> 包里），两者的作用基本是一样的。在注解中可以设置很多事务属性，具体如表 6-9 所示。</p>\n<p><strong>表 6-9　<code>@Transactional</code> 注解可以设置的事务属性</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>属性</th><th>默认值</th><th>描述</th></tr><tr><td><code>transactionManager</code></td><td>默认会找名为 <code>transactionManager</code> 的事务管理器</td><td>指定事务管理器</td></tr><tr><td><code>propagation</code></td><td><code>Propagation.REQUIRED</code></td><td>指定事务的传播性</td></tr><tr><td><code>isolation</code></td><td><code>Isolation.DEFAULT</code></td><td>指定事务的隔离性</td></tr><tr><td><code>timeout</code></td><td><code>-1</code>，即由具体的底层实现来设置</td><td>指定事务超时时间</td></tr><tr><td><code>readOnly</code></td><td><code>false</code></td><td>是否为只读事务</td></tr><tr><td><code>rollbackFor</code> / <code>rollbackForClassName</code></td><td>空</td><td>指定需要回滚事务的异常类型</td></tr><tr><td><code>noRollbackFor</code> / <code>noRollbackForClassName</code></td><td>空</td><td>指定无须回滚事务的异常类型</td></tr></table>\n\n<blockquote>\n<p><strong>请注意</strong>　默认情况下，事务只会在遇到 <code>RuntimeException</code> 和 <code>Error</code> 时才会回滚，碰到受检异常（checked exception）时并不会回滚。例如，我们定义了一个业务异常 <code>BizException</code>，它继承的是 <code>Exception</code> 类，在代码抛出这个异常时，事务不会自己回滚，但我们可以手动设置回滚，或者在 <code>rollbackFor</code> 中进行设置。</p>\n</blockquote>\n<p>要开启注解驱动的事务支持，有两种方式，在上一节里已经看到过了在配置类上添加 <code>@EnableTransactionManagement</code> 的方式，这里来介绍一下第二种：通过 <code>&lt;tx:annotation-driven/&gt;</code> 这个 XML 标签来启用注解支持，具体如下所示：</p>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;\n\n    &lt;!-- 开启事务注解支持，可以明确设置一个TransactionManager --&gt;\n    &lt;tx:annotation-driven transaction-manager=\"txManager\"/&gt;\n&lt;/beans&gt;</code></pre>\n<p>在开启注解驱动事务支持时，除了配置 <code>TransactionManager</code>，还可以进行一些其他配置。<code>@EnableTransactionManagement</code> 和 <code>&lt;tx:annotation-driven/&gt;</code> 拥有一些共同的配置，如表 6-10 所示。</p>\n<p><strong>表 6-10　注解驱动事务支持的部分配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>含义</th></tr><tr><td><code>mode</code></td><td><code>proxy</code></td><td>声明式事务 AOP 的拦截方式，默认 <code>proxy</code> 是代理方式，也可以改为 <code>aspectj</code></td></tr><tr><td><code>order</code></td><td><code>Ordered.LOWEST_PRECEDENCE</code></td><td>声明式事务 AOP 拦截的顺序，值越小，优先级越高</td></tr><tr><td><code>proxyTargetClass</code> / <code>proxy-target-class</code>（XML）</td><td><code>false</code></td><td>是否使用 CGLIB 的方式拦截类 <sup><b>14</b></sup></td></tr></table>\n\n<blockquote>\n<p><sup><b>14</b></sup>虽然这里的默认值是 <code>false</code>，但通过 6.3.2 节的介绍，我们已经知道了在 Spring Boot 中，默认会使用 CGLIB 的方式来做拦截。</p>\n</blockquote>\n<p>在 <code>&lt;tx:annotation-driven/&gt;</code> 中还有一个 <code>transacation-manager</code> 属性，在事务管理器的名字不是 <code>transactionManager</code> 时用来指定事务要使用的事务管理器。但 <code>@EnableTransactionManagement</code> 里却没有这一属性，它会根据类型来做注入。如果希望明确指定使用哪个 <code>TransactionManager</code>，可以让 <code>@Configuration</code> 类实现 <code>TransactionManagementConfigurer</code> 接口，在 <code>annotationDrivenTransactionManager()</code> 方法里返回希望使用的那个 <code>TransactionManager</code>。</p>\n<p>在介绍事务传播性时，我们有讲到 <code>PROPAGATION_REQUIRED</code>、<code>PROPAGATION_REQUIRES_NEW</code> 和 <code>PROPAGATION_NESTED</code> 的区别。下面我们通过基于注解的声明式事务来实际感受一下它们之间的差别。</p>\n<p>通过 Spring Initializr 创建一个新工程 <span class=\"comment-number\">15</span>，依赖项选择 JDBC API、H2 和 Lombok。在 src/main/resources 目录中创建 schema.sql，添加代码示例 6-23 中的建表语句。</p>\n<blockquote>\n<p><strong>代码示例 6-23</strong>　schema.sql 中的建表语句</p>\n</blockquote>\n<pre class=\"code-rows\"><code>create table t_demo (\n    id bigint auto_increment,\n    name varchar(128),\n    create_time timestamp,\n    update_time timestamp,\n    primary key (id)\n);</code></pre>\n<p>接下来我们的试验就是操作 <code>t_demo</code> 表，在不同的事务传播性下插入记录，查看结果，对表的操作如代码示例 6-24 所示。三个插入方法分别使用不同的事务传播性，<code>showNames()</code> 方法返回表中所有的 <code>name</code> 内容。</p>\n<blockquote>\n<p><strong>代码示例 6-24</strong>　提供不同事务传播性插入方法的 <code>DemoService</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.transaction;\n\n// 省略import\n\n@Service\npublic class DemoService {\n    public static final String SQL =\n        \"insert into t_demo (name, create_time, update_time) values(?, now(), now())\";\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Transactional(readOnly = true)\n    public String showNames() {\n        return jdbcTemplate.queryForList(\"select name from t_demo;\", String.class)\n            .stream().collect(Collectors.joining(\",\"));\n    }\n\n    @Transactional(propagation = Propagation.REQUIRED)\n    public void insertRecordRequired() {\n        jdbcTemplate.update(SQL, \"one\");\n    }\n\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void insertRecordRequiresNew() {\n        jdbcTemplate.update(SQL, \"two\");\n    }\n\n    @Transactional(propagation = Propagation.NESTED)\n    public void insertRecordNested() {\n        jdbcTemplate.update(SQL, \"three\");\n        throw new RuntimeException(); // 让事务回滚\n    }\n}</code></pre>\n<p>再用另一个类来组合几个插入方法，不同的组合会有不同的效果，如代码示例 6-25 所示。</p>\n<blockquote>\n<p><strong>代码示例 6-25</strong>　调用插入方法的 <code>MixService</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.transaction;\n\n// 省略import\n\n@Service\npublic class MixService {\n    @Autowired\n    private DemoService demoService;\n\n    @Transactional\n    public void trySomeMethods() {\n        demoService.insertRecordRequired();\n        try {\n            demoService.insertRecordNested();\n        } catch(Exception e) {}\n    }\n}</code></pre>\n<p>工程的主类就比较简单了，执行 <code>MixService</code> 的 <code>trySomeMethods()</code> 方法，如代码示例 6-26 所示。</p>\n<blockquote>\n<p><strong>代码示例 6-26</strong>　<code>AnnotationDemoApplication</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@Slf4j\npublic class AnnotationDemoApplication implements ApplicationRunner {\n    @Autowired\n    private MixService mixService;\n    @Autowired\n    private DemoService demoService;\n\n    public static void main(String[] args) {\n        SpringApplication.run(AnnotationDemoApplication.class, args);\n    }\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        try {\n            mixService.trySomeMethods();\n        } catch (Exception e) {}\n        log.info(\"Names: {}\", demoService.showNames());\n    }\n}</code></pre>\n<p>在目前的 <code>trySomeMethods()</code> 中，程序会输出 <code>Names: one</code>，内嵌事务回滚不影响外部事务。如果将 <code>trySomeMethods()</code> 调整为下面这样：</p>\n<pre class=\"code-rows\"><code>@Transactional\npublic void trySomeMethods() {\n    demoService.insertRecordRequired();\n    demoService.insertRecordRequiresNew();\n    throw new RuntimeException();\n}</code></pre>\n<p>那输出就会是 <code>Names: two</code>，<code>Propagation.REQUIRES_NEW</code>，会新启动一个与当前事务无关的事务，提交后如果当前事务回滚了，不会影响已提交内容。</p>\n<blockquote>\n<p><strong>茶歇时间：通常事务加在哪层比较合适？</strong></p>\n<p>Spring Framework 虽然为我们提供了声明式的事务，可以将事务与代码剥离，但它并没有告诉我们究竟将事务拦在哪里更合适。</p>\n<p>通常情况下，我们会对应用进行分层，划分出 DAO 层、Service 层、View 层等。如果了解过领域驱动设计（Domain-Driven Design，DDD），就会知道其中也有 Repository 和 Service 的概念。一次业务操作一般都会涉及多张表的数据，因此在单表的 DAO 或 Repository 上增加事务，粒度太细，并不能实现业务的要求。而在对外提供的服务接口上增加事务，整个事务的范围又太大，一个请求从开始到结束都在一个大事务里，着实又有些浪费。</p>\n<p>所以，事务一般放在内部的领域服务上，也就是 Service 层上会是比较常见的一个做法，其中的一个方法，也就对应了一个业务操作。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>基于 XML 的方式</strong></p>\n<p>看过了注解驱动的事务，再来了解一下如何通过 XML 配置实现相同的功能。<code>@Transactional</code> 注解需要添加在代码里，而 XML 则可以从业务代码剥离，将事务配置与业务逻辑解耦。</p>\n<p>Spring Framework 提供了一系列 <code>&lt;tx/&gt;</code> 的 XML 来配置事务相关的 AOP 通知。有了 AOP 通知后，我们就可以像普通的 AOP 配置那样对方法的执行进行拦截和增强了。</p>\n<p>其中，<code>&lt;tx:advice/&gt;</code> 用来配置事务通知，如果事务管理器的名字是 <code>transactionManager</code>，那就可以不用设置 <code>transaction-manager</code> 属性了。具体的事务属性则通过 <code>&lt;tx:attributes/&gt;</code> 和 <code>&lt;tx:method/&gt;</code> 来设置。<code>&lt;tx:method/&gt;</code> 可供设置的属性和 <code>@Transactional</code> 注解的基本一样，具体见表 6-11。</p>\n<p><strong>表 6-11　<code>&lt;tx:method/&gt;</code> 的属性清单</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>属性</th><th>默认值</th><th>含义</th></tr><tr><td><code>name</code></td><td>无</td><td>要拦截的方法名称，可以带通配符，是唯一的必选项</td></tr><tr><td><code>propagation</code></td><td><code>REQUIRED</code></td><td>事务传播性</td></tr><tr><td><code>isolation</code></td><td><code>DEFAULT</code></td><td>事务隔离性</td></tr><tr><td><code>timeout</code></td><td><code>-1</code></td><td>事务超时时间，单位为秒</td></tr><tr><td><code>read-only</code></td><td><code>false</code></td><td>是否是只读事务</td></tr><tr><td><code>rollback-for</code></td><td>无</td><td>会触发回滚的异常清单，以逗号分隔，可以是全限定类名，也可以是简单类名</td></tr><tr><td><code>no-rollback-for</code></td><td>无</td><td>不触发回滚的异常清单，以逗号分隔，可以是全限定类名，也可以是简单类名</td></tr></table>\n\n<p>可以将前面提到的 annotation-demo 修改一下，去掉所有的 <code>@Transactional</code> 注解，改用 XML 的方式来配置事务，代码放在示例的 ch6/xml-transaction-demo 中。具体的 XML 配置如代码示例 6-27 所示。由于用到了 AspectJ 的切入点，工程中还需要引入 <code>org.springframework.boot:spring-boot-starter-aop</code> 依赖。</p>\n<blockquote>\n<p><strong>代码示例 6-27</strong>　完整的 <code>applicationContext.xml</code> 配置示例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:aop=\"http://www.springframework.org/schema/aop\"\n        xmlns:tx=\"http://www.springframework.org/schema/tx\"\n        xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;\n\n    &lt;tx:advice id=\"demoTxAdvice\"&gt;\n        &lt;tx:attributes&gt;\n            &lt;tx:method name=\"showNames\" read-only=\"true\"/&gt;\n            &lt;tx:method name=\"insertRecordRequired\" propagation=\"REQUIRED\"/&gt;\n            &lt;tx:method name=\"insertRecordRequiresNew\" propagation=\"REQUIRES_NEW\"/&gt;\n            &lt;tx:method name=\"insertRecordNested\" propagation=\"NESTED\"/&gt;\n        &lt;/tx:attributes&gt;\n    &lt;/tx:advice&gt;\n\n    &lt;tx:advice id=\"mixTxAdvice\"&gt;\n        &lt;tx:attributes&gt;\n            &lt;tx:method name=\"*\" /&gt;\n        &lt;/tx:attributes&gt;\n    &lt;/tx:advice&gt;\n\n    &lt;aop:config&gt;\n        &lt;aop:pointcut id=\"demoServiceMethods\"\n            expression=\"execution(* learning.spring.transaction.DemoService.*(..))\"/&gt;\n        &lt;aop:pointcut id=\"mixServiceMethods\"\n            expression=\"execution(* learning.spring.transaction.MixService.*(..))\"/&gt;\n        &lt;aop:advisor advice-ref=\"demoTxAdvice\" pointcut-ref=\"demoServiceMethods\"/&gt;\n        &lt;aop:advisor advice-ref=\"mixTxAdvice\" pointcut-ref=\"mixServiceMethods\"/&gt;\n    &lt;/aop:config&gt;\n&lt;/beans&gt;</code></pre>\n<p>上面的 XML 中，针对 <code>DemoService</code> 的不同方法配置了不同的传播性，而 <code>DemoService</code> 和 <code>MixService</code> 的事务配置也有所不同。我们可以在工程主类，或者其他带有 <code>@Configuration</code> 注解的配置类上增加 <code>@ImportResource(\"applicationContext.xml\")</code>，导入 XML 配置。程序的运行效果与之前注解驱动的事务一模一样。</p>\n<blockquote>\n<p><strong>茶歇时间：声明式事务背后的原理</strong></p>\n<p>Spring Framework 的声明式事务，其本质是对目标类和方法进行了 AOP 拦截，并在方法的执行前后增加了事务相关的操作，比如启动事务、提交事务和回滚事务。</p>\n<p>既然是通过 AOP 实现的，那它就必定遵循了 AOP 的各种规则和限制。Spring Framework 的 AOP 增强通常都是通过代理的方式来实现的，这就意味着事务也是在代理类上的。<strong>我们必须调用增强后的代理类中的方法，而非原本的对象，这样才能拥有事务</strong>。也就是说调用下面的 <code>methodWithoutTx()</code> 并不会启动一个事务：</p>\n<pre class=\"code-rows\"><code>public class Demo {\n    @Trasactional\n    public void methodWithTx() {...}\n\n    public void methodWithoutTx() {\n        this.methodWithTx();\n    }\n}</code></pre>\n<p>我们在第 3 章的<strong>基于代理的“小坑”</strong>中也提到过类似的场景，请务必注意避免这种情况。如果一定要调用自己的方法，可以从 <code>ApplicationContext</code> 中获取自己的代理对象，操作这个对象上的方法，而不是使用 <code>this</code>。或者，也可以在适当配置下，通过 <code>AopContext.currentProxy()</code> 来获得当前的代理。</p>\n</blockquote>\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_103\">6.3.4　编程式事务</h3>\n<p>在看过了声明式事务之后，理解编程式事务就不是什么难事了。正如本节标题字面上的意思，Spring Framework 还支持用编程的方式来控制事务，但绝不是简单地调用 <code>Connection</code> 的 <code>setAutoCommit(false)</code> 来启动事务，结束时调用 <code>commit()</code> 或 <code>rollback()</code> 提交或回滚事务，而是将这些流程固化到了模板类中。和 <code>JdbcTemplate</code> 类似，Spring Framework 为事务提供了一个 <code>TransacationTemplate</code>。</p>\n<p>Spring Boot 在 <code>TransactionAutoConfiguration</code> 中包含了一个内部类 <code>TransactionTemplateConfiguration</code>，会自动基于明确的 <code>PlatformTransactionManager</code> 创建 <code>TransactionTemplate</code>，手动创建也很简单：</p>\n<pre class=\"code-rows\"><code>@Configuration\npublic class TxConfiguration {\n    @Bean\n    public TransactionTemplate transactionTemplate(PlatformTransactionManager transactionManager) {\n        return new TransactionTemplate(transactionManager);\n    }\n}</code></pre>\n<p>在使用时，我们主要用它的 <code>execute()</code> 和 <code>executeWithoutResult()</code> 方法，方法的声明形式如下所示：</p>\n<pre class=\"code-rows\"><code>public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException;\npublic void executeWithoutResult(Consumer&lt;TransactionStatus&gt; action) throws TransactionException;</code></pre>\n<p><code>TransactionCallback</code> 接口就一个 <code>doInTransaction()</code> 方法，通常都是直接写个匿名类，或者是 Lambda 表达式。我们简单修改一下代码示例 6-24 中的几个方法，看看编程式事务该怎么写。查询类方法 <code>showNames()</code> 可以改写成代码示例 6-28 的样子。</p>\n<blockquote>\n<p><strong>代码示例 6-28</strong>　查询方法示例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>// Lambda形式\npublic String showNamesProgrammatically() {\n    return transactionTemplate.execute(\n            status -&gt; jdbcTemplate.queryForList(\"select name from t_demo;\", String.class)\n                    .stream().collect(Collectors.joining(\",\")));\n}\n\n// 匿名类形式\npublic String showNamesProgrammatically() {\n    return transactionTemplate.execute(new TransactionCallback&lt;String&gt;() {\n        @Override\n        public String doInTransaction(TransactionStatus status) {\n            return jdbcTemplate.queryForList(\"select name from t_demo;\", String.class)\n                    .stream().collect(Collectors.joining(\",\"));\n        }\n    });\n}</code></pre>\n<p>如果是更新类的操作，则没有返回值，比如 <code>insertRecordRequired()</code>，可以改写为代码示例 6-29 的样子。通过这两个例子，相信大家一定发现了，Lambda 表达式比起匿名类的形式要简洁很多，因此建议大家平时多多考虑 Lambda 表达式。</p>\n<blockquote>\n<p><strong>代码示例 6-29</strong>　没有返回值的示例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>// Lambda形式\npublic void insertRecordRequiredProgrammatically() {\n    transactionTemplate.executeWithoutResult(status -&gt; jdbcTemplate.update(SQL, \"one\"));\n}\n\n// 匿名类形式\npublic void insertRecordRequiredProgrammatically() {\n    transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n        @Override\n        protected void doInTransactionWithoutResult(TransactionStatus status) {\n            jdbcTemplate.update(SQL, \"one\");\n        }\n    });\n}</code></pre>\n<p>如果希望修改事务的属性，可以直接调用 <code>TransactionTemplate</code> 的对应方法，或者在创建时将其作为 Bean 属性配置进去，这里建议使用对应的常量，而非写成固定的一个数字。这些属性是设置在对象上的，如果要在不同的代码中复用同一个 <code>TransactionTemplate</code> 对象，请确认它们可以使用相同的配置。</p>\n<p>在代码中设置传播性与隔离性，可以使用 <code>setPropagationBehavior()</code> 和 <code>setIsolationLevel()</code> 方法，如果是在 XML 配置中设置 Bean 属性，则可以选择对应的 <code>propagationBehaviorName</code> 和 <code>isolationLevelName</code> 属性。</p>\n<h2 id=\"nav_point_104\">6.4　异常处理</h2>\n<p>在使用传统的 JDBC 操作数据库时，我们不得不面对异常处理的问题，只捕获 <code>SQLException</code> 的粒度太粗，根据其中的 <code>SQLState</code> 和 <code>ErrorCode</code> 可以大致分析出特定数据库的错误，但换了一个数据库，错误码一改就得重头来过。</p>\n<p>不同数据库的 JDBC 驱动中也会定义一些 <code>SQLException</code> 的子类，只是捕获特定数据库的异常类就会把代码和底层数据库彻底“绑死了”，万一遇到变更底层数据库类型的情况，就会非常被动，例如碰上了公司要“去 O”<span class=\"comment-number\">16</span>，那这些异常处理逻辑几乎得重写。</p>\n\n<p>Spring Framework 为我们提供了一套统一的数据库操作异常体系，它独立于具体的数据库产品，甚至也不依赖 JDBC，支持绝大多数常用数据库。它能将不同数据库的返回码翻译成特定的类型，开发者只需捕获并处理 Spring Framework 封装后的异常就可以了。</p>\n<h3 id=\"nav_point_105\">6.4.1　统一的异常抽象</h3>\n<p>Spring Framework 的数据库操作异常抽象从 <code>DataAccessException</code> 这个类开始，所有的异常都是它的子类。无论是使用 JDBC，还是后续要介绍到的对象关系映射，都会涉及这套抽象，图 6-1 展示了其中部分常用的异常类。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00764.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 6-1　统一数据库操作异常抽象中部分常用的异常类</strong></p>\n<p>可以看到，这套异常覆盖了绝大部分的常见异常，例如，违反了唯一性约束就会抛出的 <code>DataIntegrityViolationException</code>，针对主键冲突的异常，还有一个 <code>DuplicateKeyException</code> 子类，我们可以根据这些异常清晰地判断究竟发生了什么问题。</p>\n<p>那 Spring Framework 又是怎么来理解和翻译这么多不同类型的数据库异常的呢？这背后的核心接口就是 <code>SQLExceptionTranslator</code>，它负责将不同的 <code>SQLException</code> 转换为 <code>DataAccessException</code>。<code>SQLExceptionTranslator</code> 及其重要实现类的关系如图 6-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00765.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 6-2　<code>SQLExceptionTranslator</code> 及其重要实现类的关系</strong></p>\n<p>图中的 <code>SQLStateSQLExceptionTranslator</code> 会分析异常中的 <code>SQLState</code>，根据标准 <code>SQLState</code> 和常见的特定数据库 <code>SQLState</code> 进行转换；<code>SQLExceptionSubclassTranslator</code> 根据 <code>java.sql.SQLException</code> 的子类类型进行转换；而 <code>SQLErrorCodeSQLExceptionTranslator</code> 则是根据异常中的错误码进行转换的。</p>\n<p><code>JdbcTemplate</code> 中会创建一个默认的 <code>SQLErrorCodeSQLExceptionTranslator</code>，根据数据库类型选择不同配置来进行实际的异常转换，所以让我们来具体看看它的实现。<code>SQLErrorCodeSQLExceptionTranslator</code> 会通过 <code>SQLErrorCodesFactory</code> 来获取特定数据库的错误码信息，<code>SQLErrorCodesFactory</code> 默认从 CLASSPATH 的 org/springframework/jdbc/support/sql-error-codes.xml 文件中加载错误码配置，这是一个 Bean 的配置文件，其中都是 <code>SQLErrorCodes</code> 类型的 Bean。这个文件中包含了 MySQL、Oracle、PostgreSQL、MS-SQL 等 10 余种常见数据库的错误码信息，例如下面就是 MySQL 的配置，可以看到它将错误码与具体的异常类型关联了起来：</p>\n<pre class=\"code-rows\"><code>&lt;bean id=\"MySQL\" class=\"org.springframework.jdbc.support.SQLErrorCodes\"&gt;\n    &lt;property name=\"databaseProductNames\"&gt;\n        &lt;list&gt;\n            &lt;value&gt;MySQL&lt;/value&gt;\n            &lt;value&gt;MariaDB&lt;/value&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n    &lt;property name=\"badSqlGrammarCodes\"&gt;\n        &lt;value&gt;1054,1064,1146&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"duplicateKeyCodes\"&gt;\n        &lt;value&gt;1062&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"dataIntegrityViolationCodes\"&gt;\n        &lt;value&gt;630,839,840,893,1169,1215,1216,1217,1364,1451,1452,1557&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"dataAccessResourceFailureCodes\"&gt;\n        &lt;value&gt;1&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"cannotAcquireLockCodes\"&gt;\n        &lt;value&gt;1205,3572&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"deadlockLoserCodes\"&gt;\n        &lt;value&gt;1213&lt;/value&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<p><code>SQLErrorCodeSQLExceptionTranslator</code> 会先尝试 <code>SQLErrorCodes</code> 中的 <code>customSqlExceptionTranslator</code> 来转换，接着再尝试 <code>SQLErrorCodes</code> 中的 <code>customTranslations</code>，最后再根据配置的错误码来判断。如果最后还是匹配不上，就降级到其他 <code>SQLExceptionTranslator</code> 上。</p>\n<h3 id=\"nav_point_106\">6.4.2　自定义错误码处理逻辑</h3>\n<p>Spring Framework 针对常见数据库异常的处理已经比较完善了，但在一些特殊场景中，默认的逻辑并不能满足我们的需求。假设在公司内部有一套自己的数据库代理中间件，能在应用与实际的数据库之间提供连接收敛、请求路由、分库分表等功能，对外提供 MySQL 协议，但又扩展了一些其他的功能：通过特定的错误码向上返回某些扩展的状态，这些错误码超出了默认的范围。</p>\n<p>在看过了 Spring Framework 处理数据库错误码的逻辑之后，我们很快就能想到去扩展 <code>SQLErrorCodes</code>。<code>SQLErrorCodesFactory</code> 其实也预留了扩展点，它会加载 CLASSPATH 根目录中的 sql-error-codes.xml 文件，用其中的配置覆盖默认配置。<code>CustomSQLErrorCodesTranslation</code> 提供了根据错误码来映射异常的功能，代码示例 6-30 演示了如何通过它来扩展 MySQL 的异常配置。</p>\n<blockquote>\n<p><strong>代码示例 6-30</strong>　使用 <code>CustomSQLErrorCodesTranslation</code> 来扩展 MySQL 异常码逻辑</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;bean id=\"MySQL\" class=\"org.springframework.jdbc.support.SQLErrorCodes\"&gt;\n    &lt;property name=\"databaseProductNames\"&gt;\n        &lt;list&gt;\n            &lt;value&gt;MySQL&lt;/value&gt;\n            &lt;value&gt;MariaDB&lt;/value&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n    &lt;property name=\"badSqlGrammarCodes\"&gt;\n        &lt;value&gt;1054,1064,1146&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"duplicateKeyCodes\"&gt;\n        &lt;value&gt;1062&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"dataIntegrityViolationCodes\"&gt;\n        &lt;value&gt;630,839,840,893,1169,1215,1216,1217,1364,1451,1452,1557&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"dataAccessResourceFailureCodes\"&gt;\n        &lt;value&gt;1&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"cannotAcquireLockCodes\"&gt;\n        &lt;value&gt;1205,3572&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"deadlockLoserCodes\"&gt;\n        &lt;value&gt;1213&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=\"customTranslations\"&gt;\n        &lt;bean class=\"org.springframework.jdbc.support.CustomSQLErrorCodesTranslation\"&gt;\n            &lt;property name=\"errorCodes\" value=\"123456\" /&gt;\n            &lt;property name=\"exceptionClass\" value=\"learning.spring.data.DbSwitchingException\" /&gt;\n        &lt;/bean&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<p>当然，还有另一种做法，即直接继承 <code>SQLErrorCodeSQLExceptionTranslator</code>，覆盖其中的 <code>customTranslate(String task, @Nullable String sql, SQLException sqlEx)</code> 方法，随后在 <code>JdbcTemplate</code> 中直接注入我们自己写的类实例。不过，在大部分情况下，前一种方法已经能够满足我们的需求了，大家可以根据实际情况来选择具体的方案。</p>\n<h2 id=\"nav_point_107\">6.5　小结</h2>\n<p>本章我们学习了 Spring Framework 中数据库操作的基础知识，尤其是聚焦在了数据源配置、JDBC 基础操作、事务管理和异常处理这四点上。</p>\n<p>其中，我们详细了解了 Spring Boot 2.<em>x</em> 推荐的 HikariCP 数据库连接池及其配置，以及如何用 Druid 来替换 HikariCP。并且我们还了解了 Spring 是如何帮助我们来简化 JDBC 操作的，<code>JdbcTemplate</code> 在各种场景中都非常好用。在事务管理和异常处理部分，不仅学习到了怎么运用这些东西，更是深入了解了它们背后的实现逻辑。</p>\n<p>下一章，我们将从 JDBC 切换到通过对象关系映射来操作数据库，看看在 Spring 中如何来使用 Hibernate 与 MyBatis。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发小结</strong></p>\n<p>本章我们为二进制奶茶店的核心服务 BinaryTea 增加了一个数据源，在其中存储了店铺中的菜单信息。此外，还为菜单表提供了相应的增加、删除和查询方法，并且在启动工程时还会初始化菜单并打印菜单的内容。</p>\n<p>在实际工作中，直接使用 JDBC 来做增删改查操作并不友好，更多的情况下还是会使用对象关系映射框架，下一章会对本章的 JDBC 代码进行比较大的重构。</p>\n</blockquote>\n\n<br style=\"page-break-after:always\" />","comments":[]}