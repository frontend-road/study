{"id":176075,"title":"16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？","content":"<p>在上一节课中，我们学习了单一职责原则。今天，我们来学习SOLID中的第二个原则：开闭原则。我个人觉得，开闭原则是SOLID中最难理解、最难掌握，同时也是最有用的一条原则。</p><p>之所以说这条原则难理解，那是因为，“怎样的代码改动才被定义为‘扩展’？怎样的代码改动才被定义为‘修改’？怎么才算满足或违反‘开闭原则’？修改代码就一定意味着违反‘开闭原则’吗？”等等这些问题，都比较难理解。</p><p>之所以说这条原则难掌握，那是因为，“如何做到‘对扩展开放、修改关闭’？如何在项目中灵活地应用‘开闭原则’，以避免在追求扩展性的同时影响到代码的可读性？”等等这些问题，都比较难掌握。</p><p>之所以说这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。</p><p>所以说，今天的内容非常重要，希望你能集中精力，跟上我的思路，将开闭原则理解透彻，这样才能更好地理解后面章节的内容。话不多说，让我们正式开始今天的学习吧！</p><h2>如何理解“对扩展开放、修改关闭”？</h2><p>开闭原则的英文全称是Open Closed Principle，简写为OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><!-- [[[read_end]]] --><p>这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p><p>为了让你更好地理解这个原则，我举一个例子来进一步解释一下。这是一段API接口监控告警的代码。</p><p>其中，AlertRule存储告警规则，可以自由设置。Notification是告警通知类，支持邮件、短信、微信、手机等多种通知渠道。NotificationEmergencyLevel表示通知的紧急程度，包括SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要），不同的紧急程度对应不同的发送渠道。关于API接口监控告警这部分，更加详细的业务需求分析和设计，我们会在后面的设计模式模块再拿出来进一步讲解，这里你只要简单知道这些，就够我们今天用了。</p><pre><code>public class Alert {\n  private AlertRule rule;\n  private Notification notification;\n\n  public Alert(AlertRule rule, Notification notification) {\n    this.rule = rule;\n    this.notification = notification;\n  }\n\n  public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {\n    long tps = requestCount / durationOfSeconds;\n    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) {\n      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n    }\n    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n    }\n  }\n}\n</code></pre><p>上面这段代码非常简单，业务逻辑主要集中在check()函数中。当接口的TPS超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。</p><p>现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢？主要的改动有两处：第一处是修改check()函数的入参，添加一个新的统计数据timeoutCount，表示超时接口请求数；第二处是在check()函数中添加新的告警逻辑。具体的代码改动如下所示：</p><pre><code>public class Alert {\n  // ...省略AlertRule/Notification属性和构造函数...\n  \n  // 改动一：添加参数timeoutCount\n  public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {\n    long tps = requestCount / durationOfSeconds;\n    if (tps &gt; rule.getMatchedRule(api).getMaxTps()) {\n      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n    }\n    if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n    }\n    // 改动二：添加接口超时处理逻辑\n    long timeoutTps = timeoutCount / durationOfSeconds;\n    if (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) {\n      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n    }\n  }\n}\n</code></pre><p>这样的代码修改实际上存在挺多问题的。一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了check()函数，相应的单元测试都需要修改（关于单元测试的内容我们在重构那部分会详细介绍）。</p><p>上面的代码改动是基于“修改”的方式来实现新功能的。如果我们遵循开闭原则，也就是“对扩展开放、对修改关闭”。那如何通过“扩展”的方式，来实现同样的功能呢？</p><p>我们先重构一下之前的Alert代码，让它的扩展性更好一些。重构的内容主要包含两部分：</p><ul>\n<li>第一部分是将check()函数的多个入参封装成ApiStatInfo类；</li>\n<li>第二部分是引入handler的概念，将if判断逻辑分散在各个handler中。</li>\n</ul><p>具体的代码实现如下所示：</p><pre><code>public class Alert {\n  private List&lt;AlertHandler&gt; alertHandlers = new ArrayList&lt;&gt;();\n  \n  public void addAlertHandler(AlertHandler alertHandler) {\n    this.alertHandlers.add(alertHandler);\n  }\n\n  public void check(ApiStatInfo apiStatInfo) {\n    for (AlertHandler handler : alertHandlers) {\n      handler.check(apiStatInfo);\n    }\n  }\n}\n\npublic class ApiStatInfo {//省略constructor/getter/setter方法\n  private String api;\n  private long requestCount;\n  private long errorCount;\n  private long durationOfSeconds;\n}\n\npublic abstract class AlertHandler {\n  protected AlertRule rule;\n  protected Notification notification;\n  public AlertHandler(AlertRule rule, Notification notification) {\n    this.rule = rule;\n    this.notification = notification;\n  }\n  public abstract void check(ApiStatInfo apiStatInfo);\n}\n\npublic class TpsAlertHandler extends AlertHandler {\n  public TpsAlertHandler(AlertRule rule, Notification notification) {\n    super(rule, notification);\n  }\n\n  @Override\n  public void check(ApiStatInfo apiStatInfo) {\n    long tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();\n    if (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) {\n      notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n    }\n  }\n}\n\npublic class ErrorAlertHandler extends AlertHandler {\n  public ErrorAlertHandler(AlertRule rule, Notification notification){\n    super(rule, notification);\n  }\n\n  @Override\n  public void check(ApiStatInfo apiStatInfo) {\n    if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n    }\n  }\n}\n</code></pre><p>上面的代码是对Alert的重构，我们再来看下，重构之后的Alert该如何使用呢？具体的使用代码我也写在这里了。</p><p>其中，ApplicationContext是一个单例类，负责Alert的创建、组装（alertRule和notification的依赖注入）、初始化（添加handlers）工作。</p><pre><code>public class ApplicationContext {\n  private AlertRule alertRule;\n  private Notification notification;\n  private Alert alert;\n  \n  public void initializeBeans() {\n    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码\n    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码\n    alert = new Alert();\n    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));\n    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));\n  }\n  public Alert getAlert() { return alert; }\n\n  // 饿汉式单例\n  private static final ApplicationContext instance = new ApplicationContext();\n  private ApplicationContext() {\n    initializeBeans();\n  }\n  public static ApplicationContext getInstance() {\n    return instance;\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ApiStatInfo apiStatInfo = new ApiStatInfo();\n    // ...省略设置apiStatInfo数据值的代码\n    ApplicationContext.getInstance().getAlert().check(apiStatInfo);\n  }\n}\n</code></pre><p>现在，我们再来看下，基于重构之后的代码，如果再添加上面讲到的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢？主要的改动有\b下面四处。</p><ul>\n<li>第一处改动是：在ApiStatInfo类中添加新的属性timeoutCount。</li>\n<li>第二处改动是：添加新的TimeoutAlertHander类。</li>\n<li>第三处改动是：在ApplicationContext类的initializeBeans()方法中，往alert对象中注册新的timeoutAlertHandler。</li>\n<li>第四处改动是：在使用Alert类的时候，需要给check()函数的入参apiStatInfo对象设置timeoutCount的值。</li>\n</ul><p>改动之后的代码如下所示：</p><pre><code>public class Alert { // 代码未改动... }\npublic class ApiStatInfo {//省略constructor/getter/setter方法\n  private String api;\n  private long requestCount;\n  private long errorCount;\n  private long durationOfSeconds;\n  private long timeoutCount; // 改动一：添加新字段\n}\npublic abstract class AlertHandler { //代码未改动... }\npublic class TpsAlertHandler extends AlertHandler {//代码未改动...}\npublic class ErrorAlertHandler extends AlertHandler {//代码未改动...}\n// 改动二：添加新的handler\npublic class TimeoutAlertHandler extends AlertHandler {//省略代码...}\n\npublic class ApplicationContext {\n  private AlertRule alertRule;\n  private Notification notification;\n  private Alert alert;\n  \n  public void initializeBeans() {\n    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码\n    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码\n    alert = new Alert();\n    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));\n    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));\n    // 改动三：注册handler\n    alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));\n  }\n  //...省略其他未改动代码...\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ApiStatInfo apiStatInfo = new ApiStatInfo();\n    // ...省略apiStatInfo的set字段代码\n    apiStatInfo.setTimeoutCount(289); // 改动四：设置tiemoutCount值\n    ApplicationContext.getInstance().getAlert().check(apiStatInfo);\n}\n</code></pre><p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的handler类即可，不需要改动原来的check()函数的逻辑。而且，我们只需要为新的handler类添加单元测试，老的单元测试都不会失败，也不用修改。</p><h2>修改代码就意味着违背开闭原则吗？</h2><p>看了上面重构之后的代码，你可能还会有疑问：在添加新的告警逻辑的时候，尽管改动二（添加新的handler类）是基于扩展而非修改的方式来完成的，但改动一、三、四貌似不是基于扩展而是基于修改的方式来完成的，那改动一、三、四不就违背了开闭原则吗？</p><p><strong>我们先来分析一下改动一：往ApiStatInfo类中添加新的属性timeoutCount。</strong></p><p>实际上，我们不仅往ApiStatInfo类中添加了属性，还添加了对应的getter/setter方法。那这个问题就转化为：给类中添加新的属性和方法，算作“修改”还是“扩展”？</p><p>我们再一块回忆一下开闭原则的定义：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。从定义中，我们可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。比如，改动一，添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为“扩展”。</p><p>实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。</p><p><strong>我们再来分析一下改动三和改动四：在ApplicationContext类的initializeBeans()方法中，往alert对象中注册新的timeoutAlertHandler；在使用Alert类的时候，需要给check()函数的入参apiStatInfo对象设置timeoutCount的值。</strong></p><p>这两处改动都是在方法内部进行的，不管从哪个层面（模块、类、方法）来讲，都不能算是“扩展”，而是地地道道的“修改”。不过，有些修改是在所难免的，是可以被接受的。为什么这么说呢？我来解释一下。</p><p>在重构之后的Alert代码中，我们的核心逻辑集中在Alert类及其各个handler中，当我们在添加新的告警逻辑的时候，Alert类完全不需要修改，而只需要扩展一个新handler类。如果我们把Alert类及各个handler类合起来看作一个“模块”，那模块本身在添加新的功能的时候，完全满足开闭原则。</p><p>而且，我们要认识到，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p><h2>如何做到“对扩展开放、修改关闭”？</h2><p>在刚刚的例子中，我们通过引入一组handler的方式来实现支持开闭原则。如果你没有太多复杂代码的设计和开发经验，你可能会有这样的疑问：这样的代码设计思路我\b怎么想不到呢？你是怎么想到的呢？</p><p>先给你个结论，\b之所以我能想到，靠的就是理论知识和实战经验，这些需要你慢慢学习和积累。对于如何做到“对扩展开放、修改关闭”，我们也有一些指导思想和具体的方法论，我们一块来看一下。</p><p>实际上，开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。</p><p><strong>在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。</strong></p><p>在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。</p><p>还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p><p><strong>刚刚我们讲了实现开闭原则的一些偏向顶层的指导思想，现在我们再来看下，支持开闭原则的一些更加具体的方法论。</strong></p><p>我们前面讲到，代码的扩展性是代码质量评判的最重要的标准之一。实际上，我们整个专栏的大部分知识点都是围绕扩展性问题来讲解的。专栏中讲到的很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。</p><p>在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。设计模式这一部分内容比较多，后面课程中我们能会详细讲到，这里就不展开了。今天我重点讲一下，如何利用多态、依赖注入、基于接口而非实现编程，来实现“对扩展开放、对修改关闭”。</p><p>实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。</p><p>接下来，我就通过一个例子来解释一下，如何利用这几个设计思想或原则来实现“对扩展开放、对修改关闭”。注意，依赖注入后面会讲到，如果你对这块不了解，可以暂时先忽略这个概念，只关注多态、基于接口而非实现编程以及抽象意识。</p><p>比如，我们代码中通过Kafka来发送异步消息。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。\b所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当我们要替换新的消息队列的时候，比如将Kafka替换成RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。具体代码如下所示：</p><pre><code>// 这一部分体现了抽象意识\npublic interface MessageQueue { //... }\npublic class KafkaMessageQueue implements MessageQueue { //... }\npublic class RocketMQMessageQueue implements MessageQueue {//...}\n\npublic interface MessageFromatter { //... }\npublic class JsonMessageFromatter implements MessageFromatter {//...}\npublic class ProtoBufMessageFromatter implements MessageFromatter {//...}\n\npublic class Demo {\n  private MessageQueue msgQueue; // 基于接口而非实现编程\n  public Demo(MessageQueue msgQueue) { // 依赖注入\n    this.msgQueue = msgQueue;\n  }\n  \n  // msgFormatter：多态、依赖注入\n  public void sendNotification(Notification notification, MessageFormatter msgFormatter) {\n    //...    \n  }\n}\n</code></pre><p>对于如何写出扩展性好的代码、如何实现“对扩展开放、对修改关闭”这个问题，我今天\b只是比较笼统地总结了一下，详细的知识我们在后面的章节中慢慢学习。</p><h2>如何在项目中灵活应用开闭原则？</h2><p>前面我们提到，写出支持“对扩展开放、对修改关闭”的代码的关键是预留扩展点。那问题是如何才能识别出所有可能的扩展点呢？</p><p>如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解“它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题。</p><p>不过，有一句话说得好，“唯一不变的只有变化本身”。即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。</p><p>最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。</p><p>而且，开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。比如，我们之前举的Alert告警的例子。为了更好地支持扩展性，我们对代码进行了重构，重构之后的代码要比之前的代码复杂很多，理解起来也更加有难度。很多时候，我们都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。</p><p>在我们之前举的Alert告警的例子中，如果告警规则并不是很多、也不复杂，那check()函数中的if语句就不会很多，代码逻辑也不复杂，代码行数也不多，那最初的第一种代码实现思路简单易读，就是比较合理的选择。相反，如果告警规则很多、很复杂，check()函数的if语句、代码逻辑就会很多、很复杂，相应的代码行数也会很多，可读性、可维护性就会变差，那重构之后的第二种代码实现思路就是更加合理的选择了。总之，这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的的重点内容。</p><p><strong>1.如何理解“对扩展开放、对修改关闭”？</strong></p><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p><p><strong>2.如何做到“对扩展开放、修改关闭”？</strong></p><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><h2>课堂讨论</h2><p>学习设计原则，要多问个为什么。不能把设计原则当真理，而是要理解设计原则背后的思想。搞清楚这个，比单纯理解原则讲的是啥，更能让你灵活应用原则。所以，今天课堂讨论的话题是，为什么我们要“对扩展开放、对修改关闭”？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？","id":171771},"right":{"article_title":"17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？","id":177110}},"comments":[{"had_liked":false,"id":159920,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1575842342,"is_pvip":false,"discussion_count":16,"race_medal":0,"score":"2999463014950","product_id":100039001,"comment_content":"对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！","like_count":699,"discussions":[{"author":{"id":1068819,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","nickname":"永旭","note":"","ucode":"C9C74BE32C8F46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270758,"discussion_content":"为什么你能总结的这么清晰而简洁 . 佩服","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1590048380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116862,"avatar":"","nickname":"leior","note":"","ucode":"82AEBD0D254362","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159041,"discussion_content":"既要考虑未来，又要考虑已有","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1580650009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1632716,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e9/cc/1eb3120e.jpg","nickname":"至今未来","note":"","ucode":"ED6F557FDB0B5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106256,"discussion_content":"同时 我觉得对扩展开放也是在提高代码的复用 ","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577526112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2273754,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/da/5602cb4b.jpg","nickname":"king","note":"","ucode":"1E5BD0E2A789C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1632716,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e9/cc/1eb3120e.jpg","nickname":"至今未来","note":"","ucode":"ED6F557FDB0B5B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319119,"discussion_content":"牛批老哥，的确有这种意味","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603946431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":106256,"ip_address":""},"score":319119,"extra":""}]},{"author":{"id":1269792,"avatar":"","nickname":"Geek_527ae1","note":"","ucode":"561DBD6D8A8EDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318324,"discussion_content":"精辟","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603705170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241613,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/0d/d567a50a.jpg","nickname":"Bezier","note":"","ucode":"FDD57CB90E12C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218298,"discussion_content":"总结的简单粗暴，短小又精悍","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585645816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549661,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a5/5d/22829a03.jpg","nickname":"等等 女皇","note":"","ucode":"81423644144550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369839,"discussion_content":"扩展开放的的扩展并非指需求层面要扩展，而是指代码设计的易于扩展，好的扩展往往就是增加东西，而非修改已有的，这样被影响的代码的范围就少了，修改也就关闭了。而在这之前就要做好变化和不变化的隔离设计。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619170810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1549661,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a5/5d/22829a03.jpg","nickname":"等等 女皇","note":"","ucode":"81423644144550","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375243,"discussion_content":"是需求方面需要扩展才引起的代码层面需要扩展吧，修改的关闭主要是为了系统的稳定性和可维护性","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621527272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":369839,"ip_address":""},"score":375243,"extra":""}]},{"author":{"id":1014534,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq6LGLtCCNoIf8S09fxcvk1OrTicPibZgX3kf8aaowY5nD8mTicH9SZZ8SlxgJvppqPThK1cEibrlA7bw/132","nickname":"秦汉2022","note":"","ucode":"C99D56B44F79C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300062,"discussion_content":"一语中的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597924768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299377,"discussion_content":"短小精悍，给你个赞。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597668646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2833619,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","nickname":"探雪","note":"","ucode":"2332650D9C8D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531725,"discussion_content":"短小精悍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637397294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4a/96/8756eaa2.jpg","nickname":"王也","note":"","ucode":"9EA69B51ECC99F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374828,"discussion_content":"概念都理解错了还弹性呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621384691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1597071,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","nickname":"Geek_00e01b","note":"","ucode":"BC76A83B53D0EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328557,"discussion_content":"弹性，张力，搞不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606180351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517556,"avatar":"https://static001.geekbang.org/account/avatar/00/17/27/f4/a1ce6248.jpg","nickname":"一尾","note":"","ucode":"67D404036231D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304484,"discussion_content":"汉语博大精深....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599578348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1738272,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/20/e71b5585.jpg","nickname":"蓝二哥哥我才是无羡啊👻","note":"","ucode":"E70EE4E08F16AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295395,"discussion_content":"说得好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596181873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2058308,"avatar":"","nickname":"Geek_71cea9","note":"","ucode":"DE88271BA527DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289996,"discussion_content":"说的真好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594296970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159942,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1575849682,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"508381990610","product_id":100039001,"comment_content":"开闭原则：基于接口或抽象实现“封闭”，基于实现接口或继承实现“开放”（拓展）。<br><br>争哥的第一个例子，AlertHandler为抽象，一般是固定不变的。子类TpsAlertHandler为继承；再看第二个例子，MessageQueue，MessageFormater为接口，具体实现为KafkaMessageQueue和JsonMessageFromatter等。以后替换或者增加其他的AlertHandler和message queue很容易。<br><br>两个例子中的抽象类和接口是固定的（封闭），继承或实现是可扩展的。通过“抽象-具体”体现了开闭原则，增加了软件的可维护性。<br><br>开闭原则具体应用，需要慢慢积累经验。争哥也说了，首先需要有对业务深刻的理解。其次就是学习一些设计原则和模式了。<br><br>补充：<br>1、Bertrand Meyer 1988 年提出open-closed principle。<br>2、再推荐一篇经典文章 Robert C. Martin 2006年写的The Open-Closed Principle。不方便下载的话，我放到github上了：https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;tree&#47;master&#47;designpattern&#47;pdf","like_count":119,"discussions":[{"author":{"id":1442885,"avatar":"https://static001.geekbang.org/account/avatar/00/16/04/45/0c474d47.jpg","nickname":"二少","note":"","ucode":"190983809CD3EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366514,"discussion_content":"用一层&#34;虚&#34;的东西去隔离可变的部分。让调用方与这层&#34;虚&#34;的东西交互，从而将易变的转化成不变的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618103630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517556,"avatar":"https://static001.geekbang.org/account/avatar/00/17/27/f4/a1ce6248.jpg","nickname":"一尾","note":"","ucode":"67D404036231D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304485,"discussion_content":"你是课代表吧hhhh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599578405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316454,"avatar":"https://static001.geekbang.org/account/avatar/00/14/16/66/083e7f7e.jpg","nickname":"silent","note":"","ucode":"325D31F0608249","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284586,"discussion_content":"我看完老师的，一定要再来看看你的回复，才算学完这节课哈哈。点赞！方便加个微信不？向你学习！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592563456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1316454,"avatar":"https://static001.geekbang.org/account/avatar/00/14/16/66/083e7f7e.jpg","nickname":"silent","note":"","ucode":"325D31F0608249","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284599,"discussion_content":"过奖了！后期的课程我回复的没那么认真了，惭愧。近期事情少了，要补回来。v信guodong-hu","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592565461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284586,"ip_address":""},"score":284599,"extra":""}]},{"author":{"id":1153592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","nickname":"anders","note":"","ucode":"610C80D742C331","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267537,"discussion_content":"老铁，你的阅读量很丰富哇~点个赞学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589643574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159974,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1575853296,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"186259447024","product_id":100039001,"comment_content":"听前一部分的时候觉得，哇原来代码还可以这样重构，我以后写代码一定要这么写！看到最后，恩……还是要结合具体业务需求，考虑实现开闭的代价，取舍哪些需要适应开闭原则哪些可以忽略，避免过度设计。整体来说在写代码的时候要多思考一下如何应对短期内可能面临的变化。知识+经验+多思考，看起来编程没有银弹，多思考，多总结。","like_count":43,"discussions":[{"author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119330,"discussion_content":"我觉得你一定要那么写，首先要能写出那样的代码才会建立起来设计思想。抽象思维。其次，一堆if语句是最恶心的代码没有之一","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578226940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560011,"discussion_content":"我觉得一定要这么写，因为不写  过几天就忘记了  然后就没有然后了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649122649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2516041,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/1UV7tTtMTM8hyvGl2YaSVczZve3e2aOcrRafvg64WQo7hYRRzGnondFElhGv0RnQZQgn6PycYzal2b5oAwYXtg/132","nickname":"太行山人","note":"","ucode":"66EB8BFD311A45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542235,"discussion_content":"避免过度设计，知其然，知其所以然，具体问题，具体对待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640688523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159916,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575839443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"151899694803","product_id":100039001,"comment_content":"基于一定的粒度（例如模块，类，属性等），扩展是平行地增加，修改是变更更细粒度的子集。扩展和修改和具体的粒度有关。不同的粒度下，扩展和修改定义不同。<br>我个人以为，扩展的结果是引入了更多的平行结构（例如相似的派生类handler），以及支持这些平行结构的代码（利用多态，在关键的地方使用接口）。这些引入会让代码结构变的扁平一些，但是也更晦涩一些。修改，往往会增加代码的深度（这里指更低粒度的复杂度），例如，文中log例子，修改后，check函数有五个参数，内部的if else逻辑更多。但是，如果从参数以及if作用域的角度，这也可算作扩展。所以，扩展还是修改更本质的区别在于修改发生的粒度和层次。<br>通常偏好修改发生在更高的层次上，这要求我们能够用接口和组合把系统合理的切分，做到高内聚和低耦合。高内聚可以让修改发生在更高层次上，替换掉整个低层次实现细节。低耦合，可以让模块之间的调用最小化，可以让高层次的修改最小化。<br>支持高层次的平行结构不是免费的，除非有明确的收益（例如文中隔离Kafka实现细节的例子），不然还是让重构等待到需要的那一刻，预测未来的大部分平行结构其实不会被真正用到。","like_count":36},{"had_liked":false,"id":165746,"user_name":"古杨","can_delete":false,"product_type":"c1","uid":1744092,"ip_address":"","ucode":"8F52AA86B589C7","user_header":"","comment_is_top":false,"comment_ctime":1577316492,"is_pvip":false,"discussion_count":24,"race_medal":0,"score":"143311237260","product_id":100039001,"comment_content":"我所在的公司，现在写代码入参全用map，写了两年我都不知道什么叫对象了。感觉自己废了☹️","like_count":34,"discussions":[{"author":{"id":1031309,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bc/8d/580ca194.jpg","nickname":"晓梦迷蝴蝶","note":"","ucode":"DC638290229B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215394,"discussion_content":"Map 就没有oop概念了 更没有后面的重构 设计模式 我带团队这种是直接批评的","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1585320596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":8,"child_discussions":[{"author":{"id":1264287,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/9f/b92a9139.jpg","nickname":"hj","note":"","ucode":"6ED34286AC30FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1031309,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bc/8d/580ca194.jpg","nickname":"晓梦迷蝴蝶","note":"","ucode":"DC638290229B6F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245061,"discussion_content":"会有哪些问题呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587648928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215394,"ip_address":""},"score":245061,"extra":""},{"author":{"id":1033096,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","nickname":"如来神掌","note":"","ucode":"45E20FF935BD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1264287,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/9f/b92a9139.jpg","nickname":"hj","note":"","ucode":"6ED34286AC30FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278992,"discussion_content":"点儿不出来提示😃","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1591269149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":245061,"ip_address":""},"score":278992,"extra":""},{"author":{"id":1624574,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","nickname":"benxiong","note":"","ucode":"F6498059D439D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1033096,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","nickname":"如来神掌","note":"","ucode":"45E20FF935BD2F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282022,"discussion_content":"哈哈哈一语道破真谛","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591863017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278992,"ip_address":""},"score":282022,"extra":""}]},{"author":{"id":1005630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/3e/77c9b529.jpg","nickname":"Sanhong","note":"","ucode":"0B68D6EE423CA8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328889,"discussion_content":"我司也是，来的时候，很吃惊，现在已被同化","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1606267615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1036273,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cf/f1/bf63fef6.jpg","nickname":"洛子墟","note":"","ucode":"CFC500D00F0B9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209063,"discussion_content":"优点是接口改动小，缺点太多，槽点也太多了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584605338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1264287,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/9f/b92a9139.jpg","nickname":"hj","note":"","ucode":"6ED34286AC30FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1036273,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cf/f1/bf63fef6.jpg","nickname":"洛子墟","note":"","ucode":"CFC500D00F0B9B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245060,"discussion_content":"缺点和槽点能否列举一二","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587648904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":209063,"ip_address":""},"score":245060,"extra":""},{"author":{"id":1139384,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/b8/bb9657c6.jpg","nickname":"Promise°","note":"","ucode":"0BFDBDAD852D6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1264287,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/9f/b92a9139.jpg","nickname":"hj","note":"","ucode":"6ED34286AC30FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293382,"discussion_content":"个人见解:\n   1. 接口数据不明确,不通俗易懂 比如: chngeUserName(userid,userName) 入参为这两个参数 但如果为Map的话 可能就要具体到去撸实现才能知道需要传递什么参数 原则上接口是实体类的话,也会有这个问题 不过相对来说实际参数或对象会比map好一些 mp即使增加了参数也看不出来 \n   2. 实现类的校验逻辑及其数据转换需要处理 如果是map的话 尤其是多参数 基础数据类型和对象都存在 数据需要强转 并且实现类如果改了类型 调用方是无法察觉的 存在转换异常的情况","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1595516068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":245060,"ip_address":""},"score":293382,"extra":""},{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1264287,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/9f/b92a9139.jpg","nickname":"hj","note":"","ucode":"6ED34286AC30FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561189,"discussion_content":"一个方法还好，如果套娃一样都使用Map，请问 其他模块使用你的方法，如何知道接口的入参都有什么？ 如果你在其中改了一个Map的数据 其他地方是无法察觉的，直接GG","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649573809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":245060,"ip_address":""},"score":561189,"extra":""}]},{"author":{"id":1328500,"avatar":"https://static001.geekbang.org/account/avatar/00/14/45/74/7a82eebb.jpg","nickname":"Ins","note":"","ucode":"A2509BAD9CB72C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577459,"discussion_content":"存在即合理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656128145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251242,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/aa/c00c0fdd.jpg","nickname":"七公里蔚蓝","note":"","ucode":"CD08CDEAEF2DE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577311,"discussion_content":"写lua的表示传入参数是个表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656036117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2575050,"avatar":"https://static001.geekbang.org/account/avatar/00/27/4a/ca/3b941a89.jpg","nickname":"立冬","note":"","ucode":"6E83A56084DDEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551911,"discussion_content":"map方便热部署","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645172589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334583,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5d/37/061e7fac.jpg","nickname":"小苗晓雪","note":"","ucode":"B15FDF455853D2","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541906,"discussion_content":"牛哇~那对你们单位来说模型的概念完全没有 , 就算用模型也只为了点语法而已 , 那这么个写法是纯纯的贫血模型的写法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640599051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1313365,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/55/5e440425.jpg","nickname":"振振","note":"","ucode":"ECE08186230140","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400576,"discussion_content":"如果你经常用map传参，可能你这一层没啥业务价值😅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633335183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1259156,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/94/0b969588.jpg","nickname":"青年祭司","note":"","ucode":"C88EDAE3FF09AE","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379325,"discussion_content":"我司也是，所以一定要把注释写清楚，不然读代码很费劲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623830381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3d/fc/f81d7847.jpg","nickname":"BATMAN","note":"","ucode":"414137A1074E62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352506,"discussion_content":"我刚工作时候也是这样，现在看到用map入参的想打人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614757648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2346442,"avatar":"","nickname":"Geek_8e5ba8","note":"","ucode":"0F8B4D869F4A9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336516,"discussion_content":"我们这是查询接口入参用map，更新用对象接参","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608613517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144171,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/6b/fd685164.jpg","nickname":"lcf枫","note":"","ucode":"D51E8F68BD41CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199572,"discussion_content":"Python吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583594325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1744092,"avatar":"","nickname":"古杨","note":"","ucode":"8F52AA86B589C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144171,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/6b/fd685164.jpg","nickname":"lcf枫","note":"","ucode":"D51E8F68BD41CA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200174,"discussion_content":"JAVA啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583664513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199572,"ip_address":""},"score":200174,"extra":""}]}]},{"had_liked":false,"id":159914,"user_name":"(´田ω田`)","can_delete":false,"product_type":"c1","uid":1210588,"ip_address":"","ucode":"CA043D3EC6FE7E","user_header":"https://static001.geekbang.org/account/avatar/00/12/78/dc/0c9c9b0f.jpg","comment_is_top":false,"comment_ctime":1575827243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"91770140459","product_id":100039001,"comment_content":"修改老功能，可能需要重新进行各种功能验证、测试，并且如果是接收的遗留代码，更是费时费力；<br>但是扩展的话，只需要对自己新增加的功能进行测试，工作量会小很多。","like_count":21},{"had_liked":false,"id":197873,"user_name":"01Running","can_delete":false,"product_type":"c1","uid":1015862,"ip_address":"","ucode":"2E50E4FD35D3B5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/36/29e4863f.jpg","comment_is_top":false,"comment_ctime":1585401586,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"70304878322","product_id":100039001,"comment_content":"计算机技术就是一门权衡的技术！","like_count":16,"discussions":[{"author":{"id":1149564,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8a/7c/949163dd.jpg","nickname":"成业梁","note":"","ucode":"530EB2C9718699","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291088,"discussion_content":"艺术","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594704681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2093150,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f0/5e/e06261fd.jpg","nickname":"如风过境","note":"","ucode":"318A4E85AF231C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1149564,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8a/7c/949163dd.jpg","nickname":"成业梁","note":"","ucode":"530EB2C9718699","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578306,"discussion_content":"学的好的代码确实是艺术","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656645530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291088,"ip_address":""},"score":578306,"extra":""}]},{"author":{"id":1207410,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","nickname":"紫日","note":"","ucode":"73A8DEE323AC19","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317225,"discussion_content":"虽然计算机只认识0和1，但计算及技术服务于人多，人的行为因时因势而定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603518388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159917,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1575840633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70295317369","product_id":100039001,"comment_content":"对原有代码改动越少，引入问题的概率越小。在熟悉业务的情况下，多思考一步，为了未来需求预留扩展点，就是有扩展性的代码。但凡事都有个度，扩展性和可读性需要不断权衡，需求在不断变化，系统也在不断演化，通过不断重构来解决过度设计的问题。","like_count":16},{"had_liked":false,"id":160767,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1181486,"ip_address":"","ucode":"E82C58AF2604ED","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/2e/878d3c92.jpg","comment_is_top":false,"comment_ctime":1576030650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61705572794","product_id":100039001,"comment_content":"文章写的是真的好，很容易读懂。主要的还是要知道为什么要这么做。感谢老师。","like_count":14},{"had_liked":false,"id":162986,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1258380,"ip_address":"","ucode":"BFA3BE8D8773A7","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/8c/23eef8d7.jpg","comment_is_top":false,"comment_ctime":1576638139,"is_pvip":false,"replies":[{"id":"62272","content":"重载可以。但如果报警规则很多的花 类会无限膨胀 可读性比较茶","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1576797986,"ip_address":"","comment_id":162986,"utype":1}],"discussion_count":9,"race_medal":0,"score":"57411212987","product_id":100039001,"comment_content":"文中的alter 一步一步的改造，看的眼花缭乱的😂，我就问下，为什么不能直接在原始的Alter 类中，重载一个只有新增业务参数的check 放到的，这样不就最简单，原先开发好也不用动，这样对于Alter 类来说不是对扩展开放，对修改关爱了吗？请教下大神，我这种用重载的思路有啥，不好的地方","like_count":13,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478198,"discussion_content":"重载可以。但如果报警规则很多的花 类会无限膨胀 可读性比较茶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576797986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2310814,"avatar":"","nickname":"Geek_d42e24","note":"","ucode":"CF7267A42B5E30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393918,"discussion_content":"重载是像c++ java等复杂面相对象语言才有的，go这种灵活的oop语言不支持重载。另外如果重载方法很多，看代码是真的是很有心智负担。调用者也得小心翼翼的传参。而通过不同hander实现类的方式不会存在这些问题","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631637099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607988,"avatar":"https://static001.geekbang.org/account/avatar/00/18/89/34/758bd3ab.jpg","nickname":"曉楓","note":"","ucode":"E2B4C10FC4DAB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307239,"discussion_content":"感觉任何设计原则都是基于数据量大或者需求复杂才有价值的，不能老是杀鸡用牛刀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600567308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1608383,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","nickname":"X_L～","note":"","ucode":"6BD8C24750F86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302849,"discussion_content":"作者的例子还是简单的demo级别的,实际生产过程中确实得考虑直接重载的复杂性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599046961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064902,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3f/c6/c2bf55bd.jpg","nickname":"devilyaos","note":"","ucode":"5FE075608F03F7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545977,"discussion_content":"重载是要看参数位置和类型的，也许扩展需求里相同位置的参数表达的含义是不同的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642120419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1982711,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/40/f7/e62bbc62.jpg","nickname":"zh","note":"","ucode":"98772B1B6C6E06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342681,"discussion_content":"有两个路子改起来最省事：1.添加一个参数，然后给个默认值-1，然后函数里写等于-1就是老代码，不做check，否则执行新的逻辑；2.要满足开闭原则是吧，那添加一个重载函数。这两个路子都有个问题：在进行大规模重构（耦合度太高，参数加了好几个了）或性能优化的时候（函数里面的逻辑执行效率低，需要提前建立缓存，把部分逻辑放在函数外先执行，或者使用其它对象的数据，或者需要调换执行顺序，或者里面的算法要换，等等），这个时候如果参数过多（特别是默认参数）或者重载版本过多（比如有十来个），做性能优化的人会非常痛苦，明明知道性能瓶颈在哪，也知道改进方法，但是面对一坨坨的代码，根本改不动。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610775644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122277,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/e5/053ebfc9.jpg","nickname":"•••","note":"","ucode":"D7F185FC4BFE14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332810,"discussion_content":"其实进行按照错误分类后重载也是一种实现方式，每一种错误都重载确实一点扯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607345404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622209,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c0/c1/414d5d1b.jpg","nickname":"_yh葱","note":"","ucode":"FA899711E91113","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311176,"discussion_content":"重载确实也是另外一种实现方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602243756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1622209,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c0/c1/414d5d1b.jpg","nickname":"_yh葱","note":"","ucode":"FA899711E91113","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561190,"discussion_content":"重载  比较复杂，并且让可读性越来越差","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649573885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311176,"ip_address":""},"score":561190,"extra":""}]}]},{"had_liked":false,"id":160407,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1575945799,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"48820586055","product_id":100039001,"comment_content":"简单来说，就是尽量减少调用方为了应对而导致的变更。<br>就例如本文的例子，为了应对变化需要增加函数的参数的时候。所有调用方都需要改代码。<br>而如果依照开闭原则，则增加handler 以及相应修改即可。并不会影响调用方。<br><br>其实个人认为，也是通过了 类似于“中间件”的形式。例如，小明，作为公司代表需要跟各个国外公司的人谈业务。他去跟美国人谈业务，需要学英语；跟日本谈业务，要学日语；跟毛子谈业务，又要学毛子语。<br>这时候，的解决方案：<br>1，跟各个国家说好，大家都说英语。或者都说汉语。就算再有其他的国家，也让他强制用英语。<br>2，小明自己只用汉语。然后谈业务时，带个多语种翻译，去谈业务时把翻译带上。这时候，如果有新的国家需要新的语种，那么就让翻译去掌握更多的语种。<br>应对今天的例子，翻译掌握的语种，其实就是handler。小明和各国代表谈业务时，各自都不需要变更自己的接口。只需要对【翻译】进行扩展即可。","like_count":11,"discussions":[{"author":{"id":1087243,"avatar":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","nickname":"zhou","note":"","ucode":"E1CE8575B3F106","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263453,"discussion_content":"你的理解就是说话的接口 由各个翻译实现了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589207720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260728,"discussion_content":"还是从代码理解好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588897880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159923,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1575846463,"is_pvip":false,"replies":[{"id":"61125","content":"1. 是贫血模型<br>2. 不好讲，拆分之后，类增加，维护成本高一些，但职责更单一，更加高内聚、低耦合，扩展性更好些。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1575896283,"ip_address":"","comment_id":159923,"utype":1}],"discussion_count":5,"race_medal":0,"score":"48820486719","product_id":100039001,"comment_content":"关于修改后的报警规则代码实现有两个疑问：<br>1. ApiStateInfo class 是充血模型还是贫血模型。<br>2.其实各个handler侧重的是不同的方方面面，比如错误次数，超时次数。统一接收ApiStateInfo  和 某一个handler接收具体的类比如：ErrorRequestApiStateInfo,  TimeOutStateInfo， 哪种方式好呢？比较依据是什么","like_count":11,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477208,"discussion_content":"1. 是贫血模型\n2. 不好讲，拆分之后，类增加，维护成本高一些，但职责更单一，更加高内聚、低耦合，扩展性更好些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289362,"discussion_content":"或者继承统一父类ApiStateInfo ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594081741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560013,"discussion_content":"没有一次到位的代码吧，考虑太多 可能项目直接Delay了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649122865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534049,"discussion_content":"确实 整体来说还是要根据之后的业务发展慢慢来重构拆分 一次性想到这么后面反而不是一个好的做法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638079390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202465,"avatar":"https://static001.geekbang.org/account/avatar/00/12/59/21/d2efde18.jpg","nickname":"布凡","note":"","ucode":"346FCD332F8BFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372542,"discussion_content":"是的，如果后边业务不断拓展就需要考虑针对ApiStateInfo的拆分的问题，那么通过哪种方式能将耦合拆分，使得改动最小呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620373519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159975,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1575853341,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44525526301","product_id":100039001,"comment_content":"设计模式_16<br># 作业：<br>开闭原则核心好处是：<br>- 减少因为新增功能而增加的工作量<br>- 减少因为新增功能而增加的出错数<br><br># 感想：<br>之前一直有一些执念，想要找到某一原则非黑即白的分割线。比如开闭原则，有两个极端：<br>- 任何的“修改”都不能接受<br>- 任何不能“扩展”的代码都不能接受<br>然后就进入了“走火入魔”的状态，最终陷入对原则的怀疑。<br><br>需求变更对于代码结构影响很大时，要提高对其扩展的权重；读到这里时，我拍了一下大腿，我想，我更加理解开闭原则了。","like_count":10,"discussions":[{"author":{"id":1328500,"avatar":"https://static001.geekbang.org/account/avatar/00/14/45/74/7a82eebb.jpg","nickname":"Ins","note":"","ucode":"A2509BAD9CB72C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577465,"discussion_content":"减少新增功能的工作量，这条就不对了🌚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656129024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160380,"user_name":"哈喽沃德","can_delete":false,"product_type":"c1","uid":1749033,"ip_address":"","ucode":"7620366C16826B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b0/29/7ab573f4.jpg","comment_is_top":false,"comment_ctime":1575943290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40230648954","product_id":100039001,"comment_content":"我想这篇对扩展开放，多修改关闭的文章应该会成为争哥这个设计模式系列最好的文章。很难想象，一个杰出的程序员的语言思维逻辑也是如此清晰。","like_count":9},{"had_liked":false,"id":160479,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1575958980,"is_pvip":true,"discussion_count":8,"race_medal":0,"score":"35935697348","product_id":100039001,"comment_content":"老师您好，我把代码实践了后发现， 单例初始化那块可能有点问题。private static final ApplicationContext instance = new ApplicationContext();<br><br>    private ApplicationContext() {<br>        instance.initializeBeans();<br>    }<br>这个“instance”报了空指针。","like_count":8,"discussions":[{"author":{"id":1048367,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/2f/172b942b.jpg","nickname":"扬帆起航","note":"","ucode":"708B686F19B8DE","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118004,"discussion_content":"直接 \nprivate ApplicationContext() {\n        this.initializeBeans();\n    }","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578146666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1588205,"avatar":"","nickname":"wood_wood","note":"","ucode":"3872CEB7507F82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79081,"discussion_content":"我感觉也是代码写错了，但是不用纠结，动点脑筋应该可以修改为正确的调用方式。学习不能只学形式，不动脑筋。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576053657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731701,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6c/75/16aca70e.jpg","nickname":"卡布奇诺","note":"","ucode":"218CEEF5328C7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78216,"discussion_content":"我这边也是，还有没有其他小伙伴遇到这个问题呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575984151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1570088,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","nickname":"deepz","note":"","ucode":"4BD23A44CDB384","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1731701,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6c/75/16aca70e.jpg","nickname":"卡布奇诺","note":"","ucode":"218CEEF5328C7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78770,"discussion_content":"final声明可以直接初始化，也就是调用空参，然而空参构造里又需要还未初始化成功的对象引用，instance，所以会空指针。我是真么理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576020616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78216,"ip_address":""},"score":78770,"extra":""}]},{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561191,"discussion_content":"构造函数不需要  instance.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649573970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352322,"discussion_content":"构造函数不需要 instance.喔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614682957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366413,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d9/8d/a6984f12.jpg","nickname":"Jason.w","note":"","ucode":"EE39ADEB7C6BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297083,"discussion_content":"单例对象也是需要通过构造器去实例化的，出现问题的原因是，你在构造函数里使用还没有实例化好的单例对象。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596769784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282715,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","nickname":"Wh1","note":"","ucode":"6D28506B99A285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201614,"discussion_content":"我是直接将初始化的逻辑放构造函数中，这样就没问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583815666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261887,"user_name":"航哥很帅","can_delete":false,"product_type":"c1","uid":1145270,"ip_address":"","ucode":"23A1CB2A3723AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/b6/faaa95a2.jpg","comment_is_top":false,"comment_ctime":1605570116,"is_pvip":true,"replies":[{"id":"96131","content":"总结的好","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701246,"ip_address":"","comment_id":261887,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27375373892","product_id":100039001,"comment_content":"之所以会有对扩展开放，对修改关闭的原则，是因为对扩展开放能够应对业务需求的变化，从而实现已有功能的扩展，而对修改关闭是为了保证在扩展新的需求是，能够保证已有功能的稳定。<br><br><br>对扩展开放，对修改关闭原则，听起来很简单，就是指我们在开发时尽可能的少修改已有的代码，而应该增加新的代码来实现新的功能。但对于这个原则，往往是很难绝对执行的，因为即使是完全增加新的功能，也很难做到百分百不修改原来的代码。所以，对扩展开放，对修改关闭的原则，用大白话来说就是在尽可能少修改以后功能代码的情况下，通过增加新的功能代码来实现新的功能。<br><br><br>如果想做到对扩展开放，对修改关闭，作为一个程序员要有扩展意识、封装意识和抽象意识。这三个意识听起来很简单，但要真正的做到必须要多实践多练习才能够慢慢的心领神会。","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509655,"discussion_content":"总结的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270440,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1609127096,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"23083963576","product_id":100039001,"comment_content":"个人认为可读性是第一位的，代码写的再NB,一个组的只有你自己能看懂有什么用呢？","like_count":5,"discussions":[{"author":{"id":2612274,"avatar":"https://static001.geekbang.org/account/avatar/00/27/dc/32/8b1c20a9.jpg","nickname":"升国旗","note":"","ucode":"5140BE3BB11165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377855,"discussion_content":"是不是该考虑一下提升组员的水平了","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1622910127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2671691,"avatar":"https://static001.geekbang.org/account/avatar/00/28/c4/4b/bf30a25e.jpg","nickname":"Honey,","note":"","ucode":"00AB03C755AD79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2612274,"avatar":"https://static001.geekbang.org/account/avatar/00/27/dc/32/8b1c20a9.jpg","nickname":"升国旗","note":"","ucode":"5140BE3BB11165","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390778,"discussion_content":"代码牛逼 也可以是一个贬义词","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630044810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377855,"ip_address":""},"score":390778,"extra":""}]},{"author":{"id":2833619,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","nickname":"探雪","note":"","ucode":"2332650D9C8D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531727,"discussion_content":"没有绝对的事物，可读性虽然好，但是可维护性低，不符合高内聚低耦合也是垃圾代码","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637397594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/7e/b6829040.jpg","nickname":"SevenMonths","note":"","ucode":"62A9740FBD1FAE","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405319,"discussion_content":"另外一个词叫不可替代性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634555525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1328500,"avatar":"https://static001.geekbang.org/account/avatar/00/14/45/74/7a82eebb.jpg","nickname":"Ins","note":"","ucode":"A2509BAD9CB72C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1201022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/7e/b6829040.jpg","nickname":"SevenMonths","note":"","ucode":"62A9740FBD1FAE","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":577466,"discussion_content":"通透啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1656129101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":405319,"ip_address":""},"score":577466,"extra":""}]},{"author":{"id":1098720,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","nickname":"技术骨干","note":"","ucode":"8FCF8DE6D29201","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545219,"discussion_content":"就按照jdk的标准来写就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641877945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160221,"user_name":"土豆哪里挖","can_delete":false,"product_type":"c1","uid":1370705,"ip_address":"","ucode":"F27B3BA0477050","user_header":"https://static001.geekbang.org/account/avatar/00/14/ea/51/9132e9cc.jpg","comment_is_top":false,"comment_ctime":1575893512,"is_pvip":false,"replies":[{"id":"61121","content":"关注我的github：https:&#47;&#47;github.com&#47;wangzheng0822","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1575895647,"ip_address":"","comment_id":160221,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23050729992","product_id":100039001,"comment_content":"什么时候出其他语言的demo呢，不懂java，理解起来太痛苦了","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477300,"discussion_content":"关注我的github：https://github.com/wangzheng0822","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575895647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1738272,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/20/e71b5585.jpg","nickname":"蓝二哥哥我才是无羡啊👻","note":"","ucode":"E70EE4E08F16AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295398,"discussion_content":"同感，不太熟悉Java，看代码很费劲","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596182334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1734573,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/77/ad/b4089a68.jpg","nickname":"Yule_J","note":"","ucode":"A36E41BDC1189E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1738272,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/20/e71b5585.jpg","nickname":"蓝二哥哥我才是无羡啊👻","note":"","ucode":"E70EE4E08F16AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382104,"discussion_content":"同感，看GitHub还是没有其他语言的如Python","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625412557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295398,"ip_address":""},"score":382104,"extra":""}]}]},{"had_liked":false,"id":160438,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1575951277,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18755820461","product_id":100039001,"comment_content":"spring 是如何应用开闭原则的，可以参考本文https:&#47;&#47;blog.csdn.net&#47;wenxueliu&#47;article&#47;details&#47;103467359","like_count":4,"discussions":[{"author":{"id":1649057,"avatar":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","nickname":"hello","note":"","ucode":"4F42DAA5DB5C38","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319861,"discussion_content":"短短三年就开始搞源码了，佩服佩服。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604146540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","nickname":"Mr wind","note":"","ucode":"484F02D1962239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99755,"discussion_content":"多谢分享，另外丁雪峰的spring全家桶也讲了这个返回值处理器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577202620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159937,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1575849157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18755718341","product_id":100039001,"comment_content":"扩展指的是“修改”或替换一个系统的功能，修改指的是对系统整体结构的篡改。系统的整体架构是不应该有大变动的，它相当于系统的本质，是相对稳定的部分。如果乱动的话，系统会变得连妈都不认识。<br><br>开闭原则不仅用于软件开发，拿计算机硬件设计为例。计算机的本质在于计算，这是计算机稳定的部分，是不应该乱动的。对应与计算机中的硬件就是CPU，CPU的指令集可以说相当稳定，几十年来几乎只是从16位变成32位，64位。（这里是不是也体现了开闭？当然这不是重点）。而io的部分是异变的，磁盘，显示器，鼠标，打印机，不一而足。稳定的是什么，是输入输出（相当于没说，本来就是io嘛）。对于计算机来说，它不管你使用什么io设备。在我CPU看来，就是在执行一条io指令（指令本身是稳定的），具体io逻辑的实现交给各种设备控制器。妥妥的开闭原则。","like_count":4},{"had_liked":false,"id":183405,"user_name":"Remember九离","can_delete":false,"product_type":"c1","uid":1237327,"ip_address":"","ucode":"97EE6E6344689F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","comment_is_top":false,"comment_ctime":1583034513,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14467936401","product_id":100039001,"comment_content":"PHPer 的朋友 我根据上面需求实现了一遍,感兴趣的可以看下: https:&#47;&#47;github.com&#47;wuqinqiang&#47;php-design-patterns&#47;tree&#47;master&#47;src&#47;object&#47;ocp","like_count":3,"discussions":[{"author":{"id":2651986,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/86oSia4b8CE4FuJ0cYrK0icQsmnicqs9GKlZViaX36spYeibiaDibgbeSiaicyK0plItvvwpaXbunwcprBZicT6escbkqowQ/132","nickname":"Geek_d304c0","note":"","ucode":"E094F658AA407C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411902,"discussion_content":"学习了 兄弟\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636029610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161223,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1576150751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14461052639","product_id":100039001,"comment_content":"结合徐式伟老师的课效果更好<br>第一，模块的业务要稳定。模块的业务遵循 “只读” 设计，如果需要变化不如把它归档，放弃掉。这种模块业务只读的思想，是架构治理的基础哲学。<br>第二，模块的业务变化点，简单一点的，通过回调函数或者接口开放出去，交给其他的业务模块。复杂一点的，通过引入插件机制把系统分解为 “最小化的核心系统 + 多个彼此正交的周边系统”。事实上回调函数或者接口本质上就是一种事件监听机制，所以它是插件机制的特例。<br>文章链接：https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;175236","like_count":3},{"had_liked":false,"id":232043,"user_name":"了@事@牵","can_delete":false,"product_type":"c1","uid":1036582,"ip_address":"","ucode":"A3721378E1FC2C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/26/f455adcb.jpg","comment_is_top":false,"comment_ctime":1593840653,"is_pvip":true,"replies":[{"id":"85669","content":"是的，我改下，多谢指出","user_name":"作者回复","comment_id":232043,"uid":"1190123","ip_address":"","utype":1,"ctime":1593909715,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10183775245","product_id":100039001,"comment_content":"争哥，<br>public class MessageFormatter implements MessageFormatter {&#47;&#47;...}<br>这段代码是不是有问题？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500488,"discussion_content":"是的，我改下，多谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593909715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160055,"user_name":"辉仔lovers","can_delete":false,"product_type":"c1","uid":1210219,"ip_address":"","ucode":"3DC5B0CD0B8E71","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVhJRVwJ0eVlC7zjNfWP6PP7VmUkF1X2m6qfh7Wic3NhAOz2fSGibF6LXLcJ59zOz7nBpCcByvtFjw/132","comment_is_top":false,"comment_ctime":1575861429,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10165796021","product_id":100039001,"comment_content":"老师 您好，请教几个问题<br>AlertHandler 使用的是抽象类，而不是接口。就是为了让子类去继承构造方法吗？<br>这个扩展跟spring中handlerMapping的写法一样，类似于策略模式吧？<br>单例模式的时候 使用静态代码块来初始化添加handler 随着类加载一次是不是就不用搞成单例的了？<br> static{<br>        alertRule = new AlertRule(&#47;*.省略参数.*&#47;); &#47;&#47;省略一些初始化代码<br>        notification = new Notification(&#47;*.省略参数.*&#47;); &#47;&#47;省略一些初始化代码<br>         alert = new Alert(alertRule,notification);<br>         alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));<br>         alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));<br>    }<br><br>我们是不是可以把实现类（不同的handler）放到配置文件中。使用jdk的spi扩展机制。更加灵活一些？","like_count":2,"discussions":[{"author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88924,"discussion_content":"SPI机制用在这里不合适吧，SPI本身是因为类加载器的问题，作出的一个妥协。而且你这是自己的业务系统，不是拿来给别人用的基础库，这么做感觉有点多此一举的意思了，更加复杂化了代码可读性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576740685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/8c/23eef8d7.jpg","nickname":"feifei","note":"","ucode":"BFA3BE8D8773A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86961,"discussion_content":"Java1.8的接口不是可以添加变量吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576634294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698258,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","nickname":"阿顺","note":"","ucode":"36F2AD6F980B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85781,"discussion_content":"AlertHandler使用的是抽象类还有个原因是要提取子类通用的变量作为成员变量。单例模式那块这样写我觉得也能实现，但是只是每次使用都要重新实例化一次ApplicationContext类会有额外的空间和时间消耗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576574967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159954,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1575851177,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"10165785769","product_id":100039001,"comment_content":"对于课后题，想到2点:<br>1，减少出错概率，修改出错的概率比扩展要大<br>2，边界的问题，比如用户边界，尽量减少用户侧代码的改动，比如文中alert的事例，check函数本身的修改意味着所有使用的地方都要修改，而使用了开闭原则的代码对于老用户是无须修改的，降低了用户修改的成本。","like_count":2},{"had_liked":false,"id":159930,"user_name":"aya","can_delete":false,"product_type":"c1","uid":1325690,"ip_address":"","ucode":"F50E350DCF72D6","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/7a/a68f0ff8.jpg","comment_is_top":false,"comment_ctime":1575847684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10165782276","product_id":100039001,"comment_content":"【我们都需要在扩展性和可读性之间做权衡】说得太好了，优秀开发人员分得清原则和真理，面对随时的变化做权衡的能力才是最重要的","like_count":2},{"had_liked":false,"id":297109,"user_name":"August","can_delete":false,"product_type":"c1","uid":1365190,"ip_address":"","ucode":"DBB2FE26B13E86","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLl4PvnNftXS8d5qEdyTEYy1bXMyAAeSicqnP9PRdTz6nXc0fecDvyf3r2ibrh5bJ55uEOu6NaPY7gA/132","comment_is_top":false,"comment_ctime":1623314245,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5918281541","product_id":100039001,"comment_content":"第二遍看专栏了。<br><br>我们先重构一下之前的 Alert 代码，让它的扩展性更好一些。重构的内容主要包含两部分：第一部分是将 check() 函数的多个入参封装成 ApiStatInfo 类；第二部分是引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中。<br><br>这里进行了重构，重构的这种模式是属于23种设计模式中的哪种啊。没看出来<br>","like_count":1,"discussions":[{"author":{"id":1243753,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/69/352fb079.jpg","nickname":"乌木玉","note":"","ucode":"9B5220D073538C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555363,"discussion_content":"有点类似没有传递关系的职责链模式，不过这里没有后继的说法，执行顺序按注册顺序，符合本身条件就执行，不符合就跳下一个；\n又有点像观察者模式，对各个handler观察者进行逐个通知，通知者不需要知道通知谁，谁又会干啥。\n不过我觉得在23种设计模式中，具体的类图和解决方案是招式，而设计原则和思想是心法，心法领会了，招式也就贯通了，就是所谓的-----无招胜有招。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646882376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206217,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/c9/8454f009.jpg","nickname":"赵二","note":"","ucode":"168B503C5F3D59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548761,"discussion_content":"策略模式？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643358496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277186,"user_name":"somenzz","can_delete":false,"product_type":"c1","uid":1187197,"ip_address":"","ucode":"EA59A170DF8910","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","comment_is_top":false,"comment_ctime":1612312792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907280088","product_id":100039001,"comment_content":"Django 很多类的设计都是对扩展开放，对修改关闭。如果不学习设计模式，只是惊叹 Django 牛逼，不知道它的设计原则。","like_count":1},{"had_liked":false,"id":266257,"user_name":"天下行走","can_delete":false,"product_type":"c1","uid":1462449,"ip_address":"","ucode":"73A4CD8BB91235","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLfrbMvhKQYhxP6ziaHaj4KUNRzst8u7BZsWUsazK8oTLXcNH6sDGITl6icy3IiaGFe9Iiae12LuTrF1g/132","comment_is_top":false,"comment_ctime":1607261783,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5902229079","product_id":100039001,"comment_content":"我们组的一位老员工就是一个模块就是像上面改良后的Alert做的设计，后边来的我们真的看的那叫一个痛苦啊，找一个逻辑每次都要一层层回溯，一个个类的理解，绝大多函数不超过10行代码，还包括trycatch，真的遭罪。所以这种抽象个人理解是不是可以说如果没有最后自信组织好层次关系，别一上来就堆这一堆类，给后人挖坑倒不至于，让后人加班是真的。","like_count":1,"discussions":[{"author":{"id":1243753,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/69/352fb079.jpg","nickname":"乌木玉","note":"","ucode":"9B5220D073538C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555365,"discussion_content":"这个问题，如果类名和注释都能看到名称就知道意思，写清楚注释；再加上理解下设计思路，应改还好。\n不过看具体业务实际情况，如果不复杂，直接if-else，或者简单的重载，确实容易理解的多。\n如果业务很复杂，并不像例子中的每个handler类只是简单判断处理，这样拆开还是非常有必要的，修改bug追踪代码时，可以直接追到具体类，抛除其他逻辑干扰。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646882660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264317,"user_name":"　1234567890","can_delete":false,"product_type":"c1","uid":2311910,"ip_address":"","ucode":"623CD7E3B26769","user_header":"https://static001.geekbang.org/account/avatar/00/23/46/e6/f17cfee2.jpg","comment_is_top":false,"comment_ctime":1606437145,"is_pvip":false,"replies":[{"id":"96075","content":"这个要根据实际情况来定","user_name":"作者回复","comment_id":264317,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700619,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5901404441","product_id":100039001,"comment_content":"老师请教你个问题，什么是粗粒度代码什么是细粒度代码？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510519,"discussion_content":"这个要根据实际情况来定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264111,"user_name":"Kingram","can_delete":false,"product_type":"c1","uid":2247700,"ip_address":"","ucode":"212E403E81F2FC","user_header":"https://static001.geekbang.org/account/avatar/00/22/4c/14/8fa39544.jpg","comment_is_top":false,"comment_ctime":1606354144,"is_pvip":false,"replies":[{"id":"96081","content":"嗯呢 ������","user_name":"作者回复","comment_id":264111,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700663,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"5901321440","product_id":100039001,"comment_content":"为什么要遵循开闭原则？<br>1、修改原有复杂的业务代码本来就存在一定的风险，同时耗费精力，可能影响到别的你不知道的地方，导致程序运行故障。<br>2、修改代码同时单元测试也要跟着修改，浪费时间精力。<br>3、可扩展性差的代码同时封装性也会差，违背面向对象设计原则。<br>补充：但是注意不要过度设计呦","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510424,"discussion_content":"嗯呢 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2006342,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/9d/46/ce8f7a26.jpg","nickname":"I LOVE DM","note":"","ucode":"6EA297D5A0E4C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377743,"discussion_content":"怎么解读这句话？ “可扩展性差的代码同时封装性也会差，违背面向对象设计原则”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622803420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263091,"user_name":"fenciso","can_delete":false,"product_type":"c1","uid":2298546,"ip_address":"","ucode":"6546EA008BEEE8","user_header":"https://static001.geekbang.org/account/avatar/00/23/12/b2/c89b16e9.jpg","comment_is_top":false,"comment_ctime":1605978235,"is_pvip":true,"replies":[{"id":"96110","content":"对的","user_name":"作者回复","comment_id":263091,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700852,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5900945531","product_id":100039001,"comment_content":"对修改关闭，是为了增加新功能，但不影响已有的功能，增加不必要的成本。对拓展开发就是为了应对不断变化的功能需求","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510093,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262724,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1038811,"ip_address":"","ucode":"BFAF83E23199DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d9/db/66d5b3f4.jpg","comment_is_top":false,"comment_ctime":1605833215,"is_pvip":false,"replies":[{"id":"96122","content":"嗯嗯������","user_name":"作者回复","comment_id":262724,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700932,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5900800511","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”?<br>写代码一方面是为了满足功能需求，另一方面是为了让「他人」读懂，而不是自嗨。设计模式不是为了展现自己的能力，而是为了应对变化，很多软件需要做成插件、或者可插拔架构，都是为了方便其他人拓展。<br>「对扩展开放」是为了适应变化，「对修改关闭」是把代码封装好，减少不必要的错误改动。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509942,"discussion_content":"嗯嗯������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250529,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1601117840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5896085136","product_id":100039001,"comment_content":"打个比方，从古至今，管理一个团队，组织，企业，社会，国家，世界都需要合适的规则，才能够让系统内部的角色往效率更高的方向发展，收益更大。<br>对代码也是，如果代码未来发展想要前途无量，也需要规则去指导，而对扩展开放，对修改关闭就是一个战略性规则。","like_count":1},{"had_liked":false,"id":247994,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1599971318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894938614","product_id":100039001,"comment_content":"对扩展开放，保证了程序的灵活度，对修改关闭，保证程序不影响现有代码运行","like_count":1},{"had_liked":false,"id":247166,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1599623148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894590444","product_id":100039001,"comment_content":"对修改关闭：代码主要是为了实现业务，不让修改是因为直接修改的话可能会影响业务系统的正常运行。对扩展开放：系统预留扩展点，这些扩展点的改动通常不是直接实现业务的需求，而是辅助实现业务的代码，使得新扩展的功能与之前功能保持一种隔离，同时又能灵活切换。","like_count":1},{"had_liked":false,"id":221388,"user_name":"乖，摸摸头","can_delete":false,"product_type":"c1","uid":1611745,"ip_address":"","ucode":"BD92741A11D3CD","user_header":"https://static001.geekbang.org/account/avatar/00/18/97/e1/0f4d90ff.jpg","comment_is_top":false,"comment_ctime":1590487651,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5885454947","product_id":100039001,"comment_content":"争哥，我看你是把提示规则写在了  alertRule 里面，每个 Handler  对应alertRule 里面的一个方法，那如果我要是有几百个 Handler ，alertRule 里面就得有几百个 方法， 把 alertRule 提示规则 写到 Handler里面会不会好些， 这样违背了 单一职责吗？","like_count":1},{"had_liked":false,"id":193847,"user_name":"陈包佳","can_delete":false,"product_type":"c1","uid":1576712,"ip_address":"","ucode":"9DAAC87C75D91F","user_header":"https://static001.geekbang.org/account/avatar/00/18/0f/08/7abf466e.jpg","comment_is_top":false,"comment_ctime":1584973629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879940925","product_id":100039001,"comment_content":"开闭原则是代码开发中的最高指导原则，目的是为了提升代码的可扩展性，如何实现？需要有较强的扩展思维，抽象思维和封装思维，针对接口而非实现编程，依赖注入，多态等提升代码的扩展性。修改和扩展也是针对不同粒度上的定义区分，尽量在粗粒度上修改，细粒度扩展，减少改动面，和影响面。","like_count":1},{"had_liked":false,"id":168737,"user_name":"LYy","can_delete":false,"product_type":"c1","uid":1102062,"ip_address":"","ucode":"8D5C39B9531E71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ee/f5c5e191.jpg","comment_is_top":false,"comment_ctime":1578148388,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5873115684","product_id":100039001,"comment_content":"为什么要有“对扩展开放，对修改关闭”？<br>本质上讲，因为扩展的成本低于修改。<br>先看修改，一方面修改前需要对现有逻辑有比较准确而整体的理解(学习成本)，有引入bug的风险(额外运维成本)，另一方面也需要对配套的测试用例进行修改(额外开发&#47;维护成本)；<br>对照看扩展，只需要掌握扩展单元写法和理解修改点即可，引入bug的风险低(核心逻辑复杂度被前期封装处理掉了)，同时已有的测试用例大概率不会被破坏。<br>引申一下，从本质上看，程序解决的是真实世界问题的自动化问题。问题被自动化的解决，代码便实现了&quot;业务&quot;上的正确，但仅考虑&quot;业务&quot;是不够的，绝大多数情况下我们还有“效率”和“成本”两方面的要求。从代码层面上讲，算法与数据结构能够解决程序运行的“效率”和“成本”问题，而迭代过程中开发和维护的“效率”和“成本”问题，则需要靠设计和持续重构来解决。<br>不得不吹下王争老师在极客时间上的两门课，高质量的覆盖了代码层面“业务”以外的所有问题。","like_count":1},{"had_liked":false,"id":166875,"user_name":"薯片","can_delete":false,"product_type":"c1","uid":1072044,"ip_address":"","ucode":"FE757E1248EFF5","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/ac/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1577620808,"is_pvip":false,"replies":[{"id":"64822","content":"没看懂你说的 为什么handler类会爆炸呢","user_name":"作者回复","comment_id":166875,"uid":"1190123","ip_address":"","utype":1,"ctime":1577666001,"user_name_real":"王争"}],"discussion_count":13,"race_medal":0,"score":"5872588104","product_id":100039001,"comment_content":"if分支很多，用handler导致类爆炸怎么处理？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479662,"discussion_content":"没看懂你说的 为什么handler类会爆炸呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577666001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393694,"discussion_content":"之前是一个类中的一个接口，那么重构以后，一旦 if 分支多了，就可以将这些类，都放到一个包当中，将实现类放到 impl 子包中，对外只提供一个接口，具体的实现以及分发策略还是由底层去控制，对调用者来说是透明的。 \n\n类爆炸也不会影响代码的可读性和可维护性。\n\n而且我个人是比较喜欢用最简单的 if else 来分发策略的，不喜欢用那种高大上的方法，比如反射等等（特殊场景除外），分发的代码让人看得懂就行，不会再系统内部到处跑就行（高内聚）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631547917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2042568,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","nickname":"米豆丸","note":"","ucode":"CE99FE3A1EBCAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384874,"discussion_content":"这个我有体会，刚开始觉得类太多了，可以放在一个包下，只要日志打印得当，修改定位问题丝滑，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626778303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2358638,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fd/6e/1913dbb6.jpg","nickname":"Amber","note":"","ucode":"650FE5C46CCD1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334794,"discussion_content":"有类之间组合才会爆炸，参考桥模式和和装饰模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607993863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2275431,"avatar":"","nickname":"会飞的小飞鱼","note":"","ucode":"B1B7C191BFB078","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319307,"discussion_content":"我选择用枚举","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603979995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1608383,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","nickname":"X_L～","note":"","ucode":"6BD8C24750F86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302852,"discussion_content":"做好取舍,if加入只是简单的逻辑操作没有必要使用handler去进行重构,","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599047376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299036,"discussion_content":"多就多吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597541829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762110,"avatar":"","nickname":"yangcnb","note":"","ucode":"063DC9D9670D4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295916,"discussion_content":"if只是一个举例，handler我理解的主要作用是分离逻辑实现。就像netty的handler的处理器一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596381348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092169,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","nickname":"落尘kira","note":"","ucode":"D203B519E43F85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243600,"discussion_content":"如果觉得你认同spring的解决方式是优雅的，那么就没毛病","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587552020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125184,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2b/40/89be9c69.jpg","nickname":"登风","note":"","ucode":"6C440930B6B5B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124684,"discussion_content":"如果handle太多是不是可以分组","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578447574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119334,"discussion_content":"在31个if加进来的时候你敢修改这段代码吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578227065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1072044,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/ac/abb7bfe3.jpg","nickname":"薯片","note":"","ucode":"FE757E1248EFF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109154,"discussion_content":"每个if分支都抽成一个handler去处理，譬如我有30个if判断，那不就是30个handler了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577670769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1072044,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/ac/abb7bfe3.jpg","nickname":"薯片","note":"","ucode":"FE757E1248EFF5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115462,"discussion_content":"看30个if条件判断和看30个handler，我选择看30个handler","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1578015033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":109154,"ip_address":""},"score":115462,"extra":""}]}]},{"had_liked":false,"id":160197,"user_name":"MindController","can_delete":false,"product_type":"c1","uid":1159113,"ip_address":"","ucode":"3B9CECCD12CF6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/c9/d9c72c60.jpg","comment_is_top":false,"comment_ctime":1575890114,"is_pvip":false,"replies":[{"id":"61119","content":"你可以对比理解一下“基于接口而非实现编程”思想，封装可变的实现，暴露不变的接口。","user_name":"作者回复","comment_id":160197,"uid":"1190123","ip_address":"","utype":1,"ctime":1575895543,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5870857410","product_id":100039001,"comment_content":"请问争哥“将可变部分封装起来，隔离变化”这句话是什么意思？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477290,"discussion_content":"你可以对比理解一下“基于接口而非实现编程”思想，封装可变的实现，暴露不变的接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575895543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160026,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1181647,"ip_address":"","ucode":"46A2F679C094E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","comment_is_top":false,"comment_ctime":1575858904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870826200","product_id":100039001,"comment_content":"学到了，谢谢老师；","like_count":1},{"had_liked":false,"id":160001,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1575856137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870823433","product_id":100039001,"comment_content":"个人分析的原因<br>1.不这么做的话将来某个方法会越积越多，代码行数越来越长，等回过头来修改的时候自己可能都要读上十分钟才能找到下手的机会。<br>2.确实有好处，每次只修改修改具体实现，而对外是无感知的，调用方并不关心实现细节。<br>3.需求下来后，分析出某块东西可能会频繁更改后，且采取了这种对修改关闭，对扩展开放的思想来编码后，那以后需求变动的时候才知道什么叫真香。","like_count":1},{"had_liked":false,"id":159953,"user_name":"tingye","can_delete":false,"product_type":"c1","uid":1391463,"ip_address":"","ucode":"54F7A44066DF5D","user_header":"https://static001.geekbang.org/account/avatar/00/15/3b/67/c188d3bc.jpg","comment_is_top":false,"comment_ctime":1575851171,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5870818467","product_id":100039001,"comment_content":"例子中的AlertRule类也需要修改，添加MaxTimeout定义。可以考虑把规则按统一的格式写入数据库，统一解析，这样扩展规则只要添加规则数据就行了，不用改代码","like_count":1,"discussions":[{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76761,"discussion_content":" 那要失去了内聚，配置文件或许是更好的选择","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575852851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1562814,"avatar":"https://static001.geekbang.org/account/avatar/00/17/d8/be/49d49db2.jpg","nickname":"一路奔跑","note":"","ucode":"F1B708E8AE1793","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76763,"discussion_content":"配置文件和数据库有什么区别呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575853098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":76761,"ip_address":""},"score":76763,"extra":""}]},{"author":{"id":1022247,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","nickname":"阿卡牛","note":"","ucode":"0BC43A904C3199","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76783,"discussion_content":"不要过度设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575854037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159943,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1575849758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870817054","product_id":100039001,"comment_content":"打卡✔<br>","like_count":1},{"had_liked":false,"id":358358,"user_name":"Y","can_delete":false,"product_type":"c1","uid":1179432,"ip_address":"广东","ucode":"952AA9B2CD91CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/28/040f6f01.jpg","comment_is_top":false,"comment_ctime":1664245709,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1664245709","product_id":100039001,"comment_content":"赞，这篇课程把“对扩展开放，对修改关闭”原则讲得透透的","like_count":0},{"had_liked":false,"id":357820,"user_name":"怀英","can_delete":false,"product_type":"c1","uid":1394143,"ip_address":"江苏","ucode":"E2838AF06FB300","user_header":"https://static001.geekbang.org/account/avatar/00/15/45/df/97a71dc8.jpg","comment_is_top":false,"comment_ctime":1663665244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663665244","product_id":100039001,"comment_content":"赞成@下雨天的说法。对拓展开放，对修改关闭是最大限度上平衡了修改的时间成本和修改稳定性。","like_count":0},{"had_liked":false,"id":357526,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"北京","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1663337156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663337156","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br><br>我个人理解，还是为了保证代码改动的时候，变更范围更小更可控一些","like_count":0},{"had_liked":false,"id":357133,"user_name":"Geek_3e9d7d","can_delete":false,"product_type":"c1","uid":3070253,"ip_address":"北京","ucode":"3BDEFFE68BE32F","user_header":"","comment_is_top":false,"comment_ctime":1662984282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662984282","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br>首先，对扩展开放、对修改关闭的原则实现了高内聚、低耦合；在添加新的需求或新业务逻辑时能够尽量少的修改现有代码，这样能减少添加新代码时对旧代码、旧功能的影响；<br>其次，对扩展开放、对修改关闭的原则使得代码自然模块化，提高代码的可读性和可维护性。","like_count":0},{"had_liked":false,"id":356774,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"中国香港","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662567124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662567124","product_id":100039001,"comment_content":"为什么要对外开放和对内修改关闭。 这样目的是为了让代码的改动更纯粹，尽量不去修修改已封装的代码，这样对外影响小，改动也明确。<br><br>本节主要讲了开闭原则<br>  what: 添加新功能时应该在已有的代码上进行扩展，尽量不去修改已有代码的类，方法。<br>  why: 主要是为了提升代码的扩展性，<br>  <br>how:  <br>     1.写业务代码时需要慢慢培养扩展意识，抽象意识， 封装意识<br>     2.接到新需求后，要识别出不变的部分和可以变的部分。将可以变的部分抽象出来，变成不客变的接口。通过具体实现来应对未来的改变。本例中报警，报警规则变化，就抽出了对应的hanlder。<br>    3熟悉相关业务，了解业务的短期变化，更好的进行代码设计。<br>   4. 常用来实现代码扩展的方法多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。","like_count":0},{"had_liked":false,"id":355332,"user_name":"辉","can_delete":false,"product_type":"c1","uid":1697810,"ip_address":"广东","ucode":"0D7B2C24BA8BD2","user_header":"https://static001.geekbang.org/account/avatar/00/19/e8/12/74f387c8.jpg","comment_is_top":false,"comment_ctime":1661302723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661302723","product_id":100039001,"comment_content":"我觉得能用好开闭原则是最能体现一个程序员水平的地方。首先是开，这意味着你要有足够的思考，思考怎么去设计一个拓展性强的模块，其次是闭，这意味着你要思考去做一个稳定性足够强的模块。这两者结合起来，就能判断你这个模块设计的好不好了。","like_count":0},{"had_liked":false,"id":351947,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":2649276,"ip_address":"","ucode":"CEBAD9CDCFC2A3","user_header":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","comment_is_top":false,"comment_ctime":1658305219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658305219","product_id":100039001,"comment_content":"这篇写的不错","like_count":0},{"had_liked":false,"id":348963,"user_name":"CoderArthur","can_delete":false,"product_type":"c1","uid":1625233,"ip_address":"","ucode":"5B591914F0F67C","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","comment_is_top":false,"comment_ctime":1655609867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655609867","product_id":100039001,"comment_content":"Who do Action<br>Who：主体<br>do: 执行<br>Action: 行为<br>主体和行为经常变动，但执行却比较固定，但do并不知道who和action，于是需要将who和action依赖注入到do里面。而实现该行为需要语言上的多态来支持。<br><br>其实到后来还是业务的分析，把主体、行为抽象出来，分析出哪些是变的，哪些是不变的，最后套代码来实现。","like_count":0},{"had_liked":false,"id":347658,"user_name":"Cather","can_delete":false,"product_type":"c1","uid":2163390,"ip_address":"","ucode":"E3EDAC94EFFAC8","user_header":"https://static001.geekbang.org/account/avatar/00/21/02/be/9e8acb04.jpg","comment_is_top":false,"comment_ctime":1654262540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654262540","product_id":100039001,"comment_content":"为了应对软件需求的持续变更，提前预备好扩展点，使变更发生时，修改的影响面尽量小，同时不需要对单元测试做修改，控制变更风险。","like_count":0},{"had_liked":false,"id":345241,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1652153932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652153932","product_id":100039001,"comment_content":"要实现开闭，关键是要识别出变化点，如果不能识别变化点或者变化点短期不会发生，那么就只要闭就行了。","like_count":0},{"had_liked":false,"id":338879,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1647769268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647769268","product_id":100039001,"comment_content":"1.听君一席话胜读十年书。<br>2.设计模式没有我们想的那么难，一句话总结，扩展。<br>3.23种设计模式，无非归为扩展。就好像算法，就是递归。","like_count":0},{"had_liked":false,"id":335436,"user_name":"ibrothergang","can_delete":false,"product_type":"c1","uid":1002191,"ip_address":"","ucode":"4151DA353A1DDC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/cf/5cbccd62.jpg","comment_is_top":false,"comment_ctime":1645518335,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645518335","product_id":100039001,"comment_content":"业务的场景会不断变化，唯一不变的就是「变」。没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。","like_count":0},{"had_liked":false,"id":333307,"user_name":"i-neojos","can_delete":false,"product_type":"c1","uid":1702997,"ip_address":"","ucode":"1808C25269948A","user_header":"https://static001.geekbang.org/account/avatar/00/19/fc/55/e03bb6db.jpg","comment_is_top":false,"comment_ctime":1644283306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644283306","product_id":100039001,"comment_content":"依赖注入，上次遇到这个情况，知道应该这么做，但是不知道这么做的指导思想，原来叫依赖注入啊","like_count":0},{"had_liked":false,"id":332311,"user_name":"The-Jogger","can_delete":false,"product_type":"c1","uid":1396612,"ip_address":"","ucode":"4F19CA3DFA88E3","user_header":"https://static001.geekbang.org/account/avatar/00/15/4f/84/8b3b6a55.jpg","comment_is_top":false,"comment_ctime":1643168887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643168887","product_id":100039001,"comment_content":"实战中，handler标记注解，ApplicationContext通过Spring查询handler注解构建。","like_count":0},{"had_liked":false,"id":330654,"user_name":"cheng_yc","can_delete":false,"product_type":"c1","uid":2856263,"ip_address":"","ucode":"6DE872A6AEC42E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqFjqX19XHS5npsnSrrxibLQU9b0zMb3AzmdribYdEOFrXCyh7dJRF8g8MUibWfbMM8K7fA46AZib75SQ/132","comment_is_top":false,"comment_ctime":1642084802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642084802","product_id":100039001,"comment_content":"对我理解，开闭原则，就是针对多种情况，将各自的情况内聚到各自的类单独实现。<br>我对自己的代码也会经常看看，理解下当时的设计初衷和针对现在的需求变化该如何调整。这些都是变化的，对于一些不变的业务，多几个case也无关紧要。因为它长期不变。但是在一些易变经常使用的业务代码中，case种类也会越来越多，慢慢的出现方法过长，臃肿。因此我们可以针对不同的case单独抽取，面向接口+依赖注入，这次改造是必然要经历的。除非第一次就已经设计好了。<br>但是对于以后的再有新case出现，只需要编写新的case具体实现就行。<br>好处：便于扩展，代码清晰间接<br>缺点：可能不太便于新人代码阅读<br>我的意见就是因为设计模式而去设计，还是根据实际状况决定","like_count":0},{"had_liked":false,"id":330241,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1641877522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641877522","product_id":100039001,"comment_content":"对修改关闭是为了不影响以前的功能，可能以前的代码引用过多，很容易改错","like_count":0},{"had_liked":false,"id":328687,"user_name":"邵亮","can_delete":false,"product_type":"c1","uid":1810890,"ip_address":"","ucode":"8407C3FDD11C0E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a1/ca/aae116f5.jpg","comment_is_top":false,"comment_ctime":1640842115,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640842115","product_id":100039001,"comment_content":"提高代码可维护性，防止引入新问题","like_count":0},{"had_liked":false,"id":328369,"user_name":"Geek_East","can_delete":false,"product_type":"c1","uid":1589947,"ip_address":"","ucode":"A1A7CBF9B8FB2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","comment_is_top":false,"comment_ctime":1640693594,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640693594","product_id":100039001,"comment_content":"将代码中的不稳定部分提取为模块，类或者方法，并且将这部分代码的调用过程和实现过程分离，通过抽象桥梁与原有代码保持联系。这样不稳定部分的变动并不会引起原有代码的变动。","like_count":0},{"had_liked":false,"id":327332,"user_name":"July 💫","can_delete":false,"product_type":"c1","uid":1761335,"ip_address":"","ucode":"0DC25F063E9E90","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e0/37/40b6711b.jpg","comment_is_top":false,"comment_ctime":1640069661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640069661","product_id":100039001,"comment_content":"PHP Demo 示例，欢迎issues，如果对您有帮助，用你发财的小手(😆)给我来个star✨<br><br>https:&#47;&#47;github.com&#47;iamzu&#47;Geek-CodeDesign&#47;tree&#47;main&#47;16&#47;PHP","like_count":0},{"had_liked":false,"id":322641,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637538286,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637538286","product_id":100039001,"comment_content":"里氏替换重传统，父业子承不走形。<br>偶有业务需变更，子类加个小字段。","like_count":0},{"had_liked":false,"id":322587,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637489324,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637489324","product_id":100039001,"comment_content":"对扩展开放，修改封闭的核心点就是当需求发生变化，或者需求新增时，降低对原有业务或者功能的影响。避免一个函数改一下，所有的地方都要改一遍的弊病。","like_count":0},{"had_liked":false,"id":316755,"user_name":"Bacchus","can_delete":false,"product_type":"c1","uid":1830814,"ip_address":"","ucode":"A8AA7E4909B201","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ef/9e/fd29bdd8.jpg","comment_is_top":false,"comment_ctime":1634541601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634541601","product_id":100039001,"comment_content":"对修改关闭 是因为修改原有代码有一定的风险，可能会产生问题。<br>对扩展开发一是为了少修改，另外是为了提高代码的可维护性，方便后来者修改。","like_count":0},{"had_liked":false,"id":316272,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1634254596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634254596","product_id":100039001,"comment_content":"使用开闭原则最主要是提高代码的扩展性，方便扩展代码而不会或很少修改已有代码。","like_count":0},{"had_liked":false,"id":308401,"user_name":"小周","can_delete":false,"product_type":"c1","uid":2453498,"ip_address":"","ucode":"7ED7BC27A46C4C","user_header":"https://static001.geekbang.org/account/avatar/00/25/6f/fa/615a0df3.jpg","comment_is_top":false,"comment_ctime":1629601766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629601766","product_id":100039001,"comment_content":"为了以最小的代码改动为代价，新增新的功能。不破坏原来的代码结构，降低修改风险","like_count":0},{"had_liked":false,"id":305208,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1627877148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627877148","product_id":100039001,"comment_content":"为什么要对扩展开放，对修改关闭？<br>我觉得原因有几个，一个是方便快速的完成新功能，如何只是单纯的修改，一方面是代码逻辑会越来越复杂，可读性扩展性会变差，另外一方面是可能会影响其他已经写好的程序，这样开发的成本就更大了。<br>不过这些都是相对的，如果为了这个原则付出的代价很高，那可能不使用这种原则是更好的选择","like_count":0},{"had_liked":false,"id":304895,"user_name":"不一样的烟火","can_delete":false,"product_type":"c1","uid":1473251,"ip_address":"","ucode":"6E305F0EE90E8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","comment_is_top":false,"comment_ctime":1627689472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627689472","product_id":100039001,"comment_content":"设计模式都是为了应对可能发生的需求变化，或者工作的交接，更快地修改，更好的的可读性，节省时间，从而产生价值","like_count":0},{"had_liked":false,"id":302347,"user_name":"Geek_325846","can_delete":false,"product_type":"c1","uid":2696006,"ip_address":"","ucode":"30BC2FB97C5B42","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DR4kWgpzu27N1Hu6RFVEDxvk1MRBxaB9btc1U82Fo35peVuQDOfUoqia1RU6reH3sXWlxAtvicABiaotibllSnwgmw/132","comment_is_top":false,"comment_ctime":1626173385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626173385","product_id":100039001,"comment_content":"原先的check方法 形参直接封装成对象，然后在check方法里添加判断逻辑不就可以了吗？","like_count":0},{"had_liked":false,"id":301916,"user_name":"今夕是何年","can_delete":false,"product_type":"c1","uid":1111847,"ip_address":"","ucode":"2825454A7A1588","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/7SOblVZ7dNJ88wkeYR0HklxdR9VuiaQ0GMscAnrlic6EjvRZS52m4n1VPypwZFsmabbJ4STZRbHFfVZE24Jjqr1w/132","comment_is_top":false,"comment_ctime":1625974197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625974197","product_id":100039001,"comment_content":"这个貌似是观察者模式吧","like_count":0},{"had_liked":false,"id":300540,"user_name":"笑天","can_delete":false,"product_type":"c1","uid":1561173,"ip_address":"","ucode":"B71B671B302D3B","user_header":"","comment_is_top":false,"comment_ctime":1625211893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625211893","product_id":100039001,"comment_content":"老师您好，我看了您这课以后，和我的同事们都讨论了一下。讨论了之后我忽然发现，开闭原则不就是抽象和多态的利用吗。我就有了疑惑，不知道这两者到底是什么关系。各位同学，还有老师，如果看到，希望帮我解答疑惑","like_count":0},{"had_liked":false,"id":299823,"user_name":"randomx","can_delete":false,"product_type":"c1","uid":1238993,"ip_address":"","ucode":"FC93786244932F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/d1/9d1c283b.jpg","comment_is_top":false,"comment_ctime":1624872412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624872412","product_id":100039001,"comment_content":"文中AlertHandler是abtract修饰的类，怎么有有参构造？","like_count":0},{"had_liked":false,"id":298682,"user_name":"槐安","can_delete":false,"product_type":"c1","uid":2631749,"ip_address":"","ucode":"7A7A925B57955C","user_header":"https://static001.geekbang.org/account/avatar/00/28/28/45/8dc28ef6.jpg","comment_is_top":false,"comment_ctime":1624262001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624262001","product_id":100039001,"comment_content":"对扩展开放是为了应对业务需求的增加，对修改关闭，是保证代码的稳定性","like_count":0},{"had_liked":false,"id":297195,"user_name":"Geek_cf3aed","can_delete":false,"product_type":"c1","uid":2417045,"ip_address":"","ucode":"BE1AF6D6F14541","user_header":"","comment_is_top":false,"comment_ctime":1623373777,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623373777","product_id":100039001,"comment_content":"这里的复制代码小按钮  不好用，需要粘贴到笔记本更方便查看代码","like_count":0},{"had_liked":false,"id":296910,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1623222461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623222461","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br><br>目的就是为了提高代码的扩展性，更易维护，体现在如下方面：<br>1.对扩展开放，保证新功能添加是基于原来的代码架构进行扩展，保证代码结构的一致性<br>2.新功能扩展可以做到，对细节进行修改和填充，而始终保持代码架构的前后统一","like_count":0},{"had_liked":false,"id":296287,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1622883621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622883621","product_id":100039001,"comment_content":"让我想起来之前做过的一个项目，一个公共类的方法中，if和else有几十个，因为每次添加一个新的功能都在那个方法中添加一个if。现在回想一下，按照“开闭原则”，确实可以将代码进行重构一下，","like_count":0},{"had_liked":false,"id":294758,"user_name":"姚钫","can_delete":false,"product_type":"c1","uid":1498146,"ip_address":"","ucode":"ECB8B0627A4F9B","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/22/41a390ae.jpg","comment_is_top":false,"comment_ctime":1622082930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622082930","product_id":100039001,"comment_content":"只能停留在能看懂，还是不知道如何去写","like_count":0},{"had_liked":false,"id":292502,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1620864110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620864110","product_id":100039001,"comment_content":"对拓展开放是应对未来变化的需求，对修改关闭是为了保证已有代码的稳定性。最终的是以最小的代价，保证系统的稳定性","like_count":0},{"had_liked":false,"id":288690,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1618626296,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1618626296","product_id":100039001,"comment_content":"对扩展开放就是对需求开放，对修改关闭就是保证已有代码的稳定。核心是保持系统稳定。","like_count":0},{"had_liked":false,"id":288399,"user_name":"Spiral","can_delete":false,"product_type":"c1","uid":2023006,"ip_address":"","ucode":"1BB5AF06CEF397","user_header":"https://static001.geekbang.org/account/avatar/00/1e/de/5e/170a3546.jpg","comment_is_top":false,"comment_ctime":1618455632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618455632","product_id":100039001,"comment_content":"原则不是唯一的，所以在代码开发的时候，权衡很重要。不要教条，要根据实际情况出发，选择合适的程度遵守原则","like_count":0},{"had_liked":false,"id":285265,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1616717318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616717318","product_id":100039001,"comment_content":"开闭原则，就是写代码是，注意抽象，整理清楚代码的抽象结构，让代码能够描述。最大的好处是，需求变更时，代码可以快速扩展，并减少代码因改动而出错的可能。","like_count":0},{"had_liked":false,"id":285116,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1616632693,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616632693","product_id":100039001,"comment_content":"我想到了业界有个面相接口编程，不知道跟开闭原则是不是有关联","like_count":0,"discussions":[{"author":{"id":2233517,"avatar":"https://static001.geekbang.org/account/avatar/00/22/14/ad/b5cd2a0c.jpg","nickname":"钮祜禄皮皮虾","note":"","ucode":"957DC6647AA7EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368959,"discussion_content":"依赖倒置原则感觉也和这原则有关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618888967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284775,"user_name":"御风","can_delete":false,"product_type":"c1","uid":1812807,"ip_address":"","ucode":"51C8212BE06364","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg","comment_is_top":false,"comment_ctime":1616467472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616467472","product_id":100039001,"comment_content":"1.拓展和修改是相对的，粗力度上是修改，细粒度上可能是拓展<br>2.拓展为了应对变换，修改是为了保证已有代码的稳定性。已有代码包括函数、单测。<br>以前有人问我重构、修改代码后，维护单测需要很多工作量，所以，好的设计能够对修改关闭，从而保证已有代码的单测不受影响<br>3.最常用来实现开闭原则的方法有：多态、依赖注入、基于接口而非实现编程。<br>4.设计时，需要识别出代码中变化和不变的部分，将变化封装隔离，抽象出不变的接口，当实现变化时，只需要基于接口，提供新的实现给上游代码，上游代码几乎不用改动。","like_count":0},{"had_liked":false,"id":283543,"user_name":"Graham","can_delete":false,"product_type":"c1","uid":1994570,"ip_address":"","ucode":"C2545DE16EC3DD","user_header":"","comment_is_top":false,"comment_ctime":1615813022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615813022","product_id":100039001,"comment_content":"chain设计模式，就是一种对ocp的应用，拓展的时候，只需添加&#47;删除对应的chain，在其初始化方法的时候","like_count":0},{"had_liked":false,"id":280228,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1614137943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614137943","product_id":100039001,"comment_content":"HandlerChain，职责链模式。开闭原则本质上是“对扩展打开，对修改关闭”，对代码扩展和修改可能从不同的宽度看又是不一样的，那我们在开发的时候就可以从自身的业务来看，如果自身业务近期有对应的扩展就打开，没有就不打开，","like_count":0},{"had_liked":false,"id":280136,"user_name":"Chloe","can_delete":false,"product_type":"c1","uid":1004953,"ip_address":"","ucode":"C4848ED5B35752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","comment_is_top":false,"comment_ctime":1614090355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614090355","product_id":100039001,"comment_content":"我的感受是，设计模式很好的解决了团队合作（高内聚，低耦合）和快速添加修改软件功能（易扩展）的要求。","like_count":0},{"had_liked":false,"id":279639,"user_name":"大风","can_delete":false,"product_type":"c1","uid":1606600,"ip_address":"","ucode":"95C2B6B98247FB","user_header":"https://static001.geekbang.org/account/avatar/00/18/83/c8/c08fc40f.jpg","comment_is_top":false,"comment_ctime":1613884778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613884778","product_id":100039001,"comment_content":"感谢老师的教学，老师果然传达到了设计模式之美。相见恨晚。网络上一大难似懂非懂似是而非的讲解太误导人了。可怜我等无意中就被误导这么多年","like_count":0},{"had_liked":false,"id":277207,"user_name":"金色麦浪","can_delete":false,"product_type":"c1","uid":2397738,"ip_address":"","ucode":"78B65DE7B4B9D3","user_header":"https://static001.geekbang.org/account/avatar/00/24/96/2a/851a2818.jpg","comment_is_top":false,"comment_ctime":1612316475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612316475","product_id":100039001,"comment_content":"ApiStatInfo需要分开写不同需求的构造函数","like_count":0},{"had_liked":false,"id":276438,"user_name":"Geek_eb58fa","can_delete":false,"product_type":"c1","uid":2430525,"ip_address":"","ucode":"FDB9999650CAB5","user_header":"","comment_is_top":false,"comment_ctime":1611924844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611924844","product_id":100039001,"comment_content":"对报警这个案例，进行了一点点修改，更符合真实生产需求<br>1、报警规则通过配置文件动态注入，而不是写死成一个枚举类<br>2、规则增加时，只需要增加处理类和信息类， 不需要修改已经定义好的其它类<br>项目地址：https:&#47;&#47;gitee.com&#47;fengzhili123_admin&#47;design_parttern&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;wangzheng&#47;alert","like_count":0},{"had_liked":false,"id":276406,"user_name":"世杰","can_delete":false,"product_type":"c1","uid":2415102,"ip_address":"","ucode":"6BC305EF6D525B","user_header":"https://static001.geekbang.org/account/avatar/00/24/d9/fe/7b151abf.jpg","comment_is_top":false,"comment_ctime":1611911508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611911508","product_id":100039001,"comment_content":"请问报警这个案例，如果是用例子中的单例模式，那我的报警规则是不是只能通过枚举类写死了，正常生产中这种规则应该是配置在配置文件中吧，如果想通过配置文件传进来，是不是就不能用这种单例模式了。","like_count":0},{"had_liked":false,"id":275671,"user_name":"低调的魅力","can_delete":false,"product_type":"c1","uid":1823275,"ip_address":"","ucode":"AE5CA2986B5A95","user_header":"https://static001.geekbang.org/account/avatar/00/1b/d2/2b/7a93d588.jpg","comment_is_top":false,"comment_ctime":1611640674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611640674","product_id":100039001,"comment_content":"看了第一个例子，恍然大悟，原来代码还能这么写，很幸运看到争哥这篇文章","like_count":0},{"had_liked":false,"id":273775,"user_name":"飞扬","can_delete":false,"product_type":"c1","uid":1378180,"ip_address":"","ucode":"3F77352FC25DB9","user_header":"https://static001.geekbang.org/account/avatar/00/15/07/84/18d30516.jpg","comment_is_top":false,"comment_ctime":1610675677,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610675677","product_id":100039001,"comment_content":"在《A Philosophy of Software Design》一书中，作者有一个观点是“修改放大往往意味着代码的设计问题”。这里的“修改放大”就是我们通常说的牵一发而动全身，爬过屎山的同学应该都有感受。我想应用开闭原则的一个好处，或许也是最重要的好处，就是能减少“修改放大”。毕竟，如果真是不用修改的代码，那它只要能用就行了，不是么？","like_count":0},{"had_liked":false,"id":272249,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1610005258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610005258","product_id":100039001,"comment_content":"这里将整个类分为几个不同处理类：<br>1：Alert.java 负责add不同的预警类和check消费不同的预警类<br>2：AlertHandler 是一个抽象类，定义好抽象类具体的方式和参数<br>3：ApiStatInfo 负责将传入验证的参数<br>4:  TpsAlertHandler 继承了 AlertHandler ，所以要必须实现 check 抽象方法，方法该怎么去验证，逻辑自己去写。<br>5：ErrorAlertHandler 同上<br>6：既然定义不同的 AlertHandler(Tps,ApiError,Timeout)等等不同扩展，所以肯定要用呀，我们将需要验证，都addAlertHandler,<br>然后，在调用Alert类的check方法，check方法会循环循环变量进入add中的handler，然后执行check方法<br>7：applicationContext 类，就是我们自己写的代码，","like_count":0},{"had_liked":false,"id":272056,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1609920612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609920612","product_id":100039001,"comment_content":"在没有看老师教程之前，看别人代码都是大段大段的，看框架的代码太多又看不懂。老师的教程，确实很哈。","like_count":0},{"had_liked":false,"id":269156,"user_name":"snake","can_delete":false,"product_type":"c1","uid":2347137,"ip_address":"","ucode":"47BFFE4D048156","user_header":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","comment_is_top":false,"comment_ctime":1608540578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608540578","product_id":100039001,"comment_content":"有点像策略模式","like_count":0},{"had_liked":false,"id":267641,"user_name":"Geek_2495de","can_delete":false,"product_type":"c1","uid":1786809,"ip_address":"","ucode":"BCC92B259FF165","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/lHqiahnUnaWY9GOGgIamhbddJUYtopKABFmVwaD68uXgTdaA72HX3yzd6YtqPKEt1YxJuXwYXKsmzGNKXmV75LQ/132","comment_is_top":false,"comment_ctime":1607853374,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607853374","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”。 我理解出了两个问题：<br>第一个：为什么要遵循开闭原则：<br>这是一种可以提高扩展性的原则。意味着，我们将来遇到新的需求时，可以投入比较少的人力时间成本去做开发、测试、上线回归。<br>第二个：为什么开闭原则里面：是对“扩展”开放，对“修改”关闭<br>如果关闭扩展，开放修改。那一个需求B的增加，意味着从A 变成 A&#39;+B。 原来跟A都有关的地方都要考虑。如果A 原有100个逻辑，对开发和测试的要求要更大，也容易因为考虑不周，导致上线后不够稳定。<br><br>","like_count":0},{"had_liked":false,"id":264742,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1606625400,"is_pvip":false,"replies":[{"id":"96062","content":"嗯嗯","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700541,"ip_address":"","comment_id":264742,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606625400","product_id":100039001,"comment_content":"回头再看第二遍，这个例子不就是责任链模式的变体+工厂模式吗 ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510673,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264228,"user_name":"🍃","can_delete":false,"product_type":"c1","uid":1337052,"ip_address":"","ucode":"D1E4560C49139A","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/dc/fdffbc96.jpg","comment_is_top":false,"comment_ctime":1606384800,"is_pvip":false,"replies":[{"id":"96078","content":"还好吧，理解思路为主","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700648,"ip_address":"","comment_id":264228,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606384800","product_id":100039001,"comment_content":"不会java的我理解起来有点吃力啊<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510473,"discussion_content":"还好吧，理解思路为主","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257564,"user_name":"间接性失忆患者","can_delete":false,"product_type":"c1","uid":2143290,"ip_address":"","ucode":"73593933070CB9","user_header":"https://static001.geekbang.org/account/avatar/00/20/b4/3a/53b27094.jpg","comment_is_top":false,"comment_ctime":1604028141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604028141","product_id":100039001,"comment_content":"对开闭原则的使用一直很纠结，感谢老师这么实用的建议和距离。有种豁然开朗的感觉，终于不会再纠结这个了。","like_count":0},{"had_liked":false,"id":256455,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1134539,"ip_address":"","ucode":"11C598D0723D08","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/cb/ede92cd5.jpg","comment_is_top":false,"comment_ctime":1603628655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603628655","product_id":100039001,"comment_content":"对扩展开放，对修改关闭，可在增加功能时尽量少的引入问题","like_count":0},{"had_liked":false,"id":255493,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1603357844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603357844","product_id":100039001,"comment_content":"对扩展开放是为了应对变化，对修改关闭是为了保证现有代码的稳定性，最终结果是为了让系统更加的有弹性~","like_count":0},{"had_liked":false,"id":247671,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1533352,"ip_address":"","ucode":"6FD3642D6455AE","user_header":"https://static001.geekbang.org/account/avatar/00/17/65/a8/6431f8b0.jpg","comment_is_top":false,"comment_ctime":1599789855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599789855","product_id":100039001,"comment_content":"基于接口而非实现编程，这个我深有体会，我们在做集群内本地缓存的同步方案的时候，就是基于接口，然后使用不同的技术框架实现了，经过压测和实践选择了比较合适我们的，我们基于zk，redis，mq，分别都实现了，可供不同场景不同系统选择，并且后期也可以快速替换，非常赞同和深有体会  基于接口而非实现编程！","like_count":0},{"had_liked":false,"id":246382,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1599302956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599302956","product_id":100039001,"comment_content":"对修改开放的话，对之前的代码的改动很可能会牵一发而动全身，除了要花更多时间做改动以外，还要花更多时间做测试，性价比低。","like_count":0},{"had_liked":false,"id":246352,"user_name":"liliumss","can_delete":false,"product_type":"c1","uid":1333094,"ip_address":"","ucode":"A52AC5042F3115","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","comment_is_top":false,"comment_ctime":1599292726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599292726","product_id":100039001,"comment_content":"如果使用spring框架，可以使用把同一类的接口自动获得防止到特定集合去，这样applictionContext也不需要修改了，很完美","like_count":0},{"had_liked":false,"id":246268,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599233783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599233783","product_id":100039001,"comment_content":"对扩展开放，是很容易面对未来不确定的需求变更， 扩展方便了 才能以更小的改动对整个新需求的匹配，也可以让上游系统少改动，甚至不改动，无感的适配新的需求。  对修改关闭，也不是说要完全杜绝修改， 对于新需求而言，不可能完全不修改任何原有代码就能实现的， 而我们需要做到的是，尽量少的对原有代码进行层层修改，不然代价会非常大的，导致最后可读性变差，可维护性更差","like_count":0},{"had_liked":false,"id":245948,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599118556,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599118556","product_id":100039001,"comment_content":"1、对修改关闭：为了兼容性。保证原有的系统行为不受影响、包括测试性。<br>2、对扩展开放：为了增加更多的功能、更大的价值","like_count":0},{"had_liked":false,"id":245860,"user_name":"Hunter_Dark","can_delete":false,"product_type":"c1","uid":1342279,"ip_address":"","ucode":"3A07CCBC250B69","user_header":"https://static001.geekbang.org/account/avatar/00/14/7b/47/96dad3ff.jpg","comment_is_top":false,"comment_ctime":1599096808,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599096808","product_id":100039001,"comment_content":"在spring框架中，这些设计怎么用？","like_count":0},{"had_liked":false,"id":245774,"user_name":"X_L～","can_delete":false,"product_type":"c1","uid":1608383,"ip_address":"","ucode":"6BD8C24750F86B","user_header":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","comment_is_top":false,"comment_ctime":1599047459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599047459","product_id":100039001,"comment_content":"感谢争哥,很清楚,写代码时的潜意识确实很重要,像内功一样","like_count":0},{"had_liked":false,"id":245609,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1599008588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599008588","product_id":100039001,"comment_content":"为什么要对扩展开放，对修改关闭。还是分情况的，如果是简单的系统，业务逻辑单一且缺少变化，那么可以不用设计出复杂的代码去满足这个设计原则。如果对于复杂系统，业务逻辑根据场景多变，且各个场景业务逻辑不同。这个时候就需要好好设计代码，在新增场景有新的业务规则时可以横向扩展，避免影响之前的老代码，一方面是回顾成本大，第二是容易导致不了解这块的人无法覆盖全导致出线上问题。","like_count":0},{"had_liked":false,"id":245114,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1598839565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598839565","product_id":100039001,"comment_content":"“对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！”<br>简直就是写出好代码的精髓！<br>代码的扩展性会跟可读性相冲突，难怪我在阅读开源代码的时候，觉得很吃力，就算勉强了解了它的功能，也不能识别它的设计模式，也很难借鉴。","like_count":0},{"had_liked":false,"id":244057,"user_name":"蛀牙","can_delete":false,"product_type":"c1","uid":1153349,"ip_address":"","ucode":"F765A67DFEADFD","user_header":"","comment_is_top":false,"comment_ctime":1598368976,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598368976","product_id":100039001,"comment_content":"学到这一课有种渐入佳境的感觉。突然理解了设计模式的美。这样先给个简单的实现，再给个运用开闭原则的实现非常贴合我的思维模式，就是在我的现有基础上实现了拔高。<br>而且这个例子确实是在工作中会遇到的实例，有助于遇到类似问题时的思维迁移。","like_count":0},{"had_liked":false,"id":243858,"user_name":"。华伟","can_delete":false,"product_type":"c1","uid":2095422,"ip_address":"","ucode":"CD2645632E70D0","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f9/3e/aef7a849.jpg","comment_is_top":false,"comment_ctime":1598314894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598314894","product_id":100039001,"comment_content":"不破坏原有代码的正常运行，不破坏原有代码的单元测试","like_count":0},{"had_liked":false,"id":242138,"user_name":"火影.海诺","can_delete":false,"product_type":"c1","uid":2091565,"ip_address":"","ucode":"34729AFEE93B6D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ea/2d/34cb8e0a.jpg","comment_is_top":false,"comment_ctime":1597622001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597622001","product_id":100039001,"comment_content":"对修改关闭是服务于分装思想的，是为了对现在代码负责，对扩展开放是为了以后代码能基于现在代码的一个功能扩展，为了未来服务","like_count":0},{"had_liked":false,"id":241956,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1597540035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597540035","product_id":100039001,"comment_content":"自己又画了一遍整个思路，第一次学设计模式，确实Handler这个类让我受益匪浅，已经理解了开闭原则，确实扩展性太强了，只是感觉 Class会增加很多，这是不是也不好呢","like_count":0},{"had_liked":false,"id":240860,"user_name":"站在岸上的鱼","can_delete":false,"product_type":"c1","uid":2093578,"ip_address":"","ucode":"96C3D7B1772541","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f2/0a/e10d198f.jpg","comment_is_top":false,"comment_ctime":1597105805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597105805","product_id":100039001,"comment_content":"如何在不改动原有代码逻辑的情况下，新增功能。","like_count":0},{"had_liked":false,"id":240034,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1596722758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596722758","product_id":100039001,"comment_content":"mybatis的数据类型转换也用到了第一个例子的方式，定义了不同handler类处理java对应的数据库类型。真正做到了可插拔、可扩展的方式，而不是像大部分代码一样用if...else...判断","like_count":0},{"had_liked":false,"id":239663,"user_name":"杨逸林","can_delete":false,"product_type":"c1","uid":1167233,"ip_address":"","ucode":"4BF3CF3E2F1AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","comment_is_top":false,"comment_ctime":1596610022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596610022","product_id":100039001,"comment_content":"第一部分的代码不就是 Spring MVC 中的，HandlerMapping 中取 Handler，它将所有标记为 @RequestMapping 的方法包装成 MethodHandler 然后在 DispatcherServlet 中调用对应的 Handler吗？<br><br>第二部分，Spring Cloud 的 DiscoveryClient 就是服务注册的接口，Spring 中有很多这种定义了的组建接口，也是 Java 的 SPI 很好的实现","like_count":0},{"had_liked":false,"id":239563,"user_name":"Geek_31594d","can_delete":false,"product_type":"c1","uid":2030240,"ip_address":"","ucode":"9058787881CE82","user_header":"","comment_is_top":false,"comment_ctime":1596588721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596588721","product_id":100039001,"comment_content":"对扩展开放、对修改关闭，大体理解为对原有的功能实现方式在不必要的情况不要去修改，因为每次修改都要重新进行单元测试，扩展可以认为对新类 模块 方法 属性的新增 增强","like_count":0},{"had_liked":false,"id":237792,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1595953699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595953699","product_id":100039001,"comment_content":"我觉得开闭原则的一个关键点就是一个模块的新增功能不会影响到这个模块的对外接口。比如例子中的 check 方法，因为新增功能导致了方法参数的增加，从而导致了所有使用这个方法的地方都得修改。","like_count":0},{"had_liked":false,"id":237380,"user_name":"幽林萌逐","can_delete":false,"product_type":"c1","uid":1520451,"ip_address":"","ucode":"E6D95EC891800F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLqrAA1j4Oyy6ibicNOicn8K0olrEjtLLanic8V0y9icia6cvCVRCiabOm5llC0WhzcSWvaI2fia75hYbvjrQ/132","comment_is_top":false,"comment_ctime":1595813914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595813914","product_id":100039001,"comment_content":"打卡，新的一天看了handler这个思想我get了新的姿势，准备重构一个正在开发的服务了","like_count":0},{"had_liked":false,"id":236461,"user_name":"hex","can_delete":false,"product_type":"c1","uid":1757301,"ip_address":"","ucode":"B983D40DCD159F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d0/75/3e034f71.jpg","comment_is_top":false,"comment_ctime":1595420624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595420624","product_id":100039001,"comment_content":"现在一直在写不扩展代码啊.码农.看了这篇之后感觉飘起来了","like_count":0},{"had_liked":false,"id":234006,"user_name":"程序员班吉","can_delete":false,"product_type":"c1","uid":1478098,"ip_address":"","ucode":"BD48CF7649609A","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/d2/8a6be8d8.jpg","comment_is_top":false,"comment_ctime":1594550705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594550705","product_id":100039001,"comment_content":"对扩展开放、对修改关闭，可以对应为两个扩展<br>一，对扩展开放是为了更好的扩展业务，因为业务一直在演进变化，我们期望能通过最小的开发量和时间代价最快速实现业务扩展<br>二、对修改关闭是为了更好的代码扩展及维护，由于有第一点铺垫，在实际开发中，唯一不变的就是业务的变化，我们不可能每次业务的迭代都将代码推倒重来，这样代价太大了。所以，兼顾到代码的可扩展和维护是非常有必要的。<br>总结下来，&quot;对扩展开放、对修改关闭&quot; 实际上是对以上两个扩展的一个平衡，能够作为兼顾两者的一个方法论。但事件总是有两面性，在实现单一职责的同时免不了增加代码的复杂度，对于阅读理解代码会造成一定的困难。","like_count":0},{"had_liked":false,"id":232908,"user_name":"超超","can_delete":false,"product_type":"c1","uid":1476077,"ip_address":"","ucode":"D0751F29553481","user_header":"https://static001.geekbang.org/account/avatar/00/16/85/ed/905b052f.jpg","comment_is_top":false,"comment_ctime":1594166861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594166861","product_id":100039001,"comment_content":"对扩展开放，对修改关闭原则实施是建立在业务充分熟悉理解基础之上的，不是凭空臆想的结果，而是针对业务逻辑经常适配修改点或可察觉的未来扩展业务功能点，提炼修改点的“不变”内在逻辑，提炼成框架，实现新增功能时不影响原有逻辑或单元测试LLT用例。","like_count":0},{"had_liked":false,"id":230827,"user_name":"LH","can_delete":false,"product_type":"c1","uid":1211178,"ip_address":"","ucode":"819B9B2409E834","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/2a/7d8b5943.jpg","comment_is_top":false,"comment_ctime":1593505743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593505743","product_id":100039001,"comment_content":"经常碰到有的人接手别人代码的时候在哪里pen，不好扩展，代码可读性不好云云。有功夫pen你就去重构啊","like_count":0},{"had_liked":false,"id":229586,"user_name":"杨锋","can_delete":false,"product_type":"c1","uid":1283461,"ip_address":"","ucode":"85A7828A538FB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","comment_is_top":false,"comment_ctime":1593066709,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593066709","product_id":100039001,"comment_content":"对扩展开放，对修改关闭好处很多。最主要是可以有效规避因为修改原逻辑产生新的问题。","like_count":0},{"had_liked":false,"id":229530,"user_name":"被过去推开","can_delete":false,"product_type":"c1","uid":1276690,"ip_address":"","ucode":"8B4F34FE93FD5B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Cib5umA0W17N9pichI08pnrXAExdbyh7AVzH4nEhD6KN3FXuELk4LJJuqUPPD7xmIy9nq5Hjbgnzic7sVZG5BKiaUQ/132","comment_is_top":false,"comment_ctime":1593052410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593052410","product_id":100039001,"comment_content":"为什么要对修改关闭？对我而言，最主要的原因是不想因为新需求，而去影响已经十分稳定的功能","like_count":0},{"had_liked":false,"id":229494,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1593016434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593016434","product_id":100039001,"comment_content":"参数类的修改那里 也可以应用多态扩展吗？ 比如设置一个抽象或者接口来作为参数类IParameter or IData，然后根据需要，去扩展所需的新参数类MyData。  然后在具体扩展出的handler里比如Myhandler ，将收到的idata再unbox成该Myhandler对应的扩展参数类Mydata 。缺点就是有一次开箱操作,但是参数类的代码设计会和handler一样变成纯扩展， 不用再纠结是不是修改操作了","like_count":0},{"had_liked":false,"id":229206,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592923292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592923292","product_id":100039001,"comment_content":"对扩展开放，对修改关闭。<br>老代码很可能不是当前维护人开发的，测试用例、功能点等有可能会忽略掉某些细节，直接修改，容易引入bug，而且，即使细节全部清楚，对原有代码修改后，对应的测试同样需要修改，新功能+老功能一起测试，徒增工作量啊，还容易出错。","like_count":0},{"had_liked":false,"id":226555,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592140220,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592140220","product_id":100039001,"comment_content":"思考题：为什么对修改关闭？修改意味着引入风险，对现有系统可能造成影响，本来已经测试通过的系统，因为修改了，必须重新测试。而原来的单元测试也已经不能用，测试成本太大。为什么对扩展开放？通过添加新类新属性新方法来实现功能的扩展，不需要修改原有的东西，只需要测试新增的部分，成本最小最可靠。","like_count":0},{"had_liked":false,"id":225067,"user_name":"marsly","can_delete":false,"product_type":"c1","uid":1565950,"ip_address":"","ucode":"1F61DE32D99426","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvnkXZiaop0hbe9w5kuAvf6d17suDPB6W1j2hlYPJ43eRogABUic5pUV7ia5rPHjXLWEfDZLHiafMUiaQ/132","comment_is_top":false,"comment_ctime":1591627933,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1591627933","product_id":100039001,"comment_content":"把变动划到易控的范围内","like_count":0},{"had_liked":false,"id":225051,"user_name":"今夕何夕","can_delete":false,"product_type":"c1","uid":1620929,"ip_address":"","ucode":"C3374848592304","user_header":"https://static001.geekbang.org/account/avatar/00/18/bb/c1/b2f1bd6f.jpg","comment_is_top":false,"comment_ctime":1591624964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591624964","product_id":100039001,"comment_content":"开闭原则是为了提高代码的扩展性，对已有代码的修改往往会造成不可预知的错误。对修改关闭是为了提高代码的稳定性。","like_count":0},{"had_liked":false,"id":224150,"user_name":"马球先生","can_delete":false,"product_type":"c1","uid":1119609,"ip_address":"","ucode":"858C2CE0E494C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/79/efde2a69.jpg","comment_is_top":false,"comment_ctime":1591286106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591286106","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br>对于已有的功能，可以比较放心质量，不用再重新全部测试一遍。<br>只需要保证新添加的部分功能是正确的就好。","like_count":0},{"had_liked":false,"id":223620,"user_name":"王瑞强","can_delete":false,"product_type":"c1","uid":1829090,"ip_address":"","ucode":"DEE4EB5E23433F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/e8/e2/2bcaef68.jpg","comment_is_top":false,"comment_ctime":1591145309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591145309","product_id":100039001,"comment_content":"Alert优化后的例子同时也支持了报警方式的可插拔，比如：可以任意组合报警方式，而原来的if else是不支持的","like_count":0},{"had_liked":false,"id":223469,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591098085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591098085","product_id":100039001,"comment_content":"不变的部分是扩展点，是依赖注入，变化的部分封装为接口，根据接口编写多个实现，通过装配component完成扩展和开闭原则，通过增加接口实现和在装配是用哪个接口实现，隔离变化，实现修改关闭扩展开放。<br>装配层决定着系统的行为。","like_count":0},{"had_liked":false,"id":223463,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591096002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591096002","product_id":100039001,"comment_content":"对象和方法的封装命名分层：<br>首先把需求中的名词分组封装为实体，把动词封装为方法，OOA过程的划分非常重要直接影响可读和可扩展。属性用名词开始，方法用动词开始如initXxx、updateXxx。设计属性时有子对象(UML的关联组合聚合关系)。数据实体的子对象的repository实现可以在主对象提供get方法关联表一次取出数据，也可以分拆到子对象的repository中在service层组合，insert、update建议在子对象的repository中完成。<br>预留扩展点：<br>考虑未来的可能的变更,把变化的和不变化的分开，“变化的封装成接口”，“不变化的依赖接口”，这样在有新需求时，实现接口后，在装配层组合功能替换原有功能。<br>一个接口多个实现，这些实现同时使用，可以考虑引入handler的概念，把多个实现放入切片或map中。<br><br>","like_count":0},{"had_liked":false,"id":223147,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591009664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591009664","product_id":100039001,"comment_content":"开闭原则关键是考虑现在和未来的需求预留扩展点点，扩展点是调用接口、抽象类、函数作为函数的形参传入函数，装配层在外部实例化不同对象传入，实现多种业务的支持。<br>扩展点一般预留在service层，本package的service的依赖对应package的repository，不依赖其他package的repository，可以依赖其他package的service。所以扩展点的入参和返回值是BO,不要出现entity和VO对象。","like_count":0},{"had_liked":false,"id":220749,"user_name":"朝小树","can_delete":false,"product_type":"c1","uid":1323875,"ip_address":"","ucode":"18DC282DEF16C8","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/63/2d48822a.jpg","comment_is_top":false,"comment_ctime":1590317857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590317857","product_id":100039001,"comment_content":"学了面向对象和原则，感觉懂了一些，但是对于一些东西是否修改还是要根据经验去考虑。","like_count":0},{"had_liked":false,"id":219356,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1125259,"ip_address":"","ucode":"7BF52ADBFD4F5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/8b/dd02189a.jpg","comment_is_top":false,"comment_ctime":1590015981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590015981","product_id":100039001,"comment_content":"课堂讨论：为什么我们要“对扩展开放、对修改关闭”？<br>软件开发种唯一不变的就是变化<br>对扩展开放：主要目的是便于添加新的功能或者模块。在要添加新功能的时候，不至于要推翻原有代码而从头重构<br>对修改关闭：因为修改原有代码会增加引入bug的风险，增加了修改软件开发和测试的成本<br>","like_count":0},{"had_liked":false,"id":219223,"user_name":"Geek_1f0e17","can_delete":false,"product_type":"c1","uid":1975877,"ip_address":"","ucode":"C7309788798807","user_header":"","comment_is_top":false,"comment_ctime":1589968573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589968573","product_id":100039001,"comment_content":"我感觉在原始样例中做修改最麻烦的就是添加一个接口参数后所有调用的地方都得加参数，那其实最简单的就是多个参数变为一个对象，对对象加一个属性不影响现有接口，check方法里的加个if","like_count":0},{"had_liked":false,"id":219171,"user_name":"林毅鑫","can_delete":false,"product_type":"c1","uid":1917916,"ip_address":"","ucode":"1BB3D186E90D96","user_header":"https://static001.geekbang.org/account/avatar/00/1d/43/dc/95d4f2c5.jpg","comment_is_top":false,"comment_ctime":1589960809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589960809","product_id":100039001,"comment_content":"听的有点似懂非懂，再刷几遍。","like_count":0},{"had_liked":false,"id":217917,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1589647144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589647144","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”：<br><br>- 减少「修改代码」带来的新不确定性：最简单的理解，如果修改涉及三个类，最坏的情况就是为三个类带来了不确定性，这种不确定最坏的结果就是三个类都出 bug。而如果只涉及一个类的话，问题就简单多了。这也是为什么出现依赖注入，控制反转，以及一系列设计模式被总结出来的原因。<br><br>另外关于扩展，就像作者说的，包含两方面的内容：要实现的可扩展，已经如何实现扩展。<br>一个是意识问题，一个是技能知识问题。<br>而个人理解的可「扩展」，实际上是要实现一套「规则」「框架」「流程」「协议」，以便让其他适配或者基于他实现新的功能。小到作者的例子 Alert，中到一个库，框架（如混合 app 中常用的 jsbridge 协议 ），大到通信协议，架构，都是「框架」「规则」的具体实现...<br><br>","like_count":0},{"had_liked":false,"id":217876,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1589636305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589636305","product_id":100039001,"comment_content":"少改动少出问题，系统稳定，早点下班","like_count":0},{"had_liked":false,"id":215127,"user_name":"孟令超","can_delete":false,"product_type":"c1","uid":1433609,"ip_address":"","ucode":"37916911C0F9D9","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/09/eb3da11d.jpg","comment_is_top":false,"comment_ctime":1588909525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588909525","product_id":100039001,"comment_content":"我觉得是为了保证系统的稳定性，在  添加功能和或者修改功能时候不会影响原来的功能","like_count":0},{"had_liked":false,"id":215053,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1588898175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588898175","product_id":100039001,"comment_content":"把多个根据条件依赖外部类的代码变成可以多态的接口，把原来依赖的外部类变成接口实现","like_count":0},{"had_liked":false,"id":214447,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1588750992,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1588750992","product_id":100039001,"comment_content":"对修改关闭是为了保持已有代码的稳定性，不用牵一发而动全身，对扩展修改是为了应对不断变化的需求。以前做过分享功能就是类似的，开始只知道 if else 后来看了大话设计模式，重构成策略模式了，跟本章例子一致。现在看了一遍有了新的理解，终于知道扩展的尺度，还是要跟产品多多沟通啊，了解那些业务是要长久做下去的，那些是随时可能改的。","like_count":0},{"had_liked":false,"id":213595,"user_name":"妙子爸","can_delete":false,"product_type":"c1","uid":1433842,"ip_address":"","ucode":"988C1A7B9548F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hsxzhpId4k4uGK5CG534oLEIibqluVwOqgGqxFibILZDSia38gYOHflJDE1zfDVRGRIRq8sxdrAzWnvDP0eVDRMyQ/132","comment_is_top":false,"comment_ctime":1588485864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588485864","product_id":100039001,"comment_content":"防止短期内进行大量的代码重构，测试用例失效，上游系统改造。","like_count":0},{"had_liked":false,"id":211770,"user_name":"KID","can_delete":false,"product_type":"c1","uid":1867938,"ip_address":"","ucode":"EE80B7CA7CC2A2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/80/a2/96dcd1fa.jpg","comment_is_top":false,"comment_ctime":1588002577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588002577","product_id":100039001,"comment_content":"基于工作中的理解，修改会造成多处代码需要同步修改，这样容易漏改，也徒增很多无谓的工作量。在代码设计中，我最喜欢就是做到即使以后修改或新增功能，尽量能在源头处改变少量代码，即可实现不同的功能，这就是扩展。","like_count":0},{"had_liked":false,"id":211748,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1588000834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588000834","product_id":100039001,"comment_content":"开发多年还是对扩展开放做的不好 业务多了 修改极其复杂。泛型和继承 接口编程用的比较多。","like_count":0},{"had_liked":false,"id":211368,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1587953581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587953581","product_id":100039001,"comment_content":"如果新增需求需要频繁的修改已有代码逻辑，那带来的工作量和bug率都会剧增，原因为：<br>1 已有代码会越改越乱，越改越多，最后往往if else遍地，成了4不像。改的人小心翼翼，如履薄冰<br>2 每次修改后，都要进行完整的回归测试，单元测试。如果本身的自动化测试体系做的不好，那么工作量将是惊人的<br>3 1和2所带来的复杂度和工作量，让bug变得不可避免。996的工作强度，并发的开发任务，更是让这一风险加剧","like_count":0},{"had_liked":false,"id":202613,"user_name":"鹤鹤有名","can_delete":false,"product_type":"c1","uid":1773191,"ip_address":"","ucode":"327311F22F3C30","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJB3er54ghicIaqklUYabqtsibuMjlvyrUq2GPVke1Loth8PV5tMDbahjbIqeHZYrPzWNaia0juOUmMw/132","comment_is_top":false,"comment_ctime":1586015313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586015313","product_id":100039001,"comment_content":"对扩展开放是为了是我们设计的架构能够灵活的应对各种新的需求，对修改关闭是避免对原有代码破环性的修改，打乱最初设计好的思路保证原有结构的完整性。","like_count":0},{"had_liked":false,"id":201675,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1604089,"ip_address":"","ucode":"3A66800D8E35D6","user_header":"https://static001.geekbang.org/account/avatar/00/18/79/f9/3cd59b29.jpg","comment_is_top":false,"comment_ctime":1585819255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585819255","product_id":100039001,"comment_content":"争哥，把Alert类check方法的参数封装为一个ApiStatInfo类，这是不是类似之前讲到的贫血模型<br>alertRule = new AlertRule(&#47;*.省略参数.*&#47;); notification = new Notification(） <br>AlertRule、Notification这两个类是在哪里定义的呢 没看懂这部分的代码","like_count":0},{"had_liked":false,"id":201624,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1604089,"ip_address":"","ucode":"3A66800D8E35D6","user_header":"https://static001.geekbang.org/account/avatar/00/18/79/f9/3cd59b29.jpg","comment_is_top":false,"comment_ctime":1585813516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585813516","product_id":100039001,"comment_content":"“对扩展开放，对修改关闭”就像文章中提到的最根本的问题是解决代码的扩展性问题。<br>实际开发过程中往往很多时候都只是考虑当下需求的实现，而为做长远设计，导致添加新的需求时如果变动过大不得不重新定义一套。<br>所以在今后的开发中，首先要了解清楚业务需求，在做设计时多问一个为什么或是多想一点，锻炼抽象意识<br>不多说了 把文章的代码实现以下去","like_count":0},{"had_liked":false,"id":201491,"user_name":"小明","can_delete":false,"product_type":"c1","uid":1625618,"ip_address":"","ucode":"5A0357E9849226","user_header":"https://static001.geekbang.org/account/avatar/00/18/ce/12/1488e361.jpg","comment_is_top":false,"comment_ctime":1585795416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585795416","product_id":100039001,"comment_content":"请问，如果AlertHandler类里面需要用到Alert中的信息，这个该怎么弄？","like_count":0},{"had_liked":false,"id":200803,"user_name":"进击的前端er","can_delete":false,"product_type":"c1","uid":1506085,"ip_address":"","ucode":"9229B410F48B85","user_header":"https://static001.geekbang.org/account/avatar/00/16/fb/25/f6743e97.jpg","comment_is_top":false,"comment_ctime":1585653329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585653329","product_id":100039001,"comment_content":"看了两边，再看看留言，收货颇丰！！！","like_count":0},{"had_liked":false,"id":200280,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585568278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585568278","product_id":100039001,"comment_content":"争哥用的策略模式改进的代码，开闭原则学起来很矛盾，工厂模式加上工厂方法模式就是很好的例子，对于工厂模式，根据需求创建想要的对象，难免会去修改代码，这并不符合开闭原则，但是很符合那种比较简单的系统，但是如果你用工厂方法模式，符合开闭原则，但是用在简单的系统真的好么，其实不会，他可能会产生类爆炸，难以管理的情况。依我看来，每种原则，都有其不足之处，想要用好更难，但在项目中，找到解决问题最适合的原则，最适合的场景，和最适合的设计模式，才是最棒的","like_count":0},{"had_liked":false,"id":200277,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585567807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585567807","product_id":100039001,"comment_content":"争哥用的策略模式改进的代码，开闭原则学起来很矛盾，工厂模式加上工厂方法模式就是很好的例子","like_count":0},{"had_liked":false,"id":199847,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585496887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585496887","product_id":100039001,"comment_content":"对扩展开放是为了方便以后扩展，写之前先考虑一下短期可能有扩展需求的先留着坑。对修改关闭是为了维护代码的稳定性。起码保证以前的测试能正常通过。","like_count":0},{"had_liked":false,"id":199704,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1921287,"ip_address":"","ucode":"64BBE005890845","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","comment_is_top":false,"comment_ctime":1585494177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585494177","product_id":100039001,"comment_content":"看完后打算到项目中找到这部分复杂的if else 代码，跟兄弟们一起重构掉。","like_count":0},{"had_liked":false,"id":199316,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585486597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585486597","product_id":100039001,"comment_content":"感觉这几个原则里，这个是最有用的，如果一个方法老是被修修改改以适用新场景，说明不是个好设计","like_count":0},{"had_liked":false,"id":198776,"user_name":"Skylar","can_delete":false,"product_type":"c1","uid":1250262,"ip_address":"","ucode":"9E8D1697BEE884","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/d6/0cf21fe8.jpg","comment_is_top":false,"comment_ctime":1585467946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585467946","product_id":100039001,"comment_content":"对扩展开放，提高程序的灵活性；对修改关闭，提高程序的可维护性和稳定性","like_count":0},{"had_liked":false,"id":197817,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585399579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585399579","product_id":100039001,"comment_content":"告警的例子很棒，学到了。","like_count":0},{"had_liked":false,"id":197771,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585397752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585397752","product_id":100039001,"comment_content":"有些变化是不可控的，对扩展开放尽可能的对这种不可控的变化提供了可能，而且隔离了变化与已有的逻辑，同时，对扩展出的变化就易于做单元测试了","like_count":0},{"had_liked":false,"id":196680,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1585302308,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585302308","product_id":100039001,"comment_content":"在原有的代码上修改可能会导致线上正在运行的代码出现bug， 对扩展开放，是健壮的程序为了应对新的需求","like_count":0},{"had_liked":false,"id":195230,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585148011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585148011","product_id":100039001,"comment_content":"因为只要修改代码就容易引入bug，甚至引起原来功能的使用。而基于扩展的思路，新功能对原来功能基本没影响。","like_count":0},{"had_liked":false,"id":192375,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584848020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584848020","product_id":100039001,"comment_content":"1. 对修改关闭：是因为写完的功能，可能被很多地方引用，如果后期贸然修改可能带来灾难性的问题。有一个心法就是“把所有的功能都当作对外API来实现”，这样写完就发布出去了，想改就得督促其他同学改动代码。这样就会强迫你把接口写的干净、整洁<br><br>2.对扩展开放：要做到这一点就得保证高内聚，功能职责单一以不变应万变。比较好的代码应该是分层明确，大致可以分为基础层、服务层、业务层。基础层负责基本的数据组织不含业务逻辑；服务层则是对基础层的组合；业务层的处理逻辑依赖服务层来实现。整体上看应该是个“倒三角”结构，于是底层接口越是需要“内聚、单一”，切不可轻易修改代码。<br>","like_count":0},{"had_liked":false,"id":190834,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1584697227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584697227","product_id":100039001,"comment_content":"在私有的构造方法中执行了initializeBeans()方法没问题吗？ 那个私有的构造方法会执行到么？","like_count":0},{"had_liked":false,"id":188982,"user_name":"新的起点，新的开始^_^","can_delete":false,"product_type":"c1","uid":1262068,"ip_address":"","ucode":"9C0810F472AC93","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/f4/5df17eff.jpg","comment_is_top":false,"comment_ctime":1584441595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584441595","product_id":100039001,"comment_content":"对扩展开放：是因为需求会有变动，变动的需求，对代码进行扩展来满足需求<br>对修改关闭：是因为修改已经完成的代码，可能会对之前调用的逻辑产生影响。","like_count":0},{"had_liked":false,"id":188803,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1584417894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584417894","product_id":100039001,"comment_content":"发送短信，邮件这种耗时的操作，是不是该搞个线程池呢？","like_count":0},{"had_liked":false,"id":188793,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1584416427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584416427","product_id":100039001,"comment_content":"对修改关闭是保证原有功能的稳定性，对扩展开放是为了更方便的新增功能","like_count":0},{"had_liked":false,"id":188735,"user_name":"猫在屋里晒太阳","can_delete":false,"product_type":"c1","uid":1450035,"ip_address":"","ucode":"88D12ED99D4A30","user_header":"https://static001.geekbang.org/account/avatar/00/16/20/33/81ccb712.jpg","comment_is_top":false,"comment_ctime":1584409687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584409687","product_id":100039001,"comment_content":"在告警的案例中,如果我有50个告警规则是否意味着需要50个handler类来处理?这样就会导致handler类爆炸,针对这种情况老师有什么建议?","like_count":0},{"had_liked":false,"id":187311,"user_name":"wl","can_delete":false,"product_type":"c1","uid":1392730,"ip_address":"","ucode":"45062AA2460F1F","user_header":"https://static001.geekbang.org/account/avatar/00/15/40/5a/e65e8c40.jpg","comment_is_top":false,"comment_ctime":1584081682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584081682","product_id":100039001,"comment_content":"本篇学完了，mark 一下。<br><br>原来可扩展性的代码是这样写的，下次在项目中尝试下，只有实践过的，才会更有体会。","like_count":0},{"had_liked":false,"id":184541,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1583334649,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583334649","product_id":100039001,"comment_content":"【设计模式笔记17】20200304<br>今天分享了开闭原则的判断标准以及如何写出符合开闭原则得代码，简单来说就是尽量修改少得代码满足不断迭代的需求，是不断变化的，运用开闭原则可以提高系统得扩展性喝稳定性，随着代码复杂度升高经常会有牵一发动全身的危险，所以再设计之初就考虑不变的和变化的东西，具备抽象思维我觉得是提高代码稳定性的重要工具，很多代码可能都有什么相似得逻辑，需要不断重构将公共能力服务化，其实就是不断抽象得结果","like_count":0},{"had_liked":false,"id":184357,"user_name":"极极","can_delete":false,"product_type":"c1","uid":1250773,"ip_address":"","ucode":"365F7446ABCC49","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/d5/6d66288b.jpg","comment_is_top":false,"comment_ctime":1583297591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583297591","product_id":100039001,"comment_content":"老师，这段代码更接近于责任链模式 还是  发布订阅模式？","like_count":0},{"had_liked":false,"id":182633,"user_name":"小田","can_delete":false,"product_type":"c1","uid":1073342,"ip_address":"","ucode":"59CA02059F71E4","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/be/68ce2fd0.jpg","comment_is_top":false,"comment_ctime":1582818344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582818344","product_id":100039001,"comment_content":"# 要点小结<br>1. OCP的根本目的：实现可扩展、易维护的代码<br>2. 定位扩展点的方法：具有全局观——对业务模型有清晰的认识和好的设计，以知道代码实现<br>3. 实现扩展点的方法：【微观】多态、接口、依赖注入&#47;控制反转；【宏观】各种设计模式","like_count":0},{"had_liked":false,"id":180866,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582431552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582431552","product_id":100039001,"comment_content":"应该成立一个新的学科，面向未来编程","like_count":0},{"had_liked":false,"id":180753,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582381371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582381371","product_id":100039001,"comment_content":"面对变化的需求，从实现操作方式上可以分为修改、拓展。从这个原则上看，是建议通过拓展来实现新的需求。<br>大体还是成本问题，用修改去实现需求，必须要倒推修改所影响的模块，重新测试。这边是一个成本很高的操作。<br>拓展则承诺在实现新功能时，不会影响以往核心的功能，因此成本更低，更安全。","like_count":0},{"had_liked":false,"id":180438,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582281108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582281108","product_id":100039001,"comment_content":"这个问题,我是这么理解的,假设我在一个模块下有一个函数,如果有同事想要复用我这个代码,发现少参数了,是不是需要给我的方法的入参进行修改,来满足其需求,那么这个方法原有的调用者都需要被修改,并且我们经常写的接口类,实现的业务,都是基于SQL驱动的,修改者为了满足新的需求,可能连SQL语句都修改了,那么这种修改的成本实在太高了,但是如果提前预留了扩展点,方便同事扩展来满足新需求的同时,对原有的上游系统不会进行改变,甚至数据存储层也不会改变,那么这个成本就很低了<br>","like_count":0},{"had_liked":false,"id":177168,"user_name":"巨龙的力量啊","can_delete":false,"product_type":"c1","uid":1684858,"ip_address":"","ucode":"8FC6978929E48F","user_header":"https://static001.geekbang.org/account/avatar/00/19/b5/7a/a126c48f.jpg","comment_is_top":false,"comment_ctime":1581307811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581307811","product_id":100039001,"comment_content":"对于重要业务方法做到入参可控，多分支抽象出类，多用组合，感觉这个就基本能够做到这个条件","like_count":0},{"had_liked":false,"id":175621,"user_name":"wai","can_delete":false,"product_type":"c1","uid":1439529,"ip_address":"","ucode":"29CE3BE148FB79","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/29/60e01017.jpg","comment_is_top":false,"comment_ctime":1580784657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580784657","product_id":100039001,"comment_content":"为什么 “对扩展开发，对修改封闭” ，我认为最重要的一点：降低新功能上线对已有功能的影响，提升产品稳定性，这对于ToB的企业尤其重要。","like_count":0},{"had_liked":false,"id":175509,"user_name":"刘明丰","can_delete":false,"product_type":"c1","uid":1591790,"ip_address":"","ucode":"64C1D6CC769F75","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eocPWoTKicQG9ic42hLQBOqEziaNYxBekyGXljWrYfhk8gjLGZWfUX0JlObCvOIUSA8tRXicfxeSDJMMw/132","comment_is_top":false,"comment_ctime":1580736223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580736223","product_id":100039001,"comment_content":"开闭原则就是把易变的和不易变的代码隔离起来，把易变的代码封装起来，隐藏变化的细节，暴露并提供稳定的抽象接口，让接口的使用方更加舒服，将来变化来的时候，我们仅仅需要扩展暴露出来的稳定接口而已，在接口的使用方考虑使用容器技术，实现控制反转，代码就达到了易维护的目的。","like_count":0},{"had_liked":false,"id":174316,"user_name":"jony","can_delete":false,"product_type":"c1","uid":1048286,"ip_address":"","ucode":"80765A6B9ABA0D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/de/2019f370.jpg","comment_is_top":false,"comment_ctime":1580136757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580136757","product_id":100039001,"comment_content":"对修改关闭是为了代码的稳定性，对扩展开放是为了功能的扩展，二者是统一看待的。","like_count":0},{"had_liked":false,"id":174264,"user_name":"磊","can_delete":false,"product_type":"c1","uid":1070732,"ip_address":"","ucode":"858BF8BFBFB0B8","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/8c/a8317e23.jpg","comment_is_top":false,"comment_ctime":1580112335,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580112335","product_id":100039001,"comment_content":"对扩展开放：代码在新增功能的时候，可以快速修改代码，同时尽量减少对之前的代码的影响。<br>对修改关闭：修改现存的代码会带来诸多问题，对于已经引用这个修改类的方法或者类，都需要修改，并且需要充分测试，才能上线，这里面就牵涉到代码的重构，代码重构的基本原则就是在重构后的代码，需要经过充分的测试才能上线。<br>","like_count":0},{"had_liked":false,"id":173940,"user_name":"Value","can_delete":false,"product_type":"c1","uid":1443434,"ip_address":"","ucode":"5413E5E4A7326C","user_header":"https://static001.geekbang.org/account/avatar/00/16/06/6a/48fb83f3.jpg","comment_is_top":false,"comment_ctime":1579793750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579793750","product_id":100039001,"comment_content":"对扩展开放是因为需求总有不确定性，留下可扩展点，后期对系统的改造程度最小，最能平稳保持系统的运行。而对修改关闭也是同理，保持现有系统的稳定性，如单元测试模块，上下游系统的接口调用等等。","like_count":0},{"had_liked":false,"id":173321,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1579504133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579504133","product_id":100039001,"comment_content":"为何我就想不到这样的设计呢","like_count":0},{"had_liked":false,"id":171736,"user_name":"www","can_delete":false,"product_type":"c1","uid":1275203,"ip_address":"","ucode":"951B364F2CB211","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg","comment_is_top":false,"comment_ctime":1579004176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579004176","product_id":100039001,"comment_content":"“对扩展开放、对修改关闭”原则目的是为了需求变化时，对已有代码结构和测试用例影响降到最低，提高代码的扩展性和灵活性。但是要注意，在完成已有需求的情况下，不要过度设计预留扩展点，因为这也是有代价的，增加了工作量，并且牺牲了代码的可读性。","like_count":0},{"had_liked":false,"id":171716,"user_name":"小雨子","can_delete":false,"product_type":"c1","uid":1738146,"ip_address":"","ucode":"C869A02E845FF4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLaiafYiaPZgFuLjDicyjgFA1NkNP8pwp5uyyxnluibb6ALazSNWGcOYpkjqxR0V3Hx2IBlZS9f9p2Wlw/132","comment_is_top":false,"comment_ctime":1578996214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578996214","product_id":100039001,"comment_content":" private ApplicationContext() {    instance.initializeBeans();  }<br><br>你好，在构建ApplicationContext类是 你再构造方法中调用了 initializeBeans方法 ，这样不会报空指针异常吗，构造方法的作用是为了完成对象的初始化工作把，但是构造方法还么执行完，此时回报空指针异常吗？","like_count":0},{"had_liked":false,"id":170280,"user_name":"小虫子","can_delete":false,"product_type":"c1","uid":1435887,"ip_address":"","ucode":"3DBCDFB69D3638","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLibibbBhyIQKpSF9JrG7fWxWxQxpicVice1lNj5VtqzgTqhE8PUSBFFh3UxMzgJzU4UKXHZYhmk6wdbQ/132","comment_is_top":false,"comment_ctime":1578560291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578560291","product_id":100039001,"comment_content":"abstract class Component{<br>    protected $_events = [];<br><br>    public final function on($event,$handler){<br>        if(!isset($this-&gt;_events[$event])){<br>            $this-&gt;_events[$event] = [];<br>        }<br><br>        if(is_callable($handler)){<br>            $this-&gt;_events[$event][] = $handler;<br>        }<br>    }<br><br>    public final function trigger($event,$data){<br>        if(isset($this-&gt;_events[$event])){<br>            foreach ($this-&gt;_events[$event] as $handler){<br>                call_user_func($handler,$data);<br>            }<br>        }<br>    }<br><br>    public function hasEventHandler($event){<br>        return !empty($this-&gt;_events[$event]);<br>    }<br><br>}<br><br><br>class Alert extends Component{<br><br>    public function check(){<br>        if($this-&gt;hasEventHandler(&#39;check&#39;)){<br>            $this-&gt;trigger(&#39;check&#39;,$info);<br>        }<br>    }<br>}<br><br>class Run{<br><br>    public function run()<br>    {<br>        $alert = new Alert();<br>        $alert-&gt;on(&#39;check&#39;,function($info){<br>            &#47;&#47;检查具体代码1<br>        });<br>        $alert-&gt;on(&#39;check&#39;,function($info){<br>            &#47;&#47;检查具体代码2<br>        });<br>    }<br>}","like_count":0},{"had_liked":false,"id":169955,"user_name":"✨胡小东","can_delete":false,"product_type":"c1","uid":1312339,"ip_address":"","ucode":"314D40A5857C17","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/53/29fa4e12.jpg","comment_is_top":false,"comment_ctime":1578482734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578482734","product_id":100039001,"comment_content":"对扩展开放、对修改关闭，可以很好的避免，当我们在加入一个新的需求点时候，去大面积改动之前的代码，这样可能会导致，原本功能正常的程序，因为你的改动，导致出现bug；使得开发人员不敢随意去改动代码。","like_count":0},{"had_liked":false,"id":169627,"user_name":"京京beaver","can_delete":false,"product_type":"c1","uid":1179056,"ip_address":"","ucode":"C21838D7CA7D6B","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/b0/e30fd916.jpg","comment_is_top":false,"comment_ctime":1578392361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578392361","product_id":100039001,"comment_content":"实践中简单的方法论就是：用抽象类和接口写出来核心调用关系，作为骨架。后续具体实现都是对骨架接口的实现，这样的扩展比较好。<br>核心调用关系，涵盖了业务最主要的逻辑，基本是很少变化的。","like_count":0},{"had_liked":false,"id":169190,"user_name":"CHS","can_delete":false,"product_type":"c1","uid":1240227,"ip_address":"","ucode":"3D8B2DABC0A1D6","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/a3/28763399.jpg","comment_is_top":false,"comment_ctime":1578288984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578288984","product_id":100039001,"comment_content":"对扩展开放，对修改关闭。在写代码的时候要时刻注意这些原则，修改经常比较麻烦，如果多个地方引用了这块，那修改起来就比较痛苦了。","like_count":0},{"had_liked":false,"id":168964,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1578227453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578227453","product_id":100039001,"comment_content":"扩展与修改，根据粒度不同，判定不同。其原则是以最小的代价，实现新功能的添加。方式是预留扩展点。<br>具体方法：识别代码中的可变部分与不可变部分。把可变部分的代码做封装、隔离，抽象化为不可变接口，提供给上层使用。变动时，通过扩展方式改动，对上层使用，不影响或影响较小。","like_count":0},{"had_liked":false,"id":168810,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1578191202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578191202","product_id":100039001,"comment_content":"扩展是为了将来的变化留有余地，方便快速接入，降低成本，不影响原有的业务功能","like_count":0},{"had_liked":false,"id":168712,"user_name":"Jessica","can_delete":false,"product_type":"c1","uid":1084877,"ip_address":"","ucode":"9FC7E9BD3FE9F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/cd/b6bdc1b2.jpg","comment_is_top":false,"comment_ctime":1578145530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578145530","product_id":100039001,"comment_content":"就像老师在文章中说的，开放闭合原则对最核心，最复杂的逻辑的修改是封闭的，这样可以避免复杂的逻辑不会被修改，减少出错的概率。如果都是简单的逻辑，这个原则获得的收益是比较小的，反倒增加了代码的复杂性。","like_count":0},{"had_liked":false,"id":168522,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1578103827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578103827","product_id":100039001,"comment_content":"一、如何理解对扩展开放、对修改关闭？<br>添加一个新的功能，就是通过在已有代码基础删扩展代码（新增模块、类、方法、属性等），而非修改已有代码（新增模块、类、方法、属性等）。开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。同样的代码改动，在粗粒度下，可能被认为修改；在细粒度下，可以又被认定为扩展。<br><br>二、如何做到对扩展开放、修改关闭？<br>1.要时刻具备扩展意识、抽象意识、封装意识。这些潜意识可能比任何开发技巧都重要。<br>2.写代码之前要多思考下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，这样在未来需求变更的时候就能以最小的代码改动来更加灵活的扩展。<br>3.识别出代码可变部分和不可变部分之后，要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，只要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。<br>4.很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的。23种设计模式就是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。多态、依赖注入、基于接口而非实现编程、抽象意识说的都是同一种设计思路，也都是为了提高代码的扩展性。<br><br>三、如何在项目中灵活应用开闭原则<br>1.关键是预留扩展点，如果开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，就要对业务有足够的了解，能够知道当下及未来可能要支持的业务需求；如果开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题。<br>2.对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。<br>3.有些情况下，代码的扩展性会跟可读性相冲突，我们需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。还是要看实际的应用场景来决定。<br>","like_count":0},{"had_liked":false,"id":168364,"user_name":"Yangjing","can_delete":false,"product_type":"c1","uid":1018061,"ip_address":"","ucode":"D88DFD4958D07C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/cd/2c3808ce.jpg","comment_is_top":false,"comment_ctime":1578055416,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578055416","product_id":100039001,"comment_content":"对修改关闭，后面添加的代码不会影响以前的功能，保证了前面内容的正确性，添加功能变得更容易，更易于测试；对扩展开放，以此应对需求的变化，并是通过扩展的方式。","like_count":0},{"had_liked":false,"id":167974,"user_name":"Geek_f3a3d1","can_delete":false,"product_type":"c1","uid":1603271,"ip_address":"","ucode":"E15FA1C3AB3174","user_header":"","comment_is_top":false,"comment_ctime":1577970968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577970968","product_id":100039001,"comment_content":"像是被大道洗礼了，融会贯通的感觉。","like_count":0},{"had_liked":false,"id":167019,"user_name":"薯片","can_delete":false,"product_type":"c1","uid":1072044,"ip_address":"","ucode":"FE757E1248EFF5","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/ac/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1577670804,"is_pvip":false,"replies":[{"id":"64872","content":"我是按照告警规则去定义handler的 不是一个if一个handler的 如果真有30个判断 这代码本身就有问题吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1577675779,"ip_address":"","comment_id":167019,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1577670804","product_id":100039001,"comment_content":"每个if分支都抽成一个handler去处理，譬如我有30个if判断，那不就是30个handler了？handler类爆炸了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479716,"discussion_content":"我是按照告警规则去定义handler的 不是一个if一个handler的 如果真有30个判断 这代码本身就有问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577675779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260741,"discussion_content":"用if是线性思维，用策略模式是对象组合思维，发通知，\n1.线性思维：传入通知类型枚举，根据枚举值进行判断调用什么通知类型的实现。\n2.对象组合：先想用什么通知，然后发出去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588899028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166612,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1577519377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577519377","product_id":100039001,"comment_content":"对扩展开放说的就是如何应对产品同事各种脑洞想法🐶<br>不过能预先扩展,那肯定能减少自己的工作量以及增加摸鱼时间咯.哈哈<br>","like_count":0},{"had_liked":false,"id":165901,"user_name":"柳柳木","can_delete":false,"product_type":"c1","uid":1420929,"ip_address":"","ucode":"DEE4ACCAE757B8","user_header":"https://static001.geekbang.org/account/avatar/00/15/ae/81/34a16bc8.jpg","comment_is_top":false,"comment_ctime":1577343258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577343258","product_id":100039001,"comment_content":"private ApplicationContext() { instance.initializeBeans(); }<br>这行有个bug!","like_count":0},{"had_liked":false,"id":165536,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1577255573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577255573","product_id":100039001,"comment_content":"我們公司在擴展方面弱爆了，現在擴展都是通過重新寫一個方法，在原方法名字後面加個V2，V3，最後弄得都不知道應該用V幾的方法才是合理的","like_count":0},{"had_liked":false,"id":165499,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1577246144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577246144","product_id":100039001,"comment_content":"这篇应该是我所读过的把开闭原则，程序扩展性讲得最清楚的文章。","like_count":0},{"had_liked":false,"id":165139,"user_name":"double","can_delete":false,"product_type":"c1","uid":1104928,"ip_address":"","ucode":"9C679F85CB6610","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/20/64394be8.jpg","comment_is_top":false,"comment_ctime":1577170633,"is_pvip":false,"replies":[{"id":"64849","content":"没大看懂你说的 你说的如何写指如何写什么呀","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1577668389,"ip_address":"","comment_id":165139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577170633","product_id":100039001,"comment_content":"老师，这些Handler如果都是spring管理的，该任何写比较好","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479045,"discussion_content":"没大看懂你说的 你说的如何写指如何写什么呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577668389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164930,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1577113287,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1577113287","product_id":100039001,"comment_content":"为什么要对扩展开放，对修改关闭，其实就是为了应对后续接入需求的变化而带来的可扩展性以及灵活性，如果所有的需求变更都是要通过大量修改原先的业务代码功能而达到目标，说明原先的设计是不达标的，不仅影响新功能，对原先老的业务功能也会产生影响，进而会影响整个产品对外的稳定性，加大后续开发，测试，运维等相关流程的周期。","like_count":0},{"had_liked":false,"id":164735,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1577084254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577084254","product_id":100039001,"comment_content":"我的总结：<br>2. 认识『开闭原则』很重要，因为大多数的设计原则、设计方法和设计模式都是围绕这个目的展开的<br>3. 对于原则的运用一定要结合实际的场景来做分析，不能太教条化<br>4. 如果做的是业务系统，要对业务有很详细的了解采用运用这个开闭原则；如果做的系统是和业务无关的偏向于通通用的，底层的系统，要明确调用方是谁，今后的功能路线图是什么","like_count":0},{"had_liked":false,"id":164083,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1576856545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576856545","product_id":100039001,"comment_content":"争哥出品，必属精品。","like_count":0},{"had_liked":false,"id":163596,"user_name":"有爱有波哥","can_delete":false,"product_type":"c1","uid":1464493,"ip_address":"","ucode":"DD9A023563151F","user_header":"https://static001.geekbang.org/account/avatar/00/16/58/ad/6abb57c4.jpg","comment_is_top":false,"comment_ctime":1576752922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576752922","product_id":100039001,"comment_content":"不是java出生还看不懂代码 😄","like_count":0},{"had_liked":false,"id":163085,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1576654615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576654615","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”<br>目的可以归纳为一词：省成本，不管事可维护性好，还是扩张性好，最终都是服务于现实，服务于经济成本。（个人理解）","like_count":0},{"had_liked":false,"id":163066,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1576651893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576651893","product_id":100039001,"comment_content":"OCP 指导我们在编码的时候多做些思考，完成某个功能是不难的，但要写出扩展性好，条理清晰，满足需求又不失扩展的代码是挺难的；OCP 给了一个写出这样代码的视角或者“标准”，应当在分析完需求后分出可变需求和不变需求，设计好代码结构，设计好单元测试，多做练习","like_count":0},{"had_liked":false,"id":162974,"user_name":"瓶子霸哥","can_delete":false,"product_type":"c1","uid":1125806,"ip_address":"","ucode":"A7EEB459AB5550","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/nVVI6Fib5LHbhAhv8CJ9MYPau7Lcp840ST6BeqnlibUNmI4UYvGIzxtOHcKIzFa10ERANAZQUaiaKkQg4SowsUR2g/132","comment_is_top":false,"comment_ctime":1576636776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576636776","product_id":100039001,"comment_content":"我突然想到, 如果有一天需求说某些通知可以截断别的通知该怎么改动呢?<br>比如优先检查 errorCount, 如果 errorCount 已经通知这个通知的话, 就不检查 tps 是否合理了?<br>这样不就要改动 AlertHandler 的抽象方法 check(), 就违反开闭原则了吗","like_count":0},{"had_liked":false,"id":162902,"user_name":"Geek_a85af3","can_delete":false,"product_type":"c1","uid":1747648,"ip_address":"","ucode":"1AB6285B2F80FF","user_header":"","comment_is_top":false,"comment_ctime":1576630194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576630194","product_id":100039001,"comment_content":"理论的学习还是需要结合实际的项目应用才能融会贯通，平时多有意识的去用上设计模式的思想，用的多了才能把握住这个分寸","like_count":0},{"had_liked":false,"id":162338,"user_name":"胖子","can_delete":false,"product_type":"c1","uid":1037760,"ip_address":"","ucode":"E6371346288A87","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIuRQaZX70dsBg6khub2VPM1eQAP9IWRWxgOFed3ia4kXyNJInFRicWJ0ibf2YmLsOvJa1sGygGpmJg/132","comment_is_top":false,"comment_ctime":1576501635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576501635","product_id":100039001,"comment_content":"以最小化的代价实现需求变更。","like_count":0},{"had_liked":false,"id":162241,"user_name":"Emily","can_delete":false,"product_type":"c1","uid":1265582,"ip_address":"","ucode":"F5AB9AAB475FDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/ae/eec8f44b.jpg","comment_is_top":false,"comment_ctime":1576485284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576485284","product_id":100039001,"comment_content":"ApplicationContext中的initializeBeans方法应该是private吧","like_count":0},{"had_liked":false,"id":162156,"user_name":"Geek_ecf7bb","can_delete":false,"product_type":"c1","uid":1523207,"ip_address":"","ucode":"5BF4DD62425BE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/3e/07/c27b53b8.jpg","comment_is_top":false,"comment_ctime":1576468022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576468022","product_id":100039001,"comment_content":"一旦修改了原代码就可能带来bug，更可怕的是需求频繁变化，带来的风险更高，而且每次直接改维护性很差，所以扩展的思路很重要。","like_count":0},{"had_liked":false,"id":161918,"user_name":"Varus","can_delete":false,"product_type":"c1","uid":1715988,"ip_address":"","ucode":"B9CB88C248BD93","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/14/840d0925.jpg","comment_is_top":false,"comment_ctime":1576401443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576401443","product_id":100039001,"comment_content":"对扩展开放，对修改关闭，主要还是为了以后如果又新的业务需求能够以最小的代价，或者说最便捷的方式完后对功能的新增或者修改，本质上来说，扩展开放和修改关闭是一件未雨绸缪的事情。","like_count":0},{"had_liked":false,"id":161833,"user_name":"小小代码","can_delete":false,"product_type":"c1","uid":1290642,"ip_address":"","ucode":"F3D4E2C23FC9BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/92/f3dabcb1.jpg","comment_is_top":false,"comment_ctime":1576370711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576370711","product_id":100039001,"comment_content":"请问老师，例中的handler可不可以写成责任链模式，当前handler不能处理了，再交给下一个handler处理","like_count":0},{"had_liked":false,"id":161722,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1576308216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576308216","product_id":100039001,"comment_content":"抽象类与接口实现封闭，继承与实现  实现了扩展<br>开闭原则","like_count":0},{"had_liked":false,"id":161654,"user_name":"用0和1改变自己","can_delete":false,"product_type":"c1","uid":1527530,"ip_address":"","ucode":"42B8F6ECF6BDD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/lfMbV8RibrhFxjILg4550cZiaay64mTh5Zibon64TiaicC8jDMEK7VaXOkllHSpS582Jl1SUHm6Jib2AticVlHibiaBvUOA/132","comment_is_top":false,"comment_ctime":1576287362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576287362","product_id":100039001,"comment_content":"对拓展开放是为了应对变化（新的需求），方便添加删除，对修改关闭是为了保证已有代码都稳定性（防止修改一个需求引出千万个bug）,最终还是为了系统更有弹性，更易维护","like_count":0},{"had_liked":false,"id":161605,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1576245297,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576245297","product_id":100039001,"comment_content":"课堂作业：<br>写代码遵循开闭原则的目的是为了新增代码的时候尽量不要影响原来的核心逻辑，同时可以灵活应对需求的变化","like_count":0},{"had_liked":false,"id":161586,"user_name":"牛顿的烈焰激光剑","can_delete":false,"product_type":"c1","uid":1042022,"ip_address":"","ucode":"C57018C65DAFB3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e6/66/fbbf0bb1.jpg","comment_is_top":false,"comment_ctime":1576239981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576239981","product_id":100039001,"comment_content":"重构后变得更抽象并不可怕，但是文档或注释一定要跟上。","like_count":0},{"had_liked":false,"id":161525,"user_name":"半截木头","can_delete":false,"product_type":"c1","uid":1296712,"ip_address":"","ucode":"72456E8E1BD6F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/c9/48/5a2879e3.jpg","comment_is_top":false,"comment_ctime":1576223749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576223749","product_id":100039001,"comment_content":"定义：添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。<br><br>解决的是什么问题：扩展性。<br><br>什么是开放和封闭<br>实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。<br>添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。-------不改主逻辑（流程），将变动封装于易改动处。<br><br>怎样做<br>在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。<br>在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。<br>抽象出来的不变接口就是扩展点。<br><br>具体方法<br>多态<br>依赖注入<br>基于接口而非实现编程<br>设计模式<br><br>怎么识别扩展点<br>对业务熟悉<br>知道用户怎么用，可能要的功能点<br><br>不盲目预留扩展点<br>只预留目前需要的，代价小的<br>扩展和可读的平衡","like_count":0},{"had_liked":false,"id":161482,"user_name":"NYang","can_delete":false,"product_type":"c1","uid":1239235,"ip_address":"","ucode":"FCDB3246D1195A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/c3/11479173.jpg","comment_is_top":false,"comment_ctime":1576215843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576215843","product_id":100039001,"comment_content":"对扩展开放是为了更快更好的适应新的需求，对修改关闭是为了在新增需求时降低程序出错的风险","like_count":0},{"had_liked":false,"id":161387,"user_name":"TSXQG","can_delete":false,"product_type":"c1","uid":1118087,"ip_address":"","ucode":"022BF5191BB5BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/87/505b8bf8.jpg","comment_is_top":false,"comment_ctime":1576200638,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576200638","product_id":100039001,"comment_content":"使用单例模式创建 ApplicationContext 类的时候，instance 为 null。 不能在构造器执行初始化语句。我把初始化放在获取实例的方法。<br>···java<br> public static ApplicationContext getInstance() {<br>        if (instance.getAlert() == null) {<br>            instance.initializeBeans();<br>        }<br>        return instance;<br>    }<br>···","like_count":0,"discussions":[{"author":{"id":1390286,"avatar":"https://static001.geekbang.org/account/avatar/00/15/36/ce/5c958ff9.jpg","nickname":"Just do it","note":"","ucode":"70C3F8F9707325","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111194,"discussion_content":"private ApplicationContext() {this.initializeBeans();}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577784954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161225,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1576151033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576151033","product_id":100039001,"comment_content":"我实现过一个推荐接口：<br>1.按照关注关系推荐<br>2.按照关注的股票推荐<br>3.按照用户画像推荐<br>当然还会有有其他很多，<br>但是将推荐接口抽取出来，各个实现类自行实现，这样以后添加新的推荐，去掉某个推荐，都不会太麻烦。<br>这应该是OCP的一个例子吧。","like_count":0},{"had_liked":false,"id":161224,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1576150913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576150913","product_id":100039001,"comment_content":"对扩展开放是为了适应变化，对修改关闭是为了以往代码的稳定性。","like_count":0},{"had_liked":false,"id":161075,"user_name":"肥而不腻","can_delete":false,"product_type":"c1","uid":1435246,"ip_address":"","ucode":"3E6786A82A6DD6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/6e/062da5e4.jpg","comment_is_top":false,"comment_ctime":1576114721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576114721","product_id":100039001,"comment_content":"为了尽量少点ifelse","like_count":0},{"had_liked":false,"id":160991,"user_name":"王小念","can_delete":false,"product_type":"c1","uid":1057147,"ip_address":"","ucode":"2062E25909B8E0","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/7b/53a325d1.jpg","comment_is_top":false,"comment_ctime":1576074261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576074261","product_id":100039001,"comment_content":"总结的很精辟！但落实到具体应用还需要自身多多思考，多多实践。就像争哥最后说的 “这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。”","like_count":0},{"had_liked":false,"id":160806,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1576034994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576034994","product_id":100039001,"comment_content":"对扩展开放，对修改关闭。本质上就是我们在改变逻辑或者增加逻辑的时候，尽量不要对已有的功能或者单元测试带来影响。不能因为新的改动破坏了老的系统的使用。","like_count":0},{"had_liked":false,"id":160788,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1576032603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576032603","product_id":100039001,"comment_content":"设计良好的计算机软件应该易于扩展, 同时抗拒修改. 也就是说, 一个设计良好的计算机系统应该在不需要修改的前提下可以轻易被扩展.<br>应该很容易通过新增代码来修改系统行为, 而不是只有修改原来的代码.","like_count":0},{"had_liked":false,"id":160781,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1576032043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576032043","product_id":100039001,"comment_content":"打卡<br>1、扩展开放、修改关闭 定义：添加一个新功能在原有的基础上扩展代码（新增模块、类、方法、属性），而非通过修改已有代码（修改模块、类、方法、属性）来完成；<br>2、一个修改在粗粒度下可以认为是“修改”，在细粒度下可以认为是“扩展”<br>3、多思考一下最近可能会有哪些扩展点，预留好；另外，识别出变换的部分，将变化的部分封装起来，提供一个抽象接口供上层系统调用；<br>4、提高扩展性常用的方法：多态、依赖注入、基于接口而非实现编程、入参封装成类，可以避免参数过多的修改等","like_count":0},{"had_liked":false,"id":160712,"user_name":"IOT..Yang","can_delete":false,"product_type":"c1","uid":1240343,"ip_address":"","ucode":"11589D83B67FE9","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/17/c3eb014f.jpg","comment_is_top":false,"comment_ctime":1576024973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576024973","product_id":100039001,"comment_content":"为什么“对扩展开放，对修改关闭”，正向考虑我看大家说的很多，我们也可以反向考虑，如果你增加一个新功能，会大量修改已有代码，那么就不能保证旧功能正确性(或者说是稳定性)，这样测试同学还得重新测试，费时费力。而且这种牵一发而动全身的修改方式也不优雅，也是前辈通过血和泪经历得出的结论，哈哈！","like_count":0},{"had_liked":false,"id":160669,"user_name":"云起","can_delete":false,"product_type":"c1","uid":1097790,"ip_address":"","ucode":"1642C543B47B87","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/3e/ff3ed621.jpg","comment_is_top":false,"comment_ctime":1576002805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576002805","product_id":100039001,"comment_content":"感觉核心是要做到修改只增加代码，避免删掉部分代码，而影响原来的执行逻辑","like_count":0},{"had_liked":false,"id":160636,"user_name":"风行者","can_delete":false,"product_type":"c1","uid":1541934,"ip_address":"","ucode":"F058640CF77A35","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/2e/ea54c240.jpg","comment_is_top":false,"comment_ctime":1575990499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575990499","product_id":100039001,"comment_content":"打卡，这个例子就是if else比较多的重构场景","like_count":0},{"had_liked":false,"id":160553,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1575973361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575973361","product_id":100039001,"comment_content":"老师，问个问题，我们现在要做个分佣金的功能，获得佣金的角色现在只有一种，就是购买人的上级，但是以后很可能会有其他角色获得分佣金，所以我就抽象了一个分佣金的interface，这个interface就定义了一个方法，就是分佣的动作，但是每个角色的分佣应该都有一个计算佣金的方法，我现在要不要把这个计算分佣的方法也加到前面说的interface里面呢，谢谢老师","like_count":0},{"had_liked":false,"id":160447,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1575952808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575952808","product_id":100039001,"comment_content":"有一个问题想问一下。随着handler的扩展，需要的参数可能越来越多，<br>ApiStatInfo类中也会存在各种乱七八糟的属性，实际过程中我就遇到一个权限规则校验的扩展点。权限规则可以随意扩展，但是每个规则需要的参数都不同，只能通过统一的bean传递，导致bean的参数越来越多，而且互相毫无关系。老师对于这个问题怎么看?","like_count":0},{"had_liked":false,"id":160445,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1575952552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575952552","product_id":100039001,"comment_content":"1. 应对需求变化，需求变化的时候可以迅速和方便的修改<br>(反问: 那我改代码也可以应对需求变化啊)<br>2. 控制影响最小，可以保证不影响比如原来的测试用例，调用代码。如果改代码的话。就有可能影响。<br>3. 添加新代码的时候可以缩小关注范围，我只需要关注我需要新实现的接口和初始化等，不需要从上到下查看旧的代码逻辑<br><br>我对“对扩展开放、对修改关闭”这个原则印象最深的:就是在修改的时候，不影响其他已经有的流程。<br>我把代码分为对内和对外，<br>对系统内：比较简单的情况下，不会在一开始太注重“对扩展开放、对修改关闭”，因为对内系统，就算修改，就是通一个应用，一般编译和单元测试修改也比较方便。除非当某一个点涉及到多次修改，那么才考虑抽象扩展点<br>对系统外: 比如暴露的网关，dubbo接口，就比较慎重，因为这块的调用方并不是由我们控制，修改的成本比较高，所以一般会提前考虑扩展点。","like_count":0},{"had_liked":false,"id":160369,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1575942082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575942082","product_id":100039001,"comment_content":"课堂讨论:为什么我们要“对扩展开放、对修改关闭”？<br><br>Answer:<br><br>我认为最重要的一点就是可维护性及维护成本.<br><br>若频繁的修改,会需要更多的测试,调试及时间成本.<br>若以扩展代替修改,则会减少很多不确定性,提高产品稳定性,同时也节约时间.","like_count":0},{"had_liked":false,"id":160364,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1237655,"ip_address":"","ucode":"088A8DA0A16BDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","comment_is_top":false,"comment_ctime":1575941447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575941447","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":160360,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1575941083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575941083","product_id":100039001,"comment_content":"第一个例子中: 我们先来分析一下改动一：往 ApiStatInfo 类中添加新的属性 timeoutCount。              这部分的改动相对来说是最不合理的。我认为更好的做法是，去掉ApiStatInfo类，或者说将这个类跟AlertHandler 解耦，每个handler的具体实现不应该是全部的ApiStatInfo, 而应该是其中的一部分，各自关心自己的属性即可，不必强求把所有的相关属性都归到一个类中，这种做法适得其反，既不内聚又强制耦合。其他改动没问题，增加新的handler 的实现类之后，当然可以做成配置型的添加或修改，关键在于开发的产品是什么性质的，如果是类似与SDK或spring 这种不希望让调用者看到源代码的，一定要做成可配置的，否则做成代码中的方法完全可以。然后就是每个handler 各自实现通知发送逻辑即可。","like_count":0},{"had_liked":false,"id":160341,"user_name":"BerryMew","can_delete":false,"product_type":"c1","uid":1013075,"ip_address":"","ucode":"E6CDD211617FF9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/53/76281fc3.jpg","comment_is_top":false,"comment_ctime":1575938678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575938678","product_id":100039001,"comment_content":"今天对开闭选择的理解算是豁然开朗了，虽然灵活运用还需大量实践与经验积累，但记住这节课中的handler的demo并且能够灵活运用，我觉得就已经很好了。","like_count":0},{"had_liked":false,"id":160339,"user_name":"Middleware","can_delete":false,"product_type":"c1","uid":1072015,"ip_address":"","ucode":"C0028293ECDD47","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/8f/4b0ab5db.jpg","comment_is_top":false,"comment_ctime":1575938489,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1575938489","product_id":100039001,"comment_content":"直白点就是保证已有业务不受影响，容易扩展新业务","like_count":0},{"had_liked":false,"id":160318,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1575935345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575935345","product_id":100039001,"comment_content":"对扩展开放是为了应对多变的需求，对修改关闭是为了避免被依赖的代码发生大的改动，花最小的代价去改动代码","like_count":0},{"had_liked":false,"id":160293,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1575906535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575906535","product_id":100039001,"comment_content":"1、对拓展开放是为了应对变化，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！<br>2、个人觉得公司我们组的代码就完全不符合开闭原则，通常是添加一个新的功能，每次测试上线还要回归其他的功能，根本无法做到说是老公能没有影响，leader也一直说是要重构，但是我个人是没什么好的想法，希望能多在争哥这学习一下，我也很想写出像争前面开头写的那个alert的重构，反正我是重构不出来","like_count":0},{"had_liked":false,"id":160278,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1575903907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575903907","product_id":100039001,"comment_content":"我的理解是加入新功能后对现有单元测试和调用处不用修改就算满足开闭原则，不知道对不对","like_count":0},{"had_liked":false,"id":160268,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1575901772,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575901772","product_id":100039001,"comment_content":"如果不对修改关闭,随意的修改,那么修改多了以后很可能会出现bug,影响原来的功能,而且代码逻辑会越来越复杂,变得难以维护,所以一开始就设计好可拓展性,以后即使增加功能也很方便,也不会影响到原来的代码.","like_count":0},{"had_liked":false,"id":160209,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1575892036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575892036","product_id":100039001,"comment_content":"总之别看见需求就开始写代码，能多想一步就多想一步，能把代码写活就别写死，让它再活几集。","like_count":0},{"had_liked":false,"id":160153,"user_name":"ismind","can_delete":false,"product_type":"c1","uid":1138710,"ip_address":"","ucode":"7AADD673ED3BC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/16/d1dd4972.jpg","comment_is_top":false,"comment_ctime":1575881194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575881194","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br>1，提高代码的质量，也就是将代码写得更好，当然也会权衡可扩展性和可读性，比如今天这个ALert的例子，如果告警规则少，业务逻辑简单，不需要“扩展开放，修改关闭”，也是可以的，因为代码可读性更好；如果规则多，逻辑复制，就需要修改关闭了；<br>2，文章提到了，“（1）调用函数的地方会修改（2）单元测试也会修改”，所以“扩展开放，修改关闭”可以降低维护成本，减少人力财力。这也是很重要的原因吧。<br>自己刚刚接触设计模式，希望能逐渐理解并会运用。","like_count":0},{"had_liked":false,"id":160136,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1575877617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575877617","product_id":100039001,"comment_content":"对扩展开放是因为需要应对需求的变化，做好了这一点，才能实现“对修改关闭”的结果，以保护已有代码的运行不受影响。<br>按照我的理解，“对修改关闭”是结果而不是我们需要去在代码层面做的，也不存在烂代码“对修改开放”","like_count":0},{"had_liked":false,"id":160113,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1575872520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575872520","product_id":100039001,"comment_content":"对旧版本的向上兼容，对未来需求的可扩展，对代码的可阅读性、可维护性","like_count":0},{"had_liked":false,"id":160109,"user_name":"moqifei","can_delete":false,"product_type":"c1","uid":1358410,"ip_address":"","ucode":"E0A6C858B78A3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGovXf8jNP5ZqHsDKLwajjicbFwpX9on1xiaJDR4CgWaWP2KcfOdneasBfKFo3dO3dwQyGG6WjK40w/132","comment_is_top":false,"comment_ctime":1575871489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575871489","product_id":100039001,"comment_content":"对扩展开放，对修改关闭，其根本是为了高内聚，低耦合。","like_count":0},{"had_liked":false,"id":160105,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1575871070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575871070","product_id":100039001,"comment_content":"打卡～，之前对开闭原则一直很困惑，很多对扩展开放的操作实际上还是对代码进行很多修改了呀。今天的课让我有一点感觉了，关于这点的小结：<br>第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。<br>第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。","like_count":0},{"had_liked":false,"id":160093,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1575868619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575868619","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br>修改代码可能会带来问题，尽量将修改代码量做到最小，可控，那么出现问题几率就越小。<br>一般程序都是要迭代的，要不断变化，应对不用的需求，扩展就是为了应对未来的需求变化。<br>保持代码的稳定性，能很好的应对未来的需求变化","like_count":0},{"had_liked":false,"id":160090,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1575868256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575868256","product_id":100039001,"comment_content":"为了平衡，业务稳定和加入新特性的矛盾。<br><br>1.不可修改语意更明确，减少阅读代码的心智负担。<br>2.通过扩展实现新特性，后期出问题好定位，有变更易拔插。","like_count":0},{"had_liked":false,"id":160067,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1575863188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575863188","product_id":100039001,"comment_content":"灵活应对需求变化,提高可测性稳定性.","like_count":0},{"had_liked":false,"id":160054,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1575861321,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575861321","product_id":100039001,"comment_content":"做扩展开放，对修改关闭：实际上还是需要业务功能的驱动。<br><br>拿到一份需求，以及一份月度、季度甚至是年度规划的时候，可以先考虑下需要用到的功能，需要新写还是直接扩展需求点，需要设计多少接口， 实现多少细节等等，有个大概的维度。<br><br>但是就如课程中说的，“唯一不变的只有变化本身”。所以，这就还涉及到过度设计的问题，才能更好的去做对扩展开放，对修改关闭的事情，我太难了，哈哈。<br>","like_count":0},{"had_liked":false,"id":160047,"user_name":"划时代","can_delete":false,"product_type":"c1","uid":1061454,"ip_address":"","ucode":"9554CE2F83B77F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2o1Izf2YyJSnnI0ErZ51pYRlnrmibqUTaia3tCU1PjMxuwyXSKOLUYiac2TQ5pd5gNGvS81fVqKWGvDsZLTM8zhWg/132","comment_is_top":false,"comment_ctime":1575860409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575860409","product_id":100039001,"comment_content":"这一篇“对扩展开放，对修改关闭”收获良多，是设计模式的精髓所在。我的实践过程，由最开始的大量运用到最后的敬而远之，疑惑很多。新手和高手之间的差距，原来就在一个运用的度上。“对扩展开放，对修改关闭”在于，最大的复用原有代码，最小的改动原有代码；高内聚，低耦合；更好的单元测试和保证代码质量。","like_count":0},{"had_liked":false,"id":160013,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":1514882,"ip_address":"","ucode":"2F1FA3519FAB50","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyiafvkibXnTOpIJxlhndHpSDMsqja9AajKYtYgGEGtFWtBb2Mg8DRVjqlWyIxl1piaT4qpMkwerQUg/132","comment_is_top":false,"comment_ctime":1575857685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575857685","product_id":100039001,"comment_content":"我们要时刻具备扩展意识、抽象意识、封装意识。希望通过学习培养自己这种意识，在今后看源码要多从设计入手，多分析，总结，希望早日养成这种感觉，使设计变的敏感。","like_count":0},{"had_liked":false,"id":160007,"user_name":"JOsuny","can_delete":false,"product_type":"c1","uid":1319513,"ip_address":"","ucode":"5F36D3D1AF83EA","user_header":"https://static001.geekbang.org/account/avatar/00/14/22/59/781b6fa5.jpg","comment_is_top":false,"comment_ctime":1575856920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575856920","product_id":100039001,"comment_content":"打卡<br>","like_count":0},{"had_liked":false,"id":159990,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1575854793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575854793","product_id":100039001,"comment_content":"简单一点就行，不要留下祖传代码，留着谁都不敢修改代码，避免牵一发而动全身。","like_count":0},{"had_liked":false,"id":159989,"user_name":"SMTCode","can_delete":false,"product_type":"c1","uid":1109038,"ip_address":"","ucode":"0D837A753E4FAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/2e/49d13bd2.jpg","comment_is_top":false,"comment_ctime":1575854743,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575854743","product_id":100039001,"comment_content":"昨天在复习设计模式时，在打卡中刚刚提到了自己实际开发中用到的“开闭原则”，今天争哥就在这里系统的讲到了，感觉共鸣点颇多，特此总结一下：<br>看了争哥的讲述，发现自己那段协议代码能抽象的更好一些：可以通过定义一个更高层的类，通过调用这个类的公共的check来封装所有的handler，这样就不需要我说的多个else if的更新了。<br>刚刚在想争哥文中举的“错误处理”那个例子感觉使用的和“外观模式”类似，但看了一下外观模式的场景，感觉自己套错了模式。<br>其实，我觉得开闭原则的核心就是：<br>1、提高代码的扩展性<br>2、降低扩展功能的成本<br>3、扩展功能时，不影响旧的功能。<br>有了开闭原则，在有新需求时，就可以大胆的扩展新功能，最坏的情况就是：新功能的bug只导致新功能不好用。所以对原有功能的冲击是“零”。同时，新接触项目的人，一旦掌握了这个设计框架，能很快的上手新功能的开发。间接提高了代码的可维护性。说真的，我之前那段代码的协议具体实现细节早就忘的一干二净了，但如果要做扩展，支持新的协议，开发的难度就是如何构造新的协议了。<br><br>正如争哥所言：很多设计模式是为了提高代码的扩展性，那么，如果对业务不熟悉，对需求不明确，如何能发现系统的共性？如何能找到系统中未来需要扩展的热点代码？其实如果一切都弄清楚了，可以说最终写代码就是纯力气活了。代码框架的抽象能力体现了一个程序员的综合实力。 <br>加油吧！<br>外观模式是将一个“外部”需要调用多个子系统配合才能产生正确结果的问题，进行了封装和隐藏，通过一个更高层的类，隐藏系统内部的细节，避免了外部需要过多的了解系统内部的实现步骤。显然这里不是这种情况。<br><br>","like_count":0},{"had_liked":false,"id":159987,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1575854331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575854331","product_id":100039001,"comment_content":"为什么要对“扩展开放，对修改关闭”？<br>我觉得一是提高新功能的开发效率，二是减少旧代码的维护成本<br>既开源又节流","like_count":0},{"had_liked":false,"id":159983,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1575853988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575853988","product_id":100039001,"comment_content":"1.对于一直在提供服务的代码，改动是必然的，因为世界一直在变化。<br>2.添加新功能时，肯定是需要修改已有代码的（新增模块、类、方法等），<br>3.针对不同粒度中的代码改动，在粗代码粒度下，可能是”修改“，在细代码粒度下，又可以被认定为”扩展“<br>5.划重点：设计初衷：没有破坏原有代码的正常运行，没有破坏原有的单元测试，这一个合格的代码改动<br>6.尽量做到修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则<br>7.此原则与可读性存在某种程序的冲突，需要针对具体的场景权衡。","like_count":0},{"had_liked":false,"id":159978,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1575853821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575853821","product_id":100039001,"comment_content":"学习学习，对拓展开发对修改关闭，为了减少以后代码维护的难度，而且扩展写的代码会给自己一种“挖槽，老子这么这么聪明，早就想到了改动了”的快感","like_count":0},{"had_liked":false,"id":159977,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1575853516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575853516","product_id":100039001,"comment_content":"举个例子，我们的下单接口有很多验证，之前的代码有好多的if else，像面条是的，这样代码可读性也不好，修改了某处就可能造成错误，如果把这些验证搞成开放关闭原则，在下单那个接口只要写个foreach循环各种验证，以后再增加或者删除验证也不需要在下单接口修改了，只需要在增加一个验证的实现类，把该实现类绑定到控制器里面，如果不需要某个验证，只需要在绑定那个地方删除掉就可以了，感觉这个原则比较优雅，改起来也方便快捷，当然如果验证条件不是很多就没必要用这个原则了，毕竟运用原则理解起来比直接写ifelse有难度，一定要适度，不要所有代码都套上各种设计模式和原则。","like_count":0},{"had_liked":false,"id":159963,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1575852327,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575852327","product_id":100039001,"comment_content":"首先设计好函数，然后思考这个函数是否有扩展的需求，如果有，那么将这个类变为抽象类，用子类实现该函数。扩展性的理解前提是好的函数设计。","like_count":0,"discussions":[{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76760,"discussion_content":"开放封闭的判断依据：\n1. 对已有测试的影响\n2. 新的功能尽量通过增加类而不是修改类\n3. 不必过于纠结是否修改类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575852735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159962,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1575852239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575852239","product_id":100039001,"comment_content":"对扩展开放是为了应对软件迭代过程中的变化;对修改关闭则是为了在增加这些变化的过程中防止软件出bug，减少对源代码的改动！","like_count":0},{"had_liked":false,"id":159956,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1575851440,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575851440","product_id":100039001,"comment_content":"前排打卡～😃","like_count":0},{"had_liked":false,"id":159949,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1575850866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575850866","product_id":100039001,"comment_content":"对扩展开放，对修改关闭。只要还是为了代码的可维护性和稳定性，在旧代码上修改，所有相关的单元测试都要重写，功能全部要重测，如果调用地方多，兼容性还不一定可以全覆盖到。出现线上问题也排查麻烦，这个问题改了一块，有因为这一块影响到了别的功能。代码质量会越来越差，有一天变成祖传代码就没有人敢去动了。<br><br>基于扩展的，几乎不会影响到旧的实现，只是自身的变化，代码可维护性好，质量高。易于测试，各块各司其职。缺点就是可读性变差了。","like_count":0},{"had_liked":false,"id":159940,"user_name":"progyoung","can_delete":false,"product_type":"c1","uid":1014692,"ip_address":"","ucode":"0B4898AE78F9F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/a4/24955994.jpg","comment_is_top":false,"comment_ctime":1575849542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575849542","product_id":100039001,"comment_content":"对扩展开放以应对不断变化的需求，对修改关闭以应对减少未来添加新功能时对现有代码的改动。","like_count":0},{"had_liked":false,"id":159920,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1575842342,"is_pvip":false,"discussion_count":16,"race_medal":0,"score":"2999463014950","product_id":100039001,"comment_content":"对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！","like_count":699,"discussions":[{"author":{"id":3109430,"avatar":"https://static001.geekbang.org/account/avatar/00/2f/72/36/99d12115.jpg","nickname":"西瓜","note":"","ucode":"A1E3E2579713E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589659,"discussion_content":"总结的太好了，学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665222782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159942,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1575849682,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"508381990610","product_id":100039001,"comment_content":"开闭原则：基于接口或抽象实现“封闭”，基于实现接口或继承实现“开放”（拓展）。<br><br>争哥的第一个例子，AlertHandler为抽象，一般是固定不变的。子类TpsAlertHandler为继承；再看第二个例子，MessageQueue，MessageFormater为接口，具体实现为KafkaMessageQueue和JsonMessageFromatter等。以后替换或者增加其他的AlertHandler和message queue很容易。<br><br>两个例子中的抽象类和接口是固定的（封闭），继承或实现是可扩展的。通过“抽象-具体”体现了开闭原则，增加了软件的可维护性。<br><br>开闭原则具体应用，需要慢慢积累经验。争哥也说了，首先需要有对业务深刻的理解。其次就是学习一些设计原则和模式了。<br><br>补充：<br>1、Bertrand Meyer 1988 年提出open-closed principle。<br>2、再推荐一篇经典文章 Robert C. Martin 2006年写的The Open-Closed Principle。不方便下载的话，我放到github上了：https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;tree&#47;master&#47;designpattern&#47;pdf","like_count":119,"discussions":[{"author":{"id":1442885,"avatar":"https://static001.geekbang.org/account/avatar/00/16/04/45/0c474d47.jpg","nickname":"二少","note":"","ucode":"190983809CD3EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366514,"discussion_content":"用一层&#34;虚&#34;的东西去隔离可变的部分。让调用方与这层&#34;虚&#34;的东西交互，从而将易变的转化成不变的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618103630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517556,"avatar":"https://static001.geekbang.org/account/avatar/00/17/27/f4/a1ce6248.jpg","nickname":"一尾","note":"","ucode":"67D404036231D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304485,"discussion_content":"你是课代表吧hhhh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599578405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316454,"avatar":"https://static001.geekbang.org/account/avatar/00/14/16/66/083e7f7e.jpg","nickname":"silent","note":"","ucode":"325D31F0608249","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284586,"discussion_content":"我看完老师的，一定要再来看看你的回复，才算学完这节课哈哈。点赞！方便加个微信不？向你学习！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592563456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1316454,"avatar":"https://static001.geekbang.org/account/avatar/00/14/16/66/083e7f7e.jpg","nickname":"silent","note":"","ucode":"325D31F0608249","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284599,"discussion_content":"过奖了！后期的课程我回复的没那么认真了，惭愧。近期事情少了，要补回来。v信guodong-hu","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592565461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284586,"ip_address":""},"score":284599,"extra":""}]},{"author":{"id":1153592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","nickname":"anders","note":"","ucode":"610C80D742C331","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267537,"discussion_content":"老铁，你的阅读量很丰富哇~点个赞学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589643574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159974,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1575853296,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"186259447024","product_id":100039001,"comment_content":"听前一部分的时候觉得，哇原来代码还可以这样重构，我以后写代码一定要这么写！看到最后，恩……还是要结合具体业务需求，考虑实现开闭的代价，取舍哪些需要适应开闭原则哪些可以忽略，避免过度设计。整体来说在写代码的时候要多思考一下如何应对短期内可能面临的变化。知识+经验+多思考，看起来编程没有银弹，多思考，多总结。","like_count":43,"discussions":[{"author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119330,"discussion_content":"我觉得你一定要那么写，首先要能写出那样的代码才会建立起来设计思想。抽象思维。其次，一堆if语句是最恶心的代码没有之一","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578226940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560011,"discussion_content":"我觉得一定要这么写，因为不写  过几天就忘记了  然后就没有然后了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649122649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2516041,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/1UV7tTtMTM8hyvGl2YaSVczZve3e2aOcrRafvg64WQo7hYRRzGnondFElhGv0RnQZQgn6PycYzal2b5oAwYXtg/132","nickname":"太行山人","note":"","ucode":"66EB8BFD311A45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542235,"discussion_content":"避免过度设计，知其然，知其所以然，具体问题，具体对待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640688523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159916,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1575839443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"151899694803","product_id":100039001,"comment_content":"基于一定的粒度（例如模块，类，属性等），扩展是平行地增加，修改是变更更细粒度的子集。扩展和修改和具体的粒度有关。不同的粒度下，扩展和修改定义不同。<br>我个人以为，扩展的结果是引入了更多的平行结构（例如相似的派生类handler），以及支持这些平行结构的代码（利用多态，在关键的地方使用接口）。这些引入会让代码结构变的扁平一些，但是也更晦涩一些。修改，往往会增加代码的深度（这里指更低粒度的复杂度），例如，文中log例子，修改后，check函数有五个参数，内部的if else逻辑更多。但是，如果从参数以及if作用域的角度，这也可算作扩展。所以，扩展还是修改更本质的区别在于修改发生的粒度和层次。<br>通常偏好修改发生在更高的层次上，这要求我们能够用接口和组合把系统合理的切分，做到高内聚和低耦合。高内聚可以让修改发生在更高层次上，替换掉整个低层次实现细节。低耦合，可以让模块之间的调用最小化，可以让高层次的修改最小化。<br>支持高层次的平行结构不是免费的，除非有明确的收益（例如文中隔离Kafka实现细节的例子），不然还是让重构等待到需要的那一刻，预测未来的大部分平行结构其实不会被真正用到。","like_count":36},{"had_liked":false,"id":165746,"user_name":"古杨","can_delete":false,"product_type":"c1","uid":1744092,"ip_address":"","ucode":"8F52AA86B589C7","user_header":"","comment_is_top":false,"comment_ctime":1577316492,"is_pvip":false,"discussion_count":24,"race_medal":0,"score":"143311237260","product_id":100039001,"comment_content":"我所在的公司，现在写代码入参全用map，写了两年我都不知道什么叫对象了。感觉自己废了☹️","like_count":34},{"had_liked":false,"id":159914,"user_name":"(´田ω田`)","can_delete":false,"product_type":"c1","uid":1210588,"ip_address":"","ucode":"CA043D3EC6FE7E","user_header":"https://static001.geekbang.org/account/avatar/00/12/78/dc/0c9c9b0f.jpg","comment_is_top":false,"comment_ctime":1575827243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"91770140459","product_id":100039001,"comment_content":"修改老功能，可能需要重新进行各种功能验证、测试，并且如果是接收的遗留代码，更是费时费力；<br>但是扩展的话，只需要对自己新增加的功能进行测试，工作量会小很多。","like_count":21},{"had_liked":false,"id":197873,"user_name":"01Running","can_delete":false,"product_type":"c1","uid":1015862,"ip_address":"","ucode":"2E50E4FD35D3B5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/36/29e4863f.jpg","comment_is_top":false,"comment_ctime":1585401586,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"70304878322","product_id":100039001,"comment_content":"计算机技术就是一门权衡的技术！","like_count":16,"discussions":[{"author":{"id":1149564,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8a/7c/949163dd.jpg","nickname":"成业梁","note":"","ucode":"530EB2C9718699","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291088,"discussion_content":"艺术","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594704681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2093150,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f0/5e/e06261fd.jpg","nickname":"如风过境","note":"","ucode":"318A4E85AF231C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1149564,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8a/7c/949163dd.jpg","nickname":"成业梁","note":"","ucode":"530EB2C9718699","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578306,"discussion_content":"学的好的代码确实是艺术","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656645530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291088,"ip_address":""},"score":578306,"extra":""}]},{"author":{"id":1207410,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","nickname":"紫日","note":"","ucode":"73A8DEE323AC19","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317225,"discussion_content":"虽然计算机只认识0和1，但计算及技术服务于人多，人的行为因时因势而定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603518388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159917,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1575840633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70295317369","product_id":100039001,"comment_content":"对原有代码改动越少，引入问题的概率越小。在熟悉业务的情况下，多思考一步，为了未来需求预留扩展点，就是有扩展性的代码。但凡事都有个度，扩展性和可读性需要不断权衡，需求在不断变化，系统也在不断演化，通过不断重构来解决过度设计的问题。","like_count":16},{"had_liked":false,"id":160767,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1181486,"ip_address":"","ucode":"E82C58AF2604ED","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/2e/878d3c92.jpg","comment_is_top":false,"comment_ctime":1576030650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61705572794","product_id":100039001,"comment_content":"文章写的是真的好，很容易读懂。主要的还是要知道为什么要这么做。感谢老师。","like_count":14},{"had_liked":false,"id":162986,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1258380,"ip_address":"","ucode":"BFA3BE8D8773A7","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/8c/23eef8d7.jpg","comment_is_top":false,"comment_ctime":1576638139,"is_pvip":false,"replies":[{"id":"62272","content":"重载可以。但如果报警规则很多的花 类会无限膨胀 可读性比较茶","user_name":"作者回复","comment_id":162986,"uid":"1190123","ip_address":"","utype":1,"ctime":1576797986,"user_name_real":"王争"}],"discussion_count":9,"race_medal":0,"score":"57411212987","product_id":100039001,"comment_content":"文中的alter 一步一步的改造，看的眼花缭乱的😂，我就问下，为什么不能直接在原始的Alter 类中，重载一个只有新增业务参数的check 放到的，这样不就最简单，原先开发好也不用动，这样对于Alter 类来说不是对扩展开放，对修改关爱了吗？请教下大神，我这种用重载的思路有啥，不好的地方","like_count":13,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478198,"discussion_content":"重载可以。但如果报警规则很多的花 类会无限膨胀 可读性比较茶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576797986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2310814,"avatar":"","nickname":"Geek_d42e24","note":"","ucode":"CF7267A42B5E30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393918,"discussion_content":"重载是像c++ java等复杂面相对象语言才有的，go这种灵活的oop语言不支持重载。另外如果重载方法很多，看代码是真的是很有心智负担。调用者也得小心翼翼的传参。而通过不同hander实现类的方式不会存在这些问题","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631637099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607988,"avatar":"https://static001.geekbang.org/account/avatar/00/18/89/34/758bd3ab.jpg","nickname":"曉楓","note":"","ucode":"E2B4C10FC4DAB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307239,"discussion_content":"感觉任何设计原则都是基于数据量大或者需求复杂才有价值的，不能老是杀鸡用牛刀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600567308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1608383,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","nickname":"X_L～","note":"","ucode":"6BD8C24750F86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302849,"discussion_content":"作者的例子还是简单的demo级别的,实际生产过程中确实得考虑直接重载的复杂性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599046961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064902,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3f/c6/c2bf55bd.jpg","nickname":"devilyaos","note":"","ucode":"5FE075608F03F7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545977,"discussion_content":"重载是要看参数位置和类型的，也许扩展需求里相同位置的参数表达的含义是不同的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642120419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1982711,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/40/f7/e62bbc62.jpg","nickname":"zh","note":"","ucode":"98772B1B6C6E06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342681,"discussion_content":"有两个路子改起来最省事：1.添加一个参数，然后给个默认值-1，然后函数里写等于-1就是老代码，不做check，否则执行新的逻辑；2.要满足开闭原则是吧，那添加一个重载函数。这两个路子都有个问题：在进行大规模重构（耦合度太高，参数加了好几个了）或性能优化的时候（函数里面的逻辑执行效率低，需要提前建立缓存，把部分逻辑放在函数外先执行，或者使用其它对象的数据，或者需要调换执行顺序，或者里面的算法要换，等等），这个时候如果参数过多（特别是默认参数）或者重载版本过多（比如有十来个），做性能优化的人会非常痛苦，明明知道性能瓶颈在哪，也知道改进方法，但是面对一坨坨的代码，根本改不动。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610775644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122277,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/e5/053ebfc9.jpg","nickname":"•••","note":"","ucode":"D7F185FC4BFE14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332810,"discussion_content":"其实进行按照错误分类后重载也是一种实现方式，每一种错误都重载确实一点扯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607345404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622209,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c0/c1/414d5d1b.jpg","nickname":"_yh葱","note":"","ucode":"FA899711E91113","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311176,"discussion_content":"重载确实也是另外一种实现方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602243756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1622209,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c0/c1/414d5d1b.jpg","nickname":"_yh葱","note":"","ucode":"FA899711E91113","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561190,"discussion_content":"重载  比较复杂，并且让可读性越来越差","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649573885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311176,"ip_address":""},"score":561190,"extra":""}]}]},{"had_liked":false,"id":160407,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1575945799,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"48820586055","product_id":100039001,"comment_content":"简单来说，就是尽量减少调用方为了应对而导致的变更。<br>就例如本文的例子，为了应对变化需要增加函数的参数的时候。所有调用方都需要改代码。<br>而如果依照开闭原则，则增加handler 以及相应修改即可。并不会影响调用方。<br><br>其实个人认为，也是通过了 类似于“中间件”的形式。例如，小明，作为公司代表需要跟各个国外公司的人谈业务。他去跟美国人谈业务，需要学英语；跟日本谈业务，要学日语；跟毛子谈业务，又要学毛子语。<br>这时候，的解决方案：<br>1，跟各个国家说好，大家都说英语。或者都说汉语。就算再有其他的国家，也让他强制用英语。<br>2，小明自己只用汉语。然后谈业务时，带个多语种翻译，去谈业务时把翻译带上。这时候，如果有新的国家需要新的语种，那么就让翻译去掌握更多的语种。<br>应对今天的例子，翻译掌握的语种，其实就是handler。小明和各国代表谈业务时，各自都不需要变更自己的接口。只需要对【翻译】进行扩展即可。","like_count":11,"discussions":[{"author":{"id":1087243,"avatar":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","nickname":"zhou","note":"","ucode":"E1CE8575B3F106","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263453,"discussion_content":"你的理解就是说话的接口 由各个翻译实现了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589207720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260728,"discussion_content":"还是从代码理解好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588897880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159923,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1575846463,"is_pvip":false,"replies":[{"id":"61125","content":"1. 是贫血模型<br>2. 不好讲，拆分之后，类增加，维护成本高一些，但职责更单一，更加高内聚、低耦合，扩展性更好些。","user_name":"作者回复","comment_id":159923,"uid":"1190123","ip_address":"","utype":1,"ctime":1575896283,"user_name_real":"王争"}],"discussion_count":5,"race_medal":0,"score":"48820486719","product_id":100039001,"comment_content":"关于修改后的报警规则代码实现有两个疑问：<br>1. ApiStateInfo class 是充血模型还是贫血模型。<br>2.其实各个handler侧重的是不同的方方面面，比如错误次数，超时次数。统一接收ApiStateInfo  和 某一个handler接收具体的类比如：ErrorRequestApiStateInfo,  TimeOutStateInfo， 哪种方式好呢？比较依据是什么","like_count":11},{"had_liked":false,"id":159975,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1575853341,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44525526301","product_id":100039001,"comment_content":"设计模式_16<br># 作业：<br>开闭原则核心好处是：<br>- 减少因为新增功能而增加的工作量<br>- 减少因为新增功能而增加的出错数<br><br># 感想：<br>之前一直有一些执念，想要找到某一原则非黑即白的分割线。比如开闭原则，有两个极端：<br>- 任何的“修改”都不能接受<br>- 任何不能“扩展”的代码都不能接受<br>然后就进入了“走火入魔”的状态，最终陷入对原则的怀疑。<br><br>需求变更对于代码结构影响很大时，要提高对其扩展的权重；读到这里时，我拍了一下大腿，我想，我更加理解开闭原则了。","like_count":10,"discussions":[{"author":{"id":1328500,"avatar":"https://static001.geekbang.org/account/avatar/00/14/45/74/7a82eebb.jpg","nickname":"Ins","note":"","ucode":"A2509BAD9CB72C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577465,"discussion_content":"减少新增功能的工作量，这条就不对了🌚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656129024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160380,"user_name":"哈喽沃德","can_delete":false,"product_type":"c1","uid":1749033,"ip_address":"","ucode":"7620366C16826B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b0/29/7ab573f4.jpg","comment_is_top":false,"comment_ctime":1575943290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40230648954","product_id":100039001,"comment_content":"我想这篇对扩展开放，多修改关闭的文章应该会成为争哥这个设计模式系列最好的文章。很难想象，一个杰出的程序员的语言思维逻辑也是如此清晰。","like_count":9},{"had_liked":false,"id":160479,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1575958980,"is_pvip":true,"discussion_count":8,"race_medal":0,"score":"35935697348","product_id":100039001,"comment_content":"老师您好，我把代码实践了后发现， 单例初始化那块可能有点问题。private static final ApplicationContext instance = new ApplicationContext();<br><br>    private ApplicationContext() {<br>        instance.initializeBeans();<br>    }<br>这个“instance”报了空指针。","like_count":8,"discussions":[{"author":{"id":1048367,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/2f/172b942b.jpg","nickname":"扬帆起航","note":"","ucode":"708B686F19B8DE","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118004,"discussion_content":"直接 \nprivate ApplicationContext() {\n        this.initializeBeans();\n    }","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578146666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1588205,"avatar":"","nickname":"wood_wood","note":"","ucode":"3872CEB7507F82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79081,"discussion_content":"我感觉也是代码写错了，但是不用纠结，动点脑筋应该可以修改为正确的调用方式。学习不能只学形式，不动脑筋。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576053657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731701,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6c/75/16aca70e.jpg","nickname":"卡布奇诺","note":"","ucode":"218CEEF5328C7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78216,"discussion_content":"我这边也是，还有没有其他小伙伴遇到这个问题呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575984151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1570088,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","nickname":"deepz","note":"","ucode":"4BD23A44CDB384","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1731701,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6c/75/16aca70e.jpg","nickname":"卡布奇诺","note":"","ucode":"218CEEF5328C7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78770,"discussion_content":"final声明可以直接初始化，也就是调用空参，然而空参构造里又需要还未初始化成功的对象引用，instance，所以会空指针。我是真么理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576020616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78216,"ip_address":""},"score":78770,"extra":""}]},{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561191,"discussion_content":"构造函数不需要  instance.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649573970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352322,"discussion_content":"构造函数不需要 instance.喔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614682957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366413,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d9/8d/a6984f12.jpg","nickname":"Jason.w","note":"","ucode":"EE39ADEB7C6BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297083,"discussion_content":"单例对象也是需要通过构造器去实例化的，出现问题的原因是，你在构造函数里使用还没有实例化好的单例对象。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596769784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282715,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","nickname":"Wh1","note":"","ucode":"6D28506B99A285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201614,"discussion_content":"我是直接将初始化的逻辑放构造函数中，这样就没问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583815666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261887,"user_name":"航哥很帅","can_delete":false,"product_type":"c1","uid":1145270,"ip_address":"","ucode":"23A1CB2A3723AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/b6/faaa95a2.jpg","comment_is_top":false,"comment_ctime":1605570116,"is_pvip":true,"replies":[{"id":"96131","content":"总结的好","user_name":"作者回复","comment_id":261887,"uid":"1190123","ip_address":"","utype":1,"ctime":1606701246,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"27375373892","product_id":100039001,"comment_content":"之所以会有对扩展开放，对修改关闭的原则，是因为对扩展开放能够应对业务需求的变化，从而实现已有功能的扩展，而对修改关闭是为了保证在扩展新的需求是，能够保证已有功能的稳定。<br><br><br>对扩展开放，对修改关闭原则，听起来很简单，就是指我们在开发时尽可能的少修改已有的代码，而应该增加新的代码来实现新的功能。但对于这个原则，往往是很难绝对执行的，因为即使是完全增加新的功能，也很难做到百分百不修改原来的代码。所以，对扩展开放，对修改关闭的原则，用大白话来说就是在尽可能少修改以后功能代码的情况下，通过增加新的功能代码来实现新的功能。<br><br><br>如果想做到对扩展开放，对修改关闭，作为一个程序员要有扩展意识、封装意识和抽象意识。这三个意识听起来很简单，但要真正的做到必须要多实践多练习才能够慢慢的心领神会。","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509655,"discussion_content":"总结的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270440,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1609127096,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"23083963576","product_id":100039001,"comment_content":"个人认为可读性是第一位的，代码写的再NB,一个组的只有你自己能看懂有什么用呢？","like_count":5,"discussions":[{"author":{"id":2612274,"avatar":"https://static001.geekbang.org/account/avatar/00/27/dc/32/8b1c20a9.jpg","nickname":"升国旗","note":"","ucode":"5140BE3BB11165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377855,"discussion_content":"是不是该考虑一下提升组员的水平了","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1622910127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2671691,"avatar":"https://static001.geekbang.org/account/avatar/00/28/c4/4b/bf30a25e.jpg","nickname":"Honey,","note":"","ucode":"00AB03C755AD79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2612274,"avatar":"https://static001.geekbang.org/account/avatar/00/27/dc/32/8b1c20a9.jpg","nickname":"升国旗","note":"","ucode":"5140BE3BB11165","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390778,"discussion_content":"代码牛逼 也可以是一个贬义词","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630044810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377855,"ip_address":""},"score":390778,"extra":""}]},{"author":{"id":2833619,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","nickname":"探雪","note":"","ucode":"2332650D9C8D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531727,"discussion_content":"没有绝对的事物，可读性虽然好，但是可维护性低，不符合高内聚低耦合也是垃圾代码","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637397594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/7e/b6829040.jpg","nickname":"SevenMonths","note":"","ucode":"62A9740FBD1FAE","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405319,"discussion_content":"另外一个词叫不可替代性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634555525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1328500,"avatar":"https://static001.geekbang.org/account/avatar/00/14/45/74/7a82eebb.jpg","nickname":"Ins","note":"","ucode":"A2509BAD9CB72C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1201022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/7e/b6829040.jpg","nickname":"SevenMonths","note":"","ucode":"62A9740FBD1FAE","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":577466,"discussion_content":"通透啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1656129101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":405319,"ip_address":""},"score":577466,"extra":""}]},{"author":{"id":1098720,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","nickname":"技术骨干","note":"","ucode":"8FCF8DE6D29201","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545219,"discussion_content":"就按照jdk的标准来写就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641877945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160221,"user_name":"土豆哪里挖","can_delete":false,"product_type":"c1","uid":1370705,"ip_address":"","ucode":"F27B3BA0477050","user_header":"https://static001.geekbang.org/account/avatar/00/14/ea/51/9132e9cc.jpg","comment_is_top":false,"comment_ctime":1575893512,"is_pvip":false,"replies":[{"id":"61121","content":"关注我的github：https:&#47;&#47;github.com&#47;wangzheng0822","user_name":"作者回复","comment_id":160221,"uid":"1190123","ip_address":"","utype":1,"ctime":1575895647,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"23050729992","product_id":100039001,"comment_content":"什么时候出其他语言的demo呢，不懂java，理解起来太痛苦了","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477300,"discussion_content":"关注我的github：https://github.com/wangzheng0822","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575895647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1738272,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/20/e71b5585.jpg","nickname":"蓝二哥哥我才是无羡啊👻","note":"","ucode":"E70EE4E08F16AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295398,"discussion_content":"同感，不太熟悉Java，看代码很费劲","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596182334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1734573,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/77/ad/b4089a68.jpg","nickname":"Yule_J","note":"","ucode":"A36E41BDC1189E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1738272,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/20/e71b5585.jpg","nickname":"蓝二哥哥我才是无羡啊👻","note":"","ucode":"E70EE4E08F16AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382104,"discussion_content":"同感，看GitHub还是没有其他语言的如Python","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625412557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295398,"ip_address":""},"score":382104,"extra":""}]}]},{"had_liked":false,"id":160438,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1575951277,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18755820461","product_id":100039001,"comment_content":"spring 是如何应用开闭原则的，可以参考本文https:&#47;&#47;blog.csdn.net&#47;wenxueliu&#47;article&#47;details&#47;103467359","like_count":4},{"had_liked":false,"id":159937,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1575849157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18755718341","product_id":100039001,"comment_content":"扩展指的是“修改”或替换一个系统的功能，修改指的是对系统整体结构的篡改。系统的整体架构是不应该有大变动的，它相当于系统的本质，是相对稳定的部分。如果乱动的话，系统会变得连妈都不认识。<br><br>开闭原则不仅用于软件开发，拿计算机硬件设计为例。计算机的本质在于计算，这是计算机稳定的部分，是不应该乱动的。对应与计算机中的硬件就是CPU，CPU的指令集可以说相当稳定，几十年来几乎只是从16位变成32位，64位。（这里是不是也体现了开闭？当然这不是重点）。而io的部分是异变的，磁盘，显示器，鼠标，打印机，不一而足。稳定的是什么，是输入输出（相当于没说，本来就是io嘛）。对于计算机来说，它不管你使用什么io设备。在我CPU看来，就是在执行一条io指令（指令本身是稳定的），具体io逻辑的实现交给各种设备控制器。妥妥的开闭原则。","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494932,"discussion_content":"那只是代码示例而已。你看到我代码中的”...“了吗，这部分逻辑有可能会改变handled的值的，比如我这个handler处理完了业务逻辑，不需要继续往后继续传递了，就可以主动设置handled=true","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594785523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183405,"user_name":"Remember九离","can_delete":false,"product_type":"c1","uid":1237327,"ip_address":"","ucode":"97EE6E6344689F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","comment_is_top":false,"comment_ctime":1583034513,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14467936401","product_id":100039001,"comment_content":"PHPer 的朋友 我根据上面需求实现了一遍,感兴趣的可以看下: https:&#47;&#47;github.com&#47;wuqinqiang&#47;php-design-patterns&#47;tree&#47;master&#47;src&#47;object&#47;ocp","like_count":3,"discussions":[{"author":{"id":2651986,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/86oSia4b8CE4FuJ0cYrK0icQsmnicqs9GKlZViaX36spYeibiaDibgbeSiaicyK0plItvvwpaXbunwcprBZicT6escbkqowQ/132","nickname":"Geek_d304c0","note":"","ucode":"E094F658AA407C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411902,"discussion_content":"学习了 兄弟\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636029610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161223,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1576150751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14461052639","product_id":100039001,"comment_content":"结合徐式伟老师的课效果更好<br>第一，模块的业务要稳定。模块的业务遵循 “只读” 设计，如果需要变化不如把它归档，放弃掉。这种模块业务只读的思想，是架构治理的基础哲学。<br>第二，模块的业务变化点，简单一点的，通过回调函数或者接口开放出去，交给其他的业务模块。复杂一点的，通过引入插件机制把系统分解为 “最小化的核心系统 + 多个彼此正交的周边系统”。事实上回调函数或者接口本质上就是一种事件监听机制，所以它是插件机制的特例。<br>文章链接：https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;175236","like_count":3},{"had_liked":false,"id":232043,"user_name":"了@事@牵","can_delete":false,"product_type":"c1","uid":1036582,"ip_address":"","ucode":"A3721378E1FC2C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/26/f455adcb.jpg","comment_is_top":false,"comment_ctime":1593840653,"is_pvip":true,"replies":[{"id":"85669","content":"是的，我改下，多谢指出","user_name":"作者回复","comment_id":232043,"uid":"1190123","ip_address":"","utype":1,"ctime":1593909715,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10183775245","product_id":100039001,"comment_content":"争哥，<br>public class MessageFormatter implements MessageFormatter {&#47;&#47;...}<br>这段代码是不是有问题？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500488,"discussion_content":"是的，我改下，多谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593909715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160055,"user_name":"辉仔lovers","can_delete":false,"product_type":"c1","uid":1210219,"ip_address":"","ucode":"3DC5B0CD0B8E71","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVhJRVwJ0eVlC7zjNfWP6PP7VmUkF1X2m6qfh7Wic3NhAOz2fSGibF6LXLcJ59zOz7nBpCcByvtFjw/132","comment_is_top":false,"comment_ctime":1575861429,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10165796021","product_id":100039001,"comment_content":"老师 您好，请教几个问题<br>AlertHandler 使用的是抽象类，而不是接口。就是为了让子类去继承构造方法吗？<br>这个扩展跟spring中handlerMapping的写法一样，类似于策略模式吧？<br>单例模式的时候 使用静态代码块来初始化添加handler 随着类加载一次是不是就不用搞成单例的了？<br> static{<br>        alertRule = new AlertRule(&#47;*.省略参数.*&#47;); &#47;&#47;省略一些初始化代码<br>        notification = new Notification(&#47;*.省略参数.*&#47;); &#47;&#47;省略一些初始化代码<br>         alert = new Alert(alertRule,notification);<br>         alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));<br>         alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));<br>    }<br><br>我们是不是可以把实现类（不同的handler）放到配置文件中。使用jdk的spi扩展机制。更加灵活一些？","like_count":2,"discussions":[{"author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88924,"discussion_content":"SPI机制用在这里不合适吧，SPI本身是因为类加载器的问题，作出的一个妥协。而且你这是自己的业务系统，不是拿来给别人用的基础库，这么做感觉有点多此一举的意思了，更加复杂化了代码可读性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576740685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/8c/23eef8d7.jpg","nickname":"feifei","note":"","ucode":"BFA3BE8D8773A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86961,"discussion_content":"Java1.8的接口不是可以添加变量吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576634294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698258,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","nickname":"阿顺","note":"","ucode":"36F2AD6F980B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85781,"discussion_content":"AlertHandler使用的是抽象类还有个原因是要提取子类通用的变量作为成员变量。单例模式那块这样写我觉得也能实现，但是只是每次使用都要重新实例化一次ApplicationContext类会有额外的空间和时间消耗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576574967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159954,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1575851177,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"10165785769","product_id":100039001,"comment_content":"对于课后题，想到2点:<br>1，减少出错概率，修改出错的概率比扩展要大<br>2，边界的问题，比如用户边界，尽量减少用户侧代码的改动，比如文中alert的事例，check函数本身的修改意味着所有使用的地方都要修改，而使用了开闭原则的代码对于老用户是无须修改的，降低了用户修改的成本。","like_count":2},{"had_liked":false,"id":159930,"user_name":"aya","can_delete":false,"product_type":"c1","uid":1325690,"ip_address":"","ucode":"F50E350DCF72D6","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/7a/a68f0ff8.jpg","comment_is_top":false,"comment_ctime":1575847684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10165782276","product_id":100039001,"comment_content":"【我们都需要在扩展性和可读性之间做权衡】说得太好了，优秀开发人员分得清原则和真理，面对随时的变化做权衡的能力才是最重要的","like_count":2},{"had_liked":false,"id":297109,"user_name":"August","can_delete":false,"product_type":"c1","uid":1365190,"ip_address":"","ucode":"DBB2FE26B13E86","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLl4PvnNftXS8d5qEdyTEYy1bXMyAAeSicqnP9PRdTz6nXc0fecDvyf3r2ibrh5bJ55uEOu6NaPY7gA/132","comment_is_top":false,"comment_ctime":1623314245,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5918281541","product_id":100039001,"comment_content":"第二遍看专栏了。<br><br>我们先重构一下之前的 Alert 代码，让它的扩展性更好一些。重构的内容主要包含两部分：第一部分是将 check() 函数的多个入参封装成 ApiStatInfo 类；第二部分是引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中。<br><br>这里进行了重构，重构的这种模式是属于23种设计模式中的哪种啊。没看出来<br>","like_count":1,"discussions":[{"author":{"id":1243753,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/69/352fb079.jpg","nickname":"乌木玉","note":"","ucode":"9B5220D073538C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555363,"discussion_content":"有点类似没有传递关系的职责链模式，不过这里没有后继的说法，执行顺序按注册顺序，符合本身条件就执行，不符合就跳下一个；\n又有点像观察者模式，对各个handler观察者进行逐个通知，通知者不需要知道通知谁，谁又会干啥。\n不过我觉得在23种设计模式中，具体的类图和解决方案是招式，而设计原则和思想是心法，心法领会了，招式也就贯通了，就是所谓的-----无招胜有招。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646882376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206217,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/c9/8454f009.jpg","nickname":"赵二","note":"","ucode":"168B503C5F3D59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548761,"discussion_content":"策略模式？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643358496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277186,"user_name":"somenzz","can_delete":false,"product_type":"c1","uid":1187197,"ip_address":"","ucode":"EA59A170DF8910","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","comment_is_top":false,"comment_ctime":1612312792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907280088","product_id":100039001,"comment_content":"Django 很多类的设计都是对扩展开放，对修改关闭。如果不学习设计模式，只是惊叹 Django 牛逼，不知道它的设计原则。","like_count":1},{"had_liked":false,"id":266257,"user_name":"天下行走","can_delete":false,"product_type":"c1","uid":1462449,"ip_address":"","ucode":"73A4CD8BB91235","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLfrbMvhKQYhxP6ziaHaj4KUNRzst8u7BZsWUsazK8oTLXcNH6sDGITl6icy3IiaGFe9Iiae12LuTrF1g/132","comment_is_top":false,"comment_ctime":1607261783,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5902229079","product_id":100039001,"comment_content":"我们组的一位老员工就是一个模块就是像上面改良后的Alert做的设计，后边来的我们真的看的那叫一个痛苦啊，找一个逻辑每次都要一层层回溯，一个个类的理解，绝大多函数不超过10行代码，还包括trycatch，真的遭罪。所以这种抽象个人理解是不是可以说如果没有最后自信组织好层次关系，别一上来就堆这一堆类，给后人挖坑倒不至于，让后人加班是真的。","like_count":1},{"had_liked":false,"id":264317,"user_name":"　1234567890","can_delete":false,"product_type":"c1","uid":2311910,"ip_address":"","ucode":"623CD7E3B26769","user_header":"https://static001.geekbang.org/account/avatar/00/23/46/e6/f17cfee2.jpg","comment_is_top":false,"comment_ctime":1606437145,"is_pvip":false,"replies":[{"id":"96075","content":"这个要根据实际情况来定","user_name":"作者回复","comment_id":264317,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700619,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5901404441","product_id":100039001,"comment_content":"老师请教你个问题，什么是粗粒度代码什么是细粒度代码？","like_count":1,"discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259823,"discussion_content":"stream主要还是终止指令和过程指令，为了lazy吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588822155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264111,"user_name":"Kingram","can_delete":false,"product_type":"c1","uid":2247700,"ip_address":"","ucode":"212E403E81F2FC","user_header":"https://static001.geekbang.org/account/avatar/00/22/4c/14/8fa39544.jpg","comment_is_top":false,"comment_ctime":1606354144,"is_pvip":false,"replies":[{"id":"96081","content":"嗯呢 ������","user_name":"作者回复","comment_id":264111,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700663,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"5901321440","product_id":100039001,"comment_content":"为什么要遵循开闭原则？<br>1、修改原有复杂的业务代码本来就存在一定的风险，同时耗费精力，可能影响到别的你不知道的地方，导致程序运行故障。<br>2、修改代码同时单元测试也要跟着修改，浪费时间精力。<br>3、可扩展性差的代码同时封装性也会差，违背面向对象设计原则。<br>补充：但是注意不要过度设计呦","like_count":1},{"had_liked":false,"id":263091,"user_name":"fenciso","can_delete":false,"product_type":"c1","uid":2298546,"ip_address":"","ucode":"6546EA008BEEE8","user_header":"https://static001.geekbang.org/account/avatar/00/23/12/b2/c89b16e9.jpg","comment_is_top":false,"comment_ctime":1605978235,"is_pvip":true,"replies":[{"id":"96110","content":"对的","user_name":"作者回复","comment_id":263091,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700852,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5900945531","product_id":100039001,"comment_content":"对修改关闭，是为了增加新功能，但不影响已有的功能，增加不必要的成本。对拓展开发就是为了应对不断变化的功能需求","like_count":1,"discussions":[{"author":{"id":1018370,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","nickname":"Frank","note":"","ucode":"7A488CC6FE15E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214162,"discussion_content":"文中说的“应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性“也可以算是一种看法吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585148685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262724,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":1038811,"ip_address":"","ucode":"BFAF83E23199DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d9/db/66d5b3f4.jpg","comment_is_top":false,"comment_ctime":1605833215,"is_pvip":false,"replies":[{"id":"96122","content":"嗯嗯������","user_name":"作者回复","comment_id":262724,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700932,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5900800511","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”?<br>写代码一方面是为了满足功能需求，另一方面是为了让「他人」读懂，而不是自嗨。设计模式不是为了展现自己的能力，而是为了应对变化，很多软件需要做成插件、或者可插拔架构，都是为了方便其他人拓展。<br>「对扩展开放」是为了适应变化，「对修改关闭」是把代码封装好，减少不必要的错误改动。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509942,"discussion_content":"嗯嗯������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250529,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1601117840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5896085136","product_id":100039001,"comment_content":"打个比方，从古至今，管理一个团队，组织，企业，社会，国家，世界都需要合适的规则，才能够让系统内部的角色往效率更高的方向发展，收益更大。<br>对代码也是，如果代码未来发展想要前途无量，也需要规则去指导，而对扩展开放，对修改关闭就是一个战略性规则。","like_count":1},{"had_liked":false,"id":247994,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1599971318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894938614","product_id":100039001,"comment_content":"对扩展开放，保证了程序的灵活度，对修改关闭，保证程序不影响现有代码运行","like_count":1},{"had_liked":false,"id":247166,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1599623148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894590444","product_id":100039001,"comment_content":"对修改关闭：代码主要是为了实现业务，不让修改是因为直接修改的话可能会影响业务系统的正常运行。对扩展开放：系统预留扩展点，这些扩展点的改动通常不是直接实现业务的需求，而是辅助实现业务的代码，使得新扩展的功能与之前功能保持一种隔离，同时又能灵活切换。","like_count":1},{"had_liked":false,"id":221388,"user_name":"乖，摸摸头","can_delete":false,"product_type":"c1","uid":1611745,"ip_address":"","ucode":"BD92741A11D3CD","user_header":"https://static001.geekbang.org/account/avatar/00/18/97/e1/0f4d90ff.jpg","comment_is_top":false,"comment_ctime":1590487651,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5885454947","product_id":100039001,"comment_content":"争哥，我看你是把提示规则写在了  alertRule 里面，每个 Handler  对应alertRule 里面的一个方法，那如果我要是有几百个 Handler ，alertRule 里面就得有几百个 方法， 把 alertRule 提示规则 写到 Handler里面会不会好些， 这样违背了 单一职责吗？","like_count":1},{"had_liked":false,"id":193847,"user_name":"陈包佳","can_delete":false,"product_type":"c1","uid":1576712,"ip_address":"","ucode":"9DAAC87C75D91F","user_header":"https://static001.geekbang.org/account/avatar/00/18/0f/08/7abf466e.jpg","comment_is_top":false,"comment_ctime":1584973629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879940925","product_id":100039001,"comment_content":"开闭原则是代码开发中的最高指导原则，目的是为了提升代码的可扩展性，如何实现？需要有较强的扩展思维，抽象思维和封装思维，针对接口而非实现编程，依赖注入，多态等提升代码的扩展性。修改和扩展也是针对不同粒度上的定义区分，尽量在粗粒度上修改，细粒度扩展，减少改动面，和影响面。","like_count":1},{"had_liked":false,"id":168737,"user_name":"LYy","can_delete":false,"product_type":"c1","uid":1102062,"ip_address":"","ucode":"8D5C39B9531E71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ee/f5c5e191.jpg","comment_is_top":false,"comment_ctime":1578148388,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5873115684","product_id":100039001,"comment_content":"为什么要有“对扩展开放，对修改关闭”？<br>本质上讲，因为扩展的成本低于修改。<br>先看修改，一方面修改前需要对现有逻辑有比较准确而整体的理解(学习成本)，有引入bug的风险(额外运维成本)，另一方面也需要对配套的测试用例进行修改(额外开发&#47;维护成本)；<br>对照看扩展，只需要掌握扩展单元写法和理解修改点即可，引入bug的风险低(核心逻辑复杂度被前期封装处理掉了)，同时已有的测试用例大概率不会被破坏。<br>引申一下，从本质上看，程序解决的是真实世界问题的自动化问题。问题被自动化的解决，代码便实现了&quot;业务&quot;上的正确，但仅考虑&quot;业务&quot;是不够的，绝大多数情况下我们还有“效率”和“成本”两方面的要求。从代码层面上讲，算法与数据结构能够解决程序运行的“效率”和“成本”问题，而迭代过程中开发和维护的“效率”和“成本”问题，则需要靠设计和持续重构来解决。<br>不得不吹下王争老师在极客时间上的两门课，高质量的覆盖了代码层面“业务”以外的所有问题。","like_count":1},{"had_liked":false,"id":166875,"user_name":"薯片","can_delete":false,"product_type":"c1","uid":1072044,"ip_address":"","ucode":"FE757E1248EFF5","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/ac/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1577620808,"is_pvip":false,"replies":[{"id":"64822","content":"没看懂你说的 为什么handler类会爆炸呢","user_name":"作者回复","comment_id":166875,"uid":"1190123","ip_address":"","utype":1,"ctime":1577666001,"user_name_real":"王争"}],"discussion_count":13,"race_medal":0,"score":"5872588104","product_id":100039001,"comment_content":"if分支很多，用handler导致类爆炸怎么处理？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479662,"discussion_content":"没看懂你说的 为什么handler类会爆炸呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577666001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393694,"discussion_content":"之前是一个类中的一个接口，那么重构以后，一旦 if 分支多了，就可以将这些类，都放到一个包当中，将实现类放到 impl 子包中，对外只提供一个接口，具体的实现以及分发策略还是由底层去控制，对调用者来说是透明的。 \n\n类爆炸也不会影响代码的可读性和可维护性。\n\n而且我个人是比较喜欢用最简单的 if else 来分发策略的，不喜欢用那种高大上的方法，比如反射等等（特殊场景除外），分发的代码让人看得懂就行，不会再系统内部到处跑就行（高内聚）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631547917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2042568,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","nickname":"米豆丸","note":"","ucode":"CE99FE3A1EBCAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384874,"discussion_content":"这个我有体会，刚开始觉得类太多了，可以放在一个包下，只要日志打印得当，修改定位问题丝滑，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626778303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2358638,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fd/6e/1913dbb6.jpg","nickname":"Amber","note":"","ucode":"650FE5C46CCD1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334794,"discussion_content":"有类之间组合才会爆炸，参考桥模式和和装饰模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607993863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2275431,"avatar":"","nickname":"会飞的小飞鱼","note":"","ucode":"B1B7C191BFB078","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319307,"discussion_content":"我选择用枚举","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603979995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1608383,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","nickname":"X_L～","note":"","ucode":"6BD8C24750F86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302852,"discussion_content":"做好取舍,if加入只是简单的逻辑操作没有必要使用handler去进行重构,","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599047376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299036,"discussion_content":"多就多吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597541829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762110,"avatar":"","nickname":"yangcnb","note":"","ucode":"063DC9D9670D4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295916,"discussion_content":"if只是一个举例，handler我理解的主要作用是分离逻辑实现。就像netty的handler的处理器一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596381348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092169,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","nickname":"落尘kira","note":"","ucode":"D203B519E43F85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243600,"discussion_content":"如果觉得你认同spring的解决方式是优雅的，那么就没毛病","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587552020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125184,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2b/40/89be9c69.jpg","nickname":"登风","note":"","ucode":"6C440930B6B5B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124684,"discussion_content":"如果handle太多是不是可以分组","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578447574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119334,"discussion_content":"在31个if加进来的时候你敢修改这段代码吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578227065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1072044,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/ac/abb7bfe3.jpg","nickname":"薯片","note":"","ucode":"FE757E1248EFF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109154,"discussion_content":"每个if分支都抽成一个handler去处理，譬如我有30个if判断，那不就是30个handler了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577670769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1072044,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/ac/abb7bfe3.jpg","nickname":"薯片","note":"","ucode":"FE757E1248EFF5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115462,"discussion_content":"看30个if条件判断和看30个handler，我选择看30个handler","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1578015033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":109154,"ip_address":""},"score":115462,"extra":""}]}]},{"had_liked":false,"id":160197,"user_name":"MindController","can_delete":false,"product_type":"c1","uid":1159113,"ip_address":"","ucode":"3B9CECCD12CF6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/c9/d9c72c60.jpg","comment_is_top":false,"comment_ctime":1575890114,"is_pvip":false,"replies":[{"id":"61119","content":"你可以对比理解一下“基于接口而非实现编程”思想，封装可变的实现，暴露不变的接口。","user_name":"作者回复","comment_id":160197,"uid":"1190123","ip_address":"","utype":1,"ctime":1575895543,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5870857410","product_id":100039001,"comment_content":"请问争哥“将可变部分封装起来，隔离变化”这句话是什么意思？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477290,"discussion_content":"你可以对比理解一下“基于接口而非实现编程”思想，封装可变的实现，暴露不变的接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575895543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160026,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1181647,"ip_address":"","ucode":"46A2F679C094E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","comment_is_top":false,"comment_ctime":1575858904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870826200","product_id":100039001,"comment_content":"学到了，谢谢老师；","like_count":1},{"had_liked":false,"id":160001,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1575856137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870823433","product_id":100039001,"comment_content":"个人分析的原因<br>1.不这么做的话将来某个方法会越积越多，代码行数越来越长，等回过头来修改的时候自己可能都要读上十分钟才能找到下手的机会。<br>2.确实有好处，每次只修改修改具体实现，而对外是无感知的，调用方并不关心实现细节。<br>3.需求下来后，分析出某块东西可能会频繁更改后，且采取了这种对修改关闭，对扩展开放的思想来编码后，那以后需求变动的时候才知道什么叫真香。","like_count":1},{"had_liked":false,"id":159953,"user_name":"tingye","can_delete":false,"product_type":"c1","uid":1391463,"ip_address":"","ucode":"54F7A44066DF5D","user_header":"https://static001.geekbang.org/account/avatar/00/15/3b/67/c188d3bc.jpg","comment_is_top":false,"comment_ctime":1575851171,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5870818467","product_id":100039001,"comment_content":"例子中的AlertRule类也需要修改，添加MaxTimeout定义。可以考虑把规则按统一的格式写入数据库，统一解析，这样扩展规则只要添加规则数据就行了，不用改代码","like_count":1,"discussions":[{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76761,"discussion_content":" 那要失去了内聚，配置文件或许是更好的选择","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575852851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1562814,"avatar":"https://static001.geekbang.org/account/avatar/00/17/d8/be/49d49db2.jpg","nickname":"一路奔跑","note":"","ucode":"F1B708E8AE1793","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76763,"discussion_content":"配置文件和数据库有什么区别呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575853098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":76761,"ip_address":""},"score":76763,"extra":""}]},{"author":{"id":1022247,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","nickname":"阿卡牛","note":"","ucode":"0BC43A904C3199","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76783,"discussion_content":"不要过度设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575854037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159943,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1575849758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870817054","product_id":100039001,"comment_content":"打卡✔<br>","like_count":1},{"had_liked":false,"id":358358,"user_name":"Y","can_delete":false,"product_type":"c1","uid":1179432,"ip_address":"广东","ucode":"952AA9B2CD91CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/28/040f6f01.jpg","comment_is_top":false,"comment_ctime":1664245709,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1664245709","product_id":100039001,"comment_content":"赞，这篇课程把“对扩展开放，对修改关闭”原则讲得透透的","like_count":0},{"had_liked":false,"id":357820,"user_name":"怀英","can_delete":false,"product_type":"c1","uid":1394143,"ip_address":"江苏","ucode":"E2838AF06FB300","user_header":"https://static001.geekbang.org/account/avatar/00/15/45/df/97a71dc8.jpg","comment_is_top":false,"comment_ctime":1663665244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663665244","product_id":100039001,"comment_content":"赞成@下雨天的说法。对拓展开放，对修改关闭是最大限度上平衡了修改的时间成本和修改稳定性。","like_count":0},{"had_liked":false,"id":357526,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"北京","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1663337156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663337156","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br><br>我个人理解，还是为了保证代码改动的时候，变更范围更小更可控一些","like_count":0},{"had_liked":false,"id":357133,"user_name":"Geek_3e9d7d","can_delete":false,"product_type":"c1","uid":3070253,"ip_address":"北京","ucode":"3BDEFFE68BE32F","user_header":"","comment_is_top":false,"comment_ctime":1662984282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662984282","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br>首先，对扩展开放、对修改关闭的原则实现了高内聚、低耦合；在添加新的需求或新业务逻辑时能够尽量少的修改现有代码，这样能减少添加新代码时对旧代码、旧功能的影响；<br>其次，对扩展开放、对修改关闭的原则使得代码自然模块化，提高代码的可读性和可维护性。","like_count":0},{"had_liked":false,"id":356774,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"中国香港","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662567124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662567124","product_id":100039001,"comment_content":"为什么要对外开放和对内修改关闭。 这样目的是为了让代码的改动更纯粹，尽量不去修修改已封装的代码，这样对外影响小，改动也明确。<br><br>本节主要讲了开闭原则<br>  what: 添加新功能时应该在已有的代码上进行扩展，尽量不去修改已有代码的类，方法。<br>  why: 主要是为了提升代码的扩展性，<br>  <br>how:  <br>     1.写业务代码时需要慢慢培养扩展意识，抽象意识， 封装意识<br>     2.接到新需求后，要识别出不变的部分和可以变的部分。将可以变的部分抽象出来，变成不客变的接口。通过具体实现来应对未来的改变。本例中报警，报警规则变化，就抽出了对应的hanlder。<br>    3熟悉相关业务，了解业务的短期变化，更好的进行代码设计。<br>   4. 常用来实现代码扩展的方法多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。","like_count":0},{"had_liked":false,"id":355332,"user_name":"辉","can_delete":false,"product_type":"c1","uid":1697810,"ip_address":"广东","ucode":"0D7B2C24BA8BD2","user_header":"https://static001.geekbang.org/account/avatar/00/19/e8/12/74f387c8.jpg","comment_is_top":false,"comment_ctime":1661302723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661302723","product_id":100039001,"comment_content":"我觉得能用好开闭原则是最能体现一个程序员水平的地方。首先是开，这意味着你要有足够的思考，思考怎么去设计一个拓展性强的模块，其次是闭，这意味着你要思考去做一个稳定性足够强的模块。这两者结合起来，就能判断你这个模块设计的好不好了。","like_count":0},{"had_liked":false,"id":351947,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":2649276,"ip_address":"","ucode":"CEBAD9CDCFC2A3","user_header":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","comment_is_top":false,"comment_ctime":1658305219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658305219","product_id":100039001,"comment_content":"这篇写的不错","like_count":0},{"had_liked":false,"id":348963,"user_name":"CoderArthur","can_delete":false,"product_type":"c1","uid":1625233,"ip_address":"","ucode":"5B591914F0F67C","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","comment_is_top":false,"comment_ctime":1655609867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655609867","product_id":100039001,"comment_content":"Who do Action<br>Who：主体<br>do: 执行<br>Action: 行为<br>主体和行为经常变动，但执行却比较固定，但do并不知道who和action，于是需要将who和action依赖注入到do里面。而实现该行为需要语言上的多态来支持。<br><br>其实到后来还是业务的分析，把主体、行为抽象出来，分析出哪些是变的，哪些是不变的，最后套代码来实现。","like_count":0},{"had_liked":false,"id":347658,"user_name":"Cather","can_delete":false,"product_type":"c1","uid":2163390,"ip_address":"","ucode":"E3EDAC94EFFAC8","user_header":"https://static001.geekbang.org/account/avatar/00/21/02/be/9e8acb04.jpg","comment_is_top":false,"comment_ctime":1654262540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654262540","product_id":100039001,"comment_content":"为了应对软件需求的持续变更，提前预备好扩展点，使变更发生时，修改的影响面尽量小，同时不需要对单元测试做修改，控制变更风险。","like_count":0},{"had_liked":false,"id":345241,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1652153932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652153932","product_id":100039001,"comment_content":"要实现开闭，关键是要识别出变化点，如果不能识别变化点或者变化点短期不会发生，那么就只要闭就行了。","like_count":0},{"had_liked":false,"id":338879,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1647769268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647769268","product_id":100039001,"comment_content":"1.听君一席话胜读十年书。<br>2.设计模式没有我们想的那么难，一句话总结，扩展。<br>3.23种设计模式，无非归为扩展。就好像算法，就是递归。","like_count":0},{"had_liked":false,"id":335436,"user_name":"ibrothergang","can_delete":false,"product_type":"c1","uid":1002191,"ip_address":"","ucode":"4151DA353A1DDC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/cf/5cbccd62.jpg","comment_is_top":false,"comment_ctime":1645518335,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645518335","product_id":100039001,"comment_content":"业务的场景会不断变化，唯一不变的就是「变」。没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。","like_count":0},{"had_liked":false,"id":333307,"user_name":"i-neojos","can_delete":false,"product_type":"c1","uid":1702997,"ip_address":"","ucode":"1808C25269948A","user_header":"https://static001.geekbang.org/account/avatar/00/19/fc/55/e03bb6db.jpg","comment_is_top":false,"comment_ctime":1644283306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644283306","product_id":100039001,"comment_content":"依赖注入，上次遇到这个情况，知道应该这么做，但是不知道这么做的指导思想，原来叫依赖注入啊","like_count":0},{"had_liked":false,"id":332311,"user_name":"The-Jogger","can_delete":false,"product_type":"c1","uid":1396612,"ip_address":"","ucode":"4F19CA3DFA88E3","user_header":"https://static001.geekbang.org/account/avatar/00/15/4f/84/8b3b6a55.jpg","comment_is_top":false,"comment_ctime":1643168887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643168887","product_id":100039001,"comment_content":"实战中，handler标记注解，ApplicationContext通过Spring查询handler注解构建。","like_count":0},{"had_liked":false,"id":330654,"user_name":"cheng_yc","can_delete":false,"product_type":"c1","uid":2856263,"ip_address":"","ucode":"6DE872A6AEC42E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqFjqX19XHS5npsnSrrxibLQU9b0zMb3AzmdribYdEOFrXCyh7dJRF8g8MUibWfbMM8K7fA46AZib75SQ/132","comment_is_top":false,"comment_ctime":1642084802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642084802","product_id":100039001,"comment_content":"对我理解，开闭原则，就是针对多种情况，将各自的情况内聚到各自的类单独实现。<br>我对自己的代码也会经常看看，理解下当时的设计初衷和针对现在的需求变化该如何调整。这些都是变化的，对于一些不变的业务，多几个case也无关紧要。因为它长期不变。但是在一些易变经常使用的业务代码中，case种类也会越来越多，慢慢的出现方法过长，臃肿。因此我们可以针对不同的case单独抽取，面向接口+依赖注入，这次改造是必然要经历的。除非第一次就已经设计好了。<br>但是对于以后的再有新case出现，只需要编写新的case具体实现就行。<br>好处：便于扩展，代码清晰间接<br>缺点：可能不太便于新人代码阅读<br>我的意见就是因为设计模式而去设计，还是根据实际状况决定","like_count":0},{"had_liked":false,"id":330241,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1641877522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641877522","product_id":100039001,"comment_content":"对修改关闭是为了不影响以前的功能，可能以前的代码引用过多，很容易改错","like_count":0},{"had_liked":false,"id":328687,"user_name":"邵亮","can_delete":false,"product_type":"c1","uid":1810890,"ip_address":"","ucode":"8407C3FDD11C0E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a1/ca/aae116f5.jpg","comment_is_top":false,"comment_ctime":1640842115,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640842115","product_id":100039001,"comment_content":"提高代码可维护性，防止引入新问题","like_count":0},{"had_liked":false,"id":328369,"user_name":"Geek_East","can_delete":false,"product_type":"c1","uid":1589947,"ip_address":"","ucode":"A1A7CBF9B8FB2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","comment_is_top":false,"comment_ctime":1640693594,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640693594","product_id":100039001,"comment_content":"将代码中的不稳定部分提取为模块，类或者方法，并且将这部分代码的调用过程和实现过程分离，通过抽象桥梁与原有代码保持联系。这样不稳定部分的变动并不会引起原有代码的变动。","like_count":0},{"had_liked":false,"id":327332,"user_name":"July 💫","can_delete":false,"product_type":"c1","uid":1761335,"ip_address":"","ucode":"0DC25F063E9E90","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e0/37/40b6711b.jpg","comment_is_top":false,"comment_ctime":1640069661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640069661","product_id":100039001,"comment_content":"PHP Demo 示例，欢迎issues，如果对您有帮助，用你发财的小手(😆)给我来个star✨<br><br>https:&#47;&#47;github.com&#47;iamzu&#47;Geek-CodeDesign&#47;tree&#47;main&#47;16&#47;PHP","like_count":0},{"had_liked":false,"id":322641,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637538286,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637538286","product_id":100039001,"comment_content":"里氏替换重传统，父业子承不走形。<br>偶有业务需变更，子类加个小字段。","like_count":0},{"had_liked":false,"id":322587,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637489324,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637489324","product_id":100039001,"comment_content":"对扩展开放，修改封闭的核心点就是当需求发生变化，或者需求新增时，降低对原有业务或者功能的影响。避免一个函数改一下，所有的地方都要改一遍的弊病。","like_count":0},{"had_liked":false,"id":316755,"user_name":"Bacchus","can_delete":false,"product_type":"c1","uid":1830814,"ip_address":"","ucode":"A8AA7E4909B201","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ef/9e/fd29bdd8.jpg","comment_is_top":false,"comment_ctime":1634541601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634541601","product_id":100039001,"comment_content":"对修改关闭 是因为修改原有代码有一定的风险，可能会产生问题。<br>对扩展开发一是为了少修改，另外是为了提高代码的可维护性，方便后来者修改。","like_count":0},{"had_liked":false,"id":316272,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1634254596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634254596","product_id":100039001,"comment_content":"使用开闭原则最主要是提高代码的扩展性，方便扩展代码而不会或很少修改已有代码。","like_count":0},{"had_liked":false,"id":308401,"user_name":"小周","can_delete":false,"product_type":"c1","uid":2453498,"ip_address":"","ucode":"7ED7BC27A46C4C","user_header":"https://static001.geekbang.org/account/avatar/00/25/6f/fa/615a0df3.jpg","comment_is_top":false,"comment_ctime":1629601766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629601766","product_id":100039001,"comment_content":"为了以最小的代码改动为代价，新增新的功能。不破坏原来的代码结构，降低修改风险","like_count":0},{"had_liked":false,"id":305208,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1627877148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627877148","product_id":100039001,"comment_content":"为什么要对扩展开放，对修改关闭？<br>我觉得原因有几个，一个是方便快速的完成新功能，如何只是单纯的修改，一方面是代码逻辑会越来越复杂，可读性扩展性会变差，另外一方面是可能会影响其他已经写好的程序，这样开发的成本就更大了。<br>不过这些都是相对的，如果为了这个原则付出的代价很高，那可能不使用这种原则是更好的选择","like_count":0},{"had_liked":false,"id":304895,"user_name":"不一样的烟火","can_delete":false,"product_type":"c1","uid":1473251,"ip_address":"","ucode":"6E305F0EE90E8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","comment_is_top":false,"comment_ctime":1627689472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627689472","product_id":100039001,"comment_content":"设计模式都是为了应对可能发生的需求变化，或者工作的交接，更快地修改，更好的的可读性，节省时间，从而产生价值","like_count":0},{"had_liked":false,"id":302347,"user_name":"Geek_325846","can_delete":false,"product_type":"c1","uid":2696006,"ip_address":"","ucode":"30BC2FB97C5B42","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DR4kWgpzu27N1Hu6RFVEDxvk1MRBxaB9btc1U82Fo35peVuQDOfUoqia1RU6reH3sXWlxAtvicABiaotibllSnwgmw/132","comment_is_top":false,"comment_ctime":1626173385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626173385","product_id":100039001,"comment_content":"原先的check方法 形参直接封装成对象，然后在check方法里添加判断逻辑不就可以了吗？","like_count":0},{"had_liked":false,"id":301916,"user_name":"今夕是何年","can_delete":false,"product_type":"c1","uid":1111847,"ip_address":"","ucode":"2825454A7A1588","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/7SOblVZ7dNJ88wkeYR0HklxdR9VuiaQ0GMscAnrlic6EjvRZS52m4n1VPypwZFsmabbJ4STZRbHFfVZE24Jjqr1w/132","comment_is_top":false,"comment_ctime":1625974197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625974197","product_id":100039001,"comment_content":"这个貌似是观察者模式吧","like_count":0},{"had_liked":false,"id":300540,"user_name":"笑天","can_delete":false,"product_type":"c1","uid":1561173,"ip_address":"","ucode":"B71B671B302D3B","user_header":"","comment_is_top":false,"comment_ctime":1625211893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625211893","product_id":100039001,"comment_content":"老师您好，我看了您这课以后，和我的同事们都讨论了一下。讨论了之后我忽然发现，开闭原则不就是抽象和多态的利用吗。我就有了疑惑，不知道这两者到底是什么关系。各位同学，还有老师，如果看到，希望帮我解答疑惑","like_count":0},{"had_liked":false,"id":299823,"user_name":"randomx","can_delete":false,"product_type":"c1","uid":1238993,"ip_address":"","ucode":"FC93786244932F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/d1/9d1c283b.jpg","comment_is_top":false,"comment_ctime":1624872412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624872412","product_id":100039001,"comment_content":"文中AlertHandler是abtract修饰的类，怎么有有参构造？","like_count":0},{"had_liked":false,"id":298682,"user_name":"槐安","can_delete":false,"product_type":"c1","uid":2631749,"ip_address":"","ucode":"7A7A925B57955C","user_header":"https://static001.geekbang.org/account/avatar/00/28/28/45/8dc28ef6.jpg","comment_is_top":false,"comment_ctime":1624262001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624262001","product_id":100039001,"comment_content":"对扩展开放是为了应对业务需求的增加，对修改关闭，是保证代码的稳定性","like_count":0},{"had_liked":false,"id":297195,"user_name":"Geek_cf3aed","can_delete":false,"product_type":"c1","uid":2417045,"ip_address":"","ucode":"BE1AF6D6F14541","user_header":"","comment_is_top":false,"comment_ctime":1623373777,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623373777","product_id":100039001,"comment_content":"这里的复制代码小按钮  不好用，需要粘贴到笔记本更方便查看代码","like_count":0},{"had_liked":false,"id":296910,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1623222461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623222461","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br><br>目的就是为了提高代码的扩展性，更易维护，体现在如下方面：<br>1.对扩展开放，保证新功能添加是基于原来的代码架构进行扩展，保证代码结构的一致性<br>2.新功能扩展可以做到，对细节进行修改和填充，而始终保持代码架构的前后统一","like_count":0},{"had_liked":false,"id":296287,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1622883621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622883621","product_id":100039001,"comment_content":"让我想起来之前做过的一个项目，一个公共类的方法中，if和else有几十个，因为每次添加一个新的功能都在那个方法中添加一个if。现在回想一下，按照“开闭原则”，确实可以将代码进行重构一下，","like_count":0},{"had_liked":false,"id":294758,"user_name":"姚钫","can_delete":false,"product_type":"c1","uid":1498146,"ip_address":"","ucode":"ECB8B0627A4F9B","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/22/41a390ae.jpg","comment_is_top":false,"comment_ctime":1622082930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622082930","product_id":100039001,"comment_content":"只能停留在能看懂，还是不知道如何去写","like_count":0},{"had_liked":false,"id":292502,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1620864110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620864110","product_id":100039001,"comment_content":"对拓展开放是应对未来变化的需求，对修改关闭是为了保证已有代码的稳定性。最终的是以最小的代价，保证系统的稳定性","like_count":0},{"had_liked":false,"id":288690,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1618626296,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1618626296","product_id":100039001,"comment_content":"对扩展开放就是对需求开放，对修改关闭就是保证已有代码的稳定。核心是保持系统稳定。","like_count":0},{"had_liked":false,"id":288399,"user_name":"Spiral","can_delete":false,"product_type":"c1","uid":2023006,"ip_address":"","ucode":"1BB5AF06CEF397","user_header":"https://static001.geekbang.org/account/avatar/00/1e/de/5e/170a3546.jpg","comment_is_top":false,"comment_ctime":1618455632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618455632","product_id":100039001,"comment_content":"原则不是唯一的，所以在代码开发的时候，权衡很重要。不要教条，要根据实际情况出发，选择合适的程度遵守原则","like_count":0},{"had_liked":false,"id":285265,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1616717318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616717318","product_id":100039001,"comment_content":"开闭原则，就是写代码是，注意抽象，整理清楚代码的抽象结构，让代码能够描述。最大的好处是，需求变更时，代码可以快速扩展，并减少代码因改动而出错的可能。","like_count":0},{"had_liked":false,"id":285116,"user_name":"Geek_86eac6","can_delete":false,"product_type":"c1","uid":1787022,"ip_address":"","ucode":"8C02E398CC6A35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4CBQHuLDWOdicOl1elTdSicqMyY1s5JDWXiaHsSk0VSWaVe0U6CTo701ZGz9h6MvibsAGKnvVq7xxFw/132","comment_is_top":false,"comment_ctime":1616632693,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616632693","product_id":100039001,"comment_content":"我想到了业界有个面相接口编程，不知道跟开闭原则是不是有关联","like_count":0,"discussions":[{"author":{"id":2233517,"avatar":"https://static001.geekbang.org/account/avatar/00/22/14/ad/b5cd2a0c.jpg","nickname":"钮祜禄皮皮虾","note":"","ucode":"957DC6647AA7EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368959,"discussion_content":"依赖倒置原则感觉也和这原则有关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618888967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284775,"user_name":"御风","can_delete":false,"product_type":"c1","uid":1812807,"ip_address":"","ucode":"51C8212BE06364","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg","comment_is_top":false,"comment_ctime":1616467472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616467472","product_id":100039001,"comment_content":"1.拓展和修改是相对的，粗力度上是修改，细粒度上可能是拓展<br>2.拓展为了应对变换，修改是为了保证已有代码的稳定性。已有代码包括函数、单测。<br>以前有人问我重构、修改代码后，维护单测需要很多工作量，所以，好的设计能够对修改关闭，从而保证已有代码的单测不受影响<br>3.最常用来实现开闭原则的方法有：多态、依赖注入、基于接口而非实现编程。<br>4.设计时，需要识别出代码中变化和不变的部分，将变化封装隔离，抽象出不变的接口，当实现变化时，只需要基于接口，提供新的实现给上游代码，上游代码几乎不用改动。","like_count":0},{"had_liked":false,"id":283543,"user_name":"Graham","can_delete":false,"product_type":"c1","uid":1994570,"ip_address":"","ucode":"C2545DE16EC3DD","user_header":"","comment_is_top":false,"comment_ctime":1615813022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615813022","product_id":100039001,"comment_content":"chain设计模式，就是一种对ocp的应用，拓展的时候，只需添加&#47;删除对应的chain，在其初始化方法的时候","like_count":0},{"had_liked":false,"id":280228,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1614137943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614137943","product_id":100039001,"comment_content":"HandlerChain，职责链模式。开闭原则本质上是“对扩展打开，对修改关闭”，对代码扩展和修改可能从不同的宽度看又是不一样的，那我们在开发的时候就可以从自身的业务来看，如果自身业务近期有对应的扩展就打开，没有就不打开，","like_count":0},{"had_liked":false,"id":280136,"user_name":"Chloe","can_delete":false,"product_type":"c1","uid":1004953,"ip_address":"","ucode":"C4848ED5B35752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","comment_is_top":false,"comment_ctime":1614090355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614090355","product_id":100039001,"comment_content":"我的感受是，设计模式很好的解决了团队合作（高内聚，低耦合）和快速添加修改软件功能（易扩展）的要求。","like_count":0},{"had_liked":false,"id":279639,"user_name":"大风","can_delete":false,"product_type":"c1","uid":1606600,"ip_address":"","ucode":"95C2B6B98247FB","user_header":"https://static001.geekbang.org/account/avatar/00/18/83/c8/c08fc40f.jpg","comment_is_top":false,"comment_ctime":1613884778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613884778","product_id":100039001,"comment_content":"感谢老师的教学，老师果然传达到了设计模式之美。相见恨晚。网络上一大难似懂非懂似是而非的讲解太误导人了。可怜我等无意中就被误导这么多年","like_count":0},{"had_liked":false,"id":277207,"user_name":"金色麦浪","can_delete":false,"product_type":"c1","uid":2397738,"ip_address":"","ucode":"78B65DE7B4B9D3","user_header":"https://static001.geekbang.org/account/avatar/00/24/96/2a/851a2818.jpg","comment_is_top":false,"comment_ctime":1612316475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612316475","product_id":100039001,"comment_content":"ApiStatInfo需要分开写不同需求的构造函数","like_count":0},{"had_liked":false,"id":276438,"user_name":"Geek_eb58fa","can_delete":false,"product_type":"c1","uid":2430525,"ip_address":"","ucode":"FDB9999650CAB5","user_header":"","comment_is_top":false,"comment_ctime":1611924844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611924844","product_id":100039001,"comment_content":"对报警这个案例，进行了一点点修改，更符合真实生产需求<br>1、报警规则通过配置文件动态注入，而不是写死成一个枚举类<br>2、规则增加时，只需要增加处理类和信息类， 不需要修改已经定义好的其它类<br>项目地址：https:&#47;&#47;gitee.com&#47;fengzhili123_admin&#47;design_parttern&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;wangzheng&#47;alert","like_count":0},{"had_liked":false,"id":276406,"user_name":"世杰","can_delete":false,"product_type":"c1","uid":2415102,"ip_address":"","ucode":"6BC305EF6D525B","user_header":"https://static001.geekbang.org/account/avatar/00/24/d9/fe/7b151abf.jpg","comment_is_top":false,"comment_ctime":1611911508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611911508","product_id":100039001,"comment_content":"请问报警这个案例，如果是用例子中的单例模式，那我的报警规则是不是只能通过枚举类写死了，正常生产中这种规则应该是配置在配置文件中吧，如果想通过配置文件传进来，是不是就不能用这种单例模式了。","like_count":0},{"had_liked":false,"id":275671,"user_name":"低调的魅力","can_delete":false,"product_type":"c1","uid":1823275,"ip_address":"","ucode":"AE5CA2986B5A95","user_header":"https://static001.geekbang.org/account/avatar/00/1b/d2/2b/7a93d588.jpg","comment_is_top":false,"comment_ctime":1611640674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611640674","product_id":100039001,"comment_content":"看了第一个例子，恍然大悟，原来代码还能这么写，很幸运看到争哥这篇文章","like_count":0},{"had_liked":false,"id":273775,"user_name":"飞扬","can_delete":false,"product_type":"c1","uid":1378180,"ip_address":"","ucode":"3F77352FC25DB9","user_header":"https://static001.geekbang.org/account/avatar/00/15/07/84/18d30516.jpg","comment_is_top":false,"comment_ctime":1610675677,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610675677","product_id":100039001,"comment_content":"在《A Philosophy of Software Design》一书中，作者有一个观点是“修改放大往往意味着代码的设计问题”。这里的“修改放大”就是我们通常说的牵一发而动全身，爬过屎山的同学应该都有感受。我想应用开闭原则的一个好处，或许也是最重要的好处，就是能减少“修改放大”。毕竟，如果真是不用修改的代码，那它只要能用就行了，不是么？","like_count":0},{"had_liked":false,"id":272249,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1610005258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610005258","product_id":100039001,"comment_content":"这里将整个类分为几个不同处理类：<br>1：Alert.java 负责add不同的预警类和check消费不同的预警类<br>2：AlertHandler 是一个抽象类，定义好抽象类具体的方式和参数<br>3：ApiStatInfo 负责将传入验证的参数<br>4:  TpsAlertHandler 继承了 AlertHandler ，所以要必须实现 check 抽象方法，方法该怎么去验证，逻辑自己去写。<br>5：ErrorAlertHandler 同上<br>6：既然定义不同的 AlertHandler(Tps,ApiError,Timeout)等等不同扩展，所以肯定要用呀，我们将需要验证，都addAlertHandler,<br>然后，在调用Alert类的check方法，check方法会循环循环变量进入add中的handler，然后执行check方法<br>7：applicationContext 类，就是我们自己写的代码，","like_count":0},{"had_liked":false,"id":272056,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1609920612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609920612","product_id":100039001,"comment_content":"在没有看老师教程之前，看别人代码都是大段大段的，看框架的代码太多又看不懂。老师的教程，确实很哈。","like_count":0},{"had_liked":false,"id":269156,"user_name":"snake","can_delete":false,"product_type":"c1","uid":2347137,"ip_address":"","ucode":"47BFFE4D048156","user_header":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","comment_is_top":false,"comment_ctime":1608540578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608540578","product_id":100039001,"comment_content":"有点像策略模式","like_count":0},{"had_liked":false,"id":267641,"user_name":"Geek_2495de","can_delete":false,"product_type":"c1","uid":1786809,"ip_address":"","ucode":"BCC92B259FF165","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/lHqiahnUnaWY9GOGgIamhbddJUYtopKABFmVwaD68uXgTdaA72HX3yzd6YtqPKEt1YxJuXwYXKsmzGNKXmV75LQ/132","comment_is_top":false,"comment_ctime":1607853374,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607853374","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”。 我理解出了两个问题：<br>第一个：为什么要遵循开闭原则：<br>这是一种可以提高扩展性的原则。意味着，我们将来遇到新的需求时，可以投入比较少的人力时间成本去做开发、测试、上线回归。<br>第二个：为什么开闭原则里面：是对“扩展”开放，对“修改”关闭<br>如果关闭扩展，开放修改。那一个需求B的增加，意味着从A 变成 A&#39;+B。 原来跟A都有关的地方都要考虑。如果A 原有100个逻辑，对开发和测试的要求要更大，也容易因为考虑不周，导致上线后不够稳定。<br><br>","like_count":0},{"had_liked":false,"id":264742,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1606625400,"is_pvip":false,"replies":[{"id":"96062","content":"嗯嗯","user_name":"作者回复","comment_id":264742,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700541,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1606625400","product_id":100039001,"comment_content":"回头再看第二遍，这个例子不就是责任链模式的变体+工厂模式吗 ","like_count":0,"discussions":[{"author":{"id":1167233,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","nickname":"杨逸林","note":"","ucode":"4BF3CF3E2F1AC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306062,"discussion_content":"有个东西叫RequestContextHolder,还有个东西叫ServletRequestAttributes，只要你在当前线程中，怎样都可以获得请求。你也可以自定义含 ThreadLocal 的类，在 Filter 中注入请求和响应的信息。因为 Servlet 是以线程的方式响应的，具体例子可以参考我这个 Demo。https://github.com/young1lin/evaluation/blob/master/src/main/java/cn/luckyray/evaluation/filter/InitServletHolder.java","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1600158761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1167233,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","nickname":"杨逸林","note":"","ucode":"4BF3CF3E2F1AC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1461374,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4c/7e/4771d8a4.jpg","nickname":"彭发红","note":"","ucode":"9BAC208700791E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":323812,"discussion_content":"为什么会有多个请求重叠的情况？他是ThreadLocal啊，以当前线程ID去get的值，tomcat是以线程来响应 servlet 请求的啊，并且在 DispatcherServlet 中每次用完当前请求，都会 release 掉当前请求。\n你说的情况，麻烦你以代码的形式贴出来，如何操作说一下，谢谢","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1605001214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321678,"ip_address":""},"score":323812,"extra":""},{"author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1461374,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4c/7e/4771d8a4.jpg","nickname":"彭发红","note":"","ucode":"9BAC208700791E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":324300,"discussion_content":"你这个说法显得你很业余，每一个servlet都是单独的线程，而ThreadLocal是线程隔离的","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1605088403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321678,"ip_address":""},"score":324300,"extra":""},{"author":{"id":1461374,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4c/7e/4771d8a4.jpg","nickname":"彭发红","note":"","ucode":"9BAC208700791E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345889,"discussion_content":"你开一个线程过去request试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611809019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324300,"ip_address":""},"score":345889,"extra":""}]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369185,"discussion_content":"应该是这样的吧: Filter 可以拿到原始的http请求，但是拿不到你请求的控制器和请求控制器中的方法的信息; Interceptor 可以拿到你请求的控制器和方法，也可以拿到请求方法的参数; Aop 可以拿到方法的参数，也可以拿到http请求和响应的对象","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1618969682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218320,"discussion_content":"套路虽然一样，但是魔鬼藏匿于细节之中^_^","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1585647765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1247965,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","nickname":"Geek_41d472","note":"","ucode":"DEC2B6329460CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242031,"discussion_content":"AOP一样可以拿到返回的对象!我们这用的日志统一切面类就是这样打日志的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587459891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1514305,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","nickname":"xk_","note":"","ucode":"DFE1AC38EA78A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1247965,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","nickname":"Geek_41d472","note":"","ucode":"DEC2B6329460CF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249034,"discussion_content":"只限于contrl层而已吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587907868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":242031,"ip_address":""},"score":249034,"extra":""},{"author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1247965,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","nickname":"Geek_41d472","note":"","ucode":"DEC2B6329460CF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297729,"discussion_content":"Aop 也是可以拿到http 请求的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597036524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":242031,"ip_address":""},"score":297729,"extra":""}]},{"author":{"id":2364634,"avatar":"https://static001.geekbang.org/account/avatar/00/24/14/da/37d758ae.jpg","nickname":"小民驾到","note":"","ucode":"65D9A9CD7B4287","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538969,"discussion_content":"AOP可以拿到请求对象的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639566231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1322607,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2e/6f/aba7e09f.jpg","nickname":"nobb","note":"","ucode":"D5D1BD8889D0FF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409027,"discussion_content":"最新的servlet规范支持异步了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635352045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1708328,"avatar":"","nickname":"Geek_897ea4","note":"","ucode":"864B05054D686A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371006,"discussion_content":"AOP拿不到响应对象？ 那怎么打印日志？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619607201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740322,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/22/51f690e1.jpg","nickname":"big熊","note":"","ucode":"8D382BF137EF00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349022,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612852933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333952,"discussion_content":"想问下这里的控制器指的是什么，是servlet中的FilterChain，spring中的HandlerExecutionChain吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607679037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1192651,"avatar":"https://static001.geekbang.org/account/avatar/00/12/32/cb/338b518e.jpg","nickname":"Desmond","note":"","ucode":"894EF81E40C3D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346174,"discussion_content":"控制器应该是controller","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1611884645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":333952,"ip_address":""},"score":346174,"extra":""}]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223048,"discussion_content":"总结的很骚\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586184192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264228,"user_name":"🍃","can_delete":false,"product_type":"c1","uid":1337052,"ip_address":"","ucode":"D1E4560C49139A","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/dc/fdffbc96.jpg","comment_is_top":false,"comment_ctime":1606384800,"is_pvip":false,"replies":[{"id":"96078","content":"还好吧，理解思路为主","user_name":"作者回复","comment_id":264228,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700648,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1606384800","product_id":100039001,"comment_content":"不会java的我理解起来有点吃力啊<br>","like_count":0,"discussions":[{"author":{"id":1063228,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/3c/065c042e.jpg","nickname":"hifly","note":"","ucode":"C9F4726FCD79DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309373,"discussion_content":"想要看懂框架的源码，设计模式和数据结构都要懂啊；或者说框架的源码就是设计模式和数据结构与算法应用的好例子","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601274458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6b/27/8c964e52.jpg","nickname":"不惑ing","note":"","ucode":"AF04E417D38027","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219475,"discussion_content":"Servlet Filter层过滤不到权限吧？我觉得只能过滤一下IP、爬虫之类的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585756027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1330141,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","nickname":"HomeyLiu","note":"","ucode":"EF4CCB92C369B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1207079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6b/27/8c964e52.jpg","nickname":"不惑ing","note":"","ucode":"AF04E417D38027","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539771,"discussion_content":"通过请求Request中的请求地址 就可以呀.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639837048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":219475,"ip_address":""},"score":539771,"extra":""}]}]},{"had_liked":false,"id":257564,"user_name":"间接性失忆患者","can_delete":false,"product_type":"c1","uid":2143290,"ip_address":"","ucode":"73593933070CB9","user_header":"https://static001.geekbang.org/account/avatar/00/20/b4/3a/53b27094.jpg","comment_is_top":false,"comment_ctime":1604028141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604028141","product_id":100039001,"comment_content":"对开闭原则的使用一直很纠结，感谢老师这么实用的建议和距离。有种豁然开朗的感觉，终于不会再纠结这个了。","like_count":0},{"had_liked":false,"id":256455,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1134539,"ip_address":"","ucode":"11C598D0723D08","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/cb/ede92cd5.jpg","comment_is_top":false,"comment_ctime":1603628655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603628655","product_id":100039001,"comment_content":"对扩展开放，对修改关闭，可在增加功能时尽量少的引入问题","like_count":0},{"had_liked":false,"id":255493,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1603357844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603357844","product_id":100039001,"comment_content":"对扩展开放是为了应对变化，对修改关闭是为了保证现有代码的稳定性，最终结果是为了让系统更加的有弹性~","like_count":0},{"had_liked":false,"id":247671,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1533352,"ip_address":"","ucode":"6FD3642D6455AE","user_header":"https://static001.geekbang.org/account/avatar/00/17/65/a8/6431f8b0.jpg","comment_is_top":false,"comment_ctime":1599789855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599789855","product_id":100039001,"comment_content":"基于接口而非实现编程，这个我深有体会，我们在做集群内本地缓存的同步方案的时候，就是基于接口，然后使用不同的技术框架实现了，经过压测和实践选择了比较合适我们的，我们基于zk，redis，mq，分别都实现了，可供不同场景不同系统选择，并且后期也可以快速替换，非常赞同和深有体会  基于接口而非实现编程！","like_count":0},{"had_liked":false,"id":246382,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1599302956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599302956","product_id":100039001,"comment_content":"对修改开放的话，对之前的代码的改动很可能会牵一发而动全身，除了要花更多时间做改动以外，还要花更多时间做测试，性价比低。","like_count":0},{"had_liked":false,"id":246352,"user_name":"liliumss","can_delete":false,"product_type":"c1","uid":1333094,"ip_address":"","ucode":"A52AC5042F3115","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","comment_is_top":false,"comment_ctime":1599292726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599292726","product_id":100039001,"comment_content":"如果使用spring框架，可以使用把同一类的接口自动获得防止到特定集合去，这样applictionContext也不需要修改了，很完美","like_count":0},{"had_liked":false,"id":246268,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599233783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599233783","product_id":100039001,"comment_content":"对扩展开放，是很容易面对未来不确定的需求变更， 扩展方便了 才能以更小的改动对整个新需求的匹配，也可以让上游系统少改动，甚至不改动，无感的适配新的需求。  对修改关闭，也不是说要完全杜绝修改， 对于新需求而言，不可能完全不修改任何原有代码就能实现的， 而我们需要做到的是，尽量少的对原有代码进行层层修改，不然代价会非常大的，导致最后可读性变差，可维护性更差","like_count":0},{"had_liked":false,"id":245948,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599118556,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599118556","product_id":100039001,"comment_content":"1、对修改关闭：为了兼容性。保证原有的系统行为不受影响、包括测试性。<br>2、对扩展开放：为了增加更多的功能、更大的价值","like_count":0},{"had_liked":false,"id":245860,"user_name":"Hunter_Dark","can_delete":false,"product_type":"c1","uid":1342279,"ip_address":"","ucode":"3A07CCBC250B69","user_header":"https://static001.geekbang.org/account/avatar/00/14/7b/47/96dad3ff.jpg","comment_is_top":false,"comment_ctime":1599096808,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599096808","product_id":100039001,"comment_content":"在spring框架中，这些设计怎么用？","like_count":0},{"had_liked":false,"id":245774,"user_name":"X_L～","can_delete":false,"product_type":"c1","uid":1608383,"ip_address":"","ucode":"6BD8C24750F86B","user_header":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","comment_is_top":false,"comment_ctime":1599047459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599047459","product_id":100039001,"comment_content":"感谢争哥,很清楚,写代码时的潜意识确实很重要,像内功一样","like_count":0},{"had_liked":false,"id":245609,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1599008588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599008588","product_id":100039001,"comment_content":"为什么要对扩展开放，对修改关闭。还是分情况的，如果是简单的系统，业务逻辑单一且缺少变化，那么可以不用设计出复杂的代码去满足这个设计原则。如果对于复杂系统，业务逻辑根据场景多变，且各个场景业务逻辑不同。这个时候就需要好好设计代码，在新增场景有新的业务规则时可以横向扩展，避免影响之前的老代码，一方面是回顾成本大，第二是容易导致不了解这块的人无法覆盖全导致出线上问题。","like_count":0},{"had_liked":false,"id":245114,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1598839565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598839565","product_id":100039001,"comment_content":"“对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！”<br>简直就是写出好代码的精髓！<br>代码的扩展性会跟可读性相冲突，难怪我在阅读开源代码的时候，觉得很吃力，就算勉强了解了它的功能，也不能识别它的设计模式，也很难借鉴。","like_count":0},{"had_liked":false,"id":244057,"user_name":"蛀牙","can_delete":false,"product_type":"c1","uid":1153349,"ip_address":"","ucode":"F765A67DFEADFD","user_header":"","comment_is_top":false,"comment_ctime":1598368976,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598368976","product_id":100039001,"comment_content":"学到这一课有种渐入佳境的感觉。突然理解了设计模式的美。这样先给个简单的实现，再给个运用开闭原则的实现非常贴合我的思维模式，就是在我的现有基础上实现了拔高。<br>而且这个例子确实是在工作中会遇到的实例，有助于遇到类似问题时的思维迁移。","like_count":0},{"had_liked":false,"id":243858,"user_name":"。华伟","can_delete":false,"product_type":"c1","uid":2095422,"ip_address":"","ucode":"CD2645632E70D0","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f9/3e/aef7a849.jpg","comment_is_top":false,"comment_ctime":1598314894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598314894","product_id":100039001,"comment_content":"不破坏原有代码的正常运行，不破坏原有代码的单元测试","like_count":0},{"had_liked":false,"id":242138,"user_name":"火影.海诺","can_delete":false,"product_type":"c1","uid":2091565,"ip_address":"","ucode":"34729AFEE93B6D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ea/2d/34cb8e0a.jpg","comment_is_top":false,"comment_ctime":1597622001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597622001","product_id":100039001,"comment_content":"对修改关闭是服务于分装思想的，是为了对现在代码负责，对扩展开放是为了以后代码能基于现在代码的一个功能扩展，为了未来服务","like_count":0},{"had_liked":false,"id":241956,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1597540035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597540035","product_id":100039001,"comment_content":"自己又画了一遍整个思路，第一次学设计模式，确实Handler这个类让我受益匪浅，已经理解了开闭原则，确实扩展性太强了，只是感觉 Class会增加很多，这是不是也不好呢","like_count":0},{"had_liked":false,"id":240860,"user_name":"站在岸上的鱼","can_delete":false,"product_type":"c1","uid":2093578,"ip_address":"","ucode":"96C3D7B1772541","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f2/0a/e10d198f.jpg","comment_is_top":false,"comment_ctime":1597105805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597105805","product_id":100039001,"comment_content":"如何在不改动原有代码逻辑的情况下，新增功能。","like_count":0},{"had_liked":false,"id":240034,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1596722758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596722758","product_id":100039001,"comment_content":"mybatis的数据类型转换也用到了第一个例子的方式，定义了不同handler类处理java对应的数据库类型。真正做到了可插拔、可扩展的方式，而不是像大部分代码一样用if...else...判断","like_count":0},{"had_liked":false,"id":239663,"user_name":"杨逸林","can_delete":false,"product_type":"c1","uid":1167233,"ip_address":"","ucode":"4BF3CF3E2F1AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","comment_is_top":false,"comment_ctime":1596610022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596610022","product_id":100039001,"comment_content":"第一部分的代码不就是 Spring MVC 中的，HandlerMapping 中取 Handler，它将所有标记为 @RequestMapping 的方法包装成 MethodHandler 然后在 DispatcherServlet 中调用对应的 Handler吗？<br><br>第二部分，Spring Cloud 的 DiscoveryClient 就是服务注册的接口，Spring 中有很多这种定义了的组建接口，也是 Java 的 SPI 很好的实现","like_count":0,"discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259946,"discussion_content":"是的，okhttp算比较新的实现了，蛮有意思的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588831708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239563,"user_name":"Geek_31594d","can_delete":false,"product_type":"c1","uid":2030240,"ip_address":"","ucode":"9058787881CE82","user_header":"","comment_is_top":false,"comment_ctime":1596588721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596588721","product_id":100039001,"comment_content":"对扩展开放、对修改关闭，大体理解为对原有的功能实现方式在不必要的情况不要去修改，因为每次修改都要重新进行单元测试，扩展可以认为对新类 模块 方法 属性的新增 增强","like_count":0},{"had_liked":false,"id":237792,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1595953699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595953699","product_id":100039001,"comment_content":"我觉得开闭原则的一个关键点就是一个模块的新增功能不会影响到这个模块的对外接口。比如例子中的 check 方法，因为新增功能导致了方法参数的增加，从而导致了所有使用这个方法的地方都得修改。","like_count":0},{"had_liked":false,"id":237380,"user_name":"幽林萌逐","can_delete":false,"product_type":"c1","uid":1520451,"ip_address":"","ucode":"E6D95EC891800F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLqrAA1j4Oyy6ibicNOicn8K0olrEjtLLanic8V0y9icia6cvCVRCiabOm5llC0WhzcSWvaI2fia75hYbvjrQ/132","comment_is_top":false,"comment_ctime":1595813914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595813914","product_id":100039001,"comment_content":"打卡，新的一天看了handler这个思想我get了新的姿势，准备重构一个正在开发的服务了","like_count":0},{"had_liked":false,"id":236461,"user_name":"hex","can_delete":false,"product_type":"c1","uid":1757301,"ip_address":"","ucode":"B983D40DCD159F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d0/75/3e034f71.jpg","comment_is_top":false,"comment_ctime":1595420624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595420624","product_id":100039001,"comment_content":"现在一直在写不扩展代码啊.码农.看了这篇之后感觉飘起来了","like_count":0},{"had_liked":false,"id":234006,"user_name":"程序员班吉","can_delete":false,"product_type":"c1","uid":1478098,"ip_address":"","ucode":"BD48CF7649609A","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/d2/8a6be8d8.jpg","comment_is_top":false,"comment_ctime":1594550705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594550705","product_id":100039001,"comment_content":"对扩展开放、对修改关闭，可以对应为两个扩展<br>一，对扩展开放是为了更好的扩展业务，因为业务一直在演进变化，我们期望能通过最小的开发量和时间代价最快速实现业务扩展<br>二、对修改关闭是为了更好的代码扩展及维护，由于有第一点铺垫，在实际开发中，唯一不变的就是业务的变化，我们不可能每次业务的迭代都将代码推倒重来，这样代价太大了。所以，兼顾到代码的可扩展和维护是非常有必要的。<br>总结下来，&quot;对扩展开放、对修改关闭&quot; 实际上是对以上两个扩展的一个平衡，能够作为兼顾两者的一个方法论。但事件总是有两面性，在实现单一职责的同时免不了增加代码的复杂度，对于阅读理解代码会造成一定的困难。","like_count":0},{"had_liked":false,"id":232908,"user_name":"超超","can_delete":false,"product_type":"c1","uid":1476077,"ip_address":"","ucode":"D0751F29553481","user_header":"https://static001.geekbang.org/account/avatar/00/16/85/ed/905b052f.jpg","comment_is_top":false,"comment_ctime":1594166861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594166861","product_id":100039001,"comment_content":"对扩展开放，对修改关闭原则实施是建立在业务充分熟悉理解基础之上的，不是凭空臆想的结果，而是针对业务逻辑经常适配修改点或可察觉的未来扩展业务功能点，提炼修改点的“不变”内在逻辑，提炼成框架，实现新增功能时不影响原有逻辑或单元测试LLT用例。","like_count":0},{"had_liked":false,"id":230827,"user_name":"LH","can_delete":false,"product_type":"c1","uid":1211178,"ip_address":"","ucode":"819B9B2409E834","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/2a/7d8b5943.jpg","comment_is_top":false,"comment_ctime":1593505743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593505743","product_id":100039001,"comment_content":"经常碰到有的人接手别人代码的时候在哪里pen，不好扩展，代码可读性不好云云。有功夫pen你就去重构啊","like_count":0},{"had_liked":false,"id":229586,"user_name":"杨锋","can_delete":false,"product_type":"c1","uid":1283461,"ip_address":"","ucode":"85A7828A538FB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","comment_is_top":false,"comment_ctime":1593066709,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593066709","product_id":100039001,"comment_content":"对扩展开放，对修改关闭好处很多。最主要是可以有效规避因为修改原逻辑产生新的问题。","like_count":0},{"had_liked":false,"id":229530,"user_name":"被过去推开","can_delete":false,"product_type":"c1","uid":1276690,"ip_address":"","ucode":"8B4F34FE93FD5B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Cib5umA0W17N9pichI08pnrXAExdbyh7AVzH4nEhD6KN3FXuELk4LJJuqUPPD7xmIy9nq5Hjbgnzic7sVZG5BKiaUQ/132","comment_is_top":false,"comment_ctime":1593052410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593052410","product_id":100039001,"comment_content":"为什么要对修改关闭？对我而言，最主要的原因是不想因为新需求，而去影响已经十分稳定的功能","like_count":0},{"had_liked":false,"id":229494,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1593016434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593016434","product_id":100039001,"comment_content":"参数类的修改那里 也可以应用多态扩展吗？ 比如设置一个抽象或者接口来作为参数类IParameter or IData，然后根据需要，去扩展所需的新参数类MyData。  然后在具体扩展出的handler里比如Myhandler ，将收到的idata再unbox成该Myhandler对应的扩展参数类Mydata 。缺点就是有一次开箱操作,但是参数类的代码设计会和handler一样变成纯扩展， 不用再纠结是不是修改操作了","like_count":0},{"had_liked":false,"id":229206,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592923292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592923292","product_id":100039001,"comment_content":"对扩展开放，对修改关闭。<br>老代码很可能不是当前维护人开发的，测试用例、功能点等有可能会忽略掉某些细节，直接修改，容易引入bug，而且，即使细节全部清楚，对原有代码修改后，对应的测试同样需要修改，新功能+老功能一起测试，徒增工作量啊，还容易出错。","like_count":0},{"had_liked":false,"id":226555,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592140220,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592140220","product_id":100039001,"comment_content":"思考题：为什么对修改关闭？修改意味着引入风险，对现有系统可能造成影响，本来已经测试通过的系统，因为修改了，必须重新测试。而原来的单元测试也已经不能用，测试成本太大。为什么对扩展开放？通过添加新类新属性新方法来实现功能的扩展，不需要修改原有的东西，只需要测试新增的部分，成本最小最可靠。","like_count":0},{"had_liked":false,"id":225067,"user_name":"marsly","can_delete":false,"product_type":"c1","uid":1565950,"ip_address":"","ucode":"1F61DE32D99426","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvnkXZiaop0hbe9w5kuAvf6d17suDPB6W1j2hlYPJ43eRogABUic5pUV7ia5rPHjXLWEfDZLHiafMUiaQ/132","comment_is_top":false,"comment_ctime":1591627933,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1591627933","product_id":100039001,"comment_content":"把变动划到易控的范围内","like_count":0},{"had_liked":false,"id":225051,"user_name":"今夕何夕","can_delete":false,"product_type":"c1","uid":1620929,"ip_address":"","ucode":"C3374848592304","user_header":"https://static001.geekbang.org/account/avatar/00/18/bb/c1/b2f1bd6f.jpg","comment_is_top":false,"comment_ctime":1591624964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591624964","product_id":100039001,"comment_content":"开闭原则是为了提高代码的扩展性，对已有代码的修改往往会造成不可预知的错误。对修改关闭是为了提高代码的稳定性。","like_count":0},{"had_liked":false,"id":224150,"user_name":"马球先生","can_delete":false,"product_type":"c1","uid":1119609,"ip_address":"","ucode":"858C2CE0E494C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/79/efde2a69.jpg","comment_is_top":false,"comment_ctime":1591286106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591286106","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br>对于已有的功能，可以比较放心质量，不用再重新全部测试一遍。<br>只需要保证新添加的部分功能是正确的就好。","like_count":0},{"had_liked":false,"id":223620,"user_name":"王瑞强","can_delete":false,"product_type":"c1","uid":1829090,"ip_address":"","ucode":"DEE4EB5E23433F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/e8/e2/2bcaef68.jpg","comment_is_top":false,"comment_ctime":1591145309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591145309","product_id":100039001,"comment_content":"Alert优化后的例子同时也支持了报警方式的可插拔，比如：可以任意组合报警方式，而原来的if else是不支持的","like_count":0},{"had_liked":false,"id":223469,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591098085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591098085","product_id":100039001,"comment_content":"不变的部分是扩展点，是依赖注入，变化的部分封装为接口，根据接口编写多个实现，通过装配component完成扩展和开闭原则，通过增加接口实现和在装配是用哪个接口实现，隔离变化，实现修改关闭扩展开放。<br>装配层决定着系统的行为。","like_count":0},{"had_liked":false,"id":223463,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591096002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591096002","product_id":100039001,"comment_content":"对象和方法的封装命名分层：<br>首先把需求中的名词分组封装为实体，把动词封装为方法，OOA过程的划分非常重要直接影响可读和可扩展。属性用名词开始，方法用动词开始如initXxx、updateXxx。设计属性时有子对象(UML的关联组合聚合关系)。数据实体的子对象的repository实现可以在主对象提供get方法关联表一次取出数据，也可以分拆到子对象的repository中在service层组合，insert、update建议在子对象的repository中完成。<br>预留扩展点：<br>考虑未来的可能的变更,把变化的和不变化的分开，“变化的封装成接口”，“不变化的依赖接口”，这样在有新需求时，实现接口后，在装配层组合功能替换原有功能。<br>一个接口多个实现，这些实现同时使用，可以考虑引入handler的概念，把多个实现放入切片或map中。<br><br>","like_count":0},{"had_liked":false,"id":223147,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591009664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591009664","product_id":100039001,"comment_content":"开闭原则关键是考虑现在和未来的需求预留扩展点点，扩展点是调用接口、抽象类、函数作为函数的形参传入函数，装配层在外部实例化不同对象传入，实现多种业务的支持。<br>扩展点一般预留在service层，本package的service的依赖对应package的repository，不依赖其他package的repository，可以依赖其他package的service。所以扩展点的入参和返回值是BO,不要出现entity和VO对象。","like_count":0},{"had_liked":false,"id":220749,"user_name":"朝小树","can_delete":false,"product_type":"c1","uid":1323875,"ip_address":"","ucode":"18DC282DEF16C8","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/63/2d48822a.jpg","comment_is_top":false,"comment_ctime":1590317857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590317857","product_id":100039001,"comment_content":"学了面向对象和原则，感觉懂了一些，但是对于一些东西是否修改还是要根据经验去考虑。","like_count":0},{"had_liked":false,"id":219356,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1125259,"ip_address":"","ucode":"7BF52ADBFD4F5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/8b/dd02189a.jpg","comment_is_top":false,"comment_ctime":1590015981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590015981","product_id":100039001,"comment_content":"课堂讨论：为什么我们要“对扩展开放、对修改关闭”？<br>软件开发种唯一不变的就是变化<br>对扩展开放：主要目的是便于添加新的功能或者模块。在要添加新功能的时候，不至于要推翻原有代码而从头重构<br>对修改关闭：因为修改原有代码会增加引入bug的风险，增加了修改软件开发和测试的成本<br>","like_count":0},{"had_liked":false,"id":219223,"user_name":"Geek_1f0e17","can_delete":false,"product_type":"c1","uid":1975877,"ip_address":"","ucode":"C7309788798807","user_header":"","comment_is_top":false,"comment_ctime":1589968573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589968573","product_id":100039001,"comment_content":"我感觉在原始样例中做修改最麻烦的就是添加一个接口参数后所有调用的地方都得加参数，那其实最简单的就是多个参数变为一个对象，对对象加一个属性不影响现有接口，check方法里的加个if","like_count":0},{"had_liked":false,"id":219171,"user_name":"林毅鑫","can_delete":false,"product_type":"c1","uid":1917916,"ip_address":"","ucode":"1BB3D186E90D96","user_header":"https://static001.geekbang.org/account/avatar/00/1d/43/dc/95d4f2c5.jpg","comment_is_top":false,"comment_ctime":1589960809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589960809","product_id":100039001,"comment_content":"听的有点似懂非懂，再刷几遍。","like_count":0},{"had_liked":false,"id":217917,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1589647144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589647144","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”：<br><br>- 减少「修改代码」带来的新不确定性：最简单的理解，如果修改涉及三个类，最坏的情况就是为三个类带来了不确定性，这种不确定最坏的结果就是三个类都出 bug。而如果只涉及一个类的话，问题就简单多了。这也是为什么出现依赖注入，控制反转，以及一系列设计模式被总结出来的原因。<br><br>另外关于扩展，就像作者说的，包含两方面的内容：要实现的可扩展，已经如何实现扩展。<br>一个是意识问题，一个是技能知识问题。<br>而个人理解的可「扩展」，实际上是要实现一套「规则」「框架」「流程」「协议」，以便让其他适配或者基于他实现新的功能。小到作者的例子 Alert，中到一个库，框架（如混合 app 中常用的 jsbridge 协议 ），大到通信协议，架构，都是「框架」「规则」的具体实现...<br><br>","like_count":0},{"had_liked":false,"id":217876,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1589636305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589636305","product_id":100039001,"comment_content":"少改动少出问题，系统稳定，早点下班","like_count":0},{"had_liked":false,"id":215127,"user_name":"孟令超","can_delete":false,"product_type":"c1","uid":1433609,"ip_address":"","ucode":"37916911C0F9D9","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/09/eb3da11d.jpg","comment_is_top":false,"comment_ctime":1588909525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588909525","product_id":100039001,"comment_content":"我觉得是为了保证系统的稳定性，在  添加功能和或者修改功能时候不会影响原来的功能","like_count":0},{"had_liked":false,"id":215053,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1588898175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588898175","product_id":100039001,"comment_content":"把多个根据条件依赖外部类的代码变成可以多态的接口，把原来依赖的外部类变成接口实现","like_count":0},{"had_liked":false,"id":214447,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1588750992,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1588750992","product_id":100039001,"comment_content":"对修改关闭是为了保持已有代码的稳定性，不用牵一发而动全身，对扩展修改是为了应对不断变化的需求。以前做过分享功能就是类似的，开始只知道 if else 后来看了大话设计模式，重构成策略模式了，跟本章例子一致。现在看了一遍有了新的理解，终于知道扩展的尺度，还是要跟产品多多沟通啊，了解那些业务是要长久做下去的，那些是随时可能改的。","like_count":0},{"had_liked":false,"id":213595,"user_name":"妙子爸","can_delete":false,"product_type":"c1","uid":1433842,"ip_address":"","ucode":"988C1A7B9548F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hsxzhpId4k4uGK5CG534oLEIibqluVwOqgGqxFibILZDSia38gYOHflJDE1zfDVRGRIRq8sxdrAzWnvDP0eVDRMyQ/132","comment_is_top":false,"comment_ctime":1588485864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588485864","product_id":100039001,"comment_content":"防止短期内进行大量的代码重构，测试用例失效，上游系统改造。","like_count":0},{"had_liked":false,"id":211770,"user_name":"KID","can_delete":false,"product_type":"c1","uid":1867938,"ip_address":"","ucode":"EE80B7CA7CC2A2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/80/a2/96dcd1fa.jpg","comment_is_top":false,"comment_ctime":1588002577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588002577","product_id":100039001,"comment_content":"基于工作中的理解，修改会造成多处代码需要同步修改，这样容易漏改，也徒增很多无谓的工作量。在代码设计中，我最喜欢就是做到即使以后修改或新增功能，尽量能在源头处改变少量代码，即可实现不同的功能，这就是扩展。","like_count":0},{"had_liked":false,"id":211748,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1588000834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588000834","product_id":100039001,"comment_content":"开发多年还是对扩展开放做的不好 业务多了 修改极其复杂。泛型和继承 接口编程用的比较多。","like_count":0},{"had_liked":false,"id":211368,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1587953581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587953581","product_id":100039001,"comment_content":"如果新增需求需要频繁的修改已有代码逻辑，那带来的工作量和bug率都会剧增，原因为：<br>1 已有代码会越改越乱，越改越多，最后往往if else遍地，成了4不像。改的人小心翼翼，如履薄冰<br>2 每次修改后，都要进行完整的回归测试，单元测试。如果本身的自动化测试体系做的不好，那么工作量将是惊人的<br>3 1和2所带来的复杂度和工作量，让bug变得不可避免。996的工作强度，并发的开发任务，更是让这一风险加剧","like_count":0},{"had_liked":false,"id":202613,"user_name":"鹤鹤有名","can_delete":false,"product_type":"c1","uid":1773191,"ip_address":"","ucode":"327311F22F3C30","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJB3er54ghicIaqklUYabqtsibuMjlvyrUq2GPVke1Loth8PV5tMDbahjbIqeHZYrPzWNaia0juOUmMw/132","comment_is_top":false,"comment_ctime":1586015313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586015313","product_id":100039001,"comment_content":"对扩展开放是为了是我们设计的架构能够灵活的应对各种新的需求，对修改关闭是避免对原有代码破环性的修改，打乱最初设计好的思路保证原有结构的完整性。","like_count":0},{"had_liked":false,"id":201675,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1604089,"ip_address":"","ucode":"3A66800D8E35D6","user_header":"https://static001.geekbang.org/account/avatar/00/18/79/f9/3cd59b29.jpg","comment_is_top":false,"comment_ctime":1585819255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585819255","product_id":100039001,"comment_content":"争哥，把Alert类check方法的参数封装为一个ApiStatInfo类，这是不是类似之前讲到的贫血模型<br>alertRule = new AlertRule(&#47;*.省略参数.*&#47;); notification = new Notification(） <br>AlertRule、Notification这两个类是在哪里定义的呢 没看懂这部分的代码","like_count":0},{"had_liked":false,"id":201624,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1604089,"ip_address":"","ucode":"3A66800D8E35D6","user_header":"https://static001.geekbang.org/account/avatar/00/18/79/f9/3cd59b29.jpg","comment_is_top":false,"comment_ctime":1585813516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585813516","product_id":100039001,"comment_content":"“对扩展开放，对修改关闭”就像文章中提到的最根本的问题是解决代码的扩展性问题。<br>实际开发过程中往往很多时候都只是考虑当下需求的实现，而为做长远设计，导致添加新的需求时如果变动过大不得不重新定义一套。<br>所以在今后的开发中，首先要了解清楚业务需求，在做设计时多问一个为什么或是多想一点，锻炼抽象意识<br>不多说了 把文章的代码实现以下去","like_count":0},{"had_liked":false,"id":201491,"user_name":"小明","can_delete":false,"product_type":"c1","uid":1625618,"ip_address":"","ucode":"5A0357E9849226","user_header":"https://static001.geekbang.org/account/avatar/00/18/ce/12/1488e361.jpg","comment_is_top":false,"comment_ctime":1585795416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585795416","product_id":100039001,"comment_content":"请问，如果AlertHandler类里面需要用到Alert中的信息，这个该怎么弄？","like_count":0},{"had_liked":false,"id":200803,"user_name":"进击的前端er","can_delete":false,"product_type":"c1","uid":1506085,"ip_address":"","ucode":"9229B410F48B85","user_header":"https://static001.geekbang.org/account/avatar/00/16/fb/25/f6743e97.jpg","comment_is_top":false,"comment_ctime":1585653329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585653329","product_id":100039001,"comment_content":"看了两边，再看看留言，收货颇丰！！！","like_count":0},{"had_liked":false,"id":200280,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585568278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585568278","product_id":100039001,"comment_content":"争哥用的策略模式改进的代码，开闭原则学起来很矛盾，工厂模式加上工厂方法模式就是很好的例子，对于工厂模式，根据需求创建想要的对象，难免会去修改代码，这并不符合开闭原则，但是很符合那种比较简单的系统，但是如果你用工厂方法模式，符合开闭原则，但是用在简单的系统真的好么，其实不会，他可能会产生类爆炸，难以管理的情况。依我看来，每种原则，都有其不足之处，想要用好更难，但在项目中，找到解决问题最适合的原则，最适合的场景，和最适合的设计模式，才是最棒的","like_count":0},{"had_liked":false,"id":200277,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585567807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585567807","product_id":100039001,"comment_content":"争哥用的策略模式改进的代码，开闭原则学起来很矛盾，工厂模式加上工厂方法模式就是很好的例子","like_count":0},{"had_liked":false,"id":199847,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585496887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585496887","product_id":100039001,"comment_content":"对扩展开放是为了方便以后扩展，写之前先考虑一下短期可能有扩展需求的先留着坑。对修改关闭是为了维护代码的稳定性。起码保证以前的测试能正常通过。","like_count":0},{"had_liked":false,"id":199704,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1921287,"ip_address":"","ucode":"64BBE005890845","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","comment_is_top":false,"comment_ctime":1585494177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585494177","product_id":100039001,"comment_content":"看完后打算到项目中找到这部分复杂的if else 代码，跟兄弟们一起重构掉。","like_count":0},{"had_liked":false,"id":199316,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585486597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585486597","product_id":100039001,"comment_content":"感觉这几个原则里，这个是最有用的，如果一个方法老是被修修改改以适用新场景，说明不是个好设计","like_count":0},{"had_liked":false,"id":198776,"user_name":"Skylar","can_delete":false,"product_type":"c1","uid":1250262,"ip_address":"","ucode":"9E8D1697BEE884","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/d6/0cf21fe8.jpg","comment_is_top":false,"comment_ctime":1585467946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585467946","product_id":100039001,"comment_content":"对扩展开放，提高程序的灵活性；对修改关闭，提高程序的可维护性和稳定性","like_count":0},{"had_liked":false,"id":197817,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585399579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585399579","product_id":100039001,"comment_content":"告警的例子很棒，学到了。","like_count":0},{"had_liked":false,"id":197771,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585397752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585397752","product_id":100039001,"comment_content":"有些变化是不可控的，对扩展开放尽可能的对这种不可控的变化提供了可能，而且隔离了变化与已有的逻辑，同时，对扩展出的变化就易于做单元测试了","like_count":0},{"had_liked":false,"id":196680,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1585302308,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585302308","product_id":100039001,"comment_content":"在原有的代码上修改可能会导致线上正在运行的代码出现bug， 对扩展开放，是健壮的程序为了应对新的需求","like_count":0},{"had_liked":false,"id":195230,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585148011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585148011","product_id":100039001,"comment_content":"因为只要修改代码就容易引入bug，甚至引起原来功能的使用。而基于扩展的思路，新功能对原来功能基本没影响。","like_count":0},{"had_liked":false,"id":192375,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584848020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584848020","product_id":100039001,"comment_content":"1. 对修改关闭：是因为写完的功能，可能被很多地方引用，如果后期贸然修改可能带来灾难性的问题。有一个心法就是“把所有的功能都当作对外API来实现”，这样写完就发布出去了，想改就得督促其他同学改动代码。这样就会强迫你把接口写的干净、整洁<br><br>2.对扩展开放：要做到这一点就得保证高内聚，功能职责单一以不变应万变。比较好的代码应该是分层明确，大致可以分为基础层、服务层、业务层。基础层负责基本的数据组织不含业务逻辑；服务层则是对基础层的组合；业务层的处理逻辑依赖服务层来实现。整体上看应该是个“倒三角”结构，于是底层接口越是需要“内聚、单一”，切不可轻易修改代码。<br>","like_count":0},{"had_liked":false,"id":190834,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1584697227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584697227","product_id":100039001,"comment_content":"在私有的构造方法中执行了initializeBeans()方法没问题吗？ 那个私有的构造方法会执行到么？","like_count":0},{"had_liked":false,"id":188982,"user_name":"新的起点，新的开始^_^","can_delete":false,"product_type":"c1","uid":1262068,"ip_address":"","ucode":"9C0810F472AC93","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/f4/5df17eff.jpg","comment_is_top":false,"comment_ctime":1584441595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584441595","product_id":100039001,"comment_content":"对扩展开放：是因为需求会有变动，变动的需求，对代码进行扩展来满足需求<br>对修改关闭：是因为修改已经完成的代码，可能会对之前调用的逻辑产生影响。","like_count":0},{"had_liked":false,"id":188803,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1584417894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584417894","product_id":100039001,"comment_content":"发送短信，邮件这种耗时的操作，是不是该搞个线程池呢？","like_count":0},{"had_liked":false,"id":188793,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1584416427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584416427","product_id":100039001,"comment_content":"对修改关闭是保证原有功能的稳定性，对扩展开放是为了更方便的新增功能","like_count":0},{"had_liked":false,"id":188735,"user_name":"猫在屋里晒太阳","can_delete":false,"product_type":"c1","uid":1450035,"ip_address":"","ucode":"88D12ED99D4A30","user_header":"https://static001.geekbang.org/account/avatar/00/16/20/33/81ccb712.jpg","comment_is_top":false,"comment_ctime":1584409687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584409687","product_id":100039001,"comment_content":"在告警的案例中,如果我有50个告警规则是否意味着需要50个handler类来处理?这样就会导致handler类爆炸,针对这种情况老师有什么建议?","like_count":0},{"had_liked":false,"id":187311,"user_name":"wl","can_delete":false,"product_type":"c1","uid":1392730,"ip_address":"","ucode":"45062AA2460F1F","user_header":"https://static001.geekbang.org/account/avatar/00/15/40/5a/e65e8c40.jpg","comment_is_top":false,"comment_ctime":1584081682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584081682","product_id":100039001,"comment_content":"本篇学完了，mark 一下。<br><br>原来可扩展性的代码是这样写的，下次在项目中尝试下，只有实践过的，才会更有体会。","like_count":0},{"had_liked":false,"id":184541,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1583334649,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583334649","product_id":100039001,"comment_content":"【设计模式笔记17】20200304<br>今天分享了开闭原则的判断标准以及如何写出符合开闭原则得代码，简单来说就是尽量修改少得代码满足不断迭代的需求，是不断变化的，运用开闭原则可以提高系统得扩展性喝稳定性，随着代码复杂度升高经常会有牵一发动全身的危险，所以再设计之初就考虑不变的和变化的东西，具备抽象思维我觉得是提高代码稳定性的重要工具，很多代码可能都有什么相似得逻辑，需要不断重构将公共能力服务化，其实就是不断抽象得结果","like_count":0},{"had_liked":false,"id":184357,"user_name":"极极","can_delete":false,"product_type":"c1","uid":1250773,"ip_address":"","ucode":"365F7446ABCC49","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/d5/6d66288b.jpg","comment_is_top":false,"comment_ctime":1583297591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583297591","product_id":100039001,"comment_content":"老师，这段代码更接近于责任链模式 还是  发布订阅模式？","like_count":0},{"had_liked":false,"id":182633,"user_name":"小田","can_delete":false,"product_type":"c1","uid":1073342,"ip_address":"","ucode":"59CA02059F71E4","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/be/68ce2fd0.jpg","comment_is_top":false,"comment_ctime":1582818344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582818344","product_id":100039001,"comment_content":"# 要点小结<br>1. OCP的根本目的：实现可扩展、易维护的代码<br>2. 定位扩展点的方法：具有全局观——对业务模型有清晰的认识和好的设计，以知道代码实现<br>3. 实现扩展点的方法：【微观】多态、接口、依赖注入&#47;控制反转；【宏观】各种设计模式","like_count":0},{"had_liked":false,"id":180866,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582431552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582431552","product_id":100039001,"comment_content":"应该成立一个新的学科，面向未来编程","like_count":0},{"had_liked":false,"id":180753,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582381371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582381371","product_id":100039001,"comment_content":"面对变化的需求，从实现操作方式上可以分为修改、拓展。从这个原则上看，是建议通过拓展来实现新的需求。<br>大体还是成本问题，用修改去实现需求，必须要倒推修改所影响的模块，重新测试。这边是一个成本很高的操作。<br>拓展则承诺在实现新功能时，不会影响以往核心的功能，因此成本更低，更安全。","like_count":0},{"had_liked":false,"id":180438,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582281108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582281108","product_id":100039001,"comment_content":"这个问题,我是这么理解的,假设我在一个模块下有一个函数,如果有同事想要复用我这个代码,发现少参数了,是不是需要给我的方法的入参进行修改,来满足其需求,那么这个方法原有的调用者都需要被修改,并且我们经常写的接口类,实现的业务,都是基于SQL驱动的,修改者为了满足新的需求,可能连SQL语句都修改了,那么这种修改的成本实在太高了,但是如果提前预留了扩展点,方便同事扩展来满足新需求的同时,对原有的上游系统不会进行改变,甚至数据存储层也不会改变,那么这个成本就很低了<br>","like_count":0},{"had_liked":false,"id":177168,"user_name":"巨龙的力量啊","can_delete":false,"product_type":"c1","uid":1684858,"ip_address":"","ucode":"8FC6978929E48F","user_header":"https://static001.geekbang.org/account/avatar/00/19/b5/7a/a126c48f.jpg","comment_is_top":false,"comment_ctime":1581307811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581307811","product_id":100039001,"comment_content":"对于重要业务方法做到入参可控，多分支抽象出类，多用组合，感觉这个就基本能够做到这个条件","like_count":0},{"had_liked":false,"id":175621,"user_name":"wai","can_delete":false,"product_type":"c1","uid":1439529,"ip_address":"","ucode":"29CE3BE148FB79","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/29/60e01017.jpg","comment_is_top":false,"comment_ctime":1580784657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580784657","product_id":100039001,"comment_content":"为什么 “对扩展开发，对修改封闭” ，我认为最重要的一点：降低新功能上线对已有功能的影响，提升产品稳定性，这对于ToB的企业尤其重要。","like_count":0},{"had_liked":false,"id":175509,"user_name":"刘明丰","can_delete":false,"product_type":"c1","uid":1591790,"ip_address":"","ucode":"64C1D6CC769F75","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eocPWoTKicQG9ic42hLQBOqEziaNYxBekyGXljWrYfhk8gjLGZWfUX0JlObCvOIUSA8tRXicfxeSDJMMw/132","comment_is_top":false,"comment_ctime":1580736223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580736223","product_id":100039001,"comment_content":"开闭原则就是把易变的和不易变的代码隔离起来，把易变的代码封装起来，隐藏变化的细节，暴露并提供稳定的抽象接口，让接口的使用方更加舒服，将来变化来的时候，我们仅仅需要扩展暴露出来的稳定接口而已，在接口的使用方考虑使用容器技术，实现控制反转，代码就达到了易维护的目的。","like_count":0},{"had_liked":false,"id":174316,"user_name":"jony","can_delete":false,"product_type":"c1","uid":1048286,"ip_address":"","ucode":"80765A6B9ABA0D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/de/2019f370.jpg","comment_is_top":false,"comment_ctime":1580136757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580136757","product_id":100039001,"comment_content":"对修改关闭是为了代码的稳定性，对扩展开放是为了功能的扩展，二者是统一看待的。","like_count":0},{"had_liked":false,"id":174264,"user_name":"磊","can_delete":false,"product_type":"c1","uid":1070732,"ip_address":"","ucode":"858BF8BFBFB0B8","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/8c/a8317e23.jpg","comment_is_top":false,"comment_ctime":1580112335,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580112335","product_id":100039001,"comment_content":"对扩展开放：代码在新增功能的时候，可以快速修改代码，同时尽量减少对之前的代码的影响。<br>对修改关闭：修改现存的代码会带来诸多问题，对于已经引用这个修改类的方法或者类，都需要修改，并且需要充分测试，才能上线，这里面就牵涉到代码的重构，代码重构的基本原则就是在重构后的代码，需要经过充分的测试才能上线。<br>","like_count":0},{"had_liked":false,"id":173940,"user_name":"Value","can_delete":false,"product_type":"c1","uid":1443434,"ip_address":"","ucode":"5413E5E4A7326C","user_header":"https://static001.geekbang.org/account/avatar/00/16/06/6a/48fb83f3.jpg","comment_is_top":false,"comment_ctime":1579793750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579793750","product_id":100039001,"comment_content":"对扩展开放是因为需求总有不确定性，留下可扩展点，后期对系统的改造程度最小，最能平稳保持系统的运行。而对修改关闭也是同理，保持现有系统的稳定性，如单元测试模块，上下游系统的接口调用等等。","like_count":0},{"had_liked":false,"id":173321,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1579504133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579504133","product_id":100039001,"comment_content":"为何我就想不到这样的设计呢","like_count":0},{"had_liked":false,"id":171736,"user_name":"www","can_delete":false,"product_type":"c1","uid":1275203,"ip_address":"","ucode":"951B364F2CB211","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg","comment_is_top":false,"comment_ctime":1579004176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579004176","product_id":100039001,"comment_content":"“对扩展开放、对修改关闭”原则目的是为了需求变化时，对已有代码结构和测试用例影响降到最低，提高代码的扩展性和灵活性。但是要注意，在完成已有需求的情况下，不要过度设计预留扩展点，因为这也是有代价的，增加了工作量，并且牺牲了代码的可读性。","like_count":0},{"had_liked":false,"id":171716,"user_name":"小雨子","can_delete":false,"product_type":"c1","uid":1738146,"ip_address":"","ucode":"C869A02E845FF4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLaiafYiaPZgFuLjDicyjgFA1NkNP8pwp5uyyxnluibb6ALazSNWGcOYpkjqxR0V3Hx2IBlZS9f9p2Wlw/132","comment_is_top":false,"comment_ctime":1578996214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578996214","product_id":100039001,"comment_content":" private ApplicationContext() {    instance.initializeBeans();  }<br><br>你好，在构建ApplicationContext类是 你再构造方法中调用了 initializeBeans方法 ，这样不会报空指针异常吗，构造方法的作用是为了完成对象的初始化工作把，但是构造方法还么执行完，此时回报空指针异常吗？","like_count":0},{"had_liked":false,"id":170280,"user_name":"小虫子","can_delete":false,"product_type":"c1","uid":1435887,"ip_address":"","ucode":"3DBCDFB69D3638","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLibibbBhyIQKpSF9JrG7fWxWxQxpicVice1lNj5VtqzgTqhE8PUSBFFh3UxMzgJzU4UKXHZYhmk6wdbQ/132","comment_is_top":false,"comment_ctime":1578560291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578560291","product_id":100039001,"comment_content":"abstract class Component{<br>    protected $_events = [];<br><br>    public final function on($event,$handler){<br>        if(!isset($this-&gt;_events[$event])){<br>            $this-&gt;_events[$event] = [];<br>        }<br><br>        if(is_callable($handler)){<br>            $this-&gt;_events[$event][] = $handler;<br>        }<br>    }<br><br>    public final function trigger($event,$data){<br>        if(isset($this-&gt;_events[$event])){<br>            foreach ($this-&gt;_events[$event] as $handler){<br>                call_user_func($handler,$data);<br>            }<br>        }<br>    }<br><br>    public function hasEventHandler($event){<br>        return !empty($this-&gt;_events[$event]);<br>    }<br><br>}<br><br><br>class Alert extends Component{<br><br>    public function check(){<br>        if($this-&gt;hasEventHandler(&#39;check&#39;)){<br>            $this-&gt;trigger(&#39;check&#39;,$info);<br>        }<br>    }<br>}<br><br>class Run{<br><br>    public function run()<br>    {<br>        $alert = new Alert();<br>        $alert-&gt;on(&#39;check&#39;,function($info){<br>            &#47;&#47;检查具体代码1<br>        });<br>        $alert-&gt;on(&#39;check&#39;,function($info){<br>            &#47;&#47;检查具体代码2<br>        });<br>    }<br>}","like_count":0},{"had_liked":false,"id":169955,"user_name":"✨胡小东","can_delete":false,"product_type":"c1","uid":1312339,"ip_address":"","ucode":"314D40A5857C17","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/53/29fa4e12.jpg","comment_is_top":false,"comment_ctime":1578482734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578482734","product_id":100039001,"comment_content":"对扩展开放、对修改关闭，可以很好的避免，当我们在加入一个新的需求点时候，去大面积改动之前的代码，这样可能会导致，原本功能正常的程序，因为你的改动，导致出现bug；使得开发人员不敢随意去改动代码。","like_count":0},{"had_liked":false,"id":169627,"user_name":"京京beaver","can_delete":false,"product_type":"c1","uid":1179056,"ip_address":"","ucode":"C21838D7CA7D6B","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/b0/e30fd916.jpg","comment_is_top":false,"comment_ctime":1578392361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578392361","product_id":100039001,"comment_content":"实践中简单的方法论就是：用抽象类和接口写出来核心调用关系，作为骨架。后续具体实现都是对骨架接口的实现，这样的扩展比较好。<br>核心调用关系，涵盖了业务最主要的逻辑，基本是很少变化的。","like_count":0},{"had_liked":false,"id":169190,"user_name":"CHS","can_delete":false,"product_type":"c1","uid":1240227,"ip_address":"","ucode":"3D8B2DABC0A1D6","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/a3/28763399.jpg","comment_is_top":false,"comment_ctime":1578288984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578288984","product_id":100039001,"comment_content":"对扩展开放，对修改关闭。在写代码的时候要时刻注意这些原则，修改经常比较麻烦，如果多个地方引用了这块，那修改起来就比较痛苦了。","like_count":0},{"had_liked":false,"id":168964,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1578227453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578227453","product_id":100039001,"comment_content":"扩展与修改，根据粒度不同，判定不同。其原则是以最小的代价，实现新功能的添加。方式是预留扩展点。<br>具体方法：识别代码中的可变部分与不可变部分。把可变部分的代码做封装、隔离，抽象化为不可变接口，提供给上层使用。变动时，通过扩展方式改动，对上层使用，不影响或影响较小。","like_count":0},{"had_liked":false,"id":168810,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1578191202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578191202","product_id":100039001,"comment_content":"扩展是为了将来的变化留有余地，方便快速接入，降低成本，不影响原有的业务功能","like_count":0},{"had_liked":false,"id":168712,"user_name":"Jessica","can_delete":false,"product_type":"c1","uid":1084877,"ip_address":"","ucode":"9FC7E9BD3FE9F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/cd/b6bdc1b2.jpg","comment_is_top":false,"comment_ctime":1578145530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578145530","product_id":100039001,"comment_content":"就像老师在文章中说的，开放闭合原则对最核心，最复杂的逻辑的修改是封闭的，这样可以避免复杂的逻辑不会被修改，减少出错的概率。如果都是简单的逻辑，这个原则获得的收益是比较小的，反倒增加了代码的复杂性。","like_count":0},{"had_liked":false,"id":168522,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1578103827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578103827","product_id":100039001,"comment_content":"一、如何理解对扩展开放、对修改关闭？<br>添加一个新的功能，就是通过在已有代码基础删扩展代码（新增模块、类、方法、属性等），而非修改已有代码（新增模块、类、方法、属性等）。开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。同样的代码改动，在粗粒度下，可能被认为修改；在细粒度下，可以又被认定为扩展。<br><br>二、如何做到对扩展开放、修改关闭？<br>1.要时刻具备扩展意识、抽象意识、封装意识。这些潜意识可能比任何开发技巧都重要。<br>2.写代码之前要多思考下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，这样在未来需求变更的时候就能以最小的代码改动来更加灵活的扩展。<br>3.识别出代码可变部分和不可变部分之后，要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，只要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。<br>4.很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的。23种设计模式就是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。多态、依赖注入、基于接口而非实现编程、抽象意识说的都是同一种设计思路，也都是为了提高代码的扩展性。<br><br>三、如何在项目中灵活应用开闭原则<br>1.关键是预留扩展点，如果开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，就要对业务有足够的了解，能够知道当下及未来可能要支持的业务需求；如果开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题。<br>2.对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。<br>3.有些情况下，代码的扩展性会跟可读性相冲突，我们需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。还是要看实际的应用场景来决定。<br>","like_count":0},{"had_liked":false,"id":168364,"user_name":"Yangjing","can_delete":false,"product_type":"c1","uid":1018061,"ip_address":"","ucode":"D88DFD4958D07C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/cd/2c3808ce.jpg","comment_is_top":false,"comment_ctime":1578055416,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578055416","product_id":100039001,"comment_content":"对修改关闭，后面添加的代码不会影响以前的功能，保证了前面内容的正确性，添加功能变得更容易，更易于测试；对扩展开放，以此应对需求的变化，并是通过扩展的方式。","like_count":0},{"had_liked":false,"id":167974,"user_name":"Geek_f3a3d1","can_delete":false,"product_type":"c1","uid":1603271,"ip_address":"","ucode":"E15FA1C3AB3174","user_header":"","comment_is_top":false,"comment_ctime":1577970968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577970968","product_id":100039001,"comment_content":"像是被大道洗礼了，融会贯通的感觉。","like_count":0},{"had_liked":false,"id":167019,"user_name":"薯片","can_delete":false,"product_type":"c1","uid":1072044,"ip_address":"","ucode":"FE757E1248EFF5","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/ac/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1577670804,"is_pvip":false,"replies":[{"id":"64872","content":"我是按照告警规则去定义handler的 不是一个if一个handler的 如果真有30个判断 这代码本身就有问题吧","user_name":"作者回复","comment_id":167019,"uid":"1190123","ip_address":"","utype":1,"ctime":1577675779,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1577670804","product_id":100039001,"comment_content":"每个if分支都抽成一个handler去处理，譬如我有30个if判断，那不就是30个handler了？handler类爆炸了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479716,"discussion_content":"我是按照告警规则去定义handler的 不是一个if一个handler的 如果真有30个判断 这代码本身就有问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577675779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260741,"discussion_content":"用if是线性思维，用策略模式是对象组合思维，发通知，\n1.线性思维：传入通知类型枚举，根据枚举值进行判断调用什么通知类型的实现。\n2.对象组合：先想用什么通知，然后发出去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588899028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166612,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1577519377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577519377","product_id":100039001,"comment_content":"对扩展开放说的就是如何应对产品同事各种脑洞想法🐶<br>不过能预先扩展,那肯定能减少自己的工作量以及增加摸鱼时间咯.哈哈<br>","like_count":0},{"had_liked":false,"id":165901,"user_name":"柳柳木","can_delete":false,"product_type":"c1","uid":1420929,"ip_address":"","ucode":"DEE4ACCAE757B8","user_header":"https://static001.geekbang.org/account/avatar/00/15/ae/81/34a16bc8.jpg","comment_is_top":false,"comment_ctime":1577343258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577343258","product_id":100039001,"comment_content":"private ApplicationContext() { instance.initializeBeans(); }<br>这行有个bug!","like_count":0},{"had_liked":false,"id":165536,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1577255573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577255573","product_id":100039001,"comment_content":"我們公司在擴展方面弱爆了，現在擴展都是通過重新寫一個方法，在原方法名字後面加個V2，V3，最後弄得都不知道應該用V幾的方法才是合理的","like_count":0},{"had_liked":false,"id":165499,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1577246144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577246144","product_id":100039001,"comment_content":"这篇应该是我所读过的把开闭原则，程序扩展性讲得最清楚的文章。","like_count":0},{"had_liked":false,"id":165139,"user_name":"double","can_delete":false,"product_type":"c1","uid":1104928,"ip_address":"","ucode":"9C679F85CB6610","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/20/64394be8.jpg","comment_is_top":false,"comment_ctime":1577170633,"is_pvip":false,"replies":[{"id":"64849","content":"没大看懂你说的 你说的如何写指如何写什么呀","user_name":"作者回复","comment_id":165139,"uid":"1190123","ip_address":"","utype":1,"ctime":1577668389,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1577170633","product_id":100039001,"comment_content":"老师，这些Handler如果都是spring管理的，该任何写比较好","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479045,"discussion_content":"没大看懂你说的 你说的如何写指如何写什么呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577668389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164930,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1577113287,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1577113287","product_id":100039001,"comment_content":"为什么要对扩展开放，对修改关闭，其实就是为了应对后续接入需求的变化而带来的可扩展性以及灵活性，如果所有的需求变更都是要通过大量修改原先的业务代码功能而达到目标，说明原先的设计是不达标的，不仅影响新功能，对原先老的业务功能也会产生影响，进而会影响整个产品对外的稳定性，加大后续开发，测试，运维等相关流程的周期。","like_count":0},{"had_liked":false,"id":164735,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1577084254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577084254","product_id":100039001,"comment_content":"我的总结：<br>2. 认识『开闭原则』很重要，因为大多数的设计原则、设计方法和设计模式都是围绕这个目的展开的<br>3. 对于原则的运用一定要结合实际的场景来做分析，不能太教条化<br>4. 如果做的是业务系统，要对业务有很详细的了解采用运用这个开闭原则；如果做的系统是和业务无关的偏向于通通用的，底层的系统，要明确调用方是谁，今后的功能路线图是什么","like_count":0},{"had_liked":false,"id":164083,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1576856545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576856545","product_id":100039001,"comment_content":"争哥出品，必属精品。","like_count":0},{"had_liked":false,"id":163596,"user_name":"有爱有波哥","can_delete":false,"product_type":"c1","uid":1464493,"ip_address":"","ucode":"DD9A023563151F","user_header":"https://static001.geekbang.org/account/avatar/00/16/58/ad/6abb57c4.jpg","comment_is_top":false,"comment_ctime":1576752922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576752922","product_id":100039001,"comment_content":"不是java出生还看不懂代码 😄","like_count":0},{"had_liked":false,"id":163085,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1576654615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576654615","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”<br>目的可以归纳为一词：省成本，不管事可维护性好，还是扩张性好，最终都是服务于现实，服务于经济成本。（个人理解）","like_count":0},{"had_liked":false,"id":163066,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1576651893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576651893","product_id":100039001,"comment_content":"OCP 指导我们在编码的时候多做些思考，完成某个功能是不难的，但要写出扩展性好，条理清晰，满足需求又不失扩展的代码是挺难的；OCP 给了一个写出这样代码的视角或者“标准”，应当在分析完需求后分出可变需求和不变需求，设计好代码结构，设计好单元测试，多做练习","like_count":0},{"had_liked":false,"id":162974,"user_name":"瓶子霸哥","can_delete":false,"product_type":"c1","uid":1125806,"ip_address":"","ucode":"A7EEB459AB5550","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/nVVI6Fib5LHbhAhv8CJ9MYPau7Lcp840ST6BeqnlibUNmI4UYvGIzxtOHcKIzFa10ERANAZQUaiaKkQg4SowsUR2g/132","comment_is_top":false,"comment_ctime":1576636776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576636776","product_id":100039001,"comment_content":"我突然想到, 如果有一天需求说某些通知可以截断别的通知该怎么改动呢?<br>比如优先检查 errorCount, 如果 errorCount 已经通知这个通知的话, 就不检查 tps 是否合理了?<br>这样不就要改动 AlertHandler 的抽象方法 check(), 就违反开闭原则了吗","like_count":0},{"had_liked":false,"id":162902,"user_name":"Geek_a85af3","can_delete":false,"product_type":"c1","uid":1747648,"ip_address":"","ucode":"1AB6285B2F80FF","user_header":"","comment_is_top":false,"comment_ctime":1576630194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576630194","product_id":100039001,"comment_content":"理论的学习还是需要结合实际的项目应用才能融会贯通，平时多有意识的去用上设计模式的思想，用的多了才能把握住这个分寸","like_count":0},{"had_liked":false,"id":162338,"user_name":"胖子","can_delete":false,"product_type":"c1","uid":1037760,"ip_address":"","ucode":"E6371346288A87","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIuRQaZX70dsBg6khub2VPM1eQAP9IWRWxgOFed3ia4kXyNJInFRicWJ0ibf2YmLsOvJa1sGygGpmJg/132","comment_is_top":false,"comment_ctime":1576501635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576501635","product_id":100039001,"comment_content":"以最小化的代价实现需求变更。","like_count":0},{"had_liked":false,"id":162241,"user_name":"Emily","can_delete":false,"product_type":"c1","uid":1265582,"ip_address":"","ucode":"F5AB9AAB475FDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/ae/eec8f44b.jpg","comment_is_top":false,"comment_ctime":1576485284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576485284","product_id":100039001,"comment_content":"ApplicationContext中的initializeBeans方法应该是private吧","like_count":0},{"had_liked":false,"id":162156,"user_name":"Geek_ecf7bb","can_delete":false,"product_type":"c1","uid":1523207,"ip_address":"","ucode":"5BF4DD62425BE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/3e/07/c27b53b8.jpg","comment_is_top":false,"comment_ctime":1576468022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576468022","product_id":100039001,"comment_content":"一旦修改了原代码就可能带来bug，更可怕的是需求频繁变化，带来的风险更高，而且每次直接改维护性很差，所以扩展的思路很重要。","like_count":0},{"had_liked":false,"id":161918,"user_name":"Varus","can_delete":false,"product_type":"c1","uid":1715988,"ip_address":"","ucode":"B9CB88C248BD93","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/14/840d0925.jpg","comment_is_top":false,"comment_ctime":1576401443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576401443","product_id":100039001,"comment_content":"对扩展开放，对修改关闭，主要还是为了以后如果又新的业务需求能够以最小的代价，或者说最便捷的方式完后对功能的新增或者修改，本质上来说，扩展开放和修改关闭是一件未雨绸缪的事情。","like_count":0},{"had_liked":false,"id":161833,"user_name":"小小代码","can_delete":false,"product_type":"c1","uid":1290642,"ip_address":"","ucode":"F3D4E2C23FC9BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/92/f3dabcb1.jpg","comment_is_top":false,"comment_ctime":1576370711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576370711","product_id":100039001,"comment_content":"请问老师，例中的handler可不可以写成责任链模式，当前handler不能处理了，再交给下一个handler处理","like_count":0},{"had_liked":false,"id":161722,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1576308216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576308216","product_id":100039001,"comment_content":"抽象类与接口实现封闭，继承与实现  实现了扩展<br>开闭原则","like_count":0},{"had_liked":false,"id":161654,"user_name":"用0和1改变自己","can_delete":false,"product_type":"c1","uid":1527530,"ip_address":"","ucode":"42B8F6ECF6BDD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/lfMbV8RibrhFxjILg4550cZiaay64mTh5Zibon64TiaicC8jDMEK7VaXOkllHSpS582Jl1SUHm6Jib2AticVlHibiaBvUOA/132","comment_is_top":false,"comment_ctime":1576287362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576287362","product_id":100039001,"comment_content":"对拓展开放是为了应对变化（新的需求），方便添加删除，对修改关闭是为了保证已有代码都稳定性（防止修改一个需求引出千万个bug）,最终还是为了系统更有弹性，更易维护","like_count":0},{"had_liked":false,"id":161605,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1576245297,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576245297","product_id":100039001,"comment_content":"课堂作业：<br>写代码遵循开闭原则的目的是为了新增代码的时候尽量不要影响原来的核心逻辑，同时可以灵活应对需求的变化","like_count":0},{"had_liked":false,"id":161586,"user_name":"牛顿的烈焰激光剑","can_delete":false,"product_type":"c1","uid":1042022,"ip_address":"","ucode":"C57018C65DAFB3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e6/66/fbbf0bb1.jpg","comment_is_top":false,"comment_ctime":1576239981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576239981","product_id":100039001,"comment_content":"重构后变得更抽象并不可怕，但是文档或注释一定要跟上。","like_count":0},{"had_liked":false,"id":161525,"user_name":"半截木头","can_delete":false,"product_type":"c1","uid":1296712,"ip_address":"","ucode":"72456E8E1BD6F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/c9/48/5a2879e3.jpg","comment_is_top":false,"comment_ctime":1576223749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576223749","product_id":100039001,"comment_content":"定义：添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。<br><br>解决的是什么问题：扩展性。<br><br>什么是开放和封闭<br>实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。<br>添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。-------不改主逻辑（流程），将变动封装于易改动处。<br><br>怎样做<br>在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。<br>在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。<br>抽象出来的不变接口就是扩展点。<br><br>具体方法<br>多态<br>依赖注入<br>基于接口而非实现编程<br>设计模式<br><br>怎么识别扩展点<br>对业务熟悉<br>知道用户怎么用，可能要的功能点<br><br>不盲目预留扩展点<br>只预留目前需要的，代价小的<br>扩展和可读的平衡","like_count":0},{"had_liked":false,"id":161482,"user_name":"NYang","can_delete":false,"product_type":"c1","uid":1239235,"ip_address":"","ucode":"FCDB3246D1195A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/c3/11479173.jpg","comment_is_top":false,"comment_ctime":1576215843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576215843","product_id":100039001,"comment_content":"对扩展开放是为了更快更好的适应新的需求，对修改关闭是为了在新增需求时降低程序出错的风险","like_count":0},{"had_liked":false,"id":161387,"user_name":"TSXQG","can_delete":false,"product_type":"c1","uid":1118087,"ip_address":"","ucode":"022BF5191BB5BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/87/505b8bf8.jpg","comment_is_top":false,"comment_ctime":1576200638,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576200638","product_id":100039001,"comment_content":"使用单例模式创建 ApplicationContext 类的时候，instance 为 null。 不能在构造器执行初始化语句。我把初始化放在获取实例的方法。<br>···java<br> public static ApplicationContext getInstance() {<br>        if (instance.getAlert() == null) {<br>            instance.initializeBeans();<br>        }<br>        return instance;<br>    }<br>···","like_count":0,"discussions":[{"author":{"id":1390286,"avatar":"https://static001.geekbang.org/account/avatar/00/15/36/ce/5c958ff9.jpg","nickname":"Just do it","note":"","ucode":"70C3F8F9707325","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111194,"discussion_content":"private ApplicationContext() {this.initializeBeans();}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577784954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161225,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1576151033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576151033","product_id":100039001,"comment_content":"我实现过一个推荐接口：<br>1.按照关注关系推荐<br>2.按照关注的股票推荐<br>3.按照用户画像推荐<br>当然还会有有其他很多，<br>但是将推荐接口抽取出来，各个实现类自行实现，这样以后添加新的推荐，去掉某个推荐，都不会太麻烦。<br>这应该是OCP的一个例子吧。","like_count":0},{"had_liked":false,"id":161224,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1576150913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576150913","product_id":100039001,"comment_content":"对扩展开放是为了适应变化，对修改关闭是为了以往代码的稳定性。","like_count":0},{"had_liked":false,"id":161075,"user_name":"肥而不腻","can_delete":false,"product_type":"c1","uid":1435246,"ip_address":"","ucode":"3E6786A82A6DD6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/6e/062da5e4.jpg","comment_is_top":false,"comment_ctime":1576114721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576114721","product_id":100039001,"comment_content":"为了尽量少点ifelse","like_count":0},{"had_liked":false,"id":160991,"user_name":"王小念","can_delete":false,"product_type":"c1","uid":1057147,"ip_address":"","ucode":"2062E25909B8E0","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/7b/53a325d1.jpg","comment_is_top":false,"comment_ctime":1576074261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576074261","product_id":100039001,"comment_content":"总结的很精辟！但落实到具体应用还需要自身多多思考，多多实践。就像争哥最后说的 “这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。”","like_count":0},{"had_liked":false,"id":160806,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1576034994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576034994","product_id":100039001,"comment_content":"对扩展开放，对修改关闭。本质上就是我们在改变逻辑或者增加逻辑的时候，尽量不要对已有的功能或者单元测试带来影响。不能因为新的改动破坏了老的系统的使用。","like_count":0},{"had_liked":false,"id":160788,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1576032603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576032603","product_id":100039001,"comment_content":"设计良好的计算机软件应该易于扩展, 同时抗拒修改. 也就是说, 一个设计良好的计算机系统应该在不需要修改的前提下可以轻易被扩展.<br>应该很容易通过新增代码来修改系统行为, 而不是只有修改原来的代码.","like_count":0},{"had_liked":false,"id":160781,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1576032043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576032043","product_id":100039001,"comment_content":"打卡<br>1、扩展开放、修改关闭 定义：添加一个新功能在原有的基础上扩展代码（新增模块、类、方法、属性），而非通过修改已有代码（修改模块、类、方法、属性）来完成；<br>2、一个修改在粗粒度下可以认为是“修改”，在细粒度下可以认为是“扩展”<br>3、多思考一下最近可能会有哪些扩展点，预留好；另外，识别出变换的部分，将变化的部分封装起来，提供一个抽象接口供上层系统调用；<br>4、提高扩展性常用的方法：多态、依赖注入、基于接口而非实现编程、入参封装成类，可以避免参数过多的修改等","like_count":0},{"had_liked":false,"id":160712,"user_name":"IOT..Yang","can_delete":false,"product_type":"c1","uid":1240343,"ip_address":"","ucode":"11589D83B67FE9","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/17/c3eb014f.jpg","comment_is_top":false,"comment_ctime":1576024973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576024973","product_id":100039001,"comment_content":"为什么“对扩展开放，对修改关闭”，正向考虑我看大家说的很多，我们也可以反向考虑，如果你增加一个新功能，会大量修改已有代码，那么就不能保证旧功能正确性(或者说是稳定性)，这样测试同学还得重新测试，费时费力。而且这种牵一发而动全身的修改方式也不优雅，也是前辈通过血和泪经历得出的结论，哈哈！","like_count":0},{"had_liked":false,"id":160669,"user_name":"云起","can_delete":false,"product_type":"c1","uid":1097790,"ip_address":"","ucode":"1642C543B47B87","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/3e/ff3ed621.jpg","comment_is_top":false,"comment_ctime":1576002805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576002805","product_id":100039001,"comment_content":"感觉核心是要做到修改只增加代码，避免删掉部分代码，而影响原来的执行逻辑","like_count":0},{"had_liked":false,"id":160636,"user_name":"风行者","can_delete":false,"product_type":"c1","uid":1541934,"ip_address":"","ucode":"F058640CF77A35","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/2e/ea54c240.jpg","comment_is_top":false,"comment_ctime":1575990499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575990499","product_id":100039001,"comment_content":"打卡，这个例子就是if else比较多的重构场景","like_count":0},{"had_liked":false,"id":160553,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1575973361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575973361","product_id":100039001,"comment_content":"老师，问个问题，我们现在要做个分佣金的功能，获得佣金的角色现在只有一种，就是购买人的上级，但是以后很可能会有其他角色获得分佣金，所以我就抽象了一个分佣金的interface，这个interface就定义了一个方法，就是分佣的动作，但是每个角色的分佣应该都有一个计算佣金的方法，我现在要不要把这个计算分佣的方法也加到前面说的interface里面呢，谢谢老师","like_count":0},{"had_liked":false,"id":160447,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1575952808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575952808","product_id":100039001,"comment_content":"有一个问题想问一下。随着handler的扩展，需要的参数可能越来越多，<br>ApiStatInfo类中也会存在各种乱七八糟的属性，实际过程中我就遇到一个权限规则校验的扩展点。权限规则可以随意扩展，但是每个规则需要的参数都不同，只能通过统一的bean传递，导致bean的参数越来越多，而且互相毫无关系。老师对于这个问题怎么看?","like_count":0},{"had_liked":false,"id":160445,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1575952552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575952552","product_id":100039001,"comment_content":"1. 应对需求变化，需求变化的时候可以迅速和方便的修改<br>(反问: 那我改代码也可以应对需求变化啊)<br>2. 控制影响最小，可以保证不影响比如原来的测试用例，调用代码。如果改代码的话。就有可能影响。<br>3. 添加新代码的时候可以缩小关注范围，我只需要关注我需要新实现的接口和初始化等，不需要从上到下查看旧的代码逻辑<br><br>我对“对扩展开放、对修改关闭”这个原则印象最深的:就是在修改的时候，不影响其他已经有的流程。<br>我把代码分为对内和对外，<br>对系统内：比较简单的情况下，不会在一开始太注重“对扩展开放、对修改关闭”，因为对内系统，就算修改，就是通一个应用，一般编译和单元测试修改也比较方便。除非当某一个点涉及到多次修改，那么才考虑抽象扩展点<br>对系统外: 比如暴露的网关，dubbo接口，就比较慎重，因为这块的调用方并不是由我们控制，修改的成本比较高，所以一般会提前考虑扩展点。","like_count":0},{"had_liked":false,"id":160369,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1575942082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575942082","product_id":100039001,"comment_content":"课堂讨论:为什么我们要“对扩展开放、对修改关闭”？<br><br>Answer:<br><br>我认为最重要的一点就是可维护性及维护成本.<br><br>若频繁的修改,会需要更多的测试,调试及时间成本.<br>若以扩展代替修改,则会减少很多不确定性,提高产品稳定性,同时也节约时间.","like_count":0},{"had_liked":false,"id":160364,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1237655,"ip_address":"","ucode":"088A8DA0A16BDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","comment_is_top":false,"comment_ctime":1575941447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575941447","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":160360,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1575941083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575941083","product_id":100039001,"comment_content":"第一个例子中: 我们先来分析一下改动一：往 ApiStatInfo 类中添加新的属性 timeoutCount。              这部分的改动相对来说是最不合理的。我认为更好的做法是，去掉ApiStatInfo类，或者说将这个类跟AlertHandler 解耦，每个handler的具体实现不应该是全部的ApiStatInfo, 而应该是其中的一部分，各自关心自己的属性即可，不必强求把所有的相关属性都归到一个类中，这种做法适得其反，既不内聚又强制耦合。其他改动没问题，增加新的handler 的实现类之后，当然可以做成配置型的添加或修改，关键在于开发的产品是什么性质的，如果是类似与SDK或spring 这种不希望让调用者看到源代码的，一定要做成可配置的，否则做成代码中的方法完全可以。然后就是每个handler 各自实现通知发送逻辑即可。","like_count":0},{"had_liked":false,"id":160341,"user_name":"BerryMew","can_delete":false,"product_type":"c1","uid":1013075,"ip_address":"","ucode":"E6CDD211617FF9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/53/76281fc3.jpg","comment_is_top":false,"comment_ctime":1575938678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575938678","product_id":100039001,"comment_content":"今天对开闭选择的理解算是豁然开朗了，虽然灵活运用还需大量实践与经验积累，但记住这节课中的handler的demo并且能够灵活运用，我觉得就已经很好了。","like_count":0},{"had_liked":false,"id":160339,"user_name":"Middleware","can_delete":false,"product_type":"c1","uid":1072015,"ip_address":"","ucode":"C0028293ECDD47","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/8f/4b0ab5db.jpg","comment_is_top":false,"comment_ctime":1575938489,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1575938489","product_id":100039001,"comment_content":"直白点就是保证已有业务不受影响，容易扩展新业务","like_count":0},{"had_liked":false,"id":160318,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1575935345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575935345","product_id":100039001,"comment_content":"对扩展开放是为了应对多变的需求，对修改关闭是为了避免被依赖的代码发生大的改动，花最小的代价去改动代码","like_count":0},{"had_liked":false,"id":160293,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1575906535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575906535","product_id":100039001,"comment_content":"1、对拓展开放是为了应对变化，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！<br>2、个人觉得公司我们组的代码就完全不符合开闭原则，通常是添加一个新的功能，每次测试上线还要回归其他的功能，根本无法做到说是老公能没有影响，leader也一直说是要重构，但是我个人是没什么好的想法，希望能多在争哥这学习一下，我也很想写出像争前面开头写的那个alert的重构，反正我是重构不出来","like_count":0},{"had_liked":false,"id":160278,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1575903907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575903907","product_id":100039001,"comment_content":"我的理解是加入新功能后对现有单元测试和调用处不用修改就算满足开闭原则，不知道对不对","like_count":0},{"had_liked":false,"id":160268,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1575901772,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575901772","product_id":100039001,"comment_content":"如果不对修改关闭,随意的修改,那么修改多了以后很可能会出现bug,影响原来的功能,而且代码逻辑会越来越复杂,变得难以维护,所以一开始就设计好可拓展性,以后即使增加功能也很方便,也不会影响到原来的代码.","like_count":0},{"had_liked":false,"id":160209,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1575892036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575892036","product_id":100039001,"comment_content":"总之别看见需求就开始写代码，能多想一步就多想一步，能把代码写活就别写死，让它再活几集。","like_count":0},{"had_liked":false,"id":160153,"user_name":"ismind","can_delete":false,"product_type":"c1","uid":1138710,"ip_address":"","ucode":"7AADD673ED3BC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/16/d1dd4972.jpg","comment_is_top":false,"comment_ctime":1575881194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575881194","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br>1，提高代码的质量，也就是将代码写得更好，当然也会权衡可扩展性和可读性，比如今天这个ALert的例子，如果告警规则少，业务逻辑简单，不需要“扩展开放，修改关闭”，也是可以的，因为代码可读性更好；如果规则多，逻辑复制，就需要修改关闭了；<br>2，文章提到了，“（1）调用函数的地方会修改（2）单元测试也会修改”，所以“扩展开放，修改关闭”可以降低维护成本，减少人力财力。这也是很重要的原因吧。<br>自己刚刚接触设计模式，希望能逐渐理解并会运用。","like_count":0},{"had_liked":false,"id":160136,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1575877617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575877617","product_id":100039001,"comment_content":"对扩展开放是因为需要应对需求的变化，做好了这一点，才能实现“对修改关闭”的结果，以保护已有代码的运行不受影响。<br>按照我的理解，“对修改关闭”是结果而不是我们需要去在代码层面做的，也不存在烂代码“对修改开放”","like_count":0},{"had_liked":false,"id":160113,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1575872520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575872520","product_id":100039001,"comment_content":"对旧版本的向上兼容，对未来需求的可扩展，对代码的可阅读性、可维护性","like_count":0},{"had_liked":false,"id":160109,"user_name":"moqifei","can_delete":false,"product_type":"c1","uid":1358410,"ip_address":"","ucode":"E0A6C858B78A3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGovXf8jNP5ZqHsDKLwajjicbFwpX9on1xiaJDR4CgWaWP2KcfOdneasBfKFo3dO3dwQyGG6WjK40w/132","comment_is_top":false,"comment_ctime":1575871489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575871489","product_id":100039001,"comment_content":"对扩展开放，对修改关闭，其根本是为了高内聚，低耦合。","like_count":0},{"had_liked":false,"id":160105,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1575871070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575871070","product_id":100039001,"comment_content":"打卡～，之前对开闭原则一直很困惑，很多对扩展开放的操作实际上还是对代码进行很多修改了呀。今天的课让我有一点感觉了，关于这点的小结：<br>第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。<br>第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。","like_count":0},{"had_liked":false,"id":160093,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1575868619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575868619","product_id":100039001,"comment_content":"为什么我们要“对扩展开放、对修改关闭”？<br>修改代码可能会带来问题，尽量将修改代码量做到最小，可控，那么出现问题几率就越小。<br>一般程序都是要迭代的，要不断变化，应对不用的需求，扩展就是为了应对未来的需求变化。<br>保持代码的稳定性，能很好的应对未来的需求变化","like_count":0},{"had_liked":false,"id":160090,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1575868256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575868256","product_id":100039001,"comment_content":"为了平衡，业务稳定和加入新特性的矛盾。<br><br>1.不可修改语意更明确，减少阅读代码的心智负担。<br>2.通过扩展实现新特性，后期出问题好定位，有变更易拔插。","like_count":0},{"had_liked":false,"id":160067,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1575863188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575863188","product_id":100039001,"comment_content":"灵活应对需求变化,提高可测性稳定性.","like_count":0},{"had_liked":false,"id":160054,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1575861321,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575861321","product_id":100039001,"comment_content":"做扩展开放，对修改关闭：实际上还是需要业务功能的驱动。<br><br>拿到一份需求，以及一份月度、季度甚至是年度规划的时候，可以先考虑下需要用到的功能，需要新写还是直接扩展需求点，需要设计多少接口， 实现多少细节等等，有个大概的维度。<br><br>但是就如课程中说的，“唯一不变的只有变化本身”。所以，这就还涉及到过度设计的问题，才能更好的去做对扩展开放，对修改关闭的事情，我太难了，哈哈。<br>","like_count":0},{"had_liked":false,"id":160047,"user_name":"划时代","can_delete":false,"product_type":"c1","uid":1061454,"ip_address":"","ucode":"9554CE2F83B77F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2o1Izf2YyJSnnI0ErZ51pYRlnrmibqUTaia3tCU1PjMxuwyXSKOLUYiac2TQ5pd5gNGvS81fVqKWGvDsZLTM8zhWg/132","comment_is_top":false,"comment_ctime":1575860409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575860409","product_id":100039001,"comment_content":"这一篇“对扩展开放，对修改关闭”收获良多，是设计模式的精髓所在。我的实践过程，由最开始的大量运用到最后的敬而远之，疑惑很多。新手和高手之间的差距，原来就在一个运用的度上。“对扩展开放，对修改关闭”在于，最大的复用原有代码，最小的改动原有代码；高内聚，低耦合；更好的单元测试和保证代码质量。","like_count":0},{"had_liked":false,"id":160013,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":1514882,"ip_address":"","ucode":"2F1FA3519FAB50","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyiafvkibXnTOpIJxlhndHpSDMsqja9AajKYtYgGEGtFWtBb2Mg8DRVjqlWyIxl1piaT4qpMkwerQUg/132","comment_is_top":false,"comment_ctime":1575857685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575857685","product_id":100039001,"comment_content":"我们要时刻具备扩展意识、抽象意识、封装意识。希望通过学习培养自己这种意识，在今后看源码要多从设计入手，多分析，总结，希望早日养成这种感觉，使设计变的敏感。","like_count":0},{"had_liked":false,"id":160007,"user_name":"JOsuny","can_delete":false,"product_type":"c1","uid":1319513,"ip_address":"","ucode":"5F36D3D1AF83EA","user_header":"https://static001.geekbang.org/account/avatar/00/14/22/59/781b6fa5.jpg","comment_is_top":false,"comment_ctime":1575856920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575856920","product_id":100039001,"comment_content":"打卡<br>","like_count":0},{"had_liked":false,"id":159990,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1575854793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575854793","product_id":100039001,"comment_content":"简单一点就行，不要留下祖传代码，留着谁都不敢修改代码，避免牵一发而动全身。","like_count":0},{"had_liked":false,"id":159989,"user_name":"SMTCode","can_delete":false,"product_type":"c1","uid":1109038,"ip_address":"","ucode":"0D837A753E4FAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/2e/49d13bd2.jpg","comment_is_top":false,"comment_ctime":1575854743,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575854743","product_id":100039001,"comment_content":"昨天在复习设计模式时，在打卡中刚刚提到了自己实际开发中用到的“开闭原则”，今天争哥就在这里系统的讲到了，感觉共鸣点颇多，特此总结一下：<br>看了争哥的讲述，发现自己那段协议代码能抽象的更好一些：可以通过定义一个更高层的类，通过调用这个类的公共的check来封装所有的handler，这样就不需要我说的多个else if的更新了。<br>刚刚在想争哥文中举的“错误处理”那个例子感觉使用的和“外观模式”类似，但看了一下外观模式的场景，感觉自己套错了模式。<br>其实，我觉得开闭原则的核心就是：<br>1、提高代码的扩展性<br>2、降低扩展功能的成本<br>3、扩展功能时，不影响旧的功能。<br>有了开闭原则，在有新需求时，就可以大胆的扩展新功能，最坏的情况就是：新功能的bug只导致新功能不好用。所以对原有功能的冲击是“零”。同时，新接触项目的人，一旦掌握了这个设计框架，能很快的上手新功能的开发。间接提高了代码的可维护性。说真的，我之前那段代码的协议具体实现细节早就忘的一干二净了，但如果要做扩展，支持新的协议，开发的难度就是如何构造新的协议了。<br><br>正如争哥所言：很多设计模式是为了提高代码的扩展性，那么，如果对业务不熟悉，对需求不明确，如何能发现系统的共性？如何能找到系统中未来需要扩展的热点代码？其实如果一切都弄清楚了，可以说最终写代码就是纯力气活了。代码框架的抽象能力体现了一个程序员的综合实力。 <br>加油吧！<br>外观模式是将一个“外部”需要调用多个子系统配合才能产生正确结果的问题，进行了封装和隐藏，通过一个更高层的类，隐藏系统内部的细节，避免了外部需要过多的了解系统内部的实现步骤。显然这里不是这种情况。<br><br>","like_count":0},{"had_liked":false,"id":159987,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1575854331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575854331","product_id":100039001,"comment_content":"为什么要对“扩展开放，对修改关闭”？<br>我觉得一是提高新功能的开发效率，二是减少旧代码的维护成本<br>既开源又节流","like_count":0},{"had_liked":false,"id":159983,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1575853988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575853988","product_id":100039001,"comment_content":"1.对于一直在提供服务的代码，改动是必然的，因为世界一直在变化。<br>2.添加新功能时，肯定是需要修改已有代码的（新增模块、类、方法等），<br>3.针对不同粒度中的代码改动，在粗代码粒度下，可能是”修改“，在细代码粒度下，又可以被认定为”扩展“<br>5.划重点：设计初衷：没有破坏原有代码的正常运行，没有破坏原有的单元测试，这一个合格的代码改动<br>6.尽量做到修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则<br>7.此原则与可读性存在某种程序的冲突，需要针对具体的场景权衡。","like_count":0},{"had_liked":false,"id":159978,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1575853821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575853821","product_id":100039001,"comment_content":"学习学习，对拓展开发对修改关闭，为了减少以后代码维护的难度，而且扩展写的代码会给自己一种“挖槽，老子这么这么聪明，早就想到了改动了”的快感","like_count":0},{"had_liked":false,"id":159977,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1575853516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575853516","product_id":100039001,"comment_content":"举个例子，我们的下单接口有很多验证，之前的代码有好多的if else，像面条是的，这样代码可读性也不好，修改了某处就可能造成错误，如果把这些验证搞成开放关闭原则，在下单那个接口只要写个foreach循环各种验证，以后再增加或者删除验证也不需要在下单接口修改了，只需要在增加一个验证的实现类，把该实现类绑定到控制器里面，如果不需要某个验证，只需要在绑定那个地方删除掉就可以了，感觉这个原则比较优雅，改起来也方便快捷，当然如果验证条件不是很多就没必要用这个原则了，毕竟运用原则理解起来比直接写ifelse有难度，一定要适度，不要所有代码都套上各种设计模式和原则。","like_count":0},{"had_liked":false,"id":159963,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1575852327,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575852327","product_id":100039001,"comment_content":"首先设计好函数，然后思考这个函数是否有扩展的需求，如果有，那么将这个类变为抽象类，用子类实现该函数。扩展性的理解前提是好的函数设计。","like_count":0,"discussions":[{"author":{"id":1395192,"avatar":"https://static001.geekbang.org/account/avatar/00/15/49/f8/b0ba3823.jpg","nickname":"jackie","note":"","ucode":"FFB7DE5DD7D31E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543532,"discussion_content":"支持事件很多的时候可以这么做，大多数情况跟人觉得不需要。结合java8的default或者加一层适配器然后全部为空方法就好，看起来不直观","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641196605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330141,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","nickname":"HomeyLiu","note":"","ucode":"EF4CCB92C369B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539429,"discussion_content":"StateMachine 写的有问题.\n\ntriggerAB, triggerBC,\nAB事件必须同时发生吗? BC时间必须同时发生吗?\n或者A和B事件的处理一样,B和C事件的处理一样?\n\n如果不是的话,\n应该分开来写triggerA,triggerB,triggerC","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639712803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330141,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","nickname":"HomeyLiu","note":"","ucode":"EF4CCB92C369B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539428,"discussion_content":"\nStateMachine 应该改写成\npublic class StateMachine {\n    int score;\n    State currentState;\n\n    public StateMachine() {\n        score = 0;\n        currentState = S1State.getInstance();\n    }\n\n    public void triggerA() {\n        currentState.triggerEvent(Event.A, this);\n       \n    }\n\n    public void triggerB() {\n        currentState.triggerEvent(Event.B, this);\n \n    }\n\n   public void triggerC() {\n        currentState.triggerEvent(Event.C, this);\n \n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639712623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2181661,"avatar":"https://static001.geekbang.org/account/avatar/00/21/4a/1d/3567f117.jpg","nickname":"乔宏民","note":"","ucode":"B6A9F971E9CC96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385902,"discussion_content":"这种设计思路比较好，解决了新增事件的话，代码入侵问题，新增事件的时候，需要关心此事件的状态就put一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627344569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2618193,"avatar":"https://static001.geekbang.org/account/avatar/00/27/f3/51/c8eb2d0c.jpg","nickname":"Amon Tin","note":"","ucode":"25391BEEB6A719","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380438,"discussion_content":"S1状态类里的events是笔误，可以去掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624504777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159962,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1575852239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575852239","product_id":100039001,"comment_content":"对扩展开放是为了应对软件迭代过程中的变化;对修改关闭则是为了在增加这些变化的过程中防止软件出bug，减少对源代码的改动！","like_count":0},{"had_liked":false,"id":159956,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1575851440,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575851440","product_id":100039001,"comment_content":"前排打卡～😃","like_count":0},{"had_liked":false,"id":159949,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1575850866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575850866","product_id":100039001,"comment_content":"对扩展开放，对修改关闭。只要还是为了代码的可维护性和稳定性，在旧代码上修改，所有相关的单元测试都要重写，功能全部要重测，如果调用地方多，兼容性还不一定可以全覆盖到。出现线上问题也排查麻烦，这个问题改了一块，有因为这一块影响到了别的功能。代码质量会越来越差，有一天变成祖传代码就没有人敢去动了。<br><br>基于扩展的，几乎不会影响到旧的实现，只是自身的变化，代码可维护性好，质量高。易于测试，各块各司其职。缺点就是可读性变差了。","like_count":0},{"had_liked":false,"id":159940,"user_name":"progyoung","can_delete":false,"product_type":"c1","uid":1014692,"ip_address":"","ucode":"0B4898AE78F9F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/a4/24955994.jpg","comment_is_top":false,"comment_ctime":1575849542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575849542","product_id":100039001,"comment_content":"对扩展开放以应对不断变化的需求，对修改关闭以应对减少未来添加新功能时对现有代码的改动。","like_count":0}]}