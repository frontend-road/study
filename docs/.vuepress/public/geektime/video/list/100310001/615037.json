{"id":615037,"title":"65｜再回首：“类”单元小结","content":"<p>你好，我是尹会生。</p><p>这一章我们学习了面向对象的程序设计思想。面向对象编程思想，是将“对象”当做程序的基本单元，通过操作对象中存储的数据和数据的方法，实现各种开发需求。</p><p>使用对象同上一章我们学习过的函数不只语法不同，在编程思路上也有着非常大的不同，这就导致很多人对面向对象编程产生不适应的感觉，我在初学面向对象编程时，也和你一样，体会过“突然不会编程”的感觉。</p><p>为了让你更好地掌握面向对象编程，接下来我打算用一个队列的例子，来带你从需求分析、类的定义、方法定义、调用对象的方法四个方面，来巩固一下我们学习的面向对象编程的语法，也从一个小的需求开始，帮你尽快从面向过程的编程习惯，逐渐迁移并掌握面向对象编程的习惯。</p><h2>需求分析：一个排队的例子</h2><p>要说排队这件事，我们在现实生活中肯定会经常遇到。它是解决资源竞争的一种机制。即按照时间顺序先来先得。在编程过程中，也会遇到资源竞争，其中一种解决办法就是排队。</p><p>计算机世界中的排队，一般都要按照时间顺序先来后到，所以一般队列中就有了进入队列和离开队列的基本操作。那抛开一般操作，我们还可以将队列实现得更复杂一些，比如可以排多个队，可以给排队的程序指定优先级等等。</p><p>但是不管队列多复杂，你要用编程实现它的时候，它就是一个独立的概念，因此你就可以将队列当做一个能够先入先出（FIFO）的对象。具有不同特征的队列可以被定义为队列的模板——类。</p>","comments":[{"had_liked":false,"id":365000,"user_name":"老方丈[福][福]","can_delete":false,"product_type":"c3","uid":3229514,"ip_address":"河北","ucode":"6099B921BD54D2","user_header":"https://static001.geekbang.org/account/avatar/00/31/47/4a/775e3a52.jpg","comment_is_top":false,"comment_ctime":1671881999,"is_pvip":false,"replies":[{"id":132897,"content":"每周三更新一章","user_name":"编辑回复","user_name_real":"编辑","uid":2843479,"ctime":1671939107,"ip_address":"河北","comment_id":365000,"utype":2}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100310001,"comment_content":"老师，后面章节何时更新啊","like_count":0,"discussions":[{"author":{"id":2843479,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","nickname":"小虎子🐯","note":"","ucode":"4C9530B3FB407B","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597507,"discussion_content":"每周三更新一章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671939107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"河北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385061,"user_name":"Geek_631607","can_delete":false,"product_type":"c3","uid":3789991,"ip_address":"广东","ucode":"EAF874838F0BE4","user_header":"","comment_is_top":false,"comment_ctime":1702005237,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100310001,"comment_content":"class MyQueue:\n    &#39;&#39;&#39;定义一个队列&#39;&#39;&#39;\n\n    def __init__(self, maxsize = 10) -&gt; None:\n        self.maxsize = maxsize\n        self.queue = []\n    \n    def full(self):\n        &#39;&#39;&#39;队列最大长度&#39;&#39;&#39;\n        return 0 &lt; self.maxsize &lt;= len(self.queue)\n    \n    def empty(self):\n        &#39;&#39;&#39;队列长度为 0&#39;&#39;&#39;\n        self.queue.clear()\n        pass\n\n    def put(self, item):\n        &#39;&#39;&#39;放入数据&#39;&#39;&#39;\n        if not self.full():\n            self.queue.append(item)\n\n    def get(self, item):\n        &#39;&#39;&#39;取出数据&#39;&#39;&#39;\n        if not self.empty():\n            self.queue.pop()\n\n\n\n\n\nclass PriorityQueue(MyQueue):\n\n    def putTop(self, item, topFlag):\n        if topFlag:\n            return self.queue.insert(0, item)\n        return super().put(item)\n    \n\n\nq = PriorityQueue()\nq.put(&#39;1&#39;)\nq.put(&#39;2&#39;)\nq.put(&#39;3&#39;)\nq.putTop(&#39;0&#39;, True)\nprint(q.queue)","like_count":1},{"had_liked":false,"id":379019,"user_name":"Geek_Mike","can_delete":false,"product_type":"c3","uid":3196376,"ip_address":"云南","ucode":"CFA942192C3B74","user_header":"https://static001.geekbang.org/account/avatar/00/30/c5/d8/c5509b9c.jpg","comment_is_top":false,"comment_ctime":1691139651,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100310001,"comment_content":"from queue import PriorityQueue\n&#39;&#39;&#39;自定义一个支持插入数据优先级功能,即优先级高的数据,插入队列时能够得到更靠前的位置,以便更早得到处理的队列&#39;&#39;&#39;\n\nclass Myqueue:\n    def __init__(self, maxsize=10):\n        self.maxsize = maxsize\n        self.queue = PriorityQueue() \n        # PriorityQueue类构建的数据结构不是列表；让属性 queue 能继承 PriorityQueue 类的方法，并传递给实例；\n\n    def full(self):\n        return self.queue.qsize() == self.maxsize \n    # 队列满了,返回 True\n    \n    def empty(self):\n        return self.queue.empty() \n    # 队列为空,返回 True\n    \n    def put(self, priority:int, item): \n        if self.full():\n            print(&quot;Queue is full, can&#39;t put into any itmes.&quot;)\n        else:\n            self.queue.put((priority, item))\n            # 把要插入队列的元素按照‘优先级，数据’以元祖的格式传递给 put 方法\n    \n    def get(self):\n        if self.empty():\n            print(&#39;Queue is empty, no items can be fetched.&#39;)\n        else:\n            return self.queue.get()[1] \n# 取出优先级最高的元素后,返回元祖结构(优先级，数据)中的数据\n    \n    def item_num(self):\n        print(f&#39;Queue can have {self.maxsize - self.queue.qsize()} more items.&#39;)\n\n\nmyque = Myqueue(3)\n# print(myque.full())\nmyque.item_num()\nmyque.put(3, &#39;apple&#39;)\nmyque.put(2, &#39;pear&#39;)\nmyque.put(1, &#39;banana&#39;)\n# myque.put(1, &#39;water&#39;)\n# print(myque.full())\nmyque.item_num()\n\nwhile not myque.empty():\n    print(myque.get())\n# myque.get()\nmyque.item_num()","like_count":1},{"had_liked":false,"id":370104,"user_name":"GeekNeo","can_delete":false,"product_type":"c3","uid":1146405,"ip_address":"浙江","ucode":"1D355A9BEB8BEA","user_header":"https://static001.geekbang.org/account/avatar/00/11/7e/25/3932dafd.jpg","comment_is_top":false,"comment_ctime":1678377547,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100310001,"comment_content":"from heapq import heappush, heappop\nclass MyQueue(object):\n    &#39;&#39;&#39;定义一个队列&#39;&#39;&#39;\n    def __init__(self, maxsize=10) -&gt; None:\n        &#39;&#39;&#39;初始化队列长度&#39;&#39;&#39;\n        self.maxsize = maxsize\n        self.queue = []\n    \n    def _qsize(self) -&gt; int:\n        return len(self.queue)\n\n    def full(self) -&gt; bool:\n        &#39;&#39;&#39;队列最大长度&#39;&#39;&#39;\n        return 0 &lt; self.maxsize &lt;= self._qsize()\n    \n    def empty(self) -&gt; bool:\n        &#39;&#39;&#39;队列长度为0&#39;&#39;&#39;\n        return not self._qsize()\n\n    def put(self, priority: int, item: str) -&gt; list:\n        &#39;&#39;&#39;放入队列数据&#39;&#39;&#39;\n        if not self.full():\n            # self.queue.insert(0, item)\n            heappush(self.queue, (priority, item))\n    \n    def get(self) -&gt; str:\n        &#39;&#39;&#39;取出数据&#39;&#39;&#39;\n        if not self.empty():\n            # return self.queue.pop()\n            return heappop(self.queue)[1]\n\nmyq = MyQueue(3)\nprint(myq.empty())\nmyq.put(3, 123)\nmyq.put(2, 456)\nmyq.put(1, 789)\nprint(myq.full())\nprint(myq.queue)\n\n\nprint(&quot;取出数据为 %s&quot; % (myq.get()))\nprint(&quot;取出数据为 %s&quot; % (myq.get()))\nprint(&quot;取出数据为 %s&quot; % (myq.get()))\nprint(myq.empty())","like_count":1},{"had_liked":false,"id":395901,"user_name":"尹长拟","can_delete":false,"product_type":"c3","uid":3074007,"ip_address":"北京","ucode":"1EBD42B5BBD934","user_header":"","comment_is_top":false,"comment_ctime":1732374136,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100310001,"comment_content":"import heapq\n\nclass MyQueue:\n    &#39;&#39;&#39;定义一个队列&#39;&#39;&#39;\n\n    def __init__(self,maxsize=10):\n        &#39;&#39;&#39;初始化队列长度 &#39;&#39;&#39;\n        self.maxsize = maxsize\n        self.queue = []\n\n    def full(self):\n        &#39;&#39;&#39;队列最大长度&#39;&#39;&#39;\n        return 0 &lt; self.maxsize &lt;= len(self.queue)\n    \n    def empty(self):\n        &#39;&#39;&#39;队列长度为 0&#39;&#39;&#39;\n        return not len(self.queue)\n    \n    def put(self,item,priority=0):\n        if not self.full():\n            heapq.heappush(self.queue,(priority,item))\n    \n    def get(self):\n        if not self.empty():\n            self.queue.pop()\n\nmyq = MyQueue(4)\n\nmyq.put(123, 1)  # 优先级为 1\nmyq.put(456, 3)  # 优先级为 3\nmyq.put(789, 2)  # 优先级为 2\n\nprint(myq.queue)\n\ndate_only_queue = [item for _,item in myq.queue]\nprint(date_only_queue)","like_count":0},{"had_liked":false,"id":390049,"user_name":"键盘上的魔术","can_delete":false,"product_type":"c3","uid":2697700,"ip_address":"上海","ucode":"A731D721FB8D3A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","comment_is_top":false,"comment_ctime":1714226679,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100310001,"comment_content":"我看了题目，第一反应是要自己实现一个大顶堆，感觉有点杀鸡用牛刀。其实是直接参考源码，利用heapq模块的heappush和heappop。 其中heappush(self.queue, item)中的item是个(priority number, data)元组。 这里只要构建这个元组传入就行了","like_count":0},{"had_liked":false,"id":386955,"user_name":"你好极客时间","can_delete":false,"product_type":"c3","uid":2113412,"ip_address":"四川","ucode":"EC1AE9FD105234","user_header":"https://static001.geekbang.org/account/avatar/00/20/3f/84/47f7b661.jpg","comment_is_top":false,"comment_ctime":1705997311,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100310001,"comment_content":"from queue import PriorityQueue\n\nclass myqueue(object):\n\n    def __init__(self,que_len):\n        self.que_len=que_len\n        self.myqueue= PriorityQueue()\n\n    def put(self,pri,item):\n        self.myqueue.put((pri,item))\n\n\n    def get(self,item):\n        if not self.empty():\n            self.myqueue.get()\n    def print_queue(self):\n        while not self.myqueue.empty():\n            priority,item=self.myqueue.get()\n            print(priority,item)\n\n\nmyQueue = myqueue(1)\nmyQueue.put(3,123)\nmyQueue.put(1,234)\nmyQueue.put(2,456)\nmyQueue.print_queue()","like_count":0},{"had_liked":false,"id":368835,"user_name":"yanyu-xin","can_delete":false,"product_type":"c3","uid":1899757,"ip_address":"广东","ucode":"3AA389F9E4C236","user_header":"","comment_is_top":false,"comment_ctime":1676792777,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100310001,"comment_content":"import heapq ,copy\n\nclass MyQueue:\n    &#39;&#39;&#39;定义一个队列&#39;&#39;&#39;\n \n    def __init__(self, maxsize=10):\n        &#39;&#39;&#39;初始化队列长度&#39;&#39;&#39;\n        self.maxsize = maxsize\n        self.queue = []\n\n    def full(self):\n        &#39;&#39;&#39;队列最大长度&#39;&#39;&#39;\n        return 0 &lt; self.maxsize &lt;= len(self.queue)\n \n    def empty(self):\n        &#39;&#39;&#39;队列长度为 0&#39;&#39;&#39;\n        return not len(self.queue)\n \n    def put(self, item):\n        &#39;&#39;&#39;放入数据&#39;&#39;&#39;\n        if not self.full():\n            self.queue.insert(0, item)\n        print(self.queue)\n\n    def get(self):\n        &#39;&#39;&#39;取出数据&#39;&#39;&#39;\n        if not self.empty():\n            return self.queue.pop()\n\nclass MyPriorityQueue(MyQueue):\n    &#39;&#39;&#39;按优先级表处理列表&#39;&#39;&#39;\n    # 用堆排序处理，用库heapq\n\n    def __init__(self,maxsize=10):\n        &#39;&#39;&#39;初始化输入值队列&#39;&#39;&#39;\n        super().__init__(maxsize)\n        self.queue_a = []\n        self.queue_b = []\n\n    def pro_put(self,item):\n        &#39;&#39;&#39;放入数据&#39;&#39;&#39;\n        if not self.full():\n            self.queue_a.append(item)\n            self.pro_mer()\n\n    def pro_mer(self):\n        &#39;&#39;&#39;合并两个有序列表&#39;&#39;&#39;\n        # 用堆排序合并出来\n        self.queue = list(heapq.merge(sorted(self.queue_a), sorted(self.queue_b)))\n        self.queue_b = copy.deepcopy(self.queue)\n        self.queue_a = []\n\n\nmyq = MyPriorityQueue(10)\n \nmyq.pro_put(3423)\nmyq.pro_put(123)\nmyq.pro_put(456)\nmyq.pro_put(789)\nprint(myq.full())  # True\n\nprint(myq.get())\nprint(myq.get())\nprint(myq.get())\nprint(myq.empty()) # True","like_count":0},{"had_liked":false,"id":366656,"user_name":"Cy23","can_delete":false,"product_type":"c3","uid":1591293,"ip_address":"辽宁","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1674022101,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100310001,"comment_content":"参考源码如下\nclass PriorityQueue(Queue):\n    &#39;&#39;&#39;Variant of Queue that retrieves open entries in priority order (lowest first).\n\n    Entries are typically tuples of the form:  (priority number, data).\n    &#39;&#39;&#39;\n\n    def _init(self, maxsize):\n        self.queue = []\n\n    def _qsize(self):\n        return len(self.queue)\n\n    def _put(self, item):\n        heappush(self.queue, item)\n\n    def _get(self):\n        return heappop(self.queue)\n\n\n参考后修改如下：\nfrom heapq import heappush, heappop\n\nclass MyQueue:\n  &#39;&#39;&#39;定义一个队列&#39;&#39;&#39;\n  \n  def __init__(self, maxsize=10):\n    &#39;&#39;&#39;初始化队列长度&#39;&#39;&#39;\n    self.maxsize = maxsize\n    self.queue = []\n   \n  def full(self):\n    &#39;&#39;&#39;队列最大长度&#39;&#39;&#39;\n    return 0 &lt; self.maxsize &lt;= len(self.queue)   \n\n  def empty(self):\n    &#39;&#39;&#39;队列长度为 0&#39;&#39;&#39;\n    return not len(self.queue)\n   \n  def put(self,priority, item):\n    &#39;&#39;&#39;放入数据&#39;&#39;&#39;\n    if not self.full():\n      heappush(self.queue, (priority, item))\n      \n  def get(self):\n    &#39;&#39;&#39;取出数据&#39;&#39;&#39;\n    if not self.empty():\n      return heappop(self.queue)[1]\n\nmyq = MyQueue(3)\n\n# 优先级越小越先获取\nmyq.put(3, 123) #优先级3\nmyq.put(2, 456) #优先级2\nmyq.put(1, 789) #优先级1\nprint(myq.full())  # True\n\nprint(&quot;取出数据为%s&quot; % (myq.get()))\nprint(&quot;取出数据为%s&quot; % (myq.get()))\nprint(&quot;取出数据为%s&quot; % (myq.get()))\nprint(myq.empty()) # True","like_count":0}]}