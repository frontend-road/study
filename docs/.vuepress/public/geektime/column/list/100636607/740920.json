{"id":740920,"title":"第 12 章 Web 应用程序的基础知识","content":"\n    \n    <p>想必很多人通过本书学习 HTTP 的目的是开发 Web 应用程序。Web 应用程序作为服务器进行动作，通过 HTTP 通信进行输入和输出。有的 Web 应用程序会生成面向浏览器的 HTML，有的则会提供 Web\n        API，以供其他 Web 应用程序使用。</p>\n    <p>本章将介绍 Web 应用程序的全貌。当然，根据服务器类型的不同，API 和实现方针也会不一样。另外，因笔者水平有限，所以无法说本章内容可直接适用于所有的 Web 应用程序，敬请谅解。</p>\n    <h2 id=\"nav_point_287\">12.1　术语</h2>\n    <p>在讲解之前，我们先来整理一下相关术语。</p>\n    <blockquote>\n        <p><strong>客户端（浏览器）</strong></p>\n        <p>这是发送 HTTP 请求的应用程序。虽然也可以使用 curl 命令等发送 HTTP 请求，但由于本章是以 Web 服务为背景进行介绍的，所以这里假定为大家常用的浏览器。</p>\n        <p><strong>前端</strong></p>\n        <p>在浏览器上运行的由 HTML、JavaScript 和 CSS 组成的整套程序或数据。</p>\n        <p><strong>Web 服务器 /Web 应用程序</strong></p>\n        <p>Web 服务器（也称为服务器）接收 HTTP 请求，返回 HTML、JavaScript、CSS 等文件和 JSON 文件等。一些服务器包含更高级的逻辑，会根据请求返回动态结果，这种服务器称为 Web\n            应用程序服务器或 Web 应用程序。与前端相对，它也称为后端。另外，有的服务器是多层结构，这时也将接近浏览器的部分称为前端，将远离浏览器的部分称为后端。</p><!-- [[[read_end]]] -->\n    </blockquote>\n    <h2 id=\"nav_point_288\">12.2　基本流程</h2>\n    <p>无论什么样的 Web 应用程序，将其分解后，其结构都大致相同，即接收浏览器传递过来的“输入”，然后返回 HTML 或 JSON。大家还记得构成 HTTP 的 4 个数据容器吗？</p>\n    <blockquote>\n        <ul>\n            <li>方法和路径</li>\n            <li>首部</li>\n            <li>主体</li>\n            <li>状态码</li>\n        </ul>\n    </blockquote>\n    <p>它们是互相关联的。</p>\n    <p>我们先来看一个最简单的 Web 服务器的实现。使用 Go 语言的实现如代码清单 12-1 所示。</p>\n    <p><strong>代码清单 12-1　main.go</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"net/http\"\n    \"log\"\n    \"io\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) {\n        io.WriteString(writer, \"hello world\")\n    })\n    // 启动服务器，在 8080 端口等待\n    log.Println(\"Start running server at :8080\")\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}</code></pre>\n    <p>这样就启动了服务器。打开浏览器，输入 <code>localhost:8080</code> 地址，浏览器上就会显示出文本 <code>hello world</code>。</p>\n    <pre class=\"code-rows\"><code>$ go run main.go\n2018/12/27 10:08:06 Start running server at :8080</code></pre>\n    <p>我们再用 Python 来实现一下。方便起见，代码清单 12-2 使用了 Web 应用程序框架 Bottle。</p>\n    <pre class=\"code-rows\"><code>$ pip install --user bottle</code></pre>\n    <p><strong>代码清单 12-2　main.py</strong></p>\n    <pre class=\"code-rows\"><code>from bottle import route, run\n\n@route('/')\ndef hello():\n    return \"hello world\"\n\n# 启动服务器，在 8080 端口等待\nrun(port=8080, debug=True)\n\n\n$ python main.py\nBottle v0.12.16 server starting up (using WSGIRefServer())...\nListening on http://127.0.0.1:8080/\nHit Ctrl-C to quit.</code></pre>\n    <p>Node.js 的实现如下所示。这里使用了 Web 应用程序框架 Express。</p>\n    <pre class=\"code-rows\"><code>$ npm init -y\n$ npm install express\n\n\nconst express = require('express');\n\nconst app = express();\n\napp.get('/', (req, res) =&gt; {\n    res.send('hello world');\n});\n\napp.listen(8080, () =&gt; {\n    console.log('Start running server at :8080');\n});\n\n\n$ node main.js\nStart running server at :8080</code></pre>\n    <p>这些实现所进行的处理是一样的，都是在 8080 端口等待浏览器的请求。在接收到浏览器对 <code>http://localhost:8080</code> 的请求后，已注册的 <code>GET</code> 方法的\n        Handler 会被调用。在 Handler 中，Web 服务器会将 <code>hello world</code> 文本放到主体中，并返回响应。浏览器将主体中的文本直接显示在画面上（图 12-1）。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00430.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-1　简单的 Web 服务器</strong></p>\n    <p>不过，浏览器并不知道对方是返回静态文件的服务器，还是动态生成内容的 Web 应用程序服务器。</p>\n    <h2 id=\"nav_point_289\">12.3　Web 应用程序的请求的生命周期</h2>\n    <p>在 Web 应用程序中有几种不同粒度的生命周期。<strong>生命周期</strong>是指从出生到死亡的整个过程，它并不是 Web 的专有名词。在进行调试等的情况下，我们就是以生命周期为单位来确认处理是否在中途停止的。\n    </p>\n    <h3 id=\"nav_point_290\">12.3.1　HTTP 请求</h3>\n    <p>我们先来看一下 HTTP 的一次通信，这是请求的最小单位的生命周期。该生命周期从浏览器向服务器发送请求开始，到服务器返回响应结束。</p>\n    <p>浏览器发送的请求包含方法、首部和主体。首先，在接收 HTTP 请求的套接字中，当有 HTTP 请求传递过来时，Web 应用程序的框架会创建请求和响应这两个对象，它们在生命周期结束之前都可以使用。</p>\n    <blockquote>\n        <ul>\n            <li>在 Handler 内部，在访问浏览器发送过来的数据时，使用请求对象。路径、查询和首部等数据保存在该请求对象中</li>\n            <li>在写入从 Handler 内部返回给浏览器的数据时，使用响应对象。状态码、首部和主体等数据保存在该响应对象中</li>\n        </ul>\n    </blockquote>\n    <p>所有的软件都可以分解为包含输入和输出的小的代码。在 Web 应用程序中，包含开发人员编写的逻辑的部分称为 Handler。</p>\n    <p>在创建好这两个对象之后，框架会根据路径和方法（默认为 <code>GET</code>）来决定调用哪个\n        Handler。这种分配调用目标的组件有“调度器”“中继器”“多路选择器”等名称（根据框架的不同，名称也不一样，本书中统称为“调度器”）。如果服务需要登录，框架就会查看首部，以调用向登录页面跳转的 Handler。</p>\n    <p>Handler 根据用户的操作使程序进行动作，由 Web 服务开发人员实现。例如，根据查询来编写对数据库进行操作的 SQL，然后查找数据，并将查询结果作为 JSON 返回给浏览器。在这种情况下，Handler 会将 JSON\n        结果传递给响应对象。将响应首部的 <code>Content-Length</code> 设置为字节数，将 <code>Content-Type</code> 设置为表示 JSON 的\n        <code>application/json</code>。</p>\n    <p>最后，框架将响应中写入的状态码（正常结束时为 <code>200 OK</code>）、首部和主体等写入套接字。写入套接字中的内容会返回给浏览器，由浏览器显示并使用。</p>\n    <p>从 Web 应用程序接收请求开始到向浏览器返回响应为止的生命周期大致如图 12-2 所示。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00431.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-2　从 Web 应用程序接收请求到返回响应为止的生命周期</strong></p>\n    <h3 id=\"nav_point_291\">12.3.2　会话</h3>\n    <p>Web 服务还存在跨多个请求的生命周期，那就是<strong>会话</strong>。</p>\n    <p>HTTP 的各个请求都是独立的、无状态的，但在某些情况下，如果知道“这个请求和那个请求是同一个用户的请求”会更加方便。想象一下，如果不保存用户信息或购物车中加入的商品，每次都需要在商品页面输入所有信息来购物，那是不是非常不便？\n    </p>\n    <p>浏览器使用 Cookie 来保存跨多个请求的信息，会话就是利用这一点实现的。当浏览器第一次访问时，服务器会将 Cookie 传递给浏览器。在之后的访问中，浏览器会返回针对该服务器设置的 Cookie。利用 Cookie\n        结构，服务器就可以判断访问是否来自同一个用户，即是否为同一个会话。</p>\n    <p>笔者先来介绍一下最简单的、将所有信息都放入 Cookie 中的通信方式，如图 12-3 所示。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00432.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-3　所有信息都放入 Cookie 中的通信方式</strong></p>\n    <p>在第一次认证之后，服务器会汇总用户 ID 等信息，并将其作为 Cookie 返回给浏览器。在使用了由 Web 应用程序服务器提供的 Cookie 的会话管理结构中，由于 Cookie\n        中有签名，所以信息无法被篡改。之后，在浏览商品页面时，用户信息每次都会被发送给服务器。服务器会根据用户 ID 来查找地址，并在页面上显示运费信息，非常方便。</p>\n    <p>如果添加商品，那么它也会作为 Cookie 返回给浏览器。在用户清空购物车或购买之前，这些信息会一直保存在 Cookie 中。像这样，当想保存仅在会话期间有效的数据时，可以关联会话信息来保存数据。</p>\n    <p>我们再来看一下其他方式的会话管理，如图 12-4 所示。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00433.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-4　其他方式的会话管理</strong></p>\n    <p>在该结构中，在登录之后，服务器会返回随机 ID。即使查看该 ID，我们也无法直接获取用户 ID。数据库会将该 ID\n        作为键，每当应用程序收到请求时，就会从数据库中取出信息，供服务器使用。不过，浏览器是看不到这些的。在这种情况下，也可以在数据库中保存仅在会话期间有效的数据。</p>\n    <p>以前，像这样只返回 ID 的方式是主流。在这种情况下，购物车信息等仅在会话期间有效的数据也保存在数据库中。每当有请求时，服务器就会访问会话数据库。另外，服务器只是根据键获取信息，并不会用到表的 JOIN\n        等。因此，虽然这里的数据库也会使用关系数据库，但使用 Memcached 和 Redis 等高速 NoSQL 的情况也不少。</p>\n    <p>还有一种方式是将数据保存在测试用的本地应用程序服务器的内存中，但这种方式不能用于实际环境中。在服务器重启后，数据就会消失，而且一台服务器的内存无法与其他服务器共享，因此，我们也不能增加服务器。</p>\n    <p>在许多 Web 应用程序框架中，这种与会话相关联的、保存访问用户信息的结构，称为<strong>会话存储</strong>。不管是保存在 Cookie 中的结构，还是保存在 Redis 等 NoSQL 中的结构，还是保存在\n        RDB 中的结构，抑或是不保存（On-Memory）的结构，都是会话存储。</p>\n    <p>最后，我们整理一下各种会话存储的特征（表 12-1）。</p>\n    <p><strong>表 12-1　各种会话存储的特征</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>管理方式</p>\n                </th>\n                <th>\n                    <p>保存位置</p>\n                </th>\n                <th>\n                    <p>优点</p>\n                </th>\n                <th>\n                    <p>缺点</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p>Cookie 保存</p>\n                </td>\n                <td>\n                    <p>浏览器的 Cookie</p>\n                </td>\n                <td>\n                    <p>• 可在服务间共享<br />• 无须准备存储器</p>\n                </td>\n                <td>\n                    <p>• 容量受限<br />• 服务器无法清除会话</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>数据库保存（RDB、NoSQL、Memcached）</p>\n                </td>\n                <td>\n                    <p>浏览器中保存 ID，数据库中保存数据</p>\n                </td>\n                <td>\n                    <p>• 容量不受限制<br />• 服务器可以清除会话</p>\n                </td>\n                <td>\n                    <p>• 需要准备存储器<br />• 会访问数据库</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>内存保存</p>\n                </td>\n                <td>\n                    <p>浏览器中保存 ID，服务器的内存中保存数据</p>\n                </td>\n                <td>\n                    <p>• 容量不受限制<br />• 服务器可以清除会话<br />• 无须准备存储器</p>\n                </td>\n                <td>\n                    <p>• 专门用于本地测试环境<br />• 在服务器重启后，数据会消失</p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <h2 id=\"nav_point_292\">12.4　Web 应用程序的动作模式</h2>\n    <p>与基于静态 HTML 文件的网站不同，Web 应用程序是页面内容根据数据库中存储的信息而变更的服务。根据将该变更反映到 HTML 中的方式的不同，Web 应用程序的动作模式有以下几种。</p>\n    <h3 id=\"nav_point_293\">12.4.1　第 1 代：服务端渲染</h3>\n    <p><strong>服务端渲染</strong>（Server Side Rendering，SSR）这一名称是最近才开始使用的，由于当时只有这一种方式，所以并没有人专门使用这一称呼。</p>\n    <p>如图 12-5 所示，服务端渲染将访问数据库等而获取的数据注入模板中，形成 HTML。模板包含 Text::Xslate、erb、Jinja2、EJS、JSP、JSF\n        等不同语言和框架的模板引擎，服务器将从数据库中获取的数据设置到各模板的变量或数组中，生成一个 HTML 文件，并通过 HTTP 返回给浏览器，由浏览器显示该 HTML 文件。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00434.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-5　服务端渲染</strong></p>\n    <p>如果仅看 HTTP 通信，就是浏览器请求页面，获取服务器返回的 HTML 响应并显示。因此，浏览器无法区分静态 HTML 和服务端渲染。</p>\n    <p>不同的模板引擎有不同的功能，但基本上包含如下功能。</p>\n    <blockquote>\n        <ul>\n            <li>输出变量</li>\n            <li>循环</li>\n            <li>条件判断代码块（根据条件来决定是否显示）</li>\n            <li>输出代码块</li>\n            <li>包含文件</li>\n        </ul>\n    </blockquote>\n    <p>并不是说必须使用模板引擎，只要最终能生成 HTML，使用什么方法都可以。说得极端一点，只要是能够进行字符串拼接的语言（不过也很难找到不能进行字符串拼接的语言吧），就能生成\n        HTML。不过，要想将视图与逻辑分开，方便与设计人员协作，模板引擎还是必不可少的。另外，使用合适的模板引擎还能够减少 XSS 引起的安全漏洞。</p>\n    <p>另外，许多框架还拥有针对数据库的查询生成器和 OR 映射组件。</p>\n    <p>在表单出现之前，我们只能使用在查询中加载信息的 <code>GET</code> 方法来发送信息，在表单出现之后，就也可以使用 <code>POST</code> 方法来发送信息了。</p>\n    <h3 id=\"nav_point_294\">12.4.2　第 2 代：Ajax</h3>\n    <p>之后，前端出现了使用 JavaScript 动态更新网站的潮流。Internet Explorer 中引入了 XMLHttpRequest 这一 API，并实现了标准化。</p>\n    <p>XMLHttpRequest 组件在 Web 2.0 中起到了核心作用。在此之前，在接收到服务器的响应后，网站的画面会被清除，浏览器会重新渲染新页面。在使用 XMLHttpRequest 的情况下，由于 JavaScript\n        已经完成了数据的发送和接收，所以我们可以在不清除画面的情况下从服务器获取最新信息。这种读取 Web 页面时不清除画面、错开时间多次进行更新的架构叫作 <strong>Ajax</strong>（Asynchronous\n        JavaScript And XML，异步 JavaScript 和 XML）。相信不少人听说过这个名称。使用 Ajax 功能获取 JSON 等，并显示信息（图 12-6）。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00435.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-6　Ajax</strong></p>\n    <blockquote>\n        <p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00380.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　虽然 Ajax 的全称中包含 XML，但近年来我们主要使用\n            JSON。</p>\n    </blockquote>\n    <p>在第 1 代的服务端渲染中，浏览器在重新加载时会向服务器发送请求，并更新页面。在这种情况下，浏览器会根据链接读取新页面，或者在重新加载完之前不更新页面内容。</p>\n    <p>论坛等的页面是整体进行动态读取的，而有的网站则是定期访问服务器，以确认是否存在更新信息，基本上是实时更新页面。另外，有的网站不仅会动态接收信息，还会动态发送信息。</p>\n    <p>在 Ajax 中，在使用 JavaScript 访问服务器时会用到 XMLHttpRequest。Ajax 中还新增了 Server-Sent Events、WebSocket 和 Fetch 等通信 API，并实现了标准化。\n    </p>\n    <p>发送 HTML 等的服务器也会提供 Ajax 访问的 API。常见的模式是，指定的 URL 路径后面就是 Web API 的路径。假设<code>××××.com/api</code> 后面是 API，如果在这里使用\n        <code>GET</code> 或 <code>POST</code> 方法发送请求，服务器就会返回 JSON。</p>\n    <p>此外，有时 <code>api.××××.com</code> 等子域也会提供 API，有时其他域也会提供 API。</p>\n    <p>最开始读取的 HTML 可以是使用服务端渲染的 HTML，也可以是静态 HTML。</p>\n    <p>在此前的 Web 应用程序开发中，以使用 Python 和 Ruby 等的服务器端的实现为主，其次是 HTML 和 JavaScript。使用 HTML 和 JavaScript\n        编写的浏览器端的程序也是通过服务器的静态文件发送功能发送给浏览器的。</p>\n    <p>不过，Ajax 使得前端 JavaScript 的工作不断增加。由此，代码逻辑越来越复杂，代码量也变大。最开始只需使用 jQuery 稍微加工一下 DOM，或者使用 jQuery UI 创建 UI\n        就可以了，但后来为了赋予前端状态管理的功能，出现了 Backbone.js 和 Knockout.js 等客户端 MVC，这些客户端 MVC 也在不断发展。</p>\n    <h3 id=\"nav_point_295\">12.4.3　第 3 代：单页面应用</h3>\n    <p>后来出现了用于开发更大规模的应用程序的 React、Vue.js 和 Angular 等库。React 引入了虚拟 DOM 结构，能够针对数据的变化快速进行更新，因此受到了人们的青睐。Vue.js 从版本 2 开始也引入了虚拟\n        DOM。</p>\n    <p>持有虚拟 DOM 结构的框架可以轻松地绘制画面的变化部分，还可以以组件形式来替换模板。在基于获取的数据来更新 HTML 这一点上，第 3 代与第 2 代相似，但第 2 代大多是一边解析 HTML 的内容，一边加工\n        HTML，而第 3 代则是在内部生成 HTML，单向改写 DOM。由于基本上不再需要基础的 HTML，所以最开始会读取仅加载 JavaScript 代码的、几乎为空的 HTML（图 12-7）。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00436.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-7　单页面应用</strong></p>\n    <p>另外，虚拟 DOM 是内部结构，程序员接触不到它。Angular 并不使用虚拟 DOM，但它可以动态创建几乎所有的 DOM，使用起来也很方便。</p>\n    <p>Router 库封装了浏览器的 History API。在使用 Router\n        库的情况下，当从父页面跳转到子页面时，浏览器可以在不清除画面（不显示全白画面）的前提下快速更新页面，看起来就像是通过切换浏览器地址栏的显示而使页面发生了跳转一样。</p>\n    <p>为了发送单页面应用，在前端的服务器或 CDN 中，我们要设置成无论请求什么 URL，都可以返回与首页相同的 HTML 文件。</p>\n    <blockquote>\n        <p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00380.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　关于服务器设置，单页面应用框架 Angular\n            的官网上进行了详细介绍。</p>\n    </blockquote>\n    <p>这样一来，浏览器就能够更快地更新页面。例如，我们将光标移到子页面的跳转链接上，在点击之前，浏览器就会向服务器请求子页面的内容，在点击的瞬间，子页面就会立即显示出来。这在第 1\n        代中是无法实现的，因为只有在点击链接之后，浏览器才会向服务器发送请求，服务器在创建好画面后返回给浏览器。在第 2 代中，当页面的更新内容较少时，无须重置画面，而如果要完全改写页面内容，则重置的做法会好一些。在第 3\n        代中，库的易用性大幅提高，状态管理也没有那么麻烦，因此能够实现更多的操作。</p>\n    <p>另外，由于 Backbone.js 中持有 Router，所以在虚拟 DOM 出现之前，使用 Backbone.js 就能够实现单页面应用，不过为此要创建很多控件。在 React、Vue.js 和 Angular\n        出现之后，库和生态系统也以面向单页面应用为前提进行设计，因此大家可以使用通用的做法来实现单页面应用。</p>\n    <h3 id=\"nav_point_296\">12.4.4　第 3.5 代：单页面应用+服务端渲染</h3>\n    <p>前端的代码量变得越来越多。为了保持兼容性，前端的 JavaScript 会绑定一些库来补充旧版本浏览器不支持的功能（称为 Polyfill），通常是安装他人编写的经过验证的库，不再自己直接编写代码。</p>\n    <p>单页面应用的页面切换速度很快，但首次显示时需要花费一些时间。在下载完大量的 JavaScript 代码之前，画面为全白。</p>\n    <p>为了解决这个问题，可以使用将单页面应用与服务端渲染相结合的方法。在第一次请求时，在服务器端执行单页面应用的代码，动态创建 HTML 文件，并将其返回给浏览器。该 HTML\n        中的标签就是作为单页面应用在浏览器上显示的内容。不过，该 HTML 只是页面显示，并不包含单页面应用中执行的事件处理器。即使切换页面，HTML 的内容也与一开始在服务器端创建的 HTML\n        的内容是一样的，看起来不会有什么变化，但它可以响应用户的操作事件（图 12-8）。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00437.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-8　单页面应用 + 服务端渲染</strong></p>\n    <p>虽然到能够操作为止的时间没有发生变化，但如果将用户的（直到页面显示出来的）等待时间也考虑在内，就会发现用户体验得到了改善。这就是引入服务端渲染的好处。</p>\n    <p>这种结构虽然看起来很复杂，但现在我们有了方便实现服务端渲染的框架，那就是基于 React 的 Next.js 和基于 Vue 的 Nuxt.js。使用这些框架，就可以轻松实现带服务端渲染的单页面应用。</p>\n    <blockquote>\n        <p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00380.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　至此，笔者分别介绍了第 1 代至第 3.5 代的 Web\n            应用程序的动作模式，但并不是说最新的就是最优的。在第 3.5 代的服务端渲染中，在服务器的技术栈方面存在很大限制，实现难度较大，且耗时耗力。另外，有报道称 Netflix 放弃采用 React 之后，响应速度提高了\n            50%。根据所使用的应用程序、要求和性能的不同，最优方法也会有所不同。</p>\n    </blockquote>\n    <h2 id=\"nav_point_297\">12.5　基础设施的结构</h2>\n    <h3 id=\"nav_point_298\">12.5.1　开发环境</h3>\n    <p>Web 应用程序服务器基本上具有 Web 服务器的功能，可以独自运行。我们在开发时可以利用该功能进行显示测试。在 Java 中，之前的做法是启动 Tomcat 等 Servlet 引擎，加载 Servlet 应用程序来执行\n        Web 应用程序，而现在 Spring Boot 中嵌入了 Tomcat，开发环境的结构与其他编程语言相同（图 12-9）。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00438.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-9　开发环境的结构</strong></p>\n    <p>对于 HTML 文件、JavaScript 文件、CSS 文件和图像文件等，我们可以利用 Web 应用程序服务器的静态文件发送功能，当执行 HTTP 访问时，返回本地指定文件夹（多为 static 或 public\n        这样的名称）中的文件，模拟实际环境。</p>\n    <p>在由 JavaScript 实现的前端应用程序占比越来越大后，前端的 JavaScript 和 CSS 也可以像 Java 一样，使用编译工具进行编译。</p>\n    <p>在 JavaScript 中使用 webpack 等打包器将由 Babel 或 TypeScript 等编译器 <span class=\"comment-number\">1</span> 分割的较小的脚本文件转成兼容性较高的 JavaScript\n        代码，将多个 JavaScript 文件打包成块（图 12-10）。在 CSS 中，也可以使用 sass 和 PostCSS 等来实现文件分割、变量处理和跨浏览器兼容等处理。</p>\n    \n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00439.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-10　加入了 webpack 等打包器的开发环境</strong></p>\n    <p>webpack 和 Parcel\n        等打包器中引入了<strong>编译服务器</strong>结构，缩短了编译时间。编译服务器监视开发环境的磁盘中的源代码，当检测到源代码的更新时，会自动进行编译。为了能够立即生成最新的代码，编译服务器都运行在\n        On-Memory 中。</p>\n    <p>另外，编译服务器除了进行编译之外，在将编译完的脚本发送给浏览器时，还会嵌入用于自动加载的代码。这些代码会定期检查编译服务器中是否有更新。在进行编译时，浏览器会立刻检测到更新，并自动加载最新的代码。这样一来，从文件的更新到显示都是自动执行的，这就叫作<strong>热加载</strong>。\n    </p>\n    <p>Next.js 可以在保持前端状态的同时，替换组件的代码。代码修改所引起的显示上的细微改变会直接动态反映在表单中输入的数据上，这称为<strong>模块热替换</strong>。</p>\n    <p>像这样，随着前端的结构变复杂，开发环境的结构中也开始重视前端。近几年的结构都是将前端用的开发服务器置于前面，将特定路径之后的 Web API 代理到后面的服务器（图 12-11）。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00440.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-11　重视前端的开发环境</strong></p>\n    <h3 id=\"nav_point_299\">12.5.2　实际开发环境的基本结构</h3>\n    <blockquote>\n        <p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00380.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　本节将着重讲解 Web 服务的 HTTP\n            通信和静态文件的发送。实际上，由于要添加一些工具或中间件，以便监控进程状态、收集日志信息，以及进行版本升级等，所以实际的应用程序结构会比较复杂。</p>\n    </blockquote>\n    <p>由于开发服务器本身并不能发挥出足够的性能，所以通常会先配置 Apache 或 Nginx 等高速 Web 服务器来接收浏览器的请求，让 Web 应用程序运行在这些 Web 服务器的后台。</p>\n    <p>静态文件的发送通过前台的服务器进行，只有动态内容的创建才在后台的 Web 应用程序中进行。在 Web 服务器和 Web 应用程序之间使用 Fast CGI 等独立于语言的协议，或者在 Apache 和 Nginx\n        中安装语言专用的模块并使用，或者使用高速的用于内部通信的 UNIX 域套接字进行连接。</p>\n    <p>随着 Web 服务开发的普及，除了主要的编程语言 Java\n        之外，使用脚本语言的机会也大大增加。通过根据需要进行扩展，能够确保应用程序整体的处理能力，因此现在人们倾向于使用一些能够快速实现的语言以抓住商机，其中，Python、Ruby、PHP 和 Node.js 等语言受到热捧。对于\n        Go 和 Java，除了静态文件的发送之外，其环境与开发环境一样也没有问题，而这些脚本语言根据实际情况会使用 GIL（Global Interpreter\n        Lock，全局解释器锁）功能，将同时执行的线程限定为一个。因此，在实际环境中使用脚本语言时，为了实现并行处理，就需要能够启动多个进程的环境。根据语言的不同，实现方法也不一样。</p>\n    <p>PHP 中会启动 fast-cgi 客户端 php-fpm，在该客户端中能够启动多个 PHP 进程，来处理大量请求（图 12-12）。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00441.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-12　PHP 中开发环境的结构</strong></p>\n    <p>Ruby 中拥有用于和其他 Web 服务器连接的 Rack 接口。常见的做法是，在前台放置启动工作进程的 Unicorn、Puma 和 Passenger 等服务器，并通过 Rack 与后台的服务器连接，以此来提高性能（图\n        12-13）。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00442.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-13　Ruby 中开发环境的结构</strong></p>\n    <p>Python 中的结构大致分为 3 种。</p>\n    <p>Python 中拥有 WSGI（Web Service Gateway Interface，Web 服务器网关接口）。先启动 WSGI 的一种实现 uWSGI，然后在后台启动多个 Python 进程作为工作进程，并使用\n        Nginx 和 uwsgi 协议直接连接。uWSGI 与 Python 进程之间使用 WSGI 连接（图 12-14）。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00443.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-14　Python 中开发环境的结构（其 1）</strong></p>\n    <p>在 Python 中，有的服务器可以使用异步 I/O 来提高每个 CPU 内核的套接字的输入和输出的吞吐量。比较常见的结构是，在启动多个工作进程的 gunicorn 的后台，启动高速 WSGI 服务器，使用轻量线程来处理异步\n        I/O——meinheld，然后启动应用程序服务器（图 12-15）。meinheld 以事件驱动的方式进行动作，在内核中等待并行执行的请求处理。在该结构中，使用 epoll 和 kqueue\n        等内核功能，通过轻量线程并行执行“等待套接字，直到能够接收”“到可以发送为止一直等待”等处理，以此来实现网络效率的最大化（事件驱动）和 CPU 效率的最大化（并行处理）。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00444.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-15　Python 中开发环境的结构（其 2）</strong></p>\n    <p>从 Python 3 开始，标准库中新增了实现异步 I/O 的 <code>asyncio</code> 模块，也出现了使用面向异步应用程序的 ASGI 协议来启动 Web 应用程序的方法。如图 12-16 所示，启动\n        ASGI 服务器 uvicorn，然后在后台启动多个 Web 应用程序进程，并通过 ASGI 连接。Web 应用程序框架 Django 就是使用 ASGI 来支持 WebSocket 的。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00445.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-16　Python 中开发环境的结构（其 3）</strong></p>\n    <p>Node.js 中使用进程管理器 PM2。Node.js 从一开始就在语言的运行时层实现了异步 I/O 功能，而 Node.js 的 JavaScript 解释器只可以运行在单核中。如图 12-17 所示，PM2\n        作为主节点运行，并启动与核心数相同数量的 Node.js 进程来实现负载均衡，以此提升多核 CPU 的性能。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00446.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-17　Node.js 中开发环境的结构</strong></p>\n    <p>另外，无论哪一种结构，静态文件大多是从前台的 Web 服务器、CDN 或者不同子域的主机上发送的。</p>\n    <h2 id=\"nav_point_300\">12.6　基础设施的其他形式</h2>\n    <p>除了前面介绍的基本结构之外，基础设施还有其他几种形式。不过，这些形式只不过是人们对已发布的服务进行的分类，它们之间的界线也不是很明确。下面笔者将简单地介绍一下。</p>\n    <h3 id=\"nav_point_301\">12.6.1　PaaS</h3>\n    <p>前面介绍的形式都是在操作系统中安装中间件、语言或库等来构建服务器。由于语言和各种工具都已经安装完毕，所以 Web 服务只要部署并执行该平台专用的代码就可以了。</p>\n    <p>相信不少人听说过 Google App Engine、Heroku 等，这些平台统称为 <strong>PaaS</strong>（Platform as a\n        Service，平台即服务）。操作系统和实例的管理等基础设施结构都可以交由 PaaS 来实现，PaaS 也能实现负载均衡。开发人员只需部署应用程序代码，就可以构建应用程序。</p>\n    <p>虽说是“平台专用的代码”，但实际上各种语言常用的 Web 应用程序框架基本上可以直接使用 <span class=\"comment-number\">2</span>，存储相关的处理使用的也都是原始的 API。</p>\n    \n    <p>Google App Engine 推出了可以使用容器来设置运行时的 Flexible Environment。另外，在 Go 1.11 的 Standard Environment 中可以执行 Linux\n        二进制应用程序，各平台的特色正在逐渐消失。</p>\n    <h3 id=\"nav_point_302\">12.6.2　Serverless</h3>\n    <p>近年来，<strong>Serverless</strong><span class=\"comment-number\">3</span> 引起了人们的关注。所谓 Serverlss，并不是指没有服务器，而是指没有自己管理的服务器，现实中大多是指\n        Amazon Web Service（AWS）的 Lambda、Google Cloud Platform 的 Cloud Functions 等服务，而有时服务器也会根据需要启动存储引擎等，这使得作为对象的服务越来越多。\n    </p>\n    \n    <p>Serverless 最初是为了使用通用语言编写响应处理，比如向计时器或存储器进行写入时的批处理等。Serverless 通过在处理时将结果写入存储器中，可以连锁启动其他 Serverless\n        的处理，还可以实现工作流。可以设置一个 Web 应用程序服务器，当有请求时，使 Serverless 像普通的 Web 服务一样运行。AWS 中还出现了 Amazon Aurora Serverless 这一存储服务。\n    </p>\n    <p>有了云服务之后，我们可以根据负载自动增加或减少实例个数，但在通常情况下，为了提供服务，至少要启动一台服务器，还需要根据负载来设置增加服务器的策略。Serverless 则无须关心后台运行的实例个数。从 Web\n        服务的角度来看，当有请求时，就启动服务进行处理，在处理结束后，服务也随之结束。在基本上没有访问时，运行的实例个数也会变为 0，不消耗运行成本。</p>\n    <h3 id=\"nav_point_303\">12.6.3　微服务</h3>\n    <p>近年来，我们经常会听到<strong>微服务</strong> <span class=\"comment-number\">4</span> 一词。微服务的设计方针是不创建大的服务，而是通过组合小的服务来创建服务。微服务因被 Amazon 和\n        Netflix 等公司引入而名气大增。</p>\n    \n    <p>在微服务中，每一个服务都是小的 Web 应用程序服务器。我们先来看一下微服务专有的术语，如下所示。</p>\n    <blockquote>\n        <ul>\n            <li>服务发现：用来查找其他协作的服务</li>\n            <li>断路器：防止服务发生连锁故障</li>\n            <li>服务网格：协调复杂服务之间的网络</li>\n        </ul>\n    </blockquote>\n    <p>微服务的关注度很高，市面上也出现了一些微服务的相关图书，但关于如何设计和处理事务、如何保持向后兼容、如何高效创建大型应用程序等问题还没有形成方法论，技术上还存在一定难度。</p>\n    <h2 id=\"nav_point_304\">12.7　Web 应用程序的内部层次结构</h2>\n    <p>最近的 Web 应用程序框架中经常会出现<strong>中间件</strong>这个概念。</p>\n    <p>本章开头介绍过，返回给浏览器的响应是由 Handler 创建的。那么，是不是与响应相关的所有处理都是在 Handler\n        中执行的呢？答案是“并不一定”。另外，比如在请求处理中也会解析是否包含登录信息的首部等，有一些处理在每次请求时都会执行，而 Web 应用程序中的中间件就是使这些通用的处理能够重用的结构。</p>\n    <p>提到中间件，或许有人会认为它是 WebSphere MQ 那种单独的服务（往往需要昂贵的授权费），但其实与这些服务相比，框架内部的中间件非常简单。</p>\n    <p>中间件是在 Handler 之前或之后执行的过滤器。这种过滤器分为多层，可代替 Handler 的处理，让代码变简单。虽然 Java 的 Servlet 和 Python 的 WSGI 也是中间件，但最纯粹的中间件还是\n        Node.js 的 Express。Express 在默认情况下只是将首部按项目进行分类，其中的处理都打包成了各个中间件。</p>\n    <p>例如，cookieParser 用来解析 Cookie 的首部，并将其转换成程序易于处理的形式。bodyParser 会查看 <code>Content-Type</code> 首部，如果是 JSON，就将其转换成\n        JavaScript 的本地数据结构（数组、对象、字符串、数值、布尔型等）。如果使用 multer 等支持 Multipart\n        的中间件，我们就可以在文件上传之后，将文件写入到磁盘中，并将写入的路径信息赋给请求对象。除此之外，在未登录的用户发起访问时，可以使用 <code>passport</code>\n        库重定向到登录页面，也可以处理登录请求并完成登录，还可以从会话存储中读取用户信息等。还有一些中间件可以在输出的首部中加入安全方面的各种首部，还有可以在入口和出口收集访问记录的中间件。</p>\n    <p>代码清单 12-3 是一个较大的 Web 应用程序的示例代码，其中使用 <code>express()</code> 创建的对象是 Web 应用程序的顶层元素。<code>.get()</code> 和\n        <code>.post()</code> 用于在指定的 URL 中注册 Handler。<code>.use()</code> 方法用来挂载各种中间件。</p>\n    <p>另外，<code>express.Router()</code> 用于创建调度器。调度器也可以使用 <code>.use()</code> 方法挂载到指定的 URL 下面。我们也可以添加仅在该调度器下使用的中间件。</p>\n    <p><strong>代码清单 12-3　Express 中间件</strong></p>\n    <pre class=\"code-rows\"><code>// 标准库的底层 HTTP 服务器\nconst http = require(\"http\");\n// Web 应用程序框架\nconst express = require(\"express\");\n// 下面全部是中间件\nconst morgan = require(\"morgan\");\nconst helmet = require(\"helmet\");\nconst compression = require(\"compression\");\nconst bodyParser = require(\"body-parser\");\nconst cookieParser = require(\"cookie-parser\");\nconst csrf = require(\"csurf\");\n\nconst server = express();\n// 请求的 URL、方法和记录处理时间等的日志中间件\nserver.use(morgan(\"short\"));\n\n// 设置安全首部的中间件\nserver.use(helmet({\n    ieNoOpen: false\n}));\n// 压缩响应内容的中间件\nserver.use(compression());\n\n// 用于查找的 Handler\nserver.get(\"/search\", (req, res) =&gt; {\n    ︙\n    res.send(result);\n});\n\n// 用于指定的 URL 的调度器\n// 也可以挂载仅在这里使用的中间件\nconst router = express.Router();\n// 当 JSON 格式的主体发送过来时，对其进行解析，并转换为 JavaScript 对象格式\nrouter.use(bodyParser.json());\n// 将 Cookie 转换为 JavaScript 对象格式\nrouter.use(cookieParser());\n/// 发行 CSRF 令牌的中间件\nrouter.use(csrf({ cookie: true }));\n\n// 处理针对/api/user 的 POST 方法的 Handler\nrouter.post(\"/user\", async (req, res) =&gt; {\n    ︙\n    // 返回 JSON\n    res.send();\n});\nserver.use(\"/api\", router);\n\n// 启动服务器\nhttp.createServer(server).listen(8000);</code></pre>\n    <p>在 Express 中，调度器也可以按登录顺序执行。如果匹配指定的 URL，Handler 就会被调用。另外，如果到结束为止都未执行任何处理，那么通常会调用默认的 Handler，返回错误。</p>\n    <p>像这样，层叠使用中间件这种小的过滤器来定制整个服务，这是 Web 应用程序框架常见的实现方式。</p>\n    <p>另外，Node.js 的中间件就是函数，实现起来很简单。</p>\n    <pre class=\"code-rows\"><code>// 用于设置 HSTS 首部的自制的中间件\n// 中间件就是 Express 中的函数\nserver.get(\"/*\", (req, res, next) =&gt; {\n    res.header(\"Strict-Transport-Security\", \"max-age=2592000\");\n    next();\n});</code></pre>\n    <p>中间件的动作大致如图 12-18 所示。不过，就 Express 来说，该图有一部分是不正确的。在该图中，响应首部的设置是在结束时执行的，而实际上是在入口处执行的。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00447.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 12-18　中间件的动作</strong></p>\n    <p>与 Servlet、WSGI 和 Koa（基于 Node.js 的框架）等不同，如果在 Express\n        中间件中直接使用函数定义，那么只能在入口处执行处理。为了解决这个问题，有的库会利用一些技巧在结束时进行钩取，有的中间件也会在结束时进行钩取。具体来讲，使用记录日志的 <code>morgan</code>\n        库计算入口和出口之间花费的时间，并将其输出到日志中。另外，执行压缩的 compression 中间件是通过覆盖响应的方法来实现的。</p>\n    <h2 id=\"nav_point_305\">12.8　Web 应用程序的组成元素的详细分类</h2>\n    <p>本书中反复提到了 4 个数据容器。Web 应用程序基于这些数据容器执行服务器的逻辑，并返回结果。这些数据容器中既有浏览器发送给服务器的内容，也有服务器返回给浏览器的内容。</p>\n    <blockquote>\n        <ul>\n            <li>方法和路径</li>\n            <li>首部</li>\n            <li>主体</li>\n            <li>状态码</li>\n        </ul>\n    </blockquote>\n    <p>不过，这些数据容器还可以进一步细分（表 12-2）。例如，在路径末尾可以附加查询，这也是一种数据容器。由此来看，从浏览器向服务器，以及从服务器向浏览器发送数据的方法有很多。</p>\n    <p><strong>表 12-2　数据容器的详细分类</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>容器</p>\n                </th>\n                <th>\n                    <p>浏览器→服务器</p>\n                </th>\n                <th>\n                    <p>浏览器←服务器</p>\n                </th>\n                <th>\n                    <p>必需</p>\n                </th>\n                <th>\n                    <p>备注</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p>方法</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>仅限指定类型</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>路径</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>字符个数有限制</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>查询</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>位于 URL 之后。字符个数有限制</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>首部</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>主体</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>可发送文件</p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>状态码</p>\n                </td>\n                <td>\n                    <p>&nbsp;</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>√</p>\n                </td>\n                <td>\n                    <p>仅限指定类型</p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <p>方法和状态码只有规范中规定的一些类型可以使用，在使用时也存在一些限制，比如在服务器返回 <code>204 NO CONTENT</code>\n        的情况下，不可以持有主体。另外，方法和状态码只能选择规范中规定的内容，路径的长度和查询的长度限制在 2000 个字符左右。在使用浏览器表单和 <code>GET</code> 方法发送数据的情况下，内容就是查询，在使用\n        <code>POST</code> 方法发送数据的情况下，主体的数据以表单形式或 Multipart 形式进行编码并存储。</p>\n    <p>虽然存在限制，但也可以将浏览器的请求信息全部放到路径中，汇总所使用的数据容器。我们需要根据信息类型来决定将数据放到哪个容器中。这就是 Web API 的设计。</p>\n    <h2 id=\"nav_point_306\">12.9　WebAPI 的设计：区分使用数据容器</h2>\n    <p>既然需要设计，就不可能从规范中自动导出使用哪个数据容器，而需要我们根据过去的经验和实例等来决定使用哪个容器会更容易理解。</p>\n    <p>基本上就是按 MECE（相互独立，完全穷尽）准则来确定数据的类型和存储数据的容器。数据是否可以省略，以及数据容量等数据特性都可以作为参考。例如，在从浏览器向服务器发送数据时，大多会遵循如下原则。</p>\n    <blockquote>\n        <ul>\n            <li>如果是选择数据的操作对象，则使用路径</li>\n            <li>如果是仅改变数据格式和过滤器的信息（用户可以任意删除），则使用查询</li>\n            <li>如果是共享 URL 时需要隐藏的数据，则使用主体</li>\n            <li>如果是数据的操作类型，则使用方法</li>\n            <li>如果是关于认证的数据，则使用首部</li>\n        </ul>\n    </blockquote>\n    <p>当从服务器向浏览器发送响应时，常见的做法是将表示是否存在错误的值写入状态码中，使用 JSON 将错误的详细内容写入主体中。另外，主体的类型分为 JSON、XML 和 HTML Form\n        等，服务器不会局限于一种类型，可以使用浏览器发送过来的首部或路径来指定类型。</p>\n    <p>举一个比较极端的例子，有时我们会将所有信息都放在主体的 XML 或 JSON 中，使用固定的路径，方法也固定为 <code>POST</code>。SOAP、XML-RPC 和 JSON-RPC 等 RPC\n        协议就是这样设计的。</p>\n    <p>近年来公开的 Web API 设计大多称为 RESTful API，我们不能说哪种设计是正确的，只要浏览器和服务器之间达成共识，采用哪种方法都可以。不过，API\n        的设计越接近于一般的方法，学习成本就越低，即使没有很多文档，也很容易理解。另外，如果有库或框架，服务器的实现就会更加容易。</p>\n    <p>在确定数据容器之后，我们就可以使用 CDN 或 WAF（Web Application Firewall，Web 应用防护系统）等进行过滤，比如禁止发送 <code>GET/POST</code>\n        以外的方法、禁止访问指定的路径等。提高安全性其实就是限制设计的自由度。如果设置为不允许使用系统中未使用的组合，那么就可以排除服务端未定义的组合。</p>\n    <p>在方法的限制方面，通过在末尾加上 <code>/delete</code> 等，也可以将方法放入路径容器中（方法重写）。另外，在 <code>GET</code>\n        方法中，由于（一般认为）不可以使用主体，所以通常会将数据放入查询中，而不使用主体。</p>\n    <blockquote>\n        <p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00380.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　RESTful 架构是决定往哪个容器里放什么数据的指标之一。\n        </p>\n    </blockquote>\n    <h2 id=\"nav_point_307\">12.10　今后不再使用的技术</h2>\n    <p>有些技术以前经常看到，现在却很少使用了。下面笔者就来介绍一下这类技术。</p>\n    <h3 id=\"nav_point_308\">12.10.1　CGI</h3>\n    <p><strong>CGI</strong>（Common Gateway Interface，公共网关接口）是可以以任意语言自由地创建动态 Web 服务的标准。在前面介绍的 Web 应用程序中，使用各种语言实现的 Web\n        应用程序服务器会保持启动状态，接收 HTTP 请求，并返回结果。</p>\n    <p>在 CGI 中，HTTP 请求是由 Apache 等服务器接收的。只要是可以使用标准输入、标准输出和环境变量的语言，就都可以编写 CGI 程序。服务器对请求中包含的数据进行分解，按下面的形式与 CGI 程序进行交互。</p>\n    <blockquote>\n        <ul>\n            <li>标准输入：包含主体的内容</li>\n            <li>标准输出：返回给浏览器的响应</li>\n            <li><code>PATH_INFO</code> 环境变量：路径</li>\n            <li><code>QUERY_STRING</code> 环境变量：赋给路径的查询字符串</li>\n            <li><code>REQUEST_METHOD</code> 环境变量：方法</li>\n            <li><code>CONTENT_LENGTH</code> 环境变量：主体中包含的数据的长度</li>\n            <li><code>CONTENT_TYPE</code> 环境变量：主体中包含的数据的类型</li>\n        </ul>\n    </blockquote>\n    <p>主体作为标准输入进行传递，路径、方法和一些首部作为环境变量进行传递。输出则使用标准输出。首先输出首部，然后空一行再写主体。除了状态码之外，其他行的 HTTP 输出都需要手动创建。</p>\n    <p>主体大多用于生成 HTML 文本，但有时也可以创建用于生成图像文件的 CGI。在统计访问次数的访问计数器等中会用到图像生成功能，使用静态 HTML 生成页面本身，使用 <code>&lt;img&gt;</code>\n        标签在图像 <code>src</code> 的 URL 中指定 CGI 路径，也可以创建半动态的网站。</p>\n    <p>CGI 最早是为 Web 服务器 NCSA HTTPd 开发的，用于实现动态网站。CGI 在 RFC 3875 中实现了标准化。在 2000 年左右，CGI 作为创建动态 Web\n        服务的方法而备受青睐。租用服务器的服务大多使用了支持 CGI 的 Apache。</p>\n    <p>CGI 的缺点是每次接收请求时都会启动进程，在执行处理后结束进程。进程的启动在操作系统中是比较繁重的处理，如果是脚本语言，那么库的加载成本等就会叠加到每次的请求中。</p>\n    <p>FastCGI 就是为了解决这个问题而开发的，具体来说就是将进程设为启动状态，通过套接字通信将请求传递给处理程序。现在，作为使用 PHP 的方法，FastCGI 还在被人们使用。</p>\n    <p>Go 中提供了 <code>net/http/cgi</code> 包来创建 CGI，这里就不详细介绍了。</p>\n    <h3 id=\"nav_point_309\">12.10.2　RIA</h3>\n    <p>Flash 也曾试图以 Flex 的名称成为 Web 应用程序的接口，但当时已经出现了其他一些相关的技术，如下所示。</p>\n    <blockquote>\n        <ul>\n            <li>Java Applet</li>\n            <li>Java FX</li>\n            <li>Microsoft Silverlight</li>\n        </ul>\n    </blockquote>\n    <p>现在，浏览器经常使用插件来扩展功能，Flash 也是使用插件实现的，也有一些运行时使用了插件，通过 JavaScript 之外的语言来开发应用程序。</p>\n    <p>在 Internet Explorer 7 之前，浏览器中并没有开发者工具，JavaScript 需要由专业人员来调试。在安装浏览器扩展插件 FireBug\n        之后，就可以通过查看控制台输出来进行调试。但创建大型动态网站还是很困难，相比使用 JavaScript，使用具有调试器的其他语言进行开发是更加现实的选择。</p>\n    <p>其中最常用的就是 Flash。在 PC 端浏览器中，Flash 的安装率最高曾超过 90%，也有面向功能手机的 Flash Lite。Flash 拥有基于 ECMAScript 的语言（ECMAScript 也是\n        JavaScript 的基础），也可以进行编程。由此，出现了许多能绘画也能编写简单代码的人（在现在的游戏领域中大多称之为技术美术师）。最终，Flash 作为在浏览器上玩游戏的平台，占据了大部分市场份额。另外，Flash\n        的格式也可以被解析，我们可以使用 Ming 等库，像使用 CGI 制作 GIF 动画一样动态生成 Flash 动画，这经常被用于面向功能手机的游戏。</p>\n    <p>Flash 支持 H.264 格式的视频播放，这使得 Flash 被广泛用于实现浏览器中的视频播放。视频共享服务等大多使用 Flash 来播放视频。视频格式 H.264 拥有专利，当时 H.264\n        的压缩率很高，且适用于网络环境，对视频进行压缩和解压缩的编解码器需要支付授权费才可以使用。浏览器本身并没有视频播放功能，只有导入 Flash 插件（Adobe 公司负担授权费）作为播放引擎，才可以播放视频。与 Flash\n        一样，Silverlight 也被用作网站的视频播放插件。</p>\n    <p>后来，随着 JavaScript 拥有通信 API 和开发环境，库也变得完善，Flash 的缺点越来越明显，例如，不安装插件就无法运行、与搜索引擎的兼容性较差、加载耗时、本地访问的安全风险较大、与语音浏览器等注重可访问性的\n        UI 的兼容性较差等。由于在智能手机领域占有较大市场份额的 iOS 不支持插件，再加上 Flash 耗电量大，存在安全漏洞且容易崩溃，Flash 渐渐被人们抛弃，Apple 公司宣布不再大规模采用\n        Flash。后来，HTML5 成为主流，相信在不久的将来，主要的浏览器都会移除插件功能。</p>\n    <p>这些 <strong>RIA</strong>（Rich Internet Application，富互联网应用），特别是 Flash 开创的许多多媒体功能和视频功能，在 HTML5 时代成了浏览器的标准规范。</p>\n    <p>现在的浏览器支持 WebAssembly，其运行速度接近于本地运行。有的开源项目试图用它来重新实现 Silverlight。将来或许大家还会看到其他形式。</p>\n    <h2 id=\"nav_point_310\">12.11　本章小结</h2>\n    <p>本章介绍了开发 Web 应用程序服务器所需的基础知识。</p>\n    <blockquote>\n        <ul>\n            <li>Web 应用程序做什么</li>\n            <li>Web 应用程序的基本结构</li>\n            <li>Web 应用程序的动作模式的变迁</li>\n            <li>开发环境和实际环境的区别</li>\n            <li>Web 应用程序的内部结构</li>\n            <li>API 设计</li>\n            <li>如今不再使用的技术</li>\n        </ul>\n    </blockquote>\n    <p>Web 应用程序框架开发人员不断吸收其他框架的优秀结构，渐进式地进行开发。不过，如果只是自下而上地学习框架的 API 层的知识，就会难以把握其背后的 Web 服务的共同思想，使理解受具体实现的影响。</p>\n    <p>将来即使出现新的框架，大概也不会偏离本章介绍的内容，而只是增加一些新的思想而已。与其他章节一样，通过阅读本章，我们并不能预测未来的技术，但本章内容应该可以帮助你紧跟技术更新的步伐。</p>\n\n    <br style=\"page-break-after:always\" />\n    ","comments":[]}