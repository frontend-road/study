{"id":88487,"title":"15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？","content":"<p>在上一篇文章中，我们讲到Java SDK并发包里的Lock有别于synchronized隐式锁的三个特性：能够响应中断、支持超时和非阻塞地获取锁。那今天我们接着再来详细聊聊Java SDK并发包里的Condition，<strong>Condition实现了管程模型里面的条件变量</strong>。</p><p>在<a href=\"https://time.geekbang.org/column/article/86089\">《08 | 管程：并发编程的万能钥匙》</a>里我们提到过Java 语言内置的管程里只有一个条件变量，而Lock&amp;Condition实现的管程是支持多个条件变量的，这是二者的一个重要区别。</p><p>在很多并发场景下，支持多个条件变量能够让我们的并发程序可读性更好，实现起来也更容易。例如，实现一个阻塞队列，就需要两个条件变量。</p><p><strong>那如何利用两个条件变量快速实现阻塞队列呢？</strong></p><p>一个阻塞队列，需要两个条件变量，一个是队列不空（空队列不允许出队），另一个是队列不满（队列已满不允许入队），这个例子我们前面在介绍<a href=\"https://time.geekbang.org/column/article/86089\">管程</a>的时候详细说过，这里就不再赘述。相关的代码，我这里重新列了出来，你可以温故知新一下。</p><pre><code>public class BlockedQueue&lt;T&gt;{\n  final Lock lock =\n    new ReentrantLock();\n  // 条件变量：队列不满  \n  final Condition notFull =\n    lock.newCondition();\n  // 条件变量：队列不空  \n  final Condition notEmpty =\n    lock.newCondition();\n\n  // 入队\n  void enq(T x) {\n    lock.lock();\n    try {\n      while (队列已满){\n        // 等待队列不满\n        notFull.await();\n      }  \n      // 省略入队操作...\n      //入队后,通知可出队\n      notEmpty.signal();\n    }finally {\n      lock.unlock();\n    }\n  }\n  // 出队\n  void deq(){\n    lock.lock();\n    try {\n      while (队列已空){\n        // 等待队列不空\n        notEmpty.await();\n      }  \n      // 省略出队操作...\n      //出队后，通知可入队\n      notFull.signal();\n    }finally {\n      lock.unlock();\n    }  \n  }\n}\n</code></pre><p>不过，这里你需要注意，Lock和Condition实现的管程，<strong>线程等待和通知需要调用await()、signal()、signalAll()</strong>，它们的语义和wait()、notify()、notifyAll()是相同的。但是不一样的是，Lock&amp;Condition实现的管程里只能使用前面的await()、signal()、signalAll()，而后面的wait()、notify()、notifyAll()只有在synchronized实现的管程里才能使用。如果一不小心在Lock&amp;Condition实现的管程里调用了wait()、notify()、notifyAll()，那程序可就彻底玩儿完了。</p><!-- [[[read_end]]] --><p>Java SDK并发包里的Lock和Condition不过就是管程的一种实现而已，管程你已经很熟悉了，那Lock和Condition的使用自然是小菜一碟。下面我们就来看看在知名项目Dubbo中，Lock和Condition是怎么用的。不过在开始介绍源码之前，我还先要介绍两个概念：同步和异步。</p><h2>同步与异步</h2><p>我们平时写的代码，基本都是同步的。但最近几年，异步编程大火。那同步和异步的区别到底是什么呢？<strong>通俗点来讲就是调用方是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步</strong>。</p><p>比如在下面的代码里，有一个计算圆周率小数点后100万位的方法<code>pai1M()</code>，这个方法可能需要执行俩礼拜，如果调用<code>pai1M()</code>之后，线程一直等着计算结果，等俩礼拜之后结果返回，就可以执行 <code>printf(\"hello world\")</code>了，这个属于同步；如果调用<code>pai1M()</code>之后，线程不用等待计算结果，立刻就可以执行 <code>printf(\"hello world\")</code>，这个就属于异步。</p><pre><code>// 计算圆周率小说点后100万位 \nString pai1M() {\n  //省略代码无数\n}\n\npai1M()\nprintf(&quot;hello world&quot;)\n</code></pre><p>同步，是Java代码默认的处理方式。如果你想让你的程序支持异步，可以通过下面两种方式来实现：</p><ol>\n<li>调用方创建一个子线程，在子线程中执行方法调用，这种调用我们称为异步调用；</li>\n<li>方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接return，这种方法我们一般称为异步方法。</li>\n</ol><h2>Dubbo源码分析</h2><p>其实在编程领域，异步的场景还是挺多的，比如TCP协议本身就是异步的，我们工作中经常用到的RPC调用，<strong>在TCP协议层面，发送完RPC请求后，线程是不会等待RPC的响应结果的</strong>。可能你会觉得奇怪，平时工作中的RPC调用大多数都是同步的啊？这是怎么回事呢？</p><p>其实很简单，一定是有人帮你做了异步转同步的事情。例如目前知名的RPC框架Dubbo就给我们做了异步转同步的事情，那它是怎么做的呢？下面我们就来分析一下Dubbo的相关源码。</p><p>对于下面一个简单的RPC调用，默认情况下sayHello()方法，是个同步方法，也就是说，执行service.sayHello(“dubbo”)的时候，线程会停下来等结果。</p><pre><code>DemoService service = 初始化部分省略\nString message = \n  service.sayHello(&quot;dubbo&quot;);\nSystem.out.println(message);\n</code></pre><p>如果此时你将调用线程dump出来的话，会是下图这个样子，你会发现调用线程阻塞了，线程状态是TIMED_WAITING。本来发送请求是异步的，但是调用线程却阻塞了，说明Dubbo帮我们做了异步转同步的事情。通过调用栈，你能看到线程是阻塞在DefaultFuture.get()方法上，所以可以推断：Dubbo异步转同步的功能应该是通过DefaultFuture这个类实现的。</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/c5/a924d23fc43d31267473f2dc91396ec5.png?wh=767*393\" alt=\"\"></p><center><span class=\"reference\">调用栈信息</span></center><p>不过为了理清前后关系，还是有必要分析一下调用DefaultFuture.get()之前发生了什么。DubboInvoker的108行调用了DefaultFuture.get()，这一行很关键，我稍微修改了一下列在了下面。这一行先调用了request(inv, timeout)方法，这个方法其实就是发送RPC请求，之后通过调用get()方法等待RPC返回结果。</p><pre><code>public class DubboInvoker{\n  Result doInvoke(Invocation inv){\n    // 下面这行就是源码中108行\n    // 为了便于展示，做了修改\n    return currentClient \n      .request(inv, timeout)\n      .get();\n  }\n}\n</code></pre><p>DefaultFuture这个类是很关键，我把相关的代码精简之后，列到了下面。不过在看代码之前，你还是有必要重复一下我们的需求：当RPC返回结果之前，阻塞调用线程，让调用线程等待；当RPC返回结果后，唤醒调用线程，让调用线程重新执行。不知道你有没有似曾相识的感觉，这不就是经典的等待-通知机制吗？这个时候想必你的脑海里应该能够浮现出管程的解决方案了。有了自己的方案之后，我们再来看看Dubbo是怎么实现的。</p><pre><code>// 创建锁与条件变量\nprivate final Lock lock \n    = new ReentrantLock();\nprivate final Condition done \n    = lock.newCondition();\n\n// 调用方通过该方法等待结果\nObject get(int timeout){\n  long start = System.nanoTime();\n  lock.lock();\n  try {\n\twhile (!isDone()) {\n\t  done.await(timeout);\n      long cur=System.nanoTime();\n\t  if (isDone() || \n          cur-start &gt; timeout){\n\t    break;\n\t  }\n\t}\n  } finally {\n\tlock.unlock();\n  }\n  if (!isDone()) {\n\tthrow new TimeoutException();\n  }\n  return returnFromResponse();\n}\n// RPC结果是否已经返回\nboolean isDone() {\n  return response != null;\n}\n// RPC结果返回时调用该方法   \nprivate void doReceived(Response res) {\n  lock.lock();\n  try {\n    response = res;\n    if (done != null) {\n      done.signal();\n    }\n  } finally {\n    lock.unlock();\n  }\n}\n</code></pre><p>调用线程通过调用get()方法等待RPC返回结果，这个方法里面，你看到的都是熟悉的“面孔”：调用lock()获取锁，在finally里面调用unlock()释放锁；获取锁后，通过经典的在循环中调用await()方法来实现等待。</p><p>当RPC结果返回时，会调用doReceived()方法，这个方法里面，调用lock()获取锁，在finally里面调用unlock()释放锁，获取锁后通过调用signal()来通知调用线程，结果已经返回，不用继续等待了。</p><p>至此，Dubbo里面的异步转同步的源码就分析完了，有没有觉得还挺简单的？最近这几年，工作中需要异步处理的越来越多了，其中有一个主要原因就是有些API本身就是异步API。例如websocket也是一个异步的通信协议，如果基于这个协议实现一个简单的RPC，你也会遇到异步转同步的问题。现在很多公有云的API本身也是异步的，例如创建云主机，就是一个异步的API，调用虽然成功了，但是云主机并没有创建成功，你需要调用另外一个API去轮询云主机的状态。如果你需要在项目内部封装创建云主机的API，你也会面临异步转同步的问题，因为同步的API更易用。</p><h2>总结</h2><p>Lock&amp;Condition是管程的一种实现，所以能否用好Lock和Condition要看你对管程模型理解得怎么样。管程的技术前面我们已经专门用了一篇文章做了介绍，你可以结合着来学，理论联系实践，有助于加深理解。</p><p>Lock&amp;Condition实现的管程相对于synchronized实现的管程来说更加灵活、功能也更丰富。</p><p>结合我自己的经验，我认为了解原理比了解实现更能让你快速学好并发编程，所以没有介绍太多Java SDK并发包里锁和条件变量是如何实现的。但如果你对实现感兴趣，可以参考<a href=\"time://mall?url=https%3A%2F%2Fh5.youzan.com%2Fv2%2Fgoods%2F35z7jjvd4r4oo\">《Java并发编程的艺术》</a>一书的第5章《Java中的锁》，里面详细介绍了实现原理，我觉得写得非常好。</p><p>另外，专栏里对DefaultFuture的代码缩减了很多，如果你感兴趣，也可以去看看完整版。<br>\nDubbo的源代码在<a href=\"https://github.com/apache/incubator-dubbo\">Github上</a>，DefaultFuture的路径是：incubator-dubbo/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java。</p><h2>课后思考</h2><p>DefaultFuture里面唤醒等待的线程，用的是signal()，而不是signalAll()，你来分析一下，这样做是否合理呢？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":82725,"user_name":"ZOU志伟","can_delete":false,"product_type":"c1","uid":1029179,"ip_address":"","ucode":"439779871CC992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","comment_is_top":false,"comment_ctime":1554287673,"is_pvip":false,"replies":[{"id":"29898","content":"写这一章的时候还是signal，后来有人提了个bug，就改成signalall了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554293820,"ip_address":"","comment_id":82725,"utype":1}],"discussion_count":19,"race_medal":0,"score":"624324545593","product_id":100023901,"comment_content":"不合理，会导致很多请求超时，看了源码是调用signalAll()","like_count":145,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445701,"discussion_content":"写这一章的时候还是signal，后来有人提了个bug，就改成signalall了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554293820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1902491,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/fVxmiblwa0tiboQOX8pdAVUGn3weVZR6g9Cxb4MGiajP6OkDWQkKYztayicIKPUbHlsIpP4GZml0q26COGqUNsHsfA/132","nickname":"Geek_d492fc","note":"","ucode":"D09F0445058A21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204410,"discussion_content":"看来看去其实应该是合理的，DefaultFuture实例应该是每个线程调用都会产生个新的...不然response 变量在解锁后还判断就已经不安全了。我也觉得这里用管程仅仅只是优化一下程序的异步变同步调用，类似把可能原本要轮询解决的 优化成 消息通知机制。所以等待队列里面就只有当前的一个线程，signal() 是合理的。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1584170494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1221195,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a2/4b/b72f724f.jpg","nickname":"zxk","note":"","ucode":"4BB2BD9D2BCD04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1902491,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/fVxmiblwa0tiboQOX8pdAVUGn3weVZR6g9Cxb4MGiajP6OkDWQkKYztayicIKPUbHlsIpP4GZml0q26COGqUNsHsfA/132","nickname":"Geek_d492fc","note":"","ucode":"D09F0445058A21","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356648,"discussion_content":"signal() 不合理的，await() 是把当前线程加入 Condition 的一个 FIFO 等待队列。如果前面某个线程请求的服务超时或者响应时间较长，可能会导致队列后面其他线程的请求超时。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1615643206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204410,"ip_address":""},"score":356648,"extra":""},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1221195,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a2/4b/b72f724f.jpg","nickname":"zxk","note":"","ucode":"4BB2BD9D2BCD04","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560904,"discussion_content":"那也就是说 signal() 的作用 跟 notify() 唤醒的作用不一样呗？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649488937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":356648,"ip_address":""},"score":560904,"extra":""},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1221195,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a2/4b/b72f724f.jpg","nickname":"zxk","note":"","ucode":"4BB2BD9D2BCD04","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560907,"discussion_content":" notify() 仅仅是从等待队列中随机选择唤醒一个线程，其他线程还在waiting状态，然后这一个线程去争抢锁；notifyAll()是唤醒等待队列中的所有线程，都去争抢锁；这样对比下来，只能说争抢锁的线程数量多了，就能推断出，有点线程获得不到锁，导致响应过长？这个选择唤醒的逻辑又不是根据谁睡的时间长，谁就能获得锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649489354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":356648,"ip_address":""},"score":560907,"extra":""}]},{"author":{"id":1126593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","nickname":"密码123456","note":"","ucode":"9889463CC0EA71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74703,"discussion_content":"请求超时的原因是不是，大量的线程都在条件变量等待。很多线程压根连竞争锁的资格都没有。不如唤醒全部，让他们一起竞争锁。好歹有个机会和新来的请求有个竞争。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1575677509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1029179,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","nickname":"ZOU志伟","note":"","ucode":"439779871CC992","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1126593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","nickname":"密码123456","note":"","ucode":"9889463CC0EA71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81894,"discussion_content":"是的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576292524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74703,"ip_address":""},"score":81894,"extra":""},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1126593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","nickname":"密码123456","note":"","ucode":"9889463CC0EA71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363823,"discussion_content":"是有返回结果才唤醒，如果唤醒后随机一个线程去继续if (isDone() || cur-start > timeout)，但是唤醒的这个线程!isDone()又继续去等待了不是有问题了吗，所以是所有的线程都在一个条件队列吗，如果不是那条件队列就一个线程为啥要singleAll呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617287862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74703,"ip_address":""},"score":363823,"extra":""},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1126593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","nickname":"密码123456","note":"","ucode":"9889463CC0EA71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560908,"discussion_content":"这样 最坏的结果 出现的概率 差不多啊，硬要说 一起唤醒 最坏的概率小点。那么这个提升这一点概率，付出的成本值吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649489440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":74703,"ip_address":""},"score":560908,"extra":""}]},{"author":{"id":1326971,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcmZIPiaKWfMosmDmkejiac8TDhJKz3cygJ2pRJIBHmoeUCNUssSmjETAV9dyozW6c0y8TibNCXqd8Q/132","nickname":"翡冷翠","note":"","ucode":"42FFE0F7501D56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329082,"discussion_content":"第一次感觉离开源项目贡献者这么近","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1606308442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367163,"discussion_content":"异步转同步除了容易理解有什么优势？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618281157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1430831,"avatar":"https://static001.geekbang.org/account/avatar/00/15/d5/2f/d9bb5dab.jpg","nickname":"打字员老张","note":"","ucode":"95CB3E8FAFB141","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380594,"discussion_content":"如果异步请求的接收方处理其实很快，这样的同步化封装岂不是提高了业务执行效率","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624599344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367163,"ip_address":""},"score":380594,"extra":""},{"author":{"id":2421766,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f4/06/3aca26bb.jpg","nickname":"_Zzz","note":"","ucode":"7BE41841C06EC8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1430831,"avatar":"https://static001.geekbang.org/account/avatar/00/15/d5/2f/d9bb5dab.jpg","nickname":"打字员老张","note":"","ucode":"95CB3E8FAFB141","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":555178,"discussion_content":"如果执行很快，那么同步执行耗时不也相当于只有业务执行时间么？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1646795539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380594,"ip_address":""},"score":555178,"extra":""}]},{"author":{"id":1813207,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/aa/d7/a417ad5b.jpg","nickname":"CharAt","note":"","ucode":"D7D44B48FC4E79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175519,"discussion_content":"我查看signal 的时候 它底层是从等待队列中取出头节点（等待时间最长的）放到锁池中\n额 其实对signal 和signalAll 分别什么时候调用还是不太明白","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581959166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289644,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594171623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6211,"discussion_content":"赞赞赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566788481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82922,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1554348995,"is_pvip":false,"replies":[{"id":"29979","content":"总结的太有文采了！异步加上非阻塞IO才有威力<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554379994,"ip_address":"","comment_id":82922,"utype":1}],"discussion_count":10,"race_medal":0,"score":"456820882371","product_id":100023901,"comment_content":"我理解异步的本质是利用多线程提升性能，异步一定是基于一个新开的线程，从调用线程来看是异步的，但是从新开的那个线程来看，正是同步（等待）的，只是对于调用方而言这种同步是透明的。正所谓生活哪有什么岁月静好，只是有人替你负重前行。","like_count":106,"discussions":[{"author":{"id":1138016,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5d/60/38ea52c5.jpg","nickname":"Bright丶","note":"","ucode":"B1DEA8C8100538","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2202,"discussion_content":"这是老板与员工的关系，老板布置任务，员工需要去完成，然后老板经常问的一句话就是，任务完成了吗？什么时候完成啊","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1563351965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1477612,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","nickname":"张天屹","note":"","ucode":"8BD6BD6DCF0F4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1138016,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5d/60/38ea52c5.jpg","nickname":"Bright丶","note":"","ucode":"B1DEA8C8100538","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4026,"discussion_content":"是的！这个是典型的非阻塞IO.主动轮询的模型，在程序层面类似于while(tryLock)  更进一部就是老板分配工作给一大堆员工，哪个员工全部做好了以后立刻主动告诉老板~","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1565066481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2202,"ip_address":""},"score":4026,"extra":""}]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445776,"discussion_content":"总结的太有文采了！异步加上非阻塞IO才有威力\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1554379994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624157,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c8/5d/1e3685e6.jpg","nickname":"Morse","note":"","ucode":"B09A716D79AE3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46800,"discussion_content":"我有个疑问，是关于评论中说到的透明，按照我之前的理解，透明表示可见的，那么你说的透明是可见还是指不可见，如果是可见的，那么是不是说错了，求赐教","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573210537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1477612,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","nickname":"张天屹","note":"","ucode":"8BD6BD6DCF0F4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1624157,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c8/5d/1e3685e6.jpg","nickname":"Morse","note":"","ucode":"B09A716D79AE3B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217432,"discussion_content":"透明是不可见哈，大概可以理解成因为透明所以根本感知不到看不到它的存在","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585559287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46800,"ip_address":""},"score":217432,"extra":""}]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6212,"discussion_content":"总结的太棒了，浪漫的程序员","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566788561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573632,"discussion_content":"可以不可以提供回调地址真正的异步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653556734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560901,"discussion_content":"难道异步就没有缺点吗？除了线程数量问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649488689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","nickname":"Shine","note":"","ucode":"C8C617B87C63C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2645,"discussion_content":"异步不一定是新开线程实现异步，还有异步I/O，异步I/O跟操作系统实现相关，并不需要新开线程？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563842187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1477612,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","nickname":"张天屹","note":"","ucode":"8BD6BD6DCF0F4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1022568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","nickname":"Shine","note":"","ucode":"C8C617B87C63C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4025,"discussion_content":"是的，我说的新开线程是广义的，新开不太准确，准确说是另一个线程。针对你说的内核态系统调用，异步IO恰恰是内核线程承担了部分本来用户线程的工作，将数据从内核态复制到用户态，完事了通知用户线程。因为是系统调用，不是本地的方法调用或者RPC调用，所以这里准确说是基于“另一个线程”毕竟处理IO的内核进程不是我们开的。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1565066363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2645,"ip_address":""},"score":4025,"extra":""}]}]},{"had_liked":false,"id":90142,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1556428111,"is_pvip":false,"replies":[{"id":"32323","content":"留言这两点有同学都提到了。我表示震撼！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556462686,"ip_address":"","comment_id":90142,"utype":1}],"discussion_count":1,"race_medal":0,"score":"207714858319","product_id":100023901,"comment_content":"in the method of org.apache.dubbo.remoting.exchange.support.DefaultFuture#doReceived, I think we should call done.signalAll() instead of done.signal() ,and it&#39;s unnecessary to check done != null because it&#39;s always true","like_count":48,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448402,"discussion_content":"留言这两点有同学都提到了。我表示震撼！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556462686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82181,"user_name":"天涯煮酒","can_delete":false,"product_type":"c1","uid":1241127,"ip_address":"","ucode":"EF9516EC878E4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/27/8b72141c.jpg","comment_is_top":false,"comment_ctime":1554138041,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"190532699065","product_id":100023901,"comment_content":"合理。<br><br>每个rpc请求都会占用一个线程并产生一个新的DefaultFuture实例，它们的lock&amp;condition是不同的，并没有竞争关系<br><br>这里的lock&amp;condition是用来做异步转同步的，使get()方法不必等待timeout那么久，用得很巧妙","like_count":44,"discussions":[{"author":{"id":1902491,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/fVxmiblwa0tiboQOX8pdAVUGn3weVZR6g9Cxb4MGiajP6OkDWQkKYztayicIKPUbHlsIpP4GZml0q26COGqUNsHsfA/132","nickname":"Geek_d492fc","note":"","ucode":"D09F0445058A21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204404,"discussion_content":"对，我看来看去如果是公用的话那应该最后一遍 isDone 应该也在锁里面，要不然 response 变量就不安全了=。= 我也觉得这里用管程仅仅只是优化一下程序的同步异步调用，类似把轮询优化成消息通知机制。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584170024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1567548,"avatar":"https://static001.geekbang.org/account/avatar/00/17/eb/3c/2454baec.jpg","nickname":"Leroy_lamoury","note":"","ucode":"F30A7B30C8207E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1902491,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/fVxmiblwa0tiboQOX8pdAVUGn3weVZR6g9Cxb4MGiajP6OkDWQkKYztayicIKPUbHlsIpP4GZml0q26COGqUNsHsfA/132","nickname":"Geek_d492fc","note":"","ucode":"D09F0445058A21","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354130,"discussion_content":"没毛病啊 铁铁\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615251890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204404,"ip_address":""},"score":354130,"extra":""}]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363808,"discussion_content":"如果每个线程一个condition，那条件队列就只有这一个线程为啥要用signalAll呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617286813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560902,"discussion_content":"我也是这样的疑问，或者说 尽管是一条队列，但是 需要唤醒的还得是大家伙一起唤醒 一起争抢锁，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649488803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363808,"ip_address":""},"score":560902,"extra":""}]},{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83184,"discussion_content":"+1  请老师解惑","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576418461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2329635,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8c/23/f1c5bee0.jpg","nickname":"wang.yu","note":"","ucode":"CCA775784B3EB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384343,"discussion_content":"+1 请老师解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626507849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363809,"discussion_content":"response 也没看见是成员变量会有线程不安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617286908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294446,"discussion_content":"原来如此，rpc请求进来，此处不是所有请求公用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595896854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82801,"user_name":"10buns","can_delete":false,"product_type":"c1","uid":1016554,"ip_address":"","ucode":"56E51AC21C8189","user_header":"https://static001.geekbang.org/account/avatar/00/0f/82/ea/d054c133.jpg","comment_is_top":false,"comment_ctime":1554312851,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"126108364435","product_id":100023901,"comment_content":"signal唤醒任意一个线程竞争锁，signalAll唤醒同一个条件变量的所有线程竞争锁。但都只有一个线程获得锁执行。区别只是被唤醒线程的数量。<br>所以用signalall可以避免极端情况线程只能等待超时，看了代码也是替代了signal","like_count":29,"discussions":[{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289670,"discussion_content":"可是一个条件变量最多只被一个线程等待呀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594175567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1299470,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d4/0e/496d6d7c.jpg","nickname":"冯志","note":"","ucode":"DA50D8322FD52F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311355,"discussion_content":"不是的，从管程那一章就可以知道一个条件变量对应着一个等待队列，如果多个线程都不满足这个条件的话则会在队列中等待。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602315705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289670,"ip_address":""},"score":311355,"extra":""},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1299470,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d4/0e/496d6d7c.jpg","nickname":"冯志","note":"","ucode":"DA50D8322FD52F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573633,"discussion_content":"他的意思是在这个dobbo调用中，一次请求都是新的一个线程，没有竞争锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653556869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311355,"ip_address":""},"score":573633,"extra":""}]}]},{"had_liked":false,"id":82213,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1554164604,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"87453510524","product_id":100023901,"comment_content":"不一定。如果这个类是单例，那就不合理。如果是一个实例对应一个请求，那就合理。","like_count":20,"discussions":[{"author":{"id":1477324,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8a/cc/da9adc82.jpg","nickname":"小太阳","note":"","ucode":"3B1C90425E485D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217266,"discussion_content":"dubbo在发起请求生成request对象的时候，生成了唯一请求id。客户端的DefaultFuture会维护一个静态hashmap，key是请求id，value是对应请求的DefaultFuture对象。发送请求到服务端时，该id会放在请求头里带过去。服务端响应时把请求id放入response。客户端收到response，拿出它的请求id从map中找到对应的DefaultFuture，唤醒对应线程通知结果。所以我觉得可以认为一个请求对应一个future","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585534814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94682,"user_name":"Geek_e6f3ec","can_delete":false,"product_type":"c1","uid":1360738,"ip_address":"","ucode":"A0ACE49CD3F9BB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotuhVFN9phZnUxxXueAm8rDDibjIkj0L8W7VojYRpSeXwHtDSgLW3SdrNjMQy0AcOUuMmTAQSyO3g/132","comment_is_top":false,"comment_ctime":1557882036,"is_pvip":true,"replies":[{"id":"33936","content":"会去获取锁，但是获取锁后，会执行wait后的代码","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557930043,"ip_address":"","comment_id":94682,"utype":1}],"discussion_count":4,"race_medal":0,"score":"78867293364","product_id":100023901,"comment_content":"老师关于dubbo源码的执行流程有一点疑问。<br>以下是源码<br>&#47;&#47; 调用通过该方法等待结果<br>Object get(int timeout){<br>        long start = System.nanoTime();<br>        lock.lock();<br>        try{<br>            while (!isDone()){<br>                done.wait(timeout);   &#47;&#47; 在这里调用了等待方法后面的代码还能执行吗？  我理解的管程，是在条件变量等待队列中阻塞等待，被唤醒之后也不是马上执行也要去管程入口等待队列，也就是lock.lock处等待获取锁。 老师是这样的吗？<br>                long cur = System.nanoTime();<br>                if (isDone()||cur-start&gt; timeout){<br>                    break;<br>                }<br>            }<br>        }finally {<br>            lock.unlock();<br>        }<br>        return returnFromResponse();<br><br>    }<br><br> <br><br><br><br>","like_count":18,"discussions":[{"author":{"id":1215275,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8b/2b/b9491a0c.jpg","nickname":"陈冲","note":"","ucode":"BD7488265852D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306918,"discussion_content":"你忘了 程序计数器  了吗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600418433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450168,"discussion_content":"会去获取锁，但是获取锁后，会执行wait后的代码","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1557930043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551192,"discussion_content":"我试了，并不会执行后续await()后面的逻辑，而且，lock()这个方法感觉没啥意义啊，我并不知道加锁成功与否","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644921529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242121,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/09/d78fa748.jpg","nickname":"栤枫","note":"","ucode":"72C5D6EB22CA9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305433,"discussion_content":"哈哈,同问得解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599921384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82292,"user_name":"木刻","can_delete":false,"product_type":"c1","uid":1157430,"ip_address":"","ucode":"0A3226FEE3983B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","comment_is_top":false,"comment_ctime":1554177249,"is_pvip":false,"replies":[{"id":"29858","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554217056,"ip_address":"","comment_id":82292,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70273653985","product_id":100023901,"comment_content":"老师今天提到异步转同步，让我想到这两天看的zookeeper客户端源码，感觉应该也是这个机制，客户端同步模式下发送请求后会执行packet.wait，收到服务端响应后执行packet.notifyAll","like_count":16,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445540,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554217056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91294,"user_name":"牧名","can_delete":false,"product_type":"c1","uid":1020390,"ip_address":"","ucode":"193F0F33E1AB47","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","comment_is_top":false,"comment_ctime":1556966549,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"65981475989","product_id":100023901,"comment_content":"DefaultFuture本质上只是一种future实现，所以理论上可以有多个线程同时持有同一个future并调用 get方法，如这时候使用signal()就有可能导致有些线程会请求超时<br>```java<br>DefaultFuture future = currentClient.request(inv, timeout);<br>for(int i=0; i&lt; 10000; i++) {<br>    new Thread(new Runnable() {<br>        @Override<br>        public void run() {<br>            System.out.println(future.get().toString());<br>        }<br>    });<br>}<br><br>极客时间版权所有: https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;88487","like_count":15,"discussions":[{"author":{"id":2028954,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/9a/63dc81a2.jpg","nickname":"Geek1185","note":"","ucode":"47BEE492EF4C1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290765,"discussion_content":"不是一个请求对应一个响应吗？这里是一个响应对应了多个请求？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594601825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278342,"discussion_content":"哦，明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591175794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583588,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/e4/ade74d94.jpg","nickname":"hejun","note":"","ucode":"DCF01B4159178F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55759,"discussion_content":"这个例子很棒，完美解释了为什么要改为调用signalAll()。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574395729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108887,"user_name":"杨鹏程baci","can_delete":false,"product_type":"c1","uid":1205949,"ip_address":"","ucode":"3D22F6B74340A8","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/bd/bd5d503e.jpg","comment_is_top":false,"comment_ctime":1561908181,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"61691450325","product_id":100023901,"comment_content":"老师好，关于我看到你说改成signalall()是优化了，但是我还是不明白如果用signal()可能会带来什么问题，具体优化体现在哪个方面，感觉从代码上出发，done是一个私有对象，也并不存在多个线程共享的问题，用signal()貌似也是够了的吧？","like_count":14,"discussions":[{"author":{"id":2226367,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f8/bf/59f2e600.jpg","nickname":"月明风清","note":"","ucode":"65A97CF2E320FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574842,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654400233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1543428,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDrwrfgpyavWAPKRo2IDtWMQ53bh4C1g4tv0egmGCuslicmCvPiaq6RqNURyy3rDqichZPqAexVvwicQ/132","nickname":"luke25","note":"","ucode":"4D667DDBDA898C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412535,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636204339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1505952,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fa/a0/d1a51d98.jpg","nickname":"InfoQ_9502030bf809","note":"","ucode":"8AC4DCE39BF7C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356595,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615635538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1430163,"avatar":"https://static001.geekbang.org/account/avatar/00/15/d2/93/9c58ce42.jpg","nickname":"HUANGKAIHANG","note":"","ucode":"F3871C5142AE52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3335,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564404751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83268,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1554508100,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"57389082948","product_id":100023901,"comment_content":"我有点不理解为什么这么多说合理的同学，Future这种类不应该经常由于用在闭包中，导致在多线程多上下文中传递嘛？如果我有多个线程都对同一个DefaultFuture实例调用get，而每个被唤醒的线程又不signal其他线程，那不就是只有一个线程最终会被唤醒，其他调用get的线程都是因为超时获取到的结果嘛？","like_count":13,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363895,"discussion_content":"对，而随机获得lock的那个线程!isDone不是继续去await了吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617322249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106266,"user_name":"苏格拉底23","can_delete":false,"product_type":"c1","uid":1323632,"ip_address":"","ucode":"929DF35EAC7418","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/90ZCAwGj0kaicic73wdrqeTicuYbPVib7biczdVC4KiaAKhp5L1eFqzXXyN2y9PoqVfVpFhcM9cnf5Vz7lrv0gaSySfA/132","comment_is_top":false,"comment_ctime":1561228825,"is_pvip":false,"replies":[{"id":"38404","content":"这里只是利用管程实现线程的阻塞和唤醒","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561250418,"ip_address":"","comment_id":106266,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48805869081","product_id":100023901,"comment_content":"老师您好！<br><br>有一个基本的问题不明白，如果每个request对应一个线程，似乎并没有用到共享的资源，那么为什么要加锁呢？","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455024,"discussion_content":"这里只是利用管程实现线程的阻塞和唤醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561250418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200194,"discussion_content":"dubbo 是RPC调用，consumer线程发送RPC请求后，调用future.get()方法，等待provider的response到达，在等待的过程中，consumer线程被阻塞。\nprovider的response到达consumer服务器的时候，并不是被阻塞的consumer进程调用future.doReceived()方法，而是response的线程调用future.doReceived()方法，然后调用condition的signal() 唤醒 consumer进程\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1583667534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90245,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1556458574,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40211164238","product_id":100023901,"comment_content":"我看每个请求都会新建一个DefaultFuture，这个按道理应该只有一个线程阻塞，为什么需要signall","like_count":9,"discussions":[{"author":{"id":1430163,"avatar":"https://static001.geekbang.org/account/avatar/00/15/d2/93/9c58ce42.jpg","nickname":"HUANGKAIHANG","note":"","ucode":"F3871C5142AE52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3336,"discussion_content":"疑问一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564404932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82587,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1554254917,"is_pvip":false,"replies":[{"id":"29893","content":"while条件是编程范式，可以回去看管程原理，搞工程要多重防护。超时后当然很有可能resp是空的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554292896,"ip_address":"","comment_id":82587,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35913993285","product_id":100023901,"comment_content":"老师，求指教<br>DefaultFuturewhile这个类为什么要加 while(!isDone()) 这个条件，我看代码while里面加了done.await(timeout);是支持超时的，就是说设置5秒超时， if (isDone() || cur-start &gt; timeout){，只要超过没有被signal()唤醒，那5秒就会自动唤醒，这时候就会在if (isDone() || cur-start &gt; timeout){ 被校验通过，从而break，退出。这时候在加个while条件是不是没必要。<br>还是说加个while条件是因为时间到点的时候自动唤醒后，Response可能是空，而且时间cur-start &gt; timeout 不超时，所以才有必要进行while再一次判断isDone()是否有值。","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445650,"discussion_content":"while条件是编程范式，可以回去看管程原理，搞工程要多重防护。超时后当然很有可能resp是空的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554292896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82225,"user_name":"水目沾","can_delete":false,"product_type":"c1","uid":1274495,"ip_address":"","ucode":"FDD1D15C277D58","user_header":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","comment_is_top":false,"comment_ctime":1554166356,"is_pvip":false,"replies":[{"id":"30121","content":"一对一的关系用signalall也不是不可以","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554539951,"ip_address":"","comment_id":82225,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27323970132","product_id":100023901,"comment_content":"这是一对一的关系，肯定只需要 signal。每个线程都是相互独立的，lock 和 condition 也是各自独享的。","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445516,"discussion_content":"一对一的关系用signalall也不是不可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554539951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223546,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1591112251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23065948731","product_id":100023901,"comment_content":"找到了issue地址<br>https:&#47;&#47;github.com&#47;apache&#47;dubbo&#47;issues&#47;3678","like_count":5},{"had_liked":false,"id":117768,"user_name":"浅夏","can_delete":false,"product_type":"c1","uid":1417176,"ip_address":"","ucode":"8E1F54025C865A","user_header":"https://static001.geekbang.org/account/avatar/00/15/9f/d8/62030082.jpg","comment_is_top":false,"comment_ctime":1564126905,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"23038963385","product_id":100023901,"comment_content":"2.7.3版本以及不用lock和signal了","like_count":5,"discussions":[{"author":{"id":1003104,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","nickname":"gogo","note":"","ucode":"E8F0F3B000020A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300967,"discussion_content":"maven中心最高版本才2.6.9啊，2.7.3版本是正式的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598346095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91805,"user_name":"ycfHH","can_delete":false,"product_type":"c1","uid":1498283,"ip_address":"","ucode":"084FF6C86CBCE4","user_header":"","comment_is_top":false,"comment_ctime":1557112061,"is_pvip":false,"replies":[{"id":"34441","content":"优化而已","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558359100,"ip_address":"","comment_id":91805,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23031948541","product_id":100023901,"comment_content":"作为一个完全不懂dubbo的新人，我很好奇是什么bug能让signal改成signalAll,因为不管怎么看都感觉signal就已经可以了啊(虽然使用signalall也不错)","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449037,"discussion_content":"优化而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558359100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2854129,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/8c/f1/1a55535d.jpg","nickname":"踏雪无痕","note":"","ucode":"BB426066431D4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572789,"discussion_content":"https://github.com/apache/dubbo/issues/3678","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652954969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278346,"discussion_content":"同好奇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591176324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82239,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1554167796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23029004276","product_id":100023901,"comment_content":"回复：密码12345同学，如果是单例对象，response岂不是乱套了，每一个请求都对应自己的 response。另外singal()是合理的。因为每一个主线程对应一个子线程，不可能存在一个子线程对应多个请求。","like_count":5},{"had_liked":false,"id":326462,"user_name":"Geek_c139e0","can_delete":false,"product_type":"c1","uid":2593255,"ip_address":"","ucode":"87C7E07E98354B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2msSWvJs8A6icPvUzyRs9DEqltYh0edy699wJz9BmCRoJj1bZHhBHhp4yY9Nic9oc2q8OdsVGwtmBRhKtw00Jj6Q/132","comment_is_top":false,"comment_ctime":1639534853,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14524436741","product_id":100023901,"comment_content":"翻了一遍旧版本的代码，如果让我来选，我认为signalAll是一种防呆设计可以应用，因为保不齐有不了解并发编程的人会多个线程跑同一个DefaultFuture实例。<br>但是我也认为DefaultFuture使用signal是没有问题的，在封装里面不论是Channel还是FutureAdapter都是保证new去对应请求的，而且编程规范也认为一个请求要对应一个响应而不是一个请求多个响应去竞争。<br>在看旧版本代码的时候，就在想如果实现保证好一一对应，这个lock甚至都可以不需要，这里只是单纯用lock&amp;condition实现阻塞等待返回结果，实际上这个功能是有很多办法可以实现的。后来看新版果不其然已经变成了id+TimerTask做心跳机制，去掉了这个加锁和阻塞。","like_count":3},{"had_liked":false,"id":169827,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1136022,"ip_address":"","ucode":"5808CB57A03148","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/96/5160cd31.jpg","comment_is_top":false,"comment_ctime":1578453041,"is_pvip":false,"replies":[{"id":"66869","content":"加班已成狗，看不动了😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579179482,"ip_address":"","comment_id":169827,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14463354929","product_id":100023901,"comment_content":"看了最新的DefaultFuture，已经去掉了lock，老师能分析下最新实现的原理吗","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480735,"discussion_content":"加班已成狗，看不动了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579179482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177419,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f7/4b/41e7d4d7.jpg","nickname":"randy","note":"","ucode":"6AEC444D38E49B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220557,"discussion_content":"改用CompletableFuture来实现了，其实本质都是一样的，依赖locksupport的park和unpark。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1585895779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131445,"user_name":"庄墨寒","can_delete":false,"product_type":"c1","uid":1063970,"ip_address":"","ucode":"BBD9EFA891BF06","user_header":"https://static001.geekbang.org/account/avatar/00/10/3c/22/9024c062.jpg","comment_is_top":false,"comment_ctime":1567754691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14452656579","product_id":100023901,"comment_content":"在此处使用会遇到异步转同步, 其原因是在dubbo client在处理请求IO时, 不是一个请求一个连接. 而是多个请求复用到一组长连接, 客户端的NIO. 同时还有请求合并, 在一个极小的时间窗口(比例5ms)内的请求打包成一个包, 避免过小的tpc包. 优化了TCP性能.    因为突破了1:1的关系, 所以另外开启一组线程, 原生的业务线程就等待另外开启的线程了. ","like_count":3},{"had_liked":false,"id":116976,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1563950364,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14448852252","product_id":100023901,"comment_content":"---总结---<br>1. 简单地讲，根据调用方是否需要等待结果，可以将程序的调用方式分为同步调用和异步调用<br>2. 异步调用：调用方创建子线程并让子线程执行某一方法调用<br>3. 异步方法：某一方法中创建了子线程执行逻辑，而让主线程返回<br><br>---思考题---<br>DefaultFuture的某个实例并非单线程访问的，可能会有多个线程访问同一个，因此需要用SignalAll通知全部，避免没有通知到正确的线程（不知道DUBBO中DefaultFuture同一个实例会不会共享）","like_count":3,"discussions":[{"author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106302,"discussion_content":"但是即使all了，也未必是指定线程能够获取锁呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577529569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1067354,"avatar":"https://static001.geekbang.org/account/avatar/00/10/49/5a/67b5f0b1.jpg","nickname":"单小灰","note":"","ucode":"59C4523FF1B5DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310797,"discussion_content":"all了就会唤醒所有await的线程去竞争锁，即使第一个抢到的不是预想的那它会重新await，然后剩下的线程会继续竞争锁，直到预期的那个线程拿到锁做该做的事情；但如果不是all，那么只会唤醒一个线程，如果不是预想的那个线程那它重新await，那么这次机会就浪费了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602049755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":106302,"ip_address":""},"score":310797,"extra":""},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1067354,"avatar":"https://static001.geekbang.org/account/avatar/00/10/49/5a/67b5f0b1.jpg","nickname":"单小灰","note":"","ucode":"59C4523FF1B5DB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363898,"discussion_content":"感觉说的不对，singleAll后是随机一个线程去获取lock，其他线程没有抢到lock会继续在等待队列。如果拿到锁的线程! Done则会进入条件队列。应该是一个条件队列只有一个线程，没必要singleAll","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617323281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310797,"ip_address":""},"score":363898,"extra":""}]}]},{"had_liked":false,"id":83156,"user_name":"遇见阳光","can_delete":false,"product_type":"c1","uid":1203576,"ip_address":"","ucode":"378E5D37B3CD0E","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/78/f011d586.jpg","comment_is_top":false,"comment_ctime":1554443594,"is_pvip":false,"replies":[{"id":"30066","content":"lock底层是用locksupport实现的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554478811,"ip_address":"","comment_id":83156,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14439345482","product_id":100023901,"comment_content":"老师，我想问下locksupport与此处用lock来阻塞调用者线程有什么区别","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445891,"discussion_content":"lock底层是用locksupport实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554478811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82668,"user_name":"7","can_delete":false,"product_type":"c1","uid":1114093,"ip_address":"","ucode":"10A6E57A027D42","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","comment_is_top":false,"comment_ctime":1554273428,"is_pvip":false,"replies":[{"id":"29899","content":"最新的代码他们已经改过来了😃","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554293876,"ip_address":"","comment_id":82668,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14439175316","product_id":100023901,"comment_content":"老师，有个疑问<br>为什么要判断done!=null呢？这个条件不是永远为true吗。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445676,"discussion_content":"最新的代码他们已经改过来了😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554293876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82447,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1554215466,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14439117354","product_id":100023901,"comment_content":"我觉得很合理，因为每个请求都会实例化个DefactFeture,所以每个请求一个lock，明确知道需要唤醒哪个线程应该用asign()，同样这样做法也是为了应对高并发情况下的异步转同步需求吧！不知道对不对?😂","like_count":3},{"had_liked":false,"id":237304,"user_name":"FIRE","can_delete":false,"product_type":"c1","uid":1670763,"ip_address":"","ucode":"85861D990FB3AB","user_header":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","comment_is_top":false,"comment_ctime":1595773750,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10185708342","product_id":100023901,"comment_content":"同步和异步我有个很大的困惑，同步是直接返回结果，异步的话第一步调用已经结束了，不必等待返回结果，服务器处理完后怎么知道把结果给谁呢？","like_count":2,"discussions":[{"author":{"id":1168504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d4/78/66b3f2a2.jpg","nickname":"斯盖丸","note":"","ucode":"B881D14B028F14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346674,"discussion_content":"callback方法吧，一般要获取它的返回值的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612018552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233246,"user_name":"sibyl","can_delete":false,"product_type":"c1","uid":1323652,"ip_address":"","ucode":"0D142011860D69","user_header":"","comment_is_top":false,"comment_ctime":1594269082,"is_pvip":false,"replies":[{"id":"86171","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1594346209,"ip_address":"","comment_id":233246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10184203674","product_id":100023901,"comment_content":"动手实现阻塞队列时，一定注意synchronized&#47;wait&#47;notify ， Lock&#47;Condition&#47;await&#47;signal的组合！ <br><br>我在实现时，同时用了Lock和notify，一直报错IllegalMonitorStateException，该异常表示没加锁，而norify要求的锁必须是synchronized的锁，的确notify必须在synchronized临界区中使用，这是才加synchronized锁的！！！","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500956,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594346209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208831,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1587445867,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10177380459","product_id":100023901,"comment_content":"就目前这个版本的dubbo代码来看，future每个线程独有，实现的是callback接口，用wait在等待的时候让出cpu，提高硬件的利用率。lock并没有起到互斥的作用，而仅仅是为了wait","like_count":2},{"had_liked":false,"id":146186,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1572449068,"is_pvip":false,"replies":[{"id":"56917","content":"如果用阻塞式I&#47;O，则是os做的异步转同步","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1572869007,"ip_address":"","comment_id":146186,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10162383660","product_id":100023901,"comment_content":"TCP 协议本身就是异步的，我们工作中经常用到的 RPC 调用，在 TCP 协议层面，发送完 RPC 请求后，线程是不会等待 RPC 的响应结果的。<br>-------------<br>老师，我也有类似的疑问，如果说TCP都是异步的，那么我们平时用的各种httpClient的sdk开发，它们也做了异步转同步的事情？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472743,"discussion_content":"如果用阻塞式I/O，则是os做的异步转同步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572869007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141441,"user_name":"yc","can_delete":false,"product_type":"c1","uid":1670122,"ip_address":"","ucode":"2E01505284DC4E","user_header":"https://static001.geekbang.org/account/avatar/00/19/7b/ea/a64f7822.jpg","comment_is_top":false,"comment_ctime":1571154832,"is_pvip":false,"replies":[{"id":"54750","content":"会影响效率，所以才会有无锁算法的阻塞队列","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571228849,"ip_address":"","comment_id":141441,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10161089424","product_id":100023901,"comment_content":"请问老师，阻塞队列的实现，入队和出队都要先获取锁，如果有一个线程正在入队同时又有一个线程在出队，是不是只有一个线程能拿到锁从而成功操作，另一个需要灯unlock，那么入队和出队就是串行了；又或者有两个线程同时入队，也是只有一个线程能够拿到锁从而成功执行入队，另一个线程需要等unlock，也是变成串行了。这样不会影响效率吗？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470754,"discussion_content":"会影响效率，所以才会有无锁算法的阻塞队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571228849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1466840,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/d8/3bc19bff.jpg","nickname":"恋在那时","note":"","ucode":"7F026B4B708C7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556658,"discussion_content":"看了linkedblockingqueue的实现，进队和出队使用的不是同一把锁，同时入队是需要加锁的，保证线程安全。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647439518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82434,"user_name":"liurh","can_delete":false,"product_type":"c1","uid":1468570,"ip_address":"","ucode":"9EFF41023D60D1","user_header":"","comment_is_top":false,"comment_ctime":1554210780,"is_pvip":false,"replies":[{"id":"29857","content":"这个懂netty就知道了，一般工具类搞不定了就用它<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554216850,"ip_address":"","comment_id":82434,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10144145372","product_id":100023901,"comment_content":"老师，jdk已经实现了Future去把异步转换为同步，我们直接使用get()方法就会让线程阻塞的获取线程执行结果，为什么dubbo还要自己实现MESA模型，不太理解。业务中不知道什么时候该用这个模型","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445587,"discussion_content":"这个懂netty就知道了，一般工具类搞不定了就用它\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554216850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763335,"avatar":"","nickname":"Geek_373e87","note":"","ucode":"9DBAD30E4ED24A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276204,"discussion_content":"100和request，如果用jdk的。那你怎么区分哪个response对应哪个requset？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590839439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82205,"user_name":"zhangtnty","can_delete":false,"product_type":"c1","uid":1180553,"ip_address":"","ucode":"3C9A14BD7CF432","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/89/e1621a01.jpg","comment_is_top":false,"comment_ctime":1554163064,"is_pvip":false,"replies":[{"id":"29897","content":"创建新线程和创建子线程没区别，都是约定俗成的说法而已<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554293592,"ip_address":"","comment_id":82205,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10144097656","product_id":100023901,"comment_content":"合理，等待条件都是response不空，等到通知后的动作都是返回response,也是通知一个线程。<br>老师，您在文中提到，子线程和新线程，代码上怎么区分呢？我认为在main中new thread,即使立刻返回main,也得在new thread之后。这是子线程还是新线程呢？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445507,"discussion_content":"创建新线程和创建子线程没区别，都是约定俗成的说法而已\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554293592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177683,"user_name":"CDz","can_delete":false,"product_type":"c1","uid":1114779,"ip_address":"","ucode":"A23BEE1C4A5922","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9b/b1a3c60d.jpg","comment_is_top":false,"comment_ctime":1581473593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876440889","product_id":100023901,"comment_content":"DefaultFuture 里面唤醒等待的线程，为什么将 signal()改成signalAll()？<br><br>DefaultFuture是一个future实现，get方法可以被很多线程调用，假设被十个线程调用，使用 signal()只会唤醒一个，其他线程将一直被等待。","like_count":1},{"had_liked":false,"id":166738,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1577582076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872549372","product_id":100023901,"comment_content":"学到后面的章节，回过头来有一个疑问：<br>Object get(int timeout){<br>  long start = System.nanoTime();<br>  lock.lock();<br>  try {<br>  while (!isDone()) {<br>    done.await(timeout);&#47;&#47;执行这行后，会跳出来执行finally里面的lock.unlock吗？不然怎么释放锁？<br>      long cur=System.nanoTime();<br>    if (isDone() || <br>          cur-start &gt; timeout){<br>      break;<br>    }<br>  }<br>  } finally {<br>  lock.unlock();<br>  }<br>  if (!isDone()) {<br>  throw new TimeoutException();<br>  }<br>  return returnFromResponse();<br>}","like_count":1},{"had_liked":false,"id":140569,"user_name":"yc","can_delete":false,"product_type":"c1","uid":1670122,"ip_address":"","ucode":"2E01505284DC4E","user_header":"https://static001.geekbang.org/account/avatar/00/19/7b/ea/a64f7822.jpg","comment_is_top":false,"comment_ctime":1571009152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865976448","product_id":100023901,"comment_content":"本节课的阻塞队列的实现，入队和出队都要先获取锁，那么入队和出队就是串行了，这样不会影响效率吗","like_count":1},{"had_liked":false,"id":129668,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1567213203,"is_pvip":true,"replies":[{"id":"48632","content":"wait()会释放锁，所以不会死锁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567426881,"ip_address":"","comment_id":129668,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862180499","product_id":100023901,"comment_content":"老师 有个问题 condition 这个 如果我每次都调用入队 直到看了 入队线程阻塞，此时我在调用出队，但是lock被入队线程获取了已经，因此出队线程就会阻塞，这样不就死锁了嘛？ 这个程序是不是有问题","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465592,"discussion_content":"wait()会释放锁，所以不会死锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567426881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121186,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1565072897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860040193","product_id":100023901,"comment_content":"好像很多框架都实现了类似Future这种异步转同步的同步机制，方法不一，在Dubbo中使用Lock-Condition的await实现同步，而在JDK的Future中，get（）阻塞和唤醒是通过LockSupport完成的，而Condition的await的实现其实也是利用了LockSupport的patk()  总的来说它比之Condition要更灵活底层一点.","like_count":1},{"had_liked":false,"id":103426,"user_name":"Geek_89bbab","can_delete":false,"product_type":"c1","uid":1156607,"ip_address":"","ucode":"B3110D5B3C9500","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/ff/6201122c.jpg","comment_is_top":false,"comment_ctime":1560433192,"is_pvip":false,"replies":[{"id":"37549","content":"影响，所以才有全异步的方案","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1560517040,"ip_address":"","comment_id":103426,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855400488","product_id":100023901,"comment_content":"引用：<br>`<br>当 RPC 返回结果之前，阻塞调用线程，让调用线程等待；当 RPC 返回结果后，唤醒调用线程，让调用线程重新执行。<br>`<br>请问老师，这里线程等待是否影响了并发呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453872,"discussion_content":"影响，所以才有全异步的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560517040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86705,"user_name":"JGOS","can_delete":false,"product_type":"c1","uid":1237592,"ip_address":"","ucode":"46A905A169408F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/58/2468a5e9.jpg","comment_is_top":false,"comment_ctime":1555428266,"is_pvip":false,"replies":[{"id":"31313","content":"08里面讲过，mesa管程的固有写法<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555511174,"ip_address":"","comment_id":86705,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5850395562","product_id":100023901,"comment_content":"老师,在进入等待之前的为什么都是用while()进行判断啊, await和wait方法不是讲持有锁的线程挂起吗,为什么不用if做判断啊","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447128,"discussion_content":"08里面讲过，mesa管程的固有写法\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555511174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2289740,"avatar":"https://static001.geekbang.org/account/avatar/00/22/f0/4c/791d0f5e.jpg","nickname":"Geek_009527","note":"","ucode":"C57BD66CCEB3A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":581629,"discussion_content":"王老师，如果这里换成if条件行不行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658895062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":447128,"ip_address":""},"score":581629,"extra":""}]}]},{"had_liked":false,"id":345812,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652608484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652608484","product_id":100023901,"comment_content":"当前一个线程的异步，唤醒自身一个好点，唤醒其他额外增加请求资源。","like_count":0},{"had_liked":false,"id":339885,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1648451287,"is_pvip":false,"replies":[{"id":"125428","content":"像早期的http协议，属于请求响应模型，就是同步的，请求发过去之后，必须等待响应结果，有了响应结果以后才能发下一个请求。而TCP协议一个请求发过去，立刻就可以发送下一个请求，至于第一请求的结果，TCP是不关心的，请求和响应之间的关系，上层协议来处理。","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1650970967,"ip_address":"","comment_id":339885,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648451287","product_id":100023901,"comment_content":"老师能说下为啥TCP是异步的吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567664,"discussion_content":"像早期的http协议，属于请求响应模型，就是同步的，请求发过去之后，必须等待响应结果，有了响应结果以后才能发下一个请求。而TCP协议一个请求发过去，立刻就可以发送下一个请求，至于第一请求的结果，TCP是不关心的，请求和响应之间的关系，上层协议来处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650970967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337488,"user_name":"Spring4J","can_delete":false,"product_type":"c1","uid":1645430,"ip_address":"","ucode":"06F056085A2564","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","comment_is_top":false,"comment_ctime":1646847532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646847532","product_id":100023901,"comment_content":"直接使用CompletableFuture就完事了，还自己写一个DefaultFuture干啥呢","like_count":0},{"had_liked":false,"id":326463,"user_name":"Geek_c139e0","can_delete":false,"product_type":"c1","uid":2593255,"ip_address":"","ucode":"87C7E07E98354B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2msSWvJs8A6icPvUzyRs9DEqltYh0edy699wJz9BmCRoJj1bZHhBHhp4yY9Nic9oc2q8OdsVGwtmBRhKtw00Jj6Q/132","comment_is_top":false,"comment_ctime":1639535028,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639535028","product_id":100023901,"comment_content":"仔细想想，异步转同步用dubbo做例子不太合适，juc本身的实现就已经挺好了","like_count":0},{"had_liked":false,"id":315429,"user_name":"hl","can_delete":false,"product_type":"c1","uid":1385110,"ip_address":"","ucode":"E3280721BCFA6B","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/96/beb89790.jpg","comment_is_top":false,"comment_ctime":1633896731,"is_pvip":false,"replies":[{"id":"114498","content":"不一样，这个和公平没有关系","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1634123081,"ip_address":"","comment_id":315429,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633896731","product_id":100023901,"comment_content":"如果是公平锁的话，signal和signal all还是一样吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527978,"discussion_content":"不一样，这个和公平没有关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634123081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309974,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1630421428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630421428","product_id":100023901,"comment_content":"你自己看没看过源码，估计你自己看不懂吧，出来误人子弟，看了几本翻译的中文破书就出来骗钱擦","like_count":0},{"had_liked":false,"id":307565,"user_name":"mghio","can_delete":false,"product_type":"c1","uid":1213078,"ip_address":"","ucode":"74883EDE4FD0DC","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","comment_is_top":false,"comment_ctime":1629162534,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629162534","product_id":100023901,"comment_content":"请问一下，文中代码：<br><br>&#47;&#47; 创建锁与条件变量<br>private final Lock lock <br>    = new ReentrantLock();<br>private final Condition done <br>    = lock.newCondition();<br><br>&#47;&#47; 调用方通过该方法等待结果<br>Object get(int timeout){<br>  long start = System.nanoTime();<br>  lock.lock();<br>  try {<br>  while (!isDone()) {<br>    done.await(timeout);<br>      long cur=System.nanoTime();<br>    if (isDone() || <br>          cur-start &gt; timeout){<br>      break;<br>    }<br>  }<br>  } finally {<br>  lock.unlock();<br>  }<br>  if (!isDone()) {<br>  throw new TimeoutException();<br>  }<br>  return returnFromResponse();<br>}<br>&#47;&#47; RPC结果是否已经返回<br>boolean isDone() {<br>  return response != null;<br>}<br>&#47;&#47; RPC结果返回时调用该方法   <br>private void doReceived(Response res) {<br>  lock.lock();<br>  try {<br>    response = res;<br>    if (done != null) {<br>      done.signal();<br>    }<br>  } finally {<br>    lock.unlock();<br>  }<br>}<br><br>在分布式场景中如何保证一定会通知到这个加锁的实例上呢？","like_count":0},{"had_liked":false,"id":306829,"user_name":"黑道小宝","can_delete":false,"product_type":"c1","uid":1390488,"ip_address":"","ucode":"3B4D21A06B7C98","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/98/9cf9f719.jpg","comment_is_top":false,"comment_ctime":1628737850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628737850","product_id":100023901,"comment_content":"请教个问题，文中的超时判断放在调用await()之后，那还能抛出超时异常吗？","like_count":0},{"had_liked":false,"id":306326,"user_name":"苏彧","can_delete":false,"product_type":"c1","uid":1622448,"ip_address":"","ucode":"C016B28DF7449C","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/b0/b52d9ade.jpg","comment_is_top":false,"comment_ctime":1628497988,"is_pvip":true,"replies":[{"id":"112066","content":"同步，程序员更容易理解和使用","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1630131409,"ip_address":"","comment_id":306326,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1628497988","product_id":100023901,"comment_content":"老师，为什么异步要转成同步呢<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524718,"discussion_content":"同步，程序员更容易理解和使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630131409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2289740,"avatar":"https://static001.geekbang.org/account/avatar/00/22/f0/4c/791d0f5e.jpg","nickname":"Geek_009527","note":"","ucode":"C57BD66CCEB3A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":581628,"discussion_content":"转成同步不是会影响性能吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658894168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":524718,"ip_address":""},"score":581628,"extra":""}]}]},{"had_liked":false,"id":290799,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1619754753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619754753","product_id":100023901,"comment_content":"用的是 signal()，而不是 signalAll()，你来分析一下，这样做是否合理呢？这个不就是之前提倡的使用notifyAll来唤醒的道理一样嘛","like_count":0},{"had_liked":false,"id":290038,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1619334483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619334483","product_id":100023901,"comment_content":"老师，在上面的dubbo源码分析中，done只是充当了一个条件，也就是结果有没有返回，如果没返回就阻塞，否则就唤醒。  那应该如何为这个编写测试用例呢？ 我想了想不知道该如何编写，先假设在main函数中，新建了一个子线程，然后让子线程去异步调用A接口，在结果返回之前，再用子线程调用get(int timeout)函数，用来阻塞线程，此时当前子线程阻塞。然后返回结果后，再用主线程调用doReceived(Object res),用来唤醒子线程。<br><br>疑问1：让子线程去异步调用A接口，在结果返回之前，用子线程调用get(int timeout)函数，用来阻塞子线程。是用子线程调用get(int timeout)函数的嘛，还是用main线程去调用？<br>疑问2：主线程是如何知道子线程调用的结果已经返回了呢？<br><br><br><br>老师，这个有点乱，帮忙梳理下这个整个流程，谢谢。<br><br>","like_count":0},{"had_liked":false,"id":286414,"user_name":"时光守护者-基兰","can_delete":false,"product_type":"c1","uid":1554995,"ip_address":"","ucode":"F0B0887B1979D2","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","comment_is_top":false,"comment_ctime":1617288068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617288068","product_id":100023901,"comment_content":"老师有个疑问，是有返回结果才唤醒condition条件队列线程，如果唤醒后singAll随机一个线程去继续if (isDone() || cur-start &gt; timeout)，但是唤醒的这个线程!isDone()又继续去等待了不是有问题了吗，所以是所有的线程都在一个条件队列吗，如果不是那条件队列就一个线程为啥要singleAll呢<br>","like_count":0},{"had_liked":false,"id":271212,"user_name":"艺比天高","can_delete":false,"product_type":"c1","uid":1282162,"ip_address":"","ucode":"F52AC257F834A2","user_header":"https://static001.geekbang.org/account/avatar/00/13/90/72/e17e7c61.jpg","comment_is_top":false,"comment_ctime":1609472961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609472961","product_id":100023901,"comment_content":"我理解的异步在底层中比较多的的时候I&#47;O操作和CPU计算，在单核中创建两个线程，一个线程I&#47;O操作，一个线程CPU计算，一个线程读取I&#47;O操作时，等待时间比较长，这时候就会跳到另一个线程执行CPU计算，等到I&#47;O操作从DMA响应时，线程调度回来。","like_count":0},{"had_liked":false,"id":264226,"user_name":"Mr.Hwang","can_delete":false,"product_type":"c1","uid":2172620,"ip_address":"","ucode":"26EE6BF8EB1611","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/picb3nrC6rX6t4t6pHP8huAyrBa9g4lXCsY0uz2OicZsVsCfyLRg523CTWxX5AfEptxCMEC9DMuLZcia1cwzawhmg/132","comment_is_top":false,"comment_ctime":1606384374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606384374","product_id":100023901,"comment_content":"<br>    public void consume() {<br>        while (true) {<br>            try {<br>                rtl.lock();<br>                System.out.println(&quot;抢到锁了&quot;);<br>                if (queue.isEmpty() == false) {<br>                    System.out.println(Thread.currentThread().getName() + &quot;:2 队列已空，等待入队&quot;);<br>                    notFullCondition.signalAll();&#47;&#47;signal后还会继续执行<br>                    System.out.println(&quot;signalAll之后继续执行了&quot;);<br>                    notEmptyCondition.await();<br>                    System.out.println(&quot;await之后继续执行了&quot;);<br>                } else {<br>                    System.out.println(Thread.currentThread().getName() + &quot;:1 队列已空，等待入队&quot;);<br>                    notFullCondition.signalAll();<br>                    notEmptyCondition.await();<br>                }<br>            } catch (Exception e) {<br>                e.printStackTrace();<br>            } finally {<br>                rtl.unlock();<br>            }<br>        }<br>    }<br><br>    public void produce() {<br>        while (true) {<br>            try {<br>                rtl.lock();<br>                if (queue.isEmpty()) {<br>                    System.out.println(Thread.currentThread().getName() + &quot;: 1 队列已满，等待出队&quot;);<br>                    notEmptyCondition.signalAll();<br>                    notFullCondition.await();<br>                } else {<br>                    System.out.println(Thread.currentThread().getName() + &quot;:2 队列已满，等待出队&quot;);<br>                    notEmptyCondition.signalAll();<br>                    notFullCondition.await();<br>                }<br>            } catch (Exception e) {<br>                e.printStackTrace();<br>            } finally {<br>                rtl.unlock();<br>            }<br>        }<br>    }<br>}<br><br>老师帮我理一下，我这个代码是想测试以下：<br>1. await操作后，再次被唤醒，是否是从await之后的代码去执行的。从结果上来看，在consume执行await之后，再次唤醒，不会打印 抢到锁了 这几个字，而是打印了a wait之后继续执行了 这几个字，应该是印证了我的想法；<br>2. signalAll之后，会不会继续执行后面的代码。同样我发现signalAll之后，会执行后面的await方法，是不是说，signalAll通知之后还需要把后面的代码执行完才释放了锁？那这个方法的意义在哪里？我暂时想不到。<br>请老师为我解答一下，谢谢老师！","like_count":0},{"had_liked":false,"id":250087,"user_name":"尼糯米","can_delete":false,"product_type":"c1","uid":1282819,"ip_address":"","ucode":"04D1B63F3801AE","user_header":"","comment_is_top":false,"comment_ctime":1600930419,"is_pvip":false,"replies":[{"id":"91642","content":"没事了常来看看就好了������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1600956033,"ip_address":"","comment_id":250087,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600930419","product_id":100023901,"comment_content":"最近在了解CompletableFuture，然后就接触dubbo2.7版本引入的CompletableFuture，然后就想到这里的DefaultFuture，发现这里的内容都忘了，这个怎么办呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506130,"discussion_content":"没事了常来看看就好了������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600956033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244162,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1598414088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598414088","product_id":100023901,"comment_content":"done.await(timeout); 线程阻塞的时候加了时间戳，就算没有被唤醒时间超时后也能到获取锁的队列中，使用signal（）方法不会有问题。","like_count":0},{"had_liked":false,"id":237593,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1595896680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595896680","product_id":100023901,"comment_content":"不合理。因为创建Reentrantlock的时候是调用的无参构造函数，创建的是非公平锁。不会根据时间最长的去唤醒条件等待队列里的线程。如果创建锁时传入true就是合理的。","like_count":0},{"had_liked":false,"id":235835,"user_name":"sun","can_delete":false,"product_type":"c1","uid":1076100,"ip_address":"","ucode":"0358B9288D4018","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/84/d1e6eac9.jpg","comment_is_top":false,"comment_ctime":1595216290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595216290","product_id":100023901,"comment_content":"绝大多数情况下,dubbo的消费者的一个请求,都会涉及多个生产者的接口服务, 如果不采用主线程等待,多个副线程异步执行获取等待结果的调用模式,主线程调用链可能很长,很容易挂掉,超时,且无法有效进行服务降级,高并发情况下性能很差,线程池很快会被打满,  signalAll()更有利于线程资源的充分使用","like_count":0},{"had_liked":false,"id":232945,"user_name":"sibyl","can_delete":false,"product_type":"c1","uid":1323652,"ip_address":"","ucode":"0D142011860D69","user_header":"","comment_is_top":false,"comment_ctime":1594175127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594175127","product_id":100023901,"comment_content":"老师好，回答一下课后题<br><br>我理解的是每次rpc调用都会创建一把锁和条件变量，所以条件变量针对的是每次调用，因此await该条件变量的线程最多只有一个，所以signal和signalAll没有区别吧？？？","like_count":0},{"had_liked":false,"id":229447,"user_name":"惊蛰","can_delete":false,"product_type":"c1","uid":1500880,"ip_address":"","ucode":"8A03CC80666787","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvNozkiaiao1I945xyUGC0vXZSnibImBPbf7CtibqKoGDsbmZGnia62zibv4s3grqtVllO82tILEJ1Dh2w/132","comment_is_top":false,"comment_ctime":1592998392,"is_pvip":false,"replies":[{"id":"84694","content":"tcp协议是异步的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1593002894,"ip_address":"","comment_id":229447,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592998392","product_id":100023901,"comment_content":"老师好，在 TCP 协议层面，发送完 RPC 请求后，线程是不会等待 RPC 的响应结果的。 这句话能理解成‘ tcp 协议本身是异步的么’？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499485,"discussion_content":"tcp协议是异步的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593002894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226409,"user_name":"吴月月鸟","can_delete":false,"product_type":"c1","uid":1115064,"ip_address":"","ucode":"2F068EDD166B49","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/b8/961a5342.jpg","comment_is_top":false,"comment_ctime":1592068502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592068502","product_id":100023901,"comment_content":"看条件队列阻塞线程的数量，阻塞线程数量多个时：当一个线程请求完成，如果能精确唤醒队列中该线程，线程唤醒后判断已完成就立即返回。但signal是随机唤醒，则无法保障唤醒的是请求完成的线程，唤醒其他未完成请求的线程，其他线程就会再次阻塞，请求数量很多就有大概率，超时后也没有唤醒该请求完成的线程。如果能保障阻塞线程数量只有一个时，使用signal就不会有问题。","like_count":0},{"had_liked":false,"id":223760,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1591175697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591175697","product_id":100023901,"comment_content":"signal是唤醒任意一个线程，signalAll是唤醒条件变量的所有线程，应该是出于性能的考虑，只要有一个线程抢到锁返回结果就行，不需要所有线程去抢锁","like_count":0},{"had_liked":false,"id":222578,"user_name":"Geek_373e87","can_delete":false,"product_type":"c1","uid":1763335,"ip_address":"","ucode":"9DBAD30E4ED24A","user_header":"","comment_is_top":false,"comment_ctime":1590839238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590839238","product_id":100023901,"comment_content":"其实这里可以用闭锁,我觉得更简单","like_count":0},{"had_liked":false,"id":221562,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1590540714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590540714","product_id":100023901,"comment_content":"总感觉condition用起来很反直觉","like_count":0},{"had_liked":false,"id":221467,"user_name":"Geek_3422b1","can_delete":false,"product_type":"c1","uid":2007135,"ip_address":"","ucode":"ECD3AF9B1AFF13","user_header":"","comment_is_top":false,"comment_ctime":1590503735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590503735","product_id":100023901,"comment_content":"请问老师，signalAll 虽然会全部把条件队列里的等待线程唤醒，并且加入到同步队列，但是真正被恢复运行的依旧是条件队列里的第一个吧？从这点看和signal所达到的目标是一直的呀","like_count":0},{"had_liked":false,"id":191967,"user_name":"zhangchao","can_delete":false,"product_type":"c1","uid":1508339,"ip_address":"","ucode":"E665D153A85DE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/f3/0bd094ad.jpg","comment_is_top":false,"comment_ctime":1584806377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584806377","product_id":100023901,"comment_content":"感觉没必要优化成signalAll，当然用了也没问题，没必要揣摩阿里的心思","like_count":0},{"had_liked":false,"id":187866,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1584261673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584261673","product_id":100023901,"comment_content":"老师，我想问下为什么说在lock，condition中调用wait和notify会让程序乱七八糟呢，我看了下condition的源码是park和unpark，这会有影响吗？望老师解答，还是我理解的不太对","like_count":0},{"had_liked":false,"id":181590,"user_name":"楼下小黑哥","can_delete":false,"product_type":"c1","uid":1014680,"ip_address":"","ucode":"453B099B0EE52E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/98/8f1aecf4.jpg","comment_is_top":false,"comment_ctime":1582585345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582585345","product_id":100023901,"comment_content":"关于课后思考，Dubbo 相关 issue 如下：<br>https:&#47;&#47;github.com&#47;apache&#47;dubbo&#47;issues&#47;3678 <br>不过最新代码使用 CompletableFuture 重写这部分代码","like_count":0},{"had_liked":false,"id":177657,"user_name":"CDz","can_delete":false,"product_type":"c1","uid":1114779,"ip_address":"","ucode":"A23BEE1C4A5922","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9b/b1a3c60d.jpg","comment_is_top":false,"comment_ctime":1581466916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581466916","product_id":100023901,"comment_content":"RPC其实是异步的，RPC框架通过编程的方式，将异步转化为了同步，方便代码编写，如dubbo","like_count":0},{"had_liked":false,"id":176492,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1490049,"ip_address":"","ucode":"9360D9FBB2F851","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJpJz0SORayxydkezyVfk4TvDcJjSahuMbvXPkCbvvjC4RLt6picrlp4rrxXm22TbRQrbC6ibl8zNSw/132","comment_is_top":false,"comment_ctime":1581071449,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581071449","product_id":100023901,"comment_content":"CPU waits for no io operation.","like_count":0},{"had_liked":false,"id":175810,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1580832592,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1580832592","product_id":100023901,"comment_content":"老师 dubbbo 的源码有个问题 就是 rpc返回之后 调用doReceived()方法 里面的锁  不是已经被get()方法占用了吗 怎么还能获取到呢？","like_count":0,"discussions":[{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200206,"discussion_content":"consumer线程调用future.get()方法，先获取lock锁，然后执行 this.done.await(long)方法，调用条件变量done的await()方法，consumer线程会释放lock锁，然后进入条件变量done的等待队列。\n&#34;The lock associated with this {@code Condition} is atomically\n     * released&#34;","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1583668071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200434,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583680200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":200206,"ip_address":""},"score":200434,"extra":""}]}]},{"had_liked":false,"id":175120,"user_name":"张越","can_delete":false,"product_type":"c1","uid":1670311,"ip_address":"","ucode":"5A479BE90D0712","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/a7/6a69b3d3.jpg","comment_is_top":false,"comment_ctime":1580562983,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580562983","product_id":100023901,"comment_content":" public static DefaultFuture newFuture(Channel channel, Request request, int timeout, ExecutorService executor) {<br>        final DefaultFuture future = new DefaultFuture(channel, request, timeout);<br>        future.setExecutor(executor);<br>        &#47;&#47; timeout check<br>        timeoutCheck(future);<br>        return future;<br>    }<br>通过阅读源码，DefaultFuture  是多实例，所以使用signal也可以","like_count":0,"discussions":[{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278349,"discussion_content":"是啊，我也觉得","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591176662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171583,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1578969164,"is_pvip":false,"replies":[{"id":"66611","content":"Lock功能更全，早期版本性能业更好，所以大家都习惯用Lock了?","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579013899,"ip_address":"","comment_id":171583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578969164","product_id":100023901,"comment_content":"老师。为啥不用synchronzied实现阻塞队列呀。而且代码好像还更简洁。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481421,"discussion_content":"Lock功能更全，早期版本性能业更好，所以大家都习惯用Lock了?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579013899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162355,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1576503146,"is_pvip":false,"replies":[{"id":"62405","content":"有些书是这么写的，不过当我看到canEnq的时候，我没有立刻明白为啥canEnq？后来才发现原因是notFull","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1576910895,"ip_address":"","comment_id":162355,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576503146","product_id":100023901,"comment_content":"notFull 和 notEmpty 让人很晕 改成 canEnq 和 canDeq 更好懂","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478023,"discussion_content":"有些书是这么写的，不过当我看到canEnq的时候，我没有立刻明白为啥canEnq？后来才发现原因是notFull","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576910895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555318,"discussion_content":"管程里面定义的叫做条件变量和条件队列，notFull这种就是条件，意思是满足这个条件才能干嘛，而canEnq这种名称更像是一种满足条件才能产生的结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646847943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145120,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1572220482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572220482","product_id":100023901,"comment_content":"异步和同步的区别是：获取结果的方式<br><br>同步是需要等待结果；而异步无需等待结果，而是通过回调或者通知得到结果。","like_count":0},{"had_liked":false,"id":134352,"user_name":"森呢","can_delete":false,"product_type":"c1","uid":1239193,"ip_address":"","ucode":"B3D07ACF710B11","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/99/0ea71e63.jpg","comment_is_top":false,"comment_ctime":1568811912,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568811912","product_id":100023901,"comment_content":"还是没明白为什么还成signlall()后和用signl有什么优化的地方","like_count":0,"discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555319,"discussion_content":"使用signalall肯定不会有问题。而使用signal可能会有问题，比如说多个线程持有这个对象并调用get方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646848076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128888,"user_name":"dingdongfm","can_delete":false,"product_type":"c1","uid":1564213,"ip_address":"","ucode":"7D17D2BC392A66","user_header":"","comment_is_top":false,"comment_ctime":1566980407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566980407","product_id":100023901,"comment_content":"文中同步和异步的理解应该是阻塞和非阻塞的定义。即针对调用者来说的。而同步和非同步是针对被调用者来说的。","like_count":0},{"had_liked":false,"id":126303,"user_name":"liian2019","can_delete":false,"product_type":"c1","uid":1503741,"ip_address":"","ucode":"22F639944F0EA0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epvjpicXzEv02d9ztRzIWIicbejyFTTtRA5K6oYmdicq9HQgGfRn3DLytTHQ6CHspb0TibqFkMibhBXj2g/132","comment_is_top":false,"comment_ctime":1566359104,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1566359104","product_id":100023901,"comment_content":"我觉得合理 因为每个request对应一个自己的DefaultFuture实例 线程之间是不会冲突的 所有只需要signal就够了 但是不知道为啥改成signalAll了","like_count":0},{"had_liked":false,"id":118638,"user_name":"HUANGKAIHANG","can_delete":false,"product_type":"c1","uid":1430163,"ip_address":"","ucode":"F3871C5142AE52","user_header":"https://static001.geekbang.org/account/avatar/00/15/d2/93/9c58ce42.jpg","comment_is_top":false,"comment_ctime":1564404114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564404114","product_id":100023901,"comment_content":"老师你好，每个请求都是由独立的线程去负责的，所以其实在做doReceived时，要唤醒的目标线程只会有一个，这是一对一的关系。你在评论回复里说dubbo对doReceived做了优化，把signal改成了signalALL，请问这是优化在哪？","like_count":0},{"had_liked":false,"id":117480,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1564057562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564057562","product_id":100023901,"comment_content":"那浏览器请求资源，照理http是基于TCP的，那也是异步么？","like_count":0},{"had_liked":false,"id":117448,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1564049051,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1564049051","product_id":100023901,"comment_content":"请问RPC为什么要做异步转同步？","like_count":0,"discussions":[{"author":{"id":1503741,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epvjpicXzEv02d9ztRzIWIicbejyFTTtRA5K6oYmdicq9HQgGfRn3DLytTHQ6CHspb0TibqFkMibhBXj2g/132","nickname":"liian2019","note":"","ucode":"22F639944F0EA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51007,"discussion_content":"因为tcp发送是异步的，比如用netty的writeAndFlush方法，发完是没有结果的，需要等待服务端返回结果，就把调用线程堵塞住，等服务端调用成功结果返回到客户端，调用doReceived的方法 唤醒堵塞住的线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573798671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477612,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","nickname":"张天屹","note":"","ucode":"8BD6BD6DCF0F4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4030,"discussion_content":"我理解的是RPC执行远程调用，为的是“像调用本地方法”一样，而调用本地方法是同步的，往往都需要在后续程序中针对返回的结果进行某种操作，如果异步的话，我理解除非就是完全不依赖返回结果吧，啥都给服务端做完了，做就完事了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565070543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116335,"user_name":"Shine","can_delete":false,"product_type":"c1","uid":1022568,"ip_address":"","ucode":"C8C617B87C63C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","comment_is_top":false,"comment_ctime":1563842255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563842255","product_id":100023901,"comment_content":"<br><br>异步不一定是新开线程实现异步，还有异步I&#47;O，异步I&#47;O跟操作系统实现相关，并不需要新开线程？","like_count":0},{"had_liked":false,"id":105367,"user_name":"招财","can_delete":false,"product_type":"c1","uid":1249970,"ip_address":"","ucode":"8A6781148A9932","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/b2/3fb9a4a1.jpg","comment_is_top":false,"comment_ctime":1560990666,"is_pvip":false,"replies":[{"id":"38250","content":"读锁能保证可见性和读多个变量时的一致性","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561076588,"ip_address":"","comment_id":105367,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560990666","product_id":100023901,"comment_content":"老师，这个读锁，就是可以让很多个线程可以访问他，那我只加写锁，不加读锁可以吗？感觉读锁，好像并没有什么用呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454649,"discussion_content":"读锁能保证可见性和读多个变量时的一致性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561076588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92154,"user_name":"谢特","can_delete":false,"product_type":"c1","uid":1248684,"ip_address":"","ucode":"9C30DBFECFE649","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/ac/09678490.jpg","comment_is_top":false,"comment_ctime":1557192615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557192615","product_id":100023901,"comment_content":"demo那个类，加timeout有用吗，和不加有区别，怎么不都是一直死循环吗","like_count":0},{"had_liked":false,"id":91787,"user_name":"Wynn","can_delete":false,"product_type":"c1","uid":1444094,"ip_address":"","ucode":"43F4616B1BAB1A","user_header":"https://static001.geekbang.org/account/avatar/00/16/08/fe/dff70a08.jpg","comment_is_top":false,"comment_ctime":1557108009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557108009","product_id":100023901,"comment_content":"get方法里throw TimeoutException在锁外面会不会导致超时却不会抛出异常的情况？","like_count":0},{"had_liked":false,"id":90608,"user_name":"谢特","can_delete":false,"product_type":"c1","uid":1248684,"ip_address":"","ucode":"9C30DBFECFE649","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/ac/09678490.jpg","comment_is_top":false,"comment_ctime":1556587554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556587554","product_id":100023901,"comment_content":"shell脚本中nohup 启动一个任务，那么这个就是异步","like_count":0},{"had_liked":false,"id":89477,"user_name":"Just","can_delete":false,"product_type":"c1","uid":1486087,"ip_address":"","ucode":"54DFB8120E1B96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qqPULdMQxtY3hv1hyuyaHgzGulEoo8q1KaSWnllp6I7OzK6pZpy7ujtmrtavVVcsicibWWjKicnqd5vugiczj5XFqQ/132","comment_is_top":false,"comment_ctime":1556182298,"is_pvip":false,"replies":[{"id":"32187","content":"https:&#47;&#47;github.com&#47;apache&#47;incubator-dubbo&#47;blob&#47;master&#47;dubbo-remoting&#47;dubbo-remoting-api&#47;src&#47;main&#47;java&#47;org&#47;apache&#47;dubbo&#47;remoting&#47;exchange&#47;support&#47;DefaultFuture.java#L332","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556284234,"ip_address":"","comment_id":89477,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556182298","product_id":100023901,"comment_content":"signal替换为 signalall 是在哪个版本呢，我没找到区别，还是使用了其他方式替代<br><br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448147,"discussion_content":"https://github.com/apache/incubator-dubbo/blob/master/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/exchange/support/DefaultFuture.java#L332","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556284234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87274,"user_name":"xiaoxiangran","can_delete":false,"product_type":"c1","uid":1007520,"ip_address":"","ucode":"E58E09261D1916","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/a0/bc54404a.jpg","comment_is_top":false,"comment_ctime":1555556632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555556632","product_id":100023901,"comment_content":"这里想问个关于请求实现方式的问题，请问像阿里双11这种场景，比然是高并发的，那页面上的请求是用同步还是异步呢？如果是同步的话，后端那么多节点的处理，一旦处理时间过长，请求线程必然会长时间占用，连接等资源会消耗的很快；如果是异步请求的话，最终的结果是通过不断轮询拿到吗，这不是无形中增加了后端的请求量吗？","like_count":0},{"had_liked":false,"id":82567,"user_name":"果然如此","can_delete":false,"product_type":"c1","uid":1210003,"ip_address":"","ucode":"C7543BD0A67505","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","comment_is_top":false,"comment_ctime":1554252562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554252562","product_id":100023901,"comment_content":"做过一个用webkit抓取网页的爬虫就是异步转同步，while循环里判断一个共享变量状态是否完成页面加载，循环内部有sleep等待，还有超时判断后break。","like_count":0},{"had_liked":false,"id":82417,"user_name":"ken","can_delete":false,"product_type":"c1","uid":1048245,"ip_address":"","ucode":"A43E42B541624D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/b5/df0f658f.jpg","comment_is_top":false,"comment_ctime":1554205576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554205576","product_id":100023901,"comment_content":"合理","like_count":0},{"had_liked":false,"id":82402,"user_name":"海连天","can_delete":false,"product_type":"c1","uid":1072690,"ip_address":"","ucode":"8CFAFA59086BFA","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/32/1ccb2b7c.jpg","comment_is_top":false,"comment_ctime":1554201634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554201634","product_id":100023901,"comment_content":"可能会有问题，因为请求是异步的，如果特殊场景下调用done.await之前，已经调用过done.signal，可能会导致等待的线程超时","like_count":0},{"had_liked":false,"id":82318,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1554184256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554184256","product_id":100023901,"comment_content":"合理，只有一个等待条件","like_count":0},{"had_liked":false,"id":82268,"user_name":"胡桥","can_delete":false,"product_type":"c1","uid":1055874,"ip_address":"","ucode":"673C3207614010","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/82/74ab79df.jpg","comment_is_top":false,"comment_ctime":1554173015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554173015","product_id":100023901,"comment_content":"notEmpty和notFull将两个之前用业务代码判断的条件彻底分开了，因此之前用synchronized-wait-notify-notifyAll方式时“一个锁锁多个条件”的情况就不存在了。因此signal叫醒的一个线程肯定是一个“对的”线程。","like_count":0},{"had_liked":false,"id":82259,"user_name":"suke","can_delete":false,"product_type":"c1","uid":1007753,"ip_address":"","ucode":"C0287C31A4F45B","user_header":"","comment_is_top":false,"comment_ctime":1554171187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554171187","product_id":100023901,"comment_content":"老师能具体说一说创建云主机异步转同步的问题么，尤其是遇到内部硬件资源（内存、cpu等）不足时，异步的线程需要如何处理这种情况","like_count":0},{"had_liked":false,"id":82242,"user_name":"橘子","can_delete":false,"product_type":"c1","uid":1368522,"ip_address":"","ucode":"EDF6145878F897","user_header":"https://static001.geekbang.org/account/avatar/00/14/e1/ca/d8b0835f.jpg","comment_is_top":false,"comment_ctime":1554168247,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554168247","product_id":100023901,"comment_content":"首先，我觉得上面的同学有的说的不对，如果是每次都new一个，那么没必要用到锁，用空自旋加可见性关键字就能解决问题。所有我觉得应该是异步调用实际上每次都只回调一次，没有必要所有的线程都来抢夺资源(高并发状态下应该上下文切换很严重)，只通知队头的来就行了","like_count":0}]}