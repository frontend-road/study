{"id":223111,"title":"15 | 序列化：一来一回你还是原来的你吗？","content":"<p>你好，我是朱晔。今天，我来和你聊聊序列化相关的坑和最佳实践。</p><p>序列化是把对象转换为字节流的过程，以方便传输或存储。反序列化，则是反过来把字节流转换为对象的过程。在介绍<a href=\"https://time.geekbang.org/column/article/223051\">文件IO</a>的时候，我提到字符编码是把字符转换为二进制的过程，至于怎么转换需要由字符集制定规则。同样地，对象的序列化和反序列化，也需要由序列化算法制定规则。</p><p>关于序列化算法，几年前常用的有JDK（Java）序列化、XML序列化等，但前者不能跨语言，后者性能较差（时间空间开销大）；现在RESTful应用最常用的是JSON序列化，追求性能的RPC框架（比如gRPC）使用protobuf序列化，这2种方法都是跨语言的，而且性能不错，应用广泛。</p><p>在架构设计阶段，我们可能会重点关注算法选型，在性能、易用性和跨平台性等中权衡，不过这里的坑比较少。通常情况下，序列化问题常见的坑会集中在业务场景中，比如Redis、参数和响应序列化反序列化。</p><p>今天，我们就一起聊聊开发中序列化常见的一些坑吧。</p><h2>序列化和反序列化需要确保算法一致</h2><p>业务代码中涉及序列化时，很重要的一点是要确保序列化和反序列化的算法一致性。有一次我要排查缓存命中率问题，需要运维同学帮忙拉取Redis中的Key，结果他反馈Redis中存的都是乱码，怀疑Redis被攻击了。其实呢，这个问题就是序列化算法导致的，我们来看下吧。</p><!-- [[[read_end]]] --><p>在这个案例中，开发同学使用RedisTemplate来操作Redis进行数据缓存。因为相比于Jedis，使用Spring提供的RedisTemplate操作Redis，除了无需考虑连接池、更方便外，还可以与Spring Cache等其他组件无缝整合。如果使用Spring Boot的话，无需任何配置就可以直接使用。</p><p>数据（包含Key和Value）要保存到Redis，需要经过序列化算法来序列化成字符串。虽然Redis支持多种数据结构，比如Hash，但其每一个field的Value还是字符串。如果Value本身也是字符串的话，能否有便捷的方式来使用RedisTemplate，而无需考虑序列化呢？</p><p>其实是有的，那就是StringRedisTemplate。</p><p>那StringRedisTemplate和RedisTemplate的区别是什么呢？开头提到的乱码又是怎么回事呢？带着这些问题让我们来研究一下吧。</p><p>写一段测试代码，在应用初始化完成后向Redis设置两组数据，第一次使用RedisTemplate设置Key为redisTemplate、Value为User对象，第二次使用StringRedisTemplate设置Key为stringRedisTemplate、Value为JSON序列化后的User对象：</p><pre><code>@Autowired\nprivate RedisTemplate redisTemplate;\n@Autowired\nprivate StringRedisTemplate stringRedisTemplate;\n@Autowired\nprivate ObjectMapper objectMapper;\n\n@PostConstruct\npublic void init() throws JsonProcessingException {\n    redisTemplate.opsForValue().set(&quot;redisTemplate&quot;, new User(&quot;zhuye&quot;, 36));\n    stringRedisTemplate.opsForValue().set(&quot;stringRedisTemplate&quot;, objectMapper.writeValueAsString(new User(&quot;zhuye&quot;, 36)));\n}\n</code></pre><p>如果你认为，StringRedisTemplate和RedisTemplate的区别，无非是读取的Value是String和Object，那就大错特错了，因为使用这两种方式存取的数据完全无法通用。</p><p>我们做个小实验，通过RedisTemplate读取Key为stringRedisTemplate的Value，使用StringRedisTemplate读取Key为redisTemplate的Value：</p><pre><code>log.info(&quot;redisTemplate get {}&quot;, redisTemplate.opsForValue().get(&quot;stringRedisTemplate&quot;));\nlog.info(&quot;stringRedisTemplate get {}&quot;, stringRedisTemplate.opsForValue().get(&quot;redisTemplate&quot;));\n</code></pre><p>结果是，两次都无法读取到Value：</p><pre><code>[11:49:38.478] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:38  ] - redisTemplate get null\n[11:49:38.481] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:39  ] - stringRedisTemplate get null\n</code></pre><p>通过redis-cli客户端工具连接到Redis，你会发现根本就没有叫作redisTemplate的Key，所以StringRedisTemplate无法查到数据：</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/35/0a86608821f52833e3ffaecb69945635.png?wh=670*120\" alt=\"\"></p><p>查看RedisTemplate的源码发现，默认情况下RedisTemplate针对Key和Value使用了JDK序列化：</p><pre><code>public void afterPropertiesSet() {\n\t...\n\tif (defaultSerializer == null) {\n\t\tdefaultSerializer = new JdkSerializationRedisSerializer(\n\t\t\t\tclassLoader != null ? classLoader : this.getClass().getClassLoader());\n\t}\n\tif (enableDefaultSerializer) {\n\t\tif (keySerializer == null) {\n\t\t\tkeySerializer = defaultSerializer;\n\t\t\tdefaultUsed = true;\n\t\t}\n\t\tif (valueSerializer == null) {\n\t\t\tvalueSerializer = defaultSerializer;\n\t\t\tdefaultUsed = true;\n\t\t}\n\t\tif (hashKeySerializer == null) {\n\t\t\thashKeySerializer = defaultSerializer;\n\t\t\tdefaultUsed = true;\n\t\t}\n\t\tif (hashValueSerializer == null) {\n\t\t\thashValueSerializer = defaultSerializer;\n\t\t\tdefaultUsed = true;\n\t\t}\n\t}\n\t...\n}\n</code></pre><p><strong>redis-cli看到的类似一串乱码的\"\\xac\\xed\\x00\\x05t\\x00\\rredisTemplate\"字符串，其实就是字符串redisTemplate经过JDK序列化后的结果</strong>。这就回答了之前提到的乱码问题。而RedisTemplate尝试读取Key为stringRedisTemplate数据时，也会对这个字符串进行JDK序列化处理，所以同样无法读取到数据。</p><p>而StringRedisTemplate对于Key和Value，使用的是String序列化方式，Key和Value只能是String：</p><pre><code>public class StringRedisTemplate extends RedisTemplate&lt;String, String&gt; {\n\tpublic StringRedisTemplate() {\n\t\tsetKeySerializer(RedisSerializer.string());\n\t\tsetValueSerializer(RedisSerializer.string());\n\t\tsetHashKeySerializer(RedisSerializer.string());\n\t\tsetHashValueSerializer(RedisSerializer.string());\n\t}\n}\n\npublic class StringRedisSerializer implements RedisSerializer&lt;String&gt; {\n\t@Override\n\tpublic String deserialize(@Nullable byte[] bytes) {\n\t\treturn (bytes == null ? null : new String(bytes, charset));\n\t}\n\n\t@Override\n\tpublic byte[] serialize(@Nullable String string) {\n\t\treturn (string == null ? null : string.getBytes(charset));\n\t}\n}\n</code></pre><p>看到这里，我们应该知道RedisTemplate和StringRedisTemplate保存的数据无法通用。修复方式就是，让它们读取自己存的数据：</p><ul>\n<li>使用RedisTemplate读出的数据，由于是Object类型的，使用时可以先强制转换为User类型；</li>\n<li>使用StringRedisTemplate读取出的字符串，需要手动将JSON反序列化为User类型。</li>\n</ul><pre><code>//使用RedisTemplate获取Value，无需反序列化就可以拿到实际对象，虽然方便，但是Redis中保存的Key和Value不易读\nUser userFromRedisTemplate = (User) redisTemplate.opsForValue().get(&quot;redisTemplate&quot;);\nlog.info(&quot;redisTemplate get {}&quot;, userFromRedisTemplate);\n\n//使用StringRedisTemplate，虽然Key正常，但是Value存取需要手动序列化成字符串\nUser userFromStringRedisTemplate = objectMapper.readValue(stringRedisTemplate.opsForValue().get(&quot;stringRedisTemplate&quot;), User.class);\nlog.info(&quot;stringRedisTemplate get {}&quot;, userFromStringRedisTemplate);\n</code></pre><p>这样就可以得到正确输出：</p><pre><code>[13:32:09.087] [http-nio-45678-exec-6] [INFO ] [.t.c.s.demo1.RedisTemplateController:45  ] - redisTemplate get User(name=zhuye, age=36)\n[13:32:09.092] [http-nio-45678-exec-6] [INFO ] [.t.c.s.demo1.RedisTemplateController:47  ] - stringRedisTemplate get User(name=zhuye, age=36)\n</code></pre><p>看到这里你可能会说，使用RedisTemplate获取Value虽然方便，但是Key和Value不易读；而使用StringRedisTemplate虽然Key是普通字符串，但是Value存取需要手动序列化成字符串，有没有两全其美的方式呢？</p><p>当然有，自己定义RedisTemplate的Key和Value的序列化方式即可：Key的序列化使用RedisSerializer.string()（也就是StringRedisSerializer方式）实现字符串序列化，而Value的序列化使用Jackson2JsonRedisSerializer：</p><pre><code>@Bean\npublic &lt;T&gt; RedisTemplate&lt;String, T&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n    RedisTemplate&lt;String, T&gt; redisTemplate = new RedisTemplate&lt;&gt;();\n    redisTemplate.setConnectionFactory(redisConnectionFactory);\n    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n    redisTemplate.setKeySerializer(RedisSerializer.string());\n    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n    redisTemplate.setHashKeySerializer(RedisSerializer.string());\n    redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n    redisTemplate.afterPropertiesSet();\n    return redisTemplate;\n}\n</code></pre><p>写代码测试一下存取，直接注入类型为RedisTemplate&lt;String, User&gt;的userRedisTemplate字段，然后在right2方法中，使用注入的userRedisTemplate存入一个User对象，再分别使用userRedisTemplate和StringRedisTemplate取出这个对象：</p><pre><code>@Autowired\nprivate RedisTemplate&lt;String, User&gt; userRedisTemplate;\n\n@GetMapping(&quot;right2&quot;)\npublic void right2() {\n    User user = new User(&quot;zhuye&quot;, 36);\n    userRedisTemplate.opsForValue().set(user.getName(), user);\n    Object userFromRedis = userRedisTemplate.opsForValue().get(user.getName());\n    log.info(&quot;userRedisTemplate get {} {}&quot;, userFromRedis, userFromRedis.getClass());\n    log.info(&quot;stringRedisTemplate get {}&quot;, stringRedisTemplate.opsForValue().get(user.getName()));\n}\n</code></pre><p>乍一看没啥问题，StringRedisTemplate成功查出了我们存入的数据：</p><pre><code>[14:07:41.315] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:55  ] - userRedisTemplate get {name=zhuye, age=36} class java.util.LinkedHashMap\n[14:07:41.318] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:56  ] - stringRedisTemplate get {&quot;name&quot;:&quot;zhuye&quot;,&quot;age&quot;:36}\n</code></pre><p>Redis里也可以查到Key是纯字符串，Value是JSON序列化后的User对象：</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/cc/ac20bd2117053fafee390bbb6ce1eccc.png?wh=568*76\" alt=\"\"></p><p>但值得注意的是，这里有一个坑。<strong>第一行的日志输出显示，userRedisTemplate获取到的Value，是LinkedHashMap类型的</strong>，完全不是泛型的RedisTemplate设置的User类型。</p><p>如果我们把代码里从Redis中获取到的Value变量类型由Object改为User，编译不会出现问题，但会出现ClassCastException：</p><pre><code>java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to org.geekbang.time.commonmistakes.serialization.demo1.User\n</code></pre><p>修复方式是，修改自定义RestTemplate的代码，把new出来的Jackson2JsonRedisSerializer设置一个自定义的ObjectMapper，启用activateDefaultTyping方法把类型信息作为属性写入序列化后的数据中（当然了，你也可以调整JsonTypeInfo.As枚举以其他形式保存类型信息）：</p><pre><code>...\nJackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\nObjectMapper objectMapper = new ObjectMapper();\n//把类型信息作为属性写入Value\nobjectMapper.activateDefaultTyping(objectMapper.getPolymorphicTypeValidator(), ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\njackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n...\n</code></pre><p>或者，直接使用RedisSerializer.json()快捷方法，它内部使用的GenericJackson2JsonRedisSerializer直接设置了把类型作为属性保存到Value中：</p><pre><code>redisTemplate.setKeySerializer(RedisSerializer.string());\nredisTemplate.setValueSerializer(RedisSerializer.json());\nredisTemplate.setHashKeySerializer(RedisSerializer.string());\nredisTemplate.setHashValueSerializer(RedisSerializer.json());\n</code></pre><p>重启程序调用right2方法进行测试，可以看到，从自定义的RedisTemplate中获取到的Value是User类型的（第一行日志），而且Redis中实际保存的Value包含了类型完全限定名（第二行日志）：</p><pre><code>[15:10:50.396] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:55  ] - userRedisTemplate get User(name=zhuye, age=36) class org.geekbang.time.commonmistakes.serialization.demo1.User\n[15:10:50.399] [http-nio-45678-exec-1] [INFO ] [.t.c.s.demo1.RedisTemplateController:56  ] - stringRedisTemplate get [&quot;org.geekbang.time.commonmistakes.serialization.demo1.User&quot;,{&quot;name&quot;:&quot;zhuye&quot;,&quot;age&quot;:36}]\n</code></pre><p>因此，反序列化时可以直接得到User类型的Value。</p><p>通过对RedisTemplate组件的分析，可以看到，当数据需要序列化后保存时，读写数据使用一致的序列化算法的必要性，否则就像对牛弹琴。</p><p>这里，我再总结下Spring提供的4种RedisSerializer（Redis序列化器）：</p><ul>\n<li>默认情况下，RedisTemplate使用JdkSerializationRedisSerializer，也就是JDK序列化，容易产生Redis中保存了乱码的错觉。</li>\n<li>通常考虑到易读性，可以设置Key的序列化器为StringRedisSerializer。但直接使用RedisSerializer.string()，相当于使用了UTF_8编码的StringRedisSerializer，需要注意字符集问题。</li>\n<li>如果希望Value也是使用JSON序列化的话，可以把Value序列化器设置为Jackson2JsonRedisSerializer。默认情况下，不会把类型信息保存在Value中，即使我们定义RedisTemplate的Value泛型为实际类型，查询出的Value也只能是LinkedHashMap类型。如果希望直接获取真实的数据类型，你可以启用Jackson ObjectMapper的activateDefaultTyping方法，把类型信息一起序列化保存在Value中。</li>\n<li>如果希望Value以JSON保存并带上类型信息，更简单的方式是，直接使用RedisSerializer.json()快捷方法来获取序列化器。</li>\n</ul><h2>注意Jackson JSON反序列化对额外字段的处理</h2><p>前面我提到，通过设置JSON序列化工具Jackson的activateDefaultTyping方法，可以在序列化数据时写入对象类型。其实，Jackson还有很多参数可以控制序列化和反序列化，是一个功能强大而完善的序列化工具。因此，很多框架都将Jackson作为JDK序列化工具，比如Spring Web。但也正是这个原因，我们使用时要小心各个参数的配置。</p><p>比如，在开发Spring Web应用程序时，如果自定义了ObjectMapper，并把它注册成了Bean，那很可能会导致Spring Web使用的ObjectMapper也被替换，导致Bug。</p><p>我们来看一个案例。程序一开始是正常的，某一天开发同学希望修改一下ObjectMapper的行为，让枚举序列化为索引值而不是字符串值，比如默认情况下序列化一个Color枚举中的Color.BLUE会得到字符串BLUE：</p><pre><code>@Autowired\nprivate ObjectMapper objectMapper;\n\n@GetMapping(&quot;test&quot;)\npublic void test() throws JsonProcessingException {\n\tlog.info(&quot;color:{}&quot;, objectMapper.writeValueAsString(Color.BLUE));\n}\n\nenum Color {\n    RED, BLUE\n}\n</code></pre><p>于是，这位同学就重新定义了一个ObjectMapper Bean，开启了WRITE_ENUMS_USING_INDEX功能特性：</p><pre><code>@Bean\npublic ObjectMapper objectMapper(){\n    ObjectMapper objectMapper=new ObjectMapper();\n    objectMapper.configure(SerializationFeature.WRITE_ENUMS_USING_INDEX,true);\n    return objectMapper;\n}\n</code></pre><p>开启这个特性后，Color.BLUE枚举序列化成索引值1：</p><pre><code>[16:11:37.382] [http-nio-45678-exec-1] [INFO ] [c.s.d.JsonIgnorePropertiesController:19  ] - color:1\n</code></pre><p>修改后处理枚举序列化的逻辑是满足了要求，但线上爆出了大量400错误，日志中也出现了很多UnrecognizedPropertyException：</p><pre><code>JSON parse error: Unrecognized field \\&quot;ver\\&quot; (class org.geekbang.time.commonmistakes.serialization.demo4.UserWrong), not marked as ignorable; nested exception is com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \\&quot;version\\&quot; (class org.geekbang.time.commonmistakes.serialization.demo4.UserWrong), not marked as ignorable (one known property: \\&quot;name\\&quot;])\\n at [Source: (PushbackInputStream); line: 1, column: 22] (through reference chain: org.geekbang.time.commonmistakes.serialization.demo4.UserWrong[\\&quot;ver\\&quot;])\n</code></pre><p>从异常信息中可以看到，这是因为反序列化的时候，原始数据多了一个version属性。进一步分析发现，我们使用了UserWrong类型作为Web控制器wrong方法的入参，其中只有一个name属性：</p><pre><code>@Data\npublic class UserWrong {\n    private String name;\n}\n\n@PostMapping(&quot;wrong&quot;)\npublic UserWrong wrong(@RequestBody UserWrong user) {\n    return user;\n}\n</code></pre><p>而客户端实际传过来的数据多了一个version属性。那，为什么之前没这个问题呢？</p><p>问题就出在，<strong>自定义ObjectMapper启用WRITE_ENUMS_USING_INDEX序列化功能特性时，覆盖了Spring Boot自动创建的ObjectMapper</strong>；而这个自动创建的ObjectMapper设置过FAIL_ON_UNKNOWN_PROPERTIES反序列化特性为false，以确保出现未知字段时不要抛出异常。源码如下：</p><pre><code>public MappingJackson2HttpMessageConverter() {\n\tthis(Jackson2ObjectMapperBuilder.json().build());\n}\n\n\npublic class Jackson2ObjectMapperBuilder {\n\n...\n\n\tprivate void customizeDefaultFeatures(ObjectMapper objectMapper) {\n\t\tif (!this.features.containsKey(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n\t\t\tconfigureFeature(objectMapper, MapperFeature.DEFAULT_VIEW_INCLUSION, false);\n\t\t}\n\t\tif (!this.features.containsKey(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n\t\t\tconfigureFeature(objectMapper, DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\t}\n\t}\n}\n</code></pre><p>要修复这个问题，有三种方式：</p><ul>\n<li>第一种，同样禁用自定义的ObjectMapper的FAIL_ON_UNKNOWN_PROPERTIES：</li>\n</ul><pre><code>@Bean\npublic ObjectMapper objectMapper(){\n    ObjectMapper objectMapper=new ObjectMapper();\n    objectMapper.configure(SerializationFeature.WRITE_ENUMS_USING_INDEX,true);\n    objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);\n    return objectMapper;\n}\n</code></pre><ul>\n<li>第二种，设置自定义类型，加上@JsonIgnoreProperties注解，开启ignoreUnknown属性，以实现反序列化时忽略额外的数据：</li>\n</ul><pre><code>@Data\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class UserRight {\n    private String name;\n}\n</code></pre><ul>\n<li>第三种，不要自定义ObjectMapper，而是直接在配置文件设置相关参数，来修改Spring默认的ObjectMapper的功能。比如，直接在配置文件启用把枚举序列化为索引号：</li>\n</ul><pre><code>spring.jackson.serialization.write_enums_using_index=true\n</code></pre><p>或者可以直接定义Jackson2ObjectMapperBuilderCustomizer Bean来启用新特性：</p><pre><code>@Bean\npublic Jackson2ObjectMapperBuilderCustomizer customizer(){\n    return builder -&gt; builder.featuresToEnable(SerializationFeature.WRITE_ENUMS_USING_INDEX);\n}\n</code></pre><p>这个案例告诉我们两点：</p><ul>\n<li>Jackson针对序列化和反序列化有大量的细节功能特性，我们可以参考Jackson官方文档来了解这些特性，详见<a href=\"https://fasterxml.github.io/jackson-databind/javadoc/2.10/com/fasterxml/jackson/databind/SerializationFeature.html\">SerializationFeature</a>、<a href=\"https://fasterxml.github.io/jackson-databind/javadoc/2.10/com/fasterxml/jackson/databind/DeserializationFeature.html\">DeserializationFeature</a>和<a href=\"https://fasterxml.github.io/jackson-databind/javadoc/2.10/com/fasterxml/jackson/databind/MapperFeature.html\">MapperFeature</a>。</li>\n<li>忽略多余字段，是我们写业务代码时最容易遇到的一个配置项。Spring Boot在自动配置时贴心地做了全局设置。如果需要设置更多的特性，可以直接修改配置文件spring.jackson.**或设置Jackson2ObjectMapperBuilderCustomizer回调接口，来启用更多设置，无需重新定义ObjectMapper Bean。</li>\n</ul><h2>反序列化时要小心类的构造方法</h2><p>使用Jackson反序列化时，除了要注意忽略额外字段的问题外，还要小心类的构造方法。我们看一个实际的踩坑案例吧。</p><p>有一个APIResult类包装了REST接口的返回体（作为Web控制器的出参），其中boolean类型的success字段代表是否处理成功、int类型的code字段代表处理状态码。</p><p>开始时，在返回APIResult的时候每次都根据code来设置success。如果code是2000，那么success是true，否则是false。后来为了减少重复代码，把这个逻辑放到了APIResult类的构造方法中处理：</p><pre><code>@Data\npublic class APIResultWrong {\n    private boolean success;\n    private int code;\n\n    public APIResultWrong() {\n    }\n\n    public APIResultWrong(int code) {\n        this.code = code;\n        if (code == 2000) success = true;\n        else success = false;\n    }\n}\n</code></pre><p>经过改动后发现，即使code为2000，返回APIResult的success也是false。比如，我们反序列化两次APIResult，一次使用code==1234，一次使用code==2000：</p><pre><code>@Autowired\nObjectMapper objectMapper;\n\n@GetMapping(&quot;wrong&quot;)\npublic void wrong() throws JsonProcessingException {\n    log.info(&quot;result :{}&quot;, objectMapper.readValue(&quot;{\\&quot;code\\&quot;:1234}&quot;, APIResultWrong.class));\n    log.info(&quot;result :{}&quot;, objectMapper.readValue(&quot;{\\&quot;code\\&quot;:2000}&quot;, APIResultWrong.class));\n}\n</code></pre><p>日志输出如下：</p><pre><code>[17:36:14.591] [http-nio-45678-exec-1] [INFO ] [DeserializationConstructorController:20  ] - result :APIResultWrong(success=false, code=1234)\n[17:36:14.591] [http-nio-45678-exec-1] [INFO ] [DeserializationConstructorController:21  ] - result :APIResultWrong(success=false, code=2000)\n</code></pre><p>可以看到，两次的APIResult的success字段都是false。</p><p>出现这个问题的原因是，<strong>默认情况下，在反序列化的时候，Jackson框架只会调用无参构造方法创建对象</strong>。如果走自定义的构造方法创建对象，需要通过@JsonCreator来指定构造方法，并通过@JsonProperty设置构造方法中参数对应的JSON属性名：</p><pre><code>@Data\npublic class APIResultRight {\n    ...\n\n    @JsonCreator\n    public APIResultRight(@JsonProperty(&quot;code&quot;) int code) {\n        this.code = code;\n        if (code == 2000) success = true;\n        else success = false;\n    }\n}\n</code></pre><p>重新运行程序，可以得到正确输出：</p><pre><code>[17:41:23.188] [http-nio-45678-exec-1] [INFO ] [DeserializationConstructorController:26  ] - result :APIResultRight(success=false, code=1234)\n[17:41:23.188] [http-nio-45678-exec-1] [INFO ] [DeserializationConstructorController:27  ] - result :APIResultRight(success=true, code=2000)\n</code></pre><p>可以看到，这次传入code==2000时，success可以设置为true。</p><h2>枚举作为API接口参数或返回值的两个大坑</h2><p>在前面的例子中，我演示了如何把枚举序列化为索引值。但对于枚举，我建议尽量在程序内部使用，而不是作为API接口的参数或返回值，原因是枚举涉及序列化和反序列化时会有两个大坑。</p><p><strong>第一个坑是，客户端和服务端的枚举定义不一致时，会出异常。</strong>比如，客户端版本的枚举定义了4个枚举值：</p><pre><code>@Getter\nenum StatusEnumClient {\n    CREATED(1, &quot;已创建&quot;),\n    PAID(2, &quot;已支付&quot;),\n    DELIVERED(3, &quot;已送到&quot;),\n    FINISHED(4, &quot;已完成&quot;);\n\n    private final int status;\n    private final String desc;\n\n    StatusEnumClient(Integer status, String desc) {\n        this.status = status;\n        this.desc = desc;\n    }\n}\n</code></pre><p>服务端定义了5个枚举值：</p><pre><code>@Getter\nenum StatusEnumServer {\n    ...\n    CANCELED(5, &quot;已取消&quot;);\n\n    private final int status;\n    private final String desc;\n\n    StatusEnumServer(Integer status, String desc) {\n        this.status = status;\n        this.desc = desc;\n    }\n}\n</code></pre><p>写代码测试一下，使用RestTemplate来发起请求，让服务端返回客户端不存在的枚举值：</p><pre><code>@GetMapping(&quot;getOrderStatusClient&quot;)\npublic void getOrderStatusClient() {\n    StatusEnumClient result = restTemplate.getForObject(&quot;http://localhost:45678/enumusedinapi/getOrderStatus&quot;, StatusEnumClient.class);\n    log.info(&quot;result {}&quot;, result);\n}\n\n@GetMapping(&quot;getOrderStatus&quot;)\npublic StatusEnumServer getOrderStatus() {\n    return StatusEnumServer.CANCELED;\n}\n</code></pre><p>访问接口会出现如下异常信息，提示在枚举StatusEnumClient中找不到CANCELED：</p><pre><code>JSON parse error: Cannot deserialize value of type `org.geekbang.time.commonmistakes.enums.enumusedinapi.StatusEnumClient` from String &quot;CANCELED&quot;: not one of the values accepted for Enum class: [CREATED, FINISHED, DELIVERED, PAID];\n</code></pre><p>要解决这个问题，可以开启Jackson的read_unknown_enum_values_using_default_value反序列化特性，也就是在枚举值未知的时候使用默认值：</p><pre><code>spring.jackson.deserialization.read_unknown_enum_values_using_default_value=true\n</code></pre><p>并为枚举添加一个默认值，使用@JsonEnumDefaultValue注解注释：</p><pre><code>@JsonEnumDefaultValue\nUNKNOWN(-1, &quot;未知&quot;);\n</code></pre><p>需要注意的是，这个枚举值一定是添加在客户端StatusEnumClient中的，因为反序列化使用的是客户端枚举。</p><p>这里还有一个小坑是，仅仅这样配置还不能让RestTemplate生效这个反序列化特性，还需要配置RestTemplate，来使用Spring Boot的MappingJackson2HttpMessageConverter才行：</p><pre><code>@Bean\npublic RestTemplate restTemplate(MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter) {\n    return new RestTemplateBuilder()\n            .additionalMessageConverters(mappingJackson2HttpMessageConverter)\n            .build();\n}\n</code></pre><p>现在，请求接口可以返回默认值了：</p><pre><code>[21:49:03.887] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.e.e.EnumUsedInAPIController:25  ] - result UNKNOWN\n</code></pre><p><strong>第二个坑，也是更大的坑，枚举序列化反序列化实现自定义的字段非常麻烦，会涉及Jackson的Bug</strong>。比如，下面这个接口，传入枚举List，为List增加一个CENCELED枚举值然后返回：</p><pre><code>@PostMapping(&quot;queryOrdersByStatusList&quot;)\npublic List&lt;StatusEnumServer&gt; queryOrdersByStatus(@RequestBody List&lt;StatusEnumServer&gt; enumServers) {\n    enumServers.add(StatusEnumServer.CANCELED);\n    return enumServers;\n}\n</code></pre><p>如果我们希望根据枚举的Desc字段来序列化，传入“已送到”作为入参：</p><p><img src=\"https://static001.geekbang.org/resource/image/50/26/50a81c64fef9f9f3a8f57bccaaad5226.png?wh=1510*370\" alt=\"\"></p><p>会得到异常，提示“已送到”不是正确的枚举值：</p><pre><code>JSON parse error: Cannot deserialize value of type `org.geekbang.time.commonmistakes.enums.enumusedinapi.StatusEnumServer` from String &quot;已送到&quot;: not one of the values accepted for Enum class: [CREATED, CANCELED, FINISHED, DELIVERED, PAID]\n</code></pre><p>显然，这里反序列化使用的是枚举的name，序列化也是一样：</p><p><img src=\"https://static001.geekbang.org/resource/image/04/43/0455db08f97feb2382be6e3c8329da43.png?wh=1518*932\" alt=\"\"></p><p>你可能也知道，要让枚举的序列化和反序列化走desc字段，可以在字段上加@JsonValue注解，修改StatusEnumServer和StatusEnumClient：</p><pre><code>@JsonValue\nprivate final String desc;\n</code></pre><p>然后再尝试下，果然可以用desc作为入参了，而且出参也使用了枚举的desc：</p><p><img src=\"https://static001.geekbang.org/resource/image/08/2b/08acd86f0cabd174d45f6319bffa802b.png?wh=1442*974\" alt=\"\"></p><p>但是，如果你认为这样就完美解决问题了，那就大错特错了。你可以再尝试把@JsonValue注解加在int类型的status字段上，也就是希望序列化反序列化走status字段：</p><pre><code>@JsonValue\nprivate final int status;\n</code></pre><p>写一个客户端测试一下，传入CREATED和PAID两个枚举值：</p><pre><code>@GetMapping(&quot;queryOrdersByStatusListClient&quot;)\npublic void queryOrdersByStatusListClient() {\n    List&lt;StatusEnumClient&gt; request = Arrays.asList(StatusEnumClient.CREATED, StatusEnumClient.PAID);\n    HttpEntity&lt;List&lt;StatusEnumClient&gt;&gt; entity = new HttpEntity&lt;&gt;(request, new HttpHeaders());\n    List&lt;StatusEnumClient&gt; response = restTemplate.exchange(&quot;http://localhost:45678/enumusedinapi/queryOrdersByStatusList&quot;,\n            HttpMethod.POST, entity, new ParameterizedTypeReference&lt;List&lt;StatusEnumClient&gt;&gt;() {}).getBody();\n    log.info(&quot;result {}&quot;, response);\n}\n</code></pre><p>请求接口可以看到，传入的是CREATED和PAID，返回的居然是DELIVERED和FINISHED。果然如标题所说，一来一回你已不是原来的你：</p><pre><code>[22:03:03.579] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.e.e.EnumUsedInAPIController:34  ] - result [DELIVERED, FINISHED, UNKNOWN]\n</code></pre><p>出现这个问题的原因是，<strong>序列化走了status的值，而反序列化并没有根据status来，还是使用了枚举的ordinal()索引值</strong>。这是Jackson<a href=\"https://github.com/FasterXML/jackson-databind/issues/1850\">至今（2.10）没有解决的Bug</a>，应该会在2.11解决。</p><p>如下图所示，我们调用服务端接口，传入一个不存在的status值0，也能反序列化成功，最后服务端的返回是1：</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/bd/ac6cd2c0957d1654fced53e99eb556bd.png?wh=1360*940\" alt=\"\"></p><p>有一个解决办法是，设置@JsonCreator来强制反序列化时使用自定义的工厂方法，可以实现使用枚举的status字段来取值。我们把这段代码加在StatusEnumServer枚举类中：</p><pre><code>@JsonCreator\npublic static StatusEnumServer parse(Object o) {\n    return Arrays.stream(StatusEnumServer.values()).filter(value-&gt;o.equals(value.status)).findFirst().orElse(null);\n}\n</code></pre><p>要特别注意的是，我们同样要为StatusEnumClient也添加相应的方法。因为除了服务端接口接收StatusEnumServer参数涉及一次反序列化外，从服务端返回值转换为List还会有一次反序列化：</p><pre><code>@JsonCreator\npublic static StatusEnumClient parse(Object o) {\n    return Arrays.stream(StatusEnumClient.values()).filter(value-&gt;o.equals(value.status)).findFirst().orElse(null);\n}\n</code></pre><p>重新调用接口发现，虽然结果正确了，但是服务端不存在的枚举值CANCELED被设置为了null，而不是@JsonEnumDefaultValue设置的UNKNOWN。</p><p>这个问题，我们之前已经通过设置@JsonEnumDefaultValue注解解决了，但现在又出现了：</p><pre><code>[22:20:13.727] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.e.e.EnumUsedInAPIController:34  ] - result [CREATED, PAID, null]\n</code></pre><p>原因也很简单，我们自定义的parse方法实现的是找不到枚举值时返回null。</p><p>为彻底解决这个问题，并避免通过@JsonCreator在枚举中自定义一个非常复杂的工厂方法，我们可以实现一个自定义的反序列化器。这段代码比较复杂，我特意加了详细的注释：</p><pre><code>class EnumDeserializer extends JsonDeserializer&lt;Enum&gt; implements\n        ContextualDeserializer {\n\n    private Class&lt;Enum&gt; targetClass;\n\n    public EnumDeserializer() {\n    }\n\n    public EnumDeserializer(Class&lt;Enum&gt; targetClass) {\n        this.targetClass = targetClass;\n    }\n\n    @Override\n    public Enum deserialize(JsonParser p, DeserializationContext ctxt) {\n        //找枚举中带有@JsonValue注解的字段，这是我们反序列化的基准字段\n        Optional&lt;Field&gt; valueFieldOpt = Arrays.asList(targetClass.getDeclaredFields()).stream()\n                .filter(m -&gt; m.isAnnotationPresent(JsonValue.class))\n                .findFirst();\n\n        if (valueFieldOpt.isPresent()) {\n            Field valueField = valueFieldOpt.get();\n            if (!valueField.isAccessible()) {\n                valueField.setAccessible(true);\n            }\n            //遍历枚举项，查找字段的值等于反序列化的字符串的那个枚举项\n            return Arrays.stream(targetClass.getEnumConstants()).filter(e -&gt; {\n                try {\n                    return valueField.get(e).toString().equals(p.getValueAsString());\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n                return false;\n            }).findFirst().orElseGet(() -&gt; Arrays.stream(targetClass.getEnumConstants()).filter(e -&gt; {\n                //如果找不到，就需要寻找默认枚举值来替代，同样遍历所有枚举项，查找@JsonEnumDefaultValue注解标识的枚举项\n                try {\n                    return targetClass.getField(e.name()).isAnnotationPresent(JsonEnumDefaultValue.class);\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n                return false;\n            }).findFirst().orElse(null));\n        }\n        return null;\n    }\n\n    @Override\n    public JsonDeserializer&lt;?&gt; createContextual(DeserializationContext ctxt,\n                                                BeanProperty property) throws JsonMappingException {\n        targetClass = (Class&lt;Enum&gt;) ctxt.getContextualType().getRawClass();\n        return new EnumDeserializer(targetClass);\n    }\n}\n</code></pre><p>然后，把这个自定义反序列化器注册到Jackson中：</p><pre><code>@Bean\npublic Module enumModule() {\n    SimpleModule module = new SimpleModule();\n    module.addDeserializer(Enum.class, new EnumDeserializer());\n    return module;\n}\n</code></pre><p>第二个大坑终于被完美地解决了：</p><pre><code>[22:32:28.327] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.e.e.EnumUsedInAPIController:34  ] - result [CREATED, PAID, UNKNOWN]\n</code></pre><p>这样做，虽然解决了序列化反序列化使用枚举中自定义字段的问题，也解决了找不到枚举值时使用默认值的问题，但解决方案很复杂。因此，我还是建议在DTO中直接使用int或String等简单的数据类型，而不是使用枚举再配合各种复杂的序列化配置，来实现枚举到枚举中字段的映射，会更加清晰明了。</p><h2>重点回顾</h2><p>今天，我基于Redis和Web API的入参和出参两个场景，和你介绍了序列化和反序列化时需要避开的几个坑。</p><p>第一，要确保序列化和反序列化算法的一致性。因为，不同序列化算法输出必定不同，要正确处理序列化后的数据就要使用相同的反序列化算法。</p><p>第二，Jackson有大量的序列化和反序列化特性，可以用来微调序列化和反序列化的细节。需要注意的是，如果自定义ObjectMapper的Bean，小心不要和Spring Boot自动配置的Bean冲突。</p><p>第三，在调试序列化反序列化问题时，我们一定要捋清楚三点：是哪个组件在做序列化反序列化、整个过程有几次序列化反序列化，以及目前到底是序列化还是反序列化。</p><p>第四，对于反序列化默认情况下，框架调用的是无参构造方法，如果要调用自定义的有参构造方法，那么需要告知框架如何调用。更合理的方式是，对于需要序列化的POJO考虑尽量不要自定义构造方法。</p><p>第五，枚举不建议定义在DTO中跨服务传输，因为会有版本问题，并且涉及序列化反序列化时会很复杂，容易出错。因此，我只建议在程序内部使用枚举。</p><p>最后还有一点需要注意，如果需要跨平台使用序列化的数据，那么除了两端使用的算法要一致外，还可能会遇到不同语言对数据类型的兼容问题。这，也是经常踩坑的一个地方。如果你有相关需求，可以多做实验、多测试。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>在讨论Redis序列化方式的时候，我们自定义了RedisTemplate，让Key使用String序列化、让Value使用JSON序列化，从而使Redis获得的Value可以直接转换为需要的对象类型。那么，使用RedisTemplate&lt;String, Long&gt;能否存取Value是Long的数据呢？这其中有什么坑吗？</li>\n<li>你可以看一下Jackson2ObjectMapperBuilder类源码的实现（注意configure方法），分析一下其除了关闭FAIL_ON_UNKNOWN_PROPERTIES外，还做了什么吗？</li>\n</ol><p>关于序列化和反序列化，你还遇到过什么坑吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"14 | 文件IO：实现高效正确的文件读写并非易事","id":223051},"right":{"article_title":"16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑","id":224240}},"comments":[{"had_liked":false,"id":206519,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1586873707,"is_pvip":false,"replies":[{"id":"77194","content":"1、有关serialVersionUID的意义：<br><br>The serialization runtime associates with each serializable class a version number, called a serialVersionUID, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender&#39;s class, then deserialization will result in an InvalidClassException. A serializable class can declare its own serialVersionUID explicitly by declaring a field named serialVersionUID that must be static, final, and of type long:<br><br>ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;<br>If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is strongly recommended that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected InvalidClassExceptions during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the private modifier where possible, since such declarations apply only to the immediately declaring class serialVersionUID fields are not useful as inherited members.<br><br>2、toString也可以认为是一种文本序列化，序列化当然还可以按照自己的方式来做，只要是一致的方式实现对象到字节的转换。<br><br>3、 java序列化一开始存在的意义是什么？在有xml、json、protobuf等之前，jdk总需要有序列化来实现对象的文件存储、跨服务传输吧，当时确实互联网也没这么发达没考虑到异构体系的交互问题，我们不能以现在的眼光来看当时的技术为什么考虑这么不全面这么鸡肋","user_name":"作者回复","comment_id":206519,"uid":"1001470","ip_address":"","utype":1,"ctime":1586915326,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"87486219627","product_id":100047701,"comment_content":"老师，现在像fastJson, jackson 一般使用序列化和反序列化不都是属性类型兼容就能来回序列化吗？java序列化的时候存储序列化id记录版本号的意义是什么。 java序列化一开始存在的意义是什么？为什么要那样处理呢？如果按照现在fastJson 和jackson等的处理方式，toString 不也是一种序列化方式吗？反序列化时按照一种规则解析回去不就行了","like_count":20,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491816,"discussion_content":"1、有关serialVersionUID的意义：\n\nThe serialization runtime associates with each serializable class a version number, called a serialVersionUID, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender&amp;#39;s class, then deserialization will result in an InvalidClassException. A serializable class can declare its own serialVersionUID explicitly by declaring a field named serialVersionUID that must be static, final, and of type long:\n\nANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;\nIf a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is strongly recommended that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected InvalidClassExceptions during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the private modifier where possible, since such declarations apply only to the immediately declaring class serialVersionUID fields are not useful as inherited members.\n\n2、toString也可以认为是一种文本序列化，序列化当然还可以按照自己的方式来做，只要是一致的方式实现对象到字节的转换。\n\n3、 java序列化一开始存在的意义是什么？在有xml、json、protobuf等之前，jdk总需要有序列化来实现对象的文件存储、跨服务传输吧，当时确实互联网也没这么发达没考虑到异构体系的交互问题，我们不能以现在的眼光来看当时的技术为什么考虑这么不全面这么鸡肋","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586915326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206342,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1586843967,"is_pvip":true,"replies":[{"id":"77062","content":"比较坑的是，在Integer区间内返回的是Integer，超过这个区间返回Long<br><br><br>@GetMapping(&quot;wrong2&quot;)<br>    public void wrong2() {<br>        String key = &quot;testCounter&quot;;<br>        countRedisTemplate.opsForValue().set(key, 1L);<br>        log.info(&quot;{} {}&quot;, countRedisTemplate.opsForValue().get(key), countRedisTemplate.opsForValue().get(key) instanceof Long);<br>        Long l1 = getLongFromRedis(key);<br>        countRedisTemplate.opsForValue().set(key, Integer.MAX_VALUE + 1L);<br>        log.info(&quot;{} {}&quot;, countRedisTemplate.opsForValue().get(key), countRedisTemplate.opsForValue().get(key) instanceof Long);<br>        Long l2 = getLongFromRedis(key);<br>        log.info(&quot;{} {} {}&quot;, l1, l2);<br>    }<br><br>    private Long getLongFromRedis(String key) {<br>        Object o = countRedisTemplate.opsForValue().get(key);<br>        if (o instanceof Integer) {<br>            return ((Integer) o).longValue();<br>        }<br>        if (o instanceof Long) {<br>            return (Long) o;<br>        }<br>        return null;<br>    }<br><br>输出：<br><br>1 false<br>2147483648 true<br>1 2147483648","user_name":"作者回复","comment_id":206342,"uid":"1001470","ip_address":"","utype":1,"ctime":1586849694,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"74601287999","product_id":100047701,"comment_content":"试着回答下今天的问题：<br>1、Long序列化的时候，Redis会认为是int，因此是获取不到的Long数据的，需要处理；<br>2、Jackson2ObjectMapperBuilder的采用了构建者模式创建对象；调用的是build()方法<br>\tpublic &lt;T extends ObjectMapper&gt; T build() {<br>\t\tObjectMapper mapper;<br>\t\tif (this.createXmlMapper) {<br>\t\t\tmapper = (this.defaultUseWrapper != null ?<br>\t\t\t\t\tnew XmlObjectMapperInitializer().create(this.defaultUseWrapper) :<br>\t\t\t\t\tnew XmlObjectMapperInitializer().create());<br>\t\t}<br>\t\telse {<br>\t\t\tmapper = (this.factory != null ? new ObjectMapper(this.factory) : new ObjectMapper());<br>\t\t}<br>\t\tconfigure(mapper);<br>\t\treturn (T) mapper;<br>\t}<br> 然后configure里面出了了甚多事情，比如：日式、Local、时间等的格式化器以及自定义属性命名策略等，具体详见https:&#47;&#47;github.com&#47;y645194203&#47;geektime-java-100&#47;blob&#47;master&#47;ConfigInfo.java","like_count":17,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491758,"discussion_content":"比较坑的是，在Integer区间内返回的是Integer，超过这个区间返回Long\n\n\n@GetMapping(&amp;quot;wrong2&amp;quot;)\n    public void wrong2() {\n        String key = &amp;quot;testCounter&amp;quot;;\n        countRedisTemplate.opsForValue().set(key, 1L);\n        log.info(&amp;quot;{} {}&amp;quot;, countRedisTemplate.opsForValue().get(key), countRedisTemplate.opsForValue().get(key) instanceof Long);\n        Long l1 = getLongFromRedis(key);\n        countRedisTemplate.opsForValue().set(key, Integer.MAX_VALUE + 1L);\n        log.info(&amp;quot;{} {}&amp;quot;, countRedisTemplate.opsForValue().get(key), countRedisTemplate.opsForValue().get(key) instanceof Long);\n        Long l2 = getLongFromRedis(key);\n        log.info(&amp;quot;{} {} {}&amp;quot;, l1, l2);\n    }\n\n    private Long getLongFromRedis(String key) {\n        Object o = countRedisTemplate.opsForValue().get(key);\n        if (o instanceof Integer) {\n            return ((Integer) o).longValue();\n        }\n        if (o instanceof Long) {\n            return (Long) o;\n        }\n        return null;\n    }\n\n输出：\n\n1 false\n2147483648 true\n1 2147483648","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586849694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232083,"discussion_content":"老师就是老师，我就是试了下，没注意超过Integer范围的操作，这个边界测试，还是考虑不全，需要跟随老师的脚步，继续加油","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586851339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232129,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cd/01/c7c9f2f4.jpg","nickname":"kfighter","note":"","ucode":"741CE8A22E5391","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232084,"discussion_content":"老师厉害👍，课代表也不错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586851655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207341,"user_name":"左琪","can_delete":false,"product_type":"c1","uid":1468773,"ip_address":"","ucode":"6B797070168A12","user_header":"https://static001.geekbang.org/account/avatar/00/16/69/65/eb778125.jpg","comment_is_top":false,"comment_ctime":1587050531,"is_pvip":false,"replies":[{"id":"77470","content":"这个long和int的问题应该就是我思考题的问题，你可以看看其他网友的回复以及我的回复如何解决。<br><br>我不知道你这里的用redis存入Map&lt;Long,object&gt;是不是指key是Long，value是Object，如果是的话，把数字作为Key不是一个好的实践，Redis的Key需要是字符串，并且区分命名空间，比如应用_领域_标识（或是数据库_表_PK），e.g.commonmistakes_redisexample_user123<br>","user_name":"作者回复","comment_id":207341,"uid":"1001470","ip_address":"","utype":1,"ctime":1587090011,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"40241756195","product_id":100047701,"comment_content":"老师，我之前遇到一个，我用redis存入一个Map&lt;Long,object&gt;，取出时发现却是Map&lt;int,object&gt;,然后响应给前端springmvc就报类型转换异常了，我redis的value也是用的Jackson序列化，自定义了objectmapper，正常对象都能序列化，反序列化，就是Long不行，我想知道该如何修正呢","like_count":9,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492090,"discussion_content":"这个long和int的问题应该就是我思考题的问题，你可以看看其他网友的回复以及我的回复如何解决。\n\n我不知道你这里的用redis存入Map&amp;lt;Long,object&amp;gt;是不是指key是Long，value是Object，如果是的话，把数字作为Key不是一个好的实践，Redis的Key需要是字符串，并且区分命名空间，比如应用_领域_标识（或是数据库_表_PK），e.g.commonmistakes_redisexample_user123\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587090011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206295,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1586835861,"is_pvip":false,"replies":[{"id":"77085","content":"内部没关系，也推荐使用枚举，对外是要慎用","user_name":"作者回复","comment_id":206295,"uid":"1001470","ip_address":"","utype":1,"ctime":1586855246,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"27356639637","product_id":100047701,"comment_content":"之前其实一直还是比较喜欢枚举的，一直只是觉得枚举这个是个好的功能，只是我不会用。<br>现在来看，看来枚举在使用上确实时需要谨慎。<br><br>个人理解，枚举的本质，其实就是一个Map&lt;Object,Object&gt;，但是扩展性更强一些。其本身的存在，类似于一个 不可变的常量Map，本身的存在与意义，个人感觉，与数据字典也很像。存索引值（key），但对应一个具体对象或数值（value）。经过这一讲，之后的业务，我个人可能也会使用数据字典，而慎用枚举了。<br><br><br><br>","like_count":6,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491744,"discussion_content":"内部没关系，也推荐使用枚举，对外是要慎用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586855246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231873,"user_name":"扎紧绷带","can_delete":false,"product_type":"c1","uid":1316667,"ip_address":"","ucode":"4EDB38E21C12BB","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/3b/37bcd31e.jpg","comment_is_top":false,"comment_ctime":1593793498,"is_pvip":false,"replies":[{"id":"85736","content":"字符串略好点，空间方面其实不差这些","user_name":"作者回复","comment_id":231873,"uid":"1001470","ip_address":"","utype":1,"ctime":1593956484,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"23068629978","product_id":100047701,"comment_content":"有个同学说不用 int 来枚举，而选择语义性的字符串。我也觉得语义明确的字符串更好一些，但很多人认为数字占空间小，应该用int。老师怎么看，你们是怎么用的呢？","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500460,"discussion_content":"字符串略好点，空间方面其实不差这些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593956484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208066,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1587267979,"is_pvip":true,"replies":[{"id":"77655","content":"对内环境和生产环境的问题也是比较典型的。对内虽然和生产公用数据库和中间件，但是毕竟还是用于测试验证的。<br><br>之前遇到的一个坑是类似的，对内环境和生产公用CDN，对内验证的时候传了一张测试图片上去，然后CDN节点就有了这个文件，到了生产上虽然又传了正式的图片（文件名没有变），但是CDN节点上的测试图片依旧缓存着，部分地区用户还是看到了测试图片。。。","user_name":"作者回复","comment_id":208066,"uid":"1001470","ip_address":"","utype":1,"ctime":1587269257,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"10177202571","product_id":100047701,"comment_content":"我们项目中遇到的坑是：key是字符串，value是一个自定义对象，我们环境分为inner和prd,inner验证过了才会发生产，但是inner和prd是同一个Redis缓存和DB，value值对应的对象中加了字段，生产和inner同时作用，prd缓存失效了，正好把inner的给存进去了，结果导致生产接口从缓存取数据的时候出现反序列化报错问题，影响了生产。<br>后面采取方法是在缓存key加上环境前缀来避免这个问题。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492328,"discussion_content":"对内环境和生产环境的问题也是比较典型的。对内虽然和生产公用数据库和中间件，但是毕竟还是用于测试验证的。\n\n之前遇到的一个坑是类似的，对内环境和生产公用CDN，对内验证的时候传了一张测试图片上去，然后CDN节点就有了这个文件，到了生产上虽然又传了正式的图片（文件名没有变），但是CDN节点上的测试图片依旧缓存着，部分地区用户还是看到了测试图片。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587269257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1968721,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/unkzY52hVDjTmZJGNkrBR75tFs4XTGBoYYcOYkIcPvHlQrLibwc94aBfj1uWiawoKeEMwHbkvgThXZarfoP8Dzag/132","nickname":"她","note":"","ucode":"FAC6851866C9C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408029,"discussion_content":"我们这边也是这么解决的，key用环境前缀识别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635169087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207800,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1587182371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10177116963","product_id":100047701,"comment_content":"习惯用枚举表示数据库状态字段<br>希望老师能指点枚举最佳实践","like_count":2},{"had_liked":false,"id":206214,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1586824232,"is_pvip":false,"replies":[{"id":"76982","content":"😀","user_name":"作者回复","comment_id":206214,"uid":"1001470","ip_address":"","utype":1,"ctime":1586825480,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10176758824","product_id":100047701,"comment_content":"关于枚举，无论是在 dto 还是数据库存储，我们都已经不用 int 来枚举了，而选择语义性的字符串，这在 debug 和维护上十分方便，也有利于迁移，int 枚举太难看了，每次调试，眼睛都花了😭","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491717,"discussion_content":"😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586825480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250011,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1600903380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895870676","product_id":100047701,"comment_content":"gson处理数值的时候也有类似的情况，整数变为浮点数，或者是长整数变为科学计数法","like_count":1},{"had_liked":false,"id":232704,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1594093024,"is_pvip":false,"replies":[{"id":"85904","content":"最好帖下代码以及测试用例，否则很难看懂","user_name":"作者回复","comment_id":232704,"uid":"1001470","ip_address":"","utype":1,"ctime":1594100274,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5889060320","product_id":100047701,"comment_content":"老师，我最近遇到一个坑，也是Jackson 序列化反序列的。一开始在xml中定义只定义mappingJacksonHttpMessageConverter，然后在DTO中某日期字段中加上@JsonDeserialize(using = DateJsonDeserialize.class)能实现日期转为功能。但是前台页面中显示的日期全都为时间戳。<br>于是在定义了ObjectMapper 里面重写了日期格式化的序列化方法,然后原先的进行接口Json格式反序列，@JsonDeserialize这个功能不能用了，找了好久都没有解决办法。老师这个坑，该如何解决？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500747,"discussion_content":"最好帖下代码以及测试用例，否则很难看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594100274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223936,"user_name":"额。","can_delete":false,"product_type":"c1","uid":1371888,"ip_address":"","ucode":"99B1942BAEC011","user_header":"https://static001.geekbang.org/account/avatar/00/14/ee/f0/f2577e45.jpg","comment_is_top":false,"comment_ctime":1591235652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886202948","product_id":100047701,"comment_content":"我们遇到了一个坑，在用restTemplate远程调用的时候，用FastJson的JSONObject接收，然后springboot利用jackson序列化和反序列化返回来一个LinkedHashMap，开发同学的操作不规范，喜欢直接转型，就报错了","like_count":1},{"had_liked":false,"id":206516,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1586873378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881840674","product_id":100047701,"comment_content":"redis 的序列化也遇到过问题，但是当时处理的比较紧急比较模糊，记不清了。<br>  一个类里需要不同结构的redis或者类型不同==&gt; <br>  a&gt; 序列化报错，写不进去。<br>  b&gt; 没报错，阿里云后台查看redis的结构是None,key是乱码，也无法删除。<br>  最终的解决方案是：自己new RedisTemplate, 对于每一种结构对象都设置对应的序列化反序列化方式。<br> redis 的incrby需要long接收，因为返回值是64的整数。当时看到integer 单词还以为是java的integer，结果是64位的integer","like_count":1},{"had_liked":false,"id":206346,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":1166969,"ip_address":"","ucode":"09E29168D53178","user_header":"https://static001.geekbang.org/account/avatar/00/11/ce/79/673f4268.jpg","comment_is_top":false,"comment_ctime":1586844940,"is_pvip":true,"replies":[{"id":"77061","content":"是","user_name":"作者回复","comment_id":206346,"uid":"1001470","ip_address":"","utype":1,"ctime":1586849594,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5881812236","product_id":100047701,"comment_content":"   log.info(&quot;longRedisTemplate get {}&quot;, (Long)longRedisTemplate.opsForValue().get(&quot;longRedisTemplate&quot;));<br>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Long<br>强转异常，也就是说我们获取到这样的值还要自己从Integer转成Long是吗老师？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491760,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586849594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347559,"user_name":"Geek_7de969","can_delete":false,"product_type":"c1","uid":3013754,"ip_address":"","ucode":"0A5A3E250CA3A8","user_header":"","comment_is_top":false,"comment_ctime":1654155137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654155137","product_id":100047701,"comment_content":"@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)<br>private Date signDate;<br>这是一个对象的某个字段是日期类型 redis用的上边的序列化存进去发现和数据库中日期相差一天  是怎么回事呢","like_count":0},{"had_liked":false,"id":295707,"user_name":"ImYours°","can_delete":false,"product_type":"c1","uid":1750549,"ip_address":"","ucode":"51F653129034C9","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","comment_is_top":false,"comment_ctime":1622553403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622553403","product_id":100047701,"comment_content":"请问开启类型作为属性保存到 Value 中，有范型擦除问题嘛？","like_count":0},{"had_liked":false,"id":290615,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1619659836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619659836","product_id":100047701,"comment_content":"这一节里很多用法都是反例，真实工程项目大多还是用基本类型。","like_count":0},{"had_liked":false,"id":284919,"user_name":"寒光","can_delete":false,"product_type":"c1","uid":1206187,"ip_address":"","ucode":"061BE413595F21","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","comment_is_top":false,"comment_ctime":1616546955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616546955","product_id":100047701,"comment_content":"我就习惯直接操作byte来用redis，简单直接，想怎么玩就怎么玩，完全透明。","like_count":0},{"had_liked":false,"id":245546,"user_name":"小胡子","can_delete":false,"product_type":"c1","uid":1018182,"ip_address":"","ucode":"79FEC6400D25DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/46/0b7828a1.jpg","comment_is_top":false,"comment_ctime":1598973287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598973287","product_id":100047701,"comment_content":" RedisTemplate&lt;String, User&gt; userRedisTemplate;<br>不同的类型要注入对应的对象，感觉也麻烦","like_count":0},{"had_liked":false,"id":243298,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1598024190,"is_pvip":false,"replies":[{"id":"89717","content":"之前是enableDefaultTyping吧","user_name":"作者回复","comment_id":243298,"uid":"1001470","ip_address":"","utype":1,"ctime":1598164771,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"1598024190","product_id":100047701,"comment_content":"ObjectMapper 的 activateDefaultTyping 方法 在2.10版本才提供，那之前的版本有替代方案吗。","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504250,"discussion_content":"之前是enableDefaultTyping吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598164771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}