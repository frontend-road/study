{"id":740883,"title":"第 11 章 Web 开发进阶(2)","content":"<h2 id=\"nav_point_176\">11.2　调整 Web 容器</h2>\n<p>在 5.3 节中我们提到过，Spring Boot 的程序通常会使用内嵌 Web 容器，不像传统的 Web 项目要跑在外置容器里。默认情况下，Spring Boot 自带 Tomcat 容器，当然，我们也可以更换容器。在这一节里，我们将看到如何在 Spring Boot 项目中更换不同的内置容器，如何微调容器的配置，最后再看看如何让系统从支持 HTTP/1.1 升级到支持 HTTP/2。</p>\n<h3 id=\"nav_point_177\">11.2.1　更换内嵌 Web 容器</h3>\n<p>我们在项目中通过引入 Spring Boot 的 spring-boot-starter-web 起步依赖开启了对 Web 工程的支持，这个依赖中其实已经带上了 spring-boot-starter-tomcat，因此在 Spring Boot 里默认使用 Tomcat 就是这么实现的。表 11-4 罗列了 Spring Boot 自带的 Web 容器相关的起步依赖。</p>\n<p><strong>表 11-4　Spring Boot 内置支持的几款 Web 容器起步依赖</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>起步依赖</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>spring-boot-starter-tomcat</p></td>\n<td><p>引入 Apache Tomcat 相关的依赖，这是 Spring Boot 默认的 Web 容器</p></td>\n</tr>\n<tr>\n<td><p>spring-boot-starter-jetty</p></td>\n<td><p>引入 Eclipse Jetty 相关的依赖</p><!-- [[[read_end]]] --></td>\n</tr>\n<tr>\n<td><p>spring-boot-starter-undertow</p></td>\n<td><p>引入 JBoss Undertow 相关的依赖</p></td>\n</tr>\n<tr>\n<td><p>spring-boot-starter-reactor-netty</p></td>\n<td><p>引入 Netty 相关的依赖，提供响应式 Web 服务的支持，后续在介绍 WebFlux 时会用到</p></td>\n</tr>\n</tbody>\n</table>\n<p>只要没有用到什么容器特有的东西，Tomcat、Jetty 和 Undertow 三者之间就可以实现灵活切换（Reactor Netty 仅提供响应式的支持，不支持普通的 Servlet，所以没算在内），以 Tomcat 切换 Jetty 为例，在 pom.xml 的 <code>&lt;dependencies /&gt;</code> 中只需两步调整即可：</p>\n<p>(1) 从 spring-boot-starter-web 中通过 <code>&lt;exclusions /&gt;</code> 排除 spring-boot-starter-tomcat 依赖；</p>\n<p>(2) 加入 spring-boot-starter-jetty 依赖。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>调整完毕后，运行程序，如果看到类似如下的输出，就说明已经切换到了 Jetty 容器：</p>\n<pre class=\"code-rows\"><code>2021-02-17 10:39:45.388 INFO 30464 --- [main] o.s.b.w.e.j.JettyServletWebServerFactory : Server\ninitialized with port: 8080\n2021-02-17 10:39:45.391 INFO 30464 --- [main] org.eclipse.jetty.server.Server : jetty-9.4.33.v20201020;\nbuilt: 2020-10-20T23:39:24.803Z; git: 1be68755656cef678b79a2ef1c2ebbca99e25420; jvm 11.0.8+10</code></pre>\n<p>想要切换 Undertow，方法是类似的，只需把 spring-boot-starter-jetty 这个起步依赖换成 spring- boot-starter-undertow 即可。运行后的日志是类似这样的：</p>\n<pre class=\"code-rows\"><code>2021-02-17 10:50:51.158 INFO 30637 --- [main] io.undertow : starting server: Undertow - 2.1.4.Final\n2021-02-17 10:50:51.161 INFO 30637 --- [main] org.xnio : XNIO version 3.8.0.Final\n2021-02-17 10:50:51.165 INFO 30637 --- [main] org.xnio.nio : XNIO NIO Implementation Version 3.8.0.Final\n2021-02-17 10:50:51.185 INFO 30637 --- [main] org.jboss.threads : JBoss Threads version 3.1.0.Final\n2021-02-17 10:50:51.225 INFO 30637 --- [main] o.s.b.w.e.undertow.UndertowWebServer : Undertow started\non port(s) 8080 (http)</code></pre>\n<blockquote>\n<p><strong>茶歇时间：不同的 Servlet 版本与对应的容器</strong></p>\n<p>Servlet 自诞生起已经经历了好几个大版本的变迁。Servlet 3.0 是随 Java EE 6 规范一同发布的，可支持异步处理、新增了不少注解，还增强了插件能力。Servlet 4.0 是 Java EE 8 中更新的，为 HTTP/2 的全面落地做好了准备，可支持服务器推送。Servlet 5.0 主要是随 Jakarta EE 9<span class=\"comment-number\">4</span> 发布的，这个版本跟前面的版本相比最大的区别是更换了命名空间，从 <code>javax.\\*</code> 变成了 <code>jakarta.\\*</code>，<strong>这种不兼容升级带来的影响是巨大的</strong>，升级需谨慎。</p>\n<p>在本书编写时，Spring Boot 2.6 需要运行在 Servlet 3.1 及以上版本的容器里，自带的 Web 容器可以支持 Servlet 4.0，而 Spring Boot 3.0 兼容 Jakarta EE 9，可以支持到 Servlet 5.0。</p>\n<p>以 Spring Boot 2.6.3 为例，其自带的 Tomcat 9.0.56 和 Undertow 2.2.14.Final 是能够支持 Servlet 4.0 的， 而 Jetty 9.0.52 暂时只支持 Servlet 3.1。Spring Boot 3.0.0-M2 自带的 Tomcat 10.0.18 和 Undertow 2.2.16.Final 都支持 Servlet 5.0，Jetty 11.0.8 更是支持到了 Servlet 5.1。需要特别说明的是，由于 Jakarta EE 9 有不小的改动，很多框架和设施为它做了适配，在 Maven 的 ArtifactId 位置都加上了-jakarta 后缀以示区别，Spring Boot 3.0.0-M2 里用到的 Undertow 中就有 undertow-servlet-jakarta。</p>\n</blockquote>\n\n<h3 id=\"nav_point_178\">11.2.2　调整内嵌 Web 容器配置</h3>\n<p>之前在使用外置 Web 容器的时候，我们总会对配置文件做些调整，例如，修改默认的端口号，调整处理线程数，如果要用 Web 容器来处理 <code>HTTPS</code> 请求，那还要配置证书等。现在虽然换成了内置容器，但这些配置工作还是要做的，毕竟默认配置太“大路货”了，没办法满足我们的个性化需求。Spring Boot 作为一个如此灵活的框架，必然在默认配置之外给我们开了扇大门——可以自己手动对容器进行各种调整，配置文件如果满足不了我们的要求，还可以用代码来配置。</p>\n<ol>\n<li><p><strong>端口配置</strong></p>\n<p>默认情况下，Spring Boot 的内置 Tomcat 会监听 <code>8080</code> 端口，可以通过 <code>application.properties</code> 中的 <code>server.port</code> 来指定要监听的端口号。根据 4.3.2 节中的内容，我们也可以将这个端口的配置放在操作系统的环境变量里，用 <code>SERVER_PORT</code> 变量来进行配置，其效果是一样的。表 11-5 列出了这个配置可以选择的几个取值。</p>\n<p><strong>表 11-5　<code>server.port</code> 的几种可能的取值</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>取值</th><th>说明</th></tr><tr><td><code>0</code></td><td>使用随机的端口，由系统自行决定，随机端口可以避免端口冲突。可以通过注册自己的 <code>ApplicationListener</code> Bean 来获取最终使用的端口号；如果是在单元测试中，则可以通过添加 <code>@LocalServerPort int port;</code> 成员来获得端口号</td></tr><tr><td><code>-1</code></td><td>仅启动 Web 容器，但不监听任何端口，更多是用在单元测试中</td></tr><tr><td><code>1</code>~<code>1024</code></td><td>正常可用于监听的端口，但不建议直接使用，<b>在 Linux 中非 root 用户不能使用 1024 以下的端口</b></td></tr><tr><td><code>1025</code> 及以上</td><td>正常可用于监听的端口，默认的 <code>8080</code> 就在这个范围里，像 <code>8080</code>、<code>8081</code>、<code>8090</code> 这些都算常用的端口号</td></tr></table>\n\n<p>如果服务器绑定了多个地址，例如是双网卡的机器，还可以通过 <code>server.address</code> 来指定程序要绑定的地址。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>压缩配置</strong></p>\n<p>浏览器在浏览网页时与服务器的 HTTP 交互通常是文本形式的，我们看到的 HTML、CSS、JavaScript 等内容其实都是文本，可以通过 GZIP 算法对文本进行压缩，节省传输的带宽。表 11-6 罗列了 Spring Boot 与 HTTP 应答压缩有关的一些配置。</p>\n<p><strong>表 11-6　HTTP 应答压缩相关配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>server.compression.enabled</code></td><td><code>false</code></td><td>是否要开启 HTTP 应答压缩</td></tr><tr><td><code>server.compression.min-response-size</code></td><td><code>2KB</code></td><td>要压缩的应答报文的最小尺寸，如果 <code>Content-Length</code> 小于指定值就不压缩</td></tr><tr><td><code>server.compression.mime-types</code></td><td>对 HTML、XML、纯文本、CSS、JavaScript 和 JSON 做压缩</td><td>要压缩的 MIME 类型，用逗号分隔</td></tr><tr><td><code>server.compression.excluded-user-agents</code></td><td><code>null</code>，都会做压缩</td><td>针对特定的 <code>User-Agent</code> 不做压缩，用逗号分隔</td></tr></table>\n\n<p>假设我们希望对大于 1KB 的应答进行压缩，就可以在 <code>application.properties</code> 里做如下设置：</p>\n<pre class=\"code-rows\"><code>server.compression.enabled=true\nserver.compression.min-response-size=1024</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>SSL 配置</strong></p>\n<p>用明文在网上传输信息总是不太安全，类似新闻这样的普通信息也就罢了，如果是金融或者涉及敏感信息的东西，就不合适使用明文，这时使用 HTTPS 来取代 HTTP 进行通信就是必需的。</p>\n<p>放到以前，我们需要配置 Tomcat 的 <code>&lt;Connector/&gt;</code> 标签，设置 <code>SSLEnabled</code>、<code>scheme</code>、<code>secure</code> 和 <code>sslProtocol</code> 属性，但有了 Spring Boot 就容易多了，在配置文件里加几个配置就好了。<code>ServerProperties</code> 中与 SSL 相关的配置有很多，具体都在 <code>org.springframework.boot.web.server.Ssl</code> 类里，表 11-7 中简单罗列了几个，其中的配置项有很多会设置到 Tomcat 的 <code>SSLHostConfig</code> 里。</p>\n<p><strong>表 11-7　<code>server.ssl.*</code> 的一些常用配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>说明</th></tr><tr><td><code>server.ssl.ciphers</code></td><td>要支持的 SSL 算法，可以接受 OpenSSL 或 JSSE 格式，一般不设，Tomcat 默认用 <code>HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!kRSA</code></td></tr><tr><td><code>server.ssl.enabled</code></td><td>是否开启 SSL 支持，默认为 <code>true</code></td></tr><tr><td><code>server.ssl.enabled-protocols</code></td><td>要开启的协议列表，用＋代表增加某种协议，－代表去除某种协议 <sup><b>5</b></sup></td></tr><tr><td><code>server.ssl.protocol</code></td><td>SSL 使用的协议，默认为 <code>TLS</code></td></tr><tr><td><code>server.ssl.key-alias</code></td><td>密钥库中密钥的别名</td></tr><tr><td><code>server.ssl.key-password</code></td><td>用来访问密钥的密码</td></tr><tr><td><code>server.ssl.key-store</code></td><td>保存了 SSL 证书的密钥库路径，通常是一个 JKS 文件</td></tr><tr><td><code>server.ssl.key-store-password</code></td><td>密钥库文件的密码</td></tr><tr><td><code>server.ssl.key-store-type</code></td><td>密钥库的类型，例如 PKCS12</td></tr></table>\n\n<blockquote>\n<p><sup><b>5</b></sup>这里的协议是具体的 TLS、TLSv1.2 这样的协议，如果用 all，相当于开启了 <code>+SSLv2Hello+TLSv1+TLSv1.1+TLSv1.2+TLSv1.3</code>，不过目前已经不再推荐使用 1.2 版本以下的 TLS 协议了，生产环境中可以考虑禁用。</p>\n</blockquote>\n<p>在 SSL 越来越普及的今天，二进制奶茶店当然也不能落伍，有必要让我们的系统也支持 SSL。</p>\n<blockquote>\n<p><strong>需求描述</strong>　二进制奶茶店现在对外提供服务了，虽然菜单是公开的，但是顾客的订单属于个人隐私，应该在网上加以保护，所以我们希望能加密客户端传输过来的请求与应答。为此，服务端与客户端都需要支持 HTTPS，后续还要支持 HTTP/2。</p>\n</blockquote>\n<p>一般 HTTPS 监听的端口是 <code>443</code>，但这个端口通常是为负载均衡准备的，背后的服务器可以用 <code>8443</code> 端口，<code>application.properties</code> 里的配置如代码示例 11-10 所示。<span class=\"comment-number\">6</span></p>\n<blockquote>\n<p><strong>代码示例 11-10</strong>　开启 HTTPS 支持的配置文件片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>server.port=8443\nserver.ssl.key-store=classpath:binarytea.p12\nserver.ssl.key-store-password=binarytea</code></pre>\n<p>假设我们把密钥库文件 binarytea.p12 放在 CLASSPATH 里，也就是 src/main/resources 里，对应的密码是 <code>binarytea</code>，那程序运行起来后就应该能成功监听 <code>8443</code> 端口。</p>\n<p>在第 9 章的代码示例 9-37 和代码示例 9-38 中，我们使用 HttpComponents 作为 <code>RestTemplate</code> 的底层 HTTP 客户端，配置的 <code>ClientHttpRequestFactory</code> 会忽略证书错误，同时也不会校验主机名，适用于自己签发但又没有导入信任证书列表的情况。当然，如果是机构签发的证书，也是适用的，就是什么东西都不校验了，但这样做不太安全，不建议用在生产环境里。</p>\n<p>所以，我们可以直接用 10.4.2 节中的客户端来访问 https://localhost:8443，客户端用 customer-jwt-auth 或 customer-basic-auth，这里使用前者，将 <code>application.properties</code> 中的 <code>binarytea.url</code> 改成下面这样就可以运行程序了：</p>\n<pre class=\"code-rows\"><code>binarytea.url=https://localhost:8443</code></pre>\n<p>如果这次我们希望能够校验证书，可以调整一下 <code>loadTrustMaterial()</code> 方法的参数，如代码示例 11-11 所示。<span class=\"comment-number\">7</span> 主要是注入了证书存储和对应的密码，随后将证书信息加载到 <code>SSLContext</code> 里，不再忽略校验错误。</p>\n<blockquote>\n<p><strong>代码示例 11-11</strong>　加载了证书的客户端配置类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@Slf4j\npublic class CustomerApplication {\n    @Value(\"$\")\n    private Resource keyStore;\n    @Value(\"$\")\n    private String keyStorePassword;\n\n    @Bean\n    public ClientHttpRequestFactory requestFactory() {\n        // 省略部分代码\n        SSLContext sslContext = null;\n        try {\n            sslContext = SSLContextBuilder.create()\n                // 加载证书\n                .loadTrustMaterial(keyStore.getFile(),\n                keyStorePassword.toCharArray())\n                .build();\n        } catch (Exception e) {\n            log.error(\"Can NOT create SSLContext\", e);\n        }\n        if (sslContext != null) {\n            builder.setSSLContext(sslContext) // 设置SSLContext\n                    .setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE); // 不校验主机名\n        }\n\n        return new HttpComponentsClientHttpRequestFactory(builder.build());\n    }\n    // 省略其他代码\n}</code></pre>\n<p>然后，在 <code>application.properties</code> 里增加证书相关的配置项就可以了：</p>\n<pre class=\"code-rows\"><code>binarytea.ssl.key-store=classpath:binarytea.p12\nbinarytea.ssl.key-store-password=binarytea</code></pre>\n<blockquote>\n<p><strong>茶歇时间：如何获得 HTTPS 证书密钥和证书</strong></p>\n<p>之类的信息对于企业和个人来说都是非常重要的资产，需要重点保护。在上面的例子中，我们使用了一个名为 binarytea.p12 的密钥库，里面就存储着配置 HTTPS 要用到的密钥。那这个密钥库又是怎么获得的呢？</p>\n<p>通常有两种方式：</p>\n<ul>\n<li class=\"第3级无序列表\">自己签发一个仅做学习用途或者内部使用的证书；</li>\n<li class=\"第3级无序列表\">通过专门的机构申请获得证书，有些机构也会提供免费证书，但大部分是需要付费购买的。</li>\n</ul>\n<p>我们先来尝试使用 Java 提供的 keytool 工具自己签发一个证书，具体的命令格式如下：</p>\n<pre class=\"code-rows\"><code>keytool -genkeypair -alias 别名\n         -storetype 密钥库类型 -keyalg 算法 -keysize 长度\n         -keystore 文件名\n         -validity 有效期</code></pre>\n<p>其中，密钥库类型可以选择 JKS、JCEKS 和 PKCS12，算法可以是 RSA 或者 DSA，密钥的长度越长安全性越好，比如用 2048 位的，证书的有效期单位是天。我们例子中的 binarytea.p12 文件用的命令就是：</p>\n<pre class=\"code-rows\"><code>▸ keytool -genkeypair -alias binarytea -storetype pkcs12 -keyalg rsa \\ -keysize 2048 -keystore\nbinarytea.p12 -validity 365</code></pre>\n<p>这里用了交互式的方式，需要自己输入密钥库的密码还有其他一些信息，我们例子里用的密码就是 <code>binarytea</code>。</p>\n<p>自己签发的证书由于无法通过浏览器等其他工具的校验，使用时存在诸多不便，而自己写程序或者使用工具时忽略证书校验错误又存在安全隐患，容易被中间人攻击，所以不推荐在生产中使用。比较合适的方式是从专门的授信机构获得证书。国内的几家大的云服务提供商，例如阿里云和腾讯云，都有提供 SSL 证书的服务。根据证书的类型和用途，会有不同的价格。</p>\n<p>当然，我们也可以选择像 Let's Encrypt 和亚洲诚信这样的机构 <span class=\"comment-number\">8</span>。它们针对单域名提供了免费的证书，目前前者的免费证书有效期是 3 个月，后者的有效期是 1 年。也有第三方服务提供证书自动续签。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Tomcat 容器特定配置</strong></p>\n<p><code>server</code> 打头的配置对应了 Spring Boot 的 <code>ServerProperties</code> 类，Web 容器相关的配置基本在这里了，其中还有几个内部类，针对了不同的 Web 容器，例如 <code>ServerProperties.Tomcat</code> 是针对 Tomcat 的，<code>ServerProperties.Jetty</code> 是针对 Jetty 的，而 <code>ServerProperties.Undertow</code> 则是针对 Undertow 的。因为 Spring Boot 默认使用 Tomcat，所以这里我们来详细了解下 Tomcat 都有哪些配置，具体如表 11-8 所示，也可以通过 <code>ServerProperties</code> 类的代码来查看。</p>\n<p><strong>表 11-8　<code>server.tomcat</code> 打头的几个常用 Tomcat 配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>server.tomcat.threads.max</code></td><td><code>200</code></td><td>最大工作线程数</td></tr><tr><td><code>server.tomcat.threads.min-spare</code></td><td><code>10</code></td><td>最小工作线程数</td></tr><tr><td><code>server.tomcat.max-http-form-post-size</code></td><td><code>2MB</code></td><td>HTTP 提交表单所能接受的最大报文大小</td></tr><tr><td><code>server.tomcat.max-swallow-size</code></td><td><code>2MB</code></td><td>能接受的最大请求报文大小</td></tr><tr><td><code>server.tomcat.max-connections</code></td><td><code>8192</code></td><td>能接受的最大连接数</td></tr><tr><td><code>server.tomcat.accept-count</code></td><td><code>100</code></td><td>当所有工作线程都在工作时，还能接受的请求数</td></tr><tr><td><code>server.tomcat.processor-cache</code></td><td><code>200</code></td><td>能被保留下来处理后续请求的空闲处理器数量</td></tr><tr><td><code>server.tomcat.resource.allow-caching</code></td><td><code>true</code></td><td>是否开启静态资源缓存</td></tr><tr><td><code>server.tomcat.resource.cache-ttl</code></td><td><code>5s</code></td><td>静态资源缓存的过期时间，Spring Boot 里没有给出默认值，但 Tomcat 的 <code>Cache</code> 里有个默认值为 5 秒</td></tr><tr><td><code>server.tomcat.remoteip.host-header</code></td><td><code>X-Forwarded-Host</code></td><td>用来传递远端主机名的 HTTP 头，当 Tomcat 设置在负载均衡之后时，可以通过它来获得远端信息</td></tr><tr><td><code>server.tomcat.remoteip.remote-ip-header</code></td><td><code>X-Forwarded-For</code></td><td>用来传递远端 IP 地址的 HTTP 头，当 Tomcat 设置在负载均衡之后时，可以通过它来获得远端信息，Spring Boot 里没有给出默认值，但 Tomcat 的 <code>RemoteIpValve</code> 里有默认值</td></tr></table>\n\n<p>&nbsp;</p>\n</li>\n<li><p><strong>其他配置</strong></p>\n<p>除了容器特定的配置外，在 Spring Boot 的 <code>ServerProperties</code> 里还有很多其他的配置项，表 11-9 里简单罗列了一些，更多的内容可以直接查看 <code>ServerProperties</code> 的代码，或者查阅 Spring Boot 文档的附录部分。</p>\n<p><strong>表 11-9　ServerProperties 中的一些其他配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>server.max-http-header-size</code></td><td><code>8KB</code></td><td>能接受的最大 HTTP 报文头大小</td></tr><tr><td><code>server.servlet.context-path</code></td><td></td><td>应用的上下文路径</td></tr><tr><td><code>server.servlet.session.timeout</code></td><td><code>30m</code></td><td>会话超时时间，如果不带后缀，默认单位是秒</td></tr><tr><td><code>server.servlet.session.cookie.http-only</code></td><td><code>false</code></td><td>会话 Cookie 是否使用 HttpOnly 的 Cookie</td></tr><tr><td><code>server.servlet.session.cookie.max-age</code></td><td></td><td>会话 Cookie 的最长有效时间，如果不带后缀，默认单位是秒。Spring Boot 没有给出默认值，但 Tomcat 里 Cookie 的 <code>maxAge</code> 的默认值为 <code>-1</code></td></tr><tr><td><code>server.error.include-exception</code></td><td><code>false</code></td><td>是否包含 <code>exception</code> 属性，不建议在生产环境里开启</td></tr><tr><td><code>server.error.include-stacktrace</code></td><td><code>never</code></td><td>何时要包含 <code>trace</code> 属性，里面是异常的跟踪栈，不建议在生产环境里开启</td></tr><tr><td><code>server.error.path</code></td><td><code>/error</code></td><td>显示错误信息的控制器路径</td></tr><tr><td><code>server.error.whitelabel.enabled</code></td><td><code>true</code></td><td>发生错误时是否使用默认的错误页 <sup><b>9</b></sup></td></tr></table>\n\n<blockquote>\n<p><sup><b>9</b></sup>White Label 中文直译为白标，最早指不带自己的品牌，不做品牌宣传。放在这里，Spring Boot 的默认错误页面叫 White Label，大概也是因为上面没有 Spring 和系统的 Logo 与信息，只有大大的 Whitelabel Error Page 和错误内容。</p>\n</blockquote>\n<p>如果通过配置参数无法满足需求，Spring Boot 还提供了一个 <code>WebServerFactoryCustomizer&lt;T extends WebServerFactory&gt;</code> 接口，<code>WebServerFactoryCustomizerBeanPostProcessor</code> 这个后置处理器会对上下文里的每个 <code>WebServerFactory</code> Bean 执行后置处理，进行个性化配置。在 Spring Boot 里针对不同的容器提供了不同的 <code>WebServerFactory</code>，例如 <code>TomcatServletWebServerFactory</code>、<code>JettyServletWebServerFactory</code> 和 <code>UndertowServletWebServerFactory</code>，响应式 Web 容器也有对应的类。如果想定制 Tomcat 容器，可以像下面这样：</p>\n<pre class=\"code-rows\"><code>@Component\npublic class BinaryteaTomcatWebServerCustomizer\n        implements WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; {\n\n    @Override\n    public void customize(TomcatServletWebServerFactory factory) {\n        // 调用factory里的方法\n        //例如addAdditionalTomcatConnectors()，可以多监听几个不同的端口\n    }\n}</code></pre>\n</li>\n</ol>\n\n\n\n<h3 id=\"nav_point_179\">11.2.3　支持 HTTP/2</h3>\n<p>我们在日常浏览网页时使用的协议大多是 HTTP/1.1，之前的例子里使用的也是这个协议。HTTP/1.1 正式发布于 1999 年，至今已经 20 余年了。这是一个优秀且伟大的协议，经住了历史的考验。但它也不是完全没有问题，HTTP/1.1 的性能就一直被人诟病，所以出现了很多看似不太合理的优化手段，例如 CSS 雪碧图（CSS Sprites）<span class=\"comment-number\">10</span>。为了优化 HTTP 的性能，Google 在 2012 年推出了 SPDY，这也可以看成是 HTTP/2 的原型，2016 年后 Google 就不再支持 SPDY，转而拥抱 HTTP/2 了。HTTP/2 在性能方面做了不少优化，例如：</p>\n\n<ul>\n<li>多路复用，能在一个连接上同时发起多个请求，不再需要等一个结束后再发起下一个；</li>\n<li>二进制分帧，通过在应用层和传输层之间引入额外的一层，用二进制编码后的帧来减少传输量；</li>\n<li>HTTP 头压缩，之前的压缩是针对报文正文的，而在 HTTP/2 中报文头也可以用 HPack 算法压缩了；</li>\n<li>服务端推送（Server Push），服务端能主动将内容推送给客户端。</li>\n</ul>\n<p>Spring Boot 内置了多款 Web 容器，基本都支持 HTTP/2，只需简单的配置就可以了。但如果有条件的话，还是建议在负载均衡层面来处理 HTTP/2 和 TLS 的工作，而不是在应用服务器上。</p>\n<ol>\n<li><p><strong>服务端支持 HTTP/2</strong></p>\n<p>大部分情况下，我们使用的是 Tomcat，所以来看看如何开启 Tomcat 的 HTTP/2 支持。如果在使用 JDK 9 及以上的版本（例如 LTS 版本 11 和 17），那 Spring Boot 自带的 Tomcat 能直接支持 HTTP/2，只需在配置文件中增加如下配置即可：<span class=\"comment-number\">11</span></p>\n<pre class=\"code-rows\"><code>server.http2.enabled=true</code></pre>\n<p>为什么这里的最低要求是 JDK 9 呢，因为 JDK 8 不支持 HTTP/2，此时 Tomcat 需要 libtcnative 的帮助才能提供 HTTP/2 服务。<span class=\"comment-number\">12</span> 不过，也有不走寻常路的，Undertow 就自己实现了 HTTP/2，在 JDK 8 上也能在无须任何额外依赖的情况下支持 HTTP/2。</p>\n<p>完成配置后，我们可以通过 curl 命令简单地做个测试，看到如下输出中的 <code>h2</code> 和 <code>HTTP/2</code> 就说明“走了”HTTP/2 协议，还可以加上 <code>--http2</code> 强制使用 HTTP/2：</p>\n<pre class=\"code-rows\"><code>▸ curl -v -k https://localhost:8443/menu/\n\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8443 (#0)\n* ALPN, offering h2\n* ALPN, offering http/1.1\n* successfully set certificate verify locations:\n* 省略部分内容\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384\n* ALPN, server accepted to use h2\n* 省略部分内容\n* Using HTTP2, server supports multi-use\n* Connection state changed (HTTP/2 confirmed)\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\n* Using Stream ID: 1 (easy handle 0x7fe31500e800)\n&gt; GET /menu/ HTTP/2\n&gt; Host: localhost:8443\n&gt; User-Agent: curl/7.64.1\n&gt; Accept: */*\n&gt;\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\n&lt; HTTP/2 200\n&lt; 省略部分内容</code></pre>\n<p>虽然官方不建议使用基于明文的 HTTP/2（简称 H2C），但我们还是可以在 Spring Boot 提供 H2C 的服务。首先将 <code>server.http2.enabled</code> 设置为 <code>false</code>；接下来，用上一节提到的 <code>WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt;</code> 做些手动配置，具体如代码示例 11-12 所示。<span class=\"comment-number\">13</span> 使用 H2C 时记得要去掉所有 SSL 相关的配置。</p>\n<blockquote>\n<p><strong>代码示例 11-12</strong>　开启 H2C 支持的配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableCaching\npublic class BinaryTeaApplication implements WebMvcConfigurer,\n        WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; {\n    @Override\n    public void customize(TomcatServletWebServerFactory factory) {\n        factory.addConnectorCustomizers(connector -&gt; connector.addUpgradeProtocol(new Http2Protocol()));\n    }\n    // 省略其他代码\n}</code></pre>\n<p>一样，也是用 curl 命令来做测试，但是一定要用 <code>--http2</code> 强制使用 HTTP/2，这时虽然显示的协议是 HTTP/1.1，但 <code>Upgrade: h2c</code> 说明已经升级到了 H2C：</p>\n<pre class=\"code-rows\"><code>▸ curl --http2 -v http://localhost:8080/menu\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8080 (#0)\n&gt; GET /menu HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.64.1\n&gt; Accept: */*\n&gt; Connection: Upgrade, HTTP2-Settings\n&gt; Upgrade: h2c\n&gt; HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA\n&gt;\n&lt; HTTP/1.1 101\n&lt; Connection: Upgrade\n&lt; Upgrade: h2c\n&lt; Date: Sun, 21 Feb 2021 14:18:34 GMT\n* Received 101\n* Using HTTP2, server supports multi-use\n* Connection state changed (HTTP/2 confirmed)\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\n&lt; HTTP/2 200</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>客户端支持 HTTP/2</strong></p>\n<p>聊完了服务端，再来看看客户端用 <code>RestTemplate</code> 如何支持 HTTP/2。在 9.4 节里我们说过 <code>RestTemplate</code> 支持多种底层的 HTTP 客户端，其中用的比较多的是 Apache HttpComponents 和 OkHttp。就 HTTP/2 而言，HttpComponents 在 5.1 版本才开始支持，但在 Spring Framework 中适配的还是 4.<em>x</em> 的版本。OkHttp 就不存在这个问题，Spring Framework 适配的 OkHttp 3.14 版本就已经完全支持 HTTP/2 了，因此在这里我们就要把底层的客户端切换为 OkHttp。</p>\n<p>首先，我们调整一下 pom.xml，将 HttpComponents 的依赖去掉，增加 OkHttp 的依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;\n    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>接下来，修改 <code>CustomerApplication</code> 的 <code>requestFactory()</code> 方法，原先它返回的是 <code>HttpComponentsClientHttpRequestFactory</code>，现在要改为 <code>OkHttp3ClientHttpRequestFactory</code>，相应的 SSL 配置和连接配置也要做一定的调整，具体如代码示例 11-13 所示。<span class=\"comment-number\">14</span></p>\n<blockquote>\n<p><strong>代码示例 11-13</strong>　适配 OkHttp 的 <code>ClientHttpRequestFactory</code> 配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class CustomerApplication {\n    @Bean\n    public ClientHttpRequestFactory requestFactory() {\n\n        // 构造SSLSocketFactory，配置密钥等信息\n        SSLSocketFactory sslSocketFactory = null;\n        TrustManagerFactory tmf = null;\n        try {\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(this.keyStore.getInputStream(), keyStorePassword.toCharArray());\n            tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            tmf.init(keyStore);\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, tmf.getTrustManagers(), null);\n            sslSocketFactory = sslContext.getSocketFactory();\n        } catch (Exception e) {\n            log.error(\"Can NOT create sslSocketFactory and \", e);\n        }\n\n        OkHttpClient.Builder builder = new OkHttpClient.Builder()\n             .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1)) // 默认就这样\n             .connectTimeout(10, TimeUnit.SECONDS) // 以下3个超时默认就是10秒\n             .callTimeout(10, TimeUnit.SECONDS)\n             .readTimeout(10, TimeUnit.SECONDS)\n             .connectionPool(new ConnectionPool(50, 30, TimeUnit.MINUTES));\n\n        if (sslSocketFactory != null) {\n            builder.connectionSpecs(Collections.singletonList(ConnectionSpec.RESTRICTED_TLS))\n                    .hostnameVerifier((hostname, session) -&gt; true) // 不验证主机\n                    .sslSocketFactory(sslSocketFactory, (X509TrustManager) tmf.getTrustManagers()[0]);\n        }\n\n        return new OkHttp3ClientHttpRequestFactory(builder.build());\n    }\n    // 省略其他代码\n}</code></pre>\n<p>这里需要做一些说明。</p>\n<ul>\n<li><code>protocols()</code> 指定支持的协议有些限制，例如，<code>H2_PRIOR_KNOWLEDGE</code> 和 <code>HTTP_1_1</code> 必须至少有一个；用了 <code>H2_PRIOR_KNOWLEDGE</code> 就不能再加别的协议了；不能使用 <code>HTTP_1_0</code>。</li>\n<li><code>connectTimeout()</code>、<code>callTimeout()</code> 和 <code>readTimeout()</code> 这三个超时设置为 <code>0</code> 表示不超时，这里的代码示例里使用的其实就是默认值，放在这里主要是演示一下有这个配置。</li>\n<li><code>callTimeout()</code> 这个超时包含了整个请求过程，包括 DNS 解析、连接、发送请求、等待服务端处理和返回应答，如果配置了重试，那重试也包含在内。因此它至少应该大于等于另两个单独步骤的超时。</li>\n<li><code>hostnameVerifier()</code> 设置为不验证主机完全是因为我们在演示时使用了自签证书，在生产环境不建议这么做，存在安全隐患。</li>\n<li>OkHttp 内置了一些 <code>ConnectionSpec</code>，例子里我们使用了 <code>RESTRICTED_TLS</code>，具体的几个内置项如表 11-10 所示（根据安全性从高到低排列）。</li>\n</ul>\n<p><strong>表 11-10　OkHttp 内置的 <code>ConnectionSpec</code></strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><td><code>ConnectionSpec</code></td><th>支持的 TLS 版本</th><th>加密套件 <sup><b>15</b></sup></th><th>适用范围</th></tr><tr><td><code>RESTRICTED_TLS</code></td><td>TLS 1.3 与 TLS 1.2</td><td>目前为止较为安全且支持较多的 9 种套件</td><td>服务端和客户端版本都比较新的情况</td></tr><tr><td><code>MODERN_TLS</code></td><td>TLS 1.3 与 TLS 1.2</td><td>在 <code>RESTRICTED_TLS</code> 的基础上增加了 7 种 HTTP/2 不推荐的套件</td><td>支持大部分情况，也是默认使用的</td></tr><tr><td><code>COMPATIBLE_TLS</code></td><td>TLS 1.3、TLS 1.2、TLS 1.1 与 TLS 1.0</td><td>同 <code>MODERN_TLS</code></td><td>用来兼容一些较老的平台</td></tr><tr><td><code>CLEARTEXT</code></td><td>无</td><td>无</td><td>HTTP 明文传输</td></tr></table>\n\n<blockquote>\n<p><sup><b>15</b></sup>加密套件（Cipher Suite），其实是一个“四件套”，由密钥交换算法、身份验证算法、对称加密算法和信息摘要算法四个部分组成。以 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 为例，协议是 TLS，密钥交换算法是 ECDHE，身份验证算法是 RSA_WITH_AES_256，对称加密算法是 GCM，信息摘要算法是 SHA384。</p>\n</blockquote>\n<p>如果想要走 H2C 协议，在 <code>requestFactory()</code> 里删掉与 SSL 相关的内容，协议改为 <code>H2_PRIOR_KNOWLEDGE</code> 就可以了，具体如代码示例 11-14 所示。</p>\n<blockquote>\n<p><strong>代码示例 11-14</strong>支持 H2C 的 <code>ClientHttpRequestFactory</code> 配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Bean\npublic ClientHttpRequestFactory requestFactory() {\n    OkHttpClient.Builder builder = new OkHttpClient.Builder()\n                 // 只能保留一个\n                 .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))\n                 .connectTimeout(10, TimeUnit.SECONDS)\n                 .callTimeout(10, TimeUnit.SECONDS)\n                 .readTimeout(10, TimeUnit.SECONDS)\n                 .connectionPool(new ConnectionPool(50, 30, TimeUnit.MINUTES));\n\n    return new OkHttp3ClientHttpRequestFactory(builder.build());\n}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：网站提供的 HTTPS 服务到底是否安全？</strong></p>\n<p>在这部分里我们讨论了很多 HTTPS 还有 HTTP/2 的内容，经过这一轮设置，网站的安全性得到了很大的提升。但是，我们做的到底好不好，够不够呢？总得检验一下才能放心。大公司有自己的安全团队，有钱的中小公司可以请第三方机构进行检测。那有没有既方便又不用花钱、结果还有参考价值的办法呢？</p>\n<p>结论肯定是有的，这里要给大家推荐两个工具，一个是 SSL Labs 的在线 SSL 测试，另一个是亚洲诚信推出的 MySSL 检测工具。两者的作用差不多，都是根据事先预设好的检测条目，逐条进行检测，规则包括但不限于证书、支持的协议、支持的算法、是否存在已知漏洞等。然后根据检测结果进行综合打分，最后针对网站 SSL 配置的安全性做出一个评价，最高是 A+。如果存在问题，工具也会给出优化建议。</p>\n<p>可以选择其一对自己的网站进行在线测试。建议选择前者，规则会更为严格一些。</p>\n</blockquote>\n</li>\n</ol>\n\n\n\n\n<h2 id=\"nav_point_180\">11.3　支持分布式 Session</h2>\n<p>在生产环境中，我们基本会要求应用以集群的方式部署，就算用 Kubernetes，也会要求最小保持两个 Pod，且两个 Pod 要在不同的物理节点上，以防止出现单点故障——这是最起码的设计要求。正常情况下，任何理由的单点都是<strong>不应该</strong>存在的。</p>\n<p>这时就可能出现以下情况：对于用户几次连续的请求，有的请求发给了 A 服务器，有的则发给了 B 服务器，而默认 Servlet 的 Session<span class=\"comment-number\">16</span> 是保存在本地的。访问不同的服务器，看到的 Session 信息是不同的。例如，一个请求访问 A 服务器，A 服务器发现本地没有该用户的 Session，就直接创建了个新的，写了些信息进去；下一个请求访问了 B 服务器，也发现本地没有该用户的 Session，同样创建了一个新的，这里面当然就没有 A 服务器写进去的内容。</p>\n\n<p>既然知道了会有这样的问题，那自然就要去寻找解决方案，好在我们不是行业里第一批遇到这个问题的人，前人已经为我们准备好了解决方案。</p>\n<h3 id=\"nav_point_181\">11.3.1　几种常见的解决方案</h3>\n<p>在介绍 Spring Session 这个 Spring 提供的解决方案之前，我们先来了解一些常见的解决方案的思路，也许这些方案就足够处理目前的场景了。能用简单的办法搞定的，为什么要选复杂的呢？</p>\n<ol>\n<li><p><strong>使用 Cookie</strong></p>\n<p>既然不同的机器没办法简单地使用同一个 Session，那索性就不用 Session 了。我们可以把原先需要通过 Session 来传递的信息放到 Cookie 里面。每次请求时都会从客户端读取 Cookie 发送给服务端，这相当于把在不同请求间共享信息的任务交给了客户端来做，要共享的内容也都放到了客户端。</p>\n<p>但这时需要注意以下两点：</p>\n<ul>\n<li>由于 Cookie 是保存在客户端的，而且每次都需要在网上进行传输，不建议将敏感信息放在 Cookie 里，如果一定要放也必须加密存放，避免信息泄露；</li>\n<li>每次请求都要在请求中包含 Cookie，如果 Cookie 很大，势必会导致请求很大，这带来了额外的传输量，所以东西能精简就精简。</li>\n</ul>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>会话保持</strong></p>\n<p>我们说自己的应用是个集群，那在实际的服务器之前就一定会有负载均衡设备。既然请求都会经过负载均衡，那就可以想办法让同一个用户的请求都访问同一台服务器，这样就可以一直使用同一台服务器上的 Session。这种让一次会话过程中发起的请求都发送到同一台服务器上的技术就是会话保持，有时也称为粘滞会话（Sticky Session）。大致情况如图 11-1 所示，用户发起的请求 1 和请求 2 都会被转发到同一个后端节点上。</p>\n<p>以使用 Nginx 实现负载均衡为例，可以在配置 <code>upstream</code> 时加入 <code>ip_hash</code> 配置，开启基于 IP 的会话保持。这种方案简单有效，但如果遇上 Hash 分配到的服务器宕机，会重新进行 Hash 计算，选择新的服务器，这时还是会丢失一部分的 Session。不同方案各有利弊，做出选择就意味着要接受潜在的风险。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>会话复制</strong></p>\n<p>如果还是想让请求落到不同的服务器上，也可以考虑让不同的服务器拥有相同的 Session。数据库有主从复制，也有“双主”的策略，Web 容器的 Session 管理策略可以借鉴这种思想，实现会话复制（Session Replication）。在成熟的 Java Web 容器里都有集群模式，例如 Tomcat 里就可以配置 <code>SimpleTcpCluster</code>，里面包含了集群中每个节点的信息，Session 会在整个集群中进行复制。大致情况如图 11-2 所示，节点 1 和节点 2 能双向复制 Session，因此用户的请求落到哪个节点都没有太大差别。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00783.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-1　会话保持示意图</strong></p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00784.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-2　会话复制示意图</strong></p>\n<p>当然，这个方案的问题也比较明显，在服务器之间复制大量的 Session 势必会占用服务器和网络的资源。而且数据的复制始终会有一定延时，因而就有一定的概率在节点异常关闭后数据并未及时复制，导致 Session 丢失。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>共享存储</strong></p>\n<p>应用的服务器是个集群，我们一直说它们需要做成无状态的，存在 Session 状态在某种意义上就是违背了无状态的原则，那么把这种状态从应用里剥离出来不就可以了吗？之前使用 Cookie 就是这个思路，它把状态往前推给了客户端，这次我们要往后推，既然应用服务器是无状态的，那就把状态保存在可以存储状态的地方。例如，早期会选择 Memcached，现在更多的是放在 Redis 和数据库这样的存储里。Web 容器是通过 <code>JSESSIONID</code> 来加载 Session 的，只需修改这个加载和存储逻辑，背后使用指定的存储就可以了。大致情况如图 11-3 所示，Session 都保存在同一个存储中，节点就变成无状态的了，自然可以处理全部请求。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00785.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-3　共享存储示意图</strong></p>\n<p>这个方案可以比较理想地解决会话保持和会话复制在遇到异常时会丢失数据的问题，因为数据都在后端存储里，但代价是要部署额外的存储，还要实现一定的高可用，例如 Redis 需要用 Redis Cluster，数据库要部署主从节点。另外，这个方案需要一些额外的组件开发，好在现在有 Spring Session，它已经实现好了一套比较完善的分布式 Session 机制，背后也有多种存储可供选择。接下来，就让我们一起了解一下 Spring Session。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_182\">11.3.2　使用 Spring Session 实现分布式 Session</h3>\n<p>为了帮助大家处理 Session 相关的问题，Spring Session 提供了一套完备的 API，和 Spring 的其他组件一样，它在不同的底层实现之上做了统一的抽象，开发时无须与特定容器绑定。Spring Session 中包含了对类似 Tomcat 这种 Web 容器的 <code>HttpSession</code> 的支持，还提供了 WebSocket 和 WebFlux 的支持。它由以下一些主要模块组成：</p>\n<ul>\n<li>Spring Session Core，包含核心 API 和基础功能；</li>\n<li>Spring Session JDBC，提供使用 JDBC 作为 Session 存储的能力；</li>\n<li>Spring Session Data Redis，提供使用 Redis 作为 Session 存储的能力。</li>\n</ul>\n<p>除此之外，还有 Spring Session MongoDB、Spring Session Hazelcast、Spring Session for Apache Geode，分别提供了不同的底层存储能力。</p>\n<p>Spring Boot 里自带了 Spring Session 相关的依赖，可以直接使用。如果希望使用更新版本，可以在 pom.xml 的 <code>&lt;dependencyManagement /&gt;</code> 中添加如下 BOM（具体版本需要到官方网站查看）：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-session-bom&lt;/artifactId&gt;\n    &lt;version&gt;2020.0.3&lt;/version&gt;\n    &lt;type&gt;pom&lt;/type&gt;\n    &lt;scope&gt;import&lt;/scope&gt;\n&lt;/dependency&gt;</code></pre>\n<p>然后直接在 <code>&lt;dependencies /&gt;</code> 里引入需要的依赖，此时无须指定版本。</p>\n<ol>\n<li><p><strong>实现原理</strong></p>\n<p>在开发过程中，我们基本是从 <code>HttpServletRequest</code> 里获取 <code>HttpSession</code> 进行相关的操作，区别无非是通过自己写的代码来获取，还是由 Spring MVC 框架注入方法的参数里。既然这些都是接口，对使用 <code>HttpSession</code> 的代码而言，无须关心它实际存储在哪里，又是怎么取出来的。</p>\n<p>Spring Session 正是基于这个思想，通过 <code>SessionRepositoryFilter&lt;S extends Session&gt;</code> 这个 Servlet <code>Filter</code> 拦截了 <code>HTTP</code> 请求，将请求中的 <code>HttpServletRequest</code> 封装为 <code>SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper</code>。从这个 <code>Wrapper</code> 中获取的 Session 都是 <code>HttpSessionWrapper</code>，它的操作都是由 <code>SessionRepositoryFilter</code> 里的 <code>SessionRepository&lt;S&gt;</code> 来实施的。如果背后是 JDBC，那这个 <code>SessionRepository&lt;S&gt;</code> 就是 <code>JdbcIndexedSessionRepository&lt;JdbcIndexedSessionRepository.JdbcSession&gt;</code>。Spring Session 部分核心类的大致结构如图 11-4 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00786.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 11-4　Spring Session 的部分核心类</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>基于数据库存储 Session</strong></p>\n<p>要开启 Spring Session 的 JDBC 支持，首先要在 pom.xml 中引入如下依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n   &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;\n   &lt;artifactId&gt;spring-session-jdbc&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>Spring Session JDBC 其实就是把 Session 信息存储在数据库的 <code>SPRING_SESSION</code> 和 <code>SPRING_SESSION_ ATTRIBUTES</code> 表里，前者保存了 Session 的信息，例如 <code>SESSION_ID</code>、何时创建的、最后访问时间、过期时间等信息；后者则是 Session 中的具体属性。那这两张表的表结构如何，我们该怎么去创建它们呢？Spring Session JDBC 早就为我们准备好了，在 spring-session-jdbc 的 Jar 中，org/springframework/session/jdbc/ 目录下提供了 10 种不同数据的建表与删表语句，具体如表 11-11 所示。有了表之后，再通过 <code>JdbcOperations</code> 进行各种增删改查操作就可以了。</p>\n<p><strong>表 11-11　Spring Session JDBC 内置的 Schema 文件</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>数据库</th><th>建表语句文件</th><th>删表语句文件</th></tr><tr><td>DB2</td><td>schema-db2.sql</td><td>schema-drop-db2.sql</td></tr><tr><td>Derby</td><td>schema-derby.sql</td><td>schema-drop-derby.sql</td></tr><tr><td>H2</td><td>schema-h2.sql</td><td>schema-drop-h2.sql</td></tr><tr><td>HsqlDB</td><td>schema-hsqldb.sql</td><td>schema-drop-hsqldb.sql</td></tr><tr><td>MySQL</td><td>schema-mysql.sql</td><td>schema-drop-mysql.sql</td></tr><tr><td>Oracle</td><td>schema-oracle.sql</td><td>schema-drop-oracle.sql</td></tr><tr><td>PostgreSQL</td><td>schema-postgresql.sql</td><td>schema-drop-postgresql.sql</td></tr><tr><td>SQLite</td><td>schema-sqlite.sql</td><td>schema-drop-sqlite.sql</td></tr><tr><td>SQLServer</td><td>schema-sqlserver.sql</td><td>schema-drop-sqlserver.sql</td></tr><tr><td>Sybase</td><td>schema-sybase.sql</td><td>schema-drop-sybase.sql</td></tr></table>\n\n<p>在生产环境中，DBA 通常会根据要求事先在数据库里建好对应的表。例如对于 MySQL 数据库，我们就可以把 schema-mysql.sql 里的语句拿出来给到 DBA，之前在开发时我们都选择了 H2 数据库，所以可以把 schema-h2.sql 等文件里的内容放到我们的 schema.sql 里，或者像代码示例 11-15 这样手动创建一个内嵌数据源，其他类似 <code>TransactionManager</code> 之类的 Bean 依然交给 Spring Boot 的自动配置来为我们创建。如果我们的代码中存在多个 <code>DataSource</code> Bean，可以在用于 Spring Session 的 <code>DataSource</code> 声明上增加 <code>@SpringSessionDataSource</code> 注解加以标识。</p>\n<blockquote>\n<p><strong>代码示例 11-15</strong>　添加了 Spring Session JDBC 脚本的内嵌数据源配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableCaching\n@EnableJdbcHttpSession\npublic class BinaryTeaApplication implements WebMvcConfigurer {\n    @Bean\n    public EmbeddedDatabase dataSource() {\n        return new EmbeddedDatabaseBuilder()\n                .setType(EmbeddedDatabaseType.H2)\n                .addScript(\"org/springframework/session/jdbc/schema-drop-h2.sql\")\n                .addScript(\"org/springframework/session/jdbc/schema-h2.sql\")\n                .build();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>上面的代码中，我们还在类上添加了一个 <code>@EnableJdbcHttpSession</code> 注解，它的定义如下所示：</p>\n<pre class=\"code-rows\"><code>@Retention(RetentionPolicy.RUNTIME)\n@Target()\n@Documented\n@Import()\n@Configuration(proxyBeanMethods = false)\npublic @interface EnableJdbcHttpSession {...}</code></pre>\n<p>它导入了 <code>JdbcHttpSessionConfiguration</code>，其中会为我们创建 <code>SessionRepositoryFilter&lt;? extends Session&gt;</code> 类型的 <code>springSessionRepositoryFilter</code>，通过它来实现 11.3.2 开头部分的封装逻辑。Spring Boot 会自动注册上下文里的 <code>Filter</code>，以便对请求进行拦截，如果不是在 Spring Boot 里，或者禁用了 Spring Boot Servlet 相关的自动配置，我们可以像官方文档里那样使用 <code>AbstractHttpSessionApplicationInitializer</code> 来完成 <code>Filter</code> 的注册。</p>\n<p>用户的登录信息是放在 Session 里的，未登录用户访问 <code>/order</code> 会被重定向到登录页面，登录后 Session 里就有了当前登录的信息，这时我们可以通过 JDBC 查看一下 <code>SPRING_SESSION</code> 和 <code>SPRING_SESSION_ATTRIBUTES</code> 表的内容，然后带上 Cookie 再去访问 <code>/order</code>，应该就能正常访问了。具体测试代码如代码示例 11-17 所示，但在此之前，需要先设置一下我们的 <code>MockMvc</code>，加入 <code>SessionRepositoryFilter</code>，如代码示例 11-16 所示（注意添加 <code>Filter</code> 的顺序）。</p>\n<blockquote>\n<p><strong>代码示例 11-16</strong>　在 <code>MockMvc</code> 里增加 <code>SessionRepositoryFilter</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass OrderControllerTest {\n    private MockMvc mockMvc;\n    private JdbcTemplate jdbcTemplate;\n\n    @BeforeEach\n    void setUp(WebApplicationContext wac) {\n        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac)\n            .addFilter(wac.getBean(\"springSessionRepositoryFilter\", SessionRepositoryFilter.class))\n            .apply(springSecurity())\n            .build();\n        jdbcTemplate = new JdbcTemplate(wac.getBean(DataSource.class));\n    }\n    // 省略其他代码\n}</code></pre>\n<p>在 <code>JdbcIndexedSessionRepository</code> 保存完 Session 信息后会返回一个 Session ID，<code>SessionRepositoryFilter</code> 会通过 <code>HttpSessionIdResolver</code> 将其写入指定位置，例如，在我们的测试中就是用 <code>CookieHttpSessionIdResolver</code> 把 Session ID 写到了 Cookie 中。名为 <code>SESSION</code> 的 Cookie 中用 BASE64 的方式保存了 Session ID，类似 <code>MDhhMDg5NWYtZTU5Ny00NzNlLTk2NzYtMzU0ZDBjZGIyOGE3</code>，还原后就是 <code>08a0895f-e597-473e-9676-354d0cdb28a7</code>，用它就可以在数据库里进行查询了。</p>\n<blockquote>\n<p><strong>代码示例 11-17</strong>　<code>OrderControllerTest</code> 中针对 Spring Session JDBC 的单元测试</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Test\nvoid testLoginWithJdbcSession() throws Exception {\n    mockMvc.perform(get(\"/order\"))\n            .andExpect(status().is3xxRedirection());\n\n    MvcResult result = mockMvc.perform(post(\"/doLogin\")\n            .param(\"user\", \"LiLei\").param(\"pwd\", \"binarytea\")\n            .with(csrf())).andReturn();\n    Cookie sessionCookie = result.getResponse().getCookie(\"SESSION\");\n    String sessionId = new String(Base64.getDecoder().decode(sessionCookie.getValue()));\n    String id = jdbcTemplate.queryForObject(\n            \"select PRIMARY_ID from SPRING_SESSION where SESSION_ID='\" + sessionId + \"'\", String.class);\n    assertNotNull(id);\n    int attrCount = jdbcTemplate.queryForObject(\n            \"select count(*) from SPRING_SESSION_ATTRIBUTES where SESSION_PRIMARY_ID='\" + id + \"'\",\n            Integer.class);\n    assertTrue(attrCount &gt; 0);\n\n    mockMvc.perform(get(\"/order\").cookie(sessionCookie))\n            .andExpect(status().isOk());\n}</code></pre>\n<p>其实，Spring Boot 的自动配置中提供了与 Spring Session 相关的配置，我们无须自己添加 <code>@EnableJdbcHttpSession</code> 注解，只要 CLASSPATH 中有相关的依赖，用配置文件就能完成配置，<code>spring.session</code> 对应的配置属性类是 <code>SessionProperties</code>，而 <code>spring.session.jdbc</code> 对应的则是 <code>JdbcSessionProperties</code>。<code>JdbcSessionDataSourceInitializer</code> 会根据实际数据源的类型完成数据库的初始化，我们也不需要配置 <code>EmbeddedDatabase</code> 了。</p>\n<p>在 <code>application.properties</code> 中添加如下配置也可以指定使用 Spring Session JDBC，<code>spring.session.jdbc.initialize-schema</code> 的作用与 <code>spring.datasource.initialization-mode</code> 是类似的，<code>spring.session.jdbc.schema</code> 是初始化数据表用的 SQL 文件，<code>spring.session.jdbc.table-name</code> 则是存储 Session 的表名：</p>\n<pre class=\"code-rows\"><code>spring.session.store-type=jdbc\nspring.session.jdbc.initialize-schema=embedded\nspring.session.jdbc.schema=classpath:org/springframework/session/jdbc/schema-@@platform@@.sql\nspring.session.jdbc.table-name=SPRING_SESSION</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>基于 Redis 存储 Session</strong></p>\n<p>一旦理解如何使用 Spring Session JDBC 存储 Session，使用 Redis 的方法就简单多了——先是引入 Spring Session Data Redis 的依赖（如果没有引入 Spring Data Redis 相关依赖，可以一并加上）：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>然后，按照 8.2 节中的方法配置 Redis 相关的信息，剩下的交给 Spring Boot 的自动配置就好了。如果 CLASSPATH 中同时存在多个 Spring Session 的依赖，也可以在 <code>application.properties</code> 中像下面这样指定存储方式，或者在配置类上增加 <code>@EnableRedisHttpSession</code> 注解。<code>spring.session.redis</code> 对应的配置类是 <code>RedisSessionProperties</code>，其中需要特别说明的是 <code>spring.session.redis.namespace</code> 可以用来配置 Redis 中保存 Session 信息的键名的前缀：</p>\n<pre class=\"code-rows\"><code>spring.session.store-type=redis\nspring.session.redis.namespace=spring:session</code></pre>\n<p>其实还有个简单的方法可以测试是否配置好了 Redis 存储：如果使用单机的 Session 管理，Tomcat 重启后 Session 会丢失；而使用了 Spring Session Data Redis 的系统，Session 保存在 Redis 里，只要用之前的 Cookie 发起请求，依旧可以获得 Session。</p>\n</li>\n</ol>\n","comments":[]}