{"id":429059,"title":"16｜配置和环境（下）：配置服务中的设计思路","content":"<p>你好，我是轩脉刃。</p><p>上一节课，我们已经定义好了配置文件服务的接口，这节课就来实现这些接口。先来规划配置文件服务目录，按照上一节课分析的，多个配置文件按类别放在不同配置文件夹中，在框架文件夹中，我们将配置文件接口代码写在框架文件夹下的contract/config.go文件中，将具体实现放在provider/config/目录中。</p><h2>配置服务的设计</h2><p>不过设计优于实现，动手之前我们先思考下实现这个接口要如何设计。</p><p>首先，要读取一下配置文件夹中的文件。上节课说了，最终的配置文件夹地址为，应用服务的 ConfigFolder 下的环境变量对应的文件夹，比如 ConfigFolder/development。但是还有一个问题，就是配置文件的格式的选择。</p><p><strong>目前市面上的配置文件格式非常多，但是很难说哪种配置文件比较好，完全是不同平台、不同时代下的产物</strong>。比如Windows开发的配置常用INI、Java开发配置常用Properties，我这里选择了使用YAML格式。</p><h3>配置文件的读取</h3><p>YAML格式是在Golang的项目中比较通用的一种格式，比如Kubernetes、Docker、Swagger等项目，都是使用YAML作为其配置文件的。YAML配置文件除了能表达基础类型比如string、int、float 之外，也能表达复杂的数组、结构等数据类型。</p><!-- [[[read_end]]] --><p>目前最新的YAML版本为1.2版本，配置的说明文档在<a href=\"https://yaml.org/\">官网</a>上。它提供多种语言的解析库，其中<a href=\"https://github.com/go-yaml/yaml\">go-yaml</a> 就是非常通用的一个Go解析库，这个库的封装性非常好。</p><p>我们通过第一节课讲的快速阅读一个库的命令 <code>go doc github.com/go-yaml/yaml |grep '^func'</code>，可以看出来这个库对外提供的方法非常明确，一共三个方法：</p><ul>\n<li>Marshal 表示序列化一个结构成为YAML格式；</li>\n<li>Unmarshal表示反序列化一个YAML格式文本成为一个结构；</li>\n<li>还有一个UnmarshalStrict 函数，表示严格反序列化，比如如果YAML格式文件中包含重复key的字段，那么使用UnmarshalStrict 函数反序列化会出现错误。</li>\n</ul><pre><code class=\"language-plain\">// 序列化\nfunc Marshal(in interface{}) (out []byte, err error)\n// 反序列化\nfunc Unmarshal(in []byte, out interface{}) (err error)\n// 严格反序列化\nfunc UnmarshalStrict(in []byte, out interface{}) (err error)\n</code></pre><p>我们选择Unmarshal的函数进行反序列化，因为这样能提高框架对配置文件的容错性和易用性。好，读取配置文件的格式和对应工具搞定，下一步就是想清楚怎么替换了。</p><h3>配置文件的替换</h3><p>在上一节课说的环境变量服务中，存放了包括.env中设置的环境变量，那么我们自然会希望使用上这些环境变量，把配置文件中有的字段使用环境变量替换掉。那么这里在配置文件中就需要有一个“占位符”。这个占位符表示当前这个字段去环境变量中进行阅读。</p><p>这个占位符的设计只有一个要求：够特别。只要这个占位符能和其他配置文件字符区分开就行，所以这里设计占位符为比较有语义的“env(XXXX)”。比如app/config/development/database.yaml 文件中的数据库密码，使用占位符表示如下：</p><pre><code class=\"language-yaml\">mysql:\n  hostname: 127.0.0.1\n  username: yejianfeng\n  password: env(DB_PASSWORD)\n  timeout: 1\n  readtime: 2.3\n</code></pre><p>要实现这个功能，其实也很简单，可以在读取YAML配置文件内容之后，进行完整的文本匹配，将所有环境变量env(xxx) 的字符替换为环境变量。我们应该能设计出替换文本的函数。</p><p>在框架目录的provider/config/service.go中，可以先实现这个方法。</p><pre><code class=\"language-go\">// replace 表示使用环境变量maps替换context中的env(xxx)的环境变量\nfunc replace(content []byte, maps map[string]string) []byte {\n   if maps == nil {\n      return content\n   }\n   // 直接使用ReplaceAll替换。这个性能可能不是最优，但是配置文件加载，频率是比较低的，可以接受\n   for key, val := range maps {\n      reKey := \"env(\" + key + \")\"\n      content = bytes.ReplaceAll(content, []byte(reKey), []byte(val))\n   }\n   return content\n}\n</code></pre><h3>配置项的解析</h3><p>读取并解析完配置文件内容，接下来就要根据path来解析某个配置项了。上一节课说，我们使用点号分割的路径读取方式，比如database.mysql.password 表示在配置文件夹中的database.yaml文件，其中的mysql配置，对应的是数据结构中的password字段。</p><p>那这种根据path来读取字段应该怎么实现呢？</p><p>在获取配置项的时候，我们已经通过go-yaml库将配置文件解析到一个map数据结构中了，而这个map数据结构的子项，明显也有可能是一个map数据结构。所以按照path路径查找，这明显应该是一个<strong>函数递归逻辑</strong>。</p><p>还是用刚才的database.mysql.password举例，可以拆分为3个结构。database 去根map中寻找；如果有这个key，就拿着mysql.password的path，去 database这个key对应的value中进行寻找；而递归寻找到了最后一级path为password，发现这个path没有下一级了，就停止递归。</p><p>详细的代码方法如下，同样存放在框架目录的provider/config/service.go中。</p><pre><code class=\"language-go\">// 查找某个路径的配置项\nfunc searchMap(source map[string]interface{}, path []string) interface{} {\n   if len(path) == 0 {\n      return source\n   }\n\n   // 判断是否有下个路径\n   next, ok := source[path[0]]\n   if ok {\n      // 判断这个路径是否为1\n      if len(path) == 1 {\n         return next\n      }\n\n      // 判断下一个路径的类型\n      switch next.(type) {\n      case map[interface{}]interface{}:\n         // 如果是interface的map，使用cast进行下value转换\n         return searchMap(cast.ToStringMap(next), path[1:])\n      case map[string]interface{}:\n         // 如果是map[string]，直接循环调用\n         return searchMap(next.(map[string]interface{}), path[1:])\n      default:\n         // 否则的话，返回nil\n         return nil\n      }\n   }\n   return nil\n}\n\n// 通过path获取某个元素\nfunc (conf *HadeConfig) find(key string) interface{} {\n   ...\n   return searchMap(conf.confMaps, strings.Split(key, conf.keyDelim))\n}\n\n</code></pre><p>想通了以上三个核心实现难点，我们就可以着手整体代码实现了。</p><h2>配置服务的代码实现</h2><p>首先，在框架文件夹的provider/config/service.go 中，创建一个配置文件服务HadeConfig。它有几个属性：folder代表配置本地配置文件所在的文件夹；keyDelim代表路径中的分割符号，也就是点；envMaps存放所有的环境变量；而confMaps存放每个配置解析后的结构，confRaws存放每个配置的原始文件信息。</p><pre><code class=\"language-go\">// HadeConfig  表示hade框架的配置文件服务\ntype HadeConfig struct {\n   c        framework.Container    // 容器\n   folder   string                 // 文件夹\n   keyDelim string                 // 路径的分隔符，默认为点\n   ...\n   envMaps  map[string]string      // 所有的环境变量\n   confMaps map[string]interface{} // 配置文件结构，key为文件名\n   confRaws map[string][]byte      // 配置文件的原始信息\n}\n</code></pre><p>我们初始化这个HadeConfig的函数，它从服务提供者provider/config/provider.go中获取到三个参数，除了容器之外，另外两个是文件夹地址和所有的环境变量。</p><p>我们这里对provider.go 只列一下参数函数，其他的四个服务提供者函数(Register、Boot、IsDefer、Name) 可以参考<a href=\"https://github.com/gohade/coredemo/blob/geekbang/16/framework/provider/config/provider.go\">GitHub上的代码</a>。</p><pre><code class=\"language-go\">// Paramas 服务提供者实例化的时候参数\nfunc (provider *HadeConfigProvider) Params(c framework.Container) []interface{} {\n   appService := c.MustMake(contract.AppKey).(contract.App)\n   envService := c.MustMake(contract.EnvKey).(contract.Env)\n   env := envService.AppEnv()\n   // 配置文件夹地址\n   configFolder := appService.ConfigFolder()\n   envFolder := filepath.Join(configFolder, env)\n   // 传递容器，配置文件夹地址，所有环境变量\n   return []interface{}{c, envFolder, envService.All()}\n}\n</code></pre><p>那么在provider/config/service.go中，实例化的函数逻辑如下：</p><pre><code class=\"language-go\">// NewHadeConfig 初始化Config方法\nfunc NewHadeConfig(params ...interface{}) (interface{}, error) {\n   container := params[0].(framework.Container)\n   envFolder := params[1].(string)\n   envMaps := params[2].(map[string]string)\n   \n   // 检查文件夹是否存在\n   if _, err := os.Stat(envFolder); os.IsNotExist(err) {\n      return nil, errors.New(\"folder \" + envFolder + \" not exist: \" + err.Error())\n   }\n   // 实例化\n   hadeConf := &amp;HadeConfig{\n      c:        container,\n      folder:   envFolder,\n      envMaps:  envMaps,\n      confMaps: map[string]interface{}{},\n      confRaws: map[string][]byte{},\n      keyDelim: \".\",\n      lock:     sync.RWMutex{},\n   }\n   // 读取每个文件\n   files, err := ioutil.ReadDir(envFolder)\n   if err != nil {\n      return nil, errors.WithStack(err)\n   }\n   for _, file := range files {\n      fileName := file.Name()\n      err := hadeConf.loadConfigFile(envFolder, fileName)\n      if err != nil {\n         log.Println(err)\n         continue\n      }\n   }\n   ...\n   return hadeConf, nil\n}\n\n// 读取某个配置文件\nfunc (conf *HadeConfig) loadConfigFile(folder string, file string) error {\n   conf.lock.Lock()\n   defer conf.lock.Unlock()\n   //  判断文件是否以yaml或者yml作为后缀\n   s := strings.Split(file, \".\")\n   if len(s) == 2 &amp;&amp; (s[1] == \"yaml\" || s[1] == \"yml\") {\n      name := s[0]\n      // 读取文件内容\n      bf, err := ioutil.ReadFile(filepath.Join(folder, file))\n      if err != nil {\n         return err\n      }\n      // 直接针对文本做环境变量的替换\n      bf = replace(bf, conf.envMaps)\n      // 解析对应的文件\n      c := map[string]interface{}{}\n      if err := yaml.Unmarshal(bf, &amp;c); err != nil {\n         return err\n      }\n      conf.confMaps[name] = c\n      conf.confRaws[name] = bf\n   }\n   return nil\n}\n</code></pre><p>逻辑非常清晰。先检查配置文件夹是否存在，然后读取文件夹中的每个以yaml或者yml后缀的文件；读取之后，先用replace对环境变量进行一次替换；替换之后使用 go-yaml，对文件进行解析。</p><p>初始化实例就是一个完整的 解析文件的过程，解析结束之后，confMaps里存放的就是解析之后的结果。</p><p>配置文件的获取接口上节课已经写好了，定义了接口的系列方法，这里我们就详细实现Get/GetBool/GetInt，其他方法大同小异，就不贴出来了，你可以直接参考<a href=\"https://github.com/gohade/coredemo/blob/geekbang/16/framework/provider/config/service.go\">GitHub上的代码</a>。</p><p>前面已经想好了，用方法find，通过path，从一个嵌套map confMaps中获取数据。所以Get方法就是调用一下find方法而已，同样也在service.go中：</p><pre><code class=\"language-go\">// Get 获取某个配置项\nfunc (conf *HadeConfig) Get(key string) interface{} {\n   return conf.find(key)\n}\n</code></pre><p>而对应的Get系列的方法我们使用cast库进行类型转换，比如：</p><pre><code class=\"language-go\">// GetBool 获取bool类型配置\nfunc (conf *HadeConfig) GetBool(key string) bool {\n   return cast.ToBool(conf.find(key))\n}\n// GetInt 获取int类型配置\nfunc (conf *HadeConfig) GetInt(key string) int {\n   return cast.ToInt(conf.find(key))\n}\n</code></pre><p>到这里，配置服务的代码已经基本成型了。但是实际上还有两个细节我们需要认真思考。</p><p>首先，因为之前我们设置过App服务，将一个App服务的目录都安排好了，但是如果之后有需求要改变这些目录的配置呢？如果有的话，是否可以通过配置来进行修改呢？所以第一个问题就是，我们要思考配置文件更新App服务的操作。</p><p>其次，假设现在配置服务能从文件中获取配置了，但是如果文件修改了，我们是否需要重新启动应用呢？是否有能不启动应用的方法呢？</p><p>下面我们来一一解决这两个问题。</p><h2>配置文件更新App服务</h2><p>现在有了配置文件服务，但在没有配置文件服务之前，我们启动服务的appService，也是有可能要修改这个服务的配置的。回忆<a href=\"https://time.geekbang.org/column/article/423982\">第十二</a><a href=\"https://time.geekbang.org/column/article/423982\">课</a>，appService中存放了启动这个业务实例默认设置的文件夹目录和地址。</p><pre><code class=\"language-go\">//BaseFolder 定义项目基础地址\nBaseFolder() string\n// ConfigFolder 定义了配置文件的路径\nConfigFolder() string\n// LogFolder 定义了日志所在路径\nLogFolder() string\n// ProviderFolder 定义业务自己的服务提供者地址\nProviderFolder() string\n// MiddlewareFolder 定义业务自己定义的中间件\nMiddlewareFolder() string\n// CommandFolder 定义业务定义的命令\nCommandFolder() string\n// RuntimeFolder 定义业务的运行中间态信息\nRuntimeFolder() string\n// TestFolder 存放测试所需要的信息\nTestFolder() string\n</code></pre><p>现在有需求将这些文件夹目录，在配置文件中进行配置并修改。所以应该在加载到配置服务时，再更新下appService。加载逻辑如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/f5/ee/f5141333501ce140314fb985b75c6eee.jpg?wh=1920x1080\" alt=\"图片\"></p><p>可以把设定App的这些配置文件，存放在配置文件夹的app.yaml文件的path设置项下，其中每个配置项的key，对应appService中每个对应的服务。比如log_folder对应LogFolder目录：</p><pre><code class=\"language-go\">path:\n  log_folder: \"/home/jianfengye/hade/log/\"\n  runtime_folder: \"/home/jianfengye/hade/runtime/\"\n</code></pre><p>现在加载配置服务的时候，当读取到配置服务app.path下有内容，就需要更新appService的配置。首先需要修改appService，修改框架目录下的provider/app/service.go文件。</p><p>将HadeApp增加一个configMap字段：</p><pre><code class=\"language-go\">// HadeApp 代表hade框架的App实现\ntype HadeApp struct {\n   ...\n   configMap map[string]string // 配置加载\n}\n</code></pre><p>同时为HadeApp增加LoadAppConfig方法，用于读取配置文件中的信息：</p><pre><code class=\"language-go\">// LoadAppConfig 加载配置map\nfunc (app *HadeApp) LoadAppConfig(kv map[string]string) {\n   for key, val := range kv {\n      app.configMap[key] = val\n   }\n}\n</code></pre><p>再修改对应的LogFolder等一系列XXXFolder的方法，先读取configMap中的值，如果有的话，先用configMap中的值：</p><pre><code class=\"language-go\">// LogFolder 表示日志存放地址\nfunc (app HadeApp) LogFolder() string {\n   if val, ok := app.configMap[\"log_folder\"]; ok {\n      return val\n   }\n   return filepath.Join(app.StorageFolder(), \"log\")\n}\n\n</code></pre><p>这样，对appService的修改就完成了。</p><p>在configService，读取配置文件loadConfigFile的时候，要注意，如果当前的配置文件是app.yaml， 我们需要调用appService的LoadAppConfig方法：</p><pre><code class=\"language-go\">// 读取某个配置文件\nfunc (conf *HadeConfig) loadConfigFile(folder string, file string) error {\n   ...\n\n   //  判断文件是否以yaml或者yml作为后缀\n   s := strings.Split(file, \".\")\n   if len(s) == 2 &amp;&amp; (s[1] == \"yaml\" || s[1] == \"yml\") {\n      name := s[0]\n\n      ...\n\n      // 读取app.path中的信息，更新app对应的folder\n      if name == \"app\" &amp;&amp; conf.c.IsBind(contract.AppKey) {\n         if p, ok := c[\"path\"]; ok {\n            appService := conf.c.MustMake(contract.AppKey).(contract.App)\n            appService.LoadAppConfig(cast.ToStringMapString(p))\n         }\n      }\n   }\n   return nil\n}\n</code></pre><p>这样在加载app.yaml的配置文件的时候，就同时更新了appService 里面的配置。</p><h2>配置文件热更新</h2><p>正常来说，在程序启动的时候会读取一次配置文件，但是在程序运行过程中，我们难免会遇到需要修改配置文件的操作。也就是之前思考的第二个问题。</p><p>这个时候，是否需要重新启动一次程序再加载一次配置文件呢？这当然是没有问题的，但是更为强大的是，<strong>我们可以自动监控配置文件目录下的所有文件，当配置文件有修改和更新的时候，能自动更新程序中的配置文件信息，也就是实现配置文件热更新</strong>。</p><p>这个热更新看起来很麻烦，其实在Golang中是非常简单的事情。我们使用 <a href=\"https://github.com/fsnotify/fsnotify\">fsnotify</a> 库能很方便对一个文件夹进行监控，当文件夹中有文件增/删/改的时候，会通过channel进行事件回调。</p><p>这个库的使用方式很简单。大致思路就是先使用NewWatcher创建一个监控器watcher，然后使用Add来监控某个文件夹，通过watcher设置的events来判断文件是否有变化，如果有变化，就进行对应的操作，比如更新内存中配置服务存储的map结构。</p><pre><code class=\"language-go\">// NewHadeConfig 初始化Config方法\nfunc NewHadeConfig(params ...interface{}) (interface{}, error) {\n   ...\n\n   // 监控文件夹文件\n   watch, err := fsnotify.NewWatcher()\n   if err != nil {\n      return nil, err\n   }\n   err = watch.Add(envFolder)\n   if err != nil {\n      return nil, err\n   }\n   go func() {\n      defer func() {\n         if err := recover(); err != nil {\n            fmt.Println(err)\n         }\n      }()\n\n      for {\n         select {\n         case ev := &lt;-watch.Events:\n            {\n               //判断事件发生的类型，如下5种\n               // Create 创建\n               // Write 写入\n               // Remove 删除\n               path, _ := filepath.Abs(ev.Name)\n               index := strings.LastIndex(path, string(os.PathSeparator))\n               folder := path[:index]\n               fileName := path[index+1:]\n\n               if ev.Op&amp;fsnotify.Create == fsnotify.Create {\n                  log.Println(\"创建文件 : \", ev.Name)\n                  hadeConf.loadConfigFile(folder, fileName)\n               }\n               if ev.Op&amp;fsnotify.Write == fsnotify.Write {\n                  log.Println(\"写入文件 : \", ev.Name)\n                  hadeConf.loadConfigFile(folder, fileName)\n               }\n               if ev.Op&amp;fsnotify.Remove == fsnotify.Remove {\n                  log.Println(\"删除文件 : \", ev.Name)\n                  hadeConf.removeConfigFile(folder, fileName)\n               }\n            }\n         case err := &lt;-watch.Errors:\n            {\n               log.Println(\"error : \", err)\n               return\n            }\n         }\n      }\n   }()\n\n   return hadeConf, nil\n}\n</code></pre><p>代码如上，我们使用NewWatcher创建一个监听器，监听配置文件目录，接着启动一个新的Goroutine作为监听协程。在监听协程中，监听配置文件的创建、更新、删除操作。创建和更新对应 LoadConfigFile 操作。</p><p>而删除，对应的是 removeConfigFile操作，这个操作的内容就是删除配置服务中的confMaps中对应的key。</p><pre><code class=\"language-go\">// 删除文件的操作\nfunc (conf *HadeConfig) removeConfigFile(folder string, file string) error {\n   conf.lock.Lock()\n   defer conf.lock.Unlock()\n   s := strings.Split(file, \".\")\n   // 只有yaml或者yml后缀才执行\n   if len(s) == 2 &amp;&amp; (s[1] == \"yaml\" || s[1] == \"yml\") {\n      name := s[0]\n      // 删除内存中对应的key\n      delete(conf.confRaws, name)\n      delete(conf.confMaps, name)\n   }\n   return nil\n}\n</code></pre><p>这里注意下，由于在运行时增加了对confMaps的写操作，所以需要对confMaps进行锁设置，以防止在写confMaps的时候，读操作进入读取了错误信息。</p><p>分析目前的这个场景，读明显多于写。所以我们的锁应该是一个读写锁，读写锁可以让多个读并发读，但是只要有一个写操作，读和写都需要等待。这个很符合当前这个场景。</p><p>所以在框架目录的provider/config/service.go中的HadeConfig，我们增加了一个读写锁lock。</p><pre><code class=\"language-go\">// HadeConfig  表示hade框架的配置文件服务\ntype HadeConfig struct {\n   ...\n   lock     sync.RWMutex           // 配置文件读写锁\n   ...\n}\n</code></pre><p>而在loadConfigFile和removeConfigFile这两个对配置有修改的情况，使用写锁锁住HadeConfig。</p><pre><code class=\"language-go\">// 读取某个配置文件\nfunc (conf *HadeConfig) loadConfigFile(folder string, file string) error {\n   conf.lock.Lock()\n   defer conf.lock.Unlock()\n\n   ...\n}\n</code></pre><p>在Get系列方法调用的find函数中，使用读锁来进行读操作。</p><pre><code class=\"language-go\">// 通过path来获取某个配置项\nfunc (conf *HadeConfig) find(key string) interface{} {\n   conf.lock.RLock()\n   defer conf.lock.RUnlock()\n   ...\n}\n</code></pre><p>这样，配置服务就开发完成了。</p><h2>验证</h2><p>我们先测试环境变量注入配置文件的功能。将业务目录下的config/development/database.yaml 中的mysql.password，使用环境变量进行替换。</p><pre><code class=\"language-yaml\">mysql:\n  hostname: 127.0.0.1\n  username: yejianfeng\n  password: env(DB_PASSWORD)\n  timeout: 1\n  readtime: 2.3\n</code></pre><p>然后修改业务目录下的module/demo/api.go，替换其中/demo/demo对应的路由方法。</p><pre><code class=\"language-go\">func (api *DemoApi) Demo(c *gin.Context) {\n   // 获取password\n   configService := c.MustMake(contract.ConfigKey).(contract.Config)\n   password := configService.GetString(\"database.mysql.password\")\n   // 打印出来\n   c.JSON(200, password)\n}\n</code></pre><p>最后使用命令行  <code>./hade app start</code> 启动服务。打开浏览器，看到输出：</p><p><img src=\"https://static001.geekbang.org/resource/image/27/f1/275ddfb18f04549dd62e6b45fc3cccf1.png?wh=478x86\" alt=\"图片\"></p><p>说明此时还没注入环境变量。下面使用命令行：</p><pre><code class=\"language-plain\">DB_PASSWORD=123 ./hade app start\n</code></pre><p>启动服务。这个命令注入了DB_PASSWORD这个环境变量。<br>\n重启打开浏览器看到输出。</p><p><img src=\"https://static001.geekbang.org/resource/image/33/b6/33f14f5277ea8294458141d5393269b6.png?wh=405x90\" alt=\"图片\"></p><p>环境变量注入成功！</p><p>这个时候我们不停止进程，直接修改配置文件database.yaml中的mysql.password：</p><pre><code class=\"language-yaml\">mysql:\n  hostname: 127.0.0.1\n  username: yejianfeng\n  password: 456789\n  timeout: 1\n  readtime: 2.3\n</code></pre><p>打开浏览器，输出已经变化了。</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/b7/6c86bf1f4f055d94fb17c756415a94b7.png?wh=377x82\" alt=\"图片\"></p><p>说明热更新已经生效了，测试成功。</p><p>今天所有代码的目录结构截图，也贴在这里供你对比检查，代码放在GitHub上的 <a href=\"https://github.com/gohade/coredemo/tree/geekbang/16\">16分支</a> 里。</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/38/6c9b9046f41e4b5c0719fe205540c438.png?wh=351x1140\" alt=\"图片\"></p><h2>小结</h2><p>配置服务在框架中是一个非常基础且重要的服务。</p><p>我们考虑了整个配置服务的实现，先读取配置文件，再替换环境变量，最后再根据路径获取配置项，这样三步走完成了基本的配置服务。在配置服务的基础上，我们又补充了配置服务加载时对App服务的更新，并且为配置服务增加了热更新的机制。</p><p>我个人认为，配置服务是一个App中最常用到的服务了，有非常方便的配置服务接口，能为业务代码节省不少的代码量。<strong>提供多种设置配置的方式，是真实从业务需求出发的</strong>。</p><p>比如在实际工作中，有的需求要求数据库密码不能进入git库，必须通过环境变量获取，我们就可以通过环境变量获取配置；而有的需求要求在一个服务器上调试测试和预发布环境，我们可以通过.env切换不同环境。所以，有个多层次的环境配置机制，对于一个框架来说是非常必要的。</p><h2>思考题</h2><p>现在有配置文件服务了，但是根据路径、获取某个配置却只能在代码中获取。这里我们希望有一个命令行工具  <code>./hade config get \"database.mysql\"</code> 能获取到这个path路径对应的配置。你可以尝试实现么？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得有收获，也欢迎把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见～</p>","neighbors":{"left":{"article_title":"15｜配置和环境（上）：配置服务中的设计思路","id":428012},"right":{"article_title":"17｜日志：如何设计多输出的日志服务？","id":429685}},"comments":[{"had_liked":false,"id":325739,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1639111219,"is_pvip":false,"replies":[{"id":"118651","content":"哈哈，干巴叠","user_name":"作者回复","comment_id":325739,"uid":"1069186","ip_address":"","utype":1,"ctime":1639585959,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5934078515","product_id":100090601,"comment_content":"那必须是可以实现的 我现在就实现","like_count":1,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539080,"discussion_content":"哈哈，干巴叠","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639585959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317841,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1634988668,"is_pvip":true,"replies":[{"id":"115344","content":"并没有强耦合吧，配置服务获取app都是从容器中获取的","user_name":"作者回复","comment_id":317841,"uid":"1069186","ip_address":"","utype":1,"ctime":1635203940,"user_name_real":"叶剑峰"}],"discussion_count":1,"race_medal":0,"score":"5929955964","product_id":100090601,"comment_content":"配置服务和app服务强耦合了，或许它们本来就是一体的？","like_count":1,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529002,"discussion_content":"并没有强耦合吧，配置服务获取app都是从容器中获取的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635203940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355651,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1254562,"ip_address":"浙江","ucode":"040741A40A47B9","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/a2/d61e4e28.jpg","comment_is_top":false,"comment_ctime":1661593064,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661593064","product_id":100090601,"comment_content":"感觉这个 config 文件夹里面过于复杂了， 两层配置简单些。区分出 development &#47; production &#47; testing 没太大必要，每个环境不同，由 .env 文件决定就可以了","like_count":1},{"had_liked":false,"id":330641,"user_name":"牛玉富","can_delete":false,"product_type":"c1","uid":1231623,"ip_address":"","ucode":"DD962676F8FAF6","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/07/482b7155.jpg","comment_is_top":false,"comment_ctime":1642081186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642081186","product_id":100090601,"comment_content":"嗯嗯，热加载要的要的。<br>现在正式有良好的容器、目录等设计才能有后来更复杂的ddd设计。","like_count":0},{"had_liked":false,"id":317630,"user_name":"Panmax","can_delete":false,"product_type":"c1","uid":1004871,"ip_address":"","ucode":"9D65E3B84C5519","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/47/d217c45f.jpg","comment_is_top":false,"comment_ctime":1634872297,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1634872297","product_id":100090601,"comment_content":"password 是通过环境变量传入的，优先级高于配置文件，我认为不应该被配置文件覆盖掉。","like_count":0,"discussions":[{"author":{"id":1363166,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cc/de/59a530dc.jpg","nickname":"布丁老厮","note":"","ucode":"72B86A2BE251E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579445,"discussion_content":"老师这个地方应该只是为了测试配置文件热更新才这样做的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657459952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}