{"id":92245,"title":"25 | CompletionService：如何批量执行异步任务？","content":"<p>在<a href=\"https://time.geekbang.org/column/article/91292\">《23 | Future：如何用多线程实现最优的“烧水泡茶”程序？》</a>的最后，我给你留了道思考题，如何优化一个询价应用的核心代码？如果采用“ThreadPoolExecutor+Future”的方案，你的优化结果很可能是下面示例代码这样：用三个线程异步执行询价，通过三次调用Future的get()方法获取询价结果，之后将询价结果保存在数据库中。</p><pre><code>// 创建线程池\nExecutorService executor =\n  Executors.newFixedThreadPool(3);\n// 异步向电商S1询价\nFuture&lt;Integer&gt; f1 = \n  executor.submit(\n    ()-&gt;getPriceByS1());\n// 异步向电商S2询价\nFuture&lt;Integer&gt; f2 = \n  executor.submit(\n    ()-&gt;getPriceByS2());\n// 异步向电商S3询价\nFuture&lt;Integer&gt; f3 = \n  executor.submit(\n    ()-&gt;getPriceByS3());\n    \n// 获取电商S1报价并保存\nr=f1.get();\nexecutor.execute(()-&gt;save(r));\n  \n// 获取电商S2报价并保存\nr=f2.get();\nexecutor.execute(()-&gt;save(r));\n  \n// 获取电商S3报价并保存  \nr=f3.get();\nexecutor.execute(()-&gt;save(r));\n\n</code></pre><p>上面的这个方案本身没有太大问题，但是有个地方的处理需要你注意，那就是如果获取电商S1报价的耗时很长，那么即便获取电商S2报价的耗时很短，也无法让保存S2报价的操作先执行，因为这个主线程都阻塞在了 <code>f1.get()</code> 操作上。这点小瑕疵你该如何解决呢？</p><p>估计你已经想到了，增加一个阻塞队列，获取到S1、S2、S3的报价都进入阻塞队列，然后在主线程中消费阻塞队列，这样就能保证先获取到的报价先保存到数据库了。下面的示例代码展示了如何利用阻塞队列实现先获取到的报价先保存到数据库。</p><pre><code>// 创建阻塞队列\nBlockingQueue&lt;Integer&gt; bq =\n  new LinkedBlockingQueue&lt;&gt;();\n//电商S1报价异步进入阻塞队列  \nexecutor.execute(()-&gt;\n  bq.put(f1.get()));\n//电商S2报价异步进入阻塞队列  \nexecutor.execute(()-&gt;\n  bq.put(f2.get()));\n//电商S3报价异步进入阻塞队列  \nexecutor.execute(()-&gt;\n  bq.put(f3.get()));\n//异步保存所有报价  \nfor (int i=0; i&lt;3; i++) {\n  Integer r = bq.take();\n  executor.execute(()-&gt;save(r));\n}  \n</code></pre><h2>利用CompletionService实现询价系统</h2><p>不过在实际项目中，并不建议你这样做，因为Java SDK并发包里已经提供了设计精良的CompletionService。利用CompletionService不但能帮你解决先获取到的报价先保存到数据库的问题，而且还能让代码更简练。</p><!-- [[[read_end]]] --><p>CompletionService的实现原理也是内部维护了一个阻塞队列，当任务执行结束就把任务的执行结果加入到阻塞队列中，不同的是CompletionService是把任务执行结果的Future对象加入到阻塞队列中，而上面的示例代码是把任务最终的执行结果放入了阻塞队列中。</p><p><strong>那到底该如何创建CompletionService呢？</strong></p><p>CompletionService接口的实现类是ExecutorCompletionService，这个实现类的构造方法有两个，分别是：</p><ol>\n<li><code>ExecutorCompletionService(Executor executor)</code>；</li>\n<li><code>ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</code>。</li>\n</ol><p>这两个构造方法都需要传入一个线程池，如果不指定completionQueue，那么默认会使用无界的LinkedBlockingQueue。任务执行结果的Future对象就是加入到completionQueue中。</p><p>下面的示例代码完整地展示了如何利用CompletionService来实现高性能的询价系统。其中，我们没有指定completionQueue，因此默认使用无界的LinkedBlockingQueue。之后通过CompletionService接口提供的submit()方法提交了三个询价操作，这三个询价操作将会被CompletionService异步执行。最后，我们通过CompletionService接口提供的take()方法获取一个Future对象（前面我们提到过，加入到阻塞队列中的是任务执行结果的Future对象），调用Future对象的get()方法就能返回询价操作的执行结果了。</p><pre><code>// 创建线程池\nExecutorService executor = \n  Executors.newFixedThreadPool(3);\n// 创建CompletionService\nCompletionService&lt;Integer&gt; cs = new \n  ExecutorCompletionService&lt;&gt;(executor);\n// 异步向电商S1询价\ncs.submit(()-&gt;getPriceByS1());\n// 异步向电商S2询价\ncs.submit(()-&gt;getPriceByS2());\n// 异步向电商S3询价\ncs.submit(()-&gt;getPriceByS3());\n// 将询价结果异步保存到数据库\nfor (int i=0; i&lt;3; i++) {\n  Integer r = cs.take().get();\n  executor.execute(()-&gt;save(r));\n}\n</code></pre><h2>CompletionService接口说明</h2><p>下面我们详细地介绍一下CompletionService接口提供的方法，CompletionService接口提供的方法有5个，这5个方法的方法签名如下所示。</p><p>其中，submit()相关的方法有两个。一个方法参数是<code>Callable&lt;V&gt; task</code>，前面利用CompletionService实现询价系统的示例代码中，我们提交任务就是用的它。另外一个方法有两个参数，分别是<code>Runnable task</code>和<code>V result</code>，这个方法类似于ThreadPoolExecutor的 <code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code> ，这个方法在<a href=\"https://time.geekbang.org/column/article/91292\">《23 | Future：如何用多线程实现最优的“烧水泡茶”程序？》</a>中我们已详细介绍过，这里不再赘述。</p><p>CompletionService接口其余的3个方法，都是和阻塞队列相关的，take()、poll()都是从阻塞队列中获取并移除一个元素；它们的区别在于如果阻塞队列是空的，那么调用 take() 方法的线程会被阻塞，而 poll() 方法会返回 null 值。 <code>poll(long timeout, TimeUnit unit)</code> 方法支持以超时的方式获取并移除阻塞队列头部的一个元素，如果等待了 timeout unit时间，阻塞队列还是空的，那么该方法会返回 null 值。</p><pre><code>Future&lt;V&gt; submit(Callable&lt;V&gt; task);\nFuture&lt;V&gt; submit(Runnable task, V result);\nFuture&lt;V&gt; take() \n  throws InterruptedException;\nFuture&lt;V&gt; poll();\nFuture&lt;V&gt; poll(long timeout, TimeUnit unit) \n  throws InterruptedException;\n</code></pre><h2>利用CompletionService实现Dubbo中的Forking Cluster</h2><p>Dubbo中有一种叫做<strong>Forking的集群模式</strong>，这种集群模式下，支持<strong>并行地调用多个查询服务，只要有一个成功返回结果，整个服务就可以返回了</strong>。例如你需要提供一个地址转坐标的服务，为了保证该服务的高可用和性能，你可以并行地调用3个地图服务商的API，然后只要有1个正确返回了结果r，那么地址转坐标这个服务就可以直接返回r了。这种集群模式可以容忍2个地图服务商服务异常，但缺点是消耗的资源偏多。</p><pre><code>geocoder(addr) {\n  //并行执行以下3个查询服务， \n  r1=geocoderByS1(addr);\n  r2=geocoderByS2(addr);\n  r3=geocoderByS3(addr);\n  //只要r1,r2,r3有一个返回\n  //则返回\n  return r1|r2|r3;\n}\n</code></pre><p>利用CompletionService可以快速实现 Forking 这种集群模式，比如下面的示例代码就展示了具体是如何实现的。首先我们创建了一个线程池executor 、一个CompletionService对象cs和一个<code>Future&lt;Integer&gt;</code>类型的列表 futures，每次通过调用CompletionService的submit()方法提交一个异步任务，会返回一个Future对象，我们把这些Future对象保存在列表futures中。通过调用 <code>cs.take().get()</code>，我们能够拿到最快返回的任务执行结果，只要我们拿到一个正确返回的结果，就可以取消所有任务并且返回最终结果了。</p><pre><code>// 创建线程池\nExecutorService executor =\n  Executors.newFixedThreadPool(3);\n// 创建CompletionService\nCompletionService&lt;Integer&gt; cs =\n  new ExecutorCompletionService&lt;&gt;(executor);\n// 用于保存Future对象\nList&lt;Future&lt;Integer&gt;&gt; futures =\n  new ArrayList&lt;&gt;(3);\n//提交异步任务，并保存future到futures \nfutures.add(\n  cs.submit(()-&gt;geocoderByS1()));\nfutures.add(\n  cs.submit(()-&gt;geocoderByS2()));\nfutures.add(\n  cs.submit(()-&gt;geocoderByS3()));\n// 获取最快返回的任务执行结果\nInteger r = 0;\ntry {\n  // 只要有一个成功返回，则break\n  for (int i = 0; i &lt; 3; ++i) {\n    r = cs.take().get();\n    //简单地通过判空来检查是否成功返回\n    if (r != null) {\n      break;\n    }\n  }\n} finally {\n  //取消所有任务\n  for(Future&lt;Integer&gt; f : futures)\n    f.cancel(true);\n}\n// 返回结果\nreturn r;\n</code></pre><h2>总结</h2><p>当需要批量提交异步任务的时候建议你使用CompletionService。CompletionService将线程池Executor和阻塞队列BlockingQueue的功能融合在了一起，能够让批量异步任务的管理更简单。除此之外，CompletionService能够让异步任务的执行结果有序化，先执行完的先进入阻塞队列，利用这个特性，你可以轻松实现后续处理的有序性，避免无谓的等待，同时还可以快速实现诸如Forking Cluster这样的需求。</p><p>CompletionService的实现类ExecutorCompletionService，需要你自己创建线程池，虽看上去有些啰嗦，但好处是你可以让多个ExecutorCompletionService的线程池隔离，这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险。</p><h2>课后思考</h2><p>本章使用CompletionService实现了一个询价应用的核心功能，后来又有了新的需求，需要计算出最低报价并返回，下面的示例代码尝试实现这个需求，你看看是否存在问题呢？</p><pre><code>// 创建线程池\nExecutorService executor = \n  Executors.newFixedThreadPool(3);\n// 创建CompletionService\nCompletionService&lt;Integer&gt; cs = new \n  ExecutorCompletionService&lt;&gt;(executor);\n// 异步向电商S1询价\ncs.submit(()-&gt;getPriceByS1());\n// 异步向电商S2询价\ncs.submit(()-&gt;getPriceByS2());\n// 异步向电商S3询价\ncs.submit(()-&gt;getPriceByS3());\n// 将询价结果异步保存到数据库\n// 并计算最低报价\nAtomicReference&lt;Integer&gt; m =\n  new AtomicReference&lt;&gt;(Integer.MAX_VALUE);\nfor (int i=0; i&lt;3; i++) {\n  executor.execute(()-&gt;{\n    Integer r = null;\n    try {\n      r = cs.take().get();\n    } catch (Exception e) {}\n    save(r);\n    m.set(Integer.min(m.get(), r));\n  });\n}\nreturn m;\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":89333,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1556155671,"is_pvip":false,"replies":[{"id":"32185","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556281494,"ip_address":"","comment_id":89333,"utype":1}],"discussion_count":10,"race_medal":0,"score":"534132100375","product_id":100023901,"comment_content":"我觉得问题出在return m这里需要等待三个线程执行完成，但是并没有。<br>...<br>AtomicReference&lt;Integer&gt; m = new AtomicReference&lt;&gt;(Integer.MAX_VALUE);<br>CountDownLatch latch = new CountDownLatch(3);<br>for(int i=0; i&lt;3; i++) {<br>\texecutor.execute(()-&gt;{<br>\t\tInteger r = null;<br>\t\ttry {<br>\t\t\tr = cs.take().get();<br>\t\t} catch(Exception e) {}<br>\t\tsave(r);<br>\t\tm.set(Integer.min(m.get(), r));<br>\t\tlatch.countDown();<br>\t});<br>\tlatch.await();<br>\treturn m;<br>}","like_count":125,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448093,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556281494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119440,"discussion_content":"还有一个问题，m.set(Integer.min(m.get(), r))  并不是原子操作！","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1578230692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561694,"discussion_content":"但是这个有啥问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649693597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":119440,"ip_address":""},"score":561694,"extra":""},{"author":{"id":1204947,"avatar":"https://static001.geekbang.org/account/avatar/00/12/62/d3/663de972.jpg","nickname":"懵逼猴","note":"","ucode":"BDC748A96AC316","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575365,"discussion_content":"多线程并发不安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654773867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":561694,"ip_address":""},"score":575365,"extra":""}]},{"author":{"id":1151788,"avatar":"https://static001.geekbang.org/account/avatar/00/11/93/2c/67a5d65c.jpg","nickname":"caleb","note":"","ucode":"63C7399E882EBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34117,"discussion_content":"最后一个｝符号是不是应该提到latch.await（）前面","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1571159081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1151788,"avatar":"https://static001.geekbang.org/account/avatar/00/11/93/2c/67a5d65c.jpg","nickname":"caleb","note":"","ucode":"63C7399E882EBA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106391,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577535045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":34117,"ip_address":""},"score":106391,"extra":""}]},{"author":{"id":1128953,"avatar":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","nickname":"无言的约定","note":"","ucode":"5E8046EB6B7956","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99993,"discussion_content":"return m应在循环以外","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577232856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547667,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/93/4159edaa.jpg","nickname":"朴素柠檬c","note":"","ucode":"2D4CBB70D801B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324806,"discussion_content":"主线程可不管你 线程池的情况 可能之间返回个0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605173188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041534,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoEb4oys1R20cc9FfpZsVEt04Dias86A30LUNWM8lPyBahKaMRISNB854hhXRjoohCIIwX1sO86zfA/132","nickname":"0909","note":"","ucode":"56BAF3C6FBF200","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109172,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577671615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45610,"discussion_content":"老哥，稳","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573051677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89429,"user_name":"小华","can_delete":false,"product_type":"c1","uid":1402795,"ip_address":"","ucode":"902E7ED95D73BA","user_header":"https://static001.geekbang.org/account/avatar/00/15/67/ab/facff632.jpg","comment_is_top":false,"comment_ctime":1556172851,"is_pvip":false,"replies":[{"id":"32009","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556191498,"ip_address":"","comment_id":89429,"utype":1}],"discussion_count":1,"race_medal":0,"score":"121815257139","product_id":100023901,"comment_content":"看老师的意图是要等三个比较报假的线程都执行完才能执行主线程的的return  m，但是代码无法保证三个线程都执行完，和主线程执行return的顺序，因此，m的值不是准确的，可以加个线程栈栏，线程执行完计数器，来达到这效果","like_count":29,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448129,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556191498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89365,"user_name":"西行寺咕哒子","can_delete":false,"product_type":"c1","uid":1441988,"ip_address":"","ucode":"CAE570245BA299","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/c4/634c1e10.jpg","comment_is_top":false,"comment_ctime":1556159056,"is_pvip":false,"replies":[{"id":"32188","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556284375,"ip_address":"","comment_id":89365,"utype":1}],"discussion_count":7,"race_medal":0,"score":"117520276048","product_id":100023901,"comment_content":"试过返回值是2147483647，也就是int的最大值。没有等待操作完成就猴急的返回了。 m.set(Integer.min(m.get(), r)... 这个操作也不是原子操作。<br>试着自己弄了一下：<br>public Integer run(){<br>        &#47;&#47; 创建线程池<br>        ExecutorService executor = Executors.newFixedThreadPool(3);<br>        &#47;&#47; 创建 CompletionService<br>        CompletionService&lt;Integer&gt; cs = new ExecutorCompletionService&lt;&gt;(executor);<br>        AtomicReference&lt;Integer&gt; m = new AtomicReference&lt;&gt;(Integer.MAX_VALUE);<br>        &#47;&#47; 异步向电商 S1 询价<br>        cs.submit(()-&gt;getPriceByS1());<br>        &#47;&#47; 异步向电商 S2 询价<br>        cs.submit(()-&gt;getPriceByS2());<br>        &#47;&#47; 异步向电商 S3 询价<br>        cs.submit(()-&gt;getPriceByS3());<br>        &#47;&#47; 将询价结果异步保存到数据库<br>        &#47;&#47; 并计算最低报价<br>        for (int i=0; i&lt;3; i++) {<br>            Integer r = logIfError(()-&gt;cs.take().get());<br>            executor.execute(()-&gt; save(r));<br>            m.getAndUpdate(v-&gt;Integer.min(v, r));<br>        }<br>        return m.get();<br>    }<br>不知道可不可行","like_count":28,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448106,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556284375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1350140,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Kj8GRjh4iaZaGibKXrmGnR7PxENFlFMibr1jLHxEc9R38D3kICvV7NdaiaMHpomZmkZMicPOqT3eQnNxct0uIabTkZQ/132","nickname":"yinzh","note":"","ucode":"87CD1CE5F68121","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287677,"discussion_content":"已经把比较大小的操作移到异步线程以外了，m是不是可以不用AtomicReference了呢","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1593508643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d4/78/66b3f2a2.jpg","nickname":"斯盖丸","note":"","ucode":"B881D14B028F14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348377,"discussion_content":"为什么这样就不会猴急地返回呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612530079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119408,"discussion_content":" m.get(); 不会阻塞吧，还是会直接返回的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578229714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1004484,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/c4/df86decb.jpg","nickname":"江城子","note":"","ucode":"28A2D7DEAE3337","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188964,"discussion_content":"cs.take()会阻塞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582829891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":119408,"ip_address":""},"score":188964,"extra":""},{"author":{"id":1101760,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/c0/8e4c1135.jpg","nickname":"ddup","note":"","ucode":"D8EC573DA46A10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004484,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/c4/df86decb.jpg","nickname":"江城子","note":"","ucode":"28A2D7DEAE3337","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299317,"discussion_content":" save(r)又变成串行的了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597656975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":188964,"ip_address":""},"score":299317,"extra":""},{"author":{"id":2029333,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erLujLByemCGmjp9rIicdoC59XUh99WiargBmxOMtsLlmntyEklh3LyiahtzAz3fnUu0tWwvibTqOFt5A/132","nickname":"hammer","note":"","ucode":"D98A31ACE2158F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101760,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/c0/8e4c1135.jpg","nickname":"ddup","note":"","ucode":"D8EC573DA46A10","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301696,"discussion_content":"并没有串行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598609479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299317,"ip_address":""},"score":301696,"extra":""}]}]},{"had_liked":false,"id":89349,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1556157495,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"96045438007","product_id":100023901,"comment_content":"m.get()和m.set()不是原子性操作，正确代码是:do{int expect = m.get();int min= Integer.min(expect,r);}while(!m.compareAndSet(expect,min))。老师，是这样吗？","like_count":22,"discussions":[{"author":{"id":1519545,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eohTCTF7EIAR5ic7eiaIbU9zF81JpxibTvFokTZu1hLhwwaDl0k2eaOrsibLrqibrfaV3rpJd08bzoGDMQ/132","nickname":"Echo","note":"","ucode":"2A99E37C89660E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284238,"discussion_content":"可以直接调用m.getAndUpdate","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592481383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143854,"user_name":"ipofss","can_delete":false,"product_type":"c1","uid":1018620,"ip_address":"","ucode":"DE3061C9259F9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","comment_is_top":false,"comment_ctime":1571799736,"is_pvip":false,"replies":[{"id":"55523","content":"用的时候查文档就行，工具类主要是会用，知道什么场景用什么","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571802825,"ip_address":"","comment_id":143854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70291276472","product_id":100023901,"comment_content":"老师，并发工具类，这整个一章，感觉听完似懂非懂的，因为实践中没用过，我要如何弥补这部分，还是说只要听说过，然后用的时候再去查看demo吗","like_count":16,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471726,"discussion_content":"用的时候查文档就行，工具类主要是会用，知道什么场景用什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571802825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89531,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1556197045,"is_pvip":false,"replies":[{"id":"32184","content":"这可难倒我了，并发库的源码我只是零散得看的，看完基本也忘得差不多了，感觉自己也不是搞算法的料，放弃了😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556281381,"ip_address":"","comment_id":89531,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27326000821","product_id":100023901,"comment_content":"老师stampedLock的获取锁源码，老师能帮忙解惑下么？阻塞的读线程cowait是挂在写节点的下方么？老师能解惑下基于的理论模型<br>private long acquireWrite(boolean interruptible, long deadline) {<br>        WNode node = null, p;<br>        for (int spins = -1;;) { &#47;&#47; spin while enqueuing<br>            long m, s, ns;<br>            &#47;&#47;如果当前的state是无锁状态即100000000<br>            if ((m = (s = state) &amp; ABITS) == 0L) {<br>            \t&#47;&#47;设置成写锁<br>                if (U.compareAndSwapLong(this, STATE, s, ns = s + WBIT))<br>                    return ns;<br>            }<br>            else if (spins &lt; 0)<br>            \t&#47;&#47;当前锁状态为写锁状态，并且队列为空，设置自旋值<br>                spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : 0;<br>            else if (spins &gt; 0) {<br>            \t&#47;&#47;自旋操作，就是让线程在此自旋<br>                if (LockSupport.nextSecondarySeed() &gt;= 0)<br>                    --spins;<br>            }<br>            &#47;&#47;如果队列尾元素为空，初始化队列<br>            else if ((p = wtail) == null) { &#47;&#47; initialize queue<br>                WNode hd = new WNode(WMODE, null);<br>                if (U.compareAndSwapObject(this, WHEAD, null, hd))<br>                    wtail = hd;<br>            }<br>            &#47;&#47;当前要加入的元素为空，初始化当前元素，前置节点为尾节点<br>            else if (node == null)<br>                node = new WNode(WMODE, p);<br>            &#47;&#47;队列的稳定性判断，当前的前置节点是否改变，重新设置    <br>            else if (node.prev != p)<br>                node.prev = p;<br>            &#47;&#47;将当前节点加入尾节点中    <br>            else if (U.compareAndSwapObject(this, WTAIL, p, node)) {<br>                p.next = node;<br>                break;<br>            }<br>        }<br><br>        ","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448164,"discussion_content":"这可难倒我了，并发库的源码我只是零散得看的，看完基本也忘得差不多了，感觉自己也不是搞算法的料，放弃了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556281381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89320,"user_name":"天涯煮酒","can_delete":false,"product_type":"c1","uid":1241127,"ip_address":"","ucode":"EF9516EC878E4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/27/8b72141c.jpg","comment_is_top":false,"comment_ctime":1556154302,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27325958078","product_id":100023901,"comment_content":"先调用m.get()并跟r比较，再调用m.set()，这里存在竞态条件，线程并不安全","like_count":6,"discussions":[{"author":{"id":1486895,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b0/2f/e2096905.jpg","nickname":"马成","note":"","ucode":"664F2BAA2E0F0B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47070,"discussion_content":"这里虽然不满足原子性，但是不影响结果，问题不在这里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573268169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156589,"user_name":"王昊哲","can_delete":false,"product_type":"c1","uid":1698557,"ip_address":"","ucode":"AA2F4499BF6865","user_header":"https://static001.geekbang.org/account/avatar/00/19/ea/fd/89d3d0b5.jpg","comment_is_top":false,"comment_ctime":1574918411,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18754787595","product_id":100023901,"comment_content":"有个疑问：老师也提到那种线程池+阻塞队列实现方式，队列里保存的是任务的结果，而completionService保存的future，那completionService的future拿出来get的时候，也阻塞在get那里了啊，那不跟跟线程池+future的实现一样的弊端了啊？","like_count":4,"discussions":[{"author":{"id":1052191,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0e/1f/d0472177.jpg","nickname":"厉害了我的国","note":"","ucode":"CD0A54A1B998AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214488,"discussion_content":"翻了源码：\n    private static class QueueingFuture<V> extends FutureTask<Void> {\n        QueueingFuture(RunnableFuture<V> task,\n                       BlockingQueue<Future<V>> completionQueue) {\n            super(task, null);\n            this.task = task;\n            this.completionQueue = completionQueue;\n        }\n        private final Future<V> task;\n        private final BlockingQueue<Future<V>> completionQueue;\n        protected void done() { completionQueue.add(task); }\n    }\n这里会在task执行完之后，才把Future入队，所以不会阻塞","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585198048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368827,"discussion_content":"把结果放在阻塞队列可以保证按照结果产生的顺序消费，而不放到阻塞队列有可能一直在等待时间较长的任务而较短的任务已经结束了，总的执行时间上有差别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618840714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052191,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0e/1f/d0472177.jpg","nickname":"厉害了我的国","note":"","ucode":"CD0A54A1B998AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214466,"discussion_content":"我也有相同疑问，希望老师解答一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585195276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90106,"user_name":"一眼万年","can_delete":false,"product_type":"c1","uid":1018200,"ip_address":"","ucode":"7B0823E39AE809","user_header":"","comment_is_top":false,"comment_ctime":1556416122,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18736285306","product_id":100023901,"comment_content":"课后思考如果需要等待最小结果，本来就有阻塞队列了，加了个线程池，评论还要加上栏栅，那除了炫技没啥作用","like_count":5,"discussions":[{"author":{"id":1686903,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bd/77/72676290.jpg","nickname":"cd","note":"","ucode":"AE95F4288A7978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273235,"discussion_content":"起了三个线程比较大小，是异步，可能还没比较完主线程就return m，m还是int的最大值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590420670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2593255,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2msSWvJs8A6icPvUzyRs9DEqltYh0edy699wJz9BmCRoJj1bZHhBHhp4yY9Nic9oc2q8OdsVGwtmBRhKtw00Jj6Q/132","nickname":"Geek_c139e0","note":"","ucode":"87C7E07E98354B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1686903,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bd/77/72676290.jpg","nickname":"cd","note":"","ucode":"AE95F4288A7978","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557215,"discussion_content":"可是completionService的take是阻塞的，如果最后比价不启用新线程去做，完全能保证最长阻塞时间就是最长异步时间，而且还不会因为异步启动导致取价还没返回","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647699481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273235,"ip_address":""},"score":557215,"extra":""}]},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106397,"discussion_content":"😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577535269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89832,"user_name":"海鸿","can_delete":false,"product_type":"c1","uid":1104275,"ip_address":"","ucode":"7074EF94EA70AD","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/93/098e5ef5.jpg","comment_is_top":false,"comment_ctime":1556276708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18736145892","product_id":100023901,"comment_content":"重新发过，刚刚的代码有误！<br>1.for循环线程池执行属于异步导致未等比价结果就 return了，需要等待三次比价结果才能 return，可以用 CountDownLatch<br>2. m. set( Integer. min( m. get(), r))存在竞态条件，可以更改为 <br>Integer o; <br>do{ <br>o= m. get(); <br>if(o&lt;=r){ break;}<br>} <br>while(! m. compareAndSet( o, r));<br>3.还有一个小问题就是 try- catch捕获异常后的处理，提高程序鲁棒性","like_count":4},{"had_liked":false,"id":90806,"user_name":"Sunqc","can_delete":false,"product_type":"c1","uid":1473717,"ip_address":"","ucode":"2C54659635403F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7c/b5/4a7a2bd4.jpg","comment_is_top":false,"comment_ctime":1556670643,"is_pvip":false,"replies":[{"id":"32573","content":"是的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556700177,"ip_address":"","comment_id":90806,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14441572531","product_id":100023901,"comment_content":"&#47;&#47; 获取电商 S1 报价并保存<br>r=f1.get();<br>executor.execute(()-&gt;save(r));<br><br>如果把r=f1.get（）放进execute里应该是也能保证先执行完的先保存","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448665,"discussion_content":"是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556700177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89356,"user_name":"黄海峰","can_delete":false,"product_type":"c1","uid":1275357,"ip_address":"","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1556158088,"is_pvip":false,"replies":[{"id":"32007","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556190855,"ip_address":"","comment_id":89356,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14441059976","product_id":100023901,"comment_content":"我实际测试了第一段代码，确实是异步的，f1.get不会阻塞主线程。。。<br><br>public static void main(String[] args) {<br>        ExecutorService executor = Executors.newFixedThreadPool(3);<br>        Future&lt;Integer&gt; f1 = executor.submit(()-&gt;getPriceByS1());<br>        Future&lt;Integer&gt; f2 = executor.submit(()-&gt;getPriceByS2());<br>        Future&lt;Integer&gt; f3 = executor.submit(()-&gt;getPriceByS3());<br><br>        executor.execute(()-&gt; {<br>            try {<br>                save(f1.get());<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            } catch (ExecutionException e) {<br>                e.printStackTrace();<br>            }<br>        });<br>        executor.execute(()-&gt; {<br>            try {<br>                save(f2.get());<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            } catch (ExecutionException e) {<br>                e.printStackTrace();<br>            }<br>        });<br>        executor.execute(()-&gt; {<br>            try {<br>                save(f3.get());<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            } catch (ExecutionException e) {<br>                e.printStackTrace();<br>            }<br>        });<br>    }<br><br>    private static Integer getPriceByS1() {<br>        try {<br>            Thread.sleep(10000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return 1;<br>    }<br>    private static Integer getPriceByS2() {<br>        try {<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return 2;<br>    }<br>    private static Integer getPriceByS3() {<br>        try {<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return 3;<br>    }<br>    private static void save(Integer i) {<br>        System.out.println(&quot;save &quot; + i);<br>    }","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448102,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556190855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89325,"user_name":"Corner","can_delete":false,"product_type":"c1","uid":1446316,"ip_address":"","ucode":"7862D593172536","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg","comment_is_top":false,"comment_ctime":1556154751,"is_pvip":false,"replies":[{"id":"32017","content":"👍，示例代码有问题，已经改了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556194194,"ip_address":"","comment_id":89325,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14441056639","product_id":100023901,"comment_content":"1.AtomicReference&lt;Integer&gt;的get方法应该改成使用cas方法<br>2.最后筛选最小结果的任务是异步执行的，应该在return之前做同步，所以最好使用sumit提交该任务便于判断任务的完成<br>最后请教老师一下，第一个例子中为什么主线程会阻塞在f1.get()方法呢？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448091,"discussion_content":"👍，示例代码有问题，已经改了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556194194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89275,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1556131613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14441033501","product_id":100023901,"comment_content":"executor.execute（Callable）提交任务是非阻塞的 return m；很大概率返回 Integer.Maxvalue，而且老师为了确保返回这个max还特意加入了save这个阻塞的方法","like_count":3},{"had_liked":false,"id":89321,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1556154302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10146088894","product_id":100023901,"comment_content":"老师 用 CompletionService 和用 CompletionFuture 查询，然后用 whenComplete 或者 thenAcceptEither 这些方法的区别是什么，我觉得用 CompletionFuture 更直观些；<br>老师可以在下一讲的时候说一下上一讲的思考题正确答案吗，谢谢老师","like_count":2},{"had_liked":false,"id":190895,"user_name":"鸡蛋🎱 达芬奇","can_delete":false,"product_type":"c1","uid":1104819,"ip_address":"","ucode":"8493ACD4D14E0C","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/b3/040eb673.jpg","comment_is_top":false,"comment_ctime":1584706712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879674008","product_id":100023901,"comment_content":"扩宽视野，提供思路","like_count":1},{"had_liked":false,"id":145098,"user_name":"梅小西","can_delete":false,"product_type":"c1","uid":1101347,"ip_address":"","ucode":"AF47185323E6A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/23/d722d6ec.jpg","comment_is_top":false,"comment_ctime":1572188700,"is_pvip":false,"replies":[{"id":"56145","content":"每种异步任务都会创建一个新的，不可能所有的异步任务都用一个。如果某些需要共用，可以包装一个类就可以了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1572309734,"ip_address":"","comment_id":145098,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867155996","product_id":100023901,"comment_content":"老师讲的挺不错的，看了这个例子，有几点疑问，还希望老师说明下：<br>&#47;&#47; 这个是老师例子：<br><br>&#47;&#47; 创建线程池<br>ExecutorService executor = <br>  Executors.newFixedThreadPool(3);<br>&#47;&#47; 创建CompletionService<br>CompletionService&lt;Integer&gt; cs = new <br>  ExecutorCompletionService&lt;&gt;(executor);<br>&#47;&#47; 异步向电商S1询价<br>cs.submit(()-&gt;getPriceByS1());<br>&#47;&#47; 异步向电商S2询价<br>cs.submit(()-&gt;getPriceByS2());<br>&#47;&#47; 异步向电商S3询价<br>cs.submit(()-&gt;getPriceByS3());<br>&#47;&#47; 将询价结果异步保存到数据库<br>for (int i=0; i&lt;3; i++) {<br>  Integer r = cs.take().get();<br>  executor.execute(()-&gt;save(r));<br>}<br><br>首先，CompletionService应该是要绑定泛型，代表异步任务的返回结果，实际应用中，几乎不太可能所有的异步任务的返回类型是一样的，除非设置成Object这种通用型，那又会导致拿到结果后需要强转，代码看起来更难受；<br>其次，对于返回的结果的处理方式，实际应用中几乎也是不同的，那就要针对每一个take出来的结果做判断，这实际上也是会导致代码很难维护；<br><br>综上，CompletionService 看来能够做批量处理异步任务的事情，实际应用中，我感觉不太实用！<br><br>以上两点是个人见解，有不对之处请老师指教！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472246,"discussion_content":"每种异步任务都会创建一个新的，不可能所有的异步任务都用一个。如果某些需要共用，可以包装一个类就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572309734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132686,"user_name":"ideal sail","can_delete":false,"product_type":"c1","uid":1098870,"ip_address":"","ucode":"38E1C7DE8964DF","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/76/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1568191892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863159188","product_id":100023901,"comment_content":"课后思考中只要把最小值的比较放在主线程就好了，take一次比较一次，没必要在多个线程里计算最小值。","like_count":1},{"had_liked":false,"id":129472,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1567134409,"is_pvip":false,"replies":[{"id":"48636","content":"问题出在f1.get()不是异步的，它会阻塞线程","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567427618,"ip_address":"","comment_id":129472,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862101705","product_id":100023901,"comment_content":"老师，冒昧的问下：在文章刚开始的例子，无论是三个询价任务（通过submit方法提交），还是保存询价任务（通过execute方法提交）都是异步的执行执行的啊！如果s1询价的时间过长的话，也不会影响到s2保存保价的先执行啊！他只影响到s1保存询价的动作。老师不知道我说的有么有道理，有问题请老师帮忙指正","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465489,"discussion_content":"问题出在f1.get()不是异步的，它会阻塞线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567427618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89476,"user_name":"云里雾花","can_delete":false,"product_type":"c1","uid":1232383,"ip_address":"","ucode":"98D8E75D1B2B39","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/ff/b7690816.jpg","comment_is_top":false,"comment_ctime":1556182220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851149516","product_id":100023901,"comment_content":"要解决等待三个线程都运行结束的才知道谁是最小值。CountDownLatch或者一个原子类来做计数器等都可以。","like_count":1},{"had_liked":false,"id":89436,"user_name":"hj","can_delete":false,"product_type":"c1","uid":1264287,"ip_address":"","ucode":"6ED34286AC30FA","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/9f/b92a9139.jpg","comment_is_top":false,"comment_ctime":1556174147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851141443","product_id":100023901,"comment_content":"确实，第一个例子老师为了抛出问题引出CompletionService，但是逻辑上的确不成立。不是f1.get（）阻塞主线程","like_count":1},{"had_liked":false,"id":89315,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1556153823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851121119","product_id":100023901,"comment_content":"m.set和get存在静态条件不是原子的，可能存在设置和不是最小值","like_count":1},{"had_liked":false,"id":89314,"user_name":"空空空空","can_delete":false,"product_type":"c1","uid":1082938,"ip_address":"","ucode":"A1A50E16E02803","user_header":"https://static001.geekbang.org/account/avatar/00/10/86/3a/76dbbd0e.jpg","comment_is_top":false,"comment_ctime":1556153750,"is_pvip":false,"replies":[{"id":"32339","content":"对的！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556464822,"ip_address":"","comment_id":89314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851121046","product_id":100023901,"comment_content":"算低价的时候是用三个不同的线程去计算，是异步的，因此可能算出来并不是预期的结果<br>老师，这样理解对吗？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448089,"discussion_content":"对的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556464822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351236,"user_name":"开心","can_delete":false,"product_type":"c1","uid":1517457,"ip_address":"","ucode":"C8E08E8724C7CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkzrezV2dOBAgickt9DLzabz3dNFYyDEVXENMQ5ibrWhFbFqXIOia3ZaR21pozvB7UfoxJx4Ar688sA/132","comment_is_top":false,"comment_ctime":1657634240,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657634240","product_id":100023901,"comment_content":"有个疑问， 文章的例子中三个线程够么。 前面提交任务的时候占用了三个线程。 后面又提交任务future.get()。 此时线程数不够了，可能导致 A任务执行完释放出来的线程执行 B任务得到的future.get().","like_count":0},{"had_liked":false,"id":345955,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652713061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652713061","product_id":100023901,"comment_content":"1 由于是 execute 提交提交完会立马结束，可能异步处理的任务还没执行就结束了，m是最大值<br>2 save r maybe is null ,npe 异常<br>","like_count":0},{"had_liked":false,"id":341631,"user_name":"Carla","can_delete":false,"product_type":"c1","uid":1181454,"ip_address":"","ucode":"29608BF359A567","user_header":"","comment_is_top":false,"comment_ctime":1649741857,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1649741857","product_id":100023901,"comment_content":"老师，ExecutorCompletionService和直接提交到线程池，返回future，再把future放入一个list，最后遍历list进行get这种方式相比有什么优势么。而且样例代码中需要知道任务的具体个数，才能遍历从ExecutorCompletionService中获取，这是不是有局限性","like_count":0,"discussions":[{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576625,"discussion_content":"区别在于completionService放入queue里面的task，是任务已经执行完毕的。 从里面take()出来的顺序， 和任务执行快慢顺序一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655708977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331401,"user_name":"never leave","can_delete":false,"product_type":"c1","uid":1241638,"ip_address":"","ucode":"62888A1446A1E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/26/8d42ea6f.jpg","comment_is_top":false,"comment_ctime":1642574637,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642574637","product_id":100023901,"comment_content":"我想问一下   使用阻塞队列的例子中   for循环如果用dq.size()控制   程序一直没有输出是什么原因？","like_count":0},{"had_liked":false,"id":324493,"user_name":"zhongmin","can_delete":false,"product_type":"c1","uid":1265621,"ip_address":"","ucode":"C7AB10205A4F04","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/d5/1666b7d0.jpg","comment_is_top":false,"comment_ctime":1638456180,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1638456180","product_id":100023901,"comment_content":"不清楚自己哪里没有考虑到😂这里我没有感觉和前面获取最快的地理查询服务有啥区别？我感觉把思考题中的线程池提交部分，直接改成之前的 cs.take().get() 是不是可以得到正确的结果。<br><br>因为 CS 中已经把各个线程的 Future 给填充到了内置的阻塞队列，而 get 又会同步获取等待阻塞的结果，在主线程中，肯定是等待都同步获得三个线程的结果，执行。所以我感觉改成下面这样，也能获得正确的结果<br><br>        &#47;&#47; 并计算最低报价<br>        AtomicReference&lt;Integer&gt; m = new AtomicReference&lt;&gt;(Integer.MAX_VALUE);<br>        for (int i = 0; i &lt; 3; i++) {<br>            Integer r = null;<br>            try {<br>                r = cs.take().get();<br>            } catch (Exception e) {<br>            }<br>            save(r);<br>            m.set(Integer.min(m.get(), r)); &#47;&#47; 不是原子操作<br>        }<br>        return m;","like_count":0,"discussions":[{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576626,"discussion_content":"光谈最小值的事情，确实你说的可以。 但是这个save(r)没有异步，老师想save(r)也一起异步吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655709109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318889,"user_name":"Jussi Lee","can_delete":false,"product_type":"c1","uid":1211190,"ip_address":"","ucode":"F2F5948CCD52A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/36/fd46331c.jpg","comment_is_top":false,"comment_ctime":1635474365,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1635474365","product_id":100023901,"comment_content":"老师，有这种需求：<br>1.我通过CompletionService批量提交了多个任务，可能有某个任务处理失败了。我需要把这种失败的任务记录下来如何处理？<br>2.看到文中有提到使用poll是可以超时获取一个空值的，超时执行的任务我们如何记录下来？","like_count":0,"discussions":[{"author":{"id":2434363,"avatar":"https://static001.geekbang.org/account/avatar/00/25/25/3b/864c5115.jpg","nickname":"saiuna","note":"","ucode":"8DB9C47C965195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411851,"discussion_content":"超时时，take() 返回的是null值，判空做记录吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636018314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2434363,"avatar":"https://static001.geekbang.org/account/avatar/00/25/25/3b/864c5115.jpg","nickname":"saiuna","note":"","ucode":"8DB9C47C965195","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411850,"discussion_content":"席哥？妈耶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636018204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306450,"user_name":"刘育飞","can_delete":false,"product_type":"c1","uid":1363642,"ip_address":"","ucode":"06600614E898CC","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/ba/f73555c7.jpg","comment_is_top":false,"comment_ctime":1628566360,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628566360","product_id":100023901,"comment_content":"请问 关于只要获取一个值就可以 返回得那里，应该可以不需要Future集合去装, Future集合 只是为了 取消执行中得线程，减少资源得消耗吗","like_count":0},{"had_liked":false,"id":297171,"user_name":"SonKi","can_delete":false,"product_type":"c1","uid":2055727,"ip_address":"","ucode":"E619DE2930266A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqoMJKawfU2Tia213fSM16GgFJiagjDrSDg9lBuYeuO4iatxXI61E43iczuqd191FG40vZY75zrFLtzow/132","comment_is_top":false,"comment_ctime":1623339534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623339534","product_id":100023901,"comment_content":"&#47;&#47; 创建线程池<br>        ExecutorService executor =<br>                Executors.newFixedThreadPool(3);<br>        &#47;&#47; 创建CompletionService<br>        CompletionService&lt;Integer&gt; cs = new<br>                ExecutorCompletionService&lt;&gt;(executor);<br>        List&lt;Future&lt;Integer&gt;&gt; futures = new ArrayList&lt;&gt;();<br>        futures.add(cs.submit(() -&gt; {<br>            int i = BigDecimal.valueOf(Math.random()).multiply(BigDecimal.valueOf(1000)).intValue();<br>            System.out.println(i);<br>            return i;<br>        }));<br>        futures.add(cs.submit(() -&gt; {<br>            int i = BigDecimal.valueOf(Math.random()).multiply(BigDecimal.valueOf(1000)).intValue();<br>            System.out.println(i);<br>            return i;<br>        }));<br>        futures.add(cs.submit(() -&gt; {<br>            int i = BigDecimal.valueOf(Math.random()).multiply(BigDecimal.valueOf(1000)).intValue();<br>            System.out.println(i);<br>            return i;<br>        }));<br>        &#47;&#47; 将询价结果异步保存到数据库<br>        &#47;&#47; 并计算最低报价<br>        AtomicReference&lt;Integer&gt; m = new AtomicReference&lt;&gt;(Integer.MAX_VALUE);<br>        for (int i = 0; i &lt; 3; i++) {<br>            Integer r = cs.take().get();<br>            synchronized (m) {<br>                Integer integer = m.get();<br>                m.set(Integer.min(r, integer));<br>            }<br>        }<br>        System.out.println(&quot;最小值：&quot; + m);","like_count":0},{"had_liked":false,"id":296394,"user_name":"霍霍","can_delete":false,"product_type":"c1","uid":1542586,"ip_address":"","ucode":"A483D42AD7F72D","user_header":"https://static001.geekbang.org/account/avatar/00/17/89/ba/009ee13c.jpg","comment_is_top":false,"comment_ctime":1622951241,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1622951241","product_id":100023901,"comment_content":"老师，想问一下complemetion service的异常处理，记得他好像有一个运行期异常是ExecutionException，应该如何优雅处理","like_count":0},{"had_liked":false,"id":288543,"user_name":"威先森","can_delete":false,"product_type":"c1","uid":1687656,"ip_address":"","ucode":"5F445C6832274B","user_header":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","comment_is_top":false,"comment_ctime":1618534851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618534851","product_id":100023901,"comment_content":"老师，下面这个例子的for循环有意义吗？<br>&#47;&#47; 创建线程池<br>ExecutorService executor =<br>  Executors.newFixedThreadPool(3);<br>&#47;&#47; 创建CompletionService<br>CompletionService&lt;Integer&gt; cs =<br>  new ExecutorCompletionService&lt;&gt;(executor);<br>&#47;&#47; 用于保存Future对象<br>List&lt;Future&lt;Integer&gt;&gt; futures =<br>  new ArrayList&lt;&gt;(3);<br>&#47;&#47;提交异步任务，并保存future到futures <br>futures.add(<br>  cs.submit(()-&gt;geocoderByS1()));<br>futures.add(<br>  cs.submit(()-&gt;geocoderByS2()));<br>futures.add(<br>  cs.submit(()-&gt;geocoderByS3()));<br>&#47;&#47; 获取最快返回的任务执行结果<br>Integer r = 0;<br>try {<br>  &#47;&#47; 只要有一个成功返回，则break<br>  for (int i = 0; i &lt; 3; ++i) {<br>    r = cs.take().get();<br>    &#47;&#47;简单地通过判空来检查是否成功返回<br>    if (r != null) {<br>      break;<br>    }<br>  }<br>} finally {<br>  &#47;&#47;取消所有任务<br>  for(Future&lt;Integer&gt; f : futures)<br>    f.cancel(true);<br>}<br>&#47;&#47; 返回结果<br>return r;","like_count":0},{"had_liked":false,"id":285888,"user_name":"盛权_vinc","can_delete":false,"product_type":"c1","uid":1459845,"ip_address":"","ucode":"4688DD06587CE2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LPnuO9GleKEwso2rSbibmbEwn49hnGl9qTQDBv2xLOOWOflQsc9oVEEuZgNBt7TrqRKvk8CX7Tc8iakhEicBCCfFg/132","comment_is_top":false,"comment_ctime":1617065841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617065841","product_id":100023901,"comment_content":"老师，把文章中的第一段代码块和第二段代码块放在一起还是不能谁询价结束就塞谁进队列😂线程池大小只有3","like_count":0},{"had_liked":false,"id":282551,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1615298924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615298924","product_id":100023901,"comment_content":"循环体里提交三个任务后，直接return了，有可能还没执行完毕。可以把线程池提交去掉，直接改为串行get阻塞即可。取最小值肯定需要所有结果返回，这里也没有其他耗时操作，完全可以串行get阻塞取结果然后比较","like_count":0},{"had_liked":false,"id":275737,"user_name":"Bruce","can_delete":false,"product_type":"c1","uid":1106929,"ip_address":"","ucode":"B2F562F717BD3C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/f1/346bd356.jpg","comment_is_top":false,"comment_ctime":1611654870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611654870","product_id":100023901,"comment_content":"老师，直接用executor.shutdownNow()，是不是跟遍历Future，挨个cancel(true)一个效果？","like_count":0},{"had_liked":false,"id":275645,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1611630637,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1611630637","product_id":100023901,"comment_content":"创建一个list 集合  然后 把 Future f1 f2 f3 存进集合中， <br>之后遍历集合 future.get()方法 ，实现 阻塞队列的作用。","like_count":0},{"had_liked":false,"id":275232,"user_name":"喃寻","can_delete":false,"product_type":"c1","uid":1565085,"ip_address":"","ucode":"E31B3660726671","user_header":"https://static001.geekbang.org/account/avatar/00/17/e1/9d/3ec0adec.jpg","comment_is_top":false,"comment_ctime":1611399862,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1611399862","product_id":100023901,"comment_content":"m的值需要等待三个线程执行完后获取才行,可以用CountDownLatch 实现","like_count":0},{"had_liked":false,"id":269359,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1608623207,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1608623207","product_id":100023901,"comment_content":"老师 r = cs.take().get(); 感觉这点完全没有必要 开启异步去操作呀，看了评论的 加一个CountDownLanch 进行等待三个线程，感觉这样有点类似与同步-&gt;异步-&gt;同步的感觉，直接同步执行 r = cs.take().get();就行了吧","like_count":0},{"had_liked":false,"id":266706,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1607444587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607444587","product_id":100023901,"comment_content":"最后一个示例代码（非思考题），我感觉最后计算的时候不需要用一个for循环吧，直接    r = cs.take().get()  不就行了吗","like_count":0},{"had_liked":false,"id":266704,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1607444290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607444290","product_id":100023901,"comment_content":"再次拜读本篇，通俗易懂。<br>以前是听的，没get到","like_count":0},{"had_liked":false,"id":252326,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1602236999,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1602236999","product_id":100023901,"comment_content":"return m的时候三个线程还未执行完，m值不对","like_count":0},{"had_liked":false,"id":247205,"user_name":"陈康康","can_delete":false,"product_type":"c1","uid":1192741,"ip_address":"","ucode":"A34A0DC88D6E77","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/25/eac79a47.jpg","comment_is_top":false,"comment_ctime":1599633829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599633829","product_id":100023901,"comment_content":"查询报价和计算最低价使用的同一个固定大小是3的线程池，可能会因为计算最低价的任务先执行，这样子，三个计算最低价的任务会把线程池的三个线程都占用，并且一直阻塞，导致程序一直阻塞把","like_count":0},{"had_liked":false,"id":232766,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1594113078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594113078","product_id":100023901,"comment_content":"老师思考题有个疑问<br>那个循环，不是要循环三次后，获得最低价返回，为什么说三个线程不能执行完呢？ 那个take方法和future的get方法不都是阻塞方法么？ <br>","like_count":0},{"had_liked":false,"id":228170,"user_name":"天地闲","can_delete":false,"product_type":"c1","uid":1241176,"ip_address":"","ucode":"1D5F8F8BFBE12A","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/58/59aa43b4.jpg","comment_is_top":false,"comment_ctime":1592575838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592575838","product_id":100023901,"comment_content":"3个只要有一个返回的例子中，是不是可以服用for循环3次，直接调用cs.take().get","like_count":0},{"had_liked":false,"id":203335,"user_name":"女巫在寒江","can_delete":false,"product_type":"c1","uid":1013180,"ip_address":"","ucode":"B3707072224C1C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/bc/664bbdf7.jpg","comment_is_top":false,"comment_ctime":1586175783,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586175783","product_id":100023901,"comment_content":"首先，r = cs.take().get();应该放到execute外面，同步阻塞的等待，只要得出一个结果就开始执行保存和比价，而不是各自起三个线程去等待结果；<br>其次save（r）不应该放到exception那个处理里面，他应该是一个正常逻辑；","like_count":0},{"had_liked":false,"id":197508,"user_name":"hellojd","can_delete":false,"product_type":"c1","uid":1341697,"ip_address":"","ucode":"4E51807AE7E472","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","comment_is_top":false,"comment_ctime":1585382459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585382459","product_id":100023901,"comment_content":"喜欢这个模块，并发设计模式，可以直接拿来用","like_count":0},{"had_liked":false,"id":195505,"user_name":"厉害了我的国","can_delete":false,"product_type":"c1","uid":1052191,"ip_address":"","ucode":"CD0A54A1B998AA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/1f/d0472177.jpg","comment_is_top":false,"comment_ctime":1585191930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585191930","product_id":100023901,"comment_content":"cs里的阻塞队列存的是future，那后续执行cs.take().get()还是会阻塞啊。。，是我理解的有问题吗？","like_count":0},{"had_liked":false,"id":177568,"user_name":"薯片","can_delete":false,"product_type":"c1","uid":1072044,"ip_address":"","ucode":"FE757E1248EFF5","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/ac/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1581425719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581425719","product_id":100023901,"comment_content":"问一个更小白的问题，为什么第一个例子中，要用阻塞队列，用普通队列会有什么问题呢？","like_count":0},{"had_liked":false,"id":176906,"user_name":"supermouse","can_delete":false,"product_type":"c1","uid":1321860,"ip_address":"","ucode":"88072D5F881827","user_header":"https://static001.geekbang.org/account/avatar/00/14/2b/84/07f0c0d6.jpg","comment_is_top":false,"comment_ctime":1581220099,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581220099","product_id":100023901,"comment_content":"老师您好，为什么我写的这个用CompletionService创建四个线程计算从1加到n的程序在打印出最后的结果后没有退出呢？<br>public class TestCompletionService {<br>    private static long addRange(long start, long end){<br>        long sum = 0;<br>        for (long i = start; i &lt;= end; i++) {<br>            sum += i;<br>        }<br>        return sum;<br>    }<br>    public static void main(String[] args) throws InterruptedException, ExecutionException {<br>        long n = 3000000000L;<br>        Long res = 0L;<br><br>        ExecutorService executor = Executors.newFixedThreadPool(4); &#47;&#47;创建线程池<br>        CompletionService&lt;Long&gt; cs = new ExecutorCompletionService&lt;&gt;(executor);<br><br>        cs.submit(() -&gt; addRange(1L, n &gt;&gt; 2));<br>        cs.submit(() -&gt; addRange((n &gt;&gt; 2) + 1, n &gt;&gt; 1));<br>        cs.submit(() -&gt; addRange((n &gt;&gt; 1) + 1, (n &gt;&gt; 2) * 3));<br>        cs.submit(() -&gt; addRange((n &gt;&gt; 2) * 3 + 1, n));<br><br>        for (int i = 0; i &lt; 4; i++) {<br>            res += cs.take().get();<br>        }<br>        System.out.println(res);<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1052191,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0e/1f/d0472177.jpg","nickname":"厉害了我的国","note":"","ucode":"CD0A54A1B998AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214463,"discussion_content":"线程池需要关闭，executor.shutdown()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585195071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176057,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1580925293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580925293","product_id":100023901,"comment_content":"老师 问一下 用 CompletionService 实现 Dubbo 中的 Forking Cluster 这个例子 为什么使用了一个future集合  像之前的例子一样 直接用CompletionService对象的take不行吗 ","like_count":0},{"had_liked":false,"id":167542,"user_name":"silentyears","can_delete":false,"product_type":"c1","uid":1061748,"ip_address":"","ucode":"6E137BFEB874CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/74/d9d143fa.jpg","comment_is_top":false,"comment_ctime":1577852125,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577852125","product_id":100023901,"comment_content":"老师，请问，获取到一个就返回的示例中，如果cancel时，cancel的方法执行的RPC之类的调用，会出现什么情况？","like_count":0},{"had_liked":false,"id":163446,"user_name":"特雷西皮皮","can_delete":false,"product_type":"c1","uid":1564539,"ip_address":"","ucode":"0BE139A55157F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/df/7b/4ad93869.jpg","comment_is_top":false,"comment_ctime":1576722934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576722934","product_id":100023901,"comment_content":"f1.get()占用了线程池的一个线程。不是让优先执行完的来占用，所以相当于一定程度上阻塞了。","like_count":0},{"had_liked":false,"id":148707,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1573051799,"is_pvip":false,"replies":[{"id":"57281","content":"你说的也不错，为了代码行数少一点","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573085287,"ip_address":"","comment_id":148707,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573051799","product_id":100023901,"comment_content":"老师，那个futures保存future就是为了后面取消(`cancel()`)，对吧","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473578,"discussion_content":"你说的也不错，为了代码行数少一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573085287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146527,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1572568789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572568789","product_id":100023901,"comment_content":"关于课后问题，我理解的是循环内不开启新的线程来做就可以了，本身想获取最小值就必须知道所有的值，这需要串行阻塞的。<br><br>&#47;&#47; 创建线程池<br>ExecutorService executor = <br>  Executors.newFixedThreadPool(3);<br>&#47;&#47; 创建 CompletionService<br>CompletionService&lt;Integer&gt; cs = new <br>  ExecutorCompletionService&lt;&gt;(executor);<br>&#47;&#47; 异步向电商 S1 询价<br>cs.submit(()-&gt;getPriceByS1());<br>&#47;&#47; 异步向电商 S2 询价<br>cs.submit(()-&gt;getPriceByS2());<br>&#47;&#47; 异步向电商 S3 询价<br>cs.submit(()-&gt;getPriceByS3());<br>&#47;&#47; 将询价结果异步保存到数据库<br>&#47;&#47; 并计算最低报价<br>AtomicReference&lt;Integer&gt; m =<br>  new AtomicReference&lt;&gt;(Integer.MAX_VALUE);<br>for (int i=0; i&lt;3; i++) {<br>  <br>    Integer r = null;<br>    try {<br>      r = cs.take().get();<br>    } catch (Exception e) {}<br>    save(r);<br>    m.set(Integer.min(m.get(), r));<br>  <br>}<br>return m;","like_count":0},{"had_liked":false,"id":146245,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1572482938,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1572482938","product_id":100023901,"comment_content":"try {<br>  &#47;&#47; 只要有一个成功返回，则 break<br>  for (int i = 0; i &lt; 3; ++i) {<br>    r = cs.take().get();<br>    &#47;&#47; 简单地通过判空来检查是否成功返回<br>    if (r != null) {<br>      break;<br>    }<br>  }<br>} finally {<br>  &#47;&#47; 取消所有任务<br>  for(Future&lt;Integer&gt; f : futures)<br>    f.cancel(true);<br>}<br>我有个疑问，这个获取的循环不应该用死循环么？循环3次是怎么保证一定能拿到数据的呢？","like_count":0,"discussions":[{"author":{"id":1385377,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","nickname":"何妨","note":"","ucode":"EC3983BFF7992A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41903,"discussion_content":"我懂了。cs的take方法是阻塞的。\n那为什么要循环3次呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572530147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1385377,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","nickname":"何妨","note":"","ucode":"EC3983BFF7992A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106402,"discussion_content":"3个任务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577535388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41903,"ip_address":""},"score":106402,"extra":""}]}]},{"had_liked":false,"id":135232,"user_name":"nsn_huang","can_delete":false,"product_type":"c1","uid":1041796,"ip_address":"","ucode":"D8C6DA6530F3B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/84/4a01e18d.jpg","comment_is_top":false,"comment_ctime":1569073487,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569073487","product_id":100023901,"comment_content":"老师您好，讲课后思考题部分代码这样改行么？<br>for (int i=0; i&lt;3; i++) {<br>    Integer r = null;<br>    try {<br>      r = cs.take().get();<br>    } catch (Exception e) {}<br>    save(r);<br>    m.set(Integer.min(m.get(), r));<br>}<br>我觉得cs.take().get();是阻塞的，所以同步执行就好了，循环三次，询价三次之后就能确定结果了。不知道这样对不对，希望老师指教。","like_count":0},{"had_liked":false,"id":135208,"user_name":"FantasyZsp","can_delete":false,"product_type":"c1","uid":1190037,"ip_address":"","ucode":"522878C4AEB690","user_header":"https://static001.geekbang.org/account/avatar/00/12/28/95/c57f5955.jpg","comment_is_top":false,"comment_ctime":1569060927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569060927","product_id":100023901,"comment_content":"模拟Forking Cluster获取第一个返回结果这里我有个疑问。既然cs.take().get()已经会阻塞主线程了，那么在执行后面时说明已经拿到了一个结果了，为什么取结果时仍然需要用循环取呢？<br><br>try {<br>  &#47;&#47; 只要有一个成功返回，则 break（为什么要用循环而不是直接cs.take().get()呢）<br>  for (int i = 0; i &lt; 3; ++i) {<br>    r = cs.take().get();<br>    &#47;&#47; 简单地通过判空来检查是否成功返回<br>    if (r != null) {<br>      break;<br>    }<br>  }<br>} finally {<br>  &#47;&#47; 取消所有任务<br>  for(Future&lt;Integer&gt; f : futures)<br>    f.cancel(true);<br>}<br><br>改写成这样会有什么问题吗？<br>try {<br>      String r = cs.take().get();<br>      min.set(Long.min(min.get(), r.length()));<br>      executor.execute(() -&gt; save(r));<br>    } finally {<br>      futures.forEach(future -&gt; future.cancel(true));<br>    }<br>","like_count":0},{"had_liked":false,"id":126667,"user_name":"程文","can_delete":false,"product_type":"c1","uid":1353782,"ip_address":"","ucode":"5BB1CA6F63C75C","user_header":"","comment_is_top":false,"comment_ctime":1566443981,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566443981","product_id":100023901,"comment_content":"请教下老师，我在项目中起了一个线程池，用ComletionService提交了5个异步任务。然后for循环等待任务跑完，最后关闭线程池。项目部署后第一次运行能成功，第二次就抛出concurrent. RejectExecutionEaxception异常<br>Terminated,pool size=0,active threads=0,queued tasks =0,completed task =5<br><br>","like_count":0,"discussions":[{"author":{"id":1013160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/a8/dfe4cade.jpg","nickname":"电光火石","note":"","ucode":"3AD33BB4AA940F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165054,"discussion_content":"因为线程池被关闭了吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581251995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123171,"user_name":"mi","can_delete":false,"product_type":"c1","uid":1291302,"ip_address":"","ucode":"981D61BADCF58E","user_header":"https://static001.geekbang.org/account/avatar/00/13/b4/26/131d4631.jpg","comment_is_top":false,"comment_ctime":1565619460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565619460","product_id":100023901,"comment_content":"&#47;&#47; 创建线程池<br>ExecutorService executor = <br>  Executors.newFixedThreadPool(3);<br>&#47;&#47; 创建 CompletionService<br>CompletionService&lt;Integer&gt; cs = new <br>  ExecutorCompletionService&lt;&gt;(executor);<br>&#47;&#47; 异步向电商 S1 询价<br>cs.submit(()-&gt;getPriceByS1());<br>&#47;&#47; 异步向电商 S2 询价<br>cs.submit(()-&gt;getPriceByS2());<br>&#47;&#47; 异步向电商 S3 询价<br>cs.submit(()-&gt;getPriceByS3());<br>&#47;&#47; 将询价结果异步保存到数据库<br>for (int i=0; i&lt;3; i++) {<br>  Integer r = cs.take().get();<br>  executor.execute(()-&gt;save(r));<br>}<br>这个还不是会阻塞到get么？即使从队列里拿到最快返回的future对象，只是空壳，不代表他的get会第一个返回。所以并不如第二种方法效率高","like_count":0},{"had_liked":false,"id":118132,"user_name":"倚梦流","can_delete":false,"product_type":"c1","uid":1435045,"ip_address":"","ucode":"7CB442D629534B","user_header":"https://static001.geekbang.org/account/avatar/00/15/e5/a5/fae40ac3.jpg","comment_is_top":false,"comment_ctime":1564277237,"is_pvip":false,"replies":[{"id":"43341","content":"异步要考虑的问题本身就很多，据说linus对异步就很反感","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1564358689,"ip_address":"","comment_id":118132,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564277237","product_id":100023901,"comment_content":"请问老师，任务操作中包含io操作，比如正在增删读写文件，这时候突然cancel，会有什么不良影响吗？或者任务里面包含数据库操作，如果突然cancel，岂不是需要在异步任务中，进行事务回滚？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460277,"discussion_content":"异步要考虑的问题本身就很多，据说linus对异步就很反感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564358689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114782,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1563407222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563407222","product_id":100023901,"comment_content":"有序性，和顺序性还是区别蛮大的。","like_count":0},{"had_liked":false,"id":112080,"user_name":"胡小禾","can_delete":false,"product_type":"c1","uid":1132315,"ip_address":"","ucode":"1C23B7492C0C9E","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/1b/64262861.jpg","comment_is_top":false,"comment_ctime":1562665219,"is_pvip":false,"replies":[{"id":"40817","content":"用for是因为r可能为空","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562712427,"ip_address":"","comment_id":112080,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562665219","product_id":100023901,"comment_content":"&#47;&#47; 创建线程池<br>ExecutorService executor =<br>  Executors.newFixedThreadPool(3);<br>&#47;&#47; 创建 CompletionService<br>CompletionService&lt;Integer&gt; cs =<br>  new ExecutorCompletionService&lt;&gt;(executor);<br>&#47;&#47; 用于保存 Future 对象<br>List&lt;Future&lt;Integer&gt;&gt; futures =<br>  new ArrayList&lt;&gt;(3);<br>&#47;&#47; 提交异步任务，并保存 future 到 futures <br>futures.add(<br>  cs.submit(()-&gt;geocoderByS1()));<br>futures.add(<br>  cs.submit(()-&gt;geocoderByS2()));<br>futures.add(<br>  cs.submit(()-&gt;geocoderByS3()));<br>&#47;&#47; 获取最快返回的任务执行结果<br>Integer r = 0;<br>try {<br>  &#47;&#47; 只要有一个成功返回，则 break<br>  for (int i = 0; i &lt; 3; ++i) {<br>    r = cs.take().get();<br>    &#47;&#47; 简单地通过判空来检查是否成功返回<br>    if (r != null) {<br>      break;<br>    }<br>  }<br>  &#47;&#47; **********************************<br>  &#47;&#47; for 循环其实没有必要吧？<br>  &#47;&#47; take() 是阻塞的拿到结果，get()也是阻塞的<br>  &#47;&#47; 只要有个任务完成，这个for循环就结束了<br>} finally {<br>  &#47;&#47; 取消所有任务<br>  for(Future&lt;Integer&gt; f : futures)<br>    f.cancel(true);<br>}<br>&#47;&#47; 返回结果<br>return r;<br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457565,"discussion_content":"用for是因为r可能为空","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562712427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112037,"user_name":"胡小禾","can_delete":false,"product_type":"c1","uid":1132315,"ip_address":"","ucode":"1C23B7492C0C9E","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/1b/64262861.jpg","comment_is_top":false,"comment_ctime":1562657965,"is_pvip":false,"replies":[{"id":"40761","content":"后面有一章介绍优雅停机，不过也谈不上通用","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562676431,"ip_address":"","comment_id":112037,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562657965","product_id":100023901,"comment_content":"请教下老师，实际生产中，使用BlockingQueue 时，<br>若重启实例，BQ 的任务可能会丢，对此有何通用方案？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457547,"discussion_content":"后面有一章介绍优雅停机，不过也谈不上通用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562676431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110174,"user_name":"rong","can_delete":false,"product_type":"c1","uid":1128740,"ip_address":"","ucode":"637A27C532D817","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/24/ab14f6cf.jpg","comment_is_top":false,"comment_ctime":1562204059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562204059","product_id":100023901,"comment_content":"最后一个例子，Arraylist初始化的时候，设置容量为3，这样，在放第三个的时候，根据扩容因子，就应该扩容了吧？","like_count":0},{"had_liked":false,"id":101108,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1316843,"ip_address":"","ucode":"7D440AFAA78678","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/eb/8bfd69b0.jpg","comment_is_top":false,"comment_ctime":1559719257,"is_pvip":false,"replies":[{"id":"36461","content":"为了用for循环减少代码量","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559741216,"ip_address":"","comment_id":101108,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559719257","product_id":100023901,"comment_content":"想问下，老师第二个例子里 cs.submit 返回的future 和 cs.take 获取的是同样的future吗 为什么还要加一个数组这个多余的东西啊","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452808,"discussion_content":"为了用for循环减少代码量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559741216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99831,"user_name":"奇奇","can_delete":false,"product_type":"c1","uid":1399097,"ip_address":"","ucode":"BC86B0CB55E35A","user_header":"","comment_is_top":false,"comment_ctime":1559316331,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559316331","product_id":100023901,"comment_content":"最后的问题 Math.min不是原子操作 会出现竞态条件","like_count":0},{"had_liked":false,"id":95573,"user_name":"tdytaylor","can_delete":false,"product_type":"c1","uid":1181214,"ip_address":"","ucode":"5B4919FDFE91A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/1e/51ad425f.jpg","comment_is_top":false,"comment_ctime":1558085259,"is_pvip":false,"replies":[{"id":"34218","content":"后面《35 | 两阶段终止模式：如何优雅地终止线程？》会讲","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558143536,"ip_address":"","comment_id":95573,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558085259","product_id":100023901,"comment_content":"老师，我看到几节中的demo都有在线程池里面取消任务执行，我之前看源码了解到，调用cancel时，如果线程已经在执行任务了，是没得办法终止这个任务的运行的，这种情况有没办法处理呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450521,"discussion_content":"后面《35 | 两阶段终止模式：如何优雅地终止线程？》会讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558143536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91636,"user_name":"嘉嘉☕","can_delete":false,"product_type":"c1","uid":1059771,"ip_address":"","ucode":"632A5CC4B53BB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","comment_is_top":false,"comment_ctime":1557064869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557064869","product_id":100023901,"comment_content":"置顶的留言，return是不是应该在for外面？","like_count":0},{"had_liked":false,"id":90605,"user_name":"悟空","can_delete":false,"product_type":"c1","uid":1451125,"ip_address":"","ucode":"F9DFBA74B35B40","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/75/808ac160.jpg","comment_is_top":false,"comment_ctime":1556587307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556587307","product_id":100023901,"comment_content":"使用相同的线程池，会导致前面查询报价线程池不够使用。应该使用两个线程","like_count":0},{"had_liked":false,"id":89563,"user_name":"punchline","can_delete":false,"product_type":"c1","uid":1314136,"ip_address":"","ucode":"32391B470CCD18","user_header":"https://static001.geekbang.org/account/avatar/00/14/0d/58/008173ad.jpg","comment_is_top":false,"comment_ctime":1556206375,"is_pvip":false,"replies":[{"id":"32119","content":"修改过，之前是有问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556239251,"ip_address":"","comment_id":89563,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556206375","product_id":100023901,"comment_content":"这一期的评论把我看懵了，future.get()就是阻塞当前线程啊","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448175,"discussion_content":"修改过，之前是有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556239251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89452,"user_name":"LW","can_delete":false,"product_type":"c1","uid":1325297,"ip_address":"","ucode":"89820332658E98","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg","comment_is_top":false,"comment_ctime":1556177095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556177095","product_id":100023901,"comment_content":"好多说第一个例子不阻塞的，都是没有实际运行过的，凭感觉臆测","like_count":0},{"had_liked":false,"id":89447,"user_name":"青莲","can_delete":false,"product_type":"c1","uid":1181787,"ip_address":"","ucode":"6BA5D5D47DE38E","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/5b/2a342424.jpg","comment_is_top":false,"comment_ctime":1556176722,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1556176722","product_id":100023901,"comment_content":"f1.get()真正阻塞的是线程池中的工作线程，由于工作线程数刚好和执行任务数一样，任务1耗时长肯定不会释放工作线程，f2.get()提交任务的时候，还是要等有空闲的工作线程来执行它","like_count":0},{"had_liked":false,"id":89416,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1556169789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556169789","product_id":100023901,"comment_content":"直接用一个线程安全的Skipset集合put进入，然后get(0)不就行了","like_count":0},{"had_liked":false,"id":89393,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1556163200,"is_pvip":false,"replies":[{"id":"32004","content":"👍👍，示例代码有问题，已经改了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556190742,"ip_address":"","comment_id":89393,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556163200","product_id":100023901,"comment_content":"老师我对第一个例子还是有疑问，f.get()已经提交给了线程池执行了，为什么会说阻塞主线程呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448115,"discussion_content":"👍👍，示例代码有问题，已经改了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556190742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89389,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1556162605,"is_pvip":false,"replies":[{"id":"32005","content":"👍👍，示例代码已经改了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556190791,"ip_address":"","comment_id":89389,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556162605","product_id":100023901,"comment_content":"老师,感觉开篇的阻塞队列解决future.get阻塞 存在问题,阻塞队列也是把执行get结果加到队列,然后take出来,如果线程池不够大, f1的submit 和 get占满了线程,其他线程的执行都需要等待...还是会阻塞<br>如果线程池足够大,原始方案就可以直接申请新的线程执行","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448113,"discussion_content":"👍👍，示例代码已经改了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556190791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89378,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1556160837,"is_pvip":false,"replies":[{"id":"32363","content":"👍👍👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556499973,"ip_address":"","comment_id":89378,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556160837","product_id":100023901,"comment_content":"1.m.set(Integer.min(m.get(), r))不是原子操作<br>2.catch住exception后，是否需要给r一个默认值呢<br>3.return 等不到异步结果<br><br>另外我有1个问题<br>我觉得第一个例子后面3个线程异步保存，不应该阻塞在f1.get，get方法会阻塞，但是只阻塞当前线程啊<br><br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448109,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556499973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89364,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1556158918,"is_pvip":false,"replies":[{"id":"32006","content":"👍都是火眼金睛","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556190816,"ip_address":"","comment_id":89364,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556158918","product_id":100023901,"comment_content":"第一个例子 我感觉f1.get()没有阻塞主线程啊  f1.get()是在线程池里异步执行的啊","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448105,"discussion_content":"👍都是火眼金睛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556190816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89355,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1556157978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556157978","product_id":100023901,"comment_content":"第一个例子 f1.get()是线程池里异步执行的 为啥会阻塞主线程","like_count":0},{"had_liked":false,"id":89348,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1556157264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556157264","product_id":100023901,"comment_content":"1.思考题: 这是个先判断后执行的复合操作，多线程下依赖上一个线程写入的结果。这里的m.set()方法应该不是原子操作，应该保证set的原子性吧<br><br>2.问题: 老师，这里的cs.take().get()方法我有个疑问:<br><br>a.当执行某个询价任务的过程中抛出了异常，这个异常是不是在Future&lt;T&gt;里面啊？ <br>是通过cs.take().get()里的get()方法取到异常了吗？ <br>还是直接在阻塞get()的过程中抛出来了啊？ <br><br>b.如果是阻塞在get()这里，此时任务线程被interrupt()了，那我们是不是就获取不到询价结果而是在get()过程中捕获了一个异常啊?<br><br>或者评论区的童鞋回答一下我也很感谢啊！","like_count":0},{"had_liked":false,"id":89341,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1556156702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556156702","product_id":100023901,"comment_content":"打卡。","like_count":0},{"had_liked":false,"id":89337,"user_name":"黄海峰","can_delete":false,"product_type":"c1","uid":1275357,"ip_address":"","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1556156260,"is_pvip":false,"replies":[{"id":"32008","content":"👍示例代码有问题<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556190922,"ip_address":"","comment_id":89337,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556156260","product_id":100023901,"comment_content":"老师，有个地方不理解。。第一段代码中这个f1.get不是在线程池里执行的吗？为何会阻塞了主线程？<br><br>&#47;&#47;获取电商 S1 报价并异步保存<br>executor.execute(<br>  ()-&gt;save(f1.get()));","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448095,"discussion_content":"👍示例代码有问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556190922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89334,"user_name":"渔夫","can_delete":false,"product_type":"c1","uid":1019289,"ip_address":"","ucode":"6BF08FD8923E45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/99/f886543d.jpg","comment_is_top":false,"comment_ctime":1556155709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556155709","product_id":100023901,"comment_content":"m.set(Integer.min(m.get(), r));<br><br>这个逻辑执行应该互斥，但是 set&#47;get 之间无法形成原子操作，应该使用 getAndUpdate 来完成该逻辑","like_count":0},{"had_liked":false,"id":89326,"user_name":"周治慧","can_delete":false,"product_type":"c1","uid":1335293,"ip_address":"","ucode":"7D56C4E66BEE17","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","comment_is_top":false,"comment_ctime":1556154967,"is_pvip":false,"replies":[{"id":"32189","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556284403,"ip_address":"","comment_id":89326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556154967","product_id":100023901,"comment_content":"存在问题，在执行executor.execute的时候多个线程是非阻塞的异步执行，可能还没等到线程执行完的时候就直接返回结果了，大部分情况会出现是integer的最大值。改进的办法是在遍历时去取阻塞队列中的值后再执行set操作，因为在get取阻塞队列中的值的过程是一个阻塞，最后在利用线程池的非阻塞异步操作去保存结果。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448092,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556284403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}