{"id":424550,"title":"13 | Spark SQL：让我们从“小汽车摇号分析”开始","content":"<p>你好，我是吴磊。</p><p>在开篇词我们提出“入门Spark需要三步走”，到目前为止，我们携手并肩跨越了前面两步，首先恭喜你学到这里！熟练掌握了Spark常用算子与核心原理以后，你已经可以轻松应对大部分数据处理需求了。</p><p>不过，数据处理毕竟是比较基础的数据应用场景，就像赛车有着不同的驾驶场景，想成为Spark的资深赛车手，我们还要走出第三步——学习Spark计算子框架。只有完成这一步，我们才能掌握Spark SQL，Structured Streaming和Spark MLlib的常规开发方法，游刃有余地应对不同的数据应用场景，如数据分析、流计算和机器学习，等等。</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/a3/6a56c520ab7666d1bb9dd1f0683346a3.jpg?wh=1920x915\" alt=\"图片\" title=\"还差第三步\"></p><p>那这么多子框架，从哪里入手比较好呢？在所有的子框架中，Spark SQL是代码量最多、Spark社区投入最大、应用范围最广、影响力最深远的那个。就子框架的学习来说，我们自然要从Spark SQL开始。</p><p>今天我们从一个例子入手，在实战中带你熟悉数据分析开发的思路和实现步骤。有了对Spark SQL的直观体验，我们后面几讲还会深入探讨Spark SQL的用法、特性与优势，让你逐步掌握Spark SQL的全貌。</p><h2>业务需求</h2><p>今天我们要讲的小例子，来自于北京市小汽车摇号。我们知道，为了限制机动车保有量，从2011年开始，北京市政府推出了小汽车摇号政策。随着摇号进程的推进，在2016年，为了照顾那些长时间没有摇中号码牌的“准司机”，摇号政策又推出了“倍率”制度。</p><!-- [[[read_end]]] --><p>所谓倍率制度，它指的是，结合参与摇号次数，为每个人赋予不同的倍率系数。有了倍率加持，大家的中签率就由原来整齐划一的基础概率，变为“<strong>基础概率 * 倍率系数</strong>”。参与摇号的次数越多，倍率系数越大，中签率也会相应得到提高。</p><p>不过，身边无数的“准司机”总是跟我说，其实倍率这玩意没什么用，背了8倍、10倍的倍率，照样摇不上！那么今天这一讲，咱们就来借着学习Spark SQL的机会，用数据来为这些还没摸过车的“老司机”答疑解惑，帮他们定量地分析一下，倍率与中签率之间，到底有没有关系？</p><h2>准备工作</h2><p>巧妇难为无米之炊，既然是做数据分析，那咱们得先有数据才行。我这边为你准备了2011年到2019年北京市小汽车的摇号数据，你可以通过<a href=\"https://pan.baidu.com/s/1Vys1Z1mofQFoU52ye7SKuw\">这个地址</a>，从网盘进行下载，提取码为ajs6。</p><p>这份数据的文件名是“2011-2019 小汽车摇号数据.tar.gz”，解压之后的目录结构如下图所示。</p><p>可以看到，根目录下有apply和lucky两个子目录，apply目录的内容是 2011-2019 年各个批次参与摇号的申请号码，而lucky目录包含的是各个批次中签的申请号码。为了叙述方便，我们把参与过摇号的人叫“申请者”，把中签的人叫“中签者”。apply和lucky的下一级子目录是各个摇号批次，而摇号批次目录下包含的是Parquet格式的数据文件。</p><p><img src=\"https://static001.geekbang.org/resource/image/65/93/659f18d2e1c851byye56553cbcff7b93.jpg?wh=1920x1389\" alt=\"图片\" title=\"数据的目录结构\"></p><p>数据下载、解压完成之后，接下来，我们再来准备运行环境。</p><p>咱们的小例子比较轻量，Scala版本的代码实现不会超过20行，再者摇号数据体量很小，解压之后的Parquet文件总大小也不超过4G。</p><p>选择这样的例子也是为了轻装上阵，避免你因为硬件限制而难以实验。想要把用于分析倍率的应用跑起来，你在笔记本或是PC上，通过启动本地spark-shell环境就可以。不过，如果条件允许的话，我还是鼓励你搭建分布式的物理集群。关于分布式集群的搭建细节，你可以参考<a href=\"https://time.geekbang.org/column/article/419200\">第4讲</a>。</p><p>好啦，准备好数据与运行环境之后，接下来，我们就可以步入正题，去开发探索倍率与中签率关系的数据分析应用啦。</p><h2>数据探索</h2><p>不过，先别忙着直接上手数据分析。在此之前，我们先要对数据模式（Data Schema）有最基本的认知，也就是源数据都有哪些字段，这些字段的类型和含义分别是什么，这一步就是我们常说的数据探索。</p><p>数据探索的思路是这样的：首先，我们使用SparkSession的read API读取源数据、创建DataFrame。然后，通过调用DataFrame的show方法，我们就可以轻松获取源数据的样本数据，从而完成数据的初步探索，代码如下所示。</p><pre><code class=\"language-scala\">import org.apache.spark.sql.DataFrame\n&nbsp;\nval rootPath: String = _\n// 申请者数据\nval hdfs_path_apply: String = s\"${rootPath}/apply\"\n// spark是spark-shell中默认的SparkSession实例\n// 通过read API读取源文件\nval applyNumbersDF: DataFrame = spark.read.parquet(hdfs_path_apply)\n// 数据打印\napplyNumbersDF.show\n&nbsp;\n// 中签者数据\nval hdfs_path_lucky: String = s\"${rootPath}/lucky\"\n// 通过read API读取源文件\nval luckyDogsDF: DataFrame = spark.read.parquet(hdfs_path_lucky)\n// 数据打印\nluckyDogsDF.show\n</code></pre><p>看到这里，想必你已经眉头紧锁：“SparkSession？DataFrame？这些都是什么鬼？你好像压根儿也没有提到过这些概念呀！”别着急，对于这些关键概念，我们在后续的课程中都会陆续展开，今天这一讲，咱们先来“知其然”，“知其所以然”的部分咱们放到后面去讲。</p><p>对于SparkSession，你可以把它理解为是SparkContext的进阶版，是Spark（2.0版本以后）新一代的开发入口。SparkContext通过textFile API把源数据转换为RDD，而SparkSession通过read API把源数据转换为DataFrame。</p><p>而DataFrame，你可以把它看作是一种特殊的RDD。RDD我们已经很熟悉了，现在就把DataFrame跟RDD做个对比，让你先对DataFrame有个感性认识。</p><p>先从功能分析，与RDD一样，DataFrame也用来封装分布式数据集，它也有数据分区的概念，也是通过算子来实现不同DataFrame之间的转换，只不过DataFrame采用了一套与RDD算子不同的独立算子集。</p><p>再者，在数据内容方面，与RDD不同，DataFrame是一种带Schema的分布式数据集，因此，你可以简单地把DataFrame看作是数据库中的一张二维表。</p><p>最后，DataFrame背后的计算引擎是Spark SQL，而RDD的计算引擎是Spark Core，这一点至关重要。不过，关于计算引擎之间的差异，我们留到<a href=\"https://time.geekbang.org/column/article/425322\">下一讲</a>再去展开。</p><p>好啦，言归正传。简单了解了SparkSession与DataFrame的概念之后，我们继续来看数据探索。</p><p>把上述代码丢进spark-shell之后，分别在applyNumbersDF和luckyDogsDF这两个DataFrame之上调用show函数，我们就可以得到样本数据。可以看到，“这两张表”的Schema是一样的，它们都包含两个字段，一个是String类型的carNum，另一个是类型为Int的batchNum。</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/c5/b490801c4fd89yy7d3bab83539bb36c5.jpg?wh=1467x998\" alt=\"图片\" title=\"源数据的样本数据\"></p><p>其中，carNum的含义是申请号码、或是中签号码，而batchNum则代表摇号批次，比如201906表示2019年的最后一批摇号，201401表示2014年的第一次摇号。</p><p>好啦，进行到这里，初步的数据探索工作就告一段落了。</p><h2>业务需求实现</h2><p>完成初步的数据探索之后，我们就可以结合数据特点（比如两张表的Schema完全一致，但数据内容的范畴不同），来实现最开始的业务需求：计算中签率与倍率之间的量化关系。</p><p>首先，既然是要量化中签率与倍率之间的关系，我们只需要关注那些中签者（lucky目录下的数据）的倍率变化就好了。而倍率的计算，要依赖apply目录下的摇号数据。因此，要做到仅关注中签者的倍率，我们就必须要使用数据关联这个在数据分析领域中最常见的操作。此外，由于倍率制度自2016年才开始推出，所以我们只需要访问2016年以后的数据即可。</p><p>基于以上这些分析，我们先把数据过滤与数据关联的代码写出来，如下所示。</p><pre><code class=\"language-scala\">// 过滤2016年以后的中签数据，且仅抽取中签号码carNum字段\nval filteredLuckyDogs: DataFrame = luckyDogsDF.filter(col(\"batchNum\") &gt;= \"201601\").select(\"carNum\")\n&nbsp;\n// 摇号数据与中签数据做内关联，Join Key为中签号码carNum\nval jointDF: DataFrame = applyNumbersDF.join(filteredLuckyDogs, Seq(\"carNum\"), \"inner\")\n</code></pre><p>在上面的代码中，我们使用filter算子对luckyDogsDF做过滤，然后使用select算子提取carNum字段。</p><p>紧接着，我们在applyNumbersDF之上调用join算子，从而完成两个DataFrame的数据关联。join算子有3个参数，你可以对照前面代码的第5行来理解，这里第一个参数用于指定需要关联的DataFrame，第二个参数代表Join Key，也就是依据哪些字段做关联，而第三个参数指定的是关联形式，比如inner表示内关联，left表示左关联，等等。</p><p>做完数据关联之后，接下来，我们再来说一说，倍率应该怎么统计。对于倍率这个数值，官方的实现略显粗暴，如果去观察 apply 目录下 2016 年以后各个批次的文件，你就会发现，所谓的倍率，实际上就是申请号码的副本数量。</p><p>比如说，我的倍率是8，那么在各个批次的摇号文件中，我的申请号码就会出现8次。是不是很粗暴？因此，要统计某个申请号码的倍率，我们只需要统计它在批次文件中出现的次数就可以达到目的。</p><p>按照批次、申请号码做统计计数，是不是有种熟悉的感觉？没错，这不就是我们之前学过的Word Count吗？它本质上其实就是一个分组计数的过程。不过，这一次，咱们不再使用reduceByKey这个RDD算子了，而是使用DataFrame的那套算子来实现，我们先来看代码。</p><pre><code class=\"language-scala\">val multipliers: DataFrame = jointDF.groupBy(col(\"batchNum\"),col(\"carNum\"))\n.agg(count(lit(1)).alias(\"multiplier\"))\n</code></pre><p>分组计数</p><p>对照代码我给你分析下思路，我们先是用groupBy算子来按照摇号批次和申请号码做分组，然后通过agg和count算子把（batchNum，carNum）出现的次数，作为carNum在摇号批次batchNum中的倍率，并使用alias算子把倍率重命名为“multiplier”。</p><p>这么说可能有点绕，我们可以通过在multipliers之上调用show函数，来直观地观察这一步的计算结果。为了方便说明，我用表格的形式来进行示意。</p><p><img src=\"https://static001.geekbang.org/resource/image/73/dd/73735ac4ec0bc22f4d79153ae38954dd.jpg?wh=1878x1007\" alt=\"图片\" title=\"multipliers计算结果示意图\"></p><p>可以看到，同一个申请号码，在不同批次中的倍率是不一样的。就像我们之前说的，随着摇号的次数增加，倍率也会跟着提升。不过，这里咱们要研究的是倍率与中签率的关系，所以只需要关心中签者是在多大的倍率下中签的就行。因此，对于同一个申请号码，我们只需要保留其中最大的倍率就可以了。</p><p>需要说明的是，取最大倍率的做法，会把倍率的统计基数变小，从而引入幸存者偏差。更严谨的做法，应该把中签者过往的倍率也都统计在内，这样倍率的基数才是准确的。不过呢，结合实验，幸存者偏差并不影响“倍率与中签率是否有直接关系”这一结论。因此，咱们不妨采用取最大倍率这种更加简便的做法。毕竟，学习Spark SQL，才是咱们的首要目标。</p><p>为此，我们需要“抹去”batchNum这个维度，按照carNum对multipliers做分组，并提取倍率的最大值，代码如下所示。</p><pre><code class=\"language-scala\">val uniqueMultipliers: DataFrame = multipliers.groupBy(\"carNum\")\n.agg(max(\"multiplier\").alias(\"multiplier\"))\n</code></pre><p>分组聚合的方法跟前面差不多，我们还是先用groupBy做分组，不过这次仅用carNum一个字段做分组，然后使用agg和max算子来保留倍率最大值。经过这一步的计算之后，我们就得到了每个申请号码在中签之前的倍率系数：</p><p><img src=\"https://static001.geekbang.org/resource/image/63/d0/633fc65203b70b8528544a14a09633d0.jpg?wh=1920x506\" alt=\"图片\"></p><p>可以看到，uniqueMultipliers这个DataFrame仅包含申请号码carNum和倍率multiplier这两个字段，且carNum字段不存在重复值，也就是说，在这份数据集中，一个申请号码，只有一个最大倍率与之对应。</p><p>好啦，到此为止，我们拿到了每一个中签者，在中签之前的倍率系数。接下来，结合这份数据，我们就可以统计倍率本身的分布情况。</p><p>具体来说，我们想知道的是，不同倍率之下的人数分布是什么样子的。换句话说，这一次，我们要<strong>按照倍率来对数据做分组</strong>，然后计算不同倍率下的统计计数。不用说，这次咱们还是得仰仗groupBy和agg这两个算子，代码如下所示。</p><pre><code class=\"language-scala\">val result: DataFrame = uniqueMultipliers.groupBy(\"multiplier\")\n.agg(count(lit(1)).alias(\"cnt\"))\n.orderBy(\"multiplier\")\n&nbsp;\nresult.collect\n</code></pre><p>在最后一步，我们依然使用groupBy和agg算子如法炮制，得到按照倍率统计的人数分布之后，我们通过collect算子来收集计算结果，并同时触发上述的所有代码从头至尾交付执行。</p><p>计算结果result包含两个字段，一个是倍率，一个是持有该倍率的统计人数。如果把result结果数据做成柱状图的话，我们可以更加直观地观察到中签率与倍率之间的关系，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/93/417b1430b64a7c305cb07fb49d3aa993.png?wh=1212x454\" alt=\"图片\" title=\"倍率分布\"></p><p>不难发现，不同倍率下的中签者人数，呈现出正态分布。也即是说，对于一个申请者来说，他/她有幸摇中的概率，并不会随着倍率的增加而线性增长。用身边那些“老司机”的话说，中签这件事，确实跟倍率的关系不大。</p><h2>重点回顾</h2><p>今天这一讲，我们一起动手，开发了“倍率的统计分布”这个数据分析应用，并解答了中签率与倍率之间是否存在关联关系这一难题。</p><p>尽管在实现的过程中，我们遇到了一些新概念和新的算子，但你不必担心，更不必着急。今天这节课，你只需要对Spark SQL框架下的应用开发有一个感性的认识就可以了。</p><p>在Spark SQL的开发框架下，我们通常是通过SparkSession的read API从源数据创建DataFrame。然后，以DataFrame为入口，在DataFrame之上调用各式各样的转换算子，如agg、groupBy、select、filter等等，对DataFrame进行转换，进而完成相应的数据分析。</p><p>为了后续试验方便，我把今天涉及的代码片段整理到了一起，你可以把它们丢进spark-shell去运行，观察每个环节的计算结果，体会不同算子的计算逻辑与执行结果之间的关系。加油，祝你好运！</p><pre><code class=\"language-scala\">import org.apache.spark.sql.DataFrame\n&nbsp;\nval rootPath: String = _\n// 申请者数据\nval hdfs_path_apply: String = s\"${rootPath}/apply\"\n// spark是spark-shell中默认的SparkSession实例\n// 通过read API读取源文件\nval applyNumbersDF: DataFrame = spark.read.parquet(hdfs_path_apply)\n&nbsp;\n// 中签者数据\nval hdfs_path_lucky: String = s\"${rootPath}/lucky\"\n// 通过read API读取源文件\nval luckyDogsDF: DataFrame = spark.read.parquet(hdfs_path_lucky)\n&nbsp;\n// 过滤2016年以后的中签数据，且仅抽取中签号码carNum字段\nval filteredLuckyDogs: DataFrame = luckyDogsDF.filter(col(\"batchNum\") &gt;= \"201601\").select(\"carNum\")\n&nbsp;\n// 摇号数据与中签数据做内关联，Join Key为中签号码carNum\nval jointDF: DataFrame = applyNumbersDF.join(filteredLuckyDogs, Seq(\"carNum\"), \"inner\")\n&nbsp;\n// 以batchNum、carNum做分组，统计倍率系数\nval multipliers: DataFrame = jointDF.groupBy(col(\"batchNum\"),col(\"carNum\"))\n.agg(count(lit(1)).alias(\"multiplier\"))\n&nbsp;\n// 以carNum做分组，保留最大的倍率系数\nval uniqueMultipliers: DataFrame = multipliers.groupBy(\"carNum\")\n.agg(max(\"multiplier\").alias(\"multiplier\"))\n&nbsp;\n// 以multiplier倍率做分组，统计人数\nval result: DataFrame = uniqueMultipliers.groupBy(\"multiplier\")\n.agg(count(lit(1)).alias(\"cnt\"))\n.orderBy(\"multiplier\")\n&nbsp;\nresult.collect\n</code></pre><h2>每课一练</h2><p>1.脑洞时间：你觉得汽车摇号的倍率制度应该怎样设计，才是最合理的？</p><p>2.请在你的Spark环境中把代码运行起来，并确认执行结果是否与result一致。</p><p>欢迎你在留言区跟我交流互动，也推荐你把这一讲的内容分享给更多的朋友、同事。我们下一讲见！</p>","comments":[{"had_liked":false,"id":315864,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1634025578,"is_pvip":true,"replies":[{"id":"114520","content":"老弟分析得鞭辟入里~<br><br>官方的倍率设计，确实比较粗糙，统计下来，结论实际上也不是十分牢靠。咱们这里用小汽车摇号的例子，初衷还是找一个大家都熟悉的场景，来更好地学习Spark SQL的开发流程~ ","user_name":"作者回复","comment_id":315864,"uid":"1043100","ip_address":"","utype":1,"ctime":1634137095,"user_name_real":"吴磊"}],"discussion_count":2,"race_medal":0,"score":"40288731242","product_id":100090001,"comment_content":"spark无关。讨论下摇号。<br><br>评论区有匿名读者质疑文中的结论。这里尝试换个角度代入具体的数字分析下。<br><br>简单起见，假设每轮摇号有1000人中签，并且倍率和轮次一致，即第一轮大家都是1倍，第一轮没中的人在第二轮变为2倍，第二轮又没中的人到了第三轮就变成3倍，依次类推。<br><br>先看第一轮的1000个中签者，显然他们的倍率都是1，没有其他倍率的中签者，记为:<br><br>[1000, 0, 0, ...]<br><br>再看第二轮的1000个中签者。由于新加入的申请者倍率为1，第一轮未中的人倍率为2。按照倍率摇号的话，期望的结果就是，倍率为2的中签人数是倍率为1的中签人数的2倍，记为：<br><br>[333, 667, 0, 0, ...]<br><br>以此类推，第三轮就是：<br><br>[167, 333, 500, 0, 0, ...]<br><br>尝试摇个10轮，可以得到下表：<br><br>[1000, 0, 0, ...]<br>[333, 667, 0, 0, ...]<br>[167, 333, 500, 0, 0, ...]<br>[100, 200, 300, 400, 0, 0, ...]<br>[67, 133, 200, 267, 333, 0, 0, ...]<br>[48, 95, 143, 190, 238, 286, 0, 0, ...]<br>[36, 71, 107, 143, 179, 214, 250, 0, 0, ...]<br>[28, 56, 83, 111, 139, 167, 194, 222, 0, 0, ...]<br>[22, 44, 67, 89, 111, 133, 156, 178, 200, 0, 0, ...]<br>[18, 36, 55, 73, 91, 109, 127, 145, 164, 182, 0, 0, ...]<br><br>可以看到在每一轮的中签者中，确实是倍率越高中签的人数越多。<br><br>而文中的统计方法，相当于把这张表按列求和：<br><br>[1819, 1635, 1455, 1273, 1091, 909, 727, 545, 364, 182, 0, 0, ...]<br><br>可以看到这是一条单调递减的曲线。然而却不能像文中一样得出“中签率没有随着倍率增加”的结论。高倍率的中签人数比低倍率的人数少，是因为能达到高倍率的人本身就少。比如上面例子中，10轮过后10倍率的中签者只有182人，是因为前9轮没有人能达到10倍率。相比之下，在第一轮就有1000个1倍率的人中签。<br><br>至于文中配图为什么会是一条类似钟型的曲线，猜测可能第一次引入倍率摇号的时候，就已经给不同的人分配不同的倍率了，而不是大家一开始都是1倍率。在上面的例子中，如果只对后5轮求和，可以得到：<br><br>[152, 302, 455, 606, 758, 909, 727, 545, 364, 182]<br><br>这样就和文中的配图比较接近了。<br><br>所以结论就是要验证中签率和倍率的关系，不能按照倍率去累加中签人数，而是要看单次摇号中不同倍率的中签者的分布。","like_count":10,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528186,"discussion_content":"老弟分析得鞭辟入里~\n\n官方的倍率设计，确实比较粗糙，统计下来，结论实际上也不是十分牢靠。咱们这里用小汽车摇号的例子，初衷还是找一个大家都熟悉的场景，来更好地学习Spark SQL的开发流程~ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634137095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405051,"discussion_content":"尝试看了下单轮摇号中签者的倍率分布：\n\nmultipliers.filter(col(&#34;batchNum&#34;) === &#34;201906&#34;).groupBy(&#34;multiplier&#34;).agg(count(lit(1)).alias(&#34;count&#34;)).orderBy(&#34;multiplier&#34;).show\n+----------+-----+                                                              \n|multiplier|count|\n+----------+-----+\n|         1|  107|\n|         2|  244|\n|         3|  391|\n|         4|  585|\n|         5|  746|\n|         6|  829|\n|         7|  677|\n|         8|  712|\n|         9|  789|\n|        10|  530|\n|        11|  436|\n|        12|  338|\n+----------+-----+\n\n这就只能呵呵了...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634484580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318343,"user_name":"Alvin-L","can_delete":false,"product_type":"c1","uid":1603052,"ip_address":"","ucode":"5AC96AAB75B720","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/ec/c60b29f5.jpg","comment_is_top":false,"comment_ctime":1635250472,"is_pvip":false,"replies":[{"id":"115463","content":"赞👍，感谢老弟整理Python代码~","user_name":"作者回复","comment_id":318343,"uid":"1043100","ip_address":"","utype":1,"ctime":1635260418,"user_name_real":"吴磊"}],"discussion_count":2,"race_medal":0,"score":"14520152360","product_id":100090001,"comment_content":"```<br>import os<br>from pyspark import SparkContext, SparkConf<br>from pyspark.sql.session import SparkSession<br>from pyspark.sql.functions import first, collect_list, mean, count, max<br>import matplotlib.pyplot as plt<br><br>def plot(res):<br>    x = [x[&quot;multiplier&quot;] for x in res]<br>    y = [y[&quot;cnt&quot;] for y in res]<br>    plt.figure(figsize=(8, 5), dpi=100)<br>    plt.xlabel(&#39;倍率&#39;)<br>    plt.ylabel(&#39;人数&#39;)<br>    plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;] <br>    plt.rcParams[&#39;axes.unicode_minus&#39;]=False<br>    plt.bar(x, y, width=0.5)<br>    plt.xticks(x)<br>    plt.show()<br><br># py文件就在项目的根目录下<br>rootPath = os.path.split(os.path.realpath(__file__))[0]<br><br>conf = SparkConf()<br>conf.set(&#39;spark.executor.memory&#39;, &#39;4g&#39;)<br>conf.set(&#39;spark.driver.memory&#39;, &#39;8g&#39;)<br>conf.set(&quot;spark.executor.cores&quot;, &#39;4&#39;)<br>conf.set(&#39;spark.cores.max&#39;, 16)<br>conf.set(&#39;spark.local.dir&#39;, rootPath)<br>spark = SparkSession(SparkContext(conf=conf))<br># 申请者数据<br># Windows环境<br># 注意点1：增加 option(&quot;basePath&quot;, rootPath) 选项<br># 注意点2：路径 hdfs_path_apply 需要追加 &#47;*&#47;*.parquet<br>hdfs_path_apply = rootPath + &quot;&#47;apply&quot;<br>applyNumbersDF = spark.read.option(&quot;basePath&quot;, rootPath).parquet(<br>    hdfs_path_apply + &quot;&#47;*&#47;*.parquet&quot;<br>)<br># 中签者数据<br>hdfs_path_lucky = rootPath + &quot;&#47;lucky&quot;<br>luckyDogsDF = spark.read.option(&quot;basePath&quot;, rootPath).parquet(<br>    hdfs_path_lucky + &quot;&#47;*&#47;*.parquet&quot;<br>)<br># 过滤2016年以后的中签数据，且仅抽取中签号码carNum字段<br>filteredLuckyDogs = (<br>    luckyDogsDF<br>    .filter(luckyDogsDF[&quot;batchNum&quot;] &gt;= &quot;201601&quot;)<br>    .select(&quot;carNum&quot;)<br>)<br># 摇号数据与中签数据做内关联，Join Key为中签号码carNum<br>jointDF = applyNumbersDF.join(filteredLuckyDogs, &quot;carNum&quot;, &quot;inner&quot;)<br># 以batchNum、carNum做分组，统计倍率系数<br>multipliers = (<br>    jointDF<br>    .groupBy([&quot;batchNum&quot;, &quot;carNum&quot;])<br>    .agg(count(&quot;batchNum&quot;).alias(&quot;multiplier&quot;))<br>)<br># 以carNum做分组，保留最大的倍率系数<br>uniqueMultipliers = (<br>    multipliers<br>    .groupBy(&quot;carNum&quot;)<br>    .agg(max(&quot;multiplier&quot;).alias(&quot;multiplier&quot;))<br>)<br># 以multiplier倍率做分组，统计人数<br>result = (<br>    uniqueMultipliers<br>    .groupBy(&quot;multiplier&quot;)<br>    .agg(count(&quot;carNum&quot;).alias(&quot;cnt&quot;))<br>    .orderBy(&quot;multiplier&quot;)<br>)<br>result.show(40)<br>res = result.collect()<br># 画图<br>plot(res)<br>```","like_count":4,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529199,"discussion_content":"赞👍，感谢老弟整理Python代码~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635260418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603052,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/ec/c60b29f5.jpg","nickname":"Alvin-L","note":"","ucode":"5AC96AAB75B720","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408641,"discussion_content":"请问老师2个问题：\n1（我在Windows环境下）为什么我直接使用parquet(hdfs_path_apply)的时候会报错，提示“如果提供的路径是分区路径，那么请在数据源的option中设置“basePath”来单独指定表的根路径；如果根路径不同，那么就分别加载数据，然后采用union的方式加数据合并。”，而且hdfs_path_apply要追加&#34;/*/*.parquet&#34;才能正常读取，不加的话也会报错。\n2运行后生成的blockmgr-xxxxx文件夹有8G大，为什么没有随程序完结而清除掉？是不是有哪些设置没有设对导致。\n谢谢老师。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635297254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341611,"user_name":"翡翠小南瓜","can_delete":false,"product_type":"c1","uid":1068242,"ip_address":"","ucode":"92503E54E106CD","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/d2/f12dd0ac.jpg","comment_is_top":false,"comment_ctime":1649734491,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5944701787","product_id":100090001,"comment_content":"不懂北京的摇号规则，也没写清楚，所以是一个批次号里面，一个申请号可以有多次？？？？","like_count":1,"discussions":[{"author":{"id":1260911,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3d/6f/3a97712e.jpg","nickname":"林Curry","note":"","ucode":"55FA1EE95A484F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580191,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657968070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340797,"user_name":"Spoon","can_delete":false,"product_type":"c1","uid":1959822,"ip_address":"","ucode":"2FF9193AD482C2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","comment_is_top":false,"comment_ctime":1649148070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5944115366","product_id":100090001,"comment_content":"Java实现<br>https:&#47;&#47;github.com&#47;Spoon94&#47;spark-practice&#47;blob&#47;master&#47;src&#47;main&#47;java&#47;com&#47;spoon&#47;spark&#47;sql&#47;CarNumAnalyseJob.java","like_count":2},{"had_liked":false,"id":321114,"user_name":"东围居士","can_delete":false,"product_type":"c1","uid":2144966,"ip_address":"","ucode":"0FDAC3E3053837","user_header":"https://static001.geekbang.org/account/avatar/00/20/ba/c6/10448065.jpg","comment_is_top":false,"comment_ctime":1636683287,"is_pvip":false,"replies":[{"id":"116620","content":"棒👍，感谢！~","user_name":"作者回复","comment_id":321114,"uid":"1043100","ip_address":"","utype":1,"ctime":1636701414,"user_name_real":"吴磊"}],"discussion_count":2,"race_medal":0,"score":"5931650583","product_id":100090001,"comment_content":"补一个完整的 spark 代码（windows环境）：<br><br>package spark.basic<br><br>import org.apache.spark.sql.functions.{col,count, lit, max}<br>import org.apache.spark.sql.{DataFrame, SparkSession}<br><br>object Chapter13 {<br>    def main(args: Array[String]): Unit = {<br><br>        val spark: SparkSession = SparkSession.builder().master(&quot;local[*]&quot;).appName(&quot;Chapter13&quot;).getOrCreate()<br>        import spark.implicits._<br><br>        val rootPath: String = &quot;E:\\\\temp\\\\yaohao_home\\\\yaohao&quot;<br>        &#47;&#47; 申请者数据<br>        val hdfs_path_apply: String = s&quot;${rootPath}&#47;apply&quot;<br>        &#47;&#47; spark是spark-shell中默认的SparkSession实例<br>        &#47;&#47; 通过read API读取源文件<br>        val applyNumbersDF: DataFrame = spark.read.option(&quot;basePath&quot;, rootPath).parquet(hdfs_path_apply + &quot;&#47;*&#47;*.parquet&quot;)<br><br>        &#47;&#47; 中签者数据<br>        val hdfs_path_lucky: String = s&quot;${rootPath}&#47;lucky&quot;<br>        &#47;&#47; 通过read API读取源文件<br>        val luckyDogsDF: DataFrame = spark.read.option(&quot;basePath&quot;, rootPath).parquet(hdfs_path_lucky + &quot;&#47;*&#47;*.parquet&quot;)<br><br>        &#47;&#47; 过滤2016年以后的中签数据，且仅抽取中签号码carNum字段<br>        val filteredLuckyDogs: DataFrame = luckyDogsDF.filter(col(&quot;batchNum&quot;) &gt;= &quot;201601&quot;).select(&quot;carNum&quot;)<br><br>        &#47;&#47; 摇号数据与中签数据做内关联，Join Key为中签号码carNum<br>        val jointDF: DataFrame = applyNumbersDF.join(filteredLuckyDogs, Seq(&quot;carNum&quot;), &quot;inner&quot;)<br><br>        &#47;&#47; 以batchNum、carNum做分组，统计倍率系数<br>        val multipliers: DataFrame = jointDF.groupBy(col(&quot;batchNum&quot;),col(&quot;carNum&quot;))<br>            .agg(count(lit(1)).alias(&quot;multiplier&quot;))<br><br>        &#47;&#47; 以carNum做分组，保留最大的倍率系数<br>        val uniqueMultipliers: DataFrame = multipliers.groupBy(&quot;carNum&quot;)<br>            .agg(max(&quot;multiplier&quot;).alias(&quot;multiplier&quot;))<br><br>        &#47;&#47; 以multiplier倍率做分组，统计人数<br>        val result: DataFrame = uniqueMultipliers.groupBy(&quot;multiplier&quot;)<br>            .agg(count(lit(1)).alias(&quot;cnt&quot;))<br>            .orderBy(&quot;multiplier&quot;)<br><br>        result.collect<br>        result.show()<br>    }<br>}<br>","like_count":1,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530220,"discussion_content":"棒👍，感谢！~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636701414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2845437,"avatar":"","nickname":"Geek5763","note":"","ucode":"D4C8CAEABAA925","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542758,"discussion_content":"感谢，一直无法读取数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640835367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317760,"user_name":"火炎焱燚","can_delete":false,"product_type":"c1","uid":2767491,"ip_address":"","ucode":"DB11784DD94059","user_header":"https://static001.geekbang.org/account/avatar/00/2a/3a/83/74e3fabd.jpg","comment_is_top":false,"comment_ctime":1634951052,"is_pvip":false,"replies":[{"id":"115455","content":"赞👍！！！感谢老弟~ 后续收录到GitHub~","user_name":"作者回复","comment_id":317760,"uid":"1043100","ip_address":"","utype":1,"ctime":1635258574,"user_name_real":"吴磊"}],"discussion_count":2,"race_medal":0,"score":"5929918348","product_id":100090001,"comment_content":"对应的python代码为：<br><br># 在notebook上运行时，加上下面的配置<br>from pyspark import SparkContext, SparkConf<br>from pyspark.sql.session import SparkSession<br><br>sc_conf = SparkConf() # spark参数配置<br># sc_conf.setMaster()<br># sc_conf.setAppName(&#39;my-app&#39;)<br>sc_conf.set(&#39;spark.executor.memory&#39;, &#39;2g&#39;) <br>sc_conf.set(&#39;spark.driver.memory&#39;, &#39;4g&#39;) <br>sc_conf.set(&quot;spark.executor.cores&quot;, &#39;2&#39;) <br>sc_conf.set(&#39;spark.cores.max&#39;, 20)    <br>sc = SparkContext(conf=sc_conf)<br><br># 加载数据，转换成dataframe<br>rootPath=&#39;~~&#47;RawData&#39;<br>hdfs_path_apply=rootPath+&#39;&#47;apply&#39;<br>spark = SparkSession(sc)<br>applyNumbersDF=spark.read.parquet(hdfs_path_apply)<br># applyNumbersDF.show() # 打印出前几行数据，查看数据结构<br><br>hdfs_path_lucky=rootPath+&#39;&#47;lucky&#39;<br>luckyDogsDF=spark.read.parquet(hdfs_path_lucky)<br># luckyDogsDF.show()<br><br>filteredLuckyDogs=luckyDogsDF.filter(luckyDogsDF[&#39;batchNum&#39;]&gt;=&#39;201601&#39;).select(&#39;carNum&#39;)<br>jointDF=applyNumbersDF.join(filteredLuckyDogs,&#39;carNum&#39;,&#39;inner&#39;)<br># join函数消耗内存较大，容易出现OOM错误，如果出错，要将spark.driver.memory调大<br># jointDF.show() # 打印出join之后的df部分数据<br><br># 进行多种groupBy操作<br>from pyspark.sql import functions as f<br>multipliers=jointDF.groupBy([&#39;batchNum&#39;,&#39;carNum&#39;]).agg(f.count(&#39;batchNum&#39;).alias(&quot;multiplier&quot;))<br># multipliers.show()<br><br>uniqueMultipliers=multipliers.groupBy(&#39;carNum&#39;).agg(f.max(&#39;multiplier&#39;).alias(&#39;multiplier&#39;))<br># uniqueMultipliers.show()<br><br>result=uniqueMultipliers.groupBy(&#39;multiplier&#39;).agg(f.count(&#39;carNum&#39;).alias(&#39;cnt&#39;)).orderBy(&#39;multiplier&#39;)<br>result2=result.collect()<br><br># 绘图<br>import matplotlib.pyplot as plt<br>x=[i[&#39;multiplier&#39;] for i in result2]<br>y=[i[&#39;cnt&#39;] for i in result2]<br>plt.bar(x,y)","like_count":1,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528958,"discussion_content":"赞👍！！！感谢老弟~ 后续收录到GitHub~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635258574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","nickname":"xxx","note":"","ucode":"E79CEA70430449","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544989,"discussion_content":"厉害厉害，我用Scala执行的时候老是OOM，增大executor memory也没用，原来是driver memory不够…… 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641796773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315196,"user_name":"Geek_d447af","can_delete":false,"product_type":"c1","uid":2800059,"ip_address":"","ucode":"A86EC7A2B3CE0A","user_header":"","comment_is_top":false,"comment_ctime":1633747560,"is_pvip":false,"replies":[{"id":"114411","content":"支持的，不需要Hadoop，spark-shell本地就能跑","user_name":"作者回复","comment_id":315196,"uid":"1043100","ip_address":"","utype":1,"ctime":1633962050,"user_name_real":"吴磊"}],"discussion_count":2,"race_medal":0,"score":"5928714856","product_id":100090001,"comment_content":"文章里的代码需要在 Hadoop 环境才能跑起来，spark 本身不支持解析 parquet 文件","like_count":1,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527898,"discussion_content":"支持的，不需要Hadoop，spark-shell本地就能跑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633962050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2845437,"avatar":"","nickname":"Geek5763","note":"","ucode":"D4C8CAEABAA925","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":542786,"discussion_content":"老师应该考虑一下使用windows local跑的同学，简单说明一下。如果没有评论区同学的代码，就正确读取文件数据这一步就得搞半天呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640845417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":527898,"ip_address":""},"score":542786,"extra":""}]}]},{"had_liked":false,"id":351591,"user_name":"林Curry","can_delete":false,"product_type":"c1","uid":1260911,"ip_address":"","ucode":"55FA1EE95A484F","user_header":"https://static001.geekbang.org/account/avatar/00/13/3d/6f/3a97712e.jpg","comment_is_top":false,"comment_ctime":1657968320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657968320","product_id":100090001,"comment_content":"val multipliers: DataFrame = jointDF.groupBy(col(&quot;batchNum&quot;),col(&quot;carNum&quot;)).agg(count(lit(1)).alias(&quot;multiplier&quot;))<br><br>老师，有点没有看懂倍率的计算方式，以batchNum和carNum两个字段groupby的话，计算的不就是申请号在各个批次中出现的次数么？ 难道一个申请号还会在同个批次中出现多次吗","like_count":0},{"had_liked":false,"id":349149,"user_name":"杨帅","can_delete":false,"product_type":"c1","uid":1684811,"ip_address":"","ucode":"0A558B1BA62E44","user_header":"","comment_is_top":false,"comment_ctime":1655775263,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655775263","product_id":100090001,"comment_content":"老师，本地报错 类似Caused by: java.io.IOException: Failed to connect to &#47;192.168.1.3:50561，这个一般是什么问题？","like_count":0},{"had_liked":false,"id":342341,"user_name":"爱学习的王呱呱","can_delete":false,"product_type":"c1","uid":2962972,"ip_address":"","ucode":"F6703C9B1FE6DF","user_header":"https://static001.geekbang.org/account/avatar/00/2d/36/1c/adfeb6c4.jpg","comment_is_top":false,"comment_ctime":1650201781,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650201781","product_id":100090001,"comment_content":"join的时候一直提示：【No offset index for column carNum is available; Unable to do filtering】网上没搜到，求大佬们帮忙看看原因<br><br>sc = SparkContext()<br>spark = SparkSession(sc)<br>root_path = &quot;&#47;Users&#47;admin&#47;Documents&#47;2011-2019小汽车摇号数据&quot;<br><br>hdfs_path_apply = root_path + &quot;&#47;apply&quot;<br>applyDF = spark.read.parquet(hdfs_path_apply).select(&quot;carNum&quot;)<br># applyDF.show()<br><br>hdfs_path_lucky = root_path + &quot;&#47;lucky&quot;<br>lucyDF = spark.read.parquet(hdfs_path_lucky)<br># lucyDF.show()<br><br><br>lucy_car_num = lucyDF.filter(lucyDF[&#39;batchNum&#39;] &gt;= &#39;201601&#39;).select(&#39;carNum&#39;)<br>all_car_num = applyDF.join(lucy_car_num, &quot;carNum&quot;, &quot;inner&quot;)<br>all_car_num.show()","like_count":0},{"had_liked":false,"id":341070,"user_name":"Geek_9d1801","can_delete":false,"product_type":"c1","uid":2071326,"ip_address":"","ucode":"FCC96B3673A8BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIfxu4yQEXdQ3icro8QEb0W3Rk014YXqibgw28kAcezVGy0DJzkERd1gXh5uEKL42VnnwomelvgPMDA/132","comment_is_top":false,"comment_ctime":1649327174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649327174","product_id":100090001,"comment_content":"apply&#47;batchNum=201905&#47;part-00001-f8bb8e7b-904f-42a7-a616-a413406f06fb.c000.snappy.parquet is not a Parquet file. expected magic number at tail [80, 65, 82, 49] but found [14, 14, 14, 14]<br>没有人报这个错误吗？是什么问题？","like_count":0},{"had_liked":false,"id":332581,"user_name":"lightning_女巫","can_delete":false,"product_type":"c1","uid":1935728,"ip_address":"","ucode":"A6C5B15933A62E","user_header":"","comment_is_top":false,"comment_ctime":1643354143,"is_pvip":true,"replies":[{"id":"121994","content":"从stacktrace来看，报错原因是shuffle write过程中，写shuffle中间文件的时候报错，老弟检查一下spark.local.dir配置的文件系统目录空间是否足够，如果该配置项没有配置的话，Spark默认把中间文件写入到文件系统的&#47;tmp目录，这个目录一般来说空间都不大，很容易写爆的","user_name":"作者回复","comment_id":332581,"uid":"1043100","ip_address":"","utype":1,"ctime":1644671672,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1643354143","product_id":100090001,"comment_content":"我在本地跑这个代码碰到了如下错误，请问如何解决？<br>22&#47;01&#47;28 15:13:22 ERROR BypassMergeSortShuffleWriter: Error while deleting file &#47;private&#47;var&#47;folders&#47;hk&#47;7j9sqdtn55j3cq_gv5qvp5pm39d49n&#47;T&#47;blockmgr-88ef94e9-943a-4971-a3a8-33d25949886f&#47;1a&#47;temp_shuffle_e0e163fb-852c-4298-b08e-dc4989277ab3<br>22&#47;01&#47;28 15:13:22 ERROR DiskBlockObjectWriter: Uncaught exception while reverting partial writes to file &#47;private&#47;var&#47;folders&#47;hk&#47;7j9sqdtn55j3cq_gv5qvp5pm39d49n&#47;T&#47;blockmgr-88ef94e9-943a-4971-a3a8-33d25949886f&#47;08&#47;temp_shuffle_6c160c23-3395-445f-be03-b29a375e1139<br>java.io.FileNotFoundException: &#47;private&#47;var&#47;folders&#47;hk&#47;7j9sqdtn55j3cq_gv5qvp5pm39d49n&#47;T&#47;blockmgr-88ef94e9-943a-4971-a3a8-33d25949886f&#47;08&#47;temp_shuffle_6c160c23-3395-445f-be03-b29a375e1139 (No such file or directory)<br>\tat java.io.FileOutputStream.open0(Native Method)<br>\tat java.io.FileOutputStream.open(FileOutputStream.java:270)<br>\tat java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:213)<br>\tat org.apache.spark.storage.DiskBlockObjectWriter$$anonfun$revertPartialWritesAndClose$2.apply$mcV$sp(DiskBlockObjectWriter.scala:217)<br>\tat org.apache.spark.util.Utils$.tryWithSafeFinally(Utils.scala:1369)<br>\tat org.apache.spark.storage.DiskBlockObjectWriter.revertPartialWritesAndClose(DiskBlockObjectWriter.scala:214)<br>\tat org.apache.spark.shuffle.sort.BypassMergeSortShuffleWriter.stop(BypassMergeSortShuffleWriter.java:237)<br>\tat org.apache.spark.scheduler.ShuffleMapTask.runTask(ShuffleMapTask.scala:105)<br>\tat org.apache.spark.scheduler.ShuffleMapTask.runTask(ShuffleMapTask.scala:55)<br>\tat org.apache.spark.scheduler.Task.run(Task.scala:123)<br>\tat org.apache.spark.executor.Executor$TaskRunner$$anonfun$10.apply(Executor.scala:408)<br>\tat org.apache.spark.util.Utils$.tryWithSafeFinally(Utils.scala:1360)<br>\tat org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:414)<br>\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)<br>\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)<br>\tat java.lang.Thread.run(Thread.java:748)","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550689,"discussion_content":"从stacktrace来看，报错原因是shuffle write过程中，写shuffle中间文件的时候报错，老弟检查一下spark.local.dir配置的文件系统目录空间是否足够，如果该配置项没有配置的话，Spark默认把中间文件写入到文件系统的/tmp目录，这个目录一般来说空间都不大，很容易写爆的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644671672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317598,"user_name":"东围居士","can_delete":false,"product_type":"c1","uid":2144966,"ip_address":"","ucode":"0FDAC3E3053837","user_header":"https://static001.geekbang.org/account/avatar/00/20/ba/c6/10448065.jpg","comment_is_top":false,"comment_ctime":1634867704,"is_pvip":false,"replies":[{"id":"115135","content":"老弟加我微信吧，搜索“方块K”或是“rJunior”，我QQ邮箱大邮件发你~ 加微信是确保你收到了~","user_name":"作者回复","comment_id":317598,"uid":"1043100","ip_address":"","utype":1,"ctime":1634889825,"user_name_real":"吴磊"}],"discussion_count":3,"race_medal":0,"score":"1634867704","product_id":100090001,"comment_content":"老师，数据文件方便存一份到别的地方吗，比如马云家的网盘，或者做个种子下载什么的，百度网盘那速度真的是，我下到下午下班过周末都下不完","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528890,"discussion_content":"老弟加我微信吧，搜索“方块K”或是“rJunior”，我QQ邮箱大邮件发你~ 加微信是确保你收到了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634889825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690884,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cd/04/e27b7803.jpg","nickname":"小新","note":"","ucode":"DCAD04665E2CF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535068,"discussion_content":"强烈建议使用阿里云盘","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638345061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2144966,"avatar":"https://static001.geekbang.org/account/avatar/00/20/ba/c6/10448065.jpg","nickname":"东围居士","note":"","ucode":"0FDAC3E3053837","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407016,"discussion_content":"下载完啦。不过遇到另外的问题了，就是如果用 spark.read.parquet() 直接读解压到本地的 apply 文件夹会报错 \nscala> spark.read.parquet(&#34;file:///mnt/e/temp/yaohao/apply&#34;)\njava.lang.AssertionError: assertion failed: Conflicting directory structures detected. Suspicious paths:?\n        file:/mnt/e/temp/yaohao/apply\n        file:/mnt/e/temp/yaohao/apply/paxheader\n\nIf provided paths are partition directories, please set &#34;basePath&#34; in the options of the data source to specify the root directory of the table. If there are multiple root directories, please load them separately and then union them.\n  at scala.Predef$.assert(Predef.scala:223)\n  at org.apache.spark.sql.execution.datasources.PartitioningUtils$.parsePartitions(PartitioningUtils.scala:172)\n  at org.apache.spark.sql.execution.datasources.PartitioningUtils$.parsePartitions(PartitioningUtils.scala:104)\n  at org.apache.spark.sql.execution.datasources.PartitioningAwareFileIndex.inferPartitioning(PartitioningAwareFileIndex.scala:161)\n  at org.apache.spark.sql.execution.datasources.InMemoryFileIndex.partitionSpec(InMemoryFileIndex.scala:77)\n  at org.apache.spark.sql.execution.datasources.PartitioningAwareFileIndex.partitionSchema(PartitioningAwareFileIndex.scala:50)\n  at org.apache.spark.sql.execution.datasources.DataSource.getOrInferFileFormatSchema(DataSource.scala:157)\n  at org.apache.spark.sql.execution.datasources.DataSource.resolveRelation(DataSource.scala:408)\n  at org.apache.spark.sql.DataFrameReader.loadV1Source(DataFrameReader.scala:297)\n  at org.apache.spark.sql.DataFrameReader.$anonfun$load$2(DataFrameReader.scala:286)\n  at scala.Option.getOrElse(Option.scala:189)\n  at org.apache.spark.sql.DataFrameReader.load(DataFrameReader.scala:286)\n  at org.apache.spark.sql.DataFrameReader.parquet(DataFrameReader.scala:755)\n  at org.apache.spark.sql.DataFrameReader.parquet(DataFrameReader.scala:733)\n  ... 47 elided","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634892690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315682,"user_name":"Geek_995b78","can_delete":false,"product_type":"c1","uid":2758010,"ip_address":"","ucode":"F9BD1C78366081","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/w74m73icotZZEiasC6VzRUytfkFkgyYCGAcz16oBWuMXueWOxxVuAnH6IHaZFXkj5OqwlVO1fnocvn9gGYh8gGcw/132","comment_is_top":false,"comment_ctime":1633944480,"is_pvip":false,"replies":[{"id":"114407","content":"实际上就是常数1，更准确地说，是表示一个常数列，这列的数值都是1。只不过Spark SQL这里的语法比较特殊，其实和Scala没什么关系哈~","user_name":"作者回复","comment_id":315682,"uid":"1043100","ip_address":"","utype":1,"ctime":1633961894,"user_name_real":"吴磊"}],"discussion_count":2,"race_medal":0,"score":"1633944480","product_id":100090001,"comment_content":"用scala实现，lit(1)是什么意思呀","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528146,"discussion_content":"实际上就是常数1，更准确地说，是表示一个常数列，这列的数值都是1。只不过Spark SQL这里的语法比较特殊，其实和Scala没什么关系哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633961894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2758010,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/w74m73icotZZEiasC6VzRUytfkFkgyYCGAcz16oBWuMXueWOxxVuAnH6IHaZFXkj5OqwlVO1fnocvn9gGYh8gGcw/132","nickname":"Geek_995b78","note":"","ucode":"F9BD1C78366081","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404312,"discussion_content":"好的，谢谢老师。其实这段代码是在做count(1)，只不过Spark Sql 的写法是 count(lit(1)) 是吧？可以这么理解吗 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634284870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315150,"user_name":"GAC·DU","can_delete":false,"product_type":"c1","uid":1385403,"ip_address":"","ucode":"7847FBE1C13740","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/bb/a1a61f7c.jpg","comment_is_top":false,"comment_ctime":1633703655,"is_pvip":true,"replies":[{"id":"114412","content":"赞👍~","user_name":"作者回复","comment_id":315150,"uid":"1043100","ip_address":"","utype":1,"ctime":1633962076,"user_name_real":"吴磊"}],"discussion_count":1,"race_medal":0,"score":"1633703655","product_id":100090001,"comment_content":"result具体数值：<br>scala&gt; result.collect<br>res7: Array[org.apache.spark.sql.Row] = Array([1,8967], [2,19174], [3,26952], [4,29755], [5,32988], [6,34119], [7,29707], [8,26123], [9,19476], [10,9616], [11,3930], [12,1212])","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527881,"discussion_content":"赞👍~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633962076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315063,"user_name":"Neo-dqy","can_delete":false,"product_type":"c1","uid":1924786,"ip_address":"","ucode":"9BF300EB1DDD00","user_header":"https://static001.geekbang.org/account/avatar/00/1d/5e/b2/aceb3e41.jpg","comment_is_top":false,"comment_ctime":1633677302,"is_pvip":false,"replies":[{"id":"114413","content":"lit(1)表示常数列，这列的数值都是1，是Spark SQL的语法，跟Scala无关哈~<br><br>倍率制度确实需要更好的设计~ 不过也别放弃，哈哈，万一哪天摇上了呢~","user_name":"作者回复","comment_id":315063,"uid":"1043100","ip_address":"","utype":1,"ctime":1633962214,"user_name_real":"吴磊"}],"discussion_count":1,"race_medal":0,"score":"1633677302","product_id":100090001,"comment_content":"【.agg(count(lit(1)).alias(&quot;cnt&quot;))】问下老师，这里count中的lit(1)是什么意思啊？<br>对于汽车摇号的倍率制度，如果为了优先让倍率高的人摇到号，可以把每一期的资格分多次抽取。就是说，先构建一个所有人都在里面的样本，抽部分人；再将倍率高于某个阈值的人都取出来，构建一个新的样本，再抽取部分人。（具体划分成几个样本可以按倍率的人数分布来划分）当然这样又会对新来的人不公平，所以大家还是挤地铁吧~~","like_count":0,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527865,"discussion_content":"lit(1)表示常数列，这列的数值都是1，是Spark SQL的语法，跟Scala无关哈~\n\n倍率制度确实需要更好的设计~ 不过也别放弃，哈哈，万一哪天摇上了呢~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633962214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}