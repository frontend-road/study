{"id":103724,"title":"40 | IPC（上）：不同项目组之间抢资源，如何协调？","content":"<p>我们前面讲了，如果项目组之间需要紧密合作，那就需要共享内存，这样就像把两个项目组放在一个会议室一起沟通，会非常高效。这一节，我们就来详细讲讲这个进程之间共享内存的机制。</p><p>有了这个机制，两个进程可以像访问自己内存中的变量一样，访问共享内存的变量。但是同时问题也来了，当两个进程共享内存了，就会存在同时读写的问题，就需要对于共享的内存进行保护，就需要信号量这样的同步协调机制。这些也都是我们这节需要探讨的问题。下面我们就一一来看。</p><p>共享内存和信号量也是System V系列的进程间通信机制，所以很多地方和我们讲过的消息队列有点儿像。为了将共享内存和信号量结合起来使用，我这里定义了一个share.h头文件，里面放了一些共享内存和信号量在每个进程都需要的函数。</p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/ipc.h&gt;\n#include &lt;sys/shm.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/sem.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_NUM 128\n\nstruct shm_data {\n  int data[MAX_NUM];\n  int datalength;\n};\n\nunion semun {\n  int val; \n  struct semid_ds *buf; \n  unsigned short int *array; \n  struct seminfo *__buf; \n}; \n\nint get_shmid(){\n  int shmid;\n  key_t key;\n  \n  if((key = ftok(&quot;/root/sharememory/sharememorykey&quot;, 1024)) &lt; 0){\n      perror(&quot;ftok error&quot;);\n          return -1;\n  }\n  \n  shmid = shmget(key, sizeof(struct shm_data), IPC_CREAT|0777);\n  return shmid;\n}\n\nint get_semaphoreid(){\n  int semid;\n  key_t key;\n  \n  if((key = ftok(&quot;/root/sharememory/semaphorekey&quot;, 1024)) &lt; 0){\n      perror(&quot;ftok error&quot;);\n          return -1;\n  }\n  \n  semid = semget(key, 1, IPC_CREAT|0777);\n  return semid;\n}\n\nint semaphore_init (int semid) {\n  union semun argument; \n  unsigned short values[1]; \n  values[0] = 1; \n  argument.array = values; \n  return semctl (semid, 0, SETALL, argument); \n}\n\nint semaphore_p (int semid) {\n  struct sembuf operations[1]; \n  operations[0].sem_num = 0; \n  operations[0].sem_op = -1; \n  operations[0].sem_flg = SEM_UNDO; \n  return semop (semid, operations, 1); \n}\n\nint semaphore_v (int semid) {\n  struct sembuf operations[1]; \n  operations[0].sem_num = 0; \n  operations[0].sem_op = 1; \n  operations[0].sem_flg = SEM_UNDO; \n  return semop (semid, operations, 1); \n} \n</code></pre><h2>共享内存</h2><p>我们先来看里面对于共享内存的操作。</p><p>首先，创建之前，我们要有一个key来唯一标识这个共享内存。这个key可以根据文件系统上的一个文件的inode随机生成。</p><p>然后，我们需要创建一个共享内存，就像创建一个消息队列差不多，都是使用xxxget来创建。其中，创建共享内存使用的是下面这个函数：</p><pre><code>int shmget(key_t key, size_t size, int shmflag);\n</code></pre><p>其中，key就是前面生成的那个key，shmflag如果为IPC_CREAT，就表示新创建，还可以指定读写权限0777。</p><!-- [[[read_end]]] --><p>对于共享内存，需要指定一个大小size，这个一般要申请多大呢？一个最佳实践是，我们将多个进程需要共享的数据放在一个struct里面，然后这里的size就应该是这个struct的大小。这样每一个进程得到这块内存后，只要强制将类型转换为这个struct类型，就能够访问里面的共享数据了。</p><p>在这里，我们定义了一个struct shm_data结构。这里面有两个成员，一个是一个整型的数组，一个是数组中元素的个数。</p><p>生成了共享内存以后，接下来就是将这个共享内存映射到进程的虚拟地址空间中。我们使用下面这个函数来进行操作。</p><pre><code>void *shmat(int  shm_id, const  void *addr, int shmflg);\n</code></pre><p>这里面的shm_id，就是上面创建的共享内存的id，addr就是指定映射在某个地方。如果不指定，则内核会自动选择一个地址，作为返回值返回。得到了返回地址以后，我们需要将指针强制类型转换为struct shm_data结构，就可以使用这个指针设置data和datalength了。</p><p>当共享内存使用完毕，我们可以通过shmdt解除它到虚拟内存的映射。</p><pre><code>int shmdt(const  void *shmaddr)；\n</code></pre><h2>信号量</h2><p>看完了共享内存，接下来我们再来看信号量。信号量以集合的形式存在的。</p><p>首先，创建之前，我们同样需要有一个key，来唯一标识这个信号量集合。这个key同样可以根据文件系统上的一个文件的inode随机生成。</p><p>然后，我们需要创建一个信号量集合，同样也是使用xxxget来创建，其中创建信号量集合使用的是下面这个函数。</p><pre><code>int semget(key_t key, int nsems, int semflg);\n</code></pre><p>这里面的key，就是前面生成的那个key，shmflag如果为IPC_CREAT，就表示新创建，还可以指定读写权限0777。</p><p>这里，nsems表示这个信号量集合里面有几个信号量，最简单的情况下，我们设置为1。</p><p>信号量往往代表某种资源的数量，如果用信号量做互斥，那往往将信号量设置为1。这就是上面代码中semaphore_init函数的作用，这里面调用semctl函数，将这个信号量集合的中的第0个信号量，也即唯一的这个信号量设置为1。</p><p>对于信号量，往往要定义两种操作，P操作和V操作。对应上面代码中semaphore_p函数和semaphore_v函数，semaphore_p会调用semop函数将信号量的值减一，表示申请占用一个资源，当发现当前没有资源的时候，进入等待。semaphore_v会调用semop函数将信号量的值加一，表示释放一个资源，释放之后，就允许等待中的其他进程占用这个资源。</p><p>我们可以用这个信号量，来保护共享内存中的struct shm_data，使得同时只有一个进程可以操作这个结构。</p><p>你是否记得咱们讲线程同步机制的时候，构建了一个老板分配活的场景。这里我们同样构建一个场景，分为producer.c和consumer.c，其中producer也即生产者，负责往struct shm_data塞入数据，而consumer.c负责处理struct shm_data中的数据。</p><p>下面我们来看producer.c的代码。</p><pre><code>#include &quot;share.h&quot;\n\nint main() {\n  void *shm = NULL;\n  struct shm_data *shared = NULL;\n  int shmid = get_shmid();\n  int semid = get_semaphoreid();\n  int i;\n  \n  shm = shmat(shmid, (void*)0, 0);\n  if(shm == (void*)-1){\n    exit(0);\n  }\n  shared = (struct shm_data*)shm;\n  memset(shared, 0, sizeof(struct shm_data));\n  semaphore_init(semid);\n  while(1){\n    semaphore_p(semid);\n    if(shared-&gt;datalength &gt; 0){\n      semaphore_v(semid);\n      sleep(1);\n    } else {\n      printf(&quot;how many integers to caculate : &quot;);\n      scanf(&quot;%d&quot;,&amp;shared-&gt;datalength);\n      if(shared-&gt;datalength &gt; MAX_NUM){\n        perror(&quot;too many integers.&quot;);\n        shared-&gt;datalength = 0;\n        semaphore_v(semid);\n        exit(1);\n      }\n      for(i=0;i&lt;shared-&gt;datalength;i++){\n        printf(&quot;Input the %d integer : &quot;, i);\n        scanf(&quot;%d&quot;,&amp;shared-&gt;data[i]);\n      }\n      semaphore_v(semid);\n    }\n  }\n}\n</code></pre><p>在这里面，get_shmid创建了共享内存，get_semaphoreid创建了信号量集合，然后shmat将共享内存映射到了虚拟地址空间的shm指针指向的位置，然后通过强制类型转换，shared的指针指向放在共享内存里面的struct shm_data结构，然后初始化为0。semaphore_init将信号量进行了初始化。</p><p>接着，producer进入了一个无限循环。在这个循环里面，我们先通过semaphore_p申请访问共享内存的权利，如果发现datalength大于零，说明共享内存里面的数据没有被处理过，于是semaphore_v释放权利，先睡一会儿，睡醒了再看。如果发现datalength等于0，说明共享内存里面的数据被处理完了，于是开始往里面放数据。让用户输入多少个数，然后每个数是什么，都放在struct shm_data结构中，然后semaphore_v释放权利，等待其他的进程将这些数拿去处理。</p><p>我们再来看consumer的代码。</p><pre><code>#include &quot;share.h&quot;\n\nint main() {\n  void *shm = NULL;\n  struct shm_data *shared = NULL;\n  int shmid = get_shmid();\n  int semid = get_semaphoreid();\n  int i;\n  \n  shm = shmat(shmid, (void*)0, 0);\n  if(shm == (void*)-1){\n    exit(0);\n  }\n  shared = (struct shm_data*)shm;\n  while(1){\n    semaphore_p(semid);\n    if(shared-&gt;datalength &gt; 0){\n      int sum = 0;\n      for(i=0;i&lt;shared-&gt;datalength-1;i++){\n        printf(&quot;%d+&quot;,shared-&gt;data[i]);\n        sum += shared-&gt;data[i];\n      }\n      printf(&quot;%d&quot;,shared-&gt;data[shared-&gt;datalength-1]);\n      sum += shared-&gt;data[shared-&gt;datalength-1];\n      printf(&quot;=%d\\n&quot;,sum);\n      memset(shared, 0, sizeof(struct shm_data));\n      semaphore_v(semid);\n    } else {\n      semaphore_v(semid);\n      printf(&quot;no tasks, waiting.\\n&quot;);\n      sleep(1);\n    }\n  }\n}\n</code></pre><p>在这里面，get_shmid获得producer创建的共享内存，get_semaphoreid获得producer创建的信号量集合，然后shmat将共享内存映射到了虚拟地址空间的shm指针指向的位置，然后通过强制类型转换，shared的指针指向放在共享内存里面的struct shm_data结构。</p><p>接着，consumer进入了一个无限循环，在这个循环里面，我们先通过semaphore_p申请访问共享内存的权利，如果发现datalength等于0，就说明没什么活干，需要等待。如果发现datalength大于0，就说明有活干，于是将datalength个整型数字从data数组中取出来求和。最后将struct shm_data清空为0，表示任务处理完毕，通过semaphore_v释放权利。</p><p>通过程序创建的共享内存和信号量集合，我们可以通过命令ipcs查看。当然，我们也可以通过ipcrm进行删除。</p><pre><code># ipcs\n------ Message Queues --------\nkey        msqid      owner      perms      used-bytes   messages    \n------ Shared Memory Segments --------\nkey        shmid      owner      perms      bytes      nattch     status      \n0x00016988 32768      root       777        516        0             \n------ Semaphore Arrays --------\nkey        semid      owner      perms      nsems     \n0x00016989 32768      root       777        1 \n</code></pre><p>下面我们来运行一下producer和consumer，可以得到下面的结果：</p><pre><code># ./producer \nhow many integers to caculate : 2\nInput the 0 integer : 3\nInput the 1 integer : 4\nhow many integers to caculate : 4\nInput the 0 integer : 3\nInput the 1 integer : 4\nInput the 2 integer : 5\nInput the 3 integer : 6\nhow many integers to caculate : 7\nInput the 0 integer : 9\nInput the 1 integer : 8\nInput the 2 integer : 7\nInput the 3 integer : 6\nInput the 4 integer : 5\nInput the 5 integer : 4\nInput the 6 integer : 3\n\n# ./consumer \n3+4=7\n3+4+5+6=18\n9+8+7+6+5+4+3=42\n</code></pre><h2>总结时刻</h2><p>这一节的内容差不多了，我们来总结一下。共享内存和信号量的配合机制，如下图所示：</p><ul>\n<li>无论是共享内存还是信号量，创建与初始化都遵循同样流程，通过ftok得到key，通过xxxget创建对象并生成id；</li>\n<li>生产者和消费者都通过shmat将共享内存映射到各自的内存空间，在不同的进程里面映射的位置不同；</li>\n<li>为了访问共享内存，需要信号量进行保护，信号量需要通过semctl初始化为某个值；</li>\n<li>接下来生产者和消费者要通过semop(-1)来竞争信号量，如果生产者抢到信号量则写入，然后通过semop(+1)释放信号量，如果消费者抢到信号量则读出，然后通过semop(+1)释放信号量；</li>\n<li>共享内存使用完毕，可以通过shmdt来解除映射。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/46/0b/469552bffe601d594c432d4fad97490b.png?wh=2383*2206\" alt=\"\"></p><h2>课堂练习</h2><p>信号量大于1的情况下，应该如何使用？你可以试着构建一个场景。</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","comments":[{"had_liked":false,"id":108472,"user_name":"Amark","can_delete":false,"product_type":"c1","uid":1121326,"ip_address":"","ucode":"E5F48633654002","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/2e/93812642.jpg","comment_is_top":false,"comment_ctime":1561778984,"is_pvip":false,"replies":[{"id":"48827","content":"以task，在内核里面，进程和线程都是task","user_name":"作者回复","comment_id":108472,"uid":"1001590","ip_address":"","utype":1,"ctime":1567499967,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"53101386536","product_id":100024701,"comment_content":"请教一个问题，CPU调度是以进程为单位的吗，还是以线程?","like_count":13,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455993,"discussion_content":"以task，在内核里面，进程和线程都是task","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567499967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108391,"user_name":"莫名","can_delete":false,"product_type":"c1","uid":1007254,"ip_address":"","ucode":"E28F2602BA25DD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","comment_is_top":false,"comment_ctime":1561736604,"is_pvip":false,"replies":[{"id":"48831","content":"赞","user_name":"作者回复","comment_id":108391,"uid":"1001590","ip_address":"","utype":1,"ctime":1567500081,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"31626507676","product_id":100024701,"comment_content":"System V IPC具有很好的移植性，但缺点也比较明显，不能接口自成一套，难以使用现有的fd操作函数。建议对比讲一下比较流行的POSIX IPC。","like_count":8,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455948,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567500081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108866,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1561905452,"is_pvip":false,"replies":[{"id":"48817","content":"是的","user_name":"作者回复","comment_id":108866,"uid":"1001590","ip_address":"","utype":1,"ctime":1567499059,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10151840044","product_id":100024701,"comment_content":"信号量大于1的情况，可以让进程不操作共享变量，比如操作不同的变量，比如对一批数据做操作，然后做完之后给消费端读取","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456142,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567499059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108152,"user_name":"Tianz","can_delete":false,"product_type":"c1","uid":1248212,"ip_address":"","ucode":"4B6542604B8B6F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/d4/39763233.jpg","comment_is_top":false,"comment_ctime":1561687095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151621687","product_id":100024701,"comment_content":"超哥，现在是不是推荐使用 POSIX 系列的 IPC 呢？","like_count":2},{"had_liked":false,"id":334607,"user_name":"当你的世界里有风吹过","can_delete":false,"product_type":"c1","uid":2051946,"ip_address":"","ucode":"42712891366309","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4f/6a/0a6b437e.jpg","comment_is_top":false,"comment_ctime":1645017998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5939985294","product_id":100024701,"comment_content":"信号量大于1，可以用于限流。如线程或进程的个数，访问请求的个数等。","like_count":2},{"had_liked":false,"id":159503,"user_name":"艾瑞克小霸王","can_delete":false,"product_type":"c1","uid":1674555,"ip_address":"","ucode":"58FCCAC0F675E1","user_header":"https://static001.geekbang.org/account/avatar/00/19/8d/3b/42d9c669.jpg","comment_is_top":false,"comment_ctime":1575640361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870607657","product_id":100024701,"comment_content":"信号量和锁的区别就是 信号量可以控制资源数量（&gt;1）, 而锁是 互斥排他的？","like_count":1},{"had_liked":false,"id":128469,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1053390,"ip_address":"","ucode":"ABB3F1A63E102A","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","comment_is_top":false,"comment_ctime":1566884652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5861851948","product_id":100024701,"comment_content":"这篇看的很明白，嘿嘿。","like_count":1},{"had_liked":false,"id":108270,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1561709213,"is_pvip":false,"replies":[{"id":"48835","content":"这个不行，大于1的时候，不能排他，但是可以控制资源","user_name":"作者回复","comment_id":108270,"uid":"1001590","ip_address":"","utype":1,"ctime":1567500324,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"5856676509","product_id":100024701,"comment_content":"信号量大于 1 的情况下，应该如何使用？<br>可以让多个进程同时访问一个共享内存。","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455895,"discussion_content":"这个不行，大于1的时候，不能排他，但是可以控制资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567500324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1077406,"avatar":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","nickname":"jaryoung","note":"","ucode":"6E72D107DB7E51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":539300,"discussion_content":"控制资源的意思是否是这样子？\n例如，信号量为3，总共搞三块共享内存变量，0、1、2分别对应，不同的信号量能够操作不同的资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639663274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":455895,"ip_address":""},"score":539300,"extra":""}]}]},{"had_liked":false,"id":251098,"user_name":"Geek_93a721","can_delete":false,"product_type":"c1","uid":2040594,"ip_address":"","ucode":"0168AEA57AF4EF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4Gr57Aia5McdvyQco8hKpaibeeYUhQcMtaFhNtHESSF7MPq5OdQBQpCBYicl7Libt6MjWKNJvmGwODA/132","comment_is_top":false,"comment_ctime":1601364402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601364402","product_id":100024701,"comment_content":"如果大于1时，应该使用三个信号量，一个表示任务这种资源，一个表示空间这种资源，第三个将其置为1用于互斥访问。","like_count":0},{"had_liked":false,"id":141055,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1571107592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571107592","product_id":100024701,"comment_content":"信号量大于1的时候应该就不能控制写操作了。应该是控制读操作的进程数量。","like_count":0},{"had_liked":false,"id":128854,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1053390,"ip_address":"","ucode":"ABB3F1A63E102A","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","comment_is_top":false,"comment_ctime":1566976221,"is_pvip":false,"replies":[{"id":"48753","content":"是的，创建一个就行","user_name":"作者回复","comment_id":128854,"uid":"1001590","ip_address":"","utype":1,"ctime":1567494357,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"1566976221","product_id":100024701,"comment_content":"老师好，ftok提示我的机器里没有“&#47;root&#47;sharememory&#47;semaphorekey”这个文件，我随便新建一个文件可以吗？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465136,"discussion_content":"是的，创建一个就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567494357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476675,"avatar":"https://static001.geekbang.org/account/avatar/00/16/88/43/31641bf0.jpg","nickname":"布朗老熊","note":"","ucode":"A8AF82550AFF9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6855,"discussion_content":"可以，在含有semaphorekey的文件夹下，pwd获得路径，用新路径替换/root/sharememory/semaphorekey路径就搞定了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567144102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111180,"user_name":"trllllllll","can_delete":false,"product_type":"c1","uid":1134649,"ip_address":"","ucode":"976B8BBA802A6D","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/39/14adb0f0.jpg","comment_is_top":false,"comment_ctime":1562499877,"is_pvip":false,"replies":[{"id":"46746","content":"谢谢指正","user_name":"作者回复","comment_id":111180,"uid":"1001590","ip_address":"","utype":1,"ctime":1566388075,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1562499877","product_id":100024701,"comment_content":"老师，share.h 里面 include 了两次 ipc.h。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457268,"discussion_content":"谢谢指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566388075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108475,"user_name":"Amark","can_delete":false,"product_type":"c1","uid":1121326,"ip_address":"","ucode":"E5F48633654002","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/2e/93812642.jpg","comment_is_top":false,"comment_ctime":1561779476,"is_pvip":false,"replies":[{"id":"48826","content":"内存，变量，文件，都是共享的呀","user_name":"作者回复","comment_id":108475,"uid":"1001590","ip_address":"","utype":1,"ctime":1567499943,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1561779476","product_id":100024701,"comment_content":"如果线程是掉用的到基本单位，那么进程的共享资源呢?","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455995,"discussion_content":"内存，变量，文件，都是共享的呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567499943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}