{"id":813382,"title":"08｜基于Raft协议构建分布式集群（二）","content":"<blockquote>\n<p><span class=\"reference\">本课程为精品小课，不标配音频</span></p>\n</blockquote><p>你好，我是文强。</p><p>这节课我们继续完善基于 Raft 协议开发的分布式集群，我们会完成存储层和网络层这两部分的开发。接上节课的内容，我们首先来看一下 RaftMachineStorage 的实现逻辑。</p><h2>Raft 存储层：RaftMachineStorage</h2><p>从代码上看，RaftMachineStorage 的作用是<strong>使用 RocksDB 来持久化存储 Raft 运行数据</strong>。由于 RaftMachineStorage 的代码较多，这里我就不把全部代码贴出来了，建议你先去看一下文件<a href=\"https://github.com/robustmq/robustmq-geek/blob/main/src/placement-center/src/storage/raft.rs\">《RaftMachineStorage》</a>中的代码。</p><p>下面这张图是 RaftMachineStorage 的功能列表。</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/4a/fe0d4abcfdecb8d609b444e96aa2484a.png?wh=1084x1364\" alt=\"图片\"></p><p>从函数名称中可以知道，RaftMachineStorage 的功能就是对 Entry、HardState、ConfState、First Index、Last Idnex、Uncommit Index、Snapshot 等数据进行读写。</p><p>因为 RocksDB 是 KV 存储模型，因此我们需要先定义保存数据的 Key。来看下面这段代码：</p><pre><code class=\"language-plain\">// 存储未过期的第一个Entry的Index\npub fn key_name_by_first_index() -&gt; String {\n    return \"/raft/first_index\".to_string();\n}\n\n\n// 存储最新的一个 Entry 的Index\npub fn key_name_by_last_index() -&gt; String {\n    return \"/raft/last_index\".to_string();\n}\n\n\n// 保存 Raft 元数据 HardState\npub fn key_name_by_hard_state() -&gt; String {\n    return \"/raft/hard_state\".to_string();\n}\n\n\n// 保存 Raft 元数据 ConfState\npub fn key_name_by_conf_state() -&gt; String {\n    return \"/raft/conf_state\".to_string();\n}\n\n\n// 根据Entry的 Index 保存Entry 信息\npub fn key_name_by_entry(idx: u64) -&gt; String {\n    return format!(\"/raft/entry/{}\", idx);\n}\n\n\n// 保存未正常 commit 的index列表\npub fn key_name_uncommit() -&gt; String {\n    return \"/raft/uncommit_index\".to_string();\n}\n\n\n// 保存快照信息\npub fn key_name_snapshot() -&gt; String {\n    return \"/raft/snapshot\".to_string();\n}\n\n\n</code></pre><!-- [[[read_end]]] --><p>在这段代码中，我们分别为保存 First Index、Last Index、HardState、ConfState、Entry、Uncommit、Snapshot 设计了保存的 Key。 因此你也就需要了解 Raft 运行过程中需要保存的这些数据。</p><p>从逻辑上来看，这些数据可以分为 <strong>Entry</strong>、<strong>Raft 运行状态</strong>、<strong>快照</strong>三个类型。接下来我们来看这些数据的写入实现，因为读取类操作比较简单，就不展开了。先来看Entry。</p><pre><code class=\"language-plain\">  pub fn append(&amp;mut self, entrys: &amp;Vec&lt;Entry&gt;) -&gt; RaftResult&lt;()&gt; {\n        \n        // 如果 Entry 为空，则不保存\n        if entrys.len() == 0 {\n            return Ok(());\n        }\n      \n        // 判断 Entry 列表中的 index 是否符合规范\n        let entry_first_index = entrys[0].index;\n\n\n        let first_index = self.first_index();\n        if first_index &gt; entry_first_index {\n            panic!(\n                \"overwrite compacted raft logs, compacted: {}, append: {}\",\n                first_index - 1,\n                entry_first_index,\n            );\n        }\n\n\n        let last_index = self.last_index();\n        if last_index + 1 &lt; entry_first_index {\n            panic!(\n                \"raft logs should be continuous, last index: {}, new appended: {}\",\n                last_index, entry_first_index,\n            );\n        }\n\n\n        // 循环保存 Entry\n        for entry in entrys {\n            debug!(\"&gt;&gt; save entry index:{}, value:{:?}\", entry.index, entry);\n            // 将 Entry 转化为 Vec 类型\n            let data: Vec&lt;u8&gt; = Entry::encode_to_vec(&amp;entry);\n            // 将 Entry 保存在名为  /raft/entry/{index} 的 key 中\n            let key = key_name_by_entry(entry.index);\n            self.rocksdb_engine_handler\n                .write(self.rocksdb_engine_handler.cf_cluster(), &amp;key, &amp;data)\n                .unwrap();\n            // 更新未 commit 的 index信息\n            self.uncommit_index.insert(entry.index, 1);\n            // 更新 last index\n            self.save_last_index(entry.index).unwrap();\n        }\n        \n        // 持久化存储未 commit 的 index\n        self.save_uncommit_index();\n        return Ok(());\n    }\n</code></pre><p>上面这段代码的功能是：<strong>接收 Entry 列表并保存</strong>。主要代码都加了注释，我们总结下核心逻辑：</p><ol>\n<li>\n<p>首先进行数据校验，判断 Entry 列表是否为空，以及 Entry 对应的 index 是否可用。</p>\n</li>\n<li>\n<p>循环以 /raft/entry/{index} 为 Key，在 RocksDB 中持久化保存 Entry，同时更新 last index 信息。</p>\n</li>\n<li>\n<p>因为 Entry 保存后，属于 uncommit 的数据，所以需要将 Entry 对应的 index 暂存到 uncomit 列表。</p>\n</li>\n</ol><p>完成了这三步就完成了 Entry 和 Uncommit Index 的存储，同时也更新了最新的 Last Index。因为 Entry 是会过期的，所以当 Entry 过期时，First Index 也会被更新。</p><p>再来看 Raft 运行状态的写入实现。在上节课我们知道，Raft 运行状态主要是 HardfState 和 ConfState 两个数据，来看它的代码实现。</p><pre><code class=\"language-plain\">\n\npub fn save_hard_state(&amp;self, hs: HardState) -&gt; Result&lt;(), String&gt; {\n   let key = key_name_by_hard_state();\n   let val = HardState::encode_to_vec(&amp;hs);\n   self.rocksdb_engine_handler\n            .write(self.rocksdb_engine_handler.cf_cluster(), &amp;key, &amp;val)\n}\n\n\npub fn save_conf_state(&amp;self, cs: ConfState) -&gt; Result&lt;(), String&gt; {\n        let key = key_name_by_conf_state();\n        let value = ConfState::encode_to_vec(&amp;cs);\n        self.rocksdb_engine_handler\n            .write(self.rocksdb_engine_handler.cf_cluster(), &amp;key, &amp;value)\n}\n</code></pre><p>从上面代码可以看到，它的逻辑很简单，就是拿到数据写入到对应的 Key。但是关键问题是：<strong>HardState 和 ConfState 是哪里来的（哪里生成的）？</strong></p><p>从技术上看，这两个数据的来源是 Raft 状态机，也就是 raft-rs 这个库的内部。raft-rs 实现了 Raft 的共识算法，在内部完成了发起选举、选举过程、心跳保持、用户数据保存等主要逻辑。也就说当 Raft 状态机向前驱动时，就会产生这两个数据，我们拿到这两个数据持久化存储即可。</p><p>最后来看 snapshot（快照）数据的写入。</p><p>当前快照数据的实现逻辑是：将所有未过期的 Entry 读取出来，整理成一份数据，再保存到 RocksDB 中，以便 Follower 拉取快照时更快。代码实现如下：</p><pre><code class=\"language-plain\">    pub fn create_snapshot(&amp;mut self) {\n        let mut sns = Snapshot::default();\n\n\n        // 获取快照的元数据\n        let meta = self.create_snapshot_metadata();\n        sns.set_metadata(meta.clone());\n\n\n        // 获取所有的 Entry，整理成一份数据\n        let all_data = self.rocksdb_engine_handler.read_all();\n        sns.set_data(serialize(&amp;all_data).unwrap());\n         \n        // 将快照数据再持久化保存的一个固定的快照 Key 中。\n        self.save_snapshot_data(sns);\n        self.snapshot_metadata = meta.clone();\n    }\n    \n    // 读取 HardState 和ConfState，构建快照的元数据\n    pub fn create_snapshot_metadata(&amp;self) -&gt; SnapshotMetadata {\n        let hard_state = self.hard_state();\n        let conf_state = self.conf_state();\n\n\n        let mut meta: SnapshotMetadata = SnapshotMetadata::default();\n        meta.set_conf_state(conf_state);\n        meta.set_index(hard_state.commit);\n        meta.set_term(hard_state.term);\n        return meta;\n    }\n\n\n</code></pre><p>代码注释比较清晰，这里就不展开了。需要注意的是，上面的实现会把快照数据再存储到 RocksDB，会导致重复存储两份数据。因此从实现来看是有优化空间的。</p><p>到这里，存储层的实现逻辑基本就讲完了。接下来我们看看网络层的实现。</p><p>为了帮助你更好地理解网络层的作用，我们需要先来理解一下 Raft 节点之间是如何通信的。</p><h2>Raft 节点间的通信流程</h2><p>在我看到 raft-rs 这个库时，就有一个很大的疑问：<strong>它既然只实现了共识算法，那么多个 Raft 节点之间的投票和选举、心跳保持、心跳超时 / Leader 宕机触发重新选举等等这些流程是怎么实现的呢？</strong></p><p>这里核心的是：多个节点间要如何交换信息？</p><p>回答这个问题之前，我们先来看下面这张 Raft 节点间交互的原理图。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/2b/418c3ed88byy0d399f4fyy80e391fe2b.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>如上图所示，每个 Raft 节点上都会运行一个 Raft Machine（状态机）。每个状态机内部有定时驱动机制，用于定时驱动 Raft 状态向前运行。比如定时检测心跳是否过期，是否需要发起选举等等。</p><p>从代码实现的角度，也就是说，节点会根据自身的角色（比如 Leader 和 Follower）触发不同的行为，从而产生不同的 Message（消息），再将这些 Message 发送给其他 Raft 节点。那生成的都是哪些消息呢？ raft-rs 库定义了多种 MessageType 来标识不同类型的消息，代码如下所示：</p><pre><code class=\"language-plain\">#[derive(Clone,PartialEq,Eq,Debug,Hash)]\npub enum MessageType {\n    MsgHup = 0,\n    MsgBeat = 1,\n    MsgPropose = 2,\n    MsgAppend = 3,\n    MsgAppendResponse = 4,\n    MsgRequestVote = 5,\n    MsgRequestVoteResponse = 6,\n    MsgSnapshot = 7,\n    MsgHeartbeat = 8,\n    MsgHeartbeatResponse = 9,\n    MsgUnreachable = 10,\n    MsgSnapStatus = 11,\n    MsgCheckQuorum = 12,\n    MsgTransferLeader = 13,\n    MsgTimeoutNow = 14,\n    MsgReadIndex = 15,\n    MsgReadIndexResp = 16,\n    MsgRequestPreVote = 17,\n    MsgRequestPreVoteResponse = 18,\n}\n</code></pre><p>从上面的消息类型可以看到，有投票、心跳、快照、Leader 切换等等不同类型的消息。举个例子，当用户往 Leader 节点写入数据，这条数据就需要发送给 Follwer 节点。因此 Leader 节点上的状态机就会生成一条类型为 MsgPropose 的Message，然后通过网络层将这个 Message 发送给 Follower 节点。Follower 节点遇到心跳超时时，本节点上的 Raft 状态机也会生成 MsgRequestVote 类型的消息，并将这条消息发送给其他节点。</p><p>了解完了 Raft 节点间的通信流程，接下来我们来看一下 Raft Node 网络层的代码实现。</p><h2>基于 gRPC 的网络层实现</h2><p>在上节课我们讲到，在网络层我们选择了 gRPC 来做通信协议。所以从代码实现的角度，整体就分为两步：</p><ol>\n<li>定义 gRPC proto 文件</li>\n<li>实现 gRPC Service</li>\n</ol><p>先来看 gRPC proto 文件的定义。</p><pre><code class=\"language-plain\">// 定义名为SendRaftMessage的 rpc 方法，用于在两个Raft节点间的传递消息\nrpc SendRaftMessage(SendRaftMessageRequest) returns(SendRaftMessageReply) {}\n\n\nmessage SendRaftMessageRequest{\n    // 需要传递的消息内容，是一个 bytes 类型\n    bytes message = 1;\n}\n\n\n// 返回参数为空即可，即成功不需要返回值\nmessage SendRaftMessageReply{\n}\n\n\n</code></pre><p>在上面的 proto 中，定义了一个名为 SendRaftMessage 的 RPC 方法，以及方法对应的请求和返回参数。</p><p>参数很简单，需要重点关注是 message 字段，它是 bytes 类型的数据，是由 raft-rs 中名为 Message 的结构体 encode 得到的。<strong>raft-rs 中的 Message 结构体，就是前面提到的 Raft 状态机驱动时生成的需要发给其他 Raft Node 的消息</strong>。它的定义如下：</p><pre><code class=\"language-plain\">message Message {\n    MessageType msg_type = 1;\n    uint64 to = 2;\n    uint64 from = 3;\n    uint64 term = 4;\n    uint64 log_term = 5;\n    uint64 index = 6;\n    repeated Entry entries = 7;\n    uint64 commit = 8;\n    uint64 commit_term = 15;\n    Snapshot snapshot = 9;\n    uint64 request_snapshot = 13;\n    bool reject = 10;\n    uint64 reject_hint = 11;\n    bytes context = 12;\n    uint64 deprecated_priority = 14;\n    int64 priority = 16;\n}\n</code></pre><p>可以看到 Message 中有一个前面提到的 MessageType 字段，Message 用这个字段来区分不同类型的消息。结构体内容就不细讲了，大部分比较好理解，想了解更多可以去看这个<a href=\"https://github.com/tikv/raft-rs/blob/master/proto/proto/eraftpb.proto\">《raft-rs  eraftpb.proto》</a>文件。</p><p>所以在网络层，我们只要将 Message encode 成 Vec<u8>，传递给其他节点即可，代码如下：</u8></p><pre><code class=\"language-plain\">// 将 Message 转化为Vec&lt;u8&gt;类型\nlet data: Vec&lt;u8&gt; = Message::encode_to_vec(&amp;msg);\n// 初始化请求结构\nlet request = SendRaftMessageRequest { message: data };\n// 将消息发送给其他节点\nmatch send_raft_message(self.client_poll.clone(), vec![addr.clone()], request).await\n    {\n      Ok(_) =&gt; debug!(\"Send Raft message to node {} Successful.\", addr),\n      Err(e) =&gt; error!(\n                 \"Failed to send data to {}, error message: {}\",\n                  addr,\n                  e.to_string()\n                 ),\n      }\n\n\n</code></pre><p>接着来看 gRPC Service 的实现，代码如下：</p><pre><code class=\"language-plain\">  async fn send_raft_message(\n        &amp;self,\n        request: Request&lt;SendRaftMessageRequest&gt;,\n    ) -&gt; Result&lt;Response&lt;SendRaftMessageReply&gt;, Status&gt; {\n       \n        // 将 SendRaftMessageRequest 中的 message 字段 decode 为 Message 结构体\n       let message = raftPreludeMessage::decode(request.into_inner().message.as_ref())\n            .map_err(|e| Status::invalid_argument(e.to_string()))?;\n        \n        // 将Message 传递给 Raft 状态机去执行 Raft 协议算法的逻辑\n        // 这部分在第十章会细讲，可以暂时忽略\n        match self\n            .placement_center_storage\n            .apply_raft_message(message, \"send_raft_message\".to_string())\n            .await\n        {\n            Ok(_) =&gt; return Ok(Response::new(SendRaftMessageReply::default())),\n            Err(e) =&gt; {\n                return Err(Status::cancelled(\n                    PlacementCenterError::RaftLogCommitTimeout(e.to_string()).to_string(),\n                ));\n            }\n        }\n    }\n</code></pre><p>上面这段代码的核心逻辑是：接收参数、decode Message、将得到的 Message 传递给 Raft 状态机执行，完成比如投票、选举、保存用户数据等等行为。所以说，网络层本身是不做业务逻辑处理的，当 Raft Node 拿到消息后，需要将数据传递给 Raft 状态机进行处理。</p><p>至于 Raft 状态机的实现，我们下节课会完整讲解，敬请期待！</p><h2>总结</h2><blockquote>\n<p>tips：每节课的代码都能在项目 <a href=\"https://github.com/robustmq/robustmq-geek\">https://github.com/robustmq/robustmq-geek</a> 中找到源码，有兴趣的同学可以下载源码来看。</p>\n</blockquote><p>这两节课我们基于 RocksDB 完成了存储层的开发，基于 gRPC 完成了网络层的开发。</p><p>从存储层的视角，我们主要是对 First Index、Last Index、HardState、ConfState、Entry、Uncommit、Snapshot 这 7 个数据进行读写。</p><p>从网络层的视角，核心是在多个 RaftNode 之间传递 Raft 状态机生成的消息，从而完成比如投票、选举等核心流程。</p><p>Raft Node 是指一个唯一的 Raft 投票者，需要通过唯一的 ID 来标识，不能重复。</p><h2>思考题</h2><p>这里是本节课推荐的相关 issue 的任务列表，请点击查看<a href=\"http://www.robustmq.com/docs/robustmq-tutorial-cn/%e8%b4%a1%e7%8c%ae%e6%8c%87%e5%8d%97/good-first-issue/\">《Good First Issue》</a>。 另外欢迎给我的项目 <a href=\"https://github.com/robustmq/robustmq\">https://github.com/robustmq/robustmq</a> 点个 Star 啊！</p>","comments":[{"had_liked":false,"id":396502,"user_name":"zhuxiufenghust","can_delete":false,"product_type":"c1","uid":1034291,"ip_address":"广东","ucode":"A8719F8407E74F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c8/33/2d4c464b.jpg","comment_is_top":false,"comment_ctime":1734691091,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100818701,"comment_content":"create_snapshot调用的read_all有点疑问，rocksdb存储的都是kv格式数据，entry、last_index等数据存储没有什么区别，那read_all是如何做到只读取到entry的","like_count":0}]}