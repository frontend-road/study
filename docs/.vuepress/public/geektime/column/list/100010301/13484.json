{"id":13484,"title":"13 | Java内存模型","content":"<p>我们先来看一个反常识的例子。</p>\n<pre><code>int a=0, b=0;\n\npublic void method1() {\n  int r2 = a;\n  b = 1;\n}\n\npublic void method2() {\n  int r1 = b;\n  a = 2;\n}\n</code></pre>\n<p>这里我定义了两个共享变量a和b，以及两个方法。第一个方法将局部变量r2赋值为a，然后将共享变量b赋值为1。第二个方法将局部变量r1赋值为b，然后将共享变量a赋值为2。请问（r1，r2）的可能值都有哪些？</p>\n<p>在单线程环境下，我们可以先调用第一个方法，最终（r1，r2）为（1，0）；也可以先调用第二个方法，最终为（0，2）。</p>\n<p>在多线程环境下，假设这两个方法分别跑在两个不同的线程之上，如果Java虚拟机在执行了任一方法的第一条赋值语句之后便切换线程，那么最终结果将可能出现（0，0）的情况。</p>\n<p>除上述三种情况之外，Java语言规范第17.4小节[1]还介绍了一种看似不可能的情况（1，2）。</p>\n<p>造成这一情况的原因有三个，分别为即时编译器的重排序，处理器的乱序执行，以及内存系统的重排序。由于后两种原因涉及具体的体系架构，我们暂且放到一边。下面我先来讲一下编译器优化的重排序是怎么一回事。</p>\n<p>首先需要说明一点，即时编译器（和处理器）需要保证程序能够遵守as-if-serial属性。通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。</p><!-- [[[read_end]]] -->\n<p>另外，如果两个操作之间存在数据依赖，那么即时编译器（和处理器）不能调整它们的顺序，否则将会造成程序语义的改变。</p>\n<pre><code>int a=0, b=0;\n\npublic void method1() {\n  int r2 = a;\n  b = 1;\n  .. // Code uses b\n  if (r2 == 2) {\n    .. \n  }\n}\n</code></pre>\n<p>在上面这段代码中，我扩展了先前例子中的第一个方法。新增的代码会先使用共享变量b的值，然后再使用局部变量r2的值。</p>\n<p>此时，即时编译器有两种选择。</p>\n<p>第一，在一开始便将a加载至某一寄存器中，并且在接下来b的赋值操作以及使用b的代码中避免使用该寄存器。第二，在真正使用r2时才将a加载至寄存器中。这么一来，在执行使用b的代码时，我们不再霸占一个通用寄存器，从而减少需要借助栈空间的情况。</p>\n<pre><code>int a=0, b=0;\n\npublic void method1() {\n  for (..) {\n    int r2 = a;\n    b = 1;\n    .. // Code uses r2 and rewrites a\n  }\n}\n</code></pre>\n<p>另一个例子则是将第一个方法的代码放入一个循环中。除了原本的两条赋值语句之外，我只在循环中添加了使用r2，并且更新a的代码。由于对b的赋值是循环无关的，即时编译器很有可能将其移出循环之前，而对r2的赋值语句还停留在循环之中。</p>\n<p>如果想要复现这两个场景，你可能需要添加大量有意义的局部变量，来给寄存器分配算法施加压力。</p>\n<p>可以看到，即时编译器的优化可能将原本字段访问的执行顺序打乱。在单线程环境下，由于as-if-serial的保证，我们无须担心顺序执行不可能发生的情况，如（r1，r2）=（1，2）。</p>\n<p>然而，在多线程情况下，这种数据竞争（data race）的情况是有可能发生的。而且，Java语言规范将其归咎于应用程序没有作出恰当的同步操作。</p>\n<h2>Java内存模型与happens-before关系</h2>\n<p>为了让应用程序能够免于数据竞争的干扰，Java 5引入了明确定义的Java内存模型。其中最为重要的一个概念便是happens-before关系。happens-before关系是用来描述两个操作的内存可见性的。如果操作X happens-before操作Y，那么X的结果对于Y可见。</p>\n<p>在同一个线程中，字节码的先后顺序（program order）也暗含了happens-before关系：在程序控制流路径中靠前的字节码happens-before靠后的字节码。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者没有观测前者的运行结果，即后者没有数据依赖于前者，那么它们可能会被重排序。</p>\n<p>除了线程内的happens-before关系之外，Java内存模型还定义了下述线程间的happens-before关系。</p>\n<ol>\n<li>解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作。</li>\n<li>volatile字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。</li>\n<li>线程的启动操作（即Thread.starts()） happens-before 该线程的第一个操作。</li>\n<li>线程的最后一个操作 happens-before 它的终止事件（即其他线程通过Thread.isAlive()或Thread.join()判断该线程是否中止）。</li>\n<li>线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的InterruptedException异常，或者第三个线程针对被中断线程的Thread.interrupted或者Thread.isInterrupted调用）。</li>\n<li>构造器中的最后一个操作 happens-before 析构器的第一个操作。</li>\n</ol>\n<p>happens-before关系还具备传递性。如果操作X happens-before操作Y，而操作Y happens-before操作Z，那么操作X happens-before操作Z。</p>\n<p>在文章开头的例子中，程序没有定义任何happens-before关系，仅拥有默认的线程内happens-before关系。也就是r2的赋值操作happens-before b的赋值操作，r1的赋值操作happens-before a的赋值操作。</p>\n<pre><code>Thread1      Thread2\n  |            |\n b=1           |\n  |          r1=b\n  |           a=2\nr2=a           | \n</code></pre>\n<p>拥有happens-before关系的两对赋值操作之间没有数据依赖，因此即时编译器、处理器都可能对其进行重排序。举例来说，只要将b的赋值操作排在r2的赋值操作之前，那么便可以按照赋值b，赋值r1，赋值a，赋值r2的顺序得到（1，2）的结果。</p>\n<p>那么如何解决这个问题呢？答案是，将a或者b设置为volatile字段。</p>\n<p>比如说将b设置为volatile字段。假设r1能够观测到b的赋值结果1。显然，这需要b的赋值操作在时钟顺序上先于r1的赋值操作。根据volatile字段的happens-before关系，我们知道b的赋值操作happens-before r1的赋值操作。</p>\n<pre><code>int a=0;\nvolatile int b=0;\n\npublic void method1() {\n  int r2 = a;\n  b = 1;\n}\n\npublic void method2() {\n  int r1 = b;\n  a = 2;\n}\n</code></pre>\n<p>根据同一个线程中，字节码顺序所暗含的happens-before关系，以及happens-before关系的传递性，我们可以轻易得出r2的赋值操作happens-before a的赋值操作。</p>\n<p>这也就意味着，当对a进行赋值时，对r2的赋值操作已经完成了。因此，在b为volatile字段的情况下，程序不可能出现（r1，r2）为（1，2）的情况。</p>\n<p>由此可以看出，解决这种数据竞争问题的关键在于构造一个跨线程的happens-before关系 ：操作X happens-before 操作Y，使得操作X之前的字节码的结果对操作Y之后的字节码可见。</p>\n<h2>Java内存模型的底层实现</h2>\n<p>在理解了Java内存模型的概念之后，我们现在来看看它的底层实现。Java内存模型是通过内存屏障（memory barrier）来禁止重排序的。</p>\n<p>对于即时编译器来说，它会针对前面提到的每一个happens-before关系，向正在编译的目标方法中插入相应的读读、读写、写读以及写写内存屏障。</p>\n<p>这些内存屏障会限制即时编译器的重排序操作。以volatile字段访问为例，所插入的内存屏障将不允许volatile字段写操作之前的内存访问被重排序至其之后；也将不允许volatile字段读操作之后的内存访问被重排序至其之前。</p>\n<p>然后，即时编译器将根据具体的底层体系架构，将这些内存屏障替换成具体的CPU指令。以我们日常接触的X86_64架构来说，读读、读写以及写写内存屏障是空操作（no-op），只有写读内存屏障会被替换成具体指令[2]。</p>\n<p>在文章开头的例子中，method1和method2之中的代码均属于先读后写（假设r1和r2被存储在寄存器之中）。X86_64架构的处理器并不能将读操作重排序至写操作之后，具体可参考Intel Software Developer Manual Volumn 3，8.2.3.3小节。因此，我认为例子中的重排序必然是即时编译器造成的。</p>\n<p>举例来说，对于volatile字段，即时编译器将在volatile字段的读写操作前后各插入一些内存屏障。</p>\n<p>然而，在X86_64架构上，只有volatile字段写操作之后的写读内存屏障需要用具体指令来替代。（HotSpot所选取的具体指令是lock add DWORD PTR [rsp],0x0，而非mfence[3]。）</p>\n<p>该具体指令的效果，可以简单理解为强制刷新处理器的写缓存。写缓存是处理器用来加速内存存储效率的一项技术。</p>\n<p>在碰到内存写操作时，处理器并不会等待该指令结束，而是直接开始下一指令，并且依赖于写缓存将更改的数据同步至主内存（main memory）之中。</p>\n<p>强制刷新写缓存，将使得当前线程写入volatile字段的值（以及写缓存中已有的其他内存修改），同步至主内存之中。</p>\n<p>由于内存写操作同时会无效化其他处理器所持有的、指向同一内存地址的缓存行，因此可以认为其他处理器能够立即见到该volatile字段的最新值。</p>\n<h2>锁，volatile字段，final字段与安全发布</h2>\n<p>下面我来讲讲Java内存模型涉及的几个关键词。</p>\n<p>前面提到，锁操作同样具备happens-before关系。具体来说，解锁操作 happens-before 之后对同一把锁的加锁操作。实际上，在解锁时，Java虚拟机同样需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。</p>\n<p>需要注意的是，锁操作的happens-before规则的关键字是同一把锁。也就意味着，如果编译器能够（通过逃逸分析）证明某把锁仅被同一线程持有，那么它可以移除相应的加锁解锁操作。</p>\n<p>因此也就不再强制刷新缓存。举个例子，即时编译后的synchronized (new Object()) {}，可能等同于空操作，而不会强制刷新缓存。</p>\n<p>volatile字段可以看成一种轻量级的、不保证原子性的同步，其性能往往优于（至少不亚于）锁操作。然而，频繁地访问volatile字段也会因为不断地强制刷新缓存而严重影响程序的性能。</p>\n<p>在X86_64平台上，只有volatile字段的写操作会强制刷新缓存。因此，理想情况下对volatile字段的使用应当多读少写，并且应当只有一个线程进行写操作。</p>\n<p>volatile字段的另一个特性是即时编译器无法将其分配到寄存器里。换句话说，volatile字段的每次访问均需要直接从内存中读写。</p>\n<p>final实例字段则涉及新建对象的发布问题。当一个对象包含final实例字段时，我们希望其他线程只能看到已初始化的final实例字段。</p>\n<p>因此，即时编译器会在final字段的写操作后插入一个写写屏障，以防某些优化将新建对象的发布（即将实例对象写入一个共享引用中）重排序至final字段的写操作之前。在X86_64平台上，写写屏障是空操作。</p>\n<p>新建对象的安全发布（safe publication）问题不仅仅包括final实例字段的可见性，还包括其他实例字段的可见性。</p>\n<p>当发布一个已初始化的对象时，我们希望所有已初始化的实例字段对其他线程可见。否则，其他线程可能见到一个仅部分初始化的新建对象，从而造成程序错误。这里我就不展开了。如果你感兴趣的话，可以参考这篇博客[4]。</p>\n<h2>总结与实践</h2>\n<p>今天我主要介绍了Java的内存模型。</p>\n<p>Java内存模型通过定义了一系列的happens-before操作，让应用程序开发者能够轻易地表达不同线程的操作之间的内存可见性。</p>\n<p>在遵守Java内存模型的前提下，即时编译器以及底层体系架构能够调整内存访问操作，以达到性能优化的效果。如果开发者没有正确地利用happens-before规则，那么将可能导致数据竞争。</p>\n<p>Java内存模型是通过内存屏障来禁止重排序的。对于即时编译器来说，内存屏障将限制它所能做的重排序优化。对于处理器来说，内存屏障会导致缓存的刷新操作。</p>\n<p>今天的实践环节，我们来复现文章初始的例子。由于复现需要大量的线程切换事件，因此我借助了OpenJDK CodeTools项目的jcstress工具[5]，来对该例子进行并发情况下的压力测试。具体的命令如下所示：</p>\n<pre><code>$ mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=0.1.1 -DgroupId=org.sample -DartifactId=test -Dversion=1.0\n$ cd test\n$ echo 'package org.sample;\nimport org.openjdk.jcstress.annotations.*;\nimport org.openjdk.jcstress.infra.results.IntResult2;\n@JCStressTest\n@Outcome(id = {&quot;0, 0&quot;, &quot;0, 2&quot;, &quot;1, 0&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;Normal outcome&quot;)\n@Outcome(id = {&quot;1, 2&quot;}, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;Abnormal outcome&quot;)\n@State\npublic class ConcurrencyTest {\n  int a=0;\n  int b=0; //改成volatile试试？\n  @Actor\n  public void method1(IntResult2 r) {\n    r.r2 = a;\n    b = 1;\n  }\n  @Actor\n  public void method2(IntResult2 r) {\n    r.r1 = b;\n    a = 2;\n  }\n}' &gt; src/main/java/org/sample/ConcurrencyTest.java\n$ mvn package\n$ java -jar target/jcstress.jar\n</code></pre>\n<p>如果你想要复现非安全发布的情形，那么你可以试试这一测试用例[6]。</p>\n<p>[1] <a href=\"https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4\">https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4</a><br />\n[2] <a href=\"http://gee.cs.oswego.edu/dl/jmm/cookbook.html\">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a><br />\n[3] <a href=\"https://blogs.oracle.com/dave/instruction-selection-for-volatile-fences-:-mfence-vs-lock:add\">https://blogs.oracle.com/dave/instruction-selection-for-volatile-fences-:-mfence-vs-lock:add</a><br />\n[4] <a href=\"http://vlkan.com/blog/post/2014/02/14/java-safe-publication/\">http://vlkan.com/blog/post/2014/02/14/java-safe-publication/</a><br />\n[5] <a href=\"https://wiki.openjdk.java.net/display/CodeTools/jcstress\">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a><br />\n[6] <a href=\"http://hg.openjdk.java.net/code-tools/jcstress/file/64f2cf32fa0a/tests-custom/src/main/java/org/openjdk/jcstress/tests/unsafe/UnsafePublication.java\">http://hg.openjdk.java.net/code-tools/jcstress/file/64f2cf32fa0a/tests-custom/src/main/java/org/openjdk/jcstress/tests/unsafe/UnsafePublication.java</a></p>\n<p></p>\n","comments":[{"had_liked":false,"id":20798,"user_name":"大场镇车王","can_delete":false,"product_type":"c1","uid":1072876,"ip_address":"","ucode":"5113DC367D4291","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/ec/70c8d94d.jpg","comment_is_top":true,"comment_ctime":1534761754,"is_pvip":false,"replies":[{"id":"7320","content":"volatile字段的happens-before关系指的是在两个不同线程中，volatile的写操作 happens-before 之后对同一字段的读操作。这里有个关键字之后，指的是时间上的先后。也就是我这边写，你之后再读就一定能读得到我刚刚写的值。普通字段则没有这个保证。<br><br>屏障不允许重排序是针对即时编译器的。写后对同一字段的读，属于数据依赖，本来也不可以重排序的。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534777081,"ip_address":"","comment_id":20798,"utype":1}],"discussion_count":4,"race_medal":0,"score":"9.2233721543537009e+18","product_id":100010301,"comment_content":"老师 为什么volatile内存屏障不允许所有写操作之前的读操作被重排序到写操作之后？前面不是说volatile的写操作happens before对用一字段的读操作吗","like_count":27,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422412,"discussion_content":"volatile字段的happens-before关系指的是在两个不同线程中，volatile的写操作 happens-before 之后对同一字段的读操作。这里有个关键字之后，指的是时间上的先后。也就是我这边写，你之后再读就一定能读得到我刚刚写的值。普通字段则没有这个保证。\n\n屏障不允许重排序是针对即时编译器的。写后对同一字段的读，属于数据依赖，本来也不可以重排序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534777081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1653617,"avatar":"https://static001.geekbang.org/account/avatar/00/19/3b/71/ad00d434.jpg","nickname":"小兵哥","note":"","ucode":"51A4085E0C1653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262540,"discussion_content":"看起来怎么费劲呢，是我的原因还是讲的原因？","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1589110941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2630632,"avatar":"https://static001.geekbang.org/account/avatar/00/28/23/e8/9f445339.jpg","nickname":"章潘","note":"","ucode":"1A24E1B3084450","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571642,"discussion_content":"1. volatile关键字相当于消除了工作内存的存在，即直接对主内存进行读写。因为是对同一个地址进行操作（操作系统的写指令是原子操作），所以可以简单认为多线程的操作指令是按照时序排队执行，即如果写在读之前，那么读到的值必定是写入的值。\n2. 普通变量，一般会先加载变量副本到工作内存，字节码指令对工作内存进行读写。然后在适当的时间把工作内存同步到主内存。这就可能导致数据不一致。可以类比缓存模型。当一份数据保存在多个地方时，必定存在数据一致性问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652322898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24938,"discussion_content":"老师好!volatile之前会加读写屏障，保证读最新，写之后会加写写屏障，保证写的可见。这两个读写屏障一加最后的效果就成了volatile之前的指令happen-before之后的指令。volatile关键字保证了有序行是这个意思么?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570337667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21051,"user_name":"黑崽","can_delete":false,"product_type":"c1","uid":1024159,"ip_address":"","ucode":"F31A4102EE4DA8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/9f/71345740.jpg","comment_is_top":true,"comment_ctime":1534898774,"is_pvip":false,"replies":[{"id":"7417","content":"我可能没有在原文中讲清楚。这里指的是volatile变量不能被分配到寄存器中，但是计算还是加载到寄存器中来计算的。<br><br>所谓的分配到寄存器中，你可以理解为编译器将内存中的值缓存在寄存器中，之后一直用访问寄存器来代表对这个内存的访问的。假设我们要遍历一个数组，数组的长度是内存中的值。由于我们每次循环都要比较一次，因此编译器决定把它放在寄存器中，免得每次比较都要读一次内存。对于会更改的内存值，编译器也可以先缓存至寄存器，最后更新回内存即可。<br><br>Volatile会禁止上述优化。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534929703,"ip_address":"","comment_id":21051,"utype":1}],"discussion_count":7,"race_medal":0,"score":"9.2233721457638994e+18","product_id":100010301,"comment_content":"请教个问题。刚才有说不会把volatile放到寄存器，但是应该会在栈里面对吧。直接读取主内存，读写的是栈数据，然后利用堆内存和栈上数据是利用写缓存刷新同步的？","like_count":25,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422513,"discussion_content":"我可能没有在原文中讲清楚。这里指的是volatile变量不能被分配到寄存器中，但是计算还是加载到寄存器中来计算的。\n\n所谓的分配到寄存器中，你可以理解为编译器将内存中的值缓存在寄存器中，之后一直用访问寄存器来代表对这个内存的访问的。假设我们要遍历一个数组，数组的长度是内存中的值。由于我们每次循环都要比较一次，因此编译器决定把它放在寄存器中，免得每次比较都要读一次内存。对于会更改的内存值，编译器也可以先缓存至寄存器，最后更新回内存即可。\n\nVolatile会禁止上述优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534929703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","nickname":"有米","note":"","ucode":"C9A10B7A67BC12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224327,"discussion_content":"老师这里说的寄存器应该是指CPU的L1 L2 L3缓存吧~~","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586276689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1385377,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","nickname":"何妨","note":"","ucode":"EC3983BFF7992A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","nickname":"有米","note":"","ucode":"C9A10B7A67BC12","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284076,"discussion_content":"嗯，我觉得也应该是cpu高速缓存吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592441877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224327,"ip_address":""},"score":284076,"extra":""},{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","nickname":"有米","note":"","ucode":"C9A10B7A67BC12","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319504,"discussion_content":"寄存器是属于cpu的，是cpu的内部存储","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604040615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224327,"ip_address":""},"score":319504,"extra":""}]},{"author":{"id":1344119,"avatar":"https://static001.geekbang.org/account/avatar/00/14/82/77/9cb5de00.jpg","nickname":"二毛","note":"","ucode":"2795CF80F11604","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13800,"discussion_content":"最后更新回内存，这个最后的时机是什么时候呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568701887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357376,"discussion_content":"这里实际上是两个概念。堆栈的概念是宏观上的，也就是JVM基于堆栈的结构一行行的去读代码执行。那么微观上就是CPU指令集怎么去执行。它需要寄存器和他配合来缓存数据，寄存器是内置于现代CPU中的，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615796354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613123,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/43/bf628743.jpg","nickname":"Cyber","note":"","ucode":"A7842494F57D0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305676,"discussion_content":"意思是每次都是从内存中读，而不是读cpu中的缓存？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600053295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20786,"user_name":"Alex Rao","can_delete":false,"product_type":"c1","uid":1155143,"ip_address":"","ucode":"EE055938B44CC9","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/47/620308a3.jpg","comment_is_top":true,"comment_ctime":1534752134,"is_pvip":false,"replies":[{"id":"7420","content":"工作内存是JMM抽象出来的一个概念。你可以映射到实际的CPU缓存。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534930534,"ip_address":"","comment_id":20786,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720985190994e+18","product_id":100010301,"comment_content":"老师，我在一些技术文章里看到说 volatile 的变量是存在工作内存，这个工作内存是一个什么概念？","like_count":14,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422407,"discussion_content":"工作内存是JMM抽象出来的一个概念。你可以映射到实际的CPU缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534930534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20756,"user_name":"加多","can_delete":false,"product_type":"c1","uid":1101824,"ip_address":"","ucode":"B2192A2D58C444","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/00/9d05af66.jpg","comment_is_top":true,"comment_ctime":1534729140,"is_pvip":false,"replies":[{"id":"7321","content":"即时编译器生成的代码里会使用CPU的内存屏障指令。HotSpot采用的lock前缀的指令，lock add DWORD PTR [rsp] 0。它也会刷缓存。<br><br>至于在即时编译器里禁止重排序所使用的”内存屏障”，就是一个特殊的编译器中间表达形式节点。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534777381,"ip_address":"","comment_id":20756,"utype":1}],"discussion_count":2,"race_medal":0,"score":"9.2233720813391995e+18","product_id":100010301,"comment_content":"老师，求讲解下jvm中代码如何实现的内存屏障","like_count":10,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422397,"discussion_content":"即时编译器生成的代码里会使用CPU的内存屏障指令。HotSpot采用的lock前缀的指令，lock add DWORD PTR [rsp] 0。它也会刷缓存。\n\n至于在即时编译器里禁止重排序所使用的”内存屏障”，就是一个特殊的编译器中间表达形式节点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534777381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357377,"discussion_content":"lock操作具体要查intel或AMD手册，简单来说就是缓存锁定实现的一部分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615796421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20870,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":true,"comment_ctime":1534780738,"is_pvip":false,"replies":[{"id":"7434","content":"对的！如果即时编译器把那个变量放在寄存器里维护，那么另一个线程也没辙。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534932539,"ip_address":"","comment_id":20870,"utype":1}],"discussion_count":6,"race_medal":0,"score":"9.2233720598643999e+18","product_id":100010301,"comment_content":"老师我提个问题。一个共享对象的变量是非volatile的，那么这个变量的写入会先写到寄存器上，再写回内存吗？那么jvm是不是无论如何都不保证啥时候变量的值会写回内存。假如另一个线程加锁访问这个变量，是不是jvm也不保证它能拿到最新数据。","like_count":5,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422430,"discussion_content":"对的！如果即时编译器把那个变量放在寄存器里维护，那么另一个线程也没辙。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534932539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357379,"discussion_content":"因为现代计算机遵循write back策略，所以什么时候回写CPU说了算。就会造成数据不一致","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615796485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269957,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","nickname":"樱小路依然","note":"","ucode":"DBA9FF68015FE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1627,"discussion_content":"意思是 多线程对共享变量的操作，即使加锁了也不能保证线程安全？那锁的意义何在呢...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562747821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269957,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","nickname":"樱小路依然","note":"","ucode":"DBA9FF68015FE5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1742,"discussion_content":"我也想追问这个问题，猜测是不是加锁时会强制刷新缓存？如果不会，是否应该在两个线程所包含的代码中分别用同一把锁，以保证串行？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562860688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1627,"ip_address":""},"score":1742,"extra":""},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269957,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","nickname":"樱小路依然","note":"","ucode":"DBA9FF68015FE5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203800,"discussion_content":"一个线程对共享变量加锁，另一个线程不对共享变量加锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584083813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1627,"ip_address":""},"score":203800,"extra":""},{"author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269957,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","nickname":"樱小路依然","note":"","ucode":"DBA9FF68015FE5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350564,"discussion_content":"一个锁的解锁操作 happens-before 对同一个锁的加锁操作，所以对变量的读写操作同时加锁（同一个锁）即能保证线程安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613918320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1627,"ip_address":""},"score":350564,"extra":""}]}]},{"had_liked":false,"id":20889,"user_name":"Jerry Chan","can_delete":false,"product_type":"c1","uid":1182767,"ip_address":"","ucode":"6D99FDAD6A3FEA","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/2f/54f7f676.jpg","comment_is_top":true,"comment_ctime":1534810040,"is_pvip":false,"replies":[{"id":"7433","content":"文末[4]所指向的链接。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534932409,"ip_address":"","comment_id":20889,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720426846003e+18","product_id":100010301,"comment_content":"博客在哪里啊？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422440,"discussion_content":"文末[4]所指向的链接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534932409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21279,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1534990082,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"246348125954","product_id":100010301,"comment_content":"恩，这节听了好几遍，也读了几遍，最后还是感觉蒙蒙的。<br>下面说下我的感受：<br>1:一图胜千言，尤其对于描述复杂的东西，这个建议其他同学也有提议的，希望雨迪采纳一下<br><br>2:感觉有些概念没有解释，比如：<br>2-1:Java内存模型，这节不就是要讲Java内存类型是什么？有什么特点？为什么这么设计嘛？不过我没看到这些内容，当然，特点是讲了的 happens-before 机制<br>2-2:内存屏蔽，这是什么意思？它怎么就能禁止重排序啦？还有有其引申出的各种屏蔽是怎么回事呢？也没完全明白<br><br><br>3:前面讲 as-if-serial 大概明白什么意思了，多处理器为了提高效率会采用流水线的方式来执行程序指令，但是同时要保证程序执行逻辑的正确性，所以，实际执行程序的指令和代码层面上会有不同，这个是由编译器来保证的，虽然执行逻辑不同但是程序逻辑是没变的，单线程没问题，但是多线程就变得复杂一些了，光靠这种方式保证不了啦，所以引出了下文<br><br>4:happens-before，这个概念和作用比较容易理解，线程内有这种关系，线程间更有，这个机制我认为就是为了多线程环境下为了保证程序逻辑正确性的一种方式，不过它的具体实现细节感觉没理解，不清楚他是怎么办到的<br><br>5:volatile 这个关键字之前也学习过，作用是保证内容的修改对所有线程可见，原理是修改后同步更新所有的内容，这是因为内存和处理器直接还是存在距离的，比如：内存-一级缓存-二级缓存-各种寄存器-cpu，如果是内存-cpu，则不会有这种问题了，不过性能也就不行了","like_count":58,"discussions":[{"author":{"id":1588636,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/9c/74355ff6.jpg","nickname":"despicable--","note":"","ucode":"0C4565D82D13C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34662,"discussion_content":"我也是花钱的，不是喷子，但是我觉得我搜个博客都比这个讲得要清晰，易懂。老师肯定是大神，比我牛。但是你这个讲课方式我真有点儿学的难受。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1571212955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1588636,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/9c/74355ff6.jpg","nickname":"despicable--","note":"","ucode":"0C4565D82D13C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289821,"discussion_content":"说实话，看了很多博客，都没说到点上，很多博客，直接用的是计算机模型来讲解的，而这里是jvm，是java的内存模型，jvm是虚拟机，抽象出来一个和计算机内存模型功能类似的模型，这里的volatile类似计算机里的缓存一致性协议，很多博客，直接讲的MESI协议，很好理解，老师的文章，才是jvm，如果读过计算机组成，看这个很容易，也能体会其中的精髓，否则，很难理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594220417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":34662,"ip_address":""},"score":289821,"extra":""}]},{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293260,"discussion_content":"科代表","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595493988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1855289,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/4f/39/cb4df994.jpg","nickname":"单俊宁","note":"","ucode":"403678A72C3305","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207908,"discussion_content":"java内存模型是一种针对java程序执行的机制和规范吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584524653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521451,"avatar":"https://static001.geekbang.org/account/avatar/00/17/37/2b/b32f1d66.jpg","nickname":"Ball","note":"","ucode":"1EE949E68D84CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363561,"discussion_content":"java 内存模型是 Java 定义的虚拟机多线程环境下的内存可见性规范","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617237613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40864,"user_name":"　素丶　　","can_delete":false,"product_type":"c1","uid":1081535,"ip_address":"","ucode":"883B7EDBE76104","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/bf/3041138b.jpg","comment_is_top":false,"comment_ctime":1542684565,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"147571572629","product_id":100010301,"comment_content":"可以配合程晓明大大的《深入理解Java内存模型》<br>https:&#47;&#47;www.infoq.cn&#47;article&#47;java_memory_model","like_count":34,"discussions":[{"author":{"id":2657927,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ahXhSPaGks7baUJj9x3NpIbaBbZTz3ibJwv2d0JTm3ebiaG7ymEmLxP28G4Rt7SCP6IIImfq5wj37zMUyAGGgp7w/132","nickname":"Geek_9aff02","note":"","ucode":"B1E8548C0816EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390029,"discussion_content":"这就是《java并发编程的艺术》 摘下来的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629616398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134722,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/82/eb5713bb.jpg","nickname":"牛牛01","note":"","ucode":"3D6A0B0283EF43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310361,"discussion_content":"感谢分享~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601799587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21446,"user_name":"道法自然","can_delete":false,"product_type":"c1","uid":1063627,"ip_address":"","ucode":"E4DFD0415A6291","user_header":"https://static001.geekbang.org/account/avatar/00/10/3a/cb/97dee373.jpg","comment_is_top":false,"comment_ctime":1535085755,"is_pvip":true,"replies":[{"id":"8009","content":"首先，b加了volatile之后，并不能保证b=1一定先于r1=b，而是保证r1=b始终能够看到b的最新值。比如说b=1;b=2，之后在另一个CPU上执行r1=b，那么r1会被赋值为2。如果先执行r1=b，然后在另外一个CPU上执行b=1和b=2，那么r1将看到b=1之前的值。<br><br>在没有标记volatile的时候，同一线程中，r2=a和b=1存在happens before关系，但因为没有数据依赖可以重排列。一旦标记了volatile，即时编译器和CPU需要考虑到多线程happens-before关系，因此不能自由地重排序。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535620100,"ip_address":"","comment_id":21446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"104614300859","product_id":100010301,"comment_content":"老师你好，关于指令重排序有点不太理解，指令重排序的粒度是方法级别的，还是整个源文件级别的。文中说道，b 加了volatile后，能够保证 b=1 先于r1=b ，这个我能理解，但是如何保证不会因为指令重排导致 b=1 先于r2=a发生呢？文中虽然说了，同一个线程中，字节码顺序暗含了r2=a happen before b=1，但是文中也提到了，拥有happen-before关系的两对赋值操作之间没有数据依赖，处理器可以指令重排序。r2=a 和b=1之间没有数据依赖呀！不好意思，这块有点迷糊，老师能给详细解答下不？","like_count":24,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422680,"discussion_content":"首先，b加了volatile之后，并不能保证b=1一定先于r1=b，而是保证r1=b始终能够看到b的最新值。比如说b=1;b=2，之后在另一个CPU上执行r1=b，那么r1会被赋值为2。如果先执行r1=b，然后在另外一个CPU上执行b=1和b=2，那么r1将看到b=1之前的值。\n\n在没有标记volatile的时候，同一线程中，r2=a和b=1存在happens before关系，但因为没有数据依赖可以重排列。一旦标记了volatile，即时编译器和CPU需要考虑到多线程happens-before关系，因此不能自由地重排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535620100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21611,"user_name":"Kyle","can_delete":false,"product_type":"c1","uid":1106079,"ip_address":"","ucode":"44198A0BEC5FB2","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/9f/9259a6b9.jpg","comment_is_top":false,"comment_ctime":1535195512,"is_pvip":true,"replies":[{"id":"7904","content":"谢谢总结！确实，本文重点讲的是内存可见性规则。<br><br>JMM的工作内存，主内存这些概念都是抽象的，对应实际体系架构中的缓存和内存。本文切掉了抽象的那部分，直接用实际的体系架构来讲解。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535465714,"ip_address":"","comment_id":21611,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40189901176","product_id":100010301,"comment_content":"我个人理解的“JAVA内存模型”应该是包括两部分的内容：<br>一是运行时数据区，<br>二是定义了一组内存访问规则。<br><br>这里其实主要讲的是其中的第二部分内容。不知道是不是可以这样总结。","like_count":9,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422765,"discussion_content":"谢谢总结！确实，本文重点讲的是内存可见性规则。\n\nJMM的工作内存，主内存这些概念都是抽象的，对应实际体系架构中的缓存和内存。本文切掉了抽象的那部分，直接用实际的体系架构来讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535465714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45830,"user_name":"阿巍-豆夫","can_delete":false,"product_type":"c1","uid":1005123,"ip_address":"","ucode":"732188848B0A85","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/43/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1543801463,"is_pvip":false,"replies":[{"id":"16499","content":"理论上，因为都使用同一套缓存，所以不需要volatile。实际实现中，对编译器不能重排列的限制还是存在的，但具体的memory barrier指令的实现是no-op。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1543853458,"ip_address":"","comment_id":45830,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35903539831","product_id":100010301,"comment_content":"关于Volatile, 我想问下，如果是单个cpu的系统上运行多线程的程序，是不是这个volative就没有效果了？ 因为大家都使用同一个寄存器。","like_count":8,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431226,"discussion_content":"理论上，因为都使用同一套缓存，所以不需要volatile。实际实现中，对编译器不能重排列的限制还是存在的，但具体的memory barrier指令的实现是no-op。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543853458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35059,"user_name":"第9根烟","can_delete":false,"product_type":"c1","uid":1117723,"ip_address":"","ucode":"7EBDF6E695855A","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/1b/1902d6fa.jpg","comment_is_top":false,"comment_ctime":1540391915,"is_pvip":false,"replies":[{"id":"12766","content":"在解释执行时，字节码之间也有内存屏障","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1540822888,"ip_address":"","comment_id":35059,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23015228395","product_id":100010301,"comment_content":"问一下，内存屏障是即时编译器生成本地代码的时候产生的？？那照这个意思岂不是关闭即时编译器就实现不了happen-before原则了？","like_count":5,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427429,"discussion_content":"在解释执行时，字节码之间也有内存屏障","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540822888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350567,"discussion_content":"编译器会对volatile变量的读写添加JVM层面的内存屏障（即字节码指令），即时编译器再把这些字节码指令翻译成CPU的内存屏障指令。\n\n关闭即时编译器的话，解释器也会把内存屏障字节码指令翻译成CPU指令执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613918790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234544,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1594717307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18774586491","product_id":100010301,"comment_content":"如何理解编译优化：<br>经过编译后的指令，最终是要被cpu执行。cpu 指令执行是采用流水作业的方式，一条指令的执行流程包含取得指令、指令译码、执行指令三个过程。cpu可以一次取一条指令，也可以一次取一个指令包，指令包包含多条执行。而cpu执行指令的时候，并不是等一条指令执行结束在执行下一条指令，往往一条 cpu 指令会被拆分成多个阶段，多个阶段就对应多个流水线。也就是说只要保证一条指令的多个流水线只要在一个cpu时钟周期内完成即可。这就会导致一条指令的数据操作好没写回内存，下一条指令已经开始工作，因此下一条指令读取的数据，不一定是上一条指令执行后的数据。编译优化的目的本质是加快程序运行速度，能让编译后的指令尽可能赶上cpu的执行频率。这种cpu指令的流水线作业，就导致，程序编译后的指令，实际执行的顺序可能不是严格按照编译后的指令顺序而执行。<br>在单线程执行的时候或者单核执行的时候，cpu在执行有数据依赖的指令的时候，往往通过加入一些空操作no-op来保证指令的执行顺序，对于没有数据依赖的指令，往往采用乱序执行来加快执行效率。<br>在多线程的情况下或者多核的情况下，对数据操作是并发执行，也就是说，每个线程都会把操作的数据加载到自己的缓存中(本地内存)执行，这就导致，线程之间对数据的操作不可见。java内存模型规定，要保证数据的可见性，必须经过主内存，也就是说，只有当一个线程的操作同步到主内存后，别的线程才能读到更新后的数据。在多线程下，对共享变量操作就会发生数据竞争问题，从而导致并发问题；<br>如何理解内存屏障禁止指令重排序：<br>在单线程的情况下，JMM规定了一条HB 规则，在一个线程中，前面的操作 Happens-Before 于后续的任意操作，这就要求，在cpu指令执行的时候，有数据依赖关系的指令，不能被重排序，但是CPU执行指令的时候，为了执行效率采用流水作业，并不是严格按照程序的顺序进行执行。这就要求，在有依赖关系的指令之间插入内存屏障来保证，比如插入空操作no-op，这就保证了，如果写操作指令没有执行完，这是读指令读取数据，那么读取的是内存屏障指令，也就是空操作，只有等写操作指令执行结束，读指令才能读取到最新的数据。从而解决了编译重排序而导致的数据安全问题；<br>在多线程的情况下，为了解决线程之间缓存导致的可见性问题，JMM规定了一条HB规则，对一个 volatile 变量的写操作Happens-Before 于后续对这个 volatile 变量的读操作。比如 A 线程对变量执行写操作，这时候，B线程想要在A线程写完之后读取数据，因为A 线程的写操作，往往需要多条cpu指令执行，如果写操作的指令还没执行结束，这时候读指令读取到的数据必然是不符合程序本身意愿的。A线程写操作的指令和B线程读操作的指令，在CPU执行的时候，先后顺序完全取决于CPU，CPU不会等A线程写操作指令执行完才执行B线程的读操作指令，这就会引起并发问题，这时候可以通过内存屏障来解决，也就是对共享变量用volatile 修饰，volatile 本质就是通过内存屏障来实现，也就是说用volatile修饰变量，编译后，会生成具体的每次屏障指令，以Lock开头的指令，就是保住A线程对数据的操作结果，会同步到内存中，并且在A线程执行写操作的时候，B线程不可以进行读取操作，只有当A的写操作同步到内存后，B线程才执行度操作，类似锁的功能。通过内存屏障禁止了指令重排序，保证了共享数据在多线程之间的可见性问题。","like_count":4},{"had_liked":false,"id":34248,"user_name":"Mr.钧👻","can_delete":false,"product_type":"c1","uid":1249939,"ip_address":"","ucode":"D781E030E79245","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/93/3470fc43.jpg","comment_is_top":false,"comment_ctime":1540047688,"is_pvip":false,"replies":[{"id":"12761","content":"我们考虑一种简单情况，即每个CPU有独占缓存，没有共享缓存。强制刷新缓存，是为了让跑在另外一个CPU上的线程看到你这个CPU上更新的内容。<br><br>如果想要深入研究下去，可以翻翻CSAPP那本书。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1540822073,"ip_address":"","comment_id":34248,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18719916872","product_id":100010301,"comment_content":"即时编译在单线程的情况下，根据as if serial 的选择，会是的编译逻辑和程序逻辑相同。<br><br>但是，在多线程情况下可能出现编译器重排序导致的数据竞争。这时就需要使用volatile来禁止重排序。<br><br>volatile的底层原理，是在字节码中插入内存屏障实现的。<br><br>内存屏障会被转化成一条指令，指令具体的效果是强制刷新缓存。<br>疑问：为什么是强制刷新缓存？是因为happen-before原则，要让后面的程序看到？ 那后面程序看到的就是缓存中的内容吗？<br><br>我对寄存器，缓存有不熟悉的地方，希望老师可以指正，指导我该补哪方面的知识，多谢","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427156,"discussion_content":"我们考虑一种简单情况，即每个CPU有独占缓存，没有共享缓存。强制刷新缓存，是为了让跑在另外一个CPU上的线程看到你这个CPU上更新的内容。\n\n如果想要深入研究下去，可以翻翻CSAPP那本书。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540822073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22312,"user_name":"Kenneth","can_delete":false,"product_type":"c1","uid":1183069,"ip_address":"","ucode":"AF46C8EEBDA3D0","user_header":"https://static001.geekbang.org/account/avatar/00/12/0d/5d/e50cf9c7.jpg","comment_is_top":false,"comment_ctime":1535595611,"is_pvip":false,"replies":[{"id":"8008","content":"嗯，我回到原问题上哈","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535619519,"ip_address":"","comment_id":22312,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14420497499","product_id":100010301,"comment_content":"同求讲解该问题，谢谢老师！：<br>啃yi嘴泥<br>老师你好，关于指令重排序有点不太理解，指令重排序的粒度是方法级别的，还是整个源文件级别的。文中说道，b 加了volatile后，能够保证 b=1 先于r1=b ，这个我能理解，但是如何保证不会因为指令重排导致 b=1 先于r2=a发生呢？文中虽然说了，同一个线程中，字节码顺序暗含了r2=a happen before b=1，但是文中也提到了，拥有happen-before关系的两对赋值操作之间没有数据依赖，处理器可以指令重排序。r2=a 和b=1之间没有数据依赖呀！不好意思，这块有点迷糊，老师能给详细解答下不？<br>2018-08-24","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423066,"discussion_content":"嗯，我回到原问题上哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535619519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72608,"discussion_content":"同求答案","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575508445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24678,"user_name":"昵称而已，何必执着","can_delete":false,"product_type":"c1","uid":1057139,"ip_address":"","ucode":"D8F0D534D7450F","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/73/2da558bb.jpg","comment_is_top":false,"comment_ctime":1537184053,"is_pvip":false,"replies":[{"id":"9076","content":"你需要用jcstress工具来进行压力测试。<br><br>如果跑自己写的程序的话，可以试试在电脑上跑多个满载进程，让操作系统不停切换进程。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1537196307,"ip_address":"","comment_id":24678,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10127118645","product_id":100010301,"comment_content":"我写了个方法按照上面的代码循环执行了9999次，要么是1，0要么是0,2 一直没有出现1,2。这个怎么破？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424084,"discussion_content":"你需要用jcstress工具来进行压力测试。\n\n如果跑自己写的程序的话，可以试试在电脑上跑多个满载进程，让操作系统不停切换进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537196307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22780,"user_name":"浩","can_delete":false,"product_type":"c1","uid":1122770,"ip_address":"","ucode":"9688796AF97C6F","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/d2/df11e830.jpg","comment_is_top":false,"comment_ctime":1535970905,"is_pvip":false,"replies":[{"id":"8473","content":"JMM里的工作内存是个虚拟概念，实际上映射到的是CPU缓存。<br><br>如果你指工作线程会不会将用到的内存加载至CPU缓存中，那么答案是会的。<br><br>如果你指会不会另外开一片内存，来存储这部分用到的堆内存，那么答案是不会的。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1536331809,"ip_address":"","comment_id":22780,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10125905497","product_id":100010301,"comment_content":"您好 当工作线程需要的内存特别大 比如超过10m 那工作线程会copy10m的内存数据到工作线程嘛？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423261,"discussion_content":"JMM里的工作内存是个虚拟概念，实际上映射到的是CPU缓存。\n\n如果你指工作线程会不会将用到的内存加载至CPU缓存中，那么答案是会的。\n\n如果你指会不会另外开一片内存，来存储这部分用到的堆内存，那么答案是不会的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536331809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260980,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1605166333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5900133629","product_id":100010301,"comment_content":"JMM 决定一个 线程对共享变量的写入何时对另一个线程可见。","like_count":1},{"had_liked":false,"id":233126,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1594223398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889190694","product_id":100010301,"comment_content":"以往我认为b设置为volatile后，如代码：标记1则不能重排序优化到标记2后面，若r1=1，则表明顺序肯定能确定有 1,2,3；但是4若在最前面执行了，则可能出现(r1,r2)=(1,2)。<br>但是现在这个假设已经被老师打破了，而且是我所不能理解了，我太难了......<br>能不能这样理解，b设置为volatile后，对b的赋值和读取都加了重排序限制，导致1 happen-before 2, 3 happen-before 4。<br>int a=0;<br>volatile int b=0;<br><br>public void method1() {<br>  int r2 = a; \t&#47;&#47;标记1<br>  b = 1;  \t  \t&#47;&#47;标记2<br>}<br><br>public void method2() {<br>  int r1 = b;\t&#47;&#47;标记3<br>  a = 2;\t\t&#47;&#47;标记4<br>}<br>","like_count":1},{"had_liked":false,"id":148558,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1573030570,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5867997866","product_id":100010301,"comment_content":"测试用例 [6] 中实际测试后会发现, 有一部分的 object 尚未初始化<br>问题出在 new 操作上，我们以为的 new 操作应该是：<br>\t分配一块内存 M；在内存 M 上初始化 Singleton 对象；然后 M 的地址赋值给 instance 变量。<br> 但是实际上优化后的执行路径却是这样的：<br>\t\t 分配一块内存 M；将 M 的地址赋值给 instance 变量；最后在内存 M 上初始化 Singleton 对象。<br>所谓的单例模式, 就是安全发布的问题<br>(部分来自专栏 java并发编程实战)","like_count":1},{"had_liked":false,"id":100290,"user_name":"believe me","can_delete":false,"product_type":"c1","uid":1101427,"ip_address":"","ucode":"7BF9A3C7BF6A9B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/73/cded8343.jpg","comment_is_top":false,"comment_ctime":1559522943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5854490239","product_id":100010301,"comment_content":"即时编译器才会重排序，解释执行是不是就没有这个问题了？","like_count":1},{"had_liked":false,"id":28351,"user_name":"冬末未末","can_delete":false,"product_type":"c1","uid":1118801,"ip_address":"","ucode":"09F08206EF202D","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/51/f309515c.jpg","comment_is_top":false,"comment_ctime":1538058040,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5833025336","product_id":100010301,"comment_content":"happen-before 在这里不能理解成在什么之前发生，它和时间没有任何关系。个人感觉解释成“生效可见于” 更准确。","like_count":1,"discussions":[{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328654,"discussion_content":"happen-before 不是先行发生，  是  可见  的意思","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606204544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21035,"user_name":"熊猫酒仙","can_delete":false,"product_type":"c1","uid":1112078,"ip_address":"","ucode":"17002C7A355EC1","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/0e/de697f9b.jpg","comment_is_top":false,"comment_ctime":1534896316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5829863612","product_id":100010301,"comment_content":"老师，既然有写缓存，是不是也有读缓存呢？强制刷新写缓存，无效化相应的内存数据，那么这些内存数据的读缓存也就失效了，需要重新加载最新数据，是否可以这样理解？<br><br>另外强制刷新写缓存是否也有粒度一说？就是我们加的锁也有粒度之分，那么所触发的强制刷新写缓存的区域可能不一样？","like_count":1},{"had_liked":false,"id":20840,"user_name":"agilejava","can_delete":false,"product_type":"c1","uid":1005388,"ip_address":"","ucode":"4DCFEE7D7FAEFA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4c/e6cb260a.jpg","comment_is_top":false,"comment_ctime":1534770951,"is_pvip":true,"replies":[{"id":"7319","content":"多谢建议！","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534776306,"ip_address":"","comment_id":20840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5829738247","product_id":100010301,"comment_content":"文字太多，最好能结合一些图形会更方便理解","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422420,"discussion_content":"多谢建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534776306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355619,"user_name":"(￣o￣) . z Z","can_delete":false,"product_type":"c1","uid":1433986,"ip_address":"福建","ucode":"42F97D91001DD1","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/82/1c5d285d.jpg","comment_is_top":false,"comment_ctime":1661566846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661566846","product_id":100010301,"comment_content":"为什么不是先总再细节的方式讲解，这一上来就举例、讲细节，对这块基础差一点的，比较难理解啊","like_count":0},{"had_liked":false,"id":336148,"user_name":"Geek_417e74","can_delete":false,"product_type":"c1","uid":2113978,"ip_address":"","ucode":"BEA8915879274D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLLniccwC1Mootc7IQsRGUTX3ZkkCKPc7lYV0g8CAqscWtAjd8xkHYcY3UFbYvicm42FXuAO5bZP6WQ/132","comment_is_top":false,"comment_ctime":1645956684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645956684","product_id":100010301,"comment_content":"老师，请问用 volatile 修饰对象（list，map，数组，自定义java对象，那(list#add、map#put、数组[idx]=xxx、java#setter 还有比如 list里面的java对象#setter)  算对volatile 对象的写操作么？这个时候会强制刷新写缓存么。也就是volatile 修饰对象，能保证整个对象的可见性么？谢谢老师","like_count":0},{"had_liked":false,"id":336137,"user_name":"Geek_417e74","can_delete":false,"product_type":"c1","uid":2113978,"ip_address":"","ucode":"BEA8915879274D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLLniccwC1Mootc7IQsRGUTX3ZkkCKPc7lYV0g8CAqscWtAjd8xkHYcY3UFbYvicm42FXuAO5bZP6WQ/132","comment_is_top":false,"comment_ctime":1645951660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645951660","product_id":100010301,"comment_content":"老师，想问一个问题：线程池executor.submit(task)；task里执行xxx.method(Object 1); 如果submit提交后把task放队列，那这个Object 1 对线程池中已存在的线程不可见么？比如我在主线程里对Object 1 的属性做了修改，然后sumbit，先放入队列，然后很快被一个线程执行了，这个线程是不是可能读到 Object 1 修改前的属性值呢？这时候就用 volatile 解决么？","like_count":0},{"had_liked":false,"id":293640,"user_name":"大漠","can_delete":false,"product_type":"c1","uid":1124461,"ip_address":"","ucode":"B7973B9FD7CB61","user_header":"https://static001.geekbang.org/account/avatar/00/11/28/6d/d776d35a.jpg","comment_is_top":false,"comment_ctime":1621474379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621474379","product_id":100010301,"comment_content":"happens-before 这个概念理解起来感觉有点别扭 😂","like_count":0},{"had_liked":false,"id":283829,"user_name":"黑山老妖","can_delete":false,"product_type":"c1","uid":1115958,"ip_address":"","ucode":"A1659F99C5BE1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/36/d677e741.jpg","comment_is_top":false,"comment_ctime":1615949380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615949380","product_id":100010301,"comment_content":"Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节","like_count":0},{"had_liked":false,"id":282550,"user_name":"小龙的城堡","can_delete":false,"product_type":"c1","uid":1005727,"ip_address":"","ucode":"7F1F9704548E2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/9f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1615298900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615298900","product_id":100010301,"comment_content":"volatile 字段可以看成一种轻量级的、不保证原子性的同步，其性能往往优于（至少不亚于）锁操作。然而，频繁地访问 volatile 字段也会因为不断地强制刷新缓存而严重影响程序的性能。<br><br>老师您好，这里是否是要改成，对Volatile字段的修改才会编译出lock，导致频繁的锁总线，导致性能下降呢？谢谢","like_count":0},{"had_liked":false,"id":266304,"user_name":"多一点","can_delete":false,"product_type":"c1","uid":1567389,"ip_address":"","ucode":"C00897F878FEA9","user_header":"https://static001.geekbang.org/account/avatar/00/17/ea/9d/efeeec68.jpg","comment_is_top":false,"comment_ctime":1607299293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607299293","product_id":100010301,"comment_content":"volatile关键字的作用:<br>1.不保证原子性<br>2.保证内存可见性<br>3.禁止指令重排<br>synchronized(new Object){}，等于对对象没加锁🔒。synchronize加锁的对象原理是每次拿到唯一的对象头id，你这每次new对账，重新申请内存空间，获得新的head id，锁的上才怪呢。","like_count":0},{"had_liked":false,"id":266119,"user_name":"lornsoul","can_delete":false,"product_type":"c1","uid":1234912,"ip_address":"","ucode":"EF2C7EC9B3F82E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/e0/bc774bfb.jpg","comment_is_top":false,"comment_ctime":1607176246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607176246","product_id":100010301,"comment_content":"线程内的 happens-before 与线程间的happens-before 也存在传递性吗？","like_count":0},{"had_liked":false,"id":252784,"user_name":"IT生涯路漫漫","can_delete":false,"product_type":"c1","uid":1014146,"ip_address":"","ucode":"4954D1CBEB4E44","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/82/c3cccc38.jpg","comment_is_top":false,"comment_ctime":1602486594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602486594","product_id":100010301,"comment_content":"郑老师：<br>对您文章中的这句话有疑问：“volatile 字段的另一个特性是即时编译器无法将其分配到寄存器里。换句话说，volatile 字段的每次访问均需要直接从内存中读写。”<br>我看到很多讲Java并发编程的书里写的是：<br>写volatile变量指令时会强制将值写入对应的内存地址，并使用一个总线指令使这个volatile变量缓存失效，这样就保证其他CPU核在下次读取这个volatile变量值时需要先从内存中获取到最新值到缓存中。就是说volatile变量本身还是会被读到CPU缓存中的。","like_count":0},{"had_liked":false,"id":252672,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1602429502,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1602429502","product_id":100010301,"comment_content":"在文章开头的例子中，程序没有定义任何 happens-before 关系，仅拥有默认的线程内 happens-before 关系。也就是 r2 的赋值操作 happens-before b 的赋值操作，r1 的赋值操作 happens-before a 的赋值操作。<br>老师这句怎么理解？r2赋值和b的赋值，r1赋值和a的赋值，没有因果关系，可以重拍的啊？","like_count":0},{"had_liked":false,"id":251148,"user_name":"hl","can_delete":false,"product_type":"c1","uid":1385110,"ip_address":"","ucode":"E3280721BCFA6B","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/96/beb89790.jpg","comment_is_top":false,"comment_ctime":1601379742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601379742","product_id":100010301,"comment_content":"既然volatile存在读写操作的内存屏障，那它为何不是原子性的同步呢？不是原子性能举个例子吗","like_count":0},{"had_liked":false,"id":245852,"user_name":"呼啦啦~","can_delete":false,"product_type":"c1","uid":1281850,"ip_address":"","ucode":"7E5BAB3E2BB37F","user_header":"https://static001.geekbang.org/account/avatar/00/13/8f/3a/b15e7392.jpg","comment_is_top":false,"comment_ctime":1599094881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599094881","product_id":100010301,"comment_content":"文中：<br>根据同一个线程中，字节码顺序所暗含的 happens-before 关系，以及 happens-before 关系的传递性，我们可以轻易得出 r2 的赋值操作 happens-before a 的赋值操作。<br><br>变量b使用了volatile修饰，只能保证对b的读操作happens after 前面对b的写操作。<br>而<br>  int r2 = a;<br>  b = 1;<br>这两个语句并没有数据依赖关系，并不见得 int r2=a也会happens before 后面的语句。<br><br><br>这点不是很清楚，可否解释一下？","like_count":0},{"had_liked":false,"id":226383,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1592057995,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592057995","product_id":100010301,"comment_content":"建议整个描述可以是内存模型是什么？为什么这么设计？<br>然后再深入细节，描述具体细节时也可以多讲些为什么","like_count":0},{"had_liked":false,"id":208925,"user_name":"ward-wolf","can_delete":false,"product_type":"c1","uid":1031845,"ip_address":"","ucode":"BC41D01301263A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/a5/df917d18.jpg","comment_is_top":false,"comment_ctime":1587465584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587465584","product_id":100010301,"comment_content":"感觉老师你只讲到设计Java内存模型的happens-before，具体什么Java内存模型没有细说。","like_count":0},{"had_liked":false,"id":207968,"user_name":"ls","can_delete":false,"product_type":"c1","uid":1603770,"ip_address":"","ucode":"C4656DCD9C8CAA","user_header":"https://static001.geekbang.org/account/avatar/00/18/78/ba/cb539d20.jpg","comment_is_top":false,"comment_ctime":1587223842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587223842","product_id":100010301,"comment_content":"老师请问：我的理解jvm是一个进程，那么他就有自己的虚拟地址空间，那么所谓的jvm划分出来的堆区，栈区就指的是虚拟地址空间上面的那些堆区，栈区之类的吧？那么主内存其实就是一个共享变量存放的地方（泛指，这类区域都可以称为主内存），工作内存可以理解为栈区，者寄存器这块区域（线程私有），线程对于主内存中的变量不能直接操作，需要读取到自己的工作内存中去进行操作，那么这里是读取到线程栈里面操作还是读到寄存器去操作呢。","like_count":0},{"had_liked":false,"id":203861,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1586276968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586276968","product_id":100010301,"comment_content":"我觉得要理解volatile的原理，前提是：先理解CPU的缓存及与内存同步数据的原理，理解多核CPU如何保证内存数据的一致性~~","like_count":0},{"had_liked":false,"id":192208,"user_name":"今天","can_delete":false,"product_type":"c1","uid":1532354,"ip_address":"","ucode":"F8577A2BABCD1F","user_header":"https://static001.geekbang.org/account/avatar/00/17/61/c2/94c1d4c9.jpg","comment_is_top":false,"comment_ctime":1584843198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584843198","product_id":100010301,"comment_content":"已购买期待后续课程","like_count":0},{"had_liked":false,"id":172476,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1579186180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579186180","product_id":100010301,"comment_content":"“换句话说，volatile 字段的每次访问均需要直接从内存中读写”<br>这个内存是指高速缓存吗？ 我理解的是工作内存，不是主内存；<br>如果其它线程没有触发volatile 字段写，缓存行协议不会设置其它CPU地址无效，这时没有必要从主内存重新读取volatie变量到CPU高速缓存（不是寄存器）<br><br>以上是我的分析，不知道是不是","like_count":0},{"had_liked":false,"id":171856,"user_name":"wujtApp","can_delete":false,"product_type":"c1","uid":1381461,"ip_address":"","ucode":"275942D7CF6D89","user_header":"https://static001.geekbang.org/account/avatar/00/15/14/55/c2691e73.jpg","comment_is_top":false,"comment_ctime":1579047400,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1579047400","product_id":100010301,"comment_content":"看完本章节，有一些疑惑。volatile具有可见性和禁止编译器重排序的特性，我的理解可见性对于并发访问高的情形仍然不适用，是因为非原子性，原子性是说同一段指令只能由一个线程执行？保证原子性JAVA给的方案只有锁？","like_count":0},{"had_liked":false,"id":171320,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1578901829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578901829","product_id":100010301,"comment_content":"老师 为什么使用了lock 没有使用 mfence 指令呢?","like_count":0},{"had_liked":false,"id":165720,"user_name":"白城故里","can_delete":false,"product_type":"c1","uid":1575061,"ip_address":"","ucode":"ADC169653E1FDB","user_header":"https://static001.geekbang.org/account/avatar/00/18/08/95/5adba069.jpg","comment_is_top":false,"comment_ctime":1577288627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577288627","product_id":100010301,"comment_content":"老师 要是改变下原本的赋值顺序 那么传递是不是就不存在了 就又可以重排序了呢","like_count":0},{"had_liked":false,"id":159686,"user_name":"超级芒果冰","can_delete":false,"product_type":"c1","uid":1188976,"ip_address":"","ucode":"97480FBFA4F699","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/70/4e7751f3.jpg","comment_is_top":false,"comment_ctime":1575727717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575727717","product_id":100010301,"comment_content":"老师，能不能对 happens-before 这个解释一下，总感觉好像没理解透","like_count":0},{"had_liked":false,"id":158981,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1575509910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575509910","product_id":100010301,"comment_content":"前面几个有讲到 volatile 可能会导致缓存行失效，但是如果使用了 volatile 的话，不是直接从内存中取嘛？<br><br>","like_count":0},{"had_liked":false,"id":158943,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1575505287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575505287","product_id":100010301,"comment_content":"<br>int a=0, b=0;<br><br>public void method1() {<br>  int r2 = a;<br>  b = 1;<br>}<br><br>public void method2() {<br>  int r1 = b;<br>  a = 2;<br>}<br><br>这里说的是即时编译器， JIT 也就是运行的时候吧，那这样的话，运行时就能知道了？是不是单线程调用的了？","like_count":0},{"had_liked":false,"id":158941,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1575505190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575505190","product_id":100010301,"comment_content":"<br>int a=0, b=0;<br><br>public void method1() {<br>  int r2 = a;<br>  b = 1;<br>}<br><br>public void method2() {<br>  int r1 = b;<br>  a = 2;<br>}<br><br><br>编译器是怎么知道他是单线程会吊用，还是多线程会调用呢？<br>","like_count":0},{"had_liked":false,"id":140737,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1571039567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571039567","product_id":100010301,"comment_content":"这部分内容，感觉要想理解，得自己读一读Java语言规范17.4，老师由于篇幅限制，肯定不可能什么都讲到的。","like_count":0},{"had_liked":false,"id":132249,"user_name":"断了线的风筝","can_delete":false,"product_type":"c1","uid":1211764,"ip_address":"","ucode":"6A292399F40FD2","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoGKMvtK8GTC5Adfd1lXyh0F3KupISPWLryjefVMAPOWgf83HXLrDh6EO1MKoPfib6VibtjjjbPib1A/132","comment_is_top":false,"comment_ctime":1568071912,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568071912","product_id":100010301,"comment_content":"老师，请问jmap查看内存大小与查看jvm进程大小不一致，小于进程内存大小，是什么情况？如何查看jvm进程内存都是有那几块组成，各自大小分别是多少？","like_count":0,"discussions":[{"author":{"id":1211764,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoGKMvtK8GTC5Adfd1lXyh0F3KupISPWLryjefVMAPOWgf83HXLrDh6EO1MKoPfib6VibtjjjbPib1A/132","nickname":"断了线的风筝","note":"","ucode":"6A292399F40FD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37121,"discussion_content":"请问jvm报错后，出现jvm进程关闭，有没有方法观测或者设置，让jvm自动重启","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571522645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127376,"user_name":"大俊stan","can_delete":false,"product_type":"c1","uid":1125370,"ip_address":"","ucode":"BD0CB5FC790DDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/fa/1cde88d4.jpg","comment_is_top":false,"comment_ctime":1566669365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566669365","product_id":100010301,"comment_content":"老师你这里讲x8664写写屏障是空操作，我有点不懂你所说的空操作是什么，特别是结合下面final讲的时候","like_count":0},{"had_liked":false,"id":120790,"user_name":"刘大人","can_delete":false,"product_type":"c1","uid":1577210,"ip_address":"","ucode":"F66AE613E80398","user_header":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","comment_is_top":false,"comment_ctime":1564995998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564995998","product_id":100010301,"comment_content":"老师 讲解的语速变慢了 ，挺好的，开始有点快，没来得及想就说下一段了","like_count":0},{"had_liked":false,"id":106086,"user_name":"夕林语","can_delete":false,"product_type":"c1","uid":1264180,"ip_address":"","ucode":"B57681D0C73E1B","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/34/1faac99b.jpg","comment_is_top":false,"comment_ctime":1561169376,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1561169376","product_id":100010301,"comment_content":"这一节的内容确实很干，很晦涩难懂，希望配合图片来讲解，更清晰一点","like_count":0},{"had_liked":false,"id":100138,"user_name":"Knight²º¹⁸","can_delete":false,"product_type":"c1","uid":1089754,"ip_address":"","ucode":"BDCB830B6A730F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg","comment_is_top":false,"comment_ctime":1559456542,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1559456542","product_id":100010301,"comment_content":"JVM 中的工作内存和CPU Cahce又什么关系么？","like_count":0,"discussions":[{"author":{"id":1019659,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/0b/a438de52.jpg","nickname":"0xTang","note":"","ucode":"82F5282EF3044B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259,"discussion_content":"工作内存是JMM（Java内存模型）规范的虚拟概念，可以理解为CPU的缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561364989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100137,"user_name":"Knight²º¹⁸","can_delete":false,"product_type":"c1","uid":1089754,"ip_address":"","ucode":"BDCB830B6A730F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg","comment_is_top":false,"comment_ctime":1559456510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559456510","product_id":100010301,"comment_content":"有了 read 、write指令为啥还需要 load 、store指令？","like_count":0},{"had_liked":false,"id":78860,"user_name":"MacHIne🤐","can_delete":false,"product_type":"c1","uid":1460224,"ip_address":"","ucode":"A2C17DB0F22320","user_header":"https://static001.geekbang.org/account/avatar/00/16/48/00/5451e224.jpg","comment_is_top":false,"comment_ctime":1553260623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553260623","product_id":100010301,"comment_content":"大大，我的理解是这样 上面的volatile并没有保证 读写 b的顺序  而唯一出现(1,2)的可能就是 a的写入在读取前 b的写入也在读取前 而根据hb规则 当出现b的写入在读取前时 编译器无法对1线程进行重排序 那么对<br>a的读取就发生在了写入前， 也就避免了 （1，2），请问这样想对吗","like_count":0},{"had_liked":false,"id":73669,"user_name":"Geek_c991e0","can_delete":false,"product_type":"c1","uid":1206623,"ip_address":"","ucode":"5B6391E2D69D50","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epLLXBLBLgticobxvBYRezd304Y66Q8ibYCl7mG9dvTHGrx9obRcn7ZmJBcib3ibsQPIX3xIbNYiaAUrOA/132","comment_is_top":false,"comment_ctime":1551953753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551953753","product_id":100010301,"comment_content":"老师，你答复的有一段话，我有疑问<br>首先，b加了volatile之后，并不能保证b=1一定先于r1=b，而是保证r1=b始终能够看到b的最新值。比如说b=1;b=2，之后在另一个CPU上执行r1=b，那么r1会被赋值为2。如果先执行r1=b，然后在另外一个CPU上执行b=1和b=2，那么r1将看到b=1之前的值。<br><br>这段话意思是，虽然有happens-before关系，但是如果读在一个线程，而且执行时间在，另外线程的写之前，那其实是读不到最新的值的，是这样吗。 这块是有时序问题吗","like_count":0},{"had_liked":false,"id":69429,"user_name":"snowDreams","can_delete":false,"product_type":"c1","uid":1059644,"ip_address":"","ucode":"705C602CA5B9CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/3c/1d18cb88.jpg","comment_is_top":false,"comment_ctime":1550741390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550741390","product_id":100010301,"comment_content":"JMM仅使用一篇文章讲解,总有点意犹未尽的感觉","like_count":0},{"had_liked":false,"id":67683,"user_name":"加载中……","can_delete":false,"product_type":"c1","uid":1366948,"ip_address":"","ucode":"3E59A0A0784D0A","user_header":"https://static001.geekbang.org/account/avatar/00/14/db/a4/191be6ad.jpg","comment_is_top":false,"comment_ctime":1550222191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550222191","product_id":100010301,"comment_content":"请教个问题，看到留言里面有回复：“在解释执行时，字节码之间也有内存屏障”。这句话意思是不是：解释执行过程中也会动态生成并插入内存屏障，而不是.class文件字节码之间有内存屏障？因为我比较了volatile字段和普通字段的写操作的字节码，没看出来有什么区别。","like_count":0},{"had_liked":false,"id":62110,"user_name":"zzr","can_delete":false,"product_type":"c1","uid":1264429,"ip_address":"","ucode":"04053D1E3EDDB7","user_header":"","comment_is_top":false,"comment_ctime":1547918513,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547918513","product_id":100010301,"comment_content":"编译器为啥要重排序","like_count":0},{"had_liked":false,"id":57547,"user_name":"NickNYU","can_delete":false,"product_type":"c1","uid":1009383,"ip_address":"","ucode":"728933074298E9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJngnbXIXoL0odUt5Ma172x44j0Y9xicdJqpJ3wRXqiaeqxEfJM50FtkHj3cBTKoFuGg5FlXDcLdf1w/132","comment_is_top":false,"comment_ctime":1546831381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546831381","product_id":100010301,"comment_content":"老师，看了很久您的文章，感觉收益颇丰，有个小建议，能否讲到某些知识点的时候，附上JVM的源码就更好了。因为源码更直观一些<br>谢谢老师","like_count":0},{"had_liked":false,"id":50124,"user_name":"侯布阁","can_delete":false,"product_type":"c1","uid":1334961,"ip_address":"","ucode":"EFE746A7A0F8B9","user_header":"https://static001.geekbang.org/account/avatar/00/14/5e/b1/51746dc2.jpg","comment_is_top":false,"comment_ctime":1544874338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544874338","product_id":100010301,"comment_content":"请问老师，解释执行是一行一行执行的，此时会有指令重排序吗？","like_count":0},{"had_liked":false,"id":46781,"user_name":"星星","can_delete":false,"product_type":"c1","uid":1126460,"ip_address":"","ucode":"013714D9EF1847","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/3c/c2c72e28.jpg","comment_is_top":false,"comment_ctime":1543980539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543980539","product_id":100010301,"comment_content":"以 volatile 字段访问为例，所插入的内存屏障将不允许volatile字段写操作之前的内存访问被重排序至其之后；也将不允许volatile字段读操作之后的内存访问被重排序至其之前。1.这里的内存访问指什么？2.赋值操作属于读写操作吗？<br>","like_count":0},{"had_liked":false,"id":32270,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1539508560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539508560","product_id":100010301,"comment_content":"读完全文我也有个和另一位读者相同的疑问：到底什么是内存模型？按照老师的解释感觉是说内存模型定义了变量的读写顺序，但还是没有直接对“内存模型”这个概念进行解释。那内存模型是不是和Java Jvm内存分类这种模块结构完全不同，内存模型只是一个理论上的定义，只是对内存访问操作的抽象而不是一个实际存在的或者说我们通常理解的模型，正如《深入理解java虚拟机：jvm高级特性与最佳实践》中提到的：Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。<br>那么请问老师能否用总结性的语言定义下Java内存模型呢？","like_count":0},{"had_liked":false,"id":30121,"user_name":"影子","can_delete":false,"product_type":"c1","uid":1181409,"ip_address":"","ucode":"1731BB8EC24070","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/e1/b2910060.jpg","comment_is_top":false,"comment_ctime":1538671688,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1538671688","product_id":100010301,"comment_content":"你好。这里在看jvm内存模型的时候遇到一个问题。java执行native方法时程序计数器为空。那执行完native方法之后是继续执行下去的呢？","like_count":0,"discussions":[{"author":{"id":1191290,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2d/7a/6d5157d9.jpg","nickname":"旋转跳跃俺闭着眼","note":"","ucode":"F92B7246A9CDBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2477,"discussion_content":"栈桢当中有返回地址吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563697135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29516,"user_name":"✈飞恒棋🚀","can_delete":false,"product_type":"c1","uid":1185413,"ip_address":"","ucode":"72BB43D878AF8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/85/306ffa8a.jpg","comment_is_top":false,"comment_ctime":1538400881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538400881","product_id":100010301,"comment_content":"老师，多线程的happen before操作其实都是发生在一个CPU中的吧，如果是另一个CPU，就没有效果了吧？我这样理解对吗？","like_count":0},{"had_liked":false,"id":22027,"user_name":"Rye","can_delete":false,"product_type":"c1","uid":1175100,"ip_address":"","ucode":"5BDC40ED641A6C","user_header":"https://static001.geekbang.org/account/avatar/00/11/ee/3c/a2b67971.jpg","comment_is_top":false,"comment_ctime":1535452669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535452669","product_id":100010301,"comment_content":"CPU无法直接操作内存地址，需要借助寄存器，volatile只是告诉编译器用的时候取最新的，但不能保证原子性，读，改，存至少3条CPU指令。","like_count":0},{"had_liked":false,"id":20869,"user_name":"梦想启动的蜗牛","can_delete":false,"product_type":"c1","uid":1111602,"ip_address":"","ucode":"781F2A6DA6FEB3","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/32/358f9411.jpg","comment_is_top":false,"comment_ctime":1534780666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534780666","product_id":100010301,"comment_content":"再次复习下👍🏻","like_count":0}]}