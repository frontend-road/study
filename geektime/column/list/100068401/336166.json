{"id":336166,"title":"11 | 依赖混乱：你可能还没发现问题，代码就已经无法挽救了","content":"<p>你好，我是郑晔。</p><p>我们前面已经讲了许多坏味道，无论是你很容易接受的，还是挑战你编程习惯的，它们都有相对直观的表现形式，属于你很容易一下子就看出来问题的。这一讲，我们要讲的坏味道就不属于一下子就能看出来的，需要你稍微仔细一点看代码才会发现问题，那就是依赖关系。</p><p>我前面在讲“大类”这个坏味道的时候曾经说过，为了避免同时面对所有细节，我们需要把程序进行拆分，分解成一个又一个的小模块。但随之而来的问题就是，我们需要把这些拆分出来的模块按照一定的规则重新组装在一起，这就是依赖的缘起。</p><p>一个模块要依赖另外一个模块完成完整的业务功能，而到底怎么去依赖，这里就很容易产生问题。</p><h2>缺少防腐层</h2><p>我们还是先来看一段代码：</p><pre><code>@PostMapping(&quot;/books&quot;)\npublic NewBookResponse createBook(final NewBookRequest request) {\n  boolean result = this.service.createBook(request);\n  ...\n}\n</code></pre><p>这段代码是创建一部作品的入口，也就是说，它提供了一个 REST 服务，只要我们对/books 这个地址发出一个 POST 请求，就可以创建一部作品出来。那么，这段代码有问题吗？</p><p>按照一般代码的分层逻辑，一个 Resource （有的团队称之为 Controller）调用一个 Service，这符合大多数人的编程习惯，所以看起来，这段代码简直是正常得不能再正常了，这能有什么问题？</p><p>从 Resource 调用 Service，这几乎是行业里的标准做法，是没有问题的，但问题出在传递的参数上。请问，这个 NewBookRequest 的参数类应该属于哪一层，是 resource 层，还是 service 层呢？</p><!-- [[[read_end]]] --><p>一般来说，既然它是一个请求参数，通常要承载着诸如参数校验和对象转换的职责，按照我们通常的理解，它应该属于 resource 层。如果这个理解是正确的，问题就来了，它为什么会传递给 service 层呢？</p><p>按照通常的架构设计原则，service 层属于我们的核心业务，而 resource 层属于接口。二者相较而言，核心业务的重要程度更高一些，所以，它的稳定程度也应该更高一些。同样的业务，我们可以用 REST 的方式对外提供，也可以用 RPC 的方式对外提供。</p><p>说到这，你就会发现一个问题，NewBookRequest 这个本来应该属于接口层的参数，现在成了核心业务的一部分，也就是说，即便将来我们提供了 RPC 的接口，它也要知道 REST 的接口长什么样子，显然，这是有问题的。</p><p>既然 NewBookRequest 属于resource 层是有问题的，那我们假设它属于 service 层呢？正如我们前面所说，一般请求都要承担对象校验和转化的工作。如果说这个类属于 service 层，但它用在了 resource 的接口上，作为 resource 的接口，它会承载一些校验和对象转换的角色，而 service 层的参数是不需要关心这些的。如果 NewBookRequest 属于 service 层，那校验和对象转换的职责到底由谁来完成呢？</p><p>还有更关键的一点是，有时候 service 层的参数和 resource 层的参数并不是严格地一一对应。比如，创建作品时，我们需要一个识别作者身份的用户 ID，而这个参数并不是通过客户端发起的请求参数带过来，而是根据用户登录信息进行识别的。所以，用 service 层的参数做 resource 层的参数，就存在差异的参数如何处理的问题。</p><p>你有没有发现，我们突然陷入了一种两难的境地，<strong>如此一个简单的参数，放到哪个层里都有问题。</strong></p><p>这是一种非常常见的代码，你去翻看自己的代码仓库，也许就能找到类似的代码。不过，很有可能在学习到这一课之前，你根本没有想过这种代码也是有问题的。</p><p>那这个问题该如何解呢？</p><p>其实，之所以我们这么纠结，一个关键点在于，我们缺少了一个模型。</p><p>NewBookRequest 之所以弄得如此“里外不是人”，主要就是因为它只能扮演一个层中的模型，所以，我们只要再引入一个模型就可以破解这个问题。</p><pre><code>class NewBookParameter {\n  ...\n}\n\n\nclass NewBookRequest {\n  public NewBookParameters toNewBookRequest() {\n    ...\n  }\n}\n\n\n@PostMapping(&quot;/books&quot;)\npublic NewBookResponse createBook(final NewBookRequest request) {\n  boolean result = this.service.createBook(request.toNewBookParameter());\n  ...\n}\n</code></pre><p>这里我们引入了一个 NewBookParameter 类，把它当作 service 层创建作品的入口，而在 resource 中，我们将 NewBookRequest 这个请求类的对象转换成了 NewBookParameter 对象，然后传到 service 层。</p><p>在这个结构中，NewBookParameter 属于 service 层，而 NewBookRequest 属于 resource 层，二者相互独立，我们之前纠结的问题也就不复存在了。</p><p>好，现在我们理解了，通过增加一个模型，我们就破解了依赖关系上的纠结。</p><p>也许你会说，虽然它们成了两个类，但是，它们两个应该长得一模一样吧。这算不算是一种重复呢？但我的问题是，它们两个为什么要一样呢？有了两层不同的参数，我们就可以给不同层次上的模型以不同的约定了。</p><p>比如，对于 resource 层的请求对象，因为它的主要作用是传输，所以，一般来说，我们约定请求对象的字段主要是基本类型。而 service 的参数对象，因为它已经是核心业务的一部分，就需要全部转化为业务对象。举个例子，比如，同样表示价格，在请求对象中，我们可以是一个 double 类型，而在业务参数对象中，它应该是 Price 类型。</p><p>我们再来解决 resource 层参数和 service 层参数不一致的情况，现在二者分开了，那我们就很清楚地知道，其实，就是在业务参数对象构造的时候，传入必需的参数即可。比如，如果我们需要传入 userId，可以这么做：</p><pre><code>class NewBookRequest {\n  public NewBookParameters toNewBookRequest(long userId) {\n    ...\n  }\n}\n\n\n@PostMapping(&quot;/books&quot;)\npublic NewBookResponse createBook(final NewBookRequest request, final Authentication authentication) {\n  long userId = getUserIdentity(authentication);\n  boolean result = this.service.createBook(request.toNewBookParameter(userId));\n  ...\n}\n</code></pre><p>我们之所以能注意到这个坏味道，就是从依赖关系入手发现的问题。我当初注意到这段代码，因为我团队内部的约定是，所有的请求对象都属于 resource 层，但在这段代码里，service 层出现了 resource 层的对象，它背离了我们对依赖关系设计的约定，所以，这个问题就浮出了水面。</p><p>实际上，这个问题也是一个典型的软件设计问题：缺少防腐层。我在《<a href=\"https://time.geekbang.org/column/intro/100022301\">10x 程序员工作法</a>》和《<a href=\"https://time.geekbang.org/column/intro/100052601\">软件设计之美</a>》两个专栏都讲到过防腐层的概念，只不过，讲防腐层的时候，我举的例子都是与外部系统集成，其中的观点就是通过防腐层将外部系统和核心业务隔离开来。</p><p>而很多人初见这个例子，可能压根想不到它与防腐层的关系，那只不过是因为你对这种结构太熟悉了。其实，resource 层就是外部请求和核心业务之间的防腐层。只要理解了这一点，你就能理解这里要多构建出一个业务参数对象的意义了。那下面这段代码，想必你也能轻易地发现问题：</p><pre><code>@Entity\n@Table(name = &quot;user&quot;)\n@JsonIgnoreProperties(ignoreUnknown = true)\nclass User {\n  ...\n}\n</code></pre><p>这是一个 User 类的声明，它有 @Entity 这个 Anntation，表示它是一个业务实体的对象，但它的上面还出现了@JsonIgnoreProperties，这是就是处理 JSON 的一个 Annotation。JSON 会在哪用到，通常都是在传输中。业务实体和传输对象应该具备的特质在同一个类中出现，显然，这也是没有构建好防腐层的结果，把两个职责混在了一起。</p><h2>业务代码里的具体实现</h2><p>好，我们再来看一段代码：</p><pre><code>@Task\npublic void sendBook() {\n  try {\n    this.service.sendBook();\n  } catch (Throwable t) {\n    this.feishuSender.send(new SendFailure(t)));\n    throw t;\n  }\n}\n</code></pre><p>这是我们在“<a href=\"https://time.geekbang.org/column/article/325794\">重复代码</a>”那一讲中提到的一个发送作品信息的函数，这里的重点在于，一旦发送过程出了问题，要通过即时通信工具发送给相关人等，以防系统出现问题无人发觉。只不过，这里给出的是它最初的样子，也就是通过飞书进行消息发送。</p><p>因为需求是通过飞书发送，所以，这里就写了飞书发送。这看上去简直是一个合理得不能再合理的做法了。</p><p>但是，请稍等！这是一种符合直觉的做法，然而，它却不符合设计原则，它违反了依赖倒置原则。</p><p>我曾经在《<a href=\"https://time.geekbang.org/column/intro/100052601\">软件设计之美</a>》中专门用了一讲的篇幅讲解依赖倒置原则，这里我们简单回顾一下：</p><blockquote>\n<p>高层模块不应依赖于低层模块，二者应依赖于抽象。<br>\nHigh-level modules should not depend on low-level modules. Both should depend on abstractions.</p>\n</blockquote><blockquote>\n<p>抽象不应依赖于细节，细节应依赖于抽象。<br>\nAbstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p>\n</blockquote><p>我之所以会注意到这段代码，因为在一段业务处理中出现了一个具体的实现，也就是这里的 feishuSender。</p><p>你需要知道，<strong>业务代码中任何与业务无关的东西都是潜在的坏味道</strong>。</p><p>在这里，飞书肯定不是业务的一部分，它只是当前选择的一个具体实现。换言之，是否选择飞书，与团队当前的状态是相关的，如果哪一天团队切换即时通信软件，这个实现就需要换掉。但是，团队是不可能切换业务的，一旦切换，那就是一个完全不同的系统了。</p><p><strong>识别一个东西是业务的一部分，还是一个可以替换的实现，我们不妨问问自己，如果不用它，是否还有其它的选择？</strong></p><p>就像这里，飞书是可以被其它即时通信软件替换的。另外，常见的中间件，比如，Kafka、Redis、MongoDB 等等，通常也都是一个具体的实现，其它中间件都可以把它替换掉。所以，它们在业务代码里出现，那一定就是一个坏味道了。</p><p>既然我们已经知道了，这些具体的东西是一种坏味道，那该怎么解决呢？你可以引入一个模型，也就是这个具体实现所要扮演的角色，通过它，将业务和具体的实现隔离开来。</p><pre><code>interface FailureSender {\n  void send(SendFailure failure);\n}\n\n\nclass FeishuFailureSenderS implements FailureSender {\n  ...\n}\n</code></pre><p>这里我们通过引入一个 FailureSender，业务层只依赖于这个 FailureSender 的接口就好，而具体的飞书实现可以通过依赖注入的方式注入进去。</p><p>依赖关系是软件开发中非常重要的一个东西，然而，很多程序员在写代码的时候，由于开发习惯的原因，常常会忽略掉依赖关系这件事本身。现在已经有一些工具，可以保证我们在写代码的时候，不会出现严重破坏依赖关系的情况，比如，像前面那种 service 层调用 resource 层的代码。</p><p>在 Java 世界里，我们就可以用 <a href=\"https://www.archunit.org/\">ArchUnit</a> 来保证这一切。看名字就不难发现，它是把这种架构层面的检查做成了单元测试，下面就是这样的一个单元测试：</p><pre><code>@Test\npublic void should_follow_arch_rule() {\n  JavaClasses clazz = new ClassFileImporter().importPackages(&quot;...&quot;);\n  ArchRule rule = layeredArchitecture()\n        .layer(&quot;Resource&quot;).definedBy(&quot;..resource..&quot;)\n        .layer(&quot;Service&quot;).definedBy(&quot;..service..&quot;)\n        .whereLayer(&quot;Resource&quot;).mayNotBeAccessedByAnyLayer()\n        .whereLayer(&quot;Service&quot;).mayOnlyBeAccessedByLayers(&quot;Resource&quot;);\n        \n   rule.check(clazz);       \n}\n</code></pre><p>在这里，我们定义了两个层，分别是 Resource 层和 Service 层，而且我们要求 Resource 层的代码不能被其它层访问，而 Service 层的代码只能由 Resource 层方法访问。这就是我们的架构规则，一旦代码里有违反这个架构规则的代码，这个测试就会失败，问题也就会暴露出来。</p><h2>总结时刻</h2><p>今天我们讲了由于代码依赖关系而产生的坏味道，一种是缺少防腐层，导致不同代码糅合在一起，一种是在业务代码中出现了具体的实现类。</p><p>缺少防腐层，会让请求对象传导到业务代码中，造成了业务与外部接口的耦合，也就是业务依赖了一个外部通信协议。一般来说，业务的稳定性要比外部接口高，这种反向的依赖就会让业务一直无法稳定下来，继而在日后带来更多的问题。解决方案自然就是引入一个防腐层，将业务和接口隔离开来。</p><p>业务代码中出现具体的实现类，实际上是违反了依赖倒置原则。因为违反了依赖倒置原则，业务代码也就不可避免地受到具体实现的影响，也就造成了业务代码的不稳定。识别一段代码是否属于业务，我们不妨问一下，看把它换成其它的东西，是否影响业务。解决这种坏味道就是引入一个模型，将业务与具体的实现隔离开来。</p><p>最后，我们还谈到了有些简单的依赖关系，可以通过工具来进行维护，比如 ArchUnit。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>代码应该向着稳定的方向依赖</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/11/a9/1114d3ae0675a378ebefc42ddb803da9.jpg?wh=2284*3156\" alt=\"\"></p><h2>思考题</h2><p>今天我们讲到了依赖关系，你可以用今天讲到的坏味道衡量一下自己的代码，看有哪些代码是有问题的，欢迎在留言区分享你的发现，也欢迎你把学到的知识分享给你的朋友。</p><p>感谢阅读，我们下一讲再见！</p><p><span class=\"reference\">参考资料：</span></p><p><a href=\"https://time.geekbang.org/column/article/91127\">答疑解惑 | 如何在实际工作中推行新观念？</a></p><p><a href=\"https://time.geekbang.org/column/article/240177\">软件设计到底是什么？</a></p><p><a href=\"https://time.geekbang.org/column/article/264079\">依赖倒置原则：高层代码和底层代码，到底谁该依赖谁？</a></p><p><a href=\"https://time.geekbang.org/column/article/267837\">战略设计：如何划分系统的模块？</a></p>","comments":[{"had_liked":false,"id":275152,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1611336778,"is_pvip":true,"replies":[{"id":"99888","content":"严格地说，持久化对象也应该与业务对象分开，但在实际的项目中，一般来说，持久化对象和业务对象是合在一起的，这么做的主要原因就是，一般持久化都是一个系统在内部完成的，对于一个系统而言，是一种可控的变化。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611450389,"ip_address":"","comment_id":275152,"utype":1}],"discussion_count":4,"race_medal":0,"score":"57445911626","product_id":100068401,"comment_content":"对照DDD，是否可以理解为接口层接收DTO，转换为DO后传入业务层？那么缺少防腐层的问题也可能发生在业务层和持久化层之间，比如业务层直接操作持久化对象(PO)？<br><br>相比把DTO当成DO用，把PO当DO用似乎更常见。除了违反单一职责原则之外，实际使用中似乎问题不大，因为很多系统都是从先从数据表开始设计的。郑老师对此怎么看？","like_count":14,"discussions":[{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344237,"discussion_content":"翻了下郑老师之前的《软件设计之美》，PO和DO混用的潜在危害是影响可测试性。不说了，去改todo代码了…","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1611365930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514234,"discussion_content":"严格地说，持久化对象也应该与业务对象分开，但在实际的项目中，一般来说，持久化对象和业务对象是合在一起的，这么做的主要原因就是，一般持久化都是一个系统在内部完成的，对于一个系统而言，是一种可控的变化。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611450389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043844,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/84/0b8e2d25.jpg","nickname":"邓志国","note":"","ucode":"380AE67ED7B9D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344812,"discussion_content":"我的业务对象和orm对象是分开的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611577469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570985,"discussion_content":"按照六边形架构，po和do也是要隔离的，但是，理性很丰满，具体还要看场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652020796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276210,"user_name":"明星","can_delete":false,"product_type":"c1","uid":1336838,"ip_address":"","ucode":"FE7B4033DDCFEF","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/06/c983b547.jpg","comment_is_top":false,"comment_ctime":1611833525,"is_pvip":false,"replies":[{"id":"100404","content":"这是依赖注入怎么做的事，依赖注入的 bean 其实都是有名字的，可以指定一个名字就好了，也就是 Qulifier。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1612090801,"ip_address":"","comment_id":276210,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23086670005","product_id":100068401,"comment_content":"老师，如果后期把飞书替换成别的消息发送，需要怎么做呢？假如换成email的话，新建一个继承那个FailureSender接口的EmailFailureSenderImp然后加上@Service，再把飞书的那个服务的@Service注释或删除掉吗？","like_count":5,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514630,"discussion_content":"这是依赖注入怎么做的事，依赖注入的 bean 其实都是有名字的，可以指定一个名字就好了，也就是 Qulifier。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612090801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573878,"discussion_content":"或者是用一个list接收Failuresender实现的各类Bean，在写一个select方法，更具传参（email，或者飞书）选择对应的Bean","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653706147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299748,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1624844808,"is_pvip":false,"replies":[{"id":"109371","content":"有教训不可怕，能汲取经验最重要。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1626187224,"ip_address":"","comment_id":299748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14509746696","product_id":100068401,"comment_content":"抽象不依赖于细节，细节依赖于抽象。我们业务中就出现了违反依赖倒置原则。 影响点:当抽象新增一种实现时，业务代码就很难兼容。 到店任务业务由调拨单具体实现来开展，当到店任务新增一种单据，代码写不动了... 增加一种模型，到店任务来进行解藕。具体实现依赖抽象，而抽象不依赖具体实现。这就是血淋淋的教训，也加深了对依赖倒置的理解","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522531,"discussion_content":"有教训不可怕，能汲取经验最重要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626187224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275541,"user_name":"邓志国","can_delete":false,"product_type":"c1","uid":1043844,"ip_address":"","ucode":"380AE67ED7B9D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/84/0b8e2d25.jpg","comment_is_top":false,"comment_ctime":1611577419,"is_pvip":false,"replies":[{"id":"100048","content":"你基本上已经理解了Clean Code。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611645875,"ip_address":"","comment_id":275541,"utype":1}],"discussion_count":4,"race_medal":0,"score":"14496479307","product_id":100068401,"comment_content":"看了bob大叔的干净架构后就改成这样了","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514387,"discussion_content":"你基本上已经理解了Clean Code。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611645875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536501,"discussion_content":"bob大叔是谁？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638797170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2763179,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/29/ab/59a6e437.jpg","nickname":"Kevin","note":"","ucode":"3588850B3370C8","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547338,"discussion_content":"Robert C. Martin，软件行业泰斗级人物，世界级编程大师。他是设计模式和敏捷开发先驱，敏捷联盟首任主席，C++ Report前主编，被后辈程序员尊称为“Bob大叔”。\n\n\n\nBob大叔是一名多产的作家，先后出版了《UML：Java程序员指南》《敏捷软件开发：原则、模式和实践》《代码整洁之道》《代码整洁之道：程序员的职业素养》等。其中，整洁之道系列成为了国内外数百万程序员的案头读物，豆瓣均分高达8.9。今年，Bob大叔的新书《敏捷整洁之道：回归本源》正好构成了“整洁之道”三部曲。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1642641118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536501,"ip_address":""},"score":547338,"extra":""},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2763179,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/29/ab/59a6e437.jpg","nickname":"Kevin","note":"","ucode":"3588850B3370C8","race_medal":5,"user_type":1,"is_pvip":true},"discussion":{"id":547455,"discussion_content":"谢谢，现在正在读Bob大叔的《代码整洁之道》，十分震撼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642680757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547338,"ip_address":""},"score":547455,"extra":""}]}]},{"had_liked":false,"id":301805,"user_name":"pc","can_delete":false,"product_type":"c1","uid":1652836,"ip_address":"","ucode":"1AD538B9A900B6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","comment_is_top":false,"comment_ctime":1625891093,"is_pvip":false,"replies":[{"id":"109368","content":"你要习惯于用业务术语去表达，而不仅仅是技术术语。封装是为了概念，而不单纯是为了封装。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1626186493,"ip_address":"","comment_id":301805,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10215825685","product_id":100068401,"comment_content":"想引申问一个问题，service层的参数也用struct&#47;class来表达，就会构建很多类，感觉很别扭，这是没问题的吗？","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523092,"discussion_content":"你要习惯于用业务术语去表达，而不仅仅是技术术语。封装是为了概念，而不单纯是为了封装。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626186493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325072,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1638797300,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5933764596","product_id":100068401,"comment_content":"看了之后对夸层调用恍然大悟","like_count":1,"discussions":[{"author":{"id":1308935,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f9/07/85e0fb90.jpg","nickname":"阳","note":"","ucode":"FE9BD0D90D7837","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578276,"discussion_content":"同感，之前想了很久","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656639950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275633,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1611626308,"is_pvip":false,"replies":[{"id":"100050","content":"参数类属于业务层，不用纠结它属于什么，它就是一个参数。<br><br>具体的转换其实就是一个工厂方法，放到 Request 里面而不是单独放置，就不用多谢一个额外的类了。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611646050,"ip_address":"","comment_id":275633,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5906593604","product_id":100068401,"comment_content":"1.所以说，按ddd的分层。应用层不能接收dto，应当新建一个参数类（这样工厂类的实现不依赖dto倒是很好保证了）？那么这个参数类归属什么？感觉不属于实体也不属于值对象。<br>2.dto转pojo感觉还是不好。虽然从职责分配的角度看，dto能满足pojo创建的诉求，所以归属到dto做pojo的工厂方法。但这样dto就依赖了pojo，而这个依赖是非强必要的，所以减少依赖可能更好，借助工具单独实现一个dto转pojo的转换器。<br>","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514422,"discussion_content":"参数类属于业务层，不用纠结它属于什么，它就是一个参数。\n\n具体的转换其实就是一个工厂方法，放到 Request 里面而不是单独放置，就不用多谢一个额外的类了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611646050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345080,"discussion_content":"1.工厂层在domain，这个参数放在domain会不会更合适？\n\n2.转换器这个，主要考虑到部分dto会单独成包。这时候参数类不该暴露出去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611655047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275477,"user_name":"岁月神偷","can_delete":false,"product_type":"c1","uid":1484111,"ip_address":"","ucode":"BA851259EA1F71","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/4f/592d00f2.jpg","comment_is_top":false,"comment_ctime":1611558123,"is_pvip":false,"replies":[{"id":"100049","content":"接口要稳定，实现可以变。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1611645898,"ip_address":"","comment_id":275477,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5906525419","product_id":100068401,"comment_content":"提供稳定的接口，去除不稳定的实现","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514366,"discussion_content":"接口要稳定，实现可以变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611645898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350181,"user_name":"阳","can_delete":false,"product_type":"c1","uid":1308935,"ip_address":"","ucode":"FE9BD0D90D7837","user_header":"https://static001.geekbang.org/account/avatar/00/13/f9/07/85e0fb90.jpg","comment_is_top":false,"comment_ctime":1656640504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656640504","product_id":100068401,"comment_content":"感谢老师的分享，解了自己很久的疑惑。有个问题请教，防腐层的目录该如何组织，既然不属于resource和service层，他该放在哪个目录，如何命名。有没有参考的完整工程目录组织供学习参考？","like_count":0},{"had_liked":false,"id":349050,"user_name":"Geek_c1529b","can_delete":false,"product_type":"c1","uid":2109369,"ip_address":"","ucode":"499C770AA15ADA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo2nk9s8GOOf9YRlp25PIiaLjib3X6XwY7AnTibHDc0AibZlmtWKaYtlSkQsmicclf5mNGyYZcXEOFhGhQ/132","comment_is_top":false,"comment_ctime":1655693887,"is_pvip":false,"replies":[{"id":"127341","content":"其实可以忽略它，这不是重点","user_name":"作者回复","user_name_real":"编辑","uid":"1258861","ctime":1656405266,"ip_address":"","comment_id":349050,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1655693887","product_id":100068401,"comment_content":"老师，您好，请教个事情，@Task这个注解是做什么用的？是线程池吗？能否给个包全路径","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577894,"discussion_content":"其实可以忽略它，这不是重点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656405266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347369,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1653973041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653973041","product_id":100068401,"comment_content":"代码应该向着稳定的方向依赖--记下来","like_count":0},{"had_liked":false,"id":345127,"user_name":"Grandia","can_delete":false,"product_type":"c1","uid":1073579,"ip_address":"","ucode":"98BE1967EE70BE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLtFichtxjKLu1AkyugjHCkeKhrQIp54b1QAQRfIQnygbzvOOhXzzLn2lKF3wAjunRTftzP8VwE91w/132","comment_is_top":false,"comment_ctime":1652066987,"is_pvip":false,"discussion_count":1,"race_medal":2,"score":"1652066987","product_id":100068401,"comment_content":"如果resource层对外返回NewSearchResponse，是否在service层定义个新NewSearchParameter类，resource将service层返回的数据转换成NewSearchResponse后输出呢？<br>resource层能否将service层返回内容直接输出呢？","like_count":0,"discussions":[{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580647,"discussion_content":"为了便于测试，建议转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658303925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343556,"user_name":"ONLY","can_delete":false,"product_type":"c1","uid":1049147,"ip_address":"","ucode":"180990E586D060","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/3b/b4a47f63.jpg","comment_is_top":false,"comment_ctime":1650904656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650904656","product_id":100068401,"comment_content":"这里我有一个疑问，我们做rpc服务经常会把protobuf定义的结构直接用到dao层才转换为dao层需要的结构，这样可以免去转换对象的麻烦，很多大厂也是这么做，还有的会把protobuf的文件解析出http的请求结构这样一套结构能够复用，切免去对象相互转换的开销不也是挺好?方便性能和这代码的味道如何平衡?","like_count":0},{"had_liked":false,"id":335751,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1645673008,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1645673008","product_id":100068401,"comment_content":"老师，能开一讲专门讲讲接口规范么，包括rest 接口命名这些","like_count":0,"discussions":[{"author":{"id":1107371,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","nickname":"2018","note":"","ucode":"4C2CD47AD70177","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580222,"discussion_content":"Google 接口规范了解一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658022291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307451,"user_name":"bigben","can_delete":false,"product_type":"c1","uid":1169313,"ip_address":"","ucode":"DBD15A6C8E2590","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkeOAC8k7aPMfQZ4ickiavpfR9mTQs1wGhGtIicotzAoszE5qkLfFTabkDU2E39ovSgoibJ1IiaLXtGicg/132","comment_is_top":false,"comment_ctime":1629107604,"is_pvip":false,"replies":[{"id":"111578","content":"如果你这里的 dubbo 接口指的是 dubbo 框架本身的接口，那它不属于这里任何一层。它只是一种实现，不在业务中，需要适配到业务接口中。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1629417126,"ip_address":"","comment_id":307451,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629107604","product_id":100068401,"comment_content":"dubbo接口是resource层还是service层？","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525152,"discussion_content":"如果你这里的 dubbo 接口指的是 dubbo 框架本身的接口，那它不属于这里任何一层。它只是一种实现，不在业务中，需要适配到业务接口中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629417126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}