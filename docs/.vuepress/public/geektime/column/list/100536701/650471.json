{"id":650471,"title":"18｜拦截器 ：如何在方法前后进行拦截？","content":"<p>你好，我是郭屹，今天我们继续手写MiniSpring。</p><p>前面，我们用JDK动态代理技术实现了AOP，并且进行了解耦，采用IoC容器来管理代理对象，实现了非侵入式编程。我们现在能在不影响业务代码的前提下，进行逻辑的增强工作，比如打印日志、事务处理、统计接口耗时等等，将这些例行性逻辑作为一种增强放在代理中，运行时动态插入（编织）进去。</p><p>有了这个雏形，我们自然就会进一步考虑，在这个代理结构的基础上，将动态添加逻辑这件事情做得更加结构化一点，而不是全部简单地堆在invoke()方法里。</p><h2>引入三个概念</h2><p>我们先来看看invoke()这个方法的代码在结构方面有什么问题。</p><pre><code class=\"language-plain\">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\tif (method.getName().equals(\"doAction\")) {\n\t\t System.out.println(\"-----before call real object, dynamic proxy........\");\n\t\t return method.invoke(target, args);&nbsp;\n\t}\n\treturn null;\n}\n</code></pre><!-- [[[read_end]]] --><p>我们看到，在实际调用某个方法的时候，是用的反射直接调用method，对应在代码里也就是 <code>method.invoke(target,args);</code> 这一句。而增强的例行性代码是直接写在method.invoke()这个方法前面的，也就是上面代码里的 <code>System.out.println())</code>。这么做当然没有错，不过扩展性不好。这里我们还是使用那个老办法，<strong>不同的功能由不同的部件来做</strong>，所以这个增强逻辑我们可以考虑抽取出一个专门的部件来做，实际业务方法的调用也可以包装一下。</p><p>所以这节课，我们引入以下几个概念。</p><ul>\n<li>Advice：表示这是一个增强操作。</li>\n<li>Interceptor：拦截器，它实现的是真正的增强逻辑。</li>\n<li>MethodInterceptor：调用方法上的拦截器，也就是它实现在某个方法上的增强。</li>\n</ul><p>通过这几个概念，我们就可以把例行性逻辑单独剥离出来了。现在我们要做一个切面，只需要实现某个Interceptor就可以了。</p><p>对应地，我们定义一下Advice、Interceptor、MethodInterceptor这几个接口。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic interface Advice {\n}\n</code></pre><pre><code class=\"language-java\">package com.minis.aop;\npublic interface Interceptor extends Advice{\n}\n</code></pre><pre><code class=\"language-java\">package com.minis.aop;\npublic interface MethodInterceptor extends Interceptor{\n    Object invoke(MethodInvocation invocation) throws Throwable;\n}\n</code></pre><p>MethodInterceptor就是方法上的拦截器，对外就是一个invoke()方法。拦截器不仅仅会增强逻辑，它内部也会调用业务逻辑方法。因此，对外部程序而言，只需要使用这个MethodInterceptor就可以了。</p><p>它需要传入一个MethodInvocation，然后调用method invocation的proceed()方法，MethodInvocation实际上就是以前通过反射方法调用业务逻辑的那一段代码的包装。。</p><pre><code class=\"language-java\">public interface MethodInvocation {\n   Method getMethod();\n   Object[] getArguments();\n   Object getThis();\n   Object proceed() throws Throwable;\n}\n</code></pre><p>我们再来看一下应用程序员的工作，为了插入切面，需要在invoke()中实现自己的业务增强代码。</p><pre><code class=\"language-plain\">public class TracingInterceptor implements MethodInterceptor {\n\tpublic Object invoke(MethodInvocation i) throws Throwable {\n\t\tSystem.out.println(\"method \"+i.getMethod()+\" is called on \"+\n\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i.getThis()+\" with args \"+i.getArguments());\n\t\tObject ret=i.proceed();\n\t\tSystem.out.println(\"method \"+i.getMethod()+\" returns \"+ret);\n\t\treturn ret;\n&nbsp; &nbsp;}\n}\n</code></pre><p>中间的i.proceed()才是真正的目标对象的方法调用。</p><pre><code class=\"language-plain\">public Object proceed() throws Throwable {\n\treturn this.method.invoke(this.target, this.arguments);\n}\n</code></pre><h2>改造代理类</h2><p>有了上面准备好的这些部件，我们在动态代理中如何使用它们呢？这里我们再引入一个Advisor接口。</p><pre><code class=\"language-plain\">\tpublic interface Advisor {\n\t\tMethodInterceptor getMethodInterceptor();\n\t\tvoid setMethodInterceptor(MethodInterceptor methodInterceptor);\n\t}\n</code></pre><p>在代理类ProxyFactoryBean里增加Advisor属性和拦截器。</p><pre><code class=\"language-plain\">    private String interceptorName;\t\n    private Advisor advisor;\n</code></pre><p>这样，我们的代理类里就有跟拦截器关联的点了。</p><p>接下来，为了在目标对象调用前进行拦截，我们就需要调整这个ProxyFactoryBean，并设置其Advisor属性，同时定义这个initializeAdvisor方法来进行关联。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic class ProxyFactoryBean implements FactoryBean&lt;Object&gt; {\n    private BeanFactory beanFactory;\n    private String interceptorName;\n    private Advisor advisor;\n    \n    private synchronized void initializeAdvisor() {\n        Object advice = null;\n        MethodInterceptor mi = null;\n        try {\n            advice = (MethodInterceptor) this.beanFactory.getBean(this.interceptorName);\n        } catch (BeansException e) {\n            e.printStackTrace();\n        }\n        advisor = new DefaultAdvisor();\n        advisor.setMethodInterceptor((MethodInterceptor)advice);\n    }\n}\n</code></pre><p>通过ProxyFactoryBean代码实现可以看出，里面新增了initializeAdvisor处理，将应用程序自定义的拦截器获取到Advisor里。并且，可以在IoC容器中配置这个Interceptor名字。</p><p>在initializeAdvisor里，我们把Advisor初始化工作交给了DefaultAdvisor。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic class DefaultAdvisor implements Advisor{\n    private MethodInterceptor methodInterceptor;\n    public DefaultAdvisor() {\n    }\n    public void setMethodInterceptor(MethodInterceptor methodInterceptor) {\n        this.methodInterceptor = methodInterceptor;\n    }\n    public MethodInterceptor getMethodInterceptor() {\n        return this.methodInterceptor;\n    }\n}\n</code></pre><p>随后，我们修改AopProxyFactory中createAopProxy接口的方法签名，新增Advisor参数。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic interface AopProxyFactory {\n    AopProxy createAopProxy(Object target, Advisor advisor);\n}\n</code></pre><p>修改接口后，我们需要相应地修改其实现方法。在ProxyFactoryBean中，唯一的实现方法就是createAopProxy()。</p><pre><code class=\"language-java\">protected AopProxy createAopProxy() {\n    return getAopProxyFactory().createAopProxy(target);\n}\n</code></pre><p>在这个方法中，我们对前面引入的Advisor进行了赋值。修改之后，代码变成了这样。</p><pre><code class=\"language-java\">protected AopProxy createAopProxy() {\n    return getAopProxyFactory().createAopProxy(target，this.advisor);\n}\n</code></pre><p>默认实现是DefaultAopProxyFactory与JdkDynamicAopProxy，这里要一并修改。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic class DefaultAopProxyFactory implements AopProxyFactory{\n    @Override\n    public AopProxy createAopProxy(Object target, Advisor advisor) {\n        return new JdkDynamicAopProxy(target, advisor);\n    }\n}\n</code></pre><pre><code class=\"language-java\">package com.minis.aop;\npublic class JdkDynamicAopProxy implements AopProxy, InvocationHandler {\n    Object target;\n    Advisor advisor;\n    public JdkDynamicAopProxy(Object target, Advisor advisor) {\n        this.target = target;\n        this.advisor = advisor;\n    }\n    @Override\n    public Object getProxy() {\n        Object obj = Proxy.newProxyInstance(JdkDynamicAopProxy.class.getClassLoader(), target.getClass().getInterfaces(), this);\n        return obj;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (method.getName().equals(\"doAction\")) {\n            Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);\n            MethodInterceptor interceptor = this.advisor.getMethodInterceptor();\n            MethodInvocation invocation =\n                    new ReflectiveMethodInvocation(proxy, target, method, args, targetClass);\n            return interceptor.invoke(invocation);\n        }\n        return null;\n    }\n}\n\n</code></pre><p>在JdkDynamicAopProxy里我们发现，invoke方法和之前相比有了不小的变化，在调用某个方法的时候，不再是直接用反射调用方法了，而是先拿到Advisor里面的Interceptor，然后把正常的method调用包装成ReflectiveMethodInvocation，最后调用interceptor.invoke(invocation)，对需要调用的方法进行了增强处理。</p><p>你把这一段和之前的invoke()进行比对，可以看出，通过Interceptor这个概念，我们就把增强逻辑单独剥离出来了。</p><p>你可以看一下实际的ReflectiveMethodInvocation类，其实就是对反射调用方法进行了一次包装。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic class ReflectiveMethodInvocation implements MethodInvocation{\n    protected final Object proxy;\n    protected final Object target;\n    protected final Method method;\n    protected Object[] arguments;\n    private Class&lt;?&gt; targetClass;\n    protected ReflectiveMethodInvocation(\n            Object proxy,  Object target, Method method,  Object[] arguments,\n            Class&lt;?&gt; targetClass) {\n        this.proxy = proxy;\n        this.target = target;\n        this.targetClass = targetClass;\n        this.method = method;\n        this.arguments = arguments;\n    }\n    \n    //省略getter/setter\n    \n    public Object proceed() throws Throwable {\n        return this.method.invoke(this.target, this.arguments);\n    }\n}\n</code></pre><h2>测试</h2><p>我们现在可以来编写一下测试代码，定义TracingInterceptor类模拟业务拦截代码。</p><pre><code class=\"language-java\">package com.test.service;\nimport com.minis.aop.MethodInterceptor;\nimport com.minis.aop.MethodInvocation;\npublic class TracingInterceptor implements MethodInterceptor {\n    @Override\n    public Object invoke(MethodInvocation i) throws Throwable {\n        System.out.println(\"method \"+i.getMethod()+\" is called on \"+\n                i.getThis()+\" with args \"+i.getArguments());\n        Object ret=i.proceed();\n        System.out.println(\"method \"+i.getMethod()+\" returns \"+ret);\n        return ret;\n    }\n}\n</code></pre><p>applicationContext.xml配置文件：</p><pre><code class=\"language-xml\">   &lt;bean id=\"myInterceptor\" class=\"com.test.service.TracingInterceptor\" /&gt;\n   &lt;bean id=\"realaction\" class=\"com.test.service.Action1\" /&gt;\n   &lt;bean id=\"action\" class=\"com.minis.aop.ProxyFactoryBean\" &gt;\n      &lt;property type=\"java.lang.Object\" name=\"target\" ref=\"realaction\"/&gt;\n      &lt;property type=\"String\" name=\"interceptorName\" value=\"myInterceptor\"/&gt;\n   &lt;/bean&gt;\n</code></pre><p>配置文件里，除了原有的target，我们还增加了一个interceptorName属性，让程序员指定需要启用什么样的增强。</p><p>到这里，我们就实现了MethodInterceptor。</p><h2>在方法前后拦截</h2><p>我们现在实现的方法拦截，允许程序员自行编写invoke()方法，进行任意操作。但是在许多场景下，调用方式实际上是比较固定的，即在某个方法调用之前或之后，允许程序员插入业务上需要的增强。为了满足这种情况，我们可以提供特定的方法拦截，并允许程序员在这些拦截点之前和之后进行业务增强的操作。这种方式就大大简化了程序员的工作。</p><p>所以这里我们新增两种advice：MethodBeforeAdvice和AfterReturningAdvice。根据名字也可以看出来，它们分别对应方法调用前处理和返回后的处理。你可以看一下它们的定义。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic interface BeforeAdvice extends Advice{\n}\n</code></pre><pre><code class=\"language-java\">package com.minis.aop;\npublic interface AfterAdvice extends Advice{\n}\n</code></pre><pre><code class=\"language-java\">package com.minis.aop;\nimport java.lang.reflect.Method;\npublic interface MethodBeforeAdvice extends BeforeAdvice {\n    void before(Method method, Object[] args, Object target) throws Throwable;\n}\n</code></pre><pre><code class=\"language-java\">package com.minis.aop;\nimport java.lang.reflect.Method;\npublic interface AfterReturningAdvice extends AfterAdvice{\n    void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable;\n}\n</code></pre><p>首先我们定义通用接口BeforeAdvice与AfterAdvice，随后定义核心的MethodBeforeAdvice与AfterReturningAdvice接口，它们分别内置了before方法和afterReturning方法。由方法签名可以看出，这两者的区别在于afterReturning它内部传入了返回参数，说明是目标方法执行返回后，再调用该方法，在方法里面可以拿到返回的参数。</p><p>有了新的Advice的定义，我们就可以实现新的Interceptor了。你可以看下实现的代码。</p><pre><code class=\"language-xml\">package com.minis.aop;\npublic class MethodBeforeAdviceInterceptor implements MethodInterceptor, BeforeAdvice {\n    private final MethodBeforeAdvice advice;\n    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {\n        this.advice = advice;\n    }\n    @Override\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());\n        return mi.proceed();\n    }\n}\n</code></pre><p>在这个Interceptor里，invoke()方法的实现实际上就是限制性地使用advice.before()方法，然后执行目标方法的调用，也意味着这是在方法调用之前插入的逻辑。由于这是针对before这种行为的特定Interceptor，因此上层应用程序员无需自己再进行实现，而是可以直接使用这个Interceptor。</p><pre><code class=\"language-xml\">package com.minis.aop;\npublic class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice{\n    private final AfterReturningAdvice advice;\n    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) {\n        this.advice = advice;\n    }\n    @Override\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        Object retVal = mi.proceed();\n        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());\n        return retVal;\n    }\n}\n\n</code></pre><p>同样，由AfterReturningAdviceInterceptor类中对invoke方法的实现可以看出，是先调用mi.proceed()方法获取到了返回值retVal，再调用afterReturning方法，实现的是方法调用之后的逻辑增强，这个时序也是固定的。所以注意了，在advice.afterReturing()方法中，是可以拿到目标方法的返回值的。</p><p>在拦截器的使用中，存在一个有意思的问题，同时也是一个有着广泛争议的话题：拦截器是否应该影响业务程序的流程？比如，在before()拦截器中加入一个返回标志（true/false），当其为false时，我们就中止业务流程并且不再调用目标方法。</p><p>不同的开发者对于这个问题有着不同的主张。一方面，这种机制使得开发者能够根据需要对业务逻辑进行精细控制；另一方面，过度使用这种机制也可能会导致代码难度增加、可维护性降低等问题。因此，在使用拦截器的时候，需要在开发效率和程序可维护性之间做出一个平衡，并根据实际情况做出相应的选择。</p><p>现在我们手上有三种Advice类型了，普通的MethodInterceptor，还有特定的MethodBeforeAdviceInterceptor和AfterReturningAdviceInterceptor，自然在ProxyFactoryBean中也要对这个initializeAdvisor方法进行改造，分别支持三种不同类型的Advice。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic class ProxyFactoryBean implements FactoryBean&lt;Object&gt;, BeanFactoryAware {\n    private synchronized void initializeAdvisor() {\n        Object advice = null;\n        MethodInterceptor mi = null;\n        try {\n            advice = this.beanFactory.getBean(this.interceptorName);\n        } catch (BeansException e) {\n            e.printStackTrace();\n        }\n        if (advice instanceof BeforeAdvice) {\n            mi = new MethodBeforeAdviceInterceptor((MethodBeforeAdvice)advice);\n        }\n        else if (advice instanceof AfterAdvice) {\n            mi = new AfterReturningAdviceInterceptor((AfterReturningAdvice)advice);\n        }\n        else if (advice instanceof MethodInterceptor) {\n            mi = (MethodInterceptor)advice;\n        }\n        advisor = new DefaultAdvisor();\n        advisor.setMethodInterceptor(mi);\n    }\n}\n</code></pre><p>上述实现比较简单，根据不同的Advice类型进行判断，最后统一用MethodInterceptor来封装。</p><h2>测试</h2><p>在这一步改造完毕后，我们测试一下，这里我们提供的是比较简单的实现，实际开发过程中你可以跟据自己的需求定制开发。</p><p>我们先提供两个Advice。</p><pre><code class=\"language-java\">package com.test.service;\npublic class MyAfterAdvice implements AfterReturningAdvice {\n    @Override\n    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n        System.out.println(\"----------my interceptor after method call----------\");\n    }\n}\n</code></pre><pre><code class=\"language-java\">package com.test.service;\npublic class MyBeforeAdvice implements MethodBeforeAdvice {\n    @Override\n    public void before(Method method, Object[] args, Object target) throws Throwable {\n        System.out.println(\"----------my interceptor before method call----------\");\n    }\n}\n</code></pre><p>上述的测试代码都很简单，在此不多赘述。相应的applicationContext.xml这个配置文件里面的内容也要发生变化。</p><pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans&gt;\n   &lt;bean id=\"myBeforeAdvice\" class=\"com.test.service.MyBeforeAdvice\" /&gt;\n   &lt;bean id=\"realaction\" class=\"com.test.service.Action1\" /&gt;\n   &lt;bean id=\"action\" class=\"com.minis.aop.ProxyFactoryBean\" &gt;\n      &lt;property type=\"java.lang.Object\" name=\"target\" ref=\"realaction\"/&gt;\n      &lt;property type=\"String\" name=\"interceptorName\" value=\"myBeforeAdvice\"/&gt;\n   &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre><p>将beforeAdvice或者afterAdvice放在配置文件里，除了注册的Bean类名有一些修改，其配置是没有发生任何别的变化的，但经过这样一番改造，我们就能使用上述三类Advice，来对我们的业务代码进行拦截增强处理了。</p><h2>小结</h2><p>这节课我们在简单动态代理结构的基础上，<strong>将动态添加的逻辑设计得更加结构化一点，而不是全部简单地堆在invoke()一个方法中</strong>。为此，我们提出了Advice的概念，表示这是一个增强操作。然后提出Interceptor拦截器的概念，它实现了真正的增强逻辑并包装了目标方法的调用，应用程序中实际使用的就是这个Interceptor。我们实际实现的是MethodInterceptor，它表示的是调用方法上的拦截器。</p><p>我们注意到大部分拦截的行为都是比较固定的，或者在方法调用之前，或者在之后，为了方便处理这些常见的场景，我们进一步分离出了beforeAdvice和afterAdvice。通过这些工作，用户希望插入的例行性逻辑现在都单独抽取成一个部件了，应用程序员只要简单地实现MethodBeforeAdvice和AfterReturningAdvice即可。整个软件结构化很好，完全解耦。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课的内容，我也给你留一道思考题。如果我们希望beforeAdvice能在某种情况下阻止目标方法的调用，应该从哪里下手改造？欢迎你在留言区与我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","comments":[{"had_liked":false,"id":375639,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1685781422,"is_pvip":false,"replies":[{"id":137122,"content":"为了统一处理","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685919637,"ip_address":"澳大利亚","comment_id":375639,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，MethodBeforeAdviceInterceptor为什么也要实现BeforeAdvice接口呢？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620178,"discussion_content":"为了统一处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685919637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374852,"user_name":"Geek_5c6106","can_delete":false,"product_type":"c1","uid":2971813,"ip_address":"湖北","ucode":"99F8A23E44ACC3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtlEYuHnR8VdQSpZcicEsrcpSQZKsthrluPjbv3cMCLF5tM3zbmQ1UnwPUfNoIKNvPer9sH1wS7aA/132","comment_is_top":false,"comment_ctime":1684489494,"is_pvip":false,"replies":[{"id":136774,"content":"它实现了BeanFactoryAware接口，容器对这个接口会有特殊处理:调用setBeanFactory()方法。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684545433,"ip_address":"澳大利亚","comment_id":374852,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，请问一下 ProxyFactoryBean bean中的BeanFactory beanFactory属性是在什么时候的设置值的？\n这个是要在AbstractBeanFactory中设置值的吗？\nif (singleton instanceof FactoryBean) {\n            return this.getObjectForBeanInstance(singleton, beanName);\n        }\ngetObjectForBeanInstance 方法中将this，将值设置到ProxyFactoryBean 中吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618782,"discussion_content":"它实现了BeanFactoryAware接口，容器对这个接口会有特殊处理:调用setBeanFactory()方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684545433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3228991,"avatar":"https://static001.geekbang.org/account/avatar/00/31/45/3f/e4fc2781.jpg","nickname":"梦某人","note":"","ucode":"D9F14B15AC2A12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620499,"discussion_content":"在当前课(没有实现BeanFactoryAware接口的情况下)，我修改了 AutowiredAnnotationBeanPostProcessor 类，并通过自动注入的方式完成了加载。 因为FactoryBean接口并没有定义BeanFactory，也没办法调用setBeanFacotry。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1686217207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国台湾","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3634218,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep9YJC0GnicC7TDcrGFsfAZ6ATQLO29icXSKvntKcAcJGGJN6IibLrzHyp35Lia36fVlpSE8HsicIyOQyw/132","nickname":"Geek_149cde","note":"","ucode":"4447C15B2A083B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623756,"discussion_content":"源码中 getBean() 中有个 instanceof 的判断逻辑，那里设计了 beanFactory","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689781026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385924,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"广东","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1703669340,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"思考题：因为代理对象执行的入口全部都在interceptor.invoke(invocation)这个方法中，如果想要截断，就在具体的XXXInterceptor中处理就可以了","like_count":0},{"had_liked":false,"id":378132,"user_name":"Geek_149cde","can_delete":false,"product_type":"c1","uid":3634218,"ip_address":"","ucode":"4447C15B2A083B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep9YJC0GnicC7TDcrGFsfAZ6ATQLO29icXSKvntKcAcJGGJN6IibLrzHyp35Lia36fVlpSE8HsicIyOQyw/132","comment_is_top":false,"comment_ctime":1689781038,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"这儿测试的时候调用的是 doAction() 方法，但是不太理解为什么调用 doAction() 方法会自动调用 JdkDynamicAopProxy 类中的 invoke() ","like_count":0},{"had_liked":false,"id":375645,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1685783977,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"思考题：可以在MethodBeforeAdviceInterceptor中判断是否对请求进行拦截，业务意义明确","like_count":0}]}