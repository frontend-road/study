{"id":502584,"title":"14｜DI Container（2）：如何通过Sad Path为容器增加功能？","content":"<p>你好，我是徐昊。今天我们将继续使用TDD的方式来实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code>package geektime.tdd.di;\n  \nimport jakarta.inject.Provider;\nimport java.util.HashMap;\nimport java.util.Map;\n    \npublic class Context {\n    private Map&lt;Class&lt;?&gt;, Provider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n    \n    public &lt;ComponentType&gt; void bind(Class&lt;ComponentType&gt; type, ComponentType instance) {\n        providers.put(type, (Provider&lt;ComponentType&gt;) () -&gt; instance);\n    }\n    \n    public &lt;ComponentType, ComponentImplementation extends ComponentType&gt;\n    void bind(Class&lt;ComponentType&gt; type, Class&lt;ComponentImplementation&gt; implementation) {\n        providers.put(type, (Provider&lt;ComponentType&gt;) () -&gt; {\n            try {\n                return (ComponentType) implementation.getConstructor().newInstance();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n    \n    public &lt;ComponentType&gt; ComponentType get(Class&lt;ComponentType&gt; type) {\n        return (ComponentType) providers.get(type).get();\n    }\n}\n</code></pre><p>任务列表状态为：</p><ul>\n<li>\n<p><s>无需构造的组件——组件实例</s></p>\n</li>\n<li>\n<p>如果注册的组件不可实例化，则抛出异常</p>\n<ul>\n<li>抽象类</li>\n<li>接口</li>\n</ul>\n</li>\n<li>\n<p>构造函数注入</p>\n<ul>\n<li><s>无依赖的组件应该通过默认构造函数生成组件实例</s></li>\n<li>有依赖的组件，通过Inject标注的构造函数生成组件实例</li>\n<li>如果所依赖的组件也存在依赖，那么需要对所依赖的组件也完成依赖注入</li>\n<li>如果组件有多于一个Inject标注的构造函数，则抛出异常</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>字段注入</p>\n<ul>\n<li>通过Inject标注将字段声明为依赖组件</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果字段为final则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>方法注入</p>\n<ul>\n<li>通过Inject标注的方法，其参数为依赖组件</li>\n<li>通过Inject标注的无参数方法，会被调用</li>\n<li>按照子类中的规则，覆盖父类中的Inject方法</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果方法定义类型参数，则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>对Provider类型的依赖</p>\n<ul>\n<li>注入构造函数中可以声明对于Provider的依赖</li>\n<li>注入字段中可以声明对于Provider的依赖</li>\n<li>注入方法中可声明对于Provider的依赖</li>\n</ul>\n</li>\n<li>\n<p>自定义Qualifier的依赖</p>\n<ul>\n<li>注册组件时，可额外指定Qualifier</li>\n<li>注册组件时，可从类对象上提取Qualifier</li>\n<li>寻找依赖时，需同时满足类型与自定义Qualifier标注</li>\n<li>支持默认Qualifier——Named</li>\n</ul>\n</li>\n<li>\n<p>Singleton生命周期</p>\n<ul>\n<li>注册组件时，可额外指定是否为Singleton</li>\n<li>注册组件时，可从类对象上提取Singleton标注</li>\n<li>对于包含Singleton标注的组件，在容器范围内提供唯一实例</li>\n<li>容器组件默认不是Single生命周期</li>\n</ul>\n</li>\n<li>\n<p>自定义Scope标注</p>\n<ul>\n<li>可向容器注册自定义Scope标注的回调</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><h2>视频演示</h2><p>让我们进入今天的部分：</p><p><video poster=\"https://media001.geekbang.org/109133d4dd584bdc8af0b1038b7e1865/snapshots/0955bbd5127f415c8fb1ae9937e13536-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/db5fb95-1801774e640-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/6099dd2413b24ec8868482d15db22e8f/76b3297f891b4de38f849698653bacab-bfd744b531ceb7d88ec7ff4210887c26-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p><video poster=\"https://media001.geekbang.org/bc0fb541fdfd4934b7f729b328167784/snapshots/578c764214f64a0f802b097ed570c5a0-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/ab9bdbf-1801774d7e3-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/561278c9fc4b4696abf0bb9f8f354a81/aaa2e332f5084b78a4d5679a6f08dd35-a4cc29fbebebdbfca81fe81c38338693-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2><strong>思考题</strong></h2><p>下一步将要如何重构已有代码？</p><p>欢迎把你的思考和想法分享在留言区，也欢迎你扫描详情页的二维码加入读者交流群。我们下节课再见！</p>","neighbors":{"left":{"article_title":"13 ｜DI Container（1）：如何实现基本的DI容器结构？","id":502058},"right":{"article_title":"15｜DI Container（3）：如何重构已有的代码？","id":502586}},"comments":[{"had_liked":false,"id":344259,"user_name":"JC","can_delete":false,"product_type":"c1","uid":1097553,"ip_address":"","ucode":"A95FACC6EE9851","user_header":"https://static001.geekbang.org/account/avatar/00/10/bf/51/1791ae60.jpg","comment_is_top":false,"comment_ctime":1651403146,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5946370442","product_id":100109401,"comment_content":"第二段视频最后，是不是用 Stream.noneMatch 语义上更好些","like_count":2}]}