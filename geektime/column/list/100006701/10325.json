{"id":10325,"title":"第26讲 | 如何监控和诊断JVM堆内和堆外内存使用？","content":"<p>上一讲我介绍了JVM内存区域的划分，总结了相关的一些概念，今天我将结合JVM参数、工具等方面，进一步分析JVM内存结构，包括外部资料相对较少的堆外部分。</p>\n<p>今天我要问你的问题是，<span class=\"orange\">如何监控和诊断JVM堆内和堆外内存使用？</span></p>\n<h2>典型回答</h2>\n<p>了解JVM内存的方法有很多，具体能力范围也有区别，简单总结如下：</p>\n<ul>\n<li>可以使用综合性的图形化工具，如JConsole、VisualVM（注意，从Oracle JDK 9开始，VisualVM已经不再包含在JDK安装包中）等。这些工具具体使用起来相对比较直观，直接连接到Java进程，然后就可以在图形化界面里掌握内存使用情况。</li>\n</ul>\n<p>以JConsole为例，其内存页面可以显示常见的<strong>堆内存</strong>和<strong>各种堆外部分</strong>使用状态。</p>\n<ul>\n<li>\n<p>也可以使用命令行工具进行运行时查询，如jstat和jmap等工具都提供了一些选项，可以查看堆、方法区等使用数据。</p>\n</li>\n<li>\n<p>或者，也可以使用jmap等提供的命令，生成堆转储（Heap Dump）文件，然后利用jhat或Eclipse MAT等堆转储分析工具进行详细分析。</p>\n</li>\n<li>\n<p>如果你使用的是Tomcat、Weblogic等Java EE服务器，这些服务器同样提供了内存管理相关的功能。</p>\n</li>\n<li>\n<p>另外，从某种程度上来说，GC日志等输出，同样包含着丰富的信息。</p>\n</li>\n</ul><!-- [[[read_end]]] -->\n<p>这里有一个相对特殊的部分，就是是堆外内存中的直接内存，前面的工具基本不适用，可以使用JDK自带的Native Memory Tracking（NMT）特性，它会从JVM本地内存分配的角度进行解读。</p>\n<h2>考点分析</h2>\n<p>今天选取的问题是Java内存管理相关的基础实践，对于普通的内存问题，掌握上面我给出的典型工具和方法就足够了。这个问题也可以理解为考察两个基本方面能力，第一，你是否真的理解了JVM的内部结构；第二，具体到特定内存区域，应该使用什么工具或者特性去定位，可以用什么参数调整。</p>\n<p>对于JConsole等工具的使用细节，我在专栏里不再赘述，如果你还没有接触过，你可以参考<a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html\">JConsole官方教程</a>。我这里特别推荐<a href=\"http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html\">Java Mission Control</a>（JMC），这是一个非常强大的工具，不仅仅能够使用<a href=\"https://en.wikipedia.org/wiki/Java_Management_Extensions\">JMX</a>进行普通的管理、监控任务，还可以配合<a href=\"https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH171\">Java Flight Recorder</a>（JFR）技术，以非常低的开销，收集和分析JVM底层的Profiling和事件等信息。目前， Oracle已经将其开源，如果你有兴趣请可以查看OpenJDK的<a href=\"http://openjdk.java.net/projects/jmc/\">Mission Control</a>项目。</p>\n<p>关于内存监控与诊断，我会在知识扩展部分结合JVM参数和特性，尽量从庞杂的概念和JVM参数选项中，梳理出相对清晰的框架：</p>\n<ul>\n<li>\n<p>细化对各部分内存区域的理解，堆内结构是怎样的？如何通过参数调整？</p>\n</li>\n<li>\n<p>堆外内存到底包括哪些部分？具体大小受哪些因素影响？</p>\n</li>\n</ul>\n<h2>知识扩展</h2>\n<p>今天的分析，我会结合相关JVM参数和工具，进行对比以加深你对内存区域更细粒度的理解。</p>\n<p>首先，堆内部是什么结构？</p>\n<p>对于堆内存，我在上一讲介绍了最常见的新生代和老年代的划分，其内部结构随着JVM的发展和新GC方式的引入，可以有不同角度的理解，下图就是年代视角的堆结构示意图。<br />\n<img src=\"https://static001.geekbang.org/resource/image/72/89/721e97abc93449fbdb4c071f7b3b5289.png?wh=941*351\" alt=\"\" /></p>\n<p>你可以看到，按照通常的GC年代方式划分，Java堆内分为：</p>\n<p>1.新生代</p>\n<p>新生代是大部分对象创建和销毁的区域，在通常的Java应用中，绝大部分对象生命周期都是很短暂的。其内部又分为Eden区域，作为对象初始分配的区域；两个Survivor，有时候也叫from、to区域，被用来放置从Minor GC中保留下来的对象。</p>\n<ul>\n<li>\n<p>JVM会随意选取一个Survivor区域作为“to”，然后会在GC过程中进行区域间拷贝，也就是将Eden中存活下来的对象和from区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</p>\n</li>\n<li>\n<p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，Hotspot JVM还有一个概念叫做Thread Local Allocation Buffer（TLAB），据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。这是JVM为每个线程分配的一个私有缓存区域，否则，多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，进而影响分配速度，你可以参考下面的示意图。从图中可以看出，TLAB仍然在堆上，它是分配在Eden区域内的。其内部结构比较直观易懂，start、end就是起始地址，top（指针）则表示已经分配到哪里了。所以我们分配新对象，JVM就会移动top，当top和end相遇时，即表示该缓存已满，JVM会试图再从Eden里分配一块儿。<br />\n<img src=\"https://static001.geekbang.org/resource/image/f5/bd/f546839e98ea5d43b595235849b0f2bd.png?wh=707*559\" alt=\"\" /></p>\n</li>\n</ul>\n<p>2.老年代</p>\n<p>放置长生命周期的对象，通常都是从Survivor区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p>\n<p>3.永久代</p>\n<p>这部分就是早期Hotspot JVM的方法区实现方式了，储存Java类元数据、常量池、Intern字符串缓存，在JDK 8之后就不存在永久代这块儿了。</p>\n<p>那么，我们如何利用JVM参数，直接影响堆和内部区域的大小呢？我来简单总结一下：</p>\n<ul>\n<li>最大堆体积</li>\n</ul>\n<pre><code>-Xmx value\n</code></pre>\n<ul>\n<li>初始的最小堆体积</li>\n</ul>\n<pre><code>-Xms value\n</code></pre>\n<ul>\n<li>老年代和新生代的比例</li>\n</ul>\n<pre><code>-XX:NewRatio=value\n</code></pre>\n<p>默认情况下，这个数值是2，意味着老年代是新生代的2倍大；换句话说，新生代是堆大小的1/3。</p>\n<ul>\n<li>当然，也可以不用比例的方式调整新生代的大小，直接指定下面的参数，设定具体的内存大小数值。</li>\n</ul>\n<pre><code>-XX:NewSize=value\n</code></pre>\n<ul>\n<li>Eden和Survivor的大小是按照比例设置的，如果SurvivorRatio是8，那么Survivor区域就是Eden的1/8大小，也就是新生代的1/10，因为YoungGen=Eden + 2*Survivor，JVM参数格式是</li>\n</ul>\n<pre><code>-XX:SurvivorRatio=value\n</code></pre>\n<ul>\n<li>TLAB当然也可以调整，JVM实现了复杂的适应策略，如果你有兴趣可以参考这篇<a href=\"https://blogs.oracle.com/jonthecollector/the-real-thing\">说明</a>。</li>\n</ul>\n<p>不知道你有没有注意到，我在年代视角的堆结构示意图也就是第一张图中，还标记出了Virtual区域，这是块儿什么区域呢？</p>\n<p>在JVM内部，如果Xms小于Xmx，堆的大小并不会直接扩展到其上限，也就是说保留的空间（reserved）大于实际能够使用的空间（committed）。当内存需求不断增长的时候，JVM会逐渐扩展新生代等区域的大小，所以Virtual区域代表的就是暂时不可用（uncommitted）的空间。</p>\n<p>第二，分析完堆内空间，我们一起来看看JVM堆外内存到底包括什么？</p>\n<p>在JMC或JConsole的内存管理界面，会统计部分非堆内存，但提供的信息相对有限，下图就是JMC活动内存池的截图。<br />\n<img src=\"https://static001.geekbang.org/resource/image/fa/2e/fa491795ffe21c1f49982de8b7810c2e.png?wh=930*260\" alt=\"\" /></p>\n<p>接下来我会依赖NMT特性对JVM进行分析，它所提供的详细分类信息，非常有助于理解JVM内部实现。</p>\n<p>首先来做些准备工作，开启NMT并选择summary模式，</p>\n<pre><code>-XX:NativeMemoryTracking=summary\n</code></pre>\n<p>为了方便获取和对比NMT输出，选择在应用退出时打印NMT统计信息</p>\n<pre><code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics\n</code></pre>\n<p>然后，执行一个简单的在标准输出打印HelloWorld的程序，就可以得到下面的输出<br />\n<img src=\"https://static001.geekbang.org/resource/image/55/bb/55f1c7f0550adbbcc885c97a4dd426bb.png?wh=642*821\" alt=\"\" /></p>\n<p>我来仔细分析一下，NMT所表征的JVM本地内存使用：</p>\n<ul>\n<li>\n<p>第一部分非常明显是Java堆，我已经分析过使用什么参数调整，不再赘述。</p>\n</li>\n<li>\n<p>第二部分是Class内存占用，它所统计的就是Java类元数据所占用的空间，JVM可以通过类似下面的参数调整其大小：</p>\n</li>\n</ul>\n<pre><code>-XX:MaxMetaspaceSize=value\n</code></pre>\n<p>对于本例，因为HelloWorld没有什么用户类库，所以其内存占用主要是启动类加载器（Bootstrap）加载的核心类库。你可以使用下面的小技巧，调整启动类加载器元数据区，这主要是为了对比以加深理解，也许只有在hack JDK时才有实际意义。</p>\n<pre><code>-XX:InitialBootClassLoaderMetaspaceSize=30720\n</code></pre>\n<ul>\n<li>下面是Thread，这里既包括Java线程，如程序主线程、Cleaner线程等，也包括GC等本地线程。你有没有注意到，即使是一个HelloWorld程序，这个线程数量竟然还有25。似乎有很多浪费，设想我们要用Java作为Serverless运行时，每个function是非常短暂的，如何降低线程数量呢？<br />\n如果你充分理解了专栏讲解的内容，对JVM内部有了充分理解，思路就很清晰了：<br />\nJDK 9的默认GC是G1，虽然它在较大堆场景表现良好，但本身就会比传统的Parallel GC或者Serial GC之类复杂太多，所以要么降低其并行线程数目，要么直接切换GC类型；<br />\nJIT编译默认是开启了TieredCompilation的，将其关闭，那么JIT也会变得简单，相应本地线程也会减少。<br />\n我们来对比一下，这是默认参数情况的输出：<br />\n<img src=\"https://static001.geekbang.org/resource/image/97/42/97d060b306e44af3a8443f932a0a4d42.png?wh=607*89\" alt=\"\" /></li>\n</ul>\n<p>下面是替换了默认GC，并关闭TieredCompilation的命令行<br />\n<img src=\"https://static001.geekbang.org/resource/image/b0/3b/b07d6da56f588cbfadbb7b381346213b.png?wh=592*71\" alt=\"\" /></p>\n<p>得到的统计信息如下，线程数目从25降到了17，消耗的内存也下降了大概1/3。<br />\n<img src=\"https://static001.geekbang.org/resource/image/59/27/593735623f6917695602095fd249d527.png?wh=634*85\" alt=\"\" /></p>\n<ul>\n<li>接下来是Code统计信息，显然这是CodeCache相关内存，也就是JIT compiler存储编译热点方法等信息的地方，JVM提供了一系列参数可以限制其初始值和最大值等，例如：</li>\n</ul>\n<pre><code>-XX:InitialCodeCacheSize=value\n</code></pre>\n<pre><code>-XX:ReservedCodeCacheSize=value\n</code></pre>\n<p>你可以设置下列JVM参数，也可以只设置其中一个，进一步判断不同参数对CodeCache大小的影响。<br />\n<img src=\"https://static001.geekbang.org/resource/image/94/70/945740c37433f783d2d877c67dcc1170.png?wh=530*42\" alt=\"\" /><br />\n<img src=\"https://static001.geekbang.org/resource/image/82/cd/82d1fbc9ca09698c01ccff18fb97c8cd.png?wh=641*60\" alt=\"\" /></p>\n<p>很明显，CodeCache空间下降非常大，这是因为我们关闭了复杂的TieredCompilation，而且还限制了其初始大小。</p>\n<ul>\n<li>下面就是GC部分了，就像我前面介绍的，G1等垃圾收集器其本身的设施和数据结构就非常复杂和庞大，例如Remembered Set通常都会占用20%~30%的堆空间。如果我把GC明确修改为相对简单的Serial GC，会有什么效果呢？</li>\n</ul>\n<p>使用命令：</p>\n<pre><code>-XX:+UseSerialGC\n</code></pre>\n<p><img src=\"https://static001.geekbang.org/resource/image/6e/33/6eeee6624c7dc6be54bfce5e93064233.png?wh=641*216\" alt=\"\" /></p>\n<p>可见，不仅总线程数大大降低（25 → 13），而且GC设施本身的内存开销就少了非常多。据我所知，AWS Lambda中Java运行时就是使用的Serial GC，可以大大降低单个function的启动和运行开销。</p>\n<ul>\n<li>\n<p>Compiler部分，就是JIT的开销，显然关闭TieredCompilation会降低内存使用。</p>\n</li>\n<li>\n<p>其他一些部分占比都非常低，通常也不会出现内存使用问题，请参考<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr022.html#BABCBGFA\">官方文档</a>。唯一的例外就是Internal（JDK 11以后在Other部分）部分，其统计信息<strong>包含着Direct Buffer的直接内存</strong>，这其实是堆外内存中比较敏感的部分，很多堆外内存OOM就发生在这里，请参考专栏第12讲的处理步骤。原则上Direct Buffer是不推荐频繁创建或销毁的，如果你怀疑直接内存区域有问题，通常可以通过类似instrument构造函数等手段，排查可能的问题。</p>\n</li>\n</ul>\n<p>JVM内部结构就介绍到这里，主要目的是为了加深理解，很多方面只有在定制或调优JVM运行时才能真正涉及，随着微服务和Serverless等技术的兴起，JDK确实存在着为新特征的工作负载进行定制的需求。</p>\n<p>今天我结合JVM参数和特性，系统地分析了JVM堆内和堆外内存结构，相信你一定对JVM内存结构有了比较深入的了解，在定制Java运行时或者处理OOM等问题的时候，思路也会更加清晰。JVM问题千奇百怪，如果你能快速将问题缩小，大致就能清楚问题可能出在哪里，例如如果定位到问题可能是堆内存泄漏，往往就已经有非常清晰的<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks004.html#CIHIEEFH\">思路和工具</a>可以去解决了。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，如果用程序的方式而不是工具，对Java内存使用进行监控，有哪些技术可以做到?</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n<p></p>\n","comments":[{"had_liked":false,"id":15010,"user_name":"Loading...","can_delete":false,"product_type":"c1","uid":1169877,"ip_address":"","ucode":"91651B01AE310F","user_header":"https://static001.geekbang.org/account/avatar/00/11/d9/d5/3834f474.jpg","comment_is_top":false,"comment_ctime":1530797902,"is_pvip":false,"replies":[{"id":"5070","content":"对方问得有点含糊，不知道是否故意的，以cms为例，它有不同的mark： initial mark，conc mark， remark；conc时候不需要stw；其他需要短暂stw，这样引用关系才不变，另外效率也高","user_name":"作者回复","comment_id":15010,"uid":"1009360","ip_address":"","utype":1,"ctime":1530891204,"user_name_real":"杨晓峰"}],"discussion_count":11,"race_medal":0,"score":"233459031886","product_id":100006701,"comment_content":"今天阿里面试官问了我一个问题，我想了很久没想通，希望得到解答。为什么在标记垃圾的时候，需要stop the world","like_count":55,"discussions":[{"author":{"id":1218347,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLvdWoCic6ItzibF8ia8vrUTRuyj6AT3tg5f4QicIK0jTIFheJ6274ZkibuRLFP1NXG3jibv5TiaSKNoJpLw/132","nickname":"Geek_37984c","note":"","ucode":"7A319AE28599B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202005,"discussion_content":"https://blog.csdn.net/fhy569039351/article/details/83960709","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583853626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286050,"avatar":"","nickname":"Geek_2019","note":"","ucode":"CAEA0381F4EDCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32869,"discussion_content":"为了保证引用更新的正确性？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1571064462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420207,"discussion_content":"对方问得有点含糊，不知道是否故意的，以cms为例，它有不同的mark： initial mark，conc mark， remark；conc时候不需要stw；其他需要短暂stw，这样引用关系才不变，另外效率也高","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1530891204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315402,"discussion_content":"我觉得老师回答的对。。过于模糊，你先反问依据，你说的stop the world 前提是哪个收集器  你觉得是哪个 stop the world","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603269890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1499166,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e0/1e/b71bf116.jpg","nickname":"肥月饼","note":"","ucode":"8405249D305DD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325895,"discussion_content":"我理解是标记的流程是先扫描gcroot的可达目标，然后反选标记为垃圾。如果不stw的话，在进行反选时会有可能标记到在扫描gcroot的可达目标时未能检测到的新生对象，导致错误清理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605453441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1794876,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/63/3c/4ad53829.jpg","nickname":"正能量","note":"","ucode":"7C64D1C4C5FC0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318879,"discussion_content":"简单点回答，标记垃圾的时候如果不STW，同一时间用户线程重新将一个本来被标记成垃圾对象的引用变为可达了（也就是垃圾不再是垃圾），那么接下来GC标记结束进行垃圾回收的时候，会把这个对象当作垃圾清理掉（然而这个对象现在是存活的）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603872914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1768852,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/94/8704d2b0.jpg","nickname":"spoofer","note":"","ucode":"6723F64ACC3F27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1794876,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/63/3c/4ad53829.jpg","nickname":"正能量","note":"","ucode":"7C64D1C4C5FC0D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350694,"discussion_content":"可以使用并发的可达性分析的啊！！你说的这些情况，可以再一次扫描使用增量更新和原始快照两种方案来解决，可以看一下深入理解jvm","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613981400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318879,"ip_address":""},"score":350694,"extra":""},{"author":{"id":1794876,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/63/3c/4ad53829.jpg","nickname":"正能量","note":"","ucode":"7C64D1C4C5FC0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1768852,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fd/94/8704d2b0.jpg","nickname":"spoofer","note":"","ucode":"6723F64ACC3F27","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372105,"discussion_content":"你说的这些方案是后续新的gc，但是仔细去研究，再新的哪怕是zgc也做不到完全没有stw。只是相对老的gc，大大优化了，缩短了stw的时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620194272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350694,"ip_address":""},"score":372105,"extra":""},{"author":{"id":2391701,"avatar":"","nickname":"Geek_a3890b","note":"","ucode":"BF67D080DAF96D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1794876,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/63/3c/4ad53829.jpg","nickname":"正能量","note":"","ucode":"7C64D1C4C5FC0D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403943,"discussion_content":"标记为垃圾的对象？ 没搞懂。 可达分析只能找到标记存活的对象吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634195160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318879,"ip_address":""},"score":403943,"extra":""}]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159639,"discussion_content":"《深入理解JVM》真的好深","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580718820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1564175,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hkBfzo6cRvaarhFg3zMz9zicO6Sa1lU0Zib9jECcBBbmvaEke9MvMq28mP3emViaMqIU5KNlSexaoMQN5tWFOZiafQ/132","nickname":"叶晚林","note":"","ucode":"5D6C5CB8AA68DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14009,"discussion_content":"这个《深入理解JVM》讲了啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568720643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15161,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1530939906,"is_pvip":false,"replies":[{"id":"5111","content":"非常感谢，下一章有配图详解，受制于一章的篇幅限制","user_name":"作者回复","comment_id":15161,"uid":"1009360","ip_address":"","utype":1,"ctime":1530973831,"user_name_real":"杨晓峰"}],"discussion_count":3,"race_medal":0,"score":"207689370114","product_id":100006701,"comment_content":"班门弄斧，为老师补充一些关于Eden、两个Survivor的细节。<br>1、大部分对象创建都是在Eden的，除了个别大对象外。<br>2、Minor GC开始前，to-survivor是空的，from-survivor是由对象的。<br>3、Minor GC后，Eden的存活对象都copy到to-survivor中，from-survivor的存活对象也复制to-survivor中。其中所有对象的年龄+1<br>4、from-survivor清空，成为新的to-survivor，带有对象的to-survivor变成新的from-survivor。重复回到步骤2<br><br>这是我看这边文章也有的疑问，通过查阅资料理解的，希望可以帮到其他同学","like_count":49,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420264,"discussion_content":"非常感谢，下一章有配图详解，受制于一章的篇幅限制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530973831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":152187,"discussion_content":"顶你一下👏","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579950773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404583,"discussion_content":"我咋觉得这块比原文更好呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634352249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76181,"user_name":"Bruce","can_delete":false,"product_type":"c1","uid":1035230,"ip_address":"","ucode":"93E1A42548EEBB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/de/4d857c5d.jpg","comment_is_top":false,"comment_ctime":1552545447,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"143286466215","product_id":100006701,"comment_content":"回答一下留言的问题，为什么标记的时候要stop the world，是为了避免在标记的时候又有对象在堆内生成，如果这个对象对其他未标记对象有引用，而这个时候由于gc而清理掉了未标记的对象，会有问题","like_count":33,"discussions":[{"author":{"id":1154783,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9e/df/ac5c60b5.jpg","nickname":"jiahua","note":"","ucode":"A2B85DA49DC69D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331953,"discussion_content":"不stw。标记结束，不也会有新对象生成的问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607011071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16340,"user_name":"铁拳阿牛","can_delete":false,"product_type":"c1","uid":1094950,"ip_address":"","ucode":"B8CB947995685B","user_header":"https://static001.geekbang.org/account/avatar/00/10/b5/26/d635d8d3.jpg","comment_is_top":false,"comment_ctime":1531888773,"is_pvip":false,"replies":[{"id":"5675","content":"是我记错了，非常抱歉","user_name":"作者回复","comment_id":16340,"uid":"1009360","ip_address":"","utype":1,"ctime":1531901168,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"91726201989","product_id":100006701,"comment_content":"-XX:NewRatio=value<br>默认是2<br>这里说是3面试官还说我记错了😣<br>","like_count":21,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420763,"discussion_content":"是我记错了，非常抱歉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531901168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1856182,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/52/b6/202076f0.jpg","nickname":"曾子良","note":"","ucode":"3C2F7234E40451","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349867,"discussion_content":"官方文档中举例是3，但是默认值表格中是2，文中应该没错呀。\n‘By default, the young generation size is controlled by the parameter NewRatio. For example, setting -XX:NewRatio=3 means that the ratio between the young and tenured generation is 1:3. In other words, the combined size of the eden and survivor spaces will be one-fourth of the total heap size.’\n\n这段描述的下面有个表格：\nTable 4-2 Default Parameter Values for Survivor Space Sizing\n中 NewRatio 的默认值是2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613605061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14973,"user_name":"北溟鱼汤","can_delete":false,"product_type":"c1","uid":1112826,"ip_address":"","ucode":"82CF670A8422A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/fa/28832dd5.jpg","comment_is_top":false,"comment_ctime":1530777307,"is_pvip":false,"replies":[{"id":"5088","content":"是的","user_name":"作者回复","comment_id":14973,"uid":"1009360","ip_address":"","utype":1,"ctime":1530895340,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"70250254043","product_id":100006701,"comment_content":"java.lang.Runtime类有freeMemory()、totalMemory()等方法可以获取到jvm内存情况，看了一下是本地方法。","like_count":17,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420198,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530895340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17072,"user_name":"xhkk","can_delete":false,"product_type":"c1","uid":1093421,"ip_address":"","ucode":"B36B04D83B6C70","user_header":"https://static001.geekbang.org/account/avatar/00/10/af/2d/3dd65e6b.jpg","comment_is_top":false,"comment_ctime":1532415642,"is_pvip":false,"replies":[{"id":"5961","content":"泄露可以对比不同时间点内存分配，一般看用户类型的分配情况，什么在增加。具体，比如用jmap -histo:live 多次快照，然后对比差异，或者用jmc之类profiling工具，都可以进行，对比会更加流畅一些","user_name":"作者回复","comment_id":17072,"uid":"1009360","ip_address":"","utype":1,"ctime":1532448501,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"61661957786","product_id":100006701,"comment_content":"老师，请问如何判断是否有内存泄露","like_count":14,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421031,"discussion_content":"泄露可以对比不同时间点内存分配，一般看用户类型的分配情况，什么在增加。具体，比如用jmap -histo:live 多次快照，然后对比差异，或者用jmc之类profiling工具，都可以进行，对比会更加流畅一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532448501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19316,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1533774839,"is_pvip":false,"replies":[{"id":"7671","content":"不错","user_name":"作者回复","comment_id":19316,"uid":"1009360","ip_address":"","utype":1,"ctime":1535217674,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"44483447799","product_id":100006701,"comment_content":"java.lang.Runtime类有freeMemory()、totalMemory()等方法可以获取到jvm内存情况，看了一下是本地方法。<br>另外看到有同学说jmc，jconsole在linux上用不了的问题，其实1可以远程连接，2可以使用xshell","like_count":10,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421780,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535217674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15001,"user_name":"L.B.Q.Y","can_delete":false,"product_type":"c1","uid":1069325,"ip_address":"","ucode":"5567989D1CDBBE","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/0d/14d9364a.jpg","comment_is_top":false,"comment_ctime":1530795763,"is_pvip":false,"replies":[{"id":"5093","content":"是的","user_name":"作者回复","comment_id":15001,"uid":"1009360","ip_address":"","utype":1,"ctime":1530896147,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"35890534131","product_id":100006701,"comment_content":"jmx可以做到通过代码而不是工具去监控，其实jdk安装包的工具也是对jmx的一个薄层的封装。","like_count":8,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420204,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530896147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20150,"user_name":"陈道恒","can_delete":false,"product_type":"c1","uid":1189021,"ip_address":"","ucode":"07A0695DEFA270","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/9d/ba45ff4a.jpg","comment_is_top":false,"comment_ctime":1534294117,"is_pvip":false,"replies":[{"id":"7480","content":"这个要看具体什么GC，如果cms是PretenureSizeThreshold，G1本身就有homongous object的概念，region大小的一半","user_name":"作者回复","comment_id":20150,"uid":"1009360","ip_address":"","utype":1,"ctime":1534988459,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"31599065189","product_id":100006701,"comment_content":"当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。<br>        杨老师你好，大对象直接分配到老年代，这里是指多大？有没什么衡量标准？","like_count":7,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422131,"discussion_content":"这个要看具体什么GC，如果cms是PretenureSizeThreshold，G1本身就有homongous object的概念，region大小的一半","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534988459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15350,"user_name":"ethan","can_delete":false,"product_type":"c1","uid":1149256,"ip_address":"","ucode":"723526C107DF63","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK44Hvr0AreUic5s1gdxGBibTOZy3RiaeA5iccSNW9ibmAIcsNcz3Mb67ZGxRL1rZ3iboLTMndsXr5uX2hA/132","comment_is_top":false,"comment_ctime":1531136233,"is_pvip":false,"replies":[{"id":"5314","content":"出错信息应该包含具体类的名字等信息；mvn依赖树","user_name":"作者回复","comment_id":15350,"uid":"1009360","ip_address":"","utype":1,"ctime":1531322420,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"27300940009","product_id":100006701,"comment_content":"jar包发生冲突，如何定位是哪些jar包发生问题","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420348,"discussion_content":"出错信息应该包含具体类的名字等信息；mvn依赖树","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531322420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119364,"user_name":"szh","can_delete":false,"product_type":"c1","uid":1484283,"ip_address":"","ucode":"6DFDF4883AB576","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/fb/e78299a6.jpg","comment_is_top":false,"comment_ctime":1564571639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23039408119","product_id":100006701,"comment_content":"Direct Buffer 的直接内存可以用MXBean查看，相关接口是java.lang.management.BufferPoolMXBean。在JConsole中的MBean java.nio.BufferPool可以看到。","like_count":5},{"had_liked":false,"id":14929,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1530752604,"is_pvip":true,"replies":[{"id":"5091","content":"是的，文中简单提了下","user_name":"作者回复","comment_id":14929,"uid":"1009360","ip_address":"","utype":1,"ctime":1530895778,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"14415654492","product_id":100006701,"comment_content":"还有一个就是jstat，可以实时查看gc信息,这个也还是没有工具直观，","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420179,"discussion_content":"是的，文中简单提了下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530895778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14926,"user_name":"Hidden","can_delete":false,"product_type":"c1","uid":1114462,"ip_address":"","ucode":"6323E5D32A3190","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/5e/95f7d928.jpg","comment_is_top":false,"comment_ctime":1530752203,"is_pvip":false,"replies":[{"id":"5082","content":"有点区别，新对象大多是在eden，from是minor gc活下来copy的","user_name":"作者回复","comment_id":14926,"uid":"1009360","ip_address":"","utype":1,"ctime":1530894057,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"14415654091","product_id":100006701,"comment_content":"新对象都会创建在eden 和from 区域，当发生minor gc时 把这两个区域的存活对象复制到 to区域，然后清理eden 和from 区域，是这样理解吧","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420176,"discussion_content":"有点区别，新对象大多是在eden，from是minor gc活下来copy的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530894057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14924,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1530752102,"is_pvip":true,"replies":[{"id":"5087","content":"也是个办法；JMX之类内建的方式更直观一些","user_name":"作者回复","comment_id":14924,"uid":"1009360","ip_address":"","utype":1,"ctime":1530895278,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"14415653990","product_id":100006701,"comment_content":"除了工具就是命令方式了，用过命令有vmstat，这属于linux的，主要监控cpu和内存使用情况，这里是服务器总体内存，所以这个命令不是非常直观。","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420174,"discussion_content":"也是个办法；JMX之类内建的方式更直观一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530895278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16879,"user_name":"代码狂徒","can_delete":false,"product_type":"c1","uid":1030100,"ip_address":"","ucode":"F5918543E90321","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b7/d4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1532272349,"is_pvip":false,"replies":[{"id":"5890","content":"可以remote连接的，看看文档或者网上的指南","user_name":"作者回复","comment_id":16879,"uid":"1009360","ip_address":"","utype":1,"ctime":1532357075,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"10122206941","product_id":100006701,"comment_content":"老师，麻烦咨询下，像jconsole和jmc这些图形化的工具不适用于linux 服务器环境下使用吧，我试了下貌似并没有反应，所以对服务器环境内存监控或者问题跟踪，有什么好的工具呢？","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420954,"discussion_content":"可以remote连接的，看看文档或者网上的指南","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532357075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15578,"user_name":"小卡向前冲","can_delete":false,"product_type":"c1","uid":1124914,"ip_address":"","ucode":"1C8908A61FA00B","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/32/6354a589.jpg","comment_is_top":false,"comment_ctime":1531308441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10121243033","product_id":100006701,"comment_content":"使用javaagent可以获得对象的大小，但是引入时有点麻烦，查到的资料都说需要将代码放到jar包中，然后在启动时加上 -javaagent:jar包名。<br>放不知道这个算不算。","like_count":2},{"had_liked":false,"id":269018,"user_name":"Zm","can_delete":false,"product_type":"c1","uid":1448893,"ip_address":"","ucode":"831FF80F07E965","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKj4w4lW7ibGEVxPv8wS1CrXKDeBz3RAaAdISxQSD23uUpV3wicsIMepaYZE8GzRcWmSpjet5NDN4MA/132","comment_is_top":false,"comment_ctime":1608473585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5903440881","product_id":100006701,"comment_content":"tlab不一定是start到end就会开辟新的空间，可以对其设置参数，允许浪费的空间为800kb，假设剩余1m，新来一个对象为1.2m，则在正常的堆上分配，然后再来一个500kb的对象还会在该线程分配好的空间上分配，这时还剩500kb小于允许浪费的空间800kb，就会对该线程重新分配。","like_count":1},{"had_liked":false,"id":174871,"user_name":"rike","can_delete":false,"product_type":"c1","uid":1583833,"ip_address":"","ucode":"920AAD0BD9245C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","comment_is_top":false,"comment_ctime":1580443595,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5875410891","product_id":100006701,"comment_content":"Eden 和 Survivor 的大小是按照比例设置的，如果 SurvivorRatio 是 8，那么 Survivor 区域就是 Eden 的 1&#47;8 大小，也就是新生代的 1&#47;10，因为 YoungGen=Eden + 2*Survivor<br>“Survivor 区域就是 Eden 的 1&#47;8 大小”，这里的Survivor是指其中的s0或s1，还是两个加起来？","like_count":1,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218487,"discussion_content":"单个啊。。。所以是 8：1：1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585662461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96901,"user_name":"Liu Xian","can_delete":false,"product_type":"c1","uid":1131992,"ip_address":"","ucode":"062DB9CB2AFA49","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/d8/5f9cb4e4.jpg","comment_is_top":false,"comment_ctime":1558532080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853499376","product_id":100006701,"comment_content":"分析过一次Android上的堆外内存OOM，是通过&#47;proc&#47;pid&#47;maps文件里找到的线索。在Linux和Android上堆外内存基本都是通过操作系统的mmap接口从内存映射区分配的，所以maps文件也可以提供一些分析线索。","like_count":1},{"had_liked":false,"id":16880,"user_name":"代码狂徒","can_delete":false,"product_type":"c1","uid":1030100,"ip_address":"","ucode":"F5918543E90321","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b7/d4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1532272350,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5827239646","product_id":100006701,"comment_content":"老师，麻烦咨询下，像jconsole和jmc这些图形化的工具不适用于linux 服务器环境下使用吧，我试了下貌似并没有反应，所以对服务器环境内存监控或者问题跟踪，有什么好的工具呢？","like_count":1,"discussions":[{"author":{"id":1047637,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcwXucibksEYWRmibTZj9pb3d5ibfVQHFS9shvJmgMgtN3BM3r9qiaL5YTZSFdLvPZiaEHfBia4dFODVqw/132","nickname":"北国骑士","note":"","ucode":"AC657FCA2014ED","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345678,"discussion_content":"用系统工具，top,vmstat,netstat,ss,pmap,perf,gdb等。还可以用普罗米修斯 专业的监控工具。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611759036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15150,"user_name":"张玮(大圣)","can_delete":false,"product_type":"c1","uid":1111343,"ip_address":"","ucode":"D567C4BE87D116","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/2f/56117bab.jpg","comment_is_top":false,"comment_ctime":1530934334,"is_pvip":false,"replies":[{"id":"5108","content":"看具体选择，比如G1 gc，会有单独的region放大对象，甚至有可能是占有不只一个region；所以，文章是个提醒，具体还是要看自己的需要去深入<br>","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530972374,"ip_address":"","comment_id":15150,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5825901630","product_id":100006701,"comment_content":"当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。<br><br>这里的较大具体会分配到eden的哪个位置呢，请杨兄指教下","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420257,"discussion_content":"看具体选择，比如G1 gc，会有单独的region放大对象，甚至有可能是占有不只一个region；所以，文章是个提醒，具体还是要看自己的需要去深入\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530972374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353272,"user_name":"木槿花","can_delete":false,"product_type":"c1","uid":2056833,"ip_address":"上海","ucode":"FDBCA340ED95A6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/62/81/69b09ed8.jpg","comment_is_top":false,"comment_ctime":1659324988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659324988","product_id":100006701,"comment_content":"如何合理设置java进程的堆内存大小呢？在多进程机器上，设置太大会降费资源，设置太小又怕运行时不够用","like_count":0},{"had_liked":false,"id":174873,"user_name":"rike","can_delete":false,"product_type":"c1","uid":1583833,"ip_address":"","ucode":"920AAD0BD9245C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","comment_is_top":false,"comment_ctime":1580443644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580443644","product_id":100006701,"comment_content":"Compiler 部分，就是 JIT 的开销，显然关闭 TieredCompilation 会降低内存使用。<br>按照上面讲的，加上参数-XX:-TieredCompilation后反而变大，jdk11，执行下面两个命令对比的结果<br>java -XX:NativeMemoryTracking=summary -XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics HelloWorld<br>Compiler (reserved=133KB, committed=133KB)<br>                            (malloc=2KB #42)<br>                            (arena=131KB #5)<br><br>java -XX:NativeMemoryTracking=summary -XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics -XX:-TieredCompilation -XX:+UseParallelGC HelloWorld<br>Compiler (reserved=2180KB, committed=2180KB)<br>                            (malloc=1KB #30)<br>                            (arena=2179KB #11)","like_count":0},{"had_liked":false,"id":174872,"user_name":"rike","can_delete":false,"product_type":"c1","uid":1583833,"ip_address":"","ucode":"920AAD0BD9245C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","comment_is_top":false,"comment_ctime":1580443623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580443623","product_id":100006701,"comment_content":"在 JVM 内部，如果 Xms 小于 Xmx，堆的大小并不会直接扩展到其上限，也就是说保留的空间（reserved）大于实际能够使用的空间（committed）。当内存需求不断增长的时候，JVM 会逐渐扩展新生代等区域的大小，所以 Virtual 区域代表的就是暂时不可用（uncommitted）的空间。<br>这里的Virtual 区域没看懂","like_count":0},{"had_liked":false,"id":83948,"user_name":"Jeffrey","can_delete":false,"product_type":"c1","uid":1240396,"ip_address":"","ucode":"022C19CE0B3F01","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4c/4db1d58b.jpg","comment_is_top":false,"comment_ctime":1554737053,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554737053","product_id":100006701,"comment_content":"-Xms和-Xmx为什么很多文章都建议设置成一样大？有的解释是增长过程中会引发Full Gc，请问老师是这样么？","like_count":0,"discussions":[{"author":{"id":1123468,"avatar":"https://static001.geekbang.org/account/avatar/00/11/24/8c/9f38c9ac.jpg","nickname":"林风自在","note":"","ucode":"C347C10040FD55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":184949,"discussion_content":"防止堆动态扩增，避免每次GC完之后重新计算堆大小，减少开销","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582590269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}