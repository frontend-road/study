{"id":175579,"title":"06 | 异常：用还是不用，这是个问题","content":"<p>你好，我是吴咏炜。</p><p>到现在为止，我们已经有好多次都提到异常了。今天，我们就来彻底地聊一聊异常。</p><p>首先，开宗明义，如果你不知道到底该不该用异常的话，那答案就是该用。如果你需要避免使用异常，原因必须是你有明确的需要避免使用异常的理由。</p><p>下面我们就开始说说异常。</p><h2>没有异常的世界</h2><p>我们先来看看没有异常的世界是什么样子的。最典型的情况就是 C 了。</p><p>假设我们要做一些矩阵的操作，定义了下面这个矩阵的数据结构：</p><pre><code class=\"language-c\">typedef struct {\n  float* data;\n  size_t nrows;\n  size_t ncols;\n} matrix;\n</code></pre><p>我们至少需要有初始化和清理的代码：</p><pre><code class=\"language-c\">enum matrix_err_code {\n  MATRIX_SUCCESS,\n  MATRIX_ERR_MEMORY_INSUFFICIENT,\n  …\n};\n\nint matrix_alloc(matrix* ptr,\n                 size_t nrows,\n                 size_t ncols)\n{\n  size_t size =\n    nrows * ncols * sizeof(float);\n  float* data = malloc(size);\n  if (data == NULL) {\n    return MATRIX_ERR_MEMORY_INSUFFICIENT;\n  }\n  ptr-&gt;data = data;\n  ptr-&gt;nrows = nrows;\n  ptr-&gt;ncols = ncols;\n}\n\nvoid matrix_dealloc(matrix* ptr)\n{\n  if (ptr-&gt;data == NULL) {\n    return;\n  }\n  free(ptr-&gt;data);\n  ptr-&gt;data = NULL;\n  ptr-&gt;nrows = 0;\n  ptr-&gt;ncols = 0;\n}\n</code></pre><!-- [[[read_end]]] --><p>然后，我们做一下矩阵乘法吧。函数定义大概会是这个样子：</p><pre><code class=\"language-c\">int matrix_multiply(matrix* result,\n                    const matrix* lhs,\n                    const matrix* rhs)\n{\n  int errcode;\n  if (lhs-&gt;ncols != rhs-&gt;nrows) {\n    return MATRIX_ERR_MISMATCHED_MATRIX_SIZE;\n    // 呃，得把这个错误码添到 enum matrix_err_code 里\n  }\n  errcode = matrix_alloc(\n    result, lhs-&gt;nrows, rhs-&gt;ncols);\n  if (errcode != MATRIX_SUCCESS) {\n    return errcode;\n  }\n  // 进行矩阵乘法运算\n  return MATRIX_SUCCESS;\n}\n</code></pre><p>调用代码则大概是这个样子：</p><pre><code class=\"language-c\">  matrix c;\n\n  // 不清零的话，错误处理和资源清理会更复杂\n  memset(&amp;c, 0, sizeof(matrix));\n\n  errcode = matrix_multiply(c, a, b);\n  if (errcode != MATRIX_SUCCESS) {\n    goto error_exit;\n  }\n  // 使用乘法的结果做其他处理\n\nerror_exit:\n  matrix_dealloc(&amp;c);\n  return errcode;\n</code></pre><p>可以看到，我们有大量需要判断错误的代码，零散分布在代码各处。</p><p>可这是 C 啊。我们用 C++、不用异常可以吗？</p><p>当然可以，但你会发现结果好不了多少。毕竟，C++ 的构造函数是不能返回错误码的，所以你根本不能用构造函数来做可能出错的事情。你不得不定义一个只能清零的构造函数，再使用一个 <code>init</code> 函数来做真正的构造操作。C++ 虽然支持运算符重载，可你也不能使用，因为你没法返回一个新矩阵……</p><p>我上面还只展示了单层的函数调用。事实上，如果出错位置离处理错误的位置相差很远的话，每一层的函数调用里都得有判断错误码的代码，这就既对写代码的人提出了严格要求，也对读代码的人造成了视觉上的干扰……</p><h2>使用异常</h2><p>如果使用异常的话，我们就可以在构造函数里做真正的初始化工作了。假设我们的矩阵类有下列的数据成员：</p><pre><code class=\"language-c++\">class matrix {\n  …\nprivate:\n  float* data_;\n  size_t nrows_;\n  size_t ncols_;\n};\n</code></pre><p>构造函数我们可以这样写：</p><pre><code class=\"language-c++\">matrix::matrix(size_t nrows,\n               size_t ncols)\n{\n  data_  = new float[nrows * ncols];\n  nrows_ = nrows;\n  ncols_ = ncols;\n}\n</code></pre><p>析构非常简单：</p><pre><code class=\"language-c++\">matrix::~matrix()\n{\n  delete[] data_;\n}\n</code></pre><p>乘法函数可以这样写：</p><pre><code class=\"language-c++\">class matrix {\n  …\n  friend matrix\n  operator*(const matrix&amp;,\n            const matrix&amp;);\n};\n\nmatrix operator*(const matrix&amp; lhs,\n                 const matrix&amp; rhs)\n{\n  if (lhs.ncols != rhs.nrows) {\n    throw std::runtime_error(\n      \"matrix sizes mismatch\");\n  }\n  matrix result(lhs.nrows, rhs.ncols);\n  // 进行矩阵乘法运算\n  return result;\n}\n</code></pre><p>使用乘法的代码则更是简单：</p><pre><code class=\"language-c++\">matrix c = a * b;\n</code></pre><p>你可能已经非常疑惑了：错误处理在哪儿呢？只有一个 <code>throw</code>，跟前面的 C 代码能等价吗？</p><p>异常处理并不意味着需要写显式的 <code>try</code> 和 <code>catch</code>。<strong>异常安全的代码，可以没有任何 <code>try</code> 和 <code>catch</code>。</strong></p><p>如果你不确定什么是“异常安全”，我们先来温习一下概念：异常安全是指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态。</p><p>我们看看可能会出现错误/异常的地方：</p><ul>\n<li>\n<p>首先是内存分配。如果 <code>new</code> 出错，按照 C++ 的规则，一般会得到异常 <code>bad_alloc</code>，对象的构造也就失败了。这种情况下，在 <code>catch</code> 捕捉到这个异常之前，所有的栈上对象会全部被析构，资源全部被自动清理。</p>\n</li>\n<li>\n<p>如果是矩阵的长宽不合适不能做乘法呢？我们同样会得到一个异常，这样，在使用乘法的地方，对象 <code>c</code> 根本不会被构造出来。</p>\n</li>\n<li>\n<p>如果在乘法函数里内存分配失败呢？一样，<code>result</code> 对象根本没有构造出来，也就没有 <code>c</code> 对象了。还是一切正常。</p>\n</li>\n<li>\n<p>如果 <code>a</code>、<code>b</code> 是本地变量，然后乘法失败了呢？析构函数会自动释放其空间，我们同样不会有任何资源泄漏。</p>\n</li>\n</ul><p>总而言之，只要我们适当地组织好代码、利用好 RAII，实现矩阵的代码和使用矩阵的代码都可以更短、更清晰。我们可以统一在外层某个地方处理异常——通常会记日志、或在界面上向用户报告错误了。</p><h2>避免异常的风格指南？</h2><p>但大名鼎鼎的 Google 的 C++ 风格指南不是说要避免异常吗 <span class=\"orange\">[1]</span>？这又是怎么回事呢？</p><p>答案实际已经在 Google 的文档里了：</p><blockquote>\n<p>Given that Google’s existing code is not exception-tolerant, the costs of using exceptions are somewhat greater than the costs in a new project. The conversion process would be slow and error-prone. We don’t believe that the available alternatives to exceptions, such as error codes and assertions, introduce a significant burden.</p>\n<p>Our advice against using exceptions is not predicated on philosophical or moral grounds, but practical ones. Because we’d like to use our open-source projects at Google and it’s difficult to do so if those projects use exceptions, we need to advise against exceptions in Google open-source projects as well. Things would probably be different if we had to do it all over again from scratch.</p>\n</blockquote><p>我来翻译一下（我的加重）：</p><blockquote>\n<p>鉴于 Google 的现有代码不能承受异常，<strong>使用异常的代价要比在全新的项目中使用异常大一些</strong>。转换[代码来使用异常的]过程会缓慢而容易出错。我们不认为可代替异常的方法，如错误码或断言，会带来明显的负担。</p>\n<p>我们反对异常的建议并非出于哲学或道德的立场，而是出于实际考虑。因为我们希望在 Google 使用我们的开源项目，而如果这些项目使用异常的话就会对我们的使用带来困难，我们也需要反对在 Google 的开源项目中使用异常。<strong>如果我们从头再来一次的话，事情可能就会不一样了。</strong></p>\n</blockquote><p>这个如果还比较官方、委婉的话，Reddit 上还能找到一个更个人化的表述 <span class=\"orange\">[2]</span>：</p><blockquote>\n<p>I use [<em>sic</em>] to work at Google, and Craig Silverstein, who wrote the first draft of the style guideline, said that he regretted the ban on exceptions, but he had no choice; when he wrote it, it wasn’t only that the compiler they had at the time did a very bad job on exceptions, but that they already had a huge volume of non-exception-safe code.</p>\n</blockquote><p>我的翻译（同样，我的加重）：</p><blockquote>\n<p>我过去在 Google 工作，写了风格指南初稿的 Craig Silverstein 说过<strong>他对禁用异常感到遗憾</strong>，但他当时别无选择。在他写风格指南的时候，不仅<strong>他们使用的编译器在异常上工作得很糟糕</strong>，而且<strong>他们已经有了一大堆异常不安全的代码了</strong>。</p>\n</blockquote><p>当然，除了历史原因以外，也有出于性能等其他原因禁用异常的。美国国防部的联合攻击战斗机（JSF）项目的 C++ 编码规范就禁用异常，因为工具链不能保证抛出异常时的实时性能。不过在那种项目里，被禁用的 C++ 特性就多了，比如动态内存分配都不能使用。</p><p>一些游戏项目为了追求高性能，也禁用异常。这个实际上也有一定的历史原因，因为今天的主流 C++ 编译器，在异常关闭和开启时应该已经能够产生性能差不多的代码（在异常未抛出时）。代价是产生的二进制文件大小的增加，因为异常产生的位置决定了需要如何做栈展开，这些数据需要存储在表里。典型情况，使用异常和不使用异常比，二进制文件大小会有约百分之十到二十的上升。LLVM 项目的编码规范里就明确指出这是不使用 RTTI 和异常的原因 <span class=\"orange\">[3]</span>：</p><blockquote>\n<p>In an effort to reduce code and executable size, LLVM does not use RTTI (e.g. <code>dynamic_cast&lt;&gt;;</code>) or exceptions.</p>\n</blockquote><p>我默默地瞅了眼我机器上 88MB 大小的单个 clang-9 可执行文件，对 Chris Lattner 的决定至少表示理解。但如果想跟这种项目比，你得想想是否值得这么去做。你的项目对二进制文件的大小和性能有这么渴求吗？需要这么去拼吗？</p><h2>异常的问题</h2><p>异常当然不是一个完美的特性，否则也不会招来这些批评和禁用了。对它的批评主要有两条：</p><ul>\n<li>异常违反了“你不用就不需要付出代价”的 C++ 原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀。</li>\n<li>异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常。</li>\n</ul><p>对于第一条，开发者没有什么可做的。事实上，这也算是 C++ 实现的一个折中了。目前的主流异常实现中，都倾向于牺牲可执行文件大小、提高主流程（happy path）的性能。只要程序不抛异常，C++ 代码的性能比起完全不做错误检查的代码，都只有几个百分点的性能损失 <span class=\"orange\">[4]</span>。除了非常有限的一些场景，可执行文件大小通常不会是个问题。</p><p>第二条可以算作是一个真正有效的批评。和 Java 不同，C++ 里不会对异常规约进行编译时的检查。从 C++17 开始，C++ 甚至完全禁止了以往的动态异常规约，你不再能在函数声明里写你可能会抛出某某异常。你唯一能声明的，就是某函数不会抛出异常——<code>noexcept</code>、<code>noexcept(true)</code> 或 <code>throw()</code>。这也是 C++ 的运行时唯一会检查的东西了。如果一个函数声明了不会抛出异常、结果却抛出了异常，C++ 运行时会调用 <code>std::terminate</code> 来终止应用程序。不管是程序员的声明，还是编译器的检查，都不会告诉你哪些函数会抛出哪些异常。</p><p>当然，不声明异常是有理由的。特别是在泛型编程的代码里，几乎不可能预知会发生些什么异常。我个人对避免异常带来的问题有几点建议：</p><ol>\n<li>写异常安全的代码，尤其在模板里。可能的话，提供强异常安全保证 <span class=\"orange\">[5]</span>，在任何第三方代码发生异常的情况下，不改变对象的内容，也不产生任何资源泄漏。</li>\n<li>如果你的代码可能抛出异常的话，在文档里明确声明可能发生的异常类型和发生条件。确保使用你的代码的人，能在不检查你的实现的情况下，了解需要准备处理哪些异常。</li>\n<li>对于肯定不会抛出异常的代码，将其标为 <code>noexcept</code>。尤其是，移动构造函数、移动赋值运算符和 <code>swap</code> 函数一般需要保证不抛异常并标为 <code>noexcept</code>（析构函数通常不抛异常且自动默认为 <code>noexcept</code>，不需要标）。</li>\n</ol><h2>使用异常的理由</h2><p>虽然后面我们会描述到一些不使用异常、也不使用错误返回码的错误处理方式，但异常是渗透在 C++ 中的标准错误处理方式。标准库的错误处理方式就是异常。其中不仅包括运行时错误，甚至包括一些逻辑错误。比如，在说容器的时候，有一个我没提的地方是，在能使用 <code>[]</code> 运算符的地方，C++ 的标准容器也提供了 <code>at</code> 成员函数，能够在下标不存在的时候抛出异常，作为一种额外的帮助调试的手段。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;   // std::cout/endl\n#include &lt;stdexcept&gt;  // std::out_of_range\n#include &lt;vector&gt;     // std::vector\nusing namespace std;\n</code></pre><pre><code class=\"language-c++\">vector&lt;int&gt; v{1, 2, 3};\n</code></pre><pre><code class=\"language-c++\">v[0]\n</code></pre><blockquote>\n<p><code>1</code></p>\n</blockquote><pre><code class=\"language-c++\">v.at(0)\n</code></pre><blockquote>\n<p><code>1</code></p>\n</blockquote><pre><code class=\"language-c++\">v[3]\n</code></pre><blockquote>\n<p><code>-1342175236</code></p>\n</blockquote><pre><code class=\"language-c++\">try {\n  v.at(3);\n}\ncatch (const out_of_range&amp; e) {\n  cerr &lt;&lt; e.what() &lt;&lt; endl;\n}\n</code></pre><blockquote>\n<p><code>_M_range_check: __n (which is 3) &gt;= this-&gt;size() (which is 3)</code></p>\n</blockquote><p>C++ 的标准容器在大部分情况下提供了强异常保证，即，一旦异常发生，现场会恢复到调用函数之前的状态，容器的内容不会发生改变，也没有任何资源泄漏。前面提到过，<code>vector</code> 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数。这是因为一旦某个操作发生了异常，被移动的元素已经被破坏，处于只能析构的状态，异常安全性就不能得到保证了。</p><p>只要你使用了标准容器，不管你自己用不用异常，你都得处理标准容器可能引发的异常——至少有 <code>bad_alloc</code>，除非你明确知道你的目标运行环境不会产生这个异常。这对普通配置的 Linux 环境而言，倒确实是对的……这也算是 Google 这么规定的一个底气吧。</p><p>虽然对于运行时错误，开发者并没有什么选择余地；但对于代码中的逻辑错误，开发者则是可以选择不同的处理方式的：你可以使用异常，也可以使用 <code>assert</code>，在调试环境中报告错误并中断程序运行。由于测试通常不能覆盖所有的代码和分支，<code>assert</code> 在发布模式下一般被禁用，两者并不是完全的替代关系。在允许异常的情况下，使用异常可以获得在调试和发布模式下都良好、一致的效果。</p><p>标准 C++ 可能会产生哪些异常，可以查看参考资料 <span class=\"orange\">[6]</span>。</p><h2>内容小结</h2><p>今天我们讨论了使用异常的理由和不使用异常的理由。希望通过本讲，你能够充分理解为什么异常是 C++ 委员会和很多大拿推荐的错误处理方式，并在可以使用异常的地方正确地使用异常这一方便的错误处理机制。</p><p>如果你还想进一步深入了解异常的话，可以仔细阅读一下参考资料 <span class=\"orange\">[4]</span>。</p><h2>课后思考</h2><p>你的 C++ 项目里使用异常吗？为什么？</p><p>欢迎留言和我交流你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Google, “Google C++ style guide”. <a href=\"https://google.github.io/styleguide/cppguide.html#Exceptions\">https://google.github.io/styleguide/cppguide.html#Exceptions</a> </span></p><p><span class=\"reference\">[2] Reddit, Discussion on “Examples of C++ projects which embrace exceptions?”. <a href=\"https://www.reddit.com/r/cpp/comments/4wkkge/examples_of_c_projects_which_embrace_exceptions/\">https://www.reddit.com/r/cpp/comments/4wkkge/examples_of_c_projects_which_embrace_exceptions/</a> </span></p><p><span class=\"reference\">[3] LLVM Project, “LLVM coding standards”. <a href=\"https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions\">https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions</a> </span></p><p><span class=\"reference\">[4] Standard C++ Foundation, “FAQ—exceptions and error handling”. <a href=\"https://isocpp.org/wiki/faq/exceptions\">https://isocpp.org/wiki/faq/exceptions</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “Exceptions”. <a href=\"https://en.cppreference.com/w/cpp/language/exceptions\">https://en.cppreference.com/w/cpp/language/exceptions</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “异常”. <a href=\"https://zh.cppreference.com/w/cpp/language/exceptions\">https://zh.cppreference.com/w/cpp/language/exceptions</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::exception”. <a href=\"https://en.cppreference.com/w/cpp/error/exception\">https://en.cppreference.com/w/cpp/error/exception</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::exception”. <a href=\"https://zh.cppreference.com/w/cpp/error/exception\">https://zh.cppreference.com/w/cpp/error/exception</a> </span></p>","neighbors":{"left":{"article_title":"05 | 容器汇编 II：需要函数对象的容器","id":174434},"right":{"article_title":"07 | 迭代器和好用的新for循环","id":176842}},"comments":[{"had_liked":false,"id":159955,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1575851190,"is_pvip":false,"replies":[{"id":61065,"content":"对，这就是 RAII，非常重要。\n\n学习速度飞快啊。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575855412,"ip_address":"","comment_id":159955,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"文中下面的一句话：\n\n“首先是内存分配。如果 new 出错，按照 C++ 的规则，一般会得到异常 bad_alloc，对象的构造也就失败了。这种情况下，在 catch 捕捉到这个异常之前，所有的栈上对象会全部被析构，资源全部被自动清理。”\n\n谈的是new在分配内存时的错误，是堆上内存的错误，但自动被析构的却是栈上的对象。一开始我想是不是笔误了，但仔细想想，堆上的东西都是由栈上的变量所引用的，栈上对象析构的过程，堆上相应的资源自然就被释放了。而且被释放的对象的范围还被栈帧限定了。","like_count":43},{"had_liked":false,"id":162634,"user_name":"亮","can_delete":false,"product_type":"c1","uid":1244779,"ip_address":"","ucode":"8D97C79DF7D7F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/6b/81b2e40a.jpg","comment_is_top":false,"comment_ctime":1576570204,"is_pvip":false,"replies":[{"id":61882,"content":"网络就看 Boost.Asio 吧。这个将是未来 C++ 网络标准库的基础。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576625297,"ip_address":"","comment_id":162634,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看到老师说了部分开源的异常优秀的C++开源项目，老师能否推荐些现在流行的，能逐步深入的网络编程方面的C++开源项目看呢，从入门到深入的都推荐一些吧。谢谢老师","like_count":31,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478112,"discussion_content":"网络就看 Boost.Asio 吧。这个将是未来 C++ 网络标准库的基础。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576625297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161306,"user_name":"tokamak","can_delete":false,"product_type":"c1","uid":1047341,"ip_address":"","ucode":"1726B6FC06AC3C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/2d/e6548e48.jpg","comment_is_top":false,"comment_ctime":1576171405,"is_pvip":true,"replies":[{"id":61592,"content":"我不觉得用异常有什么特别的地方，因而用异常的我个人没觉得有什么特别可参考的。\n\n由于历史原因，有不少大名气的 C++ 程序没有使用异常，特别是 Google 的项目，比如 Chromium。不用异常，实际上是对用户友好（可执行文件略小，性能有可能有小提升），而对开发者更累。\n\n我知道用到异常的一些项目：\n\n- Boost\n- C++ REST SDK\n- pytorch\n- pybind11\n- Armadillo\n- nlohmann&#47;json\n- cppcheck\n- OpenCV\n- LibreOffice\n\n这篇文章也可以看一下：\n\nhttps:&#47;&#47;cppdepend.com&#47;blog&#47;?p=311","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576312289,"ip_address":"","comment_id":161306,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，你好。目前主流的开源项目中，有没有使用了异常的优秀的C++开源项目？可以用来作为参考案例。","like_count":22,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477685,"discussion_content":"我不觉得用异常有什么特别的地方，因而用异常的我个人没觉得有什么特别可参考的。\n\n由于历史原因，有不少大名气的 C++ 程序没有使用异常，特别是 Google 的项目，比如 Chromium。不用异常，实际上是对用户友好（可执行文件略小，性能有可能有小提升），而对开发者更累。\n\n我知道用到异常的一些项目：\n\n- Boost\n- C++ REST SDK\n- pytorch\n- pybind11\n- Armadillo\n- nlohmann/json\n- cppcheck\n- OpenCV\n- LibreOffice\n\n这篇文章也可以看一下：\n\nhttps://cppdepend.com/blog/?p=311","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576312289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179034,"user_name":"fl260919784","can_delete":false,"product_type":"c1","uid":1045678,"ip_address":"","ucode":"D6E10B8BDD0BB8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/ae/3b101c00.jpg","comment_is_top":false,"comment_ctime":1581900140,"is_pvip":false,"replies":[{"id":69498,"content":"可以参考下面这些链接：\n\nhttp:&#47;&#47;baiy.cn&#47;doc&#47;cpp&#47;inside_exception.htm\nhttps:&#47;&#47;gcc.gnu.org&#47;wiki&#47;Dwarf2EHNewbiesHowto\nhttps:&#47;&#47;stackoverflow.com&#47;questions&#47;15670169&#47;what-is-difference-between-sjlj-vs-dwarf-vs-seh","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581916965,"ip_address":"","comment_id":179034,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师好，有没有编译器平台对异常的实现原理的资料呢，比如X86下G++ -S会发现安插了一些__cxa_throw之类的调用，感谢","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484070,"discussion_content":"可以参考下面这些链接：\n\nhttp://baiy.cn/doc/cpp/inside_exception.htm\nhttps://gcc.gnu.org/wiki/Dwarf2EHNewbiesHowto\nhttps://stackoverflow.com/questions/15670169/what-is-difference-between-sjlj-vs-dwarf-vs-seh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581916965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164414,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1576983089,"is_pvip":false,"replies":[{"id":62463,"content":"OK。很好！","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576994438,"ip_address":"","comment_id":164414,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"一、使用异常\n1.异常处理并不意味着需要写显示的try和catch。异常安全的代码，可以没有任何try和catch\n2.适当组织好代码，利用好RAII，实现矩阵的代码和使用矩阵的代码都可以更短、更清晰，处理异常一般情况会记日志或者向外界用户报告错误。\n二、使用异常的理由\n1.vector C++标准容器中提供了at成员函数，能够在下标不存在的时候抛出异常(out_of_range)，作为一种额外的帮助调试手段\n2.强异常保证，就是一旦异常发生，现场会恢复到调用异常之前的状态。(vector在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数，一旦某操作发生异常，就可以恢复原来的样子)\n3.只要使用标准容器就都的处理可能引发的异常bad_alloc\n4。可以使用异常，也可以使用assert\n课后思考\n你的C++项目里使用过异常吗？为什么？\n答：按老师课里说的，只要使用了标准容器就得考虑使用处理异常(bad_alloc)，所以，大部分C++代码如果保证安全的情况下都的考虑这个异常。当然也在别的地方，之前在读取配置文件(json文件)字段的时候加过，如果读取失败，异常抛出\n","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478755,"discussion_content":"OK。很好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576994438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96427,"discussion_content":"谢谢老师的肯定，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577064211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296904,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1623219819,"is_pvip":false,"replies":[{"id":107929,"content":"1. 对。标 noexcept 是一种契约声明，表明该函数永远不应该抛异常，提供不抛异常保证，比强异常安全保证更强。\n\n2. 只有析构函数默认有 noexcept 声明（前提是所有的基类和成员变量的析构函数都 noexcept）。构造函数函数如果不是 default 声明的话，仍需手工标 noexcept。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623370297,"ip_address":"","comment_id":296904,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"异常真是一个大话题，请假老师2个疑问点：\n1. 函数标不标noexcept有什么区别？标了noexcept，表示不会抛出异常，也就表示异常安全吗？异常安全的代码也就不需要try和catch了 。但实际上，不管函数有没有标noexcept，如果确实抛出了异常，就会调用std::terminate。所以总的来说，函数标了noexcept只是一种声明而已，是想告诉编译器它是安全的，可以被move或其他优化，老师这样理解对吗？\n2. 看评论说，析构函数缺省就是noexcept，那么构造函数缺省也是noexcept的吗？有必要标noexcept吗？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521638,"discussion_content":"1. 对。标 noexcept 是一种契约声明，表明该函数永远不应该抛异常，提供不抛异常保证，比强异常安全保证更强。\n\n2. 只有析构函数默认有 noexcept 声明（前提是所有的基类和成员变量的析构函数都 noexcept）。构造函数函数如果不是 default 声明的话，仍需手工标 noexcept。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623370297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160146,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1575880110,"is_pvip":false,"replies":[{"id":61124,"content":"任何东西用得不好都是坑。有朋友遇到小项目里用了一大堆（不必要的）设计模式，把代码硬生生弄得不可理解。不能说设计模式就是不好，是不？\n\nMSVC 可以用 ... 捕获非法指针操作，这也是极易被误用的功能。以前也遇到过一次，一不小心用了这个功能，把明明在调试时可以发现的崩溃变成了程序的怪异行为。不过，严格来讲这不属于 C++ 的异常……这实际上是 Windows 的 SEH，纯 C 里都能做得到。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575895765,"ip_address":"","comment_id":160146,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"用到异常的时候倒不是很多，但是异常千万别乱用，害人害己，\n曾经同事离职，接手他项目的代码，把我坑的，几乎所有能引起crash的地方都用try catch 捕获异常，然而不处理异常，比如非法指针， 这种bug居然用try catch 来规避，坑了我两个月时间才把程序搞稳定了，现在想起他来，心里还有一句mmp想送给他。。。","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477271,"discussion_content":"任何东西用得不好都是坑。有朋友遇到小项目里用了一大堆（不必要的）设计模式，把代码硬生生弄得不可理解。不能说设计模式就是不好，是不？\n\nMSVC 可以用 ... 捕获非法指针操作，这也是极易被误用的功能。以前也遇到过一次，一不小心用了这个功能，把明明在调试时可以发现的崩溃变成了程序的怪异行为。不过，严格来讲这不属于 C++ 的异常……这实际上是 Windows 的 SEH，纯 C 里都能做得到。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575895765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1674369,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqf54z1ZmqQY1kmJ6t1HAnrqMM3j6WKf0oDeVLhtnA2ZUKY6AX9MK6RjvcO8SiczXy3uU0IzBQ3tpw/132","nickname":"Geek_68d3d2","note":"","ucode":"EBD6D881AA7A74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280667,"discussion_content":"在引起crash的地方用异常处理一下不是蛮好的吗，这里的主要矛盾是不是不处理异常啊，导致了程序运行状态不一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591589553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1674369,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqf54z1ZmqQY1kmJ6t1HAnrqMM3j6WKf0oDeVLhtnA2ZUKY6AX9MK6RjvcO8SiczXy3uU0IzBQ3tpw/132","nickname":"Geek_68d3d2","note":"","ucode":"EBD6D881AA7A74","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280968,"discussion_content":"对，主要矛盾就是要不要处理异常，我个人倾向即使不处理异常也要打印出来或写到log里，程序出现怪异行为时有据可查","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591632103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280667,"ip_address":"","group_id":0},"score":280968,"extra":""}]}]},{"had_liked":false,"id":285388,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1616769983,"is_pvip":false,"replies":[{"id":103597,"content":"是的，没有catch，程序会挂掉。但你需要写出 try 和 catch 的地方很少。很多地方的异常处理，就是让程序优雅地通过异常退出当前函数。\n\n就像我文中描述的“matrix c = a * b;”这句可能出异常的地方有好几处，目前的代码写法，也在某种意义上“处理”了异常——确保发生异常时程序行为的完全正常，即给出了异常安全保证。\n\n又如异常安全的代码，常常是让会抛异常的操作最先做（如内存分配），然后再做其他不会抛异常的操作。这样的代码，一般不需要写 try... catch，也同样能在异常情况执行正确的流程。\n\n这和 Java 这样的在编译期进行大量异常检查的语言不一样。在 Java 里，因为检查性异常（checked exception）的使用，你通常会需要写出多得多的 try...catch 语句。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1616834377,"ip_address":"","comment_id":285388,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"为什么说“异常处理并不意味着需要写显式的 try 和 catch”    没有catch的话，程序不是会挂掉吗？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477271,"discussion_content":"任何东西用得不好都是坑。有朋友遇到小项目里用了一大堆（不必要的）设计模式，把代码硬生生弄得不可理解。不能说设计模式就是不好，是不？\n\nMSVC 可以用 ... 捕获非法指针操作，这也是极易被误用的功能。以前也遇到过一次，一不小心用了这个功能，把明明在调试时可以发现的崩溃变成了程序的怪异行为。不过，严格来讲这不属于 C++ 的异常……这实际上是 Windows 的 SEH，纯 C 里都能做得到。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575895765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1674369,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqf54z1ZmqQY1kmJ6t1HAnrqMM3j6WKf0oDeVLhtnA2ZUKY6AX9MK6RjvcO8SiczXy3uU0IzBQ3tpw/132","nickname":"Geek_68d3d2","note":"","ucode":"EBD6D881AA7A74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280667,"discussion_content":"在引起crash的地方用异常处理一下不是蛮好的吗，这里的主要矛盾是不是不处理异常啊，导致了程序运行状态不一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591589553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1674369,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqf54z1ZmqQY1kmJ6t1HAnrqMM3j6WKf0oDeVLhtnA2ZUKY6AX9MK6RjvcO8SiczXy3uU0IzBQ3tpw/132","nickname":"Geek_68d3d2","note":"","ucode":"EBD6D881AA7A74","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280968,"discussion_content":"对，主要矛盾就是要不要处理异常，我个人倾向即使不处理异常也要打印出来或写到log里，程序出现怪异行为时有据可查","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591632103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280667,"ip_address":"","group_id":0},"score":280968,"extra":""}]}]},{"had_liked":false,"id":312673,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1631936207,"is_pvip":false,"replies":[{"id":113310,"content":"1. 强异常安全保证不是无异常保证，只是说发生异常时保证还原现场，对象不发生变化。\n\n2. 基本同上。你似乎把异常安全和noexcept保证混淆了。\n\n异常安全有四级：\n\n不抛异常（noexcept）保证\n强异常安全保证\n基本安全异常保证\n没有任何保证","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1631970060,"ip_address":"","comment_id":312673,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师打扰一下，请教2点疑惑：\n1. 原文中描述：“C++ 的标准容器在大部分情况下提供了强异常保证，即，一旦异常发生，现场会恢复到调用函数之前的状态，容器的内容不会发生改变，也没有任何资源泄漏。”\n\n既然是强异常保证下发生异常，此时不就立即调用std::terminate结束程序了？还需要在意现场有没有恢复？容器的内容有没有发生变化？\n\n2. 原文中描述：“只要你使用了标准容器，不管你自己用不用异常，你都得处理标准容器可能引发的异常——至少有 bad_alloc”\n\n这应该是容器在分配内存时，并不是异常安全的，才会抛出的bad_alloc异常吧？如果分配内存是异常安全的，当发生异常抛出bad_alloc时，就立即std::terminate结束程序了，这样理解对吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517664,"discussion_content":"是的，没有catch，程序会挂掉。但你需要写出 try 和 catch 的地方很少。很多地方的异常处理，就是让程序优雅地通过异常退出当前函数。\n\n就像我文中描述的“matrix c = a * b;”这句可能出异常的地方有好几处，目前的代码写法，也在某种意义上“处理”了异常——确保发生异常时程序行为的完全正常，即给出了异常安全保证。\n\n又如异常安全的代码，常常是让会抛异常的操作最先做（如内存分配），然后再做其他不会抛异常的操作。这样的代码，一般不需要写 try... catch，也同样能在异常情况执行正确的流程。\n\n这和 Java 这样的在编译期进行大量异常检查的语言不一样。在 Java 里，因为检查性异常（checked exception）的使用，你通常会需要写出多得多的 try...catch 语句。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1616834377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221668,"user_name":"Minghao","can_delete":false,"product_type":"c1","uid":1946748,"ip_address":"","ucode":"E08065CD003894","user_header":"https://static001.geekbang.org/account/avatar/00/1d/b4/7c/62c1b9bd.jpg","comment_is_top":false,"comment_ctime":1590562287,"is_pvip":false,"replies":[{"id":81877,"content":"最主要是移动构造函数、移动赋值函数和 swap。析构函数也不应该抛异常，但不用标，缺省就是 noexcept。其他函数，能确保没问题的也标一下，特别是很小的返回引用和指针的函数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590712013,"ip_address":"","comment_id":221668,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"你好老师，学习了06异常和07迭代器，也自己写了一遍smart_pointer和istream_line_reader。您在课中提到了 “vector 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数“。我想请教一下，在自己开发的过程中，一般哪些成员函数需要考虑添加noexcept关键字呢？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527073,"discussion_content":"1. 强异常安全保证不是无异常保证，只是说发生异常时保证还原现场，对象不发生变化。\n\n2. 基本同上。你似乎把异常安全和noexcept保证混淆了。\n\n异常安全有四级：\n\n不抛异常（noexcept）保证\n强异常安全保证\n基本安全异常保证\n没有任何保证","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631970060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159955,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1575851190,"is_pvip":false,"replies":[{"id":61065,"content":"对，这就是 RAII，非常重要。\n\n学习速度飞快啊。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575855412,"ip_address":"","comment_id":159955,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"文中下面的一句话：\n\n“首先是内存分配。如果 new 出错，按照 C++ 的规则，一般会得到异常 bad_alloc，对象的构造也就失败了。这种情况下，在 catch 捕捉到这个异常之前，所有的栈上对象会全部被析构，资源全部被自动清理。”\n\n谈的是new在分配内存时的错误，是堆上内存的错误，但自动被析构的却是栈上的对象。一开始我想是不是笔误了，但仔细想想，堆上的东西都是由栈上的变量所引用的，栈上对象析构的过程，堆上相应的资源自然就被释放了。而且被释放的对象的范围还被栈帧限定了。","like_count":43,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477217,"discussion_content":"对，这就是 RAII，非常重要。\n\n学习速度飞快啊。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575855412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291106,"discussion_content":"需要区分当前对象和其他对象。\n当前对象构造失败，希望通过new获得的堆内存未分配，不会有资源泄露。\n但是直到catch之前的其他分配于堆上的对象，如没用通过smart ref方式管理，则可能造成资源泄露。\n保证强异常安全，是通过smart ref来使用RAII非常有价值一点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594708019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156936,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItaas8rpvXb70zfjMetkEuYeLH0rI348MCaKqyn9HAbGZsdCKibLTnfGEBMbwQLBOhPMROcVBk9vA/132","nickname":"不谈","note":"","ucode":"2E18977EAC5E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86482,"discussion_content":"没想到你想的这么深！不但跟老师学到了东西，跟你也学到了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576596176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066752,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","nickname":"piboye","note":"","ucode":"7CFD8712857A85","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586670,"discussion_content":"内存都失败了，异常有啥用，直接panic，析构也有分配内存的情况。我觉得这就是c++典型的设计失误，还有iostream的设计也是很搞笑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662428710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211961,"discussion_content":"我理解的是，bad_alloc发生时，现在这个new的对象还没有生成，毕竟alloc算是堆上创建第一步吧，然后在这个事件之前的其它对象已经正确initialize，所以直接按栈上的顺序一个一个析构就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584915776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162634,"user_name":"亮","can_delete":false,"product_type":"c1","uid":1244779,"ip_address":"","ucode":"8D97C79DF7D7F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/6b/81b2e40a.jpg","comment_is_top":false,"comment_ctime":1576570204,"is_pvip":false,"replies":[{"id":61882,"content":"网络就看 Boost.Asio 吧。这个将是未来 C++ 网络标准库的基础。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576625297,"ip_address":"","comment_id":162634,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看到老师说了部分开源的异常优秀的C++开源项目，老师能否推荐些现在流行的，能逐步深入的网络编程方面的C++开源项目看呢，从入门到深入的都推荐一些吧。谢谢老师","like_count":31,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477217,"discussion_content":"对，这就是 RAII，非常重要。\n\n学习速度飞快啊。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575855412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291106,"discussion_content":"需要区分当前对象和其他对象。\n当前对象构造失败，希望通过new获得的堆内存未分配，不会有资源泄露。\n但是直到catch之前的其他分配于堆上的对象，如没用通过smart ref方式管理，则可能造成资源泄露。\n保证强异常安全，是通过smart ref来使用RAII非常有价值一点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594708019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156936,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItaas8rpvXb70zfjMetkEuYeLH0rI348MCaKqyn9HAbGZsdCKibLTnfGEBMbwQLBOhPMROcVBk9vA/132","nickname":"不谈","note":"","ucode":"2E18977EAC5E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86482,"discussion_content":"没想到你想的这么深！不但跟老师学到了东西，跟你也学到了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576596176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066752,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","nickname":"piboye","note":"","ucode":"7CFD8712857A85","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586670,"discussion_content":"内存都失败了，异常有啥用，直接panic，析构也有分配内存的情况。我觉得这就是c++典型的设计失误，还有iostream的设计也是很搞笑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662428710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211961,"discussion_content":"我理解的是，bad_alloc发生时，现在这个new的对象还没有生成，毕竟alloc算是堆上创建第一步吧，然后在这个事件之前的其它对象已经正确initialize，所以直接按栈上的顺序一个一个析构就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584915776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161306,"user_name":"tokamak","can_delete":false,"product_type":"c1","uid":1047341,"ip_address":"","ucode":"1726B6FC06AC3C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/2d/e6548e48.jpg","comment_is_top":false,"comment_ctime":1576171405,"is_pvip":true,"replies":[{"id":61592,"content":"我不觉得用异常有什么特别的地方，因而用异常的我个人没觉得有什么特别可参考的。\n\n由于历史原因，有不少大名气的 C++ 程序没有使用异常，特别是 Google 的项目，比如 Chromium。不用异常，实际上是对用户友好（可执行文件略小，性能有可能有小提升），而对开发者更累。\n\n我知道用到异常的一些项目：\n\n- Boost\n- C++ REST SDK\n- pytorch\n- pybind11\n- Armadillo\n- nlohmann&#47;json\n- cppcheck\n- OpenCV\n- LibreOffice\n\n这篇文章也可以看一下：\n\nhttps:&#47;&#47;cppdepend.com&#47;blog&#47;?p=311","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576312289,"ip_address":"","comment_id":161306,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，你好。目前主流的开源项目中，有没有使用了异常的优秀的C++开源项目？可以用来作为参考案例。","like_count":22,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478112,"discussion_content":"网络就看 Boost.Asio 吧。这个将是未来 C++ 网络标准库的基础。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576625297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179034,"user_name":"fl260919784","can_delete":false,"product_type":"c1","uid":1045678,"ip_address":"","ucode":"D6E10B8BDD0BB8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/ae/3b101c00.jpg","comment_is_top":false,"comment_ctime":1581900140,"is_pvip":false,"replies":[{"id":69498,"content":"可以参考下面这些链接：\n\nhttp:&#47;&#47;baiy.cn&#47;doc&#47;cpp&#47;inside_exception.htm\nhttps:&#47;&#47;gcc.gnu.org&#47;wiki&#47;Dwarf2EHNewbiesHowto\nhttps:&#47;&#47;stackoverflow.com&#47;questions&#47;15670169&#47;what-is-difference-between-sjlj-vs-dwarf-vs-seh","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581916965,"ip_address":"","comment_id":179034,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师好，有没有编译器平台对异常的实现原理的资料呢，比如X86下G++ -S会发现安插了一些__cxa_throw之类的调用，感谢","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477685,"discussion_content":"我不觉得用异常有什么特别的地方，因而用异常的我个人没觉得有什么特别可参考的。\n\n由于历史原因，有不少大名气的 C++ 程序没有使用异常，特别是 Google 的项目，比如 Chromium。不用异常，实际上是对用户友好（可执行文件略小，性能有可能有小提升），而对开发者更累。\n\n我知道用到异常的一些项目：\n\n- Boost\n- C++ REST SDK\n- pytorch\n- pybind11\n- Armadillo\n- nlohmann/json\n- cppcheck\n- OpenCV\n- LibreOffice\n\n这篇文章也可以看一下：\n\nhttps://cppdepend.com/blog/?p=311","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576312289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164414,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1576983089,"is_pvip":false,"replies":[{"id":62463,"content":"OK。很好！","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576994438,"ip_address":"","comment_id":164414,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"一、使用异常\n1.异常处理并不意味着需要写显示的try和catch。异常安全的代码，可以没有任何try和catch\n2.适当组织好代码，利用好RAII，实现矩阵的代码和使用矩阵的代码都可以更短、更清晰，处理异常一般情况会记日志或者向外界用户报告错误。\n二、使用异常的理由\n1.vector C++标准容器中提供了at成员函数，能够在下标不存在的时候抛出异常(out_of_range)，作为一种额外的帮助调试手段\n2.强异常保证，就是一旦异常发生，现场会恢复到调用异常之前的状态。(vector在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数，一旦某操作发生异常，就可以恢复原来的样子)\n3.只要使用标准容器就都的处理可能引发的异常bad_alloc\n4。可以使用异常，也可以使用assert\n课后思考\n你的C++项目里使用过异常吗？为什么？\n答：按老师课里说的，只要使用了标准容器就得考虑使用处理异常(bad_alloc)，所以，大部分C++代码如果保证安全的情况下都的考虑这个异常。当然也在别的地方，之前在读取配置文件(json文件)字段的时候加过，如果读取失败，异常抛出\n","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484070,"discussion_content":"可以参考下面这些链接：\n\nhttp://baiy.cn/doc/cpp/inside_exception.htm\nhttps://gcc.gnu.org/wiki/Dwarf2EHNewbiesHowto\nhttps://stackoverflow.com/questions/15670169/what-is-difference-between-sjlj-vs-dwarf-vs-seh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581916965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296904,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1623219819,"is_pvip":false,"replies":[{"id":107929,"content":"1. 对。标 noexcept 是一种契约声明，表明该函数永远不应该抛异常，提供不抛异常保证，比强异常安全保证更强。\n\n2. 只有析构函数默认有 noexcept 声明（前提是所有的基类和成员变量的析构函数都 noexcept）。构造函数函数如果不是 default 声明的话，仍需手工标 noexcept。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623370297,"ip_address":"","comment_id":296904,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"异常真是一个大话题，请假老师2个疑问点：\n1. 函数标不标noexcept有什么区别？标了noexcept，表示不会抛出异常，也就表示异常安全吗？异常安全的代码也就不需要try和catch了 。但实际上，不管函数有没有标noexcept，如果确实抛出了异常，就会调用std::terminate。所以总的来说，函数标了noexcept只是一种声明而已，是想告诉编译器它是安全的，可以被move或其他优化，老师这样理解对吗？\n2. 看评论说，析构函数缺省就是noexcept，那么构造函数缺省也是noexcept的吗？有必要标noexcept吗？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478755,"discussion_content":"OK。很好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576994438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96427,"discussion_content":"谢谢老师的肯定，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577064211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160146,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1575880110,"is_pvip":false,"replies":[{"id":61124,"content":"任何东西用得不好都是坑。有朋友遇到小项目里用了一大堆（不必要的）设计模式，把代码硬生生弄得不可理解。不能说设计模式就是不好，是不？\n\nMSVC 可以用 ... 捕获非法指针操作，这也是极易被误用的功能。以前也遇到过一次，一不小心用了这个功能，把明明在调试时可以发现的崩溃变成了程序的怪异行为。不过，严格来讲这不属于 C++ 的异常……这实际上是 Windows 的 SEH，纯 C 里都能做得到。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575895765,"ip_address":"","comment_id":160146,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"用到异常的时候倒不是很多，但是异常千万别乱用，害人害己，\n曾经同事离职，接手他项目的代码，把我坑的，几乎所有能引起crash的地方都用try catch 捕获异常，然而不处理异常，比如非法指针， 这种bug居然用try catch 来规避，坑了我两个月时间才把程序搞稳定了，现在想起他来，心里还有一句mmp想送给他。。。","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521638,"discussion_content":"1. 对。标 noexcept 是一种契约声明，表明该函数永远不应该抛异常，提供不抛异常保证，比强异常安全保证更强。\n\n2. 只有析构函数默认有 noexcept 声明（前提是所有的基类和成员变量的析构函数都 noexcept）。构造函数函数如果不是 default 声明的话，仍需手工标 noexcept。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623370297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285388,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1616769983,"is_pvip":false,"replies":[{"id":103597,"content":"是的，没有catch，程序会挂掉。但你需要写出 try 和 catch 的地方很少。很多地方的异常处理，就是让程序优雅地通过异常退出当前函数。\n\n就像我文中描述的“matrix c = a * b;”这句可能出异常的地方有好几处，目前的代码写法，也在某种意义上“处理”了异常——确保发生异常时程序行为的完全正常，即给出了异常安全保证。\n\n又如异常安全的代码，常常是让会抛异常的操作最先做（如内存分配），然后再做其他不会抛异常的操作。这样的代码，一般不需要写 try... catch，也同样能在异常情况执行正确的流程。\n\n这和 Java 这样的在编译期进行大量异常检查的语言不一样。在 Java 里，因为检查性异常（checked exception）的使用，你通常会需要写出多得多的 try...catch 语句。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1616834377,"ip_address":"","comment_id":285388,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"为什么说“异常处理并不意味着需要写显式的 try 和 catch”    没有catch的话，程序不是会挂掉吗？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517664,"discussion_content":"是的，没有catch，程序会挂掉。但你需要写出 try 和 catch 的地方很少。很多地方的异常处理，就是让程序优雅地通过异常退出当前函数。\n\n就像我文中描述的“matrix c = a * b;”这句可能出异常的地方有好几处，目前的代码写法，也在某种意义上“处理”了异常——确保发生异常时程序行为的完全正常，即给出了异常安全保证。\n\n又如异常安全的代码，常常是让会抛异常的操作最先做（如内存分配），然后再做其他不会抛异常的操作。这样的代码，一般不需要写 try... catch，也同样能在异常情况执行正确的流程。\n\n这和 Java 这样的在编译期进行大量异常检查的语言不一样。在 Java 里，因为检查性异常（checked exception）的使用，你通常会需要写出多得多的 try...catch 语句。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1616834377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312673,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1631936207,"is_pvip":false,"replies":[{"id":113310,"content":"1. 强异常安全保证不是无异常保证，只是说发生异常时保证还原现场，对象不发生变化。\n\n2. 基本同上。你似乎把异常安全和noexcept保证混淆了。\n\n异常安全有四级：\n\n不抛异常（noexcept）保证\n强异常安全保证\n基本安全异常保证\n没有任何保证","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1631970060,"ip_address":"","comment_id":312673,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师打扰一下，请教2点疑惑：\n1. 原文中描述：“C++ 的标准容器在大部分情况下提供了强异常保证，即，一旦异常发生，现场会恢复到调用函数之前的状态，容器的内容不会发生改变，也没有任何资源泄漏。”\n\n既然是强异常保证下发生异常，此时不就立即调用std::terminate结束程序了？还需要在意现场有没有恢复？容器的内容有没有发生变化？\n\n2. 原文中描述：“只要你使用了标准容器，不管你自己用不用异常，你都得处理标准容器可能引发的异常——至少有 bad_alloc”\n\n这应该是容器在分配内存时，并不是异常安全的，才会抛出的bad_alloc异常吧？如果分配内存是异常安全的，当发生异常抛出bad_alloc时，就立即std::terminate结束程序了，这样理解对吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527073,"discussion_content":"1. 强异常安全保证不是无异常保证，只是说发生异常时保证还原现场，对象不发生变化。\n\n2. 基本同上。你似乎把异常安全和noexcept保证混淆了。\n\n异常安全有四级：\n\n不抛异常（noexcept）保证\n强异常安全保证\n基本安全异常保证\n没有任何保证","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631970060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221668,"user_name":"Minghao","can_delete":false,"product_type":"c1","uid":1946748,"ip_address":"","ucode":"E08065CD003894","user_header":"https://static001.geekbang.org/account/avatar/00/1d/b4/7c/62c1b9bd.jpg","comment_is_top":false,"comment_ctime":1590562287,"is_pvip":false,"replies":[{"id":81877,"content":"最主要是移动构造函数、移动赋值函数和 swap。析构函数也不应该抛异常，但不用标，缺省就是 noexcept。其他函数，能确保没问题的也标一下，特别是很小的返回引用和指针的函数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590712013,"ip_address":"","comment_id":221668,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"你好老师，学习了06异常和07迭代器，也自己写了一遍smart_pointer和istream_line_reader。您在课中提到了 “vector 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数“。我想请教一下，在自己开发的过程中，一般哪些成员函数需要考虑添加noexcept关键字呢？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496533,"discussion_content":"最主要是移动构造函数、移动赋值函数和 swap。析构函数也不应该抛异常，但不用标，缺省就是 noexcept。其他函数，能确保没问题的也标一下，特别是很小的返回引用和指针的函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590712013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160003,"user_name":"李蔚韬","can_delete":false,"product_type":"c1","uid":1485304,"ip_address":"","ucode":"B5367CD3569C34","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","comment_is_top":false,"comment_ctime":1575856294,"is_pvip":false,"replies":[{"id":61089,"content":"GCC&#47;Clang 下的 -fexceptions（缺省开启），MSVC 下的 &#47;EHsc（我要求大家需要用的，Visual Studio 项目里也会自动用）。\n\n我刚试了，用 GCC，加上 -fno-exceptions 命令行参数，对于下面这样的小程序，也能看到产生的可执行文件的大小的变化。\n\n#include &lt;vector&gt;\n\nint main()\n{\n    std::vector&lt;int&gt; v{1, 2, 3, 4, 5};\n    v.push_back(20);\n}","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575870669,"ip_address":"","comment_id":160003,"utype":1}],"discussion_count":5,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，对于异常的第一条批评我不太理解，什么叫“只要开启异常，即使不使用”，这里的开启是指什么呢？","like_count":2},{"had_liked":false,"id":279901,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1613996799,"is_pvip":false,"replies":[{"id":101695,"content":"你说是个标准没有规定的实现细节。如果程序的异常完全没有捕获，程序就会挂。要挂的程序，还要清理啥？所以大部分实现就完全不清理了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1614039697,"ip_address":"","comment_id":279901,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我理解RAII也并不是完全自动的，如果最顶层函数都没有try catch块的话，程序还是会异常结束，伴随着可能存在资源没释放的情况。RAII + 至少一个有效的try catch块 才能保证出现异常时，资源也会正确释放吧。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515915,"discussion_content":"你说是个标准没有规定的实现细节。如果程序的异常完全没有捕获，程序就会挂。要挂的程序，还要清理啥？所以大部分实现就完全不清理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614039697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246757,"user_name":"what are you up","can_delete":false,"product_type":"c1","uid":1196480,"ip_address":"","ucode":"AEEE63C5BB00C2","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/c0/910c4834.jpg","comment_is_top":false,"comment_ctime":1599470849,"is_pvip":false,"replies":[{"id":90687,"content":"可以，但不应该。先记住基本规则，不要在析构函数里抛异常——除非你是C++专家，知道所有的语法细节和特殊处理逻辑，知道你为什么要打破规则。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599486890,"ip_address":"","comment_id":246757,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"析构函数没法抛出异常吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505220,"discussion_content":"可以，但不应该。先记住基本规则，不要在析构函数里抛异常——除非你是C++专家，知道所有的语法细节和特殊处理逻辑，知道你为什么要打破规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599486890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193580,"user_name":"Fiery","can_delete":false,"product_type":"c1","uid":1897610,"ip_address":"","ucode":"CDB000687A6B14","user_header":"","comment_is_top":false,"comment_ctime":1584930244,"is_pvip":false,"replies":[{"id":73764,"content":"返回错误码在C++里有很多方案的，继续往下看吧（第8讲和第22讲）。\n\nPython和Go还是有明显区别的。两者都支持很方便地返回多个值，但Python里的错误处理仍然是异常为主。\n\n使用错误码，会让代码更啰嗦，对代码的整体设计要求更高，使用上不及异常方便。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584950263,"ip_address":"","comment_id":193580,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"习惯了python和golang支持的多返回值，会感觉返回错误码很方便，只要把错误码作为第二个返回值就好了，只不过c++默认只支持一个返回值，想返回多个值还要显示的调用std::tie，要是可以直接支持多返回值的话，就不会这么纠结了吧？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505220,"discussion_content":"可以，但不应该。先记住基本规则，不要在析构函数里抛异常——除非你是C++专家，知道所有的语法细节和特殊处理逻辑，知道你为什么要打破规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599486890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386404,"user_name":"寒先森","can_delete":false,"product_type":"c1","uid":3623586,"ip_address":"浙江","ucode":"96A68FC9307BAB","user_header":"https://static001.geekbang.org/account/avatar/00/37/4a/a2/4ff26e2c.jpg","comment_is_top":false,"comment_ctime":1704774357,"is_pvip":false,"replies":[{"id":140896,"content":"首先，跨语言的部分基本只能用最简单的方式，也就是错误码。这基本没什么好办法。\n\n其次，在 C++ 和 Python 里传播错误，仍可以使用异常，包括接口处收到的错误码也可以用异常包装起来。当然，一定要小心不要让异常传播到当前语言的模块之外。\n\n最后，C++ 里使用异常应当只限于罕见的“异常”场景。正常、预料中的常见错误不要使用异常。异常的运行期开销还是很大的（一旦发生的话；没有实际发生没问题）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1705024188,"ip_address":"上海","comment_id":386404,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，如果一个项目混合了C、C++、Python，应该怎么协调统一不同语言之间的错误处理方式呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488592,"discussion_content":"返回错误码在C++里有很多方案的，继续往下看吧（第8讲和第22讲）。\n\nPython和Go还是有明显区别的。两者都支持很方便地返回多个值，但Python里的错误处理仍然是异常为主。\n\n使用错误码，会让代码更啰嗦，对代码的整体设计要求更高，使用上不及异常方便。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584950263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367918,"user_name":"灯盖","can_delete":false,"product_type":"c1","uid":1482839,"ip_address":"北京","ucode":"0F8455A593D60C","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","comment_is_top":false,"comment_ctime":1675738020,"is_pvip":false,"replies":[{"id":134022,"content":"核心关注：满足项目的基本约束（性能、空间等）；开发者易于使用；处理方式具有一致性（实际也是易用性的一种体现）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1675901126,"ip_address":"广东","comment_id":367918,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"项目中有使用异常。多层函数的嵌套，异常信号的传递都是在这个过程中需要考虑的问题。异常，bool返回值，错误码，assert这些手段目前在项目中都有存在。怎样是一个比较好的状态，还需要摸索。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635652,"discussion_content":"首先，跨语言的部分基本只能用最简单的方式，也就是错误码。这基本没什么好办法。\n\n其次，在 C++ 和 Python 里传播错误，仍可以使用异常，包括接口处收到的错误码也可以用异常包装起来。当然，一定要小心不要让异常传播到当前语言的模块之外。\n\n最后，C++ 里使用异常应当只限于罕见的“异常”场景。正常、预料中的常见错误不要使用异常。异常的运行期开销还是很大的（一旦发生的话；没有实际发生没问题）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705024188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348504,"user_name":"anotherS","can_delete":false,"product_type":"c1","uid":3023850,"ip_address":"","ucode":"E0A72CC1EBC558","user_header":"","comment_is_top":false,"comment_ctime":1655139744,"is_pvip":false,"replies":[{"id":126967,"content":"这是 libc++ 里的 shared_ptr 的一个构造函数：\n\n    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {\n        unique_ptr&lt;_Yp&gt; __hold(__p);\n        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;\n        typedef __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT &gt; _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());\n        __hold.release();\n        __enable_weak_this(__p, __p);\n    }\n\n如果使用 try&#47;catch，可以写成下面的样子：\n\n    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {\n        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;\n        typedef __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT &gt; _CntrlBlk;\n        try {\n            __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());\n        } catch (std::bad_alloc&amp;) {\n            delete __p;\n            throw;\n        }\n        __enable_weak_this(__p, __p);\n    }\n\n能用 RAII 的时候，用 RAII 来保证异常安全。外层当然还是需要有个地方 try&#47;catch 来做真正的错误处理的，但和错误码的情况不同，你在大部分的代码里不用显式处理错误。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1655259304,"ip_address":"","comment_id":348504,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"&quot;1.异常处理并不意味着需要写显式的 try 和 catch。2.异常安全的代码，可以没有任何 try 和 catch。&quot;\n这个可以举个例子吗？\n1. 不显示的写是说还有隐式的什么操作吗？\n2. 异常安全的代码，异常安全指在发生异常时，既不会发生资源泄漏，系统也不会处于一个不一致的状态。但是还是有异常发生并且抛出了，如果没有try cache ，那不是崩了？崩了都不try吗？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602996,"discussion_content":"核心关注：满足项目的基本约束（性能、空间等）；开发者易于使用；处理方式具有一致性（实际也是易用性的一种体现）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675901126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341812,"user_name":"jcy","can_delete":false,"product_type":"c1","uid":1264411,"ip_address":"","ucode":"7C3E10C4E0FA87","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/1b/e3b3bcff.jpg","comment_is_top":false,"comment_ctime":1649841108,"is_pvip":false,"replies":[{"id":125055,"content":"谢谢。已修正。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1650190247,"ip_address":"","comment_id":341812,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"明白了，大概理解是使用异常代码更简洁优雅，非特殊场景使用异常更好\n\n另 第一次定义 class matrix 的地方最后少了个 ; 号","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576047,"discussion_content":"这是 libc++ 里的 shared_ptr 的一个构造函数：\n\n    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {\n        unique_ptr&lt;_Yp&gt; __hold(__p);\n        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;\n        typedef __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT &gt; _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());\n        __hold.release();\n        __enable_weak_this(__p, __p);\n    }\n\n如果使用 try/catch，可以写成下面的样子：\n\n    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {\n        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;\n        typedef __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT &gt; _CntrlBlk;\n        try {\n            __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());\n        } catch (std::bad_alloc&amp;) {\n            delete __p;\n            throw;\n        }\n        __enable_weak_this(__p, __p);\n    }\n\n能用 RAII 的时候，用 RAII 来保证异常安全。外层当然还是需要有个地方 try/catch 来做真正的错误处理的，但和错误码的情况不同，你在大部分的代码里不用显式处理错误。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655259304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297202,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1623375987,"is_pvip":false,"replies":[{"id":107985,"content":"我这儿写得不太好，应该说自动生成的特殊成员函数会是 noexcept……\n\n如果一个标成 noexcept 的函数中抛出了异常，编译器会自动产生一个对 std::terminate 的调用，终止程序运行。这个是运行期行为。编译时编译器不会对你调用非 noexcept 的函数有任何指示。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623479435,"ip_address":"","comment_id":297202,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师又打扰一下，原文中“特殊成员（构造函数、析构函数、赋值函数等）会自动成为 noexcept，如果它们调用的代码都是 noexcept 的话。”那么返过来呢？例如赋值函数标noexcept，而赋值函数中调用的swap函数没有noexcept，那么最终会是什么效果？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564206,"discussion_content":"谢谢。已修正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650190247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224908,"user_name":"Geek_68d3d2","can_delete":false,"product_type":"c1","uid":1674369,"ip_address":"","ucode":"EBD6D881AA7A74","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqf54z1ZmqQY1kmJ6t1HAnrqMM3j6WKf0oDeVLhtnA2ZUKY6AX9MK6RjvcO8SiczXy3uU0IzBQ3tpw/132","comment_is_top":false,"comment_ctime":1591589195,"is_pvip":false,"replies":[{"id":82791,"content":"对。\n\n错误码的主要好处是代码直白（但啰嗦），开销低。异常代码更优雅，但需要更多的训练。另外，如果没有捕获异常的话，异常在GCC和Clang上都可以产生较友好的运行时错误，方便调试。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591617618,"ip_address":"","comment_id":224908,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"总结：程序在编写过程中总会有不正常的情况，处理不正常的情况要么使用错误码各种if&#47;else 还要预防在构造函数里出现不正常现象，要么使用异常，在异常出现后进行try catch最终保证程序无内存泄漏且功能一致。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521759,"discussion_content":"我这儿写得不太好，应该说自动生成的特殊成员函数会是 noexcept……\n\n如果一个标成 noexcept 的函数中抛出了异常，编译器会自动产生一个对 std::terminate 的调用，终止程序运行。这个是运行期行为。编译时编译器不会对你调用非 noexcept 的函数有任何指示。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623479435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160003,"user_name":"李蔚韬","can_delete":false,"product_type":"c1","uid":1485304,"ip_address":"","ucode":"B5367CD3569C34","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","comment_is_top":false,"comment_ctime":1575856294,"is_pvip":false,"replies":[{"id":61089,"content":"GCC&#47;Clang 下的 -fexceptions（缺省开启），MSVC 下的 &#47;EHsc（我要求大家需要用的，Visual Studio 项目里也会自动用）。\n\n我刚试了，用 GCC，加上 -fno-exceptions 命令行参数，对于下面这样的小程序，也能看到产生的可执行文件的大小的变化。\n\n#include &lt;vector&gt;\n\nint main()\n{\n    std::vector&lt;int&gt; v{1, 2, 3, 4, 5};\n    v.push_back(20);\n}","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575870669,"ip_address":"","comment_id":160003,"utype":1}],"discussion_count":5,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，对于异常的第一条批评我不太理解，什么叫“只要开启异常，即使不使用”，这里的开启是指什么呢？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477231,"discussion_content":"GCC/Clang 下的 -fexceptions（缺省开启），MSVC 下的 /EHsc（我要求大家需要用的，Visual Studio 项目里也会自动用）。\n\n我刚试了，用 GCC，加上 -fno-exceptions 命令行参数，对于下面这样的小程序，也能看到产生的可执行文件的大小的变化。\n\n#include &amp;lt;vector&amp;gt;\n\nint main()\n{\n    std::vector&amp;lt;int&amp;gt; v{1, 2, 3, 4, 5};\n    v.push_back(20);\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575870669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76945,"discussion_content":"是的，所以使用这个有很大风险程序会abort，建议是不要编译时禁用exception，二进制文件的大小在绝大多数情况下都不是问题，而exception的额外开销现在也很小了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575870828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77228,"discussion_content":"你用到异常了，自然不应该关异常。关异常仅限于你不用异常的情况。（那时，你连STL也很多都不该用了。）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":76945,"ip_address":"","group_id":0},"score":77228,"extra":""}]},{"author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76841,"discussion_content":"关闭异常指的是用-fno-exceptions在编译时禁用异常吗？开启异常指的就是编译时不禁用exception，即使代码中不使用exception也要承受因为额外footprint带来的代码膨胀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575858685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77229,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":76841,"ip_address":"","group_id":0},"score":77229,"extra":""}]}]},{"had_liked":false,"id":279901,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1613996799,"is_pvip":false,"replies":[{"id":101695,"content":"你说是个标准没有规定的实现细节。如果程序的异常完全没有捕获，程序就会挂。要挂的程序，还要清理啥？所以大部分实现就完全不清理了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1614039697,"ip_address":"","comment_id":279901,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我理解RAII也并不是完全自动的，如果最顶层函数都没有try catch块的话，程序还是会异常结束，伴随着可能存在资源没释放的情况。RAII + 至少一个有效的try catch块 才能保证出现异常时，资源也会正确释放吧。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477231,"discussion_content":"GCC/Clang 下的 -fexceptions（缺省开启），MSVC 下的 /EHsc（我要求大家需要用的，Visual Studio 项目里也会自动用）。\n\n我刚试了，用 GCC，加上 -fno-exceptions 命令行参数，对于下面这样的小程序，也能看到产生的可执行文件的大小的变化。\n\n#include &amp;lt;vector&amp;gt;\n\nint main()\n{\n    std::vector&amp;lt;int&amp;gt; v{1, 2, 3, 4, 5};\n    v.push_back(20);\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575870669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76945,"discussion_content":"是的，所以使用这个有很大风险程序会abort，建议是不要编译时禁用exception，二进制文件的大小在绝大多数情况下都不是问题，而exception的额外开销现在也很小了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575870828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77228,"discussion_content":"你用到异常了，自然不应该关异常。关异常仅限于你不用异常的情况。（那时，你连STL也很多都不该用了。）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":76945,"ip_address":"","group_id":0},"score":77228,"extra":""}]},{"author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76841,"discussion_content":"关闭异常指的是用-fno-exceptions在编译时禁用异常吗？开启异常指的就是编译时不禁用exception，即使代码中不使用exception也要承受因为额外footprint带来的代码膨胀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575858685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77229,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":76841,"ip_address":"","group_id":0},"score":77229,"extra":""}]}]},{"had_liked":false,"id":246757,"user_name":"what are you up","can_delete":false,"product_type":"c1","uid":1196480,"ip_address":"","ucode":"AEEE63C5BB00C2","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/c0/910c4834.jpg","comment_is_top":false,"comment_ctime":1599470849,"is_pvip":false,"replies":[{"id":90687,"content":"可以，但不应该。先记住基本规则，不要在析构函数里抛异常——除非你是C++专家，知道所有的语法细节和特殊处理逻辑，知道你为什么要打破规则。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599486890,"ip_address":"","comment_id":246757,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"析构函数没法抛出异常吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515915,"discussion_content":"你说是个标准没有规定的实现细节。如果程序的异常完全没有捕获，程序就会挂。要挂的程序，还要清理啥？所以大部分实现就完全不清理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614039697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193580,"user_name":"Fiery","can_delete":false,"product_type":"c1","uid":1897610,"ip_address":"","ucode":"CDB000687A6B14","user_header":"","comment_is_top":false,"comment_ctime":1584930244,"is_pvip":false,"replies":[{"id":73764,"content":"返回错误码在C++里有很多方案的，继续往下看吧（第8讲和第22讲）。\n\nPython和Go还是有明显区别的。两者都支持很方便地返回多个值，但Python里的错误处理仍然是异常为主。\n\n使用错误码，会让代码更啰嗦，对代码的整体设计要求更高，使用上不及异常方便。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584950263,"ip_address":"","comment_id":193580,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"习惯了python和golang支持的多返回值，会感觉返回错误码很方便，只要把错误码作为第二个返回值就好了，只不过c++默认只支持一个返回值，想返回多个值还要显示的调用std::tie，要是可以直接支持多返回值的话，就不会这么纠结了吧？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488592,"discussion_content":"返回错误码在C++里有很多方案的，继续往下看吧（第8讲和第22讲）。\n\nPython和Go还是有明显区别的。两者都支持很方便地返回多个值，但Python里的错误处理仍然是异常为主。\n\n使用错误码，会让代码更啰嗦，对代码的整体设计要求更高，使用上不及异常方便。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584950263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386404,"user_name":"寒先森","can_delete":false,"product_type":"c1","uid":3623586,"ip_address":"浙江","ucode":"96A68FC9307BAB","user_header":"https://static001.geekbang.org/account/avatar/00/37/4a/a2/4ff26e2c.jpg","comment_is_top":false,"comment_ctime":1704774357,"is_pvip":false,"replies":[{"id":140896,"content":"首先，跨语言的部分基本只能用最简单的方式，也就是错误码。这基本没什么好办法。\n\n其次，在 C++ 和 Python 里传播错误，仍可以使用异常，包括接口处收到的错误码也可以用异常包装起来。当然，一定要小心不要让异常传播到当前语言的模块之外。\n\n最后，C++ 里使用异常应当只限于罕见的“异常”场景。正常、预料中的常见错误不要使用异常。异常的运行期开销还是很大的（一旦发生的话；没有实际发生没问题）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1705024188,"ip_address":"上海","comment_id":386404,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，如果一个项目混合了C、C++、Python，应该怎么协调统一不同语言之间的错误处理方式呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635652,"discussion_content":"首先，跨语言的部分基本只能用最简单的方式，也就是错误码。这基本没什么好办法。\n\n其次，在 C++ 和 Python 里传播错误，仍可以使用异常，包括接口处收到的错误码也可以用异常包装起来。当然，一定要小心不要让异常传播到当前语言的模块之外。\n\n最后，C++ 里使用异常应当只限于罕见的“异常”场景。正常、预料中的常见错误不要使用异常。异常的运行期开销还是很大的（一旦发生的话；没有实际发生没问题）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705024188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367918,"user_name":"灯盖","can_delete":false,"product_type":"c1","uid":1482839,"ip_address":"北京","ucode":"0F8455A593D60C","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","comment_is_top":false,"comment_ctime":1675738020,"is_pvip":false,"replies":[{"id":134022,"content":"核心关注：满足项目的基本约束（性能、空间等）；开发者易于使用；处理方式具有一致性（实际也是易用性的一种体现）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1675901126,"ip_address":"广东","comment_id":367918,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"项目中有使用异常。多层函数的嵌套，异常信号的传递都是在这个过程中需要考虑的问题。异常，bool返回值，错误码，assert这些手段目前在项目中都有存在。怎样是一个比较好的状态，还需要摸索。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602996,"discussion_content":"核心关注：满足项目的基本约束（性能、空间等）；开发者易于使用；处理方式具有一致性（实际也是易用性的一种体现）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675901126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348504,"user_name":"anotherS","can_delete":false,"product_type":"c1","uid":3023850,"ip_address":"","ucode":"E0A72CC1EBC558","user_header":"","comment_is_top":false,"comment_ctime":1655139744,"is_pvip":false,"replies":[{"id":126967,"content":"这是 libc++ 里的 shared_ptr 的一个构造函数：\n\n    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {\n        unique_ptr&lt;_Yp&gt; __hold(__p);\n        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;\n        typedef __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT &gt; _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());\n        __hold.release();\n        __enable_weak_this(__p, __p);\n    }\n\n如果使用 try&#47;catch，可以写成下面的样子：\n\n    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {\n        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;\n        typedef __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT &gt; _CntrlBlk;\n        try {\n            __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());\n        } catch (std::bad_alloc&amp;) {\n            delete __p;\n            throw;\n        }\n        __enable_weak_this(__p, __p);\n    }\n\n能用 RAII 的时候，用 RAII 来保证异常安全。外层当然还是需要有个地方 try&#47;catch 来做真正的错误处理的，但和错误码的情况不同，你在大部分的代码里不用显式处理错误。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1655259304,"ip_address":"","comment_id":348504,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"&quot;1.异常处理并不意味着需要写显式的 try 和 catch。2.异常安全的代码，可以没有任何 try 和 catch。&quot;\n这个可以举个例子吗？\n1. 不显示的写是说还有隐式的什么操作吗？\n2. 异常安全的代码，异常安全指在发生异常时，既不会发生资源泄漏，系统也不会处于一个不一致的状态。但是还是有异常发生并且抛出了，如果没有try cache ，那不是崩了？崩了都不try吗？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576047,"discussion_content":"这是 libc++ 里的 shared_ptr 的一个构造函数：\n\n    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {\n        unique_ptr&lt;_Yp&gt; __hold(__p);\n        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;\n        typedef __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT &gt; _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());\n        __hold.release();\n        __enable_weak_this(__p, __p);\n    }\n\n如果使用 try/catch，可以写成下面的样子：\n\n    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {\n        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;\n        typedef __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT &gt; _CntrlBlk;\n        try {\n            __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());\n        } catch (std::bad_alloc&amp;) {\n            delete __p;\n            throw;\n        }\n        __enable_weak_this(__p, __p);\n    }\n\n能用 RAII 的时候，用 RAII 来保证异常安全。外层当然还是需要有个地方 try/catch 来做真正的错误处理的，但和错误码的情况不同，你在大部分的代码里不用显式处理错误。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655259304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341812,"user_name":"jcy","can_delete":false,"product_type":"c1","uid":1264411,"ip_address":"","ucode":"7C3E10C4E0FA87","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/1b/e3b3bcff.jpg","comment_is_top":false,"comment_ctime":1649841108,"is_pvip":false,"replies":[{"id":125055,"content":"谢谢。已修正。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1650190247,"ip_address":"","comment_id":341812,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"明白了，大概理解是使用异常代码更简洁优雅，非特殊场景使用异常更好\n\n另 第一次定义 class matrix 的地方最后少了个 ; 号","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564206,"discussion_content":"谢谢。已修正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650190247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297202,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1623375987,"is_pvip":false,"replies":[{"id":107985,"content":"我这儿写得不太好，应该说自动生成的特殊成员函数会是 noexcept……\n\n如果一个标成 noexcept 的函数中抛出了异常，编译器会自动产生一个对 std::terminate 的调用，终止程序运行。这个是运行期行为。编译时编译器不会对你调用非 noexcept 的函数有任何指示。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623479435,"ip_address":"","comment_id":297202,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师又打扰一下，原文中“特殊成员（构造函数、析构函数、赋值函数等）会自动成为 noexcept，如果它们调用的代码都是 noexcept 的话。”那么返过来呢？例如赋值函数标noexcept，而赋值函数中调用的swap函数没有noexcept，那么最终会是什么效果？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521759,"discussion_content":"我这儿写得不太好，应该说自动生成的特殊成员函数会是 noexcept……\n\n如果一个标成 noexcept 的函数中抛出了异常，编译器会自动产生一个对 std::terminate 的调用，终止程序运行。这个是运行期行为。编译时编译器不会对你调用非 noexcept 的函数有任何指示。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623479435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224908,"user_name":"Geek_68d3d2","can_delete":false,"product_type":"c1","uid":1674369,"ip_address":"","ucode":"EBD6D881AA7A74","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqf54z1ZmqQY1kmJ6t1HAnrqMM3j6WKf0oDeVLhtnA2ZUKY6AX9MK6RjvcO8SiczXy3uU0IzBQ3tpw/132","comment_is_top":false,"comment_ctime":1591589195,"is_pvip":false,"replies":[{"id":82791,"content":"对。\n\n错误码的主要好处是代码直白（但啰嗦），开销低。异常代码更优雅，但需要更多的训练。另外，如果没有捕获异常的话，异常在GCC和Clang上都可以产生较友好的运行时错误，方便调试。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591617618,"ip_address":"","comment_id":224908,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"总结：程序在编写过程中总会有不正常的情况，处理不正常的情况要么使用错误码各种if&#47;else 还要预防在构造函数里出现不正常现象，要么使用异常，在异常出现后进行try catch最终保证程序无内存泄漏且功能一致。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497652,"discussion_content":"对。\n\n错误码的主要好处是代码直白（但啰嗦），开销低。异常代码更优雅，但需要更多的训练。另外，如果没有捕获异常的话，异常在GCC和Clang上都可以产生较友好的运行时错误，方便调试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591617618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2361409,"avatar":"https://static001.geekbang.org/account/avatar/00/24/08/41/63d4d7f3.jpg","nickname":"WonBean","note":"","ucode":"94C5E87F4F77D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353293,"discussion_content":"想问下老师，这里指的没有捕获异常，指的是不写try-catch还是写了但是正常路径不抛异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615119922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2361409,"avatar":"https://static001.geekbang.org/account/avatar/00/24/08/41/63d4d7f3.jpg","nickname":"WonBean","note":"","ucode":"94C5E87F4F77D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378874,"discussion_content":"这儿评论我是看不到提醒的……\n\n是指没有 catch 语句能捕获到这个异常，导致程序异常终止，并在终端上输出一些信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623480198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":353293,"ip_address":"","group_id":0},"score":378874,"extra":""}]}]},{"had_liked":false,"id":182243,"user_name":"JDY","can_delete":false,"product_type":"c1","uid":1848474,"ip_address":"","ucode":"4B6F55332BE6DC","user_header":"https://static001.geekbang.org/account/avatar/00/1c/34/9a/1587bc6f.jpg","comment_is_top":false,"comment_ctime":1582732475,"is_pvip":false,"replies":[{"id":70594,"content":"没看懂你的问题。文中的 matrix_alloc 是初始化的代码，传的就是 matrix 的指针。在 matrix 初始化之前，data 成员的内容是未知的垃圾数据。所以初始化时，直接覆写 matrix 的所有成员。C 的处理方式就是这么原始的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582777202,"ip_address":"","comment_id":182243,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师您好，我请教一个很基础的题外问题，在这个初始化函数中，我们为什么不传递一个matrix ptr，然后用ptr.data 呢？很小的问题，希望您能回答一下，谢谢了~\nint matrix_alloc(matrix* ptr, size_t nrows, size_t ncols){\n    .....\n   ptr -&gt; data = data;\n}","like_count":0},{"had_liked":false,"id":174018,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1579881973,"is_pvip":false,"replies":[{"id":67680,"content":"如果你要给非C++的本地客户调用，可能得把异常换成错误码。如果是本地C++调用者，或者是可以处理异常的远程客户，使用异常比使用错误码，调用者的代码更简单。\n\n当然，对于远程调用者，实际上就不能随便抛C++的异常了，必须是事先定义好的明确异常。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579933583,"ip_address":"","comment_id":174018,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"“异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常。”\n老师，一般来说是不是都采用错误码+异常的方式来处理这种问题。接口内部抛出异常并处理异常，对外返回错误码，调用接口的人就不用考虑接口内部抛出的异常？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485265,"discussion_content":"没看懂你的问题。文中的 matrix_alloc 是初始化的代码，传的就是 matrix 的指针。在 matrix 初始化之前，data 成员的内容是未知的垃圾数据。所以初始化时，直接覆写 matrix 的所有成员。C 的处理方式就是这么原始的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582777202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174009,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1579869565,"is_pvip":false,"replies":[{"id":67679,"content":"应该是，这样也和C数组的[]完全一致，以免有人说，从数组换成vector，性能就下降了……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579933341,"ip_address":"","comment_id":174009,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，为什么vector让operator[]是noexcept，是为了性能么？然后at用来调试？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482274,"discussion_content":"如果你要给非C++的本地客户调用，可能得把异常换成错误码。如果是本地C++调用者，或者是可以处理异常的远程客户，使用异常比使用错误码，调用者的代码更简单。\n\n当然，对于远程调用者，实际上就不能随便抛C++的异常了，必须是事先定义好的明确异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579933583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173677,"user_name":"Terry","can_delete":false,"product_type":"c1","uid":1757835,"ip_address":"","ucode":"2EB5CE909CD3CE","user_header":"","comment_is_top":false,"comment_ctime":1579658270,"is_pvip":false,"replies":[{"id":67335,"content":"当然会。\n\n不过，实现上有一个复杂性。在有虚拟内存的操作系统环境里，你通常不会在分配内存时得到异常（除非你要内存是理论上都不可能满足的）。然后，在你实际使用这些内存时，操作系统才会真正分配物理内存。如果你申请的内存太多了，通常会发生的事情并不是你会得到 bad_alloc 异常，而是你的程序莫名其妙地被系统杀死，或者只是系统慢得像蚂蚁爬，你自己都忍受不下去……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579683149,"ip_address":"","comment_id":173677,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"如果new失败，抛出异常不处理，程序不会crash吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482272,"discussion_content":"应该是，这样也和C数组的[]完全一致，以免有人说，从数组换成vector，性能就下降了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579933341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170977,"user_name":"执假以为真","can_delete":false,"product_type":"c1","uid":1145738,"ip_address":"","ucode":"A02D82C5CCDA07","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/8a/c411a123.jpg","comment_is_top":false,"comment_ctime":1578808246,"is_pvip":false,"replies":[{"id":66403,"content":"实际上有个评论里我已经回答了。再列一下：\n\n- Boost\n- C++ REST SDK\n- pytorch\n- pybind11\n- Armadillo\n- nlohmann&#47;json\n- cppcheck\n- OpenCV\n- LibreOffice","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578896258,"ip_address":"","comment_id":170977,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"个人所见的年销售额数亿美元产品的工业级代码里确实没见到异常，也许如文中所述的原因及历史原因吧。但有什么知名产品的C++代码或著名开源项目是使用了异常的吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482163,"discussion_content":"当然会。\n\n不过，实现上有一个复杂性。在有虚拟内存的操作系统环境里，你通常不会在分配内存时得到异常（除非你要内存是理论上都不可能满足的）。然后，在你实际使用这些内存时，操作系统才会真正分配物理内存。如果你申请的内存太多了，通常会发生的事情并不是你会得到 bad_alloc 异常，而是你的程序莫名其妙地被系统杀死，或者只是系统慢得像蚂蚁爬，你自己都忍受不下去……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579683149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211962,"discussion_content":"追问一下在老师这里提到的情况下，使用异常岂不是变得没有意义了？那是不是说error code的方式还是可以接受的？google感觉很喜欢error code连golang也都是这么设计的，而golang设计的时候肯定没有legacy code这些tech debt吧，是不是还有其它的考虑？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584916281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162822,"user_name":"不谈","can_delete":false,"product_type":"c1","uid":1156936,"ip_address":"","ucode":"2E18977EAC5E5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItaas8rpvXb70zfjMetkEuYeLH0rI348MCaKqyn9HAbGZsdCKibLTnfGEBMbwQLBOhPMROcVBk9vA/132","comment_is_top":false,"comment_ctime":1576595639,"is_pvip":false,"replies":[{"id":61884,"content":"这种行为是和值语义密切关联的——和 Java 不同。而且，要在构造函数和运算符重载中表达错误，异常是唯一的方法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576625717,"ip_address":"","comment_id":162822,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"作为java程序员刚开始对于C++这种规则完全不能理解，看了文章之后又理解了，不使用异常是有道理的。现在理解了vector 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数这句话的含义了。C++就是这么与众不同","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478156,"discussion_content":"这种行为是和值语义密切关联的——和 Java 不同。而且，要在构造函数和运算符重载中表达错误，异常是唯一的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576625717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161536,"user_name":"稻草人的忧桑","can_delete":false,"product_type":"c1","uid":1125998,"ip_address":"","ucode":"00A65AB42DE44B","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/6e/05230eb6.jpg","comment_is_top":false,"comment_ctime":1576225068,"is_pvip":false,"replies":[{"id":61543,"content":"对不起，我对 libbreakpad 完全不了解。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576237114,"ip_address":"","comment_id":161536,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"请问libbreakpad跟underflow_error有关联么？现在使用breakpad捕获异常，有很多underflow_error的信息","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478156,"discussion_content":"这种行为是和值语义密切关联的——和 Java 不同。而且，要在构造函数和运算符重载中表达错误，异常是唯一的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576625717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161010,"user_name":"稻草人的忧桑","can_delete":false,"product_type":"c1","uid":1125998,"ip_address":"","ucode":"00A65AB42DE44B","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/6e/05230eb6.jpg","comment_is_top":false,"comment_ctime":1576078358,"is_pvip":false,"replies":[{"id":61381,"content":"https:&#47;&#47;zh.cppreference.com&#47;w&#47;cpp&#47;error&#47;underflow_error\n\n定义作为异常抛出的类型。它可用于报告算术下溢错误（即计算结果是非正规浮点值的情形）。\n标准库组建不抛此异常（数学函数按指定于 math_errhandling 的方式报告下溢错误）。然而第三方库使用它。例如，若启用了 boost::math::policies::throw_on_error （默认设置），则 boost.math 抛出 std::underflow_error 。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576107217,"ip_address":"","comment_id":161010,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"请问underflow_error 什么情况下会抛出？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477753,"discussion_content":"对不起，我对 libbreakpad 完全不了解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576237114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160660,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1575997887,"is_pvip":false,"replies":[{"id":61306,"content":"因为返回值得留给错误码啊……既然不能用异常。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576022991,"ip_address":"","comment_id":160660,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"C++ 虽然支持运算符重载，可你也不能使用，因为你没法返回一个新矩阵……\n不太理解这句话的意思，是用运算符来替换构造函数吗，运算符为啥不能返回新矩阵？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477569,"discussion_content":"https://zh.cppreference.com/w/cpp/error/underflow_error\n\n定义作为异常抛出的类型。它可用于报告算术下溢错误（即计算结果是非正规浮点值的情形）。\n标准库组建不抛此异常（数学函数按指定于 math_errhandling 的方式报告下溢错误）。然而第三方库使用它。例如，若启用了 boost::math::policies::throw_on_error （默认设置），则 boost.math 抛出 std::underflow_error 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576107217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160633,"user_name":"neilyu","can_delete":false,"product_type":"c1","uid":1020068,"ip_address":"","ucode":"B9D56B3E526022","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/r0fibSY02VITyVkSxD0nOLSSf1kK3MAYHRJQgobibN2CShXOJMzwQuP7qXLH7cbrDibzw3C5fBFiaIRZwdACHTaxgg/132","comment_is_top":false,"comment_ctime":1575990018,"is_pvip":false,"replies":[{"id":61305,"content":"因为返回值留给错误码了啊……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576022944,"ip_address":"","comment_id":160633,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"C++ 虽然支持运算符重载，可你也不能使用，因为你没法返回一个新矩阵……\n&#47;&#47;请问这句话怎么理解？为啥不能返回一个新矩阵呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477450,"discussion_content":"因为返回值得留给错误码啊……既然不能用异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576022991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182243,"user_name":"JDY","can_delete":false,"product_type":"c1","uid":1848474,"ip_address":"","ucode":"4B6F55332BE6DC","user_header":"https://static001.geekbang.org/account/avatar/00/1c/34/9a/1587bc6f.jpg","comment_is_top":false,"comment_ctime":1582732475,"is_pvip":false,"replies":[{"id":70594,"content":"没看懂你的问题。文中的 matrix_alloc 是初始化的代码，传的就是 matrix 的指针。在 matrix 初始化之前，data 成员的内容是未知的垃圾数据。所以初始化时，直接覆写 matrix 的所有成员。C 的处理方式就是这么原始的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582777202,"ip_address":"","comment_id":182243,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师您好，我请教一个很基础的题外问题，在这个初始化函数中，我们为什么不传递一个matrix ptr，然后用ptr.data 呢？很小的问题，希望您能回答一下，谢谢了~\nint matrix_alloc(matrix* ptr, size_t nrows, size_t ncols){\n    .....\n   ptr -&gt; data = data;\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485265,"discussion_content":"没看懂你的问题。文中的 matrix_alloc 是初始化的代码，传的就是 matrix 的指针。在 matrix 初始化之前，data 成员的内容是未知的垃圾数据。所以初始化时，直接覆写 matrix 的所有成员。C 的处理方式就是这么原始的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582777202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174018,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1579881973,"is_pvip":false,"replies":[{"id":67680,"content":"如果你要给非C++的本地客户调用，可能得把异常换成错误码。如果是本地C++调用者，或者是可以处理异常的远程客户，使用异常比使用错误码，调用者的代码更简单。\n\n当然，对于远程调用者，实际上就不能随便抛C++的异常了，必须是事先定义好的明确异常。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579933583,"ip_address":"","comment_id":174018,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"“异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常。”\n老师，一般来说是不是都采用错误码+异常的方式来处理这种问题。接口内部抛出异常并处理异常，对外返回错误码，调用接口的人就不用考虑接口内部抛出的异常？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482274,"discussion_content":"如果你要给非C++的本地客户调用，可能得把异常换成错误码。如果是本地C++调用者，或者是可以处理异常的远程客户，使用异常比使用错误码，调用者的代码更简单。\n\n当然，对于远程调用者，实际上就不能随便抛C++的异常了，必须是事先定义好的明确异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579933583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174009,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1579869565,"is_pvip":false,"replies":[{"id":67679,"content":"应该是，这样也和C数组的[]完全一致，以免有人说，从数组换成vector，性能就下降了……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579933341,"ip_address":"","comment_id":174009,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，为什么vector让operator[]是noexcept，是为了性能么？然后at用来调试？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482272,"discussion_content":"应该是，这样也和C数组的[]完全一致，以免有人说，从数组换成vector，性能就下降了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579933341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173677,"user_name":"Terry","can_delete":false,"product_type":"c1","uid":1757835,"ip_address":"","ucode":"2EB5CE909CD3CE","user_header":"","comment_is_top":false,"comment_ctime":1579658270,"is_pvip":false,"replies":[{"id":67335,"content":"当然会。\n\n不过，实现上有一个复杂性。在有虚拟内存的操作系统环境里，你通常不会在分配内存时得到异常（除非你要内存是理论上都不可能满足的）。然后，在你实际使用这些内存时，操作系统才会真正分配物理内存。如果你申请的内存太多了，通常会发生的事情并不是你会得到 bad_alloc 异常，而是你的程序莫名其妙地被系统杀死，或者只是系统慢得像蚂蚁爬，你自己都忍受不下去……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579683149,"ip_address":"","comment_id":173677,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"如果new失败，抛出异常不处理，程序不会crash吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482163,"discussion_content":"当然会。\n\n不过，实现上有一个复杂性。在有虚拟内存的操作系统环境里，你通常不会在分配内存时得到异常（除非你要内存是理论上都不可能满足的）。然后，在你实际使用这些内存时，操作系统才会真正分配物理内存。如果你申请的内存太多了，通常会发生的事情并不是你会得到 bad_alloc 异常，而是你的程序莫名其妙地被系统杀死，或者只是系统慢得像蚂蚁爬，你自己都忍受不下去……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579683149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211962,"discussion_content":"追问一下在老师这里提到的情况下，使用异常岂不是变得没有意义了？那是不是说error code的方式还是可以接受的？google感觉很喜欢error code连golang也都是这么设计的，而golang设计的时候肯定没有legacy code这些tech debt吧，是不是还有其它的考虑？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584916281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170977,"user_name":"执假以为真","can_delete":false,"product_type":"c1","uid":1145738,"ip_address":"","ucode":"A02D82C5CCDA07","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/8a/c411a123.jpg","comment_is_top":false,"comment_ctime":1578808246,"is_pvip":false,"replies":[{"id":66403,"content":"实际上有个评论里我已经回答了。再列一下：\n\n- Boost\n- C++ REST SDK\n- pytorch\n- pybind11\n- Armadillo\n- nlohmann&#47;json\n- cppcheck\n- OpenCV\n- LibreOffice","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578896258,"ip_address":"","comment_id":170977,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"个人所见的年销售额数亿美元产品的工业级代码里确实没见到异常，也许如文中所述的原因及历史原因吧。但有什么知名产品的C++代码或著名开源项目是使用了异常的吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481193,"discussion_content":"实际上有个评论里我已经回答了。再列一下：\n\n- Boost\n- C++ REST SDK\n- pytorch\n- pybind11\n- Armadillo\n- nlohmann/json\n- cppcheck\n- OpenCV\n- LibreOffice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578896258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162822,"user_name":"不谈","can_delete":false,"product_type":"c1","uid":1156936,"ip_address":"","ucode":"2E18977EAC5E5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItaas8rpvXb70zfjMetkEuYeLH0rI348MCaKqyn9HAbGZsdCKibLTnfGEBMbwQLBOhPMROcVBk9vA/132","comment_is_top":false,"comment_ctime":1576595639,"is_pvip":false,"replies":[{"id":61884,"content":"这种行为是和值语义密切关联的——和 Java 不同。而且，要在构造函数和运算符重载中表达错误，异常是唯一的方法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576625717,"ip_address":"","comment_id":162822,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"作为java程序员刚开始对于C++这种规则完全不能理解，看了文章之后又理解了，不使用异常是有道理的。现在理解了vector 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数这句话的含义了。C++就是这么与众不同","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481193,"discussion_content":"实际上有个评论里我已经回答了。再列一下：\n\n- Boost\n- C++ REST SDK\n- pytorch\n- pybind11\n- Armadillo\n- nlohmann/json\n- cppcheck\n- OpenCV\n- LibreOffice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578896258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161536,"user_name":"稻草人的忧桑","can_delete":false,"product_type":"c1","uid":1125998,"ip_address":"","ucode":"00A65AB42DE44B","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/6e/05230eb6.jpg","comment_is_top":false,"comment_ctime":1576225068,"is_pvip":false,"replies":[{"id":61543,"content":"对不起，我对 libbreakpad 完全不了解。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576237114,"ip_address":"","comment_id":161536,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"请问libbreakpad跟underflow_error有关联么？现在使用breakpad捕获异常，有很多underflow_error的信息","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477753,"discussion_content":"对不起，我对 libbreakpad 完全不了解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576237114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161010,"user_name":"稻草人的忧桑","can_delete":false,"product_type":"c1","uid":1125998,"ip_address":"","ucode":"00A65AB42DE44B","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/6e/05230eb6.jpg","comment_is_top":false,"comment_ctime":1576078358,"is_pvip":false,"replies":[{"id":61381,"content":"https:&#47;&#47;zh.cppreference.com&#47;w&#47;cpp&#47;error&#47;underflow_error\n\n定义作为异常抛出的类型。它可用于报告算术下溢错误（即计算结果是非正规浮点值的情形）。\n标准库组建不抛此异常（数学函数按指定于 math_errhandling 的方式报告下溢错误）。然而第三方库使用它。例如，若启用了 boost::math::policies::throw_on_error （默认设置），则 boost.math 抛出 std::underflow_error 。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576107217,"ip_address":"","comment_id":161010,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"请问underflow_error 什么情况下会抛出？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477569,"discussion_content":"https://zh.cppreference.com/w/cpp/error/underflow_error\n\n定义作为异常抛出的类型。它可用于报告算术下溢错误（即计算结果是非正规浮点值的情形）。\n标准库组建不抛此异常（数学函数按指定于 math_errhandling 的方式报告下溢错误）。然而第三方库使用它。例如，若启用了 boost::math::policies::throw_on_error （默认设置），则 boost.math 抛出 std::underflow_error 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576107217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160660,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1575997887,"is_pvip":false,"replies":[{"id":61306,"content":"因为返回值得留给错误码啊……既然不能用异常。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576022991,"ip_address":"","comment_id":160660,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"C++ 虽然支持运算符重载，可你也不能使用，因为你没法返回一个新矩阵……\n不太理解这句话的意思，是用运算符来替换构造函数吗，运算符为啥不能返回新矩阵？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477450,"discussion_content":"因为返回值得留给错误码啊……既然不能用异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576022991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160633,"user_name":"neilyu","can_delete":false,"product_type":"c1","uid":1020068,"ip_address":"","ucode":"B9D56B3E526022","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/r0fibSY02VITyVkSxD0nOLSSf1kK3MAYHRJQgobibN2CShXOJMzwQuP7qXLH7cbrDibzw3C5fBFiaIRZwdACHTaxgg/132","comment_is_top":false,"comment_ctime":1575990018,"is_pvip":false,"replies":[{"id":61305,"content":"因为返回值留给错误码了啊……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576022944,"ip_address":"","comment_id":160633,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"C++ 虽然支持运算符重载，可你也不能使用，因为你没法返回一个新矩阵……\n&#47;&#47;请问这句话怎么理解？为啥不能返回一个新矩阵呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477440,"discussion_content":"因为返回值留给错误码了啊……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576022944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159952,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575851037,"is_pvip":false,"replies":[{"id":61066,"content":"外围（比如main里）当然是要写catch的。（我们一般也不会主动去调terminate；退出的话一般用exit。）但异常安全的代码本身可以没有任何try和catch。\n\n学得真快。☺️","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575855628,"ip_address":"","comment_id":159952,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"“异常处理并不意味着需要写显式的 try 和 catch。异常安全的代码，可以没有任何 try 和 catch。”\n\n出现异常时，如果没有任何的try catch,只是让std::terminate, 即使没有资源泄漏之类的，感觉什么也做不了了，感觉还是应该要catch,做点啥，至少得记录一下哪抛出异常，什么异常，然后再主动的std::terminate。","like_count":0},{"had_liked":false,"id":159945,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575850265,"is_pvip":false,"replies":[{"id":61063,"content":"不是，就是happy path。愉快的（乐观情况下的）执行路径，而不是说是否频繁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575855122,"ip_address":"","comment_id":159945,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"happy path—-&gt; hot path:)","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477216,"discussion_content":"外围（比如main里）当然是要写catch的。（我们一般也不会主动去调terminate；退出的话一般用exit。）但异常安全的代码本身可以没有任何try和catch。\n\n学得真快。☺️","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575855628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76811,"discussion_content":"地铁漫漫，希望更新的频繁些😊\n\n谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575855778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394194,"user_name":"Geek_2824a2","can_delete":false,"product_type":"c1","uid":2321211,"ip_address":"广东","ucode":"F007964A735C0F","user_header":"","comment_is_top":false,"comment_ctime":1726107779,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"之前写go的时候也是比较反感把错误处理和业务逻辑耦合到一起。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477213,"discussion_content":"不是，就是happy path。愉快的（乐观情况下的）执行路径，而不是说是否频繁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575855122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159952,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575851037,"is_pvip":false,"replies":[{"id":61066,"content":"外围（比如main里）当然是要写catch的。（我们一般也不会主动去调terminate；退出的话一般用exit。）但异常安全的代码本身可以没有任何try和catch。\n\n学得真快。☺️","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575855628,"ip_address":"","comment_id":159952,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"“异常处理并不意味着需要写显式的 try 和 catch。异常安全的代码，可以没有任何 try 和 catch。”\n\n出现异常时，如果没有任何的try catch,只是让std::terminate, 即使没有资源泄漏之类的，感觉什么也做不了了，感觉还是应该要catch,做点啥，至少得记录一下哪抛出异常，什么异常，然后再主动的std::terminate。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477216,"discussion_content":"外围（比如main里）当然是要写catch的。（我们一般也不会主动去调terminate；退出的话一般用exit。）但异常安全的代码本身可以没有任何try和catch。\n\n学得真快。☺️","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575855628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76811,"discussion_content":"地铁漫漫，希望更新的频繁些😊\n\n谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575855778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159945,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575850265,"is_pvip":false,"replies":[{"id":61063,"content":"不是，就是happy path。愉快的（乐观情况下的）执行路径，而不是说是否频繁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575855122,"ip_address":"","comment_id":159945,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"happy path—-&gt; hot path:)","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477213,"discussion_content":"不是，就是happy path。愉快的（乐观情况下的）执行路径，而不是说是否频繁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575855122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394194,"user_name":"Geek_2824a2","can_delete":false,"product_type":"c1","uid":2321211,"ip_address":"广东","ucode":"F007964A735C0F","user_header":"","comment_is_top":false,"comment_ctime":1726107779,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"之前写go的时候也是比较反感把错误处理和业务逻辑耦合到一起。","like_count":0}]}