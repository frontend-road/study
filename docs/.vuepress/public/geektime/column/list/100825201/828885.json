{"id":828885,"title":"24｜端侧模型下的JavaScript的性能局限如何解决？","content":"<p>你好，我是柳博文，欢迎和我一起学习前端工程师的AI实战课。</p><p>前面的课程里，我们在端侧使用JavaScript尝试过不少模型预测任务，即便这些任务计算量都比较小，我们仍然能切身体会到JavaScript执行矩阵运算等任务时的局限。</p><p>讲到JavaScript的性能，肯定离不开V8引擎。对于JavaScript这门极度依赖宿主环境的脚本语言，我相信包括我在内的所有前端工程师追求的极致目标，就是高性能地执行JavaScript。</p><p>那么，今天，我们就来讨论一下端侧模型下的JavaScript的性能局限到底在哪里，以及有哪些方法可以改善其端侧模型下的性能。</p><h2>端侧模型下JavaScript的局限</h2><p>想要提升性能，我想我们需要首先弄清楚两个问题，一是了解矩阵运算对硬件的要求，二是V8执行JavaScript的方式。</p><p>首先是矩阵运算对硬件的要求，关于矩阵运算的原理以及在AI模型训练过程中的作用，在第二章中的原理部分（<a href=\"https://time.geekbang.org/column/article/815865\">第四节课</a>、<a href=\"https://time.geekbang.org/column/article/818151\">第八节课</a>）已经描述清楚，有需要请进行回顾。</p><p>这里我们重点聊一下为什么我们需要使用GPU为第一选择来训练模型，而CPU只是备选。这就需要我们对比一下GPU和CPU的架构设计和运行方式。</p><h3>CPU和GPU对比</h3><!-- [[[read_end]]] --><p>CPU（中央处理器）的设计是为了处理复杂的、串行的任务，它通常拥有较少的核心（通常2到16个核心）。每个核心非常强大，能够快速处理单一的指令流。因此CPU非常适合处理多样化、复杂的任务，比如操作系统的控制和运行应用程序。</p><p>而GPU（图形处理器）最初是为图像渲染而设计，它的架构适合处理大规模的并行计算。GPU拥有成百上千个核心，这些核心可以同时执行大量简单的计算任务，因此在进行大量的数学运算（如矩阵运算）时表现出色。AI训练中的神经网络主要涉及矩阵乘法和加法，这正是GPU的强项。下图分别为GPU（左）和CPU（右）的微架构示意图，可以直观地看出两者架构设计的不同。</p><p><img src=\"https://static001.geekbang.org/resource/image/90/yy/90b8949df8875a635a97cdaab006feyy.jpg?wh=2680x963\" alt=\"\"></p><p>通过以上对比可以看出，CPU虽然能够处理这些任务，但因为它的核心数量较少（通常2-16个核心），因此处理这些任务时速度较慢。GPU则能够通过并行计算，大规模地同时处理成千上万个计算单元的任务，因此在处理矩阵和向量运算时效率更高。</p><p>总之，GPU（图形处理器）比CPU（中央处理器）更适合AI模型的训练，主要是因为它们的架构和运行方式在处理大规模并行计算任务时表现得更好。AI训练涉及大量的矩阵运算、向量操作，而这些任务都需要极大的计算能力。</p><p>讲到这里，我们找到了提升性能的第一个可能性，<strong>设法找到端侧调用GPU的方法，来进行模型推理相关的运算</strong>。</p><h3>JavaScript在浏览器以及V8中的执行</h3><p>为了更好地从原理层面寻找提升JavaScript执行的性能的方法，我们来看看浏览器和V8在执行JavaScript的时候都使用CPU和GPU做了哪些工作。</p><p>浏览器的V8在执行JavaScript时，使用了CPU来进行计算，只有在最后完成位图的生成时才调用了GPU进行图像生成。也就是在这个阶段，浏览器内部才调用了硬件上的GPU来实现加速。</p><p>下面是浏览器完成一次完整页面渲染的流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/c5/0d4e8b193e37b149b4d7b1a8de8d63c5.jpg?wh=4021x1405\" alt=\"\"></p><p>在这个过程中，主线程会使用CPU单线程的方式来执行JavaScript，完成页面的拼装和渲染，并通过其他功能的线程的协同合作最终将页面绘制出来。这些都需要花费大量的能耗和时间。</p><p>其次是V8执行JavaScript的方式。我们知道JavaScript的每次执行都是通过在主线程上执行并维护多个异步任务队列来实现的。页面的首屏渲染以及页面更新都需要进行JavaScript的计算，尤其是现代前端的框架和库都是基于CSR的渲染方式。压力几乎都给到了JavaScript，也同样给到了前端工程师。</p><p>由此我们就找到了第二个潜在优化点——<strong>看看能否改变这种单线程执行方式，把一部分计算密集型任务分出去。</strong></p><p>接下来我们再看看V8在每次执行JavaScript所需要的步骤：</p><p><img src=\"https://static001.geekbang.org/resource/image/25/98/25d8c6e082406e166dba5cfe1c0b8f98.jpg?wh=3504x1680\" alt=\"\"></p><p>如果我们能够简化这个流程，让V8直接拿到字节码，同样可以提升JS性能。这就是JS性能提升的第三个思路，至于具体方案我们稍后揭晓。</p><h2>加速端侧推理性能</h2><p>现在我们对优化方向更清晰了，分别是后面这三个方向：</p><ul>\n<li>在应用层引入更擅长处理模型推理任务的GPU帮忙。</li>\n<li>浏览器的V8里执行JavaScript都要通过主线程，设法分担主线程压力。</li>\n<li>设法化简V8执行JavaScript的步骤，比如直接让V8拿到字节码。</li>\n</ul><p>其实概括来说就是在高效推理和高性能页面之间找到一个平衡。相应的优化方法有不少，下面我们将会看到业界热议的几种方案。</p><h3>Web Worker</h3><p>第一种方案就是引入Web Worker，通过上面的分析我们知道，由于浏览器渲染页面时候执行JavaScript时是跑在主线程上，如果主线程由于执行其他任务（例如：模型推理这样耗时耗力的任务）被占用过久，就会极大影响页面的渲染和用户体验。</p><p>那么，我们就可以将执行模型推理的任务放在其他的线程中执行，当得到结果时候与主线程通信交换数据即可。</p><p>以Chrome为代表的浏览器的架构设计中设定了一个tab页面中能够存在的线程，并且线程都有特定的作用，也不允许开发者修改这些线程的作用。所以在现有架构设计的基础上，没有多余的线程让我们使用。</p><p>不过，现在W3C有了新的一个标准 Web Worker，情况就不同了。</p><p>Web Worker 是 HTML5 引入的一项技术，用于在浏览器中创建后台线程，允许 JavaScript 代码在主线程之外运行。通常，JavaScript 是单线程执行的，Web Worker 提供了一种并行处理的方法，避免长时间任务（如模型推理、复杂计算）阻塞用户界面。</p><p>Web Worker 的来源是为了提升 Web 应用的性能，特别是在需要执行密集计算时，能够保持 UI 的流畅性，同时不打断用户体验。Web Worker 允许在后台线程运行 JavaScript 代码，主线程和 Worker 线程之间通过消息传递进行通信。</p><p>接下来，我们就来看看如何使用webworker来进行推理加速。我们来设定这样一个实例：在浏览器中运行模型推理（如 TensorFlow.js、ONNX.js）利用 Web Worker 进行加速。然后观察这样做是否可以避免模型推理占用主线程时间，阻塞用户交互，同时提升模型推理的性能和效率。</p><p>思路已经有了，下面我们进入动手环节。</p><h4>在主线程中创建 Worker</h4><p>首先，我们使用 new Worker() 创建 Worker，将模型推理任务分配到 Worker 线程中。</p><pre><code class=\"language-xml\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&nbsp; &nbsp; &lt;meta charset=\"UTF-8\"&gt;\n&nbsp; &nbsp; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n&nbsp; &nbsp; &lt;title&gt;MobileNet Inference&lt;/title&gt;\n&nbsp; &nbsp; &lt;!-- 引入 TensorFlow.js 库 --&gt;\n&nbsp; &nbsp; &lt;script src=\"./tf.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&nbsp; &nbsp; &lt;script&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; window.onload = function () {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 确保 TensorFlow.js 库已经加载\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (typeof tf === 'undefined') {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.error('TensorFlow.js library not loaded');\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 创建 Worker\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const modelWorker = new Worker('./modelWorker.js');\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 生成随机输入数据\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const inputTensor = tf.randomNormal([1, 224, 224, 3]);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const inputData = inputTensor.dataSync(); // 转换为扁平数组\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 向 Worker 发送输入数据\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modelWorker.postMessage({ input: inputData });\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 接收模型推理结果\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modelWorker.onmessage = function (event) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log('Model inference result:', event.data);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h4>在 Worker 中加载和推理模型</h4><p>Worker 线程会接收到主线程发送的输入数据，然后执行模型推理。这里我们可以使用 TensorFlow.js 或其他浏览器支持的推理引擎。</p><pre><code class=\"language-javascript\">// modelWorker.js\nimportScripts('./tf.js'); // 引入 TensorFlow.js 库\n\nlet model;\n// 监听主线程消息（接收输入数据）\nself.onmessage = async function (event) {\n&nbsp; const inputData = event.data.input;\n&nbsp; if (!model) {\n&nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; // 加载模型\n&nbsp; &nbsp; &nbsp; model = await tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_0.25_224/model.json');\n&nbsp; &nbsp; &nbsp; console.log('Model loaded successfully');\n&nbsp; &nbsp; } catch (error) {\n&nbsp; &nbsp; &nbsp; console.error('Error loading model:', error);\n&nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp; // 将输入数据重构为正确形状的 Tensor\n&nbsp; const inputTensor = tf.tensor(inputData, [1, 224, 224, 3]); // 指定形状\n&nbsp; const prediction = model.predict(inputTensor);\n&nbsp; // 将结果转为数组并返回主线程\n&nbsp; const result = await prediction.array();\n&nbsp; self.postMessage(result);\n};\n</code></pre><h3>在主线程接收推理结果</h3><p>之后，主线程中 modelWorker.onmessage 事件处理函数会接收到 Worker 线程的消息，即模型推理的结果。</p><pre><code class=\"language-javascript\">modelWorker.onmessage = function(event) {\n  const inferenceResult = event.data;\n  console.log('Received inference result:', inferenceResult);\n\n  // 可以在主线程中更新 UI 或进一步处理结果\n};\n</code></pre><p>可以看到，这样就能将大量复杂的计算移到不阻塞主线程的Web Worker中执行。这种加速推理的方式是基于网页渲染流程和JavaScript执行的机制分析出来的。</p><p>Web Worker 适合在前端中分担 CPU 密集型任务，能显著提升主线程的响应性能。但需要我们权衡通信开销和线程管理的复杂性，对于较短的任务，直接在主线程中处理可能更加高效。</p><h3>WASM</h3><p>第二种可以加速推理的方式是WASM这个标准。</p><p>WebAssembly（WASM）由万维网联盟（W3C）于 2017 年推出。其主要目标是提供一种在网页上运行高性能应用程序的方式。</p><p>因为WASM 是一种二进制指令格式，可以将高级语言（如 C、C++ 和 Rust）编译成浏览器可以直接执行字节码，准确地说是V8可以直接执行的字节码。所以它自然可以作为我们简化V8执行JavaScript的解决方案。</p><p>而且WASM还支持将其他高级语言编写的代码编译成为V8能够执行的字节码，这样就能够省去一半的执行流程，进而减少执行时间。</p><p>那么，如果我们要使用WASM加速端侧模型的推理时，或许可以采用后面的步骤来完成，以C++为例。</p><ol>\n<li>编写 C++ 代码：首先，你需要编写 C++ 代码进行模型推理。</li>\n<li>编译为 WASM：使用 Emscripten 工具链将 C++ 代码编译成 WASM 字节码。</li>\n<li>加载 WASM 模块：在浏览器中使用 JavaScript 加载和运行 WASM 模块。</li>\n</ol><p>为了直观地展示出WASM和纯JavaScript执行效率的区别，这里有一个实现斐波那契数列的性能对比实例。我们一起试试看。</p><p>首先使用 C++ 代码编写一个斐波那契函数如下：</p><pre><code class=\"language-cpp\">#include &lt;emscripten.h&gt;\n\nextern \"C\" {\n&nbsp; &nbsp; EMSCRIPTEN_KEEPALIVE\n&nbsp; &nbsp; int fibonacci(int n) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (n &lt;= 1) return n;\n&nbsp; &nbsp; &nbsp; &nbsp; return fibonacci(n - 1) + fibonacci(n - 2);\n&nbsp; &nbsp; }\n}\n</code></pre><p>然后使用 Emscripten 将上面的 C++ 代码编译成 WASM 字节码，注意 WASM的环境需要安装配置。因为这个环节并不复杂，你可以在网上参考相关资料来完成配置。</p><pre><code class=\"language-powershell\">emcc fibonacci.cpp -O3 -s WASM=1 -s EXPORTED_FUNCTIONS=\"['_fibonacci']\" -s EXTRA_EXPORTED_RUNTIME_METHODS=\"['cwrap']\" -o fibonacci.html\n</code></pre><p>接下来，我们需要编写一个html文件，为了对比WASM与原生JavaScript的执行效率，在这个文件中也要实现一个JavaScript版本的斐波那契函数。然后我们在这个网页里面执行JS和WASM的函数，来对比两者的执行效率。</p><pre><code class=\"language-xml\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh\"&gt;\n&lt;head&gt;\n&nbsp; &nbsp; &lt;meta charset=\"UTF-8\"&gt;\n&nbsp; &nbsp; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n&nbsp; &nbsp; &lt;title&gt;斐波那契性能测试&lt;/title&gt;\n&nbsp; &nbsp; &lt;script src=\"fibonacci.js\"&gt;&lt;/script&gt; &lt;!-- 确保包含正确编译的 JS 文件 --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&nbsp; &nbsp; &lt;h1&gt;斐波那契性能测试：WebAssembly 与 JavaScript&lt;/h1&gt;\n&nbsp; &nbsp; &lt;button onclick=\"runFibonacci()\"&gt;运行斐波那契&lt;/button&gt;\n&nbsp; &nbsp; &lt;div id=\"wasm-output\"&gt;&lt;/div&gt;\n&nbsp; &nbsp; &lt;div id=\"js-output\"&gt;&lt;/div&gt;\n\n&nbsp; &nbsp; &lt;script&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; let wasmFibonacci;\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 加载 WebAssembly 模块\n&nbsp; &nbsp; &nbsp; &nbsp; async function loadWasm() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const module = await new Promise((resolve, reject) =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Module.onRuntimeInitialized = () =&gt; resolve(Module);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 包装 WebAssembly 模块中的 'fibonacci' 函数\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wasmFibonacci = module.cwrap('fibonacci', 'number', ['number']);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; // JavaScript 版本的斐波那契函数\n&nbsp; &nbsp; &nbsp; &nbsp; function fibonacciJS(n) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n &lt;= 1) return n;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return fibonacciJS(n - 1) + fibonacciJS(n - 2);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 运行 WebAssembly 和 JavaScript 版本并测量执行时间\n&nbsp; &nbsp; &nbsp; &nbsp; async function runFibonacci() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const n = 40; &nbsp;// 用于比较性能的大斐波那契数\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 确保 WebAssembly 模块已加载\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!wasmFibonacci) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alert('WebAssembly 模块尚未加载');\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 运行 WebAssembly 斐波那契\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const wasmStart = performance.now();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const wasmResult = wasmFibonacci(n);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const wasmEnd = performance.now();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; document.getElementById('wasm-output').innerText = \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `WebAssembly 结果：${wasmResult}，时间：${wasmEnd - wasmStart} 毫秒`;\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 运行 JavaScript 斐波那契\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const jsStart = performance.now();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const jsResult = fibonacciJS(n);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const jsEnd = performance.now();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; document.getElementById('js-output').innerText = \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `JavaScript 结果：${jsResult}，时间：${jsEnd - jsStart} 毫秒`;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 页面加载时加载 WebAssembly 模块\n&nbsp; &nbsp; &nbsp; &nbsp; loadWasm();\n&nbsp; &nbsp; &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>通过对比我们会发现，在浏览器中直接运行纯 JavaScript 代码性能比较低，尤其是递归深度较大的情况下，这是因为JavaScript 是解释型语言，而通过 WASM 执行编译后的 C++ 代码，WASM 提供了接近原生的执行速度，因此对于计算密集型任务，性能会显著优于 原来的JavaScript代码。</p><h3>GPU.js</h3><p>通过分析代码执行原理，我们找到了Web&nbsp;Worker和WASM这两种可行的解决方式。</p><p>其实更为上层的应用层面，也有许多我们可以参考使用的优化方式和库。</p><p>通过前面的分析我们知道，页面完成渲染后，GPU线程会根据绘图指令生成分块分层位图，最后交给浏览器线程完成页面的渲染和显示上图。也就是说，在浏览器环境下调用GPU是可行的，其中具有代表性的是GPU.js 这个库。</p><p>GPU.js 是一个基于 WebGL 的 JavaScript 库。它经常被用在矩阵运算、机器学习推理、图像处理等任务。</p><p>GPU.js 可以将 JavaScript 代码编译为 WebGL 着色器，并在 GPU 上运行。它允许开发者编写普通的 JavaScript 函数并在 GPU 上执行，而无需深入理解 WebGL 的细节。因此，GPU.js 是在端侧（客户端）进行高效计算加速的便捷方式。</p><p>在模型推理中，尤其是深度学习模型推理，矩阵运算（如矩阵乘法、加法、点积等）是关键。使用 GPU.js 可以加速这些操作就可以帮助我们提升端侧模型推理速度。</p><p>同样，我们再结合一个例子来加深理解 。我们简单实现一个简单的多层感知机 (MLP) 模型，并使用 GPU.js 来加速矩阵运算部分。以下是推理过程中矩阵乘法和激活函数的加速示例：</p><pre><code class=\"language-javascript\">const forwardPass = gpu.createKernel(function(weights, input, bias) {\n&nbsp; &nbsp; let sum = bias[this.thread.y];\n&nbsp; &nbsp; for (let i = 0; i &lt; this.constants.inputSize; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; sum += input[i] * weights[this.thread.y][i];\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return 1 / (1 + Math.exp(-sum)); // 激活函数 Sigmoid\n}).setOutput([128]) // 输出维度，假设我们有 128 个神经元\n&nbsp; .setConstants({ inputSize: 784 }); // 假设输入向量维度为 784（如 MNIST 数据）\n\nconst weights = Array(128).fill().map(() =&gt; Array(784).fill(Math.random()));\nconst input = Array(784).fill(Math.random());\nconst bias = Array(128).fill(0.1);\n\n// 执行前向传播\nconst output = forwardPass(weights, input, bias);\n\nconsole.log(output);\n</code></pre><p>在这个例子中，我们使用 GPU.js 来加速多层神经网络的前向传播。通过这种方式，矩阵乘法和激活函数计算可以快速在 GPU 上并行执行，显著提高模型推理速度。</p><p>同样，为了让你直观感受到GPU和CPU执行矩阵乘法的效率区别，我们分别用两个版本的矩阵乘法函数来进行对比，代码如下。</p><pre><code class=\"language-javascript\">// CPU 执行矩阵乘法\nfunction cpuMultiply(a, b) {\n&nbsp; &nbsp; const size = 512;\n&nbsp; &nbsp; const result = Array(size).fill().map(() =&gt; Array(size).fill(0));\n&nbsp; &nbsp; for (let i = 0; i &lt; size; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; for (let j = 0; j &lt; size; j++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let sum = 0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (let k = 0; k &lt; size; k++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum += a[i][k] * b[k][j];\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[i][j] = sum;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return result;\n}\n\n// GPU 执行矩阵乘法\nfunction gpuMultiply(matrixA, matrixB) {\n&nbsp; &nbsp; const gpu = new GPU.GPU();\n&nbsp; &nbsp; const multiplyKernel = gpu.createKernel(function (a, b) {\n&nbsp; &nbsp; &nbsp; &nbsp; let sum = 0;\n&nbsp; &nbsp; &nbsp; &nbsp; for (let k = 0; k &lt; this.constants.size; k++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum += a[this.thread.y][k] * b[k][this.thread.x];\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return sum;\n&nbsp; &nbsp; })\n&nbsp; &nbsp; &nbsp; &nbsp; .setOutput([512, 512]) // 输出维度\n&nbsp; &nbsp; &nbsp; &nbsp; .setConstants({ size: 512 }); // 矩阵的大小\n\n&nbsp; &nbsp; return multiplyKernel(matrixA, matrixB);\n}\n\nasync function runMatrixMultiplication() {\n&nbsp; &nbsp; const size = 512;\n&nbsp; &nbsp; const matrixA = Array(size).fill().map(() =&gt; Array(size).fill(Math.random()));\n&nbsp; &nbsp; const matrixB = Array(size).fill().map(() =&gt; Array(size).fill(Math.random()));\n\n&nbsp; &nbsp; // 测试 CPU 执行时间\n&nbsp; &nbsp; const cpuStart = performance.now();\n&nbsp; &nbsp; cpuMultiply(matrixA, matrixB);\n&nbsp; &nbsp; const cpuTime = performance.now() - cpuStart;\n\n&nbsp; &nbsp; // 测试 GPU 执行时间\n&nbsp; &nbsp; const gpuStart = performance.now();\n&nbsp; &nbsp; gpuMultiply(matrixA, matrixB);\n&nbsp; &nbsp; const gpuTime = performance.now() - gpuStart;\n\n&nbsp; &nbsp; // 显示总执行时间\n&nbsp; &nbsp; document.getElementById('output').innerHTML = `\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;h2&gt;总执行时间&lt;/h2&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;p&gt;CPU 矩阵乘法时间: ${cpuTime.toFixed(2)} ms&lt;/p&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;p&gt;GPU 矩阵乘法时间: ${gpuTime.toFixed(2)} ms&lt;/p&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `;\n}\n</code></pre><p>通过这种方式比较 CPU 和 GPU 在矩阵运算中的执行时间，我们可以明显感受到GPU加速在端侧推理中的优势。</p><h2>总结</h2><p>我们来做一个总结吧。</p><p>今天这节课，我们讨论了如何突破端侧模型推理中JavaScript的性能局限。依照现在的现状和发展趋势，将模型跑在端侧进行推理是一个必然的趋势。然后基于现在的浏览架构设计和JavaScript和V8的运行机制，在模型推理的任务处理存在明显不足，这主要体现在高性能的模型推理和优秀的页面体验的矛盾上。</p><p>于是我们分析了页面的渲染流程和V8执行JavaScript的机制，分别从渲染流程入手引出了Web Worker标准，来将模型的推理实现并行和脱离主线程。这样做既加速了模型的推理，又不妨碍主线程上的页面的渲染。</p><p>其次，我们从JavaScript的执行机制入手引出了WASM标准。这个标准通过离线编译时将其他高级语言编译成V8能够直接执行的字节码，这样就节约了V8编译JavaScript的时间，既能提升模型推理的速度，又减少了占用主线程执行JavaScript的时间。这个标准同样可以在加速模型推理的前提下，而不会过度影响页面的渲染流程和用户体验。</p><p>最后，我们还在应用层的库上找到了以GPU.js为代表的加速端侧模型推理的方式，GPU.js通过调用WebGL着色器的方式来实现调用GPU，实现模型推理的加速，这也是一个不错的解决方案。</p><h2>课后思考</h2><p>使用WASM进行加速推理的过程中，主要是优化了什么部分？</p><p>欢迎你在留言区记录你的思考或疑问。如果这节课对你有启发，别忘了分享给身边更多朋友。</p>","neighbors":{"left":{"article_title":"23｜视频生成大模型：使用MuseTalk实现商品视频解说","id":828064},"right":{"article_title":"25｜为什么Sora的出现标志着我们离Meta元宇宙更近了一步？","id":829295}},"comments":[]}