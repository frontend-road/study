{"id":8369,"title":"第11讲 | Java提供了哪些IO方式？ NIO如何实现多路复用？","content":"<p>IO一直是软件开发中的核心部分之一，伴随着海量数据增长和分布式系统的发展，IO扩展能力愈发重要。幸运的是，Java平台IO机制经过不断完善，虽然在某些方面仍有不足，但已经在实践中证明了其构建高扩展性应用的能力。</p><p>今天我要问你的问题是，<strong>Java提供了哪些IO方式？ NIO如何实现多路复用？</strong></p><h2>典型回答</h2><p>Java IO方式有很多种，基于不同的IO抽象模型和交互方式，可以进行简单区分。</p><p>第一，传统的java.io包，它基于流模型实现，提供了我们最熟知的一些IO功能，比如File抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><p>java.io包的好处是代码比较简单、直观，缺点则是IO效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p><p>很多时候，人们也把java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库，因为网络通信同样是IO行为。</p><p>第二，在Java  1.4中引入了NIO框架（java.nio包），提供了Channel、Selector、Buffer等新的抽象，可以构建多路复用的、同步非阻塞IO程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p><!-- [[[read_end]]] --><p>第三，在Java 7中，NIO有了进一步的改进，也就是NIO 2，引入了异步非阻塞IO方式，也有很多人叫它AIO（Asynchronous IO）。异步IO操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p><h2>考点分析</h2><p>我上面列出的回答是基于一种常见分类方式，即所谓的BIO、NIO、NIO 2（AIO）。</p><p>在实际面试中，从传统IO到NIO、NIO 2，其中有很多地方可以扩展开来，考察点涉及方方面面，比如：</p><ul>\n<li>\n<p>基础API功能与设计， InputStream/OutputStream和Reader/Writer的关系和区别。</p>\n</li>\n<li>\n<p>NIO、NIO  2的基本组成。</p>\n</li>\n<li>\n<p>给定场景，分别用不同模型实现，分析BIO、NIO等模式的设计和实现原理。</p>\n</li>\n<li>\n<p>NIO提供的高性能数据操作方式是基于什么原理，如何使用？</p>\n</li>\n<li>\n<p>或者，从开发者的角度来看，你觉得NIO自身实现存在哪些问题？有什么改进的想法吗？</p>\n</li>\n</ul><p>IO的内容比较多，专栏一讲很难能够说清楚。IO不仅仅是多路复用，NIO 2也不仅仅是异步IO，尤其是数据操作部分，会在专栏下一讲详细分析。</p><h2>知识扩展</h2><p>首先，需要澄清一些基本概念：</p><ul>\n<li>\n<p>区分同步或异步（synchronous/asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</p>\n</li>\n<li>\n<p>区分阻塞与非阻塞（blocking/non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如ServerSocket新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管IO操作是否结束，直接返回，相应操作在后台继续处理。</p>\n</li>\n</ul><p>不能一概而论认为同步或阻塞就是低效，具体还要看应用和系统特征。</p><p>对于java.io，我们都非常熟悉，我这里就从总体上进行一下总结，如果需要学习更加具体的操作，你可以通过<a href=\"https://docs.oracle.com/javase/tutorial/essential/io/streams.html\">教程</a>等途径完成。总体上，我认为你至少需要理解一下内容。</p><ul>\n<li>\n<p>IO不仅仅是对文件的操作，网络编程中，比如Socket通信，都是典型的IO操作目标。</p>\n</li>\n<li>\n<p>输入流、输出流（InputStream/OutputStream）是用于读取或写入字节的，例如操作图片文件。</p>\n</li>\n<li>\n<p>而Reader/Writer则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader/Writer相当于构建了应用逻辑和原始数据之间的桥梁。</p>\n</li>\n<li>\n<p>BufferedOutputStream等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高IO处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了flush。</p>\n</li>\n<li>\n<p>参考下面这张类图，很多IO工具类都实现了Closeable接口，因为需要进行资源的释放。比如，打开FileInputStream，它就会获取相应的文件描述符（FileDescriptor），需要利用try-with-resources、 try-finally等机制保证FileInputStream被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放。利用专栏前面的内容提到的Cleaner或finalize机制作为资源释放的最后把关，也是必要的。</p>\n</li>\n</ul><p>下面是我整理的一个简化版的类图，阐述了日常开发应用较多的类型和结构关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/43/8b/4338e26731db0df390896ab305506d8b.png?wh=821*626\" alt=\"\"></p><p><strong>1. Java NIO概览</strong></p><p>首先，熟悉一下NIO的主要组成部分：</p><ul>\n<li>\n<p>Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的Buffer实现。</p>\n</li>\n<li>\n<p>Channel，类似在Linux之类操作系统上看到的文件描述符，是NIO中被用来支持批量式IO操作的一种抽象。</p>\n<p>File或者Socket，通常被认为是比较高层次的抽象，而Channel则是更加操作系统底层的一种抽象，这也使得NIO得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过Socket获取Channel，反之亦然。</p>\n</li>\n<li>\n<p>Selector，是NIO实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在Selector上的多个Channel中，是否有Channel处于就绪状态，进而实现了单线程对多Channel的高效管理。Selector同样是基于底层操作系统机制，不同模式、不同版本都存在区别，例如，在最新的代码库里，相关实现如下：</p>\n</li>\n</ul><blockquote>\n<p>Linux上依赖于<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/linux/classes/sun/nio/ch/EPollSelectorImpl.java\">epoll</a>，Windows上NIO2（AIO）模式则是依赖于<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/windows/classes/sun/nio/ch/Iocp.java\">iocp</a>。</p>\n</blockquote><ul>\n<li>Charset，提供Unicode字符串定义，NIO也提供了相应的编解码器等，例如，通过下面的方式进行字符串到ByteBuffer的转换：</li>\n</ul><pre><code>Charset.defaultCharset().encode(&quot;Hello world!&quot;));\n</code></pre><p><strong>2. NIO能解决什么问题？</strong></p><p>下面我通过一个典型场景，来分析为什么需要NIO，为什么需要多路复用。设想，我们需要实现一个服务器应用，只简单要求能够同时服务多个客户端请求即可。</p><p>使用java.io和java.net中的同步、阻塞式API，可以简单实现。</p><pre><code>public class DemoServer extends Thread {\n    private ServerSocket serverSocket;\n    public int getPort() {\n        return  serverSocket.getLocalPort();\n    }\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(0);\n            while (true) {\n                Socket socket = serverSocket.accept();\n                RequestHandler requestHandler = new RequestHandler(socket);\n                requestHandler.start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (serverSocket != null) {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                ;\n            }\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        DemoServer server = new DemoServer();\n        server.start();\n        try (Socket client = new Socket(InetAddress.getLocalHost(), server.getPort())) {\n            BufferedReader bufferedReader = new BufferedReader(new                   InputStreamReader(client.getInputStream()));\n            bufferedReader.lines().forEach(s -&gt; System.out.println(s));\n        }\n    }\n }\n// 简化实现，不做读取，直接发送字符串\nclass RequestHandler extends Thread {\n    private Socket socket;\n    RequestHandler(Socket socket) {\n        this.socket = socket;\n    }\n    @Override\n    public void run() {\n        try (PrintWriter out = new PrintWriter(socket.getOutputStream());) {\n            out.println(&quot;Hello world!&quot;);\n            out.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n }\n\n</code></pre><p>其实现要点是：</p><ul>\n<li>\n<p>服务器端启动ServerSocket，端口0表示自动绑定一个空闲端口。</p>\n</li>\n<li>\n<p>调用accept方法，阻塞等待客户端连接。</p>\n</li>\n<li>\n<p>利用Socket模拟了一个简单的客户端，只进行连接、读取、打印。</p>\n</li>\n<li>\n<p>当连接建立后，启动一个单独线程负责回复客户端请求。</p>\n</li>\n</ul><p>这样，一个简单的Socket服务器就被实现出来了。</p><p>思考一下，这个解决方案在扩展性方面，可能存在什么潜在问题呢？</p><p>大家知道Java语言目前的线程实现是比较重量级的，启动或者销毁一个线程是有明显开销的，每个线程都有单独的线程栈等结构，需要占用非常明显的内存，所以，每一个Client启动一个线程似乎都有些浪费。</p><p>那么，稍微修正一下这个问题，我们引入线程池机制来避免浪费。</p><pre><code>serverSocket = new ServerSocket(0);\nexecutor = Executors.newFixedThreadPool(8);\n while (true) {\n    Socket socket = serverSocket.accept();\n    RequestHandler requestHandler = new RequestHandler(socket);\n    executor.execute(requestHandler);\n}\n\n</code></pre><p>这样做似乎好了很多，通过一个固定大小的线程池，来负责管理工作线程，避免频繁创建、销毁线程的开销，这是我们构建并发服务的典型方式。这种工作方式，可以参考下图来理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/da/29/da7e1ecfd3c3ee0263b8892342dbc629.png?wh=854*529\" alt=\"\"></p><p>如果连接数并不是非常多，只有最多几百个连接的普通应用，这种模式往往可以工作的很好。但是，如果连接数量急剧上升，这种实现方式就无法很好地工作了，因为线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势。</p><p>NIO引入的多路复用机制，提供了另外一种思路，请参考我下面提供的新的版本。</p><pre><code>public class NIOServer extends Thread {\n    public void run() {\n        try (Selector selector = Selector.open();\n             ServerSocketChannel serverSocket = ServerSocketChannel.open();) {// 创建Selector和Channel\n            serverSocket.bind(new InetSocketAddress(InetAddress.getLocalHost(), 8888));\n            serverSocket.configureBlocking(false);\n            // 注册到Selector，并说明关注点\n            serverSocket.register(selector, SelectionKey.OP_ACCEPT);\n            while (true) {\n                selector.select();// 阻塞等待就绪的Channel，这是关键点之一\n                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();\n                Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                   // 生产系统中一般会额外进行就绪状态检查\n                    sayHelloWorld((ServerSocketChannel) key.channel());\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    private void sayHelloWorld(ServerSocketChannel server) throws IOException {\n        try (SocketChannel client = server.accept();) {          client.write(Charset.defaultCharset().encode(&quot;Hello world!&quot;));\n        }\n    }\n   // 省略了与前面类似的main\n}\n</code></pre><p>这个非常精简的样例掀开了NIO多路复用的面纱，我们可以分析下主要步骤和元素：</p><ul>\n<li>\n<p>首先，通过Selector.open()创建一个Selector，作为类似调度员的角色。</p>\n</li>\n<li>\n<p>然后，创建一个ServerSocketChannel，并且向Selector注册，通过指定SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。</p>\n<p><strong>注意</strong>，为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出IllegalBlockingModeException异常。</p>\n</li>\n<li>\n<p>Selector阻塞在select操作，当有Channel发生接入请求，就会被唤醒。</p>\n</li>\n<li>\n<p>在sayHelloWorld方法中，通过SocketChannel和Buffer进行数据操作，在本例中是发送了一段字符串。</p>\n</li>\n</ul><p>可以看到，在前面两个样例中，IO都是同步阻塞模式，所以需要多线程以实现多任务处理。而NIO则是利用了单线程轮询事件的机制，通过高效地定位就绪的Channel，来决定做什么，仅仅select阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。下面这张图对这种实现思路进行了形象地说明。</p><p><img src=\"https://static001.geekbang.org/resource/image/ad/a2/ad3b4a49f4c1bff67124563abc50a0a2.png?wh=983*451\" alt=\"\"></p><p>在Java 7引入的NIO 2中，又增添了一种额外的异步IO模式，利用事件和回调，处理Accept、Read等操作。 AIO实现看起来是类似这样子：</p><pre><code>AsynchronousServerSocketChannel serverSock =        AsynchronousServerSocketChannel.open().bind(sockAddr);\nserverSock.accept(serverSock, new CompletionHandler&lt;&gt;() { //为异步操作指定CompletionHandler回调函数\n    @Override\n    public void completed(AsynchronousSocketChannel sockChannel, AsynchronousServerSocketChannel serverSock) {\n        serverSock.accept(serverSock, this);\n        // 另外一个 write（sock，CompletionHandler{}）\n        sayHelloWorld(sockChannel, Charset.defaultCharset().encode\n                (&quot;Hello World!&quot;));\n    }\n  // 省略其他路径处理方法...\n});\n</code></pre><p>鉴于其编程要素（如Future、CompletionHandler等），我们还没有进行准备工作，为避免理解困难，我会在专栏后面相关概念补充后的再进行介绍，尤其是Reactor、Proactor模式等方面将在Netty主题一起分析，这里我先进行概念性的对比：</p><ul>\n<li>\n<p>基本抽象很相似，AsynchronousServerSocketChannel对应于上面例子中的ServerSocketChannel；AsynchronousSocketChannel则对应SocketChannel。</p>\n</li>\n<li>\n<p>业务逻辑的关键在于，通过指定CompletionHandler回调接口，在accept/read/write等关键节点，通过事件机制调用，这是非常不同的一种编程思路。</p>\n</li>\n</ul><p>今天我初步对Java提供的IO机制进行了介绍，概要地分析了传统同步IO和NIO的主要组成，并根据典型场景，通过不同的IO模式进行了实现与拆解。专栏下一讲，我还将继续分析Java IO的主题。</p><h2>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？留一道思考题给你，NIO多路复用的局限性是什么呢？你遇到过相关的问题吗？</p><p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p><p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>","neighbors":{"left":{"article_title":"第10讲 | 如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？","id":8137},"right":{"article_title":"第12讲 | Java有几种文件拷贝方式？哪一种最高效？","id":8393}},"comments":[{"had_liked":false,"id":24135,"user_name":"王睿","can_delete":false,"product_type":"c1","uid":1049509,"ip_address":"","ucode":"35A1535B018F46","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/a5/ad6b2938.jpg","comment_is_top":false,"comment_ctime":1536819610,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"980789363098","product_id":100006701,"comment_content":"举个收快递的例子不知道理解是否正确。<br><br>BIO，快递员通知你有一份快递会在今天送到某某地方，你需要在某某地方一致等待快递员的到来。<br><br>NIO，快递员通知你有一份快递会送到你公司的前台，你需要每隔一段时间去前台询问是否有你的快递。<br><br>AIO，快递员通知你有一份快递会送到你公司的前台，并且前台收到后会给你打电话通知你过来取。","like_count":229,"discussions":[{"author":{"id":1391249,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3a/91/d894a61f.jpg","nickname":"好久不见","note":"","ucode":"283FDB7580D398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204745,"discussion_content":"aio应该不是你过来取，而是前台送给你","likes_number":17,"is_delete":false,"is_hidden":false,"ctime":1584201276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2070783,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/98/ff/d704cadb.jpg","nickname":"小明","note":"","ucode":"E170B9B5AF7979","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1391249,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3a/91/d894a61f.jpg","nickname":"好久不见","note":"","ucode":"283FDB7580D398","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293093,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595430656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204745,"ip_address":""},"score":293093,"extra":""},{"author":{"id":1393234,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Ko9aHAWDeYicZqElnJEoepIHLTpL8AkeicwQNsIFuZYpKAAkqkYgWmTMyqfQMSXlc5crCQWkpf8CrserhaT9mwsg/132","nickname":"CharlieWong","note":"","ucode":"0299043A439112","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1391249,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3a/91/d894a61f.jpg","nickname":"好久不见","note":"","ucode":"283FDB7580D398","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351992,"discussion_content":"对 aio应该体现自动完成","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614561199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204745,"ip_address":""},"score":351992,"extra":""}]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216583,"discussion_content":"没有体现并发呀","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585467418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1848364,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/34/2c/cd158db1.jpg","nickname":"小刘","note":"","ucode":"F50BCF1E9D285A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346421,"discussion_content":"可以换成去餐厅打饭","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611937841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1747502,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/aa/2e/3c7cb95d.jpg","nickname":"小斧","note":"","ucode":"E50115CCCA1E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1848364,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/34/2c/cd158db1.jpg","nickname":"小刘","note":"","ucode":"F50BCF1E9D285A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351309,"discussion_content":"有形象点的例子吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614238446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":346421,"ip_address":""},"score":351309,"extra":""}]},{"author":{"id":1159362,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKcwxhdFicBaGzYoicricVF7IbYXHyydKgsIx2WxFQtHvnQSGDeyIjeN7DNNtgvfMk7jujpC8UtOPT3Q/132","nickname":"kim","note":"","ucode":"D78CDF0E74369E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556043,"discussion_content":"BIO像一个普通水泵，NIO像一个有蓄水池功能的水泵","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647179502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375191,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621508071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117512,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0d/48/26e827ff.jpg","nickname":"司马思聪","note":"","ucode":"6B9BC903FF9C2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344107,"discussion_content":"感觉 AIO 的例子应该和nio 换一下。nio 是短链接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611295535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10585,"user_name":"I am a psycho","can_delete":false,"product_type":"c1","uid":1103501,"ip_address":"","ucode":"0B65ECADB378C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/8d/7db04ad3.jpg","comment_is_top":false,"comment_ctime":1527604455,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"564168320231","product_id":100006701,"comment_content":"由于nio实际上是同步非阻塞io，是一个线程在同步的进行事件处理，当一组事channel处理完毕以后，去检查有没有又可以处理的channel。这也就是同步+非阻塞。同步，指每个准备好的channel处理是依次进行的，非阻塞，是指线程不会傻傻的等待读。只有当channel准备好后，才会进行。那么就会有这样一个问题，当每个channel所进行的都是耗时操作时，由于是同步操作，就会积压很多channel任务，从而完成影响。那么就需要对nio进行类似负载均衡的操作，如用线程池去进行管理读写，将channel分给其他的线程去执行，这样既充分利用了每一个线程，又不至于都堆积在一个线程中，等待执行。杨老师，不知道上述理解是否正确？","like_count":132,"discussions":[{"author":{"id":1742501,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erwW2gTfDGV3UJqhqexHUgseu385Oo5MU9KficrAQ2tx7zzmMFBJckhBDIeN8YnHyURcVWSCy1hzTg/132","nickname":"minaki","note":"","ucode":"D0759FC96B91EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353641,"discussion_content":"这个解释很棒，我突然好像理解了netty支持几种网络模型的结构了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615183606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14979,"user_name":"蔡光明","can_delete":false,"product_type":"c1","uid":1158477,"ip_address":"","ucode":"7EACC0555B4F19","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/4d/e24fc9e4.jpg","comment_is_top":false,"comment_ctime":1530780323,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"375192935075","product_id":100006701,"comment_content":"看完之后还是不了解nio，感觉看起来越来越吃力了，大半天都啃不了一篇，好多东西都不熟悉，还要自己查资料去了解然后再回过来看，，，老师最好给些学习的资料让我们能找到，就这一篇感觉根本不够","like_count":87,"discussions":[{"author":{"id":1479923,"avatar":"https://static001.geekbang.org/account/avatar/00/16/94/f3/4f88b0e6.jpg","nickname":"Hardy","note":"","ucode":"A4599A50D2573F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306897,"discussion_content":"看那个图，画的还是很形象的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600414013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12922,"user_name":"Chan","can_delete":false,"product_type":"c1","uid":1158920,"ip_address":"","ucode":"8A7151A7E3F5D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/08/49416831.jpg","comment_is_top":false,"comment_ctime":1529136945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"280702011185","product_id":100006701,"comment_content":"B和N通常是针对数据是否就绪的处理方式来<br>sync和async是对阻塞进行更深一层次的阐释，区别在于数据拷贝由用户线程完成还是内核完成，讨论范围一定是两个线程及以上了。<br><br><br>同步阻塞，从数据是否准备就绪到数据拷贝都是由用户线程完成<br><br>同步非阻塞，数据是否准备就绪由内核判断，数据拷贝还是用户线程完成<br><br>异步非阻塞，数据是否准备就绪到数据拷贝都是内核来完成<br><br>所以真正的异步IO一定是非阻塞的。<br><br>多路复用IO即使有Reactor通知用户线程也是同步IO范畴，因为数据拷贝期间仍然是用户线程完成。<br><br>所以假如我们没有内核支持数据拷贝的情况下，讨论的非阻塞并不是彻底的非阻塞，也就没有引入sync和async讨论的必要了<br><br>不知道这样理解是否正确<br><br>","like_count":65},{"had_liked":false,"id":10469,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1527556785,"is_pvip":true,"replies":[{"id":"3358","content":"不错，不过，在非常有必要之前，不见得都要底层，毕竟各种抽象，都是为特定领域工程师准备的，JMM等抽象都是为了大家有个清晰的、不同层面的高效交流","user_name":"作者回复","comment_id":10469,"uid":"1009360","ip_address":"","utype":1,"ctime":1527608136,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"224865856177","product_id":100006701,"comment_content":"批评NIO确实要小心，我觉得主要是三方面，首先是如果是从写BIO过来的同学，需要有一个巨大的观念上的转变，要清楚网络就是并非时刻可读可写，我们用NIO就是在认真的面对这个问题，别把channel当流往死里用，没读出来写不进去的时候，就是该考虑让度线程资源了，第二点是NIO在不同的平台上的实现方式是不一样的，如果你工作用电脑是win，生产是linux，那么建议直接在linux上调试和测试，第三点，概念上的，理解了会在各方面都有益处，NIO在IO操作本身上还是阻塞的，也就是他还是同步IO，AIO读写行为的回调才是异步IO，而这个真正实现，还是看系统底层的，写完之后，我觉得我这一二三有点凑数的嫌疑","like_count":52,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418489,"discussion_content":"不错，不过，在非常有必要之前，不见得都要底层，毕竟各种抽象，都是为特定领域工程师准备的，JMM等抽象都是为了大家有个清晰的、不同层面的高效交流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527608136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14382,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1162307,"ip_address":"","ucode":"0E0D44ABB35DBB","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/43/11acdc02.jpg","comment_is_top":false,"comment_ctime":1530353891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"207688784099","product_id":100006701,"comment_content":"希望能听到更多原理性的东西，而不是在网上能搜到的样例代码","like_count":48},{"had_liked":false,"id":12927,"user_name":"Chan","can_delete":false,"product_type":"c1","uid":1158920,"ip_address":"","ucode":"8A7151A7E3F5D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/08/49416831.jpg","comment_is_top":false,"comment_ctime":1529141338,"is_pvip":false,"replies":[{"id":"4296","content":"对","user_name":"作者回复","comment_id":12927,"uid":"1009360","ip_address":"","utype":1,"ctime":1529160169,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"143263062106","product_id":100006701,"comment_content":"忘记回答问题了。所以对于多路复用IO，当出现有的IO请求在数据拷贝阶段，会出现由于资源类型过份庞大而导致线程长期阻塞，最后造成性能瓶颈的情况","like_count":34,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419461,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529160169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178888,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","nickname":"小鳄鱼","note":"","ucode":"9C30CAFB41A263","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589174,"discussion_content":"如果方案为：一个线程负责处理连接事件，一个线程负责读写事件。那确实会造成线程阻塞。但是如果是基于reactor模型，例如像Netty那样，有一个workGroup线程池，那就不会阻塞其他请求的处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664498675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50033,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1544845590,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"100329093398","product_id":100006701,"comment_content":"对比而言，感觉这节讲解的不够细致，学完以后，能回答开篇的两个问题了，Java提供了IO&#47;BIO&#47;NIO&#47;AIO这几种IO的方式，但是他们的优缺点，使用场景等讲解的不多，推荐看下慕课的 https:&#47;&#47;www.imooc.com&#47;learn&#47;941 这个课程，前半部分把Java IO相关的东西讲解的还是比较详细的。多路复用，这个东西能节省服务端的线程创建成本，一个线程监听多个通道，那个通道就绪了，就处理那个通道，不过具体他是怎么实现的呢？主动的不断轮询？还是被动的接受信息？<br>如果一个通道的处理时间比较长，其他的多个通道又都就绪了，此时该怎么办？就让其他的就绪的通道等待着？<br>感觉是开眼界还行，如果是全弄明白，还是乏力的，要看专业的书啦！","like_count":23,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216591,"discussion_content":"看下linux的epoll机制。。之前看过，类似是观察者模式，用的红黑树管理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585468477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521451,"avatar":"https://static001.geekbang.org/account/avatar/00/17/37/2b/b32f1d66.jpg","nickname":"Ball","note":"","ucode":"1EE949E68D84CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341138,"discussion_content":"怎么我订阅的专栏都能看到你的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610327464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34368,"user_name":"扁担","can_delete":false,"product_type":"c1","uid":1266540,"ip_address":"","ucode":"95B78342FD1893","user_header":"https://static001.geekbang.org/account/avatar/00/13/53/6c/46c4efb0.jpg","comment_is_top":false,"comment_ctime":1540131102,"is_pvip":false,"replies":[{"id":"12315","content":"对，这是这种多路复用的主要局限之一，nodejs等其他类似框架都有这问题","user_name":"作者回复","comment_id":34368,"uid":"1009360","ip_address":"","utype":1,"ctime":1540255379,"user_name_real":"杨晓峰"}],"discussion_count":3,"race_medal":0,"score":"74554575134","product_id":100006701,"comment_content":"据我理解，NIO2的局限性在于，如果回调时客户端做了重操作，就会影响调度，导致后续的client回调缓慢","like_count":17,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427186,"discussion_content":"对，这是这种多路复用的主要局限之一，nodejs等其他类似框架都有这问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540255379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230438,"discussion_content":"不知道你说的重操作是否包含那种类似于setter语句很简单，但是带有锁的方法，因为获取锁的时间不确定性，导致回调执行效率波动，严重时，死锁，画面就更美了；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586745009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230433,"discussion_content":"还有个实际开发中遇到的问题：对于服务端和客户端一问一答的场景，同步IO发送完数据立即接收数据，因为具有发送数据的上下文，很容易做出错误处理；而异步IO因为在回调函数中处理结果，没有上下文，只能根据返回的报文来做错误处理 ，这就要求返回的报文中包含足够多的信息以便正确处理；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586744724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11130,"user_name":"aiwen","can_delete":false,"product_type":"c1","uid":1104346,"ip_address":"","ucode":"504F06CCC7B4FB","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/da/23a4a0c4.jpg","comment_is_top":false,"comment_ctime":1527869368,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"65952378808","product_id":100006701,"comment_content":"到底啥是多路复用？一个线程管理多个链接就是多路复用？","like_count":15,"discussions":[{"author":{"id":1423993,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ba/79/5a6336f5.jpg","nickname":"Ornamentism","note":"","ucode":"1A3BFE53A3BDBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210458,"discussion_content":"我发现这个老师 很多重点不讲清楚 就开始天马行空","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1584721205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448126,"avatar":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","nickname":"慕高迪","note":"","ucode":"EB1CB5EA4E3A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330551,"discussion_content":"nio实现多路复用，主要靠channel注册到selector中，并告诉selector自己感兴趣的事件，selector通过不断的轮询来查看是否满足条件，满足条件就可以返回，交由给后面的线程处理。后面的线程要使用数据，依然是同步的方式，是阻塞的，直到数据从内核空间拷贝到用户空间。在注册到selector之前的部分，是非阻塞的，线程调用完io操作就可以返回了，不需要等待结果","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1606645368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031868,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/bc/62d402da.jpg","nickname":"Goku","note":"","ucode":"8008F3BB10E609","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378258,"discussion_content":"一个线程管理要能够同时处理多个连接才算多路复用。不然的话一个线程可以一个一个的处理所有连接。为了同时处理，就要用selector作为协调者。连接的channel注册到selector上，然后select可以根据channel上的事件进行相应的处理。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623133630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2971019,"avatar":"","nickname":"Geek_0b93c0","note":"","ucode":"ACAA7817AD2C61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571978,"discussion_content":"多路指多个socket，复用指一个线程。就是一个线程监听多个socket，但是会阻塞，直到其中一个socket有数据。因此IO多路复用依然是阻塞IO。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652520728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1479923,"avatar":"https://static001.geekbang.org/account/avatar/00/16/94/f3/4f88b0e6.jpg","nickname":"Hardy","note":"","ucode":"A4599A50D2573F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306898,"discussion_content":"主要在于线程切换，nio实际还是阻塞的，但少了线程切换，相当于汇总到一个线程中处理问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600414327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216590,"discussion_content":"我的理解是差不多吧\nNIO就是复用了线程，处理多个连接，避免了线程成本（新建和上下文的切换）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585468402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1371438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkdQpT1UAl2wjADkrc1fGy9ks9FQZnxC4P5VyABwatlWrr8AciaAr8RxA7p89CYlxlCqcdSbbmKeg/132","nickname":"不可言喻的2","note":"","ucode":"D734DE670D6AF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288212,"discussion_content":"如果一个批次的channel够大，依然还是需要使用多线程处理的，和bio的多线程处理一样的，感觉并不存在什么优势啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593679394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":216590,"ip_address":""},"score":288212,"extra":""},{"author":{"id":1501198,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/0e/876f850e.jpg","nickname":"睡觉表演者","note":"","ucode":"57876725FD0C8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1371438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkdQpT1UAl2wjADkrc1fGy9ks9FQZnxC4P5VyABwatlWrr8AciaAr8RxA7p89CYlxlCqcdSbbmKeg/132","nickname":"不可言喻的2","note":"","ucode":"D734DE670D6AF6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575197,"discussion_content":"bio是线程一直在运作，一直在执行读写操作，但是读并不一定是能成功的，因为可以只建立连接不往里写，这样就阻塞了，nio是真的能读到东西了才让你去执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654662314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288212,"ip_address":""},"score":575197,"extra":""}]}]},{"had_liked":false,"id":140979,"user_name":"Barry","can_delete":false,"product_type":"c1","uid":1182250,"ip_address":"","ucode":"C008BA878E8CBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/2a/8037612c.jpg","comment_is_top":false,"comment_ctime":1571100970,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57405675818","product_id":100006701,"comment_content":"写的啥，看着跟一个普通高级工程师写出来没啥区别","like_count":14},{"had_liked":false,"id":11135,"user_name":"扁扁圆圆","can_delete":false,"product_type":"c1","uid":1116671,"ip_address":"","ucode":"CE9B07D930BF78","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ZwLEEpglswe8uzYj4W6ZVxx0W0OdicjicFzkha4O99wZWGRXqOTF1LO8SsJaBicCXugIQhn8BQicVoTcDJic82RbwDg/132","comment_is_top":false,"comment_ctime":1527880124,"is_pvip":false,"replies":[{"id":"3594","content":"这是简化的例子，少占篇幅","user_name":"作者回复","comment_id":11135,"uid":"1009360","ip_address":"","utype":1,"ctime":1527986741,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"44477553084","product_id":100006701,"comment_content":"这里Nio的Selector只注册了一个sever chanel，这没有实现多路复用吧，多路复用不是注册了多个channel ，处理就绪的吗？而且处理客户端请求也是在同线程内，这还不如上面给的Bio解决方案吧","like_count":10,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418727,"discussion_content":"这是简化的例子，少占篇幅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527986741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1036270,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cf/ee/37c2afce.jpg","nickname":"陶智","note":"","ucode":"44B50ED897DCDB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374715,"discussion_content":"如果同时有两个Channel就绪了怎么办呢，在一个线程里面顺序处理吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621324558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10976,"user_name":"zjh","can_delete":false,"product_type":"c1","uid":1125747,"ip_address":"","ucode":"3AB3862247BEF9","user_header":"","comment_is_top":false,"comment_ctime":1527772091,"is_pvip":false,"replies":[{"id":"3723","content":"这种情况需要考虑把耗时操作并发处理，再说处理是费cpu，还是重io，需要不同处理；如果耗时操作非常多，就不符合这种模型的适用场景","user_name":"作者回复","comment_id":10976,"uid":"1009360","ip_address":"","utype":1,"ctime":1528218142,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"40182477755","product_id":100006701,"comment_content":"看nio代码部分，请求接受和处理都是一个线程在做。这样的话，如果有多个请求过来都是按顺序处理吧，其中一个处理时间比较耗时的话那所有请求不都卡住了吗？如果把nio的处理部分也改成多线程会有什么问题吗","like_count":9,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418663,"discussion_content":"这种情况需要考虑把耗时操作并发处理，再说处理是费cpu，还是重io，需要不同处理；如果耗时操作非常多，就不符合这种模型的适用场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528218142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10800,"user_name":"lorancechen","can_delete":false,"product_type":"c1","uid":1114303,"ip_address":"","ucode":"2A16CFA4726AE7","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/bf/a44cde46.jpg","comment_is_top":false,"comment_ctime":1527723989,"is_pvip":false,"replies":[{"id":"3474","content":"坦白说，内核epoll之类实现细节目前我的理解也有限","user_name":"作者回复","comment_id":10800,"uid":"1009360","ip_address":"","utype":1,"ctime":1527794491,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"40182429653","product_id":100006701,"comment_content":"我也自己写过一个基于nio2的网络程序，觉得配合futrue写起来很舒服。<br>仓库地址：https:&#47;&#47;github.com&#47;LoranceChen&#47;RxSocket  欢迎相互交流开发经验～<br><br>记得在netty中，有一个搁置的netty5.x项目被废弃掉了，原因有一点官方说是性能提升不明显，这是可以理解的，因为linux下是基于epoll，本质还是select操作。<br><br>听了课程之后，有一点印象比较深刻，select模式是使用一个线程做监听，而bio每次来一个链接都要做线程切换，所以节省的时间在线程切换上，当然如果是c&#47;c++实现，原理也是一样的。<br><br><br>想问一个一直困惑的问题，select内部如何实现的呢？<br>个人猜测：不考虑内核，应用层的区分，单纯从代码角度考虑，我猜测，当select开始工作时，有一个定时器，比如每10ms去检查一下网络缓冲区中是否有tcp的链接请求包，然后把这些包筛选出来，作为一个集合（即代码中的迭代器）填入java select类的一个集合成员中，然后唤醒select线程，做一个while遍历处理链接请求，这样一次线程调度就可以处理10ms内的所有链接。与bio比，节省的时间在线程上下文切换上。不知道这么理解对不对。<br>另外，也希望能出一个课程，按照上面这种理解底层的方式，讲讲select（因为我平常工作在linux机器，所以对select epoll比较感兴趣）如何处理read，write操作的。谢谢～<br><br>","like_count":9,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418600,"discussion_content":"坦白说，内核epoll之类实现细节目前我的理解也有限","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527794491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40392,"user_name":"unclenought","can_delete":false,"product_type":"c1","uid":1118258,"ip_address":"","ucode":"D6A10F91456EDD","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/32/8d59aaef.jpg","comment_is_top":false,"comment_ctime":1542614162,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35902352530","product_id":100006701,"comment_content":"http:&#47;&#47;tutorials.jenkov.com&#47;java-nio&#47;index.html，这篇教程对NIO讲得很好，容易理解且有一些实际例子。","like_count":8,"discussions":[{"author":{"id":1258455,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/d7/739e2f6d.jpg","nickname":"Utah","note":"","ucode":"AD5EEFE68706A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370852,"discussion_content":"还是老外的文章好啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619566942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19216,"user_name":"萧萧","can_delete":false,"product_type":"c1","uid":1120579,"ip_address":"","ucode":"9F1F69C390576D","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/43/51154077.jpg","comment_is_top":false,"comment_ctime":1533713562,"is_pvip":false,"replies":[{"id":"7666","content":"这东西并没有完全共识，概念定义要看上下文，很多情况下可以算是同等，但在网络IO编程中是区分的，本文的关注点就是这个","user_name":"作者回复","comment_id":19216,"uid":"1009360","ip_address":"","utype":1,"ctime":1535217387,"user_name_real":"杨晓峰"}],"discussion_count":3,"race_medal":0,"score":"35893451930","product_id":100006701,"comment_content":"作者对同步&#47;异步， 阻塞&#47;非阻塞的概念说明存在问题。<br><br>《操作系统（第9版）》中关于进程通信中有对这部分概念做过解释， 在进程间通信的维度， 同步和阻塞，异步和非阻塞是相同的概念。<br><br> 沿着作者的概念解释简单推论一下就可以发现: <br><br>如果同步操作是需要等待调用返回才能进行下一步， 显然这个调用是阻塞的。 <br><br>反之， 不需要等待调用返回的接口，必然需要提供事件， 回调等机制，这种调用显然是非阻塞的。 ","like_count":8,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421742,"discussion_content":"这东西并没有完全共识，概念定义要看上下文，很多情况下可以算是同等，但在网络IO编程中是区分的，本文的关注点就是这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535217387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284647,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/27/4b81bce5.jpg","nickname":"笑","note":"","ucode":"C91EAFAB88E5AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308485,"discussion_content":"单纯说io的话，作者的理解确实有些问题，同步和异步是对io执行模块来说的，阻塞和非阻塞是对调用io者来说的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1600960548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335975,"discussion_content":"理解是同步和异步：\n同步及异步指的是调用着调用IO是否通过原调用API还是通过接收消息通知，这个本质上是获取结果的形式\n阻塞与非阻塞指的是调用IO的调用者调用获取IO操作时是否线程阻塞\n如果本身是阻塞的，也就肯定是同步了\n如果是异步的，肯定是非阻塞\n所以分类上有：\n同步阻塞（BIO），同步非阻塞（NIO），异步非阻塞（AIO）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608439296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11250,"user_name":"yxw","can_delete":false,"product_type":"c1","uid":1109481,"ip_address":"","ucode":"9B29864871D895","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/e9/f667649e.jpg","comment_is_top":false,"comment_ctime":1527997304,"is_pvip":true,"replies":[{"id":"3668","content":"嗯，有局限性；那个epoll的bug应该在8里修了，netty的改进不止那些，它为了性能改了很多底层，后面会介绍，好多算是hack；另外nio的目的是通用场景的基础API，和终端应用有个距离，核心类库很多都是如此定位，netty这种开源框架更贴近用户场景","user_name":"作者回复","comment_id":11250,"uid":"1009360","ip_address":"","utype":1,"ctime":1528154836,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"35887735672","product_id":100006701,"comment_content":"java nio的selector主要的问题是效率，当并发连接数达到数万甚至数十万的时候 ，单线程的selector会是一个瓶颈；另一个问题就是再线上运行过程中经常出现cpu占用100%的情况，原因也是由于selector依赖的操作系统底层机制bug 导致的selector假死，需要程序重建selector来解决，这个问题再jdk中似乎并没有很好的解决，netty成为了线上更加可靠的网络框架。不知理解的是否正确，请老师指教。","like_count":8,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418765,"discussion_content":"嗯，有局限性；那个epoll的bug应该在8里修了，netty的改进不止那些，它为了性能改了很多底层，后面会介绍，好多算是hack；另外nio的目的是通用场景的基础API，和终端应用有个距离，核心类库很多都是如此定位，netty这种开源框架更贴近用户场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528154836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10805,"user_name":"lorancechen","can_delete":false,"product_type":"c1","uid":1114303,"ip_address":"","ucode":"2A16CFA4726AE7","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/bf/a44cde46.jpg","comment_is_top":false,"comment_ctime":1527724774,"is_pvip":false,"replies":[{"id":"3460","content":"Doug Lea曾经推荐过多个Selector，也就是多个reactor，如果你是这意思<br>","user_name":"作者回复","comment_id":10805,"uid":"1009360","ip_address":"","utype":1,"ctime":1527760337,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"31592495846","product_id":100006701,"comment_content":"还有一个问题请教，select在单线程下处理监听任务是否会成为瓶颈？能否通过创建多个select实例，并发监听socket事件呢？","like_count":7,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418602,"discussion_content":"Doug Lea曾经推荐过多个Selector，也就是多个reactor，如果你是这意思\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527760337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10606,"user_name":"ykkk88","can_delete":false,"product_type":"c1","uid":1068585,"ip_address":"","ucode":"A1BCFC2F0D1022","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/29/1be3dd40.jpg","comment_is_top":false,"comment_ctime":1527609403,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"31592380475","product_id":100006701,"comment_content":"这个nio看起来还是单线程在处理，如果放到多线程池中处理和bio加线程池有啥区别呢 ","like_count":7},{"had_liked":false,"id":10502,"user_name":"残月@诗雨","can_delete":false,"product_type":"c1","uid":1111415,"ip_address":"","ucode":"38DA6C1BC808D5","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/77/7e852c51.jpg","comment_is_top":false,"comment_ctime":1527565262,"is_pvip":false,"replies":[{"id":"3352","content":"我理解是bufferedIS是内部预读，所以两个buffer的意义不一样，前面是减少磁盘之类操作","user_name":"作者回复","comment_id":10502,"uid":"1009360","ip_address":"","utype":1,"ctime":1527606767,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"23002401742","product_id":100006701,"comment_content":"杨老师，有个问题一直不太明白：BufferedInputStream和普通的InputStream直接read到一个缓冲数组这两种方式有什么区别？","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418506,"discussion_content":"我理解是bufferedIS是内部预读，所以两个buffer的意义不一样，前面是减少磁盘之类操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527606767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10480,"user_name":"冬青树","can_delete":false,"product_type":"c1","uid":1067720,"ip_address":"","ucode":"3DC219F6EE3046","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/c8/7679cd2a.jpg","comment_is_top":false,"comment_ctime":1527558839,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23002395319","product_id":100006701,"comment_content":"IO的调用可以分为三大块，请求调用，逻辑处理，响应返回处理。常规的BIO在这三个阶段会串行的阻塞的。NIO其实可以理解为将这三个阶段尽可能的去阻塞或者减少阻塞。看了上面的例子，NIO的服务器端在接受客户端请求的时候，是单线程执行的，而BIO是多线程处理的。但是不管咋的，他们服务器端处理具体的客户业务逻辑是都要用多线程的吧？","like_count":5},{"had_liked":false,"id":16297,"user_name":"张凯江","can_delete":false,"product_type":"c1","uid":1057462,"ip_address":"","ucode":"301905828F489D","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/b6/3d8fcc2c.jpg","comment_is_top":false,"comment_ctime":1531875836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18711745020","product_id":100006701,"comment_content":"cpu运算密集型应用。node得诟病","like_count":4},{"had_liked":false,"id":10416,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1527551925,"is_pvip":false,"replies":[{"id":"3363","content":"线程看定义stack大小等，32、64位都不一样","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527608872,"ip_address":"","comment_id":10416,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18707421109","product_id":100006701,"comment_content":"老师 注册管道到select上，应该用队列实现的吧？<br>开启一个线程大概需要多少内存开销呢，我记得数据库连接大概2M","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418471,"discussion_content":"线程看定义stack大小等，32、64位都不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527608872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18076,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1533123056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14418024944","product_id":100006701,"comment_content":"1,基于nio的tcp 编程代码复杂<br>2,nio本质是同步非阻塞的<br>总结：select模式是使用一个线程做监听，而bio每次来一个链接都要做线程切换，所以节省的时间在线程切换","like_count":3},{"had_liked":false,"id":11543,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1528190466,"is_pvip":false,"replies":[{"id":"3714","content":"try with resource就相当于在finally里close；一直挂着是因为server在伺服","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528215040,"ip_address":"","comment_id":11543,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14413092354","product_id":100006701,"comment_content":"杨老师，把你给的NIOServer的例子做了一下，发现sayHelloWorld()方法，client.write()后，如果没有client.close(),线程一直在挂着。请确认一下，是否例子缺了client.close()？","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418891,"discussion_content":"try with resource就相当于在finally里close；一直挂着是因为server在伺服","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528215040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10612,"user_name":"RoverYe","can_delete":false,"product_type":"c1","uid":1113144,"ip_address":"","ucode":"ACA5AD466C2536","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/38/59dda970.jpg","comment_is_top":false,"comment_ctime":1527611870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14412513758","product_id":100006701,"comment_content":"nio不适合数据量太大交互的场景","like_count":3},{"had_liked":false,"id":10487,"user_name":"L.B.Q.Y","can_delete":false,"product_type":"c1","uid":1069325,"ip_address":"","ucode":"5567989D1CDBBE","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/0d/14d9364a.jpg","comment_is_top":false,"comment_ctime":1527559975,"is_pvip":false,"replies":[{"id":"3355","content":"所以我理解，适用于大量请求大小有限的场景，（主任务）单线程模型，比如nodejs都有类似情况，","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527607587,"ip_address":"","comment_id":10487,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14412461863","product_id":100006701,"comment_content":"NIO多路复用模式，如果对应事件的处理比较耗时，是不是会导致后续事件的响应出现延迟。","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418497,"discussion_content":"所以我理解，适用于大量请求大小有限的场景，（主任务）单线程模型，比如nodejs都有类似情况，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527607587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75664,"user_name":"java届-Mr.吉","can_delete":false,"product_type":"c1","uid":1252541,"ip_address":"","ucode":"6CF474AB180D9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/bd/23aeb6d0.jpg","comment_is_top":false,"comment_ctime":1552445952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10142380544","product_id":100006701,"comment_content":"同步和阻塞的区别方便解释一下嘛。字面理解的哈，都是两个线程同时过来，一个线程先执行，另一个线程就被阻塞，直到条件满足或者事件回掉，才能继续。没明白他俩的本质区别","like_count":2},{"had_liked":false,"id":38650,"user_name":"森","can_delete":false,"product_type":"c1","uid":1118939,"ip_address":"","ucode":"FDFD5C54D9239B","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/db/d70eb05e.jpg","comment_is_top":false,"comment_ctime":1542095182,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10132029774","product_id":100006701,"comment_content":"数据库是传统的BIO，利用线程池虽然能解决线程创建销毁的开销，相比之下，NIO实现会更好，而且连接数也会增多。但是为什么数据库不用NIO实现呢？谢谢老师","like_count":2,"discussions":[{"author":{"id":1093541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/af/a5/afa1d7d7.jpg","nickname":"hasWhere","note":"","ucode":"2C2B2988107489","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155655,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580272538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33730,"user_name":"TiTi","can_delete":false,"product_type":"c1","uid":1127343,"ip_address":"","ucode":"58F19596A1EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/af/dda311cf.jpg","comment_is_top":false,"comment_ctime":1539865819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10129800411","product_id":100006701,"comment_content":"Netty和Reactor主题是在本系列么？怎么找不到啊","like_count":2},{"had_liked":false,"id":17143,"user_name":"绍昊","can_delete":false,"product_type":"c1","uid":1111840,"ip_address":"","ucode":"1D4EF77E5A1635","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/20/32895cc5.jpg","comment_is_top":false,"comment_ctime":1532453589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10122388181","product_id":100006701,"comment_content":"可不可以这样理解，NIO适用于CPU密集并且操作的数据量不会很大场景。因为NIO只用一个线程来操作IO，所以避免了多线程切换带来的开销。","like_count":2},{"had_liked":false,"id":223449,"user_name":"颇忒妥","can_delete":false,"product_type":"c1","uid":1026448,"ip_address":"","ucode":"AA86AD1049BC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg","comment_is_top":false,"comment_ctime":1591091911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886059207","product_id":100006701,"comment_content":"同步是你主动去问，异步是别人通知你。阻塞是事情没做完就不能做下一件事情，非阻塞是事情没做完你可以做下一件事情。同步+阻塞就是BIO。同步+非阻塞就是你可以不停的主动问事情有没有做好，是NIO。","like_count":1},{"had_liked":false,"id":127426,"user_name":"日光倾城","can_delete":false,"product_type":"c1","uid":1120345,"ip_address":"","ucode":"E4329963F660DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/59/daeb0b6c.jpg","comment_is_top":false,"comment_ctime":1566706098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5861673394","product_id":100006701,"comment_content":"关于同步异步和阻塞非阻塞，还是觉得是差不多的概念，老师可以举例子说明其差别吗？或者说他们是针对不同场景的概念？","like_count":1},{"had_liked":false,"id":101447,"user_name":"药师","can_delete":false,"product_type":"c1","uid":1213258,"ip_address":"","ucode":"14BB054A38A2F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/4a/3e08427e.jpg","comment_is_top":false,"comment_ctime":1559810590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5854777886","product_id":100006701,"comment_content":"老师，BIO的例子，引入线程池部分<br>serverSocket = new ServerSocket(0);<br>executor = Executors.newFixedThreadPool(8);<br> while (true) {<br>    Socket socket = serverSocket.accept();<br>    RequestHandler requestHandler = new RequestHandler(socket);<br>    executor.execute(requestHandler);<br>}<br>只是业务处理部分多线程，但是IO部分仍然是单线程的吧？<br>BIO与下面NIO的例子相比，IO处理部分的区别就是BIO只支持单线程处理单个请求的IO（串行处理），而NIO支持单线程处理多个请求的IO，我这样理解正确么？<br>万望老师给予指导，解除我心中疑惑<br><br>","like_count":1},{"had_liked":false,"id":78394,"user_name":"kiterunner_t","can_delete":false,"product_type":"c1","uid":1062762,"ip_address":"","ucode":"026AB884351807","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/6a/f492a4df.jpg","comment_is_top":false,"comment_ctime":1553139188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848106484","product_id":100006701,"comment_content":"@lorancechen linux下的epoll实现应该不是这样子的，创建了一颗红黑树来维护所有你想关心的文件描述符fd，而协议栈在fd上面有数据发生变化的时候，会主动更改相关状态，并通知上层应用 。用C语言写一个例子就大概知道了。https:&#47;&#47;www.cnblogs.com&#47;chenny7&#47;p&#47;5069627.html","like_count":1},{"had_liked":false,"id":76996,"user_name":"Victor","can_delete":false,"product_type":"c1","uid":1432914,"ip_address":"","ucode":"60C28B7D05C6B1","user_header":"https://static001.geekbang.org/account/avatar/00/15/dd/52/e9c50a19.jpg","comment_is_top":false,"comment_ctime":1552798481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847765777","product_id":100006701,"comment_content":"类图那里，FileOutputStream 后面应该是 BufferOutputStream","like_count":1},{"had_liked":false,"id":22086,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1535479816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5830447112","product_id":100006701,"comment_content":"nio从样例代码上没看出是同步非阻塞啊，忘解答一下","like_count":1},{"had_liked":false,"id":18651,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1533523673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828490969","product_id":100006701,"comment_content":"老师,nio server 的例子有点简单哦，能否帮忙补充下生产环境下，io 密集型，和cpu 密集型场景的代码示例","like_count":1},{"had_liked":false,"id":18649,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1533521773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828489069","product_id":100006701,"comment_content":"老师，nio 的例子感觉不是很高，sayHelloWorld这个方法应该放到线程池里面执行。不然即便后面有新的链接进来，同样会被阻塞","like_count":1},{"had_liked":false,"id":11653,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1528270735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5823238031","product_id":100006701,"comment_content":"NIO 2是借助AsychronousChannelGroup,实现多Channel方案，有具备异步功能，解决NIO 1单线程多通路问题。<br>不过异步有两种方案:<br>1.New一个CompletionHandler对象，在重写方法中处理，Write和Read.<br>2.通过concurrent.Future对象，建模一个挂起操作，之后可以通过Get获取socketChannel处理Write和Read。<br>想问问杨老师，两种方式各有什么优劣？","like_count":1},{"had_liked":false,"id":11542,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1528189151,"is_pvip":false,"replies":[{"id":"3715","content":"前面介绍过，try-with-resources，自动close","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528217483,"ip_address":"","comment_id":11542,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823156447","product_id":100006701,"comment_content":"问个问题，看到你写的样例中，几处try (),小括号里面写了一些逻辑，这种写法跟放在{}里面有啥区别？望专家回复一下。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418890,"discussion_content":"前面介绍过，try-with-resources，自动close","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528217483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10622,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1527636420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5822603716","product_id":100006701,"comment_content":"我是来找茬的😄：file 应该的读「fail」<br><br><br>————————<br>请教一个概念性的问题：线程池模式和数据库连接池模式，是不是就是大家通常所说的对象池模式？","like_count":1},{"had_liked":false,"id":10459,"user_name":"Forrest","can_delete":false,"product_type":"c1","uid":1032662,"ip_address":"","ucode":"2BAF62DFE9E918","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/d6/f331dba7.jpg","comment_is_top":false,"comment_ctime":1527555877,"is_pvip":false,"replies":[{"id":"3361","content":"没有看明白问题，抱歉","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527608347,"ip_address":"","comment_id":10459,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5822523173","product_id":100006701,"comment_content":"使用线程池可以很好的解决线程复用，避免线程创建带来的开销，效果也很好，一个问题想请教下，当线程池无法满足需要时可以用什么方式解决？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418486,"discussion_content":"没有看明白问题，抱歉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527608347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253705,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/49/2d51a40a.jpg","nickname":"甜甜的美食旅行家","note":"","ucode":"DC85E460AC1528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352086,"discussion_content":"线程池能否满足，看阻塞队列和拒绝策略配置。三年了，你应该都知道了吧～～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614598401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352392,"user_name":"。。。","can_delete":false,"product_type":"c1","uid":1416047,"ip_address":"","ucode":"AA9E35E012FDEB","user_header":"https://static001.geekbang.org/account/avatar/00/15/9b/6f/acba0317.jpg","comment_is_top":false,"comment_ctime":1658636754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658636754","product_id":100006701,"comment_content":"老师，你画类图的工具用的什么？在哪能下载到呢","like_count":0},{"had_liked":false,"id":351202,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1657607301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657607301","product_id":100006701,"comment_content":"Bio阻塞io  Nio 非阻塞io  Nio2 异步非阻塞io","like_count":0},{"had_liked":false,"id":307241,"user_name":"柯伟","can_delete":false,"product_type":"c1","uid":1970536,"ip_address":"","ucode":"92BFAA8B85E5E8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/11/68/ac0d2b05.jpg","comment_is_top":false,"comment_ctime":1628962075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628962075","product_id":100006701,"comment_content":"常见IO模型下的阻塞和同步的理解：<br>\t所有的系统IO都分为两个阶段：等待就绪和操作。比如，读函数分为等待系统可读和真正的读。同理，写函数分为等待网卡可以写和真正的写。需要说明的是等待就绪的阻塞是不使用CPU的，是在”空等“，而真正的读写操作的阻塞是使用CPU的，真正在”干活“。<br>\tBIO：socket主要的读、写、注册和接收函数，在等待就绪阶段和IO操作都是同步阻塞的<br>\tNIO：socket主要的读、写、注册和接收函数，在等待就绪阶段是非阻塞的，真正的I&#47;O操作是同步阻塞的（消耗CPU但性能非常高）。<br>\tAIO：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。","like_count":0},{"had_liked":false,"id":306962,"user_name":"李沛霖-程序猿","can_delete":false,"product_type":"c1","uid":1063957,"ip_address":"","ucode":"10CF0DBED2D220","user_header":"https://static001.geekbang.org/account/avatar/00/10/3c/15/71a2aca9.jpg","comment_is_top":false,"comment_ctime":1628813482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628813482","product_id":100006701,"comment_content":"所以谁在切换io，检测io 是否有消息呢？在系统层面io 消息一直是非阻塞的，消息来了，通过cpu中断处理，没有消息时候，cpu就忙别的。","like_count":0},{"had_liked":false,"id":288297,"user_name":"jeff","can_delete":false,"product_type":"c1","uid":1026894,"ip_address":"","ucode":"68456DD035BDF4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/4e/82e9657c.jpg","comment_is_top":false,"comment_ctime":1618399068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618399068","product_id":100006701,"comment_content":"这么看nio 并不比bio效率高仅仅是节约了线程的开销。<br>我的理解是示例中的nio效率大概率比bio 低。尤其是高并发的时候。因此我觉得应该在nio遍历key时使用多线程进行响应！晚上看到一篇对tomcat的 bio nio apr 模式的测试、竟然没给 tomcat配置 线程数！所以空页面响应时 nio险胜。","like_count":0},{"had_liked":false,"id":270918,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1609317568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609317568","product_id":100006701,"comment_content":"看不明白的同学可以看看Unix里面的write,read; select, epoll; aio（Linux）等内容，上层的编程语言知识将操作系统层面的系统调用封装了一下而已。","like_count":0},{"had_liked":false,"id":256850,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1100271,"ip_address":"","ucode":"127AFF8EFFB2B1","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/ef/b7dd32d9.jpg","comment_is_top":false,"comment_ctime":1603766118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603766118","product_id":100006701,"comment_content":"感觉AIO的思想就跟JavaScript的事件机制类似，JavaScript就是单线程的","like_count":0},{"had_liked":false,"id":249615,"user_name":"梦江","can_delete":false,"product_type":"c1","uid":2059155,"ip_address":"","ucode":"B5FD2835863460","user_header":"https://static001.geekbang.org/account/avatar/00/1f/6b/93/bfda2d1c.jpg","comment_is_top":false,"comment_ctime":1600708462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600708462","product_id":100006701,"comment_content":"可以看到，在前面两个样例中，IO 都是同步阻塞模式，所以需要多线程以实现多任务处理。<br><br>这里的nio阻塞仅仅指selector","like_count":0},{"had_liked":false,"id":235896,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1595238004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595238004","product_id":100006701,"comment_content":"个人认为是多路复用的局限性，是没有利用CPU的多核优势","like_count":0},{"had_liked":false,"id":198810,"user_name":"Swing","can_delete":false,"product_type":"c1","uid":1330065,"ip_address":"","ucode":"55FCA9ECEFBBEB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","comment_is_top":false,"comment_ctime":1585468931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585468931","product_id":100006701,"comment_content":"epoll机制的。之前看过一点<br>https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;9293","like_count":0},{"had_liked":false,"id":173064,"user_name":"xiong","can_delete":false,"product_type":"c1","uid":1099375,"ip_address":"","ucode":"C1BFD9EF96372F","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/6f/ac3003fa.jpg","comment_is_top":false,"comment_ctime":1579419539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579419539","product_id":100006701,"comment_content":"大佬们，文中的 NIOServer 我跑起来之后，客户端连接了一次，NIOServer代码就一直死循环是为什么呀 ？ 不是已经remove 掉SelectionKey 了吗？ ","like_count":0},{"had_liked":false,"id":147131,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1572814536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572814536","product_id":100006701,"comment_content":"<br>Nio是将IO分类，看IO是否就绪，根据IO状态分配CPU和内存资源，而不是像传统的Java去IO包那样每个IO调用固定分配内存和CPU资源，请问老师，这样的理解是否正确？","like_count":0},{"had_liked":false,"id":147130,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1572814497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572814497","product_id":100006701,"comment_content":"同步和异步是从调用顺序来分类。阻塞和非阻塞是从是否等待来分类。一般来讲同步调用等待多，异步调用等待少，但是需要切换调用环境。 请问老师，这样理解是否正确？","like_count":0},{"had_liked":false,"id":147129,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1572814400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572814400","product_id":100006701,"comment_content":"IO意味着离开内存CPU系统去和外部的资源进行数据交互，外部资源的读写效率一般都远低于内存和CPU。传统的Java IO包提供的是同步阻塞的调用，相当于单独分配一些CPU和内存资源去处理外部数据交互，一般而言这部分内存和CPU资源无法有效利用，他们的效率会被外部低速设备所阻塞。这个角度讲反应式编程是大势所趋。<br>","like_count":0},{"had_liked":false,"id":145385,"user_name":"coderkeep","can_delete":false,"product_type":"c1","uid":1129178,"ip_address":"","ucode":"29EE99F8F19F2E","user_header":"https://static001.geekbang.org/account/avatar/00/11/3a/da/7f9cbbd1.jpg","comment_is_top":false,"comment_ctime":1572263617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572263617","product_id":100006701,"comment_content":"第三遍看这篇专栏，刚开始很懵，第三次看对同步与阻塞，三种io模型有了点感觉。有个感想，一个知识点如果看了三篇左右同类型文章还是不懂，那么再看第四篇也不会让你明白，这种时候应该选一篇反复啃。换个角度，写出的文章值得反复去看，这应该是最能反衬作者在技术上的造诣了吧。","like_count":0},{"had_liked":false,"id":135411,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1569150438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569150438","product_id":100006701,"comment_content":"说真的，几乎不会用到IO相关的代码","like_count":0},{"had_liked":false,"id":132881,"user_name":"sudo","can_delete":false,"product_type":"c1","uid":1188517,"ip_address":"","ucode":"EA0F8116999557","user_header":"http://thirdwx.qlogo.cn/mmopen/g7TWmGqjoiaSFWknFpTPAia5rPOmzEZiaGK8icd5HGEXlfaYJBoKvLn5BkqGkyTZOqDTC3NMHXUbH3tdLJzicAyickRYdP4xcM3ajia/132","comment_is_top":false,"comment_ctime":1568258388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568258388","product_id":100006701,"comment_content":"sayHelloWorld((ServerSocketChannel) key.channel());<br>这里类型强转是不是有问题？多个channel可以注册到同一个selector上。","like_count":0},{"had_liked":false,"id":121913,"user_name":"顺哥聊成长","can_delete":false,"product_type":"c1","uid":1023328,"ip_address":"","ucode":"FEF42E951B16F4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/60/45b3184d.jpg","comment_is_top":false,"comment_ctime":1565248225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565248225","product_id":100006701,"comment_content":"用C++的那些年学过这些概念，到Java了，还得再熟悉一遍。","like_count":0},{"had_liked":false,"id":121763,"user_name":"千回百转无劫山","can_delete":false,"product_type":"c1","uid":1456256,"ip_address":"","ucode":"2C249889C00929","user_header":"","comment_is_top":false,"comment_ctime":1565221292,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1565221292","product_id":100006701,"comment_content":"direct io 应该也属于文件io类型吧 老师","like_count":0},{"had_liked":false,"id":114873,"user_name":"Krison","can_delete":false,"product_type":"c1","uid":1481198,"ip_address":"","ucode":"F2800118EEF3C9","user_header":"https://static001.geekbang.org/account/avatar/00/16/99/ee/5204b281.jpg","comment_is_top":false,"comment_ctime":1563420754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563420754","product_id":100006701,"comment_content":"感觉好复杂，一天完全不无法消化","like_count":0},{"had_liked":false,"id":90895,"user_name":"尹腾","can_delete":false,"product_type":"c1","uid":1057840,"ip_address":"","ucode":"2FA104F924F015","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/30/9482e89d.jpg","comment_is_top":false,"comment_ctime":1556717513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556717513","product_id":100006701,"comment_content":"nio的非阻塞体现在buffer的设计上吧，可读可写～","like_count":0},{"had_liked":false,"id":27905,"user_name":"✎﹏๓₯㎕╮陌","can_delete":false,"product_type":"c1","uid":1100959,"ip_address":"","ucode":"2462FABBE81F4D","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/9f/170cd096.jpg","comment_is_top":false,"comment_ctime":1537963860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537963860","product_id":100006701,"comment_content":"哎。什么都不说。谢谢你","like_count":0},{"had_liked":false,"id":27124,"user_name":"江南小帅","can_delete":false,"product_type":"c1","uid":1195049,"ip_address":"","ucode":"3519F8EA938022","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/29/29d923ce.jpg","comment_is_top":false,"comment_ctime":1537836878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537836878","product_id":100006701,"comment_content":"杨老师，建议把hashMap的历史讲一下，伴随着jdk的发展，就像hashMap的树化是jdk1.8后才优化的一样，你这样突然讲出来，还是有种很突兀的感觉。。。","like_count":0},{"had_liked":false,"id":24024,"user_name":"猎羽","can_delete":false,"product_type":"c1","uid":1209802,"ip_address":"","ucode":"98A1B456871250","user_header":"https://static001.geekbang.org/account/avatar/00/12/75/ca/15b32bc5.jpg","comment_is_top":false,"comment_ctime":1536761090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536761090","product_id":100006701,"comment_content":"挺喜欢的，支持！","like_count":0},{"had_liked":false,"id":23326,"user_name":"静思览霓","can_delete":false,"product_type":"c1","uid":1119967,"ip_address":"","ucode":"FB61126250272A","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/df/82349475.jpg","comment_is_top":false,"comment_ctime":1536286431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536286431","product_id":100006701,"comment_content":"老师，我现在做的分布式文件系统服务，调用方通过MultipartFile.getBytes获取字节数组，传递给我。请问怎么做优化啊？感觉nio和socket关键比较大，不知道应该怎样提高文件的读写性能。。。","like_count":0},{"had_liked":false,"id":18200,"user_name":"、","can_delete":false,"product_type":"c1","uid":1162040,"ip_address":"","ucode":"9BA80F04C1D5E2","user_header":"https://static001.geekbang.org/account/avatar/00/11/bb/38/2fb5c4ce.jpg","comment_is_top":false,"comment_ctime":1533186060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533186060","product_id":100006701,"comment_content":"NIO 示例代码的main可以发下吗？ 菜鸡不会","like_count":0},{"had_liked":false,"id":18010,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1533085662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533085662","product_id":100006701,"comment_content":"老师，这节出现的所有“阻塞”操作，均会释放 cpu 是么？谢谢","like_count":0},{"had_liked":false,"id":14709,"user_name":"清风","can_delete":false,"product_type":"c1","uid":1129749,"ip_address":"","ucode":"59932E13FAF607","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/15/7f5fd6d3.jpg","comment_is_top":false,"comment_ctime":1530610947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530610947","product_id":100006701,"comment_content":"我认为这个nio 2基于事件编程就跟swing 编程添加监听事件一样，有事件发生了，执行回调函数。不知道理解是否准确。同时针对nio的采用线程不断地轮询，对客户多量大后会有响应延迟，并发数量有限。同时也想知道tomcat是怎么样通过nio 来解决着问题的。一直没有时间看一下他的源码，枉费我工作这么多年。老师可以写一篇这个nio和tomcat的文章！","like_count":0},{"had_liked":false,"id":13923,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1530065298,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530065298","product_id":100006701,"comment_content":"哈哈，如果能结合操作系统之中io模型讲也许更好，顺便分析下select和poll和epoll的实现机制，那么就比较完美了。不过话说这样，就这个主题就可以当一门课啦。推荐netty权威指南","like_count":0},{"had_liked":false,"id":10605,"user_name":"funnyx","can_delete":false,"product_type":"c1","uid":1115049,"ip_address":"","ucode":"A9B8E27919AE4D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoZqcVJzUjfu5noOW6OPAh6ibrBicibLmicibnVyVLHdf7GwAzf2th5s1oQ9pUbLpmq2mlVBauUZn8QUnw/132","comment_is_top":false,"comment_ctime":1527609403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527609403","product_id":100006701,"comment_content":"这个模式和go中的goroutine，channel，select很像，值得研究。","like_count":0}]}