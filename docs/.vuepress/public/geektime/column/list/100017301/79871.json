{"id":79871,"title":"54 | 算法实战（三）：剖析高性能队列Disruptor背后的数据结构和算法","content":"<p>Disruptor你是否听说过呢？它是一种内存消息队列。从功能上讲，它其实有点儿类似Kafka。不过，和Kafka不同的是，Disruptor是线程之间用于消息传递的队列。它在Apache Storm、Camel、Log4j 2等很多知名项目中都有广泛应用。</p><p>之所以如此受青睐，主要还是因为它的性能表现非常优秀。它比Java中另外一个非常常用的内存消息队列ArrayBlockingQueue（ABS）的性能，要高一个数量级，可以算得上是最快的内存消息队列了。它还因此获得过Oracle官方的Duke大奖。</p><p>如此高性能的内存消息队列，在设计和实现上，必然有它独到的地方。今天，我们就来一块儿看下，<strong><span class=\"orange\">Disruptor是如何做到如此高性能的？其底层依赖了哪些数据结构和算法？</span></strong></p><h2>基于循环队列的“生产者-消费者模型”</h2><p>什么是内存消息队列？对很多业务工程师或者前端工程师来说，可能会比较陌生。不过，如果我说“生产者-消费者模型”，估计大部分人都知道。在这个模型中，“生产者”生产数据，并且将数据放到一个中心存储容器中。之后，“消费者”从中心存储容器中，取出数据消费。</p><p>这个模型非常简单、好理解，那你有没有思考过，这里面存储数据的中心存储容器，是用什么样的数据结构来实现的呢？</p><!-- [[[read_end]]] --><p>实际上，实现中心存储容器最常用的一种数据结构，就是我们在<a href=\"https://time.geekbang.org/column/article/41330\">第9节</a>讲的队列。队列支持数据的先进先出。正是这个特性，使得数据被消费的顺序性可以得到保证，也就是说，早被生产的数据就会早被消费。</p><p>我们在第9节讲过，队列有两种实现思路。一种是基于链表实现的链式队列，另一种是基于数组实现的顺序队列。不同的需求背景下，我们会选择不同的实现方式。</p><p>如果我们要实现一个无界队列，也就是说，队列的大小事先不确定，理论上可以支持无限大。这种情况下，我们适合选用链表来实现队列。因为链表支持快速地动态扩容。如果我们要实现一个有界队列，也就是说，队列的大小事先确定，当队列中数据满了之后，生产者就需要等待。直到消费者消费了数据，队列有空闲位置的时候，生产者才能将数据放入。</p><p>实际上，相较于无界队列，有界队列的应用场景更加广泛。毕竟，我们的机器内存是有限的。而无界队列占用的内存数量是不可控的。对于实际的软件开发来说，这种不可控的因素，就会有潜在的风险。在某些极端情况下，无界队列就有可能因为内存持续增长，而导致OOM（Out of Memory）错误。</p><p>在第9节中，我们还讲过一种特殊的顺序队列，循环队列。我们讲过，非循环的顺序队列在添加、删除数据的工程中，会涉及数据的搬移操作，导致性能变差。而循环队列正好可以解决这个数据搬移的问题，所以，性能更加好。所以，大部分用到顺序队列的场景中，我们都选择用顺序队列中的循环队列。</p><p>实际上，<strong>循环队列这种数据结构，就是我们今天要讲的内存消息队列的雏形。</strong>我借助循环队列，实现了一个最简单的“生产者-消费者模型”。对应的代码我贴到这里，你可以看看。</p><p>为了方便你理解，对于生产者和消费者之间操作的同步，我并没有用到线程相关的操作。而是采用了“当队列满了之后，生产者就轮训等待；当队列空了之后，消费者就轮训等待”这样的措施。</p><pre><code>public class Queue {\n  private Long[] data;\n  private int size = 0, head = 0, tail = 0;\n  public Queue(int size) {\n    this.data = new Long[size];\n    this.size = size;\n  }\n\n  public boolean add(Long element) {\n    if ((tail + 1) % size == head) return false;\n    data[tail] = element;\n    tail = (tail + 1) % size;\n    return true;\n  }\n\n  public Long poll() {\n    if (head == tail) return null;\n    long ret = data[head];\n    head = (head + 1) % size;\n    return ret;\n  }\n}\n\npublic class Producer {\n  private Queue queue;\n  public Producer(Queue queue) {\n    this.queue = queue;\n  }\n\n  public void produce(Long data) throws InterruptedException {\n    while (!queue.add(data)) {\n      Thread.sleep(100);\n    }\n  }\n}\n\npublic class Consumer {\n  private Queue queue;\n  public Consumer(Queue queue) {\n    this.queue = queue;\n  }\n\n  public void comsume() throws InterruptedException {\n    while (true) {\n      Long data = queue.poll();\n      if (data == null) {\n        Thread.sleep(100);\n      } else {\n        // TODO:...消费数据的业务逻辑...\n      }\n    }\n  }\n}\n</code></pre><h2>基于加锁的并发“生产者-消费者模型”</h2><p>实际上，刚刚的“生产者-消费者模型”实现代码，是不完善的。为什么这么说呢？</p><p>如果我们只有一个生产者往队列中写数据，一个消费者从队列中读取数据，那上面的代码是没有问题的。但是，如果有多个生产者在并发地往队列中写入数据，或者多个消费者并发地从队列中消费数据，那上面的代码就不能正确工作了。我来给你讲讲为什么。</p><p>在多个生产者或者多个消费者并发操作队列的情况下，刚刚的代码主要会有下面两个问题：</p><ul>\n<li>\n<p>多个生产者写入的数据可能会互相覆盖；</p>\n</li>\n<li>\n<p>多个消费者可能会读取重复的数据。</p>\n</li>\n</ul><p>因为第一个问题和第二个问题产生的原理是类似的。所以，我着重讲解第一个问题是如何产生的以及该如何解决。对于第二个问题，你可以类比我对第一个问题的解决思路自己来想一想。</p><p>两个线程同时往队列中添加数据，也就相当于两个线程同时执行类Queue中的add()函数。我们假设队列的大小size是10，当前的tail指向下标7，head指向下标3，也就是说，队列中还有空闲空间。这个时候，线程1调用add()函数，往队列中添加一个值为12的数据；线程2调用add()函数，往队列中添加一个值为15的数据。在极端情况下，本来是往队列中添加了两个数据（12和15），最终可能只有一个数据添加成功，另一个数据会被覆盖。这是为什么呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/3d/4f88bec40128dbc8c1b700b4cf38b63d.jpg?wh=1142*647\" alt=\"\"></p><p>为了方便你查看队列Queue中的add()函数，我把它从上面的代码中摘录出来，贴在这里。</p><pre><code>public boolean add(Long element) {\n  if ((tail + 1) % size == head) return false;\n  data[tail] = element;\n  tail = (tail + 1) % size;\n  return true;\n}\n</code></pre><p>从这段代码中，我们可以看到，第3行给data[tail]赋值，然后第4行才给tail的值加一。赋值和tail加一两个操作，并非原子操作。这就会导致这样的情况发生：当线程1和线程2同时执行add()函数的时候，线程1先执行完了第3行语句，将data[7]（tail等于7）的值设置为12。在线程1还未执行到第4行语句之前，也就是还未将tail加一之前，线程2执行了第3行语句，又将data[7]的值设置为15，也就是说，那线程2插入的数据覆盖了线程1插入的数据。原本应该插入两个数据（12和15）的，现在只插入了一个数据（15）。</p><p><img src=\"https://static001.geekbang.org/resource/image/27/3a/27ee7d9c12590cfdf02a2f95996b713a.jpg?wh=1142*655\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/05/f7/05764e49514974aafaa97b70214a7af7.jpg?wh=1142*673\" alt=\"\"></p><p>那如何解决这种线程并发往队列中添加数据时，导致的数据覆盖、运行不正确问题呢？</p><p>最简单的处理方法就是给这段代码加锁，同一时间只允许一个线程执行add()函数。这就相当于将这段代码的执行，由并行改成了串行，也就不存在我们刚刚说的问题了。</p><p>不过，天下没有免费的午餐，加锁将并行改成串行，必然导致多个生产者同时生产数据的时候，执行效率的下降。当然，我们可以继续优化代码，用<a href=\"https://en.wikipedia.org/wiki/Compare-and-swap\">CAS</a>（compare and swap，比较并交换）操作等减少加锁的粒度，但是，这不是我们这节的重点。我们直接看Disruptor的处理方法。</p><h2>基于无锁的并发“生产者-消费者模型”</h2><p>尽管Disruptor的源码读起来很复杂，但是基本思想其实非常简单。实际上，它是换了一种队列和“生产者-消费者模型”的实现思路。</p><p>之前的实现思路中，队列只支持两个操作，添加数据和读取并移除数据，分别对应代码中的add()函数和poll()函数，而Disruptor采用了另一种实现思路。</p><p>对于生产者来说，它往队列中添加数据之前，先申请可用空闲存储单元，并且是批量地申请连续的n个（n≥1）存储单元。当申请到这组连续的存储单元之后，后续往队列中添加元素，就可以不用加锁了，因为这组存储单元是这个线程独享的。不过，从刚刚的描述中，我们可以看出，申请存储单元的过程是需要加锁的。</p><p>对于消费者来说，处理的过程跟生产者是类似的。它先去申请一批连续可读的存储单元（这个申请的过程也是需要加锁的），当申请到这批存储单元之后，后续的读取操作就可以不用加锁了。</p><p>不过，还有一个需要特别注意的地方，那就是，如果生产者A申请到了一组连续的存储单元，假设是下标为3到6的存储单元，生产者B紧跟着申请到了下标是7到9的存储单元，那在3到6没有完全写入数据之前，7到9的数据是无法读取的。这个也是Disruptor实现思路的一个弊端。</p><p>文字描述不好理解，我画了一个图，给你展示一下这个操作过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/ba/a2c0d268070ed7cc11a5d22eb223f3ba.jpg?wh=1142*856\" alt=\"\"></p><p>实际上，Disruptor采用的是RingBuffer和AvailableBuffer这两个结构，来实现我刚刚讲的功能。不过，因为我们主要聚焦在数据结构和算法上，所以我对这两种结构做了简化，但是基本思想是一致的。如果你对Disruptor感兴趣，可以去阅读一下它的<a href=\"https://github.com/LMAX-Exchange/disruptor\">源码</a>。</p><h2>总结引申</h2><p>今天，我讲了如何实现一个高性能的并发队列。这里的“并发”两个字，实际上就是多线程安全的意思。</p><p>常见的内存队列往往采用循环队列来实现。这种实现方法，对于只有一个生产者和一个消费者的场景，已经足够了。但是，当存在多个生产者或者多个消费者的时候，单纯的循环队列的实现方式，就无法正确工作了。</p><p>这主要是因为，多个生产者在同时往队列中写入数据的时候，在某些情况下，会存在数据覆盖的问题。而多个消费者同时消费数据，在某些情况下，会存在消费重复数据的问题。</p><p>针对这个问题，最简单、暴力的解决方法就是，对写入和读取过程加锁。这种处理方法，相当于将原来可以并行执行的操作，强制串行执行，相应地就会导致操作性能的下降。</p><p>为了在保证逻辑正确的前提下，尽可能地提高队列在并发情况下的性能，Disruptor采用了“两阶段写入”的方法。在写入数据之前，先加锁申请批量的空闲存储单元，之后往队列中写入数据的操作就不需要加锁了，写入的性能因此就提高了。Disruptor对消费过程的改造，跟对生产过程的改造是类似的。它先加锁申请批量的可读取的存储单元，之后从队列中读取数据的操作也就不需要加锁了，读取的性能因此也就提高了。</p><p>你可能会觉得这个优化思路非常简单。实际上，不管架构设计还是产品设计，往往越简单的设计思路，越能更好地解决问题。正所谓“大道至简”，就是这个意思。</p><h2>课后思考</h2><p>为了提高存储性能，我们往往通过分库分表的方式设计数据库表。假设我们有8张表用来存储用户信息。这个时候，每张用户表中的ID字段就不能通过自增的方式来产生了。因为这样的话，就会导致不同表之间的用户ID值重复。</p><p>为了解决这个问题，我们需要实现一个ID生成器，可以为所有的用户表生成唯一的ID号。那现在问题是，如何设计一个高性能、支持并发的、能够生成全局唯一ID的ID生成器呢？</p><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","neighbors":{"left":{"article_title":"53 | 算法实战（二）：剖析搜索引擎背后的经典数据结构和算法","id":79433},"right":{"article_title":"55 | 算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法","id":80388}},"comments":[{"had_liked":false,"id":64660,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1548850135,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"405275775959","product_id":100017301,"comment_content":"尝试回答老师的思考题<br><br>1）分库分表也可以使用自增主键，可以设置增加的步长。8台机器分别从1、2、3。。开始，步长8.<br>     从1开始的下一个id是9，与其他的不重复就可以了。<br>2）上面同学说的redis或者zk应该也能生成自增主键，不过他们的写性能可能不能支持真正的高并发。<br>3）开放独立的id生成服务。最有名的算法应该是snowflake吧。snowflake的好处是基本有序，每秒钟可以生成很大的量，容易水平扩展。<br>    也可以把今天的disrupt用上，用自己生成id算法，提前生成id存入disrupt，预估一下峰值时业务需要的id量，比如提前生成50万；<br>","like_count":95,"discussions":[{"author":{"id":1440429,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/ad/3fa02ac7.jpg","nickname":"星期八","note":"","ucode":"D8C66E7F61B0D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175181,"discussion_content":"第一种方式，如果服务器增加呢，拓展性不强","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1581951511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1795793,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zxkns28cIAUZIt3WjDb8G26qiccT84d9GMr9ZpbYR60TU1ibqSj9NoYVHlJvGF1kOltkqNDmEfJCqPuYVkue3WHg/132","nickname":"Geek_55e386","note":"","ucode":"5A727F1323C2D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1440429,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/ad/3fa02ac7.jpg","nickname":"星期八","note":"","ucode":"D8C66E7F61B0D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380621,"discussion_content":"你可以换个思路啊兄弟. 我可以单独创建一个表, 8条记录, 一条记录给一个表用.每条记录一次申请1000个id. 1-1000这种, 某个机器就是用,用完1000重新申请.\n方式1就是,预处理的想法,一次生产一批,减少并发度.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624608182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":175181,"ip_address":""},"score":380621,"extra":""},{"author":{"id":1795793,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zxkns28cIAUZIt3WjDb8G26qiccT84d9GMr9ZpbYR60TU1ibqSj9NoYVHlJvGF1kOltkqNDmEfJCqPuYVkue3WHg/132","nickname":"Geek_55e386","note":"","ucode":"5A727F1323C2D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1440429,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/ad/3fa02ac7.jpg","nickname":"星期八","note":"","ucode":"D8C66E7F61B0D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380622,"discussion_content":"你换服务器,我最多加一条记录,总体还是减少并发度. 原来每次都竞争,我现在步长设置1000,就是每1000次竞争一次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624608222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":175181,"ip_address":""},"score":380622,"extra":""}]},{"author":{"id":1105916,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DwOtGibgqEK8IHvnV6UzBuWAxUjTuI44lfsOPmHVtb8FpicXuOZlAEuqwHsAM6sHz0XH9UtIiaEnDyAqrgOp4TBHA/132","nickname":"caspar","note":"","ucode":"94CDC83BACA481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353235,"discussion_content":"第一种方式会产生重复ID的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615087989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1795793,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zxkns28cIAUZIt3WjDb8G26qiccT84d9GMr9ZpbYR60TU1ibqSj9NoYVHlJvGF1kOltkqNDmEfJCqPuYVkue3WHg/132","nickname":"Geek_55e386","note":"","ucode":"5A727F1323C2D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1105916,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DwOtGibgqEK8IHvnV6UzBuWAxUjTuI44lfsOPmHVtb8FpicXuOZlAEuqwHsAM6sHz0XH9UtIiaEnDyAqrgOp4TBHA/132","nickname":"caspar","note":"","ucode":"94CDC83BACA481","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380620,"discussion_content":"你可以换个思路啊兄弟. 我可以单独创建一个表, 8条记录, 一条记录给一个表用.每条记录一次申请1000个id. 1-1000这种, 某个机器就是用,用完1000重新申请.\n方式1就是,预处理的想法,一次生产一批,减少并发度.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624608160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":353235,"ip_address":""},"score":380620,"extra":""}]},{"author":{"id":1333649,"avatar":"https://static001.geekbang.org/account/avatar/00/14/59/91/fa2d8bb2.jpg","nickname":"不吃辣👾","note":"","ucode":"B25E0725B5E85F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555233,"discussion_content":"第一种和disruptor方案都是要提前预留空间的解题思路。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646815863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2860883,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/a7/53/ff180c83.jpg","nickname":"方向感","note":"","ucode":"0A59AEC0BF8293","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579439,"discussion_content":"自增主键不行，即使你设置的步长不一样，也可能出现重复。mysql自增主键是递增不连续的，插入一条语句报错情况下自增主键是不会滚的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657449258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2115387,"avatar":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","nickname":"Aibo","note":"","ucode":"2CE3E77BD2D014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550906,"discussion_content":"方式三 如果使用sonwflake可以本地生产id，不需要开发一个id生成器，缺点是只是趋势有序，优点是简单、拓展性强。如果想要全局有序且唯一的id，就开发生成器，提供批量申请的能力，每个服务来一次申请一批id走（disrupt的思路）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644806909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333602,"discussion_content":"同感。这个步长应该怎么设计？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607572367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64525,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1548815371,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"160462605323","product_id":100017301,"comment_content":"没有读过 Disruptor 的源码，从老师的文章理解，一个线程申请了一组存储空间，如果这组空间还没有被完全填满之前，另一个线程又进来，在这组空间之后申请空间并添加数据，之后第一组空间又继续填充数据，那在消费时如何保证队列是按照添加顺序读取的呢？<br><br>即使控制读取时前面不能有空闲空间，是为了保证能按内存空间顺序消费，但是如果生产的时候没有保证顺序存储，似乎就不满足队列的条件了。","like_count":37,"discussions":[{"author":{"id":1265741,"avatar":"https://static001.geekbang.org/account/avatar/00/13/50/4d/392f969b.jpg","nickname":"蒋旺Foo","note":"","ucode":"4325AB9674975C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5006,"discussion_content":"从两个方面解释，①：这里使用队列（数组）主要是从内存分配效率（无需再次分配内存）考虑的；②这里保证的顺序是加入到队列中的顺序，并不能保证与生产者生产的顺序一直。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565870105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249400,"avatar":"https://static001.geekbang.org/account/avatar/00/13/10/78/29bd3f1e.jpg","nickname":"王子瑞Aliloke有事电联","note":"","ucode":"9ABE8E475E336B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340351,"discussion_content":"一次申请多少，根据业务场景来调整。申请多了，会影响消费端速度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609984324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333680,"discussion_content":"第一个问题：是按照队列顺序读取，不是按照添加顺序读取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607592256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364248,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d1/18/5cc21f63.jpg","nickname":"万里国度","note":"","ucode":"9B47C4E69DAC8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311719,"discussion_content":"去阅读源码吧，里面有读取得时候得等待策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602471786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96627,"discussion_content":"预申请空间，多了的话，会导致内存浪费吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577081499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341210,"discussion_content":"控制每个线程可以申请的存储单元数量和线程池中线程数量来保证？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610351774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96627,"ip_address":""},"score":341210,"extra":""}]}]},{"had_liked":false,"id":253319,"user_name":"ɴɪᴋᴇʀ","can_delete":false,"product_type":"c1","uid":1616622,"ip_address":"","ucode":"DB7D92CBB5FD15","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","comment_is_top":false,"comment_ctime":1602682790,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"139041636262","product_id":100017301,"comment_content":"我看到很多读者对文中这段话”3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的“这句话都不是理解，我仔细看了下disruptor的设计方案，统一来回答一下：<br>每个线程都是一个生产者。对于其中一个生产者申请写入n个元素，则返回列队中对应的最大下标位置(比如当前申请写入3个，从下标3开始，返回的最大下标就是6)，456就是这个生产者所申请到的独享空间。生产者同时会带有一个标记，记录当前写入成功的下标(比如当前写入到5，标记的值就为5，用来标记自身是否全部写入完成)，这是对于单独的一个生产者。对于多个生产者来说，都是如此的，比如有两个生产者，A申请了456，B申请了789，此时A写入到了5，A的标记是5，B写入到了8，B的标记是8，队列中对应6和9的位置是没有数据的。这样是没有问题的，此刻暂停，来看下多消费者同时读数据。消费者A*申请到读取3个元素，消费中B*申请读到了3个元素，那么要申请的连续最大元素个数就是6，对应此刻的下标就是9，这里会触发disruptor的设计机制，从3开始，会依次检测对位置的元素是否生产成功，此刻这里A写到了5，B写到了8，6位置还没有生产成功的，那么机制就会返回可消费的最大下标，也就是5，然后消费者只会读取下标4到5两个元素进行消费。也就是文中小争哥所说的”3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的“-&gt;其实就是disruptor找到了还没有生产出的元素，后面的数据都是无法读取的，其实很简单。不知道这里的解释看懂了没有，有兴趣的话可以自己去看下disruptor的设计实现，而且图片会比文字更加直观。","like_count":33,"discussions":[{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b85dce85.jpg","nickname":"无尽蔚蓝","note":"","ucode":"A665DF46833A81","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586444,"discussion_content":"感谢大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662218403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2223379,"avatar":"https://static001.geekbang.org/account/avatar/00/21/ed/13/5c75a98b.jpg","nickname":"乌呼啦呼","note":"","ucode":"D6B407EB222410","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579167,"discussion_content":"类似kafka ISR的思想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657213026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2821728,"avatar":"","nickname":"600988292","note":"","ucode":"24BAE2B7A7B1E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530401,"discussion_content":"3，4 有数据，5没有数据，7，8 有数据，9没有数据，按照队列来看，消费者从3读到5过程中，3、4可以读取，5认为是没有的，所有就不继续往下读取了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637067994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475327,"avatar":"https://static001.geekbang.org/account/avatar/00/16/82/ff/3672e7e9.jpg","nickname":"Arthur","note":"","ucode":"968C4E50FCCE4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389203,"discussion_content":"那两个消费者时如何读取的那？消费者A只能读456，消费者B只能读789？那这样有并发吗，B一直卡着，因为不能读只能等A写满。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629178025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2394828,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Zf6QpbNWica3Wh3WgRANGRJ0G3ibQPAUxZQ5JeERE1nXgnGnmOnpET2OxLjuJjGf7mdIJrbADlgicZ2xvqjk8EEYg/132","nickname":"EMONova","note":"","ucode":"DC1537A579E0A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385698,"discussion_content":"感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627215931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311315,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLW8JDURuH8rWWd4kibR9ibsehbiaERqBJIP20GDJfZjaRlGQQVqw6780NTxrfxBujrzQvBnIcrmfkCg/132","nickname":"gibson1112","note":"","ucode":"51CF21A78A35C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364816,"discussion_content":"说的很细了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617615843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64473,"user_name":"想当上帝的司机","can_delete":false,"product_type":"c1","uid":1239378,"ip_address":"","ucode":"D8251388854911","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/52/f07e9001.jpg","comment_is_top":false,"comment_ctime":1548809087,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"91743122303","product_id":100017301,"comment_content":"为什么3到6没有完全写入前，7到9无法读取，不是两个写入操作吗","like_count":21,"discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40600,"discussion_content":"队列是先进先出，依赖的是数据在队列中的位置，每次获取队列最后一个数据，所以必须等队列数据完整后才能真正确定最后一个数据","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1572242952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269170,"discussion_content":"先进先出不应该是每次获取队列的第一个数据吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589874587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40600,"ip_address":""},"score":269170,"extra":""},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269333,"discussion_content":"初始队列为空（链表实现）\n按顺序入队：1 2 3\n队列的内容：1 2 3 头->尾\n出队的操作：弹出队首元素 1 队列变 2 3\n出队的操作：弹出队首元素 2 队列变 3\n是这样吧？\n\n留言中看不到是哪篇文章！不知道上下文……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589895442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269170,"ip_address":""},"score":269333,"extra":""},{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269923,"discussion_content":"高性能队列disruptor这篇专栏文章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589963081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269333,"ip_address":""},"score":269923,"extra":""}]},{"author":{"id":1234221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/2d/bd28a5bc.jpg","nickname":"葵花老师傅","note":"","ucode":"367FDEA57C675B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4758,"discussion_content":"上边好几次内容没写完就被发出去了。抱歉～\n我觉得是有两点\n1.在申请空闲空间的时候需要加锁，这个时候生产者A还没生产完空间就被B锁住生产不下去\n2.这种情况可能出现：生产者A申请的3到6空间，然后在写入的过程中刚好写入到4的时候，生产者B发现5到7可用就申请了这块儿空间开始写入，可能出现数据重复的情况（这个得看一下对空闲存储单元的设定）","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1565705171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1602652,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzSRrK59sydlOmgvqIFm1pjHA55RcM5ttWvHdOZyibZhFCr7picy4Xf5Bf9dLOW8d2DGUwA1zormzw/132","nickname":"钱勇","note":"","ucode":"BA2796F17E54E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190408,"discussion_content":"也有这个疑问，7-9还没写呢，怎么就开始读了？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582941709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047968,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/a0/1367112b.jpg","nickname":"bayannamor","note":"","ucode":"BF3092D6DEFE0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282031,"discussion_content":"需要顺序读数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591864639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269159,"discussion_content":"同没看懂这句。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589873330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/2d/bd28a5bc.jpg","nickname":"葵花老师傅","note":"","ucode":"367FDEA57C675B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4748,"discussion_content":"我觉得是因为加了锁，因为每次都要从空闲的空间占用一定的空间，为了避免这次占用3到6在写入过程中又有一个要往4到7读取写入吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565704070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65798,"user_name":"郭小菜","can_delete":false,"product_type":"c1","uid":1017297,"ip_address":"","ucode":"C4044C80BB331B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYfcUOVhf3vhEBUNGHgtIcw8ujMZnkabicLzzjn3xwdeeic2PJSe7ibJgMx2UjF0d7L4B4gsRpaqe2A/132","comment_is_top":false,"comment_ctime":1549648515,"is_pvip":true,"replies":[{"id":"24287","content":"你说的没错。这节课有点不详细，我抽空重新补充下。抱歉。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550542111,"ip_address":"","comment_id":65798,"utype":1}],"discussion_count":7,"race_medal":0,"score":"61679190659","product_id":100017301,"comment_content":"一直追老师的课程，每期的质量都很高，收获很多。但是这期确实有点虎头蛇尾，没有把disruptor的实现原理讲得特别明白。不是讲得不好，只是觉得结尾有点突兀，信息量少了。但是瑕不掩瑜，老师的课程总体质量绝对是杠杠的！","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438592,"discussion_content":"你说的没错。这节课有点不详细，我抽空重新补充下。抱歉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2449060,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","nickname":"Geek_sz","note":"","ucode":"72E86D7D6554CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":576449,"discussion_content":"挺多节都这样，这节又是说了就是做了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655558076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":438592,"ip_address":""},"score":576449,"extra":""},{"author":{"id":1086413,"avatar":"https://static001.geekbang.org/account/avatar/00/10/93/cd/dbafc7d1.jpg","nickname":"全麦小面包","note":"","ucode":"823C65BF366097","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":581492,"discussion_content":"老师，我想看disruptor的next方法详解。何时补充下哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658813621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":438592,"ip_address":""},"score":581492,"extra":""}]},{"author":{"id":2449060,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","nickname":"Geek_sz","note":"","ucode":"72E86D7D6554CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576450,"discussion_content":"就很拉垮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655558114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1163383,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c0/77/d05c6abd.jpg","nickname":"0273522","note":"","ucode":"B04365B8FC27AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412208,"discussion_content":"这节课依然很空。。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636103813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1940562,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/9c/52/dc770378.jpg","nickname":"yang","note":"","ucode":"67C86E09BA6E4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380759,"discussion_content":"所以王老师补充了吗？今天我们看到的是补充后的内容吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624689059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1175140,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ee/64/55adb692.jpg","nickname":" 海大","note":"","ucode":"03D1013FBE6047","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318494,"discussion_content":"这街课还是有点空","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603765181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64510,"user_name":"Keep-Moving","can_delete":false,"product_type":"c1","uid":1182631,"ip_address":"","ucode":"76F33C06E07A27","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","comment_is_top":false,"comment_ctime":1548814004,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"61678356148","product_id":100017301,"comment_content":"思考题：加锁批量生成ID，使用时就不用加锁了","like_count":14,"discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311255,"discussion_content":"哈哈哈 mysql申请自增id就是这么。。先申请，申请的时候加锁，申请完了释放锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602291883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027203,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/83/4c1a18de.jpg","nickname":"🐻🐻","note":"","ucode":"424120B74390CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290208,"discussion_content":"这里的锁，建议用CAS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594377369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84981,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1554951738,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"48799591994","product_id":100017301,"comment_content":"项目中有使用过分布式id生成器，但是不知道具体是怎么实现的，参考今天的Disruptor的思路：<br>1. id生成器相当于一个全局的生产者，可以提前生成一批id<br>2. 对于每一张表，可以类似于Disruptor的消费者思路，从id生成器中申请一批id，用作当前表的id使用，当然申请一批id对于id生成器来说是需要加锁操作的","like_count":11,"discussions":[{"author":{"id":1393323,"avatar":"https://static001.geekbang.org/account/avatar/00/15/42/ab/75fb1cd6.jpg","nickname":"Tim","note":"","ucode":"A3ECD9832D630D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5178,"discussion_content":"请问disruptor是这样实现的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566029392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99566,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1559261461,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"44508934421","product_id":100017301,"comment_content":"后面有补充这门课的内容吗？我看到老师回复说会补充，为何没有在评论区中反馈呢？对后面学习这门课的学生很困惑啊<br><br>“生产者申请连续空间后，后续往队列添加元素就不需要加锁了，因为这个存储单元是这个线程独享的”<br><br>这个不好理解，添加元素的不是有可能多个线程吗？那不是会产生竞争资源吗？<br><br>希望得到解惑<br><br>","like_count":10,"discussions":[{"author":{"id":1133055,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","nickname":"4567890","note":"","ucode":"23BC97FD1DADF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325669,"discussion_content":"这是其实就是java里面的线程串行封闭～\n这种情况下，只要对象被正确的创建并安全吧控制权交给数组（队列）就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605401603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311256,"discussion_content":"—— ——！如果阳仔是学java的话，可以仔细看下虚拟机栈与堆的区别。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602291920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1850499,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/3c/83/93e7af9e.jpg","nickname":"兰柯","note":"","ucode":"6D7230B3CE8722","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181330,"discussion_content":"这个就是操作系统的问题了，每个进程/线程都有自己的地址空间，不同的进程不能访问其他进程的私有地址空间，这个操作系统会做保证，比如说虚拟地址的界地址寄存器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582361463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70007,"user_name":"彳","can_delete":false,"product_type":"c1","uid":1101973,"ip_address":"","ucode":"5ACE4746E2913B","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/95/f3283c31.jpg","comment_is_top":false,"comment_ctime":1550933749,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44500606709","product_id":100017301,"comment_content":"disruptor使用环的数据结构，内存连续，初始化时就申请并设置对象，将原本队列的头尾节点锁的争用转化为cas操作，并利用Java对象填充，解决cache line伪共享问题","like_count":10,"discussions":[{"author":{"id":2127651,"avatar":"https://static001.geekbang.org/account/avatar/00/20/77/23/05086907.jpg","nickname":"涛","note":"","ucode":"DF7EADC7606033","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381720,"discussion_content":"我看的也是这样的原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625192995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64530,"user_name":"belongcai蔡炳榕","can_delete":false,"product_type":"c1","uid":1047677,"ip_address":"","ucode":"2196D413FEABA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/7d/800888a3.jpg","comment_is_top":false,"comment_ctime":1548815719,"is_pvip":false,"replies":[{"id":"24183","content":"这节课我抽空再补充下。不好意思。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550480271,"ip_address":"","comment_id":64530,"utype":1}],"discussion_count":3,"race_medal":0,"score":"44498488679","product_id":100017301,"comment_content":"看完还是有很多困惑（可能跟我不了解线程安全有关）<br>一是申请一段连续存储空间，怎么成为线程独享的呢？生产者ab分别申请后，消费者为啥无法跨区域读取呢<br>二是这种方法应该是有实验证明效率高的，私下去了解下。","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438051,"discussion_content":"这节课我抽空再补充下。不好意思。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550480271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2449060,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","nickname":"Geek_sz","note":"","ucode":"72E86D7D6554CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":576451,"discussion_content":"快补吧，我真的会谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1655558176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":438051,"ip_address":""},"score":576451,"extra":""}]},{"author":{"id":1084993,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","nickname":"袁帅","note":"","ucode":"A71A89B9F1BD69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429,"discussion_content":"这节课最后有补课吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1561546143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73798,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1552004356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31616775428","product_id":100017301,"comment_content":"雪花算法可以根据不同机子生成不同的id","like_count":7},{"had_liked":false,"id":85424,"user_name":"futute","can_delete":false,"product_type":"c1","uid":1243990,"ip_address":"","ucode":"B527A16B46EE92","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRicmicHclt9KDXCVbqjQVYEtibs4mWcsd13Z1ibqPNb1dSkNAu6Znfak0nyUibOvRD07UfZw/132","comment_is_top":false,"comment_ctime":1555058069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27324861845","product_id":100017301,"comment_content":"弱弱地问一下，后来老师补充过这节课的内容吗？我看完后，跟以前留言的同学有相同的感觉。<br>","like_count":6},{"had_liked":false,"id":164794,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1577092520,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23051929000","product_id":100017301,"comment_content":"感觉Disruptor 其实就是把锁的粒度减小了,原来只要写入和读取都得加锁,锁的是整个数组,现在是只锁数组中的某组连续的下标<br>","like_count":6},{"had_liked":false,"id":64511,"user_name":"M.Y","can_delete":false,"product_type":"c1","uid":1238648,"ip_address":"","ucode":"C195A80BD1270F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/78/3ee39415.jpg","comment_is_top":false,"comment_ctime":1548814075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23023650555","product_id":100017301,"comment_content":"课后思考。 <br>如果不是分布式应用：<br>1.用JDK自带的AtomicLong<br>2.用Oracle数据库中的Sequence<br>如果是分布式应用：<br>1.用zookeeper生成全局ID<br>2.用Redis中的Redlock 生产全局ID","like_count":5},{"had_liked":false,"id":78112,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1553072710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18732941894","product_id":100017301,"comment_content":"__sync_fetch_and_add操作即可实现原子自增的操作。","like_count":4},{"had_liked":false,"id":64502,"user_name":"神盾局闹别扭","can_delete":false,"product_type":"c1","uid":1006804,"ip_address":"","ucode":"0255AEB1EE73FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/d4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1548813405,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18728682589","product_id":100017301,"comment_content":"有个问题，按照老师所说，a线程只写1-3区块，b线程只写4-6块，假设a线程先写了块1，切换到线程b，b写块4，然后再切回线程a，a写块2。虽然没有数据覆盖问题，但是最终块1-6的顺序不是按写入先后顺序排布的，读取不是乱套了吗，怎么解决这个问题？求老师能说的详细点。","like_count":4,"discussions":[{"author":{"id":1391354,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3a/fa/21f64eaa.jpg","nickname":"mimof9","note":"","ucode":"C83B3E2CD62BBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350353,"discussion_content":"并发线程的执行顺序本来就是不一定的，所以用了并发的业务场景：生产数据的顺序和读取数据的顺序应该不需要一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613820189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64465,"user_name":"K战神","can_delete":false,"product_type":"c1","uid":1139367,"ip_address":"","ucode":"527E6BB26BB766","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/a7/3e6fee86.jpg","comment_is_top":false,"comment_ctime":1548808021,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18728677205","product_id":100017301,"comment_content":"而是采用了“当队列满了之后，生产者就轮训等待；当队列空了之后，消费者就轮训等待”这样的措施。～是不是有错别字？轮询？","like_count":4,"discussions":[{"author":{"id":1024164,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","nickname":"阿斯蒂芬","note":"","ucode":"61D5E3BDA4EBC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278931,"discussion_content":"这么久了，编辑也没改过来。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591260650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177020,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1581250363,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"14466152251","product_id":100017301,"comment_content":"Disruptor是一种内存消息队列，功能上类似 Kafka， 不同的是Disruptor 是线程之间用于消息传递的队列。在 Apache Storm、Camel、Log4j 2 等很多知名项目中都有广泛应用。<br><br>它的性能表现非常优秀，比 Java 中另一个非常常用的内存消息队列 ArrayBlockingQueue（ABS）的性能，要高一个数量级，可以算得上是最快的内存消息队列。<br><br>Disruptor 是如何做到如此高性能的？其底层依赖了哪些数据结构和算法？<br><br>基于循环队列的“生产者 - 消费者模型”<br>“生产者 - 消费者模型”，“生产者”生产数据，并且将数据放到一个中心存储容器中。“消费者”从中心存储容器中，取出数据消费。<br><br>实现中心存储容器的数据结构是队列。队列支持数据的先进先出，使得数据被消费的顺序性可以得到保证<br><br>队列有两种实现思路。一种是基于链表实现的链式队列，另一种是基于数组实现的顺序队列<br><br>如果实现一个无界队列，适合选用链表来实现队列，因为链表支持快速地动态扩容<br><br>相较于无界队列，有界队列的应用场景更加广泛。机器内存是有限的，无界队列占用的内存数量是不可控的，有可能因为内存持续增长，而导致 OOM（Out of Memory）错误。<br><br>循环队列是一种特殊的顺序队列。非循环的顺序队列在添加、删除数据时涉及数据的搬移操作，导致性能变差。而循环队列可以解决数据搬移问题，所以性能更加好。所以大部分用顺序队列中的循环队列。<br><br>循环队列这种数据结构，就是内存消息队列的雏形<br><br>基于加锁的并发“生产者 - 消费者模型”<br>在多个生产者或者多个消费者并发操作队列的情况下，主要会有下面两个问题：<br><br>多个生产者写入的数据可能会互相覆盖；<br>多个消费者可能会读取重复的数据。<br><br>如何解决这种线程并发往队列中添加数据时，导致的数据覆盖、运行不正确问题？<br><br>最简单的处理方法就是给代码加锁，同一时间只允许一个线程执行 add() 函数，由并行改成了串行<br><br><br><br>Disruptor 的基本思想是换了一种队列和“生产者 - 消费者模型”的实现思路。<br>\t* 生产者：往队列中添加数据之前，先批量地申请连续的 n 个（n≥1）可用空闲存储单元。这组存储单元是这个线程独享的，后续往队列中添加元素可以不用加锁了。申请存储单元的过程是需要加锁的<br><br>\t* 消费者：处理的过程跟生产者是类似的。先申请一批连续可读的存储单元（申请的过程也是要加锁），当申请到这批存储单元之后，后续的读取操作就不加锁<br><br>\t* Disruptor 实现思路的一个弊端：如果生产者 A 申请到了一组连续的存储单元，假设是下标为 3 到 6 的存储单元，生产者 B 紧跟着申请到了下标是 7 到 9 的存储单元，在 3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的<br><br>\t* Disruptor 采用的是 RingBuffer 和 AvailableBuffer 这两个结构，来实现功能<br><br>总结引申<br><br>\t* 多个生产者同时往队列中写入数据时，存在数据覆盖的问题。多个消费者同时消费数据，会存在消费重复数据的问题<br>\t* 为了保证逻辑正确，尽可能地提高队列在并发情况下的性能，Disruptor 采用了“两阶段写入”的方法。<br>\t* 在写入数据之前，先加锁申请批量的空闲存储单元，之后往队列中写入数据的操作就不需要加锁了，写入的性能因此就提高了<br>\t* Disruptor 对消费过程的改造，跟对生产过程的改造是类似的。它先加锁申请批量的可读取的存储单元，之后从队列中读取数据的操作也就不需要加锁了，读取的性能因此也就提高了<br><br>","like_count":3,"discussions":[{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303044,"discussion_content":"get","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599120661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154733,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1574525213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459427101","product_id":100017301,"comment_content":"我们用的百度的uid生成器，底层是雪花算法，有那么几段规则，根据机器ip和时间进行唯一性","like_count":4},{"had_liked":false,"id":67530,"user_name":"cn","can_delete":false,"product_type":"c1","uid":1216011,"ip_address":"","ucode":"0A6DCBC2B09819","user_header":"https://static001.geekbang.org/account/avatar/00/12/8e/0b/89055f4c.jpg","comment_is_top":false,"comment_ctime":1550193564,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14435095452","product_id":100017301,"comment_content":"申请了一段空间之后，只有写完才能够读取这段空间和后续空间，如果生产者挂了，是不是读取就阻塞了？","like_count":4,"discussions":[{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252333,"discussion_content":"同问，不过我感觉应该有时效性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588156325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272676,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1610199100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5905166396","product_id":100017301,"comment_content":"这种方式本质是让临界区变小。 再一个就是批量。","like_count":2},{"had_liked":false,"id":253318,"user_name":"ɴɪᴋᴇʀ","can_delete":false,"product_type":"c1","uid":1616622,"ip_address":"","ucode":"DB7D92CBB5FD15","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/ee/15c328ca.jpg","comment_is_top":false,"comment_ctime":1602682581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897649877","product_id":100017301,"comment_content":"我看到很多读者对文中这段话”3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的“这句话都不是理解，我仔细看了下disruptor的设计方案，统一来回答一下：<br>每个线程都是一个生产者。对于其中一个生产者申请写入n个元素，则返回列队中对应的最大下标位置(比如当前申请写入3个，从下标3开始，返回的最大下标就是6)，456就是这个生产者所申请到的独享空间。生产者同时会带有一个标记，记录当前写入成功的下标(比如当前写入到5，标记的值就为5，用来标记自身是否全部写入完成)，这是对于单独的一个生产者。对于多个生产者来说，都是如此的，比如有两个生产者，A申请了456，B申请了789，此时A写入到了5，A的标记是5，B写入到了8，B的标记是8，队列中对应6和9的位置是没有数据的。这样是没有问题的，此刻暂停，来看下多消费者同时读数据。消费者A*申请到读取3个元素，消费中B*申请读到了3个元素，那么要申请的连续最大元素个数就是6，对应此刻的下标就是9，这里会触发disruptor的设计机制，从3开始，会依次检测对位置的元素是否生产成功，此刻这里A写到了5，B写到了8，6位置还没有生产成功的，那么机制就会返回可消费的最大下标，也就是5，然后消费者只会读取下标4到5两个元素进行消费。也就是文中小争哥所说的”3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的“-&gt;其实就是disruptor找到了还没有生产出的元素，后面的数据都是无法读取的，其实很简单。不知道这里的解释看懂了没有，有兴趣的话可以自己去看下disruptor的设计实现，而且图片会比文字更加直观。","like_count":2},{"had_liked":false,"id":229000,"user_name":"Run","can_delete":false,"product_type":"c1","uid":1371941,"ip_address":"","ucode":"6738D2F36ACFF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLMDBq7lqg9ZasC4f21R0axKJRVCBImPKlQF8yOicLLXIsNgsZxsVyN1mbvFOL6eVPluTNgJofwZeA/132","comment_is_top":false,"comment_ctime":1592877456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887844752","product_id":100017301,"comment_content":"如果对disruptor还有疑问的可以看看这个https:&#47;&#47;tech.meituan.com&#47;2016&#47;11&#47;18&#47;disruptor.html","like_count":1},{"had_liked":false,"id":218788,"user_name":"李润东","can_delete":false,"product_type":"c1","uid":1972505,"ip_address":"","ucode":"65CFEA3C8B27C4","user_header":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","comment_is_top":false,"comment_ctime":1589875446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884842742","product_id":100017301,"comment_content":"实在是理解不了这句：3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的。。。","like_count":1},{"had_liked":false,"id":64595,"user_name":"Victor","can_delete":false,"product_type":"c1","uid":1003903,"ip_address":"","ucode":"801413B2B5C7B5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/7f/c74e3543.jpg","comment_is_top":false,"comment_ctime":1548832246,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5843799542","product_id":100017301,"comment_content":"课后问题：设计高性能、支持并发的全局唯一ID生成器<br>使用Redis生成全局唯一ID<br>1、 redis Incr为原子操作，支持并发<br>2、redis基于内存，性能较高","like_count":1,"discussions":[{"author":{"id":1593289,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","nickname":"编程界的小学生","note":"","ucode":"4A5BE9A5E877FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56923,"discussion_content":"redis宕机或者数据被不小心清了那岂不是要重头来过？不靠谱也不安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574525134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64498,"user_name":"Jamin","can_delete":false,"product_type":"c1","uid":1236792,"ip_address":"","ucode":"0449B773FE4D21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhyK1QiaqyNox3wr3GmBibziau9pPDxN5HjYBpYCd7ytDmLNtJ1cKKaq2WYFF3jpRSg6638M8NFDf2w/132","comment_is_top":false,"comment_ctime":1548812791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843780087","product_id":100017301,"comment_content":"那在 3 到 6 没有完全写入数据之前，是想说3到6的数据无法被读取吧？","like_count":1},{"had_liked":false,"id":64476,"user_name":"1024","can_delete":false,"product_type":"c1","uid":1086407,"ip_address":"","ucode":"DCC31F6EC54F43","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","comment_is_top":false,"comment_ctime":1548809344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843776640","product_id":100017301,"comment_content":"即使3-6完全写入了，7-9也不一定可以消费吧，如果此时7-9没有完全写入，也不会释放锁啊。7-9无法消费是因为生产者B拿到了写锁吧，和生产者A释不释放3-6的锁没有关系吧<br>————————————————————<br>个人理解，请老师指正","like_count":1},{"had_liked":false,"id":64469,"user_name":"沉睡的木木夕","can_delete":false,"product_type":"c1","uid":1036362,"ip_address":"","ucode":"2C6B23B34C44E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/4a/7e3d158d.jpg","comment_is_top":false,"comment_ctime":1548808311,"is_pvip":false,"replies":[{"id":"24186","content":"这节课我重新补充下，不好意思。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550480516,"ip_address":"","comment_id":64469,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843775607","product_id":100017301,"comment_content":"还是没说加存储单元是干嘛的啊，为什么在往队列添加元素之前申请存储单元就不用加锁了？能说的在详细点么","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438015,"discussion_content":"这节课我重新补充下，不好意思。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550480516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354081,"user_name":"Geek_648c53","can_delete":false,"product_type":"c1","uid":2655964,"ip_address":"广东","ucode":"51F87D92B3BD05","user_header":"https://static001.geekbang.org/account/avatar/00/28/86/dc/be1b17d8.jpg","comment_is_top":false,"comment_ctime":1660086922,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660086922","product_id":100017301,"comment_content":"这个思想和kafka有点类似呀","like_count":0},{"had_liked":false,"id":339768,"user_name":"恬毅","can_delete":false,"product_type":"c1","uid":1015240,"ip_address":"","ucode":"914ED16F3BE714","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg","comment_is_top":false,"comment_ctime":1648371069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648371069","product_id":100017301,"comment_content":"思考题：<br>1、单独的id服务器，可以集群，后面是个数据库，有请求过来加锁，每次返回一个范围，比如原始id为1，有个请求生成100个，那就返回1,100，同时本地的原始id变成101。这样子通过批量的方式，减少请求的次数<br>2、单独服务内部维护一个id生成的类，加锁，内部需要生成id的时候就访问这个id生成类，id生成类如果用完了，就会去总服务器获取，一次获取一定的数量，用完再取（可以有个定时任务，定期检查，然后小于一个水位就去总服务器请求）<br>3、如果量很大还可以有分多级，比如国家到省份到市","like_count":0},{"had_liked":false,"id":310651,"user_name":"预见","can_delete":false,"product_type":"c1","uid":2147124,"ip_address":"","ucode":"4A68569D83EF7A","user_header":"https://static001.geekbang.org/account/avatar/00/20/c3/34/58426785.jpg","comment_is_top":false,"comment_ctime":1630824189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630824189","product_id":100017301,"comment_content":"生产环境中使用过disrupter,的确性能很高，而且编程方便","like_count":0},{"had_liked":false,"id":298533,"user_name":"颜桦","can_delete":false,"product_type":"c1","uid":1099576,"ip_address":"","ucode":"1CD7250E052B32","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/38/d1a50cd6.jpg","comment_is_top":false,"comment_ctime":1624179972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624179972","product_id":100017301,"comment_content":"分批加锁只不过是从原来每个都锁一次变成了每一批锁一次，老师是不是这样的","like_count":0},{"had_liked":false,"id":292569,"user_name":"Geek_wsdllll","can_delete":false,"product_type":"c1","uid":2036524,"ip_address":"","ucode":"3F5F644D40982B","user_header":"","comment_is_top":false,"comment_ctime":1620881055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620881055","product_id":100017301,"comment_content":"相对于把锁的粒度变大了 减小冲突概率","like_count":0},{"had_liked":false,"id":289092,"user_name":"Zicheng","can_delete":false,"product_type":"c1","uid":2007101,"ip_address":"","ucode":"3B27E44A98FF99","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a0/3d/b6379573.jpg","comment_is_top":false,"comment_ctime":1618864473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618864473","product_id":100017301,"comment_content":"老师那个简单代码用%size的方式是对的吗？ 好像会导致size-1这个位置怎么都put不进去东西 比如size为1的时候 head和tail怎么计算都为0啊. 请老师指正！","like_count":0},{"had_liked":false,"id":283300,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1615698347,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1615698347","product_id":100017301,"comment_content":"看到19年的留言说把这节课补一下，啥时候补啊？老师，这节课讲的比较表面啊","like_count":0},{"had_liked":false,"id":257835,"user_name":"王世林","can_delete":false,"product_type":"c1","uid":1076155,"ip_address":"","ucode":"2BB56D0FD71417","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/bb/10aaf123.jpg","comment_is_top":false,"comment_ctime":1604150331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604150331","product_id":100017301,"comment_content":"解决思路类似于ConcurrentHashMap 16个分段锁，可以搞个final ReentrentLock数组，大小为8.对要插入的数据按照某种规则对8取余，看下插入哪个分表中，然后获取对应下标的锁即可","like_count":1},{"had_liked":false,"id":249883,"user_name":"Daemon","can_delete":false,"product_type":"c1","uid":2200995,"ip_address":"","ucode":"144164E443AF99","user_header":"https://static001.geekbang.org/account/avatar/00/21/95/a3/465a50d9.jpg","comment_is_top":false,"comment_ctime":1600842854,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1600842854","product_id":100017301,"comment_content":"这里我觉得提前申请空间从字面理解和加锁没有什么区别，提前申请空间也是需要等待的，加锁也是等待，只能说这个提前申请的策略比普通的加锁更巧妙，但是我看了文章，没看到这个策略关键的地方，这也是我迷惑的地方，只能查其他资料了","like_count":0,"discussions":[{"author":{"id":1249400,"avatar":"https://static001.geekbang.org/account/avatar/00/13/10/78/29bd3f1e.jpg","nickname":"王子瑞Aliloke有事电联","note":"","ucode":"9ABE8E475E336B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340353,"discussion_content":"原来的加锁是每次写需要申请空间，写值加锁。\n优化后是可以一次申请一批，类比io中的buffer，从多次加锁变为一次加锁，性能提高了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609984474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237268,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1595760496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595760496","product_id":100017301,"comment_content":"把ID生成器看成是一个生产者，各个用户表看成是消费者，借用Disruptor对“生产者-消费者”模型的处理思想，每当一个用户表在申请ID时，就一次性连续申请多个连续的ID，这些连续的ID都归申请者独享，这样当表中有新记录产生时，不需要再从ID生成器中去申请，从而避免了对ID生产器进行加锁，<br>但在申请连续ID的过程中还是需要对生成器进行加锁，这样多个表都可以并行、高效地申请ID。","like_count":0},{"had_liked":false,"id":221481,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1590505528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590505528","product_id":100017301,"comment_content":"启动多个线程(生产者)产生不同的id，如8个线程，线程号分别为1-8，每个线程只生产线程号+n*8的id，如1号线程生产1、9、17…，2号线程生产2、10、18…。每个线程将id放入Disruptor内存队列中。消费者从Disruptor中获取id进行分配。","like_count":0},{"had_liked":false,"id":217135,"user_name":"renwotao","can_delete":false,"product_type":"c1","uid":1042503,"ip_address":"","ucode":"8054CA7EC0C8AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/47/3e4a03ac.jpg","comment_is_top":false,"comment_ctime":1589424497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589424497","product_id":100017301,"comment_content":"申请一个连续存储后连续写多个单元，这时如果有消费者刚要消费这块内存时，应该是不行的","like_count":0},{"had_liked":false,"id":216250,"user_name":"社会你强哥","can_delete":false,"product_type":"c1","uid":1243570,"ip_address":"","ucode":"325B9005588D9B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","comment_is_top":false,"comment_ctime":1589209701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589209701","product_id":100017301,"comment_content":"1. 弄一个全局的ID生成器，每次生成ID的时候加锁，这样就可以保证ID自增的时候不会没有执行到，导致生成的ID重复。","like_count":0},{"had_liked":false,"id":212581,"user_name":"恋雪","can_delete":false,"product_type":"c1","uid":1185590,"ip_address":"","ucode":"B0D8870130A314","user_header":"https://static001.geekbang.org/account/avatar/00/12/17/36/ece951b4.jpg","comment_is_top":false,"comment_ctime":1588155867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588155867","product_id":100017301,"comment_content":"老师说：“如果生产者 A 申请到了一组连续的存储单元，假设是下标为 3 到 6 的存储单元，生产者 B 紧跟着申请到了下标是 7 到 9 的存储单元，那在 3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的”。7到9的数据无法读取，是不是有误，应该是7到9间的存储单元也无法存储数据？","like_count":0},{"had_liked":false,"id":209357,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1587540552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587540552","product_id":100017301,"comment_content":"disruptor 实现的思路是，使用循环队列。数据插入和取出之前都通过枷锁申请连续的内存空间，所以数据的添加和取出的性能比较高。","like_count":0},{"had_liked":false,"id":207364,"user_name":"Geek_d142f6","can_delete":false,"product_type":"c1","uid":1783608,"ip_address":"","ucode":"DFC61440374E79","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ryl35QN5UMAtDW4akGRyMzXEOzjXzTaXD9Tvf0M8mEvf7Kds5u8b9RvFul8oItBib8icrhyOy1xWXVDqDbicWu3nQ/132","comment_is_top":false,"comment_ctime":1587056220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587056220","product_id":100017301,"comment_content":"求救，正在实现高性能id生成器，要生成32bit的数字，怎么做？","like_count":0},{"had_liked":false,"id":204592,"user_name":"-_-|||","can_delete":false,"product_type":"c1","uid":1328142,"ip_address":"","ucode":"94B21594658BF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/0e/ce14b7d3.jpg","comment_is_top":false,"comment_ctime":1586425819,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586425819","product_id":100017301,"comment_content":"批量产生大量id，加锁。每张表轮训去申请id。","like_count":0},{"had_liked":false,"id":203501,"user_name":"夜空咏叹调","can_delete":false,"product_type":"c1","uid":1189074,"ip_address":"","ucode":"CC9350BCF218CD","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d2/a5e272ce.jpg","comment_is_top":false,"comment_ctime":1586222438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586222438","product_id":100017301,"comment_content":"Disruptor队列其实是把正常的消息队列里面的阻塞队列替换成了循环队列，减少了队列动态扩容的消耗，同时保证了数据读写的效率，然后对于避免并发的影响，一般会选择加锁，而锁一般是加在生产和消费两个环节，Disruptor队列则是选择在申请空间的时候去加锁，这样并发粒度不会很高，从而一定程度上减少了开销。","like_count":0},{"had_liked":false,"id":201705,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585821594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585821594","product_id":100017301,"comment_content":"雪花算法。一层层划分：机房-&gt;服务器-&gt;...","like_count":1},{"had_liked":false,"id":195794,"user_name":"thinker","can_delete":false,"product_type":"c1","uid":1107762,"ip_address":"","ucode":"1D9ECA03A28931","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/32/82939538.jpg","comment_is_top":false,"comment_ctime":1585215455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585215455","product_id":100017301,"comment_content":"rocketmq是怎么解决生产者并发生产消息时的并发问题的呢？<br>","like_count":0},{"had_liked":false,"id":195790,"user_name":"thinker","can_delete":false,"product_type":"c1","uid":1107762,"ip_address":"","ucode":"1D9ECA03A28931","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/32/82939538.jpg","comment_is_top":false,"comment_ctime":1585215281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585215281","product_id":100017301,"comment_content":"Disruptor只是把加锁的过程前置到申请连续内存空间而已，并非无锁<br>","like_count":0},{"had_liked":false,"id":195747,"user_name":"thinker","can_delete":false,"product_type":"c1","uid":1107762,"ip_address":"","ucode":"1D9ECA03A28931","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/32/82939538.jpg","comment_is_top":false,"comment_ctime":1585214896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585214896","product_id":100017301,"comment_content":"1、无界队列：链表<br>2、有界队列：数组<br>无界队列需要设置队列大小，防止OOM","like_count":0},{"had_liked":false,"id":185789,"user_name":"孙思强","can_delete":false,"product_type":"c1","uid":1813790,"ip_address":"","ucode":"6E3F01DDFC1310","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ad/1e/aeb8d6f3.jpg","comment_is_top":false,"comment_ctime":1583678980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583678980","product_id":100017301,"comment_content":"首先在内存中生成1000个id 根据年月日时分秒最后再加三维数数字000-999供给获取，判断党内存中id个数小于100按上面的生成规则在生成1000个放入内存中，注意再去id的时候加个判断id剩余个数，进入生成id的那个方法需要枷锁控制。","like_count":0},{"had_liked":false,"id":172971,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1579400523,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1579400523","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":152887,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1574097480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574097480","product_id":100017301,"comment_content":"disruptor可以再详细点吗？感觉没过瘾","like_count":0},{"had_liked":false,"id":148520,"user_name":"庄小P","can_delete":false,"product_type":"c1","uid":1489063,"ip_address":"","ucode":"A71FA01F713790","user_header":"","comment_is_top":false,"comment_ctime":1573023916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573023916","product_id":100017301,"comment_content":"这个真的不是很能理解了，看完没啥感觉呀，没说清楚为什么申请了内存空间就不需要加锁？","like_count":0},{"had_liked":false,"id":144633,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1571986565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571986565","product_id":100017301,"comment_content":"Discruptor 还通过缓存行填充的黑科技，充分利用了CPU的高速缓存","like_count":0},{"had_liked":false,"id":138397,"user_name":"我的黄金时代","can_delete":false,"product_type":"c1","uid":1062070,"ip_address":"","ucode":"D7825B45B372F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","comment_is_top":false,"comment_ctime":1570196824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570196824","product_id":100017301,"comment_content":"这样处理后，消息的顺序怎么保证？","like_count":0},{"had_liked":false,"id":138332,"user_name":"JustDoDT","can_delete":false,"product_type":"c1","uid":1127175,"ip_address":"","ucode":"6AF0B80F00EAEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","comment_is_top":false,"comment_ctime":1570168724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570168724","product_id":100017301,"comment_content":"我的理解：disruptor是对一小部分区间加锁。","like_count":0},{"had_liked":false,"id":134164,"user_name":"Song╮承諾","can_delete":false,"product_type":"c1","uid":1590793,"ip_address":"","ucode":"50FDBFE5BDDD12","user_header":"https://static001.geekbang.org/account/avatar/00/18/46/09/c61257f6.jpg","comment_is_top":false,"comment_ctime":1568769278,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1568769278","product_id":100017301,"comment_content":"这不就是分布式锁","like_count":0},{"had_liked":false,"id":129108,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1567043560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567043560","product_id":100017301,"comment_content":"zmq的内存池机制和批量读取和写入跟这个队列机制很相似，都是提前申请内存。不过zmq只有一个读线程和一个写线程，通过一个读指针r和写指针w还有一个原子操作的指针c和刷新指针f来控制，写指针一直批量写，不用关心内存是否分配，底层来接管内存分配，读指针一直用CAS来检查状态，写指针写好了，修改下w和f和c，然后读线程检查到这些指针和状态的变更，刷的一下全读出来了，我想问的是Disruptor 应该还有类似内存池的机制吧","like_count":0},{"had_liked":false,"id":128777,"user_name":"AnonymousUser","can_delete":false,"product_type":"c1","uid":1243930,"ip_address":"","ucode":"E03CB1EDD9775B","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/1a/57480c9c.jpg","comment_is_top":false,"comment_ctime":1566961405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566961405","product_id":100017301,"comment_content":"如果多个读线程到处消费数据，那么写线程如何再到这个循环队列里面申请连续的内存块呢","like_count":0},{"had_liked":false,"id":121269,"user_name":"DY","can_delete":false,"product_type":"c1","uid":1459006,"ip_address":"","ucode":"55536A524A99B4","user_header":"https://static001.geekbang.org/account/avatar/00/16/43/3e/960d12cb.jpg","comment_is_top":false,"comment_ctime":1565091573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565091573","product_id":100017301,"comment_content":"Disruptor的限制应该比较多吧，队列应该是无序的，对于充值投资这样的应该处理不了","like_count":0},{"had_liked":false,"id":119665,"user_name":"track","can_delete":false,"product_type":"c1","uid":1018464,"ip_address":"","ucode":"1D5307F197A877","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/60/50f88b0a.jpg","comment_is_top":false,"comment_ctime":1564648717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564648717","product_id":100017301,"comment_content":"本质应该是吧每次操作都需要申请锁，改为了多次操作申请一次锁。减少了操作同一个空间的可能性","like_count":0},{"had_liked":false,"id":118770,"user_name":"小予","can_delete":false,"product_type":"c1","uid":1442580,"ip_address":"","ucode":"3F5EAEE1746074","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/14/e9ca2d09.jpg","comment_is_top":false,"comment_ctime":1564446630,"is_pvip":false,"replies":[{"id":"43663","content":"不用等的，可以直接读取后面的n个","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564529589,"ip_address":"","comment_id":118770,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564446630","product_id":100017301,"comment_content":"一个线程一次读取n个元素，那另外一个线程想要读取元素时，必须等前一个线程的n个元素读取完，本质上读取还是单线程的，不明白这样为何能提高性能，希望老师能解释一下其原理。🙏🙏","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460566,"discussion_content":"不用等的，可以直接读取后面的n个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564529589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100113,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1559446907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559446907","product_id":100017301,"comment_content":"思考题，ID生成器可以看做一个“生产者-消费者”模型的循环队列，与Disruptor的思路类似","like_count":0},{"had_liked":false,"id":94800,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1557899703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557899703","product_id":100017301,"comment_content":"感觉这个限流用的环形队列，又回到了上一节讲disrupter队列的问题一样，接口肯定是多线程，多个线程同时在往队列生产和消费，会出现生产和消费冲突，还是要解决这个问题……哈哈","like_count":0},{"had_liked":false,"id":85672,"user_name":"Geek_c33c8e","can_delete":false,"product_type":"c1","uid":1467234,"ip_address":"","ucode":"A5B70E0A346BDC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BpprxVMjsB0Ok4wGunDLHOLEI9wJX5HIEVsqs2EaXpuODfM7tuiaNfjPcxKWc60TwTaJnTuSicGMicib4r4um02qicQ/132","comment_is_top":false,"comment_ctime":1555169536,"is_pvip":false,"replies":[{"id":"30978","content":"这里讲的时候没涉及并发问题，实际上会有的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555372596,"ip_address":"","comment_id":85672,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555169536","product_id":100017301,"comment_content":"老师，线程池的实现是单个线程往队列插入任务，单个线程去队列去任务吗，所以不会处理并发控制吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446762,"discussion_content":"这里讲的时候没涉及并发问题，实际上会有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555372596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78626,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1553184840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553184840","product_id":100017301,"comment_content":"学storm的时候讲过里面的线程有个环形队列，以为这个课程会讲代码的实现，有点失望啊，是不是实现起来太麻烦了","like_count":0},{"had_liked":false,"id":77881,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1553011269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553011269","product_id":100017301,"comment_content":"循环队列，一个生产者和一个消费者也会有线程安全问题啊，在判断是否队列满了的时候，得去tail和head的值。而没有锁就不能保证取到新的值","like_count":0},{"had_liked":false,"id":67304,"user_name":"漫漫越","can_delete":false,"product_type":"c1","uid":1249222,"ip_address":"","ucode":"F9F1E3AC4CF692","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/c6/cf344f74.jpg","comment_is_top":false,"comment_ctime":1550127296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550127296","product_id":100017301,"comment_content":"尝试回答老师的问题<br>1.最简单的办法就是加锁，但这样就不支持并发。<br>2.将所有生成唯一Id的请求放入队列中，队列每次取出数据来产生Id，优点是不需要加锁。缺点是不支持并发。<br>老师有啥方法吗？求赐教","like_count":0},{"had_liked":false,"id":66755,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1550017160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550017160","product_id":100017301,"comment_content":"两阶段写入没有代码还是看不懂","like_count":0},{"had_liked":false,"id":66042,"user_name":"🐱您的好友William🐱","can_delete":false,"product_type":"c1","uid":1215456,"ip_address":"","ucode":"427786DB178965","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg","comment_is_top":false,"comment_ctime":1549857567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549857567","product_id":100017301,"comment_content":"不同步长的自增主键还是会重复的，应该是使用唯一ID生成器将生成好的ID放到Disruptor中，之后8个以加锁申请之后读取的方式获取相应的ID。","like_count":1},{"had_liked":false,"id":65247,"user_name":"Geek_477c02","can_delete":false,"product_type":"c1","uid":1218578,"ip_address":"","ucode":"CB9A714A50B977","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/12/a169bdcd.jpg","comment_is_top":false,"comment_ctime":1549160033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549160033","product_id":100017301,"comment_content":"这期讲的不清楚，申请连续的统一大小还是实际要插入的大小，如果是后者怎么知道线程要插入多少呢？如果是一个一个的插入，岂不是一样了么？","like_count":0},{"had_liked":false,"id":65009,"user_name":"Tattoo","can_delete":false,"product_type":"c1","uid":1036503,"ip_address":"","ucode":"CE926AC8582C96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/d7/a09ef784.jpg","comment_is_top":false,"comment_ctime":1549000444,"is_pvip":true,"replies":[{"id":"24301","content":"不是的。这里应该是线程消息队列。你指的消息队列是跨进程的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550542926,"ip_address":"","comment_id":65009,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549000444","product_id":100017301,"comment_content":"这就是面试中考的消息队列吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438271,"discussion_content":"不是的。这里应该是线程消息队列。你指的消息队列是跨进程的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64941,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1548982294,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1548982294","product_id":100017301,"comment_content":"一方面是批量，一方面是把读写操作从锁过程中分离，减小加锁时间。","like_count":0},{"had_liked":false,"id":64884,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1548939212,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1548939212","product_id":100017301,"comment_content":"每个生产者一次性批量申请队列中连续的空闲空间，每个消费者一次性批量申请队列中连续的数据，在批量申请前加锁以保证数据一致性。这样每个生产者和消费者都可以放心的并发工作，不用担心并发覆盖和重复。不过大量空间和数据被预先占用，造成空间浪费，这是典型的空间换时间吧？","like_count":0},{"had_liked":false,"id":64669,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1548852273,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1548852273","product_id":100017301,"comment_content":"我目前想到2种解决方案！<br>1，自己设计一个序列生成器，加入分段机制，每次申请的是一段序列，但申请需要加锁！可灵活实现，例如，线程一申请0-100独占，线程2申请就只能从101开始，比如是100个，就是101到201，序列当前值是共享的，所以要加锁，或者das<br>2，直接使用uuid","like_count":0,"discussions":[{"author":{"id":1015240,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg","nickname":"恬毅","note":"","ucode":"914ED16F3BE714","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558536,"discussion_content":"uuid对索引不够友好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648371306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64580,"user_name":"Yakmoz","can_delete":false,"product_type":"c1","uid":1257502,"ip_address":"","ucode":"1FA18A711457A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/1e/0b05530d.jpg","comment_is_top":false,"comment_ctime":1548828697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548828697","product_id":100017301,"comment_content":"像TDDL采用的也是类似的思想，由一个sequeue维护当前已用的最大ID，然后也是取一个ID区间自己缓存起来，用的是乐观锁控制并发。另外比起zookeeper来说etcd更适合生成全局唯一的ID，因为ZK只能保证最终一致性，etcd是强一致性，在性能上也要比ZK更好","like_count":1},{"had_liked":false,"id":64500,"user_name":"Keep-Moving","can_delete":false,"product_type":"c1","uid":1182631,"ip_address":"","ucode":"76F33C06E07A27","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","comment_is_top":false,"comment_ctime":1548813121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548813121","product_id":100017301,"comment_content":"“当申请到这组连续的存储单元之后，后续往队列中添加元素，就可以不用加锁了”，这句话不太理解，老师能不能再说得详细些？","like_count":0},{"had_liked":false,"id":64496,"user_name":"yann [扬] :曹同学","can_delete":false,"product_type":"c1","uid":1199315,"ip_address":"","ucode":"C449253263E796","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/d3/365fe5a1.jpg","comment_is_top":false,"comment_ctime":1548812618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548812618","product_id":100017301,"comment_content":"应该是读不需要锁，生成id时加锁，各个表的id去生成器上查一下有没有用过，不行，需要整理一下了","like_count":0}]}