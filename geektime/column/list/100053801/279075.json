{"id":279075,"title":"29 | 怎么给Canvas绘制加速？","content":"<p>你好，我是月影。</p><p>上节课，我们从宏观上了解了各个图形系统在性能方面的优劣，以及影响性能的要素。实际上，想要解决性能问题，我们就必须要知道真正消耗性能的点，从而结合项目需求进行有针对的处理，否则性能优化就是纸上谈兵、空中楼阁。</p><p>所以这节课，我们就深入讨论一下影响Canvas绘图性能的因素，一起来分析几个不同类型的Canvas项目，找到的性能瓶颈以及对应的解决办法，从而学会对大部分Canvas项目进行性能优化。</p><p>我们知道，Canvas是指令式绘图系统，它有状态设置指令、绘图指令以及真正的绘图方法（fill和stroke）等各类API。通常情况下利用Canvas绘图，我们要先调用状态设置指令设置绘图状态，然后用绘图指令决定要绘制的图形，最后调用真正的fill()或stroke()方法将内容输出到画布上。</p><p>那结合上节课的实验我们知道，影响Canvas性能的两大因素分别是图形的数量和图形的大小。它们都会直接影响绘图指令，一个决定了绘图指令的多少，另一个决定了绘图指令的执行时间。通常来说，绘图指令越多、执行时间越长，渲染效率就越低，性能也就越差。</p><p>因此，我们想要对Canvas性能进行优化，最重要的就是优化渲染效率。常用的手段有5种，分别是优化Canvas指令、使用缓存、分层渲染、局部重绘和优化滤镜。此外，还有一种手段叫做<strong>多线程渲染</strong>，是用来优化非渲染的计算和交互方面导致的性能问题。</p><!-- [[[read_end]]] --><p>首先，我们来说说优化Canvas指令。</p><h2>手段一：优化Canvas指令</h2><p>刚刚我们说了，Canvas执行的绘图指令越多，性能的消耗就越大。那如果希望Canvas绘图达到更好的性能，我们要尽可能减少绘图指令的数量。这就是“优化Canvas指令”要做的事情。</p><p>那具体怎么做呢？我们看一个例子。</p><p>假设，我们要在一个600 X 600的画布上，实现一些位置随机的多边形，并且不断刷新这些图形的形状和位置，效果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/4e/68/4e226d7385aa48c23049b451a4525468.gif?wh=482*472\" alt=\"\"></p><p>结合我们之前学过的知识，这个效果其实并不难实现，可以分为4步，分别是创建多边形的顶点，根据顶点绘制图形，生成随机多边形，执行绘制。</p><p>具体的实现代码如下：</p><pre><code>const canvas = document.querySelector('canvas');\nconst ctx = canvas.getContext('2d');\n\n// 创建正多边形，返回顶点\nfunction regularShape(x, y, r, edges = 3) {\n  const points = [];\n  const delta = 2 * Math.PI / edges;\n  for(let i = 0; i &lt; edges; i++) {\n    const theta = i * delta;\n    points.push([x + r * Math.sin(theta), y + r * Math.cos(theta)]);\n  }\n  return points;\n}\n\n// 根据顶点绘制图形\nfunction drawShape(context, points) {\n  context.fillStyle = 'red';\n  context.strokeStyle = 'black';\n  context.lineWidth = 2;\n  context.beginPath();\n  context.moveTo(...points[0]);\n  for(let i = 1; i &lt; points.length; i++) {\n    context.lineTo(...points[i]);\n  }\n  context.closePath();\n  context.stroke();\n  context.fill();\n}\n\n// 多边形类型，包括正三角形、正四边形、正五边形、正六边形和正100边形\nconst shapeTypes = [3, 4, 5, 6, 100];\nconst COUNT = 1000;\n\n// 执行绘制\nfunction draw() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  for(let i = 0; i &lt; COUNT; i++) {\n    const type = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];\n    const points = regularShape(Math.random() * canvas.width,\n      Math.random() * canvas.height, 10, type);\n    drawShape(ctx, points);\n  }\n  requestAnimationFrame(draw);\n}\n\ndraw();\n\n</code></pre><p>这个效果实现起来虽然不难，但性能却不是很好，因为它在我的Macbook Pro电脑上只有不到30fps的帧率。那问题出在哪呢？我们还是要回到代码中。</p><p>我们注意到drawShape函数里的for循环，它是根据顶点来绘制图形的，一个点对应一条绘图指令。而在我们绘制的随机图形里，有3、4、5、6边形和100边形。对于一个100边形来说，它的顶点数量非常多，所以Canvas需要执行的绘图指令也会非常多，那绘制很多个100边形自然会造成性能问题了。因此，如何减少绘制100边形的绘图指令的数量，才是我们要优化的重点。具体该怎么做呢？</p><p>我们知道，对于半径为10的小图形来说，正100边形已经完全是正圆形了，所以我们可以用arc指令来替代for循环。</p><p>我们修改shapeTypes和draw函数，用-1代替正100边形，然后判断type是否大于0，如果是就用之前的方式绘制正多边形，否则用arc指令来画圆。这么做了之后，整个效果的帧率就会从30fps提升到40fps，效果还是比较明显的。</p><pre><code>const shapeTypes = [3, 4, 5, 6, -1];\nconst COUNT = 1000;\nconst TAU = Math.PI * 2;\n\nfunction draw() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  for(let i = 0; i &lt; COUNT; i++) {\n    const type = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];\n    const x = Math.random() * canvas.width;\n    const y = Math.random() * canvas.height;\n    if(type &gt; 0) {\n      // 画正多边形\n      const points = regularShape(x, y, 10, type);\n      drawShape(ctx, points);\n    } else {\n      // 画圆\n      ctx.beginPath();\n      ctx.arc(x, y, 10, 0, TAU);\n      ctx.stroke();\n      ctx.fill();\n    }\n  }\n  requestAnimationFrame(draw);\n}\n</code></pre><p>到这里，你会发现，我们讲的其实是个特例，那在实际工作中，我们是需要针对特例来优化的。我希望我讲完今天的内容你能够做到举一反三。</p><h2>手段二：使用缓存</h2><p>在上面的方法中，我们优化了绘图指令，让渲染性能有了比较明显的提升。不过，因为这个绘图任务的图形数量和状态都是有限的，我们还有更好的优化方法，那就是<strong>使用缓存</strong>。</p><p>因为Canvas的性能瓶颈主要在绘图指令方面，如果我们能将图形缓存下来，保存到离屏的Canvas（offscreen Canvas）中，然后在绘制的时候作为图像来渲染，那我们就可以将绘制顶点的绘图指令变成直接通过drawImage指令来绘制图像，而且也不需要fill()方法来填充图形，这样性能就会有大幅度的提升。</p><p>具体的做法，是我们先实现一个创建缓存的函数。代码如下：</p><pre><code>function createCache() {\n  const ret = [];\n  for(let i = 0; i &lt; shapeTypes.length; i++) {\n    // 创建离屏Canvas缓存图形\n    const cacheCanvas = new OffscreenCanvas(20, 20);\n    // 将图形绘制到离屏Canvas对象上\n    const type = shapeTypes[i];\n    const context = cacheCanvas.getContext('2d');\n    context.fillStyle = 'red';\n    context.strokeStyle = 'black';\n    if(type &gt; 0) {\n      const points = regularShape(10, 10, 10, type);\n      drawShape(context, points);\n    } else {\n      context.beginPath();\n      context.arc(10, 10, 10, 0, TAU);\n      context.stroke();\n      context.fill();\n    }\n    ret.push(cacheCanvas);\n  }\n  // 将离屏Canvas数组（缓存对象）返回\n  return ret;\n}\n</code></pre><p>然后，我们一次性创建缓存，直接通过缓存来绘图。</p><pre><code>const shapes = createCache();\nconst COUNT = 1000;\n\nfunction draw() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  for(let i = 0; i &lt; COUNT; i++) {\n    const shape = shapes[Math.floor(Math.random() * shapeTypes.length)];\n    const x = Math.random() * canvas.width;\n    const y = Math.random() * canvas.height;\n    ctx.drawImage(shape, x, y);\n  }\n  requestAnimationFrame(draw);\n}\n</code></pre><p>这样，我们就通过缓存渲染，把原本数量非常多的绘图指令优化成了只有drawImage的一条指令，让渲染帧率达到了60fps，从而大大提升了性能。</p><h3>缓存的局限性</h3><p>不过，虽然使用缓存能够显著降低Canvas的性能消耗，但是缓存的使用也有局限性。</p><p>首先，因为缓存是通过创建离屏Canvas对象实现的，如果我们要绘制的图形状态（指不同形状、颜色等）非常多的话，那将它们都缓存起来，就需要创建大量的离屏Canvas对象。这本身对内存消耗就非常大，有可能反而降低了性能。</p><p>其次，缓存适用于图形状态本身不变的图形元素，如固定的几何图形，它们每次刷新只需要更新它的transform，这样的图形比较适合用缓存。如果是经常发生状态改变的图形元素，那么缓存就必须一直更新，缓存更新本身也是绘图过程。因此，这种情况下，采用缓存根本起不到减少绘图指令的作用，反而因为增加了一条drawImage指令产生了更大的开销。</p><p>第三，严格上来说，从缓存绘制和直接用绘图指令绘制还是有区别的，尤其是在fillText渲染文字或者我们绘制一个图形有较大缩放（scale）的时候。因为不使用缓存直接绘制的是矢量图，而通过缓存drawImage绘制出的则是位图，所以缓存绘制的图形，在清晰度上可能不是很好。</p><p>但是总体来说，缓存的应用还是非常多的，我们应该要掌握它的用法，学会在合适的时候运用缓存来提升Canvas的渲染性能。</p><h2>手段三：分层渲染</h2><p>前面两种手段是操作Canvas上所有元素来优化性能的，但有的时候，我们要绘制的元素很多，其中大部分元素状态是不变的，只有一小部分有变化。这个时候，我们又该如何进行优化呢？</p><p>我们知道，Canvas是将上一次绘制的内容擦除，然后绘制新的内容来实现状态变化的。利用这一特点，我们就可以将变化的元素和不变的元素进行分层处理。也就是说，我们可以用两个Canvas叠在一起，将不变的元素绘制在一个Canvas中，变化的元素绘制在另一个Canvas中。</p><p>我们还是来看一个例子。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/e9/4f0c60c3810d372d41ee14d90efb23e9.gif?wh=320*318\" alt=\"\"></p><p>假设，我们要实现一个如上图的效果。这个效果的特点是，画面上有一个飞机在运动，运动的物体比较少，而其他静止不动的图形很多（如背景中的上千个三角形）。</p><p>在绘制的时候，我们如果将运动的物体和其他物体都绘制在同一个Canvas画布中，要改变飞机的运动状态，我们就要重新绘制所有的物体，这会非常浪费性能。因此，更好的做法是我们使用两层画布，一层Canvas作为背景，来绘制静态的图形，就是这个例子里的上千个小三角形，而另一层Canvas作为前景，用来绘制运动的物体就是运动的飞机。</p><p>这样的话，我们只需要一次绘制就能得到背景层Canvas，并且不管飞机的状态怎么改变，我们都不需要重绘，而前景的飞机可以每一帧重绘，也就大大减少了图形绘制的数量，并且提升了性能。</p><p>下面我列出具体的代码，虽然很长但逻辑并不复杂，核心就是用两个Canvas元素来分别绘制，你可以看一下。</p><pre><code>function drawRandomTriangle(path, context) {\n  const {width, height} = context.canvas;\n  context.save();\n  context.translate(Math.random() * width, Math.random() * height);\n  context.fill(path);\n  context.restore();\n}\n\nfunction drawBackground(context, count = 2000) {\n  context.fillStyle = '#ed7';\n  const d = 'M0,0L0,10L8.66, 5z';\n  const p = new Path2D(d);\n  for(let i = 0; i &lt; count; i++) {\n    drawRandomTriangle(p, context);\n  }\n}\n\nfunction loadImage(src) {\n  const img = new Image();\n  img.crossOrigin = 'anonymous';\n  return new Promise((resolve) =&gt; {\n    img.onload = resolve(img);\n    img.src = src;\n  });\n}\n\nasync function drawForeground(context) {\n  const img = await loadImage('http://p3.qhimg.com/t015b85b72445154fe0.png');\n  const {width, height} = context.canvas;\n  function update(t) {\n    context.clearRect(0, 0, width, height);\n    context.save();\n    context.translate(0, 0.5 * height);\n    const p = (t % 3000) / 3000;\n    const x = width * p;\n    const y = 0.1 * height * Math.sin(3 * Math.PI * p);\n    context.drawImage(img, x, y);\n    context.restore();\n    requestAnimationFrame(update);\n  }\n  update(0);\n}\n\nconst bgcanvas = document.querySelector('#bg');\nconst fgcanvas = document.querySelector('#fg');\ndrawBackground(bgcanvas.getContext('2d'));\ndrawForeground(fgcanvas.getContext('2d'));\n</code></pre><h2>手段四：局部重绘</h2><p>但是，我们用分层渲染解决性能问题的时候，所绘制的图形必须满足两个条件：一是有大量静态的图形元素不需要重新绘制，二是动态和静态图形元素绘制顺序是固定的，先绘制完静态元素再绘制动态元素。如果元素都有可能运动，或者动态元素和静态元素的绘制顺序是交错的，比如先绘制几个静态元素，再绘制几个动态元素，然后再绘制静态元素，这样交替进行，那么分层渲染就不好实现了。这时候，我们还有另外一种优化手段，它叫做局部重绘。</p><p><strong>局部重绘顾名思义，就是不需要清空Canvas的全局区域，而是根据运动的元素的范围来清空部分区域。</strong>在很大一部分可视化大屏项目中，我们不会让整个屏幕的所有元素都不断改变，而是只有一些固定的区域改变，所以我们直接刷新那部分区域，重绘区域中的元素就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/16/ff209e67ac077c1c43782e0291500e16.jpeg?wh=1920*1080\" alt=\"\" title=\"大屏的动态区与静态区\"></p><p>如上图所示，一个可视化大屏只有2块动态区域需要不断重绘，那我们用Canvas上下文的<strong>clearRect方法控制要刷新的动态区域</strong>，只对这些区域进行擦除然后重绘。</p><p>要注意的是，动态区重绘的时候，区域内的静态元素也需要跟着重绘。如果有静态元素跨越了动态和静态区域范围，那在重绘时，我们自然不希望破坏了静态区的图形。这时候，我们可以使用Canvas上下文的clip方法，它是一种特殊的绘图指令，可以设定一个绘图区，让图形的绘制限制在这个绘图区内部。这样的话，图形中超过clip范围的部分，浏览器就不会把它渲染到Canvas上。</p><p>这种固定区域的局部重绘使用起来不难，但有时候我们不知道具体的动态区域究竟多大。这个时候，我们可以使用动态计算要重绘区域的技术，它也被称为<strong>脏区检测</strong>。它的基本原理是根据动态元素的<strong>包围盒</strong>，动态算出需要重绘的范围。</p><p>那什么是包围盒呢？</p><p>我们知道，多边形由顶点构成，包围盒就是指能包含多边形所有顶点，并且与坐标轴平行的最小矩形。</p><p><a href=\"https://www.pngsucai.com/png/950314.html\"><img src=\"https://static001.geekbang.org/resource/image/f2/55/f26c205843dc9479c9ce9ebd7d762855.jpeg?wh=1920*1080\" alt=\"\" title=\"多边形包围盒\"></a></p><p>在Canvas平面直角坐标系下，求包围盒并不复杂，只要分别找到所有顶点坐标中x的最大、最小值xmin和xmax，以及y的最大、最小值ymin和ymax，那么包围盒就是矩形[(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]。</p><p>对所有的动态元素计算出包围盒，我们就能知道局部刷新的范围了。不过在实际操作的时候，我们经常会遇到各种复杂的细节问题需要解决。因为涉及的细节比较多，我没法全都讲到，所以，如果你遇到了问题，可以看看蚂蚁金服AntV团队的<a href=\"https://juejin.im/post/5e7c13b351882535ea43e1a2\">Canvas局部渲染优化总结</a>这篇文章。</p><h2>手段五：优化滤镜</h2><p>实际上，分层渲染和局部重绘解决的都是图形重绘的问题。那除了重绘，影响渲染效率的还有Canvas滤镜。</p><p>我们知道，滤镜是一种对图形像素进行处理的方法，Canvas支持许多常用的滤镜。不过Canvas渲染滤镜的性能开销比较大。到底有多大呢？我们还是用前面绘制随机图形的例子来体验一下。</p><p>这次我们用缓存优化版本的代码，这一版代码的性能最高。在绘制前，我们给Canvas设置一个blur滤镜。代码如下：</p><pre><code>ctx.filter = 'blur(5px)';\n</code></pre><p>这样呢，我们让Canvas绘制出来的图形有了模糊的效果。但是这么设置了之后，你会发现原本60fps的帧率直接掉到2fps，画面看上去一顿一顿的，卡得惨不忍睹。这就是因为滤镜对渲染性能的开销实在太大了。</p><p><img src=\"https://static001.geekbang.org/resource/image/1f/7b/1f236cbdb1eb16a3faf9f7e6c18fa27b.gif?wh=480*478\" alt=\"\"></p><p>那这种情况下，其实我们也有优化手段。针对这个场，我们实际上是对Canvas应用一个全局的blur滤镜，把绘制的所有元素都变得模糊，所以，我们完全没必要对每个元素应用滤镜，而是可以采用类似后期处理通道的做法，先将图形以不使用滤镜的方式绘制到一个离屏的Canvas上，然后直接将这个离屏Canvas以图片方式绘制到要显示的画布上，在这次绘制的时候采用滤镜。这样，我们就把大量滤镜绘制的过程缩减为对一张图片使用一次滤镜了。大大减少了处理滤镜的次数之后，效果立竿见影，帧率立即回到了60fps。</p><p>那么具体实现的代码和效果我也列出来，你可以看一下。</p><pre><code>ctx.filter = 'blur(5px)';\n\n// 创建离屏的 Canvas\nconst ofc = new OffscreenCanvas(canvas.width, canvas.height);\nconst octx = ofc.getContext('2d');\nfunction draw() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  octx.clearRect(0, 0, canvas.width, canvas.height);\n  // 将图形不应用滤镜，绘制到离屏Canvas上\n  for(let i = 0; i &lt; COUNT; i++) {\n    const shape = shapes[Math.floor(Math.random() * shapeTypes.length)];\n    const x = Math.random() * canvas.width;\n    const y = Math.random() * canvas.height;\n    octx.drawImage(shape, x, y);\n  }\n  // 再将离屏Canvas图像绘制到画布上，这一次绘制采用了滤镜\n  ctx.drawImage(ofc, 0, 0);\n  requestAnimationFrame(draw);\n}\n\ndraw();\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/63/5b/63dcf4f363561cb745yy7075b418985b.gif?wh=480*478\" alt=\"\"></p><p>当然这种优化滤镜的方式，只有当我们要对画布上绘制的所有图形，都采用同一种滤镜的时候才有效。不过，如果有部分图形采用相同的滤镜，而且它们是连续绘制的，我们也可以采用类似的办法，把这部分图形绘制到离屏Canvas上，之后再将图像应用滤镜并绘制回画布。这样也能够减少滤镜的处理次数，明显提升性能。总之，想要达到比较好的性能，我们要记住一个原则，尽量合并图形应用相同滤镜的过程。</p><h2>手段六：多线程渲染</h2><p>到这里，我们说完了几种提升渲染性能的常见手段。不过，影响用户体验的不仅仅是渲染性能，有时候，我们还要对绘制的内容进行交互，而如果渲染过程消耗了大量的时间，它也可能会阻塞其他的操作，比如对事件的响应。</p><p>遇到这种问题的时候，以前我们会比较头疼，甚至不得不降低渲染性能，以减少CPU资源占用，从而让交互行为不被阻塞。不过现在，浏览器支持的Canvas可以在WebWorker中以单独的线程来渲染，这样就可以避免对主线程的阻塞，也不会影响用户交互行为了。</p><p>那么具体怎么才能在Worker中绘制呢？其实也很简单。我们在浏览器主线程中创建Worker，然后将Canvas对象通过 transferControlToOffscreen 转成离屏Canvas对象发送给Worker线程去处理。</p><pre><code>const canvas = document.querySelector('canvas');\n\nconst worker = new Worker('./random_shapes_worker.js');\nconst ofc = canvas.transferControlToOffscreen();\nworker.postMessage({\n  canvas: ofc,\n  type: 'init',\n}, [ofc]);\n</code></pre><p>这样，从使用上来说，无论在Worker线程中还是在主线程中操作都没有太大的区别，还能不阻塞浏览器主线程的任何操作。</p><p>我这里列出一部分核心代码，完整的代码我放在GitHub仓库里，你可以试着运行一下，看看效果。</p><pre><code>function draw(ctx, shapes) {\n  const canvas = ctx.canvas;\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  for(let i = 0; i &lt; COUNT; i++) {\n    const shape = shapes[Math.floor(Math.random() * shapeTypes.length)];\n    const x = Math.random() * canvas.width;\n    const y = Math.random() * canvas.height;\n    ctx.drawImage(shape, x, y);\n  }\n  requestAnimationFrame(draw.bind(null, ctx, shapes));\n}\n\nself.addEventListener('message', (evt) =&gt; {\n  if(evt.data.type === 'init') {\n    const canvas = evt.data.canvas;\n    if(canvas) {\n      const ctx = canvas.getContext('2d');\n      const shapes = createCache();\n      draw(ctx, shapes);\n    }\n  }\n});\n</code></pre><h2>要点总结</h2><p>这节课我们讲了Canvas性能优化的6种手段，其中前5种是针对渲染效率进行优化，分别是优化Canvas指令、使用缓存、分层渲染、局部重绘，以及针对滤镜的优化。最后一种是通过多线程来优化计算的性能，让计算过程能够并行执行不会阻塞浏览器的UI。下面，我再带你一起梳理一下性能优化的原则。</p><p>首先，我们在绘制图形时，用越简单的绘图指令来绘制，渲染的效率就越高。所以，我们要想办法减少Canvas绘图指令的数量，比如，用arc指令画圆来代替绘制边数很多的正多边形。</p><p>然后，当我们大批量绘制有限的几种形状的图形时，可以采用缓存将图形一次绘制后保存在离屏的Canvas中，下一次绘制的时候，我们直接绘制缓存的图片来取代原始的绘图指令，也能大大提升性能。</p><p>可如果我们绘制的元素中只有一部分元素发生改变，我们就可以采用分层渲染，将变化的元素绘制在一个图层，剩下的元素绘制在另一个图层。这样每次只需要重新绘制变化元素所在的图层，大大减少绘制的图形数，从而显著提升了性能。</p><p>还有一种情况是，如果Canvas只有部分区域发生变化，那我们只需要刷新局部区域，不需要刷新整个Canvas，这样能显著降低消耗、提升性能。</p><p>还要注意的是，一些Canvas滤镜渲染起来非常耗费性能，所以我们可以对滤镜进行合并，让多个元素只应用一次滤镜，从而减少滤镜对性能的消耗。</p><p>最后，除了优化渲染性能外，我们还可以通过WebWork以多线程的手段优化计算性能，以达到渲染不阻塞UI操作的目的。</p><h2>小试牛刀</h2><p>学会了使用多种优化手段之后，我们来尝试实现一个粒子效果吧！</p><p>具体效果是，我们要让小三角形以不同的角度和速度，由画布中心点向四周运动，同时小三角形自身也以随机的角速度旋转。</p><p>你可以尝试用两种方式来实现这个效果，分别是使用性能优化和不使用性能优化。在这两种情况下，你的电脑最多能支持同时绘制多少个小三角形？</p><p>我们今天学的这6种性能优化手段，对你的工作是不是很有帮助？那不妨就把这节课分享出去吧！我们下节课再见！</p><hr><h2><span class=\"reference\">源码</span></h2><p><span class=\"reference\"><a href=\"https://github.com/akira-cn/graphics/tree/master/performance_canvas\">课程中详细示例代码GitHub仓库</a></span></p><h2><span class=\"reference\">推荐阅读</span></h2><p><span class=\"reference\">[1] <a href=\"https://juejin.im/post/5e7c13b351882535ea43e1a2\">AntV Canvas 局部渲染总结</a></span><br>\n<span class=\"reference\">[2] <a href=\"https://developers.google.com/web/updates/2018/08/offscreen-canvas\">Speed up Your Canvas Operations with a Web Worker，WebWorker和OffscreenCanvas使用参考文档</a></span></p>","comments":[{"had_liked":false,"id":256489,"user_name":"嗨小二","can_delete":false,"product_type":"c1","uid":1625394,"ip_address":"","ucode":"7280B0A8718B3D","user_header":"https://static001.geekbang.org/account/avatar/00/18/cd/32/ef42b1c1.jpg","comment_is_top":false,"comment_ctime":1603637070,"is_pvip":false,"replies":[{"id":"94953","content":"你可以试一下，现代浏览器的Canvas绘制的图放大不会失真了，当然这里不是放大网页本身，而是在Canvas中放大Path2D绘制的图形。","user_name":"作者回复","comment_id":256489,"uid":"1159792","ip_address":"","utype":1,"ctime":1605492620,"user_name_real":"月影"}],"discussion_count":1,"race_medal":0,"score":"14488538958","product_id":100053801,"comment_content":"“因为不使用缓存直接绘制的是矢量图，而通过缓存 drawImage 绘制出的则是位图“，我怎么记得canvas绘制的都是位图，因为使用canvas绘制图形，放大后就会失真，为什么这里会说”不使用缓存直接绘制的是矢量图“，麻烦解释下","like_count":4,"discussions":[{"author":{"id":1159792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b2/70/ba9cecc6.jpg","nickname":"月影","note":"","ucode":"298582FA7DBF27","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508028,"discussion_content":"你可以试一下，现代浏览器的Canvas绘制的图放大不会失真了，当然这里不是放大网页本身，而是在Canvas中放大Path2D绘制的图形。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605492620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244583,"user_name":"Mingzhang","can_delete":false,"product_type":"c1","uid":1332515,"ip_address":"","ucode":"072E18F1458634","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLqNxFYmldFiaT0180Po2TEbPuB3l0uZIqKb9sPWO97XicgDlaSIbkggq9yXv1vd1l7DXR4BjuqN76w/132","comment_is_top":false,"comment_ctime":1598585706,"is_pvip":false,"replies":[{"id":"94998","content":"可以的","user_name":"作者回复","comment_id":244583,"uid":"1159792","ip_address":"","utype":1,"ctime":1605515544,"user_name_real":"月影"}],"discussion_count":2,"race_medal":0,"score":"14483487594","product_id":100053801,"comment_content":"在屏幕上显示主 Canvas，利用 transferControlToOffscreen 将绘制交由 offScreen canvas 来绘制，而主 Canvas 负责监测鼠标在其上的 move 事件，然后将 event 的坐标 postMessage 给 Web Worker。请问月影这种方法可行吗？","like_count":4,"discussions":[{"author":{"id":1159792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b2/70/ba9cecc6.jpg","nickname":"月影","note":"","ucode":"298582FA7DBF27","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504627,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605515544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1159802,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b2/7a/d7c26cf2.jpg","nickname":"李冬杰","note":"","ucode":"720BB5D36D28E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301984,"discussion_content":"������你离这个答案只差个demo了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598749973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}